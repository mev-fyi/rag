00:08:16.960 - 00:08:42.520, Speaker A: Hey, Alex. Hello, guys. Hello. Hey, Alex. Nice that you could join us for a second today. I know it's holidays over there.
00:08:51.810 - 00:08:58.080, Speaker B: Not seeing what I'm expecting on the UI. It looks like it's already live, right?
00:08:58.530 - 00:09:16.260, Speaker A: We are already live on YouTube. Yeah, everybody. We're already streaming on the YouTube, so no additional movement is required. Okay. You would need to make me the host right now. Okay.
00:09:22.810 - 00:09:23.654, Speaker C: Guys.
00:09:23.852 - 00:09:42.480, Speaker A: Hey, friend. Hey, friend. Second. Yeah, I see. Good. So now I can share the screen. Have a good.
00:09:42.480 - 00:10:51.910, Speaker A: Thanks, Alexand. Talk to you Monday. Okay, so let's wait a little bit. We have everybody, I will share the discussions, we have the agenda, but we need to wait for Ilya to join and maybe Eugen is not joining this early. In any case, you can all get the link in front of you and I'll put it in the YouTube chat as well in case we have people watching. Let me hand up the rest of the people and then we can start. I'll stop the share for now.
00:10:51.910 - 00:11:48.590, Speaker A: Hi, Bo. Nice to have you with us as well.
00:11:51.460 - 00:11:52.640, Speaker C: Hi Alto.
00:11:55.220 - 00:12:00.928, Speaker A: Will you be joining us still every week or just hopping in today?
00:12:01.094 - 00:12:11.540, Speaker C: Probably not every week. If I have done something that week, I will join. Otherwise, like if I didn't do anything that week, I will skip.
00:12:11.960 - 00:12:19.560, Speaker A: Okay, while we have you, would you have some time next Monday to join our OKR review?
00:12:19.710 - 00:12:20.728, Speaker C: Yeah, sure.
00:12:20.894 - 00:12:24.650, Speaker A: Great. Did you get the calendar entry Alex sent for that?
00:12:26.480 - 00:12:27.788, Speaker C: I think so.
00:12:27.954 - 00:12:49.570, Speaker A: Okay. I think there's two meetings on Monday about okrs. One might be too early for you, but if you join the team sync, that should be a reasonable time. 09:00 your time. Okay. Hi, Liam. So I think we have everybody and we can get it going.
00:12:49.570 - 00:13:40.690, Speaker A: So yes, we are already live on YouTube and hello everybody. This is the EVM working group's weekly public sync, and this is the first one. Now in three weeks after the holidays, let me share my screen here and you can find our discussions in the Nearcore repository. We keep the meeting agenda and the meeting notes there, and we have the YouTube link there as well, in case somebody wants to share it to others. So the agenda for today I suggest is the following. Let's discuss the current goal, especially good after the long holidays, and do the weekly updates fairly quickly. I don't think anybody has anything significant to report.
00:13:40.690 - 00:14:16.990, Speaker A: And then let's talk about what we're going to do in the next few weeks, including importantly, there's been some good work from Ilya on raw Ethereum transaction relay support. We have a big discussion about the native EVM token that we need to move along. I'd prefer to have Alexiochenko with us on that discussion, but we can discuss a little bit today, and I know Mike is working on a blog post he would like to get out. So does anybody have anything to add to the agenda today?
00:14:20.100 - 00:14:28.128, Speaker D: I guess I would be curious to hear what's the status of the meta transaction really as well.
00:14:28.294 - 00:14:59.180, Speaker A: Okay, let's add that here's. Okay, good. So let's get going. The current goal of our development is towards the phase two, which is the testnet delivery. And we. Hold on, I'm missing something here. My notes.
00:14:59.180 - 00:16:17.540, Speaker A: Yeah, and the agenda for the next couple of weeks is to align all the stakeholders internally and with input from external stakeholders, potential stakeholders, on how our architecture should look for an EVM. We still have some questions in that regard, the perhaps most significant one being the question about native EVM token. Which, which token should we be using? Should we be using the new token inside our Ethereum runtime? Or should it be perhaps some form of f bridged or wrapped over from f one? So that's a big discussion, but let's touch on it a little bit today. There are other questions that Ilya and Alex and I have been discussing over the holidays. Some of those concern the long term outlook. How would we unify contract storage so that we don't have a separate mechanism inside the EVM and the native runtime? Ilya, what was your preferred term for the native runtime? Was it base runtime?
00:16:17.880 - 00:16:19.044, Speaker D: Yeah, base.
00:16:19.242 - 00:17:08.016, Speaker A: Okay. Okay, I'll call it that. So right now, contract storage is entirely separated between the two and the EVM is like a black box. And we should maybe open up this box a little bit going forward. There's also questions about the account model and ultimately what level of visibility Ethereum use should be afforded in terms of our wallet interfaces and the like. So we can come back to those things later. So for the weekly update, Alex is out of the office, given the holidays, orthodox holidays, but I'll give you this update.
00:17:08.016 - 00:18:11.930, Speaker A: So as I mentioned with Ilyanmi, he's been working on sketching out a lot of the user scenarios, use cases for the EVM. He's working on diagramming everything in terms of the system architecture and the user stories, and he'll have something to present next week. And he started this discussion on the forum this week on the native token. He's also set up for next week. He set up bridge EVM team cross sync call because we have a lot of questions that concern both teams. I think that's sometime later Monday on my end, I've been doing the aforementioned with Alex and Ilya, and I've been onboarding myself. After discussions with Eugen and Max, I've agreed to take on as EVM team lead.
00:18:11.930 - 00:18:37.010, Speaker A: And that means that Eugen can focus more on the runtime matters. He was being stretched in too many directions. And so I've been going through a lot of onboarding this week with Max and Arus. And other than that, mostly the week has been reviewing pull requests. A whole bunch of them. Bo.
00:18:39.380 - 00:18:50.740, Speaker C: Yeah, I'm mostly just addressing comments from Eugene and adding comments in the meta transaction, passing.
00:18:52.440 - 00:19:03.480, Speaker A: Yeah, I saw the updates to the pull requests and we merged that pull request, I believe. So all of your work in that regard is now in Master.
00:19:09.680 - 00:19:10.700, Speaker C: Eugene.
00:19:11.760 - 00:19:14.968, Speaker A: We don't have him today. I think it's a little early in San Francisco.
00:19:15.144 - 00:19:16.830, Speaker C: No, I finally.
00:19:18.000 - 00:19:24.560, Speaker A: Ah, okay. Hello. Go ahead, Eugene.
00:19:25.140 - 00:19:32.150, Speaker C: Yeah, I basically just reviewed a bunch of PRS, but that's it. Didn't spend as much time.
00:19:32.920 - 00:20:04.940, Speaker A: Yeah, and I noticed you posted also on the forum in the native token discussion. Okay, so it's good we have you since we're going to discuss that a little bit. I know Frank had personal matters this week, so nothing to report. I believe that's correct, yeah. Okay, so resume next week on that, Ilya, would you like to a little bit speak about the work you did on the raw transaction?
00:20:08.160 - 00:21:09.676, Speaker D: I mean, high level, pretty much been testing out a little bit how to deploy some contracts. And so some of the contract deployment uses hd wallet on the truffle side, for example, for a predictable key, pretty much for signing transactions as a specific key. So instead of generating new one. So that kind of span out into that, we need to handle already signed transactions. So we have this RPC proxy that is pretty much just runs web3 provider and takes all the JSON requests and just calls RPC provider with them. And so we did not have RPC provider handling that. So I added handling for that there, which required actually adding in your core ability to process a kind of completely signed Ethereum transaction.
00:21:09.676 - 00:21:28.616, Speaker D: It works pretty much the same way as metacol. So it's a signed transaction, ethereum transaction from signature, you can infer the signer the address, who signed it, and then we have who it's targeted to, what data was and how much value was.
00:21:28.638 - 00:21:31.656, Speaker A: Assigned, and the chain id as well, right? Yeah.
00:21:31.678 - 00:21:45.084, Speaker D: And so chain id comes from a signature as well. Actually, one caveat is that ethereum does not require chain id to be there.
00:21:45.122 - 00:21:45.276, Speaker A: Right.
00:21:45.298 - 00:22:14.464, Speaker D: So chain id is there only in some transactions, pr is there. I'm still testing some things, but so far it works. I have deployed that actual contract into betanet where it started from. This is both prs to the neocore and to webc provider.
00:22:14.592 - 00:22:34.110, Speaker A: Right. I've reviewed both. This one I had to rebase yesterday, it was a difficult rebase because we had the EVM phase two branch, so that bit us in the ass on that one. But I believe I've correctly rebased it and it does build. So if you have a chance, you can check.
00:22:34.480 - 00:22:43.740, Speaker D: Yeah, and I also saw you had like a couple of comments, so I'm going to address them and if everything else looks correct, we can submit.
00:22:43.900 - 00:22:52.790, Speaker A: Yeah, I think it's good to merge even as is because this comment is about something that was already preexisting in the code. It's not about your pr.
00:22:54.920 - 00:23:01.860, Speaker D: I actually already fix this. I just need to write a test that actually tests this. Okay. I can split it into separate pr.
00:23:01.930 - 00:23:13.640, Speaker A: That's fine. Okay. Yeah, I would just go ahead and merge this. My only question was, did you want specifically somebody else's review on this as well before we put it in master?
00:23:15.180 - 00:23:22.476, Speaker D: Well, if somebody wants to take a look, but.
00:23:22.498 - 00:23:27.740, Speaker A: Okay. You were not waiting on anybody else in that case? No, we'll merge it after the meeting.
00:23:28.720 - 00:23:37.916, Speaker C: I can take a look if there's any changes, that kind of protocol bump or anything that misses.
00:23:38.108 - 00:23:43.810, Speaker A: Okay, go ahead.
00:23:45.860 - 00:23:57.450, Speaker D: This dough I think requires a hard work. So actually the question is like, yeah, when are we going to hard fork betanet with new version do we have.
00:23:57.900 - 00:24:08.860, Speaker C: Okay, so basically if you bumped a version of EVM feature, then it will hard fork betternet, I guess.
00:24:08.930 - 00:24:09.596, Speaker D: Got it.
00:24:09.698 - 00:24:12.590, Speaker C: If it's still a manual process, then pink send it.
00:24:16.000 - 00:24:25.552, Speaker A: In other words, you generally you both saying we should deploy it to betternet as soon as possible, which would be of course helpful for Mike's blog post.
00:24:25.606 - 00:24:37.860, Speaker C: And the if we, if you merge anything to master, then betternet should be like next day automatically updated once you have the pipeline.
00:24:41.400 - 00:24:45.210, Speaker A: All right. Anything else, Ilia, from you?
00:24:45.580 - 00:24:46.664, Speaker D: No, that's all.
00:24:46.782 - 00:24:48.440, Speaker A: Okay, Mike.
00:24:49.820 - 00:26:08.496, Speaker B: Yeah, so it's mostly been covering as much as basically everything that I understand about how people can use the EVM I'm putting into. The majority is now in documentation and in separate sections. I think there's like seven or eight different sections about testing how to use truffle, how to use web3 provider, how to do the most basic simple script, how near CLI can interact with it, and then the blog post highlights these different sections and kind of gives like a teaser and just gives an update on where things are at, because I think our last blog post was from almost a year ago, and then also had been talking a little bit to, I guess, the infrastructure team. I think that we don't have the same kind of alerts going on, and so there were some timeouts on Betanet, I think, because it wasn't as important until recently. So we're getting those in tip top shape so that when we sort of invite the community to start using the EVM on Betanet, things will work as expected. I think that is the final push for me. I'm still kind of wrapping my head around what the RPC proxy means in terms of priorities and where it's at.
00:26:08.496 - 00:26:26.136, Speaker B: And should we be targeting hard hat, for instance, or should we just kind of be expecting that? People can point most things to the RPC proxy, although I see there's a lot of routes that are not done yet. So I'm kind of learning about that and how to advise folks who want.
00:26:26.158 - 00:27:23.690, Speaker A: To start using this. Yeah, those are good questions, and I guess we can segue into the discussion from that. I think it's great we have a provider we can use both in the RPC proxy as well as people can pull it into their front end code. So that's a good job on that. Actually, one thing we didn't have on the agenda, but should be here, Ilya had expressed a desire to merge the RPC proxy and the relayer code bases. So this is something we should probably discuss. But okay, first, let me note that I already mentioned that team organization changing a little bit, so it's nice to have Bo here, but Bo is pulled away.
00:27:23.690 - 00:27:31.100, Speaker A: Mike, do you know already how you will be pulled away? To which extent?
00:27:31.520 - 00:27:36.190, Speaker B: I think I'll know more after we have okrs for Barry Picker's team.
00:27:36.880 - 00:27:38.190, Speaker A: When will that be?
00:27:38.640 - 00:27:41.570, Speaker B: Within the next week, I believe.
00:27:41.940 - 00:27:42.592, Speaker A: Okay.
00:27:42.726 - 00:27:50.048, Speaker B: I don't have strong feelings that I am immediately pulled off EVM. I think this is a pretty big priority, especially right now.
00:27:50.214 - 00:28:54.596, Speaker A: Okay. Given that we're defining the EVM OKrs on Monday, if there's any input you would have, that would be already very good. And other than that, the team organization is well understaffed at the moment, which means that there's pretty active recruitment going on. And I would also encourage everybody to think of any friends, colleagues, former colleagues that they know about who we might approach and send all of that in my direction. I will screen them ASAP and we will get Max on the case if we would like to proceed so very active recruitment efforts in January, given that we have something we want to ship this quarter. Okay, so I'll talk to you guys one on one on other questions about the team organization. Let's go to the discussion.
00:28:54.596 - 00:29:03.480, Speaker A: So, Ilya, how did you see the merge of the proxy and relayer code bases? Which one should we merge to? Which repository?
00:29:05.580 - 00:29:22.960, Speaker D: Proxy is already behaving as a relayer, right? Because it has a signer in it and it is able to sign transactions. So I think we should just merge in, like add kind of another URL for the relayer into the proxy.
00:29:24.020 - 00:29:25.170, Speaker A: That makes sense.
00:29:31.940 - 00:29:46.788, Speaker D: Mike, you were asking the kind of the scope of proxy right now. So right now, proxy does everything and will continue doing everything that web3 provider does. So all the routes that are not implemented is the routes that not implemented in a three provider in the first place.
00:29:46.954 - 00:29:47.670, Speaker A: Right.
00:29:48.300 - 00:30:28.950, Speaker D: And the missing pieces in the proxy are mostly around actual key management. Right. Like making sure that you can start it in kind of read only mode or you can start it in like in a, you know, in the, like right now pretty much. It's kind of a debug mode, right, where it will sign whatever you give it, which is obviously not always good. So this is where we should have this logic of relaying logic kind of there which allows to calculate if you want to relay this or not. So be able to configure a proxy with that.
00:30:29.640 - 00:30:48.190, Speaker A: Okay. Meanwhile, while we were talking, I made a bit of, oops, wrong keystroke, and lost the notes. I'll have to reconstruct them from the video in any case. Okay, so that's clear. And are you planning to do that yourself or should I go ahead and do that?
00:30:49.280 - 00:31:02.830, Speaker D: I can take a look as I'm kind of looking through this, I guess, if you guys can talk me through and kind of update on what's Metatx relay status I know you guys been working on.
00:31:03.360 - 00:31:13.232, Speaker A: So, Mike, Mike, can you talk on that? I also talked with you earlier about potentially making a screencast on that. Did you have a chance to do that? Definitely.
00:31:13.286 - 00:32:15.930, Speaker B: No, I still owe you that screencast. So the state of affairs on the meta transactions on that are kind of the same as they've been for a while, which is bare bones in terms of you can pop up metamask, do assigned typed message EIP 712, and then send that to kind of the old version of the relayer. And that could basically say, here's the message, here's the signature, we can recover this, that was it? And then at that point, I think I was not quite sure how to put that into the actual near core, or what to send and how to package the bytes. So nothing has really changed along that. And it seems like just the EIP 712 kind of logic, which is essentially just importing some libraries, is all that we would really need to add to the RPC proxy. That was really the only offering that the RPC proxy doesn't have that the old relayer does, I believe.
00:32:16.940 - 00:32:49.170, Speaker A: Okay, well, I was also getting set up with the full flow for the meta transactions a few weeks back, but I run into some trouble. I didn't have a chance to redo the flow ilya yet, so I don't remember what the problem was. I will try to do that soonest. Is there anything else that you would want to ask on that front from Mike while we have him on the call?
00:32:50.740 - 00:33:38.050, Speaker D: Well, I think one side was, if you thought through the flow on how front end would be pulling for how front end would be checking with the relayer, like what price would relayer pretty much be okay with? Because I think for this, like rock holes, it also needs that, because pretty much the rock hole, it has a gas price and gas amount. But this is really like, it's not near gas price gas, at least right now. But the plan is to deduct that from this user's balance and put it to relayer's balance. So relayer needs to approve that it's okay with being paid this much.
00:33:39.780 - 00:34:21.340, Speaker A: Now, on that front, there's something interesting that Alex proposed. Now this assumes that, let's say we were actually going to use a base token, native token of f. But suppose we did that, then in that case it would be a straightforward extension of your current work with the raw transactions, that we would add one more field to the transaction that is relayed, and that would be the EVM address, as in the public key that should receive payment in f for relaying the transaction to the network. So it could be handled like that.
00:34:21.490 - 00:35:03.340, Speaker D: Yeah, so we don't need that, because who's paid is the person who sends a transaction in the first place. So we already have the relayers id, so we don't need to extend it for our transaction. It even presumably works. There is a RPC point, which is gas price. So you can just ask this proxy relayer for the gas price, and it should just give you the price that it's okay with kind of paying, but it's still the amount. But for metacalls, right, we need this flow as well, because meta calls don't have this flow.
00:35:06.240 - 00:35:49.710, Speaker B: So I guess maybe my question for me is how MVP are we going now? Because when you say, you're asking the proxy RPC to say, hey, it's only worth my time if you pay me this much. That sounds like we're kind of like having an MVP version where it's like one relayer, basically. Is that how we're kind of focusing on now before sort of saying hey to the community of relayers, I am willing to pay this? That was kind of what I was imagining to be the ultimate goal. Am I tracking this correctly or no?
00:35:50.400 - 00:36:46.396, Speaker A: Well, let's go back to the box diagram that Alex drew us the previous time. I think that helps to discuss the topic. So this is in the previous call from three weeks ago. So Alex's notion was that we would have a ecosystem of relayers who could offer something like market price for gases, and they can set the gas limits. We are not going to be interested to relay transactions unless you meet this criteria. And from that would emerge some kind of market rate. And on the client side, when you relay transactions through whatever library, you could do the same as gas station network clients do, which is that if a relayer rejects your transaction for any reason, you can retry the next one.
00:36:46.396 - 00:37:01.890, Speaker A: And there can be some sort of prioritization based on arbitrary criteria, including quality of service and cost, ultimately for selecting which ones to contact first. Ily, does that make sense to you?
00:37:02.260 - 00:37:18.388, Speaker D: Yeah, but I think the core point, even if you have a lot of layers, right, you still want to fetch, you still want to ask relayer for what kind of price tag is, right? That's what gas station is. Gas station gives you a price tag.
00:37:18.484 - 00:37:24.420, Speaker A: Yeah, but importantly, you don't ask each gas station. So there's kind of a need for some kind of directory.
00:37:24.580 - 00:38:15.530, Speaker D: No, on gas, gas, I mean gas station, not gas station network, the gas station, whatever IO you ask gas station, it tells you what's the current market price. So you need that piece somewhere. And if nothing else, relayers should expose it. So you can actually ask them what's their price. Gas station gives you the network price, which we also have, right? So one option is just like, you literally ask what's the current near gas price? And you submit with that, and then you retry with paying a little bit higher and stuff like this. But because you're asking anyway is a relayer, right. It can tell you the problem here is the relayer can tell you whatever they want, right? That's why? You need a lot of them.
00:38:15.530 - 00:38:21.512, Speaker D: You want your choice to find the best one and have competing dynamics.
00:38:21.656 - 00:38:55.880, Speaker A: Yeah, and of course we have questions on that that let's say that the relayer accepts the transaction, but then it actually never submits it to the network. It drops it on the floor. We have some questions around that. We have some prior example how those are solved on the gas station network, but they are not necessarily comprehensively solved or even credibly. So we have some thinking to do on that. But in any case, are we aligned that we would like to see something like an ecosystem of relayers who would in some sense compete with each other to relate?
00:38:58.140 - 00:39:22.370, Speaker D: Mean, in general, yes. But also definitely for MVP, I would target similar approach to what we have right now with RPCs. We want a lot of RPC providers, but there should be also one that's kind of semi reasonable that people just applying. It's the same as infuria, right? Yes, there is other options. You can also run your own.
00:39:22.820 - 00:39:23.824, Speaker A: Yeah, exactly.
00:39:24.022 - 00:39:27.650, Speaker D: Rent stuff so it can be alchemy. But infuria kind of works.
00:39:29.620 - 00:39:52.970, Speaker A: Well right now. Concretely, the first RPC proxy endpoint is running on my vps in Amsterdam, so that's a good start. I'll upgrade it to the latest code soon. Your code. And yeah, maybe we can think of making something like that public or semi public. Might have to upgrade my vps. Good problem to have.
00:39:56.460 - 00:39:59.210, Speaker D: It can be part of near Inc's service.
00:39:59.980 - 00:40:53.390, Speaker A: Yeah, sure. Just bootstrapping it for the moment. Okay, so we have some more work to do on the conceptual model there, but maybe we know the direction we're going in. As in indeed, there would be some set of relayers. The end developer, or the library rather, would include some logic for selecting the relayer they would want to talk to, unless it's manually configured, and maybe having some sort of retry logic ultimately. And then the process is that it's one way or another, it's indeed wrapped into a new transaction, and we will handle even the raw transactions given the support you've added in the last weeks. So that's a pretty good step forward.
00:40:53.390 - 00:41:05.410, Speaker A: It means that we are not far off from being able to test with arbitrary ethereum apps and daps and clients and whatever.
00:41:05.780 - 00:41:12.870, Speaker D: I also tried with like you can actually add that RPC into metamask and get something going as well.
00:41:13.960 - 00:41:17.620, Speaker A: Did that work out okay, as in is Metamask giving you any errors?
00:41:19.880 - 00:41:27.416, Speaker D: I think I handled some, but I need to double check. I'll update on that real quick too.
00:41:27.518 - 00:41:39.220, Speaker B: I posted in discord, like something that I saw when trying to fiddle with the pet shop and do that. And it seemed to be like some gas stuff. It couldn't determine the balance.
00:41:39.380 - 00:41:44.668, Speaker D: Yeah, exactly. There's few endpoints, I think, still missing for sure.
00:41:44.834 - 00:42:03.330, Speaker A: Okay. But yeah, pretty promising. And I'm also looking to get set up with that. Probably Monday latest. Okay, so that's very nice. Progress moving forward. Then we have.
00:42:03.330 - 00:42:26.924, Speaker A: Let's deal with the blog post question. Let's see if I have. I don't have the link here. My demo account. Where can I find it? It's neurodox, right? That's where the pr is. Okay. Yeah.
00:42:26.924 - 00:43:06.104, Speaker A: EVM content. Okay. Five, six, eight. And you have a whole bunch of new tutorials here. I guess it's kind of mixed tutorial and reference docs. You said that the one that you developed the least so far is the RPC server that can use some more input, perhaps. Were you otherwise now happy with this pr and I could review and merge? Yes.
00:43:06.104 - 00:43:21.740, Speaker A: Okay, good. And let's see where we can. The render link is fixed as well, I believe. Yes. Right. So we are. Where are we? Development.
00:43:21.740 - 00:43:37.330, Speaker A: So we have a whole bunch of new pages there. And given that the blog post itself is, I guess, cut down to size quite a lot.
00:43:37.700 - 00:43:42.944, Speaker B: Yes, there's a lot of links giving a basic description in the blog post.
00:43:42.982 - 00:43:48.630, Speaker A: That links to these. Okay. And is your plan still to publish it today?
00:43:49.640 - 00:44:03.176, Speaker B: I would like to do that. I think that we can do a final pass. I've started it so much that I probably need a final review, but that'd be great to let our. I'm excited to invite our community in.
00:44:03.198 - 00:44:10.270, Speaker A: So I'd love to publish that. Okay. Any objections from Ilya? You reviewed it as well?
00:44:11.280 - 00:44:16.216, Speaker D: I haven't reviewed the latest version. I will take a look after this meeting.
00:44:16.328 - 00:44:18.076, Speaker A: Okay. Likewise for me.
00:44:18.178 - 00:44:19.808, Speaker D: But overall sounds good.
00:44:19.974 - 00:44:36.784, Speaker A: All right. Yeah, let's get that out. And hopefully we actually get some people feeding on bitterness would be nice. Okay. And then we have the contentious topic. Potentially contentious topic. The native EVM token.
00:44:36.784 - 00:45:10.416, Speaker A: And on that we already have a long discussion going here on the forum with many viewpoints. Does everybody know what this is? So should we introduce the subject a little bit? Yes, everybody knows. Okay. Right now we are using neuro exclusively for paying well in the form of account balances on the eVm. That's what it comes down to.
00:45:10.438 - 00:45:11.056, Speaker C: Right.
00:45:11.238 - 00:46:04.640, Speaker A: And there is a proposal that perhaps it will make sense from a business perspective, from an end user perspective, that it would be f and that is technically complex compared to near, but it would have some benefits to it. And Alex has tried to summarize here some of them. I need to weigh in here as well. Does anybody have anything new to add on this? New thoughts? How shall we deal with this topic? Ilya, I understand that you had come closer to the sort of the middle of the fence on this. You can see both sides, trade offs on each side of the fence.
00:46:06.180 - 00:47:12.390, Speaker D: Yeah. Just to clarify, the complexity of the implementation is actually not that big. The only difference is that instead of. So right now when we have deposit and withdraw, we are making a promise call with a transfer action. And actually instead we'll need to have a per EVM parameter which says which token we want to use, and then the promises will be the calling, transfer or transfer from for that token. So it's pretty much transitioning from using the base token of our kind of base runtime to using any token and then any token standard. Pretty much the main issues here is mostly just our dependency on the token standard on the protocol level.
00:47:15.580 - 00:47:34.204, Speaker A: Which is certainly a concern. Well, this is probably one of those cases where we would really benefit if we had, let's say, somebody outside of the core team. Also, so far we don't seem to have anybody from the community.
00:47:34.322 - 00:48:00.580, Speaker D: Yeah, I would source some opinions from mean Igor from zeropool mentioned that everybody else is using their own token, but it's worth going out and sourcing some folks who are like Ethereum kind of builders currently and seeing what are their kind of thoughts on this.
00:48:00.730 - 00:48:18.830, Speaker A: Yeah, because I would also not begin from the point of view of what everybody else is doing, as in, sure, there's a lot of EVM compatible chains, but none of them. Yeah, none of them are particularly credible. So what would set us apart? Maybe something like this.
00:48:20.640 - 00:48:38.384, Speaker C: What's the big benefit of having it natively on the protocol versus as part of the contract on EVM side. So if you say metacol can charge any balance. Yeah.
00:48:38.422 - 00:49:16.110, Speaker D: So metacol already can charge any token. So the difference mostly is twofold. One is what the raw transaction cost would be charging, because they're charging the base token. And the second one is what is actually that base token that is inside the contracts that's used. Right. So if you launch a uniswap inside EVM, the base token is what they use in the middle. And so that will define which pairs it will be.
00:49:16.110 - 00:50:00.220, Speaker D: Right. Now, I did some experiments with Matic, for example, and even though you can enter the token handle like Matic token, but the metamask for example, still shows you the Ethereum logo for the. So like in general, support is not super robust. Right, go ahead. In general, showing transaction fees and pulling the prices for the tokens and stuff like this is not very well done, kind of not very customized.
00:50:03.280 - 00:50:56.910, Speaker A: This is one of the big concerns in terms of the developer experience that most dapps, even if they have localization, for example, say that they are available in 20 languages. Well, in any case, they're going to hard code. The assumption, perhaps reasonably, that they're dealing with f, as in the native balance is f. They're going to be pulling the f price from some oracle. And all the conversions are assuming that it's f. So it's not a trivial thing for somebody to change an application that has such a hard coded assumption. If you just pull the rug under them and swap that to something else, then they're going to have to rework a large parts of the application, which is not a great developer experience.
00:50:56.910 - 00:51:00.850, Speaker A: So that's one of the motivating concerns here.
00:51:01.380 - 00:51:49.820, Speaker C: It means we can only target Ethereum developers for developing for EVM. Because let's say I like EVM, but I also like near wallet. I want to build an application that is not using metamask. So the challenge there is going to be, I need to think how to get wrapped east token first on near side to deal with, let's say uniswap on EVM side. Because if I don't have native, I don't have wrapped east. Then in order for me to start using Uniswap on EVM, I need to first acquire wrapped east somewhere. It also makes it complicated.
00:51:50.500 - 00:52:04.900, Speaker D: Wait, that's not particularly true. Let's be specific. You're saying you're an application in a base runtime or you're just a developer who wants to use EVM.
00:52:06.200 - 00:52:14.660, Speaker C: Are you building a new application and integrating this native runtime?
00:52:18.380 - 00:52:55.632, Speaker D: So you want to use a uniswap inside EVM, right? There's no real difference. Right. Let's say you want to exchange near for die, right? And you want to use Uniswap. There's difference definitely that Uniswap has like near Dai pair or not. But there's no difference between saying I want to exchange one token to another balancer, for example, will just do it for you. It will just find the pools that will exchange these two tokens. It doesn't matter what's based token.
00:52:55.632 - 00:52:59.830, Speaker D: And you're still paying fees in near, like the near wallet still works.
00:53:00.440 - 00:53:24.590, Speaker C: No, I understand. I don't understand how non ethereum users can use EVM. Like if I don't have Ethereum and I have only near, how can I use EVM? Is not deposit the balance of what.
00:53:25.200 - 00:53:31.040, Speaker D: Any other token you'll need to deposit. Like if you have die outside of EVM and you need to deposit it.
00:53:31.110 - 00:53:48.710, Speaker C: No, let's say I want to buy some ethereum token or like some token on the evm side. If all contracts are using and I don't have it, where do I supposed to get it through the.
00:53:50.680 - 00:54:20.652, Speaker D: I mean you have near, right? You just buy the token you want to buy for near. Like there will be pairs inside EVM, in uniswap and in balancer which are near to eth, east to Dai. So if you have near and you want to buy die, you go there and you ask, I want to buy die for near and it gives you one inch. Find the best things, cannot deposit it, right? Why? It's a token. It's the same as I need to.
00:54:20.786 - 00:54:24.012, Speaker C: Wrap near to transfer to EVm somehow first.
00:54:24.066 - 00:54:43.936, Speaker A: Yeah right. That is where the bridge would come in. But the first question I would ask you, Jen, is that, and this is important for our user stories. Which users did you have in mind who would want to use the EVM but that are not f one users because we are not taking into account anybody like that in our user stories right now. And if there is somebody, then it.
00:54:43.978 - 00:54:57.032, Speaker C: Looks like we're building just another Ethereum chain that is not integrated with native near applications. But I always benefit.
00:54:57.096 - 00:55:48.952, Speaker D: I don't agree with actually, let's go back to what Eugene was saying. You do not need a bridge, you do not need to have the token balance, the base token balance inside Evm to use. Like it's the same thing as actually you don't need to have eth to use Ethereum if all the things had meta calls. So from perspective of EVM, you having near wallet is metacols. You're paying transaction fees in near and you can do whatever you want inside EvM. Like complete free from perspective, from perspective of EVM, right. The base token is talking about integration.
00:55:49.016 - 00:56:51.550, Speaker C: Of native contracts with EVM. They will need to operate on either on near side or wrapped near, which makes it all calls that go to EVM. If they don't have a native balance within EVM, which is probably weird but will have to go through the token standard first. Like token contract on native side that will call Evm for conversion and later executing. Versus if you have attached balance in native near, then they can natively call Evm and start interacting with unison. Potentially it removes one extra step. I don't know if it will be a pain point down the line.
00:56:51.860 - 00:56:55.440, Speaker D: So this part was specifically uniswap. I agree.
00:56:55.510 - 00:56:55.696, Speaker C: Yes.
00:56:55.718 - 00:57:29.324, Speaker D: So uniswap is where if you want to exchange near for something and you want to use it, it is easier if near is based token. Every single other app which are like balancer, lending apps, et cetera, none of them actually using message value for acceptance. So you will need to wrap your stuff first anyway, right? Like balancer uses wrapdeeth and dydx using wrap eth. All of the people using wrapdeeth because they don't want to write custom code like they want to use one standard for everything.
00:57:29.442 - 00:57:36.270, Speaker A: Yeah. And actually we might perhaps just state that wrapped ETH is more important for defi than ETh itself.
00:57:40.260 - 00:58:02.950, Speaker D: Yeah. My point is that if you have an application in base runtime that's calling application inside EVm for the most part, you will need to wrap your near into a ERC 20 inside Evm to be actually to use it anyway. So I think making that like a standard thing is actually probably.
00:58:05.880 - 00:58:06.888, Speaker C: Makes sense.
00:58:07.054 - 00:59:01.850, Speaker A: Well, and also from the point of view of what we would want, just if you take a step back from the details and think about somebody who's developer f user, we would want, I think that they could bridge in particular F. But of course other tokens too, they could bridge them easily across f one our EVm and our base runtime, as in maybe we are calling it nf on the base runtime eF on the EVM, and then you have wrapdeth on s one. But in any case, we would want, right, that when people have one f in one of these realms, they would feel confident that they have one f and that they can bridge it, for example back to f one at any time. That's going to be starting point.
00:59:02.620 - 00:59:06.660, Speaker C: It doesn't guarantee that the native token should be still wrap this.
00:59:06.830 - 01:00:15.904, Speaker A: No, it's a separate question. It's a separate question. But in any case, I think that's a starting point for how a user would hope that all of this would work. And then once you have the ability to bridge, especially f very easily move it around in this way. Of course, I know right now we have delays in the bridging in some directions, but assuming those can be solved, then from the user's perspective, it might make sense that, for example, let's say in metamask, I go to the bridge on f one, I have my metamask connected I get an address to send to which is going to magically credit the same amount of f I sent to the same address on the EVM side. And that all happens pretty quick. Then that's a pretty nice user experience that even if somebody was changing in metamask the network the same way as we change between testnet and Mainnet, you could just see that ultimately what it comes down to is that one net disappeared from this balance here.
01:00:15.904 - 01:00:23.120, Speaker A: I changed to that network. Whoa, I got one net there. That would be great, right? I mean, that's what I would expect as a user.
01:00:24.100 - 01:00:42.170, Speaker C: Yeah. My main argument would be that embedding something on a contract and with the protocol will make it very complicated. So make it a native token on EVM and connecting it to some standard.
01:00:44.380 - 01:00:47.252, Speaker A: I fully agree that on a contract.
01:00:47.316 - 01:01:07.152, Speaker C: Level we'll first lock all the contract side APIs, such as like a JSON host methods and stuff like this. Even so, we can upgrade it. We cannot stop supporting old versions ever because there's going to be application built.
01:01:07.206 - 01:01:08.370, Speaker A: On top of them.
01:01:09.140 - 01:01:11.090, Speaker D: But it's true about any standard.
01:01:12.520 - 01:01:24.980, Speaker C: Yes, that's why we don't link them right now at all to native implementation. So only one way contracts are depending on protocol, not other way.
01:01:25.130 - 01:01:56.370, Speaker A: Yeah, no, I think I'm perfectly with you on how technically burdensome and complex, and perhaps risky in some regard. All of this is. I'm just starting from the user's point of view that this is what one would like to see. Maybe there are constraints like this that prevent us from building it, but at least it's a good idea to try to start what we would like to see. And then if we can't do it, we can't do it. Or if we shouldn't do it, we shouldn't do it.
01:01:59.220 - 01:02:22.840, Speaker C: I still don't have full benefits. I understand the uniswap use case that it will display it correctly without changes. At the same time, working with tools is probably reasonable, and it will benefit from all other chains to properly display their native tokens. Instead of saying you should change the token.
01:02:23.900 - 01:02:40.910, Speaker A: Well, that's true, but that's a pretty large problem, as in there's naps out there that would need to be changed. It would be good if they were changed, no question. But are we going for pushing them to change it, or are we just making it possible for them to work without that kind of.
01:02:42.320 - 01:03:29.310, Speaker D: So, Eugene, I guess one question that I have, which is so right now, EvM is done as like a full kind of EVM contract is pre compiled and so one option was actually leave as a pre compile only the bytecode execution side and leave also like glue code that we have still on the contract side. Like pretty much expose just like exact evm bytecode kind of function inside vasm runtime and then so have a webassembly contract which all the glue code that calls this function.
01:03:29.620 - 01:03:32.690, Speaker A: That's pretty much the box model we are looking at. Right?
01:03:36.100 - 01:04:44.470, Speaker C: I think I would prefer the way it's done right now where everything is native. Part of this is a contract. Part of this is non contract. The reason for this is if in the future we want to enable native transactions on EVM site where the transaction doesn't go through signed near transaction, but just can lend straight to EVM, we can without this native or without this contract kind of wrapper because we will be able to verify a certain transaction similar how we verify native transactions. And hey, this ethereum address has enough tokens to cover the gas cost. Let's just go and execute this transaction so it will be able to avoid it into near transaction. In case you want to do this.
01:04:44.470 - 01:04:57.880, Speaker C: This will probably save round trip. That receipt needs to apply to EVM. Just go straight to EVM shark, which will make it less abusable.
01:05:01.500 - 01:05:34.392, Speaker A: Well, this question is also tied into Ilya, what we were discussing in the last weeks about upgradability. Right? As in what really should be in the protocol and what should be in the contracts. Yeah, and I think you changed your view on that a little bit. You started out from it would be a good idea to separate bytecode execution and have some sort of a contract interface front in front of it, but I wasn't in on the last meeting with you and Alex on this, but I understood you changed your view on that.
01:05:34.446 - 01:05:55.150, Speaker D: Well, it's mostly that currently in base runtime we have problems with easily upgrading contracts in a permissionless way. Having re upload a new contract is not really possible yet.
01:05:56.160 - 01:05:59.150, Speaker A: So it's mostly an incidental limitation then.
01:05:59.860 - 01:06:06.480, Speaker D: Well, yeah, but in the short term it is a limitation that would stop us from launching.
01:06:07.140 - 01:06:09.890, Speaker A: Okay, all right.
01:06:11.400 - 01:06:26.890, Speaker D: Yeah. Right now, upgrading our protocol is actually easier, potentially easier than upgrading imported and smart contracts. That's kind of the current state.
01:06:27.340 - 01:06:41.560, Speaker A: All right. Okay, well I think we are out of time for today, so this discussion will need to continue offline. Does anybody have anything else to add before we wrap?
01:06:42.060 - 01:07:15.352, Speaker D: Mean if I have 1 minute. Actually I'm curious Eugene, on what's the current state on the token standard actually, because the reality is as soon as we kind of approve it. Right. We will need to support it going forward because the bridge will rely on it. So EVM will rely on it through the bridge anyway. And so from my perspective, even though yes, we're hard coding it on protocol, which I totally agree is kind of leaking abstraction, but the support we need to provide to token standard will be kind of on that level.
01:07:15.406 - 01:07:16.010, Speaker A: Anyway.
01:07:18.700 - 01:08:20.604, Speaker C: We currently finalizing it. There is a standard that slightly upgrading what Robert Zaremba proposed. I do not agree that they need to always support it because there's always possibility of building a wrapper for the new standard on the top of old standard if it ever arrives. That's why. So even if we launch a breach with NAP 21 for some reason, we can have a mint burn pattern which wraps old nap and deploys a new one. So basically it will be a new standard that can consume NAP 21 and mint. And then when you want to transfer it back to Nap 21, you can do this.
01:08:20.604 - 01:08:52.500, Speaker C: So this kind of grade is how probably like die was upgraded from PSI. So similar pattern can be used to upgrade token standards in the future. But yeah, we trying to finalize it as soon as possible. So I think everyone who were interested in talking standard is now on agreement on the latest.
01:08:53.980 - 01:09:00.970, Speaker A: And I think you moved that to discord, right? That discussion. What's the channel there?
01:09:01.420 - 01:09:22.770, Speaker C: Yeah, there is a standards channel on Discord. And also there is a new map that we splitting map into three standards. One is like core API, second is metadata, talking metadata. And third is like account registration for storage related stuff.
01:09:23.140 - 01:09:50.970, Speaker A: Right. I'll put in the links in the meeting notes as well. Okay. Anything else? So shall we wrap up exactly on time? I take that as it's enough for today. Good then thanks everyone and thanks for the people watching for tuning in. And let's continue next week.
01:09:51.900 - 01:09:54.116, Speaker C: Thank you, bye.
