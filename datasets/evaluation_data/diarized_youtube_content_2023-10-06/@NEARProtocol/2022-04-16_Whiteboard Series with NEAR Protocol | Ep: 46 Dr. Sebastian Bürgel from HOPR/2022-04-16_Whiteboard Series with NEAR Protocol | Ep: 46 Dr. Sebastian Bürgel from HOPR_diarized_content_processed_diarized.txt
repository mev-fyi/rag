00:00:07.690 - 00:00:23.646, Speaker A: Hello, everyone. This is Ilya from not so sunny Zurich. But it was really nice, multive. And I'm here with Sebastian, founder of Hopper, and we're going to dive in and learn more about it. Do you want to introduce a little bit about yourself? And then.
00:00:23.748 - 00:00:47.660, Speaker B: Yeah, sure. Thanks, first of all, for coming to not so sunny Zurich to talk about privacy here. Yeah, Sebastian, founder of Hopper. We are, as we say, changing data privacy for good. What we're doing specifically is a metadata private data relay network that provides data privacy on a transport layer. So bringing data from a to b.
00:00:48.430 - 00:00:57.630, Speaker A: Okay, maybe let's dive in on the problem first. Understand why do users and developers care about this?
00:00:57.780 - 00:01:47.854, Speaker B: Sure. So let's take, for example, we have a data exchange between Alejandro and Zoe, right? So we have our first protagonist, Alejandro. And for example, Alejandro might be using metamask wallet, right? And what do we actually do when we submit, for example, ethereum transactions, right? So we send it to somebody else, in this case, to Zoe. And Zoe might be an RPC provider. And what is kind of interesting is that today, when these two exchange data, they also make to each other visible their IP address. So, for example, in the case of a metamask user and an RPC provider, the RPC provider sees where you live. They can link your accounts and all sorts of other things.
00:01:47.854 - 00:02:37.342, Speaker B: So we want to solve that. Now. Interestingly, people sometimes, you know, I get privacy by decentralized technologies by, for example, running my own node. But interestingly enough, running your own full node is not enough because you basically just have the IP address of that node, which becomes a synonym of your wallet's IP. So, yeah, basically what people sometimes then do is you use a VPN, right? So in our case, maybe we have chow as a new actor in our model here, and we just relay everything via chao. So far so good. But I guess, as we know well, with vpns, you're just trusting that guy now with everything, right? Your browsing history.
00:02:37.342 - 00:02:45.620, Speaker B: And if they know what power you have when you submit crypto transactions which they can now link, it's probably going to get even worse than vpns already are.
00:02:47.030 - 00:02:50.914, Speaker A: Yeah, so much front running. VPN extracted value.
00:02:51.032 - 00:03:10.620, Speaker B: VPN extracted value. I like that. Exactly. What if these guys find out that, for example, your transactions, which you're submitting, like, for example, to estimate gas price, right? So typically, people just submit this transaction, say, hey, tell me what gas amount I should send. Typical example, you can front run the whole thing for NFTs, defi, whatever.
00:03:10.990 - 00:03:16.858, Speaker A: Okay, well, I mean, if you have SSL messaging here, that will be harder to.
00:03:16.944 - 00:03:55.586, Speaker B: It will be harder. But interestingly, so many times, only by looking at the packet size, you can infer a lot of information. Right? And this is exactly what we mean by metadata, by how frequently, how big data packets, you can still infer a lot. So one thing that does better than just a VPN is Tor. And what Tor actually does is it introduces two additional nodes, right? So let's call this one here Betty. And then we have one other node over here, and that one is chow. No chow.
00:03:55.586 - 00:04:25.810, Speaker B: We already got in our story. Too bad. So that one is Demetrio. And now what you can do in this story is basically. So all our five friends are acting together, and you're relaying data packets from one to another. And by doing so, you are basically not really knowing where data came from, where it goes to, and who is exchanging data with who. So far, so good with Tor.
00:04:25.810 - 00:04:35.620, Speaker B: Maybe let's dive into onion encryption, which is something that is quite typical for Tor here.
00:04:36.150 - 00:04:41.160, Speaker A: I should mention that this is probably run by Russian Federation and this is by United States.
00:04:42.170 - 00:04:50.146, Speaker B: Exactly. For example, right. That's actually kind of good, right. Because you want different actors, which are ideally not colluding.
00:04:50.178 - 00:04:51.258, Speaker A: No exchange information.
00:04:51.344 - 00:05:16.706, Speaker B: No exchange of information. That's perfect, right? That's perfect. So, effectively, what we would like to see is that there is a data packet which gets forwarded along the way, right? And this data packet is encrypted. But it's not just encrypted once, but it's. And that's why it's called onion encrypted multiple times. Right. So we have multiple layers of encryption that are being passed around.
00:05:16.706 - 00:05:46.186, Speaker B: So basically, when we have the first relayer in our chain, Alhandro, he is, like, encrypting this packet four times. Betty gets the packet, she peels off the outer layer of this encryption. That's why onion, right. And passes it on and so on. So that finally, only Zoe can see the data that is actually being sent around. So that is on a high level what Tor is really doing.
00:05:46.288 - 00:05:50.910, Speaker A: And so when you're sending this, you actually need to know the full route to your destination.
00:05:51.410 - 00:06:16.942, Speaker B: Exactly. So in case of Tor is source rooted. Right. So you select a path. And this path that Alejandro is choosing is typically, like long living, so typically something like multiple minutes. So that's actually one of the weaknesses. So you can look at the packet like, let's say I'm the Internet service provider of Alejandro and Zoe.
00:06:16.942 - 00:06:46.710, Speaker B: I can link these. I can basically see exactly how big is the data packet here, how big is it over there? And link these two. And if I don't do that just for one packet, but take these long living route that is persisting, I can know even with not so hard resources, find out what's going good. So, well, not so good. That's a weakness of choice just to.
00:06:46.880 - 00:06:56.910, Speaker A: Question like Zoe presumably also should receive an encrypted message for Zoe. So what mitro is seeing is metadata about this.
00:06:56.980 - 00:07:37.370, Speaker B: Exactly, yes. So basically the writemost packet, like it contains the actual payload, which is still encrypted, and Zoe takes off the last layer of encryption. Good. Okay, so how do we get better than that? So one thing, as I mentioned, like this weakness of the trust assumption of Tor is that the first and last node is not colluding. And that specifically is the thing that we are wanting to improve. And maybe one thing to mention, because we'll pick it up later on, is the economic sustainability of Tor. Tor has been around for longer than bitcoin, but Tor hasn't been growing really for the past at least half a decade.
00:07:37.370 - 00:07:48.130, Speaker B: So we see Tor has under ten k nodes and Tor has under 2000 exit nodes. So this last one, which is of course a bit a touchy one because it gets access to the wide.
00:07:49.830 - 00:07:50.242, Speaker A: You.
00:07:50.296 - 00:09:09.738, Speaker B: Know, bringing economic incentives to that game is the second major difference here. So how does that work? What we do in a mixednet like Hopper is actually there's not just a packet coming along this route here to chow, but there's actually multiple other packets that are also being sent to chow. And Chow is sending these data packets out also to other people. So what happens there is actually, you receive a packet, you cache it for a short amount of time while you're also receiving other packets. You transform them so they look different between incoming and outgoing packets, so you cannot link them and you mix them up and send them out in a different order. And this combination of transformation, of mixing and having this artificial delays is actually what brings significant better privacy than what you have at Tor, because only if you have access to that machine do you know which packet corresponds to what. So what we call this global passive adversary, either your Internet service provider or like the three digit agency of your choice, will not be able to find out which packet corresponds to which.
00:09:09.738 - 00:09:21.150, Speaker B: And they cannot link incoming and outgoing traffic. Good, so that's the fundamentals of a mixnet.
00:09:24.210 - 00:09:24.960, Speaker A: Yeah.
00:09:27.430 - 00:10:02.690, Speaker B: Let'S actually then go to the second thing, which is the weakness of Tor, which we mentioned in the beginning, is this linkability. By just observing, like not even caring about all that, but just mixing packets. If you observe here and you observe over there. So effectively what we're doing in hopper is packets. We make packets look indistinguishable from one another. And how we do that is by basically either shrinking them or padding them all to the same size. And interestingly, it's not just about the packet itself, but also about the header.
00:10:02.690 - 00:10:55.760, Speaker B: So the header gives away usually whole lot about who you're communicating with and so on. Like in a worst case, you can just see to whom is this packet addressed. Now, that is being protected by using a packet format that's called Sphinx. It's used by the bitcoin lightning network and by a bunch of other projects. So it's made for such mixed nets. And it's basically called Sphinx because we don't just have this onion encrypted payload in the packet, but we also have a header that has a bunch of information in here for relaying that packet. And we augment that in case of Hopper by also having some payment information that we append to it.
00:10:55.760 - 00:11:52.510, Speaker B: Now, the first step maybe to realize for what's going on here is we have some key material here. So there's some alpha, a key material that is defined by the sender of the packet. And basically this alpha is an offline Diffi Hellman that Alejandro is doing with all these downstream nodes. So effectively, by knowing their pub key, Alejandro is choosing a secret. And this secret x, he does an elliptic curve multiplication times g times the base point here. So that is like the immediate material which is then multiplied with the pub keys of all these nodes. And thereby you establish a shared secret.
00:11:52.510 - 00:12:31.870, Speaker B: And this master secret I mentioned, because we'll get back to it many times, we will use it to derive all sorts of keys. Good. Now, so this is the first part of the information of this packet, and there's other stuff as for example, you need some routing information, right? So that's this beta in here, which tells basically Betty, well, where do you send this thing? And some other stuff. And finally, there's an integrity tag in here, which is just allowing you to make sure that nobody altered the packet while it was in transport.
00:12:32.690 - 00:12:34.480, Speaker A: But isn't routing information.
00:12:36.370 - 00:13:06.546, Speaker B: In this case? No, in this case not, because the onion really is only the encrypted payload. And what is interesting is how do we protect this header such that you cannot in transport extract stuff from it? And actually Sphinx does something pretty interesting here. So if we look at the header, this header contains information like when Alejandro formats the packet for all the downstream nodes.
00:13:06.578 - 00:13:06.726, Speaker A: Right.
00:13:06.748 - 00:13:56.054, Speaker B: So they all need to be able to process this. So in a naive implementation, you could basically say, okay, well, Betty just pulls out her information and passes on the rest. But that exposes some metadata information in the header because you could just observe how the header shrinks and you know where you are in the relay chain. So what sphinx actually does is it takes all these pieces of the header information for the individual nodes and that is then blinded. So it is first blinded with a blinding factor that only Betty can derive. I mark it with this hatching here. So basically only Betty is able to remove this hatching, right.
00:13:56.054 - 00:14:06.454, Speaker B: So only Betty can remove that. Then there's a second layer which can then only be removed by chow. So that's everything from here downwards generate.
00:14:06.502 - 00:14:10.998, Speaker A: Still on each layer.
00:14:11.174 - 00:14:39.778, Speaker B: Exactly. It's not part of the payload, but it's following the exact same principle. Exactly like you say. So basically you repeat the same thing. Right? So like this first part can only be derived by Betty, the second by chow and so on. So we have a bunch more hatchings for each of the nodes that participate there. And now what sphinx basically does is when Betty receives this packet, she removes this and she pads.
00:14:39.778 - 00:15:39.014, Speaker B: Then in the end, like some kind of noise data which is indistinguishable from the which is indistinguishable from actual information. And what that means is for us, as outside observers, we can tell what's going on, right? So she would just remove this part here and append this other. So that are some of the pretty interesting, neat things that Sphinx is doing to protect metadata in the header. All right. Then I said the second kind of interesting thing of Hopper is that we want to bring in incentives. So what we want to do is that chow, for participating in here, is receiving a payment. But for doing that, we don't want.
00:15:39.052 - 00:15:41.298, Speaker A: To review who is sending.
00:15:41.394 - 00:16:05.950, Speaker B: Exactly. Right. So there's a bunch of things that could go wrong. So in a naive version, it's like especially maybe bitcoin. People say, hey, you can solve all of world's problems with bitcoin, lighting network, solve everything, for example. Right? But so one thing, like in a naive example, even like on chain, right? So in a naive example, what we don't want is we do not want to see. Okay, first know Alejandro is sending money to Betty.
00:16:05.950 - 00:16:09.826, Speaker B: Betty is sending money to Charles Chow sending money to Dimitri and Dimitri to Zoe. Right.
00:16:09.848 - 00:16:11.890, Speaker A: So that money takes Zoe even better.
00:16:12.040 - 00:16:40.800, Speaker B: Exactly. So that would reveal everything that's going on here. So that's bad. How do we hide it? By going l two, basically. So what we have at Hopper is a payment channel network. So Alejandro has a payment channel open to Betty, Betty to chow, chow to Dimitra, and so on. Interestingly, we do not have an incentivization between Dimitri and Zoe because we know Zoe is part of a service provider who is in inherent interest to receive incent data.
00:16:40.800 - 00:17:15.894, Speaker B: So maybe, as a quick recap, what does that mean? It basically just means that you commit funds which can then be released by the other party with off chain information which is being passed along. So effectively, Alejandro is staking some hopper token in a payment channel towards Betty. Betty is staking hopper tokens in a payment channel towards chow. So if you want to think, like, ultra high level, it's a little bit like pos where you stake money in order to secure a network. Just in our case, it's not an l one. Right. We don't secure a blockchain here.
00:17:15.894 - 00:17:57.350, Speaker B: This is used to incentivize packet information which are being sent around. Yes. And then after we have established these payment channels, they can be used for sending actual packets around. And one interesting thing is that basically, Alejandro sends a locked amount of money to Betty here. So it's locked up because there's a free rider problem in a naive implementation here. So the free rider implementation, the free rider problem is what if Betty just. Exactly.
00:17:57.350 - 00:18:40.946, Speaker B: She just says, hey, thank you, and off I go. So what we bring in here is to solve this free rider problem is basically a key sharing mechanism. So this money, let's say initially it's like three hopper. Realistically, it's less. But just for explaining this, Betty needs two pieces of information in order to unlock this payment. So basically, she needs two keys. The first key, she can derive herself, and the second key will be passed on to her.
00:18:40.946 - 00:19:27.854, Speaker B: Maybe let's remove some of the arrows. I don't want to get a bit messy. So the second key gets delivered by Chow to her. So this second key, half here gets delivered, and those two together are giving her the information for how to release that payment off the payment channel. Cool. So let's maybe dive one layer deeper into what's actually happening here. So I mentioned that actually we have this key information out of the syncs format.
00:19:27.854 - 00:20:43.674, Speaker B: So this alpha, which we then use to derive further keys. So we have a master secret, which is not just this, but actually we have an alpha zero, which is derived for Betty. We have an alpha one, which is derived for chow and so on. And basically, this alpha, it shouldn't be the same, because if it was always the same, what could happen is that maybe Dimitri down there is extracting some of that learning about the alpha, and maybe Dimitri is colluding with one of these gpas, this bad guys who have network level overview and can de anonymize information from the network. So that's why these alphas are basically iteratively changing. So every one of them is calculating the alpha for the next party, which also then ensures that the path is being followed, because if anybody else would forward this package to somebody else, they wouldn't have access to the private key of that party, and therefore they could not modify the alpha. So what we have here is actually the secret that we're using here.
00:20:43.674 - 00:21:31.430, Speaker B: I will call s one, and that is the one that Betty derived herself. Right? So let's call it s 1 key half that we get back from chow. So Chow is basically sending this key half is s two, and it's effectively an acknowledgment. Right? So Betty is taking the packet, passing it to chow, and chow is, as an acknowledgment, coming back to us with this key hat. Good. And what we then want to validate, because that is something that needs to be validated by our smart contract, is actually. Are these values here legit? Right.
00:21:31.430 - 00:21:34.489, Speaker B: So we don't want Betty to.
00:21:34.489 - 00:21:36.922, Speaker A: To have submit some false stuff.
00:21:37.056 - 00:21:54.890, Speaker B: Exactly. Right. And it could be two things, right. It could be she made up this thing because she's not actually Betty, or it could be that she made up acknowledgement. Exactly. Yeah. So how do we do that? Well, we do it by basically doing an elliptic curve multiplication.
00:21:54.890 - 00:22:37.290, Speaker B: So again, we multiply this here with some base point. Again, it's a plus here. And effectively this value is something that has been signed off by alejandro. I'll get to that in a second in detail, but for now. So we have basically this secret value here, the sum of s own plus s acknowledgement, which Betty needs to provide to the smart contract. But now, basically, another thing could happen. Right? So what could happen is here that she doesn't know if she got betrayed.
00:22:37.290 - 00:23:32.650, Speaker B: So before she does the actual work, she wants to know, well, is this stuff actually legit? So what we actually have here, so we can basically just rewrite this equation here. So this is s own times g plus s two. The acknowledgment times g. And this value we actually provide in the header ahead of time. And we call this value here actually a hint. And this hint is actually part of the beta, which we have up here. Now, what does this do? So we have this s own, which she can derive herself, and we have this value from this together.
00:23:32.650 - 00:23:56.210, Speaker B: She can validate if the payment information of these two skis. Exactly. That's exactly what we wanted to establish here. And she can do that before she get that stuff from the smart contract. Sorry. Before she got it to chow and check with the smart contract. Hey, is this legit or not? And then everything is fine.
00:23:56.210 - 00:24:22.648, Speaker B: Just a little nuance. Basically, we have this elliptic curve multiplication, which, unfortunately, you can't do in ethereum. So that's just like this very relatively silly ec verify. So you can kind of abuse Ec verify. Actually, to do an elliptic curve multiplication, which is a bit weird, but, yeah, you have to work with what you. Right.
00:24:22.814 - 00:24:41.552, Speaker A: So let's maybe just kind of mechanically, right, so let's say I'm Alejandro. I'm just joining the network. So the first thing I do, I go to smart contract, and I pretty much commit to log some amount of funds with Betty. Like, I explicitly on smart contract, reveal that.
00:24:41.686 - 00:24:42.370, Speaker B: Correct.
00:24:43.860 - 00:24:45.116, Speaker A: Specifically to Betty.
00:24:45.228 - 00:24:46.624, Speaker B: Specifically to Betty, yeah.
00:24:46.662 - 00:24:47.152, Speaker A: Okay.
00:24:47.286 - 00:24:59.728, Speaker B: Why? Because we want to, of course, avoid double spends, right? So that's why, if you would commit to know maybe one of these, anybody is your friend, and you're just extracting funds.
00:24:59.904 - 00:25:11.400, Speaker A: So if we have the smart contract, right, so Alejandro can min with storing, like, let's say ten for Betty.
00:25:16.000 - 00:25:21.804, Speaker B: And a bunch of others, right? So probably he wants to open a bunch of other images as well, right?
00:25:21.842 - 00:25:50.804, Speaker A: So he also open up his chow. And so then when they're actually constructing this message, they are kind of committing to this. Well, they couldn't hint. And then they putting in this actually.
00:25:50.842 - 00:25:53.776, Speaker B: On the smart contract. None of this is so far, stored.
00:25:53.808 - 00:26:02.344, Speaker A: On the smart contract. No, I'm more thinking like this. Like three hopper, right? Like, they're committing based on the route that they consider to take.
00:26:02.462 - 00:26:16.190, Speaker B: So, initially, when you open your payment channel on a smart contract, you're committing something only on an individual edge base in its network. So you're committing only money to the edge of Alejandro to Betty, Alejandro to chow, and so on.
00:26:17.220 - 00:26:20.770, Speaker A: But I'm saying, like, when I'm sending this message, I need to put some.
00:26:21.780 - 00:26:45.880, Speaker B: Amount of amount is this amount that you send is committed to this edge at first. And then what happens is, actually Betty will commit to forwarding funds to chow. So what is actually happening is that Betty is sending, again, like, a hopper packet here, which contains, in this case, now, two Hopper.
00:26:46.220 - 00:26:51.736, Speaker A: Yeah. So my question here, if I'm committing to three. Will that reveal that I have the.
00:26:51.758 - 00:26:56.860, Speaker B: Three hops in that case? So in the current version of the protocol, it does reveal that.
00:26:56.930 - 00:26:57.260, Speaker A: Yes.
00:26:57.330 - 00:27:07.730, Speaker B: So we're thinking about some numbers to obfuscate this number here. Right. So you could obfuscate it up or down. That is currently a version that is revealed. That's correct.
00:27:10.100 - 00:27:16.608, Speaker A: Presumably you can have some zero know if this smart contract actually had zero through, right?
00:27:16.694 - 00:27:16.992, Speaker B: Yeah.
00:27:17.046 - 00:27:19.100, Speaker A: Then you can just send.
00:27:19.270 - 00:27:42.010, Speaker B: That is true, although we are trying to avoid that for now because we're thinking about throughput here. Right. So ideally we want this packet transmission to be fast. So that's why we're trying to avoid. I know your knowledge stuff is like very hot and stuff, but it's very slow, especially if we're know you want to send like dozens of packets a second.
00:27:42.380 - 00:27:56.764, Speaker A: All right, so then you're still encrypting kind of with the full. So I'm azalehandriff. I joined this network. First thing I need to do, I need to discover kind of as many nodes as possible.
00:27:56.882 - 00:27:58.328, Speaker B: Exactly in the network.
00:27:58.504 - 00:28:02.332, Speaker A: And so are the nodes registered on the smart contract somehow?
00:28:02.396 - 00:28:34.376, Speaker B: So effectively, if you're thinking about it, who would you want to open a payment channel to? You would only want to open payment channels to other nodes who are already kind of committed to the smart contract by having payment channels themselves. So effectively what you're doing is we are also using the smart contract as a discovery mechanism. Okay. So you're basically going there and saying, hey, who's there? And you do see the pub key there. And from that, you know to whom you can commit stuff.
00:28:34.558 - 00:28:41.868, Speaker A: So they have a pub key, which is kind of their official pub key. And then I'm assuming they also registered their IP address.
00:28:41.954 - 00:28:52.050, Speaker B: Yes, that's correct. Actually the IP address is not there, but we have a DHT for that. But you could as well just store it actually there. Yeah, that's totally possible.
00:28:55.300 - 00:28:56.572, Speaker A: When you're registering.
00:28:56.636 - 00:28:58.530, Speaker B: Yes, exactly.
00:28:59.220 - 00:29:06.980, Speaker A: Okay. So then, yeah, so I come in, I'm like, okay, here are some cool folks. Look up. Maybe the latency for this IP address is fine.
00:29:07.050 - 00:29:23.940, Speaker B: Exactly. We're doing a health check. So what we're doing is actually we're trying to probe the network. So far, the current version, which we have, is quite simple. Like I'm probing it, but we're thinking about some transitive trust or something that's a bit better to get it viewed.
00:29:24.020 - 00:29:42.748, Speaker A: Yeah, that's very interesting. Let's put a note on that. Just like basic mechanics, right? So half pub key, I discovered some. I'm like, okay, I'll commit to this, folks. I'm sending, then I build a route. Right? So how do I build a route?
00:29:42.924 - 00:30:17.710, Speaker B: Yeah, so basically what you want to assure is basically you're the new guy. You open something to Betty, and if you want to build a route, you want to find out, well, where does Betty have open payment channels to? So you're basically consuming the topology of the graph. But the interesting thing is, you remember when I mentioned initially that this last hop here is not incentivized. So it's basically not a path finding problem, but it's more a path selection, because any sort of connection of these guys is possible because your last hop is going to be here, disconnected of this.
00:30:18.160 - 00:30:19.612, Speaker A: You can go like this.
00:30:19.746 - 00:30:27.790, Speaker B: Exactly. We're assuming that on the TCP IP level, they are connectable to one another.
00:30:30.420 - 00:30:42.070, Speaker A: Let's say you build a path, but the path is Betty to, for example, to Mitra, and there don't have. Not a valid path. So Betty would just drop it.
00:30:43.160 - 00:30:51.572, Speaker B: Actually, as you do the path selection. Like we basically implemented it. Just a path selection. You wouldn't find it.
00:30:51.626 - 00:30:53.216, Speaker A: Yeah, but let's say somebody did send.
00:30:53.258 - 00:30:59.540, Speaker B: It, then it would just like, oh, that thing is not funded, doesn't work. Packet drops.
00:30:59.620 - 00:31:04.490, Speaker A: Okay. Similarly, it better see from someone who have not opened a channel.
00:31:04.860 - 00:31:18.240, Speaker B: Same thing, and actually another one. So it could be that a channel is, like, out of funds. Right. So it could be that you have not enough. If you only have one hopper left in the balance, but the packet costs two. Well, you drop the packet also.
00:31:18.310 - 00:31:28.896, Speaker A: Okay. Potentially the packets can get lost because of this, because somebody somewhere didn't top it off.
00:31:28.998 - 00:31:40.260, Speaker B: Exactly. So it's basically. It's kind of similar as packets hop around the Internet, if there's somebody pulled the plug somewhere, packets get lost and you need to retransmit and try a different route.
00:31:42.680 - 00:31:52.856, Speaker A: Okay, then let's return back. Yeah, I can generate this hint, which is for the next one in the route, actually.
00:31:52.878 - 00:31:57.580, Speaker B: Sorry, the hint got. Gets created by the sender, by Alejandro.
00:31:57.920 - 00:32:07.908, Speaker A: I, in this case is sender. And then. So how is it generated such that child can actually send the acknowledgment?
00:32:08.104 - 00:32:47.836, Speaker B: Yeah. So basically the same thing which we have done here is repeating. Right, so basically, this key derivation, which is being done by chow, repeats. Right? So chow gets the packet. So chow again has an alpha, which is their alpha. So from that, he extracts this one, he gets this one from Dimitro, he gets this downstream thing and compares it to a value, which is signed off by the previous node. So what is actually happening here? Is that part of this payment information I just wrote Hopper here.
00:32:47.836 - 00:33:17.988, Speaker B: But what is actually happening is we are also sending a signature. I, as Betty, am signing off on the funds that I'm willing to transfer to chao, which is a signature, actually, over these values here. So over the hint over the amount and some other stuff that we can get to. And we're doing that because. And that's maybe the next problem. We don't want anybody here to modify the amount, for example. Right.
00:33:17.988 - 00:33:48.560, Speaker B: So we want, in this case, chow to be able to only extract two hopper and not an arbitrarily much higher amount. And since this amount differs, like, depending where you are in the route and potentially whoever send it, this amount is being signed off by Betty. And then the smart contract is basically validating that this hint is matching something that has been signed off by the upstream node.
00:33:50.580 - 00:33:53.840, Speaker A: How is this computed?
00:33:54.980 - 00:34:05.552, Speaker B: The hint is basically the s acknowledgment. So the s acknowledgment is not something that Betty knows. Right. Betty knows.
00:34:05.616 - 00:34:14.588, Speaker A: So how does Chow calculates it? So, for example, he calculated his. So he got the acknowledgment, and then he sends back, after already calculating this, he can send acknowledgment.
00:34:14.624 - 00:34:19.156, Speaker B: Yes, exactly. So the packet goes from Betty to Charles.
00:34:19.188 - 00:34:24.330, Speaker A: No. Yeah, understood. So he already receives his, like, s three act. Right.
00:34:26.000 - 00:34:27.352, Speaker B: That he gets from Dimitri.
00:34:27.416 - 00:34:32.700, Speaker A: Yeah. So he gets Dimitri. How does he send s to AK?
00:34:34.080 - 00:35:25.900, Speaker B: So basically, the entire packet gets, like, transformed. Betty calculates the alpha for Chow and forwards the entire packet to chow. And then the first thing that chow does before passing it on is get back with the s to ag to Betty. And Chow extracts this s two ag again by his alpha in a packet that he got from Betty, deriving the master secret, which was established with alejandro. But nice enough, chao doesn't know it was actually Alejandro. From that, he is basically doing a key expansion, and from this key expansion, he's getting the s two egg, which he knows. And in that case, alejandro knew already to send the hint value in a header.
00:35:26.320 - 00:35:33.756, Speaker A: I see. So I actually thought that s two arc actually contains in some way that actually delivered.
00:35:33.788 - 00:35:56.224, Speaker B: No, it's actually all derived from the packet. That's kind of the nice thing if you're thinking about it on a high level. Right. So the nice thing is that Betty will format, will forward the packet to chow. Chow will again check some stuff like, is this legit? And if yes, then get back, then send the acknowledgement. Exactly. So this is kind of neat.
00:35:56.224 - 00:35:57.350, Speaker B: And that this.
00:35:58.140 - 00:36:00.180, Speaker A: Why does Chow wants to send. Acknowledgment?
00:36:00.260 - 00:36:31.424, Speaker B: That's a really good question. What if Chow is not such a nice person and not sending this stuff back? That is a problem. But in that case, Betty would just close the channel because they would just assume Chow is offline. So it's the same as if Chow, like, from Betty's view, it's the same behavior as if Chow just dropped the packet. And in such a case, she would just close the channel and saying, you know, like, I don't play with you anymore because you never got back to me, so I'm not in business with you anymore.
00:36:31.552 - 00:36:36.384, Speaker A: So even though eventually I got charged for one of the messages.
00:36:36.432 - 00:36:53.912, Speaker B: Yes, it depends. This will depend a little bit how we see this thing happening in action. Right. So we will need to find out how bad is a free rider and churn problem here? And saying, maybe once I forgive you, but if you do it like, three times in a row, I'm just saying, you know what? Cut it.
00:36:53.966 - 00:36:59.724, Speaker A: Okay. Is there a minimum, let's say I want to be a child.
00:36:59.922 - 00:37:00.670, Speaker B: Yes.
00:37:01.200 - 00:37:05.484, Speaker A: Is there a minimum limits that you need to have?
00:37:05.682 - 00:37:24.980, Speaker B: No, not really. Well, actually, one thing that is the minimum is, like, for three hops, you need, like, three times the minimum amount of tokens that is required for one packet. It doesn't make sense to stake less, but that amount is super low, so there's virtually no minimum limit.
00:37:25.480 - 00:37:28.150, Speaker A: So I can't register, like a million of those?
00:37:28.840 - 00:38:28.132, Speaker B: You could, but there is basically a cost to that, which is the on chain transaction fee, and you block some capital. But in principle, you could absolutely do it. Now, the interesting thing is, let's consider that as an attack scenario, right? So let's consider you're launching a million nodes here, which are all symbols of one another, and kind of coming a bit to the trust assumption of Hopper. We are assuming that there's at least one honest and effectively mixing node. Now, if it's all you, I'm wrecked, right? So what do we do to mitigate that effectively? It's kind of hard, right? Because on the one hand, we want this to be a permissionless network. On the other hand, this is a problem. So in the path selection that is implemented, you are literally defining, who do I trust? Trust is something very subjective.
00:38:28.132 - 00:38:55.456, Speaker B: So we make it very easy for people to implement their own path selection strategies. The one that we have implemented so far is weighing the probability of selecting a node with the total stake that they have staked so effectively. Yes. You could launch another nodes, but I would only select one of them once in a blue moon. So that's how we defend against that one.
00:38:55.638 - 00:38:59.120, Speaker A: Okay, so it is kind of ish proof of stake ish.
00:38:59.860 - 00:39:31.980, Speaker B: It has some properties which are very similar to POS systems. Yes. Okay. There's actually some more problem that I think we haven't talked about. And that is the problem of I don't want, if I'm in this relationship between Betty and chao, if I'm chow, I don't want to be tricked into always receiving losing payment information. Right. So in just not winning something.
00:39:31.980 - 00:40:17.096, Speaker B: And another thing that we're doing here is we are actually not settling this every single time. What we're doing is probabilistic payments. Because, again, in this scheme, in a naive implementation, if you have 100% win probability, you see, okay, Betty is claiming something on chain Shao is claiming something on chain Dimitro. Let's assume this blockchain is, like super fast and stuff and doesn't cost us anything. Some blockchains like that are exactly. I have some in mind which are also EVM compatible. So the thing that is kind of interesting is in such a setting, we really want to make sure that this can be tricked.
00:40:17.096 - 00:40:45.140, Speaker B: So what we do is probabilistically, you would win once every million payment. Only you would receive a payout. So it's probabilistic. Now, if we make it probabilistic, it solves some issues in a. It doesn't disclose the path to the general public by onchain information. Two, we save a bunch of time and money because even the fastest blockchains are probably not going to be fast enough for kind of packet relay networks. So it's kind of two birds, 1 st.
00:40:45.140 - 00:41:27.164, Speaker B: But what we want to make sure is that this probability can be tweaked, and it shouldn't be tweakable from two sides. Betty shouldn't trick chao into chow always losing. Chow should not trick Betty into always winning the payout. And what we do for the one side is basically on this smart contract that you have here, you are basically committing a pre image. And this pre image is not known to the issue of this, we call them, by the way, tickets. So what you're issuing here is not a payment like, payment is something you know you will receive. It's more like a raffle lottery ticket.
00:41:27.164 - 00:42:07.804, Speaker B: Exactly. So when Betty is issuing a ticket for chow, this probability is containing an element which is only known to chow and not to Betty in order to not get tricked. So when chao is actually redeeming a ticket, he will provide the pre image to the image which is stored on the smart contract, which is basically just a hash. And then the smart contract evaluates, well, was this really a win or not? And this is information which is not known to Betty. It can also not be cheated by Chow because they committed to it ahead of time, and that's how we avoid this.
00:42:07.842 - 00:42:32.200, Speaker A: So, just practically speaking, Betty just generates number. Right? And then Chow has a committed to a hash of number of the child number, the Betty number. And so smart contract, when child actually finds the winning condition, is like mb plus mc modulo a million is zero or something.
00:42:32.270 - 00:42:42.984, Speaker B: Yeah, it's similar to that. Exactly. So the only thing is that this number is stored on a smart contract per each channel.
00:42:43.182 - 00:42:47.390, Speaker A: Per each channel. But when he wins, he submits a ticket, then he.
00:42:47.920 - 00:43:02.000, Speaker B: Exactly. He rotates it, which also means, by the way, just to come back to what you said, when you join the network, you basically pre compute a few of these hashes and commit this to the smart contract. We don't need to.
00:43:02.070 - 00:43:05.888, Speaker A: In each channel. In each channel, you have like, na one, na two.
00:43:06.054 - 00:43:07.792, Speaker B: Yeah, exactly.
00:43:07.926 - 00:43:08.610, Speaker A: Okay.
00:43:11.960 - 00:43:34.164, Speaker B: And in that way, we can avoid that. The ticket gets tweaked. Good. Okay. We talked about the probabilistic payments and what it solves. We talked a little about. A little bit about path selection.
00:43:34.212 - 00:43:38.270, Speaker A: So what if he just sends exactly the same number all the time?
00:43:39.920 - 00:43:45.260, Speaker B: The number is not chosen by Betty. The number is what Chow committed to this?
00:43:45.330 - 00:43:46.860, Speaker A: Well, the lottery ticket.
00:43:47.760 - 00:44:01.456, Speaker B: The lottery ticket is not actually a number that gets sent along there. What is happening there is actually. It only depends on the number that is here, along with a challenge, which is sent along with a packet. Yeah.
00:44:01.478 - 00:44:03.304, Speaker A: So how's the challenge formed?
00:44:03.372 - 00:44:33.740, Speaker B: So the challenge is actually formed by the sender, which is Alejandro, in this case. So Alejandro is providing the challenge for all downstream nodes. And then we combine this challenge with the hash that is only known to chow, and therefore, chow cannot tweak it because chao committed to it, and Betty doesn't know the pre image.
00:44:35.920 - 00:44:42.130, Speaker A: So how many Alejandra can just, like, what if I just send the same challenge all the time?
00:44:42.900 - 00:44:55.332, Speaker B: What if you send the same challenge all the time? The winning probability includes the pre image of this number here. So if you send the same number all the time, the randomness is influenced by what is locked here.
00:44:55.466 - 00:45:03.768, Speaker A: Yeah. So let's say this specific challenge does not hit anybody. And so I just keep sending it?
00:45:03.934 - 00:45:05.160, Speaker B: You keep sending it.
00:45:05.230 - 00:45:06.730, Speaker A: Might as they change this.
00:45:07.260 - 00:45:18.680, Speaker B: Correct. But, ah, okay, so we have a replay protection that does not allow you to send this challenge multiple times. So basically, yeah, you cannot.
00:45:20.140 - 00:45:24.110, Speaker A: This is like Alejandro's nons, and then they just. Yeah, okay.
00:45:27.540 - 00:45:31.570, Speaker B: Good. Maybe one thing to talk about.
00:45:34.020 - 00:45:34.288, Speaker A: On.
00:45:34.294 - 00:46:09.016, Speaker B: The network overview is a little bit, what is required for this to be private. So what is required for this to be private is that there's at least one honest node. So, not colluding with any GPA who has overview of the other parts of the network, or colluding with others as well, but also needs to be effectively mixing. So it doesn't help you if you have a good guy. Exactly. And you're the only one that utilizes this node. So what we're doing here is to launch this network, we are using something that's called cover traffic.
00:46:09.016 - 00:46:57.292, Speaker B: And what cover traffic is, is kind of fake traffic that is indistinguishable from real traffic. And. Yeah, the question when you introduce such a mechanism in an incentivized network is a little bit, well, who's paying? A, who's paying? And b, how do we incentivize it in a way that is kind of safe? So in the first version, what we're doing is, well, who is paying? We basically finance it from token inflation. So this is a little bit similar, if you want to think by analogy of like, block rewards. Right, so block rewards are basically like kicking off. Exactly. So when Ethereum launched, right, they were just empty blocks, but still, people would just mine their stuff.
00:46:57.292 - 00:47:49.068, Speaker B: Why? Because they got eth. And this is kind of a similar concept here on the COVID traffic. And in the first version, the interesting thing is not just as in a mining network, where you just need to think about who pays for it, but also who sends it. So the first version that we're having built right now, which is naive, is that's us. Hopper association is like blasting out cover traffic in order to bootstrap the network. Now, what's the problem with that? The problem is that in theory, Hopper association sees all these routes, so effectively, the COVID traffic is meaningless if you assume that Hopper association would be colluding with this network. So that's what we're looking in.
00:47:49.068 - 00:48:24.200, Speaker B: A v two, which is using a trusted compute setup, such as a trusted execution environment, or like some other multiparty computation schemes, which are allowing you to disperse this cover traffic in a fashion that you can a, not cheat. Again, if you send cover traffic all to yourself, that would suck. Right. And that two is still providing significant traffic for all the participants in the network in order to have effective mixing of all the nodes and participants in this network.
00:48:24.700 - 00:48:45.292, Speaker A: And you need execution environment because presumably it's going to be running on every of these nodes, but there's no way outside of execution, like a secure execution environment to actually create random path which they cannot route to themselves.
00:48:45.426 - 00:49:10.288, Speaker B: Yeah. So the cool thing this is, again, it's not built like this is a bit speculative here, but the cool thing about a GE is also you have actual deniability of knowing which route your packet took, which is kind of cool, right. So you can effectively do the entire packet formatting and send it out to the first node.
00:49:10.304 - 00:49:10.484, Speaker A: Sure.
00:49:10.522 - 00:49:59.380, Speaker B: You need to send it where you send it out to the first node, but afterwards you don't know where it goes. Right. Because what you get out of the TE is basically just like this box here, which is preassembled, but you can't make any use of that. Yeah. And maybe one other thing are these, these numbers which we put here, right. So whenever you have token numbers in there, the question is what happens if token goes ten, x or goes down -90% right? Yeah. So that would be a bit bad, right? Because if this just gets too pricey for people to utilize, then, yeah, it's just not useful anymore.
00:49:59.380 - 00:50:40.720, Speaker B: So typically what we see in decentralized networks when we have such issues, again by analogy, would be the block size, right? Or like some fees, some on chain fees that you have. You have a market model, right? So you have supply and demand, and somehow this system equilibrates itself. The problem is, in case of Hopper, we want to provide privacy. If you want to provide privacy, and we see somebody is sending like 1.11 tokens and the other one is always sending like two. You can pretty easily make out who was sending a packet if you observe their behavior. So we cannot use the typical model that's used, for example, for gas prices of transactions.
00:50:40.720 - 00:51:35.604, Speaker B: On the other hand, it needs to be dynamic. So what we're envisioning here is that there is some sort of a dynamic kind of voting system to adjust this price up or down, but this process must be slow. So it cannot happen like on seconds or minutes. But on weeks, every couple of weeks, there is like this thing can be adjusted up or downwards in order to make sure that the utility of the network is not in danger. Basically a badly behaving Betty, extracting too much money and sending out only one hopper is actually mitigated by having that embedded in the header information. So actually, apart from like part of this beta I mentioned that we have this hint in there already. Actually, also, the challenge which you mentioned is in there.
00:51:35.604 - 00:52:23.430, Speaker B: And what is also in there for every single one of them is an amount which every single one of the downstream nodes is expected to receive. So to prevent anybody from manipulating it. But again, you can only read yours. So if we're looking Again, back at these hatchings and how information is hidden, you can only ever read what is meant for you. So in the header, we have basically this trust anchor to say, okay, nobody was misbehaving before, and I will always extract the one. Like, for example, if I'm left with less than one, I wouldn't forward the packet, I would just drop it.
00:52:24.280 - 00:52:37.064, Speaker A: So how does, when you're submitting this to the smart contract with the challenge and your number, how do you submit the amount? Because you're submitting the.
00:52:37.262 - 00:52:38.888, Speaker B: You're submitting the amount.
00:52:39.054 - 00:52:51.710, Speaker A: The full amount that Betty said, which is like part of it. Like the Alejandro assigned to you, the amount that's for. But this is full amount.
00:52:53.200 - 00:53:11.780, Speaker B: Exactly. So what is received there in the payment channel is the full amount of two hopper. But this is something that has been signed off on by Betty. So Betty has provided a signature over this and plus some other values.
00:53:12.200 - 00:53:15.350, Speaker A: But this is probabilistic, right? Alejandro actually didn't pay.
00:53:17.320 - 00:53:33.012, Speaker B: Could happen. What could happen is that you're just damn unlucky. Right? So what could happen is that Betty didn't actually receive a payment, but she gets to pay chow. That is true. That can happen. But for time that should average out. That's basically by equivalence.
00:53:33.012 - 00:54:38.552, Speaker B: Like that lucky bitcoin miner with a USB miner was mining a block, maybe. One thing to highlight on this thing on a high level, is this a trade off, what we have in here? We talked about the delays in the beginning. We talked about this cover traffic and, like, the route here. So one thing that is interesting is that there's a fundamental trade off between strong anonymity, low bandwidth overhead, and low latency, right? So if you want to have something which has super high quality privacy, you would want each of these nodes to cache the packet for a long time, and you would have, like, a super long relay chain, right. But what it means is you would have a lot of bandwidth overhead for the network, which you have to pay for. And the second one is it would take longer. So what we want to do here is to basically make this configurable for the sender, Alejandro, so Alejandro can choose how many hops he wants to send.
00:54:38.552 - 00:54:54.710, Speaker B: Now, one funny thing is, since if we looked at this whole setup is in the sphinx packet format. We need to define a maximum number of hops in the network. So otherwise you could. Everybody sees what you're doing.
00:54:58.040 - 00:55:01.168, Speaker A: You should have, like, fast packets and slow packets.
00:55:01.264 - 00:55:20.716, Speaker B: Exactly. So we're thinking it's like having two tiers, right? So one is, like, for maximum three, and maybe one is for longer. But actually, if you look at the anonymity set, how it grows as you increase the root is actually like. It's flattening out somewhere. There's some analysis that have been done also there.
00:55:20.818 - 00:55:22.732, Speaker A: Seven is plenty for sure, actually.
00:55:22.786 - 00:56:08.816, Speaker B: Like, three is already pretty good. So that's also the reason, apparently, why Tor has a choice of three and not something much more, because it just flattens out eventually and doesn't add much. But what it does add is, of course, trust in each individual one. Right. So again, the anonymity set might not grow significantly, but what does change quite a bit is the likelihood that you have one node, at least in your chain, which is honest. It's just something that you, unfortunately, always have to consider, because when you use a network like Hopper, people are going to say, well, performance is poor. Well, yeah, that's because of this very fundamental.
00:56:08.948 - 00:56:15.160, Speaker A: What's the latency? Like you said, I mean, they cache it for some period of time. They send it in different order. What's the latency?
00:56:15.240 - 00:56:42.512, Speaker B: Yeah, so we are actually trying that out right now. So, right now what we're doing is we're having a fixed delay of a few hundred milliseconds. I don't remember the exact number. But what is interesting is actually, it shouldn't be just fixed. So there's some research. Exactly. There's some research going into that saying that you should ideally have some Poisson distribution.
00:56:42.512 - 00:57:45.020, Speaker B: Now, the interesting thing with a Poisson distribution is there's non zero probability. That's almost infinitely long. Now, an infinitely long latency is pretty bad. So what that means is there's inherent packet loss in such a protocol if you want proper anonymity. But again, that's something that is required because you want to have kind of deniability of what is going on. And, yeah, another thing to add there is on this cover traffic front, which is something that we're thinking about, is not just sending this linear flow that we have here, but there's, like, some other research where people, like, split it, where people loop it back, actually. So by doing that, by looping a small fraction of the packets back to you, you can observe what is going on in the network, and you say, hey, I receive fewer packets as I should receive per this distribution.
00:57:45.020 - 00:58:09.170, Speaker B: So probably there's something nasty going on, like somebody is deliberately trying to censor me, for example. So that is something that you can do in such a free routing scheme as we have with Hopper. So you can build a lot of other mechanisms on top of it, which is just part of your path selection. Right. So you use path selection however you wanted to in your application.
00:58:10.760 - 00:58:20.580, Speaker A: Got it. And then your kind of liveness mostly depends on pretty much peer to peer. If peers is not responding, you're just dropping them.
00:58:20.730 - 00:58:22.260, Speaker B: Exactly. They'll just lose.
00:58:23.000 - 00:58:25.028, Speaker A: People will just close the state channels.
00:58:25.204 - 00:58:25.736, Speaker B: Exactly.
00:58:25.838 - 00:58:28.180, Speaker A: Kind of slowly disappearing from the network.
00:58:28.260 - 00:58:45.852, Speaker B: Yeah, it's actually a pretty interesting design space that we have here with this incentives that we bring into such networks, because I'm not saying it's necessarily a great idea, but you could bring punishments. Right. So if you have too high churn like, churn really harms this network, people.
00:58:45.906 - 00:58:47.808, Speaker A: Close a lot of stitches at the same time.
00:58:47.894 - 00:58:56.130, Speaker B: Exactly. Or like if they were not online for long enough, or if downstream nodes didn't make any revenue, you can just punish it.
00:58:58.820 - 00:59:22.650, Speaker A: Some of the things are too easy to game and spinning out a bunch of channels and then dropping them. There's definitely a lot more things to innovate here. Awesome. Well, thanks for walking me through this. Very interesting. When are we seeing this in production? In browsers near you.
00:59:23.340 - 00:59:55.332, Speaker B: In browsers near you. So we are currently working on. So we are currently working on stabilizing the infrastructure layer. So basically making this network stable for node operators. Actually one thing that we didn't talk about, which is a big headache for us, we want to make this truly decentralized. So if you're using that from your home router, like from a laptop, between your home router and me also, and they should still talk to one another. Having that in a decentralized fashion is something that's not so easy.
00:59:55.386 - 00:59:56.736, Speaker A: Peer to peer connection.
00:59:56.928 - 01:00:27.100, Speaker B: So the whole NFT topic is a big one. Yeah. So we are actually right now having a testnet online that people can just play around with. And over the course of 2022, we want to bring overlaid features that you have from, I would call it more higher level protocols near you. So like TCP like features. When we have tcp like features, then you can build stuff like socket connections. And with that, off you go.
01:00:27.100 - 01:01:05.672, Speaker B: But we'll need the course of 2022 to build these overlay features in, so that you cannot just use it for trivial first applications that we're showing right now. So we have, like, this chat application how you can just send some stuff through it, but you want to get delivery guarantees. There's also another thing we didn't talk about this return path. Right. So how does Zoe send stuff back? So in Sphinx, it's, again, not something new. There's a very cool way of ensuring that you can, in a privacy preserving fashion, send stuff back. So Zoe can send stuff back to Alejandro without knowing to whom she's actually sending stuff.
01:01:05.672 - 01:01:12.952, Speaker B: So that's very, very cool. And, yeah, that's the roadmap for the year.
01:01:13.086 - 01:01:19.100, Speaker A: Awesome. Sounds good. Well, thank you. Check out Hopper, and. And see you for the next episode.
01:01:19.260 - 01:01:25.230, Speaker B: Thanks for having me here. Our.
