00:00:06.360 - 00:00:36.144, Speaker A: All right, welcome, everyone. Thank you for making it. I hope you're not everyone is as exhausted as I am with massive jet lag, so I hope you can still follow along. So, I'm Adrian. I'm one of the co founders of Anoma, and today I'm going to very briefly talk about moving from virtual machines to intent machines and sort of what the next step in the evolution of blockchains is and what this world will look like in the future.
00:00:39.844 - 00:00:40.724, Speaker B: Yes, great.
00:00:40.764 - 00:00:41.636, Speaker A: This works.
00:00:41.820 - 00:00:42.276, Speaker B: Cool.
00:00:42.340 - 00:01:30.260, Speaker A: So let's start with a brief historic recap of how we got to where we are today. And really here we started. I would call this generation one bitcoin. Bitcoin like architectures that were very transaction centric and had limited scripting capabilities. So as you heard before, this is starting to improve and so on. But really fundamentally at the base layer, Bitcoin has limited programmability, has only scripting capabilities, and so the kind of applications you can build on top of are limited. From there, we moved to this VM world where all of a sudden everyone and their grandmother started having a vm, right? This was started with Ethereum, and all existing architectures are pretty much actually, they are all vm centric architectures.
00:01:30.260 - 00:02:39.174, Speaker A: And this doesn't actually matter whether you're on an l two, or you're on a solana or near or ethereum or optimism or base. These are all fundamentally transaction centric virtual machines where end users are supposed to have fully fledged state transitions that can be immediately settled on chain. And so today I'm going to focus on talking about intents. And so what I foresee to be the next generation of architectures, which are going to be intent centric architectures, where users don't interface directly with the virtual machines, but rather with the intent machines as abstractions built on top of many different potential virtual machines. And this sort of, to give you a very brief conception, has humongous benefits from a user perspective. Because instead of saying, this is how I want to execute my compute on some virtual machine, a user can rather say, I'm currently at state a and I'd like to be at state b. Someone else please figure out how to get me to state b, where state b could be on a different security zone or a different blockchain altogether.
00:02:39.174 - 00:03:20.822, Speaker A: The user can just programmatically specify where they are and where they want to get to, rather than specifying how to do this execution. If you're into zero knowledge proofs, this will sound very familiar. This is one of the very fundamental reasons why you need intent centric systems in order to actually support programmable privacy guarantees, because without this, you can't really represent that if local state. And I'd like to transition this local state, um, to the next state. Um, yeah, so lots of people talk about intents all the time. Um, and so if you're following the modern discourse, you may think intents are just limit orders. And in a very limited sense, this is true.
00:03:20.822 - 00:03:50.334, Speaker A: Uh, limit orders are very specific kinds of intents. Um, so, like, when you think of something like a cross protocol, Uniswap X and so on, these are really limit orders. Um, what anoma is, and what we've been working on for a while now is this is a design for generalized intents, where intents can be arbitrary things. They can be literally arbitrary programs that control some amount of state on chain. Oh, I should actually follow along here.
00:03:55.394 - 00:03:55.746, Speaker B: Yes.
00:03:55.770 - 00:04:55.984, Speaker A: And so with this anomaly is a new paradigm for infrastructure. Um, we're evolving infrastructure from being blockchain and vm centric to being intent centric. Um, and really here, the interesting thing is many nodes may want to offer different kind of services to different users, and this is way easier. So, like, in the current model, this, a node has, or an infrastructure provider has to make a fundamental choice on, like, I'm either running this VM or that VM. In tencentric world, you can, like, you can be a solver, you can be a PGP gossip node, you can be someone that just allows users to access the chain. And another really interesting follow from this is that really, users are also blockchains. And this is sort of, I'll go more into depth here later, but currently we have this very strong abstraction between, here's a node and a client, right? Like a client acts with a node via some amount of RPC calls.
00:04:55.984 - 00:06:13.752, Speaker A: In an intense centric world with a nomad, this isn't the case. It just a user decides what kind of subset of node functionality they'd like to run on their local device, and they're just another node on the gossip layer. You do not have to have the problem of like, oh, I have to pick my specific RPC provider to send my transaction to you rather say, well, I'm directly connecting as my phone to the intent gossip network, and I'm gossiping to, I don't know, 50 different peers that I have received via some sort of trust metric that I care about, and I send them my intents. This is also how you get information flow control going sort of at the network level, where you have some metrics where you can decide, I'm willing to gossip to these five people, my intents, because intents will always reveal some amount of information, but not these other five people. Right? The other thing is builders. Once you start thinking about these systems from an intent centric perspective, you can think of decentralized counterpart party discovery and distributed solving. So one of the very, very difficult problems actually is how do you do decentralized counterparty discovery? And sort of like, our best answer to answer to this problem is either, well, we all put it on a single server and we all meet at that single server.
00:06:13.752 - 00:06:45.118, Speaker A: This is what every roll up currently does. Essentially, this is what most limit order protocols do as well, or you put it on chain. This is what uniswap fundamentally does. This is what amms do. Think of amms not as liquidity things, but as the place where multiple orders meet. But once you have intense the base layer doing decentralized counter, but your discovery actually becomes way easier because I can decide who I want to send my intents to. My intents are fully signed.
00:06:45.118 - 00:07:33.192, Speaker A: If they're two overlapping intents, anyone in the network can take them, combine them, settle them somewhere. Yes, and also I was saying sort of on novel properties with regards to information flow control, which is really think of this as how do you not disclose your entire transaction graph to the rest of the world? This is what information flow control is. You being in control, what kind of data you want to reveal to the outside world. This sort of results in one large challenge, which is currently all state lives on a global mutable ledger, right? This is why it's readable by everyone. If you want to not do this, we must move state to edge devices. This is sort of the entire idea with regards to zero knowledge proof set. You generate proofs over local data that is not shared with the rest of the network.
00:07:33.192 - 00:08:16.514, Speaker A: However, in a transaction centered world, this is very hard to implement because a transaction must be fully balanced. But I may not have the state, I only have the state to trade some ETH for near, not the inverse pair, right? So I need to be able to author my intent and attach a proof over this state transition. Not the fully balanced one, but rather my part of the intent or my part of the state transition. And then someone else can sort of take the inverse or take some combination. And then as any solver can pick this up and go ah, I have 10 knowledge proof here that authorizes ETH to near this price point. I have some other intent here from near to ETH. Let me combine these two things and then settle them actually on chain.
00:08:16.514 - 00:08:48.044, Speaker A: Yeah, and then really users. I was going on a little bit about this earlier. One of the big problems is that as a user right now, you think of execution traces. Really, this is what you do when you sign a transaction. As a user, you have to think of an execution trace. You have to figure out the optimal path that you want to take through the network, or you have to outsource this trust somewhere else. But this generally means you outsource also control over your assets to some other party.
00:08:48.044 - 00:09:25.100, Speaker A: And with intents, you get to this very nice declarative paradigm around. Instead of specifying computation, you specify state updates. And again, you don't care. This is also way easier or safer from a user perspective, because my parents will never be able to audit EVM bytecode. This is idiotic to assume this will ever be the case. But in the soft intent centric model, this declarative model, UIs can just show these are the keys that you're signing over to be updated. You don't have to understand how the EVM works.
00:09:25.100 - 00:09:46.984, Speaker A: This may not actually be executed on the EVM, because we actually splitting here intent split state and execution, so that the intent machine only defines a state layout effectively. And many different intents may have different vms under the hood, but as a user, you don't have to care as long as you have something that's state compatible.
00:09:49.264 - 00:09:49.736, Speaker B: Yes.
00:09:49.800 - 00:10:18.334, Speaker A: So anoma is an intent machine. This is really, if someone asks you what anoma is, say this. Anoma is an intent machine. And in all likelihood we will standardize at the intent layer, not the chain layer or the VM layer, because it's sort of along with this chain abstraction. It is really, this is fundamentally chain abstraction. This is how you abstract different chains away from the user. This is intents or the intent machine.
00:10:18.334 - 00:11:18.158, Speaker A: Universal intent machine gives users a single programmable API, or developers a single API to build applications against that are independent of specific vm specific execution environments. So I'm going to talk a little bit about multichannel atomic settlement. So one of the other very nice properties is that with the intent machine, you can get to a homogeneous architecture in a heterogeneous security model. So think of this security model as NIA and Ethereum have two different security models, right? A proof of authority chain run by the south korean government will have a different security model than Ethereum. Users may want, like essentially run things like, again, the example of my parents. My parents will want local sovereignty run by their municipality effectively. And with the intent machine abstraction we can get to the point where our applications can roam very freely between these different security models.
00:11:18.158 - 00:12:03.904, Speaker A: Because I am not bound to a specific cpu architecture, to a specific execution environment. Rather, I am writing an application, and everywhere the intent machine is available on many different execution environments, I now can run the same application and I can do composable things across many different execution environments. This also comes with IBC two. I will go a little bit more into the technical detail. Think of IBC two as synchronous IBC across heterogeneous trust domains. And so when you come from the old research way, you can also think of this as, to some extent as heterogeneous charting. The ability to have many different security models opt into shared blocks effectively.
00:12:03.904 - 00:12:34.870, Speaker A: So how many? Oh, I have three minutes. Damn. All right, some components here, the p two, p layer. This is sort of the first component in anomaly, which is a thing that no one in the space spends enough time on, which is networking research. It's not the sexiest thing. Everyone wants to work on fancy cryptography, but this is what fundamentally enables a lot of the distributed systems properties. And so in anomal, we have a globally sparse network of many different nodes.
00:12:34.870 - 00:12:59.460, Speaker A: These nodes can live in different trust domains. These nodes can run and offer different functionality. So for example 35 down here may just be a client. Actually, they may just be a phone that's connected via the p two, p stack to the rest of the network. 38. Here may actually be a very beefy validator node that is validating three different trust domains at the same time. Think of these trust domains as validating.
00:12:59.460 - 00:13:09.624, Speaker A: Domain two is near, domain three is ethereum, and domain one is solana. Think of it this way, many different nodes may opt into being connected to many different trust domains.
00:13:11.084 - 00:13:11.724, Speaker B: Yes.
00:13:11.844 - 00:13:31.444, Speaker A: And this is sort of how do you get this heterogeneity or the sovereign security domain setup where you may also have a domain here that's like the New York Stock Exchange run as a proof of authority chain by whatever financial regulator exists in New York. I have no idea. Plus the London Stock Exchange, sort of similar example, right?
00:13:34.464 - 00:13:35.248, Speaker B: Yes.
00:13:35.416 - 00:14:27.498, Speaker A: How does, if you have this kind of intent gossip layer, how do you actually achieve consensus over this? And this is Typhon. And you may have guessed I am not a native english speaker. And as a result, we never realized that this is not an english word. I thought typhoon was spelled this way. So this is typhon, which is effectively, if you are aware of tendermint consensus. For example, this is Typhon, is PBFT, and it comes with a system called camera chains, which allows you to have atomic cross chain communication. And I won't go into the entire thing in detail here, but essentially think of you have chain a in blue, or chain a in blue, chain b in green.
00:14:27.498 - 00:15:09.044, Speaker A: And both of these chains can opt into a shared synchronous block between them. For this typhon partitions the state on chain b into so state that's composable with chain B. And these blocks are just normal blocks. You get full synchronous calling composability, for example. So like I can have a contract from blue call into green and get a synchronous callback within the same execution or within the same block. It's not an asynchronous message passing style system if you don't want it. And then probably the heart of a noma is the anomal resource machine or arm.
00:15:09.044 - 00:15:55.656, Speaker A: And everyone always asks you, is it an account model or is it Utxo model? It's neither. It's a resource model. This is very important to understand. And resource models, the resource model is what allows us to have generalized intents. And really at a high level, you can think of a resource model as you have some persistent state and a arbitrary programmable resource logic attached to how you can update and modify that piece of state. And in that sense, actually, it's similar to your Utxo model. Well, in that sense it's similar to an account model, but in the sense it's also similar to a Utxo model, because resources are always spent, so you never modify them.
00:15:55.656 - 00:16:04.464, Speaker A: You just go, I have the resource that has some smart contract logic and I modify this to. I get a new pointer to a new resource though.
00:16:07.324 - 00:16:08.104, Speaker B: Yes.
00:16:11.164 - 00:17:02.174, Speaker A: And with this really we should be thinking more about chain abstraction. Most users will not want to be on any of the systems that are currently being built, because most users in most places one like local sovereignty. We've been living in this world for the last 20 years where we outsourced everything to three AWS servers run by three large us companies. Most users at some point will want local sovereignty over their data again. And this is really what chain abstraction allows without breaking composability across the entire stack. The last thing I would like to sort of highlight is if you follow, if you don't follow ETH research, you will have not noticed this, but if you do, and then if you don't, you should. Chris, my co founder, just published a new post on ETH research earlier today.
00:17:02.174 - 00:17:21.014, Speaker A: If this didn't make sense, there is a very succinct explanation of all parts of Hanoma with links to more underlying research and anomal research topics. You can also find the research forum there or the artist topics there. Yeah. And with that, thank you very much.
00:17:24.594 - 00:17:27.634, Speaker B: You, our.
