00:00:00.250 - 00:00:19.310, Speaker A: You. We have four different projects represented up here today. We have Justin Drake from the Ethereum Foundation, Chris goes from Cosmos, Alastair from Web three, and Ilya from near. Do you guys want to each take a couple minutes and introduce yourself? Justin?
00:00:20.050 - 00:00:24.880, Speaker B: I'm Justin Drake from the Ethereum foundation, mostly researching Eve two.
00:00:25.450 - 00:00:30.530, Speaker C: I'm Christopher goes. I'm the lead author on the inter blockchain communication specs for Cosmos.
00:00:30.690 - 00:00:40.662, Speaker D: I'm Ashley Stewart, lead scientist, whatever that means, at the Web three foundation, and I designing the protocol for polka dot.
00:00:40.726 - 00:00:45.210, Speaker A: Alastair, would you mind speaking slightly closer to the mic? Sorry. Oh, there we go.
00:00:45.360 - 00:00:54.010, Speaker D: Yeah, perfect. Hi, I'm Alastair from the Web three foundation. I sort of work on protocol design for polka dot.
00:00:54.910 - 00:00:58.030, Speaker E: Hi, my name is Ilya. I'm co founder at near protocol.
00:00:59.170 - 00:01:21.480, Speaker A: Perfect. Okay, so starting off, we're talking about cross app communication. What even is that? Does anyone have a quick definition of what we're trying to do here? I think most of us are familiar with Ethereum's smart contract model. Justin, can you put cross app communication in the context of smart contracts for us?
00:01:23.050 - 00:02:20.940, Speaker B: I mean, on e one right now, you have the idea of synchronous communication, which happens instantly. I think possibly for the purposes of this topic, we actually want asynchronous communication. And I think we also have a context where we have two apps which are separated by a boundary, and this boundary is relatively expensive. And one way that we cross this boundary is using the stateless model. So the stateless model is where there's some sort of light client's mechanism to communicate a route across the boundary, which could be a shard boundary or blockchain boundary or whatever, and then pass messages which are authenticated against that route using Merkel Pass, for example.
00:02:21.310 - 00:02:50.020, Speaker A: Okay, so we have smart contracts. They're separated by some major boundary, and there's many different ways to cross that boundary. I think each project here, except near and the e two, have different names for the boundary. I think near, we call it sharding. Can we compare for a second? Sharding to parachains, to zones. Does anyone want to.
00:02:50.550 - 00:03:32.990, Speaker D: Sharding and parachains are actually very similar. We call parachains parachains because they were all different, whereas sharded system should have been all the same thing. But it's sort of moving to the case where shards are actually a bit different. So shards and parachains are actually fairly similar. Ideas. I'm not sure we're really talking about anything different here, but zones are a fair bit different. But in all cases, we're basically dealing with a chain that does its own thing, but is also able to communicate.
00:03:32.990 - 00:03:54.680, Speaker D: We have our own blockchain with its own network of peers and nodes, and maybe different. So in our case, different paratheads will be running different code, but they're all part of a bigger system which coordinates them.
00:03:55.210 - 00:03:55.960, Speaker A: Okay.
00:03:56.490 - 00:04:28.530, Speaker E: I mean, I think important part about sharding is that, first of all, it's the same code that runs everywhere. It's kind of the same communities, the same validators, block producers, et cetera, versus with power chains, it may be different code, the block producers are different. There is maybe kind of a lot of differences that people can go and change consensus, right? And that is pretty different from how people think of sharding in kind of regular, I mean, both like regular database world as well as in kind of blockchain.
00:04:29.110 - 00:05:22.882, Speaker C: I think the primary difference between sharding, parachains and my understanding of execution environments and ETH two, and IBC and zones and Cosmos, is that all of those three assume a global topological view, at least held by some root chain or some master chain. And that view informs the security constructions of the whole system. And it has to be agreed on as some singular value at some point in time, whereas zones do not. So the security model of IBC, as we build it in cosmos, only talks about two modules or two applications on two different chains talking to one another. And what kinds of authentication and message delivery are needed to realize that? Which is sort of a weaker assumption, which means that you don't need to reason about the global topology. It can be changing. No singular entity needs to even know what it is.
00:05:22.882 - 00:05:30.086, Speaker C: But you can't make as many assumptions about what incentives might exist for other actors in your model.
00:05:30.188 - 00:05:44.810, Speaker A: Okay, so you're saying that where sharding is homogeneous, chains with a shared security model and parachains are heterogeneous chains with a shared security model, zones are heterogeneous chains with heterogeneous security models.
00:05:45.150 - 00:05:46.300, Speaker C: That is right.
00:05:46.910 - 00:05:47.466, Speaker A: Okay.
00:05:47.568 - 00:06:05.310, Speaker C: Or sort of, there must exist a minimal mutual comprehensibility for consensus authentication and for encoding of particular messages, but we try to keep that requisite agreed interface as minimal as possible.
00:06:05.460 - 00:06:14.690, Speaker A: Okay. So there has to be some way for them to talk to each other, but you don't necessarily know that the message coming in and out is good or is trustworthy.
00:06:15.990 - 00:07:15.442, Speaker C: I mean, you know what it means for it to be authenticated. So you have some light client algorithm of the other chain in IBC, and you have a way to use that like client algorithm to track the consensus and track whether a particular message was sent or received. But even in IBC, we separate understanding of consensus authentication and just sort of basic message delivery from understanding what the message itself means. So that means that if there are two smart contract e chains communicating over IBC, the base layers of those chains, which might just be execution environments, don't understand what the messages mean. Smart contracts can send different messages from one chain to other smart contracts or other apps on another chain. And it just needs to be the case, assuming you want a correct application, that the two smart contracts on each end, or two applications on each end of a channel understand the same message format.
00:07:15.586 - 00:07:59.000, Speaker A: Okay, so we're getting pretty deep into the weeds, I think. But generally speaking, all of these are different chains that are communicating, sending messages back and forth through some shared interface, right? Notably, all of these are asynchronous communication, which I think is necessary when things are on different chains in almost every case. So one of the defining features of ETH one is smart contract composability and instant cross contract communication. Why is the entire industry moving away from that?
00:08:00.490 - 00:08:02.070, Speaker B: Because we have no choice.
00:08:02.970 - 00:08:15.302, Speaker A: So it just doesn't work, doesn't scale, doesn't scale. So we're kind of all unanimously agreeing that there is no scalable system with synchronous communication.
00:08:15.446 - 00:08:23.338, Speaker D: Not if you want to alphrat the contracts on ten different chains at once with any combination of ten of your 100,000 shards.
00:08:23.434 - 00:08:41.506, Speaker E: No, I mean, the alternative way is pretty much putting humongous clusters of computers that have a trusted setup between each other and pretty much execute everything in parallel with kind of, some type of merge, conflict resolution type of thing.
00:08:41.608 - 00:08:42.642, Speaker A: So go ahead.
00:08:42.696 - 00:09:18.750, Speaker C: I mean, I would qualify a little bit. I would still expect there to be some synchronous communication occurring right now in our implicit model of apps. I think we're thinking of apps as synchronous. That may not be true either. Like a single app may have parts of its code on different shards and itself execute asynchronously, or be running in different threads on a validator machine. I would expect there to be synchronous execution environments where some apps that interact with each other all the time end up living, and then sort of the more expensive communication boundaries have to be asynchronous and will be used more frequently.
00:09:21.730 - 00:09:30.194, Speaker A: I think that's a huge departure from the current model of a smart contract, right? Isn't that fair to say?
00:09:30.232 - 00:09:45.814, Speaker D: Yeah, it is a bit. And I'm not even sure if cross app is the right word, going back to the original point, because often it will actually be the same app running on multiple chains. That's talking to itself. Like we have one token on 100 chains and only one of them is allowed to mint it. Something like that.
00:09:45.932 - 00:09:48.680, Speaker C: But is that then one logical application?
00:09:49.290 - 00:09:55.958, Speaker A: Well, I think it's very difficult to say what an application is. Well, yes, I don't want to get into the semantics and ontologies.
00:09:56.054 - 00:10:06.670, Speaker E: We can call them services like we do in kind of microservice web two world where there's a ton of services. It may be one big application, and they all communicate asynchronously.
00:10:09.490 - 00:10:29.160, Speaker B: I guess one way to potentially escape the asynchrony is to go with optimistic strategies, where you have some sort of entity that's more powerful than a single chain and can observe multiple chains at the same time and can place bets as to how they will all behave together.
00:10:30.650 - 00:11:25.000, Speaker A: So you're kind of talking about like credit markets there. If there's some entity that's observing multiple chains and seeing message emitted on chain A and taking action on chain B, they're kind of issuing the sender on chain a credit, right. They're taking action on their behalf and expecting a future payment for it. Okay, interesting. So how would a system like that handle error cases or unrolls? We still have no idea how state progresses between multiple chain systems. In practice, how does sharded smart contract handle the error case where the message on shard a never shows up on shard B or gets excluded from the chain and another history goes forward?
00:11:26.010 - 00:11:44.720, Speaker B: I mean, this is where a lot of complexity creeps in. So you're trading off potentially good things like low latency and resemblance of synchrony for lots of complexity in the tell risk, where you have to start rewinding things and going back.
00:11:45.970 - 00:11:46.382, Speaker E: Yeah.
00:11:46.436 - 00:11:59.346, Speaker D: So we try to design our system so that this doesn't really make sense because messages should be able to get passed from one block to the next, and reverting one thing will revert all.
00:11:59.368 - 00:12:46.146, Speaker E: The message pretty much. You still want a synchrony at some point. And actually, the faster you can do the synchrony, the faster you can kind of progress the whole system. And then if there's any invalid, either state transition or something got missing, you revert the whole kind of chain. So I think in this sense, Polkadot and how we're designing is pretty similar, where you pretty much from perspective of a user, they need to observe the relay chain, or in our case, just the chain. And then if there's something wrong with one of the subchains or shards, you just kind of just reverse up to the point and recover from there. From this perspective, it's the same as observing ethereum, right?
00:12:46.328 - 00:12:52.466, Speaker A: So generally speaking, if there's an error, we reverse that shard to its last finality point.
00:12:52.568 - 00:12:54.130, Speaker E: No, we need to reverse the whole system.
00:12:54.200 - 00:12:54.850, Speaker A: The whole system?
00:12:54.920 - 00:12:57.478, Speaker D: Yeah, that's what Hamza Polkadot. We reverse the whole system.
00:12:57.644 - 00:12:59.634, Speaker A: Okay. Every parachain.
00:12:59.762 - 00:13:04.246, Speaker D: Every parachain. When you revert the relay chain, you revert every parachain, okay?
00:13:04.348 - 00:13:10.218, Speaker E: Because otherwise somebody minted a billion tokens on one chain and sent it everywhere else.
00:13:10.304 - 00:13:14.170, Speaker D: It's a much more synchronous model than cosmos.
00:13:15.310 - 00:13:22.410, Speaker E: And that's why you need to synchronize as fast as possible. Otherwise, kind of. And verify as fast as possible.
00:13:22.480 - 00:13:27.920, Speaker A: So when we say synchronize, we're talking about achieving system wide finality as fast as.
00:13:29.010 - 00:14:07.546, Speaker D: No. So the idea is that we're going to communicate faster than finality. In Polkadot, basically every relay chain block contains headers for some parachain blocks. These blocks happen according to the point of view that relay chains sort of synchronously. But we can revert the entire relay chain in order before it's finalized. And we really want to do this because we can't check. We're not sure if entirely sure if any of the power chain blocks are actually correct the first time we put them in.
00:14:07.648 - 00:14:13.210, Speaker A: Right, because you can't have the relay chain validating every block of every parachain.
00:14:13.290 - 00:14:18.442, Speaker D: Well, the relay chain validators do, but only 100th of them misses 100 parachains.
00:14:18.586 - 00:14:27.582, Speaker A: The same as the beacon chain validators in ETH two. Right. Only a subset of the validators validate each shard.
00:14:27.726 - 00:14:36.760, Speaker B: Yes, but it's a statistically representative subset, so you don't really have that much of a security reduction. It's almost equal in security.
00:14:37.130 - 00:14:38.658, Speaker E: So what is expected?
00:14:38.754 - 00:14:49.690, Speaker C: I would challenge that. What if there's optimistic bribery? Or what if there's, like, someone bribing the set of validators who happens to get elected? I think you have much lower security.
00:14:49.840 - 00:14:54.700, Speaker B: Well, yeah, basically we have assumptions on how adaptive the attacker is.
00:14:55.790 - 00:15:03.310, Speaker E: Okay, just for clarity, how many likely validators do you expect on beacon chain?
00:15:06.450 - 00:15:12.790, Speaker A: How many validators will there be on the beacon chain? And how many validators will there be validating an individual shard?
00:15:12.970 - 00:15:28.806, Speaker B: So on the beacon chain, there's everyone, partly because having everyone participate helps with the finality gadget. And then on individual shards, you have much smaller committees on the order of 256 validators, let's say.
00:15:28.908 - 00:15:35.666, Speaker A: Okay, and then a lot of this discussion I know doesn't apply to cosmos because there is no nothing blocks.
00:15:35.698 - 00:15:42.326, Speaker C: We never block. Blocking sounds hard. It does give you nice properties though. But when you don't know the topology, you can't block.
00:15:42.438 - 00:15:48.166, Speaker A: Right. There is no beacon chain or relay chain or master zone.
00:15:48.278 - 00:16:22.550, Speaker C: So to be honest, we don't have a good answer for this question yet. But one thing that might happen, and that does seem to offer some nice properties, is that the risk of reversions will just get priced into assets so that there will be some very fast confirmation version of a peg token, and there will be some very slow confirmation, but more secure version of a peg token with the challenge period and other mechanics. And there will exist a float market between the two tokens at like 0.9 and nine to one. So if you want faster transfer, you can pay somebody else to take the risk.
00:16:22.970 - 00:16:27.800, Speaker A: Okay, so you expect the free market to solve a lot of these problems for you.
00:16:29.290 - 00:16:59.458, Speaker C: Um, I would say the question that I would be interested in the answer to, because it will determine like which of these models works well, is sort of what are the costs of dealing with this in system versus dealing with it at the application layer in a market? And dealing with it in system imposes more costs on the system design, more constraints on the system design, but it makes it arguably easier for application level security properties to be reasoned about.
00:16:59.544 - 00:17:07.142, Speaker A: Okay, so how much of the complexity of implementation are you passing off to the developers of applications rather than the developers of the system?
00:17:07.276 - 00:17:23.050, Speaker E: Yeah, I mean, that's pretty much general question. How can we make sure that developers who are now building on Ethereum can actually transition to these new systems without totally throwing away everything they learned, but instead applying some of those principles?
00:17:23.950 - 00:17:59.560, Speaker B: I mean, one thing that should be noted is that even if the consensus layer designers try to make it as easy as possible for DAP developers, that's usually in the best case or the average case, or the optimistic case. In the worst case, these systems just fail pretty badly in similar way. And so I guess you also want to try and. Well, I guess one possible consequence of that is that as the industry matures, we're going to have all the complexity from the market anyway, as a kind of second layer of insurance, as it were.
00:18:01.210 - 00:18:45.474, Speaker C: I was just going to say another question that I'm interested in the answer to, and I don't know it for some of these systems, but in IBC we're spending a lot of time thinking about fault containment. So if some part of the graph of interconnected applications fails. And so like Prince token, say that's a very easy case, what happens? What other parts of the system does it impact? Where can you contain it? And so we're trying to put in a fair amount of containment at the application layer, like tracking, basically, we know you have this kind of dividing line between chains or consensus algorithms or even applications tracking asset flow or tracking value flow at that boundary. And then you can contain faults if you have some priori assumptions about what the asset flow could look like.
00:18:45.592 - 00:19:32.850, Speaker E: But this is pretty much the whole thing. Why at least from me, the benefit of blockchain is that it's handled for developer on the blockchain level, right? You're pretty much saying that, oh, now an application developer need to actually handle this kind of cases themselves as pretty much building up their own consensus or their own market around incentive structure around this, right? Building up some kind of insurance structure in this versus if you think of like, hey, I'm building a game or I'm building a DFI application, I want to really focus on the game design or the economic design of my application. Budgeting in this complexity becomes like ten times more work from perspective of building applications.
00:19:33.430 - 00:19:40.578, Speaker C: Yeah, I mean, one application developer has to reason about it. Other people can use that application. Just like one token developer deploys a token.
00:19:40.674 - 00:20:13.434, Speaker A: I think Justin pointed out a little earlier is in the happy path. We get rid of a lot of that complexity for the developer, but many attacks on smart contracts and many issues with them, and issues with L2 security models come from the applications developers not understanding the chain's assumptions. Right. Not understanding the consensus layer well enough. So do you really think that we can remove that complexity from app developers, or do they need to understand chain internals to be an effective blockchain?
00:20:13.482 - 00:20:44.086, Speaker D: App developer, we'd really like for them not have to do that. Right. This is why Polkadot, we're trying to go with a simple system where every chain has the same security. And ideally when you're communicating, you'll have the same code on both sides. So instead of having a standard for message passing, you'll have the same code on both sides. And we're trying to get a mechanism where you can upgrade, where if you upgrade this code, it's simultaneous. So in this case, we basically have something that acts like one app across many chains.
00:20:44.086 - 00:20:57.070, Speaker D: It'll be the same code, but each chain will have its local state. And you might use this, say if you have an app on one chain, you provide an app in every other chain, that will abstract away the communication across the chains.
00:20:58.050 - 00:21:10.734, Speaker E: But how does it work? If one chain is Dex and another one is like a game? They're not a smart contract platform. They're just like literally special case customized consensus chains.
00:21:10.862 - 00:21:12.980, Speaker D: Sure, but what's the communication between them?
00:21:13.510 - 00:21:16.962, Speaker E: I want to trade my game asset on a Dex.
00:21:17.106 - 00:21:26.470, Speaker D: Then you'd probably be using some sort of appy on your own chain on the game chain, which will be using code that was written by the Dex chain.
00:21:28.970 - 00:22:04.078, Speaker C: So the advantage of unified security models is that it's easier for developers to reason about. I agree with that, but one concern I have is that it will lead to, in some cases, security models being mismatched with applications. I think this is the case for some larger Ethereum DApPs at the moment, like say, maker. If you use Maker, you're paying for the security of Ethereum, but you're getting the security of MKR. And if the usage of MKR or the market cap or some relative value of that exceeds Ethereum, it starts introducing really weird incentives.
00:22:04.254 - 00:22:20.246, Speaker A: I'm going to get one step more controversial, because I like having opinions. When you're using Maker, you're getting the security of the medianizer, not MKR. That's the bound on your security is how strong is their centralized oracle?
00:22:20.358 - 00:22:21.420, Speaker C: Yeah, that's true.
00:22:22.430 - 00:22:36.240, Speaker A: So would you say in Cosmos, app developers get the ability to choose their own security model, whereas in other multi chain ecosystems they get the chain security model?
00:22:38.370 - 00:23:02.950, Speaker C: I think that can be true. To be honest, I think these protocols, especially Cosmos, and any of these other three are very complementary. IBC will allow near to bridge to polka dot to bridge to ETH, two to bridge to the cosmos hub. That's fantastic. Maybe there will be some applications which need their own zones. I think maker is a good example, and I expect there will be many that don't.
00:23:04.090 - 00:23:12.860, Speaker A: Okay, so on that note, IBC will allow everything to bridge to everything out. Right? Why is that?
00:23:13.390 - 00:23:28.030, Speaker C: Because we cheat and we define an interface instead of defining the implementation. So IBC says there exists a light client, and then we say that everyone has to write their own lite client and we assume that it exists. So if you have a light client, you can use IBC.
00:23:28.610 - 00:23:40.098, Speaker E: I mean, I'm really interested about Ethereum light client that you guys are obviously writing right now. Right? No, Ethereum 1.0 ETH 1.0. Yeah, because that light client is.
00:23:40.264 - 00:23:45.170, Speaker D: Yeah, I was talking to James about this recently. Yeah, I don't know if you can answer this one.
00:23:45.240 - 00:24:00.234, Speaker A: This is something that I work on. So we write bitcoin light clients typically, but we're also looking at an ETH 1.0 like client, and ETH hash is a mess and is very difficult to do inside of a consensus process.
00:24:00.432 - 00:24:08.940, Speaker E: And as the expectation is, I'm assuming for East 2.0, the aggregation of public keys will be pretty expensive. Probably for us too.
00:24:09.890 - 00:25:12.346, Speaker A: It really depends. We can get into the mechanics of light clients another time. I know we only have like ten minutes left because I know we're all super interested in light clients. That's what we all spend all of our time doing. But let's take it back to the average app developer for a second. Right now, one of my main issues with writing Ethereum smart contracts is fees and metering, and I feel like this is going to grow exponentially more complex in a multi chain ecosystem. So, for example, if my app on shard A sends a message to parachain B transiting through zone C using IBC, of course, because we're in the nice future world where everything works, who pays fees at each step and how presumably each of these is going to have a different fee asset.
00:25:12.346 - 00:25:19.220, Speaker A: Because this is a completely heterogeneous ecosystem. Do we have any idea how developers are going to handle that?
00:25:20.790 - 00:25:21.858, Speaker D: This is hard.
00:25:22.024 - 00:25:23.058, Speaker A: This is hard.
00:25:23.224 - 00:26:11.010, Speaker E: I can say for homogeneous environments, the idea is to kind of maybe underprice or overprice sometimes, but make sure that developers can kind of buy in gas or whatever fees on the entrance and then do not need to kind of handle or care about as it progresses through the system. Because if you think of it and you have like 20 steps of asynchronous communication between apps, the complexity of trading and having different prices on different shards, et cetera, will kind of kill everybody. Just building an application where some other application needs to buy in some more gas because it's like run out of gas halfway through. That's kind of very complex problem.
00:26:11.160 - 00:26:31.850, Speaker D: Yeah. So one thing about Polkadot is we don't necessarily have metering internally. Different chains might not have metering, some chains will have different metering, which makes it more complicated. But hopefully, I don't know if Polkadot or Cosmos will end up standardizing on dots and atoms for paying for things, but then you have to get the representation.
00:26:32.510 - 00:27:05.460, Speaker C: Definitely not, because to go back and answer the question, I think fees will be relatively easy if the protocols consider fees before they set their code in stone, and extremely hard if they don't. So in the case of the Cosmos hub, the Cosmos hub intentionally intends to accept many fee tokens and kind of offload the work of the user paying the transaction and multiple fees to validators converting fee tokens in batch later, which makes much more sense.
00:27:05.990 - 00:27:09.494, Speaker D: But how do you price it? Yeah, that's a hard bit then.
00:27:09.612 - 00:27:21.530, Speaker C: Yeah, it's a hard bit, but it can still be done by a validator set or like in protocol of a chain instead of by every transaction author every single time they send a transaction.
00:27:22.910 - 00:27:32.074, Speaker E: But I mean, as a developer, I need to write some code that in the front end will decide how much of which token to attach to transaction.
00:27:32.122 - 00:27:32.526, Speaker D: Right.
00:27:32.628 - 00:27:53.780, Speaker E: So I need to actually know the exact procedures that validators use or use a ton of APIs, which now become like a point of centralization like gas station right now, where you kind of can be now attacked by actually mispricing it or even just jacking up the prices and spending lots of money.
00:27:55.110 - 00:27:55.954, Speaker A: Good.
00:27:56.152 - 00:28:42.450, Speaker B: Yeah, you're right. The complexity of gas markets are going to increase. One thing that was mentioned is that each chain will have its own gas market. But then also from a UX perspective, do you really want to have tokens in every of these chains? And how do you deal with change, for example? That's also one of the strategies that we're taking in e two is to push away this logic at the application layer. So in a way we can't get it wrong at the consensus layer. And there's a room for experimentation and standardization and having it evolve. There's room for even gas abstraction, where for example, if you're making a transfer in a token, maybe you can also pay the gas in that token.
00:28:42.450 - 00:28:54.550, Speaker B: There's also ideas around prepaying gas ahead of time. So that would hedge against the volatility in the future on these markets.
00:28:55.850 - 00:29:06.010, Speaker A: How is gas token doing these days? I don't know, sorry. Gas token is an Ethereum one project that prepays gas fees.
00:29:07.390 - 00:29:11.466, Speaker E: I mean, people mine a ton when prices were low and now they're using it.
00:29:11.568 - 00:29:22.560, Speaker A: Yes. Okay, so I kind of like Chris and Justin's answers, because as an engineer, my favorite kind of problems are somebody else's problems.
00:29:26.470 - 00:29:29.954, Speaker E: And as application developer, also someone else's problems.
00:29:30.072 - 00:29:56.534, Speaker A: Yeah. So I think it's really interesting that we still don't have clear pictures of how fees are going to work in these systems. We know that it's going to be easier on the homogeneous systems, on the sharded systems like near and like ETH two, and we have various ideas on how to tackle it. But is it fair to say that there's no clear picture of fees in any of these ecosystems, we have clear picture.
00:29:56.582 - 00:29:58.538, Speaker E: It's implemented on GitHub right now.
00:29:58.624 - 00:30:01.420, Speaker A: Okay. So we can all go check out what Nier is going to do.
00:30:01.790 - 00:30:53.302, Speaker C: Yeah, I mean, I think the other part to consider is that there are different actors in play here. So the kinds of users sending transactions between different tokens or a Dex are very different than the custody providers who might be transferring large amounts of funds across chains according to security model evaluations. We're solving different problems for different people. And I think it will be the case that the cost of these barriers between chains, which ranges on some continuum from zero in a synchronous system to low in a homogeneous sharded system to medium in a heterogeneous sharded system to as high as possible in IBC made lower by good light clients will affect what kinds of transactions take place across those boundaries, what kinds of amortization of transfers being scheduled and batched occurs, that sort of thing.
00:30:53.376 - 00:31:10.626, Speaker A: Yeah, that's really interesting to me because it implies that developers need to understand the limitations of the system that they're building on when they decide where to build their application. Justin, I know you have to get going pretty soon. Anything you want to say and kind of wrap up and then we'll go.
00:31:10.728 - 00:31:12.174, Speaker B: One quick comment on this, Fred.
00:31:12.222 - 00:31:12.820, Speaker A: Okay.
00:31:14.230 - 00:32:15.494, Speaker B: If we have lots of complexity at the gas market and we have abstraction and we have lots of different standards being used, and we might make it very difficult actually for the process of block proposal to happen kind of efficiently. So as a validator, when I create a block, I want to try and choose the transactions in such a way that I maximize my fees. But in order to maximize my fees, I need a whole team of PhDs to also include things like front running on Dexes and whatnot. And one potential way this could evolve into is basically a relayer market. So you have relayers which create really optimal blocks, and then they basically sell those blocks to validators who will include them on the blockchain. And that's potentially a centralization point.
00:32:15.692 - 00:32:30.380, Speaker A: Outsourced block production. Yeah. Interesting. Okay, so that wraps up the fee discussion. We're going to wrap up the panel. Anything you want to say, like in conclusion about e two or your work?
00:32:32.610 - 00:33:11.814, Speaker B: Um, we're getting there eventually. You know, it's, we've been working on it for years, but it's, we can see the light at the end of the tunnel, you know, now starting to work on phase one. And phase two, we have this exciting potential, significant simplification of phase one and I guess for phase two, we might be in a luxurious position where other chains such as Nier are basically launching before us and taking on the risk of experimentation. So I'm looking forward to learning from them.
00:33:11.932 - 00:33:14.540, Speaker A: Awesome. Christopher, any last words?
00:33:16.590 - 00:33:41.380, Speaker C: I would emphasize what I mentioned in my talk at Devcon, but it bears re emphasizing that most of these protocols we're designing I think are non contentious. They can become benevolent monopolies. They're not like tokens. There isn't a finite amount of protocols that can exist. And once something like some analogous protocol to the Internet protocol becomes standardized, it just makes everyone's lives better. So we should work together.
00:33:42.070 - 00:33:49.560, Speaker D: Fortunately, we're a bit scared that there is a finite amount of security out there.
00:33:50.010 - 00:33:50.566, Speaker A: Interesting.
00:33:50.668 - 00:33:55.126, Speaker D: So that's why, yeah, we go for shared state, shared code, shared everything if possible.
00:33:55.228 - 00:33:58.166, Speaker A: Cool. Any other closing notes about polka dot and web3?
00:33:58.348 - 00:33:59.480, Speaker D: That was it.
00:34:01.690 - 00:34:03.254, Speaker A: Any final words about me?
00:34:03.372 - 00:34:07.720, Speaker E: I'll actually have a quick presentation, so if you stick around, you'll learn more.
00:34:08.250 - 00:34:08.902, Speaker B: Great.
00:34:09.036 - 00:34:10.238, Speaker A: Awesome. Thanks, guys.
00:34:10.364 - 00:34:10.780, Speaker C: Thank you.
