00:00:06.400 - 00:00:29.074, Speaker A: Hi, I'm here again. My name is Farat. I'm a bit jet lagged, so if I make any mistakes. Sorry about that. Today I'll be talking about bridging the multi chain divide account aggregation, account abstraction, whatever you want to call it, and gas related solutions. Let's see. So I think the main topic of today was that web3 has a fragmentation problem and usability problem.
00:00:29.074 - 00:01:13.544, Speaker A: Especially with all these Altus coming out that are scaling Ethereum and block and bitcoin. There's a lot of different accounts. And as a user I just want to do something. Let's just play a game, do a swap. Doesn't matter what it is, but when I go into this, it's not really usable and it's really fragmented. So as you've seen this before, what we're trying to do is we're trying to build these primitives at Pagoda to allow one account to control multiple accounts in multiple chains, so that the users don't really need to worry about changing networks, keeping a lot of different accounts and different wallets. And we're doing this through a technology that we call chain abstract, not chain abstraction.
00:01:13.544 - 00:02:07.278, Speaker A: Chain signatures, where an account can sign an arbitrary payload, define what the network they want to and the derivation path and in the message, and send it to the validators of this NPC network to sign it for them and to send it to the other network. And now we're going to kind of dive deep into some parts of it. I'm not going to go too much detail on chain signatures. I'm going to be more focusing on how the gas is being handled. But let's take step by step. So at a high level, what happens with chain signatures is that a user has, in this scenario, let's say a user has near and ETH right on these chain signature accounts. They send a payload to chain signatures, they sign a transaction, chain signature signs this transaction back, and then the user through their wallet can send their transaction to the foreign chain.
00:02:07.278 - 00:02:31.042, Speaker A: Let's say for now it's ETH. And in this case they have near and they have ETH on this chain abstraction account, chain signature account. So they can immediately send it. And then everything goes well, the transaction gets in profit. We're happy. So the problem happens when the user only has near and wants to take an action on ETH. I'm a user on near Isa.
00:02:31.042 - 00:03:27.824, Speaker A: I want to send a transaction to ETH. I only have near. What happens? Who pays for this? Right? Because if the transaction goes to Ethan, then if the user doesn't have any ETH, the transaction is going to get rejected. And also, if I do this, who makes sure that the transaction actually executes? There has to be some kind of infrastructure that says please take this signed payload and send it to the other side. So what we're working on right now at Pagoda is this system or this infrastructure that we call gas station contract and multi chain relayers and now we're in the first iteration of it. So what happens is the user has 0.5 near, for example, and has a payload and then basically defines how much gas it's willing to spend on BNB or ETH and it sends to the gas station contract.
00:03:27.824 - 00:04:28.414, Speaker A: The gas station contract right now is almost like a, almost like a market maker of some sort, where it calculates how much near it would want in terms of how much x per gas it will give it to you if it said, if it finds it feasible for it. What it does is it sends the payload of the user to the chain signatures and it also sends a payload that says that I will fund this transaction on either side. Both of these payloads return back, and in a multi chain relay, which is an off chain component, listens to these transactions. Its only job is to make sure that theres no nonce problem when youre sending the transaction across and it sends the transaction across. So what happens is then is that you as the user dont have to do anything. You just say heres my five NIR, take this and then please send it to the other network and pay my gas. Right.
00:04:28.414 - 00:05:23.054, Speaker A: What happens is then is that the multi chain relayer entity, let's say, operates all of these infrastructure for you and then accepts or rejects your transaction based on the rules that it defines on the gas station contract. It could be I will only cover the gas if the user is sending a transaction to a specific smart contract on ETH. It could be I will only send a transaction five times from this user. It could be I will only send this transaction if you pay me this amount of upfront costs so that I can remain this infrastructure running. This is the current structure. The current structure that is right. Now, if you go to GitHub near protocols repository and go to multi chain relayers and gas station relayer repositories, you will be able to operate all of this.
00:05:23.054 - 00:06:31.544, Speaker A: There's an additional part to this where we're also introducing to decouple the gas station contract from the user's keys, which is an NFT contract where you can give the ownership of the NFT to a gas station contract, which means that they can use that key, that they can use your ETH key for a limited amount of time if they give you the ownership back. So the good side of this is that, like I said, the extension is NFT extension for ownership transfers. And also on top of paying with near, you can also pay with any near FT. So it doesn't have to be near. You can pay with sweat, you can pay with other tokens that you own near. Like I said, Multichain relay will at launch will provide, at least for now, let's say we'll provide support for BNB and ETH and it will be used to order non skewed to make sure that the transactions eventually make it to foreign chain. Eventually.
00:06:31.544 - 00:07:40.014, Speaker A: What we want to introduce, which I will go into detail, is introducing account abstraction on each side, which will increase the capital efficiency because then you will have a pool on the ETH side so that you don't have to send this ETH to the account every time that they want to take a transaction. And a nonce control can be also done with account abstraction on the ETH side. So there's the other thing that we want to work on going forward is the trustless execution. How do we make sure that transactions actually happen on the foreign chain? Right now we just send it and then you assume that it happens. But for the contract to make sure that they can act, for the user to make sure that the contract or the multi chain realtor actually did their job, there has to be some kind of a proof on the near side that says oh yeah, this transaction actually got included and then we're looking to use like clients to do so. Running a like client on Nearside for ETH or any chain that we want to support to say that hey, yes, this transaction actually happened on the foreign chain. We would also like to introduce the retry mechanisms based on slippage.
00:07:40.014 - 00:08:59.054, Speaker A: If the slippage is too high, maybe you want to try and end the transaction without actually paying too much difference in the gas fees that you first defined. And also if it doesn't go once, maybe you want to send it again to make sure that the transaction actually executes. So the next stage for this is to say, why stop with gas? So now we're only supporting funding on the foreign chain for gas, but there's a world where you should be able to say, I want to give you just five nir and I want you to swap me as much as you can. Right? That's what we're going to be working coming soon we're going to be working on basic swaps and almost have like a cross chain Dex aggregator or near where you would go and talk to this contract and say, I have five near go find me the best Dex on any chain that would give me ETH. So this sounds like something that the industry is working on. It is not yet where we are and where we want to go. And I saw the founder of anomaly somewhere around here.
00:08:59.054 - 00:09:39.604, Speaker A: Oh, right there. They're putting a lot of work into this. Intents, right? What are intents? It is basically when you want to say something like, I give you five near find me the best deal for swapping with maximum ETH, or I give you five near buy me that NFT. I don't care where it is, I don't care how much it's going to cost, I'm willing to give you this amount and go do that for me. Or the extreme case, which includes multiple transactions is I give you five near go and vote for that Dao, because that includes multiple transactions on multiple, even multiple chains. Right. And that is where we want to go with this.
00:09:39.604 - 00:10:34.652, Speaker A: Multichain gas relayers and multi chain transactions and intents we're working with also, we're contributor to cake framework that has been also in Ethan, where we had talks with them. And there's a lot of research going on, on our side to get an intent based architecture going on with multi chain gas relayers. I don't want to call it gas relays at that point. It's almost like an intent relayer on any chain. But there's a lot of challenges that we're facing right now. The most importantly is how do you make these intents atomically execute? Because that is one of the most difficult things to do when in a multi chain world. How do you make sure a transaction actually comes from this chain and it goes to this chain without actually these delays? And if the chain goes down, how do you revert? So we're putting a lot of research into that.
00:10:34.652 - 00:11:48.148, Speaker A: Another thing is, like I said, it's also connected to this is finality differences. How do you make sure that if a chain is slow and other chain is fast, that there's a chance for arbitrage, and we want to make sure that that doesn't affect the users that comes into play into like, mevs and whatnot. And one of the most difficult things to get your head around, in my opinion, is how do you prove an intent? Because in a trusted system, you want to say, I wanted to do this, and it actually happened so that I will pay you. But an intent is very abstract, right? It's like I give you five and go buy me that NFT. Do you define a slippage? Do you define a maximum limit? And how do you come back to the user and say, I proved you that this is what you wanted? Because the user might say, I'm not sure if that's what I wanted. So these are the things that we're working on right now and I'm very excited to work on these very novel problems and very noble solutions and hopefully we will get these in the hands of the developers and users very, very soon. And that should be pretty much it, I think.
00:11:48.148 - 00:12:12.318, Speaker A: Yeah. Thank you so much. These are the Gita repositories that we have. If you want to play around with them, please feel free to do so. Like I said, it's mostly testnet and the contracts are going to be quite changing and they're going to be getting audited very soon. Sorry if I did any mistakes. I'm very, very gentle act, but hopefully it was helpful and hopefully we can move this forward.
00:12:12.318 - 00:12:12.654, Speaker A: Thanks.
