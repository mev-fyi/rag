00:00:04.330 - 00:00:24.398, Speaker A: Hi, everyone. This is Alex from Nier. With me today are Aaron Muneeb and Diwakar from Blockstack. And we will talk today about the technology and the motivation behind Blockstack. Guys, would you like to introduce yourself and tell us what Blockstack is and what are you guys trying to solve and how you approach it?
00:00:24.564 - 00:00:49.354, Speaker B: Thanks for having us. These whiteboard sessions are pretty cool. I've seen at least one of them before. So I'm Muni from Blockstack, and you should think of Blockstack as a user owned Internet. The project really started at Princeton University back in the days. I think this is like 2013 or so, and our approach has been more to. We raised some venture capital to do explicitly like r and D first.
00:00:49.354 - 00:01:03.054, Speaker B: So we were pretty much in r and D stage for a while, then build out the public infrastructure. And you should think of this as like a platform where people can publish smart contracts and build web three apps. But the underlying architecture is very different.
00:01:03.092 - 00:01:03.294, Speaker C: Right.
00:01:03.332 - 00:01:16.734, Speaker B: It's almost a little bit of an inverse of a world computer, where we try to keep minimal state at the blockchain level and most of the rest of the complexities outside of the blockchain level. We'll get into some of those details in the whiteboard session.
00:01:16.782 - 00:01:24.358, Speaker A: Awesome. So when you say this blockchain layer, is it a custom blockchain or is blockstack building on top of one of the existing ones?
00:01:24.444 - 00:01:24.646, Speaker C: Yeah.
00:01:24.668 - 00:01:41.770, Speaker B: So let me introduce Aaron and the Walker as well. So Aaron did his phd with me at Princeton University. We actually shared the same advisor, Mike Friedman, for a while. And Aaron has been working at Blocksack since 2017. And so. And he's the person. It's actually very interesting.
00:01:41.770 - 00:02:04.980, Speaker B: Like, when Aaron joined is when I stopped doing GitHub commits. I don't know how it happened, but Aaron has literally taken over. He's the one who's building the blockchain, and I think he'll drive most of the session. And then we have Devakar, who's our head of engineering, and he was at Dropbox before that. Devalker and Aaron. Why don't you guys chime in as well?
00:02:05.350 - 00:02:05.762, Speaker A: Sure.
00:02:05.816 - 00:02:22.278, Speaker D: Thanks, Muneem. And thanks again for near. For hosting us. I'm mostly here to observe. I think it's better for sort of engineer to engineer communication in these whiteboard sessions. And happy to jump in to answer any questions. As Munim mentioned, I joined Blockstack last year.
00:02:22.278 - 00:02:43.070, Speaker D: I was at Dropbox before that. Spent ten years in Silicon Valley and moved out to the east coast. Last year to be with blockstack and it's been a hell of a journey so far. I think like some of the folks at near you come from the MemSQL database community. I was at a database startup, maybe you've heard of. It's a company called Astradata. Back in the day, it was one of the first companies that were building massively pirate databases.
00:02:43.070 - 00:02:52.818, Speaker D: And so it's interesting to come from that perspective into the crypto know, every day I feel like I'm learning new things. So it's been a pretty incredible journey so far.
00:02:52.904 - 00:02:53.298, Speaker A: Cool.
00:02:53.384 - 00:03:34.062, Speaker C: Yeah. And I'm Aaron, and like Muneb mentioned, I came out of PhD program at Princeton with him. My experience prior to joining Blocksat was primarily in distributed systems and security with a little bit of sort of applied language work, some compiler work, stuff like that. And since joining Blockstack, I've worked on all sorts of things, but have been primarily working on the stack blockchain and our smart contracting language clarity. Cool.
00:03:34.116 - 00:04:16.798, Speaker B: And for the question about the custom blockchain. So yes, it is a custom blockchain. And I think the need for it really started going back to the early days. We were looking at the bitcoin blockchain and wanted to actually create other types of digital assets or even some simple smart contracts back then. And this is like for people who have been in crypto for a while, there was a blockchain called Namecoin that added very simple domain name type registrations to bitcoin. We wanted to do something similar on top of bitcoin. So ended up designing this almost like a virtualization layer where you could create almost like a virtual blockchain on top of bitcoin, and then later refined that design.
00:04:16.798 - 00:04:37.458, Speaker B: So that's stacks 1.0 that basically all of the data is written on the bitcoin blockchain itself. But stacks 2.0 is very interesting. It is a separate blockchain, but it interconnects with bitcoin. And I think those are some of the things that Aaron has some slides and we can dive into it.
00:04:37.624 - 00:04:44.710, Speaker A: And so when you say stacks 1.0 and 2.0, is it different layers of block stacks or is it evolution of block stacks?
00:04:45.690 - 00:05:07.914, Speaker B: It's more like evolution. So 1.0 is the first design that, as I said, it's a virtualized blockchain on top of bitcoin, and 2.0 is going to replace 1.0 and then the rest of our stack is outside of the blockchain layer. So there's a storage system. There's authentication layer and the rest of the pieces are outside of the blockchain layer.
00:05:08.042 - 00:05:23.060, Speaker A: And so 1.0 is what is running now and two is coming soon. Cool. Okay. And so you mentioned before the video that you guys have a short presentation to introduce all the concepts. Do you want to go through it right now?
00:05:23.750 - 00:05:29.320, Speaker C: All right. Do you see my screen over here? It should be some sort of.
00:05:30.250 - 00:05:30.758, Speaker A: Yes.
00:05:30.844 - 00:06:26.950, Speaker C: Great. All right, so what I'm going to talk about a little bit during this whiteboarding session is the stacks blockchain 2.0 or v two, I call it here, and I'm going to focus on the consensus algorithm. But first I'll talk about, I guess, what our design goals were for the stack blockchain. So the version two of our blockchain, we wanted it to be basically an open membership blockchain, so anyone can mine on it. Blocks are propagated through its own peer to peer network. The consensus algorithm, which is what I'm going to mostly talk about, is something we call proof of transfer, which is a novel concept to the stacks blockchain.
00:06:26.950 - 00:07:52.478, Speaker C: This consensus algorithm uses single leader election to form blocks. And then all of this blockchain is built to support sort of the clarity smart contracting system and other sort of like stacks transaction types, stack token transfers, things like that. As I said before, stacks consensus protocol, a single leader election protocol which go more detail in a minute. And election happens through burning or transferring bitcoin. It's the proof of transfer concept and fork selection is done similar to other blockchains where there's a longest valid chain concept and nodes sort of select that and present that view to clients. Yeah, so proof of transfer, it's a consensus algorithm that's similar to proof of burn, which is also a concept that I think I'm going to need to explain but has been used in other blockchains before, where rather than burning the base cryptocurrency, the base cryptocurrency is transferred to holders of the new cryptocurrency. So you can think of proof of transfer almost as like maybe a more efficient version of proof of burn.
00:07:52.574 - 00:08:21.274, Speaker B: Yep. And Aaron, I'm quickly going to chime in here a little bit that the problem here that we were trying to solve was that bitcoin has a limited scripting language by design. Bitcoin is very hard to change by design, and those are features. And if we want to have full smart contracts or if we want to add certain features to a bitcoin like protocol, trying to start a new proof of work chain is something that we were a little bit skeptical of.
00:08:21.312 - 00:08:21.514, Speaker A: Right.
00:08:21.552 - 00:08:49.910, Speaker B: Because especially in the early days, you wouldn't have a lot of mining power there. So we looked at things like merge mining, and it has its whole separate set of issues, but we are basically trying to solve the problem of how do you bootstrap a secure blockchain? Right? And we were circling around, basically, how do we reuse the security of bitcoin so that you don't have to go through the initial phase of getting a lot of hash power on your blockchain so that it's actually secure?
00:08:50.490 - 00:08:59.638, Speaker A: But obvious question is there's Ethereum, right? And Ethereum has smart contracts. So why would Ethereum not work as a base layer?
00:08:59.734 - 00:09:42.646, Speaker B: Yeah, I think Ethereum, it's a little bit like blocksack predates Ethereum. And we just happen to be in a very different school of thought in terms of the technical design. Like Ethereum is in the camp of they're very comfortable with the world computer type approach, that everything can be done at the blockchain layer. They're trying to scale the blockchain layer. And I know that obviously they've launched a successful proof of work network that has reasonable security attached with it. But repeating those events, it's a little bit hard that the long tail of proof of work chains are actually not that secure. It doesn't take that long or that much money to actually attack the long tail of proof of work networks and Ethereum in general.
00:09:42.646 - 00:09:57.494, Speaker B: Building on top of Ethereum is a little bit like going against the rest of our design principles, where we think that the blockchain itself is very bloated, very complex, whereas we want to keep it very simple and have the rest of the complexity outside of the blockchain.
00:09:57.622 - 00:11:22.706, Speaker C: Makes sense as, I guess, a first step towards understanding how stacks v two's consensus algorithm works. I'll provide a little bit of an overview of what our sort of model of proof of burn is, and then I'll show how that can be modified to implement proof of transfer. So in our consensus algorithm, a proof of burn system is a system where in order to mine a block, would be miners announce a block commitment on the bitcoin chain. What this block commitment is, is like the hash of the stacks block that they would like to form, and it's announced to the rest of the network through the bitcoin chain. So the bitcoin chain supplies you with sort of a strict ordering of these announcements, and it also ensures that other network participants all see it at the same time. Now, along with this commitment, this hash commitment, each miner is committing some amount of bitcoin to this block that they're building. The reason that they do this is so that there's some sort of capital expenditure associated with block formation.
00:11:22.706 - 00:12:15.826, Speaker C: So people can't just assemble blocks willy nilly. Now, these block commitments are scored according to how much bitcoin they've transferred, and then there's a random selection process based on those scores to select which of those block commitments won that particular epoch. Once a block is won, it's added to the stacks blockchain. And sort of, you repeat this process to build the next block. So one of the sort of key benefits of this is that stacks nodes are actually able to verify the entire history, these elections, entirely, with data available on the bitcoin blockchain. So there's this sort of one directional flow of information from the bitcoin chain up to the stacks blockchain.
00:12:15.858 - 00:12:19.178, Speaker A: But on the bitcoin chain, you only store the hash of the block, right?
00:12:19.344 - 00:12:20.060, Speaker C: Correct.
00:12:20.990 - 00:12:28.762, Speaker A: So could it be a problem if only a subset of participants has the full block and everybody else don't have access to it?
00:12:28.896 - 00:13:05.474, Speaker C: Yeah. So what would happen in that case is nodes that don't have access to that particular stacks block would continue to try to make progress on the stacks blockchain. So, like, if this block was hidden to them, they would mine off of the previous block to that one. And so then you would have these contending miners that would ultimately either result in a fork or enough other nodes in the network would eventually receive the block that they would start mining again on the dominant chain.
00:13:05.602 - 00:13:25.902, Speaker A: Yeah, that makes sense. Also, what happens is the stacks blockchain sort of conditioned on the. Is it specific to every particular possible bitcoin chain head? So for example, if there's a reworking in bitcoin, does it automatically rework the block stacks? I see, yes.
00:13:25.956 - 00:13:46.542, Speaker C: So if there is like a fork or reorg in the bitcoin chain, it will invalidate some of those block commits. The block commits will get moved around. And these leader elections would be calculated on the now reordered bitcoin chain.
00:13:46.686 - 00:14:11.806, Speaker A: So would it be a valid way to think about it? That one way to think of it would be to consider a particular bitcoin chain. Right. So every node, by looking at a particular bitcoin chain head, will deterministically determine every single leader election from the genesis all the way up and build a chain. Right. So if the bitcoin yours, there is deterministic way to derive a new blockstech chain, which is different.
00:14:11.988 - 00:14:58.410, Speaker C: Yes, exactly. So again, this process for proof of burn is basically that a miner is going through this sort of three step thing where they're committing some amount of bitcoin to a burn address. So it's an address that can't ever spend that bitcoin in order to get to participate as a miner. These are used as inputs to leader election that everyone can see. And it uses a process of cryptographic sortition using a verifiable random function so that every node in the network is sort of computing the same random value. And then once one of these commitments is selected, you're able to assemble the block onto the stacks blockchain.
00:14:59.070 - 00:15:02.160, Speaker A: So what prevents me from being able to grind the random value?
00:15:02.930 - 00:15:56.970, Speaker C: Yes, so the input to the random value. So there's two sort of major inputs to the random value. So one is a seed, which was a VRF output from the prior round. So the winner of the prior round, they use their VRF public key to generate the next seed based on the prior seed. So there's some randomness there. The second is the bitcoin block hash is used as an input to the cryptographic sortition. And what that input does is it says, sure, you could try to grind on this random seed, but every time you try to grind on it, you're essentially trying to discover a new bitcoin block.
00:15:56.970 - 00:15:58.654, Speaker C: And so it's very hard to.
00:15:58.692 - 00:16:07.570, Speaker A: Yeah, that's expensive. Just to understand better, why would just the bitcoin block hash not be sufficient without the VRF?
00:16:08.150 - 00:16:30.786, Speaker C: Right. So the reason that the bitcoin block just by itself isn't sufficient is because we don't want a bitcoin miner to be in a situation where they sort of exclusively know what the next seed is going to be without the stack block having already been announced.
00:16:30.898 - 00:16:45.806, Speaker A: I see. So in this case, effectively the block producer has one bit of influence. Right. Because they can choose not to tell the VRF output. Right. And so the network will have to operate somehow, so it will be skipped. And the bitcoin miner has one bit of influence because they can choose not to publish the block if they don't like it.
00:16:45.806 - 00:16:55.794, Speaker A: Right. But at least for the latter of them, it will cost them six BTC not to publish the block. Or actually, when we say bitcoin, we mean BTC. Right. Not.
00:16:55.912 - 00:16:56.386, Speaker C: Yes.
00:16:56.488 - 00:16:59.300, Speaker A: Okay. There are disagreements in the.
00:17:00.310 - 00:17:42.350, Speaker C: Yeah. Yeah. So this would be BTC. I have an example here of how an leader election might look. So in this example, we have three miners trying to compete to assemble the next block, miner a burns two BTC, and then miners B and C both burn three BTC. And so they get these scores. These scores are then converted into a range from zero to one, where if the sortition value falls within that range, their commitment is the winning commitment.
00:17:42.350 - 00:18:04.920, Speaker C: So let's say the random sortition value was like zero point 55, then minor b would be selected. And since minor b was, like, committing to building on top of chain tip three, their next block will turn the chain, the stacks block chain, into a length four chain, and it'll sort of progress that way.
00:18:06.090 - 00:18:15.370, Speaker A: So, in this case, imagine that a, or rather, imagine that a was building on tip two, c was building on tip three, and b was building on tip one.
00:18:15.520 - 00:18:16.122, Speaker C: Yes.
00:18:16.256 - 00:18:19.020, Speaker A: Would the chain shorten if they won?
00:18:19.890 - 00:19:03.418, Speaker C: So, no, it would not, because ultimately, nodes are going to follow the longest chain, or by default, honest nodes are following the longest chain. So if minor c, like, let's say minor c, was committing to chain tip one, if they were honest, maybe they're doing that because they just haven't received blocks two and three yet, then what that'll do is it'll introduce, like, a new chain, but it'll be shorter. Other nodes in the network that see it and see the other chain would choose the other chain instead.
00:19:03.504 - 00:19:15.146, Speaker A: Right. So effectively, block will be produced. Right. It's just that it will not change the tip. Well, maybe you will cover it later. Right. But I presume this happens in some sort of time intervals.
00:19:15.146 - 00:19:20.640, Speaker A: Right. So will the time interval be effectively skipped in this case?
00:19:24.390 - 00:19:34.260, Speaker C: In a certain sense, yes. So it'll have an impact on the block length of.
00:19:36.330 - 00:19:37.862, Speaker A: The canonical chain. Yeah.
00:19:37.916 - 00:20:09.870, Speaker C: The height growth rate of the canonical Chain will be shortened, but this same number of blocks will be produced. You could think about it as if a bitcoin miner was mining off of a very old chain tip. So they're assembling what they know is going to be a shorter chain. That's in some sense wasting hash throughput of the bitcoin network. And so it sort of slows it down in that sense as well.
00:20:10.020 - 00:20:11.310, Speaker A: Yeah, that makes sense.
00:20:11.460 - 00:20:44.650, Speaker C: So here, in this example, it was like, if random sortition actually returned, like, zero point 15 and minor a one, then they would assemble this block, which would be a fork, where you have two possible length three chains. And that gets into this question of, how do you do chain selection? So, the chain selection rule in the stacks blockchain, like I just said, is you select the chain with the most blocks, and in the event of a tie, you have to select one randomly.
00:20:45.870 - 00:20:49.130, Speaker A: So why randomly and not, for example, the one that was earlier?
00:20:50.370 - 00:20:54.830, Speaker C: Because that leads to an easier, greedy mining.
00:20:55.570 - 00:20:56.510, Speaker A: I see.
00:20:56.660 - 00:21:24.710, Speaker C: Yeah, that's like the classic bitcoin 25%. Yeah. Ultimately, what will happen here is whichever miner wins the next election, like whichever one they sort of randomly selected, would tend to be the dominant chain. So the next one is building off of this fork. And then if the rest of the network is operating honestly, one of the forks will come to dominate.
00:21:25.450 - 00:21:29.020, Speaker A: And how frequently does the process happen?
00:21:29.470 - 00:21:36.220, Speaker C: So it happens at every bitcoin block. So roughly every ten minutes.
00:21:38.590 - 00:21:48.830, Speaker A: So effectively, in every bitcoin block, there are proposals for a next block. And as processing every bitcoin block, we're choosing the next block. And if nobody proposed, I guess then there's no block.
00:21:49.490 - 00:21:57.220, Speaker C: Correct. If nobody proposes a block during bitcoin block, then, yeah. You would have no sortition for that.
00:21:58.310 - 00:22:01.122, Speaker A: And this is tax 2.0. Right. So this is not live yet.
00:22:01.256 - 00:22:01.746, Speaker C: Correct.
00:22:01.848 - 00:22:02.740, Speaker A: I see.
00:22:03.590 - 00:22:08.440, Speaker C: Though we do have a working test net for this.
00:22:08.970 - 00:22:19.562, Speaker A: So what is the incentive to. Presumably that cost me quite a bit of money. Right. It cost me the transaction cost plus the burn transfer. What is the incentive for me? Yeah.
00:22:19.616 - 00:22:49.870, Speaker C: So as a miner, when you win a block, you receive a stacks coinbase and transaction fees for transactions that you've mined. Both of those are denominated in stacks. So one way to think about the way that a miner is functioning is like they are burning or using BTC and receiving stacks.
00:22:50.210 - 00:23:00.120, Speaker A: And does the amount of transfer matter, or whomever transferred the most will win the block? And what happens to the transfer of those who didn't win?
00:23:00.730 - 00:23:18.700, Speaker C: Right. So the answer to the first question is there's this random function that's choosing who the winner is, but it's weighted by the amount that you burn or transfer.
00:23:19.550 - 00:23:23.502, Speaker A: Yes. It's not just the biggest, it's proportional. Okay.
00:23:23.636 - 00:23:34.814, Speaker C: Yeah. And then to the second question, even if you don't win, your commitment is lost. Like you've transferred this bitcoin.
00:23:34.942 - 00:23:52.758, Speaker A: Right. So there's certain risk. It's hard for me to tell right now without doing computations on the paper, but if it happens that the coinbase of block stacks becomes less in value than a single transaction fee on bitcoin, then the chain will stall. Right.
00:23:52.844 - 00:23:53.480, Speaker C: Yes.
00:23:54.010 - 00:24:00.940, Speaker A: That's an unfortunate event. Right. But bitcoin is like seven transactions per second. The price can go very higher up. Right. If it.
00:24:02.670 - 00:24:22.550, Speaker C: Price per transaction, that would be a very large deterioration in the value of stacks, basically, because the transaction fees in bitcoin I think the highest we've seen in the past several years is like $20 a transaction.
00:24:22.730 - 00:24:24.098, Speaker A: Yeah, that makes sense.
00:24:24.184 - 00:25:13.230, Speaker C: That was how proof of burn works. And with that model of proof of burn, basically what you get is this open membership blockchain. You get single leader election. But in order to participate as a miner, you have to burn bitcoin. So in proof of transfer, the sort of high level intuition of proof of transfer is that rather than burning BTC, we're going to send it to stacks holders. So that bitcoin is going to be sent to holders of the new cryptocurrency. So in this scheme, the sort of flow of operations is a little bit more complex.
00:25:13.230 - 00:26:25.480, Speaker C: So here what we have is there are stacks holders participating in proof of transfer, or what they're doing is basically broadcasting some signed messages indicating that they have some amount of STX. They're locking it up for some period of time, and they're voicing some support for particular stacks chain tips. So these are, we call these stacking messages. So stacks holders broadcast these stacking messages. Once they've done that, they have bitcoin addresses that are added to a reward set of bitcoin addresses. And now miners, rather than sending their bitcoin commitments to burn address, they're sending their bitcoin commitments to addresses chosen out of the reward set. And then once they've done that, proof of transfer sort of functions very similarly to proof of burn in that these commitments are chosen based on their score and the random sortition value.
00:26:26.650 - 00:26:32.060, Speaker A: And so the reward set, effectively, every STX holder can provide a bitcoin address.
00:26:33.310 - 00:26:53.406, Speaker C: So there is a threshold for providing bitcoin address because the way that these transfers are working is like they have to function at some level on the bitcoin chain. And throughput there is kind of limited. Right, but could it, for example, work.
00:26:53.428 - 00:27:02.258, Speaker A: In a way where everybody on the stacks chain provides the bitcoin address and then it just uses VRF to choose a small subset of them every time.
00:27:02.424 - 00:27:26.346, Speaker C: Problem with that approach is that ultimately, even if there's not say a throughput problem at the bitcoin level, there's a throughput problem somewhere. If you're trying to track all of these submissions, makes sense, but in the.
00:27:26.368 - 00:27:38.190, Speaker A: Current implementation, the reward set, so there's a certain threshold, and every time the STX block is mined, everybody in the reward set gets a percentage of the bitcoin.
00:27:39.170 - 00:27:46.990, Speaker C: No, there's a reward cycle. It's like a thousand blocks long over which reward set is traversed.
00:27:47.070 - 00:27:58.274, Speaker A: Okay, so effectively, if there is some number k, how many addresses getting paid every block. Then the threshold selects 1000k addresses effectively.
00:27:58.322 - 00:28:39.810, Speaker C: Okay, exactly. Yeah. So this is sort of like, I guess at a high level, what proof of transfer is trying to achieve. The tricky thing about this design is that nodes have to agree on the reward set. And the reward set could be disputed by nodes for two major reasons. But there's a lot of reasons they could end up disputing what the reward set is. A particular reward set is only valid in the context of specific stacks blocks.
00:28:39.810 - 00:29:07.740, Speaker C: These reward sets are governed by stacks holders, and your stacks holding is governed by the stacks blockchain, not the bitcoin chain. However, leader, election and mining, that's all occurring on the bitcoin chain. So miners, before they send their bitcoin to potentially invalid addresses, they need to have some sense about what a valid reward set is going to be.
00:29:09.230 - 00:29:46.822, Speaker A: But that doesn't sound like a problem, right? Because if I am a miner on the stacks chain, right, when I'm proposing something, first of all, there's a particular bitcoin chain which I'm observing right now. But more importantly, I'm also saying this is the last stacks block on top of which I'm building, right? Like I'm saying my stacks block will be block number 500, which is building on top of 499. As of that block 499, there's a very specific set of holders, right, sorry. Of the reward set. And naturally I should be sending to that reward set, because if I am to win building the block, then the reward set sounds deterministic to me. In that case, no.
00:29:46.956 - 00:30:18.958, Speaker C: Yes. So in that case, the reward set would be deterministic, but you would have a particular sort of like degenerate incentive for miners where if there was like. So let's say I'm a miner and I have a large holding of stacks, I can send those stacks to somebody on the canonical chain, but I am still empowered to mine prior to that with a different reward set in which I have large holdings.
00:30:19.134 - 00:30:54.400, Speaker A: Right? So the way I understand it, right, so let's say the particular tip right now is 499, right? So I don't have that many choices in terms of what to build on, right, I'm building on 499 or 498 and hope I will win. Or if I build on 497, then my block will not be respected by anyone, right? So the fact that I will move bitcoin to my own address, that's of course is very good, but my block will not be respected. I will not get stacks in this case, right. It will not be on the canonical chain. The only way for me to get onto the canonical chain on stacks is to build 500, right?
00:30:55.810 - 00:31:26.114, Speaker C: Sort of. But it would have this problem where. All right, so even if I'm building on block 496 or something, and it's not going to end up being the canonical stacks chain, like, if I win the leader election in that round, I'm either denying the network the ability to make forward progress, or I'm able to, if I do this enough, win enough of these elections, I'm able to come to dominate the chain.
00:31:26.242 - 00:31:27.602, Speaker A: Yeah, makes sense.
00:31:27.756 - 00:31:42.202, Speaker C: So ultimately, you want it to be the case that in every sortition, everybody that's participating in that sortition has the same view of what valid reward addresses are.
00:31:42.336 - 00:31:57.378, Speaker A: So effectively, you want the reward set to be specific to the certificate, not to the tip of this tax chain, because during the certificate, different block producers have different head in mind, potentially. Right. But you want for all of them, the reward set to be the same.
00:31:57.544 - 00:32:27.980, Speaker C: Correct. Basic problems for achieving this, even in honest cases, is that there could be forks which would alter people's views of the reward set, and there could also be stacks, blocks that disappear for a while and then reappear. If you have a stacks block that disappears for a while and then reappears, there might be like a reward set that you thought was valid, but then later becomes invalid, or the reward set changes.
00:32:28.590 - 00:32:28.954, Speaker A: Both.
00:32:28.992 - 00:33:46.870, Speaker C: Those are sort of similar. And the approach that we've come up with for dealing with this and ensuring that all miners have the same sort of view of where bitcoin should be flowing is that we've broken up the proof of transfer consensus into a two phase algorithm. So in the first phase, which we call the prepare phase, stack nodes come to an agreement on what the reward set is going to be for the next phase, the reward phase. In the reward phase, miners iterate over the reward set while committing, while performing their block commitments. And, yeah, these two phases can overlap. So a reward phase might be occurring while the next phase is doing its prepare. So the key thing that's happening in this process is that during the prepare phase, the stacks nodes are selecting what we call an anchor block, which is the block that all of them will agree on is the block that contains the reward addresses.
00:33:46.870 - 00:34:40.630, Speaker C: This block basically has the property that over the course of the prepare phase, it was confirmed by a majority of the winning sortitions during that window. So let's say the prepare phase was 240 bitcoin blocks long. The anchor block was confirmed by at least 120. But there's some sort of tunable parameter here in the protocol for what percentage needs to have confirmed it, but at least a majority. But probably a super majority of blocks. So if an anchor block was, or if a block was confirmed by 180 blocks during the prepare phase, then it'll be the anchor block for the subsequent reward cycle.
00:34:43.210 - 00:34:55.766, Speaker A: Effectively, throughout those 240 bitcoin blocks, there's a voting where we only consider votes of the participants who want the substitution. Right. Or of everybody who participated in substitution.
00:34:55.878 - 00:35:26.950, Speaker C: Right. So you could do, I guess, two things, right. So one is you could consider the vote of everybody who participates in sortition. The other is you can consider just the winners. The reason you might want to consider just the winners is because you know that these people are assembling ballot stacks, blocks. Like, you're getting sort of more of a signal from the winners, but ultimately these have sort of the same expected outcomes over time.
00:35:27.020 - 00:35:35.240, Speaker A: But when I'm proposing a block, do I not have an incentive to choose an anchor block which has me in the reward set?
00:35:36.890 - 00:35:58.000, Speaker C: You are, but you need to get confirmations. So if you're building off a very old block, that block is unlikely to get 180 confirmations during the prepare phase. Right.
00:36:01.010 - 00:36:05.262, Speaker A: Do I vote separately for the anchor block or. My vote is the tip on which I'm building?
00:36:05.396 - 00:36:07.634, Speaker C: The vote is the tip on which you're building.
00:36:07.832 - 00:36:16.740, Speaker A: But throughout 240 blocks, everybody will have, like, imagine everything goes very well, and everybody builds on top of the previous block. Then every person voted for a different block, right?
00:36:18.150 - 00:36:24.178, Speaker C: Right. But it's confirmations. So it's like the anchor block is the one with 180 confirmations.
00:36:24.274 - 00:37:15.906, Speaker A: I see. But in this case, right, so imagine everybody builds on top of the same chain, right? So by the end of the 240 bitcoin blocks, we will have one block. Like, effectively the oldest block will have 240 confirmations, right. The block on top of it will have 239, et cetera, all the way up to the block which has 180 confirmations. But let's say that each of those blocks has very different reward sets, right? So it still feels to me that at the very tip, at the very end, right, so once we get to the border of the 240 blocks, suddenly I can start making some small perturbations. Like, imagine that the block which is 180 back has me in the set, but the one which has 181 has someone else dominating the set. So suddenly it becomes beneficial for me to either skip the bit just by building on something old to intentionally be skipped.
00:37:15.906 - 00:37:22.362, Speaker A: Right, just so that the block is 180 blocks back not 181. Right. So it seems like the same problem, right.
00:37:22.416 - 00:37:35.690, Speaker C: Comes back. Now, the way that that problem is dealt with is that a valid anchor block has to have actually been mined before the prepare phase started, before the IC.
00:37:35.770 - 00:37:59.830, Speaker A: So effectively, in my example, when there are 240 blocks all built properly, the block, it's not going to be one of those 240. It's just going to be the tip of the chain before the prepare started. And the windows, how is the window chosen? The window is just blocks. Is it just the height of the bitcoin chain? Modulo 240.
00:37:59.900 - 00:38:13.098, Speaker C: I see, yeah, modulo, well, it's like modulo 1000 -240 or something, right. It's the reward cycle and then a prepare phase for the reward cycle. And they don't have to be the same.
00:38:13.184 - 00:38:50.674, Speaker A: But then. Okay, let me think effectively, when the prepare phase starts, right. Probabilistically, I don't know how big forkfulness of the stacks chain, but from what we just discussed, it feels to me that the stacks chain will rarely have any forks, right. Because you have ten minutes to agree on the block, right. So the stacks chain will usually be chain, right? Yes. So when I know, just by looking at the bitcoin height, I know that the prepare phase is about to start. It is obvious, it is obvious that whatever the reward set is going to be in the last block before the prepare set almost certainly is going to be the reward set which is going to be chosen.
00:38:50.674 - 00:38:57.362, Speaker A: Right. So again, I have an incentive now I have an incentive to mess up with the block which comes right before the prepare set. Right?
00:38:57.516 - 00:39:23.140, Speaker C: Right. So there are incentives around when it is more or less beneficial to be holding stacks. And in order to get into the reward set, you do need to lock your stacks for the duration of the reward cycle. So I couldn't get into the reward set and then immediately sell the stacks that I had used.
00:39:23.510 - 00:39:24.226, Speaker A: I see.
00:39:24.328 - 00:39:40.310, Speaker C: Because they're getting locked up. But there is some sort of time, there is a discrete value to when you issue your stacked locking.
00:39:42.330 - 00:40:25.074, Speaker A: And another question which I had is when I'm producing a block, right, I'm transferring bitcoin. I'm transferring bitcoin to the stacks holders. So if I myself already a major stacks holder, then I'm getting pretty large percentage of my bitcoin back in expectation, right. So whichever way rewards that is chosen, I will be getting bitcoin proportional to my stack holding. If I'm a major stacks holder, let's say I have 30% of all the stacks. That means that for me, producing a block only costs 70% of the cost, while for another person who is completely random, they're coming from outside, for them, it costs 100% of the cost. Right.
00:40:25.074 - 00:40:32.600, Speaker A: So does it not affect sort of the egalitarian part of the, or egalitarian component of the system?
00:40:34.010 - 00:41:45.146, Speaker C: So I think there's maybe two ways to think about it. One is like, yes, these miners are getting a discount when they participate as miners and they're able to send funds to their stacks address. That is true. But at the same time, there's not a high additional value that they're getting out of that participation than any other reward recipient would be getting. Right. So if there's like, whatever, they're sending it to five addresses at a time, they're, yes, getting like a 20% discount, but they're also still transferring that same discount to other people. And so in one sense, it does reduce the egalitarianism of the system to a certain extent, mostly because there's this threshold for participation, but in another sense, it's increasing the value of stacks to stacks holders.
00:41:45.146 - 00:41:52.320, Speaker C: So if you are participating as a stacks holder, this is a process that is ultimately benefiting you.
00:41:55.250 - 00:42:09.160, Speaker A: From the. How many more quantities do we need to learn about the chain? Because I sort of also want to spend time actually talking about block stacks. Right. I presume blockchain is just a minor component at the bottom which powers it.
00:42:10.570 - 00:42:15.478, Speaker C: Yeah, I think this is like, we've covered pretty much all of the concepts, I think.
00:42:15.564 - 00:42:31.994, Speaker A: Yeah. Awesome, right. And so also, I guess an important question to understand is that the block and the block stacks, the transactions in that block, they can be more complex than bitcoin script, right?
00:42:32.112 - 00:42:43.970, Speaker C: Correct. Yes. So, yeah, in the stacks blockchain, you're able to write smart contracts using clarity, which is our smart contract.
00:42:44.950 - 00:42:48.434, Speaker A: So what are the other components of the system?
00:42:48.632 - 00:43:27.082, Speaker B: So I was just going to comment a little bit on the STX holders who are also mining. So one thing over there is that it really depends on the current distribution of stacks as well. And that's something that we were a bit careful of, that we were actually putting limits on the maximum amount of capital any single party can put in when we did the offering in 2017. And some of the other holders, like blocks at PBC itself, actually wouldn't participate in mining. Just as a policy, I'll go back to. In my mind, it's a little bit of a cost of capital.
00:43:27.226 - 00:43:27.486, Speaker A: Right.
00:43:27.508 - 00:43:46.390, Speaker B: So you are deciding to park your capital. You could have done something else with it, and you're getting some value by parking that capital. It's a little bit like how people get loans on their bitcoin, right? They give bitcoin to somebody and they get a return on it. So you're parking capital as STX to do more efficient mining.
00:43:47.210 - 00:43:51.640, Speaker A: Yeah, that I guess makes sense. Okay, let's make sure we understand why it worked.
00:43:54.730 - 00:45:33.522, Speaker C: The blockstack ecosystem as it exists today is sort of this multilayered stack that provides application developers with a way to build decentralized applications very easily without doing a lot of transactions on our blockchain. So the way that a standard application in blockstack is built today is that they use a library blockstack js. Blockstack JS runs client side in users web browsers and it does all of this work of building up applications and showing users data associated with them or other users through our decentralized storage system, which is called Gaia. So Blocktech JS is like primarily interacting with Gaia. What Gaia is, is really just a method of looking up data for a given user at a sort of server location chosen by that user. So what that would mean is like, let's say I'm Aaron ID is like my decentralized username. I log into an application, the application tries to do some work and it tries to look up some file from Aaron ID storage.
00:45:33.522 - 00:46:06.690, Speaker C: What it's going to do is send out a query to the blockstack naming system for Aaron ID. The blockstack naming system will return some server which is my Gaia server. And once it's returned that server, blockstack JS knows how to form a URL to then query that server for the particular file in question. Let's say it's like Foo JPeG or whatever. It knows how to query the guided server for Foo JPEG.
00:46:07.430 - 00:46:15.890, Speaker A: And so in this case the blockchain naming system, is it just the nodes, which, is it the same nodes that operate the blockchain?
00:46:16.470 - 00:46:53.326, Speaker C: Yes, exactly. So the block stack naming system is the stacked blockchain v one. There are basically two applications. There's the naming system and there are stacks, tokens. The naming system is basically just a mapping of unique strings to small packets of information which we call zone files, which are actually just DNS zone files that tell applications where to find a particular user's Gaia server.
00:46:53.438 - 00:47:00.660, Speaker A: So effectively the blockstack JS it needs to locally know some anchor node or something to connect to.
00:47:01.110 - 00:48:32.510, Speaker C: Yes, in blockstack JS, if I'm writing a blockstack application, I can supply a default node that I want it to communicate with that could be a public node that I run or a public node run by some other entity, but I can supply a default there. However, users, when they sign into the app, their sign in includes where it's got like a JWT JSON web token with a bunch of information in it. And one of the pieces of information is their preferred node to communicate with. And then if that's supplied and you're using sort of the default blocksec JS distribution, then blocksec Js will communicate to the user specified node rather than the application specified node. Of course, this still does depend on users sort of trusting that application to a certain extent, because an application developer could choose to just always use their node. However, there are web extensions and other sort of tooling available which ensures that if you're using a blockstack application, the boxack application actually only ever communicates with the node that you specified.
00:48:35.990 - 00:48:42.050, Speaker A: And so for storage, storage is separate set of nodes, right? Or that's also the same nodes cooperate. Yeah.
00:48:42.120 - 00:49:38.630, Speaker C: So that's a separate set of nodes. And the great thing about the storage is that it is very much backend agnostic because you're doing this sort of recursive lookup where blockstack JS asks the blockstack naming system for information about where my data is stored. Because you have that sort of indirection step, I can specify all sorts of places. Like I could just choose to store all my data in an AWs bucket because it gets very great performance and I have a bucket that I pay for the blocks JS is just sort of pretty agnostic to that. It just needs to be able to do a normal HTP request.
00:49:40.890 - 00:49:46.946, Speaker A: When you're saying I can choose. So I in this case is the user of the application or the application developer.
00:49:47.058 - 00:49:48.554, Speaker C: It's the user of the application.
00:49:48.672 - 00:49:49.420, Speaker A: I see.
00:49:52.270 - 00:49:53.130, Speaker C: Go ahead.
00:49:53.280 - 00:50:12.560, Speaker A: So effectively user, it's the responsibility of the user to figure out whether data is stored and an application can on behalf of user, store data into their preferred storage. Or what is the relationship between the developer, because developer, when they develop application, they need to store data somewhere, right?
00:50:13.010 - 00:50:55.502, Speaker C: Yes. In the scheme as designed, all data should really only ever be stored on behalf of a user, right? If I'm using this application, my data is mine, it should be stored in my Gaia bucket. If application developer wants to do things where they're storing information related just to the application or storing things on an application server, then really that has this effect that it sort of deteriorates some of the decentralization of the app itself.
00:50:55.636 - 00:50:56.320, Speaker A: Right.
00:50:58.290 - 00:51:38.540, Speaker C: And this is where sort of the necessity of stacks v two, I think is sort of most apparent. Right. In stacks V one, you're somewhat limited as an application developer in how you can store sort of application specific data in a way that all of your users would be able to see it. However, in stacks V two, now that we have the ability to write clarity smart contracts, there's a lot more freedom for developers to harness the blockchain itself for storing data in an open, verifiable and secure way.
00:51:41.310 - 00:52:02.638, Speaker A: And in this scheme that we have on the whiteboards right now, it is the responsibility of the user to figure out where they will be storing data. So it could be their own server, it could be AWS IC. So blockstacks on itself does not try to provide any storage solution like file corner or whatnot.
00:52:02.814 - 00:52:30.060, Speaker C: Yeah. So today if users are sort of signing up through the default sort of sign up flow in the blockstack sign in experience, then they get provisioned with storage that we're providing, but ultimately they could choose to use something else and we're not going to be providing storage forever for everyone.
00:52:34.690 - 00:52:50.290, Speaker A: Yeah, that makes sense. And so naming system, what is the roles of allocating domain names to people? Is it like first come, first serve? Do they pay STX for getting the domain names?
00:52:50.710 - 00:53:13.420, Speaker C: Yes. So the answer is yes to both of those questions. It is first come, first serve and you pay to get a name. And there's like rules governing how much it costs to get a name. Like shorter names cost more, names without numbers cost more, things like that.
00:53:17.390 - 00:53:21.454, Speaker A: And all the names, the hash map is stored on the blockchain, right?
00:53:21.652 - 00:53:56.680, Speaker C: Correct. So all of the names themselves are stored on the blockchain, the associated data with the names. The zone files are not stored directly on the blockchain. There's like a separate peering network that's sharing those zone files around. The reason for that is because the zone files themselves are not like consensus bearing. Right. You don't have to wait until you have all of the zone files to continue processing operations on the blockchain, but it's good to have that data.
00:53:57.530 - 00:54:00.630, Speaker A: And how is it ensure that the zone files don't get lost?
00:54:04.110 - 00:54:10.006, Speaker C: If the whole peer network disappeared, you wouldn't be able to reconstruct it.
00:54:10.128 - 00:54:31.714, Speaker A: I see. Is there some sort of. Actually, let me think if that question would make sense. I guess one question is if I'm using the service, right, and I know where my storage is, why do I even need block stack naming system? Why would I not just locally say, well, use that storage right, right.
00:54:31.832 - 00:54:56.250, Speaker C: So the reason is because if you want to participate, if you want to use this application with other people, right. So let's say you and I, we're going to communicate and I'm Aaron ID and you're Alexandra ID. You've stored some really cool photo on your storage and you want to share it with me. I need to know how to read it from my client.
00:54:57.310 - 00:55:14.818, Speaker A: So that is accessible to other participants as well. Okay, that makes sense. So in this case, who has access? Can everybody in the system change the zone files associated with names? And if not, then what authenticates me? How do you know that that's me, not someone else?
00:55:14.984 - 00:55:39.640, Speaker C: Right. So in order to change the zone file hash associated with a name, which is the thing that's getting stored on the blockchain, in order to change that, you need to issue assigned transaction where the key that signs the transaction is like the owner key of the name. So when you register a name, you assign it to an owner key.
00:55:40.250 - 00:55:50.750, Speaker A: And you mentioned before that there are extensions. Right. But it sort of also implied that I can use blockstext without an extension. So if I'm using it without an extension, what is responsible for the keys management?
00:55:51.890 - 00:57:03.090, Speaker C: So for key management there's a couple of things that happen. So one is that when you sign into an app, the app is not given your name owner key, it's given an app specific key. So if you're familiar with a hierarchical derivation keys. So all these keys are sec p keys, which means that you could do key derivation on them. So what we do when a user signs into an application is that we take their identity key and then we derive a path to an application specific key so that the application is only ever given this app specific key, so it couldn't affect data from other applications. Now in the world where you are using an extension, the application would actually never even need to get this key either, right? Like the extension is managing that key and the app is sort of sending write requests and signature requests to the extension which is handling the signing.
00:57:06.090 - 00:57:23.914, Speaker A: Does it imply that in order for me to start using an application, I need to use some client software locally, like something locally on my end needs to do the key management, right, and issue the access key to the application, right. So I need to have some third party software installed, right?
00:57:24.032 - 00:57:42.590, Speaker C: Correct. Yeah. So what we have today is the blocksack browser or authenticator, which is what is actually holding your keys and handles the app sign in and then key generation sort of flow.
00:57:44.610 - 00:58:06.280, Speaker A: But effectively without some extra work on the app developer side, right. They will not be able to build an application which a person will just open in the browser without having like imagine I never heard of blockstacks before, right? And I want to start using blockstack application, I will have to install blockstack first. Right. The authenticator before I can use application.
00:58:08.350 - 00:59:06.538, Speaker C: Sort of. So what we have is there's a flow in which a user doesn't need to ever install anything, and rather what happens is the application that's using blockchain js, when it triggers this sign up or login flow, it generates the key in the application itself and then submits it to some server that sends a recovery key to the user. And then the user can begin using the application sort of immediately. And in that scheme, as a new user, I'm placing a lot of trust of my identity in this particular application. But in many cases that might make sense because if I'm a user that has never heard of blockstack, the app is the thing that I trust first.
00:59:06.624 - 00:59:22.158, Speaker A: Yeah. In this particular scheme. So that scheme actually makes a lot of sense. Right. If the user just joins the application at that very moment, they're very willing to trust it, right. Because application will lose more by doing something iffy. Right.
00:59:22.158 - 00:59:46.040, Speaker A: But as I'm using application for a while, at some point my assets or my data in application, my attachment to it grows, right. So at some point I want to get full control of the key. So is there a way for me to regain full control of the key such that the server who initially issued this has no way, because presumably if they can recover the key for me, they can also recover the key for themselves. Right. So is there a way for me to completely replace the key on my account?
00:59:46.650 - 01:00:39.602, Speaker C: So yes, you can do like a name transfer operation. So a total rekeying is achievable. And then if you do this rekey, and we have a CLI tool, but theoretically you could have a very user friendly tool that handles the rekeying of all of your data. It sort of crawls your Gaia data storage and rekeys all of it. So that's like if you want to get sort of a full guarantee that this application that you signed up with, even if they're storing your key, if they've had like a keylogger going when you sign in, because there's like a password based unlocking that is supported, you'd get this full guarantee by doing this transfer and rekey, presumably.
01:00:39.666 - 01:00:52.240, Speaker A: I think by the time a person does rekeying, right. They do that because they sort of at this point understand the value. So I guess at that point they would be willing to go through the CLI tool.
01:00:53.490 - 01:01:10.370, Speaker C: Yeah, maybe. I think that there's a world in which, let's say whatever, there's 3 billion people using this, right? Some of them would want to use maybe something other than a CLI tool, but even if they were motivated.
01:01:10.710 - 01:01:20.950, Speaker A: Yeah, I guess that makes sense. Cool. Okay, so so far that all makes sense. Are there any other big parts that we haven't covered yet?
01:01:21.020 - 01:02:37.920, Speaker C: I think yes, there's a lot of stuff built around this to make a lot of things easier, to make name registrations easier. We have various concepts around how you can do batched registrations of names so that a single bitcoin transaction can actually register like 100 names, which reduces the cost of new users significantly. There's a lot of developer tooling that helps to build applications in this style beyond just blockstack js. We have this notion of Radix, which is like an indexer for this decentralized data. So that if I'm building an application, it makes a lot of sense to do point to point communication very easily. Right? Like if I know that I'm trying to communicate with Alexander ID, I fetch their data, but if I'm trying to crawl like a feed of updates, like if you're thinking about a Twitter like application, then like suddenly you need the ability to index lots of different people's data. And so for that we have a piece of software called Radix that helps developers out a lot with that.
01:02:37.920 - 01:02:51.470, Speaker C: And then of course in stacks v two, there's going to be a whole host of other things going on. Mostly, I'd say the biggest piece of that is the smart contracting clarity.
01:02:51.550 - 01:02:59.318, Speaker B: Yes, I was going to bring that up. That I think the clarity smart contract language is a big component that we haven't been able to talk about.
01:02:59.484 - 01:03:43.682, Speaker C: Yeah. And I think that that is sort of large enough in scope that it probably warrants its own session. But I think that the highest level features of clarity that are important to note are one that clarity smart contracts are published on the blockchain in source form. So in a sense it's like an interpreted blockchain language. The reason that we think that this is important is to prevent a whole class of bugs that could be devastating for the blockchain, like compiler bugs, things like that.
01:03:43.736 - 01:03:48.934, Speaker A: Well, it's also inspectable, which I think is something EVM does not possess, correct?
01:03:49.052 - 01:05:29.842, Speaker C: Yes, it's inspectable both by other developers, developer themselves, and even very motivated users, there's a lot of benefits there. Then the second big design goal and sort of feature of clarity is that it's a decidable language so it's not turn complete. So any smart contract that you publish in clarity has a very specific upper bound on the running time for all of the operations in the smart contract. That allows the blockchain itself to do static analysis to determine the cost of operations before actually executing them. It also enables whole classes of analysis tools for developers themselves to make writing smart contracts easier, safer, and build more confidence for their users. And then the third most interesting feature of clarity is support for transaction conditional transactions, like we call them post conditions. But basically as a user, if I'm calling a function on any given smart contract, my wallet software or whatever tool I'm using to generate this transaction is able to add post constraints onto the transaction.
01:05:29.842 - 01:05:43.226, Speaker C: So these post constraints could say something like, I'm calling this function, but abort this transaction if more than x amount of some tokens are transferred from my account.
01:05:43.408 - 01:05:51.222, Speaker A: Or like if I'm issuing a transaction to an exchange, I can specify specifically how much I'm expecting to spend and how much I'm expecting to receive.
01:05:51.366 - 01:05:52.460, Speaker C: Yes, exactly.
01:05:53.170 - 01:06:12.402, Speaker A: There's an exchange called one inch running on Ethereum. So they have a similar feature. They're sending a transaction to various exchanges, but they always validate at the end that the transaction went at the expected price. So it is doable on Ethereum, but you can have wallet extend the transaction itself it sends, right. But it's more complex, right.
01:06:12.456 - 01:06:22.310, Speaker C: So here you get it as like a language feature. It's a sort of first class feature of the stacks blockchain. You could do it on any smart contract.
01:06:23.610 - 01:06:56.980, Speaker A: Awesome. And I have one small question, which is in the block stack, every user has their own storage, right? So effectively I, at my own discretion, can at any point terminate my storage, right? Which like an expectation. It sounds to me that for many applications that will create various suboptimal user experience for the other users, right? For example, if it's some sort of Instagram, right, suddenly other users, they see like missing pictures or whatnot, right?
01:06:59.990 - 01:07:37.518, Speaker C: I guess maybe I answer that in two ways. The first is that application developers should be able to deal with these kinds of cases and not just display broken images. And then the second answer to that is that yes, it might deteriorate the experience of other users if I decide to delete my Instagram account without informing Instagram. But I would argue that it should be my right to do that. My data yeah, I agree.
01:07:37.684 - 01:07:48.110, Speaker A: Cool. Okay, so I think we covered quite a bit today. It was very interesting. Thanks a lot for joining me. And diving deep into blockstack.
01:07:48.930 - 01:07:51.358, Speaker C: Of course. I enjoyed it. Thank you.
01:07:51.524 - 01:07:55.366, Speaker A: Yeah, thanks a lot. You.
