00:00:03.850 - 00:00:52.406, Speaker A: And without further ado, Josh, welcome to the hello. There we go. Good morning, everyone. After this last year of isolation and dealing with COVID it's so wonderful to be here with everyone in person and really feeling the energy of this growing near community. So let's just jump right into it. Today I'm going to talk about what's new in developer tooling, and I'm going to give you a little sneak peek of something we've started working on that we for now, call developer console. But first, who am I to be giving you this information? Well, as Michael so nicely introduced me, I am Josh Quintel.
00:00:52.406 - 00:01:28.002, Speaker A: I'm the product manager of developer platform at near. Like he said, I started pretty recently and I've been in the space for a while, about five years. We did consensus and truffle previously. I'm also going to be exporting these slides after this, so you'll be able to click on a lot of these links that you'll see. So, developer platform, what does that mean? So we can really sum it up with this one sentence right here. So, developer platform. We aim to empower all developers to build complex applications with simple tools across the entire software development lifecycle.
00:01:28.002 - 00:02:21.926, Speaker A: Or put another way, we want to get those ideas out of your head into the near verse without getting in your way. What's this software development lifecycle all about? Well, you're probably already doing this if you've doing or have done any kind of development. This is a really nicely condensed version of it that we have here, focuses on this core loop of coding. So this is developing your smart contracts, developing your front end testing, of course testing those things, deploying them to a live network or to your hosting provider, which is hopefully decentralized storage, and then finally monitoring the usage of the application to then analyze that and plan your next iteration. So we're going to kind of use this to anchor the presentation and I'll go through all the tooling updates and talk about that dev console. So first up is near CLI. So near CLI is having some big changes coming to it.
00:02:21.926 - 00:02:47.246, Speaker A: It's a ground up rewrite. And so first off, interactive prompts are going to be part of this. So let's say you're new to development or you just don't want to have to Google all of the options that might be necessary for a particular method. We're just going to prompt you for those if they're not filled in. So really nice upgrade to the development experience there. Next up, structured logs. These are really important if you're scripting.
00:02:47.246 - 00:03:30.922, Speaker A: This is going to let you digest the output of your logs much more easily. No more having to parse strings or do any weird juggling like that of those results. Next up, key management. So this is going to be very much improved, managing multiple keys, managing API keys for RPC providers, things of that nature. So also a much more flexible experience and kind of dovetailing off of that configuration files. So these are things like setting the network you're going to deploy to, setting things like your contract output directory, really just giving you that customization that is really important. And then finally it's actually going to be written in Rust, the current Clis in JavaScript.
00:03:30.922 - 00:04:12.278, Speaker A: So running it in rust will give us some nice security guarantees and also kind of help prevent supply chain attacks, things like that. But I didn't even mention the most exciting part of the near CLI changes, and that is that the new CLI is going to be extendable. So you can write your own extensions, you can actually write them in any language. And we at near are actually first party going to work on two extensions right out of the gate. So the first one is a validator extension. So this is really nice. If you're a validator, there's not going to be any interruption in the way you currently work, but if you are not, this will give you a bit of a lighter weight CLI since you won't be needing that functionality.
00:04:12.278 - 00:04:52.486, Speaker A: And then secondly, there is going to be a project extension which I'm going to talk about here in a second, but essentially allowing you to manage your local near development environment in a bit of a better way than we currently handle it. So speaking of that, the project extension, just a couple examples here. So you can initialize a new project. You may have currently done this through something like create near app or something like that, but this will now initialize a new empty project. We're going to go over the structure here in a second. So really nice, very easy way to get started. And then second here I demonstrate, there's this compile command.
00:04:52.486 - 00:05:28.520, Speaker A: And currently the way the workflow for development works is it's really just the language native tools. So if you're building your smart contracts in rust, you're using cargo, for example. And so this is going to allow us to kind of abstract over these languages and deal with multi language projects a little bit better. But very importantly, it's going to allow us to do additional things besides compiling to Webassembly. And in this case it's going to generate what we're calling an ACI or an abstract contract interface. This is really helpful for front end development so that you can more easily interact with your contracts. We'll talk about that in a little bit too.
00:05:28.520 - 00:06:19.266, Speaker A: So speaking of that project structure, here's an example right here within our project folder, we've got that configuration file I mentioned. So networks build folder, things of that nature, and then you have your contracts folder. So a little bit more of an organized structure here in this example, this is a rust project. So we've got our greeter contract, and then we have that extra cargo toml for the workspace there. So you also see mentioned there that that's going to support multiple languages that goes back to that compile command that I mentioned. So if you've got some assembly script and rust contracts, we'll just be reading that and use the correct compiler for that case. So once again, kind of the big advantage of that, other than that language abstraction, is that we'll be able to do some extra things after that waSM compilation when specifically generating these ACI files.
00:06:19.266 - 00:07:04.820, Speaker A: So what these really have are all of the functions and function signatures that you can easily consume on the front end. So you can pass this right into near API JS and you'll just be able to get going very quickly as far as interacting with your contract. And then you'll also have all your types and things there too, which can be really nice for a typescript integration. So, speaking of additional languages, as you may or may not know, we currently support rust and assembly script. But the great thing about near, right, is that our virtual machine runs webassembly. So any language that can target webassembly for compilation can potentially have a near SDK. And to that end, the teams at grain and zig languages are working on near SDKs currently.
00:07:04.820 - 00:07:55.070, Speaker A: So you might want to check those out if you are interested in new languages. So now that we've done our coding, we've built our smart contracts, we've worked on our front end. It's time to start testing. But of course, you've been writing tests the whole time you've been coding like a good developer, but in this case we'll call it a separate thing. So there's been some really big changes and actually like a massive leap here in improvement of the experience of testing and also just what you can test and kind of how the environment works. So we've just released these tests actually now use something called near sandbox. So previously there was these things called simulation tests, but the advantage of near sandbox is it's actually just a near core node with some additional functionality that's really helpful for development.
00:07:55.070 - 00:08:40.130, Speaker A: So this gets you a lot closer to what the live network is actually going to be doing with the addition of things like patching state. So this is really helpful for seed data in tests. This allows you to massively update state without even having to send a transaction. And then secondly there spooning, which we are definitely going to highlight, that is a very important feature that allows you to actually take a contract from a live network, pull it down into your local environment, and then of course you'll be able to integrate with that test against it without spending real near if we're talking about main net, for example. More importantly, you can write once and run on any network. So these tests, they'll run in the sandbox by default. It's just one configuration option away to get them to run on Testnet.
00:08:40.130 - 00:09:07.690, Speaker A: They're going to be able to run concurrently, so really great for speed. Of course, having them run in parallel rather than one after the other. And speaking of flexibility, you'll be able to write these in rust or JavaScript. So if you want that full stack rust experience, it's there for you if you prefer to write them in JavaScript because that's how your front end is going to interact with your tests. We got you covered there too. So that's sandbox. Let's take a little bit more of an actual look here at how this works.
00:09:07.690 - 00:09:53.050, Speaker A: So you can see here in this first example, this is a very basic example, we're actually just patching the state of the greeter contract, the variable status message there, and you can see we're updating it to say state. But you can imagine that for something, let's say you're like an NFT ticketmaster type thing, right? You'd be able to see 50 tickets into the system right away as part of setting up your testing environment without having to fire off 50 transactions. So both a lot faster and a lot more readable, right? Because you're just going to be able to see this in one command. Secondly here, this one is incredibly important. This is an example of spooning here. So you can see we've got ref finance and we're grabbing it from Mainnet. There's the account address there, block ID 50 million.
00:09:53.050 - 00:10:35.622, Speaker A: And we do want the state data. So this is hugely important. This is going to enable or make it much easier to make an entirely important class of Dapps on near, which is actually being able to integrate a lot of these protocols, especially in DeFi, which is why ref's the example here. So let's say you wanted to make like a yield farm aggregator. You'd be able to pull in ref finance, you'd be able to pull in whichever other Defi apps you wanted to include, and you'd be able to have this all running in your local environment without, as I had said, having to spend any real near so hugely powerful there. I cannot state that enough. And then in the future we're actually working on time travel for this as well, so you'll be able to fast forward and manipulate time that way.
00:10:35.622 - 00:11:09.374, Speaker A: If you have any time locked things, here's an example of writing those tests either in JavaScript or in rust. You can see that it's quite flexible there. We create the account, we deploy the contract. Yeah, really nice there. So here's an example of testing anywhere. Here you can see there's a couple of different ways to change the network. You can pass it in as a variable, set it in the environment, or finally here, if you're using Ava, you will be able to actually generate a config file.
00:11:09.374 - 00:11:55.954, Speaker A: So these workspaces come in a couple different flavors. We've got the rust workspaces, as I mentioned, we've got a base JS version which is compatible with any testing framework. And we also have this version which is already configured for Ava, so you'll be able to get started as quickly as possible, if you don't mind using AvA as your assertion library. It's also worth mentioning that this is a huge improvement on integration tests, but your unit tests can be written totally the same way as before. There's no disruption to that. So now that we've got everything developed and tested, it's time to deploy it somewhere. This one's pretty nascent, but I'll just mention that you may have noticed since this workspace can actually deploy contracts, this is going to be able to underpin a scriptable deployment system that we're working on.
00:11:55.954 - 00:12:39.280, Speaker A: I definitely want to talk to you, any developers out there about how this should work. So you've done all this, now it's deployed on the network, now what? Where do we go from here? Well, our DAP is in the wild, and we're going to want to do that monitoring step, and that's where developer console comes in, really covers the operational needs of dapps. So you can see a couple of different features here. It's going to include infrastructure management. This is including an RPC service and also an indexer service. Many people don't want to have to deal with the time and expense of maintaining or writing your own indexer. And so this is just going to allow you to stand it up and get going.
00:12:39.280 - 00:13:20.282, Speaker A: Next, very importantly, monitoring. To get more specific, this is going to include alerts of various happenings about your contract that you configure and very importantly for security executing actions. Depending on those conditions, which we'll actually take a look at in a second here, then you've got that indexer service. So of course you're going to want to be able to visualize and number crunch on that data. So there's going to be an analytics portion. And really, this entire experience really provides a lot of focus and context around your DAP and really gives you that assurance and comfort while it's out and deployed in the wild, gives you what you need to continue to improve it. So I'm going to go through two scenarios here.
00:13:20.282 - 00:13:49.702, Speaker A: Got some wireframes to show you. Like I said, it's very early, but I want to at least give you a taste of the final vision of this. So first scenario here are DeFi smart contracts been hacked. How could the developer console have prevented this scenario? So in this case, this goes back to the alerts and actions that I talked about earlier. So in this example, we're on the monitoring screen, we're looking at our alerts here and just going left to right. It's really readable how this is configured. So you can see our account here is just in this example.
00:13:49.702 - 00:14:22.378, Speaker A: It's like a vault contract for this. And the conditions of this alert are if the balance drops 20%. And this is also if that is caused by addresses not from our allowed list. So obviously we want to be able to lower the balance of the contract. So the allowed list would include like addresses of anyone that you trust. And then finally there, those are the actions that would be triggered if those conditions are met, in addition to actually alerting you. So in this case, we're actually going to call the pause method on this contract.
00:14:22.378 - 00:14:57.594, Speaker A: Briefly, if you're not familiar with the pausable pattern, this would just allow you to flip a boolean and essentially stop all functionality from the contract temporarily. And then finally there how you want to be notified. So email, text, things of that nature. So here is an example actually of what one of those email reports might look like. So you can see here we're telling you which actual alert was triggered when it happened. We got some helpful links there that can go to the explorer or in that case help you view your allowed list right away. And then finally we showed the actual actions that were triggered along with that transaction there.
00:14:57.594 - 00:15:31.826, Speaker A: Once again, you can get to the explorer really quickly and see exactly what happened there. So second scenario, this one's an NFT marketplace that wants to see their best performing collections and artists. So how can we do that? Dare I say, it's almost trivial actually compared to the last task. We've already got the indexer service running. So this is just a matter of displaying this data in a way that's useful for us. So you can see our app NFT horrific here. The analytics screen is composed of a series of tiles for visualization.
00:15:31.826 - 00:16:00.042, Speaker A: And so in this example, we're creating a new one. We want to visualize our top ten artists by revenue here. In this example, this is written in a SQL query, but this is still very early, so that may change. I'd love to hear other ways you might want to write this. And then finally we choose our visualization here, which in this case is a bar chart. Here's a nice example of what that could look like. You've got your various tiles here, and these are all charts and graphs that you've configured.
00:16:00.042 - 00:16:46.350, Speaker A: We've got our top five artists by revenue in the lower left there in the bar graph that we specified, but we could also show a proportion of artist sales. And then at the top, just an example of some transactions right there. So phase one of this, what's going to actually be coming out soon is going to include a project management portion. So this includes adding your project, uploading the contracts, the RPC service. So this is going to be really great. You won't have to obviously be managing your own node or anything like that to connect to the network. Operating analytics so you understand how you're using the RPC service and then finally explore integration so that as transactions are happening against those contracts you've added, you'll be able to quickly see the status of those transactions and what's going on.
00:16:46.350 - 00:17:12.550, Speaker A: And this is all going to be available at the end of this quarter, actually. So to summarize, this is near as tooling as it exists today. I won't spend too much time on that. And this is what it's going to look like. So we've got that new CLI written in rust with that awesome extension system. Really excited about that. I really hope that could even power potentially even like micro startups around writing extensions for near CLI eventually.
00:17:12.550 - 00:17:47.342, Speaker A: And then additional language support there. We got the grain and zig teams working really hard. Next up, scaffolding there, starting a new project mentioned that near project extensions going to kind of be supplanting create near app there. We've got dev console on the operations side. And as far as our API libraries, we didn't really touch on this much, but it's definitely worth mentioning. In addition to near API JS, we're also working on API libraries for Rust and for Python, so you'll be able to interact with near in those languages more easily. And then testing, that was the big overhaul, so Sim tests don't need to worry about those anymore.
00:17:47.342 - 00:18:17.530, Speaker A: You got near sandbox, you've got your various workspace libraries. Just choose your flavor there based on what you prefer. And that Unicode character didn't work, but we want to hear from you. And in lieu of headshots, because we didn't have them all, I'm going to have everyone here on developer platform raise your hand in the audience. So find one of us, talk about your developer experience. Complain to us, please. Actually, I'd really love to hear negative feedback so we know where to improve.
00:18:17.530 - 00:18:55.474, Speaker A: So yeah, find anyone who had a raised hand there. And so as I mentioned at the beginning, I'm going to be uploading these slides actually shortly after this, and so you'll be able to click any of these links here that I provided. I'll highlight a couple of them, actually, because I've got a little extra time. So in addition to all the things we talked about, which is mostly on that left hand side there, you can see the near CLI proposal actually is an important one to highlight there. That's the original governance forum post that led to the near CLI that I spoke about, so you'll definitely want to check that out. And then on the right hand side, some really helpful resources as far as education. So we've got a new zero to hero tutorial.
00:18:55.474 - 00:19:24.158, Speaker A: It's building a crossword. Our very own Mike Purvis has used this internally. It's a really cool project, so definitely check that out if you want to learn more about developing in rust. That's part of our newly revamped Rust SDK docs, also really nice. And then under that we've got near university. So near university's got a couple different options there depending on how you want to learn. We've got live certified courses, which are in person or live in the sense that you're with an instructor the whole time.
00:19:24.158 - 00:19:56.390, Speaker A: We've got courses offered by our partners, and we also have self paced courses if you prefer to learn that way as well. And then finally other ways to get involved. We've got the near governance forum there. That's where you'll find that CLI proposal. As long as any other big ecosystem shaping discussions, we always make everything as external and transparent as possible, so you'll definitely want to follow that for any updates. And then finally, our near discord as well. So great place for general chat, talk to Devrel, just get involved really with the community and with that, that's everything.
00:19:56.390 - 00:20:00.620, Speaker A: So thank you. It.
