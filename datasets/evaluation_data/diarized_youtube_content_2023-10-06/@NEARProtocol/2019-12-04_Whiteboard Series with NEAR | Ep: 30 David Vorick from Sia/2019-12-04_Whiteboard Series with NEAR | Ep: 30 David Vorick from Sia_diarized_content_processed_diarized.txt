00:00:04.010 - 00:00:21.870, Speaker A: Hi, everyone. This is Alex. And we have David from Saya today. And David will present us the technology, and we will go through it. And so, to start, can you introduce yourself and walk through what's powering Saya the technology?
00:00:22.020 - 00:00:46.940, Speaker B: Sure. Yes. My name is David Vorak. I co founded Saya with Luke Champion in 2014. I've been in the bitcoin space, like, observing, studying, tracking bitcoin since 2011. So it's been a long time and an exciting journey for me. Saya is a decentralized cloud storage platform.
00:00:46.940 - 00:01:36.054, Speaker B: We really took inspiration from bitcoin and the idea that you can create a banking infrastructure or a financial infrastructure with no trusted third party. And so we asked the question, could this be applied to something else? And in the case of Saya, we're applying that to, you can create a cloud storage platform that has no trusted third party. And so our goal is to be able to make it for you to put data into the cloud without having to give up control to, like, say, an Amazon or an apple or a Google. We want you to be able to use the cloud without having to trust anyone else. And Saya launched in 2015. We've been building and enhancing it ever since. And I do think we've achieved the goal at this point of decentralized cloud storage.
00:01:36.054 - 00:01:40.634, Speaker B: So I would say that it's here today. It works, and you can try it out.
00:01:40.832 - 00:01:45.182, Speaker A: Cool. So let's dive into the tech.
00:01:45.316 - 00:02:21.302, Speaker B: Okay, so the first thing to know is that PSi is a proof of work. Blockchain. I don't know what I'm going to write at this exact moment, but it is a consensus system very similar to bitcoin. We have one special edition called the file contract. So rather than use a whole smart contracting platform, we thought the complexity was high. We felt to make the scientwork, we really only needed one decentralized, primitive or one smart contract. And so we just made that, built that right into the chain.
00:02:21.302 - 00:03:01.794, Speaker B: So we have something called the file contract. And what a file contract is, is an agreement between a renter and a host. I'll go ahead and spell them out, who each put money. I'll just draw a dollar sign into a file contract. And of course, it's not uS dollars, it is siacoins. So what this does is this file contract has a size and a Merkel root in it. And so the size is how much data is in there.
00:03:01.794 - 00:03:13.740, Speaker B: The merkle root is the merkel root of the data. So we take the data and we merklize it. We put it into a Merkel tree. We take the root, and we put that here. And so the size for this guy would be four.
00:03:16.030 - 00:03:18.780, Speaker A: And those are bytes. Or, like, how big is.
00:03:19.390 - 00:03:52.360, Speaker B: Each leaf is a 64 byte set of data that you hash. And then. So each node or branch is 32 bytes of data. And then, of course, the root is 32 bytes. So, yeah, you hash 64 bytes into a 32 byte leaf. Then you combine all the leafs into a root, and then a time. We call it a start time and an end time.
00:03:52.360 - 00:04:21.822, Speaker B: We'll come back to the time in a moment. So what the money is, is money from the renter. This is getting paid to the host. So as long as the host is honest and delivers on the file storage promise, the host will get this money. And then, yeah, this money from the host is actually, like, it's collateral. So it's a promise to the renter. If I don't deliver on my promise to store the data, I will forfeit this money.
00:04:21.822 - 00:04:28.290, Speaker B: And so if the host succeeds, all the money goes to the host. If the host fails, all the money gets destroyed.
00:04:29.590 - 00:04:31.634, Speaker A: Oh, they don't go to the renters, for example.
00:04:31.672 - 00:04:57.334, Speaker B: No, they get destroyed. And this is a game theory optimization. What we don't want is if the money goes back to the renter. And let's say the renter has some pretty big storage bills, hundreds of thousands of dollars owed to hosts. Now, the renter has an incentive to make the hosts fail. The renter can get substantial revenue or substantial cash back by seeing the hosts fail. So we want to make sure that there's never any incentive to attack the host.
00:04:57.334 - 00:04:58.966, Speaker B: Nobody wins when the host loses.
00:04:58.998 - 00:05:04.926, Speaker A: Oh, you're saying your friend is Aws, for example, like someone who hosts hosts, yeah. I see.
00:05:05.028 - 00:05:16.866, Speaker B: And so we don't want anyone to be able to make money by harming hosts, and so that's why the money gets destroyed. There's no revenue to be had by.
00:05:16.968 - 00:05:22.946, Speaker A: You make a little bit of revenue. Right. Because total supply reduces, but, yeah, it's just not as much. I see.
00:05:23.048 - 00:05:59.130, Speaker B: Yeah. It's much more indirect, and that would require a much bigger attack to be profitable. Okay, so we'll dive into the start time and end time. So this is, how do we know that the host is storing the data? So the host has this Merkel route. Merkel route in size that describe the data that's being stored, and a start time and end time. So the start time might be, let's say, 10,000 blocks in the future, and the end time might be 10,288 blocks in the future, some quick context. PSIA blocks are ten minutes, just like bitcoin.
00:05:59.130 - 00:06:42.110, Speaker B: So 288 blocks is two days. So the start time is when the host has the opportunity to provide a storage proof, and the end time is when the network assumes that the host was unable to provide the storage proof. So we don't want the host to provide a storage proof earlier because then the host hasn't stored the data for enough time, hasn't fulfilled their commitment. But we want to make sure they have more than one block because it can be hard to get a transaction into a single block. So we give them some time to get the proof onto the blockchain so we can go ahead and erase this. The way the proof itself is structured.
00:06:46.130 - 00:06:48.090, Speaker A: Do they periodically submit proofs?
00:06:48.170 - 00:06:48.846, Speaker B: Just one.
00:06:48.948 - 00:06:49.454, Speaker A: Just one.
00:06:49.492 - 00:07:41.822, Speaker B: Okay, we'll come back to why that is, but I'll go ahead and make eight. So we have a Merkel tree, and let's say it's block. So let's say the start height, sh e h is 10,000. The end height is 10,288. What's going to happen is at height 9999, we're going to take the hash of that block. So we're going to get equals ABCD. We're going to take the hash of this h of ABCD, and we're going to turn that into a random number.
00:07:41.822 - 00:08:21.206, Speaker B: Rng. We're going to use the random number to select one of these at random. So let's say this one gets chosen. Now, the host has to provide a proof on this node that he has this data in particular. So this, if you remember, corresponds to 64 bytes. So the host is going to provide this 64 bytes, not the hash of them, but the actual bytes themselves. And then also going to provide, let's see, what would that be? That would be these, the merkel proof that the 64 bytes belongs in the Merkel root in the contract.
00:08:21.206 - 00:08:37.674, Speaker B: And so this is a probabilistic proof. If the host can present this proof, then we accept it as though the host proved they have all the data. If the host cannot present this proof, then we assume the host doesn't have any data at all, even if they have other. The host has one chance to prove.
00:08:37.722 - 00:08:47.110, Speaker A: They have this data, and that happens. Okay, so because they're using a hash of the previous block, then the proof will be submitted, like at this block or shortly after, or it has to be submitted at this height. Exactly.
00:08:47.260 - 00:08:49.350, Speaker B: It has to be submitted in this range.
00:08:50.250 - 00:08:53.462, Speaker A: Oh, that's a range. The proof needs to arrive. I see.
00:08:53.516 - 00:09:19.760, Speaker B: Yeah. And so if we get to 10,288 and no proof has shown up yet, then the contract will destroy all the money. If we do get a proof in this range, though, obviously, because we use this block to figure out what the challenge is, the host is unable to provide a proof until this height because the host doesn't know where the challenge is going to be. This is a secure random number.
00:09:22.130 - 00:09:27.374, Speaker A: So let's say host also happens to be one of the miners. Can they not grant? Well, I guess it's expensive.
00:09:27.422 - 00:10:40.214, Speaker B: It's a good question. Yes, and that's precisely the argument. So the hash of a block is a secure random number in the sense that it's expensive to try again. And each time, if you don't like the random number you get, you can roll again, and it's going to cost you whatever the block reward is. So if the block reward is, say, $400, it's going to cost you $400 to try and get another random number. Now, if the network is busy, if you're a host with, say, 200 storage proofs, and you have a random number that selects on all 200, what are the chances that you're going to roll another random number? If you're trying to cheat, what are the chances that your next random number is going to be good across all 200 contracts? So if you do the math out, basically the upper bound on how safe it is, if you make a 200 million dollar contract on the sign network today, which I think does several hundred dollars per block, is how much it costs to do a block on the sign network today, that's probably a bad idea. But if you have contracts even that are in the thousands of dollars, probabilistically, it should be fine.
00:10:40.214 - 00:11:49.322, Speaker B: It's more expensive to manipulate the random number. Even if you assume 100% minor than it is to just store all the data, cheating is very expensive. So the other trick that we use is the collateral. So we can prove that as long as the host is putting up more than one x collateral, the expected value of cheating is lower than the expected value of, or the expected penalty of cheating is lower than the expected cost of just continuing to store the data. And so one subtle corner of the network is actually when the price drops, because the reward is tracked in cyacoin. So if the cyacoin price goes way down, the host reward goes way down. So if you have, let's say, like a collateral that's two x the revenue, we can say like 1000 psycoins of revenue, 2000 psyocoins of collateral, and the price drops to -50% the price falls in half, the host reward is halved, and the host collateral is halved.
00:11:49.322 - 00:12:23.100, Speaker B: This ratio is still safe. If you were doing like 1001 thousand, this ratio may not be safe, because now that it's fallen in half, the host can go to someone else and get 2000 Sia coins for the same amount of storage. And so you want your collateral multiple to. You want to take into account network volatility. So this is one things where saya tries to avoid volatility in its token price. If we could have a stable coin, I think that would be best of all. At this point, we don't have one.
00:12:23.100 - 00:12:31.722, Speaker B: But the more volatile the network is, the higher you need the collateral to be, just because the host can go and get a better deal by reselling the hard drive.
00:12:31.776 - 00:12:36.090, Speaker A: But if the collateral is two x and the price goes down three times, then it's not safe.
00:12:36.250 - 00:13:10.700, Speaker B: Then it's not safe. And that actually is a function of how old the contract is. So if the contract has 3% transpired, then probably not safe. But if the contract is 99% transpired, the host only has to, or even like 50% transpired, the host only has to hold the data for half the time of the contract. If they go to someone else, they're going to have to spend, say, double or. Yeah, that someone else is going to have to compensate for more time.
00:13:11.390 - 00:13:21.786, Speaker A: And so here. So the start hash, that's the time height. Start height. Sorry. This is the time at which the renter does not need data anymore, right?
00:13:21.888 - 00:13:22.106, Speaker B: Yes.
00:13:22.128 - 00:13:27.694, Speaker A: So the data is stored up until the start height, at which point the host once provides the hash, then the proof. I see.
00:13:27.732 - 00:13:46.362, Speaker B: And so the renter should assume that as soon as this height hits, the host is going to make the proof and delete the data. And in reality, the host is going to wait a little bit, in case there's a reorg or something. So the host does wait to submit the proof, but the renter has no control over that. The host doesn't have to wait, depending on the host's model of the network.
00:13:46.526 - 00:13:51.542, Speaker A: But now the host has two kinds of expenses, right? They store data, but they also serve data.
00:13:51.676 - 00:13:52.118, Speaker B: Yes.
00:13:52.204 - 00:13:53.894, Speaker A: So what makes them serve data?
00:13:54.092 - 00:14:15.994, Speaker B: Yeah. So that is purely revenue based thing. So every time that you. We've tried to structure the SCIA network so that every time you spend resources on the SCIA network, you pay for them. So upload bandwidth, download bandwidth, storage cost, contract fees. Right. The host has to get a storage proof onto the blockchain.
00:14:15.994 - 00:15:02.080, Speaker B: That's a resource that the host, that's a cost that the host incurs when it enters into a file contract. So the renter actually prepays for that. So for bandwidth, renters pay for the hosts every time they download, and then data availability is actually one of the bigger challenges of the scientwork. One thing we can't do is a decentralized, trustless proof of data delivery. So if I'm a third party, like anyone looking at the blockchain, anyone trying to verify the blockchain is a third party. So if you and I, if you're a host and I'm a renter, and I say to the network, he's not sending me the data, but then every time I try and like, this is the data he's not sending me, and you just proved it. You proved the network that you have it.
00:15:02.080 - 00:15:37.202, Speaker B: There's no way for me to prove that you are not sending the data. You can always withhold until the last second and then give it to me. Or I could just falsely claim that you're not sending me the data. And we can't resolve who's being honest in a disagreement like that. So we have to use other means than we can't slash people for not making data available because we can't prove that they are actually not making data available. We can only prove whether or not they're actually storing it. So what we do instead is we fall back on redundancy.
00:15:37.202 - 00:16:16.958, Speaker B: So we store, this is its own thing. So I think we'll move on for file contracts. For now, we will come back to state channels. So our file contracts are actually state channels. This is a scalability optimization super important one that is fundamental to making SCIA scalable redundancy. Okay, so every single, we use something called read solomon coding. It's a k of n redundancy scheme.
00:16:16.958 - 00:17:00.382, Speaker B: So I'll take a piece of data, I'll split it up into k pieces on the sine network. Today it's ten of 30. I'm going to go ahead and draw two of six, just because it's less things to draw. So we end up with do it this way. So we end up with six pieces of data out of these six pieces of data, two of them, and it doesn't matter which two are all I need to reconstruct the original data. So we fragment the file out in a two of six scheme, so we can pick any value we want for k and n up to on most libraries.
00:17:00.526 - 00:17:03.202, Speaker A: This is not like 255.
00:17:03.256 - 00:17:40.734, Speaker B: 255, that's correct. Zero to 255. And that's just because most libraries don't support bigger values. So we pick ten of 30. On the PSI network, the redundancy overhead, this is called a maximum distance separable code, is n divided by k. So on the sine network, that would be 30 divided by ten equals three x three x redundancy. So it's basically the same overhead as doing a one of three to do a ten of 30.
00:17:40.734 - 00:18:09.734, Speaker B: But the difference is, instead of needing in a one of three, you're host. If you get three rare events, three hosts are not responsive. In a ten of 30, you don't get a failure until you have 21 rare events or 21 failures. And so, probabilistically, one is exponentially better than the other. As you increase the total number of pieces for a fixed redundancy, your robustness goes way up.
00:18:09.852 - 00:18:19.050, Speaker A: But for a particular host. So let's say there is nothing else. Right, in the network. Then for a particular host, it is beneficial not to serve files, right?
00:18:19.200 - 00:18:25.470, Speaker B: No, because if you are not serving files, you are missing out on revenue because you get paid to serve files.
00:18:26.850 - 00:18:38.450, Speaker A: I see. Okay, so there's a renter in the host, right? So renter says, please serve me a file, here's some money, but I'm not giving you the file, so why would I not get the revenue?
00:18:40.710 - 00:18:47.458, Speaker B: This is where payment channels come in. So the way our payment channels work, we're going to go ahead and accept this as solved.
00:18:47.554 - 00:18:59.602, Speaker A: So far, it feels to me that at least one of them should be able, at some point, to trick the other. Right? So between you and I, let's say you're enter. I'm a hoster.
00:18:59.666 - 00:19:00.098, Speaker B: Right.
00:19:00.204 - 00:19:11.658, Speaker A: There's the moment when you actually receive the file, and there is a moment when you release the payment. To me, there's no way that is atomic. Right. So one of those must happen before the other.
00:19:11.744 - 00:19:30.340, Speaker B: So actually there is a way to make that atomic. I'm not going to go into it because it's not how we do it. Okay, so we do something called packetized payments. So what, the renter. And I'll just go ahead and use the numbers, typically. So the renter is going to send payment. The first step is the renter sends payment.
00:19:30.710 - 00:19:31.906, Speaker A: But it's a small payment.
00:19:32.008 - 00:19:33.694, Speaker B: Yeah, for four megabytes.
00:19:33.742 - 00:19:35.150, Speaker A: Oh, you're doing interledger?
00:19:35.310 - 00:20:16.514, Speaker B: Yes, although we predate interledger, so we've had this live since before the interledger protocol was devised. This came out in, I think, August 2015 on the PSI network. So then we trust the host for four megabytes worth of payment, then the host sends four megabytes. Then we do it again. And so if we're downloading a 1gb file, we're going to run this circle a bunch of times. If at any point the host takes our payment and doesn't give us data, now we know it's a bad host, and because we're talking to 30 different hosts, one, this gives us super high parallelism. So even if each host is pretty slow as an aggregate, the throughput is super high.
00:20:16.514 - 00:20:30.134, Speaker B: And since we've been doing ten of 30, which is also many years, the bottleneck for speed has always been how fast your computer is and how fast our code is, not how fast the networks are, but also, if I remember.
00:20:30.172 - 00:20:48.890, Speaker A: Right, how read Solomon libraries work. Right. So if this is our six shares, right, then each byte is encoded separately. Right. So you don't really need to have two out of six full shares. For each particular byte. We need any two shares, yeah.
00:20:48.960 - 00:20:58.942, Speaker B: So the way the sign network is structured, you do need a full two out of six. But for each chunk, so we chunk it.
00:20:58.996 - 00:21:02.442, Speaker A: Okay. Actually the same thing, I guess.
00:21:02.516 - 00:21:02.754, Speaker B: Yeah.
00:21:02.792 - 00:21:04.530, Speaker A: Just the chunk is not one byte, I guess.
00:21:04.600 - 00:21:39.938, Speaker B: Right. The chunk is not one byte, it is 200. And I think it's 64 bytes. So I think our chunks are 64 bytes at the read Solomon level, at the network level, our chunks. So we take what we do with a large file. Let's say we have a four gigabyte file. We're going to take this four gigabyte file, we're going to split it into, basically, so the sector size on the network is four megabytes.
00:21:39.938 - 00:22:09.986, Speaker B: So we're going to split it into sector size times min redundancy. Min redundancy, which is three x no min pieces, which is ten. We need ten pieces to recover. So that would be ten. Four times ten equals 40 megabytes. So we're going to turn this into 100 chunks of 40 megabytes.
00:22:10.018 - 00:22:13.794, Speaker A: Each chunk becomes 120 megs.
00:22:13.922 - 00:22:14.902, Speaker B: Yes, that's correct.
00:22:14.956 - 00:22:15.826, Speaker A: Operator coded.
00:22:15.858 - 00:22:32.670, Speaker B: And so we call this the logical data. We erasure code that into 120 megabytes of erasure coded data. And then each, and this is, of course, sliced into four megabytes each. Each slice gets sent to a different spot on the PSi network.
00:22:33.250 - 00:22:35.470, Speaker A: Each of this is a separate file contract.
00:22:37.410 - 00:22:37.966, Speaker B: Yes.
00:22:38.068 - 00:22:38.478, Speaker A: Okay.
00:22:38.564 - 00:22:43.178, Speaker B: Within one chunk. All right. Now we'll go to the payment channels. State channels.
00:22:43.194 - 00:22:48.418, Speaker A: I see. So if there was no state channels, each of those would result in on chain transaction. Yes, I see.
00:22:48.504 - 00:23:22.642, Speaker B: But because there are state channels, really what you do is, before we get into the technical details, you're going to pick 50 hosts again. I'll just draw 510. I don't know if that's ten. 2468. 910. Okay, and so we're going to have put the renter up here. The renter is going to form a contract, file contract with each of the ten hosts.
00:23:22.642 - 00:23:42.370, Speaker B: Now, it looks like a spider. Happy Halloween. And when we upload a file, each of these are a state channel. So we're going to use the state channel operation. We're going to update each of the file contracts to now include the new data. So your average file upload results in zero on chain transactions.
00:23:43.030 - 00:23:46.294, Speaker A: That's assuming that the renter already has state channels open with all of them, right?
00:23:46.332 - 00:24:05.370, Speaker B: Yes. So part of the setup process for Saya, the setup process is like one download client or get it from whatever source you have to get Saya. Damon. Two sync chain. Sync chain. Three form contracts.
00:24:07.150 - 00:24:09.210, Speaker A: So this opens state channels, and.
00:24:09.280 - 00:24:15.200, Speaker B: Yeah, this is this phase. And then four ready to go.
00:24:16.530 - 00:24:24.420, Speaker A: So opening a state channel is an on chain transaction, right? Yes. So we need to create 50 on chain transactions. Yes, to begin with.
00:24:26.150 - 00:24:54.774, Speaker B: And then once we have them, we can use them to upload essentially an unlimited amount of data as far as the protocol is concerned. As you saw, the file contract itself is a constant size. It just has a size and a Merkel root that scales infinitely. The storage proof is logarithmic. It's a Merkel tree proof. So that doesn't scale infinitely. But log, a logarithm in a finite universe, is constant.
00:24:54.774 - 00:25:01.566, Speaker B: Right. So by the time you're up to proof sizes of, I think, around 3 kb, you've exceeded what?
00:25:01.588 - 00:25:04.830, Speaker A: The universe isn't linear in a finite universe, also constant.
00:25:07.330 - 00:25:25.710, Speaker B: Technically. All right, that's fair. But if you say Storage proofs are always no more than 4 kb, that's bigger than all the data in the universe. So whereas linear, you're going to get much larger than that.
00:25:25.720 - 00:25:26.870, Speaker A: Yeah, a little larger.
00:25:27.290 - 00:25:45.334, Speaker B: Yeah. So the chain can handle, effectively an infinite amount of data per file contract. And the largest proof size you'll ever practically see is 4 kb. But the SIA client can't. There's a lot of metadata. It has to manage. This is actually something that we improved progressively.
00:25:45.334 - 00:26:24.422, Speaker B: So, like, when we first launched SCIA, we actually didn't have the state channels up. So the whole entire SIA network was good for about, I think, 10,000 files, and the largest acceptable file was like 50 megabytes. This was like 2015. And then later in 2015, also in 2015, we got it up to like 10 million files for the whole SCIA network. And then maybe each file could be up to, I think, 200 megabytes. Today we're doing much better. So each node, a single SCIA node today is effectively good.
00:26:24.422 - 00:26:31.114, Speaker B: Up to around 50,000 files in a single node and then around 20 terabytes in a single.
00:26:31.152 - 00:26:32.662, Speaker A: Per file, per node.
00:26:32.806 - 00:26:33.702, Speaker B: Per node.
00:26:33.846 - 00:26:36.314, Speaker A: There's no limit on the file size anymore, right?
00:26:36.352 - 00:27:09.480, Speaker B: If it's a single file at 20 terabytes, you're probably still good. And then the 20 terabytes, most of that limit comes from the repair process. We're still ironing that out. We have an internal fix that we're going to push out. We don't know if it bumps this number up or how much it bumps this number up. It's early, but this is what you can do today. And in theory, with practical engineering, as we keep working on it, we think that in the end, this number will be several million and this number will be several petabytes per node, no problem.
00:27:10.570 - 00:27:50.770, Speaker A: So one question I had was, so let's say. So as a. As a host, I still get the reward. So even though I'm losing revenue if I'm not serving a file, right, I'm still making some money because there's storage from the storage, right? Yes. So someone might contemplate the idea of having a huge node which is not connected to the network or like to fast network. Because if I have 20 terabytes of data, in principle that is quite a bit. Right, I might choose not to have a network.
00:27:51.110 - 00:27:51.860, Speaker B: Yeah.
00:27:52.470 - 00:28:03.286, Speaker A: Well, I guess, yeah. But rather my question is, is there anything today in the CN network which would like for a particular renter ban some heuristics to ban hosts which.
00:28:03.388 - 00:28:39.982, Speaker B: Yeah. So we have a module that we call the hostdb. As the name suggests, it is a database of hosts and the renter. So each renter has their own hostdb, the blockchain. When a host wants to announce the network, it puts into the blockchain an announcement, I'm a host, here's my IP address, ask me about my wares. And so the renter will ping the host, get prices, availability, whatever, a bunch of statistics. And then the renter keeps in its database just a big list of how good each host is.
00:28:39.982 - 00:28:54.870, Speaker B: And so if it's using, as it starts to use hosts, it gets better data. If it noticed that a host is slower or is withholding data or is otherwise unavailable, it downranks it in the hostDB. And so if you are having trouble.
00:28:55.290 - 00:29:06.780, Speaker A: Will it rehost something that is currently hosted? So let's say I put this file for, like, ten months, and like, one month in, I realize that one of the hosts is. So. So will it automatically rehost it?
00:29:07.230 - 00:29:48.294, Speaker B: Yes. So that's called the repair process. So let's say that the renter decides a particular host is bad. Whether it's because it's offline, it, increased prices, there are a number of triggers that could cause the renter to decide a host is bad. Basically what it does is when it wants to do a repair, it will download the file. So if we're doing a ten of 30 scheme, it'll find ten pieces, download them, reconstruct the original 30, and then whatever hosts need replacing, it'll find new hosts and replace those. It'll only do that once 25% of the redundancy is missing.
00:29:48.294 - 00:30:01.440, Speaker B: So 25% is missing. So the redundancy in our case is 20 pieces. Right. We call them parity pieces. 20 parity pieces. I misspelled that. That's okay.
00:30:01.440 - 00:30:32.386, Speaker B: Times zero point 25 equals five pieces. So once a particular, not 25% of all the older pieces, just 25% of the parody. So once five hosts are bad on a particular file, it will go ahead, download that file, replace those five pieces. Whichever five are the bad ones, it'll replace them, upload them to new hosts. And so the renter is constantly doing this. We call it churn. Just constantly doing this repair churn.
00:30:32.386 - 00:30:37.234, Speaker B: And obviously that can be a scalability limitation if it's happening a lot.
00:30:37.372 - 00:30:43.190, Speaker A: But for the renter, does it mean that renter can also stop the file contract?
00:30:43.350 - 00:30:50.522, Speaker B: The renter can stop uploading to the host, but the renter already put money into.
00:30:50.576 - 00:30:51.582, Speaker A: They already paid for it.
00:30:51.636 - 00:30:51.806, Speaker B: Right.
00:30:51.828 - 00:31:00.698, Speaker A: I see. That would result in a money loss for enter. Right? They already paid for storage, which they're not using anymore.
00:31:00.874 - 00:31:03.246, Speaker B: Yeah, for some amount of storage.
00:31:03.438 - 00:31:28.154, Speaker A: That's unfortunate. Yes, because I presume that. I see. So let's say I'm running a host machine. So that's what is not very nice. If I run a host machine and my host machine crashed and I'm in Hawaii, I'm not in a particular hurry to recover it. I need to recover it the first time my next file contract expires, right?
00:31:28.272 - 00:31:49.200, Speaker B: No. So what's going to happen is the renters have certain expectations. We can get into those later, but I'll make a thing for it. Actually, I'll just go ahead and write them out. So expectations. The big one is 95% uptime. Uptime per month.
00:31:49.200 - 00:32:13.974, Speaker B: So if you're offline for more than 5% of a single month, which is about one day, so you can afford to lose about one day of downtime in a row, the renter will start to penalize you and will start to churn you. And so if a renter is active, is constantly uploading new data, is constantly repairing, if you're a host and you have downtime, all the renters who are using you are starting to downrank you.
00:32:14.012 - 00:32:28.502, Speaker A: All right, what I meant immediately. So I will start losing revenue. What I meant is that for me to lose collateral. Yes. It's not particularly depressing. I need to restart my node before file contracts expire.
00:32:28.566 - 00:32:28.842, Speaker B: Yes.
00:32:28.896 - 00:32:31.550, Speaker A: Because that's a way bigger loss for me. Right. My collateral.
00:32:32.930 - 00:33:03.746, Speaker B: And generally speaking, if you're a busy host, I would expect you to have file contracts that turn up they constantly. But as we said, that window is about two days. Right. So it's intentional that you're not in a super big hurry because we have 29 other hosts that we can depend on. And that's actually one of the reasons the network is so cheap. Right. Like Amazon, their data centers, they have full time engineers that are on site 24/7 awake, alert, trained technicians.
00:33:03.746 - 00:33:31.166, Speaker B: They know how to operate the data center. They have multiple isps, multiple power companies. Our hosts. It's fine if you go on vacation, right? And then the thing crashes and you have to call your friend and get it to reboot it or whatever. If you're slower and have less uptime than a professional Amazon data center, this is seen as perfectly acceptable because you're not a single point of failure while you're down for 24 hours. We have 29 other people.
00:33:31.268 - 00:33:37.378, Speaker A: Right. But presumably behind the scenes on Amazon, there's also quite a bit of redundancy, right?
00:33:37.464 - 00:33:39.300, Speaker B: Oh, yeah, of course.
00:33:40.070 - 00:33:50.294, Speaker A: So for them, it's crucial that the proxy between you and Amazon is always life. But what is behind the scenes that could be very redundant, right?
00:33:50.332 - 00:33:58.950, Speaker B: That's correct. But in practice, keeping that proxy has a very high uptime. Yeah. Is very expensive expense we don't have.
00:33:59.020 - 00:34:07.850, Speaker A: So one other thing where I cannot see anything bad happening yet, but because you thought more about it, you probably know if there's something happening there. Sure. When I send those things.
00:34:07.920 - 00:34:08.202, Speaker B: Right.
00:34:08.256 - 00:34:17.626, Speaker A: Some of those entities could be the same entity, right? Yes. Because this is erasure coded. Could they cheat in some way? Especially if it happens that many of them happen to be the same entry.
00:34:17.658 - 00:34:23.220, Speaker B: This gets into encryption. So the process is we.
00:34:26.310 - 00:34:28.878, Speaker A: Only, I can recover. They cannot recover.
00:34:28.974 - 00:35:22.014, Speaker B: We split the file. Yeah, and then we encrypt it. I'll just do e and then I'll put it into. I'll make it a puff after encryption. So even if all of these are the same host, and they each have one piece, and they know that the pieces go together, they can't put them together because the encryption is applied after the erasure coding, the renter has perfect confidence that the redundancy can't be cheated. This comes with a trade off, and this is the trade off that Sia makes that filecoin does not make, that resulted in filecoin doing requiring tons of open research problems. So this is fairly easy, but it means that the renter, or someone that the renter trusts with the encryption key is the only one able to do repair.
00:35:22.014 - 00:35:58.650, Speaker B: So if the renter is, like, on vacation and three hosts disappear, or let's say half the host disappear, so now the renter is in trouble, needs to repair as fast as possible. If the renter is on vacation, the network can't repair on behalf of the renter because the network doesn't know what the encryption keys are. So either the renter themselves or someone that the renter has trusted the encryption keys to has to be the one to do the repairs. Whereas filecoin has all these deep research questions that are open. How do we make it so that we can repair it without someone being able to cheat?
00:35:58.730 - 00:36:01.280, Speaker A: Well, if you believe in magic, you can use SGX, right?
00:36:02.470 - 00:36:27.474, Speaker B: Yes, that's one option. SGX, and they have a bunch of crypto protocols, require trusted setup, so similar assumptions to SGX, in my opinion. Regardless, we don't like that. We do a pure, verifiable route. We make the trade off. The renter has to be around, or someone they trust has to be around to do file repairs. That's just a limitation of the SIA network.
00:36:27.474 - 00:36:31.514, Speaker B: If filecoin figures out proof of replication one day, maybe we can move to it.
00:36:31.552 - 00:36:45.374, Speaker A: And so, in practice, in SIa network, SIA network, other participants who, let's call them watchtowers, but I guess they're not real watchtowers, like other entities whom you give the key, and they will do.
00:36:45.412 - 00:36:55.354, Speaker B: Redundancy in practice today. No, those don't exist. We haven't needed them. Although maybe someday you will see that pop up.
00:36:55.412 - 00:37:02.100, Speaker A: But also in practice, how frequently do you observe? Or first of all, can you observe someone doing churn from.
00:37:03.190 - 00:37:22.474, Speaker B: So we run our own nodes, right? So we can observe when we have to deal with churn. And of course, we talk to our community, so lots of people run large nodes. And actually, right now, again, we already have the fix for this in the lab. We're trying to push it out. We were trying to push it out this week. Didn't quite make it. Maybe next week.
00:37:22.474 - 00:37:27.690, Speaker B: But right now, churn is actually fairly high on this high network. And this is due to a scoring error.
00:37:29.230 - 00:37:30.830, Speaker A: But high is like, how high?
00:37:30.980 - 00:37:38.430, Speaker B: High would be like maybe 25% per month.
00:37:38.500 - 00:37:39.280, Speaker A: I see.
00:37:40.530 - 00:38:08.600, Speaker B: After the scoring fix, I think it will be closer to. I predict it'll be closer to 5% per month, which is still. If you have 100 terabytes of data, that means you're repairing five terabytes a month. That's still fairly substantial, but we'll see. So churn is definitely like, from a scalability perspective, that's probably the biggest bottleneck is how much repair bandwidth do you need per terabyte you put on the network every month.
00:38:09.290 - 00:38:13.986, Speaker A: But also right now, this value, ten out of 30, is it hard coded or can I configure it like.
00:38:14.028 - 00:38:15.174, Speaker B: Oh, it's fully configurable.
00:38:15.222 - 00:38:23.326, Speaker A: Okay. So if I want to go to Hawai, I will just set it to five out of 100. Sure. Okay. Probably for several months. I'm fine.
00:38:23.428 - 00:38:23.742, Speaker B: Yeah.
00:38:23.796 - 00:38:25.262, Speaker A: I'm paying more for storage, though.
00:38:25.316 - 00:38:54.550, Speaker B: And in practice, data that's unmaintained for a full month at ten of 30 is completely fine. You don't lose 21 in a single month. Normally it would take three to six months. One other thing, on the sci network, file contracts are typically, they typically last around three months. And so if you're gone for more than three months, all your file contracts expire. Host delete all the data you need to renew them. You need to let the host know you're still interested.
00:38:54.550 - 00:38:58.366, Speaker B: You need to repay to keep the file contracts aligned.
00:38:58.418 - 00:39:00.922, Speaker A: But I can renew the contract without reuploading file, right?
00:39:00.976 - 00:39:02.380, Speaker B: That's correct, yes.
00:39:03.470 - 00:39:09.930, Speaker A: Okay. Is there anything else interesting, or did we cover almost everything?
00:39:10.000 - 00:39:15.120, Speaker B: There's lots of interesting things. So one thing we didn't cover is how the state channels work.
00:39:16.130 - 00:39:19.402, Speaker A: Are they significantly different from state channels?
00:39:19.466 - 00:39:54.140, Speaker B: Not really. The one thing we have is an update number. A lot of state channels do have this, a lot don't. But it's basically like. So the file contract has Merkel root size, end height, start height, and then it also has this revision number, which is a UN 64. So if you want a file contract that cannot be revised for whatever reason, you just set it to Un 64 max. That contract can't be revised in practice, I don't think anyone does this because there's also a renter private key.
00:39:54.140 - 00:40:01.420, Speaker B: Renter public key. Sorry. And a host public key. So you need signatures from both to update the thing.
00:40:02.030 - 00:40:12.442, Speaker A: If I set revision to Intmax, that means I can close it without challenge, period. Well, I don't know if it's implemented, but that would enable it. Right.
00:40:12.516 - 00:40:18.670, Speaker B: So actually, all you have to do, there's a success balance.
00:40:18.830 - 00:40:19.410, Speaker A: I see.
00:40:19.480 - 00:40:42.086, Speaker B: Success Bal actually success outputs. So the renter gets some money back, the host gets the money back, and it's just how much. Right. And then there's fail, where the renter gets the money back. The host gets the money back, and then the void it has to add up to. And then there's an input. There's a payout up here.
00:40:42.086 - 00:40:59.482, Speaker B: These two have to add up to the payout. These three have to add up to the payout. So this is the void. So you have renter host. Void, renter host. And so in the fail, these two are significantly smaller because we destroy money in the success. Usually it's mostly host weighted, but it depends on how much you use the contract.
00:40:59.482 - 00:41:27.446, Speaker B: If you opened a contract and then uploaded almost no data, the host never put in any collateral, the renter never put in any revenue. And so both of them basically just get out what they put in. And so if you want to close out a contract early, what you can do is you change the start height and end height to just be now. Right. And then you create the success outputs and fail outputs to be equal to each other. And then it'll just fail immediately. Right.
00:41:27.446 - 00:41:31.640, Speaker B: The file contract will fail immediately, and the hosts will get paid.
00:41:32.430 - 00:41:36.460, Speaker A: I, as a renter, can just close the contract and pay to the host. Yes, I see.
00:41:38.190 - 00:41:39.066, Speaker B: That's how you'd close.
00:41:39.088 - 00:41:43.326, Speaker A: And then on the protocol level, that will not have any challenge, period. Or rather, even if it does, nobody will challenge it.
00:41:43.348 - 00:41:43.534, Speaker B: Right?
00:41:43.572 - 00:41:51.086, Speaker A: Yeah, I see. But I get no money in this case, all the money go to host. Or there's still something that.
00:41:51.188 - 00:41:54.350, Speaker B: It depends on what the renter and host agree.
00:41:54.500 - 00:42:02.770, Speaker A: Because in this channel, right. If I have the channel with the host, it could be that I have more money in the channel that I need to pay for. Anything we have right now open with them, right?
00:42:02.840 - 00:42:30.970, Speaker B: Yes. What could happen is you put 100 psychoins into a channel, right? And then initially, let's say we close the contract super early. So what's happened is the renter has paid ten sc to the host. Let me break this down a little more. So we have a file contract. Renter in, renter in will call 100 psycoins. Host in will call 200 psycoins.
00:42:30.970 - 00:43:10.754, Speaker B: These are recommended parameters. And then what's going to happen is if the renter is only stored a little bit, you might have success. Look like this, where it's renter gets back, the renter gets back 99 psychoins, the host gets back. Will that be two? One cycoins, one cycoins and then fail would be renter, renter, 99 psychoins. Host gets back, that would be 198 psychoins. And then void is going to collect the rest, which is three psychoins.
00:43:10.802 - 00:43:13.066, Speaker A: So what does this number 198 come from?
00:43:13.168 - 00:43:20.922, Speaker B: So the host was originally at 200 psycoins. The renter paid one cycoin to store some amount of data.
00:43:20.976 - 00:43:21.782, Speaker A: Oh, that was collateral.
00:43:21.846 - 00:43:41.426, Speaker B: And the host put in two cycoins of collateral. And so the void gets three in the fail case. But if we want to do an early close, what we would do is we would x out this fail or actually, okay, if we ignore this x, we would x this one out and this one out and this would go to 201 and this would go to zero. I see.
00:43:41.448 - 00:43:44.466, Speaker A: And so such contract can be closed without challenge period. Exactly.
00:43:44.568 - 00:43:57.000, Speaker B: Okay. You'd reduce the challenge period to just immediately and it'll fail immediately. But the failure condition is the same as a success condition. The host doesn't care. They get all the same money if it had been a success.
00:43:58.190 - 00:44:11.180, Speaker A: I see, cool. So you also mentioned that it is cheaper than Amazon. So in practice, what is the actual comparison of prices of Saya versus, let's say s three?
00:44:12.750 - 00:44:43.270, Speaker B: And then we can talk about snapshot backups, which I think are super cool and we should definitely talk about. And then we can talk about streaming, which is also pretty cool. Okay, so prices, let me see if I have signal in this room. I just pull up the live feed of our prices and I do just already have the page open because as soon as it loads storage.
00:44:44.170 - 00:44:46.354, Speaker A: But do you also know Aws prices?
00:44:46.482 - 00:45:26.414, Speaker B: Yes. Upload bandwidth. So storage bandwidth on the PSI network today our storage cost is month upload bandwidth costs $0.160 point 16 bandwidth. DL BW is whatever, $0.830 point believe $21 upload bandwidth I think is free on Amazon. I don't think they charge you to upload.
00:45:26.414 - 00:45:44.650, Speaker B: And for download this is about $90. So we have between a ten and 20 x improvement on storage cost and between a 51 hundred x improvement on bandwidth cost. Actually, right now we're over 100 x improvement on bandwidth cost. So prices are super competitive on this high network.
00:45:46.270 - 00:45:47.980, Speaker A: That doesn't sound bad at all.
00:45:48.430 - 00:45:49.740, Speaker B: Not bad at all.
00:45:50.510 - 00:45:56.030, Speaker A: But it does surprise me a little bit because on Amazon, the storage itself is heavily optimized, right?
00:45:56.100 - 00:45:56.286, Speaker B: Yeah.
00:45:56.308 - 00:45:58.990, Speaker A: So is it the case that all the hosts are also some professional?
00:45:59.410 - 00:46:41.354, Speaker B: So some of them are professionals. And I think the end game of the Psy network, kind of like bitcoin mining, they will all be professionals at some point. Right now, the total amount of storage on the side network is about 675 terabytes as of writing this video or as of right now. So you multiply this by this, you see it's not that much money that's getting paid per month. But as this goes up, I think we'll see increasingly more and more professionals come in. They'll continue to push the prices down. But the real cost advantage, I think, for us comes from a significant relaxing of trust requirements, significant reduction of barrier to entry.
00:46:41.354 - 00:47:04.210, Speaker B: So if you have a host on a fast Internet connection, you can just buy some hard drives and offer them up to the network. And then the uptime requirements, 95% is more than you can do on a laptop, but it's pretty easy from just any. You don't need a crazy isp or a crazy power supply agreement.
00:47:06.170 - 00:47:08.306, Speaker A: Cool. Okay, so snapshot.
00:47:08.418 - 00:47:41.626, Speaker B: Snapshots. Okay, where to start? I'll start with, we won't dive into the technology initially. We'll just talk about the end result. So I can do is I can upload a bunch of files to the sci network. We'll just call ifs, right? My fs. And this could be some folder tree. F one folder, one file, one file, two file, three, et cetera.
00:47:41.626 - 00:48:42.702, Speaker B: So I could have a ton of files and a ton of folders. And so I'll just create a snapshot of these folders. So snapshot. And then I can say, save my snapshot. And so when I create a snapshot, it will essentially freeze the metadata, make a copy of the metadata, upload the metadata to the SIA network, and then create a bunch of pointers such that in the future, if I lose my machine, my house, whatever, and I have to start fresh, I can grab a new computer, download saya, put my wallet seed in, and this snapshot will show up and all the files listed in this snapshot will be recoverable. And I need to know nothing more than my wallet seed to get all of my data back. And this, I think, is the feature that really makes Sia like a viable, proper backup solution.
00:48:42.702 - 00:49:10.330, Speaker B: So this is something that's live today. And now I can dive into kind of how that works. And it's actually fairly complicated. This is a feature we added earlier this year. So it took us almost five years to get Saya to a maturity level where it could do this. Okay, so step one is we have a blockchain full of information. So this is the blockchain.
00:49:10.330 - 00:49:35.250, Speaker B: Blockchain. And in the blockchain are all of our file contracts. So we'll just call this. And actually they're probably all in one period of time. So, like right here, I might have my slice of 50 file contracts that belong to me. So when we create the file contracts, all transactions in Saya have this. Fc.
00:49:35.250 - 00:50:13.226, Speaker B: Here's the file contract. They also have something called the arbitrary data. So inside the arbitrary data, what we do is we put a color, which is really just a hash of our seed appended with some extra. This is a little bit of a simplification, but let's say the host pub key. Host pub key. And so if I have my seed, I can see in the file contract what the host pub key is. I know what the color would be of this contract if it was mine.
00:50:13.226 - 00:50:30.550, Speaker B: And importantly, because it depends on my seed, which is a secret, nobody else can make a file contract that I'll mistakenly think has my color. They don't know what data they need. So basically, thanks to. And again, it's a little more complicated than this because it's a little bit safer than just using your seed in the raw.
00:50:33.130 - 00:50:38.934, Speaker A: But I think one thing we didn't define is the problem. Right? Oh, yes. Why was it hard? Because I lost all my state channels. Right.
00:50:38.972 - 00:50:43.290, Speaker B: You lost everything. So you have no information at all except the blockchain, which is public.
00:50:43.360 - 00:50:43.850, Speaker A: I see.
00:50:43.920 - 00:50:49.766, Speaker B: So we can download the sciaic line, which is public. We can download the blockchain, which is public. And we have our seed.
00:50:49.878 - 00:50:51.398, Speaker A: But we don't have any state channels.
00:50:51.414 - 00:51:07.920, Speaker B: And we don't have anything else besides our seed. And so from our seed we have to derive everything else. And so this is why the color is important. We know our seed. We know the host pub key because it's in the file contract. So as we're scanning through, we're going to find, I think, a million file contracts in the blockchain. That's how many are in the blockchain today.
00:51:07.920 - 00:51:29.034, Speaker B: And so a million times you're going to check and you're going to say, oh, no, this is not mine. This is not mine. This is not mine. But 50 or more, depending on if there's been churn or if you've done renewals or whatever, some of the contracts you're going to find, you're going to be like, yes, this is mine. You're going to be able to pull out your file contract. Also in the blockchain are a bunch of host announcements. Right.
00:51:29.034 - 00:51:33.418, Speaker B: And so what that is is a public key to IP address.
00:51:33.584 - 00:51:37.034, Speaker A: So I just want to query them for the latest state.
00:51:37.152 - 00:51:40.638, Speaker B: That's correct. But this is risky, right?
00:51:40.804 - 00:51:43.262, Speaker A: Because we don't want that.
00:51:43.316 - 00:52:06.978, Speaker B: We've lost our data. We can identify our file contracts. We know from the public key inside the blockchain. There's also this public key to IP address mapping. We know what IP addresses to ping. Something that we do in our protocol is that every time we connect to a host, no matter what, we open the connection by pretending we've lost our data.
00:52:07.064 - 00:52:07.554, Speaker A: I see.
00:52:07.592 - 00:52:12.374, Speaker B: So we're trying to trick the host into taking advantage of us when, but.
00:52:12.412 - 00:52:14.550, Speaker A: If we didn't lose the data, we would immediately slash them.
00:52:14.620 - 00:52:32.710, Speaker B: Exactly. We immediately know that they're cheating. We know not to use them anymore. The one time that we have no ability to double check if they're cheating, they don't know because our behavior is identical to all the other situations.
00:52:32.870 - 00:52:35.360, Speaker A: As long one third is cooperating, we're fine. Right.
00:52:36.050 - 00:52:50.770, Speaker B: So what you can actually do is you can give and we don't do this yet. This is something we'd like to like to add. But what you can do is you can put the entire state, you can put every state channel on every host. So every time you connect to a host, you can ask them for all your state.
00:52:50.920 - 00:52:51.570, Speaker A: Okay.
00:52:51.720 - 00:52:54.606, Speaker B: And this actually creates an interest incentive.
00:52:54.638 - 00:52:56.200, Speaker A: Even if at least one is honest.
00:52:56.570 - 00:53:29.246, Speaker B: Then you can get everything back. And hosts are all in competition with each other. Right. So the other people that I'm using are this guy's competition. This guy, the honest host, actually kind of has an incentive to have his dishonest competitors go out of business. So he actually wants to give me, he may not want to give me my channel state for him, but he wants to give me my channel state for everybody else so that I can penalize everybody else. And so there's just this nice little second layer incentive working in our favor.
00:53:29.348 - 00:53:38.500, Speaker A: But this particular feature of always requesting Azure pillows data, was it added as part of this change with snapshots or was it also needed before for something?
00:53:38.870 - 00:53:52.838, Speaker B: So it wasn't needed before. We've been planning this for a long time, so we've had that behavior in the network for a long time. But we did add it specifically because we knew we would need it down the road.
00:53:52.924 - 00:53:54.520, Speaker A: Yes. Interesting.
00:53:55.050 - 00:54:12.654, Speaker B: Inside. So now we have our file contracts back. We have our state channels back. We still need some way to fetch the metadata. And so basically, the first, a file contract is. Okay, this is kind of interesting architectural stuff. Zoom out again.
00:54:12.654 - 00:54:58.496, Speaker B: How's a file contract orchestrated or managed? So we have a file contract today, file contracts are broken into two sections. The first section is like a fixed data section. Fixed section. And then the second section is a random access section. So the fixed section is where we store a pointer to. When we created that snapshot, we actually uploaded it as a file. So somewhere in this random access section, there's a file that has snapshot.
00:54:58.496 - 00:55:27.548, Speaker B: Snapshot. And then that snapshot, of course, o t that snapshot, of course, will point to all the other files that we have. So here we have a pointer. And so we'll just look at this is index zero. So in index zero, we have a pointer that says this thing, this route is a snapshot. So most of our files are stored by their Merkel route. The host keeps a table on its side that goes from Merkel route to data.
00:55:27.548 - 00:55:59.828, Speaker B: And so if I ask the host for a particular Merkel route, it can give me the data. I know that it gave me the right data, because I hash it up. I see if the Merkel roots match. And then what that means is that when we want to do something like deletion, what we can do, if this is a million nodes long, which for some file contracts, that's four terabytes. A million nodes is four terabytes. If it's a million nodes long, we don't want to have to recompute the Merkel route across four terabytes of data. That's way too much hashing.
00:55:59.828 - 00:56:17.070, Speaker B: So what we do instead is we will swap this guy with the tail, and then we only have to do logarithmic number of operations. Instead of sliding everything over, we do a swap. We have the tree cached log number of updates. We get a new Merkel route. Nice and easy.
00:56:18.000 - 00:56:22.130, Speaker A: We have the tree cached for a four terabyte file. That's pretty big.
00:56:22.580 - 00:56:26.064, Speaker B: It's not too bad. And we don't cache every layer, just.
00:56:26.102 - 00:56:27.484, Speaker A: The top ones we cache.
00:56:27.532 - 00:56:46.440, Speaker B: Yeah. So the big one is we cache every four megabyte. So we cache every four megabytes. And then I think there's a second layer, seven above that. So whatever four megabytes times two to the seven is, I don't know. Actually, I do know. 512 megabytes.
00:56:46.440 - 00:57:17.148, Speaker B: We save another, save another hash. So this allows us to do things efficiently. And then something we're rolling out in the next three months or so is garbage collection. So the delete operation I explained we don't actually have right now, this will eventually be broken up into three sections. You'll have your fixed section.
00:57:17.244 - 00:57:30.692, Speaker A: So one question I have is, why is this not the very first file random coming again? Why is snapshot not the very first file that they have? Like, why would it not be just at the beginning? So that they don't have to look it up.
00:57:30.746 - 00:57:35.320, Speaker B: Yeah, because then we can repair the snapshot. We can make changes to it.
00:57:35.390 - 00:57:36.170, Speaker A: I see.
00:57:38.060 - 00:58:12.080, Speaker B: Also, we can make a bunch of them. So if we have, like, actually, I think the correct answer is so we can have a bunch of them. If we have 50 different snapshots, it becomes a pain to try and front load 50 things and keep them ordered. And then when we want to prune them or delete them, figure out how to do that when they're all in fixed. So, like, the snapshots to be random access, so that if we want to shuffle things around, it's free. The fixed section, everything's referenced by index, so it means whatever's there can't move, and we have no flexibility to touch it. If you delete something in the middle of a fixed section, you can't reclaim that data.
00:58:12.080 - 00:58:28.044, Speaker B: You can only wait until someone wants new, fixed data to go there. Whereas in the random section, we can just pop things around a bunch because nothing points to it by index, everything points by merkel root. And so that's why snapshots go out in the random section, because it's easier.
00:58:28.112 - 00:58:31.064, Speaker A: So this is a file contract between me and a particular host, right?
00:58:31.102 - 00:58:49.796, Speaker B: Yes, you and one particular host. So our snapshots. And that's the other thing. So every host has the fixed section. This is replicated. If you have 50 hosts, your fixed section is replicated across 50 hosts, but your snapshot can be erasure coded.
00:58:49.848 - 00:58:50.320, Speaker A: I see.
00:58:50.390 - 00:59:15.930, Speaker B: And so the snapshot, which can be quite a bit larger, the fixed section, the pointer to the snapshot is either 32 bytes, or if you've erasure, coded the snapshot, maybe it's 32 times 50 bytes, 32 times 50 pointers. But the snapshot itself, we can erase your code that we don't have to fix, 50 x replicate it. So, yeah, a couple of good reasons to keep the snapshot in random land.
00:59:17.740 - 00:59:20.890, Speaker A: Cool. Yeah, that's interesting.
00:59:21.580 - 01:00:30.440, Speaker B: So the last thing streaming streaming video streaming. This is really just tip of the iceberg for engineering advances on the SCIA platform. But one thing that we're really excited to be able to support is video streaming and fuse, which is file system in user space. What this means is that you can mount SIA as a drive on your computer, and so something like VLC or Plex Media center will recognize the folder that is actually a SIA folder as a normal file system folder. And so we're working on an integration with Plex called Sciastream that allows you to put your media library onto the SCIA network and then stream from it to any of your Plex endpoints and view your content. So that's, like, one interesting use case that we're rolling out the SCIA network.
01:00:30.520 - 01:00:39.988, Speaker A: Cool. And so the idea. So streaming works because effectively, I'm already streaming my file from the host. Right?
01:00:40.074 - 01:00:40.710, Speaker B: Yeah.
01:00:41.480 - 01:00:49.792, Speaker A: But it is erasure coded. But it's erasure coded in chunks. I recover one chunk. Yeah. I replay it. I recover the second chunk.
01:00:49.856 - 01:01:17.856, Speaker B: Yes. The actual erasure coding bits are, I think, divisible, down to 64 bytes. I don't think we have a specific vocab word for the 64 byte segments. If you want just the first, like, say, two megabytes of a 40 megabyte chunk, you can download just the first two megabytes. You don't have to download the whole 40 megabytes. And that makes it responsive. Streaming platform.
01:01:18.038 - 01:01:18.720, Speaker A: Awesome.
01:01:18.870 - 01:01:19.232, Speaker B: Yeah.
01:01:19.286 - 01:01:25.040, Speaker A: Cool. So we covered everything. I wish there's way more. Awesome.
01:01:25.190 - 01:01:25.696, Speaker B: Yeah.
01:01:25.798 - 01:01:29.788, Speaker A: Okay, so that was fun. Thanks a lot for coming and talking about Sia.
01:01:29.884 - 01:01:30.960, Speaker B: Absolutely. Thanks.
01:01:31.110 - 01:01:35.070, Speaker A: How to pronounce it? Awesome. Thanks a lot, everybody. Until next time.
