00:00:00.250 - 00:00:59.120, Speaker A: Hey, everyone, thanks for joining the runtime walkthrough session. Again, the topic today is going to be initialization from the Genesis actions and the receipts. And also we're going to look at how we actually execute those callbacks and how the promises work in the runtime. Because we've been talking last time, that near provides a very friendly a developer experience for the contract developers, and that allows them to work with promises without thinking how it's been executing behind the scenes. So we're going to actually look inside this box and see how promises translate into very specific messages that runtime is passing between the shards and executing. So we're going to start again with some analysis of the cases that we have. Do you guys see my whiteboard here?
00:01:00.450 - 00:01:01.054, Speaker B: Yes.
00:01:01.172 - 00:01:26.614, Speaker A: Cool. All right, cool. So again, we have multiple shards in the runtime. Draw them like this bunch of shards. Each shard has its own in the blockchain. Each shard has its own runtime. And let's say you have Alice, who is trying to call contract Bob just as a walkthrough of what we discussed last time.
00:01:26.614 - 00:02:28.054, Speaker A: So say Alice contract is trying to call Bob contract, and Alice lives on Shard A and Bob lives on Shard B. So what's going to happen is that the transaction is going to arrive to this shard. So you're going to have a transaction arriving to Shard A. Then this transaction is immediately getting converted into the receipt. It's actually going to be local receipt. As far as I remember the last time we discussed that when transaction and the contract that it calls or like the account that it's target is on the same shard, that it just becomes local receipts and it executed immediately. It's been converted to the receipt it calls contract Alice.
00:02:28.054 - 00:03:16.774, Speaker A: And then Alice is actually going to create another receipt that is going to be targeting contract Bob. And on the next step, so let's say this is block x and this is block x plus one. So on the next step, Shard B is going to process this receipt and execute it, right? Yes. So now let's take in the more complex scenario. The more complex scenario is when you have a callback. So let's say Alice wants to execute contract Bob, but at the same time have a callback back to Alice. This can be useful, for instance, when you're building an exchange.
00:03:16.774 - 00:04:11.770, Speaker A: So for instance, if you're working with the exchange in near, you would call an exchange and say exchange token x for token Y. Exchange contract will send a call to the contract X, send a call to contract Y in parallel. And then when I receive the callbacks, both from contracts X and Y, and try to do something, swap them, for instance. So the callbacks is like a very important part of the contract building experience in near. So let's say again that we have Alice contract Bop. And then once contract bop executes, Alice wants to be called back again. So it's Alice calling bop, and then it's getting called back again to Ellis.
00:04:11.770 - 00:04:53.340, Speaker A: In here is the key. The way you would write it is that you would create a promise to Bob and then you would attach a callback that says, call me back again when Bob is done. And the way it's going to work is in terms of the receipts is again the transaction arrives to shard a, then the local receipts is being processed. Then shard a spits out the receipt that travels to shard B. And block x plus one is getting executed. But now on the next block, shard B needs to call back Alice. So obviously there needs to be like next step, next step like this.
00:04:53.340 - 00:05:06.366, Speaker A: And this is going to be, let's say, block x plus two. And in this block x plus two, shard B is actually talking now to shard a.
00:05:06.548 - 00:05:08.990, Speaker B: That's a bit off screen, by the way, max.
00:05:09.730 - 00:05:10.942, Speaker A: It's a bit off screen.
00:05:11.076 - 00:05:12.720, Speaker B: The stuff on the right hand side.
00:05:13.330 - 00:05:22.306, Speaker A: Okay. Can you see the shards? So the diagram or not? Or is it cut through?
00:05:22.408 - 00:05:28.162, Speaker B: We can see the cut off side of the far right, two squares, shards.
00:05:28.226 - 00:05:51.418, Speaker A: Okay. God damn it. Let's try doing something about it. Okay. How about now? It's better. Is it better? Cool. So shard B now needs to call shard a on the next step, right? Because the callback is happening.
00:05:51.418 - 00:06:49.386, Speaker A: And the way it's going to work is there's also going to be a receipt flying because you need some information, you need some exchange of information between shard B and a. But this receipt is going to be called data receipt. Data is because it just tells the result that b was executed. It just has some information that, well, b has executed, maybe with certain even data, because you want to have callback, maybe with some data. And that's why it's called data receipt. And the receipt that calls contract b the first time, it's called action receipt. All right, so this is pretty much the high level overview of very simple approach of a very simple scenario where you have a callback, cross control call with a callback, and you have both action receipt and data receipt.
00:06:49.386 - 00:07:23.498, Speaker A: By the way, the local receipt is also going to be action receipt. Now let's look at the code in those actually action and data receipts to see what they are. 1 second, let me see. Are there any questions? I think there might be questions. All right, discuss later. So right now you see my id again.
00:07:23.584 - 00:07:25.850, Speaker C: It's slower, smaller.
00:07:26.350 - 00:07:27.546, Speaker A: Cool. There we go.
00:07:27.648 - 00:07:28.346, Speaker C: Thanks.
00:07:28.528 - 00:08:19.878, Speaker A: So this is action receipt. Let's go back to the runtime. So the way I always start working with the runtime, as I recommended you last time, you start with the apply method, which is like a go to for most of the information. You see the receipt here, which is the central structure that I was discussing. Receipt has some predecessor id, which is just an information who emitted this receipt. In case of the transaction, that is going to be the account that signed to the transaction that was converted to the receipt. If this is a receipt that was created by another contract, in case like when Alice contract called Bob contract, the receipt that's lying to Bob is going to have a predecessor Alice, even if Alice was not the one that was actually signing, the original transaction receiver is the one who is receiving this receipt.
00:08:19.878 - 00:08:50.210, Speaker A: And this is some unique identifier that we're going to use to identify this receipt globally in the blockchain. And this is where most of the stuff is. So the receipt announced, you can see it can be either action or data. So that's what I was talking about. An action receipt contains those actions that we visited last time. So it actually tells you what to do. It tells you create account, deploy contract function, call, et cetera.
00:08:50.210 - 00:09:28.366, Speaker A: The data receipt, it doesn't have actions, it only has a blob of data, maybe. So if your callback does not require transferring some execution result. For instance, Alice called contract Bob. But when Bob was executed, when the contract bob was executed, the function, the contract function did not return anything. It returned like void. Then this is going to be null and otherwise. It's going to contain some serialized execution results.
00:09:28.366 - 00:10:00.890, Speaker A: Depending on what kind of language you're going to use. It's going to have different data in there and going to probably use different serialization methods. So that's the difference between action receipt and data receipt. That data receipt only contains execution result of the contract when it's being used for the callback. An action receipt actually has the actions, as I said. So here is an interesting thing. We now start looking into the data ids.
00:10:00.890 - 00:11:05.410, Speaker A: So the receipt has dependencies. So it has dependencies called input data ids, and it produces something called data receivers, which also has some data ids. So what does it mean? Let me go back to this drawing. So in this drawing, the way we execute this callback is by creating a receipt that waits for the data receipt to arrive. So when we convert transaction to the receipt and execute the receipt. So the moment the receipt is executed, we realize that we need to call contract Bob, but at the same time we're going to wait on contract Bob to finish execution. So what we're going to create, we're going to create an action receipt here, but we're not going to execute it immediately.
00:11:05.410 - 00:12:05.090, Speaker A: We're just going to store it in our state and then we're going to identify that. Execute this receipt only when you receive callback from Bob. So it's like a dependency. And then what happens is that when Bob finishes execution and it emits data receipt, this data receipt here and this data receipt arrives to shard a the runtime finds this action receipt that we stored for later. In the first step, it identifies this data id of this data receipt is equal to the data id mentioned in the callback. And it now knows that it can execute this stored action receipt. And that's how callbacks work in the runtime.
00:12:05.090 - 00:12:10.466, Speaker A: So in this case, again, we are.
00:12:10.488 - 00:12:28.860, Speaker C: Not seeing parts of the right parts of that stuff, but during the time when you are moving this stuff, my question would be the purpose of creating of action receipts. Is this for the sake of saving network here?
00:12:30.350 - 00:12:32.906, Speaker A: Saving network, yeah.
00:12:33.008 - 00:12:45.650, Speaker C: So why Bob contractor is not able to send an action receipt back to there are targeting the same contract of Alice.
00:12:47.270 - 00:13:41.780, Speaker A: So there are probably several potential designs of the runtime that could achieve similar result. So one of them is that Bob could maybe send an action receipt back to Alice. Then that means that Bob needs to know that it needs to send an action receipt. So Bob contract, when it executes, needs to know that it needs to tell a very specific execution to Alice. And it kind of seems to be like a very simple thing to implement when you have a single cross contract call when Alice calls Bob. But if you have, let's like Alice calls Bob, and then Bob calls Carol and then Carol calls whatever, I don't remember, Danny. And then et cetera, and then someone calls Alice back again.
00:13:41.780 - 00:14:52.810, Speaker A: Then as you call in this chain of contracts, at each step, you need to remember somehow through your receipts that at the very, very end you got to call Alice. So you're going to be passing this data around with a specific action receipt for Alice with a specific execution result like all through the chain. And in this case, what you are doing is that you are just passing the data id, which is kind of simpler because it's just like an identifier rather than the whole structure that you are tossing around the blockchain. And that's like the big number one difference. So the number two difference is that we also allow the following scenario. So Alice can call Bob, then Alice can in parallel call Carol. So Alice would construct promise for Bob, it would construct promise for Carol, and then it would say when both of them execute at the same time, when both and Carol execute at the same time, call back Alice.
00:14:52.810 - 00:15:16.094, Speaker A: And in the example with exchange, that would be quite obvious. An example, right. You have an exchange, you want to have a contract call to one token that locks it certain amount. You want to have contract call to another token that locks certain amount. You want to wait for both of them. You don't want to be called twice. You want to be called once when both of them are ready.
00:15:16.094 - 00:16:10.050, Speaker A: And so you need to kind of bundle them together on the runtime level. Say, only bother me when all this stuff is done, and only then I'm going to be executing something. So when you want to have something like that where your callback is bundled, it's easier when you have multiple data ids rather than you pass information. Because then if you say, for instance, that Alice needs to be called when Bob and Carol is done, then neither Bob nor Carol is going to be the primary responsible contract for calling Alice. So who is actually going to be emitting this action receipt, Bob or Carol? I mean, they're kind of equal in this position, should be neither of them. And this is actually a great question, because it's a segue to multiple data ids. So in this case, Alice has two dependencies.
00:16:10.050 - 00:16:14.210, Speaker A: So Alice, action receipt.
00:16:16.410 - 00:16:28.570, Speaker C: Yeah, Max. And by the way, it is a hell in the screen happening. At least what I see. Yeah, I don't know, maybe you need to restart the screen sharing.
00:16:29.390 - 00:16:32.620, Speaker A: Maybe just find a zoom out button a little bit.
00:16:36.430 - 00:16:38.860, Speaker C: It is leaving lots of artifacts, actually.
00:16:39.870 - 00:16:40.620, Speaker A: Really?
00:16:41.150 - 00:16:43.020, Speaker C: From the movement of the stuff.
00:16:45.470 - 00:16:51.680, Speaker A: That's unfortunate. Oh, from the movement of the stuff. Do you see any artifacts now?
00:16:52.790 - 00:16:53.202, Speaker D: Yeah.
00:16:53.256 - 00:16:54.994, Speaker C: Yes, still seeing it.
00:16:55.192 - 00:17:03.940, Speaker A: Damn it. What if I do this? Is it better?
00:17:04.810 - 00:17:05.800, Speaker C: Much better.
00:17:07.210 - 00:17:24.054, Speaker A: Wow. Zoom. Okay. Apparently sharing a screen creates artifacts, but sharing this window does not. Well, I hacked Zoom. Great. So Alice is an action receipt.
00:17:24.054 - 00:18:01.830, Speaker A: So you're going to have this action receipt here, right? This one that waits for some data id. In this case, let me raise it. In this case, Alice is going to be waiting for two action receipts. So in this case, there are not two action, two data ids. Two data ids. So LSS action receipt is going to have two dependencies and incoming dependencies. So it's actually going to be waiting for these two data ids to arrive.
00:18:01.830 - 00:19:09.500, Speaker A: While these other two action receipts that we're emitting, one for the bob and one for the carol, they don't have any data ids that they depend on, but they themselves emit data ids. Each of them emits the data id. And when Alice executes the first time, it emits two data. No, I mean, it doesn't emit any data id when it executes the first time. So, going back to the code, that's why you see input data ids here as a vector, because action receipt can be waiting for multiple data ids to actually arrive to this shard. And you also have a multiple data receivers as a vector because a single promise can be weighted on by multiple other contracts. So that's why I have a vector here.
00:19:09.500 - 00:19:26.420, Speaker A: So this is a high level overview of how cross contracts calls work in runtime, together with callbacks. Let's see. Do you guys have any questions about it?
00:19:27.030 - 00:19:38.660, Speaker B: I have kind of more general question. Maybe I missed this from the first session, but where are receipts stored? Is there like a separate mempool like thing?
00:19:39.990 - 00:20:36.360, Speaker A: Yes. So these receipts that I just talked about, whatever we're going to call them, the special receipts that are waiting, they are stored in a queue that is implemented on top of the state try that we have. So our state try, it stores accounts, right? So it's a hierarchical structure. It has accounts in it with some contract data under each account, but it has a very special separate key at the very top, which is specific to the receipts that are waiting to execute some accounts. And they're waiting for certain data ids. They might be actually stored under each of the accounts, not on the root of the trial. So this is something I don't remember exactly by heart.
00:20:36.360 - 00:22:02.980, Speaker A: It would make sense then, to be stored under the accounts because that would allow dynamic resharding to actually work. Because if you're a shard, you cut through the accounts and you want your receipts that are waiting for certain data ids to travel together with the accounts that they're going to be actually calling the contracts on. Okay, so let's go again into the actions, just to, let's go through these actions that we can actually perform with the receipts, make sure that we know the accountant. So one of them is the create account action. As I said, it doesn't have any information inside, because the way you create an account in near is that your receiver of your transaction or the receiver of your receipt is actually the account that you want to create if you are creating a transaction that creates an account. So when you go all the way back into the receipt here, then the receiver id is the account that is going to be created if the first action is create account. And similar logic applies, for instance to the transfer.
00:22:02.980 - 00:22:48.434, Speaker A: So transfer only has deposit. Like it doesn't say whom you transfer it from and whom you transfer it to because they're all deducible from the predecessor or like signer and the receiver. The receiver is the one who is receiving the balance. The predecessor is the one who sent it and very similar to the function call. Function call doesn't say who you're calling because it's deducible from the receiver. It only says what's the method name the arguments, how much gas you use to do this function call and the attached balance. So when you attach certain amount of balance to the function call, it works exactly like transfer.
00:22:48.434 - 00:23:14.810, Speaker A: It's just like a bundled action. This amount of tokens is just going to be deposited before the function executes and if function fails it's going to be undone. So we also have stake action. We not going to touch this yet. This is a completely different topic. Add key again, it doesn't say whom you're adding this key for because it's deducible.
00:23:19.550 - 00:23:21.530, Speaker B: Can we see the access key struct.
00:23:21.610 - 00:24:32.354, Speaker A: That was in there? So the interesting thing about account design in the near, for those of you who don't know, is that we have multiple access keys for each account and this access key. Some of them, they can be like pseudo, they can have full permission, they can do anything with this contract or this account. They can delete it, they can call any method on it. So that's full access or it can be restricted to calling only specific methods on the contract that is deployed to this account. And that's what is called a function access key that specifies the method names listed method names that you can call and even whom you can call. For instance, I can add access key to Alice that says that this access key can only call certain method on contract Bob and allowance, like how much gas whoever uses access key can use from that account to do the calls. And the interesting thing here is that we have none, not per account, but per access key.
00:24:32.354 - 00:25:06.014, Speaker A: The idea is that multiple users can use the same account but different access keys. And if there was common nouns for all of them, they would be interfering with each other like they would be crushing transactions of each other all the time because they would have conflicted nouns. Because we have separate nouns for separate access keys. There is no problem with that. So the nonsense are stored per access keys and not per account. And this is also like a very important thing. Everything else is quite simple.
00:25:06.014 - 00:26:10.990, Speaker A: There is delete key, delete account. It's pretty straightforward, except one nuance here, that when you delete an account in near, you have to specify beneficiary, because whatever tokens you have left on this account, they need to go somewhere. And we want to incentivize users, obviously not to lose it, especially because we have state staking in near states taken means that when you want to write something in the state in Nier, you're going to have certain amount of tokens locked on your balance. It's a different model than the one Ethereum uses. So in Ethereum, when you write something into the state, you burn certain fixed amount of gas, and then when you delete it from the state, you get reimbursed certain percentage of this gas in near what you do when you write it in a state, you lock certain amount of tokens on your balance, like they become not liquid. You won't be able to transfer them out. And then while you're using the state, the tokens that are locked, they're kind of paying for the state maintenance through the inflation mechanism.
00:26:10.990 - 00:27:05.220, Speaker A: Just because you have these tokens locked and you cannot stake them, you are missing the opportunity to stake them and therefore you're not getting a return on the investment from your tokens. And that's how you pay for using our state for a certain amount of time, by not being able to use your tokens. And therefore, when account is getting deleted, whether you have contract on it or it's just a raw account without anything, you're going to have certain amount of tokens unlocked. Even if it's small account, it's going to be a small, tiny amount of tokens unlocked when you delete just an account with some access keys. And we want to incentivize people to just not toss this tokens away and actually move it to a different account. So delete actions, delete transactions in near blockchain. They have beneficiary that specify who is going to be receiving the stuff.
00:27:05.220 - 00:27:30.790, Speaker A: Okay, so I'm going to read through the question, what if receipt with attached tokens is reverted and by the time it arrives back to the originated account, the account is already deleted. In this case, the tokens are going to be burned, lost. There is literally nothing we can do in this scenario. Maybe Bowen can correct me if I'm wrong. I think they're.
00:27:30.950 - 00:27:40.670, Speaker D: Yes, yes, they're burnt. They are also burnt if you delete account and beneficiary id does not exist. In that case, the tokens are also burnt.
00:27:41.330 - 00:28:09.130, Speaker A: The tricky part about beneficiary id is you might not be able to verify upon the deletion of the account that this beneficiary exists because the beneficiary might exist on a different shard. And the whole point of the near blockchain is that our status shard is not just computation. So shard A doesn't know what the status is on shard B and whether it does exist or doesn't exist, Bob's account in there. So you can lose tokens by just providing a typo in a beneficiary.
00:28:12.030 - 00:28:24.718, Speaker B: Just real quick, while we're on this topic, this is good timing. I had a solidity developer ask me this morning what our zero address is for burning. Is there information on that or how we don't have a zero address?
00:28:24.884 - 00:29:06.790, Speaker D: Yeah, right now there has been talks around providing an API for house function for burning tokens, but as of now, there is no certain way you can make sure your tokens are burned. You might think that you can send tokens to a non existing account and then delete your own account to burn the token. It mostly would work. The only problem is that someone can squat that account while you delete your account. So in the end, instead of burning the token, you just send to someone else. So there is no reliable way so that you can be 100% sure you can burn the tokens.
00:29:06.950 - 00:29:26.462, Speaker A: Well, you probably kind of can say that sending it to all zeros account. Not all zeros. Oh God damn it. Anyone can actually squat anything in our blockchain anyway. We're kind of divergent here. So the second question is from Michael.
00:29:26.606 - 00:29:30.930, Speaker E: I think we can have implicit account with an invalid.
00:29:32.310 - 00:30:01.760, Speaker A: Yes, yes, that could be great. Implicit account is a completely different topic also that we're going to cover in the future. Very interesting one. Michael Bursh asks, does the beneficiary get state other than near tokens as well? Ag NFT or wrapped ERC 20 other than near tokens as well? You're talking about the case where an account gets deleted and it needs to stand.
00:30:02.690 - 00:30:05.818, Speaker D: Yeah, the state is not transferred, only the tokens are transferred.
00:30:05.914 - 00:30:37.110, Speaker A: Only the token. No state. Okay, transferring the state is a bit too much. Yeah, it's hard for sure because it's not clear what's valuable state and what's not, et cetera. And also it's very large. You really don't want to think about what happens when one of the messages in your, one of the receipts just carries around like hundreds of megabytes of data. Mike asks, I can create burn near, move all keys, then you can burn by sending to goodbye burn near, or any other sub account to that brick account.
00:30:37.110 - 00:30:39.320, Speaker A: That's pretty neat. It's a good.
00:30:42.890 - 00:31:12.980, Speaker D: Mean that kind of burns the token, but not actually burns them. They still exist. There's a slight difference between tokens that are not accessible and tokens that are actually burnt, because in the total supply it reflects different values. And this also affects inflation. In the end, you can kind of lock or burn in a nominal sense.
00:31:14.710 - 00:32:02.258, Speaker A: If you were able to delete burn near after sending it, then it would have been burning. But I don't think you can do it with our current constraints on what kind of sequences of actions you can execute. So as I said last time, the sequences of actions in here, you cannot have anything, you cannot have arbitrary actions. Because we try to take a very conservative approach with it. We say we allow almost anything but things that we have concerns with. For instance, when you create delete account multiple times, we just prohibit for now and we figure it out in the future if actually there is a use case. So for instance, Mike's scenario will not work, will it? No, you can actually do it.
00:32:02.258 - 00:32:50.562, Speaker A: You can create a transaction that creates burn, I mean, removes whatever doesn't need to remove all the keys, creates send certain tokens to goodbye burn near, and then deletes burn near in the same transaction. It might actually going to burn tokens. All right, so let's move on from the action receipts. I hope I got you properly confused here, but I think we actually reviewed almost every field in the receipts, which is great, except the gas price. So this is going to be the topic of the refunds. That's where it's going to be useful, what the gas price is. The other important thing here is that you can see that very frequently we specify who is the receiver of something.
00:32:50.562 - 00:33:20.810, Speaker A: For instance, with the data receiver, we're not just saying data id and that's it. We're saying data id and the receiver id. And that's because of the sharding. To know where you need to route this information, you need to know which shard it lives on. And to know which shard lives on, you need to know what is the receiver id. Because the sharding in our blockchain happens according to the accounts. You can think of it on a high level as we literally just like mod accounts, like account identifiers.
00:33:20.810 - 00:34:23.014, Speaker A: So you can really easily deduce from the account id on which sharded lives on. And so you would know where to route this data id. So this is something common for the code of the runtime is that very frequently in the data structures you will see receiver id for some reason next to something. And that's because we need to know where to route this information. All right, so we have 25 minutes and I think that's enough time to look into another important method of the runtime, which is apply Genesis state. So the difference between apply Genesis state and apply is that, well, as the name suggests, that you call it only when you execute Genesis block, which is just once, and the apply is being called on every new block. And the difference here is that our genesis contains what we call state records and state records.
00:34:23.014 - 00:34:54.460, Speaker A: It's basically our way to describe what we want the state to look like when the blockchain starts. And we want to have certain number of the accounts, for instance, already exist upon the genesis. Right. We want near foundation account to exist in there. We want accounts of our investors to also exist in there and of our employees, well, our employees who edit later, maybe even some of our investors who edit later, I'm not sure, but near foundations should certainly exist in there.
00:34:55.150 - 00:34:59.094, Speaker D: Yeah, actually only a few accounts exist in the main net. Genesis.
00:34:59.222 - 00:35:19.038, Speaker A: Cool. Yeah, thanks for correcting. Bon. Then we also want to have, maybe these accounts to have actually some data in them and some contract deployed on them. So we want to have some contract code to be deployed already and upon Genesis start. And the data to exist also in this contract. We also access keys to exist.
00:35:19.038 - 00:36:27.506, Speaker A: Now there is the interesting part comes in, which is postponed receipts, received data and delayed receipts. So let's start with the delayed receipts. Well, I mean, let's start first with the motivation. Why do we need anything but the top things? So before we launch on the main net, our blockchain, the testnet, specifically one was undergoing forks frequently because we were experimenting with the code and it was easy to do a fork upgrade rather than to do a proper upgrade. And upgradability was not implemented, I think, back then either. And so we wanted to take whatever the state the blockchain was at the given moment of time and start with this state, as that was a genesis, so it's a proper fork. But additionally, what we wanted to carry over are also with the receipts because as I said last time we want to have a guarantee that receipts are always going to be executed.
00:36:27.506 - 00:37:14.706, Speaker A: So in your blockchain, receipts are never lost. Because if you allow receipts to be lost or not executed, then you cannot have any contracts with any kind of guarantees built across the shards on near blockchain. For instance, as I gave an example with exchange that calls one token contract and calls another token contract. So suppose that we have a following scenario. When your exchange first calls one token contract to lock tokens with a callback, then calls another contract to lock tokens with a callback, and then if they both successfully lock, you perform the swap. If they don't, then you unlock them. If you lose receipts, then you might lose a receipt that does the unlocking.
00:37:14.706 - 00:38:07.714, Speaker A: And so your tokens might end up locked, even maybe permanently. So this is like a very simple scenario when you absolutely need a guarantee of the receipts to be executed. And there is a lot of work and the complexity inside the runtime code to ensure that this actually happens. And the delayed receipts here is one of the reasons why this exists. So when we were doing fork on the testnet, we didn't want to lose the receipts that were delayed, that were like in the process of being executed, but were not executed yet. And therefore we would scoop these receipts from the delayed queue, from the state and put them in the state records saying, these are delayed receipts, you can't execute them at some point. You cannot lose them with the postponed receipts.
00:38:07.714 - 00:38:10.370, Speaker A: There is a slight difference here that delayed.
00:38:10.450 - 00:38:22.458, Speaker C: Can I ask you a question about the delayed receipts? What's the point in keeping the delayed receipts if you're restarting the blockchain from the very beginning, you will not have respective contracts. They are deployed and stuff like that.
00:38:22.624 - 00:38:46.594, Speaker A: But you will, I mean, we're restarting. We were taking the state when we were doing the fork of the blockchain. Yeah, okay, I got it. We were rebasing the state. So you might be creating a fork right at the moment when someone wasn't doing, let's say, an exchange swap and you don't want them to end up with locked tokens or anything like that.
00:38:46.632 - 00:38:47.800, Speaker C: Yeah, got it.
00:38:49.850 - 00:39:40.962, Speaker A: And the difference between postponed and delayed receipt is the delayed receipt was the one who was actually lived in the delayed queue of the blockchain, maybe because there was a congestion at that moment. So remember last time I said the delayed receipts are actually the receipt that are written in a state carried over between the blocks. Postponed receipts is actually the receipt that was just simply in flight. So it was a receipt that was emitted by the block, right? You remember that when we process the block in near, not only we output the state as the new state, as the artifact, but we also put what is the next set of the receipts that we need to route between the shards. So postponed receipt is a receipt that was created, but it wasn't the part of the delayed receipt, but you still need to execute it. So that's the difference between postponed receipts and delayed receipt. And the received data is also the thing that we just touched.
00:39:40.962 - 00:40:10.990, Speaker A: So the received data, it could be a situation. For instance, let's go back to our drawing. 1 second. Let's go back to this scenario with Alice and. Oops. 1 second here. So it could be that Bob has already executed and sent the data, id the data back to Alice.
00:40:10.990 - 00:40:55.070, Speaker A: And right at this moment we decided to fork the testnet, but Carol did not execute yet. So some of the data has arrived and some of the data hasn't. So we cannot execute Alice yet, but we need to keep the information around that the data has arrived. Part of the data has arrived for Alice to be executed. And therefore we have this received data thing that exists, that exists as part of our state records, is that maybe we had some complex cross contract calls with callbacks, and part of it was executed and part of it was not. Some of the data has arrived, some of the data hasn't.
00:40:56.850 - 00:41:00.590, Speaker C: Is it true that local receipts can become delayed receipts?
00:41:03.030 - 00:41:12.340, Speaker A: Yes, the local receipts can become delayed receipts. Let's actually go back to the code.
00:41:14.470 - 00:41:22.920, Speaker D: I think it can if it's so contrasted that local receipts cannot even all be executed in the same block or for.
00:41:25.450 - 00:41:26.200, Speaker C: Continue.
00:41:27.130 - 00:42:03.620, Speaker A: So you see, like when your local receipts are executed, you check on every step, am I above the guest limit? And if you are, then instead of processing, you say, right, I'm delaying this receipt. And just like since I've been talking a lot about the delayed receipts, let's even take a peek into this function and you can see what it literal does. It just takes this receipt as is, and it writes it into the state. So you can see there's some set function, state update thing. What literal does it just writes it into the state. Try it's someplace, that's all it does. And also updates the pointer on this delayed receipt queue by one.
00:42:03.620 - 00:42:12.966, Speaker A: So it doesn't do anything besides that. Right. Let's go back to the apply genesis state.
00:42:13.068 - 00:42:44.190, Speaker C: An additional question, max. It is independent of user whether the receipts that are created within the tree of calls are coming to the delayed state or not. Does this mean that making a receipt, a delayed one is costing zero gas. So the execution gas costs can be calculated beforehand.
00:42:44.930 - 00:43:15.114, Speaker A: Yeah. So putting receipt into the delayed queue incurs extra cost that we don't have a separate fee for. And we consider it as a part of basically the burden that validators need to carry. The problem with the fees is that you need to draw a line at some point. You cannot create a fee for everything in a blockchain. You cannot create a fee for sending things over the network. What is your network? It's such a volatile thing.
00:43:15.114 - 00:43:47.330, Speaker A: You cannot assign a very specific fee to it. You cannot assign fee to, I don't know, RPC things. Right. Talking to the RPC and other to. You need to draw a line sometimes and say most of the fees, especially like things that are deterministic. Most of them, we try to have a fee for them. And also we try not to have fees for things that are unexpected of the contract developers.
00:43:47.330 - 00:44:18.906, Speaker A: So again, we don't want contract developers to be like, oh my God, why does my thing certainly cost more than I thought it would cost? Why do I need to care as a developer that there is something inside the black box of the runtime happening and my receipt is being put somewhere somehow? And because of that, I pay extra cost. And that's basically one of our criteria. So when we decide whether to make it a fee or not, is that, is it going to surprise the hell out of the developer? And if yes, then maybe it shouldn't be a separate fee.
00:44:19.098 - 00:44:30.210, Speaker C: Yeah, so that's the reason why I'm asking this. So if we are attached a fee from making the receipts a delayed one, then this is something unexpected to the developers.
00:44:30.790 - 00:45:01.914, Speaker A: Yeah. The good thing is that the execution of the receipt is probably orders like three orders of magnitude or something like that. More expensive than putting it into the state, just like moving this thing around. Yeah. So the execution of the receipt right now, it's on the order of terragas, like, whatever. Single digit terragas. I think the writing something, a blob of data into the state is way below single digit terra gas.
00:45:01.914 - 00:45:27.238, Speaker A: It's like zero point. And then you have either two or one zeros before you actually like 0.2 or something like that. It's quite cheap, so negligible. All right, so let's look in here. So here you see, this is the apply genesis state function, right? So we iterate over the state records that are stored. Right.
00:45:27.238 - 00:46:10.050, Speaker A: In the genesis. This is the part of the genesis that means that, as you know, we use genesis to identify the chain too. So if you have two blockchains that have everything equal but different state records, those are two different chains. They're part of two different networks. So the state record is as important as having any other config, like the block size, for instance, in our blockchain, it's a unique identifier of the chain. There is some stuff about the storage computation which we also going to skip for now. This is a completely different topic.
00:46:10.050 - 00:46:48.830, Speaker A: This stuff is convoluted, and I don't think you need just a high level idea of what the hell is postponed. Receipt is somewhere here. It's actually going to execute them or set them to be executed later. I think this code is about updating the validators. As I said last time, it's also a separate topic, discussing how validators are updated, what happens with the stake, et cetera, and everything else is all about updating the state and discussing runtime. State is also a separate topic. So we covered the apply genesis state.
00:46:48.830 - 00:47:52.846, Speaker A: Now let's now look at the apply method again. So in the apply method, as I said, this is like the most important method of the runtime. And I think the second most important method of the runtime that you can start looking into is process receipt. Since most of the logic is about the receipts, right? Logic about the transaction is quite simple because transaction is getting converted to the receipt almost immediately. That basically puts most of the complexity of the runtime inside the receipt execution. So process the receipt, it follows this very standard rust pattern of having a really large match against the tag dynam. And what you can see here, if you actually look into the data id, the receipt data, is that you're going to see that the logic here is all about waiting for all data to arrive when there is a callback.
00:47:52.846 - 00:48:30.110, Speaker A: So a lot of the code here, maybe more than half of it, is about the case. When you have a callback and you're waiting for some data to arrive, and only when it arrives, only then you do some execution. So we're not going to deconstruct this code here. You can go over it yourself. I hope you understood the high level idea of what data id is and how the callbacks work. So you see, there is something here called like pending data count. We actually count how many data we still yet to receive, and once it becomes zero, then we actually execute the receipt.
00:48:30.110 - 00:49:02.490, Speaker A: So I don't think we should go into any more topics today, because other topics are quite large and we shouldn't start on them. Do you guys have any more questions? This might be the most complex topic of the runtime, by the way, and the most new in terms of the mental model. All this callbacks and the receipts and all this data flying between the shards, everything else is going to be more linear and straightforward. So do you have any questions on this topic?
00:49:02.990 - 00:49:52.780, Speaker E: Well, maybe not exactly on this topic. So there is a problem with this system, of which I thought for quite some time. So as you said, we have a guarantee that receipt never gets lost. And I think this is most important for action receipts, but this is on the low level. But for the contract there is a problem which can make a receipt appear to get lost. Specifically if the execution runs out of gas, then for the contract, because such execution is reverted from the point of the contract, this receipt is lost. And the problem is that you can't really guarantee that you have enough gas for anything.
00:49:52.780 - 00:50:23.890, Speaker E: So there is always a risk that your execution will run out of gas. And in Ethereum it's simpler because the entire transaction gets reverted. So it is as if this transaction didn't exist. But for near it is possible that multiple execution need to happen. Either all of them need to happen or none of them needs to happen. And it is possible that one of them is completed and the second one runs out of gas.
00:50:24.470 - 00:51:27.910, Speaker A: Yeah, so that's a fundamental problem on the Shire blockchain where you have asynchronous contracts, which is if your contracts are like Turing complete thing that can do anything, you can try your best to estimate what is the amount of gas that you need to attach to it to always guarantee that it's going to be enough to execute it. But you might be wrong. And any kind of callback which can also be a Turing complete program can actually run out of gas. So if you want to allow users to make a foolproof mechanism for unlocking and for the callbacks, we either need to drop this completeness, turing completeness, and we say whatever you execute as a callback actually can be limited in gas and we can guarantee it and it's always going to work and never going to run out of gas. Or we need a completely different mechanism which is lot of synchronous calls, which is also what we've been discussing in some research meetings.
00:51:29.210 - 00:52:25.078, Speaker E: So I think what I thought about was more like the first approach. So I thought I had an idea to have some sort of event queues. So the idea is that the callback adds some item to an event queue that is part of account state. And so this action of adding this promise result to an event queue is not during complete. So it is possible to guarantee in advance that it will not run out of gas. And then it may be possible to invoke a regular callback as well. But if that callback runs out of gas, it may be possible to send a transaction to reinvoke the same callback with the information from that queue, like with more gas.
00:52:25.078 - 00:53:00.840, Speaker E: So on the one hand, it is possible to have a callback which can do something like schedule further receipts, for instance, like more do something else. But on the other hand, even if that callback runs out of gas, it is not lost completely. Like there is still a record state that this contract can use to redo this action if someone sends another transaction to give it more gas to run.
00:53:03.130 - 00:53:50.194, Speaker A: That's one of the mechanisms. I also like the approach that Libra has where they just special case anything that is an asset and they create the entire virtual machine around the fact that you cannot accidentally burn some asset. So it's like a first class citizen for them. All these ERC 20 tokens and we were actually brainstorming ideas around that. There are multiple, at least one proposal in the naps. We call it safe, where we extend our runtime with some extra host functions that will allow you to have basically the Libra functionality specifically for the asset manipulations. So that could also be a solution.
00:53:50.194 - 00:54:05.958, Speaker A: But I also like the QQ is more universal, but it's harder for the developers because now they have to think in terms of this queue like they need this new abstraction to deal with. We don't need to turn to the research meeting.
00:54:06.134 - 00:55:15.060, Speaker E: It is possible to hide the thing behind some SDK functions and instead just make it like possible to redo callback. If a previous attempt to run a callback failed, then it might be possible for anyone to send the transaction to pay for the gas to try to run exactly the same callback again. So this is like simple approach, it shouldn't affect the security. So we always had a guarantee that the callback can be invoked at any time, like possibly much later. And so now the difference is that if execution of a callback failed, that anyone can attempt to execute it in exactly the same way, but with possibly more gas. But also once it finishes, it removes itself from the queue. So it cannot be the same callback cannot be called again.
00:55:16.310 - 00:56:19.574, Speaker A: Yeah, something like that. And we can even create some design patterns for the contracts that people can just use as a recipe book without really thinking too much about how to design something custom on top of the skewer using SDK. Cool. So let's wrap it up. That was, as I said, probably the most complex topic in the runtime, in the runtime code. And I'm happy that we are through, because that will allow us to understand other things, because as we're going to be reading the rest of the code, like around the state, around the fees, around the WASM execution, we're going to see a lot of these receipts and data ids and all things like that, and we will be able to understand what it actually means. So it was important that we covered this topic early on, but I hope it didn't discourage you from attending more runtime bookfruit videos, because they're going to be simpler than this one.
00:56:19.574 - 00:56:21.254, Speaker A: Right. Thanks, everyone.
00:56:21.452 - 00:56:22.450, Speaker B: Thanks so much, Max.
00:56:22.530 - 00:56:27.540, Speaker A: Have a great. Thanks, Max. Bye. Thanks. Bye. Bye, guys. Thanks.
