00:00:02.570 - 00:01:17.030, Speaker A: Hey, hello everyone. Today we're going to review two contracts instead of one. And we will include contracts that involve cross contract calls and talk about promises and how they work at near sim. If you want to learn more how composability x this is a good session to watch. So let me present my client tab. All right, so today, contract, first contract that we're going to take a look is called a whitelist contract and it is used on the main net to whitelist staking pools. And this is important for the reason that the distribution of tokens was done through smart contracts and we use lockup contracts that we'll eventually review in this series.
00:01:17.030 - 00:03:06.722, Speaker A: But the way it works, the lockup is a standalone contract that holds tokens that supposed to be, for example, released over a period of time. So let's say the tokens are released over two years and linearly getting allocated every block. So what we wanted to do is we wanted to give an ability to stake these tokens, including the tokens that are not released yet, which means you should be able to delegate all of the tokens that you have locked for, for example two years and start earning rewards on them. This is done on a smart contract and a lockup contract, essentially calling staking pool contract that we reviewed before and transfers tokens from one contract to another. And the tokens from lockup contract leaves the account and go to the account of the staking pool. So if a staking pool doesn't provide guarantees that are required, such as you can return these tokens, then it means, let's say I build a custom staking pool that allows me to not only stake them but also withdraw them to any account. Then this type of operation will allow you to get liquid assets before the release period ends so you will be able to withdraw.
00:03:06.722 - 00:04:32.702, Speaker A: And this is not the desired behavior. That's why we introduced whitelist where custom implementation of the staking pools that are approved by Nier foundation can be used by lockup contracts. At the same time, we wanted to give an ability to create new staking pools that are already approved by anyone without going through approval from near foundation. This allows anyone to create a new staking pool through a staking pool factory. And a staking pool factory is the second contract that we will review today. So the way it works is when a lockup contract wants to delegate before they can transfer funds out to this contract, they first need to select a staking pool. When you do a select staking pool, lockup issues a transaction to check if a given account id is whitelisted in whitelist contract, and if it returns true, which means the account is whitelisted, then the lockup contract can continue with delegation.
00:04:32.702 - 00:05:39.046, Speaker A: So it allows the lockup to actually transfer to this contract. It means that the remote contract, the staking pool contract, has some guarantees and APIs that the lockup contract expects. And it's not going to lock tokens of the owner or steal tokens from the lockup contract. It also was important for vesting schedules of employees of near Inc. It was on like four year vesting schedule. And that allowed to in case an employee leaves the job or was terminated, allows foundation to issue a specific transaction to the lockup of that person to unstake everything from the staking pool, withdraw everything from the staking pool, and return the unvested amount back to newer foundation. So that's the background about lockups and whitelist.
00:05:39.046 - 00:06:26.040, Speaker A: So let's look at the whitelist contract. It's actually a fairly simple contract and it doesn't really have a lot of logic and majority of stuff we already know. It uses a new API that called a lookup set. It is similar to an ordered set. It's a persistent collection, but it doesn't have iterators. So you cannot iterate over the keys of the values elements of the set. You can only check if a given account like you given element is present or not present, and you can add it to the set, but you cannot check what elements are present in this set.
00:06:26.040 - 00:07:48.542, Speaker A: And by doing this, it improves the efficiency of storage and access from multiple reads to a few reads. So the contract contains a few fields. First, the foundation account id. This is the account id that controls the whitelist means this account can whitelist staking pools by one, and also it can whitelist staking pool factories. So the factory is a contract that can create a new staking pool instance. The way it works is when you issue a transaction towards a staking pool factory that is whitelisted by this contract, it creates a new account as a sub account of the factory. In our case, on the main net it's called Poolv one near is the staking pool factor that we use and it creates a contract.
00:07:48.542 - 00:08:34.046, Speaker A: So for example, bisontrails pool V one near, on which it deploys a valid staking pool, a whitelisted staking pool code that this factory can produce, and we will go into factory later. But at the same time it also can whitelist this given staking pool. So here's how it works. The contract has initialization, which only takes a foundation account iD. Now, a foundation has a higher permission on this contract. So there's a bunch of getters. So you can check if a given staking pool is whitelisted.
00:08:34.046 - 00:09:17.920, Speaker A: So this is how lockup contract checks. If the pool is whitelisted, it basically just check if an element is present in a set. And a second way, it also can check if the factory is whitelisted. So this is not really needed and no one calls it. So this is a method that can be called both by a factory and by foundation. So what we do, we check that this method adds a new staking pool account id to a whitelist. It checks if the account id is valid, then it's cool.
00:09:17.920 - 00:10:03.338, Speaker A: We check if this is a factory. So we check in a set that the color of this method is present in the whitelist of the factories. So if it's called by staking pool factory, then it's okay. If not, then it has to be a foundation account id. Otherwise the contract will fail. This method will panic if we pass the permission check. Then we just add this staking pool to the whitelist.
00:10:03.434 - 00:10:17.442, Speaker B: Could I ask a question? I guess it's kind of interesting to me that there are multiple factories. I was kind of thinking, would there be one factory? Is that for sharding reasons or is there a reason for that?
00:10:17.576 - 00:11:05.838, Speaker A: So right now we have only one implementation for the staking pool. But in theory we can modify this implementation. When we introduce, for example, slashing. And the staking pool has to have a permission or needs to maintain some minimum balance, it's some other change that we need to modify a validated contract. So over the vesting period of everyone, which for employees is like four years, a lot of stuff can happen around the network. And we need to have an ability to change the staking pools, potentially. So if a logic of staking pool.
00:11:05.854 - 00:11:11.538, Speaker B: Changes, that's why it allows for kind of like upgrading, right?
00:11:11.624 - 00:12:19.370, Speaker A: It allows kind of like create a new factory that is like a better version or like it supports something that was not supported before. Maybe it not allows to change a reward fee instantly, but only allows it to change after like a seven days period, waiting period or some other idea on the modification. And that will be a different factor. So remove staking pool can only be called by the foundation. Add factory can also be only called by foundation and basics just adds to a whitelist of the factory accounts ids and remove factory also only by foundation and removes the factory account id. So let's say the first factory expires. The foundation can basically remove the factory from whitelist as well as remove all the previous pools from the whitelist.
00:12:19.370 - 00:13:08.540, Speaker A: So now you will not be able to select one of the previous taking pools from a lockup contract. And finally, just to check that this is called by foundation, which is comparison. So this very simple contract and it just operates on internal sets. And the only true method that is visible by outside is this taking pool whitelisted. And there are some methods that were called by foundation. So foundation actually probably issued only one call. And this is to whitelist the factory and it didn't do anything else.
00:13:08.540 - 00:13:27.860, Speaker A: Okay, so this whitelist contract, any questions on a whitelist contract? So it doesn't have any cross contract calls. It's fairly simple, just a bunch of setters and getters with permissions.
00:13:29.480 - 00:15:01.410, Speaker C: I've got a couple of questions here. Okay, so one thing that I've been looking at or looking for is where does the model of application development on, near or in general on blockchain applications differ enough from web development or whatever, where somebody would be surprised what you just said about Mike's question and your response. What would be surprising for a web developer, that you need to think about the lifetime of this application measured in the life of the constraints of the users and their vesting schedules, which could potentially be like four years. Is the case that you just presented, right, that you wouldn't think about a design having to survive versioning intact over that many years? You would just think about swapping out the existing code base or whatever. And that's a big difference in what we're talking about. Here's my question. Do you have an intuition about this? Or have you kind of figured out what are the triggers in your mind when you're designing a contract that make you stop and think this is immutable for some period of time or whatever the constraint is, do you have a way of thinking about this that you could share? That's explicit? I think that's what I'm asking.
00:15:02.900 - 00:16:50.756, Speaker A: Well, the way smart contracts usually behave, which is not true on Ethereum, on a bunch of them, is they're immutable on itself. Well, on Ethereum, every contract interior is immutable, but they use a proxy contract that allows to upgrade the endpoint for certain contracts that are very critical to tokens, like in this case our core contracts. Essentially they are completely immutable. And we think about them as we will deploy them once and likely we'll not be able to change them because otherwise we'll have to do hard work and convince all validators to do some type of code migration. So it is important because the control over them has to be done on a contract level instead of on some centralized entity. So for example, while foundation still maintains large control over the staking pools here by having ability to remove staking pools, it doesn't have a control to blacklist particular entity in real world from deploying a staking pool. So they still can create a staking pool as much anonymity as possible and create without asking a permission to became a validator on a main net.
00:16:50.756 - 00:17:58.472, Speaker A: So something comes from decentralization, other comes from limitation over the control of the trust towards this. So while foundation is supposed to support the network, it's possible that in some scenarios the foundation can be forced to do something bad for the network. Let's say government comes in and tries to force them. If they have less ability to do this, then it has a higher security over the network. So when we design a contract, we think okay, what is the, I would say either the amount of value in this contract or the ability of this contract to influence the network in general. So if it's a small value, then it's okay to keep that credibility so long as the community trusted. If it's a large value then it's not okay.
00:17:58.472 - 00:19:42.220, Speaker A: And when we actually going to get to lockup contract and the way it's designed, you can see how for example, a vesting was designed to on one end allow foundation to actually withdraw the remaining funds, but at the same time prevent the foundation from withdrawing the vested funds. So it's kind of like a legal way of doing things except written into the code. So whitelist is very critical contract because it allows people to, before the funds are locked, majority of funds are kind of controlling the network through lockup contracts into staking pools through this particular whitelist. So it was important to design it in such a way that it keeps decentralization and security of the network without giving control to the foundation as much. So there's some logic and you potentially, let's say something happened and foundation became acting maliciously. Let's say you were able to create a new staking pool through a factory and delegate to the staking pool. Now the foundation cannot really prevent you from delegating to the staking pool.
00:19:42.220 - 00:19:51.340, Speaker A: I don't know if I answered this question, but let's move on to the more technical discussion.
00:19:51.840 - 00:19:54.290, Speaker C: Yeah, that's great, I appreciate the answer.
00:19:54.820 - 00:21:01.140, Speaker A: Okay, so this is the whitelist and essentially what we care about is the interface. Recently we had a talk and how to do this better. So ideally you just expose a trade for the methods that you think are going to be called by the other contract. So is whitelist is one method, and then add staking pool is another method, change method. So the stake and pool factory contract is a contract that internally, internally has the code of a staking pool contract in rust. You can do this by using a macro include bytes. It basically takes a file, a local file, and embeds it into the binary as a vector like row bytes vector.
00:21:01.140 - 00:22:07.028, Speaker A: So what happens there is within this webassembly binary, we can have some piece of memory allocated which represents a binary of this particular staking pool. Okay, so let's get back to the top. So this again the structure, there was some information about the gas. We'll come back to this later. There's a rewards fee fraction that's just copied from staking pool contract that we reviewed before. There is arguments of staking pool that it takes and there's trades and external contracts. So this is a high level interface that we use to call certain contracts.
00:22:07.028 - 00:23:04.904, Speaker A: We have two of them. First is it can be any name. We call it x itself because it represents our own contract and it contains a callback to a method on stake in pool create. And a second trade is for a whitelist contract that we just saw called add staking pool. So here it is, add staking pool, exactly the same interface, except the traits in rust are like interfaces in Java for example. And we just define the interface of remote contract. So let's go first through the scenario.
00:23:04.904 - 00:23:52.780, Speaker A: So when stake and pool first initialization of the factory, when the factory is created, we verify that it was not initialized and we verified that the whitelist account id. So we take the account id of the whitelist contract. During the initialization of the staking pool factory. We need to know the whitelist account id or whitelist. Staking pool whitelist account id. This is where the whitelist contract is deployed in order to whitelist our newly created staking pools, the instances of the staking pool. So we remember this and create also a set of already created accounts.
00:23:52.780 - 00:25:03.410, Speaker A: There are a few getters. And the way you enter this contract now that stake and pool factory is created, it's called Poolvan near for example, and foundation whitelisted the factory on a whitelist contract by issuing another transaction. So now this pool factory, let's say, is whitelisted. It means it has the permission to whitelist the new staking pools that it creates. So now a validator comes in and they want to create a staking pool for themselves. The way it works, they call create staking pool, and it takes a bunch of arguments. So first argument is a prefix, let's say it's a bison trails without suffix of this current account id.
00:25:03.410 - 00:25:47.650, Speaker A: And this comes from account names of near. So account can only create a sub account or very long account. So stake in pool factory creates sub account under itself. So it will be bisontrails pool v one near. So in this case, this will be bison trails. Owner id is the account id of the owner of the staking pool, as we discussed before. So all these three items are essentially arguments that you would pass to a staking pool when you first create it.
00:25:47.650 - 00:26:52.976, Speaker A: So it's an argument that you kind of proxy towards the staking pool. So for example, this can be bisontrails near, this can be their staking pool, or the staking key from running a validator node and some rewards, for example, 10%. Note that this method also payable. It means it takes incoming attached deposit. And the first thing it does, it's saying like, hey, did you attach enough deposit? And the deposit that you need to attach is 30 year, so it has a lot of zeros. But this is because it's in York ten year, so you need to attach certain year. And mostly because you need to cover the state for the contract itself on a newly created staking pool.
00:26:52.976 - 00:27:10.312, Speaker A: So the contract is fairly large. It's 250, least 25 near for this. But also it takes some extra money to cover this price guarantee fund and stuff like this.
00:27:10.446 - 00:27:35.588, Speaker B: This is actually a good place to point out, I know, I've heard before on discord and from partners who are confused why you cannot just add a lot of gas in certain cases. And this is one of those cases, I believe, where you do have to have an attached deposit because you cannot attach this much gas to this transaction. So this is a really good example of.
00:27:35.674 - 00:28:22.370, Speaker A: Right. Also, we cannot convert gas to near within a contract. So gas, ideally separation stays the same. It's only used for computation and some write read operations and cross contract calls. And balance is used for state storage and transfers. So in our case, this will create a new account. And creating a new account in near requires to pay for the storage of this account and storage in our case, going to be not only the account itself, but also the contract of this account.
00:28:22.370 - 00:29:36.622, Speaker A: And in our case, this is the, well, this is the code of the staking pool contract. So next thing we do, we verify that the prefix doesn't have a dot. It means it's not a sub account itself. Then we create a new staking pool account id by concatenating our account id, this new prefix, and we verified that the new staking pool account id is valid. So basically, if any of this assert fails, the near protocol will refund the tokens. So if a transaction fails with attached deposit, the attached deposit will go back to the sender to the predecessor, because only predecessor can attach a balance. So that's safe to do like a bunch of asserts in this type.
00:29:36.622 - 00:30:44.900, Speaker A: Next, we verified that the owner id of the staking pool is valid. This is basically just a bunch of extra helpers that are also verified on the staking pool. And to make sure if you pass the correct arguments or slightly incorrect arguments, you better fail early before you do this, trying to create to avoid burning gas and locking the tokens that you spent. Finally, we check using insert that the staking pool doesn't exist. Basically, insert will return true if it's a unique, new unique element and return false if the element already exists in a set. So this is how rust has set works. Same way an ordered set works.
00:30:44.900 - 00:31:45.400, Speaker A: If the pool name already exists, we will not add this taking pool or try to create this account again using insert for that. So insert does two things. It adds this element to the storage as well as return true if the element is unique and didn't exist before, or returns false if the element already present. So it's kind of not op in this case. I think Kras does this. Not sure which other language has similar API. So we can go to for example hashmap to see what adds a value to the set.
00:31:45.400 - 00:32:51.200, Speaker A: If the set did not have this value present true is returned. If the set did have this value present false is returned. Finally, we use somewhat, not the highest level API, but somewhat like a medium level API. So we don't use raw host methods, but at the same time we don't use high level interface like this. So the way it works, we create a new promise. So this creates a temporary record, temporary structure in our near SDK and it remembers the receiver of this promise. So you can think about as this method going to issue a transaction towards, or this contract will issue the transaction towards that given account id.
00:32:51.200 - 00:33:29.766, Speaker A: So we will call nonexisting account id staking pool account id. Of course it's not a transaction but a receipt, but it's a technical detail. Next thing we say, this is the first action on top of this promise. So we start batching actions into this promise. First action is create account. So this method or this action will create a new account or it will fail. If account already exists, then we deposit the attached balance.
00:33:29.766 - 00:34:47.730, Speaker A: So we deposit entire deposit that was passed to us, so we don't keep it in this factory and it will go with this same receipt on the remote account. Next we deploy a contract. As I explained, this is a macro that pretty much creates static slice, which we convert to a vector that will pass to a deploy action. So this will deploy code on the remote account. You can only deploy a code on the account you control, but create account gives you permission for only this particular transaction to act like you are owner of this account. So you can do deploy contract and you can do stake for example and some other stuff on behalf of this contract in the first transaction that you do. Finally, we initialize the contract, the staking pool contract using CeRDa API.
00:34:47.730 - 00:35:39.870, Speaker A: So we take this structure and we serialize this into JSoN, the method name called new. The first argument is the attached deposit to this function call, so we don't need it because it doesn't expect it. And next is the amount of gas that you take from your current amount of gas and immediately take it out and kind of say it will go to this promise. So let's say our method was called this 100 terragas. Terra gas is a kind of unit that is roughly human, understandable. So you have 100 terragas when you entered. And we say we're going to pass base multiplied by two bases, 25 terragas.
00:35:39.870 - 00:36:43.800, Speaker A: So we will pass immediately 50 terragas to the function call of this method. So this 50 terragas is. So it means we only left with less than 50 terragas because we already burned some on some logic before. Plus, every action that you include into this promise will also cost you some gas. For example, a deploy action cost you to transfer the bytes over the one shard of one account to another. Finally, we use Dan then is similar how Javascript works. It attaches the dependency on a promise before.
00:36:43.800 - 00:38:54.032, Speaker A: So ideally we should say like okay, finalize or something, but we don't have it because it will happen afterwards. So think about this as this is the first promise and we say then once it completes, do this the second promise. So the way it works is you called, let's say, let's use bison trails example again, bisontrails near called this contract pool v one near to create bisontrails Poolv one near, we first create a promise to bisontrails pullv one near, and then we attach a callback to this API is not great in terms of it uses positional arguments for two different things, but it calls ourselves back the current account id. So it will call pool v one near after this promise has executed. So let me just write this in comments. So bison trails near calls pool v one near the method create taking pool, blah blah blah. Now, this method, um, creates a promise to create a promise to bison trails pool v one near with like multiple.
00:38:54.032 - 00:40:18.150, Speaker A: So let's just call it like this. Then it also creates a promise to itself on a method on staking pool. But this method depends on the callback from bison trail sense. So it needs a result of this method before this method starts and it passes three arguments here, it passes the staking pool account id. It passes attached deposit and predecessor account id. So who called us, what account tried to be created and how much tokens was attached in case we need to do a refund. Now, if this is successfully executed, then this method will receive a result of execution saying it was success.
00:40:18.150 - 00:41:22.490, Speaker A: If it failed to execute, let's say there was some misconfiguration that this method will also be called, but will receive a callback saying it failed and we returned this promise after then it means we returned not this promise, but we returned on staking pool create. Now, why it's important is because now this method result depends on the result of this promise. So the transaction doesn't complete or starts in parallel. Instead, it now depends on execution of this particular method. Does it make sense so far?
00:41:26.860 - 00:41:52.368, Speaker B: Yeah, I think so. One thing I think is interesting is that first, when you highlighted the first promise, the create account transfer deploy contract, that is an example of a batch call, right? If there's confusion about terminology, that's a batch call, but there's also a promise. So if any one of those actions failed, then it would revert.
00:41:52.544 - 00:42:29.184, Speaker A: Yes. So entire sync going to return failure to this promise. But this promise will still be executed if this is scheduled and started to execute. So let's look at the callback. And here is a callback, basically a method. First thing we do, we say that it can only be called by current contract. Means no one else can call this.
00:42:29.222 - 00:42:38.770, Speaker B: Promise because it's technically public, right? So people can technically call it. But then that's how you check to make sure that it's not anyone else.
00:42:39.800 - 00:43:08.350, Speaker A: Next thing we do, we use another utility method helper method. Saying is the dependency that the creation of the staking pool succeeded or failed. So we do this the following way. We use two n methods. First, we check that number of results is one. This is invariant because we already know that no one can call this two. And second is if the result is success.
00:43:08.350 - 00:43:57.570, Speaker A: And so yeah, if, if the method executed successfully then we return true. If the promise failed then it will be false. So now we know if the staking pool was created or not and we have logic. So if it was created it means it was good. So we continue. So again, we also attached 50 gas to the callback. So now we are in callback, it means we only have 50 gas, 50 terra gas.
00:43:57.570 - 00:45:13.372, Speaker A: If we succeeded then we'll log in. Okay, the pool was successfully created, let's whitelist it. We call another promise from a callback and attach 25 terragas. So now we call staking pool whitelist account id. So the whitelist contract, we call the whitelist and say hey, now you can whitelist the staking pool that I just created because I passed this argument in towards the callback and we return this promise so we don't stop the execution yet because we want to only complete the entire transaction once the waitlisting completes. So rust doesn't have a return because if the last value without semicolon is given then it's a return value. And if the creation failed, it can fail.
00:45:13.372 - 00:46:12.040, Speaker A: For I assume only one reason is if you put invalid, reset a key, restrate a key as we discussed briefly before. So if it's like some beard curve that you created your staking key, then it will fail. And the reason how it fails is it means the deposit that you passed to the staking pool for creation will be refunded to us, not to the predecessor. So we have 30 near on this contract and we need to return them back to the sender. So we are not locking them. So first thing we do, we remove it from list of staking pools that were created because this was not successful. So we say creation failed.
00:46:12.040 - 00:47:18.560, Speaker A: We're going to refund you the attached deposit. So now it's not a real attached deposit because the callback doesn't receive the attached deposit. It flies through a separate refund receipt that usually arrives first, then a callback and, and it also takes the predecessor account id. Again, in our case if we call n predecessor account id that will be us because this is a callback. But we need to know who should we return tokens to. And the way we do this, we create a promise using new predecessor account id and we say return the tokens that were touched before. But as you can see, we do not return this promise, we just say that's it, we don't care if it succeeds or fails.
00:47:18.560 - 00:48:12.790, Speaker A: We basically return a value false, saying the pool failed to be created. So what happens now? The transaction continues to be executing, but the value will be returned to the front end. So front end, like usually near Cli will immediately know that the transaction has failed. You may not get your money back yet, so you're still waiting for this particular refund to execute in the next block. But you already know that the pool was not created, so you can continue. And this is an example of how you can do a parallel promise. So if we go back to this example, there is two scenario, let's say success and success.
00:48:12.790 - 00:49:35.630, Speaker A: This method is executed and then it basically calls, I think it calls something like whitelist near, or maybe something like this, add staking pool and passes the arguments to add staking pool. So this transaction started here, will wait on the result of this now because it's redirected to promise. And in case of a failure, what happens is this method creates a call to buy some trails near this transfer of x amount of tokens. But it does this in parallel because it immediately returns false. So here it just returns false. So this method will immediately get false. And this is how a staking pool factory works.
00:49:35.630 - 00:50:20.350, Speaker A: That's it. So it looks like we didn't need unordered set here because there is no getter. It has a getter, so it checks how many staking pools were created and we can possibly check. It's on the main net 1 second. I'll prepare so I can demonstrate, um, how it works. For now you can ask questions.
00:50:22.880 - 00:50:38.176, Speaker B: Yeah, this is really good. I guess I'm curious, what happens if you didn't have the return value, promise or value? Or when do you need to return promise versus promise or value.
00:50:38.358 - 00:51:43.490, Speaker A: Right? So here, this method uses promise because it's only one outcome. It always returns promise. But this method can either return a promise, in this case, this returns a promise and we call into which will call it or convert it to promise of value enum, which is just either a promise or some type of value. Or in this case, we don't want to return a promise because transfer will succeed, but we don't want to return success, we want to return false instead. We could also have callback on the transfer to make sure we return false later, but that's not important for this. Okay, thanks. And occasionally I think we can look at the staking pool.
00:51:43.490 - 00:52:07.740, Speaker A: It doesn't return a promise, but it does check somewhere here. So it does internal restake that doesn't return a promise, so just ignores it. So it does it in parallel as well, just for validation of the staking key.
00:52:09.310 - 00:52:14.910, Speaker B: And for things like transfer, nothing can really go wrong, right?
00:52:15.060 - 00:53:07.390, Speaker A: Well, it can fail if the account doesn't exist. And in this case, you will receive an error like failure instead of promise success. So let me quickly switch to terminal. Okay. So we can call a view method on our main net, pool V one, near. And that returned us the total 88 staking pool contracts were created on the main net. Under this given pool v one.
00:53:07.390 - 00:53:42.010, Speaker A: We can also check another field, which is minimum attached balance. It just returns 30 meters. And the way I usually check it is I do something like this. So I basically divide it by ten and 24 and it tells me the number. Cool.
00:53:42.860 - 00:53:43.836, Speaker B: Yes, it's really good.
00:53:43.858 - 00:53:53.230, Speaker A: Thank you. Again, any other questions? Because this time they actually fit into the timeline. So this is good.
00:53:55.760 - 00:54:12.660, Speaker C: I've got a couple of questions. So there's one set of questions around the gas. You had a bunch of constants set for gas. And I was wondering, did you discover those empirically by running through the contract in the code and then code them in? Or is there some way to discover that while you're designing?
00:54:13.480 - 00:54:14.710, Speaker A: Yeah, good question.
00:54:16.120 - 00:54:18.948, Speaker C: And then some more questions about promises, if we have time.
00:54:19.114 - 00:55:07.152, Speaker A: Yeah. So 25 for the base. It came from the reason, because when you do a promise and a callback in one method, it cost about 20 terragas just for this, without attaching any guest, because a promise with the current fees cost around five, like 4.6 terra gas and dependencies cost around ten terra gas. So when you do two methods, which is first call and a second callback, this is about 9.2 terragas. And then you do a dependency on first to another, to the second one, it's ten terragas.
00:55:07.152 - 00:55:56.464, Speaker A: So this is going to change soon once we adjust it, because it was taking into account compilation and incorrectly estimating this value. So that will be down dramatically. So when you attach base two, you consider that the remote method may need to do one promise or like one promise with a callback. So I usually say how many promises you need to attach or call if it's two. So for example, promise with a callback, then it has to be base for the basic computation and two bases for first promise and the second promise. And it kind of combines recursively. This is the complication for near due to a sync execution.
00:55:56.464 - 00:56:18.060, Speaker A: So you need to know how much gas you need to pass to each asynchronous call, including your own callback. The good thing is, if you currently overestimate it, a little, then we do refunds. There was consideration to remove these refunds, but it's not finalized and unclear.
00:56:20.240 - 00:56:46.516, Speaker C: And then you're talking comfortably about these numbers that you just quoted. Two or three different numbers off the top of your head. Is that because you have built this intuition over time? Or are you using some utility to help kind of give you this sense of what costs are? Because these costs can change over time as well. So I wonder, how do you maintain a current intuition about the cost of things?
00:56:46.618 - 00:57:32.976, Speaker A: Right, so the cost can go down. We're trying to guarantee that the cost will only go down, and there is a mechanism to enforce it. So let's say we need to increase some cost. Instead of increasing this cost, we can bring down the cost of all other methods and increase the price of gas, or decrease the supply of gas. That effectively will balance out the costs. There is a configuration file in near core that explains all fees. And mostly we figured out this from experiments.
00:57:32.976 - 00:58:12.320, Speaker A: So we have simulation test for some contracts which allows you to pass limited amount of gas. And you can check if it succeeds or fails. But we'll probably publish more guidelines on the gas once we upgrade fees. At the same time, it's currently unclear. This entire gas is like a mystery, especially around storage and all the fees. But because function calls were dominating the cost of this, it was more expensive.
00:58:16.180 - 00:58:56.712, Speaker C: Okay, thanks for that. The second question I had was about the external interface for the contract calling itself staking pool factory had an external interface set up to call itself early on in your presentation. And it wasn't clear to me why you did this. I guess lines 86 to 91. But it makes sense because that's the callback that you're registering to be informed of what happened when you try and deploy and fund the other contract. Right? That's the reason for this. You want to set up this external interface.
00:58:56.712 - 00:59:00.528, Speaker C: If you're expecting a callback, basically from a promise, that's what this is for.
00:59:00.694 - 00:59:29.210, Speaker A: So this is just a high level. It allows you to pass positional arguments that will later be serialized into the JSON. But it's similar how you do this particular call. So here you explicitly pass the arguments through the serialization. Here you implicitly pass three arguments. And this macro will create a structure for you for the input that will serialize it to.
00:59:30.220 - 00:59:40.140, Speaker C: So this is a choice that you've made. You could have written lines 200 to 205, similarly to 190 to 194. Is that right?
00:59:40.290 - 00:59:59.360, Speaker A: Yes. They're not that much different. Okay, I think we have a conflict meeting, so we need to jump well, thank you, everyone who help us. And listen to this. Thanks again. Bye. Thanks, Eugene.
