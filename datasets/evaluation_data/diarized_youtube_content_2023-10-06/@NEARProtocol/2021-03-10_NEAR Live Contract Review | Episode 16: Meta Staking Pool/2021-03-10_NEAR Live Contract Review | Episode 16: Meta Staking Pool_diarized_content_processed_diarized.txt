00:00:00.330 - 00:00:34.520, Speaker A: Okay. Hey, everyone, this is Eugene. And today we have with Patrick, Matt, and William, and we're going to record another episode of live contract reviews. And today we actually have a request from Metapool. So there's a new contract, and it creates a new token. So let's actually dive in. I started compiling it.
00:00:34.520 - 00:01:39.742, Speaker A: So I compiled it, and I'm doing testing right now to see if it actually works. And Metapool is a project by narwhal wallet, which is a metamask like wallet. And the idea here, let's see what you can do. You can deposit withdraw by something didn't work in tests, which maybe it was wrong built or something. Maybe my version of this isn't correct. Anyway, just test my capture. Okay.
00:01:39.742 - 00:02:33.160, Speaker A: Anyway, it does compile, which is good. Tests are separate, so you can buy s near stake, then you can sell, which gives you immediate unstaking. So it's kind of wrapped staking token, so you can do unstake, wait, finish, I guess it's unstake, wait, finish, withdraw. That allows you probably to unstake. So you can also stake, which gives you a token. You can provide liquidity, remove liquidity, retrieve unstaked, and distribute staking and staking. Okay.
00:02:33.160 - 00:03:13.458, Speaker A: All right, so majority of work, it looks like is done. So let's jump into the source of leap and see what it is. So it has some constants. You can get contact info. That's cool. Oh, by the way, it uses near SDK tag two 40, which is fairly old. And even so, it's called 40240.
00:03:13.458 - 00:03:38.250, Speaker A: It's still probably older than this one. Maybe that was just a patch. So it may be not as old, but somewhat in the middle. Soon we're going to publish 3.0 that has a bunch of cool stuff and a lot of helpers. So that would be nice. Okay, so it's split into multiple modules.
00:03:38.250 - 00:04:05.694, Speaker A: There's an allocator, internal account. I don't know what it is. Debug. That's actually a method that we introduced. It's a log macro. So this is external API to staking pool. And it implements staking pool.
00:04:05.694 - 00:04:57.790, Speaker A: This is kind of interesting. What is. Okay, just to make it clear that this is a string. So staking pool is a core contract that is defined in core contracts. And the APIs are known. And this is a standard APIs. There's also a separate API that you probably want to use, which is get account that returns you a composed value of three of this essentially now meta staking pool owner callback.
00:04:57.790 - 00:05:57.666, Speaker A: So this is us. I assume. So this is this contract and it implements this bunch of callbacks, index amount stake, maybe deposit and stake and stake all on get result from transfer poll poll result. I actually not sure what it is for, but it looks like it's some legacy logic around when the transfers are enabled. Total balance. So this is our core contract and it does implement default for some reason. It's a pull info.
00:05:57.666 - 00:06:31.760, Speaker A: It's not core contract. Okay so it has some data. Let's scroll down to the main contract. So main contract called Metapool. It has owner id, min account balance, some metadata. Total available. I'm not clear in what balance is total available.
00:06:31.760 - 00:07:41.390, Speaker A: Is it near a token total for staking? Total actually staked. Total stake shares. Okay total meta okay so that was near. And this is Modata. So, so this is what I started to see. Like more complicated contracts, they get way more fields in the main structure, which means every time you do any operation on the contract you have to deserialize all of this and later serialize all of this back. So this is cost you gas and storage cost for writing it and reading it and for fungible token metadata we introduced a new collection that calls lazy option.
00:07:41.390 - 00:08:44.790, Speaker A: And this is what I talked in the last review about the berry cards where we have trade data that doesn't need to be deserialized every time unless you actually want to trade. So it might be helpful to split our main structure into this lazy option fields and implement them separately so they don't need to be deserialized unless you actually operate on it. And we can talk about lazy option later in the next video once we actually publish it. So there are some fields. So there is an ordered map on accounts. The string here I would prefer to use account id. And the reason for this is it makes it a little clear that this is an account and not an actual.
00:08:46.600 - 00:08:49.590, Speaker B: Could you also use a valid account id type?
00:08:51.160 - 00:10:11.432, Speaker A: Yeah, you can use a valid account id as well if it supports borsch. Let's see if it does. Yeah, it does support borsche, so it should be fine. Also, I started to look into how to decrease thread size and there is huge amount of logic coming from strings because let's say if you go into string then you have methods such as from UTF eight. So from UTF eight method takes a vector and tries to parse this vector. So we actually spend extra data every time we parse an account id as a valid UTF eight. In theory, account cannot even have an escape character inside, so it will be immediately nonviolet so what we may want to do is to have an account id represented as a vector of u eight internally and not as a string, but then you can implement a display for the account id and conversion to string if you want, and stuff like this.
00:10:11.432 - 00:11:07.410, Speaker A: But that will give us some performance boost. Every time we deserialize a string, we don't need to call from UTF eight on the string. Staking pools as a vector, so you cannot really have that many staking pools, which is probably what we want. It's a list of pools you want to diversify in. So it's not in an order, it's not a persistent vector, which means we will deserialize all this data every time, which is also another inconvenience. It's kind of fixed size, but it has an account id as well. Now, loan requests, not sure what it is, but it's a lookup map and then a bunch of extra configuration data.
00:11:07.410 - 00:11:43.310, Speaker A: Operator is probably the one who rebalances. It's maybe an account id as well. And treasury is an account id as well. Cool. So there is a lot of data in the main structure which will cost extra gas for deserializing it, but the data is not that large. So it's a bunch of integers which are in binary serialization. Deserialization are fairly cheap, so it shouldn't be a big issue.
00:11:43.310 - 00:12:45.760, Speaker A: Okay, so we're going into a new contract implements several trades, deposit trades, taking pool meta staking and multitoking. Cool. We actually don't have a standard for multitoken yet. We only did one contract token for fungible token. But I guess some contracts might need to support multiple tokens so they will have to be separate. Okay. All right, so initializing it uses some nice mechanics where you say how much gas you use in a core or in a comment to the method.
00:12:45.760 - 00:13:58.326, Speaker A: Ideally we wouldn't need to do this if there was online simulation like on RPC level where you can just tell me how much this transaction going to take and it will tell you. So it attaches somewhat the same amount of gas needed. So we initialize a bunch of stuff it and we use return self, but probably a resty way to just do this. Pink. And it should pink. So deposit it does internal deposit, withdraw. So one thing we started doing for fungible token standard is security consideration for everything that is payable.
00:13:58.326 - 00:15:02.080, Speaker A: So in this case a withdraw method is payable. It operates on the amount of positive balances. So in theory we want to enforce that. This is like one yakta. Maybe we should even introduce a macro right now, something like not payable, but require one yakta on the API that will actually check the touch deposit is one yakta. And eventually we can turn it into contract metadata that will use this decorator to say that this method should not be part of the access key. And the reason for this is like, well, maybe you don't want to withdraw it from access key to your balance, select to some other place.
00:15:02.080 - 00:15:31.400, Speaker A: Even so, withdrawal is fairly safe, usually internal. Withdraw, withdraw all. So that would be nice to know how much gas these methods cost, because constructor, you call it only one, so you don't really care. You can attach like ton of gas for the constructor, but for regular methods, it would be interesting to know how much gas it takes.
00:15:32.110 - 00:15:47.550, Speaker B: Yeah, I was imagining also some sort of gas abstraction where in this case, when there's some external contract, that external contract could also tell you how much gas it costs.
00:15:50.050 - 00:15:53.326, Speaker A: Some kind of decorator, you're saying, or.
00:15:53.348 - 00:16:09.380, Speaker B: Just like some other trait on that contract that would outline the costs for each method. Yeah, but that's some fanciness that I just thought about, but never done anything with.
00:16:11.450 - 00:16:51.470, Speaker A: Chad. Hey, I see we're looking at something called metapool. Yeah. Metapool is another version of a stake token, but it works with multiple staking pools and that try to bundle them into one contract in one token that kind of diversifies across multiple pools. So let's say one pool became inactive. You don't really lose that much value for the next epoch. Who read this? So this is from Narwhal on a narwalt.
00:16:51.470 - 00:17:17.306, Speaker A: From Robert. Not from Robert, from Lucia. Lucia. And how different is it from stake? I don't know yet. So stake is one to one. So it issues a token for one staking pool. So this is one too many.
00:17:17.306 - 00:18:10.202, Speaker A: So it issues one token, but it diversifies across pools that are controlled by operator. So it allows you to, for example, bootstrap low pools that have lower fee, but they're also lower on the list, so you don't risk if one of them falls off, but you also supporting decentralization. And do I have to pick all my own pools? No, I think it will be provided by operator. So we don't know yet. I'm still kind of starting to read the API. Seems like maybe something where today operator is an individual, but operator could be turned into a dow in the future. Yeah, that's how I actually think about access control.
00:18:10.202 - 00:19:09.280, Speaker A: So the contract doesn't have to built into the access control itself. So every contract doesn't need to have a separate control per owner. It just say one owner to control it and then this owner is going to be a contract itself that does the governance. Okay, so this is a bunch of stuff like stake and stake and stake all getting balances, getting values. All of this is not as interesting. Get owner id reward fee uses reward fee I guess similar to the azure contract. The stake and pool contract get staking key.
00:19:09.280 - 00:19:45.980, Speaker A: Boom. No staking key. Staking passed get account. So it looks like it tries to mimic the staking Pool API. So it can be considered a staking pool itself. So it's kind of like a metapool I guess. I understand now.
00:19:45.980 - 00:21:11.080, Speaker A: It allows you to kind of deposit here and then it start to spread this information like this data these funds into staking pools. Get accounts info result what is this? It's a large one. It's kind of like info pro account. Okay, cool. Finish on staking user method completes and stake action by moving from the retrieved from pools to available. Try finish on stake itself on YouTube. What? Okay, terminal update account log.
00:21:11.080 - 00:22:49.532, Speaker A: It seems like here we can actually use this debug macro from top biased near stake. What? Okay, so it's identical to stake but it's not payable. So I guess it has to be payable. It oh, you first deposit and then stake. Um, sell discount basis. So there is some mass that probably you need to check separately. It why are we doing it in U 16 discount basis point why even cop it into percentage or something like this? Why not give it like this larger denominator? All right, this is one that seems to be interesting.
00:22:49.532 - 00:24:00.300, Speaker A: Let's look at the method to sell near. So this is the amount of stake near you want to sell and this is how much near you want to get at least so you get how many on. So we convert um, amount to sell. If it's less than what is near is one year. If less than one year, we sell in everything. If more than we sell the amount at least one year, then we sell the amount. I don't know what is NSLP account.
00:24:00.300 - 00:25:07.080, Speaker A: I guess it's some kind of account to keep track of liquidity near stake liquidity pool assumption near to receive. So we look at the liquidity we call how much you will get if you try to sell to sell. So this is where we found overflow in vladscode in the past. Let's see if there's some potential to see an overflow here. Discount basis points is probably like a liquidity fee that you take. Apply percent of discount to the amount to sell. That is using you.
00:25:07.080 - 00:26:29.312, Speaker A: So it uses denominator. Okay, so this is how discount works. So discount works based on liquidity that is available when you're trying to sell something. So you get less if you're trying to sell all amount because you don't have unstaked balances. So this is how it works. So let's say you have a uniswap that allows you to convert staked balance to unstaked balance at the current rate of the stake balance. But then someone keeps this unstaked balance unstaked in the liquidity pool, and they earn tokens or they earn commission for people who needs to skip waiting period.
00:26:29.312 - 00:27:30.242, Speaker A: So they don't want to wait two days or four epochs for unstaking to happen. So they just go to the pool and do instant swap. And for doing this, you kind of earn in your more often staked balancing or more of the staked tokens into the liquidity pool. Then you provide the staking, wait for epochs, and rebalance the liquidity pool. So this gives you ability to make profit on unstaked near. And that's the whole goal of this thing. It this one returns you 128 as well.
00:27:30.242 - 00:27:58.958, Speaker A: So that's this into. It doesn't. We don't really need this into. Okay, so this is how much near you receive. And if you get less, then we panic. If your available balance is like less, then we also panic. But that shouldn't happen because we calculated it straight from available, so it's unlikely this may happen.
00:27:58.958 - 00:29:13.770, Speaker A: It's more like a safety check. Now, how many shares you have to sell? What is share there? Share to amount is proportional. Total shares, rounded download. If you don't have so many, then we panic. So we're saying the liquidity pool decreases the amount of near you get. Near what? Why do we need this kind of check? This check actually verifies that you received less than the amount you sold. But you sold St near.
00:29:13.770 - 00:29:43.790, Speaker A: So in theory, St near can never go lower. But this is not true because let's say we have a staking pullback or something like this, and one of the stnier is non recoverable. It doesn't earn fee. Well, it's theories. It should be fine. Anyway. So this one calculates how much fee you get fee in shares again.
00:29:43.790 - 00:30:25.074, Speaker A: Round it down. No stake shares from amount again. Yeah, round it down. Can we pull a bunch of internal accounts? What's important here is none of this should be the same. Otherwise we will fetch the information that is same account, but there are going to be three copies of this account. So let's say a treasury is the same as operator. In this case, we will pull two accounts from the state, but they will point to two different copies.
00:30:25.074 - 00:31:56.674, Speaker A: So if we modify one here, modify one there, one of these operations will not be received. So treasury gets cut from fee and near operators get cut, then developer swap cat basis points, non configurable. So it's like hard coded treasury cat, operator Cat, and developer cat nominal PCAT meta from operation. What would be the correct way to deal with the fact that treasury account, operator account, and developers account could potentially all be the same? You would probably want to save this account here and then pull it only after for operator account. So you kind of independently operate on treasury first, then on operators, then on developer. Then you need to update it again. So maybe you pull this account again or you do the math first here.
00:31:56.674 - 00:33:15.604, Speaker A: So you will do something like this. Then you move it all here and then you would do, let's check treasury then. Where do we save this account? User NLP? Yes, you do this, then operator account will do. Here's it. And then developer account will be here. So you do a bunch of operations all independently. Well, at least it works for this contract.
00:33:15.604 - 00:34:54.830, Speaker A: Like it's possible that it cannot work for a general case. In this case, you just may have to go multiple times to like oh, let's pull this account again. It so this assert better be living somewhere here, let, because you computed all the values here and then you don't need to do modifications. Some of this is already in a variable, so you don't need to recompute them. But anyway, so we add stake shares and again this mass probably can be optimized into a variable that is already computed somewhere here. Maybe there's different values. Not sure why it has to be in these variables.
00:34:54.830 - 00:35:46.406, Speaker A: Probably not to leak meta to seller or something, but we already updated total meta, total meta from operation. Okay. Anyway, so we saved the user account to save NSLP account. Again, user account can be an operator account potentially. So you need to be careful what you do here. So maybe when you pull user account, you verify that this is not an operator. But then how does operator take the money? Cannot operator use it? If you want to avoid it, maybe you should save it here before you start modifying these treasury accounts.
00:35:46.406 - 00:37:16.356, Speaker A: So you would save, but then maybe there's some logic that will be broken at the moment, but probably okay. Or you can introduce art or reference here. So when you get an account, you don't just get it from the state, but you also cache it locally into some kind of static cache for the duration of the execution anyway. The only problem if the account now can be an operator, developer, or treasury account, so that might trigger some issue because of this operation and that operation. Not sure if you can just move them here so you don't have to deal with this. So can you potentially move this logic here? Then maybe you will avoid it because you just move this operation. Not sure why developer takes half of the meta hard coded here instead of a fee, so maybe it's logic now.
00:37:16.356 - 00:37:50.584, Speaker A: Next method looks like adding liquidity. So this should be interesting as well. So you say how much you want to add? Assert min amount. What is min amount? Five near. You can only add at least five. Here's. Do you know why that would be true? Well, I guess you want to avoid some rounding error.
00:37:50.584 - 00:39:39.020, Speaker A: Select some other stuff. Do it. So the staking pools, they deal with this issue by having this kind of magical yocta near fund that is like throwing extra yakta surrounding this one doesn't really have this lp meter stake delta stakeholders shares. The total pool value is available balance plus from stake shares plus unstaked and shares from amount rounded down. So all this rounding down occasionally causes issues. I guess it's a denominator. Righteous amount total shares.
00:39:39.020 - 00:40:01.844, Speaker A: Total amount. Total amount is denominator. Total shares is a multiplier. So you multiply amount by shares, divide the total pool value, and that's how you know how many shares you get. So rounding down is fine. So we decrease the balance. We increase the shares.
00:40:01.844 - 00:40:25.888, Speaker A: We increase the amount. We increase the shares. So we minted new liquidity save account. So that works. Remove liquidity should work somewhat similarly. Realize meta. Okay, so let's see what is realized meta.
00:40:25.888 - 00:41:45.750, Speaker A: So values in share pending meta realize Samsung give account meta. Cool. So it's a little confusing because there's meta, there's staking shares, and there's like unstaked balances. Not sure if you need both meta and staking shares, but probably you might need this. I feel like meta is a staking share or like shares that we're dealing with. Okay, how much we need to remove liquidity valued shares amount from shares from shares proportional. So that's interesting because they do not round up the amount.
00:41:45.750 - 00:42:49.120, Speaker A: So you want to round shares up because you essentially underpaying some rounding error because you remove less years than the amount. If less than one year, then remove all makes sense. I would probably panic saying this. So it kind of like removes unexpected amount. So you say, hey, I want to remove half of the balance or like half of near, but instead it removed full zero point 75. So it kind of broke the request. So it removed more.
00:42:49.120 - 00:44:45.898, Speaker A: So instead I would say, well, you actually need to remove exactly this amount because it's less than one year. Instead of letting user silently modify the amount, the contract stake shares to remove to remove remove removed liquidity removal is kind of a little more complicated because you need to remove from multiple pieces. I also think there might be some rounding errors from all this amount from shares and taking pool actually dealt with them by throwing this Yoktanier extra from the trillion of yoktaniers. But this one implementation doesn't do this. So I'm not quite sure how all of this works, but maybe it works from because we have near state near to actually take it basically compute rounding error comes from near to remove. All right, cool. So you get near to remove to your account, you get shares, and you get unstaked, and we remove your liquidity shares.
00:44:45.898 - 00:45:24.840, Speaker A: Now, you do reverse from here, you remove all the stuff that you do. Okay, so now it actually makes sense for me. So you have your account that has two values, ignoring the meta token. So you have three values. You have available, unstaked and staked, and liquidity shares. So four values. Well, also 50 is a matter.
00:45:24.840 - 00:46:10.690, Speaker A: And then on liquidity pool is an account that accounts for all the liquidity. For swapping, it tracks the same values. It would probably make sense to somehow wrap them all together, if it's possible, into maybe a data structure. So you would introduce a method, something like add or remove, that operates on all four or five values. And this way you don't need to write this separately, because you kind of have to do this most of the time. Not sure why liquidity provide. When you provide the liquidity, you don't need to stake.
00:46:10.690 - 00:46:42.762, Speaker A: I guess it's staked from your liquid near. But in theory, you should be able to provide liquidity from your already staked balance harvest. Meta. Stake realized. Meta. What is this pending meta? You realize meta. I don't know.
00:46:42.762 - 00:47:08.526, Speaker A: I still don't understand meta. Meta from liquid pool. Okay, cool. So that's it. So this is the main method. I haven't actually fully understood the meta logic. We are not going to look at the reward loans or reward internals utils.
00:47:08.526 - 00:48:58.048, Speaker A: We kind of looked types hash some information that you may get. Reward meter, compute rewards delta. Not sure if I fully understand why we need both of them in the same contract. But mostly I understand except for meta in theory. How would you deal this? You already have staking shares so why not just operate on these values instead of like having maybe there's some distribute staking that's kind of going to be expensive. If this is 75 and then this is 100 plus not 100 but base. So total 100 plus 20.
00:48:58.048 - 00:50:31.022, Speaker A: So 120 for a single staking pool. But where does it call it sp okay so this is on, I guess you need to call it multiple times to like iterate on it so it will do this. Cool. And then there are some callbacks on this which are going to verify if we succeeded or not. And same for staking and then query current stake. It probably needs extra time to look into this in more details to make sure there's no API issues or anything like this. And this is kind of obfuscated from the user so user doesn't have to deal with this and the operator essentially deals with this kind of stuff.
00:50:31.022 - 00:51:36.830, Speaker A: So operator is the pool owner. So let's say this is standalone pool that spreads this info. Then operator just have to occasionally ping this it some gas internal this is a conversions internal and stake. External stake internal withdrawal. So this is similar to a staking pool to be able to act like a regular staking pool. What is this? Get staking pool required stake. It's not public.
00:51:36.830 - 00:52:11.560, Speaker A: This is not public. Okay. Multifungible token. We are not going to look there. Owner is a pool owner. I'm not sure why you need to add access key that's coming from lockup. So it's probably just for debugging.
00:52:11.560 - 00:54:05.850, Speaker A: Yeah, there are a lot of stuff. How big is the contract? It's like half a meg of the contract. Just because it's a lot of the methods that needs to be handled and a lot of JSON in Borsch. Cool. I think we can stop today but it kind of definitely interesting. It's just not very clear from readme or the comments how the meta token is used and what is a meta token. So it would be good to come back and actually figure out how you can use meta token and where you can use it.
00:54:05.850 - 00:54:32.920, Speaker A: So I'll stop sharing and we can quickly discuss if there's any particular questions or comments on this contract. No? Okay cool. Thanks for watching. See you next time. Thanks for joining.
