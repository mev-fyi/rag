00:00:04.090 - 00:00:20.430, Speaker A: Welcome, everyone, to our new episode of Whiteboard series. I'm Ilya, co founder of Nier, and I have Costas, chief cryptographer at Miston Labs and previously at Facebook. And today we're going to be diving in at all the things that Miston Lab is working on.
00:00:20.580 - 00:00:48.442, Speaker B: Thank you, Ilya. So, by the way, yeah, I'm also coming from Facebook. As the whole founders team, five of us, we used to be leaders there. I was leading the cryptography part, obviously, while Libra was collapsing, I was actually dealing with other stuff, including WhatsApp security and cryptography. It eventually left and we built XUI. And after a year, now almost a year, we recently launched Testnet. We had Devnet for a while.
00:00:48.442 - 00:00:56.800, Speaker B: We're doing really well on Testnet. We have wave one now running and. Yeah, any question that I can answer, I'm open for you. Sure.
00:00:57.650 - 00:01:01.518, Speaker A: Let's dive in how Suey is structured, and then we can dive in. Right?
00:01:01.604 - 00:01:55.694, Speaker B: Of course. So obviously, we all know the basic paradigm of how blockchains are built, right? You have transactions that are reaching some blocks eventually. You're waiting until either some time or until you have enough transactions here, you're going through some consensus, and then these transactions via some hashing. And obviously someone will pick the transaction that will go into this block, either by mining or by some proof of stake or any other method, you will create a different block with different transactions, and they come here. And then we said, okay, cool. This was pretty much the model that we used to have at Libra, and most of the blockchains are built under this pretty much the same construction. But we said there are a few opportunities where we don't need to wait for blocks.
00:01:55.694 - 00:02:31.150, Speaker B: Maybe we can have some parallelization native into the system. And in fact, you can still evolve into a block situation. But before you build a block, you might have other structures that you can avoid all of this blocking until you get enough transactions. And maybe you cannot parallelize because now you need some sequencing here. All of the transactions should go with some order. And we said, okay, we can avoid it. So Sui took a very different like approach of actually combining two schemes, two mechanisms to have all of this agreement on the transactions.
00:02:31.150 - 00:03:02.434, Speaker B: And now we have transactions that can actually fly independently and unparalleled. TX one, TX two, and TX three. We don't need consensus. You go through the validator set. We are delegated proof of stake, which means that people can actually give with some weight their stake to someone else who will vote on behalf of them, like regular democracy. And these transactions will go unparalleled into. You're having questions about democracy.
00:03:02.482 - 00:03:09.142, Speaker A: Yeah, regular democracy is very broad definition, but off topic from this I get it.
00:03:09.196 - 00:03:37.362, Speaker B: Let's assume there is a set of validators. There are epochs, of course, like every few moments at the moment, we have a day for an epoch. At Sui. This can be rotated based on the stake. And let's assume now that we are in an epoch and we have all of these transactions happening on parallel. And what will happen in this particular case, I will assume like a four or five situation. You just go on this transaction to the validators and you ask a signature on parallel from all of the four out of five.
00:03:37.362 - 00:04:07.450, Speaker B: Let's assume it's literal five and you need four out of five for BFT, you get the signature back, and then this might be enough if you can construct now the user the difference between the other chains and suite. The user here is actually getting the transaction of the, getting the signatures for this transaction. They are forming a certificate and they are sending it back to the validators. How does this help you? Do you understand why this is actually useful?
00:04:08.190 - 00:04:16.238, Speaker A: Well, it's non blocking, right? So you don't block on waiting for all the stuff. And it's from the user perspective, so you can order your transactions in the way you want.
00:04:16.324 - 00:04:54.022, Speaker B: Exactly. So there is a benefit here in the sense that these validators do not need to interact between them, which usually introduces an n square, or depending on the protocol, it might be Ncube like communication cost. Now what we did is we have the user, and the user is actually the driver of, yeah, I'm sending a transaction, I'm going into the validators getting only signatures. They don't communicate between them. Then I receive all of the signatures back. We're using BLS, and bls in this particular case can actually aggregate the signature. The signature is aggregated on the usage side and I send it back to the validators.
00:04:54.022 - 00:05:40.738, Speaker B: So the validators, they see a signature of like n two f plus one of them, and they say, okay, if other people also sign and I also sign, we have two f plus one, I can accept this transaction without communicating with them. Instead of having the validators actually communicating, you have the user being the aggregator. And in this two step process, which can happen on parallel, of course, you can actually have the same thing as a consensus mechanism. This is taken from a protocol that George Danezis and some other people in our company, Alberto as well, have created. Back at Facebook it was called fast pay. So this is a method for fast payments without full consensus. There is no full consensus here.
00:05:40.738 - 00:05:47.162, Speaker B: And you can have parallel transactions. Obviously there is a caveat here, right? I mean, you cannot do it.
00:05:47.296 - 00:05:48.582, Speaker A: Well, you don't have ordering.
00:05:48.646 - 00:05:57.498, Speaker B: Yes, exactly. Now you don't care about the order. What are some examples that this works? Can you give me a few applications where you don't need ordering?
00:05:57.594 - 00:06:00.560, Speaker A: Well, given you're calling to pay, probably you mean payment.
00:06:01.090 - 00:06:34.662, Speaker B: Yeah, you're right. Okay, so you go to Starbucks, and by the time you go there, you buy a coffee, and then obviously they are ready to prepare your coffee to serve you. They don't need to wait for a block. You just send the signatures, the request signature to the validators. You don't need to wait 3510 seconds until a block is formed and you are getting these signatures by yourself and you are giving them directly to Starbucks. And Starbucks knows that this certificate will one day go to a block. Now they can serve you the coffee.
00:06:34.726 - 00:06:38.810, Speaker A: So what happens if you don't have the money on your balance?
00:06:39.150 - 00:07:10.582, Speaker B: Well, it's your object, right? I will explain how the object models works, but at this mean you can get the certificate. Starbucks will check the signatures, but the validators, when they sign the transaction, they check that you had the balance to actually pay for this element. And because in order to sign, obviously they check the correctness of the transaction. But this is what they do. They didn't communicate with other validators. That's the trick. They do the execution, they do the locking of the object, and they check that you have enough balance to pay for this.
00:07:10.716 - 00:07:19.578, Speaker A: So there is a state transition that happens when you receive the kind of transaction first time. You have changed the state somehow here.
00:07:19.664 - 00:07:45.470, Speaker B: Yes, exactly. There is a state change. But the small difference between other account based systems and our system were somewhere between account based and Utxo based. So Sui is not Utxo based, like completely. It's not even an account based. Well, you have an account. So let's finish with this stuff and then I can explain why the object model in our case is very useful for Fastpay.
00:07:45.470 - 00:08:11.210, Speaker B: Fastpay wouldn't work in a purely account based system of Ethereum. For example, the idea is that you have like, imagine this transaction is using only one Utxo. This might be the object that I'm sending you. It might be $5, right? It's these $5 that will change state. Of course. And what's the change of the state? I'm changing the owner. I'm just sending you a particular object.
00:08:11.210 - 00:08:39.540, Speaker B: So imagine all of them as being like nfps. Yes, but it's fungible now, right? It can be fungible, it can be mutated, but it doesn't matter. It has an owner. So the balances are not under accounts anymore and are not under contract. Like internal data structures, they live independently. So I'm sending you this, and this is why I can make the state change without affecting anything else on the network. I'm only affecting the state of this particular object.
00:08:39.540 - 00:09:09.340, Speaker B: And this is how you are getting all of this benefit on payments. Some other examples that are very interesting. Okay, let's go and listen. Right, payments, obviously you can have confidential payments because there is no huge difference between sending real visible integers or sending peders and committees. I mean, you can do whatever you want. These can also be objects. What you can do is you can even build like your personal web page.
00:09:09.340 - 00:09:26.566, Speaker B: It's something that you own every single time you're mutating your page. Nobody else is affected. If you know how to do your ordering by yourself, it can be unparalleled. You don't need blocks anymore. The same thing is for Twitter. We have this example on sweet. We call it Twitter.
00:09:26.566 - 00:09:51.066, Speaker B: What is a tweet? It's an NFT. So in practice, when I'm sending something to you, I'm creating an NFT and I'm sending it to the network. I'm the owner. Then in this NFT, I might even have a reference if it's a retweet, if it's a like, or it's something else. And in practice, everything lives as an NFT. In theory, you can imagine sui as. Yes, we have defi, we have the NFT world.
00:09:51.066 - 00:10:00.990, Speaker B: We have all of this history. And we learn from the goods and bad things of the past. And we build a system where everything can be considered an NFT.
00:10:02.050 - 00:10:07.358, Speaker A: It's an object store, right? Where every single thing has an owner which can mutate it.
00:10:07.444 - 00:10:39.020, Speaker B: Exactly. And anything that you can imagine that it's objects that you control, nobody else can touch, it's only you that actually can define the order can be built with this fast pay model. Some other examples are even things that you cannot imagine. It is possible to do with single owner. We call them single owner objects because they have a single owner. Can you imagine of something that you believe that it would require some locking, but I can avoid it.
00:10:39.390 - 00:10:41.638, Speaker A: I think the most interesting is uniswap.
00:10:41.814 - 00:11:08.078, Speaker B: Uniswap you cannot do. You got me here. Okay, so with uniswap and the transactions for which you need some people actually to agree on order. On some ordering, you can do different things. One is in this one transaction, you can probably have a transaction that gets two transactions as an input. We both sign the transaction and we submit the transaction. So we agreed on the ordering together beforehand.
00:11:08.078 - 00:11:36.138, Speaker B: There is an issue here. However, in some applications it might be tolerable that the other player might at the same time send the same object that they locked in the same transaction somewhere else, and there might be an equivocation. So there is a race. Will this succeed or the other transaction will succeed and there is another race. Maybe this transaction will succeed on 50% of the validators and the other on the other 50. And then you have a problem. Yes, you need to resolve it.
00:11:36.138 - 00:11:53.102, Speaker B: And then the resolution. I guess you're going to ask, how do you resolve this? Right? The resolution can happen. Even the same user can do a mistake without an atomic swap. I'm trying to send an object for some reason. I have two services that are running on parallel. I have two servers sending the same object. You're sending the same object.
00:11:53.102 - 00:12:17.890, Speaker B: So what we can do is we're resolving this at deploy level, deepoc level. You can do it. And there is, because at the epoch level you can actually say if you didn't receive, the transactions can actually define the epoch that they want to be executed. If you didn't receive it on time, just throw it and then you can start again. What's your epoch lengths at the moment? It's one day. Well, this is something that we will play with that. But there is an extra proposal.
00:12:17.890 - 00:12:45.342, Speaker B: Lefteris Koyas, who is one of the, he's a great author on census schemes. He's working on unfreezing. I can provide an evidence, right? I have a transaction that has 50% of signatures and the same object, another 50%. Unlock it. I provided an evidence, so you can do it. So there is a fast and freeze. But it's not only those examples that I explained here.
00:12:45.342 - 00:13:08.230, Speaker B: There are more examples. Well, defy, as you said, uniswap is more complicated. You can do it with this way. However, with a multi agent transaction. We're working on the multi agent. It's not there yet, but there is also lotteries. Imagine if we have a giveaway, where in this giveaway you have a car, right? You're giving away a car, people are participating.
00:13:08.230 - 00:13:34.026, Speaker B: And obviously if you imagine a lottery in your head, you will say no, this requires a third object. I mean, we cannot participate in the same lottery where people are locking money. This money should go to some counter to some balance that it always goes up and up and up. There is a way to avoid it. And the way to avoid it is I can buy tickets independently on parallel. I pay $5 in this payment. I pay the owner of the giveaway.
00:13:34.026 - 00:13:57.650, Speaker B: Let's say it's an organization. So I pay $5 to buy a ticket independently. We all pay $5. There is no limit, right? Because the total profit, eventually, the reward is not dependent on the ticket, on the number of tickets. It's only a car. You will win a car, which means that you buy tickets independently. And in this particular case, you can have the fast pay approach.
00:13:57.650 - 00:14:14.062, Speaker B: I just buy tickets. But how is the winner defined? Now have the problem. You need to define a winner. So the winner can be defined by the fact that you can use fraud proofs. We can use the. Do you know, algorithms, sortition algorithm where they do the leader election thing.
00:14:14.196 - 00:14:14.686, Speaker A: Yeah.
00:14:14.788 - 00:14:47.400, Speaker B: So very quickly, let's assume that we find a way to have the lottery beacon. I will erase this if that's okay. So we're now on the lottery example, right? And in this lottery example, we're a lottery. We have nfts, which are the tickets. Ticket one, ticket two, blah, blah, ticket n. Eventually, on some, we define when this ticket issuing will finish. Let's assume epoch seven.
00:14:47.400 - 00:15:05.786, Speaker B: Epoch seven, you start from epoch one until epoch seven. You can buy tickets, that's fine. And then eventually you have a list of tickets. And let's assume on epoch eight we have the bitcoin. The bitcoin is defined on epoch eight. How do we define the. I mean, all of them are independent.
00:15:05.786 - 00:15:33.478, Speaker B: You don't know. You cannot even sort them, you cannot do anything. However, the users can have access on these tickets because it's a blockchain, they can go offline. Let's assume that it's a very basic function of hash of a beacon comma ticket. Everyone is producing the hash of a beacon comma ticket, and the smallest one wins. Like the hash that starts with many zeros wins. So only the winner is the one that will go and have a shared object.
00:15:33.478 - 00:15:50.854, Speaker B: Now, all of the tickets, 99.99% of the transactions, are fast pay, and only the winner will use the shared object, something for which you need consensus. And what the winner will do, will say, I won. You will wait. If nobody complains, you won. If someone comes to you, it's like arbitrum.
00:15:50.902 - 00:15:52.666, Speaker A: Yeah. Then you keep going down.
00:15:52.688 - 00:16:16.086, Speaker B: Yes, you keep going down until there is only one winner, nobody complains, and then you're definitely the winner. Or the winner didn't report it. But everyone can report it, right? Even if you are not the winner, you know how to provide the ticket as evidence, as a fraud proof. And this is very similar, actually. It's a good way to have fraud proofs on sui. Not necessarily a fraud proof by executing the whole state. It's a special case.
00:16:16.086 - 00:16:19.750, Speaker B: Fraud proof. There are more, there are more applications.
00:16:20.090 - 00:16:28.822, Speaker A: Yeah. So how does the consensus in the beacon? Are you just saying that you're waiting for another epoch for everyone to present it, whoever is a small.
00:16:28.876 - 00:16:44.382, Speaker B: Yes. Let's assume we're using dram, right, or any beacon. And we say on epoch eight there will be some random beacon. You don't know it by the time you registered because you registered until seven. So when this beacon is published now we're going to do all of the hashes offline and the winner will just report it.
00:16:44.516 - 00:16:55.502, Speaker A: That's what I'm saying. There's some code somewhere that will be then reassigning the ownership of the car, for example, after this is all published. Right? So how's that exactly?
00:16:55.636 - 00:16:57.026, Speaker B: So at the very beginning, I'm just.
00:16:57.048 - 00:16:59.650, Speaker A: Publishing an object of this hash, right?
00:16:59.800 - 00:17:42.522, Speaker B: It's a great question. At the very beginning, the organizer defined the third object. This is an object now that is not single owned. It's like a data structure or it's something that the organizer actually has sent one car nft here. And obviously the rules, like on epoch eight, we have to get the beacon and if someone executes a transaction, we have to wait, I don't know, for two epochs for the fraud proof. So this one, it's a served object created at the initiation in the beginning, yeah. Yes.
00:17:42.522 - 00:17:46.500, Speaker B: And then the winner will come to this object to request the car.
00:17:47.110 - 00:17:55.140, Speaker A: So what's the interaction? Because for me, this transaction is my object. Right.
00:17:55.610 - 00:18:01.000, Speaker B: It's just an input. It's just an input to this particular.
00:18:02.170 - 00:18:07.030, Speaker A: Here you were explaining how you interact with your object. So how you interact with somebody else's object.
00:18:07.100 - 00:18:59.266, Speaker B: Okay, that's great. So a nice thing by using object based model for Sui is smart contracts can get as inputs object from other smart contracts. Now you can literally have, I'm raising this now you can literally have an object that is having a reference to another object or a function. Under the lottery contract, you have a function that takes as an input some object type x, and this one might be your ticket. So you will provide the ticket. This ticket type can only be created by this smart contract. You cannot create it by another smart contract.
00:18:59.266 - 00:19:17.226, Speaker B: So the winner will just send to this function that lives under the cert object, an object that has been created somewhere else. I mean, where you're buying tickets. And it can understand that this is object type x. And it knows. Oh, it's definitely a ticket that I issued. It was issued by my particular smart contract.
00:19:17.418 - 00:19:22.378, Speaker A: So let's say this lottery contract has like function by ticket, right?
00:19:22.484 - 00:19:25.710, Speaker B: Yeah. And this is single owner.
00:19:25.790 - 00:19:34.690, Speaker A: Yeah. Which outputs the ticket of that type. And so ticket has the owner field, which will be.
00:19:34.760 - 00:19:40.102, Speaker B: And probably the lottery id. There might be a lottery id as well. So you know this is a ticket for this lottery, right?
00:19:40.156 - 00:19:40.566, Speaker A: Yeah.
00:19:40.668 - 00:19:41.718, Speaker B: Maybe you need it.
00:19:41.804 - 00:19:43.346, Speaker A: Well, if this multilateral.
00:19:43.378 - 00:19:49.142, Speaker B: Yes, if it's a multilottery one. And I will explain why multilottery is possible on suite easier than ethereum.
00:19:49.286 - 00:19:55.638, Speaker A: So then when you present this here, it then does a hashing with the beacon.
00:19:55.734 - 00:19:56.138, Speaker B: Exactly.
00:19:56.224 - 00:19:59.354, Speaker A: And this ticket id.
00:19:59.472 - 00:20:07.642, Speaker B: Yes. If it's smaller than the previously smallest one, you register it and you wait until the fraud proof expires.
00:20:07.706 - 00:20:14.114, Speaker A: And so you still need another method which is like actually declare winner or something like distribute or whatever.
00:20:14.232 - 00:20:14.900, Speaker B: Exactly.
00:20:15.270 - 00:20:19.746, Speaker A: Okay. And so distribute returns the car in.
00:20:19.768 - 00:20:40.710, Speaker B: This case to the winner. To the winner, yeah. So as you can see, there are protocols. Indeed. Or applications where we can use just of pay payments, Twitter, like mass NFT, minting. You're minting nfts on parallel. I mean, nothing is stopping you from ordering your own minting.
00:20:42.490 - 00:20:47.562, Speaker A: It's an object that mints nfts too, right? In this case, it's by ticket. It'll be an object.
00:20:47.616 - 00:20:54.910, Speaker B: So I can in parallel, this function, mints NFT. Yeah, but you can call it as a single loan. I mean, you are not touching anything on this state.
00:20:55.060 - 00:21:01.726, Speaker A: Well, so that's the question is like, no, when I write the code for this object, right, I just specify that.
00:21:01.748 - 00:21:04.962, Speaker B: This is, this byte ticket could even live outside this object.
00:21:05.096 - 00:21:05.780, Speaker A: Okay.
00:21:06.230 - 00:21:38.010, Speaker B: This module, it can accept any module type here. That's why we have the composability in Sui that you cannot easily get on Ethereum. On Ethereum, everything is a U 256. How do you know it's a has? How do you know it's a number? How other contracts know the type that you represent internally in your own contract? Well, in our case, they are like strictly typed. You know exactly what this is like of this type. And if you also need to use some generics, we also have this object type p. You know, it's from this lottery.
00:21:38.010 - 00:22:19.754, Speaker B: And this is why we allow this composability. And I guess one example that you will see with Sui is people who are running independent contracts. Then I can go and create a new contract that has input, some object that you created on your own contract. And maybe you can define like many complex structures here of different contracts, communicating with other contracts and different types of objects and evolution, you can even evolve. Now if you don't like your contract anymore, you can just create another contract that takes as inputs types of your previous contract and you know exactly the type of the expected inputs of the function. So that's a benefit, I think it's, is it clear at least?
00:22:19.872 - 00:22:44.846, Speaker A: Yeah, at the high level, yeah, I think probably worth saying pretty much that the object that's stored kind of on chain. Right. Which are, there's owner kind of, and there's some global idea, I'm assuming. Right, yeah, that's used. And then the code is living separately and the code can refer to any of the object types.
00:22:44.958 - 00:22:45.618, Speaker B: Exactly.
00:22:45.784 - 00:22:48.034, Speaker A: Right. And so through that only which might.
00:22:48.072 - 00:23:14.330, Speaker B: Be single owner or like shared owner. What is a cert ownership? Right. What is a cert ownership? Okay, I'm raising this again. You have a contract on Ethereum. Let's take a contract on Ethereum. You have some like what is the name for struct on Ethereum we use track. But anyway, you have a contract.
00:23:14.330 - 00:23:38.042, Speaker B: This contract has internally, usually a map. Right. Where you have the owner, comma, some whatever is the UID or something. Yeah, whatever it is, you have a map. This one, because everyone can go and write on this one is a shared object, of course. Right. And it's actually held as like some data structure internally to the smart contract.
00:23:38.106 - 00:23:38.298, Speaker A: Yes.
00:23:38.324 - 00:24:08.282, Speaker B: If it belongs to the smart contract, with high probability it will be a shared object. But now you can even have objects that do not live as a shared data structure. It's like a single thing. You have an NFT that has as ownership a user. It's still coded inside this module, but it's not part of some data structure. And this is where you're getting all of this single owner and those that are not single owner. So everything that you see in an Ethereum smart code run where it's usually a map of things.
00:24:08.282 - 00:24:12.078, Speaker B: Everyone can go there and write. These are the cell objects and anything.
00:24:12.164 - 00:24:20.670, Speaker A: Else is, let's say this is owned by some user, but a third user wants to modify it, they cannot.
00:24:21.090 - 00:24:24.020, Speaker B: But let's say there's, give me an example.
00:24:24.870 - 00:24:33.410, Speaker A: We're playing a video game, I'm doing damage to your character. The smart contract would modify the health points on your.
00:24:33.480 - 00:24:51.938, Speaker B: If you need to access it. You need to go to the cert object model. If you need to modify it without me giving you the permission, you need to use this. But not all of the games are requiring. Yeah, but if you require this property, I do agree with you. You need full consensus. You need to go through a third object and maybe you can find the pattern.
00:24:51.938 - 00:24:59.174, Speaker B: I don't want to be blind here on the sense that when we say something, it's only possible with served objects because you've seen before in the lockdown.
00:24:59.222 - 00:25:00.058, Speaker A: You can turn things.
00:25:00.144 - 00:25:06.810, Speaker B: Maybe you can define a model where you can literally do some updates in my character. Maybe you have my character.
00:25:06.890 - 00:25:08.750, Speaker A: Well, yeah, you can have another object.
00:25:08.900 - 00:25:11.406, Speaker B: Which references this character, which is a.
00:25:11.428 - 00:25:15.626, Speaker A: Game object, which has like how much hp deal, et cetera.
00:25:15.658 - 00:25:18.818, Speaker B: Exactly. Or you might even have an escrow, which is a game engine.
00:25:18.904 - 00:25:19.202, Speaker A: Yeah.
00:25:19.256 - 00:25:28.120, Speaker B: Where you deposit the game studio is actually having all of the mutable stuff, and then you're doing all of the things that they cannot touch. So that's the idea.
00:25:29.610 - 00:25:33.686, Speaker A: In module, there is internal. Like, you can have it.
00:25:33.708 - 00:26:15.438, Speaker B: You can have, we have vectors now we're going to introduce even limits on how big these objects can be. Generally, we don't want to allow like huge objects on ethereum because they have the, has the references, they can do whatever they want with the sizes. But in our cases, because you can actually remove things from this object, you can create very interesting data structures. Maybe you can even have a map. And this map gets up to elements. And if you need more, you're just creating an extension object on this that can move one, or you can even have a tree structure. So you have pointers and you're creating multiple objects that are owned by this object.
00:26:15.438 - 00:26:36.646, Speaker B: And now that I mentioned this, we have the concept of parent and children. So you can have an object that owns other objects. So when we say this nft is owned by the user, it might be owned by an object and this object might be owned by the user. So you can have all of this inherent structure to some owners.
00:26:36.678 - 00:26:47.678, Speaker A: So if I modify this, let's say there is this structure, right? There is another object, like house points object is owned by this nft by a user. I can modify this?
00:26:47.764 - 00:26:50.570, Speaker B: Yes. You as a user need to provide all of the path.
00:26:50.730 - 00:26:52.666, Speaker A: Okay? You provide the path, and it knows.
00:26:52.698 - 00:27:19.170, Speaker B: That eventually this signature is required in the transaction. In the transaction. There is a way, actually, it was a good question. There is a way to provide the parent object now. And actually it can resolve all of the children object or the children that you want internally to the execution maybe you say, but that's expensive. Now it can be a bit, well, it depends. Maybe you can find good ways to do it, like some prefixes or some references.
00:27:19.170 - 00:27:44.158, Speaker B: Internally you just need a byte and you know that if you see this byte, it's this object id. Don't provide the whole object id. And yeah, this concept actually exists. It's very useful actually. I can explain why it's useful. Imagine you have an account now in Ethereum, and this account owns nfts in multiple smart contracts. You're a company, and eventually you want to sell your company to another bigger company.
00:27:44.158 - 00:27:45.566, Speaker B: What do you do?
00:27:45.748 - 00:27:50.078, Speaker A: You use near and you use near and the account is actually transferable.
00:27:50.174 - 00:27:54.322, Speaker B: Yeah, of course you can do it. But on ethereum you cannot do this, right.
00:27:54.456 - 00:27:55.538, Speaker A: You did not set it up.
00:27:55.624 - 00:28:07.974, Speaker B: Exactly. So pretty much like you. And in our case, what you can do is you can have a main object or multiple objects, and you just store all of the ownership under this object and you just change the ownership of this particular.
00:28:08.092 - 00:28:12.970, Speaker A: Well, on Ethereum you would do the same, you would have a smart contract and then this will be.
00:28:13.040 - 00:28:26.590, Speaker B: Yes, but now all of these have literally types. You can do whatever you want now, because if you have a smart contract in Ethereum, maybe you don't have the ability to have all of this abstraction and put whatever you want there. Here you literally can put anything.
00:28:26.660 - 00:28:35.454, Speaker A: As a children, as a child you kind of can't. Yeah, on near you can actually swap this. The Account itself is a contract.
00:28:35.582 - 00:28:38.178, Speaker B: Yeah, but you cannot have paralyzation because of this.
00:28:38.264 - 00:28:41.870, Speaker A: Well, you paralyze on account level. Every account is independent.
00:28:42.030 - 00:29:02.246, Speaker B: I agree. But logically, you need to split your account logically now, because you can change it. You cannot have the fast pay model, obviously, because imagine in one transaction you are changing the account and in the other you are doing a transfer. You need to have the order on who is the owner at the time of transaction.
00:29:02.278 - 00:29:03.450, Speaker A: You need to synchronize on that.
00:29:03.520 - 00:29:13.966, Speaker B: Exactly. We don't have this ability because of paralyzation. So obviously you lose something and you get something. But we're working on it. By the way, there might be solutions for this as well.
00:29:14.148 - 00:29:25.570, Speaker A: So I guess just to go back a little bit to this, when I'm changing the state of this, right, you're saying this will wait until end of the ebook.
00:29:27.270 - 00:29:32.498, Speaker B: No, if you change the state and it's a third object, you will not get the fast pay.
00:29:32.664 - 00:29:33.730, Speaker A: Yeah, but that's.
00:29:34.070 - 00:30:02.950, Speaker B: No, we have consensus. Okay, let's go to this now, right? Because we only mentioned one type of the consensus. It's not full consensus, but a way of broadcasting precommend. Exactly. So what is the lifecycle of a transaction? Right? I only explained part of it. So we have a transaction and this transaction will go first. Like let's assume in the fast pay world where the validators will give you two f plus one signatures.
00:30:02.950 - 00:31:05.970, Speaker B: And this is like for locking the objects because here you will have object inputs, object, one object, two blah blah blah. So you are locking this, you are getting all of these signatures back that the validators say I locked this object and then you return back the certificate. This is a certificate. Now you are the aggregator, you send this back and then the validators again will provide a two f plus one signature. I executed it. And if it's fast pay, right? If it's fast pay, it will go through this model and this certificate of the certificate after the execution that the effect certificate, it's enough to go to anyone and pay you. But if it's not fast pay, then after the locking mechanism, after this one round trip, you can actually send it to Narwhal and bullshark.
00:31:05.970 - 00:31:37.690, Speaker B: And this is literally a BFT consensus, like one of the fastest. This one doesn't even require a leader election. So previously if you see all of our documents, we had task and then it's pretty much the same team that actually created both tasks and bullshark. But task requires some random beacon for fairness and other things. And Bullshark. It can help if you have a random beacon, but it's not a huge requirement here. And now you're not going through Fastpay, now you're going through this.
00:31:37.690 - 00:32:21.740, Speaker B: And here you have to wait for a block. And after you have these blocks, obviously you have, some are with effect certificates, some are with Nargle. What do you do? We have another model where these fast pay executed transactions, they can also go through a nargle eventually. And all of these nargals now and this nargo, they go through the checkpoints. And this is the part where sue is a blockchain. Checkpoints evolve into pretty much blocks, yes, but these are enough as evidences for like, I don't know if you have a delivery versus payment, you see the payment and you deliver the object.
00:32:22.590 - 00:32:24.502, Speaker A: How frequently are the checkpoints?
00:32:24.566 - 00:32:41.230, Speaker B: So we're working on the checkpoints. It might be seconds. I think we had an example with six to 10 seconds, if I remember correctly. I don't know what the number will be on Mainnet because now we're working on synchronizing this part of synchronizing to a checkpoint.
00:32:43.190 - 00:32:47.134, Speaker A: How long does this actually usually take? Like getting certificate and certificate.
00:32:47.262 - 00:32:49.982, Speaker B: This happens on parallel. Don't forget that the user.
00:32:50.046 - 00:32:51.860, Speaker A: No, I know, but it's still latency, right?
00:32:54.470 - 00:33:06.646, Speaker B: Two round trips on parallel, like a second. It's less, I mean, it can be, usually it's the worst case, it's 2.250 milliseconds or something. Yes. You can get it in half a second.
00:33:06.748 - 00:33:07.400, Speaker A: Okay.
00:33:10.330 - 00:33:24.710, Speaker B: Obviously it depends on topology and other things here, right. But, but in theory you can do it, but you can, and it can happen on parallel. There is a huge benefit with, I mean, if we get this route, this is like horizontally parallelizable.
00:33:24.790 - 00:33:25.420, Speaker A: Yeah.
00:33:26.210 - 00:33:39.010, Speaker B: What does this mean? Right, unlike other blockchains. Exactly. We can just build workers and actually there are workers on algorithm and bullshark anyway, but this is for extra optimization here on the consensus.
00:33:39.750 - 00:33:41.794, Speaker A: This, yes, I will want to go.
00:33:41.832 - 00:34:10.058, Speaker B: Deeper into this, but this one is actually Nargo is the mempool and we have mempool. And this mempool is actually pluggable and can work with both task and Busarc. And we've seen some companies actually using this for other systems. But yeah, that's the whole idea. George is the best person actually to ask all of these questions. I can go a bit like mean.
00:34:10.064 - 00:34:14.126, Speaker A: I think high level would be probably good to highlight this because you have workers here, right?
00:34:14.148 - 00:34:20.670, Speaker B: I mean, you can have workers and it is possible that they put narwhal packets.
00:34:23.010 - 00:34:25.122, Speaker A: So let's say you have all these validators, right?
00:34:25.176 - 00:34:25.394, Speaker B: Yes.
00:34:25.432 - 00:34:31.922, Speaker A: So you assign some of them to be. So the transaction comes in.
00:34:32.056 - 00:34:37.630, Speaker B: Yes, all of them. They are forming different, let's say blocks, small blocks.
00:34:37.710 - 00:34:38.194, Speaker A: Yeah.
00:34:38.312 - 00:35:04.574, Speaker B: And it is possible that one block is having, I mean, this block is having TX one. This also has TX one. They have different blocks. And then they are starting proposing this. And if you see a transaction that was already included in a different block, I mean, it was already included. There is some duplication here, but this is what gives you the speed, right? I mean, some transactions are indeed in different blocks, however, it doesn't really matter. You just need one of them to include it.
00:35:04.574 - 00:35:23.458, Speaker B: And it's a dag. You get a dag in bullshark and eventually you have multiple objects, multiple blocks being proposed. Some of them might be overlapped, not fully overlapped, and then you go back to check if a transaction was already included. You don't include it. We have some hasmaps internally and all.
00:35:23.464 - 00:35:29.138, Speaker A: Of this will every node need to receive blocks from everybody else.
00:35:29.304 - 00:35:31.170, Speaker B: All of them can actually propose blocks.
00:35:31.250 - 00:35:34.882, Speaker A: Well, they propose, but then they will need to receive it to identify if it wasn't.
00:35:34.946 - 00:35:52.214, Speaker B: Yes. You need two f plus one signatures, right. Even if you didn't receive something, but you receive an evidence that two f plus one have signed. Did you accept it? Yeah, that's the idea. Well, you will see a few systems that actually are down and only two f plus one are live. Eventually, you need to sync up. You have two f plus one signatures.
00:35:52.214 - 00:36:06.510, Speaker B: You assume that the system is running correctly, assuming the BFT property holds. But all of them can propose. That's the thing. And there is a difference because it's a dag. Mev is slightly different on how you do on dags. You know the story, right? It's more complicated.
00:36:06.670 - 00:36:21.474, Speaker A: Yeah, let's not go. Mev is whole separate. I'm just like. Just so for clarity, right, so let's say I am as a user, right? In this case, because I already have the certificate that they saw the transaction.
00:36:21.602 - 00:36:22.470, Speaker B: If you go through.
00:36:22.540 - 00:36:24.914, Speaker A: Yes, this is a lock.
00:36:24.962 - 00:36:25.720, Speaker B: Even if.
00:36:26.330 - 00:36:28.086, Speaker A: Even if I'm not going through this.
00:36:28.188 - 00:36:28.502, Speaker B: Okay.
00:36:28.556 - 00:36:33.066, Speaker A: Even if I'm not going through, I still send the transaction first to all.
00:36:33.088 - 00:36:40.374, Speaker B: The first one to get the transaction that I locked the objects for now. Yes. You are sending it even to narwhal?
00:36:40.422 - 00:36:41.020, Speaker A: Yeah.
00:36:42.190 - 00:36:43.194, Speaker B: To who, man?
00:36:43.312 - 00:36:44.700, Speaker A: I send it to everyone.
00:36:45.650 - 00:36:47.982, Speaker B: You can send to some of them you don't need to send to anyone.
00:36:48.036 - 00:36:50.222, Speaker A: And so they propagate it with blocks, right?
00:36:50.276 - 00:36:50.686, Speaker B: Yes.
00:36:50.788 - 00:36:55.086, Speaker A: And so that's part of Narwold, the propagation of blocks. And the bullshark is the way to.
00:36:55.108 - 00:37:09.350, Speaker B: Resolve all of this. Exactly. In theory, you can even send to one, but you have the risk that this one will not forward it. So you can actually pick a bit more like this number. I don't remember if George has a real number. We're testing this number. What it will be.
00:37:09.350 - 00:37:14.214, Speaker B: Obviously, if you send it to f plus one, it's enough that someone will propose it.
00:37:14.252 - 00:37:33.206, Speaker A: Yeah. Okay, so then everybody proposes a block, and then they start sending their blocks to the other validators. Right. From a single validator point, I have my blocks that I proposed, and then I received some other. There's no timestamping.
00:37:33.238 - 00:37:33.386, Speaker B: Right.
00:37:33.408 - 00:37:34.526, Speaker A: So they come all.
00:37:34.628 - 00:37:42.590, Speaker B: At the moment, we don't have timestamps. You can have timestamps in theory. So you cannot have timestamps here. It's more difficult. Yeah, because this is unparalleled.
00:37:43.330 - 00:37:45.226, Speaker A: But here you cannot aggregate on a timestamp.
00:37:45.258 - 00:37:50.270, Speaker B: But here you can have timestamps. In theory, you can have like the block proposal here to have a timestamp.
00:37:50.350 - 00:37:56.638, Speaker A: Well, but I'm just saying, just in general, it doesn't matter at which you receive.
00:37:56.734 - 00:37:58.294, Speaker B: No, it's a die time. Right.
00:37:58.412 - 00:38:01.190, Speaker A: So they just point at what was the last thing they saw.
00:38:01.260 - 00:38:01.880, Speaker B: Exactly.
00:38:02.810 - 00:38:08.706, Speaker A: But they point at all of the things they saw. Right. How are they determining the referencing?
00:38:08.818 - 00:38:22.158, Speaker B: Well, you have transaction that they refer to previous object versions. We have versions from the object. And obviously you know where to reference. If this has been signed by two f class one, it's fine. I mean, you can reference, you can just reference that.
00:38:22.244 - 00:38:33.150, Speaker A: Okay. And so then within here you have like there's transaction one. It's transaction one here. At some point you build pretty much an ordering right of transactions.
00:38:33.490 - 00:38:38.926, Speaker B: Yes, this is happening. And this is what we're working now in the checkpoint eventually.
00:38:38.958 - 00:38:49.510, Speaker A: Okay, so this is like kind of as this all gets aggregated, then you're like, okay, now we know like we saw to f plus one up to here. So we can run this order. Exactly this.
00:38:49.580 - 00:38:52.546, Speaker B: Exactly. And the checkpoint can also have a timestamp.
00:38:52.658 - 00:38:53.126, Speaker A: Yeah.
00:38:53.228 - 00:39:19.466, Speaker B: And it's up to the application to say, okay, do I trust this time we don't have time, but we can have here, which is more like fine grained, there is sequence of blocks. While here in the dag, it's very difficult to have a good time. Yeah, but yeah, that's the whole idea of the basic protocol. What people can understand on this one is definitely you need one round trip to get a locking on the object, some certificate on the object, and then you get to two routes.
00:39:19.658 - 00:39:23.040, Speaker A: Why do you need to lock the object if you're going to this?
00:39:24.450 - 00:39:32.340, Speaker B: I have a feeling, I'm not 100% sure on this, but I have a feeling because we want to actually have one flow independently on. If you are going here, I see it.
00:39:32.710 - 00:39:33.698, Speaker A: It looks the same.
00:39:33.784 - 00:40:01.600, Speaker B: Yeah, it looks the same. The user, I mean, it's as easy as possible for the user. They don't even need to know where they are sending their transaction. This is happening everything on the background. So that's a general way of how sweet works. Right? And we explain a few examples. There is also move in the game and in move, some of the hint that we gave already is everything is object.
00:40:01.600 - 00:40:28.674, Speaker B: It's strictly typed. There is also some capabilities like the object can have capabilities like drop. This is droppable. It has key, it has store. There is another one as well. But all of the idea is when you define an object you say has dropped, has key has stored whatever you can actually have on this one. And these are used a copy.
00:40:28.674 - 00:40:29.858, Speaker B: I think it's also copy.
00:40:29.954 - 00:40:32.246, Speaker A: So there's a standard runtime level.
00:40:32.348 - 00:40:47.658, Speaker B: Yes, exactly. And if it's a copy, you can copy it. If you are not having Clyde has copy, you cannot even copy it on the code. We will stop you. The same thing is for key. The same thing is for store. What is key and store have to do with.
00:40:47.658 - 00:40:58.170, Speaker B: Is it an NFT, a real NFT, or it's like you have an object that references to another object. It can be a key to another object and drop if it's droppable.
00:40:58.250 - 00:41:01.774, Speaker A: So user is a key object, account is a key object?
00:41:01.812 - 00:41:31.366, Speaker B: It can be, yeah. So that's the idea. We have this. Let's assume abilities, capabilities, traits, right? Yeah, well, it can be traits, but it's also abilities that they have. So some is working on some very interesting, like even extra. Some is our CTO, extra things that we might have here, and Tod Novaki, who's leading the move team. And there is another thing that we have to know about Sui.
00:41:31.366 - 00:41:55.230, Speaker B: So we explained all of this. What we didn't explain is transaction cost, storage and this kind of stuff. Our tokenomics is very interesting. What is usually the cost for a transaction? Why do you pay the validators? Why do you pay gas for two things, execution and storage. You need execution. You have questions?
00:41:55.300 - 00:41:57.002, Speaker A: No, I said yes.
00:41:57.076 - 00:42:45.866, Speaker B: Execution starts, you pay for this. And also this is the cost that the validators pay, right? I mean, a validator has to execute transaction, but at the same time they need hard disks, they need all of this stuff to maintain the network and the state. What we do is we split the gas between these two and we have a storage fund. What is a storage fund? When you pay for the transaction, let's assume that this is TX cost part of this. Well, there are some functions from Alonso, our economist, go to a storage fund. And this storage fund is actually giving the opportunity for the users. If in the future you want to delete this NFT, the storage that takes, you will get some rebuttal.
00:42:45.898 - 00:42:46.606, Speaker A: You get the return?
00:42:46.708 - 00:43:06.710, Speaker B: Yes, you get some return. And it also gives an advantage to the validators. Are we good with the time? Are we good with the time? No, we're good. Okay, cool. And the storage fund is reinvested. Yes. And there is a benefit for this, right? Imagine you're a validator and you come one year later.
00:43:06.780 - 00:43:07.302, Speaker A: Yeah.
00:43:07.436 - 00:43:11.734, Speaker B: You need to maintain state. You didn't get a thing, right? A single cent.
00:43:11.772 - 00:43:13.170, Speaker A: You're not paid for the transactions.
00:43:13.250 - 00:43:13.542, Speaker B: Exactly.
00:43:13.596 - 00:43:14.634, Speaker A: But you need to store all the.
00:43:14.672 - 00:43:44.066, Speaker B: You have to store its fund that we can pay you. Obviously, you are not going to get as a user all of this. I mean, if you delete it, you're not getting everything back. Like, the rebuttal is sorted, but at least you're getting something some people might use it to have. Like I'm storing objects, and then if the market goes up, in practice I can even make money in theory. But let's assume that this is not the reason. The reason is if your business goes, I mean, you dissolve your business, you can get something back.
00:43:44.066 - 00:43:51.574, Speaker B: Right. You don't need the nfts anymore. Why do you need to pay? So that's another difference. I don't know how you're doing it on near. Do you have a different.
00:43:51.692 - 00:43:58.134, Speaker A: Yeah, so we lock near itself, and if you delete the storage, you get back near.
00:43:58.252 - 00:43:58.870, Speaker B: Okay.
00:43:59.020 - 00:44:00.038, Speaker A: And then developers do.
00:44:00.044 - 00:44:01.842, Speaker B: You split it between execution and storage.
00:44:01.906 - 00:44:06.166, Speaker A: So gas is on execution, and then you pay near for storage.
00:44:06.278 - 00:44:07.450, Speaker B: Oh, I see.
00:44:07.600 - 00:44:12.058, Speaker A: So storage is like, it's called storage taking, but it's very similar to this model.
00:44:12.144 - 00:44:15.162, Speaker B: Okay, so there is a different token for the gas.
00:44:15.226 - 00:44:18.442, Speaker A: It's not a different token. It's two parameters.
00:44:18.506 - 00:44:22.062, Speaker B: Pretty much. It's two parameters. Okay, but this has a price as well, or it's near.
00:44:22.116 - 00:44:27.940, Speaker A: Yeah, it has a price that fluctuates with how expensive computation is. And this is fixed price.
00:44:28.630 - 00:44:29.886, Speaker B: Fixed per byte.
00:44:29.998 - 00:44:30.466, Speaker A: Yeah.
00:44:30.568 - 00:44:31.506, Speaker B: I see.
00:44:31.688 - 00:44:34.082, Speaker A: Because storage doesn't change. Right?
00:44:34.216 - 00:44:34.900, Speaker B: Yeah.
00:44:35.530 - 00:44:37.000, Speaker A: More people want to use.
00:44:38.250 - 00:44:46.182, Speaker B: So that's another thing that we're doing. There is another part of suite on the storage fund.
00:44:46.316 - 00:44:49.750, Speaker A: So this is actually reinvested or how is that managed?
00:44:50.330 - 00:44:57.302, Speaker B: So there is some function on how we define all of these parameters in this fund. What do you mean by reinvested?
00:44:57.366 - 00:45:00.794, Speaker A: Well, it's like it's just a bunch of sui sitting in.
00:45:00.832 - 00:45:05.466, Speaker B: Some just sits there. And there are some functions giving money to the validators and to the users for rebuttals.
00:45:05.498 - 00:45:06.222, Speaker A: I see.
00:45:06.356 - 00:45:26.686, Speaker B: Because then we might not be solvent. We didn't. Right. You can invest it in theory, you can do a lot of things, but this is something that will be defined in the smart contract level, not outside the smart contract. Right. I mean, everything will be transparent if something happens to this one. But in practice, you need to have all of the money to return back to the users if they delete.
00:45:26.718 - 00:45:27.494, Speaker A: If they want to free everything.
00:45:27.532 - 00:46:04.334, Speaker B: Yes, if they want to free anything. So that's one part, the other thing that is interesting with us is crypto agility. I'm going into my territory now. So what we have, right, we do have API internally from the STD API on Grove 16. Like, we have zero knowledge proofs. Yeah, I mean, some, the smart contracts can literally execute zero knowledge proofs by just calling the verify only verification unit on the blockchain. We made some improvements on arcworks.
00:46:04.334 - 00:46:43.370, Speaker B: I don't know if you write rust, you know that there is arcworks rs and this one is okay. All of the structure of arcworks is great, but we made some additions by adding a BLST, which is a BLS library for faster operations on the BLS care. And now we are like two times more faster than the original AK works. So we have very, very fast verifiers on group 16. We also have, obviously we have the BLS verification even internally to the contracts. We do have the regular ECDSA.
00:46:44.130 - 00:46:45.866, Speaker A: Did you speed up BLS?
00:46:46.058 - 00:47:30.114, Speaker B: We're using the BLST, but we're working, you will see in a couple of weeks, another optimization of the aggregation. On top of the Dan Bonet paper. We managed to make a way where, because it's validator's keys, if you're using BLS, mostly you need it for validator signatures. What you can do is you can have different ways of aggregating by even avoiding proof of possession of the keys. You might not need proof of possession anymore. Usually you need to prove, because you're doing aggregation, that a, it's my key to avoid the kind of attack called the wrong key attack, because you're aggregating somehow. I know some other validators keys, and I create my key in a way that I take advantage of your keys and then I can omit your signature.
00:47:30.114 - 00:48:06.594, Speaker B: And somehow the people who believe you signed, we found some ways to make it a bit faster. So we call it MSKR, it's multi signature key randomization. So there is a version of BLS. Let's see if we're going to have it already, because the BLSt implementation and the aggregation is really fast now. I think we're the first company that we have a library called fast crypto. So this is popular enough now. I mean, even funks are using it that have the fastest implementation we find in rust.
00:48:06.594 - 00:48:32.506, Speaker B: We make all of the adjustments. Obviously we use them on SUI, but this one is like published independently and everyone can use it. We have grove 16 there. We have BLS, we have VCDSA, we have EDDSA with some improvements ed to 519. I personally found many attacks on all of the implementations like great. Yeah, two months ago. No, it was July where I think all of the implementations were broken.
00:48:32.506 - 00:48:55.382, Speaker B: Could be broken. Okay, could be broken. And there was even treasure and some other wallets that they had an exposed API where someone, if they were not careful, they could expose a private key. Treasure was lucky and it didn't have this vulnerability being exploited, but someone could do it accidentally. Now they fixed it. I mean, they were super fast to fix these things.
00:48:55.436 - 00:48:57.094, Speaker A: And in fast crypto you have all.
00:48:57.132 - 00:49:24.542, Speaker B: Yes, we have already fast crypto and what we do in move. So we have move to provide all that as API. And in move you can have rust, I mean libraries. Libraries, and then obviously you can have binaries. And we execute this as native function move now. So we actually implement the algorithms in rust and then move has some precompilation and exposes the API. It's all of this.
00:49:24.542 - 00:50:02.218, Speaker B: And there is also another about Pedroson commitments. This is for confidential transactions and other things that you can do. Generally you will see a very rich API on cryptography. We even have Durant support, native Durant support. So literally you can use their Durant committee internally to show you today. We also have some other protocols that we implemented, like some optimistic satoshi dice for lotteries, even multiparty, so you can even avoid vrfs. We're working on our own examples right on top.
00:50:02.218 - 00:50:29.302, Speaker B: We do have examples. Obviously we're not providing confidential, like payment now, but the functionality is there that if someone has the license to do it, they can do it. So these are like parts of the signatures and like all of the fast crypto part. But we have another thing as well. It's what the user can use to sign. I don't remember if near. Are you crypto agile on what types of signatures people can use?
00:50:29.356 - 00:50:31.602, Speaker A: We have ECDSA and Andertzen curve.
00:50:31.666 - 00:50:32.726, Speaker B: ECDSA, yeah.
00:50:32.748 - 00:50:33.880, Speaker A: We can add more.
00:50:37.370 - 00:50:38.994, Speaker B: Okay, so you have this QR.
00:50:39.042 - 00:50:41.962, Speaker A: Yeah. Okay, you can add more like.
00:50:42.096 - 00:50:45.462, Speaker B: Exactly. And I guess you have k one, right, the ethereum curve.
00:50:45.526 - 00:50:46.140, Speaker A: Yeah.
00:50:48.990 - 00:50:52.086, Speaker B: We now work on the r one as well. There is a benefit.
00:50:52.198 - 00:50:53.486, Speaker A: There is benefit, yes.
00:50:53.588 - 00:51:08.142, Speaker B: What is the main benefit? In the mobile enclaves? Yes, mobile enclaves. So we're having this and obviously we're making, because they're not good implementation of r one. Unfortunately, you will realize it as well. This is faster. This is faster because the bitcoin world actually made it faster.
00:51:08.206 - 00:51:08.866, Speaker A: Yeah.
00:51:09.048 - 00:51:11.986, Speaker B: And this one is faster because we also contributed on this.
00:51:12.088 - 00:51:14.114, Speaker A: Well, now generally this one is way.
00:51:14.152 - 00:51:37.242, Speaker B: Faster than it is. But even our team actually contributed a lot on making this a lot faster. Even on batch verification. If you go, we even have half aggregation here. You can literally aggregate without any interaction in the DSA signatures to half of the size. We published this on RSA conference like two years ago while at Facebook. But yes, r one.
00:51:37.242 - 00:51:45.210, Speaker B: And we're going to even have bls on the user side because in BLS you can have very efficient threshold schemes.
00:51:45.370 - 00:51:51.406, Speaker A: Without going into this. Well, we have a multi sig implementation for this. But.
00:51:51.428 - 00:51:54.494, Speaker B: Yeah, is it is.
00:51:54.532 - 00:51:55.902, Speaker A: Yeah, but it's a painful as.
00:51:55.956 - 00:52:05.986, Speaker B: Yeah, it's painful. Exactly. And then we said, okay, yeah, BLS. Just let's use BLS. It's a bit more expensive, by the way. You can see all of the benchmarks in the fast crypto library. We even have diagrams.
00:52:05.986 - 00:52:10.680, Speaker B: You can see like, how they perform. Sweet point. About 42.
00:52:12.170 - 00:52:13.062, Speaker A: The answer?
00:52:13.196 - 00:52:15.430, Speaker B: Yeah, it's 40 times more expensive.
00:52:18.730 - 00:52:20.354, Speaker A: We were actually planning to use BLS.
00:52:20.402 - 00:52:23.242, Speaker B: For our validator, but you have to. For validators? Yes.
00:52:23.296 - 00:52:24.810, Speaker A: Well, we end up doing this because.
00:52:24.880 - 00:52:27.226, Speaker B: At that point, for validators, you're using.
00:52:27.408 - 00:52:28.518, Speaker A: It was too expensive.
00:52:28.614 - 00:52:30.234, Speaker B: How many validators do you have?
00:52:30.352 - 00:52:32.460, Speaker A: Like 100 plus 200.
00:52:32.850 - 00:53:03.890, Speaker B: Then BLS will perform better. Download fast crypto and you can use it literally. I mean, we did a lot of good work there to make this as fast as possible to be comparable, but obviously we have less. Then there is a point to compare between the size of the signature, because the size also plays a role and the execution cost. And you can do some other batching and parallelization. We also did some parallelization here. So this is the other part on cryptography.
00:53:03.890 - 00:53:32.720, Speaker B: And a very interesting signature scheme is coming. I cannot, unfortunately, cannot reveal it because we don't have yet the security proof, but this one will be, I think, one of the best ideas in the space on how you can authorize users without smart contracts. So that's the main idea behind SRi. I don't know if you want to ask any other deeper question.
00:53:33.170 - 00:53:34.946, Speaker A: I mean, can you even go to.
00:53:34.968 - 00:53:36.660, Speaker B: Transparency and other things?
00:53:38.070 - 00:53:40.050, Speaker A: Yeah, we can discuss transparency.
00:53:40.470 - 00:53:47.410, Speaker B: So today is the day that I published something. It's very interesting, right?
00:53:47.560 - 00:53:49.602, Speaker A: It's going to be published a bit later, right?
00:53:49.736 - 00:54:24.622, Speaker B: Yeah, we will publish it later. But the idea is I played a big role in the past, personally, as my personal goal. While working at Libra, we had to work with regulators. So I was involved in this meeting sometimes, and I had all of the input from auditors, regulators like regular auditors, not only governmental auditors, and Libra literally it wasn't technical. The issue that didn't work right. It was other things outside our territory that didn't allow it to be able to be a product. However, we did a lot of work on solvency.
00:54:24.622 - 00:55:20.430, Speaker B: We had very good economists, even Dahlia from Chainlink now and Christian Catalini, like the economists that we have now in Sui, Alonso de Cortari, myself as a cryptographer, Lera, who is Lera Nicolenko, who is now an a 16 z, and some other cryptographers, like around the world, in visa research in Cornell University, Panos and Yan. We worked a lot on finding, okay, even if we want to have solvency, it's not easy. It's very, very difficult. How you have a centralized exchange, or even a decentralized exchange, if it uses some of the assets outside the blockchain, how do you even verify that what they are liable for, they have the exact same assets, or even more. And then some companies after FTX started to offer proof of reserves and proof of liabilities and proof of solvency. So the most common thing is you are putting four liabilities. You are putting all of the user balances as leaves.
00:55:20.590 - 00:55:21.954, Speaker A: Yeah. And then you mercurialize it.
00:55:21.992 - 00:55:24.770, Speaker B: And you mercurialize it. Exactly. You are going into.
00:55:24.840 - 00:55:27.278, Speaker A: And then you let users go and check that their balance.
00:55:27.294 - 00:55:38.914, Speaker B: Exactly. What's this? What's the proofs of liabilities? This is a decentralized probabilistic random sampling. Yeah, that's what it is. We call it proofs of liabilities.
00:55:38.962 - 00:55:43.034, Speaker A: But this is exactly like you need to rely on users to actually go check, which.
00:55:43.152 - 00:56:08.450, Speaker B: Yes, but even in the regular, there is no other solution. And I can explain to you why there is no other solution. This is for sex, right? Sex of the centralized exchange, not the other sex. No. You remember Vitalik's recent post, how to have a safe sex? This was the title, literally. But obviously, we mean about centralized exchanges. The problem is, first they have issues with privacy.
00:56:08.450 - 00:56:53.754, Speaker B: And the other thing, if you have, like the values here, 510 twelve. I mean, people who do inclusion proofs, they can see the neighbors. If you hide them, you need an auditor, and the auditor can obviously see them, but the users can only check inclusion, and they have to blindly trust the auditor. This is one of the things that we mentioned in binance now, but some other exchanges that they're also using the same algorithm, like Kraken and others, and something that they always do, I don't know why people are doing it, is they truncate hashis. So instead of using 32 bytes they're only using, for example, eight bytes for leaves. And this is very dangerous. Why? It's dangerous because someone can now find collisions off chain.
00:56:53.754 - 00:57:20.038, Speaker B: Here you're using also some salt per user. You can just play with the salt until you find two balances. You report the lower balance to the auditor, you report the real balance to the user, and the auditor will do the sum and will see some very small value, even zero, in theory, and the user will say, no, my balance was there. But this is completely wrong. And this is. I don't know. I feel the mistake is based on the fact that traditional auditors have implemented the original Maxwell approach.
00:57:20.038 - 00:57:44.942, Speaker B: It was Greg Maxwell from the bitcoin space. Like a great scientist, he didn't propose this, but the first auditor actually did it for ux reasons. They didn't want the people to see, like, imagine you usually present this as a hex, right? And then you see some numbers here, and they say, okay, let's truncate it. But this truncation is actually vulnerable, because.
00:57:44.996 - 00:57:46.402, Speaker A: Now eight bytes is too easy.
00:57:46.456 - 00:58:11.580, Speaker B: Eight bytes. And if you go to four bytes for a collision attack, this is two in the power of 32. I can do it in seconds. And we identified this issue. We identified other issues regarding the summation. Vitalik takes now a leading role on trying to propose even a standard. And there is the communities at k proof and many cryptographers that we literally want all of this.
00:58:11.580 - 00:58:14.422, Speaker B: Yes. To be zero knowledge proof.
00:58:14.486 - 00:58:16.742, Speaker A: So you don't need compatible provides the pairs.
00:58:16.806 - 00:58:55.362, Speaker B: Yes, we do have a paper, it's called daple plus. And actually this year was in the top ten innovations of 2021, in one of the biggest, I think, innovation contests in the world, CISO. And this one works really well. We've proven security in all of this. Vitalik now is proposing another scheme where instead of using this, let's snark everything. And by snarking everything, probably we can have faster verification proofs and other things. However this works, in my opinion, we should start with this, at least to ensure that it's better than the current Merkel tree approaches.
00:58:55.362 - 00:59:21.454, Speaker B: And I'm like all ears to see Vitalik coming with the real. Which snark to use. Do we need a trusted setup? Go to the regulators and convince them that we need a trusted setup. There are all of these things that while this one is using bulletproofs, it doesn't require a trusted setup. So we say, let's start with this thing. We have proof of liabilities. How do you solve proof of assets there? It's difficult right.
00:59:21.454 - 00:59:30.546, Speaker B: With centralized exchanges that might have liquid, semi liquid liquid assets, what do you do? You need both auditors and oracles, but.
00:59:30.568 - 00:59:33.858, Speaker A: Also they can be like investing. And that's part of the.
00:59:33.944 - 00:59:34.642, Speaker B: Right, exactly.
00:59:34.696 - 00:59:35.362, Speaker A: That's the whole point.
00:59:35.416 - 00:59:56.598, Speaker B: Investing on chain is probably traceable, but investing off chain, most of it is off chain. Right? Yes. And this is where the problem starts sometimes. I don't know about the FTX situation. Right. I mean, nobody knows the correct number. But the idea is, even if they were and something was illiquid in practice, you're not solvent.
00:59:56.598 - 01:00:02.546, Speaker B: I mean, if someone tries to withdraw the money, you're not solvent. And it's very tricky how to define solvent.
01:00:02.678 - 01:00:07.150, Speaker A: Well, this is where it is a question of defining some limits.
01:00:07.490 - 01:00:08.046, Speaker B: Exactly.
01:00:08.148 - 01:00:09.834, Speaker A: And lenders resort.
01:00:09.962 - 01:00:37.462, Speaker B: Something that I realized in the past, this was Deloitte. In this particular case, we found attacks on Deloitte as well two years ago. Very similar attacks that we found now on binance. Binance, by the way, is super transparent, at least on me. And they told me that they will check everything they're open, and I give it to them. They just didn't know it's the auditor offering something. And if you don't have, I don't know, crazy cryptographers in your team, you just accept what the auditor is giving you.
01:00:37.462 - 01:01:03.280, Speaker B: And they said they will fix it. So I feel confident they will do it. But even back then, one of the issues that we have is sometimes synchronicity. How do you synchronize the input you get from the proof of assets with the proof of solvency in the millisecond level? Because you know what can happen. You know there is an audit, like a moment ago, you move the assets here and then you are removing them back again. Or there are in flight transactions of the user. Right.
01:01:04.050 - 01:01:05.714, Speaker A: We need to snapshot at a point.
01:01:05.752 - 01:01:23.014, Speaker B: Yes. But let's assume at the time, like one millisecond before the deadline, I'm sending money. But you will see the transaction on your report whenever the sex decides. And there is a thing. Right. They can play in these late moment transactions. They can play.
01:01:23.014 - 01:01:59.490, Speaker B: And Deloitte told me that we give a 5% usually threshold. Yeah, because of all of these things that can happen. But we realized that most of them had one to 3% surplus if they were secure. So all of this is happening now. We are trying to even as misten and I guess all of the other companies will help with their cryptographers. We need a standard because something that can happen is bitmex. If I remember correctly, published something literally today, just hours before my announcement on the binance vulnerabilities with a different scheme.
01:01:59.490 - 01:02:23.334, Speaker B: And then binance is going to propose a different scheme, and then Vitalik is proposing another one. I say let's start with this, and we can go to Vitalik. We cannot have ten solutions. Right. It's very important to go with cryptographers, with auditors sitting on the same table, with exchanges, with l ones, and people who want to help. It's also proof of assets, as we said, sit together and have a standard.
01:02:23.532 - 01:02:27.000, Speaker A: Okay. Yeah, sounds good. Well, thank you.
01:02:27.370 - 01:02:28.198, Speaker B: Thanks so much.
01:02:28.284 - 01:02:37.680, Speaker A: Yeah. For deep dive into Suey. And, yeah. Subscribe, comment, check out the papers and reports, and we'll see you next time.
01:02:38.050 - 01:02:43.580, Speaker B: Thanks again. Close.
