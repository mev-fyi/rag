00:00:00.650 - 00:00:30.706, Speaker A: You know, I'm, I actually should have introduced myself. I'm actually senior legal counsel at the near foundation. Every time I hear regulation, I kind of wince a little. So full disclaimer, the NCon token is not a security. So I don't think there's, there's anything to fear there. We've got our next session coming up. Social Lego blocks what boss offers to web three builders very excited to welcome Eugene from proximity Labs up to the stage to give a presentation.
00:00:30.706 - 00:00:32.920, Speaker A: Please welcome Eugene to the stage, everybody.
00:00:41.470 - 00:01:26.390, Speaker B: Hey everyone, my name is Eugene. I'm a founder of near social and that's how all the boss started. And today I'm going to talk more about what you can do on the social side of this instead of just building apps for entire web. So before we begin, so that talk going to be mostly technical with a lot of visuals, but hopefully you're all going to enjoy it. So another disclaimer, you probably want to know some basics about how it all works, otherwise you'll be confused. But there's going to be a link at the end that you can use to get all the slides. So let's get started.
00:01:26.390 - 00:02:06.726, Speaker B: So first we're going to talk about social components. So what are actual building blocks of a social applications and how they actually stored in the decentralized social platform. So first is a profile. It's fairly simple, it's probably the simplest thing you can do. And behind it we have a decentralized database that is unique and accessible by every single user. So users can only store data under their own accounts. And I'll show how it works.
00:02:06.726 - 00:02:40.714, Speaker B: So there's a simple boss VM command that you can do to get the profile data. So in this case you have first request a command called Social get. It takes the account id. Then we say what you want to retrieve, for example profile. And then you get a double asterisk to retrieve all the data under profile. So expand the object you pass final to indicate the finality of this data. And final just going to retrieve it from the server.
00:02:40.714 - 00:03:10.838, Speaker B: So it can do very large amount of data. And the data you get in the following format. It's basically a JSON starting from the root where the first key is the account, and then you get subpass data. So in this case profile and all the information that we store for a profile. So that's why it's very simple. It's just data that we store for a user for a given profile. So there's like image and it's stored as NFT.
00:03:10.838 - 00:04:14.014, Speaker B: There's a description that user posted about their profile and name, and maybe a background image that is a hash on ipfs. So the next thing is a graph. So that's how you keep connections in a social data. So in any network you have people you follow or like being friends with or you like, and then people who follow you back. So in order to get this data, you need two things, right? We get data from graph under a key follow for me, and that way we can get who I follow. And if you want to get the data that who follows me, because they cannot write under my profile, I have to retrieve it in inverse, I'm saying who are all the accounts that have a key under graph who follow my account? If we execute it, we get the following. So on the left you get pretty standard, you get list of people who follow you.
00:04:14.014 - 00:05:06.218, Speaker B: And on the right you get the kind of inverse object. It starts with an account and then it has a bunch of keys indicating, all right, they follow me and so on. So that's how you can do kind of inverse edges in a graph. Now the next piece is a post. So how people actually write anything on a social network, they create text that getting stored on a chain. To get the post, you go to a specific key called post main, and you get the information and it's stored slightly different. Instead of being an object which contains text type and stuff like this, it's stored as a string, but not a simple string, but JSOn serialized string.
00:05:06.218 - 00:05:57.920, Speaker B: We do this because we don't want to store this data forever and to decrease storage, we want to override this data because on near protocol you're only paying for the data that is stored in a state. So you don't pay for the data that was previously written and later deleted. So in this case, that message is effectively a single string that can be overwritten. But how you get data from the past, right, the post that was before this. So for this we have to go back and we use indices. So what is an index? Index is a specific key in the database that is getting parsed by the server. So here's an example.
00:05:57.920 - 00:06:32.506, Speaker B: When you post a new message, you also write a specific key under a namespace index. And that key is in this case, post. So this post is an action, and it should be again like serialized JSOn string that contains two attributes, key and value. Key is what a unique key that you would aggregate data on. So in this case we say just a main feed and a value. It can be any data that you want to store. In addition to this.
00:06:32.506 - 00:07:53.810, Speaker B: So every time you write into the index, a server indexes this data and it will serve you using the custom API called social index. So for example, we say, hey, give me an action post where the key is main and we also filter by account id. And if you do this well, you get all the posted account ever written and the way you get it is account id, a block height when it was created and then a value that was specified. So using this information you can reconstruct the feed. Basically now we can say all right, who was all the people that posted into this index called main and we can request it using command social index. How we do this? Well, we say all right, now do not filter by the account id and just give me everyone who ever posted anything but make an order descending and give me a limit at most ten posts. And here you are, you get the index of everyone who ever posted under their account namespace and the values.
00:07:53.810 - 00:08:48.610, Speaker B: So that allows us to actually create a feed of posts on a main page. Still no custom logic on a server except for this magic indexing, but makes it very powerful. Now how we do likes. So if you familiar with lens, they actually don't store likes on a blockchain, so instead they like all right, here's our server, let's keep likes there. We instead decided to store likes and without inventing anything custom. For this we just reused the previous stuff like storing data either under your account or into an index. So how we get the certain likes for this we need to know what item was liked.
00:08:48.610 - 00:09:30.306, Speaker B: So we need to introduce items. So what is the item? So in social, an item is effectively this structure. So it has a type. So for example, if it's social it means it's stored in the database social db. Then it has a pass which indicates where the data is written in the absolute pass. So in this case, root near is account id, post main is the past and then a block height and a block height is when this data was created. So this uniquely identifies a post and that's kind of a unique link that we'll use for all the information.
00:09:30.306 - 00:10:15.460, Speaker B: So if you want to talk about the post, you would use something like this. So now how we store the like, we do the following. We basically say let's write a new index under action like and the key going to be the item that you're liking. So in this case, this item is a unique identifier. On a post we say all right, and the value going to be like and to retrieve it we use social index. We say all right, let's give all the likes on a particular key, and the key is this object. So if you execute it, you get all the likes and when it happened and for every item you have like.
00:10:15.460 - 00:10:49.340, Speaker B: So what happens if you don't like the post familiar anymore? Well, it's on a blockchain, so it's done and cannot be done. That's kind of a problem, but you can fix it. For this, let's just basically send the same index and say I unlike it. So that will remove the like. But then let's say I liked it again. So I added the like. Now instead of 13 items in previously I have 15.
00:10:49.340 - 00:11:30.922, Speaker B: Even so, it means the same thing. So to solve that for likes, I introduced an experimental API. So given an item it will retrieve you the list of likes. So it's not available in a vm. Instead we just fetch it directly from the server and you pass the data where the body consists of just a single item and it will retrieve you a list of likes. So they're basically just a list of accounts who like the post. So that's very useful because now considering the feed consists of ton of posts, you don't really need to fetch an index for every post.
00:11:30.922 - 00:12:05.362, Speaker B: You can just fetch likes in aggregate. Finally, the simple stuff is comments. And comments are like likes, but they are really posts on a given item. So let's see how it actually implemented. So when you comment something, you have the following in your data that you overwrite. Every time you comment, you have an item indicating on what you're commenting in. And in this case it's a post.
00:12:05.362 - 00:12:49.650, Speaker B: So if you comment in on a post, you just indicate all right, that's an item. And then in the index for this item you also indicated that you just commented. So now if you want to retrieve all the comments on a given post, you query an index. If you want to retrieve what was the post for which you created this comment, you will read the comment by the item and then you can retrieve the parent. And finally, here's an example of the index. For a given post, you request it and you get the following. So you get all the comments.
00:12:49.650 - 00:13:37.570, Speaker B: A final component that is useful are notifications. And if you remember, in a social db you cannot really notify someone directly because you cannot write under their data. So instead you have to write it under your account and they somehow need to figure out that you made this notification related to them. To solve this, we will create a new index where the key is the account id and we say notify. So we're basically notifying someone about an action that I just did. And you can read notifications from anyone. So in this case, for example, you can read that I commented on your post and then three other people liked.
00:13:37.570 - 00:14:28.850, Speaker B: So that's pretty much it from the Lego blocks. And to get used of them, you can use component that I started working on, which consists of all the different social components that I used for the main feed. And if you go to this link, it will land on a Component. And whenever you're building something in social, you can use this to figure out what is the component, how to use it, its properties and stuff like this. I'll try keep it updated over time, but it's not right now. Now a second part of this is actually how we build some new applications. So we have a feed which looks like a Twitter feed which has the following properties.
00:14:28.850 - 00:15:23.230, Speaker B: It takes your graph, people you follow, then it requests an index of posts from these people and we just display them in reverse chronological order. And then for every post we can get the likes amount and we can also get the list of comments and notification works. So instead we're going to build an edit. It's like a Reddit forum, but it has a few differences from the main feed. So it has to be community specific. So it's not only like one single big feed, but instead kind of have communities in which people also talk about specific topics. Usually it's sorted by likes.
00:15:23.230 - 00:16:13.282, Speaker B: So when you go to the main page, you see top popular post from the last day, for example. And to get it a time specific bound, you want to decay it by age. So if the post was like two days ago, but received like enormous amount of likes, it still can be in the top. So we need to use the previous Lego blocks in order to build something like this. So let's start with a feed. So we'll call it n all. And it consists of the post ordered by likes coming from different subnets and also based on their age, they going down in popularity, how we can implement it.
00:16:13.282 - 00:16:37.530, Speaker B: So we'll use stuff that I just talked. First we start with the index. And instead of fetching just ten posts, we will fetch like large amount of posts. And because it's an index, we don't fetch every independent data. So the data is fairly small. We're just fetching when they were posted and who posted them. So we can construct items.
00:16:37.530 - 00:17:15.494, Speaker B: And the key is a subnet. So for mainfeed we will use all. And for something else we use, let's say Nearcon. Next we're going to do some javascript to convert this data into the items. And the reason why it's a bit more complicated because maybe you want to repost it from one community to another community, which is not implemented on UI, but the logic is implemented for this. The third thing you want to do is fetch likes. That's where the experimental API coming into play.
00:17:15.494 - 00:17:54.018, Speaker B: And instead of fetching just likes for one item, we will fetch likes for multiple items at once. So for all posts that we fetched in the first batch, we will now fetch the number of likes and who likes them, but we only care about the numbers. And finally, we want to sort your feed in order to display it. So how we do this? Well, we use the following. We say okay, how old is the post? That's your age of the post and how many likes it got. That's your score. So we divide the score by exponentially decaying age.
00:17:54.018 - 00:18:44.306, Speaker B: So the older the post, the less score it gets. The more likes it has, the more higher the score is. Then we just sort all the items that we get and we can display them. And that's how the feed works. Now, another difference from traditional Twitter feed are multi level comments and what is actually a multi level comment. It's something like a comment on top of comment, and for every comment on top of comment, you can also apply the same algorithm we did for the sorting of the post. So we get all the comments, we sort them by like decay them by time and render them in sorted order.
00:18:44.306 - 00:19:28.260, Speaker B: And now for every comment we just need to display a feed of comments under this comment. So a comment is an item, so let's just use it. And here's just how the data would look slightly modified from before. So for every post we added a subnetted item which indicates under which feed it was posted. So that's very useful for displaying the post when you get notification for it. For every comment we also add a root item which indicates what was the post on which it was posted. So you can display a whole tree instead of just a parent, or like having to recursively find a parent.
00:19:28.260 - 00:19:58.860, Speaker B: And finally, here's when you make an index, you write it into two indices instead. You write it under the subnetit index and also all so that way you can get an aggregated overall fit. And that's pretty much it. Thank you. If you have questions, maybe I have time.
00:20:08.550 - 00:20:11.220, Speaker C: Because maybe the original post was not.
00:20:13.830 - 00:20:37.130, Speaker B: All right, so the question is why comments are not included in the score of post. So that's actually valid. But for this you basically just need to kind of have a big aggregation of number of likes total or something like this or like frequency how they were posted. So that might need a bit more data on sorting this but probably possible to implement.
00:20:41.550 - 00:20:43.930, Speaker C: Or do you also want to build groups?
00:20:44.350 - 00:20:45.386, Speaker A: Would you mind asking a question?
00:20:45.408 - 00:20:53.230, Speaker C: Yeah, I can ask it again. So is this nevid idea going to replace the concept of groups or are you still planning to build on groups?
00:20:55.830 - 00:21:50.770, Speaker B: Well the social itself is kind of like a super app of different social applications. So that's why potentially what you want is probably replace the main feed. The groups are interesting concept as well, but groups also make sense if you can restrict people who can control them. So in this case, current group implementation, at least the hacking version was based on NFT membership. So if you own an NFT then we filter on the front end all the content only to the current members. If you don't own the NFT then you can still write your data into socialdb because no one protects from that. But it's not going to be displayed on a feed because whoever visits the official endpoint or like official app will have a filtering based on the membership.
00:21:50.770 - 00:22:05.400, Speaker B: So with Reddit it also in theory can be controlled to private, but that's a different topic that require azure encryption or some kind of another access control.
00:22:10.330 - 00:22:24.960, Speaker C: Yeah. So based on your answer, so do you see near social as becoming a social network or more becoming some place where people can go and actually find the components to create their own social network? What do you envision for the future?
00:22:25.410 - 00:23:35.140, Speaker B: Yeah, so a few features that differentiate neurosocial from traditional networks. Ability to embed applications directly into the feeds and posts. So currently they're under strict whitelist and you can only repost another post. But you can imagine you can create applications that can be embedded in the main feed and that may be a mechanism to distribute the data. Probably there are going to be some kind of main version of the near social which have more polished feed, but you would also be able to use different applications. So once some kind of technical details are figured out around how to make custom notifications so they are not easily attack, cannot be used for phishing, then it's very easy to create new custom uis and new custom applications. So if someone want to make a new app that's just image focusing social network where the image is on top of the post instead of on the bottom, well maybe they will call it Instagram and build it on social as well.
00:23:35.140 - 00:24:37.750, Speaker B: Do you have any components that are related to safety or moderation yeah, so currently it's done on a user basis or a post basis. So when you render an index you can filter it by the people you hidden. So if it's not like Reddit specific where everything is displayed. So for everything specific you can also flag any given post for moderation which goes to a custom feed that you can later kind of query. When it comes to DMCA takedowns and some illegal stuff, it's probably going to be deleted or blacklisted on the server and you will not be able to request it. When it comes to building a custom UI to get it, you will probably still get it. Maybe not from an official RPC server, but you can get it from a blockchain if you run your own node.
00:24:40.450 - 00:24:41.680, Speaker A: Any other questions?
00:24:49.620 - 00:25:38.860, Speaker B: Are you planning on introducing any paid content, private pay content for subscribers? Yeah, that's currently in the works, but it's not going to be part of the main experience that can be fully decentralized because private content requires encryption. So you can probably build easily built like peer to peer data that has been encrypted. And Calimera is a good example of this. They built a private chat, but for mass adaption data you might need a separate server that will keep data encrypted and only give it for the parties that need it. Otherwise you run into a problem where you need to do key exchanges or not store data on the chain.
00:25:43.940 - 00:25:54.810, Speaker A: All right, last opportunity for questions here. All right, I think that's it for Eugene. Everyone give it up for Eugene. The dream.
