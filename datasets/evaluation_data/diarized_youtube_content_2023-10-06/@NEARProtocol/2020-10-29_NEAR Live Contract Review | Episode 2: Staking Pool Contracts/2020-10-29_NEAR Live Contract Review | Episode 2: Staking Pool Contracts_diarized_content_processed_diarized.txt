00:00:04.330 - 00:00:59.950, Speaker A: Hey, I'm Eugene and I'm here with Mike, sheriff, Chad and Josh. And this is the second episode of live contract reviews. And today we're going to review staking pool contract, which is used right now to secure near protocol proof of stake system. Basically all validators that currently are running on near protocol are running on behalf of the contract. So they don't control the account themselves. That stakes the amount for proof of stake, but instead the contract stakes this amount and they just provide a staking pool and they run their nodes. And today we're going to dig into this contract and let me present my window.
00:00:59.950 - 00:01:58.624, Speaker A: All right, so I hope you can see it. So in the core contracts we have a staking pool account or staking pool contract. And it's a little more complicated than the previous contract that we reviewed, the voting contract. So today we're going to focus more on the logic and less on the near bunch and rasp specific stuff. But it will probably involve a little more of near protocol knowledge. So as before, the contract starts from the main structure. In this case, it's a staking contract structure.
00:01:58.624 - 00:02:51.860, Speaker A: As you can see, there's a nearby gen and Borsch serialized, deserialized. And the structure now has way more field than in past. And there are some comments on them. Probably most of them are up to date. The logic of the staking pool contract allows to do the following. Basically anyone can deposit some amount of near tokens to the staking pool and delegate them to the staking pool by staking on the pool. That allows to bundle together balances from multiple people, we call them accounts here into one large stake.
00:02:51.860 - 00:04:04.904, Speaker A: And this way this large stake may actually qualify for validator seats. So near protocol has a limited amount of seats right now for a single shard, there's at most hundred validator seats. You can think about a seat as if you take the total amount of tokens staked and divide it by 100. So this number will be a minimum amount required for a single seat. Something like this, except it's a little bit more complicated to involve removing the stakes that are not qualifying to do this minimum amount and stuff like this. But this contract basically is a contract, standalone contract without any access key on it that is controlled by the owner. In this case, owner is provided as intelligent.
00:04:04.904 - 00:05:24.100, Speaker A: So let's go to intellisation method similar as before. It has three arguments. And first is owner id. Owner id is the account id of the owner account and owner has a bunch of permissions on this contract that allowed the contract to perform actions that are not available for the rest of the accounts. So if the account and one of these methods was to vote, vote on behalf of the staking pool to the voting contract that we discussed last time. So the owner can call vote, um, vote method, we verify that the predecessor equals to the owner. So this method can only be called by the owner.
00:05:24.100 - 00:06:22.948, Speaker A: So welcome bone to join in our meeting. So at this meeting, we basically go through a contract and we record it, and later we publish it. So the community can see the logic and understand how the contracts are implemented on near specifically rust contracts. So the vote method is first thing it does, it verifies that the method was only called by the owner, and then it verifies some logic, but that's not important right now. So the contract has the owner, and this owner can do certain things, so it has the extra permissions. Then it takes a few more fields. Stake public keys.
00:06:22.948 - 00:07:36.720, Speaker A: So when you stake on your protocol, you need to provide a public key that will be used by your validator node to sign messages on behalf of the validator node. And this public key can be different from any access key. And ideally it should be different from any access key, because your node may be running a data center that can be vulnerable to some attacks. And in this case, the most they can do is actually do something bad to the network, but not to your account, and they cannot steal your funds. And you can replace this key easily comparing to you need to replace the bad access key. And finally, the third argument that the contract takes is initial reward fee fraction. So this is the commission that the owner of the staking pool takes for running the validator node.
00:07:36.720 - 00:08:13.790, Speaker A: And this is a fraction that has numerator and denominator. And it allows you to basically say, for example, I take 1% of the rewards for running this particular pool. And if, let's say you have a million tokens, they acquired some reward, let's say 10,000 tokens in reward. Then the owner will take 1% out of this, which is 100 tokens. Can I ask a quick question? Yes.
00:08:14.400 - 00:08:16.590, Speaker B: So I've heard this in discord before.
00:08:17.120 - 00:08:20.360, Speaker A: People wondering about using floats.
00:08:20.520 - 00:08:24.204, Speaker B: And maybe can we talk a little bit about why we have a numerator.
00:08:24.252 - 00:09:36.150, Speaker A: And denominator for this kind of percentage stuff, right? So floats has an unpredictable behavior when you multiply them and you acting on the floats. While this piece can be for fractions, for example, you can use a math with larger number of bits. So the way you, for example, do division is you first multiply the amount which is U 128 by this numerator. And this already can overflow U 128. But that's why we do this in U 256. And then you divide it by the denominator, which should bring it below U 128 again, which gives you higher precision than for example, flood 64 that cannot operate with U 128 bits precision. So it will have some rounding errors or like precision errors when you do the mass.
00:09:36.150 - 00:09:49.672, Speaker A: So you either need like higher precision floats which are not really different from the mass we simulate with U 256. Does this make sense? Cool.
00:09:49.726 - 00:09:50.730, Speaker B: Yeah, thank you.
00:09:52.000 - 00:11:03.440, Speaker A: Also, I think solidity originally doesn't support floats, and we originally also did not support floats, but that caused some issues around string formatting and rust for debugging. So we decided that there is no harm in supporting floats, especially as we standardized this on the VM side. So, biggest issue with floats was undefined behavior around certain values of floats. Like what means, for example, when you have infinite float, what other bits contain? So we standardize this, and now they are equivalent platform independent. So it's okay to use floats now in our VM environment. So again, standard practice in it is we first check that the state doesn't exist. Then we verify input up to certain things that we can do.
00:11:03.440 - 00:11:57.200, Speaker A: So first thing we do, we verify that the fraction is valid, and we check that denominator is not zero. And also numerator is less than equal than denominator, which makes a fraction is less than equal to one. This is important to avoid some logic mistakes. Next thing we do is we verify that the account is valid. So this contract was written before some of the helper metric exists. So now we have, for example, valid account Id in JSON types that does this check automatically during the deserialization. And if it's invalid, it will just panic.
00:11:57.200 - 00:13:16.910, Speaker A: Next thing we do, we pull the account balance, the current account balance of the staking contract. So this balance has to is usually large enough because it has to pay for the storage of this particular contract. And then we say we're going to allocate some tokens for price guarantee fund. So the staking pool has certain guarantees that are important for lockup contracts. And guarantees are when you deposit to the staking pool, you should be able to withdraw at least the same amount of tokens. And you cannot lose tokens even like one yacht a year on this contract by depositing and withdrawing from the staking pools. So this stake share price guarantee fund is around 1 trillion yacht a year, which we consume, usually around one or two yoktanir for rounding errors and we can get into details of how this works.
00:13:16.910 - 00:14:46.410, Speaker A: Finally we remember what's the balance that we're going to stake on behalf of this contract itself. This is required to establish some baseline to limit the rounding differences, and we verify that the account doesn't stake already. So this might break some logic and we don't want this to happen. So we want to initialize the contract before it stakes anything. Finally, we initialize the structure, but we don't return it immediately. We just created the structure here and then we issue restaking transaction. This is important because we want to make sure that the staking key that was provided is a valid restret ED 255, something like 5119 valid key.
00:14:46.410 - 00:15:49.740, Speaker A: So there are some keys on the curve that are valid keys but not restrata specific. And validators keys can only be restrata specific. So this is a near protocol specific scene. And what happens is it makes a staking transaction with the given key. And once this transaction is created from the contract, when it leaves, we do validation on this transaction. And if the key is invalid, then it will throw an error and entire sync utilization of this staking pool will fail. So if you pass invalid staking key public key as an input, then your contract initialization and deployment, and all this that happens in one batch transaction will be reverted.
00:15:49.740 - 00:16:59.968, Speaker A: And this is important. So the pool doesn't have an invalid key because that might be allowing you to block the stake of other people and we don't want to. So as part of guarantees, we're saying if you unstake, your tokens will be returned in four epochs so they will be eligible for withdrawal. This is again important for lockups to be able to return them to lockups. I think this is too much details before I explain the high level of how contract works and how balance works. So we should probably go here and explain the concept of how we actually can distribute rewards to account owners in a constant time when an epoch passes. So this is important for most of the smart contracts.
00:16:59.968 - 00:18:08.920, Speaker A: They want to act in constant time for every method instead of a linear time for the amount of users. Because if the amount of users grow, then the amount of gas required to operate in linear scale will grow as well and eventually will run out of gas. So that's why all smart contracts have to act in Constantine, usually algorithmic. So the way it works for every user, we keep structure called account. So every user that delegated to this staking pool will have a structure called account that has the following fields. And staked is the balance in Yuktanir that is not staked. So it's just a balance of the user.
00:18:08.920 - 00:19:28.390, Speaker A: Then stake shares is actually a balance, but not in near, but instead in number of stake shares. So stake share is a concept that was added to this particular staking pool. And the way it works is when you stake, you essentially mint new shares at the current price by converting your unstaked balance into stake shares. So a stake share price originally is one, but over time it grows with rewards. And when the account receives rewards, its total stake balance increases. But the amount of total stake shares doesn't change. So essentially when account receives validation rewards or some other deposits straight to the balance, that increases the amount that you can receive for every stake share.
00:19:28.390 - 00:20:43.520, Speaker A: So the example can be the following. Let's say you had originally 1 million near that was deposited to this account. Let's say you get 1 million shares, ignoring the Yoktanir for now. Now, if the staking pool received 10,000 near in reward, you still have 1 million shares. But this 1 million shares now corresponds to 1,010,000 near. Now, if someone else wants to stake at this time, they will purchase stake shares internally within the contract at the price of 1.1. That is because every share now is equal to one year.
00:20:43.520 - 00:22:01.702, Speaker A: Now, when you receive another reward, you don't the total balance, and in constant time, everybody share the reward proportionally to the number of shares they have. Now, when you unstake, you're essentially selling these shares or burning them in concept of fungible tokens in favor of unstaked balance. So you sell at the current price, so you decrease the total amount of stake as well as total amount of shares. And when you purchase, you increase the total stake balance and the total stake shares while keeping the price at a constant. So when you stake or unstake, you don't change the price. When you receive the reward, you increase the price, so the price can only go up. So this may lead to the rounding errors when your yoctan year balance cannot correspond.
00:22:01.702 - 00:23:01.770, Speaker A: Precisely. And that's why we have this guarantee fund of like 10 trillion or like 1 trillion Yaktanier that will throw one extra yocta a few times. And finally, the final part is because the near protocol does not unstake and return the balance immediately. It has to wait three epochs until your balance will became unstaked and returned to the account so unlocked. So if you unstake, you cannot withdraw this balance immediately from the staking pool. You need to wait three epochs. And we remember at which epoch height you called the last unstake action.
00:23:01.770 - 00:24:30.180, Speaker A: And after, in theory three epochs, your balance will became unlocked and you should be able to withdraw from unstaked. But there's one caveat with this. If you call unstake at the last block of the epoch, the actual promise that does unstaking will arrive at the next epoch, or like first block of the next epoch, and that will delay your locked balance to became unlocked for four epochs instead of three. Because we recorded the epoch in the previous block, but the actual transaction happened in the next block on the next epoch. And to make sure that doesn't happen, we log the balance by four epochs instead of three epochs to account for this border case. So that's an account. Does it make sense of how the high level logic works from staked and staked shares? Yeah.
00:24:30.180 - 00:24:31.960, Speaker A: Okay.
00:24:34.410 - 00:25:29.000, Speaker B: I've got a couple of questions, but I don't know if this is the right place for them. Yeah, you decide. In terms of the design of this, was this predesigned or for example, num stake shares and this kind of simplification of having internal shares that people buy into at different periods. Sometimes people will make a design choice like that to simplify a bunch of kind of noise, arithmetic noise or whatever that's spread around the code, and you kind of factor it out into this new idea that makes things easier. Or did you kind of start with this idea? I'd be curious when and how some of these decisions were made, what the driver was to make the decision, because that might help developers recognize those moments in their own code and say, oh yeah, I'm kind of running into the same problem, maybe I should do this or that, right?
00:25:29.930 - 00:26:34.874, Speaker A: Well, the idea of shares is not that new, because on Ethereum, majority of providers, liquidity providers and automated market makers use this similar concept. So when you, for example, deposit to the liquidity pool, you get some kind of token from this pool instead of actual amount that represented there. And when you withdraw from the pool liquidity pool, then you burn this token and get the actual represented tokens. So the idea is very similar. To call them shares is somewhat because they have a corresponding price and we could have called them differently. So it was almost from the beginning of the stake and pool contract because we needed a way to represent. Well, not really.
00:26:34.874 - 00:27:31.770, Speaker A: There was exploration around how we can do this properly. One way was we limit the number of accounts that can deposit to a given pool to account for this particular update. And eventually we landed on the constant time and it was actually simpler model constant complexity time. And then the mass of this became somewhat reasonable. Even so, there's some complexity as well involved there. So let me probably go through this contract. It's not as well structured as for example a lockup contract, because lockup is even more complicated.
00:27:31.770 - 00:28:27.194, Speaker A: So the types are still bundled in the same contract. So there is a bunch of types. So for example, reward fraction is a separate type, account is a separate type, and there is also a human readable account as a type that only used for view calls. So it's not used for logic internally. Then after you finish with all the types, we have cross contract calls using a high level interface. So there's two of them. The way it works is you have a macro from nearby engine called x contract standing for external contract.
00:28:27.194 - 00:29:35.298, Speaker A: You can give a short name that it will generate, that you will be able to use. And then you have a trig description describing the interface of external contract that you want to do. And this describes that you can call a method vote on a remote contract and pass one argument, which is is vote true or false boolean. Now you will be able to create a promise when you need it, and pass a positional argument instead of a JSON serialized argument. And the macro behind the scenes will make it into low level promise APIs and the second interface for a callback on ourselves. So this is fairly common, you can call it x self. So when you need to do a callback and do something on the result of the asynchronous promise, you can have this type of interface.
00:29:35.298 - 00:30:18.206, Speaker A: And what we do, we check if the staking action succeeded. And we may get to this detail if we have time. So finally we have this main implementation structure, implementation body of the staking pool. So we went through the constructor, so the next method. So this contract is split into multiple modules. So this is a lip rs, which is the main input. And also you have internal module.
00:30:18.206 - 00:31:13.746, Speaker A: So internal module has the implementation without near binding macro. So none of these methods will be visible to be called by a contract by someone else on the chain. They only can be called within this contract internally. So they don't generate JSOn formats and don't deserialize state. So they act as regular rust methods. So the way again high level how this contract works is when an epoch passes, you may acquire certain rewards as a validator. So we have a method ping which pings the contract.
00:31:13.746 - 00:32:35.470, Speaker A: So method checks if there's epoch passed, and then we need to distribute rewards and we'll go there for the legislature. And if epoch change then it will also restake because there might be some change in the amount of total stake the contract has to stake. The next is deposit. Deposit is a payable which means it can accept an attached deposit. So this is similar to Ethereum decorator that allows to receive funds only to the methods that expect them. So nearby engine by default will panic if you try to call a method, for example pink and attach a deposit to this method and payable allows to attach a deposit. So every method first does internal ping to make sure we distributed previous rewards before changing any logic.
00:32:35.470 - 00:33:44.150, Speaker A: And the common structure is if we need to restake then we first do some logic and then restake. So this is next method, deposit and stake this combination between two methods of like first you deposit balance to then stake balance of your account and also you want to stake the same amount immediately instead of doing two transactions. And it's also payable because it also accepts a deposit. So next is withdraw all, withdraw all tries to withdraw all entire unstaked balance from the account that called it. So when you interact with the staking pool, you need to interact with the account that owns the balance. So in this case this is a predecessor account id. And the logic is we basically check the account and then we withdraw the unstaked amount if we can.
00:33:44.150 - 00:34:45.116, Speaker A: And if it's not then it will panic. For example, if it's still locked, do it to unstaking for epochs ago, less than four epochs ago, withdraw allows to withdraw the balance that is not all balanced but only partial balance. Then stake all stakes, all unstaked balance. It's pretty rare to have this method because you usually use deposit and stake and it already has all the stake balance. Then stake, you just stake some amount of unstake balance. I think Moonlet wallet uses separate calls to deposit and stake, but they use a batched transaction to do this. Finally, you have unstake all stakehold.
00:34:45.116 - 00:36:15.724, Speaker A: It takes your current amount, so it basically unstakes all your stake shares by converting them to yoctanier. So this is the helper method which saying convert my shares number of shares to amount to yocta, near amount and round down because we cannot give you extra for your share multiplied by price. And that's how we get the amount. And then we call unstake for the given amount. If this logic is the following, it uses U 256 because we operate balances operate on U 128 and to avoid overflow we do the following, we multiply the balance by number of shares. So basically this is the price. This two divided and rounding down and equivalent is we have a round up but it's reverse and it's staked amount rounded up.
00:36:15.724 - 00:37:03.276, Speaker A: Here's a round up. Roundup is very similar except we do this hack that allows to round up and then we cast it back to you. 128. So this unstake all. Then we have an unstake action which is very similar to unstake all except you pass the amount. And then there is a bunch of getter methods of you calls that return you some amounts so you can get the stake balance, stake balance, total balance check. If you can withdraw then you can get total stake balance.
00:37:03.276 - 00:38:03.600, Speaker A: This is the total amount the staking pool has in active stake. Then you can get who is the owner of the staking pool. You can get the current reward fee or commission of the staking pool, get the current staking key. And there is a separate thing that allows the owner to balance the staking pool. Let's say the owners does a migration on the staking pool on the node. So something they need to completely unstake. For example, so they can pass the staking pool which will send unstaked transaction to the near protocol and then will not restake until they resume the staking pool.
00:38:03.600 - 00:39:21.064, Speaker A: But you can still withdraw your balances, but you will stop acquiring rewards after it's passed. Finally you can get a human readable account. Instead of giving you number of shares, we give you how much tokens you actually have for the number of shares at the current price. And finally it's saying can you withdraw or not? Then it gives you number of accounts, number of delegators to the stake impulse and you can also retrieve multiple delegators at once. So this is a pagination on the large number of accounts within the unordered map. And the way you do this is one way of doing this is you use the helper that we call keys as a vector from the unordered map. It gives you persistent collection of keys from the map.
00:39:21.064 - 00:40:04.650, Speaker A: And then you can use iterator to request accounts from these keys. So that's not the most efficient way, but it allows you to implement pagination on an ordered maps. And finally, this is a callback that we will probably skip for now. And there is a bunch of owners method. So owner method is the methods that can only be called by the owner. So owner can update the staking key. Let's say they have a different node and need to use a different key.
00:40:04.650 - 00:41:00.788, Speaker A: So all these methods first check that the only owner could call it. This is the method that changes the commission of the staking pool. So owner can change the commission that will be active at this epoch, starting from this epoch immediately. But all the previous commissions will be calculated using the previous fee. Then this was a vote that allowed us to transition to phase two of the main net and two methods that I described, which allowed to pause taking and to resume staking. And finally, we have tests here. So we have about 15 minutes left that we can spend.
00:41:00.788 - 00:41:36.930, Speaker A: We basically described the high level interface of how this works, and we touched a little bit about the mass of how rewards are distributed. So most logic is happening in internals. What would be a good way to start? Like what should we try to see? Maybe we can start with internal pink. So this is the way that rewards are distributed. So let me.
00:41:41.880 - 00:41:48.992, Speaker B: Eugene, this is a lot of code to take in without seeing execution.
00:41:49.136 - 00:41:50.660, Speaker A: Your mic is pretty.
00:41:50.810 - 00:42:15.790, Speaker B: Oh, sorry about that. Thanks, Josh. This is a lot of code to take in without seeing execution. If we run the test suite or some of the tests, can we visualize some of the paths through this code? Like, this is what the owner would do when they set things up. This is what somebody would do when they're staking. In terms of, I don't know, a couple of scenarios to help us exercise our thinking in terms of how this code actually runs. Does that make sense?
00:42:16.900 - 00:42:25.490, Speaker A: Right? I think, yeah, we can do this, but it's probably like, will take some amount of time.
00:42:26.020 - 00:42:28.224, Speaker B: Okay, that's fine.
00:42:28.422 - 00:43:07.340, Speaker A: We basically also have simulation tests for this particular pool. And maybe, well, there's not that many. So this simulation test, that's like how that network actually going to work. So we first initialize the pool, and then the owner paused the pool. We checked. Well, that's not really helpful. Um, but the idea is how it works is.
00:43:07.340 - 00:43:45.654, Speaker A: So Bob is the delegator Bob called full deposit, which is deposit the amount using deposit method. Then Bob can verify the state balance is working. Then Bob stakes the amount. There's the amount staked. Now we verified that Bob has staked the same amount. Bob calls the ping. There's no rewards, but in simulations, the rewards are not working anyway.
00:43:45.654 - 00:44:04.510, Speaker A: So you need to manually do this. We verify that the bob amount is still the same. Then pool resumes. We verify that the pool has resumed. The lock is zero. Then we simulate that the pool has acquired some rewards. One.
00:44:04.510 - 00:45:11.540, Speaker A: Then Bob pinks the pool, and we verify that the amount that Bob received is positive. That's very simple. Simulation case which saying Bob first deposited to the pool, that verifies that the piles and resume works or simulates that it works and makes sure that the pool doesn't stake during while being paused and then when resumed the pool actually stakes. So this test verifies not only this, but also that Bob has acquired reward and got distributed the reward. There is another test that verifies some logic, but that's more complicated. There are some unit tests on the bottom of this that supposed to verify certain stuff. Let's see what simple one.
00:45:11.910 - 00:45:16.214, Speaker B: It might be good enough that we just called them out as well. That's fine, we can take a look.
00:45:16.252 - 00:46:16.806, Speaker A: Sure. Some of the test tests, they are not ideal, but they verify certain stuff that was good enough to make sure that mass adds up. So internal pink is the method that you call, or anyone can call actually like through pink to make sure rewards are distributed. So right now we have active staking pools and there is a contract or there is an account sponsored by one of near folks that basically pings every staking pool like every 15 minutes to make sure they have distributed the rewards to display on the balance. So the way rewards distribution works is the following. We first check the current epoch height. So if epoch height is the same, then the epoch hasn't changed.
00:46:16.806 - 00:46:47.010, Speaker A: We return false. So you don't need to restate. But if epoch has changed, then we remember that the current epoch is this. We get the new total balance of the account. Pink may be called when some tokens were deposited through deposit balance and they are already part of there. But pink is called before. So we need to subtract this balance before we distribute the rewards.
00:46:47.010 - 00:47:49.698, Speaker A: So we get the total amount that the account is has, including both locked balance and unlocked balance. So locked balance is a staked amount that acquires rewards. Unlocked balance is the. It also may have rewards in certain scenarios where you decrease your stake, but your rewards will still be reflected for the next two epops and they will come to the unstaked amount we verify. This is the assert that the total balance is more than the previous total balance. This invariant that the stake can pool requires. And there was a bunch of stuff on Testnet that happened to fail this invariant because people still had access key on the same staking pool.
00:47:49.698 - 00:48:54.540, Speaker A: And when you have it, you spend the balance for gas and you may decrease your total balance without acquiring the reward. Um, finally we calculate the amount of rewards that the staking pool received. This is total balance minus the previous known total balance. So the balance from the previous epoch and if the rewards are positive, we distribute them. The first thing we do, we calculate the reward that the owner takes for themselves as a commission. We multiply this fraction by the total rewards received and this is fairly similar. Rounded down numerator in U 256 multiplied by value divided by denominator in U 256.
00:48:54.540 - 00:50:23.596, Speaker A: So this is the amount in Yoktanir that the owner will keep for themselves and this is the remaining rewards. We're saying all remaining rewards have to be restaked and it goes here to be restaked. Then we calculate how many so owner received the rewards in Yocta near not in shares, but because all the logic has to be in shares. Essentially the owner of the staking pool purchases shares at the price at which the post reward distributions to the rest of the delegators. And this is the number of shares that owner will receive as a compensation for running the staking pool. If it's positive, we increase the amount of shares and save the owner account back. And we also increase the total amount of staking shares.
00:50:23.596 - 00:51:33.612, Speaker A: If for some reason rounding down this balance became zero. So rewards was very small and the price per share was very large and owner received zero rewards, then this balance will just go to the price per share instead of compensating the owner. And finally we put some helpful login data saying that the current tip of is this. We receive the rewards in that amount of staking shares or in tokens. The total stake balanced of the pool is this and number of shares. This is the only way we expose the number of shares to external world is through the logs is this and if owner received rewards, we send total reward fee was so many shares. And finally we just remember the new total balance and that's it.
00:51:33.612 - 00:52:32.684, Speaker A: So we distributed all rewards in a constant time. We only updated one account and this is the owner's account for commission and only if the commission was positive it. So what else would be interesting here? The interesting part probably is something like a stake, one stake. Let's see for example a staking thing. So the way we stake and that is when we do price guarantee fund is let's say the predecessor. In this case we're going to call it account id wants to stake this amount of tokens. And balance is actually not a JSON type because it's internal method we don't need JSON.
00:52:32.684 - 00:53:42.950, Speaker A: Here we calculate how many shares around it. Down again down, not up required to stake the given amount. So this is how many shares the owner will receive. It has to be positive. Then we check the amount, how much the owner should pay for the shares again round it down. This is to guarantee that the owner when they purchased shares and converted back without rewards, never lost one Yoktanier because it might break the guarantee. Finally, we say that the account has enough amount to pay for the amount charged and we give the unstaked, we decrease the internal unstaked balance, increase the internal number of shares, balance of the account and the stake amount.
00:53:42.950 - 00:54:38.452, Speaker A: We round this up, so the number of shares actually rounded up. So this one extra penny or like one extra yoctan year will come from the guaranteed fund. During the rounding of the shares up. So we charge user less, but we contributed to the amount more from this 1 trillion yoctas that we had originally designated for this. And this difference usually is just one Yoktanier that may come from rounding up or down. And this is amount of total staked balance and number of shares increased, so we minted new shares. Finally we put a log and return and unstaking works very similarly.
00:54:38.452 - 00:55:49.882, Speaker A: We round up, so this is the amount of shares you need to pay. We calculate how much amount you receive, again rounding up, so we overpaying you for this. But this also comes from guarantee fund and we decrease the shares, increase the amount and saying when you can unlock. So in four epochs, and this is the unstaked amount, we rounded it down, so we unstaked slightly less to guarantee the price of other participants of the pool. So that's pretty much how the staking pool works and how mass works. So we compensate for rounding errors from the fund that we allocated. Okay, I think we out of time that we wanted to spend on this and we can do a few questions and then finish it up.
00:55:49.882 - 00:55:51.340, Speaker A: Let me know if you have.
00:55:51.650 - 00:55:56.560, Speaker B: I've got a pile of questions, but I've been talking a lot, so I'll wait a few seconds to see if anybody else wants to ask.
00:55:57.010 - 00:56:03.570, Speaker A: Okay, go ahead.
00:56:05.460 - 00:56:31.980, Speaker B: Okay, I'll just fire off the questions, then you can decide what you want to answer. Okay, sounds good. Just in order of how these occurred to me while you were talking. So you mentioned restretto keys are required for validators or validator nodes. I was wondering why that is. It seems like there's some kind of subset of the curve keys that are somehow more secure. Based on what I checked out briefly, I'm not quite sure if you can add to that.
00:56:31.980 - 00:57:08.310, Speaker B: Does the stake share price guarantee fund set an upper limit on the lifetime of the contract or does that get refilled over time? Those are the two maybe technical questions and then two questions around level of effort and experience review like a retrospective on this work, level of effort. Like how long did this take to design and build? How many people were involved? How many revisions were there? And then for experience, what was the hardest part of this for you? What was the most surprising? Any discoveries that you made, any changes that were put into the protocol during the development of this, because of its development, that kind of stuff.
00:57:09.240 - 00:57:48.320, Speaker A: All right, so for Estrada, it's pretty much yes, we updated it during the design of this contract. And that was a surprise that we needed to account for this. Then. Second was about the price guarantee. So 1 trillion should be enough for 500 billion transactions. So that should be long enough for the staking pool. So it cannot be refilled because the rewards will be immediately redistributed to the total stake balance on a next ping.
00:57:48.320 - 00:58:57.800, Speaker A: So it's a lifetime of the contract, I say, but it's unlikely to happen. Next was the question about the level of expertise. I think we spent on this contract quite a bit. And we did ton of security reviews, including internally and externally, especially around this mass that was complicated. Some stuff was discovered, like this restrator key popped up during the reviews. So we marked the change lock of this contract as well. In the readme, there is a bunch of stuff that popped up during the development and testing on a live system, but the original version was took maybe like a week to write and later clean it up, test it properly and improve.
00:58:57.800 - 00:59:58.460, Speaker A: And then we did a bunch of revisions. So pausing and resuming was asked by the pool because otherwise the owner had no ability to unstake. And if their node goes down, they will be attacking the network essentially with active stake, kind of requesting the validation and not running the network. So right now we don't have slashing. So this was just not an issue for the participants, but it was an issue for the network itself. So that way the owner can pause the staking and just if they don't want to run the pool, they migrate into pool and communicate as much as possible. Before this next, we updated the vote interface to match the final phase two voting contract.
00:59:58.460 - 01:00:41.310, Speaker A: There was helper view methods and to be able to query accounts in a human readable way. And finally, there were some improvements around batching methods together. Deposit and stake, stakehold and stake all, withdraw all. Instead of like you have to make a vehicle first get the amount, put the amount and call the stake. And the way we fixed it, I think we can spend a few minutes on this. When you stake, not only you take the amount, we also attach a promise to check if the stake was successful. It needed for two things.
01:00:41.310 - 01:01:51.804, Speaker A: So if you're trying to stake with invalid key, not restrate a specific key, then the promise before execution will fail. So it will fail validation before sending it and that will make it so this way we don't need to check it within the contract, it will revert the last call and it's all going to be good. But we also introduced the minimal seed on the contract and the minimum, not minimum stake on the protocol level. So minimum stake is one 10th of the amount of last seed price. And if your contract tries to stake less than this, then the action will fail and you will not send the profit. So let's say you want to unstake some amount and you dropped your balance below one 10th of a stake. So the staking action may fail and you will not unstake.
01:01:51.804 - 01:03:14.490, Speaker A: While you needed to guarantee that unstaking has to happen, in this case we have this callback that checks that the staking action has successfully completed. And this callback basically checks that if it fails, if it fails and the balance is positive, we need to unstake. So it will call unstaking action where the stake amount is zero to make sure that all balance is released and you can withdraw. In for epochs, just findings. During the testing of these contracts that we did on better net testnet before mainnet, the contract was ready maybe around summertime. So the testing of this and iteration of this took probably like two, three, four months due to complexity that it involves interacting with the protocol. And as for learnings, there were quite a lot of learning.
01:03:14.490 - 01:03:59.434, Speaker A: So from pagination to helper methods and batching together some stuff. So one thing that would be really nice to have is stake, or like deposit and stake all on a lockup contract. So right now, lockup, you have to issue manually how much you want to stake on a lockup contract. But it would be great that you didn't need to think about Yoktanier, how much it's locked for storage and stuff like this. And you want to stake everything from your lockup. But because it was already deployed, it was too late to think about this. There's also some gas that is hard coded.
01:03:59.434 - 01:04:31.030, Speaker A: And with the coming decrease in fee, these numbers cannot be changed because they're already on chain. So vote is not important. But this method requires you to have large number for every stake action and we cannot decrease it. So every restaking action or every call on this contract will require us to have large amount of gas.
01:04:31.190 - 01:04:33.370, Speaker B: And the problem is that that's wasteful.
01:04:33.870 - 01:05:24.430, Speaker A: It's wasteful. We had a proposal to burn all the gas that you attach. And in this case, once the fee go down and we decide, let's say we agree on burning all the gas. This gas will be always burned wasted. Plus it limits the number of transaction you can put into one block because of that gas amount if we are restricting based on this gas. Finally, there was lots of iteration on the testing of the contract using the simulation test framework that we improved a lot. And from this learning, if we get to the lockup contracts, eventually you can see how the structure of lockup contracts improved over this one.
01:05:24.430 - 01:06:08.600, Speaker A: And there is a better structure on the sources. So we split all the methods. Here's getters, internal owners, method, foundation methods, types, utilities. So this is still bundled together. But it was a good iteration and readability of the contracts. Plus a lot of stuff was improved on near SDK itself on nearby gene to help support some stuff like this public key serialization for example. So you don't need to think about how the JSON string converts into inner serial two bytes representation.
01:06:08.600 - 01:06:48.680, Speaker A: Yeah, so that's like a review. I think that was more technical than the first one. And let us know, know if you have any feedback and we'll try to improve on it. Thank you. Any final comments before we start it? No. Okay, thanks everyone. Bye.
