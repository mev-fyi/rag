00:00:01.850 - 00:00:48.300, Speaker A: Hello, everybody, to the EVM working group's weekly update. Today. We will not have everybody joining as the bridge release is imminent. Let's see our agenda, given that, is it there? So we continue to work towards our EVM testnet release by the end of Q one, which is in a couple of weeks. So better light a, light a fire under us. And today I think we have enough to discuss on the specific things everybody's working on. But if somebody wants to add something to the agenda, by all means, now's the time to mention it.
00:00:48.300 - 00:01:47.162, Speaker A: All right, so let's go ahead. We don't have Alex today. He's attending a bridge sync, but I believe for him this week was just bridge work. And on my end this week I've been focusing on finishing the refactor and upgrade of the EVM contract. The EVM contract now lives in a new home called Aurora Engine. And over here, I've rebuilt the contract from scratch in a more maintainable way. It has feature parity with the old contracts, but it's possible to upgrade the EVM implementation.
00:01:47.162 - 00:02:32.990, Speaker A: We are on a much newer version than the old contract, so we have certain performance improvement and some bugs are fixed. Let's see here. Yeah, we are not released as of two days ago, currently, so pretty much in sync with upstream. So this is what I've been working on, and also I'm upstreaming our additions, our changes to the EVM implementation. So working with upstream to see what will be accepted and what perhaps what we will need to maintain on our end. That's everything from me this week, Yevgeni.
00:02:33.890 - 00:03:45.090, Speaker B: From my side, I started implementation of pure s connector smart contract with now STD, and one major problem was related to dependencies and it was ABI dependency, and I successfully resolved that problem. I forks implementation with no STD and it was some bugs and I fixed all of them. And currently that problem successfully resolved it and everything worked. I mean, as Abby dependency, it was not dependency. I put it as local implementation to contract. So currently it work all fine. And I started implementation specific functions for s connector and currently almost implemented deposit.
00:03:45.090 - 00:04:06.490, Speaker B: And I think it's really good progress because I solve probably all problems that stopped me to implement a new implementation for nostdd. So next week I think I will have really good progress and probably I will end the task.
00:04:07.310 - 00:04:17.230, Speaker A: Okay, sounds good. Tell me, the changes to SRB, are they something that we can upstream? Can Srb be made no STD compatible?
00:04:17.890 - 00:04:30.850, Speaker B: No. Not support nostd. So it's completely different implementation for upstream.
00:04:31.670 - 00:04:53.546, Speaker A: Okay. All right, I also see that you are now on the same nightly version as we are using in a contract. That's good. I was going to ask whether we needed to stay on an older version, but if that works, that's great. Yeah, so this is coming along. I will find some time in the next days to review. Is it ready for review?
00:04:53.728 - 00:05:44.570, Speaker B: No, ready for you is Abby. But as you understand, currently as connector has no STD and not completed because I should implement fungible tokens. Currently I implement some things related to SDK. I mean SDK node, std, SDK. I copy paste some functionality from near EVM and I put additional functions for working as connector. So currently full environment for development is ready and I think in next week I probably can finalize that smart contract.
00:05:44.990 - 00:06:00.190, Speaker A: Okay, sounds very good. And no other dependencies gave you trouble? We have a lot of dependencies here. Everybody else can default features false will be fine. Okay, great. Good. Okay Frank.
00:06:05.830 - 00:06:12.500, Speaker C: Continuing on the bully. So in order to call the EVM contract, we have to sign and.
00:06:14.470 - 00:06:14.882, Speaker D: Create.
00:06:14.936 - 00:06:35.980, Speaker C: Transactions and sign them. And it's basically the same as transmitting money. So I started building that first to be able to test it. It basically means creating a transaction, encoding it as Borsche and signing it. And I built that. It's finished, but it doesn't work.
00:06:37.070 - 00:06:37.702, Speaker A: Unfortunately.
00:06:37.766 - 00:06:57.090, Speaker C: I wasn't able to figure out why exactly it's rejected by near core. Might be some bug in the Borsch go library or some other small thing, but basically that's what I will do next. Once that is debugged, then we can call the contract functions.
00:06:58.470 - 00:07:03.540, Speaker A: Okay. And as you saw, I hope I added those today.
00:07:03.910 - 00:07:05.220, Speaker C: Yeah, that's great.
00:07:06.970 - 00:07:34.830, Speaker A: Basically we can look a little bit at that. So for the begin chain, currently we're only taking chain id. We need to add a genesis state there for begin block. I believe we have everything you need for that. As long as we are tracking the block hashes in the contract. Yeah, those should be okay. And you should be able to call those.
00:07:34.830 - 00:07:49.742, Speaker A: Just remember to Borsche, encode the input. It's not JSon. None of the EVM contracts inputs are JSON. That will change when we incorporate the fungible token standard. Perhaps, but for now they are all Porsche.
00:07:49.886 - 00:07:51.220, Speaker C: Okay, sure.
00:07:51.910 - 00:08:03.480, Speaker A: Okay, so how does it look in terms of our schedule then for beginning to replay? Can we replay next week?
00:08:04.490 - 00:08:05.254, Speaker C: I think so.
00:08:05.292 - 00:08:52.600, Speaker A: Yeah. We are pretty much behind on this task. Let's see, what do you think in terms of the data volume? Have you calculated how long it will take to replay Gurley no, I haven't calculated it. Okay, let's calculate that. Assume some reasonable transactions per second, and then just figure out how many days it will actually take to replay. Assuming that everything looks, because we're getting a little tight on that. If it takes a week, then we're not going to get too many chances of doing that if it gets interrupted later on.
00:08:52.600 - 00:09:19.390, Speaker A: Okay, so we have the send transactions working, but with a service session bug for the whole stack implemented. Okay, we don't have Ilya today. Joshua.
00:09:21.090 - 00:10:19.650, Speaker D: Yeah, so I did the EVM test, except for the one that required pull request 320 on the near SDK, which is now merged, which is good. So I'll test up until the actual checking if it upgraded. That's all done. And then I added better featured gates around PR 39 54, which is the extra cryptography methods or the math API extension. I'm waiting on a response about a question I had about adding fields to the Genesis config. I mean, typically you don't want to change those, and I don't think we've like, we changed some fields since, I think. But yeah, I'm not sure about actually adding fields to that.
00:10:19.650 - 00:10:50.620, Speaker D: I don't think we've ever done that. And then I looked at implementing the Blake two f compression function and I was like a quarter of the way through it and I just thought, I'm like, it must be in that library because I've been through that library before and I'm pretty sure I did see the compression function in there. And sure enough, it was the f compression that was described in the Ethereum protocol. What do they call those?
00:10:51.390 - 00:10:52.230, Speaker A: Eips.
00:10:52.390 - 00:11:05.330, Speaker D: EIP, yeah, in the EIP, also known as eeps. Yeah, it was already there. It's already in the Blake two library, so we don't actually have to add it ourselves, which is pretty sweet.
00:11:06.310 - 00:11:29.740, Speaker E: Is it different though? Because if compression function in EAP allows the caller to specify the number of rounds, and in this implementation it is fixed, so we'll probably have to copy it. We can't use it from this library, and we'll have to copy and have some modification to make some changes to this code.
00:11:31.390 - 00:11:49.742, Speaker D: Yeah, then I've been wondering about that. Then we would pretty much have to fork most of the Blake two library for us to add that in there, because I know it's twelve rounds for Blake two B and it's ten rounds for Blake two s. This only implements Blake two b.
00:11:49.796 - 00:12:06.920, Speaker E: So this pre compile only implements a compression function for Blake two b, but you have to specify the number of rounds. So in geth they copied library code and changed it and we will probably have to do the same.
00:12:07.850 - 00:12:19.240, Speaker D: Okay, so we're probably going to have to actually implement the Blake tv library itself because I got no public methods that I care public deals I can plug into.
00:12:20.970 - 00:12:22.600, Speaker E: It shouldn't be.
00:12:23.930 - 00:12:38.720, Speaker D: No, no, it isn't. It's just that we would have to actually take the blake two library and put it into our code because I can't plug it in the way that it's set up right now.
00:12:40.690 - 00:12:47.938, Speaker A: Or potentially fork it and add an API that you can use and see if upstream accepts it. That would be better.
00:12:48.104 - 00:13:01.510, Speaker E: This kind of API isn't really useful outside of implementing this AAP because I think no one is using Blake two with non standard number of rounds.
00:13:02.010 - 00:13:33.490, Speaker A: True. However, in any case they may accept it and so that would be the preferable way to proceed. So Joshua, you need to keep your eye on the ball here, as in this is what we need. Ultimately, this needs to be implementable and whatever it takes to get this implementable, that's what you need to do. So it's not enough. As jokingly pointed out, if something is in the source code there, we have to actually be able to provide this call signature.
00:13:34.150 - 00:13:44.930, Speaker E: Now we can discuss it in detail on Tuesday when we have a call for discussion of those math API editions.
00:13:45.430 - 00:14:16.030, Speaker A: Yeah, but there's still a bunch of days until Tuesday, which we wouldn't want to misdirect Joshua, in the meantime. So let's make sure that we agree what we work on here. So it doesn't mean that the mass API should have a host function which is exactly equivalent to the EEP as it's defined. Because after all, we would like these host functions to be generally useful beyond just implementation of an EVM. However, it must be flexible.
00:14:17.650 - 00:15:24.370, Speaker E: Have thought about how to make a generally useful function that can also be used to implement this EIP. So what I thought about basically is a function that can perform like the same of compression call, but on multiple blocks at once. This is generally useful because you can, for example, compute regular blake two hash in a single call of such function, even if the message to be hashed is longer than a single block. And at the same time you can implement this precompile. So this precompile in Ethereum is not that good for Ethereum users because it only perform this compression on one block at a time. So if you need to hash a longer message, you need to call it multiple times. And currently in Ethereum there is a high cost for calling any contracts, including precompiles.
00:15:24.370 - 00:15:43.530, Speaker E: But we are not Ethereum. We can make more useful host functions, and we don't have this high cost for each call. But for VM, we are just implementing the same thing that Ethereum implements.
00:15:44.750 - 00:15:55.630, Speaker A: Yeah, that makes sense. Would you be able to sketch out the API for your concept in a comment here so Joshua can perhaps have a stab at it before Tuesday?
00:15:57.090 - 00:16:09.250, Speaker E: Yes, so probably I will add the outline, but still, I think we should discuss that on Tuesday in more depth.
00:16:10.150 - 00:16:26.070, Speaker A: Certainly, but there's a lot of time between now and then, so we need to put that time to use. So if you would do that, then we can get Joshua in the right direction there. And I believe the other things you were working on, Joshua, were coming along nicely. You got the feature gating.
00:16:26.490 - 00:16:37.980, Speaker E: I can also help with actually implementing this cryptographic code because as we see, we can just use the library as is.
00:16:38.830 - 00:16:48.800, Speaker A: Okay, great. Any help? Certainly welcome. Anything to do with the feature gating still Joshua, or is that all?
00:16:49.170 - 00:17:24.134, Speaker D: Yeah, I renamed it to kind of follow what we were doing before, which was like the protocol feature, underscore crypto extras, and I implemented that into EVM feature. But other than that, that's pretty much good to go. I still have to push that one, but I was going a little bit over time when going through the compression function. Then I got one last thing. Yeah. Then I guess I've just been fixing the lingering CI issues because there's a couple backwards actually. That was weird.
00:17:24.134 - 00:17:35.840, Speaker D: I think all the backwards compatibility issues are done, but I ran into, like a weird server issue that something wasn't running when it should have. So I'm not too sure what that was about.
00:17:36.450 - 00:17:42.270, Speaker A: Okay, one note here. I don't think we need this on this granular level.
00:17:42.340 - 00:17:45.440, Speaker D: Yeah, that's basically already gone.
00:17:46.130 - 00:17:50.030, Speaker A: Okay. All right. That was coming in a later comment.
00:17:50.610 - 00:17:53.758, Speaker D: Yeah, that's going to come in. It's already gone.
00:17:53.924 - 00:18:12.058, Speaker A: Okay, good, good. All right, so this is how does it look? Let's say that we get the hash function missing hash function in by Wednesday next week. How does it look from your point of view otherwise, Joshua, in terms of the overall task list here?
00:18:12.144 - 00:18:21.662, Speaker D: Yeah. I looked at multiple different source codes that did the same thing, and some of them were able to use the Blake two library that they were already.
00:18:21.716 - 00:18:34.090, Speaker A: No, I don't mean Blake. Let's defer Blake. It's not an important question. There's many more important questions here than Blake. So what about the rest of all of these items other than Blake?
00:18:34.250 - 00:18:58.394, Speaker D: Yeah, the investigate. Yeah, I already took a bunch of notes of how 39, 71 already does or already did their implementation. So I just got to add those last little bits. I still got to do the test case for EC recover ten k. Okay. And then I still got to measure and assign the gas cost. Right.
00:18:58.394 - 00:19:04.940, Speaker D: That was another question. Because he mentioned that I needed a server because it has to run for 6 hours.
00:19:05.950 - 00:19:26.980, Speaker A: I believe Paul mentioned that. Yes. I wouldn't get held up on questions like that. Just boot one up and expense it. Otherwise you introduce pipeline stalls into critical paths and that's not good. Right. So let's just get it done.
00:19:26.980 - 00:19:51.100, Speaker A: So I believe that the other question that you had here, we will need either Yevgenikusiako for, or perhaps Yevgenikapun or Bowen Wang, who are on the call, know something about this, as in, when we add new host functions that have never existed in the protocol before. Does the genesis JSOn file need to be changed as well?
00:19:53.390 - 00:20:18.050, Speaker F: No. First of all, that file is not the Genesis file. It is a file that's used for testing purposes. Okay? And yes, it has to be changed, but that's not for the reason of changing the genesis file. It's mostly just like I think some tests rely on that file. Rely on the fact that the file is updated.
00:20:19.430 - 00:20:25.220, Speaker A: Okay, Joshua, maybe you can ask a more specific question to unblock you on this.
00:20:25.830 - 00:20:51.682, Speaker D: Yeah, it was just more so. Like the JSON's failing to parse because we have a check to make sure that all the fields are the same. So it fails because it goes, oh, right, MD 160 doesn't exist because, of course, the one that was compiling was not running off the evm features. So do you want me to make a new Genesis file?
00:20:51.846 - 00:20:55.710, Speaker F: Well, in that case, you just don't update Genesis file.
00:20:56.930 - 00:21:06.900, Speaker D: All right, no problem. That was my other question. If I just don't update it because I think I already deleted it locally just to get it to compile on my end.
00:21:08.150 - 00:21:18.790, Speaker A: Okay. All right, so that sounds like you got pretty much the questions answered and we'll be able to continue. Anything else blocking you?
00:21:18.940 - 00:21:20.886, Speaker D: No, that's it.
00:21:21.068 - 00:22:06.614, Speaker A: Okay, great. Okay, so those are the team updates. Now, if we had Alex with us, probably we would discuss the connector in more detail. Yevgeni, you. Do you have anything to comment on that you are not blocked on? Anything. As you were saying in your update, you just need to finish the coding and that's all. You're not waiting on Kirill or Alex or me or anything like that? Yogeni Ohano all right.
00:22:06.614 - 00:22:23.820, Speaker A: Maybe he has some connectivity trouble. Same question for the bully. Other than the support in the EVM contract, which is underway, do you need anything else, Frank? Any pricing? Okay.
00:22:25.790 - 00:22:33.550, Speaker B: From my side, I don't need additional help. So I think in next week I should complete my task.
00:22:34.050 - 00:23:29.790, Speaker A: Okay, great. Okay, then. Those are pretty much the items we had. Let's see. Let's have a look here. So this is the roadmap as we originally formulated it six weeks ago. And let's see where we are.
00:23:29.790 - 00:24:04.220, Speaker A: So the debug bounty program got deferred altogether. That will begin earliest, middle of April. Let's see. That looks a bit of a scrolling. So currently the goal is that we would deploy. Let's look at the calendar and see what date that was. March 29 is a Monday, just a few days before the end of the month.
00:24:04.220 - 00:24:21.870, Speaker A: And we will certainly have something to deploy on that day for testnet, no question. Given the EVM contract approach, a different question is what all might be missing in terms of performance and testing.
00:24:25.670 - 00:24:34.210, Speaker F: Actually, Arthur, I want to ask a question. So are you still planning to release EVM to test that on March 29?
00:24:35.050 - 00:24:40.870, Speaker A: Correct. But not any changes to near core, just the contract.
00:24:42.250 - 00:24:46.466, Speaker F: Oh, so that release is unrelated to near core.
00:24:46.658 - 00:25:11.610, Speaker A: Yeah. So we don't need to have a protocol change by then. The protocol change later on. So the bits Joshua is working on right now, that will give us a performance boost, but that can be delivered asynchronously for now. The contract will have the same functionality. Just use more gas. That's good enough for the end of March.
00:25:11.610 - 00:25:12.590, Speaker A: Testnet.
00:25:13.330 - 00:25:15.040, Speaker F: Okay, thanks.
00:25:16.710 - 00:25:46.886, Speaker A: Let's see. So the bug bounty program was deferred for both bridge and EVM on the performance end. We are definitely late with the replayer, which is frank why we need to know how long it will take to replay something like Gurley. So if you would calculate that as soon as you can. And we did the protocol upgrade proposal. There wasn't much discussion around it that I saw. But then again, it's no longer on the critical path.
00:25:46.886 - 00:26:21.320, Speaker A: Given the change to the contract, the bridging is coming along nicely. I do believe we can make that date. And the connector, of course, is also coming along very nicely. In fact, this is pretty much on schedule still. And the Berlin hard fork got descoped, although upstream is actively working on it. So we might even have it in the next few weeks. But if so, it's just a cherry on top.
00:26:21.320 - 00:27:12.818, Speaker A: The Berlin hard fork for the Ethereum mainnet is scheduled for middle of April, so we have a little bit time before any tooling starts to assume that Berlin is available. Okay, so I think we are late on the pre player here. We are doing okay on the connector and bridge. And what's not really captured here, because when we made this roadmap, we did not anticipate changing the architecture. What is not captured here is that we did change the architecture. And there are some things that still need reimplementation. Such as, for example, the pre compiles.
00:27:12.818 - 00:28:00.040, Speaker A: So that's what I'm working on actively. Okay. It's not looking too bad, but time is running out. Anything else to discuss today? Anybody have any questions or concerns? Okay, then I suggest we get back to book and we keep this a nice and short meeting next week. I'm sure we will have more to talk about given the bridge release and all of these independent tracks coming together to some conclusion on each of our parts. Ah. So I wish everybody a nice weekend and talk to you next week.
00:28:01.370 - 00:28:03.058, Speaker C: See you. Bye bye.
00:28:03.234 - 00:28:05.490, Speaker D: See you guys. Bye.
