00:00:04.170 - 00:00:12.398, Speaker A: Hi, everyone, this is Ilya from near. And with me is Eric from Holochain. We'll talk about what is Holochain about? Do you want to introduce yourself?
00:00:12.564 - 00:00:21.934, Speaker B: Yeah, I'm Eric Harrisbrown. I'm one of the co founders of Holochain and Holo. And it's a pleasure to be here. Thank you for having me. Great.
00:00:21.972 - 00:00:26.920, Speaker A: Yeah. So let's dig in. What is Holochain? And like, why is it different?
00:00:27.290 - 00:01:00.842, Speaker B: So, Holochain, we think of it as a distributed web application platform. So you can think of things like Ethereum as smart contract layers, but we like to think of Holochain as the equivalent of something like rails, a whole platform for developing web applications in the distributed context that run from the full gamut of what's possible in designing, we say web applications, but really it is a compute fabric for decentralized computing.
00:01:00.986 - 00:01:06.826, Speaker A: All right, so how does usually an application build on Holochain would look like?
00:01:06.868 - 00:01:48.046, Speaker B: Okay, so the thing that's interesting about Holochain is that especially if you've been living in the blockchain world and that's what's dear to you and that's what, you know, you have to shift your mindset, because Holochain is not a consensus mechanism. It is not a way of having some data reality that everybody agrees on. What Holochain is more like is what we actually know the world to be like. Everything comes from an agent centric perspective. So what Holochain provides is a way of different agents who are playing a game, I. E. An application or a little microservice, to agree on a set of rules to begin with and then make plays inside those rules and have them be validated by the community.
00:01:48.046 - 00:02:34.430, Speaker B: So the agents declare moves in a rule. And that would be the chain where you have the chain part, where you have a hash chain that starts at the bottom with what we like to call the DNA or the rules of the game. The second element in the chain, and this is every agent has one of these chains, is a record of the agent's identity, what their address is. So there's an id, and then from there on out in the chain, it would be the rules of the game as defined in the DNA. And so you will have lots and lots of different agents that are doing the same thing, DNA Id. And then whatever it might be, let's pretend this is a Twitter clone. You might have a tweet that goes in, or you may have a follow that goes into the chain.
00:02:34.430 - 00:03:07.790, Speaker B: And then what ends up happening is that each one of these things that an individual says gets shared out to a distributed hash table. When these get published to the distributed hash table, which is made up of other agents around the node in this particular network of this particular DNA, they will validate the move according to the rules that are in the DNA, and they will then answer requests for those particular moves. I'm using the game metaphor here. If they validate it according to the rules.
00:03:07.970 - 00:03:19.606, Speaker A: Okay, if there's two agents, right, agent one and agent two, will agent two actually see these things kind of appear in their chain?
00:03:19.718 - 00:03:21.926, Speaker B: No, see, you just said that there's one chain.
00:03:22.038 - 00:03:22.954, Speaker A: That's what I'm trying to.
00:03:22.992 - 00:03:40.622, Speaker B: You just popped into that mindset. There's not one chain. This is an agent centric point of view, where instead of data centric, where you're saying there is a chain which is the reality of everyone, there isn't that. And this is true of the world. We've known this. Einstein made this quite clear to us. Everything is from the perspective of an observer.
00:03:40.622 - 00:04:15.770, Speaker B: So you can think of agents as observers in the rules, making declarations or making. Seeing events, and declaring events in the world. And then what happens in the shared space is somebody seeing that they made a cryptographically signed set of movements, actions in that world, and they can verify them. So if it's something like a tweet, the only thing you're checking for is, is it the person who said they were right? Is that their identity? According to their identity, if it's a currency transaction, you may be doing a bunch of things like checking history and checking transactions that other people did to make sure that that transaction is valid according to the rules.
00:04:15.850 - 00:04:31.300, Speaker A: So let's actually say this example of transferring money, right? Let's say there's three agents. The agent one added, they send money to two.
00:04:32.150 - 00:04:48.182, Speaker B: Okay, this is beautiful, because this is right where I want to get to. In a data centric world, this is what people start to think in their head. They create an ontology of, there is a thing out there called money, and I'm going to move that physical object from one place to the other. That is the idea that we do.
00:04:48.236 - 00:04:50.786, Speaker A: Or at least we keep a record of that transaction.
00:04:50.818 - 00:05:42.746, Speaker B: But what I'm saying is this is the important thing, that if you think of the world as if you think of data as something that exists, as opposed to claims and experiences of agents, is the thing that exists. We create a world in which what we need to do is the blockchain where we need to solve the double spend problem. If you don't start with that ontology, which is what we don't do in Holochain, if you start with this agent centric ontology, what you do is you solve the problem of money a different way. You use mutual credit, in which what you say is this is my ledger and the transfer of money is not a coin that you have to see where it went and whether it was double spent or not. Instead, what you're doing is you're just entering in the ledger. I transacted, my account went down by this amount and that person's account went up by that amount. And according to the rules, I have a credit limit of a certain amount and they can validate that.
00:05:42.746 - 00:05:46.250, Speaker B: My credit limit is the way it is by looking back at my chain.
00:05:47.150 - 00:05:55.966, Speaker A: That's why I'm like, I'm just trying to understand. So I'm agent three, right? What do I query to say? How much? What's the balance of agent one and.
00:05:55.988 - 00:06:36.994, Speaker B: Two in this particular case? Well, what you would do is you would look at their chain. It depends on what you allow. So the DNA would have in it a function called balance, and then you would be able to call that function balance on a particular agent or on yourself and report it. It depends how you implement it in the particular application you do. So in Holochain, there's node to node messaging and then there's UI. Basically you can think of it as there's an internal communication mechanisms where nodes can talk to each other on that particular network. And there's also the UI facing side where the human user talks to the agent, which is the device and calls functions.
00:06:36.994 - 00:07:10.422, Speaker B: So you would end up in your application writing. If you want to be able to have call balance on any particular agent, and that's one, then you would be able to send a node message, node to node message in which you request the balance. And the balance would be you get back their chain. You see that it's a chain because it goes all the way back to the DNA and you calculate out their balance and you just see it because you can do that by either getting it directly from them or you can do other things that I haven't gotten into in the way this DHT in Holochain has linking on top of it. But now I've jumped really fast and technical and I'm not sure if that's where we want to go. I can get there if you would like.
00:07:10.476 - 00:07:13.638, Speaker A: Yeah, we'll probably get there. Yeah. Cool.
00:07:13.804 - 00:07:46.114, Speaker B: But to recap, the big thing about Hologene is that we're a way in which you can create arbitrary applications by specifying the rules of the game. In this DNA, everybody knows what the rule is of that particular game. On one network, each DNA, the hash of the DNA itself is the network hash. And so Holochain is built on thousands and thousands of networks, because you should think of each one of these microservice, they can communicate with each other through what we call bridging. There's a bunch of other technical details in there.
00:07:46.232 - 00:08:10.760, Speaker A: So for people who are like, in let's say, coming from Ethereum world, I can actually say that DNA is actually a smart contract. And then each kind of agent is an account under this smart contract which kind of tracks or like, I mean, it's not really an account, but you can see the transition of it. But the thing is.
00:08:12.570 - 00:08:16.794, Speaker B: You could look at it that way. Yeah, but in ethereum, of course, what you're trying to do is simulate one computer.
00:08:16.912 - 00:08:19.754, Speaker A: Yeah. Here it's like we're not trying to do that.
00:08:19.792 - 00:09:07.690, Speaker B: What we're trying to do is actually separate that out and understand that these computers actually are decentralized and are distributed, and that there are different contract, different sub levels. There's also different levels of security and different levels of validation that are needed in different contexts instead of the ultimate blockchain, trustless context, which carries with it a very high price. So you can tune the price of what you do to the context of the application that you're writing. That's another differentiating and interesting thing. It does mean that it pushes work to the developer, but a lot of that work is going to end up inside of libraries where you choose the level of validation that's necessary to your context, based on that context. And it'll be inside of tons of different libraries for doing different kinds of things around collision management and all these other conflict type situations that show up. All right, does this make sense?
00:09:07.760 - 00:09:17.198, Speaker A: Yeah, no, it makes sense. Cool. So yeah, let's talk about how DHT is built. I'm actually really interested in that part.
00:09:17.284 - 00:09:17.920, Speaker B: Okay.
00:09:21.090 - 00:09:26.800, Speaker A: How do you maintain the DHT, as well as how does this agency communicate with each other?
00:09:27.890 - 00:10:13.214, Speaker B: Okay, let's see. So when we started what we used, I mean, really, you could use pretty much any DHT you want, because distributed hash tables are a technology and you can use different ones. When we started, we used cademlia based and we just actually took IPFS's Lipida P and we used that in our proto version that was written in go and we got that up and running. The thing that's slightly different about our DHT and the reason why we didn't stick with that is that when you create one of those nodes, one of the entries in the chain, that's what we call them, chain entries, and you publish it to the DHT. Basically what you've done is you have an entry which has some kind of hash, and so you're publishing the content and the hash. And the entry also has a header associated with it. Right.
00:10:13.214 - 00:10:47.126, Speaker B: Because that's where the header is and the entry is the content. Because what the DHT is, is the content addressable store. What you do off of the DHT is you do gets on the hash. The other thing that we do is we allow you to publish links between onto the DHT. In which case what you do is you say, I'm publishing a link between one hash and another hash of data on the DHT. So that is how you would do. Because the thing that's hard about a DHT is finding data because it's a sparse.
00:10:47.158 - 00:10:49.098, Speaker A: There's no discovery, there is a sparse place.
00:10:49.184 - 00:11:33.426, Speaker B: So what we've allowed is this notion of creating a graph inside of a DHT, where you say there's a base, which is some hash, and then a tag and a target which is another hash. So you can use the tag to semantically say what the graph relationship is between the base. And then when you're doing a get request on the DHT, you can get the content of an entry, but you can also get a list of the links by tag. So you can find out what things are related to other things. Example, back to the Twitter clone example you may want to have follows. So you may create a well known entry that is related to your. Or you might.
00:11:33.426 - 00:11:52.282, Speaker B: Let's see what would be. So there's a more complicated way of doing this. That's a better way of doing it because you don't want to load tons and tons of. Actually, here, let's do this example. So let's do the same thing with the Twitter. So remember how the second entry on the chain. So here's the dna.
00:11:52.282 - 00:12:14.578, Speaker B: The second entry is your id, right? So if you use the hash of this id, which is just your public key, and any metadata associated with that public key, if you use the hash of this entry, which is well known, everybody can know it as the base. Then you can have followers as a tag and you can link to the identity of another agent on the DHT.
00:12:14.674 - 00:12:19.560, Speaker A: And it's like one to n or end to end. What's one to one? One to one, right?
00:12:20.090 - 00:12:40.202, Speaker B: Well, it depends on what the content is, right. Because the content could make it one to n. You could do any kind of graph you want. If you wanted to do stuff, you could put crazy things in the tags. We don't really recommend that. That's probably not the best design principle, but that way we can have discovery of concepts in your application in the distributed hash table. So that's one of the pieces that's added to our notion of a distributed hash table.
00:12:40.266 - 00:12:45.074, Speaker A: You can also, by hash of the content, query all the tags that are.
00:12:45.112 - 00:12:47.940, Speaker B: Associated with it, with that particular base. Exactly.
00:12:48.790 - 00:12:58.594, Speaker A: And just for me to understand, this tag is associated like here, or it's associated with any subsequent item as well.
00:12:58.712 - 00:13:11.638, Speaker B: The tags are always a base and a target on either end is the hash of an entry, on the other end is a hash of another entry. Because what it's for is discovery of entries on the DHT. Because remember, every particular agent is publishing to the DHT.
00:13:11.734 - 00:13:21.690, Speaker A: And you can modify this later. That's the question I guess have, because I create id and then I follow here, I want to modify pretty much this link.
00:13:21.760 - 00:13:28.670, Speaker B: We do have crud operations on links. We have delete, delete, we don't have update.
00:13:29.730 - 00:13:33.702, Speaker A: I mean, my main point is that the link itself is like a separate item.
00:13:33.786 - 00:14:18.606, Speaker B: Yes, it's a separate item that's stored that the other agent would store associated with the entry that it's also storing. Because remember, what's going on here is that, and I didn't say this in the beginning, but part of what makes this whole thing scalable and work as a scalable distributed compute platform is that in this DHT only a subset of the nodes are holding a certain number of the nodes of the entries that come in based on a nearness algorithm between their agent hash and the hash of the entry that you're trying to store. But yes, that's related to the linking where you can do a get operation on the base or on any entry hash. But you can also do a get on the links on that hash to find the other stuff that's there.
00:14:18.788 - 00:14:37.294, Speaker A: I see. And then, so I, as a node, right, let's say I'm also participating in the Twitter app. So I have a dna, I have my own id. I want to know everybody who follows me. Right? So can I query you backwards?
00:14:37.342 - 00:14:39.390, Speaker B: Pretty much no, because how could you do that?
00:14:39.480 - 00:14:41.238, Speaker A: Well, I mean, if you index it.
00:14:41.324 - 00:15:06.206, Speaker B: You could do that. So we can talk about how there's lots of different ways to manage indexing. If it's a small community, you could just create a directory and put everything on that. You could create like a hash whose key is directory, I mean, whose value is directory. And then that will be a well known thing and everybody could look at it. That's if you're creating an app for a small community like Slack, where you only have 10,000 people, that would be fine, that would be sustainable. That's getting on the edge of that.
00:15:06.206 - 00:15:41.878, Speaker B: If you wanted to do much larger scale indexing, where you're indexing content, like if it's a Wikipedia style app, then we have a pattern where we have a whole separate DNA on a separate network where nodes volunteer to be indexers. So you can have distributed indexing and then your app queries the other app, the other DNA. And when you publish, you also publish into the indexer as well. And then you can do index queries on that and you could use whatever database on the back end to be able to pull the indexing out. That's if you need large scale indexing.
00:15:41.974 - 00:15:47.930, Speaker A: But that indexing is not like it doesn't provide you as a cryptographic proof. Was the data it indexed?
00:15:48.830 - 00:15:52.522, Speaker B: No. You go back and you would find that in the DHT after you're done.
00:15:52.576 - 00:16:01.310, Speaker A: So it will tell you, like, here's a hash that, here's a bunch of hashes you're looking for, and you need to go check that this is actually like hashes that are inside.
00:16:01.460 - 00:16:13.282, Speaker B: You might get a bunch of hashes and then you go and you actually use the DHT to get the values back. You don't have to get the content back. And if you didn't get a value back, then you knew that that entry that was indexed was falsely indexed. Right?
00:16:13.416 - 00:16:23.030, Speaker A: And then, so when I get a hash, like, let's say I got this hash, I actually need to replay from the DNA to make sure that this is valid.
00:16:24.090 - 00:17:03.454, Speaker B: Depending on the context, yes, but if it's a Twitter context, does it really matter? It's been signed by the provenance of the person who did it. That's all you care about. You might need to do that. So for example, in the currency transaction one, you would do that every single transaction, you replay back to the beginning to make sure, or you replay back to a checkpoint, or you replay back to some known entry where somebody also co signed an entry with a notary. There's lots of different solutions on how you could do that, depending again on the application context for how you want to make it scalable or how many transactions per second you're expecting, et cetera, et cetera.
00:17:03.582 - 00:17:18.694, Speaker A: I see. So in theory you can either implement like a state channel where it's like just two people exchanging, then they kind of have a record going between them, or you can implement, you can actually probably implement your own consensus on top of this. Absolutely.
00:17:18.812 - 00:17:58.590, Speaker B: I mean, so we've got one of our core developers, he's been dying to have the few spare hours to go reimplement, either ethereum or bitcoin on top of holochain, because he thinks it would be a fun project. And sometimes people do think of holochain as just only state channels. That's one way of thinking about it. And one of the things we thought that would be fun is, oh cool, let's use holochain as a place to implement your state channels on an ethereum smart contract. And then we're interested to see how many things would start getting removed. Because in the end, in our experience, almost all use cases. Not all use cases, but almost all use cases.
00:17:58.590 - 00:18:09.578, Speaker B: When you do the mind flip from the data centric to the agent centric point of view, you come up with a slightly different way of solving the same problem that doesn't require consensus the way blockchain solutions do.
00:18:09.744 - 00:18:57.078, Speaker A: Well, I guess the question mainly is like getting to the same state between at some point, especially if you're dealing with money, right? You do want to make sure that this is something that everybody would also agree on. Because if you want to keep moving this, like let's say somebody sent you money before you can move this money to somebody else, you kind of want to make sure that people would agree that you have this money in the first place. Right? So this is kind of, even if it's agent centric, you at the end, care about yourself and that your payments will be accepted. And that's why the question is, depending on how you implement it, it may take a while to validate kind of all the sources of where you got this money from.
00:18:57.244 - 00:19:08.134, Speaker B: Well, and it depends on in your context, how many sources you have to track back to believe that the ledger accounts that you have are accurate or satisfactory.
00:19:08.182 - 00:19:08.826, Speaker A: Exactly.
00:19:09.008 - 00:19:24.474, Speaker B: But there's something od to me about the fact that if I want to have a cup of coffee, somebody in China needs to know that it's a valid cup of coffee. Right. Somebody here in San Francisco, there's something really weird about this only zero membrane environment.
00:19:24.602 - 00:19:42.582, Speaker A: The point here is that when you go in China and you want to buy a cup of coffee there? You want to make sure you can do it as well, right? That's where it's like, yeah, it may be like at any single point when you're buying something, you don't really need world to know. But the problem is when you are in that part of the world, you also want to know.
00:19:42.636 - 00:20:10.670, Speaker B: That's the point. So you do the validation, then you don't do the validation ahead of time. They can come back and check. That's a really different point of view than let's make everything perfect now. Right? This is the agent centric thing. It's like, oh, you're an agent, you did a bunch of things. Now let me go take a look and see if all the context of the people who did things with you, well, that matches up, right? That seems real to me right now, rather than this other way of like, let's have one hard coded reality that exists.
00:20:10.670 - 00:20:36.610, Speaker B: I think the claim that we're making, and it's really about when you have an architecture that's based on what reality really looks like, you're much more likely to get decent solutions at different scales over time. And we know that reality looks like lots of agents and lots of viewpoints playing. This is why git is so freaking awesome, because you can branch and merge. You didn't pretend that there was one code base from the beginning that has to advance.
00:20:36.770 - 00:20:41.574, Speaker A: The thing is, at the end we built GitHub and we said, this is one reality, everybody should come here.
00:20:41.612 - 00:21:11.950, Speaker B: Yeah. And do you think that that's actually the right way? It's supposed to go, I just can't wait until we watch that change, because GitHub is exactly like what AOL had. You might be too young to remember this AOL. Before there was the web, there were these rooms where there was content and it was all siloed inside of AOL and there was another silo inside of Genie. Along comes HTTP as a protocol that allows us to spread that out. It's the same kind of thing with GitHub. When GitHub turns into a protocol, I-E-A set of DNA in a game that we can play together, then we have a different space of what it means to do project management.
00:21:11.950 - 00:21:33.820, Speaker B: And yes, there is this going back and forth between the centralizing, the large scale, the one place to go look at a reality, and then back into the agent centric. And that's why we're not only agent centric, in fact, we also might describe ourselves as sociocentric. Because you say things according to the rules of what you did, but then you publish it to the community. And the community says, yes, that looks right to me.
00:21:34.270 - 00:21:41.946, Speaker A: Okay. So then the question I have is, if somebody publishes two alternative versions, what happens then?
00:21:42.048 - 00:22:07.880, Speaker B: Yeah. Or another thing they do is they publish something forward and they say, okay, I made this transaction, then I cut this off my chain and do another one. Right. Well, both of these got published to the DHT. Right? So somebody out there is going to see, wait, the same person, they check the chain and they're like, there are two things that showed up inside that chain that should be at the same place. And this is clearly a fraudulent player because I can see that that's the case.
00:22:08.410 - 00:22:29.382, Speaker A: But I mean, you're indexing everything by hash, right? So here, to one person I send this hash, to another person, I'll send this. It's both published, it's both on DHT. But as another agent that observes this, right. I'm telling him, hey, here is your data you're looking for is at this hash.
00:22:29.446 - 00:22:33.470, Speaker B: He doesn't send it. You get this hash by doing a get on the DHT.
00:22:35.410 - 00:22:43.742, Speaker A: But what am I querying by then? I'm a different agent. Right.
00:22:43.796 - 00:22:51.106, Speaker B: So you query by the hash, you get back the header. Let's actually come up with a concrete use case, because when you pay for.
00:22:51.128 - 00:22:53.490, Speaker A: A coffee, you pay for a coffee.
00:22:54.230 - 00:23:18.218, Speaker B: Okay. So I'm about to write down in my book a minus and you're about to write down a plus, right? And so I go and I say, give me your chain. No, I say, so there may be a pre negotiation phase where you tell me what the header of your chain is and I do a get and I look on the DHT. I'm going to find something different on the DHT than you just told me.
00:23:18.384 - 00:23:26.638, Speaker A: But I gave you a header, right? I gave you this, you will fetch it. This looks good.
00:23:26.724 - 00:23:27.360, Speaker B: Yeah.
00:23:28.370 - 00:23:35.938, Speaker A: Somebody else, I mean, I just went to a different coffee shop and gave them this header. They also fetched it.
00:23:36.024 - 00:23:50.066, Speaker B: Okay. No, because what's going to end up happening is that they're going to find, when they do a fetch, they will also get the headers back and that they'll see that there is a conflicting publish on the network.
00:23:50.178 - 00:24:02.700, Speaker A: So you somewhere half id to list of headers index on DHT stored because this is not content addressable. Right.
00:24:03.150 - 00:24:20.960, Speaker B: Well, so here's one of the other things that we're doing for precisely this kind of situation is we're allowing apps to do header publishing. So the header itself has a hash right. And so you can hash the header and so you can know what the headers look like too.
00:24:21.490 - 00:24:41.590, Speaker A: But how do you index the header? Pretty much I want to know for agent one, two, three. Right. What is their header pretty much without asking them. So if it's just published header, then it's indexed by the hash of this header, which is I need to know that hash.
00:24:44.760 - 00:25:31.012, Speaker B: All right. So I think the reason why I'm getting myself muddled here is because the use case isn't as exactly clear and I'm not describing it in a way that is working here. Okay, so let's see if we start again and let's draw this up and make it clearer for the use case that you're asking for. And let's also actually do it a little bit more carefully so that it shows correctly. So let's see here. Let's say that I start out, I've got my dna and I've got my id. All right? And so I have a balance of zero.
00:25:31.012 - 00:26:07.500, Speaker B: And I want to do a transaction with you. And so you've got your dna and you've got your id. And so we're going to have a negotiation phase where I say we're about to make a transaction and you say you're going to make a transaction. And so we both sign the transaction ahead of time. So we have what the content of this thing is going to look like beforehand. And then it's going to have a header in which you sign something and header in which the signature of this entry where you're minus $10 for the coffee and I'm plus $10 for the expensive coffee.
00:26:08.000 - 00:26:12.064, Speaker A: Wait, so what is the signature? So let's say this is id one. This is id two.
00:26:12.182 - 00:26:28.740, Speaker B: Okay. Right. And so then this is the content which shows this is the value of the transaction. And of course, every one of these entries has headers off of it, which have in it the fact that it has my signature and it has the hash of the header. In fact, actually, that's what's linked. Right. In any chain we always know that.
00:26:28.740 - 00:26:48.796, Speaker B: And this is a combination of both of those things. Right. Okay. So we are preparing this entry together where we knew that that was what was happening. And so I signed this here. Let's do it like that because that's the content. Okay.
00:26:48.796 - 00:27:22.980, Speaker B: So in this situation now, this got published to the DHT and we know that the rules of the DNA said that the credit limit is 100. Each of us have 100 credit limit. So you can see my chain to the bottom and you can see that I'm not overspending. I can see your chain to the bottom to know that you're not engaged in other things that I don't care about or that I don't like. And this is fine. Now we're moving to the next scenario, right, where we publish.
00:27:24.860 - 00:27:57.840, Speaker A: Now there's a third guy, id three. So he, well, let's do this the other way. And let's say credit limit is ten. Yeah. Okay, it's ten, right? So now this Guy wants to pay him as well. So he starts to negotiate from this state. So he creates a new header.
00:27:58.900 - 00:28:27.848, Speaker B: Doesn't fit. Actually, this is fun. You know what I'm going to do? I'm going to actually have you solve the problem, because from this, this is a really interesting exercise. So thinking from the agent perspective, what do you need to publish to the DHT to actually make this work? And what questions? This is exactly. What's great about holochain is that it makes you actually think about the real problem that's necessary for the exact situation you're in. Okay, so basically this is a rollback situation where the credit limit was ten. Now I shouldn't be able to go any further.
00:28:27.848 - 00:28:38.050, Speaker B: What do you need to publish to the DHT? To be able to have queried, to be able to see that this was a situation that was not according to the rules. There's a bunch of different ways to solve this problem.
00:28:40.180 - 00:28:43.744, Speaker A: What do you need to publish? So DHT is content addressable, right?
00:28:43.782 - 00:28:50.544, Speaker B: Content addressable. And you can publish headers as content if you want to. And when you get a hash, you can see what header was associated with that hash.
00:28:50.592 - 00:28:52.548, Speaker A: But you still need to get a hash, right?
00:28:52.714 - 00:29:00.184, Speaker B: Yeah. So you've got hashes, we've got a linked DHT. What do we do with the linked DHT to solve this problem?
00:29:00.222 - 00:29:12.772, Speaker A: Yeah, so I mean, if you have links, that's doable. Pretty much. You just publish a link saying, this is my last header. But you said you don't update links.
00:29:12.916 - 00:29:15.820, Speaker B: You don't update leads, you delete links and then you can add another.
00:29:15.890 - 00:29:26.510, Speaker A: Okay. Yeah. So then you put a link from your id to the latest, to the header of your chain. So this guy only accepts it after he saw that.
00:29:27.200 - 00:29:35.936, Speaker B: So then there's other ways too, if you don't like that, if you think that there's problems with network partitioning, you can also have notaries, well known notaries, if you want, in your particular well.
00:29:35.958 - 00:29:38.080, Speaker A: Known notaries is also network partitioning.
00:29:39.080 - 00:30:01.530, Speaker B: Yeah, that's right. Yeah, that's interesting. But sometimes one of the ways that we handle network partitioning is by having sentinel nodes, and the sentinel nodes tell us what part of, if that a certain percentage of sentinel nodes open. I'm inside a real network? Because in the true distributed world, you don't really know. It's always partitioned. So it's just about whether probabilistically you think that's the case and context for your application.
00:30:03.600 - 00:30:18.490, Speaker A: So just for me to the timeline here for publishing this link, though, is who is waiting for this link to actually be published?
00:30:19.310 - 00:30:21.978, Speaker B: Because this person is.
00:30:22.064 - 00:30:26.986, Speaker A: Yeah. So this person waits like he queries a link.
00:30:27.088 - 00:30:32.942, Speaker B: Remember, what happens in the end is that this is going to get published and this is going to get published. And you have the community observing this.
00:30:32.996 - 00:30:33.310, Speaker A: Yes.
00:30:33.380 - 00:30:37.294, Speaker B: So they will also see that. Okay. And they can validate it as well.
00:30:37.332 - 00:30:42.014, Speaker A: You're saying that everybody else actually should be like, checking only the people who.
00:30:42.052 - 00:30:53.570, Speaker B: Are responsible for storing this data, all of the people who are restoring, not everybody else, but the shard of the network that's responsible for the shard of the DHT that's responsible for storing that hash by its nearness algorithm.
00:30:54.150 - 00:31:01.000, Speaker A: All right, so this is not like a regular DHT. That's why I'm like, you actually have a lot of extra.
00:31:03.050 - 00:31:32.430, Speaker B: Well, it's a sharded dhtamlia. You can think of it as sharded because only a subset holds it. But we have a different DHT that we're developing because the math is really hard for calculating neighborhoods when you're using a tree and things don't look like they're in the same neighborhood from different vantage points in the tree. In academia, DHT, and we really wanted to be able to have a euclidean geometry for figuring out what the neighborhood is, rather than a non euclidean one, which is really, really weird.
00:31:32.510 - 00:31:34.978, Speaker A: So how do you do it? Euclidean way?
00:31:35.144 - 00:32:10.858, Speaker B: Well, we're developing something we're calling rrdht. It's in development, and it's interesting. We did some prototyping of it. It's not completely developed, but the basic idea works like this. If you take all the hashes of the nodes and you put them on a circle. And I might be getting this wrong because I'm not the main engineer on this, but it's pretty close to what it is, and you'll get the idea about how to do this. So if you think about any particular agent, let's put that line there as an agent, agents hash.
00:32:10.858 - 00:32:44.466, Speaker B: Then you can draw an arc on this circle as actually they should be equal in length there. Pretend that's the same. This is the arc of all of the hashes, of the entries that this agent says it's responsible for. Right. And then you have a second arc, which is the arc of all of the agents who it indexes. Right. So I know that there are other agents over here, and I index their existence.
00:32:44.466 - 00:33:28.440, Speaker B: And they have their own arcs inside and their own index arcs. And so your neighborhood is just an art, is these arcs that you're holding. And that's how you can do that. And then the other thing you do is you index some random things out to the other side so that you can get complete coverage of the circle if you can't find someone. And that's the way you can get the full connect to other things around the other side. And the thing that's really nice about this way of doing the DHT is that you can expand and contract the arcs dynamically according to what the population is in this space. This is, I think, a 32 bit.
00:33:28.440 - 00:33:34.598, Speaker B: We compress the hash down to 32 bit so we can do the math even faster. And collisions are fine.
00:33:34.764 - 00:33:39.110, Speaker A: Okay, so what is this hash?
00:33:39.690 - 00:33:46.506, Speaker B: This is the hash of the public key. Well, this is the hash of the. And this is not. No, it's not even the hash. It is the public key.
00:33:46.528 - 00:33:47.894, Speaker A: It's just the public key of the node.
00:33:47.942 - 00:33:48.454, Speaker B: Of the node.
00:33:48.502 - 00:33:52.350, Speaker A: So people can grind and try to end up in the same neighborhood.
00:33:53.010 - 00:34:21.218, Speaker B: Yeah, you can do that. But the problem with that is that it only takes one person to find out that you're a bad actor to then publish what we call a warrant and then get you blacklisted from that particular network. So, yeah, you can do grinding. There are some particular places where some civil attacks were susceptible to that in most places. But for the most part, what we see is that that would be actually really hard, because it just takes one good actor to show a bad Actor.
00:34:21.314 - 00:34:33.182, Speaker A: Yeah, but you can, in theory, crawl the current state. Right. And find, like, if there is a neighborhood, which is. But you're saying you will dynamically actually expand the circles and trade somewhat.
00:34:33.346 - 00:35:06.082, Speaker B: And then the other thing about this is that the way we're implementing this is that we have like a second layer of this where the hashes. This is another interesting thing about this DHT, where instead of the agent being. So you think of the agent as one portion and then what, it's the hash of the content. These things is what's being referred to in the arc. You can do the same thing with the nodes for discovery of nodes where the agent has this ring. But what's in the hash is the transport address as a transport address.
00:35:06.136 - 00:35:06.610, Speaker A: I see.
00:35:06.680 - 00:35:10.840, Speaker B: And so that's how we can actually also find nodes on the DHT. It's a two level.
00:35:11.930 - 00:35:15.554, Speaker A: In DHT you store all the other nodes as transport addresses.
00:35:15.602 - 00:35:30.222, Speaker B: Yeah, so we use the same pattern of a DHT for finding other agents on the node as we do for finding content. It's just two layers. So when you want to find something, first of all, you go and you find the public key of the address. And then you go and you look at the next layer down to find the transport addressport address.
00:35:30.276 - 00:35:40.062, Speaker A: And then you query that. Interesting. How does the validation happen actually?
00:35:40.196 - 00:36:30.478, Speaker B: Well, the validation happens is whenever you're doing a publish and you found out who is in your neighborhood, who needs to store it, you publish to them directly, because that's the meta rules of the game. Then they go and they run the dna on and run whatever the rules are locally on their node to see if the data that you're publishing follows. And that may involve doing gets, that may involve doing gets on the network to find out whether things are true. But there's another interesting thing we do is we have a validation package that gets sent or can be queried for during that validation phase, because what is necessary to do validation is also context specific. So you can query back the original node, you can get the full chain of the original node. You could query and see whether it fits into the rules of the game.
00:36:30.644 - 00:36:39.246, Speaker A: So how expensive is that? That sounds like pretty, I mean, if this chain been going on for a while, right, and somebody publishes another node.
00:36:39.278 - 00:36:58.760, Speaker B: On that, it could get very expensive in the context where it would get expensive, then you would do other things to make it cheaper. That would be an application, like I was saying, there would be checkpoint nodes where you summarize the state, and you know that you only have to go back that far because it's been validated by other nodes. And you can validate that, checkpoint things like that.
00:36:59.530 - 00:37:02.440, Speaker A: In theory, you can use some consensus to checkpoint everything.
00:37:03.470 - 00:37:27.470, Speaker B: Absolutely, you could use consensus, and we're not against that at all. There are some really reasonable use cases for blockchains. There are other efforts out there that have the same kind of agent centric approach. And one of the things that they end up doing is using things like a blockchain for finding nodes, just node discovery. And because you publish that to that blockchain and you go find that, that's one case that is somewhat reasonable.
00:37:27.810 - 00:37:37.730, Speaker A: State channels list, pretty much that. It's like you use blockchain as kind of your checkpoint, and then you use state channels for exchange of information between peers. This is more like generic way of doing.
00:37:37.800 - 00:37:52.860, Speaker B: Exactly. So it's turning it on its head. It's saying we start from state channels, and then if you need that, maybe that's a special case where you use it, where it's actually okay to spend that much power or that much whatever the proof of x is and whatever consequences come from that. Proof of x, context specific.
00:37:54.750 - 00:38:06.030, Speaker A: All right, interesting. Had another question about DHT, but I kind of skipped my mind. What's this? DNA.
00:38:08.210 - 00:38:32.230, Speaker B: Okay, so now it's some of the technical stuff. Yeah, exactly. So in our prototype, the original prototype that I wrote, what we did is we had two interpreters in there, because that's what I found easily in go libraries. We had a lisp interpreter and we had a Javascript Interpreter. And you could write your DNA in any one of those languages. And then it would run. Because the whole point is it just needs to be hashable so everybody knows they're running starting from the same hash.
00:38:32.230 - 00:39:08.914, Speaker B: Then what we decided is that we wanted to use. We did the flip to rust for all the reasons that one flips to rust because of its speed and its quality. And we hit the same thing that everybody hits with rust as learning curve, which was a problem. But the big deal was that we could use WASm. We could use WasMi from parity to have a generic deterministic virtual machine engine. And then we could take advantage of all the new languages that would end up compiling to WASM, which we knew would be coming down the pike. So we have a WASm interpreter that we compile everything to.
00:39:08.914 - 00:39:27.842, Speaker B: Currently, people write their dnas in rust. There's an hdk for all the basic functions that you call it hdk holochain development kit. Exactly. Yeah. I just spit this out. I am not even thinking about it. So that's our hdk, and we're looking forward to hdks in other languages.
00:39:27.842 - 00:39:39.674, Speaker B: We have one of our devs is a real Haskell enthusiast, and so she's building an hdk for Haskell. I just found out this weekend that the assembly script people have moved a long ways forward.
00:39:39.792 - 00:39:41.610, Speaker A: We're actually working with them very closely.
00:39:41.690 - 00:39:42.142, Speaker B: Are you?
00:39:42.196 - 00:39:45.280, Speaker A: Yeah. Cool. Yeah. Because we also. On webassembly. Right.
00:39:45.650 - 00:39:59.154, Speaker B: And so we're excited about that. And actually we're hoping that somebody in the community will build the webassembly hdK. We set stuff up for multiple hdks that's the way we want it to go. And that was the initial way that.
00:39:59.192 - 00:40:01.106, Speaker A: Goes, yeah, that's cool.
00:40:01.128 - 00:40:37.530, Speaker B: So we have a bunch of other stuff too. We have a testing environment that allows you to describe scenarios and create like virtual agents and then do the scenario, run the scenario, see what happens. So you basically run through this process and you create tests for that. Watch if they fail or don't fail. And so there's a whole bunch of tooling that we're building alongside everything to make it easy for folks to develop in this. And it's been pretty fun to watch. I mean, we started out with our developer, our dev camps that were online dev camps and people really hit the wall of rust.
00:40:37.530 - 00:40:48.242, Speaker B: But then each time the tooling has come up and it's like, oh, it's actually not that hard because in the end what goes into your DNA is probably ten, five, 2% of your application.
00:40:48.376 - 00:40:49.874, Speaker A: Because most of it is front end.
00:40:49.912 - 00:41:53.080, Speaker B: And like data integrity layer. Exactly. And so most of it is a front end UI place where you are assembling bunches of these different dnas together into the user interface that you want. So like we have a chat app, for example, where each one of these chains is a channel and that allows you to have really real private channels and that's all that is. And there's another chain that's a comment chain and they're linked together by a DPKI DNA, which is the one that allows you to be doing revocation and issuing of identity associated with that lets you actually create revocation keys that you can then use if you need to revoke a key, because a key gets lost and so on. And then there's a personas app that does identity stuff that you can then use across different dnas that you can say, hey, I need this little bit of Persona data that's on that chain, or I need a zero knowledge proof of that data that's on that particular chain and get a little value out of it. So from the point of view of composability, it's really fun platform.
00:41:53.770 - 00:42:09.370, Speaker A: Yeah, that's interesting. So pretty much the combination actually happens on the front end, right? Mostly because the DNA itself just describes the data transition rule for specific kind of bit.
00:42:09.440 - 00:42:20.414, Speaker B: So that is true. And there is an HDk function which is bridge. So you can have a dna that requires the existence of other dnas to be able to call across to it.
00:42:20.612 - 00:42:21.922, Speaker A: How would that work?
00:42:22.056 - 00:42:33.026, Speaker B: So there can be a function when you're running what the DNA describes is validation rules and it also describes, it.
00:42:33.048 - 00:42:35.060, Speaker A: Can require fetch other data.
00:42:35.830 - 00:43:11.214, Speaker B: Well, the other thing that it describes is what is the interface for the user interface to call into this particular DNA, right? And so if you do a function that would, if you call a function like post in your Twitter app, that function may do a call to another dna to get some value around the name that's associated with that account. Because the name actually comes from the personas app. The posting doesn't even know what name is there that comes from another app. So we can do a bridge call to the personas app to get the name, to put it into the text, for example.
00:43:11.252 - 00:43:34.774, Speaker A: But how does validation happens on the DNA side? Right? So let's say this example where you have a, let's say it's a chat, right, channel, and then you have a personas. So the validity of this message is the only one that has something from personas, some information provided from personas, right? That's what you're saying.
00:43:34.892 - 00:43:43.866, Speaker B: Well, what I'm saying is that if the DNA includes functions that are called, that actually do the addition of an entry onto the chain. Right?
00:43:43.888 - 00:43:44.460, Speaker A: Yeah.
00:43:46.590 - 00:44:08.978, Speaker B: Post. So that's a function that's available message, et cetera. So in this particular app, there would have been probably at initialization time, there would have been a time when you went to personas and you got the name or some value or an avatar. Actually, maybe this is not a good example because you'd probably end up doing that later. But the validity of that, well, it depends on what you need to validate with.
00:44:09.064 - 00:44:36.940, Speaker A: So let's say you want to post a message and you want to make sure that whoever posts a message has a Persona in the personas app. Okay, so how does this validity function looks like for the post to actually validate that another app contains this information inside the DNA? Can you fetch other items from DHT to validate? And how much can you do there, in a way?
00:44:37.710 - 00:45:13.362, Speaker B: So that's a great question. It's a complicated thing. What's going on with that is that in validation we have two different stages, because there's two different types of validation. Essentially, there's the preconditions of validation and then there's the deterministic aspect of validations. So, for example, one of the things that you might want to validate is that a particular link exists, right? But that is a nondeterministic fact. So you can't run the final validation rules until you have gathered all the information that you need. That may be nondeterministic because the validation rules themselves have to be deterministic.
00:45:13.362 - 00:45:42.798, Speaker B: And so there are two different phases of validation. And so in one, you can do fetches and you can do things like check to see if links exist. And if they exist, if the preconditions exist, then you can actually do the final validation, which will commit something into a chain. So, yes, the answer to your question is yes. I'm just giving you a little bit more context because of what's true about the world. There are preconditions in validity, and those are complicated things and they may fail. And then there are things that absolutely need to be absolutely true that are deterministic, and both of those different parts of validation are encoded into the DNA.
00:45:42.894 - 00:45:53.390, Speaker A: So then let's say this precondition fails later when somebody else wants to validate, then this becomes invalid, right? Well, it becomes invalid.
00:45:53.550 - 00:46:06.982, Speaker B: Well, they would stop validating it, but I think that's a complicated case because I think in that case you would say, no, it was valid at the time because you could see that somebody else validated it. Depending on the context, you may or may not allow that.
00:46:07.036 - 00:46:19.100, Speaker A: So who will be deciding the context? Because we're going back to this example, right? Like at some point there was a link between these guys, but then I destroyed this link, created a new link.
00:46:19.950 - 00:46:44.854, Speaker B: Well, you can't just destroy links. They don't go away forever. You can always look at the history and see if they were there. So the links are marked as deleted because it is an append only log. So you can always go back and reevaluate the context at the time that it was done. So this would be a case like somebody stopped doing something and they're not even online. You can still go and check whether other people on the DHT have that data, and you can ask for the deleted links and see what they were at that time.
00:46:45.052 - 00:46:48.070, Speaker A: How do you store links?
00:46:49.530 - 00:47:18.190, Speaker B: Okay, so now you're asking implementation questions. We have two things. We have a CAS, our content addressable store that we use for storing most everything. And on top of the CAs, we have something called an EVI, which is an entity attribute value index store, which kind of looks like a DHT with links. It's the same kind of thing mirrored inside our storage. And their evs are pretty typical data storage systems for sparse data. They've been used for medical data for a long time.
00:47:18.190 - 00:47:34.274, Speaker B: And the index is the thing that allows you to find what was the latest one by history so that you can do, like if you have a hash, you put something in. I mean, it looks exactly like that thing that I did with the post in the target. But again, now I'm really jumping into a part that may be more than what you were asking.
00:47:34.312 - 00:47:45.330, Speaker A: No, I'm actually interested. So you have links which connect, like you say you have append only ledger off links which connect pretty much to hashes, right. With a tag.
00:47:45.490 - 00:48:05.486, Speaker B: So on each individual node we use a similar pattern inside a content addressable store for storing all the data that we need to store. So we can store a link using the same pattern in our store, but there's also an index on top of that that allows us to know what was the latest one. And so you can basically, I mean.
00:48:05.508 - 00:48:12.720, Speaker A: Inside the store a previous link pretty much under the same. You store a link to a previous link?
00:48:13.090 - 00:48:49.962, Speaker B: Yeah, basically we have, let's see, we're using tombstone sets. I don't know if you're familiar with that. So there's this whole other part of how you manage eventual consistency. I didn't even mention that early on. This is an eventually consistent DHT because different parts of the network are going to get it and it will propagate over time. But in any eventually consistent state system you're going to need to have, there are going to be conflicts. And so we're building in, this isn't implemented yet, but we are planning for building in CRDTs conflict resolution data types, and there are a bunch of different data.
00:48:49.962 - 00:49:26.678, Speaker B: And so you can actually say what the rules are for how to resolve the conflict when the data shows up. And so, yeah, I'm just jumping forward a little bit. But indeed in our Eavi content addressable store, again, I'm not the person who's coded all of this. So this part I may be getting slightly wrong, but we do stuff exactly like we store something whose content is the word deleted and then on deleted, it points to all the links that were deleted, but its base is, I think that's the way they do that.
00:49:26.764 - 00:49:51.214, Speaker A: No, because the problem with any of this is that you can have a double head on the links in any append only index. Right. The problem always is like having two of append only because of either conflict or malicious attack. So that's why I'm going there. We're distilling it from.
00:49:51.412 - 00:50:12.520, Speaker B: But what you're seeing is the thing we just did here, you can do inside your content addressable store as well, because if you basically in your content addressable store on your local machine, you can do the exact same thing that we did here. You can store a link to what? The current head is the thing that's current from your experience.
00:50:12.970 - 00:50:21.660, Speaker A: But we have two sets of nodes, right, which will have different head, and then they'll update each other on.
00:50:23.150 - 00:50:30.490, Speaker B: Right. And so then you have. Wait, no, right now I was talking about a node within itself.
00:50:30.560 - 00:50:30.854, Speaker A: Yeah.
00:50:30.912 - 00:50:38.622, Speaker B: Okay, so that's not that situation. This situation is the one where you figure out using. By doing the link here. Right.
00:50:38.676 - 00:50:55.250, Speaker A: Well, I meant like, let's say you did this link here, right? And then you just sent the different link to different. You created two, like one minus ten and 10, and you created two links and you send it to different nodes.
00:50:56.630 - 00:51:32.734, Speaker B: Yeah, but remember, these things are all published and then they get watched by the other nodes. You can always do that, but the thing is, it's being validated by other nodes on the network. What would be fun actually for you is to have one of these sessions with the guy who's actually designing our mutual credit currency, who's gone through all of the different permutations of all of the different failures on this, because I just have a general knowledge of how that's done and I just always know that it's possible. And so my trick was to get you to figure it out because I knew you could. But. Indeed. But there's a lot of other, actually, there's this thing called the fini attack.
00:51:32.734 - 00:51:53.670, Speaker B: When you do neighborhood stuff, there's a bunch of other use cases. But what's interesting is from this approach of the agent centric approach, there always seems to be a solution that's appropriate for the context. So I keep saying that appropriate for the context because that's what matters so much. If we want to have any scalable, decentralized solution has to be scalable according to the context.
00:51:54.970 - 00:51:57.014, Speaker A: I'm not arguing with that, I'm just.
00:51:57.052 - 00:52:16.160, Speaker B: Emphasizing that for the purposes of our viewers, that's a key, key thing for us to know. And that's like a message that I want to keep getting across. And it's important because people will say, well, but what about blah? Yeah, that's a great question. Fantastic question. Now think about it from an agent's point of view. What about it? How do we solve that? Because that's actually the way the world works.
00:52:16.610 - 00:52:31.566, Speaker A: Yeah, I think it especially fits very well, very specific, a pretty big set of use cases. And then I think for something like payments, it is something with generic consensus.
00:52:31.598 - 00:52:47.130, Speaker B: Is just easier if you create the world and you believe that things get transferred from one place to the next. And you want that to exist in the digital world. Yes. You need that, go ahead, that's fine. If you've got a double spend problem and it's trustless, there's no membranes and you've got double spend, go do that. Great.
00:52:47.200 - 00:52:48.922, Speaker A: Yeah, but yeah, if you want like.
00:52:49.056 - 00:53:16.530, Speaker B: Twitter style or something, everything else in the world. And the other thing is the actual mechanics of doing a mutual credit. Instead of coins, it's doable at scale with the same patterns. It's just a different kind of validation that ends up happening and it's happening between the subset of people. So here's the difference. There's a lot of validation to handle these header things. There's a lot of different cases and edge cases you have to pay attention to.
00:53:16.530 - 00:53:39.580, Speaker B: But what does end up happening is you're still only doing it between a small subset of the nodes on the network. In the blockchain world, everybody has to agree for that block to get chained. So you end up having that big, long, that clock cycle. The basic pattern is that clock cycle of the appending up of blocks and creating one reality. This doesn't do this. It does the validation in the subset of the spaces that are needed.
00:53:40.430 - 00:53:56.318, Speaker A: I mean, we're doing sharding, so we are doing a subset. But yeah, in general, I agree with you actually. So the question I had was, you mentioned that if somebody observes a conflict, right? Let's say you do observe like two conflicting or simple.
00:53:56.404 - 00:54:12.042, Speaker B: Let's actually use a really benign case, which is a network partition. So somebody like, I mean, in the Twitter case you might have this where somebody says this is my Twitter handle and they say this is my Twitter handle. It was partitioned, it comes back together. You have two people have the same handles. You want to have a rule that says you can't have the same handle.
00:54:12.106 - 00:54:12.702, Speaker A: Okay. Yeah.
00:54:12.756 - 00:54:13.614, Speaker B: Is that a use case?
00:54:13.652 - 00:54:19.634, Speaker A: That's, I mean, that's interesting. Yeah, I'm more interested in non benign cases.
00:54:19.682 - 00:54:25.560, Speaker B: Well, as a matter of fact, all non benign. I think they actually match. Yeah, they're theoretically the same.
00:54:26.570 - 00:54:27.834, Speaker A: The faults are the same. Yeah.
00:54:27.872 - 00:54:30.700, Speaker B: Well, plus it's just the emotions are different.
00:54:31.310 - 00:54:38.378, Speaker A: Well, the question is, do you have a different mechanism of punishing people who are actually actively trying to.
00:54:38.464 - 00:54:40.314, Speaker B: Oh, you want me to get into that for a little bit?
00:54:40.352 - 00:54:40.714, Speaker A: Sure. Yeah.
00:54:40.752 - 00:55:47.250, Speaker B: Okay. So when you detect things that are against the rules, there's a whole layer of what we call warrants that can be issued. So if you detect something that's against the rules and you believe that it's maliciously against the rules, according to the rules, then you can issue a warrant, which is you publish on your chain a warrant that so and so is a bad actor. And according to the rules of the particular game, there may be different consequences. You may have three chances and you're out. And if the third publish of the warrant happens, or if the warrant is the publish of the evidence of the three bad actions, then what the other agents can do is you just block list that node from the network, and that can get pushed pretty far down the stack in the implementation that we're working on, where it can get blocklist all the way down to the transport layer, because we can pass that into the networking module, which says, okay, anything coming from this node is likely to be bad by the rules of the game. So you use the same system and other people can verify and validate the warrant as well, because you have to do that, because you could publish a bad.
00:55:47.320 - 00:55:50.178, Speaker A: This is on application per application?
00:55:50.264 - 00:56:08.298, Speaker B: Pretty much, yes, it's per application. But notice that if my node got hacked and I've got ten applications, because they end up getting multiplexed on the transport layer, then it's likely that the other ones are hacked too. And it depends, again, context wise, you may say no. And also. Yeah. Do you see what I'm saying?
00:56:08.384 - 00:56:33.666, Speaker A: Yeah, I'm just trying to understand if one node that has like ten applications running, right, one of the applications is malicious, but all of the other users of this application will ban it. But then other applications, does the information between applications propagate or not? That's kind of the question. You said you have like an extra layer, right, of address.
00:56:33.848 - 00:56:42.434, Speaker B: Where's an eraser? Oh, there's an eraser. So let's go to a little architectural design maybe. Is that useful? Sure.
00:56:42.472 - 00:56:43.060, Speaker A: Yeah.
00:56:43.910 - 00:56:45.478, Speaker B: Is this the way we want things to go?
00:56:45.564 - 00:56:50.520, Speaker A: I mean, it's the way you want it to go. And I'll just ask questions.
00:56:54.490 - 00:57:54.714, Speaker B: We have this thing called a conductor. And the conductor is you can think of it as the virtual machine host, or what is it, the hypervisor? You can think of it, but that way. And so it basically runs instances of different dnas, right? And it manages any bridging that needs to happen between them. And then the other thing that it does is it also spins up an instance of our networking code, right? And the networking code can therefore it can multiplex between different dnas so that we don't have to throw open a port, because you may have 100 or more. And so then it goes to another conductor with a networking side, and that goes in like that. And then that communication can go to the different dnas. Right.
00:57:54.714 - 00:58:04.666, Speaker B: So your question is if one of these is a bad actor because this particular agent got compromised, you probably do want to shut the whole thing down. Right. And it's this network.
00:58:04.778 - 00:58:24.078, Speaker A: There's two layers of the ids I'm more interested in. So let's call DNA one, DNA two. DNA one, DNA two. And this has DNA two. And it's connected to this guy. So this one is malicious. So this guy bans him.
00:58:24.078 - 00:58:37.240, Speaker A: Will he propagate to this node? Three, the information that this node is malicious, even though this guy. They are connected. Right. But they're connected about the.
00:58:38.170 - 00:59:07.010, Speaker B: So basically these networks. Remember when I said that there was two different layers of the transport? So there's the node id, which is at this level. There's the DNA id that's at this level. There's a transport id that's at this level. So per DNA, you can make a decision about that. Do you want that to like, is your warrant DNA specific or is your warrant node specific? I'm pretty sure we're going to have to do that. I mean, a lot of this part isn't complete in the development of it because this is the phase that all of us are in.
00:59:07.010 - 00:59:24.594, Speaker B: But there are cases where indeed, right. If this one is malicious, you would propagate that this network has been compromised. And that's a good thing because then this one is saved from whatever other malicious things that might be happening that way. I mean, it could be denial of service attacks which are DNA independent.
00:59:24.642 - 00:59:33.820, Speaker A: Yeah, exactly. That's why I'm asking. I mean, pretty much if I would be implementing this, I would actually have just dna zero, which everybody runs, which is kind of the.
00:59:34.830 - 01:00:06.040, Speaker B: Well, so the DPKI, the distributed public key infrastructure, DNA is similar to that because pretty much everybody needs to have a way of revoking keys and getting keys back in. And there's a bunch of other things that will be like that. There's the App Store or the DNA store, which publishes other dnas. And most people will be likely running that. Most people will likely be running some version of a Persona's DNA. There's a bunch of things that a lot of people will be running. It's just like on your Unix box, how many processes show up that everybody's running similar.
01:00:08.650 - 01:00:11.560, Speaker A: All right, any other part we should cover?
01:00:12.730 - 01:00:22.970, Speaker B: This is just fun. We just ramble around inside the space of code. I don't know what you're. I mean, you've got experience of what's been valuable to your viewers. I'm happy to answer any questions and ramble into wherever.
01:00:25.150 - 01:00:29.866, Speaker A: I guess one thing is like, what's the incentive structure here in general?
01:00:30.048 - 01:00:52.690, Speaker B: Well, the incentive structure here in general is the most important incentive structure. You host your data, you have a very, very high incentive to host your data, plus a little bit more to be part of the game. So you're shard of the other space. It's deeply communal in that sense. Like you have all the incentive in the world to host your data. So you have all your data, it's on your chain.
01:00:53.270 - 01:01:07.334, Speaker A: So pretty much you're just saying because it's a distributed storage, you store your data in it and then you. What's the overhead on, like I store 1gb, how much of other people's data.
01:01:07.372 - 01:02:08.966, Speaker B: I'm storing depends on the game you're playing, right? So you choose the game and it's up to you to decide whether you want that or not. If you're doing Wikipedia, how much do you need to. Actually, somebody in our team did a little bit of math about how many. If you store one page of the Wikipedia and how was it? I think we needed something like everybody needs to store three pages of the Wikipedia. And then if there were a million users or 5 million users, and then the Wikipedia is stored. So times five, times ten, overhead for almost every single app, let's even say it's two orders of magnitude, you're pretty much done. And of course, you know, it'll depend on the application that you're running, right? How much of it? I mean, there are plenty of applications where everybody will store everything because you're running an application with a small team that you want your calendar and your shared hack mds and your shared spreadsheets.
01:02:08.966 - 01:02:13.086, Speaker B: Everybody shares a copy of everything and that's fine. That's it. Yeah.
01:02:13.108 - 01:02:26.900, Speaker A: The question is mostly around if it is actually used for data storage. Wikipedia is a good example, which is like, it is a relatively large data set.
01:02:28.310 - 01:03:11.270, Speaker B: It would be difficult if it was the Internet archive, which I found out is in the petabytes. That's big. And also if you were trying to do a YouTube, if you were trying to run a YouTube app, well, you know that everything you would do here you would do. We actually had somebody sharding up video and writing a DHT in which the chunks of the video were distributed around and then could be pulled down and reassembled just like any webtorrent type thing. I don't know how that would go and might scale actually really beautifully because you have micro channels instead of thinking that there's all of YouTube there. There's micro channels of YouTube and people store the part that's important to them. I think it scales, actually, really interestingly.
01:03:11.370 - 01:03:22.530, Speaker A: Yeah. And I mean, normally overhead is like five x. Anyway, Google stores it in three data centers and one data center stores two more copies.
01:03:23.850 - 01:03:28.930, Speaker B: Right. So here you may have even higher redundancy.
01:03:29.090 - 01:03:38.840, Speaker A: Yeah, I mean, here you have higher redundancy, more question of higher overhead. Like, redundancy comes with overhead. Absolutely. Yeah. All right. Yeah, it's really cool. Really interesting.
01:03:38.840 - 01:03:40.890, Speaker A: Yeah, I think we're good.
01:03:40.960 - 01:03:41.322, Speaker B: All right.
01:03:41.376 - 01:03:44.186, Speaker A: Yeah. Thanks a lot. Yeah. It's really nice meeting you.
01:03:44.208 - 01:03:45.130, Speaker B: Nice to meet you as well.
01:03:45.200 - 01:03:49.658, Speaker A: Check out Holochain, I guess. What's the best resources to learn?
01:03:49.744 - 01:04:24.214, Speaker B: Well, you can always go to holochain.org. You can go to the GitHub repo GitHub slash Holochain. There's hundreds of repos in there of different parts of the project. I think Holochain Rust is the main repo where core is being built out of right now. And you can always go to Holo host, which is the big app space that the premier use of Holochain. That is what launched the Holo token. And the idea behind that is to connect the current web to a world where all of us are doing only this.
01:04:24.214 - 01:04:30.246, Speaker B: And so it's a hosting app built on top of Holochain. You can look at that at Holo host. Enjoy.
01:04:30.428 - 01:04:31.140, Speaker A: Yeah. Thanks.
