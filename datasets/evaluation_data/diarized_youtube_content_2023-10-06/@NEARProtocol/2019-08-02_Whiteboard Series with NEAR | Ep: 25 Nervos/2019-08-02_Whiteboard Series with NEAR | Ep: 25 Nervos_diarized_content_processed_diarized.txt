00:00:04.490 - 00:00:13.182, Speaker A: Hello, everybody. This is Ilya from near with a special from Shanghai. This is Hai chao from nervous. And we're going to talk about how Boston nervous is.
00:00:13.236 - 00:00:13.902, Speaker B: Yeah, sure.
00:00:13.956 - 00:00:16.862, Speaker A: So do you introduce yourself and then we can start giving?
00:00:16.996 - 00:00:17.246, Speaker C: Yeah.
00:00:17.268 - 00:00:45.580, Speaker B: Thank you. So, my name is Hai Chao. I'm a researcher at Nervous foundation, and we are working on this protocol called Nervous, which we think will be like an infrastructure protocol for the future, crypto economics. So it's kind of like a vision that in the future, we will have tokens on public blockchains to represent all kinds of assets, like security. And once we have that.
00:00:48.510 - 00:00:49.018, Speaker C: We will.
00:00:49.024 - 00:01:26.466, Speaker B: Have a better transaction experience. We have a lower transaction faith, which means we have better liquidity for these assets and make our economic society more efficient and finally make this world a better place. So that's kind of the vision we are trying to achieve. And what we are doing is to build a foundation protocol for that, which is called nervous. I'm just reading here. So nervous, pronounced as nervous. So the nervous is actually a set of protocols.
00:01:26.466 - 00:01:28.680, Speaker B: It's not just only one protocol, right?
00:01:31.690 - 00:01:32.150, Speaker C: Yes.
00:01:32.220 - 00:01:33.254, Speaker B: We will illustrate that.
00:01:33.292 - 00:01:33.880, Speaker C: Maybe.
00:01:36.810 - 00:02:17.714, Speaker B: Just draw people like this. Okay, so this is the nervous protocol. So at the center of it, there is a core called CPP. So this thing here, the CPP here is actually the public blockchain. This is a public blockchain protocol, and ground is CPB. There are different L2 protocols, such as, like payment channel or stational, or like plasma settings or the ZK Uaps, different L2 systems. And this one is a foundation.
00:02:17.714 - 00:02:56.820, Speaker B: The core is called CPP, which stands for common knowledge base. I'll just write it here. Common knowledge base. So, yeah, so what we are building is not just public blockchain, but a set of protocols, including a layer one public blockchain, but also has all these L2 systems. So I think you are familiar with this, right? Yeah. So in our opinion, that layer one is kind of like a verification system.
00:02:58.230 - 00:02:59.194, Speaker A: Like a settlement.
00:02:59.262 - 00:03:42.450, Speaker B: Yeah, it's like a settlement or verification system verification. And there, too is for competition or generation. So generation of state of proofs. So the L2 system basically do the calculation and generates cryptographic proofs and send it to the layer one system, and layer one system do the verification and return the result to a L2 system. So this is basically how these two system works together. And currently we are building CTB, the common knowledge base, which is a public blockchain.
00:03:43.830 - 00:03:44.146, Speaker C: Yeah.
00:03:44.168 - 00:04:17.130, Speaker B: So why it's called common knowledge base? Ask our CEO. So we have a lot of names, including this one, there's a lot of mysterious stories behind names. So today I'm going to focus on the technology. So overall, this protocol has many similarities to bitcoin protocol. Basically it's a blockchain. So I should join blockchain here. So just a lot of blocks.
00:04:17.130 - 00:04:45.570, Speaker B: And in each of the block there are two parts, there's a header and there are a lot of transactions. Typical blockchain structure. And as I said, it's very similar to bitcoin. So the transaction structure has two parts.
00:04:47.430 - 00:04:47.746, Speaker C: Yeah.
00:04:47.768 - 00:04:52.130, Speaker B: Input and outputs.
00:04:57.830 - 00:04:58.146, Speaker C: Yeah.
00:04:58.168 - 00:05:28.000, Speaker B: So they have two parts, input and output. So in the bitcoin case, what you have here is Utxo. So in this case you have two input Utxo and two output Utxo. But in our case, in commonage base, the difference is that instead of Utxo, what we have here is something color cell. So this is another name.
00:05:30.770 - 00:05:31.520, Speaker C: Yeah.
00:05:33.750 - 00:05:37.906, Speaker B: So cell is like the job of cell is like the job you get.
00:05:37.928 - 00:05:38.500, Speaker C: Go.
00:05:39.030 - 00:06:40.020, Speaker B: But the difference is that by utilizing cell, we want this to have a smart contract because we want it to interact with this L2 system. So it should have some advanced capability to verify proofs that the bitcoin cannot verify. So in this case, we use this structure to enable it. So what is this character? Just as comparing Utxo cell. Yeah. So utensil has to have two parts, basically two parts. There's a log and there's invaluable, just say value here.
00:06:40.020 - 00:07:19.650, Speaker B: And so this is how the UK. So you are familiar with this, right. So basically here the lock defines the ownership of this ukexo. So whoever can provide kind of a script key to unlock this lock will be able to use this utxo as input of another transaction. And that's unlock. And the value here indeed is how much bitcoin does this utxo represent? So if this is represent time. So to compare with cell has four parts.
00:07:19.650 - 00:07:38.964, Speaker B: Similarly it also has a lock here to defend the ownership of the cell. And also similar to value, it has another scene called pc here. And along with this too, there's a.
00:07:39.002 - 00:07:39.590, Speaker C: Data.
00:07:42.280 - 00:07:45.460, Speaker B: And a tap.
00:07:47.240 - 00:07:47.700, Speaker C: Yeah.
00:07:47.770 - 00:08:15.040, Speaker B: So I will scroll through these four bars to make you understand this. So lock is just like a log here. Yeah. And the capacity is kind of like a value of Utah code here, but the capacity actually constrained the size of the cell. So what does it mean is that the capacity should be equal or larger than the length of these four views.
00:08:15.540 - 00:08:20.624, Speaker A: So if I were that you pay with tokens for this storing data.
00:08:20.742 - 00:08:21.408, Speaker C: Yes.
00:08:21.574 - 00:08:24.450, Speaker B: So that's the part right.
00:08:31.160 - 00:08:31.668, Speaker C: So if.
00:08:31.674 - 00:09:18.176, Speaker B: You add it into a formula, then the capacity, the value selling capacity should be equal, larger than the length of data field, length of f field plus length of the lock view. So it should be larger than that. And also we have data field here. So data field here is what makes this whole thing different. Data is like you can store architecture but it is stored on chain. So it's actually part of the world state of this blockchain. So that's because common knowledge base, because you can store common knowledge in this data field and it can be stated or arguing code, that can be, the code can be later loaded into virtual machine object to be executed for realizing all kinds of verifications, getting to them.
00:09:18.198 - 00:09:19.504, Speaker A: Later, I got to show how it works.
00:09:19.542 - 00:10:06.290, Speaker B: And the tab, so tap here is to define what kind of cell is this. So you can only represent speedcoin. But ideally on smart contract platform we want to issue different kinds of tokens, not as bitcoin, so as we can use a cell to represent. So we want to realize that to use a cell to represent different kind of tokens. So tab is a script, it's also script to define what kind of tokens that sell represent. So it may contain some rules or regulations on how this sale can be spent. Maybe this is the part that should introduce how the transaction verification works.
00:10:06.290 - 00:10:33.500, Speaker B: Take a picture. Yeah, I'll just draw another transaction here. So let's say this one has one input and one output.
00:10:40.350 - 00:10:41.210, Speaker C: Lock.
00:10:41.710 - 00:10:50.940, Speaker B: One lock, two, one, two later.
00:10:54.930 - 00:10:55.680, Speaker C: Yes.
00:10:56.050 - 00:11:42.606, Speaker B: So this is a transaction. So when this transaction is sent to the blockchain, the compound space, they will first be verified upon the blockchain products like they need to verify if the sum capacity of input is larger than the subcapacity of output because you cannot double spend it. Also it should verify if the format is right according to the vertical level rules, and then it verifies the ownership of the input by verifying the logistics here. So what's going to happen is that we will have a VM here and.
00:11:42.628 - 00:11:46.842, Speaker A: Then you also have signature attached to the production.
00:11:46.986 - 00:11:47.726, Speaker C: Yeah, exactly.
00:11:47.828 - 00:12:55.040, Speaker B: So this parameter, we actually call it witness. Yes, it's witness, just like the same witness also in the transaction manual data. So this is like the VM we have. And what's going to happen is the log script here will be loaded into the transaction VM stack and together with this fitness, and there also should be kind of like a key along with this lock to unlock this key. Basically in most of the case it's a public key to unlock this thing and all this will be loaded into a vm and be executed. And if this program returns code zero, which means it has been successfully executed, which will mean that this verification is successful. And a different thing here is that the script is actually not stored in d cell.
00:12:55.040 - 00:13:03.090, Speaker B: The data, the script data is not stored in this cell. Starting here is only a pointer that points to another cell.
00:13:04.500 - 00:13:05.250, Speaker C: Yeah.
00:13:05.700 - 00:13:29.000, Speaker B: Another cell that stores the script. So it's like null cell here's maybe like cell a, cell b. And the cell here should store the verification scripts in a theater part. And when this one is verified, it actually has a pointer that points to this one. And this data will be loaded to the VM.
00:13:30.700 - 00:13:31.412, Speaker C: Yes.
00:13:31.566 - 00:13:42.220, Speaker B: Along with also the business here. So this is how the input ownership is verified.
00:13:46.960 - 00:13:47.710, Speaker C: Yeah.
00:13:49.760 - 00:13:52.928, Speaker B: So here we can define different kind of.
00:13:53.014 - 00:14:00.812, Speaker A: Yeah, most of them will be the same, like few regular types. So you don't need to store every one of them.
00:14:00.966 - 00:14:01.670, Speaker C: Yes.
00:14:03.320 - 00:14:30.430, Speaker B: So one of the feature of our blockchain here is that when I say verification function, it doesn't imply only one kind of verification function. So on bitcoin you only have sec p two, five, six, k one. And on ethereum you have only the KTC. Yeah, that's one function. You can use a signature verification here.
00:14:36.480 - 00:14:37.230, Speaker C: Yeah.
00:14:38.240 - 00:15:09.432, Speaker B: So the point is that they only have only one kind of verification function. But in our case we can use different kinds of. And actually you can implement your own periphery functions in this way because this vm here is actually. Yeah. And it's based on large. So it's based on an instruction set called the risk level. You heard about it.
00:15:09.486 - 00:15:09.992, Speaker C: Yeah.
00:15:10.126 - 00:15:40.156, Speaker B: So this is an instruction set that originally designed for hardware. It's very low level. It's a very low level instruction set. It has around, in our case it has around 100 instructions. So we implement one of these simulators and machine to execute all kinds of verification functions in it. And the benefit is that in this way you can, because our vision is to make it compatible with all kinds of L2s.
00:15:40.188 - 00:15:40.636, Speaker C: Right.
00:15:40.758 - 00:16:11.112, Speaker B: And for these L2s they may have different proofs to be generated. For example, the decade web would have some decay proof for the layer one to verify, but the existing layer 1 may not be compatible with these kind of proofs. So in that case you will need to make it do hardcore. For example, the Ethereum is trying to enable interoperability with zcash.
00:16:11.256 - 00:16:11.708, Speaker A: Okay.
00:16:11.794 - 00:16:12.092, Speaker C: Yeah.
00:16:12.146 - 00:16:26.148, Speaker B: And zcash has a big to be function, but ethereum doesn't matter. So it needs to have a hard work to implement this kind of function in ethereum to enable this, but I.
00:16:26.154 - 00:16:32.096, Speaker A: Think it's more for gas. Usually it's because you can implement.
00:16:32.208 - 00:16:57.980, Speaker B: Yeah, exactly. Yeah, you can implement that in EVM, but it's the only way to do it now is to hard work. But in our case this mine has a very low level done to the hardware in certain set. So you can implement those cryptography privatives on chain.
00:16:59.360 - 00:17:04.270, Speaker A: It would not cost. I have more questions.
00:17:06.180 - 00:17:48.760, Speaker B: Yeah, so this is how it works. So first verify the protocol rules and then the log script, and then verify the test grid here. So if this might represent a different kind of token, that these two should have the same task, at least the same tab script. Hash and tab script will be loaded into the VM later along with the information. So tab script here has access to the transaction information. So you can have access to this one. And this will be loaded into the VM and it will be verified in the VM to say this transition of data is valid.
00:17:48.760 - 00:17:54.312, Speaker B: Yes, exactly. So this is how the token, customized.
00:17:54.376 - 00:18:01.068, Speaker A: Token being so like for people who come from Ethereum, this type script will be ERC 20 rules.
00:18:01.164 - 00:18:01.616, Speaker C: Yes.
00:18:01.718 - 00:18:08.580, Speaker A: Data will be actually one ownership of one. It's one balance of one user pretty much.
00:18:08.650 - 00:18:09.252, Speaker C: Yes, exactly.
00:18:09.306 - 00:18:20.180, Speaker A: And then this will be like transferring from balance from one person to another. For example, this will be calling the claiming script the type script. And then we'll transform.
00:18:23.180 - 00:18:27.210, Speaker B: Yes, except that there's a little bit difference.
00:18:29.180 - 00:18:31.124, Speaker A: Yeah, that's why I'm like a trend map.
00:18:31.172 - 00:18:34.250, Speaker B: Yeah, it's based on account model. And this one is more like.
00:18:36.960 - 00:18:37.276, Speaker C: We.
00:18:37.298 - 00:19:14.330, Speaker B: Think this one has a little bit benefit in terms of working with Dr. Two, especially the plasma, because in this way, the ownership of the state is explicitly defined. So I only sell, which means I own this token, no matter if it's native token or DRT 20 token. I can own it directly. But in the case of account model, I'm kind of sharing the who smart contract with a lot of other, and that can have some problems in terms of transferring between their one and plasma. So there are some researchers coming to.
00:19:16.060 - 00:19:17.770, Speaker A: I have some questions about that.
00:19:20.060 - 00:19:27.470, Speaker B: Let's see. So yeah, this is basically how the works.
00:19:29.200 - 00:19:32.216, Speaker A: Otherwise, I mean the, the whole block.
00:19:32.248 - 00:19:35.084, Speaker B: Structure and this part is similar, it.
00:19:35.122 - 00:19:39.120, Speaker A: Just seemed to what they use for consensus.
00:19:39.860 - 00:19:42.368, Speaker B: Yeah, the consensus is proof of work.
00:19:42.454 - 00:19:43.090, Speaker C: Okay.
00:19:44.660 - 00:19:48.710, Speaker B: And we call it, this might be a bill.
00:19:56.840 - 00:19:57.590, Speaker C: Here.
00:19:58.120 - 00:20:26.588, Speaker B: And this is what our consensus call. It's uncity maps. So uncity stands for nuclear consensus. So it's based on the original Nakamoto consensus using bitcoin. But we based on modification to that. So basically we adopted a dynamically adjusted block interval and we have a targeted uncle block rate. And in this way we think we have a better bandwidth usage efficiency.
00:20:26.684 - 00:20:27.184, Speaker C: I see.
00:20:27.222 - 00:20:44.020, Speaker B: So the bandwidth can be better used by lowering the unbox. We think that in this way we have better super rate than the original dynamic. But still this is a natural, it's a prop up work manufacture.
00:20:45.400 - 00:20:49.940, Speaker A: And what would you use for the manufacture?
00:20:50.700 - 00:20:59.880, Speaker B: We are designing a new manufacture and we are trying to be acid neutral. Yeah, not like in current, not against.
00:20:59.950 - 00:21:00.730, Speaker A: It, but.
00:21:07.120 - 00:21:09.710, Speaker B: Yeah, just another touch function.
00:21:12.320 - 00:21:12.972, Speaker C: Cool.
00:21:13.106 - 00:22:04.590, Speaker A: All right, so I'm not sure whether I'm about that more, but that's actually. So I see the value of, yes, the ownership of specific token or specific balance in some token. But the benefit of account model is that you can actually do have a shared data among all the users. So how do you handle shared data? Let's say the token, the transition actually requires checking that only once a day in the whole system people can transfer this token. I want to launch my token that only can be transferred once a day across the whole system.
00:22:10.530 - 00:22:58.970, Speaker B: I mean how's the token? So here's infinity token, right? In the case of ERC 20 token, the type here will refer to a script. And that script is actually stored in another cell on chain. So if I issue a token, I will first implement, deploy a cell that fits the boost, and then deploy a cell that has all the test pointing to the rule cell. That's how it works. And if I want to do a transfer, I would just use that cell as an input and transfer it to like 100 people, maybe 100 outputs that 100 people can chose.
00:22:59.310 - 00:23:07.650, Speaker A: All right, so the question is how do we implement a contract which has a shared state?
00:23:07.720 - 00:23:08.098, Speaker C: Right?
00:23:08.184 - 00:23:17.780, Speaker A: So this is very good design for kind of storing user data, user to some data. But many contracts require a shared state.
00:23:19.030 - 00:23:44.250, Speaker B: So a shared state, I think the trick is just to define the ownership by the lock script. You can either define the log script that cannot be unlocked by anyone, or you can define a log script. You can define no log script, so anyone can alter the data. But maybe at the same time you can define test script to constraint how the data can be altered.
00:23:48.430 - 00:24:14.946, Speaker A: Let's say I have Ilia token, which is code, but I also would need a. And then the data is the shared.
00:24:14.978 - 00:24:19.558, Speaker B: Data, and then this is code.
00:24:19.724 - 00:24:24.022, Speaker A: So when I want to transfer, I need to bring this cell into my.
00:24:24.076 - 00:24:24.870, Speaker B: Document.
00:24:27.950 - 00:24:39.066, Speaker A: And then together both of this code and this code will be loaded and they will have access to both this data and this data, and they will be able to pretty much do.
00:24:39.088 - 00:24:40.582, Speaker B: A mission of both things.
00:24:40.656 - 00:24:41.326, Speaker C: Yes.
00:24:41.508 - 00:24:53.006, Speaker B: And maybe there's another layer of complexity here that because when you are updating cell, we updated the pointer, the hash of this thing.
00:24:53.028 - 00:24:54.798, Speaker A: We use a hash of this pointer.
00:24:54.894 - 00:25:03.334, Speaker B: But if you alter it, hash changes, which means you will need something like a name system to find. To find this name.
00:25:03.372 - 00:25:03.910, Speaker C: Yes.
00:25:04.060 - 00:25:06.214, Speaker B: This one report to a name. That name.
00:25:06.252 - 00:25:07.320, Speaker A: Point to this.
00:25:10.730 - 00:25:16.966, Speaker B: Little bit complicated. Hopefully it will be covered as a mandate.
00:25:17.078 - 00:25:17.802, Speaker C: Okay. Yeah.
00:25:17.856 - 00:25:19.610, Speaker B: To make the whole thing easier.
00:25:21.630 - 00:25:26.800, Speaker A: All right, cool. So let's talk about capacity in general.
00:25:30.130 - 00:26:20.660, Speaker B: So, in our blockchain, there is a token called CK bets C bets. And this one actually represents the piston itself. So, which means that if you have 160 bats, it actually means you have a cell that you can unlock and this cell has 100 psd. And this actually also means that you have some state storage on chain. You can use it because you can use cell to store on state. So the CPAP also represents the state storage storage space on chain.
00:26:21.000 - 00:26:21.460, Speaker C: Yes.
00:26:21.530 - 00:27:03.376, Speaker B: So the token equals the state storage on chain. So when you are trying to develop an application, you will need to consume some resources from the blockchain. This includes computational resources like battery resources, and also storage resources. And accordingly, you need to pay for these resources, particularly. So in the case of Ethereum, you are paying the competition resource with gas fees. And also you are paying storage with gas fees. So in our case, the difference is that you pay for competition with the tokens one time, but for the storage, you're not paying for it.
00:27:03.376 - 00:27:11.604, Speaker B: But you are kind of, granted, it's kind of like staking. You need to hold it.
00:27:11.642 - 00:27:11.940, Speaker C: Yes.
00:27:12.010 - 00:27:33.720, Speaker B: If you store data in this one, then you cannot use this one as input anymore because that will destroy the data. So basically, you need to stake 100 cp tokens to use 100 bytes of data on chain. And this is not enough because it's not paying anything.
00:27:33.790 - 00:27:34.216, Speaker C: Right.
00:27:34.318 - 00:28:06.950, Speaker B: So the way we pay is that while you are holding this thing, the value of this token will be inflated. So there will be constantly, constantly generate new coins to inflate the value of the tokens. So by holding it, the value is actually inflated. And that part is actually paid to the manners because the new tokens are going to the manners who are providing this conversation. What's the difference? Right? Why?
00:28:08.760 - 00:28:11.560, Speaker A: Actually, I think this makes sense.
00:28:11.630 - 00:28:12.250, Speaker C: Okay.
00:28:13.900 - 00:28:24.908, Speaker A: The way I analyze these things is actually whatever the rate you have by amount of bytes, like byte cost.
00:28:24.994 - 00:28:25.244, Speaker C: Right.
00:28:25.282 - 00:28:29.068, Speaker A: And then you can actually see the cost that they're actually paying.
00:28:29.154 - 00:28:36.944, Speaker B: Yeah, exactly. The benefits is like one ethereum has a stage ramp proposal going on.
00:28:36.982 - 00:28:37.568, Speaker A: Yes.
00:28:37.734 - 00:28:46.032, Speaker B: The benefit for this one is that you don't need to worry about launch ramp. In my rank, user experience will be.
00:28:46.166 - 00:28:54.390, Speaker A: Better, but this requires way more talking to stick because pretty much, let's say, what's your inflation rate?
00:28:58.440 - 00:28:59.008, Speaker C: Yes.
00:28:59.114 - 00:29:17.628, Speaker A: So inflation is 10%. So what it means is if you want to pay two miners, like $10, you actually need to pull $100 for a year. Yes, that's pretty much what it means.
00:29:17.714 - 00:29:18.396, Speaker C: Yes.
00:29:18.578 - 00:29:23.692, Speaker A: And this is like, pretty much, you require ten x the amount of money.
00:29:23.746 - 00:29:25.070, Speaker C: That you need to hold.
00:29:26.420 - 00:29:38.396, Speaker B: This is not how it's calculated. Blockchain is an open market, so there's actually no price being calculated in the dollar.
00:29:38.428 - 00:29:38.764, Speaker C: You may.
00:29:38.822 - 00:29:54.044, Speaker A: There's always a price, right? Yeah. We may hide it by the market, but with the price, let's say I want to store a gigabyte of data for a day, we can actually calculate the price, assuming the price of token.
00:29:54.112 - 00:29:55.044, Speaker B: Will not be changing.
00:29:55.092 - 00:29:56.104, Speaker C: Right. Much. Yes.
00:29:56.142 - 00:29:57.576, Speaker A: We can actually calculate the price.
00:29:57.678 - 00:29:58.330, Speaker C: Yes.
00:29:59.900 - 00:30:35.376, Speaker B: And you can also measure how much profit you can get from your application and to compare it and see if you should use this storage. Yeah, user storage. So this is only one part of it. And on the chain we also have something called normal stock. So this one is like a bank. So normal stock. So as developer, you have option to develop applications with your tokens, but also you have options to deposit your tokens into this normal stock.
00:30:35.376 - 00:31:10.190, Speaker B: And in this way, you are not using the resources of blockchain, but you still want to hold the tokens. So in this way that the newly generated tokens will. Part of the newly generated tokens will go to the holder of the nervous doll dice. So people who put their tokens in the noble star will get rewarded from the newly generated. So let's say we have four block, there's 100 tokens generated, let's say 100 and let's see, 100.
00:31:11.380 - 00:31:16.956, Speaker A: Just to reduce how much people get inflated by just holding buckets.
00:31:17.068 - 00:31:17.500, Speaker C: Yeah.
00:31:17.590 - 00:31:26.196, Speaker B: Some people just want to put it on, use it to develop or just go to the original secondary market.
00:31:26.298 - 00:31:26.852, Speaker C: Yes.
00:31:26.986 - 00:31:30.388, Speaker B: So if 50% store 50% of a.
00:31:30.394 - 00:31:31.956, Speaker A: Person store their tokens in the north.
00:31:31.988 - 00:31:53.172, Speaker B: Dollar and 30% use it for development and another 20% maybe they're trading it on the secondary market. So the 100 token will be distributed accordingly. So 50% will go to these people, 30% will go to miners.
00:31:53.236 - 00:31:53.920, Speaker C: Yes.
00:31:54.110 - 00:32:04.720, Speaker B: And yeah, actually 50%. So 50%, 3% will put manners. And these parts.
00:32:08.740 - 00:32:09.890, Speaker A: That'S what I'm saying.
00:32:10.840 - 00:32:11.590, Speaker B: Exactly.
00:32:14.680 - 00:32:16.420, Speaker A: They just have like a shelter.
00:32:18.360 - 00:32:23.960, Speaker B: Yes, because that's also contributing to the stability of existing.
00:32:26.860 - 00:32:27.464, Speaker C: Yeah.
00:32:27.582 - 00:32:32.090, Speaker A: So how does execution feed works?
00:32:35.100 - 00:32:45.692, Speaker B: Yes, so this one here, it's based on hardware. It's a hardware circumstance. So it can be measured in cpu circles.
00:32:45.756 - 00:32:46.272, Speaker C: Okay.
00:32:46.406 - 00:32:49.212, Speaker B: So we just use the cpu circles.
00:32:49.276 - 00:32:49.890, Speaker C: To.
00:32:53.700 - 00:32:59.680, Speaker B: Kind of like gas. So you just calculate how much cpu circles does it take for executing the script?
00:33:03.000 - 00:33:13.380, Speaker A: For me to understand a bit more about, you have an interpreter of risk. You don't actually run risk five on a hardware directly.
00:33:14.300 - 00:33:14.664, Speaker C: No.
00:33:14.702 - 00:33:17.770, Speaker B: This one is like a simulator. On simulator or making.
00:33:18.780 - 00:33:24.430, Speaker A: It actually has some overhead, which is probably pretty.
00:33:26.160 - 00:33:26.968, Speaker B: EVM.
00:33:27.064 - 00:33:38.500, Speaker A: The things are expensive in EVM. Not because EVM is like, because EVM is interpreter of the bytecode. So it actually has the overhead.
00:33:38.600 - 00:34:05.748, Speaker B: Yes, in that aspect it's similar to. Well, I mean by overhead you mean it's slower. Yeah, exactly. But that's not really necessary for blockchain. Blocking is already slow enough. It doesn't need to have a very high competition, in our opinion. It doesn't really have a very.
00:34:05.834 - 00:34:09.624, Speaker A: But my question is, why then risk five, right?
00:34:09.662 - 00:34:11.604, Speaker B: Because if you still use an interpreter.
00:34:11.652 - 00:34:24.990, Speaker A: You could have used like, I mean, we use webassembly. A lot of people using webassembly. And it is from perspective of generalized platform webassembly so far showcase that.
00:34:31.360 - 00:34:31.724, Speaker C: Maybe.
00:34:31.762 - 00:35:15.536, Speaker B: I should not compare webassembly here. I would just say our consideration here. So we think that the support, as I said, there are circles and the relative side of different. For different distractions. The circle closed relation between different distractions is more clear than the one in EVM. Because in EVM the way you calculate the gas code is basically by running that instructions for a thousand times and calculate comma ten. Just do it according to the.
00:35:15.718 - 00:35:23.810, Speaker A: So you just say like, because first five is hybrid instructions. You say each instruction is one cycle and then.
00:35:26.260 - 00:35:39.552, Speaker B: Not exactly one cycle, but the relation between the cycle codes, the relation between these different instructions are more clear, more reasonable, but better too.
00:35:39.626 - 00:35:55.544, Speaker A: Is it true about the interpreter that you use? Because let's say I take it with five, I implement my own interpreter. In my interpreter, the relation between instruction time can be different than, from what it's supposed to be like on fiber.
00:35:55.592 - 00:36:22.640, Speaker B: Level, yes, but compared to polymer is different, but on the same level, on the same operating system, the difference each instruction should have. Like for example the sum, let's say sum post two and let's say subtract one, maybe. So this relation is kind of fixed by the circle specific circles.
00:36:23.560 - 00:36:35.796, Speaker A: My point is that you don't really run the cpu cycle instruction here, right? You don't actually compile it into assembly and run it directly. You actually have an interpreter.
00:36:35.908 - 00:36:36.570, Speaker C: Yes.
00:36:37.020 - 00:37:27.560, Speaker A: What did you, what language is rust? Okay, so let's say rust has some overhead drive. So, yes, some in theory takes two instructions, but the compiled rust interpreter code actually will take up one. Actually, you have interpreters, you actually have like a switch here on a command, and then based on each command, you actually execute things. This switch is actually not counted. That's just what I mean. The reason why DM is like measuring time this way is because of this thing. The overhead of interpreter is actually greater than the instruction.
00:37:27.560 - 00:37:30.440, Speaker A: That's what we think an instruction itself.
00:37:30.510 - 00:37:34.088, Speaker B: Should be in some cases, as you.
00:37:34.094 - 00:37:36.508, Speaker A: Said, in our case, we still need to do experiments on this.
00:37:36.594 - 00:38:01.990, Speaker B: You can't just use the cv surface directly. We have some experiments on it, and there will be talk on the battery. Samysh also. So this is one of the benefit also is risk five.
00:38:03.240 - 00:38:03.700, Speaker C: Yes.
00:38:03.770 - 00:38:11.830, Speaker B: Maybe just comparing with this structure, we can implement arbitrary cryptographic primitive function to execute it.
00:38:12.360 - 00:38:13.060, Speaker C: Yeah.
00:38:13.210 - 00:38:49.444, Speaker B: And the benchmark shows that the performance is not a bad, I mean, I'm not sure about that or something, but for our virtual machine, the SeC P K one algorithm takes around 90 seconds to do once, which I think is like 110 times slower than one from the original operating system. That's the data I got from our.
00:38:49.562 - 00:38:50.516, Speaker A: We can look into it.
00:38:50.538 - 00:38:51.110, Speaker C: Yeah.
00:38:52.280 - 00:39:03.300, Speaker B: The point is that we sacrifice some of the performance in change of the flexibility. So you can enable this kind of crypto algorithms on the blockchain.
00:39:05.400 - 00:39:46.416, Speaker A: Okay, so what you said, pretty much. So I have a transaction, I do the lock and capacity. So the question that I have is I send this transaction. So this log, let's say, actually be pretty complicated. You said I implemented my own crypto function, maybe like, is it, so when does this log gets ran and who pays for it? So I send this transaction out, I send it to network, it gets added to Memphis.
00:39:46.448 - 00:39:47.030, Speaker C: Right?
00:39:49.480 - 00:39:52.100, Speaker A: Do you execute log on? Accepting.
00:39:53.880 - 00:40:18.060, Speaker B: The log here will be, I'm not sure, actually. Maybe after Manpool, maybe before Manpool it will be, the lock here will be, the transaction will be sent to the manpool, and we will first verify the protocol. And yes, before it's entering.
00:40:19.620 - 00:40:47.610, Speaker A: So pretty much it means like everybody on the network will run my log code that I have. But then if it fails, right, you will not subtract. My capacity will not charge me. So I can actually put really complicated code that runs for 1 second into the log function. Yeah, but transaction that will just fail. To.
00:40:49.420 - 00:41:12.670, Speaker B: Me you're talking about the. Let me see, the transaction fee is paid in the way that the difference. And that part will be. Let me see.
00:41:13.700 - 00:41:17.728, Speaker A: Usually you charge that when you actually accept the transaction into the block, right?
00:41:17.814 - 00:41:18.450, Speaker C: Yes.
00:41:20.500 - 00:41:26.550, Speaker A: Before that. And like it fails, you will not include this into Manpool at all.
00:41:28.600 - 00:41:54.620, Speaker B: So there's a man pool and the transaction through our system to the man pool. And CF has definitely done that. Yes, you're right. So it should be verified when it's getting to a block.
00:41:57.200 - 00:42:25.064, Speaker A: So there's this type of thing like there is a proposal, for example, that is called, and they actually declined this proposal from Vitalik because there was no good way to charge for it. Because indeed you can write like a huge piece of code there, which is executed before you can charge. Which means you can actually block all the nodes capacity, just verifying blocks even before getting.
00:42:25.182 - 00:42:36.410, Speaker B: I see what you mean. So that might be a little bit different, I think on this part. Is there some deformation check. This is format check.
00:42:42.000 - 00:42:48.060, Speaker A: So you will include into the block transactions that may not pass the block.
00:42:49.520 - 00:42:54.110, Speaker B: Yeah, you can spam. Actually I'm not sure about this.
00:42:55.680 - 00:43:27.932, Speaker A: That's interesting part, because we also working on how to work around indeed having a walk that's fully dynamic and allow you to pretty much access data. Let's talk else a little bit more. I really said you have adaptive broadcast, how that works?
00:43:28.066 - 00:43:28.668, Speaker C: Oh yeah.
00:43:28.754 - 00:43:30.780, Speaker B: So that's fucking terrible.
00:43:36.160 - 00:43:58.980, Speaker A: I think we can clean them. Actually in general, in my head, the blockchain is two pieces, or like this kind of stuff. One is state transition and one is actual block. And they can be actually discussed totally separately, because you can actually swap state transition and you can swap blockchain most of the cases.
00:44:03.340 - 00:44:11.044, Speaker B: So this one here, you're familiar with compact, compact block.
00:44:11.172 - 00:44:11.850, Speaker C: Yeah.
00:44:12.780 - 00:45:35.860, Speaker B: So a block everywhere has two transaction zones. One is for me measures and we also include, but not so block just the. Yeah, this is an error. And for the transaction it will need to be first be proposed to the network. And it only can be committed, which means be valid after it is proposed for, let's say the block. So the transaction can be proposed here in lockdown and it can only be accepted after. This is not example.
00:45:42.810 - 00:45:43.560, Speaker C: Yes.
00:45:47.530 - 00:46:21.240, Speaker B: So main idea is that we want to reduce how many times a transaction should be broadcasted in the network. In the case of bitcoin, it should be broadcasted twice. First it should be sent to all the node. The transaction itself should be sent to all nodes and then it is sent again. So in our case, how should I draw it?
00:46:26.700 - 00:46:27.690, Speaker C: Like this.
00:46:38.240 - 00:47:17.400, Speaker B: So this is node. So node April 1, send a short int. This is a short. And B would check if it already has transactions. And if it does not, it will request the transaction from a and then it will download the transaction to b. But if it already has a transaction, it will not double. So this is idea of reducing the bandages.
00:47:17.400 - 00:47:27.324, Speaker B: Transaction transfer time is reduced and there's a lot of details here.
00:47:27.522 - 00:47:37.540, Speaker C: That's. Yeah.
00:47:37.610 - 00:48:42.648, Speaker B: Also the onco block should be included in the inner block to add an indicator for calculating what is the average overall network ongo block rate. There should be a target on the block rate set in the protocol. On the block there's app book for currency bars, maybe stand for a lot of blocks. And in each of the app book there should be the number of blocks in each apple is adjusted according to the uncle block rate in the last apple. So if the uncle block rate in the last apple is larger than the target block rate, then the block numbers in this epoxy will be if it's larger than decrease number of blocks.
00:48:42.744 - 00:48:43.004, Speaker C: Yeah.
00:48:43.042 - 00:48:47.640, Speaker B: Because the network is kind of secretion is not that good. So it increased the block.
00:48:47.800 - 00:48:48.844, Speaker C: Yes. And.
00:48:48.882 - 00:49:01.330, Speaker B: And that's how the block interval jacket. And this is how the transaction is circulated. Yes. It's kind of random thing.
00:49:05.640 - 00:49:07.190, Speaker A: What is this for then?
00:49:09.720 - 00:49:20.392, Speaker B: Actually this is also part of the. So it's proposed that it only proposed a shot transaction id.
00:49:20.526 - 00:49:21.672, Speaker C: Okay. Yeah.
00:49:21.806 - 00:49:39.050, Speaker B: And just needs to. Actually I'm not that sure here, but I think it just needs to follow the transaction id to be proposed to network and maybe I should.
00:49:44.560 - 00:49:45.164, Speaker C: Yeah.
00:49:45.282 - 00:49:55.244, Speaker A: So they just have header. They just send this compact block.
00:49:55.292 - 00:49:55.456, Speaker C: Yeah.
00:49:55.478 - 00:49:56.492, Speaker B: This is a compact block.
00:49:56.556 - 00:49:56.880, Speaker C: Yeah.
00:49:56.950 - 00:49:58.370, Speaker A: And then they play it.
00:50:07.360 - 00:50:08.110, Speaker C: Yeah.
00:50:09.520 - 00:50:17.280, Speaker B: Check another YouTube video. I'm really not sure about it yet, but this one is for the targeted.
00:50:17.700 - 00:50:18.432, Speaker A: That makes sense.
00:50:18.486 - 00:50:19.090, Speaker C: Yeah.
00:50:23.780 - 00:50:26.796, Speaker A: So I as a minor, when it generates this block.
00:50:26.828 - 00:50:27.024, Speaker C: Right.
00:50:27.062 - 00:50:29.972, Speaker A: And I will do all of the uncle block that I've seen.
00:50:30.026 - 00:50:31.284, Speaker C: Right? Yes.
00:50:31.402 - 00:50:32.740, Speaker A: So what if I don't?
00:50:33.560 - 00:50:34.900, Speaker B: There will be rewards.
00:50:36.120 - 00:50:39.428, Speaker A: I get more rewards for including uncle blocks.
00:50:39.604 - 00:50:42.372, Speaker B: Yes, it's just like the uncle block rewards.
00:50:42.516 - 00:50:45.050, Speaker A: But uncle block rewards are rewarding other guys.
00:50:46.140 - 00:50:58.570, Speaker B: No, let me see.
00:51:00.460 - 00:51:07.180, Speaker A: I mean here, like if I like as a minor, so that's not the same rewards.
00:51:07.260 - 00:51:07.504, Speaker C: Right.
00:51:07.542 - 00:51:19.380, Speaker B: So in this case, let's see. So let's say the block goes up here and you man a new block.
00:51:19.720 - 00:51:20.470, Speaker C: Here.
00:51:22.520 - 00:51:38.884, Speaker B: And you want your block to be on the main chain. And in this case, you should include this one as your uncle block because this one is proposed as someone else. This is uncle.
00:51:38.932 - 00:51:39.530, Speaker C: Okay.
00:51:40.060 - 00:51:41.156, Speaker B: This is uncle.
00:51:41.268 - 00:51:44.350, Speaker C: Yeah. Actually.
00:51:46.880 - 00:51:48.380, Speaker A: Not an arrow.
00:51:49.600 - 00:51:50.350, Speaker C: Yeah.
00:51:53.760 - 00:51:57.580, Speaker A: So you're saying there's an incentive for me to do this because of Alcantra?
00:51:59.140 - 00:52:02.530, Speaker B: Yeah, I think that's the case. But detailed design.
00:52:06.100 - 00:52:08.684, Speaker C: Yeah. Yes.
00:52:08.742 - 00:52:21.060, Speaker B: This part is, I think these people get. Yeah, but how much and how is distributed?
00:52:23.580 - 00:52:26.836, Speaker A: Is there any benefit for me to not include?
00:52:27.028 - 00:52:30.680, Speaker B: Of course there should be. Otherwise there's no incentive.
00:52:31.500 - 00:52:44.830, Speaker A: But also, even if I do have incentive to improve them, but is there any incentive for me to try to trick the adaptive time to actually, is there more blocks produced and get.
00:52:45.920 - 00:53:12.500, Speaker B: We were talking about selfish manning. So one of the designing target for our consensus property is to make the selfish manning attack nonprofit low. And the details will be on our YouTube channel nose network. And there will be our researcher here talking about this in detail. The conclusion is that selfish money, in this case, by sending a bug, trying to automate another bug is not profitable.
00:53:12.660 - 00:53:13.370, Speaker C: Yes.
00:53:16.380 - 00:53:49.056, Speaker A: We'Re saying that pretty much uncle blocks are not included in the chain weight. I guess maybe it's like a non topic question, but for everybody who actually uses uncle blocks, ask why not use uncle blocks as part of your, why not order them? So if you pass these blocks, why not include them for the logic of blocks? And then you might try to get.
00:53:49.078 - 00:53:50.290, Speaker B: You include this one.
00:53:51.240 - 00:54:36.720, Speaker A: Let's just say you have few blocks using this block. Right now. It knows about this one. So in theory you can actually, let's say this is block one, block two, block three, block four, you can actually execute. Or two, three, even though it's not a block that's not on the main chain because you are aware of it and you include it in your block, you can actually execute the transactions. And then this way uncle blocks actually become useful now and participate. You can now sample transactions a little bit more and get a little bit more superpower.
00:54:38.580 - 00:54:44.060, Speaker B: It depends on the transaction fee. How's the transaction fee structure?
00:54:44.140 - 00:54:52.804, Speaker A: Yeah. How can distribute the transaction? If they would sustain, then it doesn't matter if you can actually see the transaction.
00:54:52.852 - 00:55:10.232, Speaker B: Yeah, as you said, there's going to be a large intense piece for the manning and improvement model to determine should I improve the transactions or should I include it as a pretty much it?
00:55:10.286 - 00:55:10.696, Speaker C: Yeah.
00:55:10.798 - 00:55:20.210, Speaker A: All right, cool. Thanks for checking the video out. And we are like, you guys are leaving much stuff, I guess soon.
00:55:20.900 - 00:55:24.000, Speaker B: Yeah, we already have a testnet, testnet running.
00:55:24.070 - 00:55:24.352, Speaker C: Okay.
00:55:24.406 - 00:55:32.304, Speaker B: And you can mine on it. And the main net will be launched in the q four this year, which is very soon.
00:55:32.502 - 00:55:34.720, Speaker A: Check out their website and YouTube.
00:55:35.460 - 00:55:36.770, Speaker C: Thanks. Thank you.
