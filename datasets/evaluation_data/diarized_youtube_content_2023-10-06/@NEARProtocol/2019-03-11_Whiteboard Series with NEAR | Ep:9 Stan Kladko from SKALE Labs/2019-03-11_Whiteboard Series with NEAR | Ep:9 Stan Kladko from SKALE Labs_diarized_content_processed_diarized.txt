00:00:03.770 - 00:00:15.662, Speaker A: Hi everybody, it's Ilya from near and we're here with Stan from scale to talk about how scale scales Ethereum. Stan, you want to introduce yourself and then we can dive in?
00:00:15.716 - 00:01:07.438, Speaker B: Okay, just a couple of minutes, tell you guys about myself, because then you'll better understand what I'm interested in and what kind of things scale does. So I'm the CTO of scale, but my history started when I was still in the high school. I did lots of mathematics, physics. There's probably many children in the former Soviet Union. Matrixal, I would say like a neurod in a sense that I did lots of science, so I did physics. When I was in high school, I participated in different competitions in meth and physics. Then I studied at the physics department in Ukraine, did phd in physics again, like theoretical physics in Germany.
00:01:07.438 - 00:01:39.606, Speaker B: Then I was working at Los Alamos National Lab in New Mexico, in the states, and then at Stanford University. All was about physics. So mathematics, physics. And then at some point I was at Stanford, and at that time was close to the first bumble. Everyone was doing like startups and making lots of money and excited. And I moved from academia to more like startup life. Pretty much for my entire life I was doing startups, different types of startups.
00:01:39.606 - 00:02:31.970, Speaker B: So I built a startup which was started by professor Dan Bonnet at Stanford. It was called Ingrid networks, and then they raised about $50 million total. That was a network encryption device. So that time people needed to encrypt stuff, and we started as encrypting websites, but then we pivoted to database encryption and created this hardware books, which was used at banks to encrypt databases. And at some point the startup got acquired by a company called Safenet, and now it's still a pretty well selling device. So by Safenet, they're selling it to banks. If you go to a bank as a database and there's some information in the database, there's a very significant chance that it's encrypted using hardware books.
00:02:31.970 - 00:03:26.878, Speaker B: So after that I actually started my security lab, and this lab was doing research together with the US government and also certification with the US government. So we certified different types of crypto, starting from software, crypto software to hardware. So we worked on things like Mozilla browser, Crypto Library, another crypto library, which is called OpenCL. We worked on crypto chips from different companies such as KVM Networks, Marvel, all kinds of crypto. And in all of those cases, we tried to understand whether a particular mathematical algorithm conforms to government standards, whether there are any types of vulnerabilities. So it was very interesting kind of work. And then I was working in this crypto lab for a while.
00:03:26.878 - 00:04:29.374, Speaker B: And then after living for many years in Silicon Valley, I got seed funding for a startup which was doing Wi Fi security. And I kind of got back to Ukraine and hired people there. And it was a product, a software product which secured large Wi Fi installations. So our product got installed in many places, such as London Underground and Thames river in London, in New York City, in Manhattan, in the former telephone buses in San Francisco, city of San Francisco, city of San Jose, shopping malls. It was pretty good product, and we ended up selling this product to a telecom company in the UK, London. And after that I was looking to do something else. So I went to vcs, and at that time I knew some vcs, so I knew Mike from Floodgate, Mike Maples, and I knew Rick Thompson from Sydney.
00:04:29.374 - 00:05:09.998, Speaker B: Amateurs. So we were thinking what to do, and we started doing big data. So we did like a big data platform and build a product, but we were competing against similar platforms by Google, and also AWS had a similar data platform. And it was very hard for us because like a small startup, you're like, wow, here's my big data platform. But it's like Google and it's Amazon. So it was not doing well. All the technology was doing well, but competing against very large companies was not thinking about putting down the startup or doing something about that.
00:05:09.998 - 00:06:09.134, Speaker B: But at that moment, all of the crypto revolution, it was, I think, in 2017. So all of the crypto stuff suddenly started happening. And we went back to our investors, to Mike Maples from Floodgate and to rip Thompson from Signia, and they said, yeah, you guys have to, you know, this big data stuff and crypto, and you have to go into this crypto space. And that's then they kind of started to learn, understand what problems exist in this crypto space and how we can find the product market fit, how we can actually find something that people needed. So we started researching Ethereum and the scalability problems and this and that, and then we realized, I think as many people, that definitely the scalability is a problem. So transactions are expensive on easer also takes time to finalize. So typical Ethereum transaction.
00:06:09.134 - 00:06:57.966, Speaker B: If you want to make sure it's actually okay, you wait maybe a minute, two minutes. If you don't want someone else to come and kind of reward that chain. Yeah. So we kind of were thinking and thinking about it and we kind of just have a scalability problem and we talked to our investors and investors, yeah, do this. And then we started to kind of. First we understood the problem and then started to understand the product market fit, what should we do? And so we made several decisions, and one of the decisions we made was to focus on ETH ecosystem. So instead of creating our own blockchain, we decided to create this product, this complementary network, which kind of works with ETH, 100% compatible.
00:06:57.966 - 00:08:01.442, Speaker B: Because we saw all this momentum like hackers and people and coding and using these languages like solidity and EVM, we saw lots of excitement. So we had this theory that it's like JavaScript, if you guys remember, when the first browser was released, there was JavaScript, which probably wasn't the perfect language, but there was so much momentum in hiker community for programmers and stuff, that people kind of kept on modifying JavaScript. And although companies like Google for instance, like Google tried to come up with a different language, there was this language, for instance Dart from Google, which was way later, yeah, later, but they couldn't actually get momentum. So what ended up with Javascript is now typescript from Microsoft. So Javascript kind of took this more like evolutionary approach, and dart kind of still exists, but market is more kind of attached to JavaScript. So that's what we are betting on. That's what we told investors.
00:08:01.442 - 00:09:07.610, Speaker B: So that's really what we focus on, on speeding up eth while being still eth compatible. So when we decided this, then the next step was to decide how do we do this. And the solution that we have is pretty straightforward. We have the side chain. So then there's like eth main chain, let's draw like this, like Eth Mainnet, and we have our side chain. And let's say we have some number of computers, servers on this side chain, and this thing is proof of stake chain, which is like ETH compatible. So we test it to make sure it works with remix and truffle and metamask and all of this stuff.
00:09:07.610 - 00:09:44.230, Speaker B: And then obviously we also have to somehow connect the two. There has to be some connection here. And then an important decision which we also were thinking about. Principal thing was miners. There are some networks which are mineable and some networks which are not minable. Mineable means that paid people for putting servers in your network, participating in your network. So for instance, ETh is mineable, right? But for instance, EOS is not so much mineable because you cannot freely join EOS.
00:09:45.370 - 00:09:47.430, Speaker A: You can delegate yourself, you can delegate.
00:09:50.270 - 00:10:36.674, Speaker B: Right? But it's not like St th at a high level. What we realized is that the project mining is where your money goes, the money that you print. Because in mining, in many cases, you print money, you introduce inflation, and you print it out of the thin air. So this money has to go to people who actually grow your network. So you have to produce this natural feed where you print money. But you don't just give it to people who don't care about your network. You really want to simulate people who care, who promote your network.
00:10:36.674 - 00:11:28.486, Speaker B: And if you find this direct symbiosis, the network starts to grow. And so if you look, for instance, eth mainnet, right, it's not so optimized in this way. So miners, for instance, get paid, right? So you get paid for mining. But then in the change main net, there are also 10,000 nodes, which are more like altruistic guys, right? They do lots of work. They get blocks, they store them, they run vm, they respond to requests, but all of those nodes are not actually getting paid. And there is lots of tension now, on the Ethereum mainnet, where these people are saying, okay, we're running this full node, but we are not getting paid. So we cannot increase our computational resources, cannot increase our storage.
00:11:28.486 - 00:12:10.418, Speaker B: So in our network, we are trying to find a more natural payment scheme where everyone that does something in our network is somehow getting paid. And if we can find this way, then the network is going to grow. This is kind of very principled thing as far as the economics. But the economics becomes really hard because these guys do lots of stuff. So they store files, they respond to requests, as you probably guys know, in th, there is call requests where the state of the blockchain doesn't change, but they just get some information. They spawn the requests. They do storage, they do computation.
00:12:10.418 - 00:12:42.746, Speaker B: So we need to be able somehow to pay good people and not to pay bad people. And this problem is not only our problem, it's for every utility network. Totally. Yeah. So, for example, we met these people from a network called lifetime. It's people who do like video streaming, and they pretty much have the same problem, right? I want to pay people that include video for me, and I don't want to pay people who are actually byzantine or bad stuff. Right.
00:12:42.746 - 00:13:42.658, Speaker B: The way we solve this problem in our network, because it's a complex thing, we introduced this notion of, we call it decentralized quality of service or decentralized SLA service level agreement, where let's say we have some number of servers in our network. By default, each of them gets the same bounty at the end of each month. So we pay them monthly, but we need to somehow measure performance of each of them. And if the server is misbehaving, we don't pay, right? So in the first iteration of our network, we're going to take a very simple formula. And the formula is that we have a larger network. And so if you are a server, every month you have 21 guys, other servers from the same network, randomly assigned to you. So it's like everyone is watching everyone.
00:13:42.658 - 00:14:23.130, Speaker B: So at the end of the month, these 21 guys report on me and say, okay, sten server was okay, the latency was okay, it was responding to requests, scanning the metrics. And if every metric measured by these 21 guys is above the minimum we require, we pay this particular server bounty. And then if one of the metrics goes down the average metric, right, then we don't pay the bounty. But then now there are 21 measurements. So let's say this guy is getting measured by its peers, and at the end of the month, let's say you measure latency.
00:14:23.210 - 00:14:26.510, Speaker A: So how does it prove the information that you have?
00:14:26.660 - 00:15:06.522, Speaker B: So let me give you the example. Let's take a very simple mathematical example. So let's say this guy is like 21 other guys. This guy push latency, right? At the end of the month, each of the 21 guys is actually reporting average latency that this guy measures. So you actually have like this line, and on the line you have 21 points. So let me give you the algorithm that we are going to have in the first iteration of our network. Not saying that's the perfect algorithm, but it's the simple formula that we are going to start in the first iterations.
00:15:06.522 - 00:15:58.926, Speaker B: The formula is now, very important thing is, in this proof of stake systems, raster mathematical assumptions. So we always assume that less than one third m of the guys are bad. And then that's something which is assumed in many proof of state networks. All of our servers have the same stake, and we assume that on the chain, less than one server of them are bad. So then we have this. What do I, what we do in this case? On the left we drop one six, and on the right we drop one six, because these are the most outliers, these are the most measurements, which kind of off the average. And then we take medium, you're moving.
00:15:59.028 - 00:16:01.230, Speaker A: High percentiles, and kick in medium.
00:16:01.650 - 00:16:44.954, Speaker B: And then somewhere here, there's this line, this like standard. So at the end, this is the found. And then if this metric is more than the standard, the metric is could be latency, could be response to API calls. You can create all kinds of metrics. What we plan to have, we're going to start with a simple metrics measuring script, but then we'll know what's going to happen. There could be all kinds of bad things that bad people may try to use to fool our network into paying them salary work. So this script is actually going to be dynamic.
00:16:44.954 - 00:17:02.020, Speaker B: And so when there will be governance in our chain and then it's three months from start, we see a particular bad behavior, we can always add additional metric to the script. And then this is kind of a way to fight, to fight.
00:17:03.510 - 00:17:08.114, Speaker A: So I have two questions here. First of all, how does this 21 actually get selected?
00:17:08.162 - 00:18:19.914, Speaker B: Okay, so let me go into this part. So in many cases in our network we need randomness. And actually it's kind of a hot topic in the community, right? And we actually tried all kinds of stuff and thought about all kinds of stuff. And how do we create this random thing? At some point we were really excited by an algorithm which is called VDf, verifiable delay function. There is this algorithm called VDF. And the idea is that a number of nodes, let's say even one node, you know, submits this function BDF, which takes a long time to calculate, but once it's calculated, it takes short time to verify. So let's say the function VDF takes ten minutes, right? And what you do, one guy, for example, provide your random number r, and then the sheep for the random, and then the seed for the random number generator becomes like PDF of R.
00:18:19.914 - 00:19:27.826, Speaker B: And the idea is that this guy used to provide things really fast, and so he's not able to calculate PDF, and that's why he doesn't know what the result is. So although I'm providing a random number, I'm not able to know what the result is going to be. So I'm not able to fool the system, influence the system. So there are different types of ways to use PDF, but the fundamental problem that we encountered with PDF is that PDF is this function, which let's say takes ten minutes to calculate, right? The problem is that if you build a function like that in software on intel processor. Exactly. So that's what we faced. So it may run ten minutes on intel, right? But if you do, ASIC may run like 10 seconds, who knows? Right? So because of that, this entire business with vgfs require you to have this ASIC, and this asics don't exist now.
00:19:27.826 - 00:20:09.262, Speaker B: No, Asics like that. Ethereum foundation recently announced they're going to be building this asics, and maybe even open sourcing this code for asics. So it may be that a couple of years from now is going to be something that you'll be able to buy easily and incorporate your network. But since now this stuff is not available, it seems like we need to release pretty much our network. In the summer of this year, we're not able to use vds. So after many sad moments, because we really like this entire mathematics, we decided it's unusable for us. In 2018 19, we pretty much like killed this stuff.
00:20:09.262 - 00:20:54.880, Speaker B: So instead of VDF, we're using pretty much the only other algorithm which is working. And I'll tell you guys about this algorithm. So this mathematical notion, which is called common coin, and it was introduced by mathematicians many years ago and was not used much for anything. But now, suddenly, this blockchain, this whole, like, mathematics is used. And the idea of common coins is that you have like, m people, m people. Somehow we need to derive the random number. And you know that, let's say as an example, you know, that less than one third of these guys are better.
00:20:54.880 - 00:21:59.922, Speaker B: So what you want to have is an algorithm for collective random number derivation, where each of these n guys somehow creates a piece of something, like a symmetrical, obscure thing, and send it set to all other guys. And ultimately, when I get all of the pieces, I kind of glue the pieces and create a random number. Very important thing is that this requires at least one serve over n guys to participate. So bad people cannot just install a number, because there has to be at least one good person in the system, and the random number is unpredictable. So if you require one third of guys, then the bad guys cannot influence, because it's kind of aggregation of entropy. The resulting entropy is kind of the sum of everything. So even if in a group there's one good guy, when the entropy is aggregated, the bad guys are not able to predict or pre influence the stuff.
00:21:59.922 - 00:22:53.602, Speaker B: So then there's only one algorithm, pretty much, which is good enough to solve this problem. And this algorithm is called VLS signatures. So this algorithm was derived in about 2001 by three people. So there is a professor, Dan Bonier at Stanford, and there's another assembly, that's his PhD student, and another guy. They were thinking about this really interesting symmetrical algorithm, where normally all of us using signatures, blockchain will use signature. Typically a signature means that I have a private key, and then someone gives me information, Ilya gives me information. Inside this information is the private key, and Ilya has my public key and can verify this.
00:22:53.602 - 00:23:40.494, Speaker B: So this is like used everywhere. Ecommerce, you go like Gmail, like all of this public private is used now a threshold signature, something which they call threshold signature. Threshold signature is a bit of a kind of improvement on this technique where I have m guys, I have like ten people, let's say. And to create a signature, it's a collective thing. So let's say six out of these people need to sign a piece. And then when the signed pieces like bring them together, you have the signature as a result. So the interesting thing is the interesting mathematical properties.
00:23:40.494 - 00:25:01.806, Speaker B: So you have the signature s, right, of a message. And the way I derive a signature, I have my key, so I sign my piece, and then out of the remaining nine people, I don't care if five people send me their pieces, I kind of grew my piece and the five pieces I got from them and I get this s. But the very intriguing mathematical property of this s is that no matter which of those people, which six subset of six, I get out of ten, the result is going to be the same, which helps to prevent against bad people, because one thing which bad people can do is to withhold stuff. They don't have to send me an incorrect signature. If they're like four bad people, they could just send me anything at all. And then my protocol loses something, which is called live business. Liveness means that the action has to complete, right? But in this example, if six people are good and the signature requires six out of ten, no matter what the bad guys do, including like not saving their signatures to some people, sending to another, whatever happens, it's guaranteed that the good people will be able to glue and every good person is going to have the same result as.
00:25:01.806 - 00:25:19.582, Speaker B: And since s in general looks like a pretty random number, this s provides very much like this common coin. So it's a random number which is derived by everyone, known to everyone, and can be used then for purposes.
00:25:19.646 - 00:25:21.060, Speaker A: What are you using to sign?
00:25:22.070 - 00:25:57.162, Speaker B: So that's an interesting question. So depending on the application, you could sign different. Just need a random number, right? Let's say you have a block. Typically you need to have a random number to block. So your blocks are like 012345. And then you can use all kinds of modifications, improvements, and to anywhere in our network. When we need a random number, we can take, these are all nodes in our network, or subset of nodes.
00:25:57.162 - 00:26:00.190, Speaker B: And we always use this VLA signature.
00:26:01.090 - 00:26:03.870, Speaker A: The threshold signature requires a setup.
00:26:03.950 - 00:26:11.620, Speaker B: Right. That's another interesting question. Thank you. Let's talk about setup, which is totally another set of.
00:26:11.990 - 00:26:20.742, Speaker A: That's pretty much the biggest problem with structural signatures is the setup is quite complex. Totally in the original paper was very.
00:26:20.796 - 00:26:57.038, Speaker B: Interactive, totally for the setup. We studied these things a lot. There are several papers which provide this initial setup, the mathematical name of it. Many people use this name. Distributed key generation. And distributed means that there's no trusted party because for the threshold signature you have all the keys, but you need to somehow generate those keys in such a way that everyone gets a key, but no one knows everyone else's key. So it's fully decentralized.
00:26:57.038 - 00:27:28.422, Speaker B: And there's like entire set of papers on how this key is derived. And there's an algorithm which is called joint Feldman. Feldman, which provides a number of steps to derive this key. But this joint film algorithm is well known literature. You need to change lots of messages. All of these guys send messages to each other. This is well known.
00:27:28.422 - 00:28:10.374, Speaker B: But some of these guys, as we just discussed, may just withhold their stuff, not send anything. So for this joint helpment thing, they have to be somehow punished. And the punishment algorithm we do through blockchain. And let me explain how it goes. Let's say someone comes to us and large network, these are our miners, they have the servers, they're getting paid. Someone comes to us and says, I want like a 50 server blockchain. So pays using our token.
00:28:10.374 - 00:28:54.470, Speaker B: Then we randomly select 50 guys here and we're supposed to run the blockchain with these 50 guys. But each of those 50 guys needs to get this key, this like super important key for us. This key which uses decay. And the way it does our case is that on the main net, on the ethereum main net here there is something which you call a DKG smart contract. So all these protocols enjoyment all these messages that send to you, these guys don't send to each other directly, but they send them through this object to the DKG contract. Why? Because we punish them for just doing nothing. Right.
00:28:54.470 - 00:29:41.366, Speaker B: So we give it like ten minutes and tell them, okay Guys, you have ten minutes to exchange messages using DKG. And if each of them sends the correct message, there's a verification procedure. So each of them follows the protocol, everything is fine. The keys are derived, then they are superheated. If on the expiration of these ten minutes, one of them either sends an incorrect message which doesn't pass verification or doesn't send anything at all. At particular step we just stop the protocol and punish the particular node, essentially take charge of mine. We don't really know how much, but let's say like $100 and then you.
00:29:41.388 - 00:29:53.100, Speaker A: Restart again and you start again. So pretty much if I just front run these guys on Ethereum constantly, I can pretty much just slash all of them and pretty much postpone this for a while.
00:29:54.350 - 00:29:55.420, Speaker B: How? I will.
00:29:56.030 - 00:30:02.414, Speaker A: There's a minute transaction system gas, right. So I'll just send transactions as high gas which will kick them out of.
00:30:02.452 - 00:30:04.654, Speaker B: Sample for ten minutes.
00:30:04.692 - 00:30:06.030, Speaker A: I mean that's doable.
00:30:07.730 - 00:30:12.080, Speaker B: But this will require you to spend money.
00:30:12.530 - 00:30:28.518, Speaker A: I mean this is an attack, right? Pretty much. Somebody requested this chain, like a custom chain for something, right. They are waiting for it. So it's denial service attack, right.
00:30:28.604 - 00:30:34.562, Speaker B: So you are going to feel like increase the gas price for the entire block.
00:30:34.626 - 00:30:45.370, Speaker A: Yeah. Depending how they define the gas price for the transactions, I'm assuming they don't want to pay that much, right. Because I'm assuming there's a lot of messages for EKG.
00:30:47.390 - 00:31:19.400, Speaker B: The typical timescale money scale for this is that each of those guys will stake. So the typical staking, we don't know exactly how much it's going to be, but we're going to assume it'd be like $5,000. So they stay $5,000. The typical amount they're going to get each month from mining. Maybe like several hundred dollars each.
00:31:19.930 - 00:31:22.230, Speaker A: Am I going to get more? Is there less people?
00:31:22.380 - 00:31:44.880, Speaker B: Yes. I'll tell you about economics, but let's say $500 to front run them. If we see this problem, I think definitely we can either increase the time or they can pay more. It's a problem. But for the first version of the network, not such.
00:31:46.210 - 00:31:48.410, Speaker A: How many messages do you need for DKG?
00:31:48.490 - 00:31:54.500, Speaker B: So for DKG, typically each of them sends a message to each other.
00:31:58.870 - 00:32:00.862, Speaker A: Each needs to send 50 transactions.
00:32:00.926 - 00:32:28.074, Speaker B: Yeah, it's actually going to be one transaction. Just they would actually put in the transaction many messages. It might be a bit of a problem, but for the first, we'll see how it goes this part. So that's the decision. Now, coming back to your question about the bounty. Currently network, the bounty is 2.75%. Don't ask why.
00:32:28.074 - 00:32:34.480, Speaker B: 2.75 or half of the whole mathematical calculations. So we pay 2.75% per year.
00:32:36.370 - 00:32:37.530, Speaker A: Of the total supply.
00:32:37.610 - 00:33:19.178, Speaker B: Yes. If in our network, say like 10,000 servers, let's say you have 2.75%. Let's say our market capitalization is $100,000,000.02.75% means $2.75 million. So if we have thousand servers, all of them functioning well, pretty much like paying two point seven k per year. This naturally adjusts the number of servers in our network, because when the number of servers goes up, each of them gets.
00:33:19.178 - 00:34:14.814, Speaker B: And at some point it becomes not economic to not economic to actually join the network. So that's currently the economy. So if you look at bitcoin or ethereum, you always see that in a network initial stage where network is underwater and most of the miners are getting paid by this inflation, when the network gets loaded, at some point there are transaction fees which are becoming not zero. And the hope is that when the equilibrium is right, many years after, at some point the inflation goes to zero, it's halved every six years. And at some point the network becomes self sustainable, paid by this transaction. That's pretty much what we do. Like many other people follow this, that's the common.
00:34:15.012 - 00:34:32.180, Speaker A: So on this question. So pretty much, let's say we're 21 folks that are monitoring your specific node, right? So for us it's actually beneficial to all collude and kick you out of the system because we'll get more money, right? Like for that specific month.
00:34:34.150 - 00:35:13.950, Speaker B: It'S true. But for the most part they won't care because to kick you out, the potential gain they have is very small, right. You have like 1000 node network and you select only one of them. Yeah. If you pick one up now, you kind of increase marginalized bounty, but there's a very little gain. And what we see at this point is that all these miners are going to be like the generalized mining guys. And most of them are going to have pretty significant operation.
00:35:13.950 - 00:35:22.286, Speaker B: They're going to have lots of servers. So it's a community. But that's a very important question. I think at some point, let's assume.
00:35:22.318 - 00:36:02.798, Speaker A: We have less than one third of malicious, right? So we have 333 servers that let's say are run by a single entity for simplification. Then they have, I mean, statistically they'll monitor a lot of other folks. So this will be more than 100 other nodes. So they can kick out 100 nodes per month and then this goes to 900 and they now control more than 130. And then they can start actually affecting randomness. So even up to one month of us just kicking out few servers, we can actually start affecting the randomness of VLS and DKG, right?
00:36:02.964 - 00:36:56.702, Speaker B: Yeah, potentially yes. But all these systems, if you look at them, there are different security options, right? There is like external attackers, someone can do services, there is vulnerability, someone finds a hole in your software, there's this insider thing that you see. But when these networks become realistic, some of the attacks you cannot potentially fix all of the small things from the beginning because the systems are complex and if you just try to fix everything, you will just be able, the system becomes too complex. So I think us and life, peer, maybe you guys, everyone is creating these newer generational networks, these lots of servers, you kind of solve the problem. What is getting created?
00:36:56.846 - 00:36:58.014, Speaker A: I mean, it's trade offs.
00:36:58.062 - 00:36:59.214, Speaker B: It's all trade offs.
00:36:59.342 - 00:37:01.410, Speaker A: We need to be clear what are the trade offs?
00:37:02.070 - 00:37:56.414, Speaker B: Totally. So you started something and you iterate. So I think an answer to all of those questions, it's like a lead startup technology where you start something with something simple, you see what the important problems are, you kind of fix them. And so that means that you have to have very important community and governance in your system. You should be able to react to threats. And in our system at this point, we decided for the security response team that we're going to have a security response team which is going to be decentralized, just security experts selected or elected by community. And the security team will have ability to at some point stop an exchange because you could have anything in guarantees against like for instance, security vulnerabilities.
00:37:56.414 - 00:38:43.410, Speaker B: You can wake up and just exchange can be down. So there will be an election process which we are still thinking about. But a simple model is that let's say you wake up and your s chain is compromised. So the s chain owner votes, yes, I've been compromised. And then the security response team looks at this and also says, yes, they've been compromised. And then they decide how to roll back the chain and they decide to come on points in time to which the chain is rolled back. And this is kind of diverse scenario, but my feeling is that you have to, with this kind of faster chains, you have to have scenarios like this because there's no way to do like an AI to prevent against all of the security problems.
00:38:43.410 - 00:39:06.410, Speaker B: So you need to be kind of modest in a sense that you accept the fact that you can be compromised and you have to find some reasonable way to solve this problem. So I think that's pretty much the solution. We arrived at the moment for this part. Yeah. So I think I can also tell you a little bit about our consensus.
00:39:08.270 - 00:39:16.238, Speaker A: I just wanted to finish this. How do people become validators and how does this two way communication happen?
00:39:16.324 - 00:39:45.426, Speaker B: So how they become validators? Everything in our network is based on this DKG and BLS that you discussed. So when there's a need to create a newest chain, all of the nodes in the existing chain, they sign the BLS signature. And this BLS signature becomes the random number season which is used to randomly pick a certain number of nodes from a network and it becomes a network.
00:39:45.618 - 00:39:53.130, Speaker A: I meant how does new validator become like I have a server, $5,000 how they become part of this?
00:39:53.280 - 00:40:30.342, Speaker B: So this happens like that, you buy a server and then you have to have also this deposit. So you buy our tokens and you stake our token. Exactly. And then actually one of the kind of decisions that you made was that to simplify our network, all of our management stuff happens actually on the Ethereum main net. So all of this bounty, payment node addition, removal, all is implemented through smart contracts on the main. Net. So your node registers using our ERC 20 token on the main net.
00:40:30.342 - 00:41:11.566, Speaker B: If you pass this token and if you become part of the system, but originally you don't have any scams running on you, but you still pay bounty. You'll pay bounty no matter whether you're loaded or not. But then at some point some idea of developer comes and says I want to have an s chain and you're getting randomly picked. And then now you start serving an s chain. And an interesting thing in our case is that we provide also cheap s chains for developers. Let's say, don't want lots of performance, right? We run our stuff on Docker containers and a single server can run up to 128 tiny docker containers. We call it tiny chains.
00:41:11.566 - 00:41:36.730, Speaker B: So essentially on each server you only run 128 of all resources such as cpu and storage. And then these things, these daffra containers are joined into a blockchain, which is not so much of a performance blockchain, but it's going to be very cheap because on a server you essentially use only like 128 of resources of the choice server. So we could have a flexibility.
00:41:38.270 - 00:41:40.714, Speaker A: So how does this guys know about.
00:41:40.752 - 00:43:19.978, Speaker B: What'S happening on the interesting question? So that's really a question which we were thinking a lot, right? So what we have now on ethereum differently, we have the main net which functions well, but is expensive. What we want to have is have lots of our side chains, right? And becomes like an AWS in a sense, or like Internet in a sense that every chain becomes like a server in the old language and serves a particular application. So regular Internet, you have like a hotel ecover site, you have a hotel server and then you have airline, you have airline servers, you have these logical things and you have this loose coupling between different servers in the sense that typically an Internet servers talk to each other through APIs. So the hotel server calls JSON API on the airline server and the airline server replies, we kind of lose coupling architecture and we decided in our system to implement this loose coupling architecture. So all of our stuff is implemented using messages, smart contracts on each network solidity smart contracts can talk to each other, send a message. So in particular, when this s chain wants to send a message to the main net, not all, but again to store three m servers on the s chain, sign particular message and the message we have an agent which relates this message to the main net.
00:43:20.064 - 00:43:21.786, Speaker A: How does the agent work?
00:43:21.888 - 00:44:21.482, Speaker B: And the way the agent work is that actually on every each of those servers there's a copy of the agent and there is a time, maybe like 5 seconds, let's say 10 seconds with him, right. So in round robbing fashion, at least on the first version of our network, each of them gets to be drill here. So if this guy is bad and when the message is sent from this place, that place, it is originally sent by smart contracts, like a proxy smart contract in this net. So actually the message is trust in the smart contract here and then it's signed. But now someone has to relate it to this smartphone, to this proxy smart contract. So this guy is supposed to relate, but let's say this guy's bad. Like 10 seconds after this guy she's well okay, this guy was supposed to relay things, he didn't relay things, but this guy relates like round robin fashion in which all of those guys at some point get to be relayers.
00:44:21.482 - 00:45:15.114, Speaker B: So on average, even if some of them are bad and don't relay, you'll get a message relate. It's definitely not so fast as things inside, but for the most part the messaging is used in our case for transferring tokens. So pretty much you freeze a token on the main net, this smart contract gets, sends a message to a smart contract on this s chain and a clone is created. So this message on the main net, these guys can just verify in a regular Ethereum way, verify the state route of Ethereum until it's actually first in the smart contract here. And then this guy verifies the state rule and passes this message to the smart contract.
00:45:15.162 - 00:45:26.374, Speaker A: Of this he means the external person who wants to send the token, he actually, after block included, he sends it here.
00:45:26.572 - 00:45:45.306, Speaker B: Let me give you an example. On this net we have this proxy smart contract proxy, sure. And there's a proxy smart contract on this net and there is a smart contract sender right here.
00:45:45.408 - 00:45:49.450, Speaker A: Yeah, he's outside of the network.
00:45:50.110 - 00:46:05.394, Speaker B: In this case it's just a smart contract. Let's say this smart contract on this network, on the management, and there's like another smart contract on this net. So this guy sends a message first to this proxy, smart contract, don't send.
00:46:05.432 - 00:46:08.510, Speaker A: A message person who authorized transaction.
00:46:08.670 - 00:47:05.490, Speaker B: Yeah, so ultimately there's a user usually, and the user could be also a user, could be a smart contract, could be a user, but one of them sends a message. Actually could be different architectures, but in our architecture there's also like a deposit box. So bank smart contract user sends a message to that one, it doesn't matter, it's not so important. But ultimately the message is here and it needs to be relayed to this. So again, we have this kind of round ruby situation where there's a relayer and one of these guys actually relays, but two thirds of them confirm. You again have this two third confirmation. So to pass the message, it talks to other two third guys, creates a threshold signature and then the threshold signature is verified.
00:47:05.830 - 00:47:08.722, Speaker A: So every node actually needs to run a full ethereum client.
00:47:08.866 - 00:48:02.486, Speaker B: Yes, absolutely, every node runs full ethereum client. And moreover, going back and forth here actually requires you to spend some easer. And the way it's done, the owner of this gap is posed to maintain this account that shouldn't be zero, where this easer should be placed. And then it's up to the owner of the app how to reimburse, maybe ask users to pay or someone has to pay these guest costs. And this type of BLS signature relay is also used by definity. And also I think Polkadot also uses this kind of threshold signature based messaging. The idea is that the security of that depends on everything is getting signed by two thirds of the guys.
00:48:02.486 - 00:48:12.570, Speaker B: And so the security model, as you see again, that if one third of the guys become malicious, the problem. So all of these proof of stake systems have this natural.
00:48:12.910 - 00:48:15.594, Speaker A: The question is how easy it is to get one third right.
00:48:15.712 - 00:49:03.398, Speaker B: Definitely. That's really a question. I think that people will learn and when the first generation of the networks will be released, people will see how important this problem is. It may be, there are different discussions, it may be nodes, you'll need to maintain some kind of a reputation, because what you want to do for those side chains, and not only for that, even like a for life peer finance like utility network, you want to be able to keep the number of bad guys small, because if you have many bad guys, no mathematical algorithm can help. So maybe this can be done through reputation, maybe through governance. So at some point there will be some kind of way to enforce this. And it's a very important question in this industry.
00:49:03.398 - 00:49:16.400, Speaker B: That's something that I think everyone is going to address. Okay, so that's this part. How much time do I still have?
00:49:19.650 - 00:49:20.880, Speaker A: Talking about near.
00:49:21.330 - 00:49:22.400, Speaker B: Yeah. Okay.
00:49:24.130 - 00:49:26.640, Speaker A: This black is pretty bad.
00:49:29.510 - 00:50:36.630, Speaker B: Let me just go into a bit of a different old and tell you guys a little bit about ancestors. Sure. So it's kind of a very interesting subject because we have lots of mathematicians in our company, and we're really interested not only kind of in theoretical, not only practical application of that, but also in theory. How does it kind of connect to mathematics? And usually in mathematics, if you kind of understand things, they tend to be simplified. We were looking for a simplified framework to understand how what this consensus, the same is how it's getting used and to find some kind of a logical framework in our brain, how we can understand things, because otherwise, you see, like, these people are doing this consensus, that people are doing that consensus, like a zoo of different consensus. Everyone says, I have the best consensus, and it becomes really passionate, I think people talking to each other. So we designed this framework, which is a simple framework.
00:50:36.630 - 00:51:30.970, Speaker B: I mean, what's a typical consensus? What are the typical steps of a consensus and what a consensus is? And so we're talking about classic consensus. In a classic consensus, you have multiple nodes, right? And really what you have is on each of those nodes, there's this blockchain. So, for instance, there's, like, blockchain here, and the blockchain is kind of composed. It's kind of glued together transactions. So you have this 1234 like transactions, which are like blocks, actually. So they added to the end of the blockchain and blocks. But really, what you want to have is that what attacker doesn't want you to have is that all of these chains kind of are identical, with the only exception of network delays.
00:51:30.970 - 00:52:10.214, Speaker B: So I may have, for instance, like, a longer chain here, like three, four, five fine, and only four transactions here. But the parts which are the same on this node and on this node have to be the same. So it's not guaranteed that the chain grows at exactly the same time on every node, but pieces which are kind of on the same nodes have to be the same. So you want them to be the same. The attacker wants them to be different. And that's like, the entire business of blockchain is about that. What you typically have, no matter what protocol you use.
00:52:10.214 - 00:52:41.002, Speaker B: Like tendermint, for instance. Like my friend. Exactly. That you guys interview tendermint or, like, definity or, like, algorithm or all these people, actually, conceptually is the same, like small differences. So you have steps. And what steps do you have? Okay, the first step, number one, it is a submission. Typically you have users, like submitting transactions, like, okay, yeah, so submitting transactions to your network.
00:52:41.002 - 00:53:14.710, Speaker B: So you have the submission. The users, you typically have lots of them. They're not going to be cooperative. So they typically have your network, and they're like throwing transactions on your network. And so when they throw them, you have some type of a painting queue on each node. Somehow these transactions, they don't actually go into blockchain right away. They go some kind of stored somewhere and they hope to be included.
00:53:14.710 - 00:53:58.200, Speaker B: So you have the spending queue. And then next step, someone has to create this, out of this chaos, someone has to create like a block candidate or maybe block candidates, because you might have multiple block proposals at the same time. You may have a single block proposal. So you have this block proposal stage. And whatever your algorithm is, you may have one block proposal at a time, like an EOS, maybe have five block proposals. Could be all kinds of variations, but someone has proposed proposed blocks. Now, this is another important thing, which is called data availability.
00:53:58.200 - 00:54:48.410, Speaker B: And this is really like an important concept, which means that, let's say you have some type of an algorithm, you have the block proposer, and many of them one of them. And at some point, this block may win. Winning means that it may actually get committed to the end of the chain, and it kind of transforms from the block proposal to the block, which everyone is supposed to have. If I'm a bad guy and I somehow manage to not send a block proposal or to one of the good guys, this good guy is going to get stuck. So what I would want to have as a bad guy is to somehow propose. Everyone accepts my proposal, maybe hash of the block, maybe the hash of the block. So they accept the proposal.
00:54:48.410 - 00:55:30.946, Speaker B: And then once everyone says, okay, we accept this block, I say, okay, I don't going to give this block to anyone. And everything is stuck because of that. If someone proposes, you have to somehow guarantee data availability. And there could be different methods, but this step has to be there. After that, there is a fifth step, which is, let's call it consensus in some generalized sense. Right? And this consensus means that, okay, you may have at this point, still multiple block proposals, but now you know that all of them are data available. Or you can use the term safe.
00:55:30.946 - 00:56:12.580, Speaker B: They are safe. And so what means they are safe is that at least one good guy has the copy of it. Because if I am a good guy. I have a copy of a particular block proposal. I can always give it to some other good guy. So the data availability or safety of a book proposal means that the mathematics has to guarantee that after this step, for every book proposal which is deemed safe and goes further, the further steps, at least one guy have this proposal so that there is consensus, and it's kind of where you may still have multiple safe proposals. Somehow you have to select which of them wins, and then you somehow select which of them wins, and then kind of finalization step.
00:56:12.580 - 00:56:36.822, Speaker B: This way, the proposal, the winning one, is committed to the end of the chain. If I'm a good guy, but I don't have a copy of it, I ask around other good guys because I know it's safe, so I'm able to pull it. So this finalization step, when the block proposal is added to the chain, finalization.
00:56:36.886 - 00:56:40.342, Speaker A: Also means that there will be no other block that will be replaced.
00:56:40.406 - 00:57:26.294, Speaker B: Exactly. Not as a blocks. Right. So you have to also, with no other block, you have to guarantee also that one single proposal only had only one proposal, because otherwise I could send one proposal to one guy, another to another guy, and that would be mismatched. So this is kind of framework. You can use this framework, you can look at tendermint, for instance, and actually the state machine, which is inside tendermint, you can somehow map to this kind of logical framework. You can take algorithm and map it, and then it kind of becomes easier for you because you can take a look at the particular protocol and you say, okay, what are the six steps and how conceptually, at high level, this is achieved.
00:57:26.294 - 00:58:13.500, Speaker B: Now, let's go back to our protocol. So the important thing is data availability. So in our protocol, if I'm a proposer, I want to propose a book. The way it works is that if I proposer, I have to send my book to everyone, right? But some of the bad guys may decide not to accept it. So I cannot guarantee that everyone will take my block. So what I do, I'm in parallel, parallel trying to send my blog proposal to all nodes in the network. But once I uploaded the proposal to two thirds of the nodes, I cannot wait anymore because the other guys may not accept it.
00:58:13.500 - 00:58:36.480, Speaker B: Each time I upload a boot proposal, I get a piece of a threshold signature. So as a result of this data availability step, I have a threshold signature, which attests that I did upload my blog proposal to two over three m.
00:58:37.250 - 00:58:38.630, Speaker A: Is there one block proposal?
00:58:38.650 - 00:59:04.970, Speaker B: In your case, multiple. Could be one, could be multiple. It's configurable. So this protocol works for multiple proposers. One proposer, everyone could be a proposer, depending on how many proposers. It takes more computation and more network. There is a version where everyone is a proposer, and there's some great fairness about this version where everyone proposes, the bad guys cannot really change things.
00:59:04.970 - 00:59:48.722, Speaker B: But really, the critical thing is having this data availability receipt. Now I hear proof that I'm a good guy, uploaded my proposal to two thirds of the nodes, and then I'm actually broadcasting this proof again to everyone in the network. So even I'm, like, sitting. I'm not a proposal. I'm just sitting in the network, and I'm seeing what's going on. Someone sends me a proposal, but also sends me a proof that not only I got this proposal, but also to search of other people got this proposal. So there is a mechanic like that, and this proof verifies to me that this proposal is safe.
00:59:48.722 - 01:00:40.906, Speaker B: So then I vote one if, for particular proposal, if it's safe, if I can prove that it's safe, and I can prove it's safe, because I have this hash called synergy. So, there's, like, this algorithm, which kind of explained at a high level, but the idea is that I vote one for a particular proposal only if I prove to myself that it's safe. It's owned either by me or by at least one honest guy, right? So I vote one in this case, and I vote zero if I don't have a proof like that. Then at this point, you have a particular proposal. You have, every node votes is a zero or one. And then an algorithm happens, which is called binary consensus. The binary consensus are like zillions of.
01:00:40.928 - 01:00:46.922, Speaker A: Algorithms, but you don't have binary. If you have multiple block proposals, you actually have zero one on all of the.
01:00:46.976 - 01:01:28.054, Speaker B: Exactly. So, for each block proposal, if you have five proposal proposals, you actually have a vector of five, so you hold zero, one for each of them. And that's how honeybee works. That's how we work. So you end up running, in this example, like, five binary consensus algorithms, and then you have this fine name, Abba asynchronous binary consensus algorithm, also synchronous binary consensus algorithm. There's, like, entire zoom of them. But the point is that what you do, you run consensus on each of them, and five consensus is complete, and you have zero, one.
01:01:28.054 - 01:01:56.130, Speaker B: And if at least one consensus return one, you can commit. But you could have situation where for several proposals, you return one. So you could actually commit any of them. There has to be just some deterministic procedure to commit, like let's say four of them at once. And you use a PLA signature randomness to decide the priority. There are four ones which block proposer wins. So there is also this type of a game going on.
01:01:56.130 - 01:02:28.202, Speaker B: And this is something which we do, something that honeybeeger does blockchain at University of Sydney in Australia. Also this kind of plays this vector. So it's interesting thing. Now, the last thing I'm going to tell you guys in a very simple way, what a binary consensus is, and this entire, I think, conversation is invitation to look at those things, because some of these algorithms are very involved. It's hardly to go into every detail, but I hope at least you get a feeling how it works. Before we do that.
01:02:28.336 - 01:02:33.322, Speaker A: What is the style of a block? Or how do you do this data?
01:02:33.456 - 01:03:00.630, Speaker B: That's great question. So in unconsensus, there's no preset, there is like maximum size of a block. But the block proposal happened in Ethereum network. You have this 15 seconds time variation time. So you wait 17 seconds, whatever you get in your painting queue. Like you mind make a block proposal. Don't have anything like that in our case is that I'm unknown.
01:03:00.630 - 01:03:34.362, Speaker B: I just committed a particular block and I immediately do a proposal for the next block. So there are lots of different policies or algorithms. The greedy algorithm is that I take whatever I have in my painting queue and all of this stuff like trying to increase the throughput, the entire thing in my painting queue becomes the proposal. But this has to be somehow limited. So we can say, okay, it has to be like less than a megabyte or ten megabytes. So the larger are the blocks, the faster is overall throughput of the chain.
01:03:34.426 - 01:03:45.380, Speaker A: Because your networking cost will be huge, right? Because you want to send it to everybody pretty much to get signatures. And if you have multiple block proposals, they also send it to everybody.
01:03:45.930 - 01:04:19.898, Speaker B: This is also another very interesting set of algorithms that you could use. So when you send a port proposal, you have this painting views, right? So you kind of assume that absent network delays, painting views on each of the nodes kind of look the same. Most like many transaction filters. Yeah. So you can do lots of mechanics. You can like for instance, iteration the way you would do it. The proposal does not actually include transactions, includes hashes of the transactions.
01:04:19.898 - 01:04:58.054, Speaker B: They become smaller. So I push proposal. The guy on the other side sees, okay, I have all of those hashes. So it reconstructs proposals from hashes. If there are some missing hashes it talks back to this guy, stored guy, and get the missing transactions. These algorithms, we don't do this now, but could be actually even taken even deeper, because if you think how this goes, typically pending use on each node will look very much the same. So you have all of this algorithms.
01:04:58.054 - 01:05:49.818, Speaker B: Totally. So you have all of the algorithms related to kind of how, if you have two things which are actually almost the same, what amount of information you kind of pass between the two entities for the destination entity to reconstruct. So this entire kind of potential for this part. Now let me go really fast into the upbusting into binary consensus, just to give you guys a seeding what binary consensus is. So, binary consensus, it was like a very interesting mathematical topic. And some people call it byzantine general's problem and stuff. And the classical mathematical problem is that maybe it's a wall, it's a castle wall, and like two gates, like gate number one and gate number two.
01:05:49.818 - 01:07:10.310, Speaker B: And you have end generals, like a number of generals. And the army has, like, next morning, the army needs to decide, do we attack here on this wall, on this gate, or we attack here on this gate? And we assume that out of the generals, most of them are really smart people. And there's a one, like, crazy guy or bad guy or byzantine guy, right? All of the good guys, they look at this particular situation, and maybe one of them thinks, okay, you can attack here, and another one makes decision, you can attack here, but what's important that in the morning, all of the armies attack one of the gates. Because if some of the soldiers go here and some of them go here, they may lose. But if all of them concentrate in one single place, then they will win. So you have this thing where initially, each of the generals, let's say zero is left gate and one is right gate, each of them independently decides, I would attack here. Right? So each of them, like 011-0100 and the crazy guy may also decide something.
01:07:10.310 - 01:07:34.430, Speaker B: But since this crazy guy is totally crazy random, you may assume that his decision is totally illogical. And he can, during the protocol message exchange, he can send any messages, wrong messages, correct messages. Actually, a random guy is the same as Byzantine, a malicious guy, because he can type a book.
01:07:34.500 - 01:07:41.614, Speaker A: Well, I mean, malicious can be more like. It can actually have malicious can know the state of everybody else and actually affect it.
01:07:41.652 - 01:07:43.274, Speaker B: Exactly. So it can be exactly.
01:07:43.412 - 01:07:44.974, Speaker A: Way smarter than just random.
01:07:45.022 - 01:08:30.462, Speaker B: Right. But if you want to protect against all of the actions of the random guy, you may assume that just by the very randomness, the random guy might just randomly generate a malicious strategy. So actually, all the proof actually assume the guy to be random in the same way, like a monkey can print, like Shakespeare, the random guy. Mathematically, you can prove that totally random guy. If you prove that any randomness results in consensus, malicious is the same. This one of these guys are random. So what you want to have, they kind of start changing messages, calling each other, and you want to have several things.
01:08:30.462 - 01:09:25.142, Speaker B: First of all, at the end of this protocol, you want all of them come to the same, to the consensus, to the same decision, either zero left gate or one right gate. And then next morning, each of them will attract the same gate. So first of all, it has to be consensus zero and one, and its consensus has to be throughout all of the good guys. But then there's another very important property. If initially all of the good guys, all of them decide one, the result should be one, which means that none of them decided zero. And you don't know, maybe the zero gate is not safe. Maybe the reason why you decide one, because they clearly see that this other gate is, like, so strong, you can't actually break straight.
01:09:25.142 - 01:10:16.338, Speaker B: So if all of one has to output one, and initially, if all of the good guys say zero, it has to be zero. And this is kind of the entire byzantine consensus thing. Now, if we take now these ones and zeros, and just to give you guys a feeling, remember, in our case, one is zero. One means that the block proposal is safe and zero is unsafe. So if all of the good guys say that the proposal is unsafe, this means that no one has a proof that it's data available, so it should be zero at the end, you cannot select this proposal for consensus. So if all of the good guys, initially, zero has to be zero. And this fact is not so important.
01:10:16.338 - 01:10:54.430, Speaker B: But what's important about the consensus? If all of the good guys say this proposal is unsafe, you shouldn't commit it, because otherwise. So now you see that this general problem has a direct kind of mapping to the proposal, whether it's being safe or unsafe. So this algorithms, there are lots of different versions of these algorithms in the literature. Some use cryptography, some don't use cryptography. We use a particular version which comes from a group in France. There's a professor, his name is Mustefawi. I think that's how it's spelled.
01:10:54.430 - 01:11:34.614, Speaker B: You guys can Google for it, and you can Google Honey badger paper and honey badger paper, because honey Badger also uses this. This also referenced this. It's pretty nice consensus of Mustafawi. But that's something we use because it's pretty fast in theory. We could take this Mustafawe consensus and use something else. But then what I forgot to tell you is that there's actually a very interesting mathematical proof that even, like if one general is bad, there's no deterministic algorithm that solves consensus. So there has to be some randomness in consensus.
01:11:34.614 - 01:12:19.602, Speaker B: So if everything is deterministic, the web guy always has a strategy for the consensus to either not never stop or output different values on different sites. So that's a very interesting theorem. It actually can be explained, but maybe not today, but there is actually a pretty simple explanation that we are planning to publish a blog post simplifying how theorem is. Right. But isn't it interesting saying that the consensus requires some randomness? And the last thing about consensus is that consensus assumes some type of a network model. So these generals or the Servers exchange management. The question is, what's the quality of this network? And there are general control network.
01:12:19.602 - 01:12:22.460, Speaker B: Exactly. And all kinds of things.
01:12:24.830 - 01:13:04.102, Speaker A: I think. Yeah, there's all kinds of things that there's a lot of thought consensus to study. One question I have is given, you actually have like as a blog proposal, right? If you're collecting parts of the signatures from the people you distributed the thing at the end, you actually have an aggregated signature, which is a proof that two thirds, right? So pretty much you're saying, why are you running binary consensus on top of it? Like, if you have already proved two thirds, is it just because one third of them can be malicious and they like you?
01:13:04.156 - 01:13:43.534, Speaker B: Yeah. So that is a very interesting question. And this entire consensus thing, it's a bit mind boggling. So me personally, it took some time to kind of go into this kind of understanding, like this great thing, mathematics. So let's say you have a proof that this block proposal is safe. Then why did consensus, you could like say, okay, you could commit it to your blockchain? Well, there could be another good guy. And the bad guys could have intentionally withheld the proof from the good guy to this other good guy does not have a proof.
01:13:43.534 - 01:13:54.818, Speaker B: So when you commit a block, you shouldn't only know that this is safe, but you should know that all other good guys know this is safe.
01:13:54.914 - 01:14:15.514, Speaker A: But in this case. So let's say there's two cases, right? There's a good guy who is a block proposal. In this case, he collected two certs, which means at least one third of those two certs is good guys. They will distribute it, right, totally. And then there's a case where the bad guys is proposing a block.
01:14:15.562 - 01:14:15.822, Speaker B: Right?
01:14:15.876 - 01:14:21.822, Speaker A: So for him to show an aggregated to search signature, he also needs to show it to one third.
01:14:21.876 - 01:14:22.094, Speaker B: Right.
01:14:22.132 - 01:14:22.782, Speaker A: Of good guys.
01:14:22.836 - 01:14:23.402, Speaker B: Totally.
01:14:23.466 - 01:14:25.262, Speaker A: So this guy is also distributed.
01:14:25.406 - 01:14:26.050, Speaker B: Right?
01:14:26.200 - 01:14:36.486, Speaker A: So if you have one block proposal, at least, and this block proposal collected two search signatures, it is like, we don't need to run another binary consensus. This is how.
01:14:36.668 - 01:15:07.440, Speaker B: Okay. But that is unfortunately another iteration. So have one block proposal, the block proposal. Let's say it's a bad, but very smart bad guy, right? Block proposer sent his proposal, her proposal, to two thirds. Now really, like two thirds have the proposal. Then he has the receipt, but he was handsome, and he sends the receipt to all of the honest guys except one. So all of these honest guys.
01:15:07.440 - 01:16:03.378, Speaker B: And they committed. But then there is this other. And then if they broadcast it, then you have another level of the problem is if they broadcast it, you have to deal with entire form of worms because you're getting broadcast, you don't know if the broadcast you're getting coming from, you can help the broadcast. So there are lots of things which you think it's easy. And the consensus kind of this potential infinity stops, because what consensus tells you it's not only that this is safe, but that every good guy knows that this is safe. And then it's kind of a logical step, which is very counterintuitive. And I spent my entire life in mathematics over AI, like machine learning this and that.
01:16:03.378 - 01:16:52.078, Speaker B: This is kind of one of the most strange parts, all these asynchronous things. And you kind of have to take time to kind of move your mind and took me, you're going through exactly the same things, which I was going, like, trying to understand this stuff, and I think I understood this, but it took me like six months. But this brain is the thing. And I, at some point, suggest you guys, you can find your paper, there's like lots of references written. This paper of Mustafawi, which is cited in the Fanny Bajer paper. And then from that you can go. And there are all kinds of consensus algorithms, like this entire academic community working.
01:16:52.078 - 01:17:22.920, Speaker B: It's really interesting. But what's great for us, we are using this stuff. So even though we're not super experts in consensus, if we take these mathematical papers and implement them as proven in the papers, and also if we understand at least the concepts, we know that it's secure. So we can build our security pools by kind of referring to other guys. But this is a very interesting subject. Sure.
01:17:23.770 - 01:17:25.030, Speaker A: We are assigned.
01:17:25.450 - 01:17:26.438, Speaker B: Thank you very much.
01:17:26.524 - 01:17:29.870, Speaker A: Please leave your comments and feedback on the video.
01:17:29.980 - 01:17:36.700, Speaker B: Okay guys, if you have any questions you can also send it to Ilya and we will happy to answer.
