00:00:00.170 - 00:01:14.450, Speaker A: Hi everyone, my name is Kiril Bobarov and this summer I worked on an efficient symbol index for Clankd at Google. So Clankd is our language protocol implementation that provides smart IDE features like code completion. And one of the focus of our team was us to improve the speed and quality of code completion for global symbols. So as soon as the code completion pipeline starts with user typing some text and requesting code completion through their editor, and it sends a request to clangd which queries the index and the syndics returns completion list which contains some variables, functions, class names and so on. So the symbol index is kind of the heart of global code completion for clankd and we wanted to improve the performance. So the new symbol index is called DAX. And our vision of DAX was influenced by several factors.
00:01:14.450 - 00:02:12.018, Speaker A: We wanted open source developers to be able to run global code completion without noticeable latency. We wanted it to be high quality and we wanted our index to scale well for large projects such as LVM and chromium. So the information that is available to the index is the symbol attributes. So for each symbol we know whether it's a class or a function or a variable, we have information about the scope. And during the build stage we extract all this information for each specific symbol. Using that information of the attributes, we create postal lists. Postal lists are basically, we basically pre rank all the symbols using for example, number of references.
00:02:12.018 - 00:03:08.134, Speaker A: And then for each attribute we store lists with every symbol that is having this attribute. In this example, it's every symbol, it is in the LVM scope. And what is important is that everything is sorted by the precommitted rank. And to process the queries to get the global code completion, we just extract a set of attributes from the query and then we try to match that. Like we try to find all the symbols matching a specific set of queries expressed in the semantics of query tree. So we have some logic operations on these postal lists. We can merge and intersect the postalists so that we can retrieve symbols which have certain qualities that we want.
00:03:08.134 - 00:03:56.134, Speaker A: There are multiple more sophisticated examples of operations on these postal lists, but these are the basic ones. We can just query the SMV over our database to get like small vector. So the completion is fuzzy matching based. It's not the exact string matching for unqualified names, and we also have different attributes to tweak the quality. And that brings me to the point of that this code completion is fuzzy matching based. So for that to work, we have to create a special set of attributes. So for each symbol's unqualified name.
00:03:56.134 - 00:05:19.600, Speaker A: We have to get the fuzzy matching trigrams and these trigrams allow us to get more sophisticated matches like small vector can be retrieved with queries like SVAC SMV. So we kind of get more flexibility on the query side and better quality for code completion and the results were pretty good. So DaX replaced the previous index implementation. It was much faster as in this example it's actually up to 60 times faster and it also provides more features over last index so we can tweak quality and we can also improve speed dramatically. Right now it's used for global code completion with a static index so the index is immutable but we want to use that for incremental index in the future and you can find out more because everything is like the design is public, the implementation is open source and you can get instructions on how to set up your global index in the documentation and get it running on your pc and on your code base. Thank you.
