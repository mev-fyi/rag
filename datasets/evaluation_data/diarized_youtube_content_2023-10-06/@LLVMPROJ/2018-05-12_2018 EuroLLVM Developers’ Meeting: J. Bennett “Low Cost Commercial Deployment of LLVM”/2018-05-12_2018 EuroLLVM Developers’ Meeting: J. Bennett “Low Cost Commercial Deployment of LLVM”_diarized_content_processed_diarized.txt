00:00:00.410 - 00:01:07.810, Speaker A: Those of you who are at Euro LLVM 2012 will have possibly seen Anton Korobanikov demonstrate how to bring up a complete LLVM compiler for open risk in 24 hours. I'm interested in how we get from there to a commercially deployable tool chain as quickly as possible. We'll need to be able to handle any code a compiler can a customer can throw at us, and we'll need things like an assembler, a disassembler, linker, libraries, a debugger, and some utilities. Now this talk concerns one common type of customer, the midsized electronics design house, developing its own specialist chips with its own in house DSP. Originally, this company would have added a small programmable element to its chips, and this tiny DSP was a great success, and the designer on his own would also write the assembly code needed. In time, this became a more powerful DSP version two, which was even more successful. And now we have a small assembly language programming department.
00:01:07.810 - 00:02:30.570, Speaker A: Today's DSP version three is even more successful, with a large assembly program set of assembly programmers implementing standard codecs. These codecs all come with reference c implementations, and so the company would rather program the DSP in c. Programming in c should greatly increase programmer productivity generally, but to justify this change, this small company must be able to deploy a compiler that is commercially robust but not cost too much. In this case, the compiler development is simplified because the customer is only using a small subset of c, typically needs minimal library support, and has a single small user base in house. Completing the generation of real instructions for tablegen is a routine task for an experienced compiler engineer with a simple architecture. LLVM instruction selection and register allocation are very simple and straightforward, and a working compiler with all the instructions can be achieved in a few weeks. The customer already has an assembler by definition, and usually that acts as a rudimentary linker.
00:02:30.570 - 00:03:32.678, Speaker A: Libraries aren't that important, so we can use reference C implementations, and a minimal debugger just needs to be able to allow programs to be loaded and run on the target. And this proof of concept complete tool chain can usually be completed within 60 engineered days and allow the customer to see that things are going to work. We then need to ensure that all the required functionality is covered by LVM, so that means making sure we've got an elf assembler and linker. CGen can help generate an assembler, and porting an ELF linker is fairly trivial. Special functionality invariably found in these processors, like saturating arithmetic. We just support with built in functions, and we get to where we can pretty much cover the whole of C in about 60 days. Then this boring part of plowing through testing regression test cases and improving optimization.
00:03:32.678 - 00:04:33.194, Speaker A: And for a small, well defined use case like this, 60 days is probably enough for a skilled engineer to deal with that's. And finally, and this is perhaps a surprising one even for a small user base, deployment takes just as long as the testing. And the reason is that a customer base that's used to a simple assembler can really get out of control when you give them a globally optimizing compiler, a debugger that can handle source level optimized code, and that can run linker scripts that can get you in complete messes. So we actually find we spend as much time there as in any other part of the thing. Only then does the customer realize the savings made by moving to c programming. And they've got a commercially robust LLVM compiler tool chain for their uses, and it's been achieved commercially in about one engineer year. I've rushed through this to give you the big picture.
00:04:33.194 - 00:04:45.460, Speaker A: We've got a poster outside with all the details of how LLVM helped and the actual use case example on which this talk is based. So do come and talk to me and my colleagues later on today. Thank you. Thank you.
