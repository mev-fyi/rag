00:00:00.730 - 00:01:01.786, Speaker A: So hello and welcome. Thank you for coming and learning about finding some interesting bugs. So let's start what's in an ABI? What are we actually talking about here? We're talking about things like the size and alignment of types, the layout of things like structs and classes and unions and arrays and all that sort of stuff. We're talking about how your function names and variable names and any sort of entity that two compilers have to actually agree upon. It can be something that you think is very unimportant, but to the compiler it actually might mean quite a great deal. And the complexity of your ABI is pretty closely related to the complexity of the thing it's trying to represent. And for us in Klein we have c, which is actually a little complicated.
00:01:01.786 - 00:01:39.740, Speaker A: So let's start with this little example that's a union. It has two fields. They're both ints, int a and int b. And we have two pointers to data members and we have x and y. X is initialized to the address of the pointer to data member for a, and y is initialized to the pointer to data member for b. And the question is, does x equal y? Well, it's great, because we don't actually have to think about this. We have a standard, a lot of smart people worked on this.
00:01:39.740 - 00:02:17.430, Speaker A: It's got to have the answer right? And luckily for us, it does have the answer. This is excellent. So two pointers to members compare equal if they would refer to the same member of the same most derived object, or the same subobject of indirection with a hypothetical object of the associated class type were performed. Otherwise they compare unequal. Unfortunately, no ABI actually implements this. Believe it or not, no one like ever clang gets it half right. If you try to do this comparison in a const, expert context, it will say one thing, and if you do it at runtime, it'll say the exact opposite.
00:02:17.430 - 00:03:21.694, Speaker A: Turns out abis are hard. So why does any of this matter? Well, if we have data or functions or whatever, and they communicate across an ABI boundary, unpredictable things might happen. If two compilers disagree about the same translation unit, or the same compiler disagrees about the same entity in two different tus, you include a header and you see the same type, and you decide to do one thing in one translation unit and a different thing in another translation unit. And the reason why this is so heinous is because when people think about compiler bugs, they think about bugs in the optimizer like, oh, the compiler miscompiled my bug when I ran it with two or with fomit frame pointer or whatever, not like I ran my compiler with, I explicitly ordered it not to optimize. Like just leave my program alone. I just want my program, that's all I want. They expect to get a working program out of that.
00:03:21.694 - 00:04:00.366, Speaker A: And Abi bugs totally subvert this. You end up with this strange place where programmers start doubting themselves. Clearly I made a bug here because my program I'm not running with optimization. The compiler is just doing the normal compilery things. Nothing scary is happening. But unfortunately for us ABI implementers, the ABI kind of intersects itself in very unexpected ways. Right? Like you might not be able to easily predict what might happen when ABi feature X and ABi feature y collide and you get something really weird.
00:04:00.366 - 00:04:35.778, Speaker A: Like one compiler permutes the field order. If the struct's alignment is 16 and it has an empty virtual base and there's at least one bit field at the end and it's Thursday, it can get arbitrarily complicated in some cases. Fortunately, we don't have to be compatible with that particular bug, but it can get pretty bad. And unfortunately some APIs aren't even documented. Imagine the horror of that. Like you're trying to be compatible with a thing that won't even tell you how to talk to it. It's very difficult.
00:04:35.778 - 00:05:09.706, Speaker A: And even if they are, they lie. We have specifications in some cases, but there's no law that says that if you violate the specifications, some scary person is going to hunt you down and destroy the things you love. No, that's not what actually happens. You just have a buggy compiler. So what happens if we aren't proactive about trying to find these sorts of bugs? Well, we can let our users find the bugs. And I think that's kind of a suboptimal solution because users are not. They probably weren't trying to find these bugs.
00:05:09.706 - 00:06:02.634, Speaker A: They were probably just trying to make their Tetris app or their sudoku solver, or their Google Chrome compile and link and run. They just wanted to get their stuff done. They didn't want to go and triage their compiler. And it's actually kind of altruistic, right. We're kind of hoping that the user is going to sit down and be like, okay, well, my compiler just, I found a thing that's definitely a bug because I decided to sit down and reduce my program to the smallest number of elements that clearly shows that the bug isn't in my program. And I cross referenced this with the necessary c plus plus EBi specification and the C plus plus standard to show that my program is well formed and it's pretty unlikely. And even if they do all these things, which they sometimes do, bless their hearts, the user's time has been spent on something that it's not optimal.
00:06:02.634 - 00:06:27.800, Speaker A: Right. We don't want to do this, so instead we can try to let the computers find the bugs. I like this approach a lot. It's actually conceptually very simple. We just generate some c plus plus, feed it to the compiler. If the compiler died from eating our c plus plus, well, then we have an interesting test case. If the compiler lived well, let's ask another compiler and if they disagree about how they feel about the c plus plus, that's interesting.
00:06:27.800 - 00:07:16.978, Speaker A: So what did we manage to attack? Well, certain aspects of external name generation, virtual table layout, funk generation, record layout, ire generation. It's actually like a pretty large amount of surface area, just by generating a pretty small amount of c plus plus over and over and over and over again and over again. So the simplest of these, I thought to be record layout. It was believed that it would be very valuable. We were having a lot of trouble sort of figuring out what the record layout algorithm was. We kept on having these like, whoa, there's this really weird special case here and this really weird special case there. And we just weren't seeing the forest through the trees.
00:07:16.978 - 00:07:54.660, Speaker A: We were just sort of handling each special case on their own. And that didn't yield the right result. We kept on adding more and more complexity. So the more tests we have, the better our understanding of what we're trying to do actually is. And for record layout, just a single translation unit execution test was selected as the best way to do this. So we had structs, which had constructors, and the constructors would print out their offset relative to the start of the struct, and we would know how far each field was. Pretty simple.
00:07:54.660 - 00:08:45.826, Speaker A: And one of the other goals of this was to not just generate a huge plethora of an abundance of tests. We didn't want like a million tests, all testing like, oh, what happens if we have a struct with an array, with one element, with two elements, with three elements, with four elements? We wanted to have interesting test cases, each of which pointed out an interesting quirk of the ABI. And version 0.1 of the fuzzer was very simple. Because of this, all it did was generate hierarchies of classes. We wanted it just to just fill the classes with fields there would be very simple fields, they wouldn't be class types, they would just be the simple C scalar fields, types like int and char and long and double. No support for bit, support for bit fields, but no arrays or pointers to data members or member functions or virtual methods or any of that fancy stuff.
00:08:45.826 - 00:09:40.466, Speaker A: No pragmas or attributes as simple as they possibly could be. And yeah, all we wanted to do is dump the offsets of all the fields and it should be pretty simple. Unfortunately it wasn't. The other compiler that we were comparing against had decided that the class on the right was somehow inferior to the class on the left, even though they are almost identical. In fact, they give almost identical error messages for almost the same types. And this turned out to be actually a huge problem, because if we spend all of our time generating the wrong kinds of test cases, we're spending time not fixing or finding bugs. So we determined that having a very high failure rate just would cripple the fuzzer.
00:09:40.466 - 00:10:19.614, Speaker A: We would be spending time just burning cpu cycles, making the room very warm. We weren't actually getting anything done, so eventually we figured out the algorithm. But in the meantime we decided to. We had a model where we didn't actually get a lot of stuff done, but then we figured the algorithm out and it was really nice. We were able to very quickly generate hierarchies that the other compiler liked. This actually turned out to be incredibly successful. We found, I think, dozens of bugs this way, and then we added support for more features.
00:10:19.614 - 00:11:08.530, Speaker A: Pragmapack and decalspec align pragmapack is a feature that lets you take the alignment of c class or structure union down to one. And decalspec align allows you to specify that a field in a structure class or union has this particular amount of alignment. And here's one of the examples of one of these test cases, right, we would have struct a followed by struct b. Both of them are empty. We have struct c, which virtually inherits from a and b and is surrounded by a pragma pack. And we'd have struct d, which has inheritance from c. And crazily enough, the alignment of D and the alignment of C are different, even though they have the exact same layout.
00:11:08.530 - 00:11:59.362, Speaker A: Why? Well, it turns out that the ABI has a particular quirk that requires this kind of behavior. It actually naturally falls out of their algorithm. It's just, we didn't know about this. And to be honest, I think it would take a real hero to figure out that it requires two consecutive empty virtual bases to trigger this behavior. I don't know how many people use empty virtual bases or decide to configure them consecutively, but I'm not one of them. So I realized that there were actually two different ways to fix this bug, and I decided I would try one way and see where that led me. And it led me here, which is almost the exact same test case, but the pragma pack is moved to d, and it looks like I made the wrong decision and I went down the other road.
00:11:59.362 - 00:12:54.658, Speaker A: And then both of the test cases worked, and I was a happy person. But it just goes to show how complicated this can be. The number of test cases that you could potentially write is infinite, right? You could add as many c plus plus classes and structs and whatever to your program as you'd like. But I think reducing the test down to the minimum number of elements is vital to getting an understanding. And eventually, once this test case was found, we understood why the behavior was the way it was. So let's talk about default operators. So it turns out that clang will generate you default operators like copy constructors, like you want to copy some non pod type x around.
00:12:54.658 - 00:13:37.470, Speaker A: Sure, great. And if it feels that it's profitable and valid and correct to do this, like it's not a complicated, nontrivial copy constructor, it will go ahead and do this. And almost always it worked. Sometimes it would get it wrong because it would make an assumption. It would assume that the, this that you were copying around was always, you know, over here, when actually it sometimes could be over there. And, you know, the, the problem is, you know, trying to be really clever can really bite you in the butt. It's really hard to think about all of the possible things that can go wrong because c is very, very complicated.
00:13:37.470 - 00:14:37.110, Speaker A: So one of the other things that clang has to do a lot is turn C types into LVmir types. We need to synthesize an IR type in many different situations. For example, if you had a pointer to a c plus plus class and you wanted to load one of the fields, well, you need a type to describe where is the field relative to the start of the pointer. If you want to do point arithmetic, you need to do all these sorts of things. You also need an LVMI or type to do initialization. If you had a global variable, and we have to have a way to describe what type that variable is. If you have an LlvM function that takes arguments, we have to come up with types to describe the arguments to describe the return type, we have to have Llvmir types for all of the places where we have these C types.
00:14:37.110 - 00:15:12.430, Speaker A: And it turns out that there's actually different algorithms in Clang's code gen to synthesize these types. So here's a little cute example. Meet CG record layout. He's this friendly little component in Clang that he code genrecord layout. It's pretty clear what he does, right? Well, not exactly. So we had this union starts with a double trails with a long long, and we want to zero initialize it. We just have u space, u semicolon.
00:15:12.430 - 00:15:58.862, Speaker A: Well, it turns out that in c plus plus, the first named union member is the one that gets to be initialized. It also turns out that almost all compilers get this wrong, and the compilers that get it right are not the ones you would expect. And the code that does this is relatively simple because it leverages a lot of the work that we did in earlier phases of the compilation. So a lot of this stuff was already figured out when we got to the ast building phase of compilation. And this is actually great. I haven't found too many bugs in CG record layout since we rewrote it, because the old one had a ton of bugs. So then here's this slightly different test case.
00:15:58.862 - 00:16:45.770, Speaker A: So instead I chose to initialize the second field in the union. And it turns out that the type that CG record layout builder tried to synthesize is no longer appropriate for this global variable. And because of that, the type was for a double. And we're trying to initialize a long long. We can't initialize a double with a long long value, so we have to do something else. So construct builder de novo from scratch builds a new Llvmir type, which means that it has to do all of this really complicated work again on its own with a from scratch implementation. And it's complicated, and it had bugs, it had non trivial bugs.
00:16:45.770 - 00:17:31.354, Speaker A: I would wish on no one to try to find these sorts of bugs. It would take you a long time. And in fact the bugs have been in there since the code was written, because it's very subtle where it goes wrong, and you might think to yourself, well, why can't we just have one algorithm to do both of the jobs? It turns out that unfortunately we can't. CG record layout is very useful. It allows us to describe a type in memory. Construct builder is also very useful because it allows us to describe types that CG record layout can't describe. So I actually spent a bit of time trying to merge the two together so that we would only have one type generation facility in clang.
00:17:31.354 - 00:18:17.580, Speaker A: But it didn't actually work out because of unions and pointers to data members. And the horrors of trying to come up with ways to initialize virtual table pointers, it actually gets kind of sophisticated. Sorry. So, speaking of virtual tables, what about virtual tables? Well, certain abis are endowed with a virtual base table and a virtual function table, and others concatenate the two into one. Minor difference. The concatenation is prettier, arguably, but conceptually, they're the same thing. I will use the virtual function virtual base table nomenclature, though.
00:18:17.580 - 00:19:00.490, Speaker A: Virtual function table entries might point to virtual functions, or they might point to thunks, which delegate to virtual functions. Sometimes the thunk will adjust the dispointer. Sometimes the thunk will adjust the returned value. Sometimes the thunk will adjust both. And we also have RTTI data, which also lives in the virtual function table. And it has to be able to accurately describe stuff like accessibility from one base to another, where the virtual links are between bases. And it has to be able to describe all of the information you could possibly need to implement something like dynamic cast.
00:19:00.490 - 00:19:34.898, Speaker A: And that actually turns out to be a lot of information. So initially, the first thing I needed was not a fuzzer, but a tool that allowed me to compare v tables. So I wrote one based around LLVM's obstaml. And the first thing I actually had to do was make sure that obstaml actually generated valid yaml, because it didn't do that. So I couldn't use it. And then I worked on it, and then, bam, I had this great tool. I could slurp up an object file, turn it into this dictionary of stuff.
00:19:34.898 - 00:20:05.200, Speaker A: And I had like a little python script that would walk around the yaml and tell me where all the data was. And I was able to do some comparisons. And this was actually very useful. We were able to find a number of bugs this way. And then eventually a dedicated tool is written, because obstyml is really slow. It's not like mostly obstaml or like almost all of the obstaml. It takes all of the text and puts it into strings, and it has to read everything out, even the stuff you don't care about.
00:20:05.200 - 00:21:12.500, Speaker A: So a dedicated tool is written, and it's much faster. It can very accurately take apart RTTI data and give you a very pretty view of the world. And hopefully this is visible on that screen. But it's just a dump of a typical lovmv table dump output. And we can clearly see where all the virtual function table entries are, all the virtual base table offsets, what the RTTI data looks like. And lvmv table dump does its best to have a very stable output so that all you need to do is run diff and you can immediately see where the vtable entries differed. So here's like a typical test case in which something went wrong, where Klang decided that to generate code for this hierarchy, which again, God bless you if you use this many virtual bases, but in my life I've never had to write a single program with them.
00:21:12.500 - 00:21:43.546, Speaker A: We have a single struct, a guy who returns an f. We have a struct b guy who virtually inherits from a, is an overrider for f and also has a constructor. And that constructor is actually important. If you remove the constructor, the contents of the v table change. It's actually kind of nutty. And then we have struct c, which virtually inherits from a and directly inherits from b. So it virtually inherits a twice.
00:21:43.546 - 00:22:38.320, Speaker A: And that's kind of nuts, because if you were going to write struct c, you already know that b does this virtual inheritance for you. Why would you write it down again? Well, again, that actually matters even though it doesn't affect the layout. You already only have one copy of a in your complete object. And what ends up happening is clang will generate a V table that only has a single entry in it, which is the thunk. Microsoft will correctly generate a VF table that will have the thunk and the guide the thunk designates to, but it won't do any kind of return adjustment. So if you had a pointer to a struct b, and you cast that to an a, and then you called f, you would get a garbage pointer back out. You wouldn't get a pointer to an a object.
00:22:38.320 - 00:23:44.730, Speaker A: And it turns out both of these compilers for the same exact test case get it completely wrong. We managed to make it, at least for this test case. Clang is correct, which is kind of nice, but who knows how much code we've successfully compiled with clang before we hit this test case. It would take ages, I think, for a normal user to, at their computer, sit down and type out exactly this test case. Things get a little bit trickier if you want to figure out what the layout of things which are pure are, because you can't actually construct a pure type, it'll say, sorry, you can't allocate an object of this type. It's pure. But you can do a tricky thing where you use decalspec DlL export, and in order for struct a or struct b to be used across interface boundaries, all of a sudden all of its virtual functions and virtual function tables and all of its other ABI minutiae must be visible across an API boundary.
00:23:44.730 - 00:24:34.686, Speaker A: And this was actually mighty useful. We use this trick over and over again to find bugs in all sorts of really weird places where something assumes that, oh, we can never possibly have a copy operator for a pure thing. That'll never happen. Like, no, actually it can happen. And the fuzzer was instrumental, I think, to our implementation of RTTI. Before the fuzzer, we sort of worked on ABI components and we found ourselves sort of writing test case and figuring stuff out. But RTTI was the first thing written after the Fuzzer and I was able to generate a lot of really nice test cases for RTTI as RTTI was being developed.
00:24:34.686 - 00:25:09.150, Speaker A: And we were able to very quickly iterate on exactly what each of the undocumented bits in some bit field did or what behaviors were supposed to occur. It was actually really marvelous. I don't know of any bugs in our RTTI implementation. We have not had any reports. I've run the fuzzer millions of times by now and still nothing. It looks like it's correct. So virtual tables don't seem so hard compared to record layout.
00:25:09.150 - 00:26:15.640, Speaker A: It didn't seem like that big of a deal. But it turns out that the compiler we're comparing against has these really unfortunate bugs where they'll go and they'll generate bad stuff. And we want to know whether or not we're right and we don't want to generate the wrong thing just so that the fuzzer tests will pass. We want to generate good code and kind of smirk at their bad code. We don't want to generate the same bad code. So we have to unfortunately develop these heuristics which determine whether or not we're correct and they're wrong. And this is annoying, but actually definitely worth it, you know? Like the trade off is rather unfortunate, right? We find ourselves with a lot of cases where we have to simply say like, yeah, I mean, I guess, I guess we're right and I guess they're wrong, but the alternative is to basically fill up our bug database with a whole bunch of their bugs, which doesn't seem that great either.
00:26:15.640 - 00:26:52.934, Speaker A: And also what I found out as I was working on this project that non virtual overloads, which are things that don't go into the v tables, actually can have an effect on the virtual table contents. And this kind of blew my mind when I heard this from my colleagues. Like, really? That's actually a thing. So I went and I taught the fuzzer how to add these. And surprisingly enough, there weren't actually any bugs across this boundary. We apparently had enough tests to actually get this correct. But it was surprising as a person who was writing a fuzzer.
00:26:52.934 - 00:27:41.086, Speaker A: And I would imagine to most people writing tests for C plus plus Abi, that, yeah, your non virtual overloads can actually change the behavior of your virtual things, which kind of like. So string literals, that's a thing that matters. They can be mangled. What does it even mean? I don't understand why? Yeah, well, it turns out that under this Abi, the only way to get string literals to merge together across translation units is if you give the string literals a name. You got to give them a name, and then they can sort of fold into each other. So here, let's look at some pretty little examples. Hello.
00:27:41.086 - 00:27:52.034, Speaker A: Right? Question mark, question mark. Underscore c at, underscore zero, six, Ganfod at. Hello. All right. And then some other junk at the end. Okay, sure. All right.
00:27:52.034 - 00:28:33.940, Speaker A: And then, of course, everyone's favorite wide characters, slightly uglier. Right? And this was actually really tricky. It took me a long time to figure this one out. And eventually what it came down to was I had been staring at manglings for so long, so long, that I knew just by looking at it that everything before the at hello was actually a number. That Ganpod thing is a number, believe it or not. I don't know why they don't choose to just write a number there, but they encode their numbers in a very special way. It's like hexadecimal offset from the letter a.
00:28:33.940 - 00:28:56.920, Speaker A: Sure. Okay, works for me. I can work with that. And then what was before that hexadecimal number was some sort of length. That's what that six is. That's my hello. And then that zero appears to be always zero, except if I make it wide, in which case it turns into a one.
00:28:56.920 - 00:29:35.140, Speaker A: Okay, interesting. So, I had been working and working and working, and I thought I figured out the scheme, but I wasn't sure, unfortunately. Right? Because it could be arbitrarily bad. Like, who knows what's after that hello, like, hello, question mark, dollar cb, dollar aa at. It could be really seriously problematic. And without the ability to merge strings. Large programs can become really large.
00:29:35.140 - 00:30:14.426, Speaker A: So what I did is I wrote a little custom fuzzer. I thought I figured out the scheme, and I wanted to actually see if I actually figured out the scheme. And all it did was generate lots and lots and lots of string literals. And before long I figured out this guy. This is exactly what goes into that ugly, ugly, ugly string. We know that zero means character, one means wide character. We don't know what they've chosen for car 16 or car 32 because they haven't chosen anything for them yet.
00:30:14.426 - 00:30:53.040, Speaker A: They don't implement those features. But when they do, we'll figure it out. Then they follow it by the length of the string, followed by a crc of the string encoded in hexadecimal, including the null terminator, which was important. And then they have four different ways, four or five different ways of encoding characters, which was really exciting to figure out. And with that we were able to generate a way to merge strings together. This was really cool. It saved actually like megabytes of object file, which was great.
00:30:53.040 - 00:31:18.610, Speaker A: Interesting to note, because there's a CRC in there, and crcs are no different from any other hash function. They can have collisions. Well, interesting things happen when your strings mangled to the same thing. Very interesting things. It's a little too exciting, maybe. So let's categorize, let's figure out. Did this approach work? Well, 96 Abi bugs have been found since the fuzzer was written.
00:31:18.610 - 00:31:50.960, Speaker A: And the bug numbers, in bold are the ones that the fuzzer found. And the ones that are unbold are the ones that poor humans found. And I would say that's pretty successful. That's like two thirds of our bugs were found by some machine. Instead of someone starting from chrome not working and working their way down to three lines of code, I think that's a pretty good testament to. Hey, it works. Thank you.
00:31:57.510 - 00:31:58.820, Speaker B: Okay, any questions?
00:32:00.550 - 00:32:08.274, Speaker C: Sure. Yeah. So let's say while hacking something, I. Some virtual table entry is not correct.
00:32:08.392 - 00:32:09.010, Speaker A: Yeah.
00:32:09.160 - 00:32:12.946, Speaker C: How will this find this catch that bug?
00:32:13.138 - 00:32:35.870, Speaker A: So if no compiler ever gets it correctly, it won't without an execution test of some sort, or an oracle compiler, or someone looking at the output of lovm vtable dump. But if there is at least one compiler that gets it correctly, you can compare with that one and you'll get something saying that these two compilers disagreed about this particular vtable entry.
00:32:36.290 - 00:32:42.670, Speaker C: So it will create some kind of dump that you will compare against two compilers.
00:32:43.410 - 00:32:57.062, Speaker A: Yes. This output, this output is diffable it's stable, it has a very careful sorting order so that if you have two compiler outputs, you'll be able to very quickly see exactly what's different.
00:32:57.196 - 00:32:57.880, Speaker C: Okay.
00:33:02.010 - 00:33:02.758, Speaker A: Sure.
00:33:02.924 - 00:33:04.834, Speaker B: Did you look at all at Csmith.
00:33:04.882 - 00:33:26.000, Speaker A: And C reduce either for minimizing your test or making structs? I have been using C reduce recently. I haven't been using Csmith for this sort of thing. I don't think Csmith knows much about this sort of C stuff. So I feel like to me it was just really easy to hack this sort of thing together. It didn't take too long.
00:33:30.920 - 00:33:35.620, Speaker B: Have you tried applying this to other APIs other than the Microsoft API?
00:33:36.200 - 00:34:12.870, Speaker A: Yes, I have actually. And I have found that we are not completely conformant against the itanium API. There are open bugs. If those of you who are sufficiently inclined to fix bugs involving attribute align and bit fields, there are bugs for you there, but they're not simple. Both GCC and client do things and it's not entirely clear what they were trying to do. Yeah. Nice work.
00:34:12.870 - 00:34:17.146, Speaker A: Thank you. Working out of the dark and figuring out stuff.
00:34:17.328 - 00:34:20.198, Speaker C: Did you report those bugs to the MS folks?
00:34:20.294 - 00:34:22.700, Speaker A: I have, yes. Okay, good.
00:34:31.340 - 00:34:36.108, Speaker B: You said you develop heuristics to decide whether your compiler was wrong or the other compiler was wrong.
00:34:36.194 - 00:34:37.292, Speaker A: Do you talk a bit about those?
00:34:37.346 - 00:34:38.156, Speaker B: That's interesting.
00:34:38.258 - 00:35:37.760, Speaker A: Oh, they're very simple heuristics. So it turns out that if you have certain virtual hierarchies, the other compiler will faithfully do the wrong thing every time. And what we assume is that if we generated a particular kind of thunk, because awesomely, there are like three different kinds of thunks in this Abi. If we chose a particular thunk and they chose a different specific kind of thunk, and we had this specific kind of virtual inheritance, we assumed that we were on the site of justice and they were on the site of evil. And every time it's shown to be that for all the test cases that I've looked at, and there are actually a number of bugs, or a number of bugs in the LVM database which are actually not bugs in our compiler, it's a bug in the other compiler.
00:35:41.320 - 00:35:50.012, Speaker B: So are you trying to make clang use Microsoft's ABI on Windows? I mean, is that sort of your goal?
00:35:50.176 - 00:35:56.360, Speaker A: It already does that. We can compile chrome with the Microsoft API and it runs and passes all the unit tests.
00:35:56.860 - 00:36:00.490, Speaker B: So that's the ultimate goal of this work.
00:36:02.220 - 00:36:40.660, Speaker A: So some of these bugs actually are ABI independent stuff, like generating the right kind of Lvmir type for a particular kind of C plus plus class. Those are sort of bugs in the neutral zone of client code gen. But in general, understanding why something went wrong is generally very useful. You get a better understanding of how the system works as a whole. I learned a lot. I didn't even know there was this other way of building types. I have worked on clang for quite a while and I just never ran into this construct builder guy just showed up and got stuff wrong.
00:36:40.810 - 00:36:46.090, Speaker B: So now that you've done this work, could you propose Klang's Abi as a standard?
00:36:47.180 - 00:37:02.110, Speaker A: I think there are other people who are trying to do something like that in the C standards committee, trying to at least get, sorry, to get platforms to specify their ABI, and I think that's a good idea.
00:37:07.500 - 00:37:16.232, Speaker C: Do you test the constructor and v tables during constructor and destruction?
00:37:16.296 - 00:37:49.690, Speaker A: Yeah. So the Microsoft ABI does not have constructor or destructor v tables. It has its own scheme that mostly works in lieu of constructor v tables. Constructor v tables are not a thing that LvM v table dump understands upstream, but locally I have patches to make LVM v table dump dump itanium rtt I and artenium v tables and I should probably go home and commit that.
00:37:54.380 - 00:38:01.540, Speaker B: Okay, other questions? Okay, thank you very much.
