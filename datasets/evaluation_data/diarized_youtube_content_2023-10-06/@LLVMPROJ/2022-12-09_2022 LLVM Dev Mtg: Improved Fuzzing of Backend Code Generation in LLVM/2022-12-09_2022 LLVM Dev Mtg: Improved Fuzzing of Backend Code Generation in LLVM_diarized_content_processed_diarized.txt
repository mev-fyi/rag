00:00:01.290 - 00:00:42.090, Speaker A: Hi everyone, I'm Peter and today we'll be talking about IR fuzzer. We improving fuzzing with more diversified input or our experience here at AMD and UC Davis to fuzzing lvm backend. So first of all, what is fuzzing? Fuzzing is not just input generation. After you generated that input, you still have to execute it and then monitor if there is new behavior in your program. Ever say a new feature has been executed? So if you do have a new feature being executed, you will send that input to the store and then try to mutate it further. So that's a loop. But what are we expecting when we are fuzzing lvm with that loop? First of all, we want the input to be complete.
00:00:42.090 - 00:01:09.470, Speaker A: We want to be able to generate all possible inputs that are out there. But second, it's kind of conflicting. We don't want invalid input to getting there. If the program aborts early on because you send it invalid inputs, that's just not interesting. And third, that's something not much people have ever noticed. Behavior monitoring. You need to know very precisely if you have executed new stuff and eventually throughput.
00:01:09.470 - 00:02:11.730, Speaker A: How fast is this loop turning? The faster you're going, the better you're testing, right? So here are some previous tools and our tools comparison csmith I know a lot of people are using it, but actually it's not a fuzzer because it doesn't have feedback, it doesn't tell you how your input is doing. Icl fuzzer comes with LVM, so you can use it right out of the box. But it has limited support and only a bunch of scalar IRS has been generated. And AFL Plus plus is a very mature tool that has been used widely in other applications, but it only generates by the ray, so we can say it's 100% complete. It generates all possible inputs out there, but most of them are just not valid. That's our improvement here. First of all, we introduced more IR features so that you can generate a more complete LVmir, and then we introduced a matter table monitoring to tell you if a new pattern in the back end instruction selection has been triggered.
00:02:11.730 - 00:02:53.934, Speaker A: So let's talk about monitor first. Our key idea here is that if you mutate a nonvalid IR using a non valid way, the output should still be valid. Yeah, so we started off with first mutate a library in LVM, and we added more support, including more instructions, more vector operations, function calls we can call intrinsics and function signatures. We generate random control flow graphs using switch, using branch, using return and global variables. Here's one of the code that we generated out of nothing. A lot of things are actually abnormal here. You can see we have constants overflowing size one vectors.
00:02:53.934 - 00:03:34.160, Speaker A: Switch branch switches that only have one branch, but still it's compliant with language reference, so it should compile. But our experience is sometimes it doesn't. Now let's talk about matcher table monitoring. What's that traditional code coverage is say I track the control flows and see if there are new edges being executed. But that doesn't really work with back end because control flow doesn't really correlate with the machine instructions you're generating. Most of the information is encoded in this matcher table. So our solution is to track this table and use control flow table together to determine if this input is interesting or not.
00:03:34.160 - 00:04:02.498, Speaker A: So our funding here is that we have found 30 bugs in LVM. 14 of them has been fixed. The slice is not updated, we just fixed two last week. And some of the things that we want to highlight is one, we find infinite recursions in the optimizer. That means sometimes fixed point algorithm never converge. And we also find that length one vectors, like I mentioned earlier, sometimes cause problems in the back end. Many developers never realize this thing existed.
00:04:02.498 - 00:04:40.914, Speaker A: They just assume that size one vectors should be a scalar and then be done with it. So finally our conclusion. First one is that fuzzing helps you find a lot of unexpected things. This has been well received in fuzzing community, but not elsewhere. So if you haven't started doing fuzzing, please do it with whatever application you have. We have found bugs that's sitting in LVM code base for six years and documentations that's not really clear for I don't know how long. Yeah, and the second thing we want to highlight is that specialized fuzzing can help you discover bugs better than generalized fuzzing.
00:04:40.914 - 00:05:01.360, Speaker A: If you have a front end, do flue byte mutation. Pretty awesome. But if you have a back end that needs specialized input, do structured fuzzing. And I think my time is running. Also, if you have any questions, please contact me. We are really happy to answer any questions regarding fuzzing and I can thank you.
