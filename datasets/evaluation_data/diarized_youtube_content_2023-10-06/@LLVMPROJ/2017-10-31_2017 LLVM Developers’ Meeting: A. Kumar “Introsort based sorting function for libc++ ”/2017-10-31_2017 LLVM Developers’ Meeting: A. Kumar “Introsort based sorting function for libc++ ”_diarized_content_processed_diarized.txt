00:00:00.330 - 00:00:43.174, Speaker A: Last and the least lengthy lightning talk. Yeah, it's a small presentation. This is in continuation this is in continuation with our presentation from the last year where we optimized a bunch of other lip C libraries and lib standard C libraries and we presented at CPP now know. So this time we have only one function which is I guess very useful to optimize. So we did, yeah, still from 70s. We are dealing with quicksort in lipsy plus. The sorting the standard sorting algorithm uses quicksort.
00:00:43.174 - 00:01:36.758, Speaker A: And I am pretty hopeful that all of you are familiar that Quicksort has a worst case complexity of n square. So it doesn't trigger often. But if you have a very synthetic pattern, basically if you have cycle in the magnitude of variables like higher and lower, something like that, and there is a synthetic test case which is in LLBM Bugzilla. If you use that sequence, you'll see on square time complexity for quicksort. So the idea was to optimize this GCC lib standard C plus plus already does this. The algorithm is called introsort, which is a hybrid of quicksort and heapsort. So yeah, there is nothing so fancy about it, but the implementation in standard library you have to deal with like reading lot of leading underscore variable names.
00:01:36.758 - 00:02:07.190, Speaker A: So it's kind of tricky in that sense. Yeah. So quicksort in lip C plus plus has a worst case of n square and it also uses recursion. I don't know, there is a reason, I'll explain later, why they use recursion. Probably in the worst case the recursion can go to log n and that can kill your performance in some cases at least. So we had basically two improvements. The first one is converting the algorithm to introsort.
00:02:07.190 - 00:02:59.666, Speaker A: So introsort is when you start going into recursion and the recursion depth increases beyond a certain limit, like there is a threshold which is close to n log n. Then you just switch to heap sort. And heap sort is already implemented in lip C plus plus called as standard partial sort probably, I guess very few of you know. So we just call partial sort and it just works, only a few lines of change. The other part is eliminating the recursion. Now that was tricky because it's a standard way to eliminate recursion is to use a stack, some kind of array to store the variables. But when you're dealing with standard library, it's tricky because you cannot just use standard stack because standard stack uses standard deck and deck uses algorithm.
00:02:59.666 - 00:03:42.506, Speaker A: And we are changing STD algorithm. So it's a cyclic dependency. So we had to come up with our own hacky version of standard stack. So these are two different patches, but even with the first one, once you convert the standard sort, to use the intro sort, you gain like an order of magnitude improvement. So this is the graph. This graph shows that the last two test cases are exploiting the worst case time complexity, so you can clearly see a huge improvement. The other patterns basically are like random test cases, like increasing order, decreasing order, and random patterns.
00:03:42.506 - 00:03:51.560, Speaker A: You can see that we are not regressing in any of them. So that's a good thing. You are only getting good parts. So, yeah, that's it. Thank you.
