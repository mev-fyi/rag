00:00:00.570 - 00:00:43.420, Speaker A: Hi, I'm Justin, this is Aditya and Daniel. We work at Apple on the GPU compiler backend, and today we're going to walk you through how to get started on porting your backend to global ISL. So there's a few things you need to know when you're trying to port to global ISL. So we're going to kind of walk you through. We're going to give you an overview of kind of what a global ISL backend looks like. We're going to kind of talk about testing, and we're going to point out how you can go about writing tests as you go and test individual components of your back end as you make progress. We're going to try to point out places where you can kind of parallelize work and where there's kind of bottlenecks where you need to do something before something else.
00:00:43.420 - 00:01:30.540, Speaker A: And we're hoping that by the end of it you have kind of a good idea of where you are and what you need to do next. So we thought for a tutorial you'll want some examples. And we thought about drawing examples from AR 64. But you know, AR 64 is a pretty complex back end, right? It has about 50,000 lines of code. So what about other back ends? They're all pretty big, right? So what we ended up doing is we actually took the smallest backend we could find and we went ahead and implemented a good chunk of global isol in it, and we're going to use those examples to talk you through how things work. So BPF is actually a pretty good back end for reference here. It's simple in a lot of ways.
00:01:30.540 - 00:02:26.566, Speaker A: There's only one register class, there's one legal type, there's a single calling convention. So in a lot of ways we can kind of show you a complete example kind of end to end. On the other hand, there are places where we need to illustrate some complexity because you'll need that in your implementations. So in those cases we'll kind of point at AR 64. So global icel more or less consists of this kind of core pipeline of passes, the IR translator, the legalizer regbank select, and the instruction selector itself. And to implement these in your own backend, you implement kind of these objects that do the target specific parts of these, the call lowering the legalizer info, Reg, bank info and the instruction selector. So we're going to talk you through kind of wiring up global ISIL and then each of these passes now you'll notice I kind of changed the order on you here we're actually going to talk about the register bank stuff before the legalizer.
00:02:26.566 - 00:03:17.930, Speaker A: The pass pipeline goes the one way, but it is important to kind of get started on the reg bank select stuff before you get into the legalizer because there are some places where it kind of needs to refer into it. So I said we'd talk about testing. And what does it look like to test global IsL? Essentially we can write really targeted, specific tests in global ISL using Mir, the machine IR representation. And so LSE has this run pass command line. You can call that and run just one pass over like a single function and do really small targeted tests. So you can get mirror from lvmir using LSE's stop after command. And if you want to take that as the basis for a test you're going to write, you might want to use simplify mirror, which rips out some of the kind of more detailed stuff that you don't necessarily need for hand editing.
00:03:17.930 - 00:03:45.614, Speaker A: So given an llvmir function, what does the mirror look like? Here's a simple function that doubles its input, returns that, and here's that same function in mirror. So you can see there's kind of some metadata, there's a name, there's some other stuff there. And then there's this block that's the body. And that's kind of the important part. And that's what we'll show you later. And in there, there's obviously some offcodes. You have some instructions and you have some registers.
00:03:45.614 - 00:04:09.500, Speaker A: Now the registers are either named like this, r one, R two. Those will be the actual target names of the registers. Or they're these virtual registers which are numbered. Now the virtual registers have some extra stuff after them. And these are kind of these constraints. So they'll be the register bank or the register class. Sometimes the type is there and they kind of tighten up as you go into more and more specific things depending on where in the pipeline you are.
00:04:09.500 - 00:04:52.486, Speaker A: The other thing to note is you may have noticed these registers aren't in order. They're not zero one two here. It's dangerous. Well, you don't want to rely on the exact virtual register names because they can change really easily. So it is important when you're writing these tests to use file checks, patterns, and try to match these things by name so that when your test isn't going to be as flimsy and easy to break. Okay, so with that, let's start talking about wiring up global isol. So the first thing you need to do to wire up global isol to your target is to add kind of the objects that we talked about before to your subtarget.
00:04:52.486 - 00:05:30.802, Speaker A: So you have getters for each of those objects and you're going to back those by unique pointers. The subtarget should own them and you can start out just leaving them null and implement them and initialize them as you implement the actual objects themselves. The next thing to do is to kind of wire up the pass pipeline. So you want to call initialize global ISL in your initialized target function, and then you want to go ahead and actually set up your passes. So there's these hooks in the pass config that are going to add the passes for each of these phases. You have the ir translator, again, all four of them. Additionally here there's a couple more hooks.
00:05:30.802 - 00:06:15.170, Speaker A: If for whatever reason, your target wants to add some extra passes in between these, you can go and call say add pre legalized machine IR to put extra passes between add ir translator and add legalized machine IR if you need to. And finally, there's of course some build system stuff. You have to go and add your files to cmake. When you add TD files, you need to add the table gen rules and there's the dependencies in LVM build text. So at this point you've wired up global ISO. So if you throw a function at it, what do you get? Well, the first thing you're going to hit is this call lowering object we talked about as null, and we need to go and implement that. So I'll hand this over to Aditya to talk about the IR translator.
00:06:15.670 - 00:06:50.880, Speaker B: Thank you. So IR translator is the first pass in the global SL pipeline. So the goal of this pass is to transform LLVM IR into generic machine instructions. And one of the things that happen in this pass is the ABI lowering. So you will implement your targets calling convention by implementing this interface called call lowering. So the three main methods are lower return, lower formal arguments, and lower call. So your ir translator will use your target specified call lowering to perform the API lowering for you.
00:06:50.880 - 00:07:26.506, Speaker B: So let's quickly stub out this one method to get started. So here we have a lower return function, and we're basically saying if there's actually anything to return, we'll give up and return false. But otherwise we'll just create this BPF return structure and return true for now. So you would have to similarly create a simple implementation for the other two methods and just wire them up. And with that, let's give this a shot again. And with this you will now see that you'll get a BPF, the return instruction. So now is a good time to start writing your first test case.
00:07:26.506 - 00:08:02.802, Speaker B: So here we have a function f and we just check for the return instruction. And this is one of the nice things in the global ISL infrastructure where you can write extremely targeted tests. So let's continue. So one of the things that's common between all the backends is figuring out exactly where an argument or a return value goes. And this is mostly done with the table gen functions for you with the calling convention functions. But once exactly the location is decided, what the targets do can vary. So we have this abstraction called value handler, which helps you abstract these differences.
00:08:02.802 - 00:08:51.046, Speaker B: So essentially what the target needs to do is create a handler for each of the method, like lower arguments or lower return, and then create a bunch of objects which represent what you want to copy into. And then pass both of these into this method called handle assignments. And the handle assignments will then use your handler and perform all the loads and stores or copy register copies for you. So let's look at the API. So there are three main methods, which is getstack, address, assign value to address, and assign value to reg. Now if you look at the BPS calling convention, and as Justin mentioned earlier, there's just one type which is I 64, and you are promoting all the smaller types to I 64. And the arguments are being passed through registers r one through R five.
00:08:51.046 - 00:09:33.630, Speaker B: There's one thing that's missing here, which is the return is through registers R zero. So for the purpose of the stock, we'll ignore handling through stack, but you should definitely look at the other backends to see how to do that. So the method we're going to implement is in this class called formal ag handler. So let's look at how to do that. So here you have this assigned value to reg and you're given this valvreg, which is where you want the argument to be in your function, and the physical reg is where it's been assigned. So we first check if it's exactly the same size and we just create a copy from the physical reg to your valvirig. And in case it's not, you just create temporary with temporary generic virtual register.
00:09:33.630 - 00:10:14.746, Speaker B: And you can do this by just giving the build copy a type and it'll create a generic virtual register for you. And then you build a truncation from the temporary to your valve erect. And then you can finish off by saying add the physical register to the basic block. So now you have the handler created we should use that in your lower arguments method. So in this case we have this array which is vrex, which is all the arguments we want to be lowered into. So the first thing we do is create this arg info object. So arg info just has a simple struct which has the destination virtual register, the type and the argument flags.
00:10:14.746 - 00:10:43.430, Speaker B: So we can use this method called set arg flags to copy over all of the flags from the function. And we'll do this for all of the arguments. And you just push this into this vector called in arcs. So now we can instantiate the handler we defined earlier, which is the formal ArG handler. And you'll notice that you're passing in the CC underscore BPF 64 function. This is what Tablegen has defined for us in the calling convention. And then we can just hand both of these into this method called handler assignments.
00:10:43.430 - 00:11:19.510, Speaker B: And we are passing in in args and handler here. So you can actually start writing your test case for making sure this argument loading works. So here we have an I 64 argument and we're making sure there's a copy from R one to a register and followed by a return. And in case it's an I 32 we're going to check that there's a copy to a temporary followed by a truncation from the temporary to another register. So let's look at how to implement return. And for the most part it's almost exactly the same. Your task is to implement a handler and then use your handler in your implementation.
00:11:19.510 - 00:11:55.850, Speaker B: So the only difference here is along with all the other parameters in the handler, we will also take a machine instruction builder. So we'll use this builder to add implicit uses of physical registers later on. Again, your assigned value to reg method will look something like this. So here you have your valvireg and you want to copy it into physical reg. So first we can call this helper called extend register, which basically makes sure that the types are compatible. And if an extension is required it'll create an extent for you. And then you build a copy from this extended register to your physical register.
00:11:55.850 - 00:12:25.254, Speaker B: And now we have this mib which we took in the constructor, and you can add the implicit use of the physical register. So let's look at how to use this in our lower return. So again we have this Vreg. So the first thing we do is create this return instruction and for now we don't insert it into the basic lock yet. So you can imagine it's right now outside. And as before you create this arg info object for your Vreg, and then you copy over your flags. And then you can instantiate a handler.
00:12:25.254 - 00:13:04.166, Speaker B: And again in the handler you're passing in the calling convention function. And the builder and the builder in this case is referring to the return instruction. And when you call handle assignments with all of this, you'll see that it's created a copy from the Vreg into r zero, and it's also added r zero as an implicit use into the return. And in case an extend is required, it will look something like this. And finally you can insert, now that all the copies have been created, you can insert your return in the right position. So now we should be able to write a full test case for both argument loading as well as a return. So in this case you're just getting an I 64 argument and you're just returning it.
00:13:04.166 - 00:13:25.550, Speaker B: And your test will look like this, where the first line is checking for argument loading and the next two lines are checking for return. And probably a slightly more complicated example is making sure the first two lines are handling the truncation and the next two lines are handling the extension. With this, I'll hand it back to Justin to talk about register banks.
00:13:27.170 - 00:14:07.286, Speaker A: Okay, so register banks are a bit of a new concept in global isol, and what they are is they're just kind of these groupings of registers by kind of their basic type. The main thing you want to be concerned with when you're defining your register banks is that they should kind of abstract the cost of copying between them. So if it's cheap or free to copy between two register classes, they should probably be in the same bank, whereas if it's more expensive, they should probably be in different banks. So a typical split is kind of general purpose versus floating point registers. You may also want to deal with vectors in there or something like that. So let's go ahead and define these. So defining register banks in tablegen is pretty straightforward.
00:14:07.286 - 00:14:53.994, Speaker A: You create one of these register banks, you give it a name, any GPR here, and you say which register classes are in it, the GPR here. So BPF is obviously a little simple here because it just has the one. But we should point out here, you do have to be careful about naming collisions here. The register classes and the register banks should not have the same names because there are places where they can show up in the same place in the syntax, and you want to avoid that ambiguity. So let's jump over to AR 64 for a second, which has a few more register classes to deal with. So to group these into register banks you can kind of get away with three. So you have all these general purpose registers and a GPR bank, floating point registers and an FPR that also includes the vector registers in AR 60 four's case.
00:14:53.994 - 00:15:41.674, Speaker A: And then you have a third bank that's just kind of special for the condition code register. Now to define these, you go ahead and you do these register bank definitions again. But now you'll notice here that we've actually only listed a single register bank in each of these definitions. And we can get away with that because the generic code will go and it'll walk sub register classes and sub registers and it will kind of gather up things for you. So in this case we can just use the largest class of each bank to define it fully. The next thing to do once you've done your tablegen stuff is to implement the generated register bank info. Now this is something that tablegen might generate fully for you in the future, but there are some targets that do some funny stuff here.
00:15:41.674 - 00:16:10.580, Speaker A: So for now you have to do this little bit of boilerplate. Once you have that you can go ahead and actually implement the register bank info object itself. Now this has a couple of methods. It has this get reg bank from reg class and a couple of things to do with instruction mapping. So get regbank from reg class is kind of exactly what it sounds like. It takes a register class and you need to return the appropriate register bank. So this is probably just a simple switch and that'll probably do everything you need it to do.
00:16:10.580 - 00:17:08.530, Speaker A: Now I should point out at this point you've actually implemented enough of the register bank info that you can start moving on. You can implement most of the legalizer and most of instruction selection with just this much of the register bank stuff. However, to get the actual register bank selection pass working, we need to talk about these instruction mappings. So these methods, this get instrument mapping stuff take machine instruction and they need to associate each of the operands with the appropriate register bank. So you can usually kind of just get away with calling this helper, this Getinster mapping imple, which will take care of most of the generic instructions for you and it'll just do the right thing for your mapping. If you do want to do something special, you can obviously wrap this and try to take over some of the stuff instead of what the default implementation does. Anyways, you call this and then you call get instrument mapping ample and if it returns a valid mapping, you're done.
00:17:08.530 - 00:17:57.806, Speaker A: If it doesn't return a valid mapping, you need to go ahead and write your own mapping that looks a bit like this. So basically you're going to go and you're going to create this vector of value mappings, one for each operand and the position in the vector should matches the operand number. And these value mappings, they just have to kind of say what the size of the value is and which register bank it belongs in. So in BPF this is nice and straightforward. We just loop over the operands and throw them in any JPR bank. For most backends you'll do different stuff depending on the machine instruction, but you'll kind of switch over the instruction type and then set up your mappings as you need. So at this point we can go ahead and write a test for register bank selection.
00:17:57.806 - 00:19:02.950, Speaker A: And so what do you need to test in register bank selection? Well, you want to go and look to see if that we go from this, underscore this unspecified register class or bank into the any GPR. So we can see after the colon here we have any GPR in our results. We have the same instructions coming out as going in, but we've just specified the register bank. Okay, but what happens if there's kind of more than one option that are reasonable? So for example in AR 64 there's a kind of 32 bit and 64 bit or, and these map equally well into floating point or general purpose registers. Then comes in the Getinster alternative mappings where you can go ahead and create a whole set of mappings that all work. So here we can create a value mapping for the GPRs and a value mapping for the FPRs, set their costs to equal. And then we've kind of described that these are equally good options and these will be used in addition to what you get from the get instrument mapping.
00:19:02.950 - 00:19:26.638, Speaker A: Now depending on your needs you can do different stuff here and the generic code will go and look at the context of where this instruction is going and make a choice for you based on what's around it. And with that, that's all you need to know about register banks. So let's hand it back to Adishev to talk about the legalizer.
00:19:26.814 - 00:19:51.206, Speaker B: Thank you. So the goal of the legalizer pass is to transform generic machine instructions into legal instructions. So what is legal here? So in global ISL, legal is something that you know how to select. So unlike selection Dag, there is no type legalization. There is just operational legalization. That is if you know how to select it, it's legal. So let's look at the legalization framework.
00:19:51.206 - 00:20:23.010, Speaker B: So here we have the legalizer pass which iteratively drives legalization. This uses the target specified legalizer info. So this says which operations are legal and what should you do if it's not? And the legalizer actually will use this helper called legalizer helper. And this contains utilities and common legalization operations for generic machine instructions. So most of the legalization specification revolves around this one API. It's called set action. So set action takes two parameters.
00:20:23.010 - 00:20:53.094, Speaker B: The first one sort of specifies the operation and the second one sort of specifies the action. So the action can be something like legal custom or lip call or widen. And the first one sort of is sort of a tuple of opcode, opine index and a type. So let's look at a few examples. So here on the right you have a few generic instructions and you have a few set action calls on the left. So say we want to make this 64 bit ad legal. You would say set action G add s 64 as legal.
00:20:53.094 - 00:21:28.114, Speaker B: And let's say we want to widen a 32 bit ad. It would be something like set action S 32 as widen and the legalizer will create an extent followed by 64 bit ad for you. So you'll notice that there's an optional parameter in the first parameter which is operand index, and we don't really use it. So it's not really useful in instructions such as G add because all the operands have the same type. But this may not be the case with certain instructions like Gnext. So in this case we have an extent which where the source and the destination are different types. So say we want to make this instruction legal.
00:21:28.114 - 00:22:12.594, Speaker B: You would do that by saying gnext, the destination of S 64 is legal and the source with S 32 is legal. So what the target needs to do to implement legalization in global ISL is to define which operations are legal and what to do when they're not in the legalizer info constructor. We'll also look at one example of doing custom legalization when the standard legalization actions are not sufficient for your backend. So let's look at the constructor. So we just start off with some type objects which we'll just reuse throughout. There is some boilerplate here where G impicit def is the typed equivalent of implicit def and we say all of these types are legal. And for BPF we want 64 bit fees to be legal.
00:22:12.594 - 00:22:59.842, Speaker B: And for all the smaller types we're saying widenet and then we'll finish off by saying compute tables. So at this point we have enough of the legalization implemented to actually test it. So here we can use the run pass equals legalizer option to LLC and we can check that given the input where it's already target instructions, you'll get the same thing back. But if you have something like a gad, in this case it's a generic instruction, the legalizer will complain saying I don't know how to legalize this, but this is really easy to fix. So all you do is say G ad, s 64 is legal, and for all the smaller types you say widen. So now we should be able to write a test case for making sure your G ad works. So here you have the 64 bit ad and you're asserting that the checkline matches a 64 bit ad.
00:22:59.842 - 00:23:53.650, Speaker B: And in case you have something like this where a 32 bit ad is there and you want to make sure your checkline is 64 bit ad. And this is one of the nice things in the global SL API where you can write extremely targeted tests, and I'll encourage you to leverage it. So let's look at one example of custom legalization. So obviously the target needs to implement this method called legalized custom, and you'll say which operation needs to be legalized and you'll set the legalized action to be custom for it as well. So here we're going to try to legalize this instruction g select into the pseudo instruction called VGF selectcc. And later Daniel will show you how to leverage tables and patterns to automatically select this instruction into target instruction. So the pattern we're going to try to match is the select of a trunk of a compare, and we're going to create this BPS selectcC instruction which is very similar to the selection Dags selectcc node.
00:23:53.650 - 00:24:29.378, Speaker B: So here you have the two components, the predicate and the two results. The first thing you need to do is to create a pseudo instruction. This is sort of the way to get an equivalent to something similar to selection DAgs custom as de nodes. So here we are going to define the operands in terms of generic types, which is type zero, type one. This lets you use one opcode to support several kinds of instructions. The other advantage of this is you can sort of specify type constraints between operands. So here we are saying the LHS and RHS should have the same type.
00:24:29.378 - 00:25:02.140, Speaker B: The true and the false value has to have the same type, and it should be the same as the result as well. So as before, the meat of this is in the last line, which is select CCF 64 is custom. And we'll say for everything else widen. So the method the target needs to implement is the legalized custom. This will probably look like a giant switch statement with something to forward the implementation. So in this case we're going to look at how to implement legalized custom select. So here you have this Mi which is the select which is the root of your match.
00:25:02.140 - 00:25:39.000, Speaker B: First thing we're going to do is get all the operands so we can rebuild the instruction. So here we have destination operand, the destination type, we get the comparand and the predicate. So the first thing we're going to try to find is where percent three came from. So here we use the machine register info's getvregdef method and this will give us this G trunk. And similarly we walk the source of this trunk and we get to this GI compare. For now we'll just ignore what happens if it's not a compare and just give up. But obviously your target will need to handle that as well.
00:25:39.000 - 00:26:16.562, Speaker B: So now we have this compare so we can get the two comparands and obviously the predicate operand. So we have collected all the operands we have to rebuild the new instruction. So the first thing we're going to do is reuse the destination register which is percent four. So we can build a new instruction which using the same definition so you don't have to create a new register and then update all users of the new one. And we'll tell the builder to start inserting the instruction right here. So the first thing to do is to create the constant which stores your predicate. So here we can say the Mr.
00:26:16.562 - 00:26:59.474, Speaker B: Builder build constant and that gives us the person seven constant. So now we can actually build the BPF select CC instruction and we are using the same destination register which is person four. And then we add the comparands, you add the predicate and you add the two results. So now that we have the new instruction we can just delete the previous one and we're almost done. So the one thing that you need to do is because the BPF select CC is already a target instruction, the register bank select pass right now will not help you select the destination register. So you will need to set the register bank explicitly. And this is quite easy to do, you just say get me a register bank for this register class.
00:26:59.474 - 00:27:30.910, Speaker B: In this case it's GPR class and it gives you back RB. And then you tell the machine register info to set your register bank and you'll notice that it changed from underscore to any GPR. And we're done. So at this point you should be able to write a test case for checking that your custom legalization works. So you have the select in the bottom and you're checking that the BPF select CC is produced. And you're also obviously trying to pattern match which operands are produced correctly. And you should also not forget to check that the register bank is also defined which is any GPR.
00:27:30.910 - 00:28:31.646, Speaker B: So some good practices that I'd recommend following in the legalizer is first you'll need to start incrementally adding instructions and you should try to add test cases for it. And this is the nice thing about the globalizable API where you can write extremely targeted test cases. And you should use the machine IR builder for all of your building, which may be custom legalization because the builder will track the new instructions that are created and it will also call legalized and it will legalize them for you. And obviously you should not try to erase anything besides the current instruction because there might be some iterators pointing and you shouldn't try to do anything like DC. The legalizer pass currently doesn't do dead code elimination, but this might change in the future. It's currently handled by the instruction selector. And finally, when you are trying to match multiple instructions in custom legalization, you don't want to end up in a situation where you have some sort of an order dependent on which instruction got legalized first.
00:28:31.646 - 00:28:48.310, Speaker B: That is like in this case, you don't want the select to be legal only if the previous instruction was not legal or illegal. So at the end of each legalization step, you want to be either legal or illegal. You don't want to be conditionally legal there. And with this I'll hand it to Daniel to talk about instruction selection.
00:28:48.650 - 00:29:25.582, Speaker C: Thank you. So the main topic I'm going to talk about is importing rules from selection DAG into global ISL. The importer is still in development, but it's able to import quite a large number of rules. Unfortunately, it's not a fully automatic process and it will require some manual work from you. I'll then talk about what you can do when the importer fails. For the implementation of the instruction selector, there's two main functions that are relevant. The first is select.
00:29:25.582 - 00:30:42.954, Speaker C: Impla and tablegen will generate this. It will provide most of the implementation for you. You need to implement the select function, and at some point in that function you will need to call selectimpler. So here's a minimal example of select to get going with we pass through copies to the register allocator and we call selectimpler to select our GMIR instructions into target specific instructions. There's likely several things that you will want to add to this, such as passing through target instructions that you've already chosen to use or handling GFI nodes, but example is that these are in other targets and you can have a look at those if you're interested in that. So now that we're ready to get started importing rules, we need to assess our out of the box situation. The easiest way to do this is to copy and paste a command from Ninja V for generating the global ISL rules and add the stats option to it.
00:30:42.954 - 00:31:38.726, Speaker C: This will tell you how many rules it imported and how many rules it rejected. We haven't got off to a great start here, only 16 rules imported, but it's quite easy to improve on this significantly. Tablegen will also tell you why it refused to import a rule when given the Warnon skip patterns option just like before. The easiest way to make use of this is to copy and paste the relevant command from ninja V and add the option yourself. So the most important reason right now is this. No equivalent instruction BpFISD brcc this is related to a custom SD node which it's been unable to import. Now I happen to know that there's a couple of prerequisites you need to meet before we'll be able to import those particular rules.
00:31:38.726 - 00:32:37.120, Speaker C: So we're not going to look at those first. Instead we're going to look at source pattern child has predicate the fundamental problem with this predicate is that it's written in terms of SD nodes which don't exist in global ISIL. Now the rejection reasons from the previous slide were all pointing at one particular predicate which I had to trim to fit on the slide. It's this I 64 m sx 32. Fortunately, it's fairly easy to replace this predicate with one that global ISIL can handle. And we can replace the pat leaf with immleaf so that we have access to the actual immediate rather than the SD node. And then we can update the predicate to replace our lookup of the immediate with the immediate itself.
00:32:37.120 - 00:33:35.700, Speaker C: This will allow global Isel to import this rule. While we're at it, we'll also change another Pat leaf. In this particular case, we're not sign extending the immediate, which makes Imleaf a unsuitable choice for replacement. Instead we have int imleaf, which is the same thing, but uses an AP int so we can zero extend the value instead. In this case, it's even easier than it was in the previous slide, because we can just replace the N with im and that's it. Before we move on, we need to check that our rule did actually get imported, and that it works as we expect. In this test case, we simply provide a G constant in the any GPR register bank, and we check that it selects the LDM 64 instruction and is constrained to the GPR register class.
00:33:35.700 - 00:34:28.420, Speaker C: That got us a fair few more rules. We're up to 27 now, and now we've fulfilled all the prerequisites for that custom SD node I was talking about earlier. So let's have a look at importing that the pseudo here isn't particularly interesting. It's a fairly standard pseudo. What's interesting here is the GI node equivalent, which maps that custom SD node to a target pseudo. This will allow globalized cells to import rules involving this custom SD node. So yeah, you also need to arrange for something to produce this target pseudo though, because otherwise it won't be there for you to match.
00:34:28.420 - 00:35:06.750, Speaker C: This will often be in the legalizer, but it really depends on your circumstances. It could be in a combined pass, or it could be in target specific pass. In this particular case, conditional branches aren't legal unless we do some further work. So we would do this one in the legalizer again. While we're at it, we'll change another custom SD node. You will have seen this one from the legalizer section when Adicha talked about it. Again, the target pseudo isn't particularly special here.
00:35:06.750 - 00:35:42.330, Speaker C: It's the GI node equivalent that's important. This will cause it to import the select rules, and as long as there isn't anything else, fully import the rule. So that's a big improvement. We're now up to 49 rules imported. Now that we fixed the two major reasons why we weren't importing rules, it would be a good idea to have another look at the rejection reasons to see what the current important things are. The main one now, right now, is source pattern. Root isn't a trivial operator.
00:35:42.330 - 00:36:43.230, Speaker C: These are related to predicates that couldn't be imported because they had C plus plus that hasn't been converted yet. Now, I've gone through the full list of these ones, and in this case they're all related to loads and stores. As we flesh out the load and store importing, these predicates will be imported with no further effort from you. However, rules that involve load and stores typically have complex patterns somewhere in the rule, and these do require some manual work. So with that in mind, we'll take a look at importing complex patterns much like with pat leaf predicates. The fundamental problem is that the C has been written in terms of SD nodes, and those don't exist. So we need to define a global icel equivalent and map that to the original complex pattern.
00:36:43.230 - 00:37:41.120, Speaker C: The declaration of this is fairly simple. The GI complex operand matcher specifies a type to the root of the match to check for, and a c function to call whenever the matches are tempted. We then have the GI complex pattern equiv to map this to the adrari complex pattern, which is a base plus offset check. The selection Dag implementation of that complex pattern covers four main cases, but we're not going to talk about this third case because it's fundamentally the same as the second. It requires exactly the same techniques. There's just a little bit more code to write because there's more nodes. However, there's also this g global value case, which we need to detect and handle because that was also in the original predicate, and I'll come back to this one later.
00:37:41.120 - 00:38:43.570, Speaker C: The first case is this GFrame index. In this case we need to use Getvregdef and get operand to reach through and extract the fixed stack operand and render that to our target instruction, along with an invented zero offset. We return an array of lambdas to indicate a successful match, and each of those lambdas is responsible for rendering one particular instruction, sorry, operand. To the resulting instruction. We return an array of lambdas, because there's a rarely used bit of table gen syntax that allows you to reorder the operands. The next case we have is a base plus offset case, and for this one we have a helper function that will detect the structure, allowing you to just reach through and grab the percent one and the sim 16 and render those to your resulting instructions. Just like before, we return an array of lambdas to indicate a successful match and render those operands to our resulting instruction.
00:38:43.570 - 00:39:39.186, Speaker C: The gglobal value case is somewhat interesting because it's a case where we want to detect and reject something that would be perfectly valid. The reason why we want to reject this is because there's better rules available, and complex patterns typically have priority over everything else. So if we were to allow this one through here, those better rules wouldn't have a chance to match. We return none to indicate that we reject this case. I personally think that this should be a better way to handle priorities involving complex patterns, but there's contradictory requirements involved, and we haven't come up with a good way of implementing this yet. The last case is where you match nothing except what you're given. In this case, we just return the operand we're given and along with an invented zero offset.
00:39:39.186 - 00:40:52.510, Speaker C: And we do this by returning an array of lambdas that render those there's some common predicates that are helpful for implementing this you've already seen is based with constant offset, and I'm sure you can work out is operandim equals. The most interesting one here is is obviously safe to fold, and this will check that a particular instruction that you're matching can be safely folded into the instruction you're producing. This will look for things like intervening side effects or potential load store reordering and that general kind of thing. I've got some overall advice to give you for implementing complex pattern predicates. The first is that the operand you're given isn't const, but you mustn't modify it. The next is that your renderer lambdas need to capture locals by value rather than by reference. This is because they're going to be used after your predicate function returns, and if you capture locals by reference, then you will be left with references to memory that you've already freed.
00:40:52.510 - 00:41:55.810, Speaker C: And this last one also comes under the heading of don't modify Mir, but it's worth calling out separately. Unlike selection DaG, there's no garbage collection that will clean up instructions you create, but then don't decide to use. For this reason, you need to make sure that you only create instructions in your renderer lambda and not in your matching code. So that got us one more rule, which admittedly isn't very impressive, but it would be a lot more if we had the full support for load and store predicates. There's a few known issues that you will probably encounter at the moment, and these are related to work that's in progress or is about to start. The first one is related to load and store predicates, and as I mentioned on the previous slide, these are currently in development and not fully implemented. The main things we're missing right now are extending loads, truncating stores, and atomics.
00:41:55.810 - 00:43:19.100, Speaker C: The other main one that you might encounter is the case where a rule needs to create more than one instruction. This isn't supported right now, and work is about to start to implement this, so if the importer fails, you need to do something else, and what you can do in that case is you can use a C plus plus implementation. So let's try implementing the rule from the previous slide in C plus plus. The first thing we need to decide is which side of the select implical we're going to put our code. Generally speaking, we'd like to put it after the select impler so that tablegen, as it gets better, can take over from your code and start using the selection diagonals instead. Unfortunately, in this case we already import a generic free register, and so if we allow tablegen to have a go first, then it would always match that and our new code would not have a chance to match. So before we write our code, we should create a test case and check that it currently fails, and we'll later use it to check that our code works.
00:43:19.100 - 00:44:26.820, Speaker C: In this case we provide a G and and G constant and check that it produces the shift left and shift right sequence that we want. Just as with the earlier tests, we also provide them in the any GPI register bank, and we check that they're constrained to the GPI register class. The first thing we do in our implementation is test the opcode and check that it's a gand. We then extract the free operands and give them more convenient names for later use. We then check that the operands are 64 bit scalars and that they're in the any GPR register bank. We don't need to test for all free operands because gand has type constraints that require all free operands to be the same type. We then go on to look for our immediate constant and handle commutativity, and whichever way round we match, we've successfully matched our case and we can go on to creating instructions creating instructions is probably much like you've seen before.
00:44:26.820 - 00:45:26.660, Speaker C: It's the same kind of API where you create an instruction and add operands to it. One slight change here though is that this API is able to create a temporary register if you need it to do so. The main interesting thing here is constraint selected reg operands. This will constrain all the operands of the instruction you just created to the register classes that are defined in the definition of the instruction. So in this case it will constrain them to the definition of the shift left instruction. Once we've created the shift left, we can just repeat the same thing for the shift right, and then erase the original gand from our basic block. As a result of erasing that gand, you'll notice that that G constant is now dead, and the instruction selector will notice this as it walks through your code and selects it.
00:45:26.660 - 00:45:57.520, Speaker C: With that, you should have the tools you need to begin porting your target to global ISL. I'll leave you with this chart that shows the amount of rules we successfully imported after roughly a week's work, during which time we were also writing the initial draft of these slides. I've also included a yellow wedge on here, which are the rules that should be imported in the near future. Thank you very much for coming and attending. And is there any questions?
00:46:13.330 - 00:46:25.430, Speaker B: Your example for the custom select with the node was select CC, but I thought the reason people usually do that is to avoid introducing control flow. So is it legalizer still not allowed to introduce control flow?
00:46:25.850 - 00:46:41.950, Speaker C: I don't think there's any reason the legalizer can't introduce control flow. In this case we just have a BPF already had a select instruction, and we've just preserved that into our global ISOL implementation.
00:46:45.330 - 00:46:58.274, Speaker D: Hey, random question, what's with the constraint call after building an instruction? What's the motivation for having that, having to be a separate thing? It seems like kind of awkward overhead maybe.
00:46:58.312 - 00:47:13.730, Speaker A: So you don't always necessarily. The constraint call is the usual way to do it, and it usually does the right thing, but sometimes you'll want to constrain them in some custom way. Right. If you do need to do the work, being a separate call makes it easier to do something more flexibly.
00:47:13.810 - 00:47:29.986, Speaker D: Sure. I was just thinking that you might want to set up the register classes and the instruction ahead of time rather than having to constrain the register, but it just seemed like an awkward API having to call it after every time, or maybe put it into Buildinster as a default.
00:47:30.038 - 00:47:30.782, Speaker A: I don't know.
00:47:30.916 - 00:47:31.920, Speaker D: Just a thought.
00:47:32.370 - 00:47:33.760, Speaker C: Okay, thank you.
00:47:39.010 - 00:48:02.920, Speaker E: So, just wondering. So one of the problems I ran into when implementing global ISO was selecting an instruction like an integer compare, which returns like a one bit virtual register. But when you select it, you're selecting it to an instruction that implicitly defines a condition code register. So I just was wondering if there's any way to handle that case.
00:48:04.090 - 00:48:05.720, Speaker C: Would you like to answer that?
00:48:06.090 - 00:48:07.830, Speaker B: Can I just repeat the question again?
00:48:07.980 - 00:48:08.246, Speaker A: Yeah.
00:48:08.268 - 00:48:24.160, Speaker E: So basically, let's say you have the generic integer compare and it returns a one bit virtual register, and then when you select it, you're selecting it to a machine instruction that doesn't return any value but implicitly defines a condition code.
00:48:27.810 - 00:48:29.822, Speaker B: I'm not sure I can get back to you on that.
00:48:29.876 - 00:48:33.278, Speaker E: Okay. Yeah, when I tried, it didn't really work, so I wasn't sure if that.
00:48:33.284 - 00:48:45.640, Speaker C: Was something that was. So one thing I can comment on that is that the selection Dag importer currently doesn't handle that case. If there's fewer deaths than there were in the original rule, it will just give up.
00:48:53.610 - 00:48:54.920, Speaker B: Any other questions.
00:48:56.810 - 00:49:00.790, Speaker A: So if there is no questions left, let's thanks the speakers.
