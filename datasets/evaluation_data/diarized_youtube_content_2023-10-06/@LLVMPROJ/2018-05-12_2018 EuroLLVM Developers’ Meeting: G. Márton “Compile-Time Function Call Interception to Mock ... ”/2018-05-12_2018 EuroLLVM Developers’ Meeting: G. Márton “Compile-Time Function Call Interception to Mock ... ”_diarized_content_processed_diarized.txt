00:00:00.330 - 00:01:05.010, Speaker A: Welcome dear audience. This is a great pleasure to be here for me. Please let me start with a question. Have you ever been in a situation where you were struggling with testing where you had to refactor a whole class just because of testing? Or perhaps have you ever been in a situation where you had to refactor after a significant part of your applications because you wanted to add a few new tests? So this presentation is about to ease that burden in certain cases when you have some struggling with tests. My name is Gabor Martin. I'm a PhD student at Budapest, Hungary, and I'm going to talk a little bit about the problem I'd like to solve here and a few words about the existing solutions to the same problem. Then I will present our solution and our approach.
00:01:05.010 - 00:02:03.170, Speaker A: Also I will have a few words and a few slides of the future of this research. So imagine that you have a simple server class which so this class really handles requests in multiple threads. And for some reason we have a mutex to synchronize between these threads. And if we can acquire a lock on a mutex then we will do something. Otherwise we will do something else and this behavior might be really important for some reason. So we want to write test for this behavior. How could we achieve that? So one approach would be to just simply create a runtime interface which hides the abstraction.
00:02:03.170 - 00:03:06.386, Speaker A: And we would have two implementations, one for the production code and the other one for the test code. So in details actually we would use the different implementations in this way. I'd like to draw your attention that the ownership of the mutex in the original faux server class has changed. So the original server class is no longer the owner because of the interface. Actually we receive reference or a pointer to that interface. We have to somehow inject the dependency from outside. And for that injection, actually we may call it as a dependency injection, but for that injection we added a new public constructor or that could have been even a sector.
00:03:06.386 - 00:04:01.224, Speaker A: But the point is that we had widened the public interface just because of testing. Another approach would be to do something similar, but with compile time polymorphism instead of front time polymorphism. So the idea is the same as previously, but this time we have to make the whole class to be a template class, right? And this might be a burden. Just think about the original structure and the original class might have been scattered around in several translation units. And this time we made it template. It has to be in a header file. So both this approach and the previous approach has some serious disadvantages and some serious effects on the original structure we had.
00:04:01.224 - 00:04:51.188, Speaker A: This is what I call struggling with tests. On the other hand, there are certain tests or certain way of testing where we don't have to change the structure, we don't have to change the original structure. This testing is called nonintercise testing and this can be really useful also in case of legacy code bases. Let's say we have a big legacy system without any unit test. We would like to do some further development on that system. So actually we should have some tests in order to verify that we don't break havoc the existing behavior. So nonintercisive testing is not a new thing.
00:04:51.188 - 00:05:40.820, Speaker A: There are tools for nonintercive testing. For example, LD preload, the environment variable can be used to change a shared library for the purpose of testing. However, setting up text executable to be loaded with a different shared library can be cumbersome. We have to use somehow the build system, so it is not trivial what's happening. It cannot be seen in the test code, in the source test code right now how we set up the test itself. Also another tool is the so called instrument functions compiler instrumentation. This can be found in GCC and in clang as well.
00:05:40.820 - 00:06:35.320, Speaker A: It emits hooks at the beginning and the end of a function. So this way we may alter a dependent function's behavior. So once again, what we want to achieve here is to be able to write tests without changing the original structure and keep the test setup as simple as possible and as visible as possible. In this example, we say that, okay, please replace the trilog member function with a test double. And with the help of that test double, we can actually exercise the units under test. That's how simple the motivation is. So our solution is actually a compile time instrumentation.
00:06:35.320 - 00:07:47.250, Speaker A: We instrument every call expression. And this has an advantage in case of shared libraries, for example, because we don't have to recompile the shared libraries, we just have to compile, recompile that part of the code where the call expression itself is. So we can easily replace system functions and other third party functions in our system. The architecture of this research, I mean this prototype consists of three main parts. There's a backend where we modify the Lrvmir, that's where we emit a new hook, and there's a runtime library where we have to implement the mapping of the origina and the substitute functions. Also, there's a language specific front end which handles some c plus plus specific difficulties. I will just have a few more words about that soon.
00:07:47.250 - 00:09:05.172, Speaker A: So here's what's happening in the Lrvmir, we take the original cohort expression and compile time we emit a hook function, and based on the result of that hook function, we decide whether we have to call the original function or the substitute function. It's so simple actually. Currently the prototype we have is implemented in a way that we modify the code generation part in clang. However, this would been better to implement this as an LVN pass, because that way it would be independent from clang and from the language front end. So the runtime library is actually nothing more than a lookup and a hash map. So if we have an entry in a hash map, that means we have to replace a function to a substitute function. Actually, we use a technique which maybe may seem familiar to you, shadow memory technique.
00:09:05.172 - 00:10:02.910, Speaker A: This has been used in other sanitizer sanitizer. So instead of using difficult hashing, we just simply map the virtual memory and we offset directly into the shadow memory. This can make the hash map itself a little bit more efficient. Also, this runtime library has the task to provide the c and c API. In both cases we may call the substitute macro with all capital letters. So we just simply say which function to replace with which counterpart function. This thing itself can be really difficult in case of virtual functions, because as you may know, that we cannot just get the address of a virtual function.
00:10:02.910 - 00:11:08.992, Speaker A: So that's the exact reason why we created a c plus plus specific front end, where actually we created a new unary expression, which is really similar to the existing address of unary expression. But the type of this expression is different in case of virtual functions. So it is something like we can get the concrete address of that function as it is in the text segment. Anyway, this feature is already implemented in GCC, however, it is not in Klang. Also, there are very good reasons why this was never implemented. So this feature is only available when the testing specific instrumentation is turned on, and this is hidden away from the users. So this is only for being able to get a unique identifier for a virtual function.
00:11:08.992 - 00:12:12.580, Speaker A: So we can replace that with any other functions. A few words about the future. Well, since nowadays we instrument all call expressions, this can be really slow, really slow. So it has the performance similar to the f instrument functions, instrumentation or this is a little bit faster because of the shadow memory. So one idea would be to just instrument only those call expressions which are really needed to be replaced. We might be able to use attributes on function declarations, but this can be really hard and it's not an easy solution. Also some idea would be to do similar instrumentation, what's being done in the x ray system.
00:12:12.580 - 00:13:15.970, Speaker A: So they actually emit no operations which can be executed really fast by the cpu. And the idea here would be that, okay, replace the no operations only when we do relevant to do this substitution. Again, some alternative approach would be to do the whole thing on the ast level. So some of you may have known that there's a nice little part of clang, the aST importer which are used only in LLDB and in cross translation unit static analysis. This might be reused in a way to do transformations on the abstract syntax tree level so we could do the whole thing instead of instrumentation at the level of the aST. Thank you very much. Please shoot me with your questions.
00:13:15.970 - 00:13:23.268, Speaker A: You. Okay?
00:13:23.354 - 00:13:32.760, Speaker B: So we have plenty of time for questions. Does anyone have any questions?
00:13:38.690 - 00:13:39.440, Speaker A: Hi.
00:13:42.790 - 00:13:53.590, Speaker C: Did you make any attempts to test this thing for correctness? I mean like substituting for itself and then running some tests?
00:13:54.410 - 00:14:45.960, Speaker A: So correctness actually, yeah, we should have some sort of checking whether, whether the substitute function and the original function has at least the same prototype or the same type. Yeah, that's right. That is still a missing feature in the prototype that we do not do any kind of checking. But this could be easily implemented with some sort of template programming or Cc plus plus metaprogramming. Again, I don't know. Is that an answer to your question? Okay.
00:14:52.750 - 00:15:06.106, Speaker D: Um, I would have another question. I'm not sure if it was on your slide, but how do you handle the vis pointer? So you replace the stipex, but as far as I saw, you didn't pass in the pointer for that mutex instance.
00:15:06.298 - 00:15:19.118, Speaker A: Yeah. So the first parameter of the substitute function will be a pointer which actually has the type of a pointer to the mutex type. So it's like passing this pointer as the first parameter.
00:15:19.294 - 00:15:20.418, Speaker D: Okay, thanks.
00:15:20.504 - 00:15:21.140, Speaker A: Welcome.
00:15:33.190 - 00:15:36.220, Speaker B: Trying to maximize the amount of exercise I get.
00:15:37.630 - 00:16:04.980, Speaker E: So I might misunderstand something here, but do you have a concern that using this technique too much ties the testing code to the code you are testing? Like if you have an ability to change arbitrary functions inside the code you are testing, then suddenly the test starts to rely on old private implementation details it ideally should not care about. Whereas in dependency injection sort of has to explicitly specify those.
00:16:06.710 - 00:16:11.326, Speaker A: Okay, if I understand your question correctly.
00:16:11.358 - 00:16:11.940, Speaker B: Then.
00:16:14.650 - 00:16:16.840, Speaker A: Could you please rephrase your question?
00:16:17.930 - 00:16:28.540, Speaker B: So I think the question is about the tight coupling between the tests and the implementation details rather than the expected behavior of the things they're testing, right?
00:16:30.350 - 00:17:15.254, Speaker A: Yes. This could create tight coupling with the test. That's right. However, this tool can be a nice complement in certain cases. It's not a new theorem. I would say it is not a word saving tool, but it can be a tool when you have certain cases where, for example, you have a legacy system and you don't want to change the legacy code because you don't have any tests at the moment. Or it can be also a tool, for example, as you see in this running example, if you don't want any structural changes.
00:17:15.254 - 00:17:29.020, Speaker A: But it has a price. As you see, it's a price. It can introduce new dependencies, but as engineers, we have to negotiate between bad and good or more bad things.
00:17:31.650 - 00:17:34.240, Speaker B: Okay, I think we have time for one more question.
00:17:37.740 - 00:17:38.490, Speaker A: No.
00:17:41.580 - 00:17:44.990, Speaker B: You were a fraction slower, but you're much closer, so you win.
00:17:48.560 - 00:17:51.900, Speaker F: Let's see. Have you thought about chaining instead of replacement?
00:17:52.400 - 00:17:53.368, Speaker A: Chaining.
00:17:53.544 - 00:17:58.110, Speaker F: So, to be able to have a prestep and then call the actual function and a post step.
00:17:58.960 - 00:18:07.396, Speaker A: No, I didn't think about that. Okay. You. Okay.
00:18:07.498 - 00:18:14.130, Speaker B: So, thank you very much. Close.
