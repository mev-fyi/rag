00:00:08.880 - 00:00:47.346, Speaker A: I figured since we already introduced the APIs and been talking about it for a minute, try to just go down the rabbit hole on something that I think is actually extremely important for cosmos. It is this new technology called ABCi. If you don't know what ABCI is, it's the interface between the application and the cosmos. Blockchain and tendermint. And ABCI, or ABci 2.0, is a brand new re envisioning of this that I would argue, actually basically brings a lot of these narratives and exciting things happening outside of cosmos into cosmos. So it's gonna be a little bit of a technical talk.
00:00:47.346 - 00:01:17.580, Speaker A: So hope everybody had some coffee and I tried to spice it up with some memes. So basically, this is how I feel, talking about ABCI. It's like everyone else is talking about Chainlink, talking about suave, they're talking about eigen layer. And I'm just like, Abci does this. It allows for all these things already and you can have them in a cosmos chain. And I think that's going to be really important for the next generation of applications to realize this and take full advantage. And so I'm going to try to talk through it.
00:01:17.580 - 00:01:39.240, Speaker A: So I think it's bigger than most people think. A lot of people think it's just a technology. I think it lets change be ten x more powerful and fully sovereign. And I'll talk through why that is. I got a clicker. Nice. So just to talk through what I'm going to talk about, first of all, I'm going to talk about what is the motivation of this talk.
00:01:39.240 - 00:02:16.278, Speaker A: I'm going to talk mainly from the lens of how do we enable more sovereignty for applications. I think the defining characteristic of app chains is the fact that they are fully sovereign compared to any other basic ecosystem. And I think l, one's really sort of allow for that, especially in cosmos. The tool chain I'm talking, of course, is absi. And then the kinds of applications I'm going to talk about in that context are sort of the functionality that ABCI brings and also what we're building at Scip and sort of how it builds around ABCI. So three applications to talk about. One, sovereign Mev.
00:02:16.278 - 00:03:23.250, Speaker A: So how that works, how basically scips products operate. So how can we, when I say sovereign, I mean how do you take full control of your Mev market? How do you direct it to any stakeholder that you want without any centralized services? And then, number two, sovereign data. How do you as an application take full control over your data? So this is in the context of privacy, how do you have private data? And then also in the context of oracles. So how do you get data from an outside source in a fully sovereign way? And then finally I'm going to talk about sovereign blocks. So basically, how do you use ABC to fully construct your app chain perfectly to your application and to the needs that you have. So one argument I have is absi, is actually the thing why we have this new influx of, of great applications. Dydx, barachain, I would argue, are here partly for Abci.
00:03:23.250 - 00:04:20.886, Speaker A: And looking through their architecture, you can see really closely how they use it. Dydx uses it for oracles. So they'll use ABCI to have this in protocol censorship resistant oracle that they need for their exchange. And then Barachain uses it for a variety of things, excuse me, but specifically for MeV block building and also some of their precompiles for Polaris. So what is it finally getting to this part? So basically at a very high level, because I'm going to get more technical, ABCI transfers control over basically everything from the consensus layer. So that's like tendermint or comet into the application where the application can define the logic that they want to apply to their blocks. So how did it work before? Before, this was the traversal of consensus.
00:04:20.886 - 00:05:08.880, Speaker A: Basically, transactions would collect in the mempool of tendermint. They would be passed to the proposer where proposal was created. Then it would go to consensus, and then that proposer would finalize the block themselves so they wouldn't ask for feedback from anybody else, and then the block would get executed. So basically I had a meme at the end of this that I'll show you. But basically the proposer has full control over the entire block construction process. They have full control over the ordering, full control of what goes in it. And this led to a lot of, let's say, difficult results when it came to MEV, because there's no way to properly enforce, let's say, sharing the MEV with the entire network because the proposer had full control.
00:05:08.880 - 00:05:54.330, Speaker A: This changes a lot, and I know it's quite complicated in Abci 2.0 or ABCI. So in the updated model, the proposal is created. This function called prepare proposal is called the application then looks at that proposal and decides, okay, is this a correct proposal? And can use application side logic to modify it. Then the proposal goes to process proposal on all the other validators, basically, meaning other validators can say, did you do this block correctly? Right. They could say you ordered it incorrectly. They could say you didn't include this transaction and this has meaningful implications.
00:05:54.330 - 00:06:55.188, Speaker A: Then we go to a function called extend vote. So another part of ABCI that I would argue is as important as the prepare and process proposal is vote extensions, meaning you can add additional data that is signed by your vote, meaning that you sort of have this censorship resistance layer at the consensus level so that you can add additional data that must be considered when creating the next proposal. Those vote extensions are then verified, and then finally the block is finalized. So it's a much more back and forth process between the consensus layer and the application layer, meaning that an application like Dydx can basically verify additional things about consensus in order for that block to be valid. So dumb version left curve. Now basically before proposer would say this block is correct, I swear, validators are just like, great, sounds good, I'll execute it. And now they're just like, I'm not so sure about that.
00:06:55.188 - 00:07:33.810, Speaker A: Maybe that's not right. And they do a lot of additional checks. So what are those checks? The ordering check is actually quite limited. You can't do a full deterministic ordering check, meaning you can't say transactions have to be in order a, b, c, d, e, f. Because mempools are different, validators might not have received transactions, and you actually get into an impossibility result in this sort of cyclical voting if you try to enforce an ordering. This is why we can't have true fair ordering in blockchains. However, you can do limited ordering, and I'll talk about that in the MEV use case.
00:07:33.810 - 00:08:28.640, Speaker A: What you can do is inclusion and vote extension consideration. So basically, when the proposal is considered to be valid, all the validators can say, did you include this transaction? For example, that transaction might be an oracle update and only vote yes and continue the blockchain if those transactions or that data is included. Talk about why this enables censorship resistance with two thirds plus of the network. And then finally you can check for aggregation as a validator or sorry for logic. So that might include aggregation like did you consider all the prices from the last block and construct a accurate new price for this asset? And so that's obviously very important for oracles. So I'm going to go into Pob. So POB is skip software that is open source and that any blockchain is absolutely free to use.
00:08:28.640 - 00:09:18.330, Speaker A: It's running on a number of blockchains today or getting set up, actually. So POB uses properties one and properties two to allow for an in protocol MeV auction for chains to just easily, permissionlessly capture their own MEV without any outside parties. So I'm talking through the three ways that it does this, sort of getting technical again, whenever you see these diagrams, I get nervous and I'm like over explaining. So basically what POB does is it introduces a new transaction type. It's called a message auction bid, which allows for a searcher to find a transaction in the mempool bundle with it and put it at the top of the block. So this happens through prepare and process proposal. And prepare proposal.
00:09:18.330 - 00:10:00.286, Speaker A: The validator will look for these like special meta transactions or wrap transactions, grab them and then unbundle them at the top of the block and have them be atomic. This is how it works today. But it has some downsides. The downsides are the validator, again, can just rip it out and put in a different bundle, right? They can just say, okay, well, you made, you know, $100,000 at the top of my block. What if I just replaced that transaction data with my own? It's called a generalized front running strategy. It's very common in MeV. And then also the bids aren't private, right? Since it all happens in protocol, all the other searchers can see what you bid, so they know exactly how to bid right over you.
00:10:00.286 - 00:10:54.074, Speaker A: So this is where the rest of the parts of ABC I come in. So in V two, we have a consensus enforced auction. So, just to talk through this quickly, basically all of the validators picked what their top bid was. So like what won their block auction, and they put that in vote extensions, so that the proposing validator has to choose that data, since they have to choose two thirds plus of votes by stake weight in order to move consensus forward. They also have to see the top bids from each validator. That way you, as the top bidder, have to be censored by over one third of the validators in order to be censored. So basically you have a much stronger censorship resistance property around your top bid, which basically makes it a much more credible auction.
00:10:54.074 - 00:11:50.114, Speaker A: But we still have one more problem left, which is the bids are still public, which means other searchers can still bid over you. That's where the third property comes in, which is encrypted bundles. So with ABCI, which was actually created to allow for threshold encryption on osmosis, you can have fully encrypted bundles where basically the user or the searcher will send in ciphertext instead of just plain readable data. And then those bids can be selected post facto by all the validators after they've been decrypted. So that way, basically you have the censorship resistance properties, so you'll always get the highest biddenness, but it will also be private until execution time, meaning nobody can see it and bid over it until it's too late, which is what you want. So then you have a fully credible system. We also use dks for that.
00:11:50.114 - 00:12:42.832, Speaker A: But basically, what do you get out of this? What's the reasoning here? What you get out of this is you don't need something like flashbots, you don't need an external system, you don't need extra nodes, you don't need extra infrastructure. All runs on the existing validator set, and it runs efficiently, and it runs as a fully credible auction, which is in mech design, very hard to get to. It needs to be private and needs to be censorship resistant. So you can direct that revenue anywhere, because now proposers can't unilaterally decide where the money goes. It can be split across the entire network, censorship resistant, as I said, mev stealing proof. And it's just all on chain, and it's an open source module, so any chain can just run it. So if at all interested, do check out the Xbuilder module, which we published on ideas, skip money and talk more about.
00:12:42.832 - 00:13:10.494, Speaker A: It's also on our GitHub. All that's required is for your chain to run 0.47, and then it's just free software that you can run. So that's the first use case. What's the second use case? Oracles. So my argument in this talk is that you can get a chainlink like Oracle, with all the same security properties native inside your chain. With Abci, in fact, it's already been done.
00:13:10.494 - 00:13:46.300, Speaker A: I'll talk through how it's been done. So Chainlink is coming to Cosmos. I mean, they're not actually coming to Cosmos, but you know, the chain link you have at home is coming to Cosmos. So how does chain link work in general? I don't know. You know, maybe this is common knowledge, but I think it's worth noting. So Chainlink has a network of nodes that all grab price feeds, right? And each node will grab price feeds from different providers. So one from binance, one from Coingecko, one from Coinmarketcap, that node will aggregate them by taking the median of all those prices.
00:13:46.300 - 00:14:36.450, Speaker A: Then all the nodes will post their aggregate prices, and then another aggregate is taken across all the nodes, and then that is posted on chain to a smart contract and read by developers. But this is actually just ABCI. So this is the model for how you can build an oracle using ABCI with the exact same trust assumptions. Each validator, as part of consensus or as part of its regular operation of the chain, can run a side process to grab prices from all the different sources. So it will grab bearer price, eth price, osmo price, evmose price, et cetera. And then it will put those prices, it will take a median, just like Chainlink, and put those prices in the vote extensions. And then all of those vote extensions are aggregated across the validators.
00:14:36.450 - 00:15:25.216, Speaker A: They are finally calculated inside the proposal, and then they're posted into an on chain oracle module where they're made available to, let's say, cosmosm contracts or solidity smart contracts if you have EVM compatibility. And this all uses the same calculations as chain link, right? And the reason I argue it's the same security properties as chain link is even if you used real chain link on your application, you're still trusting that your validator set isn't screwing around. This way. You're also trusting your validator set. You're trusting it with two thirds plus of the stake weight to actually report correct prices. And so my argument is you basically have the same trust assumptions at the end of the day anyway. So here's just a more in depth view.
00:15:25.216 - 00:16:08.458, Speaker A: This is a little bit small to read, but basically, I'll just talk through it. The vote extensions from the last block have now all these prices. Then the proposer, who has to look at those vote extensions to move consensus forward, will grab those prices, aggregate them. All the other validators will check and say, did you look at those vote extensions, and did you aggregate the prices correctly? Then the new prices are queried, put into the vote extensions for the next block. They're all verified, and the block is finalized with the updated prices. So this way you have true two thirds plus censorship resistance on your oracle prices. So basically what you get, again, you get basically an in process chainlink version.
00:16:08.458 - 00:17:08.290, Speaker A: You have the same trust assumptions, you have censorship resistant data, and in this case off chain data, and again, all on chain, so you don't need any external providers. So I basically said this, we have an implementation of this as well in the Xoracle module, which is actually coming out quite soon. Again, all your chain needs to do is run 0.47 and it can just have this existing price feed. So the final thing, and I don't think something we've talked about previously ever, is what we call modular blocks. So we argue that the abstraction of ABCI with the addition of something that we've built in POB allows for this really, really interesting abstraction over the block layer so that applications can fully and granularly decide how their blocks are built. And it's not just mev.
00:17:08.290 - 00:17:53.299, Speaker A: So we've built this thing called laned mempools, where basically you can separate your blocks out into different lanes that have specific applications for certain kinds of transactions. So in this example, which I realize is pretty small, you can have, for example, the very top, an essential IBC lane. So let's say those are lite client updates. You can specify the top of my block, the first 5% always and only for like client updates, right? And maybe those are gasless transactions. Why not? They're free, right? They're so important to my network. After that, maybe you have an Oracle lane where only Oracle transactions are allowed in there. Then maybe you have an mev lane, right, to capture the MEv after the Oracle updates.
00:17:53.299 - 00:18:27.354, Speaker A: You definitely don't want that to go before you get front running. And then finally, maybe you have a custom fee market like EIP 1559, which is Ethereum's fee market applied to cosmos for the rest of the transactions. And at the very end you have free transactions. And maybe you say users who are making their first five transactions on my blockchain should get it for free, help them onboard. Maybe they don't have the gas token, they're trying to figure it out. And then maybe also you have free transactions for undelegating. A very common thing in cosmos is people delegate all their tokens, they have none left, and then they can't undelegate.
00:18:27.354 - 00:19:22.698, Speaker A: And so it's like catch 22. So you make undelegate transactions free so you can fully customize your application with different percentages of block space to restrict and reorder things according to your application's needs. This might be really useful if you have an oracle, and it might just be generally useful if you want to, let's say, have permissionless cosmos, but don't have trusted enough to have it take up all your block. Maybe just 20%, right? Maybe somebody deploys a gas heavy contract you want to make sure you don't get spammed. Especially true if you have zero gas fees, which is dangerous but obviously nice for users. So this also fits into all the other use cases, right? So like you see an MEV lane and Oracle Lane, it can fit into those other use cases of ABCI to just create this highly super powered application that can do so much more in protocol that normally had to require on outside applications. That's my talk.
00:19:22.698 - 00:19:24.890, Speaker A: Hope it wasn't too complicated. I hope it was helpful.
