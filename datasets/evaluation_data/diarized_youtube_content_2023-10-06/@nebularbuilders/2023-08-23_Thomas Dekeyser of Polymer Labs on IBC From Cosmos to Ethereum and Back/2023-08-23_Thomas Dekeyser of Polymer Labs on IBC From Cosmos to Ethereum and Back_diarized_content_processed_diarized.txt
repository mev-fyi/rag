00:00:09.240 - 00:00:53.780, Speaker A: All right, good afternoon, everyone. I am going to present to you today an exciting topic. How we bring IBC from Cosmos to Ethereum. So who am I? My name is Thomas. I'm a developer advocate at Polymer Labs, and we are expanding IBC beyond the cosmos basically anywhere. Before I was a developer advocate at Polymer Labs, I was a developer of relations at Interchain, at the IBC team. And it's always been a dream of mine to make sure that developing with IBC is not just something for the cosmos and interchange gigabrains, but that it's very accessible to every developer.
00:00:53.780 - 00:01:48.950, Speaker A: And so, one question to start out with. Who has ever built or tested IBC applications that can be go modules, that can be smart contracts that are IBC enabled? I think the people that have probably know that essentially it's quite tricky to get set up. So IBC means that you have a cross chain application. So you have multiple chains, you need a relayer in between. If you're just an application developer, you probably don't really care about all the DevOps stuff that goes into the background. And that's why we at polymer Labs have made the assessment that to make IBC successfully come to Ethereum, it's not only important to provide the technical aspects to do this, but also to provide great tooling. And that is why part of this presentation will be about the IBC SDK.
00:01:48.950 - 00:02:38.562, Speaker A: So, what is required to bring IBC to Ethereum? Over the past couple of months, we've already been bringing out a number of blog posts about these different topics. And you can see multihop IBC, virtual IBC, Zkmint, and then ultimately the IBC SDK, which is the tooling we're going to discuss. It's a lot of things, a lot of puzzle pieces. But we developers, we like composability, we like modularity. And today, I'm going to explain how all of these puzzle pieces together make sure that we bring IBC from cosmos to Ethereum. So first, let's briefly review the interoperability model. As you can see, we can take inspiration from the original OSI model.
00:02:38.562 - 00:03:31.014, Speaker A: So for the interoperability model as well, we have a clean separation of layers that are modular. So on top we have the application layer. This is where application developers interact with IBC. Then we have the transport layer in between, and ultimately the state layer. The state layer is how we verify that some state has been committed on the remote chain. And the transport layer, which is often overlooked, is actually very important because it allows us to standardize transport semantics in IBC, these are declines, the connections, the channels across ecosystems, and make it really easy for application developers to develop between different ecosystems and different chains. So this is an overview of IBC as you probably know it, if you know IBC.
00:03:31.014 - 00:04:23.866, Speaker A: So we essentially have two cosmos chains you can think of. We have the IBC go module, which is the transport implementation. Then we have our light clients, which in cosmos represents tendermint light clients. And we build connections, we build channels, and then we can send over packets with the help of the relayer, which you see down below. Now, how is it that we haven't seen an IBC implementation come to Ethereum yet? That's because there are some issues that arise when we want to implement a IBC outside of Cosmos. And this kind of shows you the worst case scenario, if you will, where if we have an IBC chain on the right and an other chain that we want to connect on the left, that is not from Cosmos. The worst case scenario, it does not have an IBC transport implementation.
00:04:23.866 - 00:04:59.344, Speaker A: So that's something you would have to develop. It doesn't have the light clients on both sides, actually. And also, there is no guaranteed relayer support. So all of these things we would have to develop from scratch in a regular situation. And so specifically for Ethereum, there's also the issue that verifying tendermint consensus, which is what Cosmos SDKchians use in the EVM, is cost prohibitive. So we need to find solutions for that. And also, Ethereum does not have single slot finality, which is also a requirement if you have different forks.
00:04:59.344 - 00:05:51.970, Speaker A: An Ethereum lite client is not immediately IBC compatible. And so when we think about the puzzle pieces that I showed you, the first one is multihop IBC. So this actually works also between multiple cosmos chains. It's not limited to the problem of connecting to Ethereum. And so what happens is that with a chain in the middle, you can still create a multi hop channel that acts and functions much like you would have a regular IBC channel, at least from the applications developer's point of view. But it leverages pre existing connections between chain a and polymer and polymer and chain b, with polymer acting as the middle hop as sort of a router. And that is one piece of the puzzle.
00:05:51.970 - 00:06:32.124, Speaker A: Another piece of the puzzle is virtual IBC. And if we think back to the interoperability model, we'll remember that we had these different separation of layers, app layer, transport layer, state layer. And what we say is that you can actually have modular interoperability. So previously there was a talk from celestia, and they kind of coined the term modular blockchains. So, modular blockchains enable to have the different functions that a logical blockchain needs to have. But they said they don't have to actually be on the same chain. We do something similar for interoperability.
00:06:32.124 - 00:07:09.270, Speaker A: We say, yes, you need the application layer. Yes, you need the transport layer. Yes, you need the state layer. But these can be on different chains still forming logical interoperability. And so what we did for Ethereum was we consider Ethereum as a virtual IBC chain, and in fact, we bring the transport layer to polymer. So all the computation related to interoperability will actually be executed on polymer. And then the remaining puzzle piece was Zkmins.
00:07:09.270 - 00:08:34.080, Speaker A: So remember that verifying tendermint consensus inside EVM was cost prohibitive. So how do we go about solving that? So at polymer, we have, sorry, at polymer, we have Zkmint, which is a novel consensus engine, which essentially makes it possible to have at each height, multiple headers in a different format that are optimized for each execution environment, in this case the EVM. And so this is really important to understand that this is not just a solution for Ethereum, it's actually a generalized solution that makes it very adaptive and flexible to every chain environment ecosystem that we will want to connect to into the future. And so when we have polymer with ZK Mint, the only thing that we need to do is we need to have an off chain ZK prover making a ZK proof that the computation was done on polymer. And then we can verify this on the Ethereum chain, which is orders of magnitudes cheaper to execute. And so virtual IBC actually has another benefit. And this comes back to the problem that Ethereum does not have native single slot finality.
00:08:34.080 - 00:09:28.930, Speaker A: And so when we have an ETH client, this is what we call the native lite client for the chain, it can have a view of multiple forks, multiple views, and so to make it IBC compatible, this does not work. So we have introduced this concept of a virtual light client, which is essentially a wrapper around the native lite client that can allow you to have different security parameters. This is what we call the fork choice rule. So for different virtual light clients, you can allow for a different number of block confirmations to have gone through to use the client for IBC applications. And so, depending on the security requirements that you have, you might choose a different solution. And so when we put all of this together, we have succeeded. We have brought IBC end to end from Cosmos to Ethereum.
00:09:28.930 - 00:10:30.380, Speaker A: And this looks a little bit complicated, right? And so for developers who want to develop cross chain applications, we have the IBC SDK, which, remember, was tooling that basically abstracts away all of the DevOps. So you can imagine having put polymer in the middle, different relayers going on, you have all these chains to set up. IBC SDK allows to do that all for you, and the application developer can just focus on deploying their smart contracts or their applications. So again, why is this IBC SDK important? Well, for us, as polymer, it's also important because it provides developers the first opportunity to really interact in a tangible way with what I've been describing, the polymer protocol. And like I said, it's also very important for the UX, for developers, because as I mentioned before, just bringing IBC to Ethereum isn't enough. It also needs to be easy and accessible for developers. And especially.
00:10:30.380 - 00:11:05.484, Speaker A: Let me just go away. On the left, we have these two diagrams. The one on top is actually a homogenous environment, and you can think of that as cosmos. We have all cosmos SDK chains, and we connect them over IBC. This is still a lot easier than if we go to a heterogeneous environment, which was also always the intention of IBC. If we have a heterogeneous environment, we have all these different types of chains. So you can imagine if you had to spin up all of these chains yourself, know how to interact with them, spin up the different relayers.
00:11:05.484 - 00:11:48.930, Speaker A: This is a lot of work, and this is what IBC SDK makes really easy for you. And this is why I'm happy to announce that actually tonight or last night, we open sourced IBC SDK, and it is available for you to try it out. So what does my developer journey actually look like? It is open source. I can try it out. What does it look like? So there's a couple of possibilities of what you can do as a developer. So say you're an EVM developer and you want to make an IBC enabled EVM smart contract. That could just be that you have an application on a cosmosm chain that you want to interact with.
00:11:48.930 - 00:12:41.200, Speaker A: You can just focus on your EVM development with the development environment that you're familiar with. You can easily slot it into the workflow with IBC SDK, and we have a tutorial on that. Or you could be a cosmosm developer who is interested in developing an application that interacts with an application on Ethereum. That is also possible. And lastly, we have these God tier developers who essentially will have native cross chain applications that leverage vms on different chains in different ecosystems. And hopefully we'll see a lot more of this. So I've prepared a tutorial example, actually, now that IBC SDK has been open sourced, you can just go to the documentation for it.
00:12:41.200 - 00:13:09.828, Speaker A: This will be an example. So very simply, what is happening? We have a cosmosm chain. On one hand we have ethereum on the other hand. What I prepared was an example of a lending borrowing contract. So we have an amount of tokens, in this case three tokens. We have supplied some collateral as a community, and now we want to vote on what asset to borrow. But we don't want to vote on Ethereum.
00:13:09.828 - 00:14:07.040, Speaker A: That's very expensive. So what you could do is actually deploy the polling contract, what you're going to borrow on cosmwasm, and you can vote on that, make a decision. And when the vote ends and we have a winner, you just send over the IBC packets to Ethereum, and that will execute the loan. And importantly, you also have an ack. So if you wanted to do something upon the receipt of the ack, that is also possible. And so my tutorial example is of course a great way to get started. But ultimately, if we bring IBC end to end, from Cosmos to Ethereum, the question is, what are you going to build? And I think I can speak for all of us that we're very excited about this future and very excited to see what great applications the cosmos developers are going to build to interact with Ethereum.
00:14:07.040 - 00:14:56.160, Speaker A: And so I started the presentation with saying that for IBC to thrive, we need a lot of puzzle pieces to be pieced together. And so right now, bringing IBC to Ethereum, how is the puzzle looking? I would say it's starting to look pretty good. But all of the other teams also working on IBC, and a lot of them have presented at this conference, it's starting to look pretty good. How can we improve it, though? One way is to contribute to the IBC SDK to make it even better, because right now we started with support for Ethereum and Cosmos chains, but it can be a lot more. It can be any generalized setup. And there's some other things that we still need. We can turn it into a library, we can build dashboards for it to really make it as easy as possible for contract developers.
00:14:56.160 - 00:15:22.870, Speaker A: But there's some bigger pieces as well. We think that there's some really huge things that can still change in IBC to bring it to that next level. And if you're curious, to find out. Be sure to catch Bo's talk in the afternoon because he is going to talk about a new concept called enshrined interoperability. That's my presentation. Thank you for listening, and have a great afternoon.
