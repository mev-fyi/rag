00:00:09.760 - 00:00:27.730, Speaker A: Okay, so, hello, everyone. Thanks a lot for having me here today at Nebula Seb. Great to see you. I'm here to talk about intents in IBC. So just a quick little bit about me. My name is Jack Samplin. You might know me from some of these projects over here, where I've been a product manager.
00:00:27.730 - 00:01:36.354, Speaker A: I've been working in Cosmos since 2018. And at Strangelove, we're dedicated to building IBC and supporting its growth. We're one of the primary teams building out the core IBC protocol, and we're doing a lot of work to expand IBC to new ecosystems, like Polkadot Avalanche and a bunch of other ones. So you hear a lot of people talking about intents recently. What are intents? It's a little bit of an amorphous concept, but you can think about it where a user specifies an intent and a transaction on one chain, and that gets carried out across multiple different systems or different blockchains. This is really important for scaling, because if we're going to live in an app chain world where each application lives on a different chain, how do you get the same level of composability that you get in Ethereum? In Ethereum, you can send one transaction, go borrow money on maker, trade it on Uniswap, and then maybe in a report position on some perp protocol. And all of that happens with one single signature from your ledger.
00:01:36.354 - 00:02:36.936, Speaker A: But if we're living in a world where all of these applications are on different chains, how do we offer that exact same user experience to end users, where they only have to send one transaction to complete a complex set of financial primitives? Well, there's a few different ways to do it, but maybe think about how traditional web systems have scaled. And look at this historical example of Google as a user. You send one request to google.com and google.com, then farms out different pieces of those requests to a bunch of different back end servers and returns it to you. So, intents in IBC will work in a kind of a similar way where you're sending your transaction to one chain, and there might be interactions on many different chains that end up happening under the hood to perform what the user wants. So, right now, if you want to do this in IBC, and I think a lot of folks in this room are familiar with this, maybe you want to trade on osmosis and go borrow over on UmI or, uh, do various things.
00:02:36.936 - 00:03:05.278, Speaker A: There's many transactions that you need to sign in order to. To do that, and it's kind of painful right now. Honestly, I don't love it. My ledger is getting tired. So let's take this simple user flow here, where we want to lend USDC on UMI with Atom that we currently have in an LP on Kujira. So this is the set of transactions that you need to make as a user. First, you need to remove the atom from the Kujira LP.
00:03:05.278 - 00:03:39.050, Speaker A: That's a single transaction. We need to initiate an IBC transfer over to the cosmos hub. There's a relayer involved there with another transaction that you don't have to do. You have to IBC that atom to osmosis, which is another user transaction. There's the relayer there. Then we single transaction, trade atom for USDC on osmosis. We would ibc the resultant USDC to noble to unwrap that denomination, and then IBC the USDC to UMI, where we would then enter the lending position and end up there.
00:03:39.050 - 00:04:39.688, Speaker A: That's a nice seven transactions to do something that should be a single transaction. So let's talk about IBC middleware. IBC Middleware adds additional processing to IBC packets as they're sent and received. This allows you to kind of think of that ICS 20 packet is a bearer instrument where it's not just a single transfer, but that packet contains the value that the user has, and maybe you want to do other things with it besides just put it directly into the user's account. This relies on this simple JSON structure that's stuffed into the memo field of an IBC transfer that allows users to specify additional actions to be taken, additional processing to be done on the chain that they're sending the transfer to. So here's a little code and a couple of examples of things that are live today. You see the swap over here on the left.
00:04:39.688 - 00:05:21.950, Speaker A: This is a swap in forward on osmosis. We've also built a similar piece of middleware for duality that will be live with that chain once that goes live. But here you specify the arguments for the swap over on the chain that you're originating the IBC transaction on, and the swap happens without the user having to send a second transaction. And if you know the swap API in osmosis, this is just all of the exact same arguments, we're just passing them in in a different way. Here's an example over on the right of a double forward. Let's say you want to forward an asset through two chains. I don't know why you'd want to do that, but it could be fun.
00:05:21.950 - 00:06:50.090, Speaker A: And there's the first forward that would get processed on the first chain, and you see the arguments there. And then once the first chain processes it, it pulls off that top level of JSON, goes to that next field, and then makes the memo for the next transfer, the second set of forward instructions. So here with these two middlewares that we've described, swap and forward and packet forward middleware, let's go back to that flow we looked at earlier. We're going to remove the atom from a Kujira LP, and then in a single transaction all of that other stuff is going to happen automatically and the user would end up in a lending position on UMI. And the only piece of middleware that would not be live in this flow is a middleware to expose that lending position on Umihdev. But I think that, oh, the way that I'm starting to think about these middlewares is a way to expose an interchange API for your product. So if you have perps or you have any of these other things, and you want users to be able to use those in a more composable way, you can write a little piece of middleware that exposes that functionality to end users and allows them to do these single transactions that accomplish many different things and chain them together in new and unexpected ways.
00:06:50.090 - 00:07:36.270, Speaker A: So this is the flow for packet forward middleware. The first thing that happens is the user initiates a transfer. The packet gets received over on the receiving chain, and then we enter the packet forward middleware, which then forwards the packet that's received on the next chain. This is a, the bottom flow here is a for packet example, it would be this piece of JSON over here. And then the acknowledgements come back. And if you'll notice, the acknowledgement only returns to the first chain once the entire flow has unwound. So it allows you to process these things in an atomic way.
00:07:36.270 - 00:08:33.236, Speaker A: What is the sad path look like in that JSON blob? You might have noticed a field called timeouts. In the event that the packet times out in the intermediate chain, we need to figure out what to do. So what we do is we allow the user to specify how many times they like that retried. And you can see here that instead of actually successfully making it to the next chain in number seven there, we're returning an error to the end user, and that's after two timeouts. Another way to enable this type of composability is with interchain accounts, and Quasar is probably the most prominent project working on this stride. Also has a really robust interchange accounts implementation. But this allows contracts or smart contracts on other chains accounts or smart contracts on other chains to control an account or a smart contract on another chain.
00:08:33.236 - 00:09:21.022, Speaker A: And in this way, you can have a smart contract on one chain that controls accounts on many different chains and can perform these actions on behalf of the end user interchain. And Jake was just up here talking about Polytone. Interchain accounts and Polytone are examples of this. I think that both of these models are really needed, and what we're going to see is application builders are going to end up utilizing either one or the other, or potentially a combination of both of them. So what's next? I was talking a little bit earlier about how interchain accounts exposes this interchain API. I think that there's a lot of other of these middlewares that need to be built to help enable this composability. And as applications are bootstrapping and building their code for the first time, try to think about this.
00:09:21.022 - 00:10:21.878, Speaker A: What functionality does your application want to expose via IBC, and how can you easily do it? I think that there's enough examples of these middlewares out there right now. It's relatively easy to write. There's realistically two functions on packet receive and on send packet that you need to implement as an application developer. And there's enough examples where you can see exactly how to use this. I think one of the other things that I want to call out here is standardization of these JSON blobs is going to be really important as this sort of like arbitrary text field with arbitrary data in it. There's a lot of unexpected things that might be lurking there, and we need to make sure that we're using the same standards and the same formats across many different applications. There's been a lot of discussion recently about this IBC hooks and packet forward middleware issue where the intermediate chain can potentially spoof the sender.
00:10:21.878 - 00:11:06.508, Speaker A: And I think that this is kind of a fundamental property of IBC that's going to be hard to get around until we have something like fully multi hop transfers that the fully multi hop packets that the polymer team is working on, where you can kind of recursively prove across the clients that the sending chain sent the exact same packet you're getting with these middlewares, the intermediate chain is actually processing the packet and then recreating a new one. And that can offer an opportunity for a malicious chain to do that. In practice, however, most cosmos chains have a really constrained coding environment. You can reason about the code that's on the chain. And you can see that it's impossible to spoof that packet in a trusted intermediary. Thank you guys very much. And I'm also.
00:11:06.508 - 00:11:14.320, Speaker A: I've got like five minutes left because I rushed through that. But if anyone's got questions, I'm happy to take a few minutes for questions.
00:11:17.800 - 00:11:42.748, Speaker B: So you mentioned standards, which is great. Is there an existing organization in which that should sit? For example, we have the interchange standards like GitHub. I guess what organization, if it exists or doesn't exist, should be responsible for curating those probably increasingly important IBC standards.
00:11:42.844 - 00:12:32.708, Speaker A: As we go forward. Yeah, so the interchange Berlin team has done a great job in giving us a high level format for these. So if you see here this word swap that references the exact piece of code that your middleware is going to call, and then that next is what you're going to put into the next packet. So this is the standard that we've been given to. But I think for swap and forward middleware in particular, each Dex has some slightly different arguments that are slightly differently named for the inputs that they take for a standard swap. In order for Dex aggregation to be effective across the interchain, we're going to need to come up with a standard for that swap and forward in particular. I think that should again live in the ICs repo and be a broadly promulgated standardization.
00:12:32.708 - 00:12:55.580, Speaker A: I think that one in particular is going to be a little challenging because exchanges tend to view each other competitively and it would be easy for them to sort of diverge there. We, when we did the work with duality, aligned it with the osmosis work. So I believe that our jsons are similar, but this is something we need to look out for as we sort of expand this functionality. Great question, Jake. Sir.
00:12:57.520 - 00:13:07.980, Speaker C: How do you recover from, say, a failed IBC transaction or failed swap in that case, if you have multiple hops, how do you get back to the old chain? Is this done automatically or the funds going to be just stuck?
00:13:11.080 - 00:13:49.008, Speaker A: Okay, so here in the packet, forward middleware is a great example. So you see, the user sends the transfer first, the packet is received over on the intermediate chain, and then we have a failure. The packet doesn't get relayed in time. There is a couple of timeouts, and then finally we return an error acknowledgement to the user. That error acknowledgement then unlocks those user funds. So the way that we deal with that is sort of natively through the call and response in IBC. And if you look back here, you can see that number nine.
00:13:49.008 - 00:14:14.260, Speaker A: The acknowledgement returned to the original sending chain only comes back after the entire flow that the user has specified is completed. So we wait quite a while on those acknowledgments. But yeah, we tried to preserve that basic call and response functionality that IBC gives you. It's a great question. Yes, Open Q and A is like my absolute favorite.
00:14:16.080 - 00:14:28.100, Speaker D: Thanks. Since you're doing a great job trying to simplify the user experience and so on. We just talked about security. What about latency?
00:14:29.680 - 00:15:20.340, Speaker A: Yeah, I think that fundamentally latency is going to be dependent on the latency on IBC connections and how long it takes it to transmit between two chains or potentially many other chains. If you have a four or five hop, it's going to take five x the amount of time that a single transfer takes. That kind of goes without saying. But so how do we get latency down? As an application developer, try to do as many things in parallel as possible. If you can send two packets out at the same time that go do a couple things and then come back, that would be a lot less latency than doing it all serially. So think about ways to parallelize that work. And because you have a lot of different workers which are these different blockchains, you can parallelize that work relatively easily.
00:15:20.340 - 00:16:01.990, Speaker A: Other things are sort of like getting down that latency on IBC in general, reducing block times across chains. The FMos team has led the way there, but sort of seeing that more broadly and seeing more and faster chains I think is one other way to reduce latency. As we see rollups with different clients and different trust assumptions, and also different block times, I think that will also help to reduce latency. Fundamentally, there will be a decent amount of latency in some of these user interactions, but keeping it acceptable is going to be up to the app developers. Good question. Any other questions? Sir.
00:16:04.130 - 00:16:15.176, Speaker E: How do you see the expansion of the types of middlewares that can be handled and then the dependency management, like say between chains, of what kinds of middleware actions are allowed or not? Right?
00:16:15.368 - 00:16:52.870, Speaker A: Yeah, I think that this, just in my mind, is another great use case for the chain registry and bringing that on chain in terms of a chain naming service. Chains should have the APIs, these interchain APIs that they exposed, and the way to use those APIs registered somewhere that can be programmatically accessed or at least like accessed by an end user in an easy way. And I think that as a community we've done a really good job of building up that chain registry repo. But we need to continue to add new data to that. And this would be one of those things. Yes.
00:16:54.450 - 00:17:21.040, Speaker F: I just wanted to ask, why implement them as like a JSON and not like a cosmos message? Messages are already very standardized. They are like protocol. Yeah. So we can like, you know, encode them in a binary format or something. Protocol or something, which is like already generic and, you know, chain them in a way where basically we already have a standard, then by reinvent the standard in a JSON format.
00:17:22.260 - 00:18:15.130, Speaker A: I think that there's a lot of answers to that question. But fundamentally, as we're thinking about parsing these fields in non cosmos places, JSON is a broadly usable data format. It's also human readable, which when you're signing transactions, is extremely important. Like if on your ledger you saw this memo field and it was opaque binary and your front end inputted malicious data there, it's really hard to read that. So human readability was one thing, ease of use in other programming environments is another. I agree it is a slightly subpar solution, but this does allow us to get things to market much quicker and allow us to offer these user experiences that you see on IBC, fun and TFM and all of these other places that are going to allow us to bring many, many more users into the ecosystem. So I think the trade off has been worth it.
00:18:15.130 - 00:18:28.834, Speaker A: But yeah, it's not the best, but it's what we got. Awesome. I think I'm out of time. Really appreciate you guys as an audience. Thank you very much. Go check me out on Twitter. Check out strangelove.
00:18:28.834 - 00:18:29.890, Speaker A: We're doing IBC work.
