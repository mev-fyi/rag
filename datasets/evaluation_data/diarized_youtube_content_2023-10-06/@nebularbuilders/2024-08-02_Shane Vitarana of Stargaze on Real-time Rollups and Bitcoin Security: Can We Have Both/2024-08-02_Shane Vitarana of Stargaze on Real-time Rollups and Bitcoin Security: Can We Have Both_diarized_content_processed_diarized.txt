00:00:00.400 - 00:00:53.154, Speaker A: Hey, guys, how's it going? All right, those are a little mix up on the schedule, but he's speaking now, so let's get started. All right, real time roll ups and bitcoin security. Can we have both? All right, I'm Shane, founder of Spargies. Spargies is an app chain for NFTs at war. You may have heard of barricades or sloths and sloths. Anyone have a barricade or a sloth? All right, now whip your elbow. No one's going to do that.
00:00:53.154 - 00:01:27.260, Speaker A: All right, fine. Let me see. In my previous life, I built low latency audio engines for iOS music apps. And then before that, we're done scaling web two apps. At Mubon, there's a bit more, but I'll save you guys that background. So I'm going to talk about real time roll ups without sacrificing the values of crypto that we all never love. And I'm going to define real time here as a web3 query or web3 write.
00:01:27.260 - 00:02:13.542, Speaker A: That's as fast as a web two API call. So the thesis for stories has always been that NFTs are kind of like a stepping stone to bring more users in the crypto and we want to build the best possible for J ux. The approach that we've always kind of taken is more bottom up than top down. There are a lot of projects in the infraspace especially that are kind of starting with the end game first. But this is kind of a little precarious because sometimes you may end up building stuff that people actually don't want. So when you build with the bottom up approach, when you build the app first, then it's easier to have Podmore fit. You can get user feedback, you can iterate quickly.
00:02:13.542 - 00:02:50.200, Speaker A: And this is how things traditionally work, uh, in kind of the rest of the non crypto space. Um, so, uh, lately you guys probably heard about the modular thesis. Uh, it's kind of an interesting way to scale. Uh, the kind of philosophy is that you break things into components and you scale each component instead of, uh, scaling like a monolithic exchange. Uh, so one way to think about that is you have a computer, you have separation concerns. You have CPU, GPU and Ram. You can loosely map that.
00:02:50.200 - 00:03:40.420, Speaker A: Maybe GPU like execution, cpu's like consensus ram, slight data availability, and then you optimize each one. And why do you want to focus on performance in UX? Speed is essential for any kind of consumer or user facing product. Google kind of. I mean, there's examples in history that kind of proves this out, right. Google partly won the search engine wars because it was much, much faster than Optimist and Yahoo and the other solutions that were out around that time. You can get results in half a second instead of waiting two to 10 seconds. Another example is Uber internally really focused on the time to find a car.
00:03:40.420 - 00:04:55.890, Speaker A: And they trained this transformer model with graph theory to be able to find the shortest time to find a car. Amazon has the one day shipping in the context of crypto. If you make a blockchain super fast, it attracts more users and then they will add more tvl, you'll have more volume, and then in turn you can learn from them, improve the UX, and then you have more users, they'll come do more transactions, you'll have more tvl, and you kind of create this positive feedback loop. So we kind of look at where users spend a lot of their time, and a lot of people are focused on optimizing the transaction part, but users actually spend most of their time trying to change. They spend their time looking for yield opportunities or finding the perfect NFT or whatever. So there's not enough focus on optimizing like the read side of things. So we kind of initially focused on optimizing reads, and we have this real time index versus built in rust.
00:04:55.890 - 00:05:33.278, Speaker A: It's async and multithetter super fast. You can throw a bunch of cpu's at it and it kind of scales and you can like index big chains like osmosis in under 5 hours. And then the other part of it is optimizing the rpcs for reads. So we have Reed optimized rpcs where most of the merkle trees like cash and ram, so you have fewer discretes. And we're working towards like a newer version of it where we store an entire Merkle tree ram. And then the other side of it is optimizing rights. So there's two ways to do this.
00:05:33.278 - 00:06:30.440, Speaker A: You can scale the l one, or you can build rollups and l two s and separate consensus and execution. So scaling in all ones, like this 1 hour approach. There's also if you guys go check out devs from osmosis, he did a really great talk on optimizing tenurement or common BFD, and looks like you can bring that down to like a second or so for block times. And if you combine these two, you're going to have incredibly fast blockchains. All right, so why scale with robots? Nl two s, you just have better separation of concerns. You do one thing, you do that one thing really well, and you could reduce the speed, the latency to the speed of execution. And then the other thing is you get fractal scaling, right? So if you need to scale VLT, you can watch an additive and so forth.
00:06:30.440 - 00:07:37.422, Speaker A: Another interesting thing about this is that as an app developer, if Mev is like, the largest source of revenue that's yours, you kind of want to own that, right? You don't necessarily want to leak all the MeV to the base layer. So selection Voc is one way to do this. In rolekit, you can have Cosmos SDK as an executioner on it, so you can have a cosmos or EVM or whatever on it. There's no tenement, so there's no amounts of DFT. And it also uses lit p two p, which is a kind of more modern networking stack that is apparently less buggy than the genomic one. All right, so you can get really fast pre conformations with rollkit, right? So the speed of execution is super fast. So that's like, you know, maybe like one to five milliseconds or so, but you can get really fast precomps.
00:07:37.422 - 00:08:44.560, Speaker A: You can get like 100 to 150 millisecond pre comps. So, you know, now we're getting into territory of a web two transaction, all right? So sequencers are like, at least in the Ethereum world, known to be really centralized. How can we give it some guarantees so it's more secure? And one approach I like for that is bitcoin staking. So the way bitcoin staking works is that the sequencer will lock up some bitcoin on bitcoin side, and then it signs this extra transaction when it's doing the sequencing with the same key. And if it double signs that, it exposes that key. And then when that key is exposed, someone can go in and slash their stake on the bitcoin side. And so this can prevent the sequencer from cheating.
00:08:44.560 - 00:09:37.502, Speaker A: And the reason I kind of like this is there's no additional level of hypothecation, right? It's just staking. It's not restaking. And of course, all the other nice things about bitcoin is credibly neutral, is the most dominant currency, and there's a lot of capital out there and a lot of people looking to earn yields on their bitcoin. All right, so now I'm going to go into show mode a little bit and talk about Astro. So everything I just talked about is. So we're building this roll up, and the goal for it is to be super fast. It's going to have cosmos and wooden rust, so contracts run at near native speeds and it's also going to have native yields.
00:09:37.502 - 00:10:27.620, Speaker A: So we're working with stride and noble and some others. And the way this works is that as a user, you just like, you can transfer atom to vl two and then automatically starts earning yields. And it's like just earning yield in your wallet, right? So the UX is going to be like awesome for that. It's also going to run the skip block SDK so you can collect NVB and you can share it with the base player if you want. So a lot of people ask me, oh, why Stargaze doing this? Right? So Stargaze has to kind of evolve beyond nfts right now. The way I think about it is kind of like when Amazon was just like selling books, right? You have to grow, you have to expand. We have a lot of users.
00:10:27.620 - 00:11:31.410, Speaker A: Those users want to do other things, and the only way to do it is to launch more products and service their needs. It's going to be permissionless, so anyone can deploy contracts on it. But strike a ZL1 is still going to be permission. So it has this base layer that is safe and secure. So this is going to open like a whole new class of apps, right? So, like if you can end up with a social media like or whatever, right? Like maybe stuff like that, it's going to be possible on azure. So it's going to have native yield in some cosmos tokens, also stables, and it's probably going to be the first vault that also has bitcoin native yield. So after Babylon launches, there's going to be restaking providers for bitcoin.
00:11:31.410 - 00:12:16.078, Speaker A: And those can be like, we can wrap around that and have native yield in bitcoin. Also on NASCAR. So I'm just going to dive in a little bit and talk about how it's going. So this is an example with like a cosmos asset, let's say stars in this case. So let's say you want to transfer stars to Astra. The way it works behind the scenes is that it'll get liquid staked on stride and then it uses this thing called a hyperlink yield route and it gets locked in a vault. And so the state version gets locked in a vault.
00:12:16.078 - 00:13:17.508, Speaker A: And then there's this contract that calls like a rebasing function every like 6 hours or so, and then that emits like new versions of stars that flows into your account and it can also flow in a contract, right? So if you're an app dev, now you have this yield flowing into your contract. This opens the door for new kinds of things that you could build. Some that yield could be revenue, some of that could flow to the users as a reward. Really looking forward to what people vote with this. The other thing is, it's not going to have a dispute, period. So if you use l two s on Ethereum, like base and blast, you have to wait like two weeks if you want to go from the l two to the l one. There are other ways around this.
00:13:17.508 - 00:14:09.804, Speaker A: You can use all the bridges, but then you got to pay like an extra fee for that, right? So just real quickly, the way this works, and by the way, Yermo did a whole talk about this, so go find his talk at Mahler's summit. But the way this works is that the validators in Scroggy z one will run full nodes of Astra and then they're able to get the latest state and verify the roll up. And it can update the live client on the starting l one side. So now we have this validating bridge between the roll up and between the l one. So you can just do like IVC transactions. And this also opens the door to, let's say there's another l two once various. So you can now do IBC routing between the l one and the l two s.
00:14:09.804 - 00:14:55.182, Speaker A: So you could possibly have atomic execution where robots could talk to another roll up, rather through the l one. So shall that off. I think it went a little fast. But in summary, with real time rollups, you can have awesome ux, you can have pull new classes of apps, you can have this really fast user adoption loop. You can have users come in and add more TVL and bring in more and more users. You have native yield that flows into your apps and you can have scalable security, what bitcoin is taking. And.
00:14:55.182 - 00:15:36.992, Speaker A: Yeah, that's it, folks. If you want to learn more, you can follow me, Shane three B on Twitter or ask our Australia. Thank you all. Actually, anyone have any questions? So are all assets on Astra like liquid staked assets? Like, you effectively turn them into liquid staked assets? No, all assets don't have to be liquid staked assets.
00:15:37.056 - 00:15:37.368, Speaker B: Got it.
00:15:37.384 - 00:15:47.350, Speaker A: So not all assets are inherently yield bearing on. I mean, but if they are oriental bearing at this, then we do want to, like, you know, go do stride or go through another provider.
00:15:47.690 - 00:15:48.122, Speaker B: Got it.
00:15:48.146 - 00:15:49.870, Speaker A: Very cool. Thanks.
00:15:53.570 - 00:16:04.550, Speaker B: Do you plan to replace the layer one with this Astra linker or. Why are you building Astra?
00:16:06.250 - 00:16:27.830, Speaker A: Because we want to build something that's really fast. And right now there are other teams that are working on scaling the layer, scaling the layer one. And we want to separate execution and consensus to build the fastest possible experience. Right now, you can build that on the layer one.
00:16:29.050 - 00:16:32.110, Speaker B: How much DP's do you intend?
00:16:33.010 - 00:16:47.000, Speaker A: Haven't really looked at those numbers yet. We still have to figure out, figure out the metrics. But I mean, in theory, it's going to be much, much faster than layer one because you have another level of abstraction on top of it.
00:16:50.140 - 00:16:54.280, Speaker B: I wonder how many transactions per second Amazon is doing.
00:16:55.180 - 00:16:56.052, Speaker A: I'm sorry.
00:16:56.196 - 00:17:11.860, Speaker B: I wonder how many transactions per second is Amazon doing on the e commerce? Because you said staircase can become Amazon selling any product as an NFT. So I want their own much credibility to hit.
00:17:13.920 - 00:17:18.200, Speaker A: Yeah, I mean, we can talk offline and kind of figure out the math there. But yeah.
