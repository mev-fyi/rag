00:00:09.480 - 00:00:39.830, Speaker A: Hello, everyone. My name is Adair Kelly and I am co founder of Abstract Money. So let's talk about the interchain endgame, the next generation of interchain apps. Right now, it's kind of like the problem that we've all been talking about for years now. Web three, UX and developer experience is really bad and so applications and developers are trapped in silos. And this is one of the reasons that we haven't seen a lot of adoption in Web three. And so, whoops, I'm sorry.
00:00:39.830 - 00:01:23.270, Speaker A: What we need to do to solve these problems is add a layer of abstraction on top of web3, and especially in Cosmos and abstract aims to solve these problems. So I'm sure that all of you have seen all the rampant advertising for Barbenheimer. This is just the media propaganda in your inbox, in your email, in the news outlets and such. But, you know, they work perfectly for an example. So we have Oppi over here and Oppy wants to send Barbie a hundred atom and. But there are some problems. So Oppy's Adam is actually split on four different chains.
00:01:23.270 - 00:01:59.094, Speaker A: We've got Adam on stargaze, osmosis, injective, and stride. And of course, Barbie's over here in Barbie world. She's got her own app chain like everyone else in cosmos. And so Oppy wants to get all of his Adam over to Barbie in Barbie World. So here on the left, we can see Oppy's wallet. He's got his normal Adam on Stargaze, his quicksilver Adam on injective persistence on osmosis, and staked Adam on stride. And Barbie's over here, of course, again in Barbie world.
00:01:59.094 - 00:02:40.730, Speaker A: And traditionally, API would need to perform two swaps and four separate IBC transfers, including an unstake on stride to get that atom over to Barbie. And of course, this is one of the biggest, biggest problems plaguing the cosmos right now is that doing relatively simple actions on the inner chain is quite complex and complicated. But first, how did Oppenheimer split the atom? Well, technically he didn't. It was John Cockroft and Ernest Walton. But that's beside the point. So let's take a look at the theory. And we'll have to go back in time for this, back to the old days of the Ethereum ecosystem and the EVM.
00:02:40.730 - 00:03:27.016, Speaker A: And they subscribe to something called the fat protocol thesis. And this is something that's relatively new in technology, where all of the value accrued by the. All of the value is accrued by the underlying protocol and those applications built on top of it, drive that value down into the protocol. And of course, this is because as the speculation of the underlying protocol increases, more people are inclined to build applications, increasing the value of those applications, driving that value down to the protocol layer and increasing speculation. And it's a cycle. It's not vicious, but it certainly is. And we can see this very clearly in the Ethereum ecosystem.
00:03:27.016 - 00:04:14.926, Speaker A: We've got all these applications driving the value down to the Ethereum protocol. And this is evident in the market captain, which is almost ten times the amount that is locked in DeFi right now. We've got 25 billion versus 225 ethereum. And we have a famous tweet from sunny a few years ago where that Cosmos is the rejection of the fat protocol thesis. And I think we all know why. It's why we're here today because of the fat application thesis. So now we have platform specific applications that are customized and catered to those specific users and can be made more efficient to support those applications built on them.
00:04:14.926 - 00:05:19.840, Speaker A: So for instance, right here we have osmosis, which is designed specifically for swapping, providing liquidity, withdrawing, and then now they have supercharged liquidity, and it can be customized to the users and the application's needs. We also have other examples, like injective, which offers an order book, but you can also build applications on top of this orderbook. And of course, all of this value is encapsulated solely in the application and not the underlying protocol, as opposed to an ethereum, of course, where it's all driven to the eTH token. Now, traditionally between different blockchains to bridge the gap, we have just a bridge. And this can be very centralized and is actually the source of many hacks that we've seen in DeFi, is not very secure, but in a transfer value and send messages, it sometimes works. But of course, we all know what happens with those. We have trust issues because of these bridges.
00:05:19.840 - 00:06:16.790, Speaker A: And the largest hacks that we've seen to this day, with the exception of Euler, have been bridges. So what, in the multi chain world, what do we do without bridges? And like, how do we transfer value between all these chains, transfer messages and improve this experience so that we're all building on that same protocol? Because I think we can see in each of the Ethereum conferences, we're all building on Ethereum. And that makes us feel good because we're meeting fellow builders. They're building an ethereum and they're building another application that could provide more value to that underlying token, which of course increases our application's value. But in Cosmos, all of our app chains are quite siloed. We have individual protocols with individual tokens, and there's nothing that kind of equalizes that. And the that value can be accrued to.
00:06:16.790 - 00:07:39.078, Speaker A: However, we have IBC, and IBC is a very unifying protocol that you can transfer all these values and messages between the chains. However, why aren't we seeing that value being brought through the different chains? Why are we seeing such fragmented liquidity and such infighting in the cosmos when we have these amazing applications on terra Juno and all these other chains? We're not seeing the unification of the builders and we're not seeing better interchange applications. That's IBC. And so people on Twitter have theorized, like, maybe it's the fat interface thesis, and I want to explore more of what that means. So if we look at interchain apps, they like 42, they are building auto compounders and Dex aggregators across the cosmos to aggregate that liquidity and provide a good user experience. They have an auto compounder on Astraport, on Windex, osmosis, and of course an astroport, again on injective. And now their implementations are tightly integrated with their integrations and tightly coupled with their integrations, which means that bringing this auto compounder to different chains requires them to do a complete reimplementation of it, a complete redeployment.
00:07:39.078 - 00:08:35.710, Speaker A: And it's a struggle for them and their users who have to, you know, switch their chains and just deal with a bad user experience. So this is where abstract kind of steps in. We want to define a better interface for interacting with these wide variety of protocols and applications that we have in the interchain. And this is not just limited to the cosmos. We want to bring this to all applications over IBC, and we can even support EVM through evmos, EVM extensions in the future. So in this diagram, we can see that 40 two's auto compounder now is depending on a Dex adapter and an LP staking adapter. And what might these adapters do? Well, if any of you know the adapter pattern in computer science, it allows for incompatible protocols to be adapted to the same standard interface.
00:08:35.710 - 00:09:24.466, Speaker A: And that's exactly what we've done here. So I'm going to go through some code a little. But we can see on Dexs, there's only a limited set of actions that we traditionally do. There's swapping, providing, withdrawing liquidity, and maybe some simulations. And so we define a top level struct for a Dex action where we can provide our offer and ask asset, as well as a possible max spread or belief price. And then when we want to execute this action on a given Dex, on any given chain, we just provide the Dex via name and the action that we wanted to do. And so here we're swapping on osmosis, we're swapping USD for euros, and we have a 1% maximum spread.
00:09:24.466 - 00:10:35.160, Speaker A: And what this does in the backend is it actually, and this is completely on chain, this is an on chain smart contract that translates that message into the osmosis swap message, which means that you can perform the swap on any chain from your application without having to worry about intricacies of that service that you're using. And this works for almost every single Dex in cosmos, at least the ones that we support. And it pushes away that integration from the implementation. So you can focus on your core business logic without having to even think about what the underlying Dexs or underlying protocols that you're using their technology. And so here, as a cosmosm developer, we can see that we're in our application, we're asking for the Dex, and this returns us a string construct that encapsulates actually all of the messages in your cosmosm contract. And we build the offer and ask asset, and we can literally just say Dex swap. And this is because we've pulled in osmosis up here.
00:10:35.160 - 00:11:58.616, Speaker A: It's aware that that is the osmosis Dex. And then when we call swap, this essentially just builds a message to send to this adapter smart contract, which is installed on your application, and it executes it via your application, hiding all of that logic from the end user and from the developer, which makes it a lot easier. And so we've kind of encapsulated this functionality not only with the dexadapter, but with a couple other things, like the CW staking adapter, which allows for arbitrary staking of arbitrary LP assets on DEXs and protocols. So that means that you can provide liquidity on osmosis and then stake that liquidity somewhere else, theoretically. And up here, we can see that 40 two's auto compounder depends on both of them, as there are four actions where there's deposit, and then after you deposit it has to swap those assets for the pair of assets. Then it provides liquidity, takes that LP token, stakes it using the staking adapter, and then periodically. What's not pictured here is that it uses croncat, which is also a module that's encapsulated to call this compound function over and over again.
00:11:58.616 - 00:13:25.486, Speaker A: And so with abstract, we are trying to scale application development. We provide a strongly opinionated framework for building applications in a more modular manner, and so that each of these modules can fit together, each team can focus on their core business logic, not worry about the integrations which could be built by other teams. And what we'd really like to see in the future is that Windex will take care of their own Windex adapter that fits into the DeX, same with astraport osmosis whatsoever. And then these applications, for instance, 40 two's auto compounder, you can actually build on top of them because these are published to some sort of package registry, which is another thing that we don't have on chain nowadays. We don't have a way to publish our smart contracts in a secure manner where we can trust all of the code that's in them, see if they're audited or. Yeah, and something else that's pretty cool is that when you're building these applications and you take on a dependency, that dependency on chain is dynamically resolved. And so when the module publisher publishes an update, you can choose whether you want to pull down that update into your own infrastructure.
00:13:25.486 - 00:14:21.866, Speaker A: And that means that your applications, when there's a bug fix, you can get that security fix immediately out to your customers and while the infrastructure is still completely sovereign to your application and completely customized to your needs. Yeah, so another thing that we can see here is that there are two different types of modules. There's these adapters which are essentially service providers. They sit in front of these services and then there's applications. And these applications can be composed to form even greater applications, which we can see with the auto compounder aggregator which sits on top of 400 two's auto compounder across every chain. And that means that they can interact with all of their auto compounders through one smart contract, completely cross chain, but, or not. But.
00:14:21.866 - 00:15:48.052, Speaker A: And so how do we get from fat to fit from the fat application thesis to the fat interface thesis? So with abstract we're trying to do this here, where the abstract interface sits on top of each of these chains, each of these applications and all of these services. And IBC is that common unifying protocol. However, I like to think of it more as the fat interchain thesis as we're going to see a lot more interchain applications built on top of these interfaces that we've defined. And this means of composing applications and pushing the business logic into their own isolated modules, their own microservices that we can compose and make better scalable interchain applications. And so coming back to the Barbie example, what if I told you that every one of these applications was actually a smart contract wallet? And so I don't know if this brings up, oops, yep, brings up any visualizations in your mind. However, it means that any application that you build, you can actually have your users pull that application down, purchase it from you, or maybe not even purchase it. They could pull those modules from the module registry and run your infrastructure themselves.
00:15:48.052 - 00:16:35.540, Speaker A: And you can self host these applications that service providers have created. For instance, 42, you can self host their auto compounder. And the thing that this is really useful for is actually for enterprise, except enterprise is the wrong word. It's enterprise like VC's, for example, who want to host their own liquidity, and they don't want to trust a service like beefy finance. They want to self host it themselves, run all their infrastructure themselves. And they can do that with the power of account abstraction. And so looking into this example, we can see that Oppy over here has an abstract host account on any given chain.
00:16:35.540 - 00:17:27.149, Speaker A: Let's say it's stargaze in this example. And Oppy has client accounts, and this is similar to interchain accounts. However, they're interchange smart contract accounts that leverage interchange accounts in the background for chains like stride that don't support cosmwasm. And so now with Oppi's host account, he can call one action, he can call request liquidity from each of his client accounts. And so his client account on osmosis as it is based on account abstraction, can leverage this when it receives this request liquidity request, it says, all right, where do I get this liquidity? It's on osmosis. I need to swap my quicksilver atom, I believe, or persistence, atom for atom. And then it comes back, sends it back to the host.
00:17:27.149 - 00:18:25.058, Speaker A: Same with the quicksilver atom on injective can swap using the orderbook module. And yes, that is an async action. However, we can define a number of blocks that we want to wait for that swap action to complete, sends it back to the host account, and then finally on stride, we can unstake that atom and send it back to the host account. And finally, once this is all completed, while yes, it has taken a few blocks, he can make a second transaction to send all of those assets over IBC to Barbie. And this is the power of account abstraction and composition of modules. And this can actually be completely encapsulated in another module, which, and this is where kind of the craziness steps in because you can take all of this functionality. You can think of all of this functionality as an interchain application.
00:18:25.058 - 00:19:23.790, Speaker A: So this host account is kind of like an outpost model where there's the host and then each of the clients that has been touted by osmosis and Stargaze recently just mentioned their new starbase, outposts. And so you can take this and do outpost as a service built on abstract. So I don't have that much time left, but I'd like to invite you to come to a workshop tomorrow. So, to build an interchain application with the abstract SDK, we're going to be using Croncat and the Dex adapter to create a dollar cost averaging app similar to maybe calc finance. And this can sit on any Dex that you want and whether that be osmosis, Windex, Astraport, Terraswap, Junoswap, and then a couple others. But yeah, it's 1130 tomorrow in this room. And thank you for listening.
00:19:23.790 - 00:19:33.710, Speaker A: Yeah. Are there any questions?
00:19:36.500 - 00:19:43.948, Speaker B: Like, you mentioned arbitrage at some point, and when I saw the graph, like, seems like the perfect.
00:19:44.084 - 00:19:44.596, Speaker A: Yes.
00:19:44.708 - 00:19:46.892, Speaker B: To build, like an arbitrage bot for the interchange.
00:19:46.996 - 00:19:47.420, Speaker A: Yes.
00:19:47.500 - 00:19:58.240, Speaker B: But just how much of it can I do? Like, with how permissionless it is, if I want to do some actions or deploy smart contract from some chains?
00:19:59.620 - 00:20:00.360, Speaker A: Yes.
00:20:00.660 - 00:20:10.730, Speaker B: So I interact with abstract, but then how does it work for it, for it to be implemented on chains that you don't have permissionless or contract deployments.
00:20:11.230 - 00:21:03.790, Speaker A: For chains that don't have, like any, like the Cosmos module, for example. Yes. And so the abstract framework and like, the core applications, like the adapters, would have to be done via proposal. And so we're on their test nets right now, and we've been in talks with Sunny and Shane about those on those specific chains. But yes, that is one of the limitations with this. However, you can perform any of those interchain actions and you can create the messages on the host chain and send them to the client and still execute them. So essentially, you could build all of your complex messages on another chain if you don't have that module deployed on the target chain.
00:21:03.790 - 00:21:16.210, Speaker A: That's a good question, though. Cool. Well, thank you so much.
