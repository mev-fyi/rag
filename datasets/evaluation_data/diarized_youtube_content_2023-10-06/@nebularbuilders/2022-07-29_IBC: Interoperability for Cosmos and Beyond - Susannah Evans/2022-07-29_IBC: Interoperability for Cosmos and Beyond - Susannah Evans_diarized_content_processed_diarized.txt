00:00:10.440 - 00:00:52.790, Speaker A: Hi, everyone. So, yeah, thank you for joining and coming to my talk. So, as I was introduced, I am currently working as the product leader interchain, and our team is working on the IBC specs and the go implementation of IBC. So today I'm going to talk about IVC, the inter blockchain communication protocol. I'm going to give an overview of how it works, how it's used, and how it can be used beyond cosmos, and then I'll just wrap everything up at the end. So, yeah, we're going to start by looking at this very beautiful picture. This is a port in Marseille in the 17 hundreds.
00:00:52.790 - 00:01:34.100, Speaker A: And as you can see, there's people kind of loading barrels onto ships, offloading sacks of grain. And it's quite chaotic. There's a lot going on. All of the cargo has a different shape, and there's kind of no unified way to put stuff on and off the boats. And if we fast forward to the 21st century, we can see that this is a typical port. This boat is completely optimized to hold as much cargo as possible. There's cranes, which are dealing with the loading, so they handle the cargo, taking it on and off the ship with ease.
00:01:34.100 - 00:02:15.674, Speaker A: And the reason why it's improved so much since the 17 hundreds is because of this shipping container. And the shipping container is a yemenite, a global standard in the shipping industry. It has a standard size, dimensions, and this means that it can be used in all ports interchangeably. All of the cranes are compatible with these containers. And it doesn't matter what's inside the containers. You can move anything from a to b really easily because of this standard. So, yeah, if we go back to Marseille, they had, for instance, wine in barrels and grain in sacks.
00:02:15.674 - 00:03:20.292, Speaker A: If you had these shipping containers, you could also be transporting the wine and grain, and it just fits nicely into these containers. So, yeah, why am I talking about shipping? So it forms a kind of nice analogy for IBC. And so IBC, if you didn't know, is an interoperability protocol to allow blockchains to communicate with one another. And in terms of the shipping analogy, you can think of the blockchains as ports relayers who are actually responsible for sending the messages from a to b. You can think of that as the boats going between the ports and the closed shipping container, which has standard dimensions and means that all the cargo is going to be transported in a standardized way. You can think of this as the transport layer in IBC. And when you actually open the shipping container and you see, oh, there's like wine or grain inside.
00:03:20.292 - 00:04:06.138, Speaker A: You can think of this as the application module in IBC. So once you know what's inside the shipping container, you'll do specific actions based on what you have. So then if we look in a bit more detail into each of these components, here is a high level depiction of how IBC works. So you have two blockchains, blockchain a, blockchain B, that are trying to communicate with each other, and they have an application module. And this interfaces with the transport layer. And the relayers are responsible for ferrying messages between blockchain A and blockchain B. And important to note is that anyone can be a relayer.
00:04:06.138 - 00:04:54.410, Speaker A: So this is what makes IBC a permissionless protocol. In theory, you could relay your own messages between the two blockchains that you want to communicate between. So if we look in a bit more detail at what's going on in the transport layer, the nice thing about IBC is that you split up the transport layer into these three components. And the top layer are the channels. So the channels are what interface with the applications. And this is nice because if you're an application developer, you only need to be concerned with what's going on with these channels. Everything else in the transport layer is not really relevant for your specific purpose.
00:04:54.410 - 00:05:34.472, Speaker A: And so these channels are where data packets are sent over. And every channel has a, a port id and a channel id. And the port id is identifying the application that this channel is intended to be used for. And the channel id is just a unique identifier for this channel because it's important to note that one channel has a single application for it. So for instance, if I wanted to send atom from the hub to osmosis, this would be through one channel. And for a single token denomination there would be one channel as well. So you wouldn't have multiple channels sending atom.
00:05:34.472 - 00:06:34.700, Speaker A: There would just be one channel that's dedicated to sending atom between the hub and osmosis. And these channels can be ordered or unordered. So it either matters the time that the originating message was sent or it's irrelevant. And in this example that I've just picked out just to demonstrate the naming and a use case. So if I wanted to send atom from the hub to osmosis, the port id would be transfer to show that it's a token transfer and the channel id is 141. And if I was sending atom from osmosis to the hub, the port id would also be transfer, but the channel id is zero in this case. So the next level of the transport layer are the connections, and between two blockchains you would have one connection, but then there can be as many channels as you want built on top of this one connection.
00:06:34.700 - 00:07:18.600, Speaker A: And the connection is there to verify that the chain that you're communicating with is as you expect it to be. So there's a connection handshake that will take place between the two blockchains. And then once the connection is established, it's responsible for all of the communication between these two chains. And then the clients are arguably one of the most important parts of the transport layer. In IBC. It's the way that means that you are sure that messages are actually being sent to you. So the blockchain a would have a client of the blockchain b that it's trying to communicate with.
00:07:18.600 - 00:08:08.520, Speaker A: And with this client it can check that a message was actually sent from blockchain B. And this means that the IBC protocol has security in line with the underlying chain's consensus mechanisms. There's no kind of trusted third party in that sense, so it's really trust minimized, dependent on the underlying chain's consensus mechanisms. And relayers are responsible for updating these clients. So they will submit block headers to the clients, and then this will be used to verify the consensus date of the counterparty chain. And relays can also submit misbehaviour. If they think something is either there's like a hard fork or some misbehavior, they can also submit this to the client.
00:08:08.520 - 00:09:14.150, Speaker A: And then what's actually being sent between the chains are the packets themselves. And this is going back to the kind of analogy I said with the shipping container. So the packets are sent in standardized format, so you have information on the origin of the packet and the destination, and then you have a timeout height and timeout timestamp associated with it. This is so that if a packet does not reach its destination as it's expected, you wouldn't lose, say, for instance, you were sending tokens, you wouldn't lose them forever. The transaction would be reverted and your tokens would be refunded. And then within this shipping container there's data in the form of bytes, and it's the responsibility of the application module to decode these bytes and perform whatever action is intended to be performed. So it could be a token transfer or a cross chain query, or whatever the application is intended to do.
00:09:14.150 - 00:10:20.242, Speaker A: So for the protocol to function with a successful packet send, this is the kind of flow that a packet would take, so a user would interact with the application they would then send the packet to the transport layer, and then the relay would query this packet. They would then pass this packet on to the receiving blockchain. And then once the receiving blockchain has received the packet, the application module on the receiving blockchain will then carry out whatever logic that application needs to function. And then they will send an acknowledgement back, and the relayer will ferry this acknowledgement back to the sending blockchain. In the case where the packet wasn't received by the other blockchain. So blockchain B doesn't actually end up getting the packet that was sent. The relay would query the core IBC on the receiving blockchain.
00:10:20.242 - 00:11:05.030, Speaker A: They would say, oh, this packet wasn't received. Then they would send this timeout back to the sending blockchain to let the blockchain know that the packet never got there. And, yeah, just to. That's kind of a summary of how IBC works. But the reason it's such a powerful protocol and why it forms this standard for cross chain communication is there are three main elements that make IBC such a powerful interoperability protocol. So the first is the security. As I mentioned, with the like clients, you're trusting the underlying consensus mechanism of the blockchains that you're trying to communicate between.
00:11:05.030 - 00:11:46.300, Speaker A: And there's also fault isolation built into IBC protocol. So if there is some misbehavior detected, this, like, client would just shut down and stop sending messages between the chains. And this is really important just to, like, you know, stop the spread of, you know, file behavior, which could have a much greater impact if it went beyond a single chain. IBC is also permissionless, so anyone can relay packets between chains. You don't have to have a specific person. You don't have to be whitelisted. There's no restriction on who is able to actually ferry these data packets between chains.
00:11:46.300 - 00:12:22.182, Speaker A: And IBC is also generic enough to enable general message passing. So it's not just about sending tokens between chains. There's a whole other host of functions that you can use IBC for. And because of these factors, this is what makes IBC a really powerful interoperability standard. And IBC was launched just over a year ago. And there's some nice graph here which demonstrates the growth IBC has seen. It's been exponential growth, really.
00:12:22.182 - 00:13:07.680, Speaker A: It's a very fundamentally used protocol within the cosmos ecosystem. Right now, there are 48 chains that are connected and using IBC. And in the past 30 days, there were over two and a half million transactions. And in value that was transferred $330 million. So it's a. It's great to see that this protocol has had such great utilization and growth and it's only been around for a year. So yeah, I've talked a bit about how IBC works, but I haven't really touched on any of the applications and I said that it could enable general message passage, general message passing.
00:13:07.680 - 00:14:19.980, Speaker A: But the main use case so far has been token transfer. That was kind of the first essentially go to market of IBC and you can do token transfer today with IBC using either the interchange standard or you can actually do token transfers using Cosmos and smart contracts. There's also an example of a more general data transfer using IBC. So the band protocol is a decentralized oracle network and they are actively sending out oracle data to blockchains in the cosmos ecosystem. And injective created a custom application to actually send and receive this oracle data, so they're mainly using it for price feeds. These are just two use cases which are live and happening frequently today, but there's a whole host of other things which are currently under development. So interchain accounts has been launched as a feature, but chains are just still working on implementing it for their specific use cases.
00:14:19.980 - 00:15:14.438, Speaker A: It's basically a way to do a cross chain write. So perform an action on another chain originating from a chain that basically say you're on blockchain A, you can then perform an action on blockchain B. And so for instance, example you could use this functionality for is cross chain voting. So the hub could vote on a governance proposal on regen, for example. Another cool feature which is being developed by a few teams is interchange queries. So this is a cross chain read. So quicksilver are developing a interchange query application module and for instance a use case for this module could be to check the delegations of an account.
00:15:14.438 - 00:15:58.844, Speaker A: So see what one account is delegating their tokens to on another chain. And there's also NFT transfer that's been developed by Irisnet. So this would enable you to send nfts between two blockchains. So for instance, you could send your NFT from Iris to Stargaze or omniflix. Also use nfts. And all of these examples that I've kind of given so far have been very cosmos focused, but IVC can and is in the process of going far beyond cosmos. So currently the out of the box lite client implementation is the tendermint lite client.
00:15:58.844 - 00:16:45.134, Speaker A: So that's what all of the Cosmos SDK and tendermint based chains are using to plug into the IBC protocol, and they're using the IBC Go implementation. But this is just kind of the first use case. So composable are developing two lite clients to extend the reach of IBC. The first one that they've developed, and it will be going live, I think, in this quarter, is the beefy lite client. So this would connect cosmos with parachains in Kusama and Polkadot, and there also started work on a near light client. So this would enable us to connect to the near ecosystem. And there's also enterprise applications of IBC.
00:16:45.134 - 00:17:58.690, Speaker A: So Hyperledger Bayesu has a like client for their proof of authority based consensus mechanism. So, yeah, these are just four examples of IBC being developed for use outside of the cosmos ecosystem, which I think is really exciting and really reinforces this notion that IBC can be a cross chain communication interoperability standard. And beyond just lite client implementations, there are also other ways that you can access this interoperability standard that IBC offers without having to make a lite client. So, for instance, Siftane uses peg zones, which is a way to basically interface with blockchains with different consensus mechanisms, your blockchain. So it kind of just acts as a buffer to make sure that there's a. For instance, Ethereum has probabilistic finality. So the peg zone has adequate delay to make sure that you can verify that what's happened on Ethereum is actually going to be final.
00:17:58.690 - 00:18:43.148, Speaker A: And then the solo machine case is just another way to verify a state. But it's using like, a key value per signing. And crypto.com use this to mint dot. So they're a custodial chain, and they buy dot themselves, and then they use an IBC solar machine to mint dot that can then be used on their Cosmos SDK change. So, yeah, just to summarize everything that I've spoken to, spoken about, I'm really bringing this analogy back of IVC being this interoperability standard. It's a secure way for chains to communicate.
00:18:43.148 - 00:19:28.936, Speaker A: It's permissionless, and it enables a really big range of applications through this general message passing ability. And as I mentioned, IBC is not just for Cosmos. That was definitely the first use case and implementation of the protocol. But it's already starting to have reached much, much further than just Cosmos. And if you're interested in the interchange accounts feature that I mentioned, Thomas, our developer relation, is going to be giving a presentation and demo at 525. I think, in the workshop room? I would have to double check, but, yeah, you should check it out if you're interested. So, yeah, thank you for listening to my talk.
00:19:28.936 - 00:19:34.740, Speaker A: And, yeah, this guy is just wishing IVC existed back then.
00:19:43.400 - 00:19:51.990, Speaker B: That was awesome. Congrats. We have time for questions and with some beautiful mics here. Does anyone have a question for susanna?
00:19:55.690 - 00:20:11.498, Speaker C: Yeah, it's a similar question. I was wondering if you send a token with IBC from chain a to chain b, then from chain b to chain c, and then from chain c back to chain a, do you get the original token back, or is this like some split of liquidity?
00:20:11.594 - 00:20:22.564, Speaker A: No. So that basically, when you do this, it would have the path going a to b to c and then c to a. So you'd actually have to unwind it down the path.
00:20:22.652 - 00:20:24.716, Speaker C: Is that something that might be changed?
00:20:24.788 - 00:20:43.920, Speaker A: Yeah. Yeah. So I think there's kind of talks to possibly implement some middleware which could unwind tokens. So then it would become, like equivalent to the native token that it came from on chain a. But, yeah, currently it would have a different.
00:20:45.220 - 00:20:48.480, Speaker C: Any timeline for this or just talks?
00:20:49.940 - 00:21:28.550, Speaker A: I think it's actually something that we've been thinking about, thinking about if the interchange standard 20. So this is token transfer should maybe be changed and generally like middleware, which is going to then probably be used for lots of token transfer use cases. So token fungibility is like, a big general topic that is discussed, and, of course, it's a key question. So I think it's something that we're thinking about. But I can't put a timestamp on. It's not going to be in this quarter, but possibly q four, something like this.
00:21:39.540 - 00:21:42.600, Speaker B: So what happens with a contentious, hard fork?
00:21:44.540 - 00:22:34.020, Speaker A: So, if the lite client was updated and there was discrepancy between the previous update and it saw like, oh, either there's a discrepancy in the timestamp of updating the client, or you have a consensus state for the client, which has information on the block header and the validator hash. So if there was some discrepancy you set, like the. Every client sets their own parameters as to how far this discrepancy would be, then the client would just shut down. So, yeah, this is like a fault isolation mechanism. If there's something that looks wrong. Yeah. The safest thing to do is just to say, I don't want to communicate anymore or deal with this.
00:22:38.560 - 00:22:44.496, Speaker B: Any final questions? Okay, cool. Thanks so much, Susanna.
00:22:44.608 - 00:22:45.000, Speaker A: Thank you.
