00:00:00.400 - 00:00:23.910, Speaker A: Do that if you're not very techy, you probably just realize that it's too hard and you're going to quit. The next option is that you mess with the configuration of that application. Let's say you did get it set up properly. You're going to figure out you can't change the token, you can't change the wallet prefix. There's no easy way to launch a testnet, so you realize it's too hard and then you quit. Then you realize that you need external modules. The SDK doesn't have everything that you need.
00:00:23.910 - 00:01:05.762, Speaker A: Other people have built these other plug in like systems, and so where do I go find smart contracts or how to allow users to make tokens or these other features that are core to almost all Cosmos chains and it's not provided to you by default. So you realize it's too hard and you quit. Then there's these other instances of how do I run this? You need to learn multiple languages, you need to have an understanding of how to test these complex frameworks that's not provided to you in the SDK. And once you get that all set up, finally you need to upload that to GitHub. It's just a pain. So you quit writing a faucet, you're ready for a testnet, you finally got everything set up and you just another step in a roadblock there. So you realize it's too hard and you have to quit.
00:01:05.762 - 00:01:58.214, Speaker A: And then finally you finally got all of that set up and we've not even done any custom logic yet, and so there's so many points of friction for a new user to come into the space and we need to drastically reduce that onboarding burden. At every point you realize it's too hard and you quit. Whether you're extremely smart in general software engineering or just someone coming in new, there's no easy way to get started from either point of view. So what's the result? We don't have any applications. There's no applications for people to use because it's too hard and you realize it's too hard, so you quit. So how do we fix this? Well, first we need to make it easy to pick features, so allow the users to come in and select what do they actually want. It's not up to us to be opinionistic about what you should use, it's about what's best for your product.
00:01:58.214 - 00:02:32.170, Speaker A: So if you want a proof of stake network, for some reason it's baked into your tokenomics. You should be allowed to select that. If you want to build out a proof of authority network because you don't actually need a token, you just need a validator set for some reason. Something like noble for example. You should be able to select that in your use case. Or maybe you want where someone else runs all the infrastructure for you, such as partial set security or interchange security through the cosmos hub ethos via Ethereum restaking, or maybe something like saga. You should be able to select all of those options, and it is not up to us, it is up to you to decide that you want that.
00:02:32.170 - 00:03:09.860, Speaker A: Then the other important thing is selecting popular features. So these other instances that are not provided by default in the SDK, some of them are coming, but token, factory and smart contracts, you have to go find those, integrate them. It's going to take you at least 15 minutes for experienced cosmos developers to do this. It's another hassle that you need to go through. We need to reduce that and make it super simple to say I want smart contracts in my application because I already know that ahead of time and it's just going to work out of the box. There's some other features like core parts of IBC that you have to also do the same thing. We should provide those by default and allow users to choose and pick what they want.
00:03:09.860 - 00:03:54.860, Speaker A: So we also need to make testing easy and fast. So it needs a pre built environment that has everything for you end to end testing, unit testing and helpers for all of those functions there. That way that you can just get started up and running. There should be some example test, that way that you can understand what does that flow look like for GitHub, we need to have that easily integrated. So every time you push up new code that should be verified in the CI, which is continuous integration. So I should push up new code and does everything break or do things still work as I expect, based off of my test? And then I should be able to deploy via GitHub an entire testnet in one click through a standard UI that I'm already used to as a developer. So we want to make it where you're not always in the command line.
00:03:54.860 - 00:04:31.124, Speaker A: You're actually able to use the UI that is upstreamed. And then part of this testnet is we need IBC enabled by default. Current testnets that are local, they're very specific to just your protocol. But what if you have a protocol that needs to talk to something like an osmosis or a cosmos hub? You have to be able to launch that, and we need to do it easily by abstracting away what IBC looks like from an application point of view. As a builder, I don't care what needs to happen on the backend. I just want a channel that connects me to Cosmos hub that I can transfer tokens in between. And if I need something more specific, I should be able to override that.
00:04:31.124 - 00:05:15.606, Speaker A: And if I'm overwriting it, it's because I already know that I need to. Most people believe that they just want it for tokens, so allow them to go in and learn more as things come up where it doesn't fit their current use case and allow those power users to override things like that. We need to provide a faucet, and as I mentioned, we also need to be able to launch it in GitHub, not via the CLI. So we need to also make it extensible. You should be able to easily create modules on top of all of this. We talk about all these modules, you're importing all these modules, but how do I actually make my own? And going through that setup process can take hours even for experienced developers of setting this up, getting everything connected and it still doesn't work. And then you spend another day on it and it still doesn't work and you finally get it.
00:05:15.606 - 00:05:51.280, Speaker A: And now your idea, you want to go focus on other things for other projects that you're working on. Make it super easy for that base structure schema to be set up and then allow for you to decide do you want a standard module or maybe an IBC module or middleware. And you should be able to have that option in there, built in and automatically connected up through your entire application for you. And that way you can focus on what actually matters, which is building the application logic. So we need all of this in one place. You should be able to do it in less than five minutes with very minimal system requirements. That specifically being docker and go understanding.
00:05:51.280 - 00:06:26.006, Speaker A: So if you have those two understanding, that's all you need for the requirements here. And then a little bit of basic go understanding is a good prerequisite for this. So with all of that said, meet spawn the easiest way to build, scale and maintain applications for Mac OS, Linux and Windows. So if you're going to capture an entire market, you have to actually support an entire market of developers. That is extremely important. Most of us are focused on the more Mac OS and Linux side, but other ecosystems that do support windows. There are leaps and bounds ahead of us in terms of tooling and operations.
00:06:26.006 - 00:06:48.210, Speaker A: We need to also have those same things there. And Spawn is able to bring that to our users with a lot of work that we've put in on the engineering side. So let's create a new application, we're going to use this new chain and we're going to create a new chain called Titan. Those are the only three words that we need to set up. And then a UI comes up. Power users can decide that they want to override this, to not have uis. So you can bypass this prompt.
00:06:48.210 - 00:07:29.564, Speaker A: But for most users, you're probably just going to want to have a little UI in your Cli that allows you to just select what you want. So here you select down. We're going to select proof of stake and we actually show you what does that actually mean? Like what is proof of stake? Maybe I'm a user and I don't know, we should at least document somewhat that way. It intrigues your interest, and maybe that's actually a better fit for me than what I expected with the original idea that I had interchange security. If we did select, that would give you a dropdown of Cosmos Hub ethos and then saga in the future and other providers that come up that are supporting ics will also be in there. So you're able to mix and match it and decide what you really want, reading through it, and then go ahead. Once you go through this, you'll click done.
00:07:29.564 - 00:08:02.488, Speaker A: And then the next slide will actually show the features that you're able to select. So we're going to select token factory IBC packet forward middleware, which is not provided by default even in the IBC Go repo. This is an external repository selecting cosmwasm, giving us smart contract execution and optimistic execution, which allows for some more performant action. So all of this is just selected by the user in the UI. We haven't wrote any more in the CLI, it's just here. Then you press enter, you invoke some magic, and you're ready to go. So this is going to automatically generate everything for us.
00:08:02.488 - 00:08:48.490, Speaker A: So everything's been created with all of the features that we want. It's all configured, including testing. And then we just tell the user, hey, your chain's been created, Titan is generated. And here are some useful commands that you may find useful both from your own system, such as uploading it to GitHub, as well as creating new modules and how to make a testnet. And we want to make that simple and easy to use for users where they can just come in, run a single command and it works as expected, like really the entire cosmos application is generated, all of the CI we've got an entire testnet JSON file. You can also write it in YAML if you like comments. So everything is there with some same defaults that you can then decide to override when it is time and then on the right shows all the keepers are set up there for you, including the latest things like the Circuit keeper and SDK version 50.
00:08:48.490 - 00:09:24.614, Speaker A: It's super easy to scaffold new modules as well. Within spawn you just run module new and then name it whatever you want and it's generated. And then you can also just run make protogen and that's going to take your schemas that are given to you by default and turn those into the go code that you can then begin your application logic on. We'll pre define all of the method stubs for you. So you really just write your logic and the schemas so you can focus on your application because that's important. And for any power users, yes, we have dependency injection support by default and we automatically move all of those files for you. So we abstract all of that setup away from the users.
00:09:24.614 - 00:10:09.138, Speaker A: Just write your schema, just write your business logic and then you're ready to push it up to the next step, which would be testnets. So what does it look like to actually launch one of these testnets? Well in the current state you need to launch it with a bash script and you try to figure it out with Docker, but then you need multiple docker instances and you can literally spend weeks trying to do this. Well we make it a simple command that just says make testnet. And behind the scenes we build up all of your images for you, we build up a docker image for you and then we connect all of these with relayers and all of that from that previous JSON file that we saw. And then you get an easy to interact with rest API here is on the right. That gives you all of the information for RPC addresses, your rest addresses, your peer to peer. So you can actually launch this with other external validators.
00:10:09.138 - 00:10:27.468, Speaker A: We just give you a testnet and we launch it all with Docker. No kubernetes. All the orchestration is done and go through our local interchange environment. But the user doesn't need to know that. All they know is that they want the Testnet and we allow them to have that. Well now we've got all of this set up with a custom module. We'll assume that we wrote some custom logic.
00:10:27.468 - 00:10:55.812, Speaker A: There's a little bit given by default for parameters. So let's upload this to GitHub. Well, there was that command when we created it for using the GitHub command to upload our new Titan network. And we're going to push it up and we're going to make it private. So we run this within the repository, and now that's pushed up into my repo. Every time that you push up with all of the features, they're all tested. We have interchange test running here, and we're already testing basic, just making sure the chain runs full IBC.
00:10:55.812 - 00:11:28.818, Speaker A: So we're launching multiple chains IBC ing between them, validating that those are done. We have wasm test where we're executing against wASm contracts and ensuring that your logic works. Related to that. We have packet forward testing where we launch four of your networks. We connect them all together and then we route tokens through them and all the way back, verifying that that also works a more complex part of IBC. And then we have token factors to make sure that minting and sending these tokens works as expected, as well as burning. So all of this is run and the user hasn't had to write any of these tests.
00:11:28.818 - 00:12:10.670, Speaker A: All we said is I want this feature. And with that feature we now wrote tests for them based off of their configuration, abstracting away all of the headache for the user and giving them a sane environment to work on for their applications. So how do I get from here though, to a public testnet? Now I've written my application, but I want something with multiple validators. I want this faucet, I want an IBC environment that I can fully control, but also allow others to connect to another testnet like osmosis or the cosmos hub. And I want other users to have external interaction with my testnet because I've only run local testnets up to this point. Well, all you have to do is cut a release in GitHub. So any developer that has ever used GitHub has probably pushed a release.
00:12:10.670 - 00:12:47.994, Speaker A: All you do is press publish release and you get a tag that has a semantic version. So I'm just going to say version one of this is the launch and we're just going to publish release. Once you do that, it just launches on a public cloud. So you enter in a couple of your authentications for, in this case we're using Hetzner and we just launch up your entire testnet exactly how it was in your development environment, and we run that upstream. This also works for private repositories. We've built up a docker image and behind the scenes we're doing all of that and launching it on Hetzner. And now anyone can access it via this local interchange API or via the standard APIs and RPCs that are provided by the Cosmos hub chain.
00:12:47.994 - 00:13:27.784, Speaker A: The most important part is this is all public, so anyone's able to access it. You could add some permission based systems on top of this. We have that support, but it is the easiest platform to actually launch from just idea to a new testnet. And you can get this up in a matter of minutes from just your idea starting to. Well, what about interaction? We know in the bottom two we can interact via the rest API on port 1317 or via the binary with the RPC. But what if I don't want to have a binary and I also don't want to interact via the API or GRPC for whatever reason? Well, from a user perspective, it's always a pain to interact with multiple testnets. You have all these rpcs, you've got all these chain names.
00:13:27.784 - 00:14:02.686, Speaker A: How do you interact with three layers that are up on another machine? We've invented this local interchain interact, which through Docker will give you the correct version. It will find out what the chain name is, give you that binary, and we abstract that from users. So I want to interact with local chain one, which is what the default chain is that you're configured in your testnet. And I want to query these params and it just figures out everything for you. What does that map to on the RPC? What does that look like? So from a user perspective, it's just magical. If I just want to interact with that chain that I created, and we allow that to happen and then it just works. And that's the idea behind it.
00:14:02.686 - 00:14:49.918, Speaker A: If you have multiple versions of the same chain previously, you would need multiple binaries. With this, you don't need that because we're doing it through Docker. So it'll just automatically download those docker images to you, you interact with it and it works well, what about relayers? Like I mentioned, we have relayer support through it too. So anyone would by default be able to interact with the relayer, set up new paths, set up new connections on this testnet, and they don't have to run any relayer infrastructure. We do it all through Docker for them on that host machine through this API address. There's also an API key. I've not showed any instances of that here, but if you had a more restrictive testnet because you want to be the admin of it, as you typically would, you would just add an API key here whenever you launch that testnet, and then only you would be able to interact with it, kind of like a password based system.
00:14:49.918 - 00:15:15.180, Speaker A: So we allow for the relayer to be set up and you don't have to run a relayer, we just do it for you. So to recap, we opt in for a proof of state consensus here with multiple features, including cosmosm, smart contracts, token factory, and packet forward. We then got our unit test automatically set up. We didn't have to write anything. The helpers, everything was there. It was running CI for us on GitHub. Our end to end integration tests were set up for us.
00:15:15.180 - 00:15:54.242, Speaker A: So we had all of that done through the generation of the network. We created a new module called the chain name service. We wrote a little bit of logic there whenever it was our time. We then set up a local and public testnet, and then we integrated it with our GitHub organization, had everything run, and all we had to do was type in three words and use UI driven choices. So everything was done for us and we had all of the parts that take the most amount of time for us developers building up new applications just automatically done. And I think that that's extremely important. As we're scaling to hundreds or thousands of blockchains, you need to make it easy to actually scale up to hundreds or thousands of blockchains.
00:15:54.242 - 00:16:16.340, Speaker A: So what are we looking for in the future? We're working on a Cosmos EVM solution at the moment. This is kind of like SAis EVM solution, but it's on the latest. We'll also have support for Coin type 60. That way you have direct support between Ethereum zero x hex addresses and standard Cosmo spec 32s. You'll be able to convert between those directly. So we're working on that. Cosmosm 2.0
00:16:16.340 - 00:16:34.556, Speaker A: support is almost done. The limiting factor at the moment is some technicals with the token factory how we test that at the moment. So that is almost done. We'll have that full support in any new chain. You'll be able to say, I want Cosmwasm 2.0, and maybe we provide that by default, or require you to go select that you wanted 1.0 features.
00:16:34.556 - 00:17:07.568, Speaker A: So we'll have 2.0 soon. We'll have support for vote extensions soon. As well. As you generate your module, you'll just say, I also want to have vote extensions, and we'll provide that for you and connect that up within your application, including smartly placing it in other areas compared to where other vote extensions may be so having a more builder like pattern with that for testing. We'll also have selecting other frameworks that are based on cosmosm. So dao dao Abstract, SDK, Polytone and mesh security where you're able to just select I want this.
00:17:07.568 - 00:17:38.092, Speaker A: I'm using cosmosm. I want Dao Dao in any testnet that I set up to just work out of the box with some sane defaults and allow the user to then override that if they have specific configurations that they need for. And all we'll have is a single line in the testing frameworks that just say interchange test setupdao dao. And so it's just going to set it up for you. There'll be a config in there, you can override it, but we want to make it super easy to set up these more complex frameworks as well. We'll have an Akash deployment soon as well. So we have the uploading it to Hetzner.
00:17:38.092 - 00:18:14.474, Speaker A: What about uploading it to Akash? So we'll have a generation by default with there. And then finally the last thing we're working on is a template frontend where you'll have support for Kepler Leap and ledger out of the box. So many teams don't have support for Ledger. It's actually a pain to just add a single word because no one knows where to find that. And so we're going to add that support in there that way that everyone can create their front ends and just have support natively day one with a basic staking cosmosm governance and token factory UI expenditure. From there, we'll have no css or very little css, and it's up to you to build on that template for your application. So thank you.
00:18:14.474 - 00:18:37.590, Speaker A: This has been great. If you're interested in using spawn or you just want to look more into it, check out role chain's spawn. We're also looking for other partners. If you have a product or infrastructure that you think would fit great into this, whether it's directly cosmos or not, we would love to talk with you. We are very excited about it. We want to give the power to developers rather than trying to be opinionistic in what we think is right for them. So thank you.
00:18:37.590 - 00:19:15.870, Speaker A: Yeah, can I have this? Six months ago we had three months. Yeah, yeah. We're working on more products on top of this to help with, like the long term maintenance. I'm just saying, I went through all this pain. Yes, yes. We've gone through a lot of pain, and so we're working not only on the generation, but also what does that future maintenance look like for you guys? When you run into, say, SDK upgrades, we're going to have a fully automated tool that we'll be working with teams on for maintenance, et cetera. So we're helping both starting and continuing on as well.
00:19:20.170 - 00:19:40.622, Speaker B: This might be coming from a noob, but can you talk about what the tests are actually testing? Either only testing the boilerplate that you generated, or are they testing actual stuff that the users will change in the code? So that's some logic somewhere. And this test are testing that logic that I will add later.
00:19:40.766 - 00:20:10.662, Speaker A: So by default, we're just testing similar standard interactions. So with CosmwASm, we execute on a contract query against it, make sure that works. We execute sub messages to make sure certain things are not breaking on your side where I've had that issue in other protocols. So we're making sure that the application is hooked up correctly, that you've not overridden something in your application that would be more of a power user move, but could break. Then it's up to the user to decide. I've written custom logic on top of this. Let me go test those other applications.
00:20:10.662 - 00:20:26.630, Speaker A: We're looking into what that would look like, but something that's a little bit more specific to your app and you're willing to write tests for that. You don't want to have to write up the entire test suite for, say, IBC or Cosmwasm. You just want something there that's a basic reference that you can build on top of, and so that's the direction that we've gone with that.
