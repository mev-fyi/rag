00:00:00.360 - 00:00:42.640, Speaker A: Hi, everyone. Thank you for coming to my talk. So, yeah, as introduced, I'm going to talk about the v two of token transfer for IVC. But first, who am I? I'm Susanna. So I am the product lead for the IVC team at the Interchain foundation. I've been working in the space for three years, and before I got into working on IVC, I was actually kind of in academia doing a PhD on bio printing. I had a startup during that period, and I generally worked for a few years as a manufacturing engineer in the food and aerospace industry.
00:00:42.640 - 00:01:30.332, Speaker A: So a bit of a weird background, but yeah, I'm here today and we're going to cover three things in this talk. So we're going to talk about why do we need a v two of token transfer, how is it actually going to work, and then when can you start using it, and what's next for IBC and our team? Okay, it's gone a little bit off there, but I'm going to start with a question. What is the proportion of IBC transactions that are token transfer? Anyone have a guess? 70. We've got 70. Any higher? 90. Anyone higher? Feels like an auction. 95 higher than 95.
00:01:30.332 - 00:02:30.390, Speaker A: Final bid. Okay, so actually it's 99% of 16 chains that we analyzed. There's something going a little bit weird with the slides, so I'll just do that. So, yeah, across some of the larger chains in the ecosystem, 99% of the IBC transactions are using token transfer. So clearly it's really the predominant application that is used with IBC. If we go back in time a bit, this is like three years ago, IBC really took off when osmosis launched and people were moving atom from the cosmos hub to osmosis, maybe they were using, they were sending Osmo from osmosis to the hub. But I think predominantly it's going atom to osmosis to do trades and whatnot.
00:02:30.390 - 00:03:09.540, Speaker A: And three years ago, maybe some of you were there using IBC. You're probably using Kepler, and you're probably using this advanced IBC function. Frankly, it was really hard and challenging to make an IVc transfer. You had to go quite deep into the wallet UI. You had to put in loads of configuration data. You had to pick specific channels that you wanted to move the tokens over. And with IBC, the channel determines the fungibility of your token.
00:03:09.540 - 00:04:05.680, Speaker A: So if you pick the wrong channel and then you send your token on the wrong channel, then at the destination you can't actually use any of the applications you want to use. And as you can see here, this is a little screenshot of mint scan. And between the cosmos hub and osmosis, there are literally hundreds of channels. By social consensus, channel 141 is the one that you want to be using. But it's pretty much like a Ux nightmare back then of like, how do I actually just move atom from us, from the hub to osmosis? And that was like three years ago, and now we have a lot more chains that people want to move their tokens to in between. So just for example, stride. Let's say I move my atom from the hub to osmosis, but then I want to move it to stride.
00:04:05.680 - 00:05:08.312, Speaker A: So intuitively you might think, okay, I'm just going to send that atom from the hub from osmosis to stride. But the problem is, as we just mentioned earlier, the channel determines the fungibility of the token at the destination. So if I naively just sent my atom from osmosis to stride, it would just be useless. So actually what you need to do is send it back to the cosmos hub and then send it on to stride. Because, yes, the atom sent directly from osmosis to stride is not fungible with the atom sent from the cosmos hub to stride. Thankfully, we have come a long way since those times three years ago where we're manually selecting which channels we want to use to to transfer our tokens. And today everything is really just abstracted away for you.
00:05:08.312 - 00:05:38.674, Speaker A: So this is IBC. Fun, I think. Now it's called skip go with the recent rebrand, but essentially it's just like a uniswap like interface. You don't have to have to think about all this channel level detail. You just pick the chains you want to move between, pick the tokens and. Yeah, it's as easy as one click. And we do see more advanced use cases with token transfer today.
00:05:38.674 - 00:06:43.630, Speaker A: So, for example, in this case, you're moving TIa from Celestia to USDC on Neutron. And for you as a user, it's just one click, but under the hood, you're using IBC in quite a nuanced and complicated way. So you're transferring TIa from Celestia to osmosis. There's a contract on osmosis that will swap your TIA for USDC, then that USDC will be sent to noble, and then it will be sent from Noble to Neutron. So all of this is happening under the hood. And actually, now we see that 42% of token transfers are using a token transfer, and they're sending some additional data with this. This is specifically the memo field for those of you that know how we do this, but it's really popular and it's really showing that we've moved a long way from just sending tokens.
00:06:43.630 - 00:07:15.270, Speaker A: It's now like we actually want to send tokens and do stuff with those tokens. And so. Okay, great, we can actually already do that already. But the problem is by not having this as more of a default feature, things get pretty messy pretty quickly. So I don't know if any of you know of IOB scan. It's an IBC explorer. And basically this is looking at the USDC token that originates from Axelar.
00:07:15.270 - 00:07:57.434, Speaker A: And I've highlighted IBC hops. This details the path that this token has traveled through. And there's actually eight pages of hundreds of entries here. And you can see that some people have really struggled to move their USDC from XLR to wherever they want to go. And they've probably got really confused and frustrated, but they've ended up sending it not back through the origin chain to then send onto their destination. And this example here, it's gone through seven hops. Someone wanted to go to osmosis, but in the meantime they've transferred through.
00:07:57.434 - 00:08:56.330, Speaker A: They've gone from channel zero to channel three, four, three on another chain, channel one, another chain, channel one, another chain, channel two, seven, seven on another chain, channel 81 and so on. This USDC on osmosis is useless. So by not having this functionality as more of a default feature, it still creates bad ux for users. So yeah, why do we need a v two? IBC has really developed a lot since it's been launched, and the usage and need how people want to use IBC and token transfer has developed as well. We're increasingly seeing applications that abstract a lot of complexity away from the users. They allow actions to be automated. Chain abstraction is this buzzword going round, but we're seeing it in practice.
00:08:56.330 - 00:09:47.480, Speaker A: This just means that the default needs for token transfer are evolving now. It's not just tokens, there's a lot more that people want to do with the tokens as well. So that brings me on to how does token transfer v two work? So there's two main feature additions that I'm going to talk about. The first one is being able to send multiple different types of tokens in a single transfer. And the second one is linked to this whole problem space that I was just describing, which enables atomic path unwinding and forwarding. So to understand how it works, we'll just go through some of the basics of token transfer. Sorry, one of my little men there is covering up a bit of text.
00:09:47.480 - 00:10:56.626, Speaker A: But basically, let's go back to the cosmos hub and osmosis. If I want to move atom from the hub to osmosis, I would lock the atom on osmosis, and then I would mint a voucher which represents that atom on. Sorry, I'd lock the atom on the hub and I'd mint a representation on osmosis. And unfortunately, this is like covering up here. But basically this voucher, the token denomination, is taking into account the application, the channel it came from, and then the denomination of that token. So when you send a token transfer packet, you have this denom, you have the amount, you have who sent the tokens, who's going to receive the tokens, and then this memo field, which we touched on briefly, that allows a lot of more advanced token transfer use cases. And with the v two of the multi token sends at the top here, you can see v one is showing how we, how we present a DNom.
00:10:56.626 - 00:12:00.582, Speaker A: So we have transfer channel 141 UATM. So it's the application, the channel id and the token denom and the amount. And this is all kind of together in the token dnom field with v two, because now we're going to allow you to send not only atom, but you could send, say you're on stride, you might want to send atom and stri, sorry, not atom like staked atom and stride, or staked atom, staked here, just to another destination. So now we need an array of multiple tokens, and we've also improved the readability usability of how we display these denominations. So we have the base denomination, which for atom is uatomous separated from the trace. So we separate out the application and the channel id from having it all in one massive line, and then we nest the amount with the specific token that we care about. And then you can have an array of multiple tokens.
00:12:00.582 - 00:12:58.930, Speaker A: So I've just demonstrated with a different token called foo. And then this enables you to do things like if you're on stride, send stake atom and stride to osmosis in one transfer. So the second feature, atomic unwinding and forwarding. As we said, the path that a token travels on is really important for determining its fungibility on the final destination. So if we want to send that atom from osmosis to stride I, we have to send it back via Cosmos hub. And to do this, we introduce a field in the memo field called forwarding. And so here we want to transfer the tokens from osmosis to Cosmos hub, that's just a normal transfer.
00:12:58.930 - 00:13:47.538, Speaker A: But then to go from the cosmos hub to stride, we need to add in an additional hop. Um, so because already in the token denomination, we actually know how to get back to the cosmos hub, we know how to go back there automatically. But then to go from the hub to stride, um, we do need, um, some additional input, actually. This is like, I realized my slide's a little bit wrong here. Um, but basically you just specify the path that you want your token to travel through, um, in the initial transfer, and then it will send back atomically. Um, and so say you want to. Then also, you know, we saw this example of going from celestia all the way to Neutron.
00:13:47.538 - 00:15:06.700, Speaker A: So to do that in one click, you'd have to specify the path from Celestia all the way to. To arriving at Neutron. And so basically you can have multiple hops, and you just specify the path that you want the tokens to travel down in these multiple hops. And what happens is once you make the first transfer and you've completed one hop, you essentially delete that hop from the packet data, and then you'll just have hop one is removed and hop two becomes hop one, and then hop one will be the next path. And how this is done atomically is that with IBC we have acknowledgements, which basically tells you, okay, the packet was received, and then you send an acknowledgement back to the sending chain to say this packet was received on the destination and to have this whole workflow being atomic. So, I mean that it will either completely succeed or completely fail. You basically wait until you have the packet arriving at the final destination before you then asynchronously send the acknowledgement all the way back to the source.
00:15:06.700 - 00:16:06.380, Speaker A: And so what you do is you commit the packet in a private store and you wait for the acknowledgement from the step ahead to come back to you before it then becomes part of the provable store. And this means that you will only propagate the acknowledgement all the way back to the source if the final destination is actually reached. And if, for whatever reason, something goes wrong between stride and the final destination, you would then revert all of the transfer logic going back. So this means that you don't end up with your tokens just somewhere completely random and a user has no idea what's going on. So, yeah, that's like kind of the high level. The main two features of token transfer, V two. And this will be released in IBC Go V nine, which will be compatible with the SDK V 50 line.
00:16:06.380 - 00:17:05.610, Speaker A: We'll be having an external audit on this feature. So it's actually like more or less ready. But obviously it's token transfer, so you know, it's somewhat sense. So we want to have additional assurances that this is going to be functioning as it should and not creating any security risks. And to use this V two of transfer, you can either use channel upgradeability to upgrade your existing channels, or we will be releasing a point release in Q four and this will encapsulate the application version within the packet data. So now, rather than needing to coordinate across chains to say, renegotiate the application that a channel is using, instead, you could send a V two packet. If the destination chain has the V two application, it will succeed, and if it doesn't, it will just fail.
00:17:05.610 - 00:17:55.712, Speaker A: But we think this will be a simplified rollout. You don't need to coordinate with your counterparties, you can just try and use the upgraded version. If it doesn't work, then you just fall back and use the v one. So yeah, that's the overview of token transfer V two. I put this QR code here, which is a broadcast only Telegram channel which gives updates on releases across IBC, go relayers, things like that. So if you want to keep up to date through telegram, feel free to join the group there. And yeah, there's our website and feel free to reach out on Twitter or email or you can talk to me here as well.
00:17:55.712 - 00:17:57.000, Speaker A: But yeah, thank you.
