00:00:00.280 - 00:00:26.690, Speaker A: The stage is yours. Hello, everyone. Hope you're having a great week. It's coming to an end. So, I'm Antonio, and I'm about to talk to you about a Cosmos SDK module that I've been working on for the past few weeks. But first, I wanted to start this presentation with a nostalgic moment. I don't know if anyone in this room recognizes this or know what this was.
00:00:26.690 - 00:01:21.396, Speaker A: Okay. This was a project that I worked on at tendermint that died, unfortunately. But if I quote from the official Cosmos blog, it was supposed to be the one stop portal for all crypto apps, no matter what blockchains they run on. So basically, I was in the backend team for this, and we were planning to do this high level UI for users that are not super technical. And they wanted to get started into Cosmos, but they didn't want to deal with all the IBC mass of transferring tokens between chains or knowing where the tokens were and trading and swapping and all this stuff. So this is how I got first into the blockchain world. And I would say that I'm continuing this, my career in the blockchain space, focusing on the user experience.
00:01:21.396 - 00:01:57.480, Speaker A: So what we are doing today with worden is going into the same direction that I was doing at tendermint on Emory's, where we want to provide user experiences that are easy to use, even for non technical people. Just to give you a context now to talk about what we're building, I like to make this analogy with if, this and that. I don't know if you ever use it. It was pretty popular. Then they introduced some payment systems, I guess. And then from free to use, it became a more pay to use. And I think they lost some traction.
00:01:57.480 - 00:02:25.592, Speaker A: But basically it was the duct tape for the digital world. They connected apps that were not supposed to be working together, like Instagram or Dropbox. Users could build this automation with just a few clicks, integrating apps that they use every day. But we're not supposed to work together. Right. And we're kind of doing this for the blockchain world. For blockchains, our rules might look something like this.
00:02:25.592 - 00:02:43.718, Speaker A: I like to make these two examples. One of them is when two of members of my team approves this action. Do it. Or when ethereum prices is above $3,000, do something. And. Okay, so the first one might look like multisig. It's similar.
00:02:43.718 - 00:03:22.900, Speaker A: The second one is maybe for automated trading. Right. We're building a language where user can express these kind of conditions. And this language is supposed to be very small, very readable, even for non technical people. And by being super small it's possible to build user interfaces. And some, you know, this works for the engine, but for the user we can build more friendly interfaces. Now I want to get a bit more deep into how the language works.
00:03:22.900 - 00:03:59.214, Speaker A: We call this internally the shield language. I don't know if you ever built an interpreter for a language. It's an interpreter for languages like Python or JavaScript or whatever. It's mainly composed by three pieces, a tokenizer, a parser, and an evaluator. And I'm going to do a little walkthrough about how an interpreter works. I'm not going into too many technical details, don't bore you. The tokenizer first step in our pipeline takes the user input as a string, and then it splits the string into pieces that are called token.
00:03:59.214 - 00:05:06.430, Speaker A: Each token has a unique type associated with it. In the example above, I split the string into the identifier any then we have the last parenthesis, the number comma brackets, other identifiers, and other brackets. It's important to notice that the tokenizer knows what the two means, so it knows that two is a number. But while the one two three inside the word and address are not, numbers are part of the same identifier. That's the role of the tokenizer, the output of the tokenizer, the list of tokens is the input for our parser, and the parser builds what is called an abstract syntax tree, or ast. And it's called abstract syntax because we lose all the syntax of our language, we lose all the commas and the parentheses to build effectively a tree. And in this particular case we are invoking a function called any, and the arguments of the function are the number two and an array of items that are two identifiers, effectively two wording addresses.
00:05:06.430 - 00:05:36.334, Speaker A: And parser is a fun experiment. If you never built a parser yourself, I think you should. It's a fun experiment, fun exercise. It's a well known problem. The parser that we built for our shield language is a recursive descent parser. Not going into many details here, but we have all open source in our GitHub. And finally, the last step for our interpreter is the actual runtime.
00:05:36.334 - 00:06:27.260, Speaker A: So the evaluator is taking the ast as the input just to output a final result. In the shield language we have this concept of expressions. Everything is an expression, and everything will eventually result in a single value using our act module. What you will have is that these expressions are eventually resolving into a boolean, true or false, to say whether the condition is satisfied or not. But what the evaluator actually needs to do is to apply the function. So it needs to know what the any function does, what the arguments means, and it needs to do that, firstly by resolving these identifiers that were present in the ast. So we have, for example, the AnI identifier that was a built in.
00:06:27.260 - 00:07:22.010, Speaker A: We have a few built in functions. In our language, any is a function that takes a number, that is a threshold and an array of boolean values, and it just results into true if there were enough true values in the array, or false if not. But importantly, the other two identifiers were word and addresses, and they need to be resolved eventually by what is called an environment. Now, programming languages have different algorithms or implementations for resolving variables. You can have variable shadowing or other complex stuff, but in our language we only have a global scope, which is a simple key value storage. So these keys, the wording addresses, eventually need to be mapped into boolean values by the environment. And who's providing this environment when evaluating the expression is our act module inside the Cosmos SDK.
00:07:22.010 - 00:08:11.104, Speaker A: So to give you an overview of what the act module exposes to the user, I wanted to go through all the transaction that the user can actually make to our chain. And the first one is this message. New rule, new rule is to store a new rule on chain. We can see that the user here in this message defines or actually sends the definition as a string, which was the first input that we saw that was given to the tokenizer. But in the application database, we're not storing the string itself, we are actually storing the ASD. So during the rule creation, we do the first two steps that I showed you before, the tokenizer and the parsing to build the ASD. And the ASD is what we actually store on chain.
00:08:11.104 - 00:09:02.942, Speaker A: This is nice, has nice features because we, for example, remove all the extra white spaces or parentheses. And it's actually a more compact way of storing the user expression on chain. Okay, we talked a lot about the rules and the language so that the user can use to express their intents, but we didn't talk about what you can do with these rules. So we talked about the if this we didn't talk about then that part, and it's coming out. We call these actions a user can actually send a message, new action on our chain, wrapping any other protobuf message. So we expect the user to wrap any other Cosmos SDK message that can be executed by our chain. This is similar to how the governance the.
00:09:02.942 - 00:09:54.030, Speaker A: Gov module works in Cosmos SDK. So you can actually do anything that can be done on our chain, wrapping it into an action that gets executed when the rule is evaluated. This is the message that the user sends to our chain. And I want to go through a real, I wouldn't say a real world example, but as an example, because I think it's if you, I don't know if you noticed, but the user is not sending the rule that it wants to be applied for this message, it's just sending the action, not if this part. And I think it's easier explaining it with an example. Let's imagine we have a satellite module in our chain that can be used to launch satellites into the orbit and the user want to launch a satellite of type Soyuz at some point. Let's see.
00:09:54.030 - 00:10:39.962, Speaker A: First of all, we have the act module invoking some hooks for the other modules. It knows that the message launch satellite is a message coming or defined from the satellite module. So it invokes a hook that the satellite module can use to generate a rule. It doesn't matter if the rule is hard coded in the satellite module. It doesn't matter if the satellite modules uses the rules to store in the database for the user or if it access parameters or other dynamic variable at that time. Eventually the satellite module returns a rule that must be applied. I show you here the human readable version, but it actually will return an ASD technically.
00:10:39.962 - 00:11:28.442, Speaker A: And we can see for example a rule like if the cost of producing this particular satellite is less than 100, just go ahead. Or require at least two approvals from these three members we haven't finished yet. AcT will invoke other modules hooks to give models a chance to resolve identifiers into fixed values. Now this is like a macro expansion. This happens only once during the action creation. And for example here we had a satellite cost variable that gets replaced into the fixed number 999. Because we can imagine that a Soyuz satellite has a fixed producing cost, it won't change over time.
00:11:28.442 - 00:11:53.630, Speaker A: That's it. And so this can be seen as an optimization to this process. It only happens once the react. Sorry, it only happens only once during the action creation. And we are actually using into worden to do some smart contract invocation that are pretty expensive. So we only do once. What gets stored on chain is this action object.
00:11:53.630 - 00:12:38.014, Speaker A: Now from the bottom up we see the rule that was generating during the previous tab. After the pre processing, we see we have a message field containing the message launch satellite that we want to be eventually executed. We have a field that will contain the result of the execution. We have a status and we have a list of approvers. This concept of approvers basically means that anyone on our chain can approve any other action. I like to think of it like GitHub pull request approvals so I can put my approvals into a pull request and the repo owner has set up some rules. And maybe then after approving I can merge, but not before.
00:12:38.014 - 00:13:27.360, Speaker A: Right to talk a little bit about the action lifecycle. The status of an action can be it gets created in a pending state, it can be revoked by its owner, or can eventually timed out if the user specified an optional maximum block height to consider this action ready. But what I'm going to focus and talk about is when the action goes from pending to complete and the message gets actually executed. So this happens on certain point in time called triggers. And right now in the current implementation, it only happens when a new user approves an action. But in the future we want to have more triggers. We want, for example, to have a cron job like triggers when the user can specify check this action every ten blocks or 100 blocks.
00:13:27.360 - 00:14:34.150, Speaker A: Ok? If you remember, we talked a little bit about resolving the identifiers during runtime, and I want to talk about the action going from pending to the resolve state. So we need to evaluate the rule. Like for example, as I said, every ten blocks, the xact module will provide an environment to the runtime that resolves word and addresses into booleans, true or false, depending whether they are in the approvers list or not. In the future version, we want to expand this environment and to let other modules resolve their own variables into their values independently. And this will enable some cool user cases, like having an oracle providing price feeds that changes over time. So reevaluating the rule makes sense because the price changes, like we saw in the very first slide I talked about when Ethereum prices go above $3,000. So we need to wait and recheck this action every once in a while to see if it can execute it or nothing.
00:14:34.150 - 00:15:28.442, Speaker A: Now, to put all of these into a bit of context, I wanted to talk about Warden really, really little. We want to build this infrastructure for building all these automations. So we have this agnostic module that can be used by other cosmos SDK chain. Really. But what we want to do with worden is to provide inputs and outputs that are useful for this automation. So we're integrating with Oracles, we're supporting interchange queries, also are supporting smart contracts with cosmological or with Evmos that are considered by my point of view, inputs and on the output side. So the actions that you can do with this are transactions on other ecosystem, like on Ethereum or Solana, or invoke even other smart contracts.
00:15:28.442 - 00:15:56.730, Speaker A: They can be living on Warden, but they can also be living on other chains. Thanks to our integration, for example, with Axelr, we can do general message passing to the Ethereum ecosystem. I think this was it. This is the end of the presentation. If you have any question, I'll take it. If you want to learn more about Wharton, I think I'll be around. Thanks.
00:15:56.730 - 00:16:49.740, Speaker A: Okay, so are the actions executed in the same blocker, the trigger installation? Yes. Right now, when the user approves, sends a transaction to our chain to approve the action, and the action execution is done inside that transaction. We want to decouple this because who pays for the fees for the gas and let's say the commission resulting from executing the action. It shouldn't be really the approver of the action. Maybe it should be the creator of the action, or maybe it should be someone else. So we thought of that. We haven't come to a conclusion yet, but we are thinking of building something like this to let the user, to give the user freedom to choose a who will pay.
00:16:49.740 - 00:17:03.320, Speaker A: And this is also important when just evaluating an action and not executing it. So if you need to check every ten blocks is different than checking every block, for example, it should cost you more. And so we're building something like this.
