00:00:00.760 - 00:00:26.098, Speaker A: Hi everyone. Thanks for sticking around for the last day of the week. I hope you enjoyed the talk. I'm Dima. I'm CTO of Fortify, and I will tell you about a recent product feature that we've launched that allows our institutional customers to react to on chain events in an automated and instant way. Just to begin, give a little bit of background. So our company, Fortify, we're an institutional MPC wallet provider, the first one that was actually purpose built for DeFi.
00:00:26.098 - 00:01:47.608, Speaker A: What this means is we provide our customers with an MPC based key management solution so they can securely manage their private keys, and we combine it with our multi chain browser extension that allows them to interact in DeFi across more than four dozen chains that we support, including EVM, Solana, Sui, and perhaps very relevant to this conference. We're the first institutional wallet to support Cosmos. We support more than ten Cosmos app chains with our browser extension that's fully compatible with Kepler and hence with all Dapps in the ecosystem. And kind of the thing that ties them together is our platform allows institutions to define their own policy controls and transaction rules to really manage risk and control the transactions and permissions within the organization. So some of our customers that we're working with include crypto funds, trading firms, market makers, treasuries of foundations, as well as retail facing companies such as exchanges. And collectively, our customers transact in over $4 billion of transaction volume every month. And you know, one of the things that's quite common to a lot of those institutions who participate in DeFi, which is actually also a problem that individuals face, is that what keeps them up at night, there are lots of different on chain events that require their immediate attention and often instant reaction.
00:01:47.608 - 00:02:52.082, Speaker A: So this could be something like a smart contract getting exploited, in which case the user would usually want to withdraw their funds immediately or maybe revoke any token allowances to the contract. It could be a position whose health factor dropped, and then they need to act on it and perhaps deposit some extra collateral, or it could be even something positive, maybe a trade opportunity appears to, and the user wants to capitalize on that. And there's quite a lot of monitoring solutions out there. There's lots of companies who monitor the chain and provide with instant alerts and instant information about events happening on chain. But what we actually been wanting to build is the first solution that kind of closes the loop and allows those institutional users to act on that on chain event and transact automatically. So to give a little bit of more context about some of the design goals that we try to reach with our solution. The first one is that we were really aiming at no code, low code solutions.
00:02:52.082 - 00:03:51.492, Speaker A: So some of our more sophisticated customers, like automated trading firms, those guys have their own strategies, have their own trading bots, they really don't need our help in that kind of stuff. But we really have a lot of customers who might not have the technical expertise to set up automated trading strategies, and we wanted to help them to access those type of solutions. The second thing, we really wanted to provide a scalable solution across different chains and different protocols. So we did not want an EVM only solution or something that only works on cosmos, but rather have something pretty broad. A key requirement is that the solution needs to kind of maintain the self custody and all the security controls that our wallet provides. Your normal operation and the solution has to be also seamless with ongoing operations, meaning the users need to be able to use those wallets on which those triggers are set, as opposed to locking them in some other system. And finally, we want to really support the wide range of monitoring solutions out there.
00:03:51.492 - 00:04:41.262, Speaker A: There are several different companies that have different pros and cons across different use cases, and we want to be pretty open in the type of monitors that that customers can integrate. So in this talk, I'm going to first tell you a little bit more about the mechanics of an institutional wallet like ours, because this is going to be key to understand our solution and some of the challenges that we face by building it and how we solve them. And at the end, I'm also show you a demo of the thing that we've built. So, as I kind of mentioned, an MPC wallet has three main pillars. The first one is connectivity, giving the institutional users access to, to the wide range of chains and defi apps. The second is key management, and the third one is the transaction policy that provides those internal controls. So I'm going to go a little bit in depth about each of them.
00:04:41.262 - 00:05:26.362, Speaker A: So on the connectivity side, you can think about our goal being is providing ubiquitous connectivity to our customers across the different kind of chains. And here's what I would say. We basically want to be like retail grade here. So similarly, how users with retail wallets can access all those chains on those apps, really don't want to be a position where our wallet limits are limits our users, and they have to somehow need to ask us to add support for a particular protocol and so on. And so what we've done, we've built our own browser extension that combines kind of plugs in into our key management solution, while being completely compatible with all the standard wallets on each of the chains. Meaning if you're using EVM, then our wallet would work with any Dapp that metamask works. And if you're working on Cosmos, change that.
00:05:26.362 - 00:06:07.812, Speaker A: Any dapper that works with Kepler would work with our wallet as well. And we build in some extra data features into our extensions, such as transaction simulation, identifying different protocols, and so on. So just to kind of give you a taste of that, as you can see, this is our browser extension. You can go and adapt. That works with EVM and with Cosmos, and you connect using the same extension to all the different types of chains and protocol, which really unifies the operation of an institution across the different types of chains they interact with. And then when you want to do a transaction, in this case on Cosmos, we give you a transaction simulation, you can actually see all the tokens that are involved. You can see a preview of the transaction policy and how would it evaluate the transaction.
00:06:07.812 - 00:07:09.944, Speaker A: And this is what many of our users do to interact with DeFi. So on. Our extension, while providing the connectivity element, clearly doesn't handle any of the private keys, we want an institutional grade solution for that. So for that we use multiparty computation, or threshold signature, meaning that the private key for each of our customer's wallet is never held at any single device or held by any individual party, instead of secret shared between the users and hardware enclaves that we're running on our servers. Some of the benefits of that is, of course, that the organization doesn't need to trust any individual user who can leave, who can be malicious with the private keys. And it's also the service, completely non custodial, meaning we never control all the key material for the wallet, and the customer maintains that level of control and self custody. And then finally, while the threshold signature mechanism allows you some basic abilities to control who can sign what and enforce a quorum, we really want to provide a more flexible solution on top of that.
00:07:09.944 - 00:08:10.278, Speaker A: So the transaction policy is an extra mechanism that we have that allows those institutions to really set fine grained rules on the different transactions they do. So, for instance, they can set rules based on the wallet, on the user initiating the transaction, the protocol, and down to the method level of the contract. And for each such transaction, they can essentially say who needs to approve it. So maybe a high risk transaction will require multiple steps of hierarchy in the organization to approve, while low risk transactions, the trader can just quickly do on their own. This is kind of an example. We have this transaction policy builder when the user is completely self serve, can set those rules and define their internal policies. So kind of when we wanted to build this solution for automated response transaction, the basic idea that we had is we want to build something that allows some automated execution of transactions that are prerecorded ahead of time and are then triggered based on some external monitoring conditions.
00:08:10.278 - 00:08:38.188, Speaker A: So the general approach that we've taken is that the user first needs to create that response transaction ahead of time. So ahead of, let's say some emergency condition. Well ahead. And then this transaction kind of parks and waits for a trigger. Then the user would use one of those third party monitoring solutions. And the first one who we've partnered with are hexagate. And this allows them to define different kind of monitors for different types of on chain events.
00:08:38.188 - 00:09:46.960, Speaker A: And then when this external monitoring solution identifies that critical event, it essentially can trigger VR API, our platform, which would then set off the signing process of the transaction and the broadcast of the transaction to the chain. So now maybe let's just see some of the challenges kind of turning this general blueprint into reality. So the first question is, how do you actually pre create the response transaction? And here the solution, if we kind of go back to the principles that I laid out in the beginning, it has to be accessible to non technical users. We don't want our users to have to write trading bots that will actually use the SDK of individual protocols to craft those transactions. The solution has to be multi chain. So there's quite a few good solutions that rely on smart wallets, on EVM, or on some particular chain, whereas we don't want to be kind of tied to a particular smart wallet implementation. And finally, we want to be protocol agnostic, meaning we don't want to have like pre selected list of ten protocols for which we support on responses, because the reality is that our customers are pretty advanced, they're going to use a lot of different protocols, this long tail of protocols that we would never be able to keep up with.
00:09:46.960 - 00:10:37.024, Speaker A: So the approach we took is pretty simple. We've added the ability to prerecord transaction using our browser extension, thus making it accessible to traders who just use the UI. As you can see here, there's a checkbox that you can select when creating this transaction, which essentially tells our system this transaction should be saved for later, as opposed to being sent to the blockchain immediately. And so users would kind of go on the DAP and let's say they know that if some emergency conditions happen, they need to do some swab, they need to add collateral, they need to take some action. They will just kind of do that action ahead of time, but mark the transaction to be saved for later. And then, as I mentioned before, every transaction in the institutional setting needs to be possibly approved by multiple users in the organization. And what we wouldn't want to do is to wait for manual approvers at the time of emergency.
00:10:37.024 - 00:11:45.982, Speaker A: So if it's now in the middle of the night and I need to execute one of those transactions, it's probably not the best time to wait for all the people in the company that need to approve the transaction. On the other hand, it's definitely insecure to exempt those emergency transactions because then you're kind of creating a security hole in your system. So the solution is we basically run through the policy engine at recording time. So when the user records the transaction with XDEM, with the extension, at that point everybody in the organization who needs to approve it would get notified, would say, well, this is an emergency transaction I'm preparing. They would review it, review the transaction simulation, see what's it about, and approve it, if so, and then the transaction, as I said, parks after having been approved, after it already cleared the security policy. And then the last challenge that we needed to solve is how to reconcile the fact that we're a self custody solution, an NPC based solution that requires the user to actively participate in the signing process, again with the goal to being able to sign transaction really quickly. So while the regular transactions that human traders do on our application, they sign it with their mobile app.
00:11:45.982 - 00:12:34.408, Speaker A: And so there's a person in the loop. This obviously cannot be the case for the automated transaction. And for that we actually have a solution that is used for actually other types of programmatic trading scenario, which is we call the API signer, which is a self hosted service that we provide to our customers. They can run it on any cloud of their choice. It's really simple to run it. And that service holds the MPC share on behalf of the customer on their own infrastructure and can participate in this kind of headless signing without a person being in the loop. Now you may ask yourself how to make this secure, because now if a transaction can be signed without a person in the loop, what prevents, let's say, an attacker who compromised our service to being able to trick the user or the organization to sign any transaction, including a malicious one.
00:12:34.408 - 00:13:55.320, Speaker A: So for that we actually have a mechanism where all the transactions we enforce end to end authentication of the transactions from creation time to signing time, meaning this API signer will not sign this transaction unless it was created by an authorized device such as a browser extension that has the customer's credential in Ithoodae. And so I guess one kind of alternative solution that you might think about if you are designing this thing is why not just pre sign the transaction? So we did a lot of steps ahead of time, like pre creating and pre approving the transaction. Why don't we just pre sign the transaction and keep it in the state where it's ready to be sent to the blockchain? And this is an interesting approach, but it actually introduces a few difficulties and which is why we avoided it. So one complexity this approach would introduce is that now you have to commit to the nonce of the transaction ahead of time, and then you kind of run into the situation where your wallet is kind of locked. Because if you're going to do more transaction, the nonce in that pre signed transaction will already be stale. And now you could do more complicated stuff like maybe signing a bunch of transactions with different nonces, but this obviously makes it much less scalable and easy to use. Another thing is that our approach allows, by the fact that we signed a transaction just in time, just when it needs to be sent, allows us to dynamically adjust the gas fees right before signing.
00:13:55.320 - 00:14:54.306, Speaker A: And so if there are differences in gas fees between creation time and signing time, we'll make sure to use the correct gas setting when the transaction is signed and sent to the chain. So we kind of build all this solution. We've done this in partnership with Hexagate. We're a security company that specializes as detecting various kind of on chain events and setting up those monitors. Tulipa capital were the first customer that was kind of a design partner in developing this, and their use case was actually acting on some kind of on chain trading opportunity that they want to capitalize on very quickly once it happens. So let me show you kind of a general demo of how this thing looks like. 1 second so what we'll see here is that the user first goes to adapt, connects with a fortify browser extension, and prerecords the transaction.
00:14:54.306 - 00:15:51.238, Speaker A: So in this case, the user might do some kind of swap that they want to schedule to be done later based on some trigger the user connects with our extension, selects that checkbox that basically says that this is a response transaction, and this is when the transaction is created. At this point, the transaction undergoes the approval process, and any additional users that needs to approve it will get notified and have approved it. And then this transaction parks in the state where it's waiting for a signing trigger. So it's not signed yet, it's waiting for the trigger. The user goes in this case to the hexagate platform and defines a triggering condition, some kind of monitor that monitors some on chain event, the position exploit or whatever the user might want. And the user then points the monitor, links it to the transaction that they pre created on the fortify system. And this links the monitoring condition with the prerecorded transaction.
00:15:51.238 - 00:17:06.760, Speaker A: Then once that on chain event occurs and the hexagate monitor detects this condition, they call our API and trigger the beginning of the signing. Then, as I explained before, the API signer and our system run the MPC protocol, sign the transaction with the correct nonce, with the correct gas value and broadcast the transaction to the node. And then hopefully a few seconds later the transaction is completed and the user's intent is satisfied on chain. So this is the basic approach that we've developed. It turns out there are actually a few more challenges which we're working on solving right now to improve and make the solution more applicable, applicable to a wider range of scenarios and more robust. So some of the interesting challenges that we're still working on is one, a lot of the positions that user, that our users, that our users have actually are multilayered, meaning that when you want to do the response, the response would usually consist of a sequence of steps that needs to be done one after the other. And if you think about it, if I need to pre record all the steps ahead of time, it's a bit tricky to record the second step of the sequence of transactions before actually executing the first one.
00:17:06.760 - 00:17:42.324, Speaker A: And so for this we need a little bit more clever approach. It's something that we're working on these days. The second challenge is that transactions may expire. So some of these transactions often would have, or not that often, but sometimes would have the maximal block number encoded as a parameter which limits their time that they can be sent to the blockchain. And this requires some extra heuristics to detect and fix. And finally, there could be changes in the on chain conditions between the prerecording time and assigning time. You can imagine if I want to do a swap, maybe the slippage conditions change or something of that form.
00:17:42.324 - 00:18:39.460, Speaker A: And so this is another challenge that we, that we're working on again to make the solution applicable to a wider range of scenarios. So to summarize, we kind of seen here the new mechanism that we've built for automated response transaction that allows our customers in a completely chain agnostic way perform automated transactions without having to write any code on their own. And the use case for that, as I mentioned before, could be exploit mitigation, could be maintaining the health of their position, or even capitalizing on some trading opportunities. There's more info on our blog, so if you're interested, please check it out. And if you're interested in being a user for your company, or if you're a monitoring solution and you want to integrate with us so that users can use your monitoring and triggers, please come talk to me after the talk or reach out at any point in time. Thank you very much.
00:18:47.160 - 00:19:02.880, Speaker B: Thank you, Tima, that was great. I actually have a question for you. So with your automation, you could have a trigger from a different chain also triggering a transaction on another chain, right?
00:19:02.960 - 00:19:03.432, Speaker A: Yes.
00:19:03.536 - 00:19:04.592, Speaker B: That's super interesting.
00:19:04.696 - 00:19:05.032, Speaker A: Yes.
00:19:05.096 - 00:19:08.960, Speaker B: Awesome. And could I use it or is it only for institutions?
00:19:09.080 - 00:19:25.960, Speaker A: So we're focusing on institutions, but some of the institutions we work with are large companies, but it could be like a fund of two or three people, and we work with a bunch of those as well. I think if you're a company at any size, please come chat with us and I'm sure we can provide some value.
00:19:29.420 - 00:19:36.900, Speaker B: Is there anyone that wants to ask a question? And then otherwise, we'll do a last round of applause. Thank you. Dima.
