00:00:10.360 - 00:01:06.150, Speaker A: All right, thank you everyone. Yeah, the weekend is almost there, but before we have that, we're first going to talk about cross chain messaging with interchain accounts. My name is Thomas. As said, I am the devils of the IBC team at Interchain GmbH, and we are the team that is responsible for the reference implementation of IBC, which is the IBC go implementation. And I want to talk to you about interchange accounts today because we got some feedback from the ecosystem that there's still some confusion about interchain accounts and all of the terminology. So what we're trying to do today is to make that a little bit clearer and hopefully to kickstart a conversation, because we're obviously open to feedback from the ecosystem to see if there's anything else we can do to help to make things more clear. All right.
00:01:06.150 - 00:02:02.188, Speaker A: Actually, today at this event, I don't think I will have a very hard job telling you what IBC is and why it's useful. But still, I think it's always good to stop and think, okay, what are we doing and why are we doing it? IBC is the interchange universal general purpose interoperability protocol. And if you ask why you use IBC, I think you can make the distinction, why do we need interoperability at all? And I think it's pretty clear at this stage of the crypto industry, the blockchain industry, that there's not going to be one chain to rule them all. So we have different ecosystems. And obviously for developers, it's very useful if we can have interchange functionality and applications. Right? So why pick IBC over competitors? There's a whole bunch of reasons, but those three are quite important. So we have security and permissionlessness.
00:02:02.188 - 00:02:45.158, Speaker A: So basically, IBC is a protocol that works with lite client verification. So that means that we don't need to rely on intermediate trusted parties. For example, other bridges employ like multisigs, which is a lot less secure and also permissioned. But actually relevant for the talk today is the third one, which is that it supports generalized message passing. And let's go for. So first, a little bit of context before we dive into interchange accounts. Maybe one more thing about IBc that is interesting to note is that you can kind of split it up into two distinct layers.
00:02:45.158 - 00:03:51.064, Speaker A: So first we have the transportation layer, which is also sometimes called tau layer, which stands for transportation authentication and ordering. And basically that is what ensures that we can send over packets from one chain to another chain. And the actual data that we send over the transport layer is opaque to that, so it doesn't really care what data you send over. And this is the concern of the application layer. And most developers that will be working with IBC probably will be application developers. So they are concerned with the encoding, the decoding, and the interpretation and subsequent execution of logic based on what that packet data is. So for the context and the history, last year, in April, I think IBC was launched live, and what it had in the IBC Go implementation back then was exactly this transportation layer, so packets could be sent and one single application which was ICS 20, the fungible token transfer.
00:03:51.064 - 00:04:22.088, Speaker A: Now, fungible token transfer is very important for the IBC protocol, but as we said, it's not just a bridge that does token transfers, it is actually more than that. It supports generalized message passing. And this is why we'll talk later about interchain accounts. But so the first application was ICS 20, the fungible token transfer. And let's take a quick look at this. So here we have two chains, a and b. A is the source chain.
00:04:22.088 - 00:05:23.092, Speaker A: What happens is on the left we see that some tokens are being escrowed on the source chain. Then in the middle a packet is being sent. This is done by the relayer, who are responsible for ferrying these packets from the source chain to the destination chain. This is what happens in the middle. And then in the right corner, bottom corner, we see that there was a success. So there was a proof sent along with the packet by the relayer to basically allow the protocol on chain b, the destination chain, to check whether or nothing the commitment to send the packet and escrowing of the funds on chain a was in fact committed. Now this slide I added because I wanted to make clear that token transfers is a very intuitive way to understand how IBC works.
00:05:23.092 - 00:06:10.216, Speaker A: But actually, as I mentioned before, but it's good to emphasize it. The packet data is customizable, so you can send any type of packet data that the application developer chooses. So a very similar thing. I'm not going to go through all of the steps, but yeah, we see the source chain, the destination chain, the relayers, which are the important actors. And then maybe one more thing to notice that is important is that it's not always the case that we have a happy case where the packet is actually received. It could also be that for any reason, the packet is not reaching its destination. And because we don't want packets to be stuck in perpetuity, we actually have a timeout functionality.
00:06:10.216 - 00:07:02.900, Speaker A: And this means that if the timeout period has passed, the relay layer can actually check on the destination chain for a proof of non receipt, we call it. And if this proof is found, we can go back to the source chain, have a timeout packet message, and then the funds, for example, in token transfer can be unlocked. All right, so enough about token transfer. Let's now go to interchain accounts. So as we said, we want ways to have random and arbitrary packet data being sentence over IBC. And now there's kind of two ways right now to do this, and that is interchange accounts. And we have custom IBC applications and we're going to compare those two now.
00:07:02.900 - 00:07:39.950, Speaker A: So first up is building custom IBC applications. Now, this is the more general one. As you can see on the left we have a blockchain which has an IBC module. Now, this is not the IBC core module that is present in the reference implementation. So if you spin up the Cosmos SDK blockchain, this will have already an IBC core module. But this module that you see, the IBC module is the one that is being developed by the application developers. Excuse me.
00:07:39.950 - 00:08:24.880, Speaker A: So here we see the relayer. And the important thing to gather here is that there is a lot of flexibility, a lot of customizability for the application developer. But it takes a little bit more time to get this going because we need to develop our own custom module. And at the top you also see ics, which stands for interchange standards. So a standard has to be built so that every blockchain who wants to implement this application understands what is going on and that we have some specification. So this can take a long time. And so another option to send generalized message passing is interchange accounts.
00:08:24.880 - 00:09:08.590, Speaker A: So if you take a look at this on the left here, we also have this IBC module, which there means actually the core IBC. And then we see on the left and on the right hand side that it's a little bit more asymmetrical. It doesn't have to be, it could be symmetrical, but it allows for an asymmetrical design. And the blockchain on the left is actually called the controller chain. The blockchain on the right is called the host chain. So what actually happens with indoor chain accounts? I like to see it as the host chain. So the chain on the right having some functionality that is native to the host chain, but that is not present on the controller chain.
00:09:08.590 - 00:10:04.260, Speaker A: So the way I like to think of it is as kind of an API. So say I'm an application developer who develops an application on the controller chain. Sometimes I could want to use some functionality on the host chain. And you can think of an analogy in regular web development. For example, if you want to have a website, a web application that compares airline fares, you're not going to ask your user to go every single time to every website of the different service providers, ask them to fetch that data and then compare only on your web application. What you're going to do is you're going to trigger an API and you're going to look for that data from the API, send it over to your web application and then do the custom logic. And a very similar thing is going on in the chain accounts.
00:10:04.260 - 00:11:01.850, Speaker A: So now a little bit of a closer look at the architecture. So again, it's important to realize that there's two asymmetrical parts. So we have the controller chain and the host chain. Once again, it's also important to notice that you can implement both of these functionalities or you can implement one of it. And as a matter of fact nowadays in the ecosystem we see that a lot of chains are in fact implementing host functionality. So they are allowing other controller chains to use functionality on their chain, but they are not actually using controller functionality and we will see why this is. So once again, there the host chain will host the interchain account and execute the sent transactions from the controller chain, the controller chain.
00:11:01.850 - 00:11:48.690, Speaker A: So actions on the host chain are being triggered from here like an API. And actually the controller chain has two main methods which is register, interchainaccount and send TX. But that will become clearer with this diagram. So once again on the left here we have the controller chain. So the chain that wants to implement some functionality from the host chain on the right. And here we see that actually what we implement in the IBC go package is the ICS 27 module that has sub modules, controller and host. But what you also see on the left is that we actually need an authentication module that wraps this module.
00:11:48.690 - 00:12:37.612, Speaker A: And this is kind of the tricky part which means that the developers will have to develop this. But more on that on the next slide. Something else that we see is that we have the interchain account on the host chain. So essentially when we want to execute the logic on the host chain, what is being done is we simply create an account on that chain and instead of using private keys to submit transactions, this happens programmatically by the ICS 27 or interchain accounts module. Some other things is that originally we have a connection between those two blockchains. But if a module or a user wants to use this functionality, first we have to register this interchain account. It's not present from the start.
00:12:37.612 - 00:13:34.060, Speaker A: And actually the authentication module, its job is to make sure that we manage the ownership of the different interchain accounts that could be created. And then the next flow, for example here would be to have a send TX. We actually updated the nomenclature first. It was called Tricenti Xdev, but we thought maybe it's better to use SantX, even though in reality, as I said earlier, things can time out. So it is actually try. We don't know for 100% sure that this will work out, but actually in IBC there's like 90% success rate, I would say so that's pretty good. And as I already mentioned, to go back to the current situation, and probably the reason we think that there's not a lot of controller chains out there yet is the fact that you have to develop this custom authentication module.
00:13:34.060 - 00:14:51.730, Speaker A: And we do have documentation for that, that guides you to this process. But obviously it's a little bit more work to do than for example with token transfer, fungible token transfer, where you simply spin up your chain, it has IBC and you can send tokens over IBC. So one of the things that we're doing at our team right now is investigate if we can have a couple of templates that people can simply use and adjust a little bit, but basically make sure that there's less work associated with developing this authentication module. Yeah, and let's look into some module templates, authentication module templates that we've considered. So one important thing that I also should mention is that when we developed interchain accounts, it wasn't so much the intention to make sure that every single user on one chain has an interchange account on another chain. That, for example could be done by a multi chain front end, for example. It was really the intention that a module on the chain would create an interchain account on another chain and then use some functionality like an API.
00:14:51.730 - 00:15:19.260, Speaker A: Nevertheless, we leave it up to the developers. And maybe some of the confusion was also because we have a demo repo which we are going to take a look at later. And this actually uses the first flow. So the first flow is single user to single interchain account. Like we said, this was not the intended use case. Also because for each interchain account you have to open a new channel. So this could potentially lead to a lot of channels being opened.
00:15:19.260 - 00:15:50.522, Speaker A: Then we also have one to one. But here the contract, the interchange account, sorry, is rather a contract. So a smart contract. So this is slightly different and maybe could make more sense then we have few to one in the cosmos. SDKs zero, four, six version. We have the govs in groups module. So this actually allows a few users or a group of users to control an interchain account.
00:15:50.522 - 00:16:43.370, Speaker A: And then the last one is ultimately what we had envisioned. So basically many users go through the authentication module. The ownership of the interchain account is up to the chain or a module on the chain. All right. And now it's going to be the moment of truth to see if we can go to the demo. All right, there we go. So, yeah, this is public, so you can also find it if you want to take a look after interchange accounts, demo repo.
00:16:43.370 - 00:17:39.436, Speaker A: So when we made this demo repo, actually our intention was to just quickly show what can happen because as we said, if you don't have the authentication module, you can't really use it. So for demo purposes, that's not great, obviously. But basically we're going to be looking, if we can extend this and have the multiple templates. But what we're going to do, or what is being done if you copy all of the commands that are here, is essentially we're going to use the controller chain to delegate some stake on the host chain without actually having an interface or without having a direct message on the host chain. All right, so first what happens here is just some installation. Then we have Makeinit. And Makeinit is the difference between.
00:17:39.436 - 00:18:09.646, Speaker A: Yeah, this where basically nothing is initialized. Makeinit will make sure that we build our binaries for both chains, start both chains and have a connection. So as I said initially, there is no interchange account. So there is no channel. Then this is just to make our lives easier. Just have some environment variables. Then the first step is to register an interchange account.
00:18:09.646 - 00:18:56.456, Speaker A: So again, here it's simply the flow of one user, one interchain account. So one user can actually use the CLI commands based on this authentication module to, in this flow. Let's go a little bit further to register an interchain account. And as you can see, we now have a channel that is live and also we have the interchain account that has been registered. So if we are going to want to submit transactions with our industry account, we also need to fund it. So this is what happens in the next step. And then we are mostly set up to sense the interchain accounts transaction.
00:18:56.456 - 00:19:47.730, Speaker A: So again, what we want to do is we want this user to actually make sure that there is a delegation to a validator that they choose on the host chain from the controller chain. Without having to change interfaces. And so here we have the commands. So what you see here already is that you simply include the data for the transaction and then what happens is this flow. So remember what I said, the API is basically registered in the chain account and this send TX, so the user initiates the send TX goes through the authentication module ICS 27 on the controller chain. Then in the packet we include this transaction data is being picked up by the host. Hopefully then we have execute transaction.
00:19:47.730 - 00:20:45.520, Speaker A: And as you can see here, we have some stake to this particular validator. So this is just proof of concept, but I think you will find if you do the demo yourself that it's actually pretty nice to see that you can do this and just have transaction from a user on one chain being executed on the host chain. And as we saw before, we'll hopefully have more of these demos that can ultimately lead to templates and then we will hopefully see a lot of chains implementing this controller functionality and we'll have a lot of interchain accounts, applications. All right, so that was my presentation. Thank you for your attention and also thanks to the team here for organizing this amazing event. Thank you. I don't know if we have time for questions.
00:20:45.520 - 00:20:57.070, Speaker A: Sure. I don't know if there are any questions. All right, cool, thanks. Yeah, cool, thanks a lot.
