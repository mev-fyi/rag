00:00:00.840 - 00:00:52.668, Speaker A: My name is Larry. I founded a company called Left Curve Software, and over the past six to eight months, we have been working on this project called Grag. So Grag is a new execution environment for blockchains. That means it is an alternative to the ethereum virtual machine, EVM, Solana, VM, move, cosmosm, and so on. Today, I'm just going to show you this project, and maybe if you're an app developer thinking about launching a new chain, maybe you can look into using Guac for that. So before we jump into Guac, I want to just spend a minute to give a brief thought on what it's like to building a new execution environment in today's market. So you see, there are a few aspects you can look at when evaluating an execution environment.
00:00:52.668 - 00:01:48.812, Speaker A: There is speed, meaning how many TPs it can do. There is security, meaning how many security pitfalls your developers can potentially fall into. And there's features, meaning how big of a toolbox you provide to your developers for them to implement their apps. So one strategy you can do when implementing your execution is to spread your efforts evenly across these dimensions. So in the end, you can probably do something like, oh, we create a new vm that is 1.2 x better than the EVM in every aspect, which I would say is a cool thing, but I just don't think that thing will have a lot of traction in the market. So instead, I think the right strategy is to pick only one of these aspects and focus on that makes that one aspect ten x better than any other alternative.
00:01:48.812 - 00:02:41.688, Speaker A: So if there are some apps that really, really depends on that one aspect being good, then that is your natural customer. That is how you carve up a niche in the market and grow from there. Here at Guac, our strategy is to focus on the features side. Our niche is to provide some unique features that you don't find in other vms, such that apps are difficult or straight out impossible to develop in other vms are going to be easy to do in grag. So for the rest of this talk, I will just be walking over some of the top, my favorite features that grag uniquely offers. So the number one of these features is our smart account system. So Ethereum now has EIP 3074, which I think is the right direction.
00:02:41.688 - 00:03:27.586, Speaker A: But our smart account system, in my opinion, is much more elegant and powerful than that. So let me just tell you about how it works. On the right hand side of the screen, you can see a flowchart. This is how a transaction is processed in grag. So the first step is to authenticating the transaction, meaning to make sure that the transaction was sent by the account's rightful owner. Right? So in a traditional VM, like the eVM, this is typically done by verifying a cryptographic signature. So the transaction is accompanied with a signature signed by the sender, and the VM is going to make sure that account is, that signature is valid.
00:03:27.586 - 00:04:08.198, Speaker A: However, this is quite restrictive. That means the VM needs to choose a signature scheme and enshrine that. So if at some point, oh, we don't like that signature scheme anymore, we want a different one, or maybe we want a totally different authentication system that does not utilize a signature, well, you're out of luck. So here in Guac, we want to make that more flexible. So our first major innovation in our smart account system is that instead of a signature inside our transaction, we don't have a signature, we only have a generic JSON value. So that can be a string, that can be a JSON object, it can be anything. And the blockchain.
00:04:08.198 - 00:04:56.900, Speaker A: The VM does not attempt at all to interpret or do anything with this credential. Instead, it leaves that duty to the account. So each account must expose a special function called before underscore transaction before transaction. So before the chain processes any transaction, it calls this function and provides the contract with the transaction. So everything about the transaction then inside that contract, the contract can interpret and verify that credential in however way it is programmed to do. So. That can be a cryptographic signature, that can be a one time password, that can be a hardware key, that can be your biometric key, whatever you can think of.
00:04:56.900 - 00:05:36.796, Speaker A: It is the most flexible account system ever. So the next step after authenticating it is we move on to execute the transaction. And after that comes our second major innovation in this account system, which is we call back into the account contract telling it, hey, this is the outcome of the transaction. And now the account can do something, whatever it is programmed to do about it. So this is called the back running the transaction. And there are a lot of new possibilities that this opens up. But I just want to give two examples.
00:05:36.796 - 00:06:32.644, Speaker A: One is you can implement a daily outflow limit in your account. For example, in the before transaction method, the account can compute its total value, and at the end it can compute its total value again. And if the account finds oh, my value decreased too fast, that's abnormal, it can reject this entire transaction. So in this case, if you implement this correctly, it just straight out prevents a lot of the hacks, because the account will literally not allow its value to drop too fast. So that's the first use case. The second use case is we can create a special margin account that allows you to take under collateralized or uncollateralized loans. So this is the feature that you find in centralized exchanges like binance or FTX, but you don't find a in deFi lending markets like aveo compound.
00:06:32.644 - 00:07:33.850, Speaker A: And this is only possible using our smart account systems for two reasons. Number one, we have the back running feature. So in the background part, the account can compute its own health factor. And if the transaction has resulted in the accounts going into an unhealthy state, the account can reject that transaction. And number two, because every single account is a smart contract, the account can implement an liquidation mechanism, so that if the account drops into an unhealthy state due to an external factor such as price oscillations, it can be liquidated. So combining these two things, we can create a new DeFi primitive called credit account, or margin account that allows it to take under collateralized loans. So now it would be dishonest for me if I don't mention Mars protocol, which is a project that I worked on before doing Grok.
00:07:33.850 - 00:08:21.730, Speaker A: Mars implemented this credit count primitive in cosmos. So it is definitely not to say that it is literally impossible to implement this without Grok. It is possible, but it is just really, really, really difficult. In fact, we estimate that if Mars had used grag, their code base can be reduced in 70% by size. That is just how easy grag makes to implement complex defi apps like this. That smart account, number two in our favorite features is our flexible fee scheme. You might remember that in the flowchart, I left out the final step.
00:08:21.730 - 00:08:44.390, Speaker A: And that is where we handle the gas fee. So different from every other vms out there. Evm, Solana, VM, move, whatever. Different from all of them. Gas fee in grag is handled by a smart contract. It is not enshrined in the VM. It is done by a governance appointed smart contract.
00:08:44.390 - 00:09:15.240, Speaker A: In our terminology, that contract is codenamed the taxman. So after every transaction, the chain prepares a gas report. Like this is the gas limit, this is how much it was consumed, and so on and so on. And calls a special function on the taxman contract called handle gas. So the taxman can do whatever it is programmed to do. Right. Let's give a few examples.
00:09:15.240 - 00:09:54.192, Speaker A: It can be a flat rate gas fee, as in cosmos SDK, and it can be a floating rate gas fee, as in ERP 1559. You can burn the fee, you can distribute that to stakers. Or maybe you can allow the users to pay gas fee in any asset. You can just swap the gas fee in a Dex. Maybe you can give a discount gas fee to holders of a specific NFT. Maybe you can say, oh, newly onboarded users gets their first ten transactions for free. Or you can say, oh, I'm building an order book Dex.
00:09:54.192 - 00:10:22.910, Speaker A: Maybe if you put a limit order that doesn't eventually get filled, you get a partial refund. So these are all the possibilities you can do. And you can do that simply by programming a contract. You don't need to fork the chain. And if at one point you are unhappy with your current gas fee mechanism, you want to change that? Well, just write a new contract and upgrade your existing contract. It's very simple. There's no hard fork of the chain needed.
00:10:22.910 - 00:11:13.388, Speaker A: And feature number three is cron jobs. A cron job is a task that needs to be executed at regular time intervals. For example, if you are running an order book, you need to find the matching orders at every block and execute them. Or if you are running a perpetual futures exchange, you need to adjust your funding rates every once in a while based on the long and short open interests. These are examples of cron jobs. So, in traditional vms, like the EVM, state changes can only be triggered by transactions. So if you want to do any of these things I mentioned, while you need a bot to submit a transaction once in a while to trigger those things, and bots can be unreliable, it can be expensive.
00:11:13.388 - 00:12:01.874, Speaker A: So what we want to do in Grok is to natively enshrining a cron job mechanism in the chain. So how does that work? Well, I just showed you the single transaction handling flowchart. Now, here is the full block handling flowchart. So here we use a mechanism that we borrowed from Cosmos SDK. So at the very beginning of the block, there's a list of contracts set by governance that is called one at a time, one by one. So if you are running a perpetual futures exchange, as we mentioned, you can, maybe one of those contracts can be your founding rate contract. So the chain will automatically cause that contract and update your funding rates, and then it goes into the transactions and do them one by one by one.
00:12:01.874 - 00:12:34.444, Speaker A: And at the end of the block, there's another list of contracts also set by governance. For example, that could be your order book matching algorithm, and that gets automatically executed. Now, these contracts are governance set because they're not subject to gas fees. They have unlimited gas. So we cannot let anybody permissionlessly put their contracts into the list. Otherwise they can just put an infinite loop in there and just screws up the chain. So this has to be governance gated.
00:12:34.444 - 00:13:29.652, Speaker A: However we can imagine the governance can create a contract that has a limited gas and use some sort of auctioning mechanism to permissionlessly allow people to put their cron jobs in. So yeah, it just opens up a lot of possibilities. The fourth feature is our new token standard. So I'm a big hater of ERC 20, and I'm going to tell you a few reasons exactly why ERC 20 sucks. First, every ERC 20 token is a separate contract and has its own state. That means if you want to send 20 tokens, well, you need to call 20 separate contracts. And it just also happens that each Ethereum transaction can only do one contract call, right? So that means if you have 20 assets in your account, you want to move that to another account, well, there's 20 transactions for you, right? So that's the first drawback.
00:13:29.652 - 00:13:58.490, Speaker A: Second drawback, you cannot send. Well, sending the token is a contract call. But if you want to send a token to a contract and call that contract, well there's two actions. You cannot do them in the same action, same transaction. That is why when you do a swap on Uniswap, that's two transactions. You have to first prove a spending limit and then the contract will withdraw your assets and do the swap. Two transactions.
00:13:58.490 - 00:14:34.930, Speaker A: Now there are some newer token standards that adds a new method called transfer and call, which solves this issue to some degree. But still, that's only one token. If you want to transfer two tokens and call, well that's two transactions. So that doesn't solve the issue completely. Number three, the recipient cannot reject a transaction. So if you send assets to a contract, the contract cannot do anything about it, and that has resulted in a lot of loss in value. The next two issues are related to queries.
00:14:34.930 - 00:15:18.984, Speaker A: So if I have, I give you an address and say hey, list all the assets holdings of this address. Well, it turns out you cannot do that because every token is a separate contract. If there are 2000 tokens in existence, you have to query those 2000 contracts one by one. That's just how, that's just a situation that indexers and blog explorers have to deal with. EvM, on the other hand, I give you a token and say hey, list me. All the holders of this token is also impossible. This is due to the Merkel Patricia tree data structure that Ethereum uses, meaning that's impossible to change.
00:15:18.984 - 00:15:59.130, Speaker A: You can't change the Merkel Patrizia tree. And the final drawback is it is a separate token, a separate standard from NFTs. Wouldn't it be better if we have fungible and non fungible tokens under one roof, under one standard? That would be much easier for developers. So Gurak still can solve every of the issues. Let's start with the two query issues. On the right hand side of the screen, you see an example of how it looks like when you query the balance of an account in grag. So you just say, hey, I want to query balances.
00:15:59.130 - 00:16:36.860, Speaker A: I want to query the where did my slides go? I want to query the balances. Here is the user's account and this is the response. It just lists you all the assets. As simple as that. In grag, fungible tokens and non fungible tokens are a single standard. A non fungible token is simply a fungible token with one supply. As simple as that.
00:16:36.860 - 00:17:08.310, Speaker A: You can see here I have bad kids. As an example, if you hold two bad kids nfts, that is what it looks like in your wallet. You just have one of each of them. Recipients can reject transfers. Every single account needs to implement a function called receive. That is called when the transfer is executed, so the recipient can see, oh, I only want USDC, but this guy is sending me USDT. I want to reject that.
00:17:08.310 - 00:17:47.570, Speaker A: The transfer is rejected. Or if sender is on a sanctioned list by the us government, I don't want to have anything to deal with him. You can reject that transfer and when you call a contract, you can attach any number of fungible or non fungible tokens as a payload. So you can send all these assets in one go and call a contract. Yeah. And last thing, as I mentioned, everything I just mentioned is managed by a contract. So if you don't like what I just mentioned, you want to implement your own standard, well, just write your own contract.
00:17:47.570 - 00:18:07.102, Speaker A: You don't have to fork the chain. Number five, Cosmos. IBC is enshrined. I think IBC is just the best bridging standard. If you disagree, I think you're wrong. So you can, with IBC, you can onboard users from every ecosystem. I have listed a bunch of options.
00:18:07.102 - 00:18:36.050, Speaker A: Ethereum, Solana, bitcoin, USDC, Cosmos. I'm not endorsing any of these just to show you how much opportunity there is by supporting IBC for the devs out there. We also have a bunch of quality of life improvements for you guys. Our transactions are multicol. You can iterate over mapping data structures. There's a null type which you don't have in solidity. Contracts are natively upgradable.
00:18:36.050 - 00:19:16.652, Speaker A: Our call data are humanly readable. You don't have to decode your call data. Reentrancy attack is impossible. And so on and so on and so on. In terms of roadmap, we are thinking about tagging a release candidate somewhere in the Q one of 2025. As mentioned, our focus right now is on the features side. We are not spending too much effort on optimization, but even though I think we can do 1000 TPS easily, which is I think enough for most applications, we are going to launch a chain, we are going to have a token and we are going to ship the first few consumer apps on that chain.
00:19:16.652 - 00:19:49.094, Speaker A: So post launch we also have a few things to do. We are going to have a solution to state bloating, which is considered one of the biggest hurdles in blockchain scaling. We're going to explore parallel processing using block STM, which is what AptoS and Sui uses. And we're going to explore ZK proving our execution. So one last thing. Grok is heavily inspired and adapted from Cosmos. It's safe to say without cosmosm there will be no grag.
00:19:49.094 - 00:20:19.260, Speaker A: So I want to say thank you for anyone who have contributed to Cosmopolm, especially Confio. And lastly, this is our discord server. If you want to chat more, join our server or just directly dm me on Twitter, Telegram, so on. Yeah, that's it. Q and a question.
00:20:26.320 - 00:20:40.530, Speaker B: Regarding the receive feature. Does it mean that you double every transaction? Like for any send you have two transactions they need to execute.
00:20:42.630 - 00:21:01.690, Speaker A: It is still one transaction, but there will be two contract calls. So you call into the bank contract to update the balances and after that it calls the receiver contract and receiver can do its thing. So it's still one transaction but two contract calls? Yeah.
00:21:03.220 - 00:21:09.040, Speaker B: So does the receiver need to pay gas if he wants to implement some filter, for example?
00:21:10.380 - 00:21:33.170, Speaker A: So who pays gas is determined by the taxman contract. So you can program however you like, but we are going to ship a default implementation of Taxman. And the way that works is gas fees paid by the transactions sender. So the sender pays it? Yeah, but you can customize it any more.
00:21:41.830 - 00:21:49.250, Speaker B: What do you think is the impact on gas fees of the before transaction and after transaction hooks?
00:21:50.550 - 00:22:01.390, Speaker A: So those two are just regular contract costs that incur normal gas fees added to the total transaction cost. Yeah.
00:22:09.770 - 00:22:17.986, Speaker B: Are you going to be integrating ABCI into grug? And that's going to be available in the smart contract later as well.
00:22:18.058 - 00:22:18.670, Speaker A: Yes.
00:22:19.730 - 00:22:20.470, Speaker B: Nice.
00:22:20.810 - 00:22:25.410, Speaker A: Yeah. The chain we are going to launch will use that to provide a native oracle feed.
