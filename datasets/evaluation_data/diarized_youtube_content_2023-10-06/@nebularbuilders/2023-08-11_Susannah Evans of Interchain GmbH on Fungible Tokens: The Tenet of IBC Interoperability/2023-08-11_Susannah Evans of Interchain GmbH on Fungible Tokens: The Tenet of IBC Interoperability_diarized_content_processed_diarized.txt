00:00:09.280 - 00:00:36.562, Speaker A: Hi, everyone. So yeah, I'm going to talk about fungible tokens and why they're so important for IBC interoperability and interoperability in general. So I'm Susanna. I'm the product lead for the IBC team at Interchain. We work on IBC Go repo and the specs we maintain and develop. And I'm sure there's lots of you using these repos. So, yeah, today I'm going to start by covering interoperability fungibility.
00:00:36.562 - 00:01:03.986, Speaker A: Just give an overview of why it's really important. Then we'll go into a bit more detail about channels and then how you can upgrade channels, which is the reason why we need to upgrade channels. It's all linked to fungibility. So let's go. So I'm sure pretty much everyone here has seen this image. It's from map of zones. It's just showing us how the IBC network looks.
00:01:03.986 - 00:01:42.864, Speaker A: Currently we have over 60 chains that are connected and interoperating, all using IBC. Token transfer, interchange accounts, queries. There's loads of different cross chain applications which are just being leveraged by using IBC. And just to give an example of how much this is being used, between last year and February this year, over 29 billion value was transferred using IBC. This is huge. And right now we have mostly cosmos, SDK chains, tendermint chains. We recently connected to the polkadot ecosystem, which is really cool.
00:01:42.864 - 00:02:12.132, Speaker A: And we do have more diverse chains coming soon. So we will have connections to Ethereum, nomada, penumbra. And in this time that IBC has been live more than two years, there have been no exploits. Woo. Yeah, exactly. So this is huge, right? Interoperability is so important. We know about the fragility of all of these systems in general.
00:02:12.132 - 00:02:46.460, Speaker A: But IBC battle tested, secure, strong. So we know how great the IBC network is. But one day a few chains said, hey, actually I want to have connections with Ethereum. Right now, we can't have a direct connection using IBC to Ethereum, so we have to use other solutions. I've just given a few examples of some solutions. So you could use gravity bridge, you could use Axar, you could use wormhole, or you could make your own native bridge. There are options.
00:02:46.460 - 00:03:48.730, Speaker A: So great we can connect to Ethereum with one of these options. But let's say I'm osmosis and I wanted to connect to Ethereum so that I could have USDC flowing into osmosis if I chose all three of those solutions and deposited USDC and osmosis I would have three separate representations of USDC coming from Ethereum. Right? And if I'm a user, that's, quite frankly terrible. No one wants to have to deal with fragmented liquidity, knowing that these three tokens are not going to be fungible of each other. You just want to have one representation of USDC in your USDC OSMo liquidity pool and osmosis, they're a great team. They had this foresight, right? They realized you can't have multiple different bridging solutions coming into osmosis because it's going to create this fragmentation. And they went through a whole governance proposal to decide on a canonical bridge provided to connect them to Ethereum.
00:03:48.730 - 00:04:33.874, Speaker A: And in the end, they went with AxLr. And now we can see, if we look for the USDC Osmo pool, there's just one, right? The front end is abstracting away that actually it's the representation coming from Axlr. But to an end user, we just have one USDC Osmo pool. And this is just really important for user experience. Like, you don't want to have loads of different representations of, to you, what you think is pretty much the same token, you just want to have one unified liquidity pool. So, yeah, why am I talking about other bridges? Bring it back to IBC and how fungibility is still relevant for IBC. So imagine I want to send atom from the cosmos hub to osmosis.
00:04:33.874 - 00:05:08.214, Speaker A: I'm going to use ICS 20. That's the standard for token transfer of IBC. Hopefully, as an end user, you would just use one of the existing front end applications, which abstracts away all this complexity. So you've got the native osmosis front end, here's TFM, there's IBC. Fun by the skip, guys, loads of options. But under the hood, you're using the channel between the Cosmos hub and osmosis. So you're using transfer channel 141 on the Cosmos hub.
00:05:08.214 - 00:05:51.064, Speaker A: You're sending data packets to osmosis to arrive at transfer channel zero. And you're sending atom. Right? So you have your atom on the hub. Um, and then on osmosis, it actually arrives as an IBC denomination, and an IBC denomination is the hash of the path and the base DNA. So the path for this atom arriving at osmosis is the transfer channel zero on osmosis, and the base enum is u atom. And then this actually ends up in this really long, horrible looking string of letters and numbers. And obviously, as an end user, you don't want to have to see that.
00:05:51.064 - 00:06:51.338, Speaker A: And thankfully, front ends abstract away that complexity. So if you go on mint scan and you want to see the atom on osmosis, it will just appear looking like this atom IBC token. But for the observant among you, maybe you've also seen on mint scan that they're like loads of other channels that you could choose to transfer your tokens on. With IBC, right? There's not just this one channel, there's a few other which aren't really being used, but they exist. And if we go back to what I just said, what is an IBC DNom? It's representation of the token and the path that it took to get that is really important, right? So if I send tokens on a different channel, it's going to have a different path. So therefore it's not going to be fungible of the tokens sent on a different path. So therefore there is this kind of fungibility problem in IBC as well.
00:06:51.338 - 00:07:29.950, Speaker A: If you pick the channel which the liquidity pool isn't made up with, if you try and deposit, it's not going to be possible. So then how do you know which channel to pick? This is a good question. And there's loads of registries in cosmos which are trying to make it easier for people to know, okay, you should pick this channel. This is just an example of what stride have on their GitHub. They just list all of their canonical channels. But the canonical channels are really just decided based on social consensus of okay, we're all going to use this channel. Great.
00:07:29.950 - 00:08:09.120, Speaker A: As a side note, I do think that there should be local on chain registries that chains maintain to indicate which channel they use canonically. Osmosis have implemented one in cosmomosm. But yeah, that's just a little side note. But all of that is to say, all of the accumulated state in a channel is really important. Once you create this channel, it's really important that we keep using this channel. And this channel in particular between the hub and osmosis has been used for 8 million transfers. It's been around for well over two years.
00:08:09.120 - 00:08:45.428, Speaker A: And this channel in particular has sent back and forth 1.5 million billion dollars in value. Okay, so let's look a bit more in detail about channels. So a channel is just a way for two applications to communicate with IBC. They do this by sending data packets along this channel. And channels enforce the ordering of packet delivery, say for transfer. We don't care about the order of packet delivery, but other IBC applications order matters.
00:08:45.428 - 00:09:12.774, Speaker A: For instance, interchain accounts. You need ordered channels. Channels ensure that packets are delivered only once. And this is really important because, you know, if you're sending tokens, you don't want double spend things like this. And a channel determines who can communicate on that channel, which application module can send packets on that channel. I've also just shown you the other abstractions in IBC. We're not going to go into those in detail today.
00:09:12.774 - 00:09:41.052, Speaker A: We're really going to focus on channels. But yeah, below the channel layer there's other transport layer abstractions. We don't need to be concerned with these to understand what's going on at the channel layer and the application layer. So if we just take a little more of a look into what's a packet. So a packet has a sequence. This is important for enforcing, ordering. It has information about timeout.
00:09:41.052 - 00:10:27.552, Speaker A: So this is to say this packet needs to be delivered by this time. It has information about where the packet came from, where the packet's going to, and then it has data. And this data is just taken by application modules. The application module will decode the data and then perform specific logic that it needs to perform. So for instance for token transfer, this might be minting a token, escrowing tokens, whatever. So then how do we create these channels? So there's something called the channel handshake, which I'll go into in detail. But what are we actually making when we make these channels? Okay, so the channel end is defined by this interface.
00:10:27.552 - 00:10:49.020, Speaker A: You have state of a channel. When packets are freely going back and forth along this channel, it will be in the state open. But to create this channel, we go through two other states. We go through initializing the channel and we try to open this channel. The ordering. So as I said, token transferred, unordered. But for interchange accounts you may have ordered channels.
00:10:49.020 - 00:11:30.170, Speaker A: And then we want to know who we're talking to, who we're communicating with on this channel. Connection hops is less relevant for IBC today because we don't have multi hop routing in IBC. We currently have direct connections. But in the future with multi hop you can have two channel ends which have an intermediate chain between them. And the version is defining which application module is using this channel. And upgrade is what we will talk about a bit later in this talk. But first, how do we make this channel? So first of all, we have two chains, they don't have channel, so the state doesn't exist yet.
00:11:30.170 - 00:12:08.940, Speaker A: Then an application module called chanopenernit. They say I want to form a channel between my chain and my counterparty. The channel on chain a now is in the initialization stage. So we've defined all of the parameters that we want this channel to have. And this is just the starting point of creating a channel. Then a relayer will basically let the counterparty know, hey, your counterparty wants to make a channel. Here's all the parameters that they want to make this channel with.
00:12:08.940 - 00:12:50.320, Speaker A: What do you think looks good to you? If the counterparty says, yes, I want to make this channel as well. I agree, all of these parameters look great. Then it moves into the try open state. Then a relayer will send a message back to the chain a, who wanted to make the channel in the first place, saying, hey, chain B says, it's all looking good. They agree with the parameters you proposed. And then the channel on chain a moves to open. And the last step is sending back this confirmation that your counterparty is ready to open this channel.
00:12:50.320 - 00:13:33.902, Speaker A: And then you have an open channel, so packets can flow freely between the two chains. And then we have to write the channel in state. So in this case, for the communication between the hub and osmosis, we have open channel, we have unordered channel because we're just using transfer. The port id is transfer for ics 20. The channel identifier on osmosis is zero, and our version is app version ics 21. So yeah, then we end up with this channel, which we've been using to send atom from the hub to osmosis. That's great.
00:13:33.902 - 00:14:18.876, Speaker A: But one day a relayer says, hey, I love IVC and everything, it's amazing, but I'm actually paying all of these fees and infrastructure costs to relay these packets. And then the IVC team said, okay, that's fine, don't worry about it. We made ics 29. So ics 29 is a middleware. You add to both ends of your channel, and it ensures the timely delivery of packets whilst making no new packets in the process. Great, we can add incentives to relayers. Everyone should be happy, right? But then let's look again at our channel.
00:14:18.876 - 00:14:57.692, Speaker A: Okay, so we have this version, app version ics 21. This is the version of the channel, channel 141 between the hub and channel zero between osmosis. But now if we add fee middleware to this channel, we have a different version. We have fee version ics 29, app version ics 20. So it's not the same anymore. So what can we do? We could create a new channel. The problem of doing that is we lose all of this built up state in this channel, and we lose the fungibility of all the tokens that was transferred along this channel.
00:14:57.692 - 00:15:27.030, Speaker A: Okay, it's probably not a good enough trade off to bother creating a new channel, right? There was 8 million transfers that took place along this channel. I don't see why anyone would bother. And no one has bothered creating new channels. So there must be another solution. And thankfully there is one coming very soon. So you can upgrade an existing channel. Okay, so what's the benefit? You retain all of the built up state in the channel.
00:15:27.030 - 00:16:10.434, Speaker A: You retain the fungibility of all the tokens you transferred along that channel. And another bonus is you get to prune all of the prior acknowledgements along that channel. So just for some context, there osmosis have 26gb of pruned state in archives and 5gb of that is IBC data. So if you could prune some of that data, that would be pretty nice as well. So yeah, now let's talk a bit more about what channel upgradability is. So channel upgradeability is basically renegotiating the channel parameters. And what you can change is the ordering of a channel, the version.
00:16:10.434 - 00:16:52.400, Speaker A: So you could add v middleware, you could even upgrade existing application modules. And you can change the network topology by adding and removing connection hops between two channel ends. And you do all this whilst retaining all of the built up and existing state in the channel. And this is really important for future proofing IBC. So how does it work? Now we have our two channel ends, they're both in the open state. After a governance or authority gated process, chain a will call channel upgrade init. And this is signaling I'm ready to perform this specific type of upgrade.
00:16:52.400 - 00:17:33.230, Speaker A: And what they will do is they will say, okay, for this, this specific channel, I want to perform this upgrade. And they'll put that in a provable store. Now in this scenario, we're taking kind of the simple happy pass scenario. Chain B is ready for this upgrade. They've already done all of their wiring they need for the upgrade and they have decided to permissionally accept incoming upgrades. So now we know that our counterparty wants to do this upgrade. So a relayer can then submit Chan upgrade try.
00:17:33.230 - 00:18:01.312, Speaker A: And they submit this along with the proof that the counterparty wants to perform this upgrade. Everything's going well. The chain B also wants to upgrade. So now they can start flushing the channel of all of the packets from the previous version in that channel. So now channel B will move to flushing. Then a relayer will submit Chan upgrade. Ack.
00:18:01.312 - 00:18:36.740, Speaker A: So this is to say channel B agrees to this upgrade and they've started flushing packets on their side. We're also going to start that process as well. So we're going to start flushing out all of the packets in the channel that are from the old version. And obviously during this flushing process, you can't send new packets. So send packet is enabled in the channel. So basically it's kind of freezing the channel, getting rid of all the previous packets that may have been built up. Then both channel ends will complete the flushing process.
00:18:36.740 - 00:19:09.570, Speaker A: You submit confirmation that the upgrade has been successful. All of the previous packets have been flushed. We can now move the channel to the new version, and you'll also submit that on the originating chain for the upgrade. And now we have the channel in the open state again. Packets can flow freely between the channels, but we have the new version of the channel now. We've added free middleware to the channel. So we've got relay incentives and we've got token fungibility.
00:19:09.570 - 00:19:39.434, Speaker A: Amazing. But that was just one example of what channel upgradability can be used for, because as soon as the feature is live, it's ready to use that. But channel upgradeability has a lot more to offer than just adding relay incentives. There's three main things you can change. So ordering right now, for interchange accounts, you need order channels. You might want to not have order channels. I think this has been a bit of a pain point.
00:19:39.434 - 00:20:28.576, Speaker A: There shouldn't be ordering necessarily with interchange accounts channels. So now with channel upgradability, you could change an ordered channel to an unordered channel. Censorship might also be a concern. With token transfer, you have unordered channels. What if you want to enforce some kind of weak ordering to make sure that all packets are actually delivered? So you could retain token fungibility of your token transfer channels and change the ordering from unordered to weak ordering, as I mentioned, versioning. So any upgrade that requires middleware at both ends of the channel or some kind of change, that would not be backwards compatible. The example here is adding relay incentives, but this can really be extended a lot further.
00:20:28.576 - 00:21:00.904, Speaker A: So if we want to improve ics 21 of the big improvements many people have asked for is having multiple coin types in an ICS 20 packet. With channel upgradability, we can now enable that. And connection hops is really, really important for future proofing. And if we presume the interchange is going to grow, we need to change the network topology of IBC. We might say, okay, I have this direct connection between two chains. It's really congested. I actually want to use a router chain.
00:21:00.904 - 00:21:38.680, Speaker A: Who's going to give me some kind of benefit. They're going to deal with all the infrastructure of relaying, especially when we're connecting non heterogeneous blockchains. It's going to make a lot of sense to have router chains then. Right now, we just have a lot of tendermint Cosmos SDK chains. Everyone has direct connection, but in the future, connecting to Ethereum, this is going to be a lot more expensive than having these direct Cosmos connections. So, yeah, it's just a really important feature for future proofing the protocol. So, yeah, thank you for listening, and, yeah.
