00:00:10.880 - 00:00:41.430, Speaker A: Thanks. So, I'm Isaac, I'm a scientist at Heliax, and I lead the typhon product group. Specifically, typhon includes Alex, tobias, Nakeeb, and myself. In no particular order. Heliax is building typhon as part of the anoma fabric of protocols, which we hope will enrich the cosmos ecosystem. And right now, anoma based blockchains, the first of which will be nemata, use tendermint, which is pretty common for cosmos. But tendermint isn't perfect and we think we can do better.
00:00:41.430 - 00:01:37.280, Speaker A: So we're building typhon to replace tendermint, and it's going to improve throughput and latency. But the feature I'm most excited about is that it's going to enable a new kind of side chain, a protocol we call camera chains, which support multi chain atomic commits. So before I dive into that, I'd like to give you a taste of how typhon will improve tendermint, even in single chain transactions. To zoom out a little bit, the idea behind most any blockchain is to maintain a replicated state machine, and that machine is replicated across all the validators. It starts in some initial state and each transition takes it to a new state. Usually individual pieces of state have well defined permissions on when they're allowed to update, such as only Alice can deduct money from Alice's account, and these are defined in code that has to be checked each time state changes. These checks might be called validity predicates or smart contract transactions, or stuff like that.
00:01:37.280 - 00:02:08.400, Speaker A: Usually we want our blockchains to be highly available. That does mean that they should be easy to read, pretty much by anyone who wants has permission to read the state, but it also means that everyone should be able to commit transactions. They should have high throughput. The really tricky part, however, is that we also want to have high integrity. We want everyone to agree on the replicated state machine, even in the presence of failures. And that's what tendermint does. It provides a basis for maintaining a replicated state machine with high availability and high integrity.
00:02:08.400 - 00:03:06.160, Speaker A: Typhon is intended to replace tendermint, and we're hoping to improve on tendermint in a few ways. Firstly, tendermint has a fundamental throughput limitation, and there are a couple of reasons for this. One is serialized execution, which is pretty normal for blockchains, but puts a fundamental limit on the throughput, regardless of how good your actual distributed system component is. When I talk about serialized execution, I mean that tendermint executes each transaction from start to finish sequentially, not just in some equivalent manner, but actually in sequence. This serialized execution doesn't allow for concurrency, putting a fundamental limit on how many transactions can be processed. Even if all the distributed stuff were free, essentially all applications actually running on the chain itself at least, are trying to timeshare a single cpu. Ideally, we would want to execute transactions as concurrently as possible, while preserving some kind of equivalence to serialized execution, which is what high performance databases do.
00:03:06.160 - 00:03:50.766, Speaker A: We want to preserve an execution that is serializable, which is to say equivalent to a serial execution. Specifically within any serial transaction. Reads and writes should be consistent with the global order of transactions, but when transactions don't actually touch the same parts of state, we should be able to compute them in parallel using multiple machines, even for each validator. To do this, we need to break up state into substates. We're thinking about phrasing them as key value pairs and require that each transaction label the substates that it's reading or writing. Any transaction which tries to read or write state outside of its labels would fail, much like a transaction that runs out of gas. The execution engine could then run multiple transactions concurrently, even on separate machines updating their separate pieces of state.
00:03:50.766 - 00:05:09.900, Speaker A: We're hoping to leverage some existing work in databases to make this run. Specifically, the gold standard database property is called serializability, the idea being that for purposes of reads and writes within a transaction, each transaction observes the world as if it were being executed alone, one at a time, in some kind of serial order. But under the hood, we actually run faster than that. Taking advantage of parallelism, this is going to involve an execution engine where validators have multiple execution workers, and mempool consensus engines have to forward the relevant information to them so that they can execute transactions and update the state the way that tendermint does. Leader block proposals also creates a bottleneck that damages throughput and latency. Specifically, at least the authors of Narwhal and Tusk found that a major bottleneck is that each tendermint block with all of the transactions it contains has to be broadcast by some proposer, some leader to all the other validators, and this broadcasting can be the limiting factor for throughput and a significant latency problem as well. Ideally, we distribute transactions in a less centralized manner, and consensus would only need to agree on references to collections of transactions that we know are available.
00:05:09.900 - 00:06:13.780, Speaker A: Typhon is adapting the Narwal mempool published earlier this year at Eurosys, which allows validators to store an arbitrarily large structure of transactions, while consensys only has to periodically order signed references to transactions that are already available. Narwal lets us decouple the throughput of our blockchain and how many transactions it can add from consensus latency or consensus protocol bandwidth, which is really useful. We do have to tweak it a little bit to allow for chimera chains, which I'll get to in a minute. And that brings me to we want to expand Typhon's functionality to handle atomic transactions that update state on multiple instances. This requires changing the definition of what it means to agree on the state machine, since different chains have different validators and thus different sets of individuals who want to agree. Typhon will enable a new technique, which we call camera chains. And to explain where this fits in, I just want to go over a very high level of how typhon is architected.
00:06:13.780 - 00:07:02.850, Speaker A: It's composed of three layers, mempool, a consensus, and an execution, and each layer passes information to the later layers. Our mempool is based on narwhal, tweaked slightly to allow for chimera chains. Any mempool on any consensus on any blockchain has to receive transactions from clients or solvers or whatever you call them, and store those transactions so we know that they're available. Consensys then needs to work with references to batches of transactions or needs to pass along the transactions themselves. Our consensus layer then establishes a total order of these transactions. Our consensus will be based on heterogeneous Paxos, and we'll try and enable these chimera chains. And the execution layer then needs to read that total order from consensys and the transactions from the mempool and actually update the state machine with as much concurrency as possible.
00:07:02.850 - 00:07:49.614, Speaker A: So at last I could talk about camara chains and the cross chain atomic commit problem. We hope that in the cosmos ecosystem, many active chains will provide many applications, many of them using the Anoma architecture, each of which will have their own set of validators, their own security model. Anoma will use and even extend some existing tools like IPC, which we heard about earlier, to securely send messages from one chain to another. And tendermint can handle this kind of thing reasonably well. But this kind of asynchronous communication doesn't solve a specific difficulty of multi blockchain applications. So for concreteness, let's consider the train and hotel problem. Suppose that a hotel tracks rooms using red blockchain and a train tracks seat bookings using blue blockchain.
00:07:49.614 - 00:08:21.834, Speaker A: Now suppose I want to buy a train ticket to Paris if and only if I can get a hotel room in Paris. I don't want to buy one and then find out that the other is sold out, which has happened to me before. One traditional way to do this would be to use a multiphase commit. So we'd start with some state. Each chain would commit a transaction saying that it wants to do this multiphase, multi chain transaction. So it's locking the relevant state until all the relevant chains are locked, and then no one is allowed to change the state until it's unlocked. So here we're putting a lock on the train seat.
00:08:21.834 - 00:08:59.730, Speaker A: I haven't bought it yet, but no one else can buy it while it's locked. And that state stays locked even while more transactions are processed, until all the relevant chains have locked all the relevant state. Now, I've also locked a hotel room. I haven't booked it, but no one else can book it while it's locked. The other chains will need to receive IPC messages indicating that each of them have indeed locked their relevant state committing to the multi chain transaction. And at last, the transaction can take place and the state can be updated and unlocked. So finally, here I have booked the hotel room and the train seat.
00:08:59.730 - 00:10:01.252, Speaker A: Fundamentally, multiphase commits like this have at least three problems, and the first is liveness. If the blue chain locks its state and red chain dies, then blue chain state stays locked, despite the fact that conceptually the blue state machine should be live objects on blue chain, I don't think should be made on live because of failures outside of blue chain. And in this example, the train ticket would stay locked and unbookable because of failures that have to do with validators that the hotel trusts, even if the train system doesn't particularly care about those validators. Secondly, and more simply, it takes at least two rounds. Every multichain transaction requires at least two blocks worth of latency without pipelining, because you have to wait for proofs of consensus to receive the IBC messages for the second phase. And finally, whichever chain commits last gets to decide effectively when the transaction happens. And in a market of fluctuating prices and opportunities that can be valuable.
00:10:01.252 - 00:10:39.270, Speaker A: We don't really want to incentivize chains to delay anything. So Typhon introduces a new solution to the atomic multichain commit problem that I call chimera chains. So suppose that we want to atomically commit some transactions to red chain and blue chain. We propose that what red chain and blue chain instances need is a third chain, a place where in the train and hotel example, both the train ticket and the hotel room can be booked atomically. And we call this a chimera chain. Most importantly, red transactions on the chimera chain get all the same guarantees they get on redchain. They won't lose safety or get stuck because of something that wouldn't stop red chain.
00:10:39.270 - 00:11:19.424, Speaker A: Likewise, blue transactions get all the same guarantees that they would get on blue chain. But crucially, this chain supports batches of multi chain, in this case some red and some blue transactions that will be committed atomically. Either everything in the batch happens, or none of them will within a certain guarantee. For example, we might want an atomic batch that includes a red transaction booking the hotel room and a blue transaction booking the train ticket. Either both get booked or neither. And we're going to do this using a consensus protocol based on heterogeneous Paxos, which I published at Opetus in 2020. Heterogeneous Paxos isn't magic, but it gives us a specific failure tolerance under which we get this atomicity guarantee.
00:11:19.424 - 00:11:56.250, Speaker A: In a sense, a chimera chain is a bit like a trusted bridge. You can run transactions on it and you'll get this atomicity under certain trust assumptions. And these trust assumptions arise naturally from the quorums of validators on each chain. The more validators they have in common, the stronger the atomicity guarantee. In practice, proof of stake chains often share a lot of validators. There are something like 30 companies that run validators professionally, so we expect a lot of Noma instances will be able to have quite secure chimera chains between them. But this does naturally raise the question, what does it mean for the base chains to be safe if we lose atomicity? Well, it means that in some sense the chimera chain has forked.
00:11:56.250 - 00:12:23.364, Speaker A: But here's the useful property that we get from heterogeneous paxos. So long as Redchain's consensus itself remains consistent, red chain perceives a consistent chimera chain in some sense. For red chain, the chimera chain is like an ordering shard or an additional side chain. Blue chain also remains consistent. Blue nodes perceive a consistent chimera chain. Without atomicity. Red's chimera chain might get incorrect information about blue transactions.
00:12:23.364 - 00:13:06.536, Speaker A: It may think that a hotel room was sold out when it was in fact available. The atomicity guarantee is simply that the chimera chains that they decide on will be the same. Then, of course, there's the Chimera state machine itself. This requires some work in the execution layer. I mean, the API that we're using to represent the abstraction barrier between consensus and execution is called ABCI for abstract blockchain interface. So let's assume that the chains involved here have their own state machines, each written with to communicate with their own ordering mechanisms via ABC I. Then one of the remaining challenges is that for our Camara chain, we need to write our own state machine, which runs these atomic multi chain transactions.
00:13:06.536 - 00:14:02.330, Speaker A: And the easiest way to do this would be within the Camara state machine to run instances of the constituent state machines, and we know how to do that. We can communicate with these instances via ABC I. Now the transactions for our Camara state machine will be bundles of transactions spanning each of the constituent state machines. So far we we can keep everything in ABCI abstractions if our chain schedules an atomic bundle of transactions, our chimera chain schedules the transactions from the bundle for each of the constituent state machines. But a lot of these transactions probably want to include computation based on the current state of the state machine. We will want to add some additional communication interface whereby transactions running on the constituent sub state machines can send information to each other or even get replies within the same bundle. You could imagine writing code on the hotel side that sends some kind of a message to the train side to ask which seats are available, and gets a response back and makes decisions accordingly.
00:14:02.330 - 00:15:00.740, Speaker A: That means adding yet another communication interface, this time not any literal communication over the wire, but rather taking place entirely within the Chimera state machine. But it's going to require some support from the constituent machines and their transaction languages. So hopefully that gives you a taste of the Chimera chain project. They are a general way to atomically commit transactions across multiple noma instances without multiple rounds of locking resources, hopefully making things as fast as they theoretically can be, at least in the easy case. We hope that with better multi chain support, people won't be quite so incentivized to force all their applications onto a single chain, and having many interoperable instances reduces congestion and costs. But it also allows each application to choose a trust model that's actually right for them. Kamira chains will be a key feature of Typhon based enuma chains, and the core component that enables them is our heterogeneous Paxos based consensus layer.
00:15:00.740 - 00:15:58.900, Speaker A: I just want to talk a little bit about where we spent some of our time recently working on Typhon, and that is formal verification, specifically for the mempool and consensus layers, at least so far. We've been developing formal models for our mempool and consensys in Leslie Lamport's TLA plus specification language, and then building formally verifiable proofs for those models in the TLA plus proof system, which was created by Lamport with folks from Inria. Specifically, we're able to prove key safety properties about heterogeneous Paxos, and we're working on proving our Mempool ensures key availability properties. We're also able in these specs to model check at least small hypothetical setups, which has already allowed us to check some liveness properties, even if they're harder to formally prove. This has actually helped us uncover and fix a subtle bug in our original heterogeneous Paxos spec and update it accordingly. We think that this kind of work is really important, given how subtle bugs in byzantine systems can actually go undetected for an extremely long time. So we want to make sure that we get ours correct.
00:15:58.900 - 00:16:47.430, Speaker A: So that's typhonous. It's a replacement for tendermint. It's built with a narwhal based mempool designed to fix the block proposal bottleneck, a heterogeneous Paxos based consensus protocol that facilitates chimera chains and addresses cross chain atomic transactions, and a highly concurrent execution engine that preserves serializability without the serialized execution bottleneck. The enoma framework will allow people to build cosmos blockchains using typhon and enable chimera chains. You can check out the english language spec in progress here, but we're hoping to have a full spec proposal coming soon that may end up going through peer review someplace, maybe financial crypto or Eurosys or something. You can also check out progress in the formal specs and prototypes on GitHub. And finally, we are hiring, especially if you are an expert in concurrent serializable execution environments.
00:16:47.430 - 00:16:57.860, Speaker A: Contact me. Are there any questions? All right, I have confused everyone.
00:17:00.560 - 00:17:10.980, Speaker B: This is cool. We have another effort to integrate. There's another effort at similia to integrate narwhal with tendermint, which I should get you in the chat.
00:17:11.320 - 00:17:12.620, Speaker A: I would appreciate that.
00:17:14.080 - 00:17:19.228, Speaker B: This is definitely matches my mental model of where consensus should be going, so this is very cool.
00:17:19.384 - 00:17:20.120, Speaker A: Thanks.
00:17:29.540 - 00:18:00.142, Speaker C: I got a question is regarding about locking assets. Maybe if we can take the example of the train. Let's say that a malicious actor just want to lock it, but for unlimited time. Durie, how do you manage that? Because if someone else wants to take a ticket for the train, it will not be possible to do this, right?
00:18:00.326 - 00:18:38.510, Speaker A: So that is a problem with multi chain atomic commit based systems, and there are several ways that people have chosen to address this. So in particular, with Camara chains, we don't have to lock the assets. We can move them to the Camaro chain where they have the same liveness properties. The atomic bundle will buy the ticket or not. Although if it doesn't get committed, then someone else can buy the ticket. In other atomic swap setups based on multiple phases, there are often protocols involving timeouts or some kind of deposit that incentivizes people to not screw it up. But I'm not an expert in this.
00:18:39.010 - 00:18:43.180, Speaker C: Okay, thank you. Cool.
00:18:43.220 - 00:18:45.220, Speaker A: Thanks very much, Isaac. Thank you.
