00:00:09.000 - 00:00:46.408, Speaker A: Hello? But yeah. So catalyst has a unique kind of perspective of aggregating all these different interoperability protocols. And we can say definitively that IBC is the best developer experience. And so I'm going to talk to you guys a little bit more about why we love IBC, kind of from the lens of what you guys know and love, which is like the values. But we'll talk a little bit more concretely about why we think IBC is so excellent for building the next generation of cross chain applications. So, of course, can't talk about IVC without talking about the values. And so we do like IVC for the ethos.
00:00:46.408 - 00:01:19.260, Speaker A: We like it because it's open for missionless. There is such a wide ecosystem of teams that are building standards at all parts of the stack, the transport, the state verification. And at the application layer, we mainly work at the application layer. The separation of those three layers makes it really easy to have innovation in all different pieces. And so you kind of slide them in and out, and that makes it very modular. That kind of clean separation allows, again, that rapid innovation. And again, we mainly do it at the application level.
00:01:19.260 - 00:02:21.666, Speaker A: And then also what's good about IBC beyond the values is the Lindy. And so it is the most battle tested, not going to name numbers on the screen, but it's good. There's ongoing adoption on all the Cosmos app chains, and then we're working as an ecosystem to bring it beyond cosmos, and so bring it into the parachain paradigm as well as within Ethereum and its roll ups. And then there's growing reach, right? Different implementations, different vm specifications. And so it's just good to kind of build an IBC and have other smart teams expand it for you as an application. But that's not today's focus. Today's focus, again, really is on the hard benefits that we, as a protocol, have from building on top of IBC and the smooth developer experience that allows us to have this cross chain automatic liquidity coordination that catalyst is.
00:02:21.666 - 00:03:10.204, Speaker A: And so the three things that I think are really excellent about IBC are the acts and the callbacks, the simple gas payment and then the flexible relayer design. And so I'm double clicking on those. And so before I'll dive deeper into that, I have to explain how Catalyst works, because then you have a better understanding of how IBC kind of slots into the system. And so basically, how catalyst works is you have, again, these sovereign liquidity pools that live on different chains. And so in this case, we have optimism, Mainnet and then we have probably a polygon validium. If you guys watch Polygon v two, they're all about validiums these days. So you have ETH and then you have matic on each of these pools.
00:03:10.204 - 00:04:01.478, Speaker A: And so the first step of the process is, well, step zero of the process is a user wants to move assets, which is what users want to do. And so first step is the user deposits the assets into this op mainnet vault, and then the assets are actually put into escrow. And so we're reserving, we're basically saying we're reserving a portion of the liquidity of this pool for this swap. And then what catalyst does, and this is where all the math comes in, is basically a swap message is generated, basically articulating what we call the amount of liquidity that's been escrowed and deposited into this vault. Right? And so this is basically calculated as, like, some arbitrary value that we hold equal. It doesn't really matter what it is. We call it the unit of liquidity, but we pass that as a message.
00:04:01.478 - 00:04:42.650, Speaker A: And so this is where an interoperability protocol like IBC would come in. But basically we pass that as just a very simple string of bytes and to deliver it on a destination chain in order to complete the swap. And so what happens on a destination chain? You can kind of think of a catalyst vault as kind of a dumb box. It doesn't know what's happening in other chains. It only knows the state of its own local chain. And so it receives that message from the messaging interface and then says, okay, I can now take this arbitrary value units of liquidity and then convert it into something tactical. And so we convert it into number of matic that can then be withdrawn from the target vault and then given into the user's wallet.
00:04:42.650 - 00:05:30.540, Speaker A: And so from the user's perspective, they just sold op and they got polygon or they got matic, rather trivially. And this is extensible to not just polygon, but Cosmos hub to or not cosmos hub, but neutron, because smart contracts, or it could be or eclipse rollups, it could really be spanned into any sort of general purpose vm supporting roll up or app chain. And then as a result, we basically have the ack that shows that this has been delivered into the source chain, and then the escrow is then placed into the vault. And then. Why do I care so much about this escrow? Is because in the instance in which the message is not delivered, the swap fails. It can be not delivered for a number of reasons. If the gas is too high and there's no inclusion on the destination chain.
00:05:30.540 - 00:06:39.060, Speaker A: If there's some sort of timeout, there's some sort of relayer latency, the message could fail. And so why is that important? It's because we still need to deliver the ack back to the source chain and then the escrow is actually released back into the user. And so the power of catalyst is not only the ability to do cross chain swaps, it's actually the atomicity with it, right? Because if something fails, you can actually return that asset and the original asset that the user had back to the user. And so when you look at this in terms of a one hop scenario, not really that interesting, but when you look at it from an n hop scenario where you have to do a number of things, right, you want to do a governance vote on destination chain, you want to hop, hop a number of legs to go to some fourth chain to do some sort of swap, we can revert all of that back because of this acknowledgement, right? And so that kind of ties up to why IBC is so excellent. Because they have acts and callbacks natively included into the actual specification and the round trip delivery of a packet. And I want to stress that other ambs do not have this. They do not have this.
00:06:39.060 - 00:07:35.032, Speaker A: Instead, what they have is what we call a prepaid or a pre call method where they're basically just shooting things into the void. They're like, okay, like I hope, I really hope they have this transaction, but the source chain doesn't have any acknowledgement of that. And so what happens is all the liquidity networks that built on top of other ambs, what happens is if there is a reversion on any of the legs that they have, they're stuck with some sort of intermediary asset, right? So if you guys ever go to the documentation on gotta name names now, but like hop or Stargates or Sushi X, you're gonna go down the faq really, really, really deep and see what happens when my transaction gets reverted and usually says, oh, you'll probably get sushi on a destination chain or USDC on some other chain. And that's not really what the user wants. User wants tight atomicity. They want the original asset on their original chain. But that cannot happen if you're building on other amvs.
00:07:35.032 - 00:08:19.834, Speaker A: And so that's a really good piece about IBC. And again, because of this act, we're able to do things like release the escrow and basically just clean up state on the composite view of the liquidity system. Gas payment. Gas payment is something else that is really clean within IBC. Other Enbs, they kind of have a interesting mechanism where they have like, you know, you have to pay in the destination chain, you have to pay their own native token. But IBC is really helpful because you can basically do the gas payment on the source chain. And this is really helpful because if you guys saw my talk in modular summit, we've been kind of designing this generalizable relayer payment that basically incentivizes a timely delivery of a round trip acknowledgement.
00:08:19.834 - 00:09:35.174, Speaker A: So again, the forward packet, as well as the acknowledgement and gas payments being incredibly simplified and incredibly generalized, like IBC, allows for something like catalyst to slot in which I won't bore you the details on kind of what we're doing, the relayer stuff, but if you're curious, happy to talk about afterwards. It slots in any sort of arbitrary logic on the source chain, and the coordination of payment for it, quite trivially. So that's really good for us as a cross chain liquidity network. And then lastly, relayer design, there's not really a canonical way in which you are passing packets between two domains within IBC, I think there's other interoperability protocols that are much more opinionated about how that's actually going to be constructed. Or even said differently, the implementation or the construction of the implementation of a relayer is very opinionated or very centralized. And obviously because the ethos IBC, that's not the case for us. And so we're actually able to, again, because we think a lot about relayer design, be much more flexible about that, set up a one of n assumption, and actually incentivize the n to be very high, right? Because when people say one of n, they usually mean one of two.
00:09:35.174 - 00:10:17.062, Speaker A: Because there's four validators or four foundations that are running relayers, we rarely mean one of n and having some sort of robust incentivization scheme for the n to be very high. Or we can do a one on one too. And so at Catalyst, we'll be running around relayers as a public good. It won't be the best relayer in the world, but it will get the job done. And we actually want this incentivization scheme that we're shipping to be a function in which our relay is the baseline, but there's going to be much more competition for much more performant relayers on top of it. And so again, very easy to do within the IBC kind of specification. And then lastly, the fee middleware is also something that we like to work closely with.
00:10:17.062 - 00:11:02.498, Speaker A: So ics 29 for, again, this kind of timely delivery of a message, as well as the round trip acknowledgement. So those are the three things that we really like about IVC. Some other things that I think are really awesome that we want to leverage are packaford mirrorware, or some other implementation of doing an n hop path for cross chain swaps. I think over time this will probably evolve to looking more like a enshrined or canonical or transport level multi hop specification for IBC. But right now PFM is pretty good and we want to get our hands on it. And IBC hooks allows for more kind of expressive intents, if you want to use that buzzword. And so that's something that we want to leverage within our system as well.
00:11:02.498 - 00:12:13.936, Speaker A: It pairs really nicely with this atomicity that we've built in within our catalyst transaction flow. Yeah, so that's really what we like about IVC. But I would be remiss if I didn't say things that I enjoy about other Ambs that we would like to start a conversation with about IBC and eventually bring into the IBC specification at all layers. So the first thing is modular verification. And so basically, because IBC has such a kind of clean separation of all three states, we would probably like to see a little bit more innovation as it pertains to the state verification layer of a message. And so right now, you guys are familiar doing native verification using on chain lite clients, but I think there's a design space that opens up for a lot more expressivity on how to user, or how an application, or how a chain want to actually secure their cross chain messages. And so I think polymer is doing a lot of really good work as it pertains to virtual IBC, as it pertains to expanding the scope of what a transaction state verification looks like.
00:12:13.936 - 00:13:25.612, Speaker A: Whether it be a fraud proof, whether it be a validity proof in the form of a snark, whether it be a multisig. So, going back to the ice ages for the sake of exhaustivity, as well as having more expressivity on the consensus mechanisms of a like client. So going beyond comet, BFT, including Gaspar, including Grandpa, or what have you, so that's something that we really like to see. And I think a lot of other protocols, like early bird, by orb labs, or like Hyperlane, they've kind of taken that narrative. And I think IBC can actually slot that in quite trivially because of the clean separation of those three layers. Gas payment for multihop while makes sense right now in the context of IBC, having it be really simple in the source chain does get a little bit confusing when you want other chains or you want relayers that want to be paid in different tokens. And so this is something that we think other Ambs have thought a lot about and hasn't really necessarily been a big conversation within IBC as it pertains to how do you actually have multi token incentivization for relayers and a multi hop context.
00:13:25.612 - 00:14:02.370, Speaker A: And the high level takeaway is that catalysts can be used for it, so we'll be slotting that in in future specifications. And then lastly, not that sexy, but gas refunds also something that we want to do within the context of relay incentivization. And so this is something that we think that other ambs do quite well as well. Cool. I'm at time, I talked a lot about catalysts, but if you want to follow us, we're on Twitter and I'll be here after. If you guys want to talk more about IPC, relayers, liquidity app chains, what have you. So thank you.
