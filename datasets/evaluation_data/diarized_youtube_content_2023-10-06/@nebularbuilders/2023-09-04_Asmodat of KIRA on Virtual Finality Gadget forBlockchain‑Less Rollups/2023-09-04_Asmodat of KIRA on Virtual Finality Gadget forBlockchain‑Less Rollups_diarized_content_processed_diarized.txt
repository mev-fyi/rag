00:00:09.080 - 00:01:04.176, Speaker A: All right. Hello everyone. Today we are going to be talking about virtual finite gadget, which is a mechanism that enables general purpose roll ups to achieve finality on the base layer. And this is non technical talk, actually will be. So if someone is already building their own roll up and connecting their sequencers DA layers from celestial, maybe you will rediscover some new perspective on what roll ups are, how do they, where we can find them and what their use cases and what kind of cool new things we might be able to do with them. It might be a talk for you. And also, if you have no idea what the roll up is, it's probably the good presentation for you.
00:01:04.176 - 00:02:02.176, Speaker A: And so let's begin. We're starting with a formal definition of roll up because it's sort of hard to find a format definition. And most of those concepts most of the time are sort of made up, right? So it's better to formalize something so that we know what we are talking about. And most of the time people talk about like this, something happens off chain, something happens on chain. I try to avoid saying on chain and off chain. I think it's better to talk about on the base layer and off the base layer. So then, because the roll up does not necessarily have to be something created in the context of the blockchain itself, actually with general purpose roll ups, will be experimenting with a concept of the roll up that not necessarily is a blockchain application, has anything to do with a blockchain application.
00:02:02.176 - 00:02:47.970, Speaker A: And. Yeah, so what is a roll up is basically some form of the base layer computation that impacts the state of the base layer. And currently there are quite few different types of roll ups. Like people say, like other, like those optimistic roll ups, pessimistic roll ups like ZK roll ups. Right. What they differ by most of the time is the way we decide how those changes that are occurring off the base layer are finalized on the base layer. So what by that what I mean, for example, in optimistic roll ups, whatever, like that, we commit some proposal for the base layer state change.
00:02:47.970 - 00:03:42.172, Speaker A: We just assume, okay, it's correct. You don't have to verify or say anything, but if you spot that something is wrong, you can submit a fraud proof and be like, hey, something is wrong. Let's not have the state committed. In case of pessimistic roll ups. We talking more. And from the perspective of I don't know if this is correct, like I think it's best that at least n people verify that it is correct and only then the state transitions can occur. And to sort of make our life easier, we will try to introduce something which we call just general roll up, general purpose roll up, something that encompasses both this pessimistic way of achieving finality optimistic way, like it will not matter in our examples.
00:03:42.172 - 00:05:20.280, Speaker A: So maybe let's start with why do we even need it? Why do we need roll ups? If you want to have the centralized network, the decentralized network, which is because what's the point of decentralized network? Their point is to democratize access to finance, right, to money, to unbank the banked, right? And if your blockchain is clogged with state, which is pure malware, like, which is like full of something that is not really useful for you, you still have to pay for it, right? Like if there is like some crappy application running on EVM where anyone can commit the code, right, then you, even if you are not interacting with this application, you still have to pay for it. And in the context of application specific blockchains, it's even more problematic because it takes a long time and a huge effort to actually have your blockchain specific application. It costs millions of dollars to create this application, to have people come together and have all those validators onboarded and raise the money and do your project. Your time to deployment is very long. So with the roll ups, sort of like the expectation is like, hey, we don't even have to care about blockchains. We can deploy applications much faster, much cheaper, right? If we can go down to the cost of deployment, close to Ethereum, right? But we have much more access to much more useful resources. That's where the roll ups will come into play.
00:05:20.280 - 00:06:07.120, Speaker A: And because those EVM chains or whatever other applications, they are pretty limited when it comes to resources. What can you do on EVM? Like, I don't know, a couple of multiplications, write divisions, write something to some register. It's not really that exciting. With Rolla's what we can do, we can plug in any resource we want and have some interesting application. As long as this application is deterministic, we can have something much more powerful running there. So we're going to have an example of a general roll up, and this is going to be our lambda swap example. There is going to be an execution part of the general roll up and there's going to be a verification part of how does this general roll up comes into finalization.
00:06:07.120 - 00:07:38.684, Speaker A: So in our case, the lambo swap application is some sort of deterministic application. What it means for the application to be deterministic it means basically that whenever the same sequence of inputs come into the black box that we have in the middle, the same thing to come out on the other side. And that application could be already running like in our case for quite some time. And we have some state as t minus one, something that happened in the past, and we have two lambos in our lamboswap, right? And maybe there is some new input coming from the base layer chain, and for example, someone is depositing like two rolexes to our lambda swap. And then once our lambo swap gets aware of this, like knows what the auth state is, and gets aware of this new inputs coming in, the user that made this input, maybe he can make some operation. In our case, we have a swap operation, will try to swap to Rolexes for a lambo, and as the result of this computation we might get different outputs of this, depending what kind of roll up that is. We might get some proof of execution if we are using ZK proofs, right? If we are using optimistic roll ups, maybe just like some batch of transactions where the root hash gets committed on the base layer and we just have some new upstate and maybe some possible output that a user can then take off this roll up, which is most often, at least in the EVM represented, like just some smart contract where you lock the assets.
00:07:38.684 - 00:08:27.044, Speaker A: So if you show the proof that Merkel proved that something, that Merkel proved that your withdrawal transaction is included in this root hash, maybe you can take out your lambo. So in our case, we don't know, right? Like we had this state transition, and we don't know if this is correct execution or it's not correct execution. This is the question we have to answer to ourself, right? Was this state correct or not? And like we need some, in this finalization process, some information, right? What information is doing, we need to know what happened. So we need all the inputs that came in. We need order the ordered inputs. In certain case, we don't even need the inputs, we can just have a proof of execution being correct. It is our ZK proof example.
00:08:27.044 - 00:09:16.382, Speaker A: Of course, we need the private state that the application was in. We need the new state of the application and this base layer input. We also need to be aware of all this information to be able to verify it, right? And this verification logic is what allows us to answer, was the state transition of getting this one lambo out correct or not? Right? Like you cannot take three lambos. This doesn't make logical sense. And what interesting, in case of general roll ups, which differentiates them from optimistic, pessimistic roll ups is that this execution part has to be deterministic, the verification part doesn't have to be deterministic. And why we're going to find out a little bit later. And yeah, so let's get back into it.
00:09:16.382 - 00:09:51.558, Speaker A: So if we look from like a high level perspective, all those things are actually the part of the same puzzle. It's all fully recursive. And that's why I started with formal definition, because it, if we define the formal definition as I showed in the first slide, then we find that this definition allows for full recursive. We find out that oh, maybe the optimistic roll ups are a type of a pessimistic roll up in which the number of verifiers is zero. Right? Because we optimistically assuming that it's correct, so we don't need the verifier. So optimistic roll up is a type of a pessimistic roll up. And.
00:09:51.558 - 00:10:35.254, Speaker A: But at the same time we can say like a pessimistic roll up. Maybe it's a subset of something bigger. Maybe it's a subset of some general roll up in which we don't know. There can be n number of verifiers and the code for verification doesn't have to be deterministic. In case of pessimistic and optimistic roll up, we have a very predictable way in which we verify that the application arrived to the state. That makes sense. So when we talk about this, why did I use this word general purpose roll up? Because I want to introduce the concept of like general compute, but general compute in the context of roll up from the concept of blockchain less, completely blockchain less application has couple of problems.
00:10:35.254 - 00:11:14.678, Speaker A: Couple of problems that like normal types of roll ups don't really address. And those are like, they could, but they are not really designed for that. Like you have things like, oh, hey, we don't really need blockchains. We might want to have multiple parties cooperate together and pull up resources. Maybe we would need to have our verification logic to be slightly more fancy because there's a lot of problems with blockchain applications. No application is perfect. It's expected the application might arrive to the state that we didn't expect because we are humans who actually run all those applications.
00:11:14.678 - 00:12:12.228, Speaker A: It's actually our decision, how do we want to interpret what happens on chain? It's better to have a transparent process for this than to have this hidden process where like in Ethereum, dao, oh, if I lose the money, right, it's like oh just working out but if you lose the money oh fuck you. Right? So in this case like what do we, what does it tell us that the verification logic is not logical. This code not always arrive to logical state. And if we have wants to have some cool applications, right? I not type of applications where we say oh, we don't have enough resources on our EvM trying to play this game. What if we duplicate EVM chains to 100 EVM chains? Will that solve a problem? We have 100 roll ups for some session part of the game. It's not really useful. There has to be completely different solution that enables us to have this web two type of applications which are not perfect and games are the best example of that.
00:12:12.228 - 00:13:01.920, Speaker A: If you play something like Minecraft, maybe you are familiar with Moonbeam on Polkadot. You know the game admin still need to have a video stream from you playing the game and in real life. See ok, were you cheating or were you not cheating this game? Because we are interested mostly in humans, we are not really interested in this application itself. We know it's imperfect and that's why we have humans. And we need a way to allow not only verify a code in one specific predefined way, but also enable anyone to decide what is their own logic for unique testing, verificating what is really going on. So here comes the virtual finality gadget to the rescue. I'm going to show at the end how we in particular implemented it.
00:13:01.920 - 00:13:51.058, Speaker A: But anyone can do it. It is like this idea, anyone can take try experiment with for themselves and what we are trying to achieve with the finality gadget we will try to give the developer ability to define the way that he wants to verify his application. Right? Maybe today we're using ZK proofs. Maybe there are some good way to do ZK proofs. But tomorrow there's going to be a new way to do ZK proof and we need to not only be able to update what the application does, but we also need to update how do we verify that this application is running correctly? Maybe there'd be better ways to verify something. So we want to give this power to the developer to as he submits to the chain. Like hey, I want this application to run in this specific way.
00:13:51.058 - 00:14:49.206, Speaker A: Maybe someone picks that work out. We also want to give him ability to like hey, you can also this is the way I suggest you to verify it. But there are many way infinite ways to do so and this is what we're trying to achieve. And when you think about all of this from this perspective, hey, there can be, like, many verifiers, many ways to verify something. Like, we come to the conclusion, yeah, all this thing is fully recursive, right? The blockchains themselves are a fancy case of a general roll up in which you have multiple people collaborating together to create a block. But our fancy verification logic here is basically all people coming together being like, oh, we're running the same thing. So in the simplest case scenario of a blockchain, we just have multiple executors and multiple verifiers that literally rerun the same thing.
00:14:49.206 - 00:15:38.286, Speaker A: It's all fully recursive, it's all part of itself. That's why we need this definition of the roll up to be as defined at the beginning. So we in particular, as we design our application, like our VFG, we are particularly working with roll downs. It's something that you might just have recently heard also from the Polkadot, that they're introducing this concept of a roll down instead of a roll up. And basically, what's the difference between a roll up and a roll down is that roll down is intended very particularly for a monolithic stack of things. You can think about it from like, oh, Microsoft Corporation has its own, like, Excel OneDrive. Like all the tools and things that you need to use your operating system, it's all packaged together.
00:15:38.286 - 00:16:16.448, Speaker A: You cannot expect that, like on your Apple device. You're going to have a great experience with OneDrive and going to work perfectly with everything. It's very hard to have this kind of live in this kind of world where Celestia is like, hey, everyone can build this up. It works with everything. Does this work really in real life scenarios, it's like, maybe if you have billion dollar raise, maybe it's possible. But if you are a smaller project, I'll just exploring this concept for yourself to experiment with something out of the box. Maybe there's a solution for you.
00:16:16.448 - 00:17:03.432, Speaker A: So, in our case, we work specifically with a roll down, is a type of a roll up, which only exists in the context of a monolithic chain. So it's like Polkadot, for example. And I think before we go to our example of how we implemented it, I think it's like we should give a shout out to a couple of people, without which we would never be here. J Kwon and who is the founder of Tendermint and Cosmos, without him, none of us would be here. Celestial wouldn't be here. All the modular nebula summits wouldn't be here. But also, we cannot forget about true creator of the pessimistic roll downs.
00:17:03.432 - 00:17:58.050, Speaker A: A person like started this entire roll up movement. And that's Joseph Poon, the creator of bitcoin lightning. Bitcoin lightning is the very first example of a pessimistic roll up as per definition that we showed before. Bitcoin lightning payments channels is a type of a pessimistic roll down. Where I execution happens off chain like people exchange between themselves transactions and at the end of the day they finalize them by saying ok, this is the final state, we run it off chain for quite some time and maybe there was million transactions happening and now we're just using a single transaction to say this was correct. And on top of that everyone comes to the consensus on yeah, that execution was correct because we committing hashing power and confirming this block over time. And that finalizes this pessimistic roll out.
00:17:58.050 - 00:18:21.686, Speaker A: Which is. Yeah, which is. Which is bitcoin lightning. So this was an example of a pessimistic roll down. And here is our example how we are implementing it. And for Cura in particular, we have, our stack is separated into three components. We have a backend part which we call our blockchain.
00:18:21.686 - 00:19:20.336, Speaker A: Like our base layer, we have a middleware part which we call our interx, it's a shortcut for interchange engines, is a decentralized API which can create fraud proofs that enable anyone to verify, oh, like my RPC request coming from the node that it's supposed to. And if it's incorrect, I can check it against another node and have a fraud proof that it wasn't correct. I can evict the guy because we using governance permissioning to become a validator in our network, you have to be permissioned by the governance of this network. And this way you cannot, you know, once you have malicious actor you can evict them. So in our case, people have money at stake, they also run the middleware at the same time. So if they do something sketchy, then can be kicked out by the community. And on the top of that we have the user interface, which is also decentralized because it's static, it can be hosted in ipfs, you can just download the HTML file, interact with it on your machine.
00:19:20.336 - 00:20:13.736, Speaker A: So as from the front end application running in memory of your browser, you can access the backend through the middle. Where every single part is decentralized is how we intended it, because lite clients were very difficult to maintain, as we see with Polkadot. And on top of that we have our execution part, which is our VFG part, so from the context of our platform, like we don't really care what the type of application is. What do we care is that the application is deterministic. As long as the developer can create a deterministic application, something like for example rest, API server and Python, whatever language you want, we don't really care. Then you can propose that hey guys, I want this application to run specific resources that I need for my application to run. Maybe there's some ML or there's some other AI app.
00:20:13.736 - 00:20:52.770, Speaker A: We don't know what the application is, but hey, I'm specifying in my config, this is the Docker container, the docker image that I want to run. This is the resources I need. Is there anyone who wants to run this application? And our validators can come and be like, hey, I want to run this application. There are some incentives for you because this is also an account abstraction in our case. So our applications are able to interact with the base layer just as if they were normal reserve. They can issue tokens, they can do any operations on the base chain. They could communicate between each other using Xam cross application messaging protocol, which we also developed.
00:20:52.770 - 00:21:25.580, Speaker A: And so that's the execution. You have to be a validator to be an executor. All you do is literally pull the container and run it. And you can also join the network as a verifier. So anyone can be a verifier. If you have an interest in this application, you have some tokens of this application, you can be permissionlessly verifying what this application does. And if you don't have money, you can just be whitelisted by the people, by the owner of the application, which by the way, since it's account abstraction, can be also an application itself.
00:21:25.580 - 00:21:54.564, Speaker A: It's like one way which you can develop your VFG, but there is like literally infinite ways to which this can be done. Like I see like people are already by the window and waiting for their tour. So thank you. And second, like just, you can find us@cura.net work and I don't think they are chasing us away. So if anyone has any questions, the.
00:21:54.732 - 00:21:59.160, Speaker B: Actual application layer and distribution layer is limited to the number of outliers that you can run.
00:22:00.860 - 00:22:44.380, Speaker A: In this case that we, I mean like yeah, so in our case, the way we develop, because you can develop anyway, you are forced to be a validator. To run an application, there has to be at least one executor, right, in order for application to exist. But this single validator can run many applications like nothing stops you. But of course you need to have resources because every application will commit on chain a message like hey, this is my binaries. But those are resources I need. And different validators will have different resources. Some will run I know raspberry PI in Africa.
00:22:44.380 - 00:23:06.970, Speaker A: Here we go back with this flashback of our chain where our chain has to be super lightweight so people can access us anywhere. If you have a gigabyte byte block, sorry, but your network is not decentralized. It's literally impossible. It's pure bullshit. It has to run in Amazon. There are different slashing conditions. Most of proof of stake networks always have that force you to go to a data center.
00:23:06.970 - 00:23:48.732, Speaker A: We want to live in a world which hey, we want to have access to those resources that maybe exist in the data center, but we also want anyone to be able to access networks. You don't have to because you will get evicted by the application owner, the token holders, which will make a proposal because you can abstract the way by default when you start your application. It's sort of like an ethereum. You have an owner of a contract and the owner fully controls it until he gives up his ownership right to maybe token holders or however he coded it. And yeah, so this is what we can do.
00:23:48.836 - 00:23:55.880, Speaker B: Something's pretty cool, and I guess it works out for static and like you mentioned, constraint, I guess applications, we'll go for dynamic applications.
00:23:57.220 - 00:24:37.780, Speaker A: So the cool thing is like we developed our frontend just for our network. This front end is not intended for your application, right? This application has to have its own front end. It can be static, it can be game. We don't know where the heavy work actually happens on your computer because you need the graphics to render something. The game server, I don't know, rpg game will just tell you ok, where are the players? What you should see, what we did however for you is we have this middleware part. This interacts which proxies the request. You can use it as an API of your own, which is proxied.
00:24:37.780 - 00:25:19.330, Speaker A: It orders your transactions. The only limitations we have is basically you have to use HTTP for input because this is the easiest way for us to order those transactions. However for output back to the user you can use TCP UDP protocols. It's not the problem in your configuration. When you say hey, I want this docker container to run, you also have to say, hey, I need this to be proxied and I need this kind of this for UDP, this for TCP. So like when you have your ideal game, maybe you have to okay. Maybe there is streaming when it comes to, like, updating where the players are, but when you comes to you interacting with it, it's just like rpg.
00:25:19.330 - 00:25:38.600, Speaker A: Maybe you just, like, do one click a minute. Right? So the speed is not that important, but at least you have, like, you know, you don't need the blockchain for it, so. Yeah. And since it's recursive, as we talked before. Right. Like, I think the formal definition is much more correct than whatever other people are proposing. Another questions.
00:25:38.600 - 00:25:44.060, Speaker A: All right, so thank you, guys.
