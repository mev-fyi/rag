00:00:07.060 - 00:00:24.810, Speaker A: Okay. Hello, everyone. Welcome to another episode of Stark at home. This time it's very exciting. We will be talking about Starknet. First question, as usual. Is anyone here? Can you hear me? Can you type? Can you see me? Can you hear me? There's a bunch of us here.
00:00:24.810 - 00:01:02.976, Speaker A: Okay, terrific. Yeah, usual mic check. So today, as I said, I'm very excited for this episode because we'll be basically unveiling stuff about Starknet, both as it exists today. And the next steps. We'll be discussing them. And most of the presentation is going to be done by Tom Brand, who's the product manager and blockchain researcher for Starknet. And he's here.
00:01:02.976 - 00:01:45.448, Speaker A: Do you want to wave your hand? Everyone sees you. And Leo Goldberg, who's the engineering lead on the team of both Cairo and Starknet, and also Cairo, co creator. And we'll be basically showing onboarding how to use it, showing a little bit of its capabilities. It's live today. We sent some emails in advance in which you can download it and start playing with it. I just want to recap for those who are not familiar with what Starknet is and what it attempts to accomplish. I want to talk for about roughly ten to 15 minutes about what we're trying to achieve.
00:01:45.448 - 00:02:31.820, Speaker A: Then we'll pause for questions. I'll hand it over to Tom to explain what are the capabilities today, the next steps, the status of it, and then we'll hand it over to Leo, who's going to show us how to write and deploy and interact with Starknet as it is today. And those who already downloaded the software needed for it can also interact with it as we're doing it. So without further ado, and we'll pause just one bureaucratic comment. There's this thing called ask a question. So you should go there, type. So here's a question, typing one, and then we can from time to time go there and answer it and so on.
00:02:31.820 - 00:03:05.992, Speaker A: Okay, so that's better than using the chat room because it's a bit hard to look at the chat room. Okay, so without further ado, I want to talk a little bit about why Starknet. So let's take a step back. Blockchains and ethereum in particular. Blockchains are great. Ethereum is great. Basically gives you this world computer that tracks one single state that everyone can monitor and everyone agrees on its state.
00:03:05.992 - 00:03:45.364, Speaker A: So this is really terrific. And you can deploy any kind of program on it. So there's a lot to love about it. The only problem with it is that everyone wants to use it so it has very limited scale, right? So think of it as a very first computer from the 1980s, with clock rate of one khz or whatnot and very limited memory, and everyone wants to use it. So there's a scalability problem. And while we're all waiting for e 2.0 to arrive and give us more scale, another option is basically to use Ethereum more wisely, only for very certain things.
00:03:45.364 - 00:04:44.936, Speaker A: Basically. Think a good analogy here is that if you have a company, so in a place where the real estate is very expensive, maybe you'll have your office or some flag store or something, but the actual factories will be some other place. So in Manhattan, you're going to put your office and the flag store, but the factories are going to be some other place where it's less expensive. So the analogy here is that you want to use the Ethereum, this very slow but very important machine, only for checking the correctness of vast amounts of computation. And this is precisely what is achieved by stark proofs, also by other kinds of zero knowledge and other kinds of proofs. So they have this amazing ability to exponentially speed up verification of computation. And this is a topic we discussed in many, many other episodes of stark at home.
00:04:44.936 - 00:05:45.060, Speaker A: But for our purposes here, you have this technology or this math and innovation that allows you to have this very slow but important computer that is Ethereum. Verify a proof that attests to a huge amount of computation. Okay, so now we're going to write on Ethereum a smart contract that just checks the correctness of an update to a state. And now you can basically have exponentially more computation taking place, not in the place where the flagship store sits, which is Ethereum layer one, but on this other place, which is layer two. So that's the basic concept of start net. And we still want to have the same feeling of Ethereum, which means anyone can write any smart contract and deploy on it, anyone can submit transactions to it, but you want to have massively greater scale. So this is what basically starknet gives you.
00:05:45.060 - 00:06:26.324, Speaker A: Now, it all sounds nice and dandy, but there are several challenges, and I just want to go over them very briefly and mention them. Some of them we already have resolved, and some of them are very intriguing research questions that maybe we can answer some questions about, but we're still grappling with. So let's go over these quickly. So the first question is, we all know and love Ethereum. The big thing that Ethereum does on top of bitcoin is allow general computation. Bitcoin limits you to very limited kinds of transactions and computations, basically to payments. And Ethereum has opened the floodgate to any kind of computation.
00:06:26.324 - 00:06:29.076, Speaker A: Right. So you have this universality or curing completeness.
00:06:29.188 - 00:06:29.464, Speaker B: Good.
00:06:29.502 - 00:07:42.304, Speaker A: We would like also to have curing completeness. And the issue is that all of this fancy, innovative math that goes into producing and verifying a stark is very computationally intensive and initially required, or seems to require a lot of math ingenuity in order to sort of get it right. So how do we bridge the gap between developers who just want to write code, but just have much greater scalability and all of this math that goes into it? So the answer, and this is one of the issues that have been already resolved, is offer a programming language that is the sort of Goldilocks principle or the just right programming language for the problem here. So every programming language is some optimization between various constraints. You want it to be efficient, you want it to be expressive, you want it to be easy to write. And in our context, the thing you want to optimize is the sort of the footprint in terms of proving. So you want to have full functionality of a programming language, you want to have Turing completeness, but at the same time you want the proofs to be efficient enough.
00:07:42.304 - 00:08:00.692, Speaker A: And I said there are several challenges. Some have been resolved and some have not. This has been resolved. This is Cairo. So Cairo is a Turing complete language, allows you to write any program. It's pretty convenient to work with, and we'll need it more here. We also did a bunch of episodes discussing it in the past.
00:08:00.692 - 00:08:29.488, Speaker A: So, problem one, universality, we have that covered. Okay. The next problem is one that we have an initial solution, but actually it's very interesting, and we don't quite know how to deal with it. Okay, so proof systems are really good at compressing computation exponentially, right? So there's one prover generates a proof. Everyone verifies that at logarithmic time. Great. But what about, if you look at Ethereum cost, there are three things that you're charged for.
00:08:29.488 - 00:08:49.316, Speaker A: There's the witness link, or the transmission or call data, right? There's the computation and there's the storage. Okay, so now proofs definitely remove the computation. That's great. But the witness and especially the storage are not affected in a similar way.
00:08:49.418 - 00:08:49.828, Speaker B: Right.
00:08:49.914 - 00:09:39.328, Speaker A: And now this poses this big challenge. If you want to scale Ethereum 100 x, you want to scale on all fronts. You want to scale the storage, you want to scale the computation, you want to scale the transmission. So we said that computation has been solved, but what about the storage and the transmission, especially storage. So right now we already have two kinds of solutions on our other systems, right? It's sort of a trade off world. You can either go with a ZK roll up, which means that you put all of the state updates on Ethereum, and then you can slightly, maybe compress, but there is a limit, an information theoretic limit, to how much you can compress, and then you can also not put all of the data on chain. This is something like validium or volition, or there are other solutions of this nature.
00:09:39.328 - 00:10:20.710, Speaker A: And then you sort of remove the scalability problem from l one, but you're starting to compromise potentially on the security assumption. Do you need to rely only on l one or do you need to rely on other things? Okay, so I just want to mention that this is a question and a point of tension in our design space, and all three of us are happy to answer questions about it. But there is a trade off here. If you want all of the security of l one with respect to storage, there's going to be an inherent limit that proofs are not going to help you break through. Right. You need some other means. So that's a question that we're grappling with.
00:10:20.710 - 00:11:11.190, Speaker A: Another question is there's this trade off in the update rate. The longer you wait with an epoch till you put a proof for the new state update, the more you can compress stuff, the more that you scale. But there also is lesser finality, or the time to finality is slightly longer. Okay, so there's this trade off, and there are interesting questions here about how you can get the best of both worlds. Both have very large proofs, very long epochs that allow you to compress more, even the state of the computation, and at the same time also have instant finality and allow people to come in and off of the network. And maybe Tom and his part is going to elaborate on that, because he wrote a very interesting research post about this and offering some solutions. That's another question.
00:11:11.190 - 00:12:13.976, Speaker A: And then in terms of another very important question when designing layer twos, and it's no different for ours, is the question of using crypto economic incentives in order to align the various players to solve problems such as data availability, the availability of provers in a decentralized world, the availability of storage and distribution of it. This is another extremely interesting question that all layer two s are discussing, and we're thinking about it as well. So I just wanted to mention some of the challenges. Now I'm going to pause here, see if there are any questions so I see in the chat, but please use the ask a question. So the question will it be recorded? Yes, all of the crowdcast episodes are recorded and that's okay. Someone is asking why can't solidity be used? That's a really terrific question. Maybe Leo, do you want to answer that?
00:12:14.158 - 00:13:06.120, Speaker B: Yeah. So solidity, you will be able to use solidity eventually. Hopefully you can compile solidity to Cairo. You will be able to compile once such a compiler is available. But solidity can't be used as the basic language, as the primitive block, basically because it doesn't fit. So for example, the primitive types in solidity are 256 bit integers. In order to generate star poops, you need field elements, not integers.
00:13:06.120 - 00:13:55.812, Speaker B: And solidity wasn't built to be efficient for poof generation. So this is the reason why solidity can't be the basic language. But you can write compilers from solidity to Cairo. Because Cairo is incomplete, you can do basically anything with it. However, it will be much more efficient to write things directly in Cairo, at least until the compilers from solidity will be really optimized. Until that point, it will be much more efficient to write contracts in Cairo.
00:13:55.956 - 00:14:04.190, Speaker A: Maybe you want to say Tommy, do you want to say a word about the community effort for building compilers and then also segue into your part?
00:14:04.800 - 00:14:05.596, Speaker B: Sure.
00:14:05.778 - 00:14:27.520, Speaker C: So hi everybody. Actually, we worked on an EVM to Cairo compiler in house recently, which is formerly two days ago an external team started working on it. It's a team from the Nethermind.
00:14:29.400 - 00:14:30.080, Speaker B: Organization.
00:14:30.160 - 00:15:08.460, Speaker C: Which is called Nubia. We started working on Cairo I think almost four months ago, and now actually took the initiative and started working on an EVM to Cairo compiler. And hopefully soon enough we'll be able to see the first results. And as soon as we have something we will share it publicly again. It probably will allow, at least at first, some compilation from solidity contracts to start. Net contract, but it will have its limitations.
00:15:09.940 - 00:15:38.408, Speaker B: Yeah, probably. Even then you should remember that writing an l two contract is not the same as writing an l one contract. It's not just the question of the language. Yes, for example, you have to take care of communicating between l one and l two, which you obviously don't need if you are working within l one. And this is just one example.
00:15:38.574 - 00:16:08.636, Speaker C: And also, as Alice mentioned, the biggest saving comes from computation. So stuff that are impossible on solidity and many workarounds are created in order to avoid them are very cheap on Ezekiel, on startnet, and so the architecture or the properties that you want to minimize for are different and so different things can be achieved. Yeah.
00:16:08.678 - 00:16:17.972, Speaker B: So maybe an efficient solidity code will not necessarily be translated to an efficient chiropode. You may need an unefficient solidity code.
00:16:18.026 - 00:16:24.468, Speaker C: To generate better chiropode because the objectives.
00:16:24.644 - 00:16:25.930, Speaker B: Are not the same.
00:16:26.460 - 00:17:39.680, Speaker C: And I can give an example for that for something that we from experience that we had in house. So I will mention it in a few minutes. But Bydx deployed an April layer two system based on our technology, and basically what they did together with us is they rewrote their solidity contracts in Cairo. And the very beautiful thing that it allowed them to do is to offer properties that were not possible on the solidity system. For example, when the system was on l one, an oracle price to monitor the position liquidation was updated on chain about every ten minutes or so. And now in the system, because it almost costs nothing, an oracle update is sent before each transaction. So the immediate effect it had on the system is the ability to offer much larger margin.
00:17:39.680 - 00:17:43.744, Speaker C: And there are many other examples on the IDEx system.
00:17:43.862 - 00:18:07.736, Speaker A: Okay, there's another question maybe you want to answer, so. And thanks for the question. Leo, please use the ask a question button. So I'll read it. I'm guessing the focus is on scalability right now, but I was wondering if privacy could be achieved in the future. Wants to take it? I think you should take it.
00:18:07.758 - 00:19:06.300, Speaker C: Okay, so yes, darkness in a sense, Zk rollup is a very misleading name. I didn't invent it, but I use it. But in any case, Zk rollup has nothing to do with zero knowledge. It does use ZK proofs, which is also a misleading name. And the actual name that we use for them are validity proofs. And indeed stark proofs has the property that they allow scalability for computation, but they can also offer the property of zero knowledge, meaning no information is revealed about the computation other than the statement that is being proved. So startnet as a system is not designed to be privacy oriented, meaning, for example, all the state updates are published on chain.
00:19:06.300 - 00:20:04.350, Speaker C: Of course the sequencer and the pools are well aware for all the inputs to all the transactions. So there's no privacy in that sense. And there's no like a magic property we can just activate and then it will be zero knowledge because the design of the protocol is inherently different. But there will be the possibility to build privacy applications on top of Starknet, which will be much more cheaper than what they are on Ethereum. So for example, Aztec are building. Aztec is a well known company on the Ethereum ecosystem that are building privacy applications on top of Ethereum. They basically use zero knowledge proofs, actual zero knowledge proofs, in order to provide this property.
00:20:04.350 - 00:20:29.220, Speaker C: But it's an application that is built on top of the Ethereum protocol. And those kind of applications can also be built on top of Starknet. And the main advantages for those kind of applications is that the most expensive things about those protocols is the verification of the proofs. And as we said, computation will be much more cheaper and starting to be much more feasible to build those kinds of applications.
00:20:31.260 - 00:20:39.190, Speaker A: Do you want to say maybe a word about the combination of recursion privacy and some future versions of your.
00:20:43.600 - 00:22:03.270, Speaker B: Okay, so I'll start by slightly repeating what Tom said. Basically, in order to get real privacy, you need two things. You need the proof to be zero knowledge. This part is pretty easy with start, and you need the protocol to allow privacy. So if the protocol, for example, by definition reveals information, for example, the balances are kept on chain, then it won't help if the pool is not revealing any more information because we already revealed too much. Now let's say that I fixed it and now the protocol is also private. Still, the user can't send raw data to the miners, to the operator, or sequences, depending on how you want to call them, because then the operator will know the data.
00:22:03.270 - 00:22:53.460, Speaker B: So this is also not good. The only possible case is that the users themselves will generate proofs and put these proofs on chain. And now there's a question. Once the user generated the proof themselves, if the proof has zero knowledge, their data is not revealed. Okay, now there's the question of scalability. If every user generates a proof, putting the proof will cost more than putting the original transaction on Ethereum. So we will lose privacy, we lose scalability.
00:22:53.460 - 00:23:37.440, Speaker B: So what we need is both. We need a scalability engine that can take a lot of proof and prove that all these proofs are valid. And this is called recursive start, when you have a very fact, a proof that proves that you saw another proof. So we'll need this to, to have privacy. Eventually we will have it. But as you said in the question, we can't be focused on scalability.
00:23:38.280 - 00:23:40.230, Speaker A: Okay, so, Tom, your turn.
00:23:41.000 - 00:24:41.430, Speaker C: Okay, so thank you for your. Yeah, Ellie gave an introduction. I will dive a little bit deeper into what is Starknet, what is the roadmap, how we plan to reach it, and where we are today and what are the immediate milestones. So just to formally state it, Starknet, the vision we're building toward it is a permissionless decentralized ekola that operates as a network, a layer two network on top of Ethereum. And the functionality that it will offer is basically an Ethereum like state in the sense that state will have contracts and they will have storage and users will be able to deploy contracts and send transactions to those contracts and those contracts will be able to interact with each other. This is darknet. I think it defines it pretty well.
00:24:41.430 - 00:25:58.732, Speaker C: And what's nice about Starknet and what we're doing here is that it lies on a very solid foundation. So first of all, as Eddie said, it will be written in Cairo and Cairo has been in production. Mean our first use of Ethan Mainet was in July last year and it operates Darkex since November. So it is a language that we developed and we are ourselves using it in our products. It also relies on stock pools which are on our stock pools which again are in production since even before, yeah, even before I think June 19. And I mean they have some of the Guinness records for generating proofs. And actually as we speak today, 500K NFT means proofs are being generated and verified on chain for immutable and we expect by the end of the week to mint between 3.5
00:25:58.732 - 00:26:49.904, Speaker C: to 7 million nfts. And this will also power Starknet. And lastly we have Starkx, which is our original product, which is also in production. And Starkx is through the life of Starkware. Starkx was our way to always take the technology that we are developing and put it into a real world use case. So it was the case with the provost, it was the case with Cairo, and it will also be the case with Starknet. We plan to migrate Starkx maybe as the first application to Starknet and to make sure that it actually can achieve what we demand from our product.
00:26:49.904 - 00:27:56.580, Speaker C: Okay, so this is the foundations of Startnet and the roadmap or the plan for us to go to startnet starts, let's say in a stepwise operation, in a stepwise process from the building blocks to the whole system. So the first step which was actually published to the public last week, I think Monday, last week is what we call planets. And the first building block that we develop is Starknet contract. So what was published on Monday is basically a hosted service. Maybe I will start by saying that we chose to share with you, with all the community, a work as we process. So we don't share a full working system. We share our latest state of development.
00:27:56.580 - 00:29:08.028, Speaker C: And what we have today is basically a hosted service that allows anyone to write a contract, deploy them, send transactions to those contracts that interact with them. And all this operation, the deployment of the contract and the transactions that interact with them are batched together and approved, pulled off chain and then verified on chain. And the state is basically updated on layer one. So this is where we are today and this is the first step. And the second step that we are aiming for is basically to take this building block and expand it to the full functionality of startup. What I mean by that? I mean that we will offer the full state functionality, meaning contracts that can interact with each other, that can interact with l one, that have their state update, have their storage posted on chain, basically all the required functionality that will allow applications to work on Startnet. So this is the next phase that we're aiming for.
00:29:08.028 - 00:30:10.956, Speaker C: We hope to have an MVP version of it on Mainet by the end of this year. And again, the way we plan to progress throughout the coming months is that once we will have one of these features in a form that we can share it as a working feature, we will update the public alpha and allow developers to start experimenting with it. And hopefully, and this is really our biggest hope, to also start, give us feedback and say the way you did, it works, it doesn't work. We're missing that. Just today I received a telegram message from a developer that interacted with the system and he said, I really want to write contracts but it's really hard to test them. So I understand what he's saying and it's a really good feedback. We're also working on having some testing tools published.
00:30:10.956 - 00:31:16.740, Speaker C: So this is the second step, we call it constellation. And the last step will be to take this fully functional starknet and to decentralize and make the operation level permissionless, meaning more concurrently to add some leader election mechanism to the sequencer which will allow permissionless operations of the sequencer and we expect to reach this phase somewhere next year. Let's see that. I haven't forgot anything. Yes, maybe just a word on the ecosystem. So as I've said before, we have the Nethermind team working on EVM to Cairo compiler and generally we are working very closely with them and it's been a pleasure. We also have the Turbo guest team which is now renamed to Eregon working on the full node stack and the network level of Starknet.
00:31:16.740 - 00:31:44.750, Speaker C: By the way, both of those teams are hiring and generally speaking anyone who wants to contribute to the Starknet ecosystem and tooling. We are really happy to work with external parties and teams and you are very welcome to reach out. Okay, so this is what I have to say. Let's see if you have.
00:31:47.040 - 00:32:17.530, Speaker A: Do you see the questions? I can read them. Okay, so the first question, there are two questions right now by Johann Birnick. Very good one. But also please, if others have questions, please type them in. Okay, so the first question can you say something concerning documentation also of Starkx, Cairo, et cetera. I am interested in how all of your stuff works and I want to find bugs and issues, but it seems that nowhere it is explained how all this works in detail.
00:32:18.700 - 00:32:59.364, Speaker C: Okay, it's a good question. I will happily share it here in the chat. But for Starkex there is pretty extensive documentation and also the on chain contracts and the verifier and also the Cairo program. Everything is open source. Also for Cairo there's a pretty extensive documentation and actually Dior, when he's not on this crowdcast, is working hard to release the caio white paper. White paper?
00:32:59.482 - 00:33:00.388, Speaker B: Just paper?
00:33:00.554 - 00:33:54.676, Speaker C: Yeah, something which will mean, I won't say, will hopefully be out soon and it will detail the full architecture and how Cairo operates for Starknet. Again, as I've said, it's not a working system and we chose to release stuff soon. So one of the drawbacks of this decision is that not everything is documented. We did publish tutorials that explain how to interact or what is the structure of starknet contracts, but we indeed still haven't published, for example the Starknet os Kyo program, which is basically what operates Starknet and haven't documented its architecture.
00:33:54.868 - 00:33:55.610, Speaker B: But.
00:33:57.420 - 00:34:04.620, Speaker C: I will say a few things. One, Startnet will be fully open source, meaning both the node infrastructure.
00:34:06.880 - 00:34:07.436, Speaker A: All the.
00:34:07.458 - 00:34:20.960, Speaker C: Chiracode, all of those stuff will be open source. And once of course we will expect someone to actually use it. It better be well documented.
00:34:22.980 - 00:34:30.516, Speaker A: I'll just say that in the chat we'll soon just put in a bunch of links for whatever we have right now about Cairo, et cetera and these things.
00:34:30.538 - 00:34:54.040, Speaker C: Okay, I will just add that the best way to talk about those kinds of topics is through our discord server. And one, you can ask questions there. And two, if there is a missing documentation, I will be happy to hear after you go over what I will link here, I will be happy to hear what is missing.
00:34:54.540 - 00:35:12.524, Speaker A: Okay, next question also by Joan Birmingh. Is it true that currently also in starkx there is no open source prover and verifier so everybody can check integrity? To me it seems like one has to use a shared proverb. Nobody can verify whether the proving system is secure.
00:35:12.652 - 00:36:37.848, Speaker B: I want to answer. Okay, first the verifier is open. Actually it's a solidity contract, so you can check it. The question of the proverb is actually if you need to check the prover code in order to know if the system is secure, then it means that the protocol between the proverb and the verifier is the wrong one. The idea of approver verifier system is that once the verifier is that all you need to do is check that the verifier follows the protocol and then even if the poverty is malicious, you won't be able to generate proof that the verifier accepts unless the proofs are actually valid. Once you have approval verifier system, you don't need to check the code of the proverb. Eventually we may publish the proverb code in order to allow decentralization with darkness.
00:36:37.848 - 00:36:49.580, Speaker B: But if the question is about soundness, then it's not necessary. If it were necessary, then the entire system wouldn't be sound by definition.
00:36:49.740 - 00:37:35.672, Speaker A: I'll just add that we have for now roughly more than a year, or roughly a year, open source approver and verifier and documentation. I'll share the link both for zero knowledge, stark and for Stark for a bunch of things. And when Starknet is released, it's very likely that the proverb for Starknet that will be shared source available will be based on that system. Right? So there's a lot of stuff and we'll share some resources. Okay, next question. Okay, I don't know who it is, but someone is asking or saying very excited for ZK stars. Yay.
00:37:35.672 - 00:37:45.952, Speaker A: So are we, is it possible to write zero knowledge contracts with a current Cairo tool chain or is zero knowledge support still in the works? Who wants to answer?
00:37:46.086 - 00:38:06.776, Speaker B: So it's a similar question to the question about privacy. Currently. I think you can't at least easily write a contract that verifies a zero knowledge group, but you will be able to do it in the future. Do you want to add anything?
00:38:06.878 - 00:38:08.120, Speaker C: What is missing?
00:38:09.580 - 00:38:25.400, Speaker B: So catch up. You need a good hash function in terms of x 86 speed in order to efficiently.
00:38:27.940 - 00:38:56.712, Speaker A: I want to add that as part of e Stark code base. There's also a zero knowledge prover and verifier there, and including a signature scheme that's post quantum secure and the code is open source. You're welcome to look at it again. So the adding zero knowledge takes some time, but it's not the big issue. The point is that you want privacy, not just zero knowledge. And the way Cairo infrastructure right now is built in Starknet, you won't get privacy even if you make the proof zero knowledge. You want a little bit more.
00:38:56.712 - 00:39:23.916, Speaker A: And that more is what Leo was referring to. And of course we'll get there. Okay, next question. So terrific that there are a lot of questions. Okay, next question. How to join the starknet testnet as one of the validator based on the proof of stake consensus as known, it could be a permissionless network. Who wants to answer this? So someone wants to join the validator set for zero knowledge.
00:39:23.916 - 00:39:25.760, Speaker A: Sorry for starter.
00:39:28.360 - 00:40:37.336, Speaker C: Okay, so there's no need by definition to have a proof of stake consensus for a ZK wallet. Actually the consensus rule. So what is the consensus rule? For example, on Ethereum, the longest chain, right? If we all want to agree, what is the correct chain, what's the correct state? Then the consensus rule says that the longest chain, meaning that the chain that the most work was put into it is the correct chain. Now on layer two, we get to enjoy ethereum, layer one. And it is actually the consensus rule. What do I mean by that? On l one, you have a contract, which is the startnet contract. And when we want to update the state of the system, what we actually do is we are calling an update state function on this contract and only if this call is accepted, meaning a state was updated, let's say from s one to s two.
00:40:37.336 - 00:41:49.090, Speaker C: Then the state of the system is advanced, meaning we don't need to have another consensus protocol, let's say side chain, in order to agree on what is the correct state. And the beauty of Zika rollup is that on these state updates, there is no assumption other than the fact that the proof was verified and accepted. And so the state transition is correct. Okay, so going back to your question, currently there is no proof of state consensus. There might be a leader election mechanism which will allow to choose at each time who is the sequencer that can update the state of the system. And we're still debating on what kind of leader election mechanism will it be. Will it be a proof of stake mechanism or will it be something which is more similar to how Hermes are doing their leader election mechanism, which is a very nice auction mechanism on l one.
00:41:49.090 - 00:41:54.800, Speaker C: So currently there's no proof of stake consensus.
00:41:56.900 - 00:41:58.576, Speaker A: Okay, next question.
00:41:58.758 - 00:42:02.352, Speaker B: There is reply on the chat.
00:42:02.496 - 00:42:03.092, Speaker C: Yes.
00:42:03.226 - 00:42:26.808, Speaker B: So if you have two conflicting transactions. Yes. Okay, so I think that we'll answer nevertheless. So if you have two conflicting transactions, then the operator or the sequencer will decide which comes first. This is very similar to the way it is in Ethereum.
00:42:26.984 - 00:42:47.312, Speaker C: Yeah, so the sequencer of a specific time is equivalent to the miner, right? So a miner decides which transactions to include in the block, and the equivalent to that in starknet is the sequencer which decides which transactions to include in the block and then generate a proof to this block and publish this proof on l one.
00:42:47.446 - 00:42:52.176, Speaker A: Okay, next question. Can you explain? And maybe. Okay, we'll try to answer briefly because.
00:42:52.198 - 00:42:54.580, Speaker C: I want to have time for the demo.
00:42:54.650 - 00:43:11.272, Speaker A: Yes. Okay, can you explain? So we'll take all of the questions, but answer briefly. Can you explain the Ethereum to start net bridge, e. G. Converting from Ethel one to Ethel two? What makes it secure? Is there some scenario where you can bridge back to l one for some reason?
00:43:11.406 - 00:43:12.932, Speaker C: Terrific question. Very timely.
00:43:12.996 - 00:43:13.476, Speaker A: Right.
00:43:13.598 - 00:43:25.884, Speaker C: I guess the question is where you can't bridge is. Okay, so basically the way we. Do you want to explain?
00:43:25.922 - 00:43:28.268, Speaker B: Do you want me to explain? Go ahead.
00:43:28.354 - 00:44:37.696, Speaker C: Okay, so the way to interact between l one and l two, which would also be the underlying mechanism to construct this bridge, for example, of transferring it from l one to l two, is a general messaging protocol that allows contracts on l one to send messages to contracts on l two, and vice versa. Contracts on L two can send messages to contracts on l one. And basically with this primitive, you can implement any kind of logic you want in the bridge. So for example, how it will operate in an bridge, a user will want to send ether from l one to l two. What they will actually do is they will call a function on the l one site bridge. It will lock the ether on this contract and will send a message to the other part of the bridge on L two, which says, hi, it's me. Your other part on L one, you recognize me? This address deposited this amount of ether.
00:44:37.696 - 00:45:21.344, Speaker C: Please credit it on the l two side. And once the message will arrive on the l two side, the contract will check its validity, meaning it actually arrived from the correct other token bridge by identifying its address. And once everything is correct, it will mint to the address on L two the same amount of detail. And same goes for the other way around. Now you're asking if there's a scenario where you can't bridge back to l one. For some reason, there is no such scenario. Maybe a bug, but generally speaking, by the protocol, there is no such scenario.
00:45:21.344 - 00:45:33.956, Speaker C: And there's no signature from some kind of operator that needs to sign or admit this transaction. The only problem that can be is.
00:45:33.978 - 00:45:34.870, Speaker B: That if.
00:45:37.640 - 00:46:16.692, Speaker C: You'Re being sensor, meaning you cannot send the transactions that transfer it. But since the sequencer layer of Stocknet is permissionless then the same way that you have censorship resistance on Ethereum, you will have it also on stocknet. So I hope it will answer. And this also answered the question from Bruno. Yes, Stagnet will be decentralized. And as I've said in previous questions, a contender's protocol to achieve decentralization is an active research topic. We have few very good options that we still need to understand what will fit.
00:46:16.692 - 00:46:18.692, Speaker C: Mostly a ZK roll up system.
00:46:18.826 - 00:46:34.540, Speaker A: The last question will be a great segue to Leo. Right, so the question by Arad is this, as someone who hasn't gotten into Cairo yet and knows a very basic amount of solidity, will I have trouble diving deep into Cairo, having no extensive knowledge, experience with solidity?
00:46:37.760 - 00:47:18.410, Speaker B: The short answer is no, you don't need to know solidity in order to learn chiral. You can just go look at the tutorials and start writing Chiro code. I'm going to follow actually now the tutorials of Starknet and we are going to deploy together and interact with starknet contract. So first let me share my screen. Okay, can you see my screen?
00:47:19.260 - 00:47:21.816, Speaker A: Someone can type. I can see your screen.
00:47:21.998 - 00:47:22.730, Speaker B: Yeah.
00:47:24.300 - 00:47:28.908, Speaker C: There is a few seconds delay between what you're saying and when they hear it.
00:47:28.994 - 00:48:02.410, Speaker B: Okay, so I'll start. And if you can't see my screen, please let us know. Okay, so this is the Starknet tutorial. It's currently part of the Cairo documentation. So you also have here the low Cairo, which is, if you don't know Cairo, take a look first, at least on the first few pages. And I'm going to look at this tutorial. So let's just dive in.
00:48:02.410 - 00:48:22.910, Speaker B: I have here a very simple starknet contract. Yeah, I'll increase the font size in a second. Okay, how is this?
00:48:23.440 - 00:48:24.476, Speaker A: Yeah, I think this is good.
00:48:24.498 - 00:48:54.730, Speaker B: This is good. Okay, let's save this file. Save this file. Contract Cairo. Okay, so this is a very basic starknet contract written in Cairo. Let's quickly go over it. We have the Lang starknet, which says this is a starnet contract and not a regular Cairo program.
00:48:54.730 - 00:49:22.560, Speaker B: There is a difference. I won't go into it. We have the list of built ins which if you are familiar with Cairo. So this means basically that I can use that Peter ten hash function. I have a few import lines. And now let's go to the more interesting stuff. We have a storage variable named balance.
00:49:22.560 - 00:50:01.996, Speaker B: I can, and I hope that I will have time to demonstrate how I can add arguments here. But currently balance is a single storage variable which can contain a field element. And we can think of a field element as an integer. So I have a balance in this contract, and I have two functions. Both are marked. One is as external function, one is a view function. So let's start with this one.
00:50:01.996 - 00:50:54.476, Speaker B: It's called increase balance. Ignore this built in path. It gets an amount and it does really the simplest thing, it takes the balance and read it. So you get the read and write function from this storage VAR decorator that we had here. So we have balance, read this, reads the value of the storage variable. And next we just write the value that we've just got and edit the amount that we got in the function argument. And we have get balance, which is even simpler, just reads the value and returns it.
00:50:54.476 - 00:51:35.132, Speaker B: Okay, so I have this contract. Let's try to deploy it. Actually before deploying, let's compile it. So I'll use the starnet compile. By the way, in order to install the starknet utilities, just follow the setting up the environment page of Cairo. It will install both Cairo compiler and the starknet compiler and the starknet command line interface. And basically you can do whatever I'm doing with me, it should work.
00:51:35.132 - 00:52:05.012, Speaker B: If it doesn't, let us know on this code. Okay, so I'm going to compile the contract. By the way, Tom, if there are questions, I can see them, so let me know. Thanks. And let's contract compile. I want the output to be in a file called contract compiled. And I want to get the ABI of the function.
00:52:05.012 - 00:52:53.952, Speaker B: The ABI is basically. I can show you, it's just very similar to Ethereum. It's just a list of functions and the input arguments of every function. And I have the contact compiled, which is the result of the compilation. Okay, so I have the starknet deploy command line which gets actually, before using the stagnet deploy, I will define starknet network environment variable and set it to Alpha. This will save me typing the Alpha network every time I deploy. Okay, so we want to deploy.
00:52:53.952 - 00:53:19.020, Speaker B: I have to give it the compiled contract and that's it. Okay, now let's wait. I got the new contract address. This is the address of my contract. I have a transaction id. This is the deployment transaction. And I can query the status of the transaction using again the CLI.
00:53:19.020 - 00:54:10.492, Speaker B: So let's do great. So if you see transaction status pending, it means that it was added to a block, which is good, but it is still not accepted on chain. So the proof is not necessarily generated. After each block. We can take a few blocks and generate one proof for it. So it may take a few minutes until it gets accepted on chain, but we can work with it right now. So let's have a look at that.
00:54:10.492 - 00:54:45.224, Speaker B: Sorry, just 1 second. At the starknet planets alpha block explorer, this was developed by Nethermind and it basically shows the blocks and the transaction. And for example it says here that the block was twelve 974. So this was the block and my transaction number was the one with the 41 at the end.
00:54:45.262 - 00:54:46.136, Speaker A: Okay, great.
00:54:46.238 - 00:55:28.390, Speaker B: So this is my transaction, this is a deploy transaction and I can take a look at the contract. Let's see. So here I have the get balance function. If you remember, we had two functions, get balance and encrypt balance. Now, increase balance is a function that changes the state so it's marked as external. So I won't be able to see if it lists now in the blockchain explorer, but view functions I can, and I can just run it, there are no arguments. Let's see.
00:55:28.390 - 00:55:55.870, Speaker B: Yeah, okay, great. So the result is zero. This is because I had a storage variable. By default everything starts from zero and I didn't change it. So let's do that. Let's change the balance. So I'll use the starknet invoke to do that.
00:55:55.870 - 00:56:29.290, Speaker B: I need to give it. Okay, let's start. Actually, I need to give it the address of the contact, I need to give it the function name, which is increase balance. I need to give it the input. So the input is the amount. Let's go with three, two, one. And I need to give it the ABI file that I generated by compiling the contract so it will know what to do with the name of the function.
00:56:29.290 - 00:57:05.612, Speaker B: And I think that that's it. We'll see. No, it wants something else. One secondary sign or space, not both. Okay. And I can query the status of this transaction as well. Let's see what's going on with it.
00:57:05.612 - 00:57:47.770, Speaker B: By the way, everything that I'm showing is basically written in the hello start. Net tutorial. So if you don't follow, you can always go and check it out. Okay, pending, which means that it got into a block. Let's go to the state and click on query again. And yes, the result is now updated to three to one. Okay, so I think that we are out of time.
00:57:48.780 - 00:57:50.510, Speaker A: Let's answer a few questions.
00:57:52.400 - 00:58:06.850, Speaker B: If I had more time I would change the contract instead of having one balance, having a balance per user. But you can take a look at the tutorial and follow it yourself.
00:58:09.700 - 00:58:29.530, Speaker A: I'm going to create a poll. Should we continue after answering the questions and then we'll see if there are enough people who want to continue. We'll go a little bit longer. If not, should we continue after questions? And Leo, if you have more time, what would you talk about?
00:58:30.380 - 00:58:42.660, Speaker B: So I would change this contract and add it instead of one balance, multiple balances balance per each user and add signature verification.
00:58:42.740 - 00:59:41.660, Speaker A: Okay, so we'll answer a question and then you see there's a Paul button. So please press and we'll just go along with whatever people want. Okay, so question number one by David is there a killer feature that differentiates starknet from other l two solutions? In other words, what would a dev team gain by switching from their current stack, e. G. Solidity to Cairo net to Starknet Cairo? I want to try and answer this, so I think there are many, many reasons to switch from your current stack to Starknet and Cairo. The simplest reason is, look, your solidity code, which you wrote, you worked very hard to minimize the gas cost, and because of that you had to cut many corners and optimize things. Why? Because ethereum is very compute constrained.
00:59:41.660 - 01:00:43.196, Speaker A: Now, by moving to an l two, the main benefit that any l two is going to give you is basically it's going to tell you, look, you have vastly more compute at no cost or at almost no cost. So even if you wrote everything in solidity, the reason you're moving to l two is to harness that. So you're going to rewrite your code pretty much from scratch, right, in order to get that. And when you do that, you want to do it in a way that gives you maximal scalability, okay? Generally speaking, even if you're going to move it to some other evm compatible l two, you're going to very quickly want to rewrite things, okay? And that's just one reason. Another reason is that l one and l two are not really the same. So you're going to need to rewrite many parts to get the thing secure again. You need to run through a new set of audits.
01:00:43.196 - 01:01:17.260, Speaker A: The state is very different than syncing it. This is true for ZK roll ups and optimistic roll ups. So you're going to need to rewrite and re audit your code, period. So you might as well do it in a way that maximizes the benefits. Now, Starknet, first of all, as you see for yourself, it's right now available for developers. I think that massive scale will be the thing you'll get first on startnet before anything else. Moreover, you're going to rewrite a lot of stuff to get this vastly greater scale.
01:01:17.260 - 01:01:55.096, Speaker A: Optimistic roll ups are very limited in the total amount of scale that they can boost ethereum by. Right? And this comes from a variety of reasons. It's not just the capital inefficiency, it's also the fact that all of the witness data and the storage must be presented on Ethereum all of the time. So the amount of scale that you can ultimately get from the optimistic roll ups is extremely limited. Right. The bandwidth of Ethereum is not going to go on optimistic roll ups up by a factor of 1000 x. It's going to go up by a factor of, I don't know, five x at most.
01:01:55.096 - 01:02:57.768, Speaker A: So now you're going to do all this work, and if everyone else is going to do all that work, you're all going to be in the same exact location where you didn't get much scale and you didn't get the gas costs down. So think about that. With Starknet you have a vastly greater scalability. We don't know the exact numbers yet, but it's going to be vastly greater scale that you can get even when everyone is coming on board than you can get on altruistic roll ups. And with respect to other ZK roll ups, well, the core difference is that these things are now all of our systems written on the same infrastructure at Startnet are already live in production for many months using Cairo during complete language that is now made accessible to you. If you're a developer team and you're looking for similar things in other projects, you won't find them. I mean, on Twitter you'll find a lot of promises, but if you're looking for actual things like these links will lead you to where you can build and deploy.
01:02:57.768 - 01:03:02.700, Speaker A: They just don't exist. And they won't exist for a very long time. So that's the main reason.
01:03:02.770 - 01:03:03.292, Speaker B: Okay, yeah.
01:03:03.346 - 01:03:48.636, Speaker C: Amari is saying that Zksync is also available and open to the public. I think the main difference is mean, maybe I'm wrong, but at least as far as I know, there is no system Zksync offer right now that allows you to write contracts. And those contracts are actually in the same state in which pools are being generated and it is verified on chain. So I know that Zk sync one or one point X is available on Mainnet, but ZK sync one is the equivalent to Starkx, right? It's not equivalent to Starknet, which is.
01:03:48.658 - 01:03:51.550, Speaker B: Available one year now.
01:03:52.340 - 01:04:41.790, Speaker C: Yes. So as far as I know, this functionality is not yet available. I think one thing that is also a killer feature of secure Olap is the ability to argue about security. So the security of an optimistic roll up. For me, it's a very tricky thing to define, and in the case of a ZK roll up, there's no possibility for an invalid state transition. Only valid state transitions are possible, and so the security is derived directly from the consensus rule of l one.
01:04:44.820 - 01:05:42.236, Speaker A: Next question I'll also answer. Can you explain the differences between coda protocol, which is Mina, ZK sync, and Starknet, or at least between the last two? So roughly, Mina is a layer one, ZK sync is a layer two. Both of them are building on planks and other systems that rely on elliptic curve cryptography and all kinds of assumptions about it. You need a trusted setup, which also limits the size of computations that you can have. So they solve, or try to solve scalability by using recursion. But recursion is a very costly thing, so you're going to get much less scalability. The biggest bottleneck is the prover, and you're going to get much less scalability that you can get than with Starknet, which uses the fastest and most future proof and post quantum secure technology, which is the ZK stork.
01:05:42.236 - 01:06:17.436, Speaker A: So you have better scaling technology over Starknet and only over Startnet, which is going to translate into higher scalability for your network, especially if you think of it as everyone wanting to go on it. So that's the difference. Okay, another question that I'm happy to answer. How will starquare earn money in the future? So we're optimistic about it. There are at least two avenues. One is from our star tech systems. We already are earning money by basically having all kinds of rev share agreements with our customers.
01:06:17.436 - 01:06:54.360, Speaker A: It's very likely that some of them will want to continue operating in this way. And we think that just like in other blockchains, they're going to be various crypto economic incentives to various providers of services. The same thing it holds over l one, it's going to hold over l two, we plan to both facilitate these things and also participate in them. So that's how we can probably earn money or hope to do so in the future. Okay, another question. There was mention by Zach of an announcement at the beginning. Sorry, I may have missed it.
01:06:54.360 - 01:07:16.050, Speaker A: What was that announcement? I think we also missed it. Sorry. Yeah, I'm not sure which announcement. Okay, so let's look at the mean. They're more in favor of continuing for a bit, so now we'll go back to Leo, who's going to beef up. So please share your screen again.
01:07:17.380 - 01:07:19.440, Speaker B: Okay, it's already shared.
01:07:20.100 - 01:07:22.832, Speaker A: Okay. For some reason.
01:07:22.886 - 01:07:23.776, Speaker B: No, it's not.
01:07:23.878 - 01:07:24.764, Speaker C: I see.
01:07:24.902 - 01:07:53.240, Speaker B: Okay. So I don't know. But anyway. Okay. If you can't see the screen, let us know. So, as I promised, let's try to modify this contract a little. So instead, now we had one storage variable called balance.
01:07:53.240 - 01:08:31.864, Speaker B: I can add an argument here. Let's call it user. And this makes this from one variable to a map, a map, a dictionary, from user to a value which will be the user's balance. And now just, I want to show you what happens if I try to compile it this way. So let's try to compile it. And I get an error. It says here that in the balance read it expected exactly one expression, got zero.
01:08:31.864 - 01:09:04.880, Speaker B: This is because now this balance is a map. I need to give the value of the user. So I'll change the argument of the function. I'll add the user here, and I'll pass it both to the read function and to the write function. And I need to do the same here. Sorry. So let's get a user.
01:09:04.880 - 01:09:39.930, Speaker B: Let's pass the user. The user will be the public key in a second when we add the digital signature. And let's try to compile again. Okay, so it compiled successfully. Let's try to deploy it. Deploy. Okay, we'll take a look at the block explorer in a second.
01:09:39.930 - 01:10:17.160, Speaker B: Let's. Let's invoke the increased balance, increased balance function. So address the address of the new contract, the function that I want to use. Increase balance. Now I have to give two inputs. The user, let's say user number three, and the balance, let's say 100 and Abi. And the Abi.
01:10:17.160 - 01:11:02.500, Speaker B: Okay, so now let's have a look on the blockchain explorer. Okay, so let's see. We had transactions. This is 80 and 77 is the contract. Okay, so 77 is here. So I should be able to see the get balance, which now accepts an argument. So let's give it value four, which is not my user.
01:11:02.500 - 01:11:36.760, Speaker B: It should return zero, which it does. Now I try to do three. I'm not sure that actually. Let's check whether my transaction was included in a block. Yes, it is. I see hero zero, probably I clicked before it was added. Let's hope.
01:11:36.760 - 01:12:15.100, Speaker B: Yeah. Now we see the 100. Okay, so this was a relatively easy change. As you can see. Currently anyone can encrypt the balance of any user. Let's try to make it more interesting. And I'll do that by adding a signature so that the user will have to sign using its key the amount that it wants to add to the amount of money that it wants to add to the balance variable.
01:12:15.100 - 01:13:01.204, Speaker B: By the way, of course there is no actual money involved, because as Tom mentioned before, we don't have the l one l two interaction in the alpha at this moment. We will have a few weeks from now. Okay, so let's start by importing the necessary things. So I need the signature built in. I have to add ECDSA here. Again, everything is written actually in the third page of the documentation. Signature verify.
01:13:01.204 - 01:13:45.450, Speaker B: So I'm importing a function called verify ecdSta signature, and let's add it. In the increased balance function, it needs a message that I sign. Just for simplicity, I'll put the amount as my message. Usually to get a secure signature scheme, you need the message to be a hash of something. So you can use the paydays and hash for that. I need the public key, which will be the user, and I need the signature, which is actually signature. So we have.
01:13:45.450 - 01:14:06.510, Speaker B: Sorry, just 1 second. So by the way, we're doing this tutorial now. So the signature is the signature r and signature s arguments. So let's add them.
01:14:10.480 - 01:14:11.230, Speaker A: S.
01:14:14.100 - 01:15:10.100, Speaker B: And of course I have to pass. So at the moment, stagnet does not have a notion of accounts, but we'll have something in the future. So currently you can do it by yourself. Okay, so let's try to compile. And it will remind me if I forgot something. Yeah, I forgot the ac disability. Okay, so it compiled, let's deploy it, and now let's try to invoke the function, but let's give it an invalid signature.
01:15:10.100 - 01:15:58.820, Speaker B: It's easier to generate an invalid signature than to generate a valid signature. So let's start with that. So I updated the address, I have the function, the inputs now, which were user number three and amount 100. Let's give the signature one, two, which is of course invalid. And let's try to do that. And now let's take a look at the status of the transaction. Again, it, okay, received means that the system received the transaction and haven't processed it.
01:15:58.820 - 01:16:44.928, Speaker B: Yes, let's wait a few seconds. Actually, let's send the valid signature in the meantime. So let's change the parameters here. The tutorial has valid arguments, but also a python script that allows you to generate them. Okay, so this will be my key. Sorry, I don't need a private key. The amount in this example is 4321.
01:16:44.928 - 01:17:19.470, Speaker B: And these two large numbers are the signature. And let's try to send this one as well. Okay, let's go back to the previous transaction and see what happened. Okay, so the transaction status is rejected, which kind of was expected. So it says the signature one two is invalid. Yeah, so we kind of expected it. Let's see if this transaction, yeah, this transaction is already in.
01:17:19.470 - 01:18:12.300, Speaker B: I'll use this time the call command line interface in order to invoke the get balance function. So the call is very similar to invoke, which we used before, except that it just queries the state instead of modifying it. So we won't have to wait for the transaction to be in a block. Because it's not a transaction, it just query the state. I do need to give it the function name, which is get balance and the input. So I want to query this user. And finally I need to give it the Abi.
01:18:12.300 - 01:18:52.520, Speaker B: Let's see if I forgot anything. Okay. Yeah, so as you can see, we got the 4321. So basically we changed our contract. Now we have a contract that have multiple balances. If a user want to change their balance, they need to sign the amount. By the way, we don't protect here, for example, from using the same, from invoking the same transaction twice.
01:18:52.520 - 01:19:37.290, Speaker B: And we should have, if we want something that is secure. So I can currently invoke the same transaction again and it will change it to 8642. And you can add with the current infrastructure, you can definitely edit yourself. You just need to add something like a non or a variable that tracks what transactions were executed so far. Okay, so this is a tutorial. As I said, you can take a look in the documentation of darkness and follow it yourself.
01:19:37.980 - 01:19:38.964, Speaker A: Okay, terrific.
01:19:39.012 - 01:19:39.972, Speaker B: Thanks, Leo.
01:19:40.116 - 01:20:06.430, Speaker A: Let's answer the last few questions. David is asking. Can Starknet's technology work on other non EVM blockchains like Solana? The short answer is yes. Anything that is basically curing complete can. It doesn't mean that we'll do it anytime soon, mostly because we're extremely limited in our capacity, but there's nothing that prevents it from working on other.
01:20:07.680 - 01:20:27.512, Speaker C: I mean, I think that specifically for Solana the main things that need to be changed are the l one contract, but I don't think there's anything conceptually different. But maybe I'm missing something, I guess.
01:20:27.566 - 01:20:28.170, Speaker A: Also.
01:20:30.220 - 01:20:34.410, Speaker C: Some stuff for the full node infrastructure, but nothing major.
01:20:36.860 - 01:21:06.080, Speaker A: Next question. I am concerned about the licensing process for Cairo, as it seems that there is a lot of them ending by the end of the month and some end at the end of the year. Would you elaborate on this for devs? Want to work on the. So I wrote back already, please share the link. Even the licenses that are time limited, they first of all should end by the end of the year. And this is mostly just kicking the can. Most of them will be replaced.
01:21:06.080 - 01:21:47.360, Speaker A: I need to see the specific ones, but most of them will be replaced by open source. I think this is for the Cairo contracts and our plan is basically to open source them in the very near future. There are other more burning things, but those with the time that mitted Singh are probably going to change to open source, or at the very least we're going to extend it to the end of the year. And our plan is of course to have a licensing strategy that will be extremely conducive to developers. So of course if you see something that you want to discuss. So reach out and we'll try to make things more to your liking. But in particular those ones.
01:21:47.360 - 01:22:31.024, Speaker A: If there's anyone that still mentions the end of the month that will be updated as soon as we see it to the end of the year and probably before that, those things are going to be replaced to open source. Okay, so summing up, we gave you a tasting of how it looks right now to build on Starknet and deploy on it. More features are going to be added all the time. We talked a little bit about the plan for the next half year or year that we want to reach a decentralized l two. And I think if you're asking yourself what can you do if you want to participate, join the discord download. You have the links here. The discord insight is also here.
01:22:31.024 - 01:22:41.940, Speaker A: Right? Or maybe we can just add it. Okay, great. So it's in the chat and we hope to interact with all of you and see you as part of the ecosystem that we hope to build.
01:22:42.010 - 01:23:28.996, Speaker B: Yeah, I want to add, you can actually start writing sarknet contracts right now. A lot of things are going to be missing. You won't have l two interaction. You won't have the ability to call contracts for other l two contracts, but you can start to play with it and start to get the feeling of how it is and let us know if you think that something should be done more easily and let us know if something works as you expected. But you can basically start writing contract now. So thanks.
01:23:29.138 - 01:23:31.430, Speaker A: Thank you, Leo. Thank you, Tom.
01:23:32.040 - 01:23:33.648, Speaker B: Thanks everybody. Bye.
