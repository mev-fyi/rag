00:00:03.450 - 00:00:58.874, Speaker A: Hello everybody, I'm George Belina. I'm the technical lead at Polygon ZkabM. And today, well, I'm going to explain a detail of the ZKBM that we are building, is the recursive part. What I want to explain you is, okay, we start with a circuit that actually verifies a block, which is where all the things happen. But then the idea is that we want to aggregate many blocks in a single proof, and for that we want to create a proof that aggregates proof and all that. So I'm going to explain all this process from, we have a proof of ZKBM and how we aggregate and we convert to a final proof, a very small proof with many blocks, and we prove that on chain. Okay, so if we see the basic where all the logic of the ZKBM, this is a huge circuit.
00:00:58.874 - 00:01:29.794, Speaker A: It's a huge stark circuit working with God deluxe prime field. And if you see the inputs here, it should sound quite familiar. It's a circuit that proves from going from an old state route to a new state route. And which transactions? Well, all the transactions that are processing is in the second input. This is the accumulated hash. This is where all the transactions come. Actually this is like a kind of a blockchain.
00:01:29.794 - 00:02:16.374, Speaker A: And this is built in the smart contract. So actually what we are doing is in each batch we hash all the functions and we hash which is the last block, something like a blockchain, but it's not processing nothing. It's just chaining all the transactions that is going to be processed. So this would allow us for example for proof a segment from block four to block 14. So a segment on the chain. And then the idea is that the input accumulated hash and the output accumulated hash matches in the case of a single block, which is this case just for one block here for the local exit route. This is mainly for the breach, just for transferring information from l two to l one, we have the old batch number, the new batch number.
00:02:16.374 - 00:02:59.390, Speaker A: So from which batch it is, in this case it just increments one. This proof goes from, it's the proof for batch three to four or for four to five. This is the main batch and the chain id that we are here. Okay, so this proof is a huge proof. We are working with two to the 23 polynomials. There is 669 polynomials. At this point there is 18 permutation checks, 29 plug ups, two copy constraints, and this griffs a total width of more than 1000 columns in the stars, which.
00:02:59.390 - 00:03:15.190, Speaker A: It's a big stark. Okay, we are applying a blow up factor of two here. And this is, okay, if you see the size of this proof is about two megabytes. So it's a huge proof, okay. So the first thing that we do, we have this huge proof. We cannot prove that on chain. And this does not aggregate anything.
00:03:15.190 - 00:03:40.994, Speaker A: So the first thing that we do is we try to reduce this proof. So actually what we are doing is a proof of proof. So we are creating a first level of recursion with a single proof, just to reduce. The only reason for reduce, okay, and here is. Well, if you see this circuit is, well, the public inputs are exactly the same that the original circuit. The only thing is that the input are not the transactions. In this case, the input is the last proof that we generated these two megabytes on the system.
00:03:40.994 - 00:04:06.890, Speaker A: And this is another circuit. This circuit. The interesting thing of this circuit is that this circuit that verifies, is a circuit that verifies the stark, okay? And this circuit is writed in circum, actually it's written automatically pill stark. Mainly what does is just convert any pill. So any circuit and generates the verifier in circum. And then there is a process to convert this circum.
00:04:10.030 - 00:04:11.610, Speaker B: Into another stark.
00:04:12.190 - 00:04:38.706, Speaker A: Okay, here, this whole stark is a structure. Mainly it's a plunk like circuit. Instead of having three columns, there is twelve columns. We have basic plunks, basic plunk gates. Actually we have four per row because we have twelve. So thing, then we have four custom gates that are specific for verifying a starks. These custom gates are.
00:04:38.706 - 00:05:13.534, Speaker A: While one is a four, positon is one step of positon. So that we can do that in a single row, a single step in a single row. We have another four ffts. An fft of four elements in a complex field. So goes twelve to twelve. We have another custom gate for evaluating polynomials that you require that in the fry polynomial. And then we have another one that's just a complex, well, it's a multiplication addition in extension three that you do that a lot in the operations.
00:05:13.534 - 00:05:38.502, Speaker A: So with all that together, we have a circuit. And then after this we reduce that a lot. We go from two megabytes to half megabyte altogether. You see that the proving time here we go from two minutes to 14 seconds. This is, well, actually we need to add them to the proving side, but it's not that much. This gives us a smaller. We are using a blow of factor of four.
00:05:38.502 - 00:05:55.854, Speaker A: And it's a much more simple circuit. Okay. And now after this we start, what's the recursion part. Okay, the first step is like another reduction. It's also a kind of a normalization. It's another circuit that does exactly the same. The only difference is, well, we add an extra public input we call root c.
00:05:55.854 - 00:06:06.274, Speaker A: We'll see what's this. But actually this is a public input that in this circuit does nothing. It's just a public input that's put it there.
00:06:06.392 - 00:06:07.060, Speaker B: Okay.
00:06:09.510 - 00:06:45.498, Speaker A: This gives us another level of recursion that goes smaller and so on. And what we do here is, okay, we generate with circum, but we don't generate a full circuit here. What we do is we generate a template, a circum tem template that actually does this verification. So this verification you just pass as a private input, you pass the output of the last circuit, you pass to here. And this is a circuit that actually verifies that. Let's keep this circuit.
00:06:45.594 - 00:07:00.046, Speaker B: Okay, so this template, and now with this template, we actually want to build a circuit that aggregates two proofs. Okay, let's do this. Start for here, take one proof and another proof. And then we create a circuit that actually is a proof of two proofs.
00:07:00.078 - 00:07:01.474, Speaker A: Okay, so how would we do?
00:07:01.512 - 00:07:03.426, Speaker B: Well, we will take two of these.
00:07:03.448 - 00:07:06.326, Speaker A: Templates, we put them together in the.
00:07:06.348 - 00:07:42.586, Speaker B: Circuit, we align them altogether. Actually you have these two circuits. So here is, you can see that the input of the circuit is going to be the two proofs. And this will aggregate, will convert one single proof in two proofs. Okay, but you cannot do much more. You can take two basic proofs and this you aggregate to a single proof. Okay, but now let's take this circuit and let's create another template that verifies this double circuit, this recursive two circuit.
00:07:42.698 - 00:07:46.030, Speaker A: Okay, and here we have a circumcise.
00:07:48.530 - 00:07:59.638, Speaker B: So this is a circumstance that actually verifies the two. In this verification, the only thing that's different is what we call the constant, the pre computed polynomials, which is the.
00:07:59.644 - 00:08:01.894, Speaker A: Hash of all the polynomials, okay, but.
00:08:01.932 - 00:08:42.322, Speaker B: This is exactly, so this circuit of verifying the verifier two and the circuit for verifying the original circuit is exactly the same. The only difference is this constance root. And the trick here is that we put this constance root as a public input. That's why we added this public input. So if you see these templates in circum, they are exactly the same code. So this is exactly the same. So this circuit here, actually it allows you to verify two proof, but the proof can be either recursive one or a recursive two.
00:08:42.322 - 00:09:15.438, Speaker B: The only difference is as the input of this recursive verifier. This is a root c. We need to tell them if it's a recursive one or a recursive two. The recursive one, we can't hard code them because recursive one, we are already built. The problem is that the recursive two with this root, we don't know yet because we are building this circuit. So we have this kind of chicken and egg problem, okay? But because this input, we put it as a public input, we are just selecting. And actually this template is exactly the same.
00:09:15.438 - 00:09:42.998, Speaker B: It does not depend on this. And here is where we have this multiplexer where depending if we are proving a recursive one or a recursive two. So it's an original or the first one. We are multiplexing and selecting one constant to one or the other. Okay, so this circuit is very cool because it allows you to aggregate two proofs. So I can take two original proofs and aggregate them. But then this proof, I can aggregate with another proof one.
00:09:42.998 - 00:09:48.198, Speaker B: Or I can take two roots, two. So I can build a tree. And no matter, so I don't need.
00:09:48.204 - 00:09:49.266, Speaker A: To do it sequentially.
00:09:49.378 - 00:10:16.050, Speaker B: So I can do it very much in parallel. It allows you to maybe have a process aggregating the batches one and two, the other aggregating the batches three and four, the other the batches five and six. And then the output of the first two process the recursive one and two and three and four. We are aggregate them all together. So we have a proof that is the 1234. Then the aggregate with five and six. I can add maybe an extra one of seven.
00:10:16.050 - 00:10:42.886, Speaker B: So I'm free of selecting how I'm building this proof. This is the trick and the magic of this circuit. If you see the circuit, this is much smaller. I'm sure this can be reduced. But this is around 10 seconds right now. But I'm sure it can be done subsecond here. But this is a quite relatively small proof.
00:10:42.886 - 00:10:59.120, Speaker B: Okay. And this allows us to aggregate. And in the final step we have like another circuit, as we call recursive f, which is the last one, when I have write the proof and I want to send that on chain. So here is the steps. Actually we have another circuit. We're taking exactly.
00:11:00.850 - 00:11:02.270, Speaker A: The same template.
00:11:04.550 - 00:11:36.406, Speaker B: The same verifier template that we already built before. Here we already fixed these constants because we already know the recursive one and recursive two constants, which is circuit. And here I'm just selecting one or the other, depending if I want to just do. It's a final one or a recursive two. Sort of recursive one or a recursive two. So I have this multiplexer again, and here I just have another stark, this stark. The thing, the difference here is that here, this stark, it's a normal stark.
00:11:36.406 - 00:12:03.102, Speaker B: The only difference is that the hashing is not in the gold bellocks field. The hashing is in the BN, it's in the Bn corp. It's a poseidon in the BN corp. Because this goes to the final stage. The final stage actually is what's doing in the final state is actually this verifier. But it's a normal circum. It's a normal BN Corp.
00:12:03.102 - 00:12:49.858, Speaker B: It just takes a verifier and it takes all these inputs and verifies that. But the difference here is that the inputs, instead of being private inputs, instead of being public inputs, we are putting as private inputs, we hash them together, and there is just a single public so on chain there is only one public input, which is the hash of all the public inputs of the recursion of the past states. Okay, this circuit is quite small. In global 16, it takes less than 11 seconds. It's less than white megabytes of constraints. Works in the BN corp. And yeah, the gas cost for verifying that is 362.
00:12:49.858 - 00:13:22.960, Speaker B: Actually we are working right now instead of using row 16, using f long, the cost of f flunk, the gas cost is going to be more or less the same that grossistine. It will not require to trust the setup, but the proving time is going to be maybe like 910 times slower. But this is aggregation part, so this time is some more tids with all the batches. That's verifying that. So it's not a big issue there. So.
00:13:26.770 - 00:13:28.494, Speaker A: That'S very much what I wanted.
00:13:28.612 - 00:13:37.486, Speaker B: Just as an announcement is in Polygon ZKVM, if everything goes okay, we are going to launch the main net in March 2023.
00:13:37.508 - 00:13:40.320, Speaker A: We are finishing the audits and everything is looking good.
00:13:40.850 - 00:13:43.626, Speaker B: And yeah, that's my presentation.
00:13:43.738 - 00:13:44.460, Speaker A: If you have any questions.
