00:00:03.770 - 00:01:04.562, Speaker A: Hi, I'm Brian Retford. I'm the CEO of RISC Zero, and today I'm going to be talking about the Bonsai network. It's going to be a new kind of blockchain that we think of as a universal ZK powered compute accelerator that can really, really enable application developers to be limited more by their imagination than the capabilities of the platform they're building on. So about Risk Zero, if nobody's familiar with it, we were founded about a year and a half ago. Our first product was a stark based ZKVM that runs the RISC five instruction set. So I think we can claim to be the first ZKVM that actually implemented a real physical ISA. And this has advantages that we'll talk about in a little bit.
00:01:04.562 - 00:02:53.826, Speaker A: The founders all know each other from the Seattle infosec scene, and we've been friends for 20 years. So when I talk about being limited more by your imagination than by what's currently possible, say you wanted to build a game on chain, like the amazing Xerox Monaco thing that matchbox just did in this game, I don't know how many people are familiar with it, but people basically write strategies for these race cars. You upload them as smart contracts, and then the cars battle it out on chain, and you can update your contract every period of time. So imagine, though, you wanted to build something where the game was a little bit more sophisticated and maybe the strategies were potentially hidden and the game itself were something more like Doom. So Bonsai is really designed to let people take state that lives on chain somewhere, and then run programs that are written in any language, including Doom written in c, and then seamlessly kind of integrate that with an existing chain like Starknet. So the way this works is you have your sort of Starknet state and contract. So you can imagine in the kind of Monaco example or the Doom example, you would have all the players where they are and sort of the state of the world.
00:02:53.826 - 00:05:32.454, Speaker A: And as soon as players commit to their turns or their strategies, or even just like a hash of their strategy, you basically post that to Starknet, and then Bonsai will sort of pick this up and then run this very complicated set of computations in a ZK fashion, roll this up to a single state route, and then post that to every chain, including starknet, verify it, and then basically give you the next state to update your game logic to. Sorry, jet lag. Okay, so the general way this works is people will submit requests for things to be proven, in this case potentially an execution of doom or things that they've proven separately, privately, maybe in their web browser, that they would like to be rolled up into this sort of universal state route that people can then reference from their smart contracts with just a Merkel lookup. So the sort of point of doing this universal roll up is to take a huge number of computations and reduce them down using ZK recursion to just one state route that can readily be referenced from any number of smart contracts. So something that may or may not be obvious from this kind of problem is if you have a bunch of proofs and you're trying to build a substrate that's actually universally sorry scales in an unlimited manner, you need to roll up lots and lots of proofs via recursion. So sort of the amount of time it takes to do recursion is critical. So one of the things we've been focusing on a lot is reducing our recursion time to be like, our goal is subsecond, because you can imagine if you're going to prove an entire execution of 30 seconds of doom, you might have to split that proof itself up into any number of small proofs, recurse them together to create one proof, and then all the other people that are also building other applications will have to do the same thing.
00:05:32.454 - 00:06:51.658, Speaker A: So the number of kind of transactions you can fit in any given block is really bounded by the log of the sort of recursion time. So the goal of bonsai again, is to enable people to build any kind of application they want using languages that they already know and code bases that already exist. So currently we support rust, c plus plus and go will be coming soon. The goal with unlimited scalability. We just mentioned this because of these trends, these sort of bonsai programs are stateless in the sense that the state lives on the host chain, and then they're run completely independently. You can, in fact, horizontally scale this as broadly as possible. So a goal is to give application developers the ability to run effectively on chain programs that are very complicated, but have a very predictable and fairly low cost for those programs.
00:06:51.658 - 00:07:54.002, Speaker A: So we like to think that programs that run on Bonsai will be about 10 million times cheaper than an equivalent program running on the EVM. Okay, so a little bit about how this works. So this is some background on the RISC zero zkVm. So just like the know VM executes Cairo code, the RISC zero ZKVM executes RISC V assembly language. So the way that you actually get programs into the ZK proving system is through a standard compiler tool chain. So yeah, you can just use LVM or GCC or anything to actually emit the RISC five assembly. It gets packaged up into a specific format that looks.
00:07:54.002 - 00:08:58.250, Speaker A: There's actually an l file, but is a little bit different. That gets passed into our ZKVM, which executes the RISC five assembly set and produces your standard sort of succinctly verifiable proof. The way this is all sort of constructed internally has a bunch of sort of additional accelerator circuits to perform specific features. For instance, we have like a Shaw accelerator. And as I mentioned, because recursion performance is so critical, we actually have a completely separate vm and chip just for doing recursion. Doom is kind of the example I would like to see running on this system before I kind of consider it done enough that people can generally make programs work. So the way I tend to think about the current level.
00:08:58.250 - 00:10:06.586, Speaker A: So this system has been out for about a year now, and month by month it gets more capable. So I like to think of where we're at now as the ZKVM has the capabilities of kind of a fancy arduino. It can address like 64 megs of memory and runs at about 40 khz on a MacBook utilizing GPU acceleration. You can run faster if you're using CuDA, but the next version we're working on will have the ability to sort of chunk proofs up into a bunch of small portions and prove them massively in parallel. So this system will actually look a bit more like a 486, which is perfectly fine to run doom moving forward. We kind of expect the sort of core of the proving system to basically be revved almost entirely twice a year. So the version we're looking to beyond the one we're working on now will actually be in a different field and will support two gigs of memory.
00:10:06.586 - 00:10:56.640, Speaker A: And we also expect to see sort of consistent improvements in performance. And then we'll also be releasing the Zergen language that you can use to write these sort of acceleration circuits. There are a bunch of examples that we have online that I think are interesting that people can check out. Now, the reservoir ZkVM is actually like fully ZK. So as I mentioned, you can do private proofs, post them to bonsai, and have them rolled up to be available on any chain. So most of these examples are actually things that utilize the kind of ZK properties. And I think people should check them out if it's something they're interested in.
00:10:56.640 - 00:12:10.418, Speaker A: So this is one example that's from that repository. And this kind of highlights the utility of having something like rust and or C Plus plus available to you as a developer. This actually basically takes as an input serialized string in a standard format for a chessboard and then a move, and creates a proof that that move is a checkmate without actually ever revealing the move. And it does this just by importing this shack matey chess library. So you basically have like an entire chess program that can be run off chain and then ZK rolled up onto starknet. So it's far more boring than running all of doom, but it gets it the same sort of concept. So to sort of harp on this idea a bit more, this is like one of my favorite games from when I was a kid was called scorched Earth.
00:12:10.418 - 00:13:28.702, Speaker A: I think people call it worms now is like the newer version of this, but you can imagine having similarly all of your game state living on Starknet. People basically commit to where they want their little tank to shoot without revealing it. Everybody commits to all of that, and then you actually reveal it. And then you send all of the logic off to Bonsai that will run all the 2d physics computations, potentially even render the frame in case you want like an NFT of your victorious moment, and potentially allow people to actually create sort of new programmatic ways of interacting with the gate, with the game that could optionally sort of remain private. You have to have a trusted third party to sort of escrow the private code. So we're hoping to launch a demo of a bunch of this stuff on top of Ethereum in the next month. The Starknet integration, just ignore the Cairo code because I just wrote that yesterday and it doesn't actually work yet.
00:13:28.702 - 00:14:40.950, Speaker A: But we're trying to start to build out the set of libraries that are necessary for developers to actually use this system from chains that they know and love. So I'm here for a week, so I'm hoping to get bug people's brains who actually know about all of this to figure out the right way to actually design this system. The most complicated part will obviously be the sort of cryptographic verifier, and I don't think we'll probably get that done for a while. But once all that's done, then you should in theory be able to run almost any code you want off chain, verify it easily on chain, and accelerate whatever part of your application you might want to do using that mechanism. So as I mentioned, people are building like a central limit order book on this. There's a bunch of people building roll ups and a couple games and game developers building stuff on there. And there's several sort of interesting applications in oracles, bridges and so forth.
00:14:40.950 - 00:15:46.262, Speaker A: Right now, a bunch of these features like fast recursion and then access to this acceleration framework are only available to people who sign up for our early access program, which anybody can do. And that sort of continually gives people access to whatever we're working on next that's not quite ready for public consumption. Yeah. So hoping to bring this feature to Starknet sometime in the next quarter in some capacity. Yeah, I think that's it. I save time for questions. Do people have any questions? Yeah, so the question is, how is this different from what the nil foundation is doing? And I will say, I haven't had a chance to really dive into their code.
00:15:46.262 - 00:16:08.410, Speaker A: They're doing a workshop later today, which I'm going to go to, but they sort of intercept c at a different level and translate it into circuits more directly. So our system is very stark. E. It's not exactly what Starquare uses, but it's very similar in the sense that it uses fry and air and all this stuff in deep. Ollie.
