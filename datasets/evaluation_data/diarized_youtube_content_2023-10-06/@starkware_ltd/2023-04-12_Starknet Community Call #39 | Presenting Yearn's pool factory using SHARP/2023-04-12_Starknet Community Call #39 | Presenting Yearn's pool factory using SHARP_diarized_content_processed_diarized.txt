00:00:00.170 - 00:00:37.750, Speaker A: Can see me. I am pressing go live now on YouTube and we should be good to go. So welcome everyone and welcome to new community call for Starknet. We are at edition 39. So as usual, we're live on YouTube and we are live on Twitter. I don't think we communicated that much for that community call, so this might catch you by a random chance. So do stick around and if you have questions, feel free to ask them either on Twitter or on YouTube.
00:00:37.750 - 00:00:44.598, Speaker A: I'm Henry, I'll be your host. And today I'm joined by Sasha. Hello, Sasha.
00:00:44.774 - 00:00:47.274, Speaker B: Hey, how are you? How is it doing?
00:00:47.472 - 00:00:49.450, Speaker A: I'm doing well. How about.
00:00:49.600 - 00:00:51.550, Speaker B: Perfect? Yeah, really good, thanks.
00:00:51.620 - 00:00:54.270, Speaker A: Did you have a lot of chocolate last weekend?
00:00:55.010 - 00:00:56.334, Speaker B: A lot of what? Sorry?
00:00:56.452 - 00:00:57.466, Speaker A: Chocolate.
00:00:57.658 - 00:01:03.120, Speaker B: Yeah, I'm pretty lucky I have to say.
00:01:04.290 - 00:01:14.770, Speaker A: Yeah, it's a good thing with Easter. Okay, cool. So Sasha, you're here to talk about pool factory, is that.
00:01:14.920 - 00:01:16.406, Speaker B: Yeah, yeah, absolutely.
00:01:16.588 - 00:01:31.270, Speaker A: Super cool. So you'll be talking about this in a sec. Let me check that we have everything set up. Tweet this real quick. Just give me a minute.
00:01:34.650 - 00:01:35.510, Speaker B: WHOOP.
00:01:47.090 - 00:02:07.430, Speaker A: I'm going to do this later on, don't worry. Okay, well, Sasha, the floor is yours. So if you want to present what you've been working on. You've been in the ecosystem for a while, right? You worked previously on Magnet. Now you're also working on morphine. Can you give us a bit of context of how you came to work with urine?
00:02:08.170 - 00:02:44.926, Speaker B: Okay, so I get involved in the stacknet ecosystem for one year now. A bit more maybe. So yeah, I started, as you say, I started with manatees. So some projects related to defi. So the proposal was to provide on chain asset management for users. So I worked on this for some months and finally I get engaged with urine on a really cool project. So I contacted Juan that told me about what he wanted to do with so on that new version.
00:02:44.926 - 00:03:21.862, Speaker B: So maybe I should explain a bit yarn in the first time so people could understand. So yearn is yield aggregator protocol. So that the protocol exists for several years now. So basically it's vault that can contain many strategies. And the purpose of yearn is to maximize your profit through DeFi. So you can get yields through Ethereum, you can get yields through stablecoin, USDC, USDT. And what they do with all the money they receive from user is that they will allocate all of this money in different strategies on the ecosystem.
00:03:21.862 - 00:03:48.310, Speaker B: So the strategy can be lending pool on AAve. It can be a lending pool on compound. It can use curve pool liquid staking token. So what you have with your lido, they can leverage it, they can use several different strategies through the DeFi ecosystem and optimize it. So you have the best yield.
00:03:48.970 - 00:03:59.306, Speaker A: So strategy is really just a set of steps for you to manage your liquidity on ethereum, right? So you put some liquidity there, you do something with it, then you put.
00:03:59.328 - 00:05:35.880, Speaker B: It somewhere like a central vault that interacts with several strategies, smart contracts, which are also like mini vaults, that's like a big vault containing a lot of minivaults. And what's complex for yarn is to find what is the best allocation for this different strategy. Should I put more money into ave strategy or compound strategy? And so that's what the project wants to optimize what I did with Jun. So how to make the data allocation more optimized and more decentralized? So previously, what yon did is that they have the governance that decided, okay, I will distribute, let's say 50% in this strategy, because I saw off chain that it's performing well. And this allocation to this one and to this one, the thing is that it's not really optimized because you never know, it's not really precise, it requires a lot of governance intervention, and you never have the allocation for the basil every time. It gives a lot of overhead in this process. The idea was to calculate, unchain this API and allow anyone to provide a better solution, so we could make sure that the new allocation solution is better than the previous one.
00:05:35.880 - 00:06:05.060, Speaker B: And this can be done through the sharp proverb. So the idea is to calculate through kerose script, the APY of the defense strategy have approved that this yield are the good one, and then submit the proof to the shop, and then submit to the layer one verifier, on which one you can make sure that you have calculated the strategy ip the good way and in a verifiable way.
00:06:05.990 - 00:06:18.190, Speaker A: Interesting. So before what was done is off chain, the yield was calculated by a set of tools, imagine in JavaScript, in.
00:06:18.200 - 00:06:29.030, Speaker B: A lot of stuff, I imagine JavaScript, I don't know exactly, but yeah, the idea is that it was performed off chain and then the governance came and say, okay, this is the new allocation.
00:06:30.170 - 00:07:12.146, Speaker A: But when you say the governance, this means that from the point of view of the smart contract, it's really just a bunch of person saying yes, this is the new allocation. And the smart contract is like, well, we have to trust these people, maybe the allocation is just sending it to your private wallet, which is something that can happen obviously, or maybe it's suboptimal, whatever. And the goal here was to remove the trust factor. And so you made all these verification, but in an approvable manner, meaning now instead of saying, yeah, we did it off chain and we certified that this is correct, you can do it in a way that the smart contracts then says, yes, I see that this was done correctly and that this new strategy is valid.
00:07:12.338 - 00:07:56.050, Speaker B: Yeah, exactly. This solution is much more decentralized, so you don't need to trust anyone. You can directly verify that the new allocation is better than the previous. And so we needed the depth allocator needed to be so decentralized. If you remove the trust, you need to make it permissionless. So everyone should be able to propose a new solution, verify it, and then we should incentive these people. So what Yondin is that they allow everyone to post a new solution using the shop.
00:07:56.050 - 00:08:24.030, Speaker B: Calculating this appearance through kerascript, and when the proof was ready on the layer one factory registry, you could calling the depth allocator again. Okay, this is the new allocation that has been calculated. We can make sure it's better than the previous one. And we, the new proposer, just verified the new solution and get rewarded through a lama pay stream.
00:08:25.090 - 00:08:30.526, Speaker A: It sounds like in your program, so you wrote this program, you're the one who wrote this program, is it correct?
00:08:30.628 - 00:08:38.626, Speaker B: I wrote the Cairo script and we both collaborated on the layer one contract with member of Yon team.
00:08:38.808 - 00:08:57.782, Speaker A: Because it sounds like in your Cairo script you have to use data from the blockchain. So I'm guessing you have to use some kind of oracle or some kind of way to tie into that of the blockchain and then convert the data that you have there, which is just a root of some state, to, hey, yeah, the APY is actually, this sounds.
00:08:57.836 - 00:09:04.890, Speaker B: Complicated to give the good input to the kerosecript. So the depth allocator contract.
00:09:06.590 - 00:09:07.018, Speaker A: So it.
00:09:07.024 - 00:09:47.000, Speaker B: Can accept several strategies. And when we add a new strategy, we have to specify what are the interesting data to call. So we give like the contract address to call all the call data, and we say, okay, what we want from the response, because it can be a structure. So you need to get what you need. I've made a small presentation, so it could, let's go better if I share it and I explain it through this, and then we could go like a bit in the code. So let's try to share the screen. Okay, can you see?
00:09:48.030 - 00:09:50.780, Speaker A: And now people should be able to see it too.
00:09:51.310 - 00:10:52.846, Speaker B: Okay, perfect. Just to take more about the problem. So the thing is that we needed to calculate it on chain, the apy of the strategy, which was really too complex before it was done by governance. So we needed to update frequently the new allocation so it could put some issues and it was not decentralized. And to make it permissionless, we could not allow everyone to submit a new solution, because we need to make sure the new solution is better than the previous one. So to deal with this, we used the sharp prover to be able to calculate the happy way of the different strategy of chain. So just a small reminder, social approver will allow you to attest the validity of a kero program execution and to post the proof on layer one.
00:10:52.846 - 00:11:57.294, Speaker B: So you'll be able to access the proof directly interacting with the fact registry contract on layer one. As I was saying, to calculate the APY of the defense strategy, we need to have some data from the concerned strategy on chain. So for example, if you want to calculate the APY of Ave strategy, you need to get some parameters of the ave interest rate model, so it will be parameter like the politicalization. So it's a linear interest rate model, so in two pieces, so you have like a slope and then a kick. And after this, another way to calculate it. So the first step was adding a new strategy, and take all the necessary call data, so you can access this data. So you need to sell everything for each strategy.
00:11:57.294 - 00:13:05.890, Speaker B: So some stuff for Ave, some other stuff for compound. Each strategy has its own data, has its own need in terms of data. So the first step is to add a strategy. I add Aave, so I need this and this, et cetera. And once you have saved all the necessary call data, everything you need to access the information that will be useful to calculate the strategy appear there is a function which is a save snapshot that will save the current state of the different strategy. So when you call this function, the contract will call all the necessary call, he will just call other contracts like Ave compound everything. So he will just get all the data he needed, hash it so we don't need to save it because storage can be expensive on Ethereum.
00:13:05.890 - 00:14:31.822, Speaker B: And better than saving all of this, we just hash it all, save the hash, and emit an event with all the data that we received. This is like the second step. And once you have all of this data, so you get it in the event that you emitted, and then you can put all of this data in input for the carrier program. So it will have all the data it needs to calculate the different strategy appear, you arrive with a lot of information that you receive from the 3d event from the save snapshot function, and you add the new allocation that in your opinion will provide a better general appear. So you can say, okay, so right now there are two strategies. You put all the data you receive from the event and you say, okay, I want to have 50 50 on the allocation of those two strategies. So I'm going to run the caro program, and when you find a good solution, so you can basically brute force and find the optimal solution, putting different allocations.
00:14:31.822 - 00:15:40.774, Speaker B: So let's try 50 50, let's try 20%, 80%, et cetera. And once you found the best general appear, when you found the perfect allocation, you can submit the proof, the execution proof to the sharp. So the sharp is going to receive many carrot trace and will submit approved to the verifier on layer one. And then the proposal will be able to verify this new solution on the layer one. So he will call the verify solution function, he will provide the output from the carrot program. So that will be basically the ash of the safe snapshot function. So to make sure we use the good input, he will also provide the new allocation, the previous allocation, and then the contract will check on the layer one factory registry to make sure it's true.
00:15:40.774 - 00:16:36.730, Speaker B: What we provide in the verified solution is true. The new allocation indeed provide this appear and is indeed better than the previous one. And indeed we use the good data. So we'll get the hash of the input, we'll compare it with the one we stored when we did the save snapshot function. If it's good, we'll then check on the layer one, the factory, everything has been performed, everything can be verified, everything has been performed well, and then it will be updated. And so you, as the proposal that provided a new better solution, you will be paid through Lamapay. So this system creates kind of on chain competition that incentive everyone to provide a new better solution than the previous.
00:16:36.730 - 00:16:47.230, Speaker B: As a consequence, the vote always have the optimal allocation.
00:16:51.010 - 00:17:39.150, Speaker A: That sounds really interesting. What's funny is that I like the snapshot idea. I think it's fun that you're asking the smart contract to take a snapshot of some interesting parameters and then you reuse these later on. I'm wondering how easier this is rather than using something like say storage proofs for example. But I'm guessing probably when you did that, the tooling wasn't there yet. And also when I start thinking about the complexity of the Cairo program, to take all of these parameters and to have something that is generic so that you don't have to submit a different Cairo program every time my mind gets lost. So adding even more complexity to that sounds daunting.
00:17:39.490 - 00:18:43.982, Speaker B: Yeah, when we verify the proof, it's like basically you do a KCAC 256 between the Caro program ash and the program output. And yeah, the caro program hash has to be unique. We need to calculate the apy of different strategy and each strategy has its own calculation method. And in the kero program we can update it. But we didn't want in our design, so we had to provide moreover in input than the good information like current utilization on Ave. We have to provide also the calculation method for each one of this strategy. So we have like a code to represent an addition, we have another kind of code to represent a multiplication.
00:18:43.982 - 00:19:37.986, Speaker B: We need also to say okay, take a certain calculation step and multiply it with another. We could have for each of our strategy a unique chiro script. But we decided to gather it all and to provide the call data, the calculation method of each strategy. So it can become really complex if the strategy calculation is really complex. But for case it was okay because we only used compound and Ave and basically it's just a linear function and if a certain collision is respected it's another linear function. So it was fine. But yeah, because you always need to specify the kero program ash.
00:19:37.986 - 00:19:51.400, Speaker B: So what's your kero script? When you want to verify the solution, you need to make sure it's the good kero program.
00:19:52.810 - 00:20:04.046, Speaker A: Yeah. And if you change the carrot program every time, the solidity contract doesn't know what is in the Cairo program. So it's a governance vote. So if you have to change your Cairo program every time you're back to.
00:20:04.068 - 00:21:14.542, Speaker B: Square one, and then you have other governor, then there are some decentralization problem, you have additional governance. But I think the way we did is okay when you calculate, when it's not too complicated for the calculation. But once you have a lot of calculations in which one you have a lot of condition, in which one you have a lot of operation, it can become very difficult like even to save the calculation method on Ave, which is a really simple calculation, it was quite long, it depends. So this is like a resume of all the different steps. So you add your multiple strategies with each one, the calculation method inside the call data, inside everything. Then you save snapshot, you save the ash. So you'll make sure after, when you will verify the solution that you have used the good input.
00:21:14.542 - 00:22:34.742, Speaker B: So when you save the ash, you get the data from the event, you will use this data in the caro program, you will run the caro program, you will submit the proof to the shop one. You can accept the fact on the layer one verifier you can call verify solution and the new allocation of the yond vault will be updated. If indeed your new allocation provide a better appear than the previous one and you as a proposer will get incentivized. So right now it has been implemented with a lambda pay stream that each time do a stream of money to the last proposer. But yeah, basically there are other methods. And yeah, this design could have been done using storage proof and you could basically describe the calculation logic on Stacknet, make some contract, add a new calculation method for the appear, and then get access the L2 data in layer one. This is another design that will have been done also.
00:22:34.742 - 00:22:39.200, Speaker B: But yeah, right now we did with the sharp, so it works pretty well.
00:22:39.650 - 00:22:40.720, Speaker A: Super cool.
00:22:41.170 - 00:22:48.066, Speaker B: Yeah, I have also some code, if I can also show some piece of code.
00:22:48.248 - 00:23:07.462, Speaker A: Yeah, that'd be great. Looking on YouTube. If there are questions, no questions for now and no questions on Twitter. I repeat it. If you have any questions, feel free to drop them there and then we'll answer them live. So yeah, if you want to show some code, Sasha, go ahead. That's great.
00:23:07.516 - 00:23:30.800, Speaker B: Yeah, sure it. Okay, can you see it.
00:23:34.470 - 00:23:35.522, Speaker A: Now? We can.
00:23:35.656 - 00:23:36.740, Speaker B: Okay, perfect.
00:23:37.750 - 00:23:40.946, Speaker A: Can you make the font a little bigger please?
00:23:41.048 - 00:23:42.340, Speaker B: Yeah, just a little.
00:23:47.290 - 00:23:48.294, Speaker A: Yeah. Good.
00:23:48.412 - 00:23:51.160, Speaker B: It's good. Yeah. Okay.
00:23:52.730 - 00:23:54.486, Speaker A: And you wrote all of this in.
00:23:54.508 - 00:24:09.062, Speaker B: Cairo one or Cairo zero, but I have to carry one. So this is the kero zero because I updated the Vs extension for kero. No, not really anymore.
00:24:09.126 - 00:24:10.278, Speaker A: It's all right.
00:24:10.464 - 00:24:21.630, Speaker B: Yeah. Should I start to explain the layer one, the solidity contract, or the kerose script?
00:24:22.530 - 00:24:28.338, Speaker A: Up to you. Actually, if we can go over the solidity one, I'm curious to see how you did that.
00:24:28.504 - 00:24:31.838, Speaker B: Yeah. Okay, so let's start with the 3d contract.
00:24:32.014 - 00:24:34.100, Speaker A: Are you freezing? Is this me?
00:24:37.670 - 00:24:39.050, Speaker B: Am I still freezing?
00:24:39.150 - 00:24:41.270, Speaker A: No. Looks like you're back.
00:24:41.420 - 00:25:31.794, Speaker B: Okay, perfect. So let's start with add strategy. So when Jerome wants to add a new strategy, he has to provide additional information regarding the strategy, if it used the depth allocator system. So he has to provide the call data. So all what we need to call the good information we need. So for Ave, it will regard some parameters such as the pollutization and what appear it gives you regarding the pollutization. So this is a structure which is strategy.
00:25:31.794 - 00:25:49.402, Speaker B: Param is defined here. Yeah. So you have to tell. Okay, which contract. I have to call the sector. So which method I have to call and then the code. Sometimes you have to provide some call data.
00:25:49.402 - 00:26:33.786, Speaker B: For example, you have like data provider contract on Ave that ask you a function that can be a get pool info. So you have to provide the pool in the call data. The offset will be useful. So you call it and you get a certain response. And the response can contain many arguments, it can return a structure. So you want to just select what you need, then the calculation. So as I told you, because we are not updating the kero program, Ash, each time we add a new strategy, we do this in a generical way.
00:26:33.786 - 00:27:39.520, Speaker B: So we have to provide the calculation data. So the kerascript will understand how to calculate this strategy. So the calculation data, can I explain it here? Okay, so basically it's kind of easy. You just have to provide the first member, is it a member that you get from the data emitted by the event safe snapshot, the data you have when you, the data from the strategy, or is your first operand regard the result of a previous calculation step. Then you have to do this with the second operand, and then you have to provide what operation. So zero represent an addition, one, a subtraction, two, a multiplication entry, a division, and then some other rules for power or route or whatever.
00:27:40.930 - 00:27:50.802, Speaker A: Did this strategy like the modeling of how you calculate strategies, is it something you came up with for this project or is it something was already implemented and done?
00:27:50.856 - 00:28:25.082, Speaker B: No, I use it especially for this project. So it's not like I would say super optimized, super clean. It's just a way to do it. It works okay, exactly. There's not only calculation, but there is also condition. So as some of you may know, the ave interest rate model works in two linear pieces. The first one is when the current utilization is before the optimal utilization.
00:28:25.082 - 00:29:26.706, Speaker B: So it's just a coefficient multiplied by the current utilization. And if it's after the optimal utilization, it will be rapidly increased to avoid the pool, to be fully borrowed. So it's just that with a certain condition, you'll have another calculation method. We also added a method for the caro script to know if there is a condition and if there is a condition, jump to a certain calculation steps. So in the calculation array, there is the calculation method of the first condition and of the second condition. And if the first condition is respected, the career program will know he has to jump to a certain step of the calculation. So another calculation method and yeah, let's go back here.
00:29:26.706 - 00:30:02.150, Speaker B: So here pack strategy is just because we don't want to save the previous strategy parameters. So we just hash it and just save the hash. So we don't need to, every time we add a new strategy, we have to provide all the previous one in the call data. So it's used in memory. But we don't store anything. We just make sure that the previous strategy, when we hash it, we refine the hash we have calculated before. So yeah, this is just to make sure the previous strategy had a good one.
00:30:02.150 - 00:30:34.754, Speaker B: So the address of the new strategy, the strategy param, as I show you. So then I won't explain that much. The update strategy and remove strategy, there are a lot of things to manage because we save ash for all the previous one. But whatever, let's check save snapshot. Okay, so check at least one strategy. So it's just to make sure you have at least one strategy registered. Then you'll check the strategy hash.
00:30:34.754 - 00:31:24.630, Speaker B: So, as I told you, we are not saving all the strategy parameters, we just hash it. So we have, every time we want to use it to provide it. Additionally, in the call data, we just make sure it's a good one and we continue. This is some conversion stuff to call, because we saved in the strategy param, a lot of contracts, letter call data, and we just make it good, so we can use it to call contracts. And then you have get strategy data. So I will show you this function. So what does it do? Basically, it will call the address that you provided in the parameter, this vector.
00:31:24.630 - 00:32:22.790, Speaker B: As I told you, we needed to provide an offset to make sure we get the good information from the wall structure that is returned. And yeah, so we get from this all the data strategies. Now we have the data strategies, we ash it all and we save the ash. So here we receive all the data we needed for the strategic calculation. We ash it with the calculation and conditions, and we store the ash for a certain timestamp. So now we store this once we will verify the solution, because we also provide this ash in the caro output. We will make sure that what we send to the karo, what we use for the kero script was indeed this data, this calculation and these conditions.
00:32:22.790 - 00:33:07.560, Speaker B: So just to make sure it's fair. And then we emit the event, so the users that called safe snapshot can retrieve all this data. Because here we save the ash, so we don't have access. And here we just emit it. Maybe I'll transit to the kero program now, because before calling verify solution, we have to run the carrot program. Okay, so it's not really beautiful because of all of this red underlay. So how does it work? Let's go to the main function.
00:33:07.560 - 00:34:27.238, Speaker B: Okay, so in the program input here we can see really good, but we have, so the current allocation, the new allocation that we want to test to see if with this new allocation we have a general better solution, the strategy data. So this is all what we get from the safe snapshot events, as I show you just before. So data strategy calculation, and finally a bit later, strategic condition maybe, but whatever, that's the idea. So obviously we don't type it manually. We have a script that is able to find the last events so we can directly get all of this data, put it in the JSON and run the kero script. So in the kero we are going to get the current allocation, the new allocation, we are going to take the calculation and the condition, and then that's a lot of just codes that basically just calculate the APY.
00:34:27.434 - 00:35:12.320, Speaker A: We have a question on YouTube. I think it's more related to your l one contract, but one is saying why not have an intermediate l one contract that computes the needed parameters? I think that's what you described earlier. So DL1 contract gets the parameter and saves the snapshot for these. The second question is how does the verifier contract validates that these parameters are correctly formed? For example, that you're indeed calling the ave contract and you're calling the valid method. I see that you're doing a call to a contract. What prevents me from sending an array where you call approve on Ave and then transfer to send me money.
00:35:15.490 - 00:35:15.806, Speaker B: When.
00:35:15.828 - 00:35:23.090, Speaker A: I verified the solidity, in the solidity part where you record the strategy.
00:35:23.430 - 00:35:45.194, Speaker B: Oh, okay. So when we add the new strategy, all of these parameters. So this is the governance, let's say. So you have to like, so here the question is how can I make sure these are good ones?
00:35:45.392 - 00:35:49.900, Speaker A: Yeah. That there's no, that using these won't steal money.
00:35:50.370 - 00:35:56.990, Speaker B: Okay, so this is a function that is used by the governance.
00:35:57.410 - 00:36:00.462, Speaker A: Okay, so anyone cannot just submit something.
00:36:00.516 - 00:36:33.482, Speaker B: It's really yearns that the governance that decide to add a new strategy to his vault. To the vault. It would be complicated to make it permissionless and allow everyone, because here you provide everything you need for the strategy calculation, for the strategy data you need. So this is done by governance and this should be done in a good way. That's it.
00:36:33.536 - 00:36:37.980, Speaker A: Well, yeah. Okay. Think about roundabout ways to do this.
00:36:38.670 - 00:36:57.380, Speaker B: Yeah. Might be a bit complicated. So what we do at least is some call check before we add it. So we still call the contract deselector. And we make sure this works. This returns some things. But yeah, it's in this function.
00:36:57.380 - 00:37:32.620, Speaker B: Um, yeah, so we, we still do a call to make sure. So it's, it's, it's not like fully optimized. But yeah, you can do some additional checks or when you add a new strategy to make sure it call a real contract, real method. But yeah, this is done by the governance. So you cannot be completely.
00:37:32.930 - 00:37:35.086, Speaker A: Okay, sorry, I interrupted you when you.
00:37:35.108 - 00:38:38.002, Speaker B: Were on, I was saying that we put everything as an input in the Kerry program, in the JSON. Then in the Kerry program we take all of this data and we run what? Run input. So we basically calculate score. So what we provide is the current allocation, the new allocation, the data strategy. So current utilization on average slope one on compound whatever calculation strategy, condition strategy. And this is like, because it's recursive, we save a certain score for each allocation and we just calculate the first strategy. We appear, we multiply it by the allocation of this strategy and we add it to the score and we call again it.
00:38:38.002 - 00:39:16.170, Speaker B: So it's just a recursion function. How does it work? So this is just the recursion stop. So when it's over, just return stuff. This is prepared calculus. So as I told you, there are some strategies that require a condition. So this function will be used to tell where is the index. I should start in the input calculation.
00:39:16.170 - 00:40:12.526, Speaker B: So it will just check if the condition provided is respected. Yes, we jump to a certain calculation step. No, we keep at the first index zero for the calculation step, we just check the condition and go to a certain step in the calcul. So then there is the calculus called strategy. So this is the function that will from the calculation method and the data calculate the appear of the strategy. How does it work? The first thing is like to choose your two operands. So what do I want to multiply the current utilization on Ave with a certain constant or whatever.
00:40:12.526 - 00:41:19.430, Speaker B: So here, the first step is to select your two apparent, what will be the two terms of your calculus? That can be division, multiplication or whatever. So we did a certain things. If the first apparent is before 10,000, it means that it represents the index in the data array. So you can have like index zero, the current utilitization index one, a certain percent. So here you just take the good one, the good index. Then if it's over 10,000, we are just taking the x less 10,000 steps. So to access the previous step, so let's say I calculated current utilization multiplied by this a, I have this result, then I want to do some things with this result.
00:41:19.430 - 00:42:15.720, Speaker B: So here I will just take as a first operand the result of this last operation. And if it's over 20,000, it means that it's a constant. So if you want to just plus constant, less constant divided by constant or whatever, we just take the number and we make sure it's a constant. If it's more than 20,000, and then we take this number, subtract less 20,000. So we do the same with the second operand. And once we know each, what are the two appearance, we perform calculation and the oops. And from this, wait, I'm just looking for the function.
00:42:15.720 - 00:43:05.698, Speaker B: Okay, this, and so, yeah, now we have our two operand, and what will be the operation? It will just depends of the operator. So as I told you before, if it's a zero, it's a plus, if it's one, if it's less, then it's multiplied, then it's div, then it's po. So you have a different method. So that's how we have a generic method for APY calculation. In the carrot program, we always provide the calculation method as input. And then the kero program will detect what is the calculation. Once it's done, it's calculated.
00:43:05.698 - 00:43:51.240, Speaker B: So yeah, it will calculate the current allocation APY and the new allocation APY. And finally it will print it as an output. It will output what we need. So what we want to output, we want first to output our input, we make sure we calculate it with the good values. So this is the ash that have been saved during the save snapshot function on the layer one solidity. So we calculated directly through the carrot program, and then we output it. Then we'll verify on the layer one three DT that it's a good one.
00:43:51.240 - 00:44:39.046, Speaker B: Why we need, so it's felt, you cannot print un 256 like this. So we print two felt and then we serialize array with the current allocation, new allocation. So the current allocation will be then used to make sure the current is a good one. And the new allocation is also the new one you provided, and the previous APy, and the new API. So it's important to calculate the previous APY because it changed every time. So let's say you have saved a 3% general API for your solution. If you recalculate it, it can be more or it can be less.
00:44:39.046 - 00:45:17.330, Speaker B: So it's important to calculate it again in the kero program and output it, and then the new APY, and then you have everything you need in the output you submit. So you do, Carol. Submit to the sharp and you will have a job. Once you submit it to the sharp. You want to verify the solution on the layer one. So we go back in the three DT code. And now we want to call verify solution.
00:45:17.330 - 00:46:14.814, Speaker B: So in the verify solution, we are going to add everything that has been output in the kerry program. Once we run it, the first thing is to check the strategy ash. So this is what we saved in the wait? Yeah, this is just again, we are not storing anything for the data. So we need each time to provide this. But do not worry about this. So the first thing is to make sure when we save snapshot, it has not been staled, because you don't want to use data that have been provided like a month ago. So there is a certain limit, like one day after you save the snapshot.
00:46:14.814 - 00:46:46.302, Speaker B: These data are no more valid, because you want to use fresh data each time to make sure it's true. This is just parsing stuff. This is check program outputs. So this is kind of important. So these are just classic verification. But what is important is here. So we make sure the new solution is better than the previous one.
00:46:46.302 - 00:47:22.300, Speaker B: Also, we introduce a little gap to make the user experience better. Because if you provide a new solution, which is like zero, zero, 1% better than the previous one, it can be a problem for the previous proposal, there is a little gap. So you have to make it better, but more than better, you have little gap. And what else then we need important. So the get fact function. So.
00:47:24.110 - 00:47:36.906, Speaker A: What we do is here, you're taking the output basically from the sharp verifier, to make sure that indeed it was the combination of a specific kyro program on a specific run and that it was run correctly.
00:47:37.098 - 00:48:08.422, Speaker B: Yeah. So here we provide the program ash and the output ash. So this is like the magic stuff. You can get the fact with KC 256 of the program Ash and of the output ash. And once you have this fact, you can call the layer one fact registry. Yeah, so you can call the verifier. So this is just an interface to the verifier.
00:48:08.422 - 00:48:30.830, Speaker B: So we install the address of the verifier, we call it, we send this fact and we make sure it has been executed. And then when everything's good, we update the allocation of the vault and we initiate a streaming fees for the last proposal. So, to incentive people to update the new solution.
00:48:31.650 - 00:48:34.340, Speaker A: Now we've come full circle. Really interesting.
00:48:38.870 - 00:48:49.110, Speaker B: Maybe I, how I find the strategy parameters for calculation and condition.
00:48:50.010 - 00:49:00.380, Speaker A: We're reaching about 50 minutes in the community call. So I think we're going to wrap it up there. But where can people find more? How do they reach you and how do they ask you questions about this?
00:49:00.750 - 00:49:17.262, Speaker B: They can reach me directly on Twitter, on Telegram. What's your little one? You can access the git of the repository. You can check the code. You can also contribute. Also if you can like.
00:49:17.316 - 00:49:18.990, Speaker A: Can you share the link here please?
00:49:19.060 - 00:49:32.346, Speaker B: Yeah, sure. Okay. Should I drop it in the chat?
00:49:32.458 - 00:49:35.640, Speaker A: Yeah, perfect. All it.
00:49:54.590 - 00:50:01.790, Speaker B: Here'S a GitHub. I can also drop my telegram. If you have any question, feel free to reach.
00:50:01.860 - 00:50:07.520, Speaker A: Yeah, sure. Spell it and then you can spell it and people will reach it.
00:50:08.450 - 00:50:38.918, Speaker B: And I think you can use some similar stuff to calculate ave interest rate model to update each time. The good solution, the optimal solution to calculate to find the best deal between supplier and borrower. I think you have many, many other applications. I would say you can largely do cool stuff with gaming also on layer one and use this system to improve.
00:50:39.094 - 00:50:41.340, Speaker A: Communication is breaking up a little bit.
00:50:43.310 - 00:50:44.586, Speaker B: Can you hear me well?
00:50:44.688 - 00:50:46.426, Speaker A: Yeah, now we can hear you. Yeah.
00:50:46.448 - 00:50:54.990, Speaker B: I was just saying that you can use this system for many other use case, including on chain gaming defi.
00:50:55.330 - 00:51:19.060, Speaker A: I think this whole concept of delegating code outside for it to be checked inside the blockchain is really powerful. Usually think about L2s and layer three. But the reality is that it's not a step, it's the spectrum. There's a lot of stuff you can delegate off chain, whether it's a chain or it's a full fledged net outside. It's really interesting.
00:51:21.850 - 00:51:25.190, Speaker B: Pleasure to work on this for me. That's super amazing.
00:51:25.340 - 00:51:40.140, Speaker A: Well, Sasha, thank you for spending time with us today. We're going to wrap it up. So as mentioned, I've put in the description on YouTube, the repo you shared, as well as your telegram handle. And to everyone listening to us, thank you. And no.
