00:00:03.140 - 00:00:36.220, Speaker A: Hey, everyone, thank you for being here. My name is Thiago. I'm a research engineer at Herodotus, and today I'll be talking about storage proofs and historical data access. So, basically, to start off with, I'll tell you what we do at Herodotus. We combine storage proofs with zero knowledge proofs in order to enable access to historical data across different chains and also current data. Cool. So let's start off by why does it matter? Why does this problem matter? So, as you know, currently when you deploy a smart contract on a specific chain, you only can access present data from the smart contract.
00:00:36.220 - 00:01:15.468, Speaker A: So we solve this by letting you access data from the past, also of the smart contract. Also, furthermore, we enable you to do this across different chains. So this means that if you have a smart contract deployed on one chain, you can access this type of data from a different chain than the one that you are deployed to. Also, as you probably know, there are a couple of solutions for this russian problem, but most of them either rely on centralization or some approaches that are not really scalable. So we aim to solve this problem without compromising on any of that. Cool. So let's start by why does it mean exactly to have access to historical data and to prove a chain and all this jargon that you might have heard of.
00:01:15.468 - 00:02:02.590, Speaker A: So let me start by the basics. As you know, a blockchain is basically linked list of blocks where every block is connected to the previous block by the parent hash. So essentially what does this mean is that we have a certain block, we can go all the way back to the first block by going from parentheses to parenthes until we reach the Genesis block, which is a pretty cool property that was first introduced by bitcoin, as you know. So if we have what we call an IBD, an initial block download just by that block, we can go all the way back, which is nice. So, yeah, we're going to use this property in order to be able to prove an entire blockchain just by starting with a single block. Also, we have to take to understand that there's some ankle risk, which in both proof of work consensus and proof of stake consensus is probabilistic. But in proof of stake consensus, it's not so likely to happen as in proof of work.
00:02:02.590 - 00:02:32.176, Speaker A: Nice. So some more theory before we get into the more practical approaches on how we're actually tackling the problem. So, firstly, let me introduce you Zika proofs. I'm sure most of you are familiar with Zika proofs, but I just want to make sure that everybody's on the same page right now. So Zika proofs have, essentially they allow you to prove that a certain computation was well made without having to make that computation yourself. This is a very interesting property. And ZK proofs, they actually have two interesting properties that we are going to explore.
00:02:32.176 - 00:03:07.424, Speaker A: So the first one is called the succinctness property, which basically tells us that it's much cheaper to verify a proof than to verify the computation itself. The second property is the privacy property. So essentially, in a Zkap proof, you have what you call the public inputs and the private inputs, and you have two sides, the prover and the verifier. So the prover is the person that is trying to prove the verifier that the statement is actually correct. And the cool thing is that the private input doesn't get sent to the verifier. So we can save a lot on bandwidth here and we're going to leverage this fact, although we're going to focus more on the succeedness aspect of ZK proofs. Cool.
00:03:07.424 - 00:03:44.120, Speaker A: So now that we understand ZK proofs, guess what? Proving proof itself is also computation. So this means that we can prove a proof inside a proof, and we can do this as many times as we want. And this is called proof recursion. And a cool thing about proof recursion is that generating a very big, large single proof takes a lot of proofer overhead. As you may guess, the size will be huge, and it takes a lot of time, so we can use proof recursion for our advantage. Nice. So I'm almost done with theory, and soon we'll be jumping into the applications and how we're actually solving this problem at Herototus.
00:03:44.120 - 00:04:10.032, Speaker A: But before that, I want to introduce a concept of Merkle mountain ranges. So remember that to access historical data from any blockchain, we need to have access to all the blocks. Because if we want to access data from block 1000, we need that block available. So essentially we need access to all the blocks. But storing all the blocks on chain, as you may guess, is crazy expensive. Currently in Ethereum, there are around 16 and a half million blocks. So that's a lot of blocks.
00:04:10.032 - 00:04:28.564, Speaker A: Each block hash is about one kilobytes. So yeah, as you see, it's quite a lot of data. So we need an approach to solve this. So the more naive approach that you might be thinking is, well, let's just use a Merkel tree. Merkel trees are used all over the place. And for those of you who don't know. A Merkel tree is essentially a way of committing to a big amount of data in a structure that looks like a tree.
00:04:28.564 - 00:05:02.960, Speaker A: And at the end we have what we call the root of the tree. And just by having that root, you are able to verify cryptographically that a certain piece of that actually belongs to the tree. This is pretty cool, and we could use for that problem, but it has a tiny problem you can't really append to a merkel tree. Merkel trees are not meant to be appended to, so we use Merkel mountain ranges. Merkel mountain ranges are essentially like a Merkel tree, but you can append to them and also update elements and the way they work. From an implementation point of view, they are essentially a list of merkel trees. So as you can see, in this Merkel mountain range, we have three Merkel trees, and the root of each merkel tree is called a peak.
00:05:02.960 - 00:05:37.392, Speaker A: And the property about Merkel mountain ranges is just by having all the peaks, you have enough information to add a new element to the Merkel mountain range. By the way, we have implemented the first Merkel mountain range library in Cairo. It's fully open source, so feel free to use it and to contribute, too. Nice. So now that we understand where we are actually starting the block headers, the block hashes in this Merkomoton range, let's look into the more practical approaches on how we can actually do this. So I'm starting by the more naive approach, and we'll slowly work our way up until a more complex and robust approach. So the first approach, called on chain processing, is very simple.
00:05:37.392 - 00:06:16.664, Speaker A: There's no tricky things going on here. So you start with the IVD that I previously referenced, the initial block, and you go to the parent hash, and every parent hash, you go back, you append that block hash to the Merkelman range. So you do this for Ethereum 16 and a half million times, and you'd have to pass all the blocks as call data. So as you can probably guess, this approach is terrible because tons of call data, tons of computation, and it's not feasible at all to do this. So let's start by exploring another approach, a much better approach now. So the second approach, it's called a single proof. And basically what we're doing is we're doing the exact same thing that we're doing on the first approach, but here we're doing it inside a Zika proof.
00:06:16.664 - 00:06:51.112, Speaker A: So we're saving a lot here. So the way it looks like basically the first initial block and the final Merkle mountain range route would be the public input to the proof, while the rest of the blocks, all blocks, but the first, the block hashes, I mean, would be the private input. So we're solving a lot on call data as the private input is not passed to the verifier. So it's very good for bandwidth. Even though this approach is definitely better than the first one, we still have a long proving time, because as you may guess, this proof is going to be huge and it will take immense amount of time to generate. And the memory consumption is also completely unfeasible from the prover point of view. Cool.
00:06:51.112 - 00:07:20.564, Speaker A: So now this is where things start to get way more interesting. Let's talk about approach number three. So approach number three is where we first introduce recursive proving. So the idea is that again, you always start with the IBD, with that initial block. And inside a proof, you verify that that block and a certain block backwards actually are related to each other through the parent hash. So in this example, we are going chunks of one by one block, but you can think of it as chunks of 100,000 whatever size blocks you want. So, cool.
00:07:20.564 - 00:07:53.532, Speaker A: After we have that proof, you take another proof, and the second proof verifies that the first proof is correct and it adds a few more blocks to this approach. And so we do this, so on and so forth, until we have multiple proofs. And at the end we just have to verify the final proof and we are successfully able to actually verify the entire chain, which is pretty cool. Just by verifying one proof, we verify the entire chain. So this approach might look very close to perfection. But the problem here is that it also takes a lot of time. So there's a lot of proofer overhead here.
00:07:53.532 - 00:08:26.388, Speaker A: And the reason for this is because this is not parallelizable, because to generate proof n, you already need to have generated proof n minus one. So we have a problem, but we can still solve this problem. Let me introduce you to tree like parallelization. So this approach is a bit similar to the previous one, but now we can use parallelization. And the way we can do this is by, again we divide the chain in multiple chunks. Here we are choosing chunks of two blocks each, but again, you can choose chunks of how many blocks you prefer. Actually, two blocks is probably not optimal.
00:08:26.388 - 00:09:12.304, Speaker A: So what you do is you take each chunk inside a ZK proof and you verify that chunk, verify that all blocks inside that chunk actually match with each other through the parent hashes. Then we take two of those proofs and verify them together, then we take two of the proofs of the proofs and we verify them together and so on and so forth. And you verify that the verification was well verified and in the end you'll have just this final proof. And again, you just need to verify this final proof on chain and you are successfully able to have access to all the block hashes on chain, which is cool. So yeah, this is the final approach, the one that I would say is more suitable to most use cases, but depending on your use case, you might want to use one of the previous ones. But yeah, this is usually the one that works the better for most approaches. And the cool thing about this one, I mentioned it already, but it can be paralyzed.
00:09:12.304 - 00:09:48.432, Speaker A: So while we're doing like the first proof and the second proof, while we're doing the first proof and the second proof, we can do them at the same time because we can paralyze them. So it's much more efficient on the prover side. Cool. So as you might have noticed, this is quite complex and it's quite a big problem to tackle at herotos. We've been tackling this problem for quite some time now and take my word, it's very complex. So we actually built an API that you can use for your historical data and cross chain data access needs. So the API, you simply post a post request to the API and the body of the request is super simple.
00:09:48.432 - 00:10:19.724, Speaker A: You choose the origin chain, the destination chain, the block number to which we're trying to prove whatever thing you're trying to prove. In this case we're, as you can see, proving that this account had a certain amount of balance on that block number. So it's pretty cool. You can prove accounts, you can prove states, you can prove receipts, you can prove literally anything that fits within an ethereum block or any blockchain block. So yeah, the API is soon will be ready and we'll soon starting to distribute API keys. So look out for that. And yeah, that's all on my side.
00:10:19.724 - 00:10:58.408, Speaker A: Thank you very much for hearing and let me know if you have any questions. Cost from chain? Yeah, the final proof costs around 600k gas. It also depends on the proving system. Of course. Someone here there had a question. Yeah, what chains are you going to support? Yeah, so currently we are supporting the connection between Ethereum and Sarknet. So this means that you can read Ethereum state on Sarknet, but soon we're going to all l two s.
00:10:58.408 - 00:11:42.430, Speaker A: So all the roll ups on Ethereum and Webex, so you can read data from l one on l two. L two on l one and l two s on l two s. Any more questions? Yeah. Provided. Yeah. The public input is just 32 bytes of data, which is basically the IbD, the initial block, and the final Merkel mountain range route. Everything else is private input, so you save a lot on bandwidth there, so.
00:11:42.430 - 00:11:46.780, Speaker A: Yeah. Okay, cool. Thank you.
