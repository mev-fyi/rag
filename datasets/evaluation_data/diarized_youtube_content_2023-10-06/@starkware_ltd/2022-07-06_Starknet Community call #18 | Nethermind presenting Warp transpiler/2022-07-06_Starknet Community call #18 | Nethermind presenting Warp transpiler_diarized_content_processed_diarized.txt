00:00:06.970 - 00:00:59.440, Speaker A: And we're live on YouTube also. Smile. All right, so the video is live on YouTube. I'm going to share the link in the community channel so that those of you want to see our face and faces and our screen can act up. All right, let's see. Turns out I was talking and nobody was hearing me just a few moments earlier. So I was really talking to myself.
00:00:59.440 - 00:01:18.466, Speaker A: It happens more often than you think, by accident or just by habit. But anyway. Hi everyone, on Discord again. So we're about to start our community call. Welcome. We'll start in a few minutes. Today we have the Nevermind team presenting warp.
00:01:18.466 - 00:01:37.020, Speaker A: We're also live on YouTube. If some of you want to take a look at our screens and what they will have to present and we will just start in a few seconds. Swap. Neil, guy, if you want to connect on Discord, that would be wonderful. And then people can hear you.
00:01:51.820 - 00:02:02.134, Speaker B: I've joined on Discord as well now. I'm sorry, I've joined on Discord as well. I think now.
00:02:02.252 - 00:02:05.340, Speaker A: Yes, I've invited Joric to speak now.
00:02:08.350 - 00:02:09.100, Speaker B: Hello?
00:02:10.110 - 00:02:12.314, Speaker A: Hey Joric, can you hear us?
00:02:12.512 - 00:02:17.020, Speaker B: Yeah, I can hear everything. Cool.
00:02:21.630 - 00:02:28.080, Speaker A: So let me check. Swapnil, are you able to connect on Discord also?
00:02:30.470 - 00:02:31.220, Speaker B: Yes.
00:02:32.310 - 00:02:51.974, Speaker A: So you should raise your hand for people to hear you or. Let me see. I see a hand swap. Oxo swap, Neil. Yeah, makes sense. And we got guy also. There we are.
00:02:51.974 - 00:03:21.902, Speaker A: So there's the four of us here on Discord and we're also here on YouTube. I think we can start. Okay, let's do it now. So hello again, everyone. Thank you for joining us today for this 18th community call. I'm pretty sure we missed one somewhere and there's a missing number but I'm not sure which one. So I'm going to count it as 18.
00:03:21.902 - 00:04:11.922, Speaker A: It's going to count. So today we have part of the Nevermind team. I was going to say the Nevermind team, but you guys are a big organization and there's only three of you today. So that's part of the things I want to understand what you guys do at Nevermind, but we'll talk about their project, what they're working on, which is warp. For those of you who are not familiar with Warp, Warp is a transpiler from solidity to Cairo that lets you deploy your solidity code base on Starknet. So we're going to talk about it, maybe see a small demo if Joric is able to resuscitate his laptop. And yeah, we're open for questions.
00:04:11.922 - 00:04:30.326, Speaker A: Don't hesitate. You can ask your questions in the community calls channel. And that's the plan for today. Let me check if there are questions. Not yet. Oh good. So let's start.
00:04:30.326 - 00:05:02.210, Speaker A: So guys, thank you for joining today. If we can start, I'd be curious to hear a bit more about Nevermind. I know it's a big organization. You guys are doing a lot of stuff on Starknet specifically. I think the two projects that come up first are obviously Voyager, the block explorer of Starknet, and Warp, which you guys are working on. I'm curious to hear how many people work at Nevermind and how many people are in your team working on warp.
00:05:03.270 - 00:05:44.842, Speaker B: Sure. First, thank you Henry, for having us on the community call and letting us present about warp. Nevermind is quite a big organization, so I think the last count we had over 130 people, but that is updating constantly. We're growing very fast and we're still actually hiring during this difficult time for us people, which is quite nice. Our projects range across a broad area within the crypto space. So we write net and my client, which most people are probably familiar with, we've got a project on Juno which is doing one of the implementations with Starknet. And then we have an auditing team which works in Cairo and does Cairo audits.
00:05:44.842 - 00:06:02.520, Speaker B: We've also got a formal verification team which is developing formal verification tools for Cairo. And we have a team that's in the metaverse. So we're quite a large organization and we're all very self directed and take our favorite projects and run with those.
00:06:03.370 - 00:06:05.910, Speaker A: Very nice. And how many people work on Warp?
00:06:07.690 - 00:06:11.126, Speaker B: I think guy would be better to answer that. You know the answer?
00:06:11.308 - 00:06:28.730, Speaker C: Yeah, sure, sorry, I'm just trying to navigate discord and YouTube. Yeah, roundabout, I would say five or four full time employees. And then we have roundabout two or three interns that sort of rotate in and out of our internship.
00:06:30.450 - 00:06:38.320, Speaker A: Very nice. Sorry. And can you say a few words about yourself? Actually, there's three of you.
00:06:41.330 - 00:06:41.694, Speaker B: Sorry.
00:06:41.732 - 00:07:03.320, Speaker C: Yeah, sure thing. So yeah, I work full time on the warp team. I wasn't very involved in warp 1.0, but came in and worked with Yarik and Swapnaltu and our team lead, Dom Henderson, who's not here to finish warp 2.0. But yeah, just excited to be here.
00:07:05.770 - 00:07:39.630, Speaker B: I was the team lead on the Ave port project and I stepped in on Warp one at the start of my time in Nethermind and I joined it around the time, same time that Slofno joined, he's now dropped off. So I'll introduce him as well. We have like a background in programming languages and compiler design. So that's why they hired us for the warp project. And we kind of came in the tail end of Warp one. And then we bootstrapped the start of warp two, which then got taken over by Dom Henderson, who's the main architect of Warp two. And we then stepped in again near the end to just push things over the line for the deadline.
00:07:39.630 - 00:07:41.810, Speaker B: So that's our background with warp.
00:07:43.270 - 00:08:09.102, Speaker A: Nice swap, Neil. You're not connected anymore on Discord. If you want to talk there, you'll need to raise your hand again. Very nice. So we can. Actually, I was going to ask a question for you to present a bit warp, but we can start with the question from Odin. Kind of trolling, I guess.
00:08:09.102 - 00:08:24.980, Speaker A: But is warp a transpiler or compiler? I think the broader question here is, for those who are not very familiar with the term, how could you define a compiler? A transpiler, the difference between both.
00:08:28.470 - 00:08:30.350, Speaker B: Well, a compiler.
00:08:30.430 - 00:08:32.466, Speaker D: We've actually had this conversation many times.
00:08:32.568 - 00:09:19.554, Speaker B: Internet. Yeah. A compiler is actually a system which translates one language to another. This can be a low level machine language, or it can actually be anything from a high level language or any other target, really. A transpiler is usually a translation from one high level language to another high level language. And the reason this distinction is because you usually use a different set of tools for achieving this thing, I would say, but a lot of people would judge me for this, that transpilers are a little easier to write than compilers, but that really depends on the target. In our case, we wanted to write a transpiler and we wanted to get as high level as possible out of Cairo to the highest level.
00:09:19.554 - 00:09:47.070, Speaker B: Cairo that matched the semantics of solidity. And in a lot of cases we were successful. But then in a few cases we do some really opaque things in order to make translation work. And in that sense, sometimes reading the output feels more like a compiler's output. So honestly, Odin, it's a gray area. I would call it a compiler. And I think everyone on the team has a slightly different opinion.
00:09:49.570 - 00:10:16.040, Speaker A: Cool. Could you go a bit into how did you approach transpiling solidity to Cairo? I know you guys took various different routes. And where you released recently? Warp version two. Can you present how you guys settled on warp one? And then how did you move to warp two? And why is warp two kick ass?
00:10:18.890 - 00:10:26.986, Speaker B: Sure. There are actually three versions of warp. We have a secret first version, or like not a .1 version which never made.
00:10:27.008 - 00:10:28.202, Speaker A: We don't talk about it.
00:10:28.336 - 00:11:08.630, Speaker B: We don't talk about it. Warp one was the idea was that we would try and go through Yule. So the solidity compiler has an intermediate representation which is a language which is slightly lower level than solidity, which should have been easy to write vms for, or interpreters for if you wanted to run them locally over going to the EVM. And then it transpiles from Yule to EVM. That's the latest pipeline. And what we wanted to do was link in at the Yule phase and then transpile from Yule. And there I've used transpile anyway, transpile from Yule to Cairo.
00:11:10.890 - 00:11:14.886, Speaker A: Why is it easier to transpile from Yule than from solidity?
00:11:15.078 - 00:11:54.710, Speaker B: Yeah, the solidity compiler already does a lot of desugering and taking out a lot of semantics that we would have to written ourselves when it's doing a translation from solidity to Yule. So that makes it a lot easier to work with. And writing of the transpider was actually very quick, like work one was out in record time. My. The one thing that it causes issues with is that whatever steps it takes to remove the semantics from solidity, that adds some overhead to a representation in Yule which we might be able to do more efficiently if we're going to Cairo.
00:11:56.410 - 00:11:58.246, Speaker A: Can you repeat that part please?
00:11:58.428 - 00:12:36.638, Speaker B: Yeah. So the transformations from solidity to Yule might make something which makes sense if you want to represent a concept in Yule that might be implemented by some interpreter nicely. For example, the call data, the semantics of solidity. But then we are transpiling all of these semantics that have been already encoded in Yule over to Cairo, which added a lot of overhead that we didn't actually need. So we could write a more efficient compiler from solidity to Cairo. And that is where work two comes in. So in particular we dropped call data semantics.
00:12:36.638 - 00:13:04.474, Speaker B: And there's a notion of block scopes in Yule which meant that all of the blocks which had scopes defined in Yule were being functionalized in Cairo. And we've gotten rid of a lot of work. One covered a lot of the semantics view, but the output was infeasible to deploy on Stacknet. Why?
00:13:04.512 - 00:13:07.950, Speaker A: Because it was generated programs that were too complex.
00:13:08.610 - 00:13:28.340, Speaker B: Yeah, it generated programs that are much too large. Actually, the main thing was just file size and the upload overhead that I would have for Stacknet. Okay. Yeah. Warp two produces much smaller output. And we'll see that soon with some of the slides that guy will present.
00:13:29.750 - 00:13:46.220, Speaker A: Very nice. Thank you. So for those of you who are on discord. If you want to see guy's slides, you can go on the community call channel. There's a link to the YouTube link and guy will present his screen in a sec. Very good.
00:13:47.710 - 00:13:48.460, Speaker B: Cool.
00:13:49.070 - 00:13:50.330, Speaker C: Is it presenting?
00:13:50.990 - 00:13:54.198, Speaker A: Yeah, we can see your presentation and we hear you correctly.
00:13:54.374 - 00:13:54.762, Speaker B: Sure.
00:13:54.816 - 00:14:39.526, Speaker C: I guess I'm kind of cheating here. I'm screen sharing a blog that's going to come out because we didn't have time to make slides. But just reiterating on what Yorick said about Yule, just providing these extra instructions that we then had to transpile here we just have an example in solidity where we have like a one line function. And this would be fairly simple to transpile. But then if you compile it to Yule and then transpile that you see it gets much more complex. I think it goes from a one line function to six lines with function calls. So even more lines than those function calls.
00:14:39.526 - 00:15:29.740, Speaker C: So you just had the contracts really blow up in terms of size, but yeah. So onto walk two, we just have some example contracts here that we've transpiled. This one is base jump rate model v two. And basically you can see that warp two is providing a contract size that's, I guess, half of warp one, which is cool. It's because a lot of these high level semantics that are represented in solidity are also handled in Cairo. So we can almost go like directly from one to the other. And here we have open Zeppelin's ERC 20 contract, you can see, also reduced it by half, which is great.
00:15:29.740 - 00:15:56.882, Speaker C: Yeah, the wallpoint contracts were rather large and it wasn't great. The handwritten is still obviously more optimized. Obviously generated code will always have more lines of code than original handwritten. But here onto step counts as well. You can see in the blue we have warp one. More instructions means more steps, basically. And we have, sorry.
00:15:56.882 - 00:16:33.306, Speaker C: This is the first contract based jump rate model v two. See, warp is providing sort of half the step count for all of these functions. Step count is basically analogous to efficiency or I guess, I don't want to say gas, but computation. So you can see the transpiler is generating functions that are much more efficient than warp one. Warp two still. I mean, sorry, handwritten, still very much more efficient. But the real surprise comes from the step counts of the open zeppelin contracts.
00:16:33.306 - 00:17:19.950, Speaker C: You can see warp two does a much better job. Yeah, it really reduced it. Most of these functions over here, so such as name, symbol, total supply, these are just sort of storage variables. You can see warp one had quite a hard time dealing with them. But with warp two and the optimizations we've built in, yeah, it's really reduced it by orders of magnitude. So yeah, those are the two of the real cool features about not using the Yule intermediary and going direct from solidity to Cairo. The second benefit, or I guess you could say the third benefit, is we have increased readability for Cairo for the transpiled functions.
00:17:19.950 - 00:18:05.850, Speaker C: So here we just have an approved function from that ERC 20 open Zephyr contract. Fairly readable. Obviously it's solidity, we all know how to read it. But once transpiled we keep the function names there, we keep the comments there, the documentation, the Cairo that's generated is readable. Warp one, this would have exploded, would be a lot of lines. But yeah, it makes developing with warp much more easier and user friendly. And then sort of the last thing we threw in as well is all these helpful unsupported feature messages from swapnal.
00:18:05.850 - 00:18:48.460, Speaker C: Nothing's worse than using a package and you just get a random typescript error. And it's not like it doesn't really tell you anything about the tool you're using, just that there's an error in the code. So here we've added these unsupported feature messages just so we can guide the sort of developers as they use the tool into knowing what features we do support and don't support, because obviously finding an equivalent from solidity into starknet is quite challenging. So there are a few features we don't support yet, but in the future we're working on it. And yeah, there'll be a closer mapping between the two.
00:18:49.950 - 00:19:51.920, Speaker A: That's super cool. So something, can you go up a bit in the function that is transpile, please? So there's a question on the chat, and I'm actually also really interested into it. Can you discuss Warp's storage model? Can you explain a bit how data is stored in the warp contract? Because I see the functions are named the same, or there's some prototype that is similar. I see that you wrote some specific warp function, but I think, which are understandable, I think where there is something that is very peculiar is for storage. Can you talk a bit about it please? Sorry, did you hear me? I'm not sure. It's cutting up a bit. Sorry.
00:19:58.290 - 00:19:59.840, Speaker B: I think we're losing guy.
00:20:00.850 - 00:20:05.486, Speaker A: So I don't know, Jorek, if you can maybe talk a bit about Warp's storage.
00:20:05.598 - 00:20:52.830, Speaker B: Yes, yes. So the most surprising thing that you'd face with the storage model is that the storage VAR that you'd have for your storage is actually just one single VAR. So we don't transpile every single storage VAR. The reason that we have to do this is because in solidity you can have references to storage and we'd have to be able to update those references consistently. And we looked at a number of different models. So you can have a pointer to a storage bar, right, in solidity. And if you updated this storage pointer and then updated some value inside it, you'd have to make sure that all the other references are correct and have the right pointers to the right storage varies.
00:20:52.830 - 00:21:28.510, Speaker B: And we run into some problems here, because the most naive way to do it, for example, would be to write some form of enum for every single storage like storage VAR that you instantiate and then switch over those when you are accessing a reference to a storage bar. This is a bit ugly. So what we've actually done is we've just created one unified storage space, and the entire storage space has indexes which we use to keep track of which storage file you're referencing to. This makes the storage model a bit opaque and one of the arguments for calling it compiler over transpiler.
00:21:31.490 - 00:21:48.130, Speaker A: Interesting. So basically there were functions like the way storage works on solidity. And in Cairo is so different that you had to re implement a storage model, some kind of fraction on top of Cairo. Doesn't this create a lot of overhead?
00:21:51.190 - 00:22:08.938, Speaker B: No, this doesn't create a lot of overhead because the compiler is aware what the indexes are to the various storage models. So it is just a key for accessing the data. We don't actually store more data than is required, so they're quite similar in performance. Now where this, sorry.
00:22:09.104 - 00:22:13.558, Speaker D: It's actually quite similar to how solidity compiles the Yule and how it handles.
00:22:13.654 - 00:22:15.500, Speaker A: You're muted on discord. Sorry.
00:22:19.950 - 00:22:30.830, Speaker D: So how warp search model works is actually quite similar to how we compile the U, the storage model, how it handles that is quite similar. So that was also a part of my explanation.
00:22:31.650 - 00:22:32.720, Speaker A: Really interesting.
00:22:33.490 - 00:23:08.238, Speaker B: Yes. So this is another layer where you get two levels of abstraction on top of each other. The UL was implementing its own storage model, and then we would have to then write a translation from that to the Cairo storage model. That was causing us a lot of overhead as well. So in memory we have something quite similar. We have like one memory location, except for, yeah, no, sorry. Memory is we just use addict access model, which is default from the Cairo package, and that is just a key value store.
00:23:08.238 - 00:23:44.950, Speaker B: And we do the same thing. We implement our own memory model. Everything which is a basic type gets stored directly into some key value pair there. And if it's a more complex type, we make it a reference to another area memory. And the reason we do that is for the same reason that we have multiple references to the same memory values, and we need to make sure that those stay correct throughout the program. That does add a bit overhead, because now you have two abstractions for referencing some more complex types, but those would be structs and arrays would be slightly.
00:23:46.730 - 00:24:00.830, Speaker A: Oh, follow up question by Maisushka. This model produces non straightforward Cairo code. Isn't it just a mismatch between what warp needs and what Cairo storage API provides?
00:24:03.170 - 00:24:03.920, Speaker B: Yeah.
00:24:05.730 - 00:24:08.626, Speaker D: What it provides is not what we need to be able to work around it.
00:24:08.648 - 00:24:10.020, Speaker B: Basically, that's the issue.
00:24:11.350 - 00:24:13.460, Speaker A: Okay, I'm not sure you heard your answer.
00:24:16.150 - 00:24:17.282, Speaker D: The Cairo model, sorry.
00:24:17.336 - 00:24:18.834, Speaker C: That it provides is not enough for.
00:24:18.872 - 00:24:23.010, Speaker D: What solidity needs, so walk has to work around it and make a decision.
00:24:25.530 - 00:25:04.740, Speaker B: Yes, there are very good reasons why these things are different. The VM, the Cairo workshop works really well for its implementation for the ZK part of this, but referencing everything is done with two registers, and Cairo works really well for that model. It could be raised up to a solidity like level, but I think Cairo should be free to do some things differently and to experiment with its own models. And so it makes sense to go from solidity to Cairo and do this transformation step.
00:25:06.470 - 00:25:31.642, Speaker A: Thank you. So I have a question. The first one would be, how would you compare theoretical ZKe VM with warp is what do you get in one case? What don't, you don't get in one case in the other. And what are the trade offs? It's a broad question. Right?
00:25:31.696 - 00:26:27.146, Speaker B: But it is a broad question. If we take a theoretical ZK EVM, you basically have the full EVM implementation, right? So out of the box you get almost all of the implementers lily working in this space, which is a really nice property. But the proof system and everything else is now constrained by the constructs of this EVM. And the performance is also linked to the implementation of the EVM. So I think it makes sense to go through your own model and to explore maybe better languages that might reveal the trade offs between performance for the end user. If we have warp, the trade off here is that we don't implement everything that the EVM would support. And there are certain differences that are as a result of Cairo having a different semantic representation and the translation doesn't make sense.
00:26:27.146 - 00:26:33.920, Speaker B: And there are a few where it just got so prohibitively costly that it didn't really make sense to do.
00:26:34.850 - 00:26:45.394, Speaker A: There's also difference in the way the two networks are structured, right? I mean, there are some concepts at the network level that don't map from Ethereum to Starknet and the other way.
00:26:45.592 - 00:27:40.820, Speaker B: Absolutely. So I actually think that having something like warp allows a target more flexibility in the sense that starknet does not need to be EVM compatible. And I can choose different network configurations and systems and that we can very clearly show to the end user which constructs from simulatory work very well and that they can modify their code accordingly. And to be honest, the majority of things work very well out of the box. So it doesn't seem like a huge effort to change your code over if you have a large liquidity code base and then to try and warp it. Warp is very helpful in this. It will tell you exactly retreated to unsupported and usually it's just a simple matter of deleting a few lines here or there.
00:27:41.430 - 00:27:58.140, Speaker A: Superb. I'm very eager to see people using Warp. I think it's a great tool to onboard people who have a solidity code base and want to be able to deploy it to Starknet. Who do you think Warp is for and who is it not for?
00:28:00.110 - 00:28:51.178, Speaker B: Yeah, Warp can be for projects that want to very quickly prototype on Starknet. And if you already have a large solidity code base, it's really worth just trying to warp the whole thing, see what works, what doesn't work, and then patching it up so that it deploys on Starknet. That's pretty incredible considering how much time it could save you. It's really useful as well if you are writing in low level Cairo because you want to be as efficient as possible. For example, that's another difference between having an EVM compatible language and using Warp. You can handle the efficiencies better if you're not going through a complex transpiler like Warp. Yeah, you could for example, leverage any solidity libraries that are out there and just warp them.
00:28:51.178 - 00:28:55.226, Speaker B: And then you would have all the functionality of libraries that have already been written within the wait.
00:28:55.248 - 00:29:02.762, Speaker A: But if you do that, you mean you could take a library in solidity, warp it in Cairo and then use it from a Cairo contract?
00:29:02.906 - 00:29:04.000, Speaker B: Yes, you could.
00:29:04.610 - 00:29:17.410, Speaker A: That's pretty cool. So it would basically save you the time to re implement the library in Cairo. You would probably lose a bit in performances, but you get the speed of experimenting with it. And if at some point you need to make it better you can re implement?
00:29:17.750 - 00:29:32.550, Speaker B: Absolutely. For example, I think we use Ray and Wadmath a lot in the Azay project, and I have written a handwritten implementation myself and then I warped it a couple of weeks later when Warp was ready and I would have saved myself all that time. It would have worked perfectly.
00:29:35.850 - 00:29:47.920, Speaker A: Cool. So if you have a solidity code base, it's good to use it. If you want to experiment with some solidity libraries that are not on Cairo, it's a good thing. Who is Warp not for?
00:29:52.290 - 00:30:33.114, Speaker B: Warp is probably not for sliding maximalists. If you want every concept, it's not going to work. Yeah, Warp will also lag behind the Cairo implementation the small bit all the time, which is not a huge issue and is probably not going to impact most people. But if you want to use the absolute latest and greatest out of Cairo, then stick to Cairo. And there are a lot of developments in theware space, so it's not for you. If you want to just write a Cairo project like from start to finish. Yeah, I'm not really sure who it's not for, it's just for those who want to use it.
00:30:33.114 - 00:30:58.340, Speaker B: I guess I don't see any major drawbacks. If your solidity is already really heavy and has a huge overhead, it might be a severe bottleneck to try and warp that. But I think it still remains to be seen in the wild what the performance is on a really big project, and we're really excited to find out, so please try it and let us know.
00:30:59.350 - 00:31:12.760, Speaker D: One more point to that work is also for new developers who don't want to delve into Kyro, which is not a non triple language. If you can just do the subset of solidity that Warp supports, then work is for you.
00:31:13.710 - 00:32:12.460, Speaker A: Cool. Yeah. So if you want to start to try starknet easily, don't want to start a new language, then you can use amazing. So Masieche is asking, I hope I say his name right. What about correctness of the transpilation process? How are you going to ensure output? Cairo is equivalent to input solidity, basically the way I understand it. And correct me if I'm wrong, it's a weird analogy, but the way compilation works is kind of like when you have a product id and you get executives asking devs to implement it, right? So it's from high level to low level transpilation is some executives asking other executives to ask their devs to do something. So this part like having executives talk with executive and be able to transpire it to pass the message correctly down can be challenging, obviously.
00:32:12.460 - 00:32:14.054, Speaker A: Weird.
00:32:14.102 - 00:32:16.694, Speaker B: And anyway, about the correctness.
00:32:16.742 - 00:32:29.714, Speaker D: So this is something that we work, most of our testing is based for this. So there's something called the semantic test in the solidity repo, which is the compiler, and test each bit of semantics for the smallest constructs. So there will be like one for.
00:32:29.752 - 00:32:30.340, Speaker B: Message.
00:32:34.630 - 00:33:03.530, Speaker D: Signature and the smallest species you can think of. If else, while loops, anything, there will be a small test file that will say the inputs and the outputs that is expected for that bit of sync code. We take that solidity code, we transpile it, we feed the same input and we expect the same output. That's our major way of testing if warp is correct. Warp is also being audited right now, so hopefully that will also add more guarantees there. But that's a way of making sure that transpires correctly.
00:33:03.950 - 00:33:09.130, Speaker A: So basically a whole lot of testing. How many tests do you guys have for warp?
00:33:10.670 - 00:33:20.466, Speaker D: So depending on how you count the test, like you count each function as a test, you count one file as a test. Let's say you count one file as a test. I'd say there are about 1000 plus.
00:33:20.568 - 00:33:25.906, Speaker B: At least decent testing can take long as.
00:33:25.928 - 00:33:26.740, Speaker D: That was.
00:33:32.970 - 00:33:36.150, Speaker A: Very nice. Yeah, no, go ahead, George.
00:33:36.570 - 00:34:29.910, Speaker B: I was going to say, for those who are curious, the definition of correctness is that for all of the inputs that a function receives, you will get the same output from the style result and from the original result. And so it's very important that all of the, this is kind of interesting in this space, because the inputs in Cairo and the inputs in affinity are fundamentally different. Right. We have the felt type versus uints and ints and so on. The way that we restrict the space is that every function call will do a runtime check to make sure that those values are within the bounds expected and represented in their felt form, and then we'd run the test. So we also test quite heavily the inputs and the outputs of function calls. Well, like the input transformation of function calls, to make sure that we don't end up putting wrong inputs in and getting behavior we're not expecting.
00:34:29.910 - 00:34:35.030, Speaker B: That's just an extra little piece of the puzzle.
00:34:36.190 - 00:34:55.790, Speaker A: Very cool. So you guys released recently warp two. My following question is, what's next? Should we wait for warp free? Or what are you guys working on? What's the next step for Warp?
00:34:57.570 - 00:35:29.194, Speaker D: A lot of work is now being put into exploring how we can integrate warp into already existing solidity tooling. It'd be nice if we could just use your turn tool like hard hat and brownie or whatever, and warp just works with that. So there's another team looking into that. There's work going to be done into looking at writing tutorials and a bit of marketing so that people can onboard to it easily. And then there's obviously also work into making it efficient and making it more which complete. So there's already work being done on decreasing the size of the unsupported feature list.
00:35:29.232 - 00:35:29.820, Speaker B: Basically.
00:35:31.390 - 00:35:32.140, Speaker A: Nice.
00:35:34.030 - 00:35:58.530, Speaker B: If you check out the warp repo, you'll see the list of unsupported features and then you'll see question marks on those that are being worked on and little hammers on those that are being currently worked on, as in like being implemented at the moment. And then big Red X's, so you know those ones are not coming. There will not be a warp three because there aren't any real fundamental shifts that can still be taken unless solidity changes drastically or Cairo changes drastically.
00:36:00.550 - 00:36:03.474, Speaker A: There might be a warp three, then.
00:36:03.512 - 00:36:04.900, Speaker B: There might be a warp three.
00:36:08.570 - 00:36:47.060, Speaker A: But. Okay, understood. I guess my question was really geared towards, I mean, having a language that is easy to use, such as solidity, because it's well documented and everything is nice. I've gone to realize that the big mode of solidity is not necessarily just the language, it's the integration with all the tooling, just like you mentioned. Swap, Neil. And I'm curious about how it would be great if it were possible to just use your rhapat project in solidity and just change the endpoint and say, yeah, deploy to Starknet and then in the background have warp running to transpile it and deploy it.
00:36:47.990 - 00:37:07.658, Speaker D: Yeah, so we have a team of two or three people right now looking just into those, just integrations with other tools. Hopefully the UX will be that smooth. Hopefully the UX will just be target start net mainet alpha, whatever you want. And that should just work out of the box. It's not going to be some hiccups, but hopefully not too many.
00:37:07.824 - 00:37:23.150, Speaker A: I guess you're going to need also like an AiRPC translator, right? Not a transpiler, but a translator because you don't use the same endpoint and you don't use them the same way between Starknet and Ethereum.
00:37:23.490 - 00:37:23.902, Speaker B: Yeah.
00:37:23.956 - 00:37:29.470, Speaker D: So hopefully we'll collaborate with the tool writers themselves, hopefully to fix all those bits.
00:37:30.630 - 00:38:12.954, Speaker A: Awesome. Guys. I think I've asked most of the questions I have so people in the audience, if you ask to ask questions either on YouTube or on Discord, feel free to do so. So there's a bunch of people saying hi, on YouTube, hello, nice to have you here, there's a bunch of people listening on discord. So very nice to have all of you here also. Yeah. So while we're waiting, I'm going to ask a question that is, it's hard for me to rephrase it exactly, but recently somebody asked me, oh, but prove.
00:38:12.954 - 00:39:06.366, Speaker A: So wait, when you write Cairo code, you can generate a proof for the code. How is this different than formal verification? You mentioned earlier that you guys work on formal verification and that you have formal verification. You're working on formal verification for Cairo. The way I answered was like, formal verification is to conceptually prove that your program is sound. Provable computing is to show that n execution of a program, sound or not, is correct. But it's fun because for both we kind of generate a proof to prove that it's correct. How would you define both, and how are they complementary? I don't know if you guys work on form of verification, maybe that's a.
00:39:06.388 - 00:39:42.300, Speaker D: Good question, but I think an analogy here might help. Right, so let's say you're writing a program on Stocknet which calculates factorial. When you submit that to Starnet, the starnet proof is not checking if this actually produces factorial, it's checking if it produces a valid state transition, whereas you might formally verify and write a model that does checking specifically for factorial. Basically, the goal here would be different. The goal of Saturn is to check if you're doing a provable correct state transition. And in case of formal protocol or something, you're checking if the liquidity stays as it should or something like that.
00:39:43.470 - 00:40:37.740, Speaker B: I think it's a bit of unfair question already, because you answered it perfectly. But I would say there's different properties about something which you wish to prove, and each one requires a different proof system for it. And so that is what is happening here. We're layering proof systems on top of each other to get behavior that you would expect. So we want to say the property is that there is integrity in our computation. Then we generate a proof of the execution of the program, and then we get the property integrity out of it. If you want to say that the computation does what you thought that it should do, which is a specification, then you use formal verification to write a model of what the output should be in relation to the inputs in some sense, or the behavior of the system like it always terminates, which is almost possible.
00:40:37.740 - 00:41:31.280, Speaker B: There's some subset of behavior that you wish to prove, and then you write your statements in one language, and then it takes statements in your target language, and sees, do all these statements together have the property that we. So in this case, it's the model that you have, and then Cairo as the language is the statements that you're checking it against. In the proving case of integrity, your model is actually the Cairo program, and the proof is over the statements of the trace of the execution of the program. Right. So those are the same thing. And in the same way you have type systems. Type systems just say that the data that you're operating over is what you expect it to be.
00:41:31.280 - 00:41:49.250, Speaker B: It's much deeper than that, but it's also a form of proof that your program has a particular property that you expect. And so all of these things are like, yeah, they're instances of very similar ideas.
00:41:51.370 - 00:42:11.180, Speaker A: Interesting. Thank you. All right, I actually have one last question for warp. Can you talk a bit? So you guys are also working on porting Ave to Starknet, right? Ave Av depends on how you pronounce it. Right. Ghost lending protocol. I say that way.
00:42:11.180 - 00:42:42.370, Speaker A: So you guys are working on porting Ave to Starknet. How did warp fit into that picture? I know there is some projects to. How did you guys approach it? Do we develop new feature? Do we develop new features in solidity? Then warp it. Do we reuse the code base? Warp it. Do we rewrite the code base in Cairo? How did you guys approach it? And what were the requirements from Ave to have this work soundly.
00:42:44.710 - 00:43:19.998, Speaker B: Right. The design phase, when we were involved, it was actually the phase one, which is not the full implementation of Ave. It's a much smaller project compared to the Ave protocol. In total. At the time when we were writing this, Warp one was the only thing that was available and it was not actually feasible to use Warp two yet because it just didn't produce any useful output. So in our work with it, what we wanted was warp to be ready, but this wasn't the reality. So it didn't actually feature in our implementation phase at all.
00:43:19.998 - 00:44:02.000, Speaker B: But retrospectively, as I mentioned before, I went through a couple of libraries that we used and warped them and realized I would have saved myself a lot of time. So I kind of wish that we had Warf when we had done that. Now with the second Ave phase swap and I are not actually involved with it anymore, but I think that they are going to do a Cairo implementation from the ground up. And the reason being is that they need to ensure that there's auditability of the output code. And what the situation as it is now is that warp isn't audited. Right. So we make no guarantees about what the output of your code is.
00:44:02.000 - 00:44:33.862, Speaker B: No official ones. I think it's pretty good. So it means that the avid project can't rely on the output of warp yet to say, yes, this is good enough for us to deploy. And auditing what comes out of warp could be quite tricky if they also need to audit the memory model and the storage model, which you would get for free once the warp audit is finished. Right. So then the auditors would say, well, we trusted warp, like the storage and memory model, which is correct. And now we just check the implementation details that are in the functions themselves.
00:44:33.862 - 00:45:53.390, Speaker B: In Kalo, that's one example. But I think what's happening at the moment is that we have a bunch of interns looking at some of the sub modules in the Ave project that might be quick to work on, and we're giving them as like practiceable projects while we're working out the full design of Ave phase two. And what we've had one or two interns do, we just walk them to see what their equivalent Cairo would look like. And so it's good for exploring and seeing how equivalent Cairo might look because it's not that far off in a lot of cases. So I could even see a situation where you could warp something that's not really complex to implement, but might take you a long time to transpile over to Cairo by hand and then just going through it and editing it out to a really clean handwritten version, which one of our interns did, and it just a really nice result. Now it's not necessary because they're almost equivalent, but it is a good way to just get into use of the contract on the power side. So we will not be using Orc for the same reason as we didn't do it in the Ave phase one, which is that we don't have an audited output.
00:45:53.390 - 00:45:59.090, Speaker B: But I really wish that we could have because I think it would have saved us a lot of time, maybe.
00:45:59.160 - 00:46:02.366, Speaker A: For the next phase of Ave, who knows?
00:46:02.478 - 00:46:03.650, Speaker B: Yeah, who knows?
00:46:04.330 - 00:46:14.360, Speaker A: Cool. All right, guys, we are 15 minutes into our call. I think we covered most of the question I have. Is there any points you wish we'd mentioned?
00:46:15.850 - 00:46:16.600, Speaker B: No.
00:46:16.970 - 00:46:20.118, Speaker D: Please try it out and let us know what works and what doesn't.
00:46:20.214 - 00:46:21.580, Speaker A: How do we find it?
00:46:22.270 - 00:46:26.560, Speaker D: You can find it on the GitHub repo, which you can link in the Discord as well.
00:46:28.130 - 00:47:08.060, Speaker A: So it's HTTP two point GitHub. I'm posting it in the community call. All right, so I posted it on discord in the community call channel I'm actually going to put it in the chat also on YouTube live so that people can go on the repo, never mind eat warp. And yeah. All right, guys, look, thanks again for attending our community call and presenting. Really excited to see what people come up with warp. We're not working right now on it, but we do plan on having a warp tutorial out soon.
00:47:08.060 - 00:47:24.240, Speaker A: So do keep an eye on that also. Yeah. And in the meanwhile, thank you for your work and to talk more once you guys have more integration with tools and stuff like that.
00:47:25.010 - 00:47:26.238, Speaker D: Thank you for having us.
00:47:26.324 - 00:47:52.520, Speaker A: Very cool. And for all of you listening to the community call on YouTube, on Discord, thanks for attending. I hope you learned something today. And yeah, next time we meet is not in two weeks because there's going to be eat cc week in Paris. So I hope I'll see a lot of you around to eat good stuff and listen to interesting talks. Jorik and Sapneil, will you be around?
00:47:54.970 - 00:47:58.120, Speaker D: I'm sorry, unfortunately I can't come.
00:47:58.510 - 00:47:59.610, Speaker A: You're lost.
00:48:00.030 - 00:48:13.646, Speaker B: I know I'm a question mark because of personal reasons, but Guy McComb will be there and so Greg, he's also worked on the project and one other person, I can't remember who. So yeah, there will be another my people around and definitely come and talk to us.
00:48:13.828 - 00:48:36.678, Speaker A: Amazing. Super cool. So there's not going to be a call on the week of like it should have been on Tuesday 19th. So next call is going to be on Tuesday 26. So we're going to have this time we're going to talk about full nodes. So thanks everyone for attending and have a good day.
00:48:36.844 - 00:48:41.010, Speaker B: Thank you. Yeah, bye.
