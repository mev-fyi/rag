00:00:03.440 - 00:01:14.420, Speaker A: Hi, I'm Ori. Today I'm going to talk about how we are solving the halting problem for Starknet. That's a bit extreme, but actually how do we prevent attacks on Starknet from users that try to run infinite loops? The main scenario we're going to discuss is this user sends this code to Starknet. This code is a recursion that would never stop because has no stopping condition. We need to stop this from happening, otherwise we would need to detect this happening and won't be able to charge to prove the fact that that happened and charge the user. First solution that we can do is simply adding a gas counter in code. What we're going to do with the gas counter? Oh, I just deduct from it and whenever I ran out of gas I panic without of gas and all is hunky dory.
00:01:14.420 - 00:02:14.332, Speaker A: We prove the user I've ran out of gas, improve the entire trace run execution. It's all good, but this is user code. How can we actually make sure the user actually added gas counting information here? So a reminder in Shakur's lecture that I hope you yesterday, otherwise I would give a quick reminder. Anyway, we have a Sierra, which is a safe intermediate representation that this is the sort of code we are going to accept on Starknet. It is a very structured IR, meaning we can add simple constraints on it to make sure that the user of this code provided us with any information we actually require. So using Sierra, we can just inject a gas change and check per command. If we've got this code, you can ignore the actual content of the code.
00:02:14.332 - 00:03:03.260, Speaker A: But let's believe me, it's some sort of fibonacci implementation that sort of look like Sierra. We can add a getgas statement and failure in every line I try to get gas. If I succeed, I continue, if I fail, I panic. Since the user did not actually send the code, everyone's happy. But if we ran out of gas in this line, we can prove I got to this line and we ran out of gas, so we were happy. Issue some functionalities are much cheaper or pricier than others. For example, obviously getting the constant one is much cheaper than actually calling the Fibonacci code itself recursively.
00:03:03.260 - 00:04:02.920, Speaker A: Okay, let's try another solution. We can inject a gas change, but having varying costs, same code. This time I ask for the varying amount of gas per command. Okay, so we solved the varying prices issues, but still this adds an additional gas check for every command, which makes at least all the chief commands at least twice as pricey. And also it means that every command may fail, which first of all, still makes everything pricier. Second of all, if some of you remember Shakan's lecture, there are some specific instances that we have to call code, which means we can exit the code at every point in time. If we can exit the code in every point in time, it means we need to do some sort of special error handling to make sure the code is still provable, which is pretty difficult.
00:04:02.920 - 00:05:28.518, Speaker A: Solution the gas wallet what is a gas wallet? A gas wallet is a compile time solution for us to know that the submit user code provide. Does this specify to some constraint about gas usage? We'd see specific example. What we actually are doing is in compile time we are bookkeeping some sort of gas wallet, while when we add each and every command statement into we are trying to add it to the run, we can deduct its price from the local wallet and we validate that you never actually ran out of gas in this wallet. This is the simple constraint we added to Sierra here, and we added a new special command for Getgaz, which is the only command that can actually fail. When I try to call Getgaz, I can fail and exit the program, which means the only place I need to actually handle errors in these sort of focal points. So our CR code now would have a simple additional getgaz. In the beginning I ask for 30 gas units, and I know I can at least run the code until the next time I would get to get gas.
00:05:28.518 - 00:05:59.750, Speaker A: We would run through a very simple example. Now let's assume I have five available steps in my wallet. I'm calling the get gas. If I failed, I would exit assuming succeeded. After this line I've got 35 available steps of gas. I'll try running, and this branch I take one step, the ad costs another one, the cost, and the rest of the until the function call costs an additional six. And on the other example, I got to the other branch.
00:05:59.750 - 00:06:01.980, Speaker A: I only took the price.
00:06:04.110 - 00:06:04.586, Speaker B: Of the.
00:06:04.608 - 00:06:48.054, Speaker A: First action, but in the merge I would use the worst possible case. Here I still made sure that I haven't ran out of gas in any of the branches, and I'm still happy. And I know that I can verify by in the compilation stage here that I never actually would be able of running out of gas without marking it in my actual gas counter. That is provided for the context of the running program. As I mentioned earlier, we've got the issue with Sierra linear types. Sierra in Sierra variables we must destroy return all the variables some. This may be quite heavy.
00:06:48.054 - 00:07:22.120, Speaker A: For example, dix squash, dick squash is after I do any sort of dictionary accesses. I got to do a dick squash in order to be able to prove the fact that these sort of accesses were actually valid. Otherwise, it means my code is not sound. Meaning in Sierra we make sure that every time I construct a dictionary, I need to destroy it using dick squash. But if you look at this example, there is no dictionary here. But if there would have been the Getgas command, I said it panics. I still need to make sure a squash is called.
00:07:22.120 - 00:08:07.614, Speaker A: Why is that an issue? So that could be an issue because I said I panic out. And I still need to make sure that I call this command. And dick squash specifically is a pretty expensive command. Its cost corresponds exactly to the amount of accesses that actually happened. Meaning if I did a lot of access there and I ran out of gas, now I need to call a very heavy command while I ran out of gas, which means someone can make me use a lot more gas than I actually plan to. The trick here is precharging the cost. As I said, the squash command corresponds to the amount of access to the dictionary.
00:08:07.614 - 00:09:25.230, Speaker A: So despite the fact that access to a dictionary is not that pricey by itself, I would pre charge the price of destroying this access in this cross stage, during the access stage. So instead of the actual cost of, let's assume twelve steps for readers and writes, and the actual 100 plus 70 for the number of axes, instead, I would actually charge at the time of the axis plus the 70 for the axis itself. Which means that even though I ran out of gas, I already precharged all the problematic parts of the squash command, so I'd be able to call it. Another issue is in the case of deconstructor loops. For example, if I have an array of such dictionaries, I still need to call the squash of all the dictionaries, right? Because I said if I don't squash all my dictionaries, my code is unprovable, so somehow I must be able to call them. What would I do? Instead of having an array of the heavy object, I have an array of the heavy object plus a price. Gas coupon.
00:09:25.230 - 00:10:18.670, Speaker A: What's a gas coupon? I can call the gas coupon. Create a gas coupon. It would deduct from my local wallet, but it would create an object that once I decide to release, I give back into my local wallet. So even though I called getgas summer entirely different, I already precharged for this destruction command. So when I have the array of heavy plus coupon tuples. I can just iterate over it, redeem the coupon and heavy drop, and despite this seems that it should cost amount of gas that correspond to the size of ARR. It actually costs zero because the coupon itself gave me an existing gas to be able to redeem it and do this all even though I already ran out of gas.
00:10:18.670 - 00:11:46.570, Speaker A: Just a small example, this is actual Sierra code in an Android level, but you can see that one of the first commands is actually us if there's an if on gas gas and handling of the error case in case of the actual failure in our generated code. Another things we can solve here is prices for dynamic cost sort of objects. For example, hashes may have dynamic costing and other builtins may have dynamic costing and we don't want to ahead of time say, I don't know, Peterson cost 100 units of correspond to 100 steps. I want the OS to be able to decide what is the cost of Peterson hash for example. So instead of only having the steps, the step token type inside my local wallet, I can do the exact same process that I described earlier for other kind of steps and still bookkeep for each and every one of these and make sure it never goes negative and make sure I can get the gas for it. Of course, getting gas for something that I decide has a non console cost would be a bit pricier since I need to calculate the amount of actual gas I want to take from some price table given to me by the OS.
00:11:48.350 - 00:11:49.100, Speaker B: Yeah.
00:11:52.990 - 00:12:24.330, Speaker A: So yeah, that was the main part of the presentation. If you want some questions about Sierra, generally about specifically what we discuss here about our ability of how to solve gas, ask away. Yes, in this slide I saw you are charging less fee for scratch squash squash.
00:12:24.510 - 00:12:31.126, Speaker C: So what happens if it requires more gas fee here?
00:12:31.308 - 00:13:03.922, Speaker A: Yeah, what about it actually cost less than the charges? The total cost in both cases is exactly the same, although I pre charge everything in this case. That's the idea that I won't be able to create enough accesses that create the squash. If I would have ran out of gas, I would have ran out of gas earlier and still would have needed to call the squash. So I can still prove the exact process of the I would still call squash. So all my code would be provable. Anything else?
00:13:03.976 - 00:13:04.580, Speaker B: Yes.
00:13:13.640 - 00:14:04.310, Speaker A: Okay, so the question here, if I can basically bound an area of code to have a specific gas bound right on the transaction level. So if I won't have a get gas command and have no recursive, if I have any recursive code, by definition, I don't know the amount of gas I'm going to take. So it would have to have some sort of getgas command and I would need to check it and deduce from some sort of actual gas counter. But if I have no recursion at all, I can actually know the exact cost of calling the function and it would be entirely fine as long as the entry point itself would still need to decide. I need to make sure this user had enough gas in his wallet to call this and it would be deducted from his account.
00:14:05.480 - 00:14:06.230, Speaker B: Yes.
00:14:14.200 - 00:14:28.860, Speaker A: No, this is all in Sierra level. The actual submit Sierra code is going to have gas instances, but this is mostly going to be hidden. Unless you really don't want it to be hidden.
00:14:30.880 - 00:14:31.388, Speaker B: Yes.
00:14:31.474 - 00:14:39.640, Speaker C: Can you talk about cost in Sierra and why for instance, read and write being the same cost can somewhat surprising.
00:14:39.800 - 00:14:42.092, Speaker A: That read and write for the dictionary of the same cost.
00:14:42.146 - 00:14:42.750, Speaker C: Yeah.
00:14:45.380 - 00:15:05.910, Speaker A: So dictionary specifically, it's a completely different subject, but the dictionary itself is a set of accesses that later. I validate that it makes sense. The squash action is validating that the previous access made sense. So an access of read and write is basically the same thing. I just need to make sure.
00:15:07.740 - 00:15:08.104, Speaker B: The.
00:15:08.142 - 00:15:10.760, Speaker A: Series of accesses make sense. And that's a squash command.
00:15:13.540 - 00:15:14.290, Speaker B: Yes.
00:15:15.620 - 00:15:50.860, Speaker A: Maybe I didn't understand very well, but on the pictures you showed, there was no gas check for the return statement. For the return statement? Yeah, if I remember well, there was no gas check. Which one? The actual code or I need to know. I think it was the first one we showed here. Yeah, it's fake code. Anyway. The return statement doesn't have a gas cost just because the call statement has a gas cost of two.
00:15:50.860 - 00:15:56.190, Speaker A: So just amortized, make the same amount of sense, but yeah.
00:15:57.120 - 00:15:57.628, Speaker B: Yes.
00:15:57.714 - 00:16:02.860, Speaker D: What's the main difference between Chiro and solency that makes Chiro need this solution?
00:16:03.460 - 00:16:58.426, Speaker A: So first of all, our necessity for linear types makes us have to handle every exit point to make sure all the variables are destroyed or are no longer available, not necessarily destroyed. So we got to handle each and every exit point. Having less exit points makes it much easier. In EVM, as far as I know, every command can fail by running out of gas, varying amount of gas, but still running out of gas. Anything else? Yes, squash command, you basically roll the variable to the dynamic cost into the rent and write. Yeah, but the spot itself still has a constant cost. You can bury it in the construction cost as well, but in every flow, in every running flow, you'd always have the new and the destruction in the same flow.
00:16:58.426 - 00:17:29.580, Speaker A: So I don't really care if it's amortized there or not. But it's not really because you still deduce it to begin with. Yeah, but it's still not actually going to matter there. But it makes it easier to. We have some sort of auto step counters making sure our code generation makes sense, and it's much easier that way if we actually charge whenever it's actually charged as much as we can.
00:17:30.910 - 00:17:31.660, Speaker B: Yes.
00:17:43.300 - 00:17:48.240, Speaker A: Yeah. I mean, at least currently we can compile the error without gas constraint.
00:17:50.180 - 00:17:50.832, Speaker B: Yes.
00:17:50.966 - 00:17:53.250, Speaker D: You calculate the gas based on the.
00:17:55.880 - 00:18:10.584, Speaker A: That was a bit of a lie. We are actually, by hand, realign these and we can actually refund gas counters for alignment. We're not actually doing that currently, but we can do that.
00:18:10.622 - 00:18:25.630, Speaker D: The question is, if I were to have two functions, could be in the water, be taking a lot of gas, but in practice, the first one takes a little gas, takes a lot of gas, and in theory it could run them both.
00:18:26.420 - 00:18:42.042, Speaker A: So the optimized scenario would be handling the gas counter, that the compiler would handle a gas counter and refund the gas for that case. Still, we've got a minute if anyone wants a couple.
00:18:42.196 - 00:18:42.946, Speaker B: Yeah.
00:18:43.128 - 00:18:44.114, Speaker D: When there will be.
00:18:44.152 - 00:18:46.306, Speaker A: For loops, each entry into the for.
00:18:46.328 - 00:18:48.770, Speaker D: Loop will call down. Get gas.
00:18:49.110 - 00:18:57.080, Speaker A: Yes, but if it's too small of a loop, you probably do some rupen rolling. So you'd only get gas once any, I don't know, four iterations or whatever.
00:18:59.690 - 00:19:00.440, Speaker B: Yes.
00:19:01.930 - 00:19:03.480, Speaker D: I mean, if the cost sense.
00:19:07.710 - 00:19:26.440, Speaker A: If you unroll the entire loop, that still makes the match the same amount of sense. If you know the cost of the, of the loop in advance, you can also do the coupon, the coupon method. Anyway. Anything else?
00:19:27.610 - 00:19:28.214, Speaker B: Yes.
00:19:28.332 - 00:19:51.360, Speaker A: Why do I need the key dictionaries? Since if I need to destroy an arbitrary amount of dictionaries, I need to iterate over them for the iteration itself, even just the iteration code would have to cost some gas, so I need to pay for it somehow. Okay, thank you very much.
