00:00:03.320 - 00:01:12.864, Speaker A: I'd actually like to start like, I've been programming in my bedroom for the last six months, so I'm a little nervous presenting, but I'm really excited to present to you all today about Sandstorm. I'd like to say a big thank you to Starquare and especially Louis for inviting me to speak here today. And I'd also like to thank all of you, you, for your interest in my projects and interest in coming to this. Yeah, today I'm going to talk about Sandstorm, which is a Cairo prover that's designed to run fast on consumer devices. So this is like laptops, like smartphones, things like that. I'm going to talk about quite quickly what a Cairo prover is, and then I want to talk about why you want to prove Cairo programs on something like a smartphone or something like a laptop, as opposed to the top of the line Nvidia gpus on AWS. And then at the end, I'd just kind of like to share my story of how I got to working on this stuff and why I'm interested in.
00:01:12.864 - 00:01:58.904, Speaker A: So what is a Cairo approver? Okay, so before we get to a Cairo approver, we have to understand a Cairo runner. So a Cairo runner will take some Cairo source code, it'll take some input and it'll run it and it'll get to some output. This is like you would have with python. You basically run it and you get some output. Except with a Cairo runner, you don't just get some output, you also get memory bin and trace bin. And these are going to be essential for the prover. So memory bin contains all the address value pairs for all the memory accesses that happen during execution of this program.
00:01:58.904 - 00:02:52.424, Speaker A: And trace bin contains all of the register values for every cycle. And we haven't proved anything at this stage. Okay, so this is where the prover comes in. So the prover basically takes values from these two files and lifts them into this huge table. This is what you could call an execution trace, and it's what's required for kind of generating this stark proof. So to get a bit of intuition for this table, basically we would take something like the program counter in trace bin, and we would lift it into, for this example, we'll say like the dark blue square in this table. We'll take the program counter in the first cycle and we'll lift it into the first dark blue square here.
00:02:52.424 - 00:03:43.896, Speaker A: And then we'll take the program counter for the second cycle and we'll lift it into the next dark blue square in this example, a cycle kind of spans four rows, but you could basically lay this out however you want. You could have two cycles on each row, you could have one cycle down 30 rows or something like that. And there's a couple of trade offs to that. So generally speaking, the more vertical you stack this table, the longer it might take to prove, but the smaller the proofs will be. So you can kind of trade off the proof size for prove a time. So, yeah, you can see that the memory bin is also loaded into this table. We load all the values in.
00:03:43.896 - 00:04:43.980, Speaker A: And this is the first job of Sandstorm. This is the first job of the Kyra per river. And the second job is basically defining a set of constraints that maps to a correct state transition of a chirop program. So this is something the verifier and the proverb need to agree on that makes sure that this table is basically the correct execution of a Cairo program. Yes, sandstorm basically collects this, basically generates this table, and generates the set of constraints, and then it hands those to a stark prover, and the stark prover is what's responsible for generating a proof. And this is where you do all of the heavy computation to generate a proof. And then once you've got the proof, you can just use the source code and you can verify that the program was executed correctly.
00:04:43.980 - 00:05:29.064, Speaker A: So, yeah, I just want to basically reiterate, Sandstorm is just the lifting of the values from trace bin and memory bin and basically putting them into this table and also coming up with the set of constraints for Kyra execution. And in this case, the stark prover is ministark. It's a prover I made that's designed to basically run fast on consumer devices. So that's like iPhones, laptops, and also in the browser. And that's what this slide is basically showing. Sanslam says on top it sends the constraints and whatnot to ministark. And I've also got arcworks here.
00:05:29.064 - 00:06:39.904, Speaker A: So instead of re implementing field arithmetic and stuff like that, ministark builds on top of arcworks a great library to kind of not have to re implement all of those primitives. So that's kind of an overview of the Sandstorm Cairo prover, and let's take a look at speed. So how fast can you prove on these consumer devices? Well, sandstorm can prove at around 10,000 Cairo steps per second, but it should be fairly straightforward to get this to around a million steps per second, or 100,000 to a million. And it's at that stage where you can kind of really generate proofs for quite interesting applications. It's actually in making these slides that I was like, oh, 1 million steps per second. I wonder what else is 1 million steps per second. And I was honestly a little bit depressed when I found out that it was the first computer ever made.
00:06:39.904 - 00:07:46.400, Speaker A: But I think I've think about this a bit. It's not exactly the same the processor speed of a SIM card. For instance, in one cycle you might be able to multiply two bytes together, or it might take 20 cycles to read a piece from memory. Whereas in Cairo you could have built ins, for instance, that you basically build a built in so that you can do a ShA 256 hash essentially for free in one cycle, or you can read a memory location in one cycle. So I don't think you can really compare, you definitely can't compare these two things. But I think it is interesting to kind of think about how fast you can prove that and use that to kind of think about what applications you might want to build where you're actually proving on a consumer device on the client side. So that's kind of like a little bit about the speed.
00:07:46.400 - 00:08:49.390, Speaker A: And now I wanted to kind of talk about why would you want to generate proofs on laptops and smartphones when you could send trace bin and memory bin to approving network and get it done for you much quicker. And the real kind of answer here is because it's essential to prove it yourself for privacy. If you're giving away your memory bin and your trace bin, you're basically telling that person who's generating your proof everything that you're trying to do. So if you're making a transaction, you're telling them all the details about your transaction. Or if you're playing a game, for instance, and say you're proving that you're following the rules from a game and this game has some secret information, you're basically like telling someone what that secret information is and you want to keep that private. So you want to basically generate your proof that. So you want to generate the proof yourself.
00:08:49.390 - 00:09:44.990, Speaker A: That's why I really think generating proofs on consumer device is important. And that's definitely one of the reasons why I'm excited about this kind of stuff. Cool. So that's a little bit about why you want to generate proofs on consumer devices on the client side. And now I kind of want to talk a little bit about my journey to making this and kind of like what interested me about this? I heard about stocks around a year ago and I found them really magical I thought, wow, you can verify, like someone executed something and you can do it really quickly. And it captivated me so much. I was like, okay, I need to leave my job and just basically figure out how this stuff works.
00:09:44.990 - 00:10:21.480, Speaker A: So that's what I did. I left my job and I spent six months kind of like trying to figure out how starks work. And I had an amazing time. I really kind of got my passion for programming back. I lost a lot of my savings, but I had a lot of fun. And with Sandstorm specifically, it was interesting. I actually kind of went between the Cairo white paper, I went to Starquare's open source verifier, and then I would basically put all the values that I saw into this Excel spreadsheet.
00:10:21.480 - 00:11:19.036, Speaker A: So this Excel spreadsheet here actually lays out this table that I was kind of showing you earlier. And then I kind of just coded it up. And I think this exercise really showed me kind of how powerful and how amazing Cairo is and how it's kind of like so simple and the best way for executing some program you want. And then you can just kind of create built ins, like really efficient built ins for whatever functionality you want on top of that. So I'm really excited about Cairo and Starknet, and I also want to say I worked on this in a vacuum for six months and I wasn't really sure what people would think when I released it, but I released it and the star community was so encouraging. And I just want to say thank you to everyone and I really appreciated that. I'm working on this.
00:11:19.036 - 00:12:27.500, Speaker A: If you're interested in working on generating proofs on consumer devices or you're interested in generating proofs for your use case, I'd love to chat and. Yeah, thank you so much. This is my information. Thank you. So, yeah, happy to take some questions if there's any like maybe memory observations that you have, because. Yeah, absolutely. That's one of the biggest issues that I've had is basically like when you generate these proofs, they allocate so much memory that you could generate a proof of something like relatively small, and it could easily chew up 60 gigs of memory.
00:12:27.500 - 00:13:13.836, Speaker A: And there's actually ways you can trade this off. So as I said before, the key reason why you want to generate a proof client side is because you want privacy. And the good thing about that is you don't care how big your proof is, you can have the biggest proof you want. That's one way to basically reduce the memory that you need to allocate. Another way is you don't need everything in memory. You can store a lot of it to disk while you're kind of performing the Stark protocol, and you can just kind of like query locations on disk towards the end for the things you need. So yeah, there's like a lot of tricks like that that you can do to kind of reduce the amount of memory you need.
00:13:13.836 - 00:14:07.416, Speaker A: A generator proof. And that's definitely things that I want to explore with this prover. It's not trying to be the fastest prover, it's not trying to run on the best gpus. It's trying to work for the everyday user. It's trying to do that. Any more questions? The use of gpus. One of the key things for this ministark prover is that I want to basically use the GPU, even if that means that the GPU runs kind of slower than the cpu, because generating these stocks is so parallel that it doesn't matter if you have some work that you need to be done, you can offload it to the cpu, you can offload it to the gpu as well.
00:14:07.416 - 00:15:05.172, Speaker A: And they kind of work at the same time. In terms of the gpus that ministock's coding for, it's coding for Apple devices. I'm really trying to focus, so that means writing a lot of the code for these gpus in Apple's programming language for gpus called Metal. And I'm also, I think, most focused on getting this working really well in the browser and using the browser API called web GPU, which has like a shader language. I've run tests with this for ffts with field elements, and I've got near native performance on those. So I'm really excited about the browser. I think these APIs are kind of only on nightly releases, but I think once they're kind of in Chrome, which could be this year, I think you could prove really substantial things in the browser.
00:15:05.172 - 00:15:31.170, Speaker A: And there's tricks that you can do in the browser as well. This is my specialty because I feel like before I was doing Starks, I was doing CSS in JavaScript. So I'm really happy that this is finding a place in the browser. But yeah, you can do a lot of tricks to allocate as much memory as you have in the system and stuff like that. So yeah, hope that helps. Awesome. Thank you.
