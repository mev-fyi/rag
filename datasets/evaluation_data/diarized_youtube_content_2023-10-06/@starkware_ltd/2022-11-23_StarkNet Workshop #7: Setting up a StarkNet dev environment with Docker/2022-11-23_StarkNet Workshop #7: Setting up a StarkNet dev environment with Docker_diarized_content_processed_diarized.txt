00:00:49.740 - 00:00:50.290, Speaker A: You.
00:00:52.020 - 00:01:00.800, Speaker B: I'm muted, that's why. Okay, I wonder why. Can you hear me? I was muted. Just a couple of seconds. Just verifying that the stream is working correctly.
00:01:09.010 - 00:01:10.042, Speaker A: There's a delay.
00:01:10.106 - 00:01:14.400, Speaker B: Muted. All right, I can see that it's working.
00:01:17.900 - 00:01:19.450, Speaker A: Perfect. Okay.
00:01:20.540 - 00:01:40.528, Speaker B: Hello everyone, my name is David Barretto. I'm one of the developer advocates for Stagnet. And today's workshop is focused on how to create the proper development environment for a stagnet project. So we're going to see two approaches.
00:01:40.624 - 00:01:44.196, Speaker A: One very simplistic or easy to use.
00:01:44.218 - 00:02:13.630, Speaker B: That is just using Python built in tools, virtual environments. And then we're going to see what are the limitations of this type of setup. And then we move on to a more complete dev environment that uses Docker to encapsulate even global dependencies. So let's start with the simplistic approach, which is perfectly fine for projects that they only depend on Python, but they don't have any other external dependency. So I'm going to share my screen here.
00:02:22.370 - 00:02:22.830, Speaker A: Okay.
00:02:22.900 - 00:02:35.574, Speaker B: I've been told there's a little bit of echo, but yeah, I don't know, maybe because of the room is not very big. So nothing I can do right now for it. Okay, so you should be seeing my.
00:02:35.612 - 00:02:36.600, Speaker A: Screen now.
00:02:41.340 - 00:02:42.684, Speaker B: Before I jump in into.
00:02:42.722 - 00:02:45.630, Speaker A: The coding, let me show you.
00:02:46.240 - 00:02:49.900, Speaker B: You can search for stagnate.edu medium.
00:02:50.640 - 00:02:52.300, Speaker A: And you should be able to find.
00:02:52.450 - 00:03:04.690, Speaker B: Our medium account where we create blog posts on these topics. So this will be the starting point. This article right here, important here.
00:03:06.660 - 00:03:07.410, Speaker A: Is.
00:03:08.680 - 00:04:03.956, Speaker B: This diagram that you see here, right? So when you want to set up a dev environment, you have multiple options. And of course if you come from solidity and you have used foundry before, you can use Protostar, which is, it uses Python under the hood. So this dev environment will be like a prerequirement for using even Protostar. But you like hard hat also coming from web3. So you could also use a plugin. But in this case you will need to find a way to encapsulate not only Python, because at the end you will need some python tooling, especially the Kyrolang peep package, but you also will need node js to have globally available and probably also the typescript. But then you have a more simplistic approaches, like if you are brand new to web3, then you can use remix, which I'm not going to cover here today.
00:04:03.956 - 00:04:31.070, Speaker B: Or you can just directly just use Chirolang, which is this package created by Starware directly and it's a Python package. Or Nile created by open sepling. So what I'm going to explain today is pretty much like a prerequisite for any of these setups except remix, which remix is just an online ide. All right, so just give me a sec.
00:04:32.080 - 00:04:39.996, Speaker A: Right, so I have here my folder.
00:04:40.028 - 00:04:48.390, Speaker B: So let's create like a simple project folder, let's call it project.
00:04:50.840 - 00:04:53.124, Speaker A: And I get into it.
00:04:53.162 - 00:05:22.270, Speaker B: So in the most simplest approach you would only need Python. But remember that with latest version of Cairo you will need Python 3.9 specifically. And as you try to use an older or even a newer version of Python, you may get some issues when you try to compile. So really need to make sure that you have the right version of the binary. So if you are on a Mac, as I am, you can easily install.
00:05:24.320 - 00:05:30.370, Speaker A: Python 3.9 just by doing this command 3.9.
00:05:31.380 - 00:05:43.590, Speaker B: So in my case I have this already installed, so I'm not going to repeat this, but it's fairly easy to do on a Mac. You will also need this package global install GMP. So Caroline will work.
00:05:44.360 - 00:05:47.348, Speaker A: If you are on Ubuntu, it's kind.
00:05:47.354 - 00:06:28.000, Speaker B: Of difficult to install a specific version of Python. I haven't found a way, a reliable way that it doesn't include just compiling from source, which is a pain. So when we get to the second part of this workshop, which is using Docker, we're going to see an easier way to have this reliable and repeatable environment. But it's not going to depend on which OS in particular you're using. But let's say in this case of using Python we can for example, first create just a simple folder structure. Let's say they have the contracts folder. For our Cairo smart contracts we have the compile.
00:06:28.000 - 00:06:30.048, Speaker B: Let's keep it super simple.
00:06:30.214 - 00:06:34.404, Speaker A: So let's have only these two and.
00:06:34.602 - 00:06:44.036, Speaker B: Now we can use. Let's open this for now Anna and vs code so we can take a look at it. Think it's easier to follow on vs.
00:06:44.068 - 00:06:55.130, Speaker A: Code, increase the font size, open the integrated terminal maybe a little too big like this.
00:06:57.340 - 00:07:14.176, Speaker B: So just to reflect that everything is working, I'm just going to add here a new file. I'm going to call it the ERC 20 Cairo right in whatever separate, verify that it works just by trying to compile one smart contract. And I'm not going to write it.
00:07:14.198 - 00:07:17.600, Speaker A: Myself, I'm just going to go to open sepling.
00:07:19.560 - 00:07:22.096, Speaker B: They have the Cairo wizard.
00:07:22.288 - 00:07:27.956, Speaker A: Yeah, there you are. This is very similar to what you.
00:07:27.978 - 00:07:45.070, Speaker B: Have for Ethereum, but for Cairo smart contracts. So in here we can just pretty much copy paste a simple implementation of ERC 20 token. Just going to copy this to clipboard and going to go back to my editor. I'm just going to paste it here.
00:07:48.560 - 00:07:51.628, Speaker A: So right now I'm not going to.
00:07:51.634 - 00:08:17.872, Speaker B: Be able to compile this because I shouldn't have Caroline installed globally. I don't think I should. So we need to find a way to install these packages in a way that is contained within the project itself. We want to minimize the number of global dependencies. So with Python you can easily create what's called a virtual environment. So we're going to create one with Python 3.9 that we have installed.
00:08:17.872 - 00:08:34.670, Speaker B: And you create this virtual environment by just passing this flag M and then VM, and then you give it a name to the folder that you want. All this not only the binary, but the Python packages that you install from Pip to be stored. So I'm just going to call it.
00:08:35.360 - 00:08:38.670, Speaker A: Let'S call it also m.
00:08:40.400 - 00:08:43.240, Speaker B: So this is going to add a new folder.
00:08:43.320 - 00:08:47.116, Speaker A: To our project M, and every time.
00:08:47.138 - 00:09:28.764, Speaker B: We install a package from PiP it's going to be installed here. So the benefit of doing it this way is that now you can have multiple Cairo projects, each one of them with their own dependencies, and they're going to be isolated from one another. So you can have different versions of the same package for different projects compared to having just everything globally installed. And when you update one dependency, you might be maybe thinking of one project that you want to update, but maybe another project might be breaking because it's not ready to be updated yet. So in this way you can have this an isolation. Of course you don't want this end folder to be tracked by version control. So in this case let's create the.
00:09:28.802 - 00:09:33.004, Speaker A: Git ignore file and let's put it.
00:09:33.042 - 00:09:35.096, Speaker B: Outside of the n folder.
00:09:35.288 - 00:09:37.104, Speaker A: And in here I'm just going to.
00:09:37.222 - 00:09:44.764, Speaker B: Exclude the end folder just to make sure that everything has been tracked and the Git ignore is working correctly.
00:09:44.812 - 00:09:48.980, Speaker A: I'm just going to initialize my repository.
00:09:50.680 - 00:09:53.510, Speaker B: Just add we have right now.
00:09:59.190 - 00:10:01.154, Speaker A: Okay, so we can see now here.
00:10:01.192 - 00:10:30.654, Speaker B: That this m folder is not being tracked because of the Git ignore. So now that we have the virtual environment, we can install pretty much the main dependency of a Cairo project, which is Cairo Lang. But before we do that, we have to activate the virtual environment, because otherwise if I try to run the PiP install command here, it's going to install globally. So to get into our virtual environment we do source and then we go.
00:10:30.692 - 00:10:33.262, Speaker A: To the m folder, we enter into.
00:10:33.316 - 00:10:34.990, Speaker B: Bin and then activate.
00:10:37.010 - 00:10:38.318, Speaker A: And as you can see here in.
00:10:38.324 - 00:11:02.774, Speaker B: The terminal prompt now it tell us that we have the virtual environment active. So any PIp package you install is not going to be globally installed. It's going to be installed in this particular folder for this particular project. So the two main dependencies for project is going to be of course as I mentioned, Cairo Land, which is the official package created by stackware, which is the CLI for Cairo. And then we can use also open.
00:11:02.812 - 00:11:08.806, Speaker A: Zeppelin because given that we are importing here, you're going to see we have.
00:11:08.828 - 00:11:10.318, Speaker B: Some imports from open Zeppelin.
00:11:10.354 - 00:11:12.458, Speaker A: So we need to the library in.
00:11:12.464 - 00:11:58.240, Speaker B: Order to resolve this import. So open Zeppelin Cairo contracts, that's the name. Let me see if I'm spelling this open sepling correctly. Should be correctly. Let's see, let's try to install it. It's going to take a little bit while all these dependencies install on my computer. You can see that even though I only installed two packages, especially Caroline, depends on so many other packages from PiP, that once we create the requirements TXT.
00:11:58.320 - 00:12:00.036, Speaker A: File, you're going to see a lot.
00:12:00.058 - 00:12:10.792, Speaker B: Of dependencies that we didn't explicitly define right now. It's also giving us like a notice that we should upgrade Pip. So we can just go ahead and.
00:12:10.846 - 00:12:13.896, Speaker A: Do that right now so we can.
00:12:13.918 - 00:12:26.296, Speaker B: Get rid of this warning. Okay, so you can see that if I open my end folder, I should.
00:12:26.318 - 00:12:29.604, Speaker A: Be able to see all these packages.
00:12:29.732 - 00:13:11.452, Speaker B: This is all dependencies of Caroline mostly, right? And to verify that Caroline is actually installed and available in our dev environment, in our simple dev environment, we can simply do the compile the version. Okay, so starting compile is one of the CLI that is available when you install Caroline. So we have the latest version of it. So to make all these dependencies explicit.
00:13:11.516 - 00:13:14.416, Speaker A: And tracked by git itself, we can.
00:13:14.438 - 00:13:20.816, Speaker B: Just simply dump all the dependencies and the requirement files. So to do that you do pip.
00:13:20.848 - 00:13:24.196, Speaker A: Freeze, and then you put it on.
00:13:24.218 - 00:13:27.556, Speaker B: A file that is usually called requirements txt. It doesn't need to be called that.
00:13:27.578 - 00:13:31.800, Speaker A: Way, but just typical convention requirements txT.
00:13:32.540 - 00:13:54.296, Speaker B: And now we're going to see here. These are all the packages that your project is going to depend upon. I don't like the way Python manages dependencies. I think pape has a lot to learn from, for example NPM from Javascript. But at least this way we make all these dependencies explicit.
00:13:54.328 - 00:13:56.700, Speaker A: Because you want a way that anyone.
00:13:56.770 - 00:14:22.328, Speaker B: On your team, if you're working in a team, when they run the project and when they clone it for the first time they will have exactly the same dependencies as you do. So there's no inconsistency across team members. To make life a little easier for other team members. The first time they download or clone the project, we can create, let's say a bash file that is going to.
00:14:22.334 - 00:14:25.064, Speaker A: Go ahead and not only create the.
00:14:25.102 - 00:14:31.960, Speaker B: Virtual environment, basically install all these packages, all these Python packages referenced by the recurrence TXT.
00:14:33.820 - 00:14:35.276, Speaker A: Into a virtual environment, right?
00:14:35.298 - 00:14:43.020, Speaker B: So they don't make the mistake of installing that globally. So one way to do it will be I'm just going to create this file called setup.
00:14:47.540 - 00:14:49.728, Speaker A: And then I'm going.
00:14:49.734 - 00:14:51.056, Speaker B: To tell that this is going to.
00:14:51.078 - 00:14:57.696, Speaker A: Be the binary to use is the shell.
00:14:57.888 - 00:15:05.348, Speaker B: And the first I will do, just for house cleaning is if you have this folder ready, the end folder, go.
00:15:05.354 - 00:15:09.556, Speaker A: Ahead and first remove it, then install.
00:15:09.658 - 00:15:25.896, Speaker B: Or create the virtual environment. Remember, this is something that a team member is going to run the first time only, not all the time, although they can run multiple times if they want. That's why we take care of removing that folder before. So basically we're repeating the comments that we did before, but in a file.
00:15:25.928 - 00:15:38.136, Speaker A: So we can share it. We activate the virtual environment and then we activate, and then we install all the dependencies.
00:15:38.168 - 00:15:45.696, Speaker B: In this case we install it from the requirements in the. Txt file, right? So these are all what defined. So we pass the r flag and.
00:15:45.718 - 00:15:49.300, Speaker A: Then the name of the file, and.
00:15:49.370 - 00:16:03.396, Speaker B: Finally we just deactivate the virtual environment once this installation is complete. So to verify that this work, what I'm going to do right now, I'm.
00:16:03.428 - 00:16:09.176, Speaker A: Going to leave my vm, as you can see now I don't see the.
00:16:09.198 - 00:16:11.288, Speaker B: M for the beginning and I'm just.
00:16:11.294 - 00:16:15.308, Speaker A: Going to remove this folder here, right?
00:16:15.394 - 00:16:22.716, Speaker B: So it will be similar to a team member just cloning the preview for the first time. And now I can do something like.
00:16:22.738 - 00:16:26.736, Speaker A: Bash setup sh they should be able.
00:16:26.758 - 00:17:01.300, Speaker B: To do all these steps automatically. You can see that the end folder was created. It's now installing all the packages from the requirements TXT because as I mentioned, there's all these indirect dependencies that needs to be installed.
00:17:07.420 - 00:17:10.584, Speaker A: And it should be done.
00:17:10.702 - 00:17:17.224, Speaker B: Notice that how I'm getting this message again? So maybe we can add this comment here as well. Maybe.
00:17:17.342 - 00:17:21.084, Speaker A: Let's see, right after you install, right.
00:17:21.122 - 00:17:42.576, Speaker B: After we activate the environment, we could upgrade pip so we don't get this message again. Let's try again just to make sure that this install is working. It's going to take a while, but let's see does it matter? Maybe it doesn't matter right now it.
00:17:42.598 - 00:17:45.424, Speaker A: Just added to the list of things.
00:17:45.462 - 00:17:47.956, Speaker B: To install when you set up. So you run this mostly the first.
00:17:47.978 - 00:17:50.624, Speaker A: Time you clone the project or anytime.
00:17:50.672 - 00:18:15.020, Speaker B: That requirements have changed so someone added new dependencies to the project. And that's it. Just to make sure that even though all this was installed in a virtual environment, your terminal is not using the virtual environment yet. So you have to do this again to activate it. So let's try compiling this contract just to see that everything is just wired correctly.
00:18:15.360 - 00:18:20.076, Speaker A: So we could do stacknet compile, see.
00:18:20.098 - 00:18:27.920, Speaker B: If I recall how to use this. So we pass the source file, which is going to be contracts ERC 20, and then we provide the output.
00:18:31.860 - 00:18:32.176, Speaker A: And.
00:18:32.198 - 00:18:33.248, Speaker B: Then we're going to put this in.
00:18:33.254 - 00:18:35.956, Speaker A: The compile folder and it's going to.
00:18:35.978 - 00:18:41.780, Speaker B: Be ESC 20, it's going to be a JSON file at the end. So let's see, let's see if I.
00:18:41.850 - 00:18:44.980, Speaker A: Remember the interface of the CLI correctly.
00:18:50.910 - 00:19:28.594, Speaker B: Okay, so we have now this compiled folder. So it's working as expected. So this is a very simple dev environment. If you only ever want to use Python dependencies, which could be just Caroline, could be Nile, could be even Protestar, that's perfectly good. The only downside is that now any other team member, sure they have a simple way to install all of these things, but the binary is going to be the issue, right? This is something that they have to do independently and to globally make them available. So the only way to overcome that.
00:19:28.632 - 00:19:31.826, Speaker A: Because it cannot be encapsulated in the.
00:19:31.848 - 00:19:35.446, Speaker B: Source file, there's this global dependency, you're going to have to document it, right?
00:19:35.468 - 00:19:57.550, Speaker A: So you will have to create like a readme file. And then you will say my project and say like install Python 3.9 and GMP globally. Maybe this is like the Prereq.
00:20:01.250 - 00:20:03.134, Speaker B: And then if you want to use.
00:20:03.172 - 00:20:18.898, Speaker A: The project usage, you will say after cloning, install dependencies in a virtual environment by running.
00:20:19.064 - 00:21:09.314, Speaker B: And then we document our setup file, right? So you now are counting of people knowing how to do this part, which seems trivial, but the instructions changes a lot depending on which os the person is using. So as we see, for a Mac OS, it's super simple. For Ubuntu it is not, I don't even know windows, how difficult it's going to be. So this is going to get worse. If you also try to add, for example, you want to create a front end for your decentralized apps, you will need to have node js, also global installed. So now you're going to have two global dependencies that people will have to resolve by themselves. And that opens the door for people making mistakes and having inconsistency in the binaries that they're using.
00:21:09.314 - 00:21:43.630, Speaker B: So to avoid this problem, we're going to now use Docker to not only encapsulate the project dependencies, but also encapsulate the global dependencies that this project needs. And in a way that now all the developers on your team doesn't matter which os they have installed a computer, they all will use the same dev environment using the same os, right? So let's see, first of all, let's do some tracking here, just added git.
00:21:44.690 - 00:21:57.110, Speaker A: Commit and let's call this simple python. Cool.
00:21:58.040 - 00:22:06.440, Speaker B: Okay, so in the case of now using Docker to encapsulate global dependencies, we're going to start as usual with a Docker file.
00:22:07.820 - 00:22:12.104, Speaker A: So to use Docker, even before you.
00:22:12.142 - 00:22:44.976, Speaker B: Try to create Docker file, you need to know that you have to install the Docker desktop or at least a Docker binary. You can go to Docker, maybe desktop. There you have it. So here you're going to see the instructions for installing Docker on your machine. So for Mac, Windows, Linux. So you will need to have that running on your computer installed for any of these instructions to work. Just so you know, Docker is super efficient with Linux.
00:22:44.976 - 00:22:52.120, Speaker B: I don't know, I think for Windows maybe now as well. For Mac it's not as efficient because it works pretty much like a vm.
00:22:52.540 - 00:22:55.128, Speaker A: But it has very nice properties anyway.
00:22:55.214 - 00:23:35.504, Speaker B: So we use, so you make sure you have that installed. I do have it installed, so I'm able to have, I don't have it running. So let me just run Docker. So I'll show you how the Docker desktop work before we start actually creating images and containers. So this is how Docker desktop would look like and it will give us this nice graphical interface just to see which images, volumes and containers we have right now running. So we have to wait a little bit while docker the engine starts. So right now we don't have any image, we don't have any container.
00:23:35.504 - 00:23:39.412, Speaker B: So we have a clean slate. We can go back.
00:23:39.466 - 00:23:45.496, Speaker A: So first step with docker is always to create a docker file, which we.
00:23:45.518 - 00:24:07.650, Speaker B: Are going to define. Okay, what's the characteristic for development machine? So I'm going to go ahead and deactivate for now my Python virtual environment because now we're not going to use Python virtual environment, right. So I'm going to delete this folder. Big docker, it works a little bit different. So let's remove this.
00:24:10.180 - 00:24:10.640, Speaker A: Okay.
00:24:10.710 - 00:24:33.816, Speaker B: So the first line of any docker file will say okay, what's your base dependency? Our base dependencies are going to base this on an image that is called Python. It's actually the official image from Python for the version 3.9 using Alpine Linux, right, alpine or alpine I don't know.
00:24:33.838 - 00:24:36.904, Speaker A: How to pronounce correctly but it is.
00:24:36.942 - 00:25:15.872, Speaker B: Like the smallest and the most efficient Linux image that you can get because you can base this off an Ubuntu image but it's going to be much bigger in size, it's going to take much more space in your computer. So using the alpin version of Linux is much smaller footprint. So even just doing this we are able to get a dev environment that has Python 3.9 installed and we can verify that very easily. So to use Docker we're going to have to first build the image and then run a container based on the image. So to build the image the command.
00:25:15.936 - 00:25:21.536, Speaker A: Will be docker build. And then we give it a name to this image.
00:25:21.568 - 00:25:33.828, Speaker B: Let's call it stagnet dev because it's going to be our dev environment. And this dot is because to tell the ClI that the docker file is going to be located in this folder at the root folder of our project.
00:25:34.014 - 00:25:35.630, Speaker A: So let's take a look.
00:25:37.120 - 00:25:42.444, Speaker B: And it completes. So if it's working correctly we should.
00:25:42.482 - 00:25:45.772, Speaker A: Be looking our dashboard and you see.
00:25:45.826 - 00:26:25.556, Speaker B: That we have now an image and look that it's pretty small, right? You have pretty much an OS with a terminal you can log in and it's only 47 megabytes. That's pretty cool. You can also look at these images by doing Docker image ls you see the same information here as well on the command line. So now that we have the image we can go ahead and create a container based on this image. Because the container is really the thing that we use as a development environment. The image is just like the blueprint.
00:26:25.748 - 00:26:30.828, Speaker A: So to create the container we can do Docker run and then we're going.
00:26:30.834 - 00:26:50.550, Speaker B: To do it in interactive mode because we want to get a terminal, get into the container using a terminal and interact with it. I'm going to tell Docker to, whenever I exit my container to remove the container. I don't want to keep lingering dependencies because it takes space on your computer.
00:26:54.360 - 00:26:56.036, Speaker A: I'm going to use this image, the.
00:26:56.058 - 00:27:24.140, Speaker B: One that we created in the step before and I want to open bash. Right that is the terminal that I want to use. And let me see, maybe I can use sh becomes preinstalled probably, yeah. So now this terminal that I get here is actually inside the container. So this is going to be my dev environment, right. This is my computer for development pretty much. So in here I can do Python version and you can see that Python 3.9
00:27:24.140 - 00:27:49.270, Speaker B: int installed. So now we have a way to encapsulate this first global dependency, right. Python that before we couldn't. Let's make a little change, let's see what's going to be there. I'm thinking about adding bash as my shell, but I think this is fine for now.
00:27:50.920 - 00:27:53.336, Speaker A: You can also again take a look.
00:27:53.358 - 00:28:04.844, Speaker B: At Docker desktop and you will see not only the image, but you will see now the container here running. And you can see that it's based on this image that we used before.
00:28:04.882 - 00:28:09.356, Speaker A: Right. If I exit the container, I can.
00:28:09.378 - 00:28:19.280, Speaker B: Just click sorry, type exit and go back to my host machine and you can see that the container now it's been killed. Right? That's the flag rm that we added to the command.
00:28:20.420 - 00:28:21.170, Speaker A: Cool.
00:28:23.460 - 00:28:58.620, Speaker B: Oh, one thing that I forgot to mention here is that not only that we have Python, we also should have pip available. That is also very important. So you get the proper connection between the binary Python and the package manager. Right, let me go back. Exit again. Okay, next step, we know that our project or any Cairo project is going to have two main dependencies, right? Global dependencies, the python binary. Now we have it now defined here explicitly, but also we have a package called GMP that we need to have installed globally.
00:28:58.620 - 00:29:09.216, Speaker B: So that doesn't come with Alpine out of the box. We have to install it. And to install it we're going to have to modify our image and use this instructional run.
00:29:09.398 - 00:29:13.036, Speaker A: So we use Alpine Linux package manager.
00:29:13.068 - 00:29:15.696, Speaker B: APK and say okay, add me the.
00:29:15.718 - 00:29:19.392, Speaker A: Latest version of this package, right?
00:29:19.526 - 00:29:33.476, Speaker B: So take a look that this is one of the issues of local dependencies that Docker is going to solve. The name of the package changes based on which distribution, which Os and which distribution you're using. So here now we can explicitly tell, okay, this is the name for Alpine.
00:29:33.508 - 00:29:34.280, Speaker A: Linux.
00:29:36.940 - 00:29:42.776, Speaker B: And that's it. Now we have the two global dependencies. We can rebuild the image just to.
00:29:42.798 - 00:29:52.860, Speaker A: Verify that it's all wired up correctly. So was able to add these other global dependencies. So cool.
00:29:52.930 - 00:30:01.804, Speaker B: The two main global dependencies are now available in our project. We can now move on to install Caroline itself using Pip.
00:30:01.852 - 00:30:02.016, Speaker A: Right?
00:30:02.038 - 00:30:06.640, Speaker B: Because Pip is going to be available in this machine. So we know the command.
00:30:07.220 - 00:30:13.924, Speaker A: So install Chirolang and we can install.
00:30:14.122 - 00:30:16.420, Speaker B: Now as before, open sepling.
00:30:20.600 - 00:30:22.664, Speaker A: Chiropracts if.
00:30:22.702 - 00:30:38.164, Speaker B: I type this correctly. Let's see if that's right. Pip install Keralab and zablin kernel contracts. Let's drag in to build the image, see what happens. So now it's actually installing all the.
00:30:38.202 - 00:30:46.628, Speaker A: Python packages from Pip. Let's give it a little bit of time.
00:30:46.714 - 00:31:05.612, Speaker B: As she knows, there's a lot of dependencies. And also as I mentioned before, Docker for Mac is not as efficient because works as a virtual machine. So it has limited resources from my host machine that it can use. So it's not going to be as.
00:31:05.666 - 00:31:09.548, Speaker A: Fast as it will be, for example.
00:31:09.634 - 00:31:21.090, Speaker B: On Linux and I think on Windows as well. Haven't used windows in a long time, so don't take my word for it. We have an issue here.
00:31:22.020 - 00:31:27.696, Speaker A: Okay, we have multiple issues and let's.
00:31:27.728 - 00:32:04.944, Speaker B: Try to get to the top of these issues. There's a lot going on building variant, right could not be wills for numpy. You should consider upgrading via. So it basically tells that hey, the issue here is that you need to have the latest version of Pip working before you install any of these packages. So we can do that right before trying to install any package. In this case we say we can.
00:32:04.982 - 00:32:10.736, Speaker A: Copy actually this command copy here if.
00:32:10.758 - 00:32:41.000, Speaker B: I paste it so it is going to upgrade Pip and then try to solve the problem. So let's try that again. Let's try to build our image once more. Let's see if it works or if we get a new type of error. Wait a little bit again, it's a little slow, so hopefully you have a cup of coffee or something to do in the meantime while this all installs.
00:32:44.450 - 00:32:46.590, Speaker A: I got to be honest, I work.
00:32:46.740 - 00:32:48.078, Speaker B: As a front end developer for a.
00:32:48.084 - 00:32:51.874, Speaker A: Long time because as a front end.
00:32:51.912 - 00:33:22.094, Speaker B: Developer, usually your only global dependency is node js. I didn't really care that much about Docker because I didn't have to juggle with multiple dependencies like databases or having multiple binaries globally installed. So I wasn't really much of a fan of Docker. I think it created more complications that it helped. But once you have more than one global dependency, you definitely want to have Docker. So it failed once more.
00:33:22.292 - 00:33:25.102, Speaker A: So if we try to see where.
00:33:25.156 - 00:34:05.498, Speaker B: The issue was, there you have it. Common GCC failed. So to enable GCC on our image we need to install another global dependency that is called build base. Notice just because I look up at the error and eventually I came up to this conclusion that this was the global package that was missing, that is going to include GCC as well, which is the compiler. Let's try one more time and see what happens. And also we're going to take a.
00:34:05.504 - 00:34:09.386, Speaker A: Look at how much the size of.
00:34:09.408 - 00:34:19.630, Speaker B: Our image is going to change once we have all these dependencies installed. If you recall, at the very beginning the image was only like 50 megabytes, but you're going to see how much.
00:34:19.700 - 00:34:25.070, Speaker A: It grows because we had to install these two packages.
00:34:25.150 - 00:34:43.030, Speaker B: And also Carolyn brings a lot of other dependencies with it. So that's going to increase the size of the image, but still it's going to be much smaller if we had used as a base ubuntu or some other full fledged Linux distribution.
00:34:45.290 - 00:34:46.920, Speaker A: Let's wait a little bit more.
00:34:47.550 - 00:34:51.370, Speaker B: Still just installed the packages from Pip.
00:34:58.100 - 00:34:59.568, Speaker A: Well, at least it's a good sign.
00:34:59.654 - 00:35:08.390, Speaker B: That it hasn't failed yet. So fingers crossed, that should be all we needed.
00:35:20.730 - 00:35:23.686, Speaker A: It's taking a while, 70 seconds.
00:35:23.798 - 00:35:35.366, Speaker B: You can if you want to increase how much ram you dedicate for your docker desktop. I think right now I have 8gb if I'm not mistaken.
00:35:35.558 - 00:35:41.258, Speaker A: I haven't checked these settings, preferences, maybe resources.
00:35:41.434 - 00:35:44.746, Speaker B: Yeah, I have dedicated half of my cpus.
00:35:44.858 - 00:35:45.278, Speaker A: Eight.
00:35:45.364 - 00:35:52.274, Speaker B: I have 32 and I could have.
00:35:52.312 - 00:35:54.654, Speaker A: Given it more ram.
00:35:54.782 - 00:36:02.370, Speaker B: So you have that option. We want to speed up things to show you. Let me go back to Docker.
00:36:04.650 - 00:36:06.118, Speaker A: Why did I close it?
00:36:06.284 - 00:36:53.842, Speaker B: Dashboard, so you can see. Okay, the image hasn't been created yet, so we need to wait. Taking a lot of time, more than two minutes. Once all this is working and we complete the setup, you only need to build the image once, right? And once you build it once, you only need to start containers to work on it. Every time you want to install a new dependency from Pip, you will need to rebuild the image. So just keep that in mind. There's an upfront cost of time and resources, but once your image stabilizes and doesn't change, you don't have to run this all the time.
00:36:53.842 - 00:37:18.236, Speaker B: And creating a container is pretty fast, so you don't have to wait this long. I don't recall how much time it.
00:37:18.258 - 00:37:21.548, Speaker A: Took last time, but hopefully when you.
00:37:21.554 - 00:37:24.316, Speaker B: See the recording you can speed up. And you don't have to wait with.
00:37:24.338 - 00:37:48.140, Speaker A: Me while I watch the screen. Seeing numbers increasingly.
00:37:48.240 - 00:37:52.490, Speaker B: So by the way, this environment you will be able to use it for.
00:37:53.040 - 00:37:55.608, Speaker A: If you want to use Protostar, Joe.
00:37:55.624 - 00:37:59.228, Speaker B: Skyrolan or Harahat, this is going to.
00:37:59.234 - 00:38:06.160, Speaker A: Be like a prereq for all of those development tools.
00:38:06.980 - 00:38:08.610, Speaker B: So yeah.
00:38:29.650 - 00:38:30.606, Speaker A: Next time I give this.
00:38:30.628 - 00:38:40.020, Speaker B: Workshop, but it's going to give like 16gb to my docker desktop, so I don't have to wait this long. Although I don't know this time is.
00:38:41.190 - 00:38:46.542, Speaker A: Related to ram or related to cpu.
00:38:46.686 - 00:38:52.120, Speaker B: But I think eight cpus should be more than enough. A ram thing.
00:38:53.050 - 00:39:00.214, Speaker A: Funny enough, when I did this before on my own without having the stream.
00:39:00.262 - 00:39:11.050, Speaker B: At the same time it was much faster. So definitely the stream is taking a lot of resources from my computer that is making this process extra slow.
00:39:13.880 - 00:39:18.676, Speaker A: The benefit is that also Docker is.
00:39:18.698 - 00:39:38.504, Speaker B: Going to try to cache every single instruction. So for example, if I add a new instruction below this run, after this finish compiling and clean the image, Docker is not going to redo all the steps again. It's going to take the result from.
00:39:38.542 - 00:39:45.516, Speaker A: A cache and only do the new step right. So hopefully we don't have to do.
00:39:45.538 - 00:39:57.216, Speaker B: This every time I think, yeah, we don't need to install more things. The downside is that if I make a change on, let's say here to the instruction, let's say I add more.
00:39:57.398 - 00:40:00.576, Speaker A: Global dependencies, then Python is going to.
00:40:00.598 - 00:40:17.976, Speaker B: Invalidate the cache for layers or instructions that come after it. So by modifying, let's say, this instruction, this part is not going to repeat, it's not going to try to redownload the image from Docker hub. But now from this point on it's going to redo all these instructions once more.
00:40:17.998 - 00:40:24.744, Speaker A: So we're going to have to wait a while. So just keep in mind how these.
00:40:24.942 - 00:40:29.196, Speaker B: Layers in Docker work. You can find out more.
00:40:29.378 - 00:40:35.752, Speaker A: See if you go to search for Docker layer.
00:40:35.896 - 00:40:36.860, Speaker B: Docker.
00:40:39.200 - 00:40:50.586, Speaker A: Cache layer optimizing builds yeah, so.
00:40:50.608 - 00:41:13.234, Speaker B: You can see this page on the official Docker docs. It's actually explained how this caching mechanism works and how it works like layers. So if you modify one layer, for example here, you make a change here. Now all these lower layers get invalidated and they have to rerun again. So from this point on you don't use the cache. This is what I'm trying to tell.
00:41:13.272 - 00:41:13.860, Speaker A: You.
00:41:17.190 - 00:41:19.666, Speaker B: And it's still going and going.
00:41:19.848 - 00:41:22.850, Speaker A: All right, seems to be finalized.
00:41:24.970 - 00:41:54.346, Speaker B: Okay, let's take a look at our new image and look how much it grew. Right now you can see the size now it's 465 megabytes compared to just 50 megabytes. By the way, these are the old bills, so let's just remove the old images. We don't need them, we just need the latest one. So every time you build the image using the same name. It basically assign the tag to the newest one that you build and remove.
00:41:54.378 - 00:42:07.954, Speaker A: The tag for the oldest one. Let's try now to create a container in this image. And now to verify that we have.
00:42:07.992 - 00:42:17.880, Speaker B: Everything working, we can try to compile again our smart contract. First of all, let's verify that this is present.
00:42:18.570 - 00:42:19.480, Speaker A: It is.
00:42:19.850 - 00:42:25.590, Speaker B: So we can try to start net compile contracts.
00:42:27.390 - 00:42:28.140, Speaker A: And.
00:42:30.030 - 00:42:31.706, Speaker B: Actually this is not going to.
00:42:31.728 - 00:42:39.134, Speaker A: Work because if you do a list of all the files, you can tell.
00:42:39.172 - 00:42:43.178, Speaker B: That we are in the root folder.
00:42:43.354 - 00:42:45.918, Speaker A: Of our container, which is not a.
00:42:45.924 - 00:43:06.086, Speaker B: Good place to be when you're working on a project. So before we move on, we're going to have to create a work directory and we also need to make our source code available to our container and we do that using what's called a volume. So first of all, let's create the working directory and it's a good time.
00:43:06.108 - 00:43:14.118, Speaker A: To verify that this image layer caching actually works. So let me exit the container and.
00:43:14.284 - 00:43:19.626, Speaker B: To create this new folder where we're going to use as our place to.
00:43:19.648 - 00:43:22.906, Speaker A: Work within the container, use the work.
00:43:22.928 - 00:43:35.310, Speaker B: There instruction and then we just create this folder, just called app, right. So if I try to rebuild the image, this should be go much faster because everything should be cache.
00:43:36.610 - 00:43:37.454, Speaker A: Yeah.
00:43:37.652 - 00:43:49.586, Speaker B: So blazing fast. If I go into my container now you can see that now we are inside the app folder and if I try to do a list of all.
00:43:49.608 - 00:43:53.198, Speaker A: The path, there's nothing, it is empty.
00:43:53.374 - 00:44:14.746, Speaker B: So we need to mount our source code into our dev environment, right. So we can work from there. So we can do that when we run in the docker run command, we're going to have to pass a new flag, it's called v for volume. And we're going to tell hey, I want you to mount the folder that I'm looking at right now and I'm.
00:44:14.768 - 00:44:19.854, Speaker A: Using this variable PWD and I want.
00:44:19.892 - 00:44:35.922, Speaker B: That to be mounted on the app folder inside my image. So let's take a look at this, what it does. Now if I list my files now I can see all my files, right?
00:44:35.976 - 00:44:38.114, Speaker A: So if I make a change from.
00:44:38.152 - 00:44:43.958, Speaker B: My host computer, it's going to replicate on my container and vice versa as well.
00:44:44.124 - 00:44:47.174, Speaker A: So let's make a small test here.
00:44:47.212 - 00:44:51.030, Speaker B: Let's create a file called test TXT.
00:44:52.250 - 00:44:54.726, Speaker A: If I list here again, you can.
00:44:54.748 - 00:44:59.514, Speaker B: See that we have text TXt. If I remove that file from within.
00:44:59.552 - 00:45:03.286, Speaker A: The container, it's now also removed from my host machine.
00:45:03.478 - 00:45:26.450, Speaker B: So you can see that this connection is happening between host and container. Cool. So let's try to see if we can compile the smart contract. So now we can actually do startnet compile contracts ERc 20 Cairo and output pile ERc 20 JSon.
00:45:26.790 - 00:45:34.140, Speaker A: Let's give it a try. Right.
00:45:34.210 - 00:45:35.368, Speaker B: So it didn't complain.
00:45:35.464 - 00:45:36.430, Speaker A: It's working.
00:45:36.960 - 00:45:47.984, Speaker B: So our dev environment, we are back to the same point that we were before when you use Python virtual environments. But now we have a benefit is that now even the global dependency, which.
00:45:48.022 - 00:45:51.252, Speaker A: Is the version of Python NGMP is.
00:45:51.306 - 00:46:04.632, Speaker B: Now also defined within the project. It's going to be tracked by Git. That is a step forward. Let's keep increasing the complexity. So let's pretend that we also want.
00:46:04.686 - 00:46:11.064, Speaker A: To create some, we want to use stagnet JS, right?
00:46:11.102 - 00:46:17.180, Speaker B: And we want to run some scripts using typescript. So I'm going to create a new folder called scripts.
00:46:20.480 - 00:46:22.664, Speaker A: And I want here to create files.
00:46:22.712 - 00:46:43.270, Speaker B: Using starnet JS, which is an SDK or a library to interface with the stagnet feeder and also give you some utility functions that are pretty handy as well. So let me take a look at my notes before we move forward to see where we are, what we need to do.
00:46:44.760 - 00:46:49.030, Speaker A: Volume. Okay.
00:46:49.400 - 00:47:00.596, Speaker B: All right, so because we want to use node JS, of course, first step is we actually need to install node.
00:47:00.628 - 00:47:03.368, Speaker A: JS and we're going to have to.
00:47:03.374 - 00:47:05.080, Speaker B: Install as well NPM.
00:47:05.580 - 00:47:06.330, Speaker A: Now.
00:47:08.700 - 00:47:55.630, Speaker B: You can have it here and probably that might prefer way to have all in the same instruction like install all the global dependencies here. But seeing how slow it was, remember if I run this, if I try to rebuild this image, it's going to invalidate all the steps here. It's going to take again a long time to complete. So I'm just going to install my node dependencies in a new instruction, right? So I keep using the cache from these previous instructions. So I do something similar, upgrade updates, right. But now I need to have node js available and I want to use Npm also available. Let's take a look.
00:47:55.630 - 00:47:59.772, Speaker B: Let's try to rebuild this image here.
00:47:59.906 - 00:48:02.350, Speaker A: This should be fast.
00:48:05.440 - 00:48:22.900, Speaker B: So as you can see. Okay, good decision. It was pretty fast. We used the caching mechanism to our advantage. And now if I get into the image using the volume, it's a long command. But then I'm going to show you a way to make it a little shorter. But for now it's a long command to run the container.
00:48:23.400 - 00:48:27.012, Speaker A: Now I can do node version and.
00:48:27.066 - 00:49:02.690, Speaker B: I have node 16. Now this version of Alpine Linux, it doesn't have the latest available node JS binary, which I think from our project is fine. Just keep in mind that there are going to be some limitations, right? So if you use the image for python three point ten, or even more a newer one, you will be able to see a newer version of node js available. But for now node 16 is perfectly fine and Npm should also be available.
00:49:03.620 - 00:49:08.652, Speaker A: Yeah, npm eight. Cool. So now that we have our node.
00:49:08.716 - 00:49:12.400, Speaker B: So let's create our package JSon.
00:49:13.400 - 00:49:17.092, Speaker A: And I just want to make this private, right?
00:49:17.146 - 00:49:53.376, Speaker B: I will never want to publish this to NPM. It's not a package that I want to share, it's just for my project. And now that I have the package JSon, I can install my node JS dependencies. And as I mentioned, I want to use stagnet, which is a library, and then I want to use it with typescript. And I don't want to be compiling myself all the time from typescript to javascript. So I'm going to use this package called ts node that allows to directly execute typescript code, and it's going to do the compilation under the hood, so.
00:49:53.398 - 00:49:58.496, Speaker A: It'S going to be transparent to us. So running this command, I think I.
00:49:58.518 - 00:50:00.310, Speaker B: Made a mistake here it's install.
00:50:03.160 - 00:50:04.310, Speaker A: There you go.
00:50:05.800 - 00:50:43.342, Speaker B: This package, the JSOn file should update. It's downloading all the dependencies. Okay, so now we're tracking the Javascript, all the node js project dependencies here, the same way that these requirements, actually I'm going to remove these requirements txt I find it very hard to use because all the noise that it adds and we are not really using it, we install it directly, find the packages.
00:50:43.406 - 00:50:46.020, Speaker A: Here, I'm just going to remove this.
00:50:46.950 - 00:51:45.138, Speaker B: I don't see a benefit of the, when it's configured this way, if it were configured like NPM, that you only get the top level dependencies and it hides from you the dependencies of the dependencies. Yeah, I will leave requirements of TXT there, but because it just makes it all, I don't like it, it's just noise. Okay, so because we want to use typescript, we need to create a configuration file which is called tsconfig JSon. And I don't want to write this by hand, there's a lot of configurations happening here. So I'm going to use instead a keyword that's called extends. And I'm going to use configuration that already exists that is specific for node JS 16. And you can get this from NPM, it's called tsconfigno 16 right, because that's the version of node that we have installed.
00:51:45.138 - 00:51:57.706, Speaker B: And in here you can find this base type sheet configuration file. So it's going to save us a lot of time. And what else?
00:51:57.808 - 00:52:01.254, Speaker A: Well, I want to only use typescript.
00:52:01.302 - 00:52:17.994, Speaker B: For a particular folder, which is the scripts folder. So I'm going to define this here scripts. So any file within the scripts folder is one that I want typescript to be able to resolve. Nothing else. I don't care. Contracts is not going to be typescript.
00:52:18.042 - 00:52:22.274, Speaker A: File, not even compile. Cool.
00:52:22.472 - 00:52:39.560, Speaker B: There's a little extra thing that I will add. Well that's fine. Let's keep it as simple as possible. So now we need to make this available to our project, right? So we can get this from NPM. So let's come back here. So NPM install.
00:52:41.530 - 00:52:43.590, Speaker A: And then ts config.
00:52:44.430 - 00:53:09.008, Speaker B: Node 16 and we have the package. So this configuration file should be working. Okay, what else we modify? I noticed that node modules has been tracked here, so I'm just going to modify my git ignore. I don't have m anymore, but I'm.
00:53:09.024 - 00:53:12.184, Speaker A: Going to remove node modules from my.
00:53:12.302 - 00:53:14.920, Speaker B: Repository or I want it to be tracked.
00:53:16.300 - 00:53:17.530, Speaker A: Okay, cool.
00:53:18.460 - 00:53:33.688, Speaker B: All right, so we have now python node js. We have typescript as well. So typescript is hard to pronounce for me. So now we can actually create a file or a test file to verify that it's all working fine on the node JSI.
00:53:33.864 - 00:53:38.072, Speaker A: So let's call this test ts.
00:53:38.136 - 00:53:39.004, Speaker B: Right? This is going to be a test.
00:53:39.042 - 00:53:45.452, Speaker A: Sheet file and here I'm going to be using stagnate JS.
00:53:45.596 - 00:53:49.456, Speaker B: So first of all, we're going to.
00:53:49.478 - 00:53:55.140, Speaker A: Get from Stagnet, we're going to get this provider.
00:53:56.520 - 00:53:57.156, Speaker B: What is this?
00:53:57.178 - 00:54:01.808, Speaker A: A class and provider is what we.
00:54:01.834 - 00:54:46.500, Speaker B: Use to connect to particular network, right? To connect to a stagnant main net to Gorely one or to go two. Here I'm just going to connect to the regular gorely. So we create a variable or a constant called provider and then we create a new instance of this class and we need to pass some configuration. And what I love about typesheet is the autocomplete and the tooling that you get because of the types. So we need to define which sequencer and how do you define which network are you going to be targeting and network. And here you're going to have to see the options. So just going to use Gorli.
00:54:48.360 - 00:54:48.964, Speaker A: And.
00:54:49.082 - 00:55:03.080, Speaker B: To make sure that it works. I'm just going to read some simple or small information about Gorli. Just to verify that it's actually talking to the sequencer and getting information. So let's create our main function that's going to be async.
00:55:05.420 - 00:55:08.008, Speaker A: Now in here I just want to.
00:55:08.014 - 00:55:21.936, Speaker B: Get the chain id from the network. And to get that I'm going to await, I'm going to use my provider constant and then use the method, get chain id. And if it all works correctly, I.
00:55:21.958 - 00:55:27.010, Speaker A: Just want to log into the console, right, chain id.
00:55:29.400 - 00:55:32.390, Speaker B: And now I actually have to run main.
00:55:34.200 - 00:55:36.916, Speaker A: And this should be all that.
00:55:36.938 - 00:56:21.462, Speaker B: We need to verify that we have the connection between node js with typescript and starting js and we're able to talk to the feeder. So in here to execute this, I want to use Ts node, as I mentioned, and something like scripts test ts. But Ts node is not globally installed within the container, it's in the node modules. So to use Vanessa from the node modules you use NPX. Let's run it and take a while because try to talk to the feeder. And there you go. Now we got the chain id from Gorli.
00:56:21.462 - 00:56:26.060, Speaker B: So it is working. All the wiring is in place.
00:56:29.150 - 00:56:30.586, Speaker A: Good, let me see.
00:56:30.768 - 00:56:46.578, Speaker B: Okay, so let me show you what else can we do to improve things. Let me exit the container for a moment. I'm going to add all these files to my repo. What did I do here?
00:56:46.744 - 00:56:54.418, Speaker A: Get it. Docker file. Okay, so what is the issue that.
00:56:54.424 - 00:56:57.106, Speaker B: We want to resolve now? Everything looks good.
00:56:57.208 - 00:57:00.758, Speaker A: We have this all dependencies track in.
00:57:00.764 - 00:57:09.110, Speaker B: The Docker file, even pre dependencies and global dependencies. But the issue is that if I try to use my Cairo contract.
00:57:12.270 - 00:57:19.420, Speaker A: This should let me verify if I have.
00:57:19.790 - 00:57:34.050, Speaker B: Do I have this available globally? Let me check something here before I do anything. No, it's not showing me.
00:57:35.860 - 00:57:36.288, Speaker A: But I.
00:57:36.294 - 00:58:21.168, Speaker B: Also cannot navigate to any of these dependencies. So the issue that I'm trying to explain here, that is surprisingly is not showing, just because it's sometimes pretty slow to react. The Cairo extension for vs code is like in our host machine where vs code is running. There's no knowledge of Caroline, right? Caroline is not available to my host machine. This library is also not available. So vs code would complain that it's not able to resolve this. So it's going to show you these red squiggly lines all over the place, which I'm surprised they're not showing here.
00:58:21.168 - 00:58:52.328, Speaker B: But I know for a fact that vs code is not able to resolve these dependencies. Let me see if I try to reopen. Fresh reopen. No, but the problem persists and it's going to showcase at some point, right? Maybe right now it's not showing, but as soon as it finishes parsing or attempting to parse all this file, the issue is going to present. So we need to find a way.
00:58:52.494 - 00:58:56.072, Speaker A: To tell vs. Code or to open.
00:58:56.126 - 00:59:08.716, Speaker B: Vs. Code within the container. So now vs. Code will be able to resolve all these dependencies that are only available within the container and not available to my host machine. So there's a handy extension for vs.
00:59:08.748 - 00:59:10.930, Speaker A: Code that is called.
00:59:13.060 - 00:59:14.080, Speaker B: Docker.
00:59:16.580 - 00:59:17.520, Speaker A: Docker.
00:59:18.840 - 00:59:23.540, Speaker B: Give me a second. Oh, dev containers.
00:59:25.720 - 00:59:26.470, Speaker A: Right.
00:59:27.080 - 00:59:38.410, Speaker B: So this extension is going to allow you to open vs. Code within the container itself. So all dependencies are available to your vs. Code.
00:59:40.940 - 00:59:43.064, Speaker A: Let's close this for a moment and.
00:59:43.102 - 00:59:45.196, Speaker B: I'm going to show you how to use it.
00:59:45.378 - 00:59:51.948, Speaker A: So we're going to have to go back to our project and I'm going.
00:59:51.954 - 00:59:56.956, Speaker B: To create a new file, a new file that is specific to dev container or to this extension.
00:59:56.988 - 01:00:01.760, Speaker A: So it's called devcontainer JSON. Right.
01:00:01.910 - 01:00:21.704, Speaker B: So this is a configuration file for the extension and it's going to work kind of similar to, let's say the purpose of a docker compose. In a way. It's going to use a different type of syntax using JSOn to begin with. So you're going to give it a name to your container within vs. Code. Right.
01:00:21.742 - 01:00:31.924, Speaker A: So I'm just going to call it stagnetdef stagnet def. Then I'm going to tell where vs.
01:00:31.972 - 01:00:54.236, Speaker B: Coder or the extension is going to be able to find my docker file. Because what vs. Code is going to try to do is not directly just compile my docker file. It's going to take the docker file and install what it says there and do what it says there. But also it's going to install and add more layers specific to vs. Code to make the connection between the two ends.
01:00:54.428 - 01:00:57.952, Speaker A: So we use the build keyword and.
01:00:58.006 - 01:01:27.896, Speaker B: Here we specify, okay, the docker file is, the name is Dockerfile and its location, the context, you find it here in this same folder, the root folder of my project. Then we're going to have to customize our vs. Code or the instance of vs. Code that's going to open within the container because this instance of vs. Code is not going to have any extension installed even if your host vs. Code will have it. So you will have to install or define here what extensions for vs.
01:01:27.896 - 01:01:32.636, Speaker B: Code you want to have available. So we use these keywords and then.
01:01:32.658 - 01:01:35.724, Speaker A: We define which extensions we have, we.
01:01:35.762 - 01:01:40.290, Speaker B: Want and we want basically two, we want the Python extension because.
01:01:42.260 - 01:01:52.400, Speaker A: Cairo uses Python import, the same import system that Python uses.
01:01:52.480 - 01:01:56.148, Speaker B: That's why you need Python as an extension. And of course we're going to need.
01:01:56.234 - 01:01:56.870, Speaker A: The.
01:02:00.040 - 01:02:18.004, Speaker B: Cairo extension, which is darkware Cairo. So our vs. Code is going to be loaded with those two extensions only. And I want to also tell them every time that I open the Internet.
01:02:18.052 - 01:02:21.336, Speaker A: Terminal that vs. Code has, I want.
01:02:21.358 - 01:02:30.240, Speaker B: To tell vs code which terminal in particular I want to have enabled. So this is terminal Integrated.
01:02:34.900 - 01:02:38.850, Speaker A: Default. This is the one.
01:02:39.320 - 01:02:42.980, Speaker B: And for now let's call it sh because that's what we have.
01:02:43.050 - 01:02:48.420, Speaker A: But we can stall better terminals.
01:02:49.800 - 01:03:07.290, Speaker B: See, this should be all that we need. Still is not complaining. It's funny. It should be complaining with the red query lines. All right, so now to launch vs. Code in this container we can open.
01:03:08.220 - 01:03:10.956, Speaker A: The command palette which you can use.
01:03:10.978 - 01:03:23.568, Speaker B: In like command shift p, or you can use to think view command pullet and you have this command rebuild and reopen in container. So this is going to close vs. Code, it's going to reopen, it's going.
01:03:23.574 - 01:03:28.288, Speaker A: To open a new instance, we're going to compile the image and it's going.
01:03:28.294 - 01:03:31.140, Speaker B: To open vs. Code inside the image.
01:03:31.640 - 01:03:34.436, Speaker A: This is going to take quite a.
01:03:34.458 - 01:03:38.550, Speaker B: Long time, probably as we did before, but let's do it once. Let's see if it works.
01:03:39.080 - 01:03:42.170, Speaker A: And let's see, let's take a look.
01:03:43.260 - 01:04:10.016, Speaker B: So you can see it restarts. And if I open here the log, you can see how vs. Code is compiling. First of all, it defined a volume by itself, even though in this configuration file I never mentioned a volume. Vs. Code is smart enough to tell yes, you're going to need to mount your source code into this container, obviously. So as you can see, there are.
01:04:10.038 - 01:04:13.996, Speaker A: Things about our docker file that vs.
01:04:14.028 - 01:04:22.084, Speaker B: Code is kind of ignoring. It's adding its own stuff on top of it. Right now it's installing the extensions for.
01:04:22.202 - 01:04:29.076, Speaker A: Our vs. Code instance that we should.
01:04:29.098 - 01:04:32.280, Speaker B: Be able to see here in extensions.
01:04:33.900 - 01:04:34.970, Speaker A: Let's see.
01:04:39.900 - 01:04:45.404, Speaker B: So far it hasn't tried to run anything, any code of our docker file yet.
01:04:45.522 - 01:05:10.760, Speaker A: It seems to be all things specific to vs. Code. Wait, is it done? Let's see, what if I open. Oh, okay, it seems to be done. See Python there.
01:05:14.090 - 01:05:15.638, Speaker B: If I try to do as well.
01:05:15.724 - 01:05:29.376, Speaker A: Yes. Node scripts test okay, yeah, that was.
01:05:29.398 - 01:05:32.630, Speaker B: Much faster than I expected. Actually. That was going to take a long time.
01:05:33.320 - 01:05:40.484, Speaker A: So now the benefit is that now vs. Code is completely aware of where.
01:05:40.522 - 01:05:42.192, Speaker B: All these things are located.
01:05:42.256 - 01:05:48.088, Speaker A: It's just the kyro extension seem to be working right now, but if you.
01:05:48.094 - 01:06:11.320, Speaker B: Use for example Python, you will be able to resolve all dependencies fine. So now vs code is actually aware of all the dependencies within the container. A few final things that I will do on my dev environment just to make it a little nicer to use, is that I will change the terminal to instead of having just a regular sh, I will use omicial.
01:06:11.400 - 01:06:15.890, Speaker A: I love that project and the way you add it.
01:06:16.420 - 01:06:22.516, Speaker B: First of all you have to install Csh. You also need to install git and.
01:06:22.538 - 01:06:28.928, Speaker A: Then curl because then you will have to run the script to install all my seashell.
01:06:28.944 - 01:06:49.740, Speaker B: So if you go to all my seashell website, you will get this instruction how to use it. So I have this new terminal. And to use the new terminal when I use vs code, I will have to tell them here, hey, don't use the regular one, use the nice one Csh.
01:06:50.560 - 01:06:52.060, Speaker A: Why are you complaining?
01:06:57.040 - 01:06:58.460, Speaker B: How I complain.
01:07:01.040 - 01:07:06.290, Speaker A: I don't know. Let's try me exit this for a moment.
01:07:07.940 - 01:07:09.264, Speaker B: I'm going to have to close vs.
01:07:09.312 - 01:07:14.228, Speaker A: Code to exit the container. I need to find a way to.
01:07:14.314 - 01:07:17.264, Speaker B: Cleanly whenever I exit or close vs.
01:07:17.312 - 01:07:21.296, Speaker A: Code to also kill the container.
01:07:21.328 - 01:07:22.468, Speaker B: Because as you can see, the container.
01:07:22.484 - 01:07:27.370, Speaker A: Is here, still there. I'm just going to delete it.
01:07:27.980 - 01:07:40.270, Speaker B: And if I see all the images, all the old images, you can see vs code build its own image base of our own image. So let me remove first of all the old ones.
01:07:40.800 - 01:07:45.500, Speaker A: Take a little space and let's rebuild.
01:07:45.840 - 01:07:54.444, Speaker B: Our image with this addition of omic shell. And of course I lost vs code. So I need to give me the terminal.
01:07:54.492 - 01:07:59.590, Speaker A: Come on. Okay, let's open here again.
01:08:06.910 - 01:08:24.110, Speaker B: You can see that when I open the print now automatically, it's telling me to reopen in a container. I want to rebuild the image first because seems to be scope is taking advantage of some of the caching mechanism. Docker.
01:08:24.450 - 01:08:28.106, Speaker A: I have it in my docker.
01:08:28.138 - 01:08:29.380, Speaker B: Build stagnet dev.
01:08:32.070 - 01:08:32.578, Speaker A: Right.
01:08:32.664 - 01:08:39.670, Speaker B: Just because we added new things, we added these dependencies and we added also my C shell.
01:08:41.690 - 01:08:46.466, Speaker A: Now let's try to rerun vs code in a container.
01:08:46.498 - 01:09:11.782, Speaker B: Let's try to launch it in a container. See if we get now a nicer integrated terminal. See what's happening here. Show me the logs. Still going. Python complete.
01:09:11.916 - 01:09:12.994, Speaker A: Spython isore.
01:09:13.042 - 01:09:14.680, Speaker B: Is that the end of it?
01:09:15.210 - 01:09:20.674, Speaker A: I open a container? Yeah. Now I have a much nicer integrated.
01:09:20.722 - 01:09:33.530, Speaker B: Terminal in the vs code that is launching inside the container. So that's it. That's what I want to show you I'm going to write. I actually have a blog post showcasing these same steps.
01:09:35.230 - 01:09:35.978, Speaker A: And it's going to.
01:09:35.984 - 01:09:43.246, Speaker B: Be available on starnet.edu, and you'll be able to find it here later in.
01:09:43.268 - 01:09:46.800, Speaker A: The week in this medium account.
01:09:47.970 - 01:10:06.600, Speaker B: And that's it. That's what I want to show you how to use Docker to encapsulate not only project dependencies, but also global dependencies for Python for node, in a way that is completely consistent across your development team, and it just plays nicely with vs code.
01:10:07.850 - 01:10:08.358, Speaker A: Yeah.
01:10:08.444 - 01:10:12.950, Speaker B: So for today, I'll see you in the next workshop.
01:10:13.370 - 01:10:13.860, Speaker A: See ya.
