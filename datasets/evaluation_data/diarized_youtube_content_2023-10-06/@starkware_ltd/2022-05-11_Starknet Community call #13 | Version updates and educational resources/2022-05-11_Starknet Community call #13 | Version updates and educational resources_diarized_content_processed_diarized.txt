00:00:00.630 - 00:00:01.180, Speaker A: It.
00:00:03.150 - 00:01:08.810, Speaker B: Okay, and we're live now. Cool. So I'm going to ping everyone on Discord and then we'll wait a bit for people to connect and. And we'll start. Let's also start the meeting on Discord. So if you can connect to the room on Discord to start the event there. All right, so the event is starting now.
00:01:08.810 - 00:01:50.276, Speaker B: Can people on Discord hear me? No, not yet. Now they should be able to hear me. Hello, everyone on Discord. Okay, so I can see people are logging into Discord. I'm not so sure about YouTube. Let's see, there are some people on YouTube also. All right, so it's 232.
00:01:50.276 - 00:01:54.550, Speaker B: Let's wait two more minutes and then we can start.
00:02:40.930 - 00:02:41.680, Speaker A: It.
00:02:42.850 - 00:03:31.680, Speaker B: Okay, so we have 70 people waiting in the audience. Luca, can you connect to discord also so that, I mean, you can connect when you talk a bit later on. Okay, so let's start. So welcome everyone. Thank you for joining us for this 13th community call. Today we are going to talk about the roadmap new versions of Starknet Alpha, one of them which is released and deployed today on Testnet and which will come to mainnet a bit later on. And then we'll talk about an upcoming important feature which will come in version 0.9.
00:03:31.680 - 00:04:22.022, Speaker B: And finally we'll talk a bit about education material and resources for Starknet and how we can help onboard more people collectively to build cool stuff on Starknet. So I'm going to start with 0.8.2. Let me check if I'm sharing the right screen. Yes, I am. Okay, cool. So the, okay, so I wanted to briefly cover what is included today in version 0.8.2 of Cairo Lang and which is deployed today to testnet.
00:04:22.022 - 00:05:00.090, Speaker B: So it's not a major version, 0.8.2. You already had 0.8.0 and 0.1 that were deployed before. So as you can see, for Starknet it was mostly about performances. So performances, fixing a bug and adding some fields into the block info that were retrieved. Something I wanted to underline, however, is the inclusion of Kichak and DTRim signature verification into the Cairo library.
00:05:00.090 - 00:05:58.970, Speaker B: So this is basically just taking something that was done in an outside library and including it in the repo so that it's easier to access inside of Cairo and inside of your darkness smart contract. That way you don't have to clone the file and then import it, but it won't affect the performance of these functions. These are still the same Cairo code. They're still written in Cairo. And so you won't get necessarily performance improvement, it's just that these are the, let's say, canonical libraries for now in order to get performance improvements for these functions. So for ketchak or for signature verification, we'll have to convert these in what we call built. So, which are, let's call them like optimized functions for Cairo.
00:05:58.970 - 00:06:38.994, Speaker B: So they run faster and they will save you a lot of steps in your contract. We don't have a fixed timeline for that. It will come, but for now you can still use these libraries instead of importing things from elsewhere. So that's a minor release. A minor release we have today. Something I wanted to share with you was this web page, which I'm going to share in Discord and which I'm going to share also. Well, I'm going to share it in discord.
00:06:38.994 - 00:07:35.510, Speaker B: Actually, I'm going to share it now in the community called channels that people have access to it and can read with me. So I'm going to post it in the community calls channel. Right. So I see that there are some questions in the community call channel. Just want to underline that you can follow the call either on Discord in audio only, or you can follow it in YouTube. I'm going to share the link also in Discord, and that way you can see the stream. This is for Axel.
00:07:35.510 - 00:08:29.846, Speaker B: I think Delax is excel, who is trying to see my screen. Okay, so coming in version Alpha 0.9.0 will have a big change in the way contracts are considered in Starknet. So the document really sums it up well. But I wanted to cover live here some of the key aspects of it. So as some of you may know, on Ethereum there is a very large number of smart contracts that are deployed which are essentially the same code. They're small variation on ERC 20 and ERC 721 by open Zeppelin, and they're just deployed with some parameters that are changed.
00:08:29.846 - 00:09:25.550, Speaker B: Each of them has its own storage, and for each of them we store the code of the smart contract. But for a lot of them, the code is duplicated and remains the same. So for example, think about the way uniswap v two works. Every time you want to deploy a pool of assets, the code for this specific pool is duplicated. So part of it is inside a library, so there is some efficiency there. But to a large extent, we create a new storage for a new pool and we store some code and this code is duplicated. So the reason why it took us some time to ship the contract factory in Starknet is that we wanted to get this design right in light of years of experience of how Ethereum works.
00:09:25.550 - 00:10:52.298, Speaker B: And so we went with this approach where we will separate what we call a contract class and a contract instance. In a nutshell, you can think of the contract class as the code of a smart contract and the contract instance as triplet, which will point to a contract instance. So a specific code, a specific storage, and a specific address, right? And so it's a very simple design, right? You have the code and then you'll have the instance of this code, right. However, this will imply first some immediate change in how you deploy a smart contract, and then there are some larger changes in how you design your smart contract, which we can discuss also later on. So basically today, when you deploy a smart contract, you send the code, it gets an address, it's stored, and you have a new contract. Now, when you declare a smart contract, there will be two actually calls to be made. One of them will be a declare transaction where you'll create a contract class.
00:10:52.298 - 00:12:02.894, Speaker B: So you will basically send to starknet the code of your contract without deploying it. Then there will be a new deploy smart call, which will work a bit differently than the deploy call you have now, which will basically say, okay, so I want to create a new instance of a smart contract. It is using that specific class for its code, and then at this point your contract will get assigned an address and some storage. Some impact to this are first, that the way delegate call will work will be a bit different today. If you use delegate call, basically your smart contract a will send delegate call to smart contract b. In this new paradigm, you won't delegate your call to a smart contract instance, you will delegate it to a smart contract class. So it will change a bit.
00:12:02.894 - 00:12:55.010, Speaker B: Instead of specifying the address of the contract you want to delegate it to, you will have to specify the ash of the class. So basically the ash of the class will be the thing we use to index all the smart contract classes that are deployed. So you'll have to specify where the code you want to execute sits alongside. I'm just reading through the documents here, so if you have questions, feel free to ask them or comment. Same thing for proxy contracts. Instead of having an implementation address, point to a smart contract instance, it will point to a class ash. So it will point to a repository of code where things will be stored.
00:12:55.010 - 00:14:05.350, Speaker B: Right now, yes, there will be also some changes made to account contracts because this will allow having a syscol where you can deploy a new smart contract instance from an account contract. This opens the door to paying for fees for deploying new contracts. Contract instances from the smart contract, the account smart contract. This will also change the APIs of Starknet. Now you don't have today you have a single endpoint to, I mean, you designate a smart contract as both the code, the storage, its address, and also now we will distinguish between the smart contract instances and the smart contract classes. So the API will reflect that change. Now, this is the first step, and as you know, Starknet is in deployment, so we don't have all the answers.
00:14:05.350 - 00:14:48.886, Speaker B: But this will bring some, quite a lot of change. It will bring the capacity to a factory. So with 0.9 we will be at feature parity with Ethereum. Anything you can do on Ethereum you'll be able to do on stocknet. However, some questions remain open. The first thing is how do you pay for deploying a smart contract class? How do you pay for deploying a smart contract instance? How do you price both of this? What is the resources it takes, how much it should be, and things like that.
00:14:48.886 - 00:16:36.040, Speaker B: The second question, which remains open is still the same. Everyone is asking is how do you seed in a way your account contract? It's not how you seed it, but you're a new user, you don't have money on Starknet yet. How do you create an account contract without being able to pay for your deployment? So these are open questions. I think there are some others that are missing, but the first one that comes to mind is how does this affect the way we write smart contracts for Starknet? I think this is a very important questions for people writing standards such as ERC 20 ERC 721 today it is possible if you go on Ethereum you can take ERC 20 ERC 721 and then customize them a bit and deploy them. There are some arguments in the constructor you can use to make your contract parameter like to your taste here. This logic will be pushed even further because there will probably be a bonus, like not a bonus, but it will be cheaper if you just deploy a new smart contract instance compared to if you deploy both a smart contract class and a smart contract instance. So making your contract versatile and reusable will be very important.
00:16:36.040 - 00:17:22.710, Speaker B: Anyway, this also opens the door to other funny stuff where you can deploy a smart contract class to starknet without creating an instance. And so your smart contract can be, I mean, your smart contract class is deployed to Starknet and you can have a contract that delegates call to this smart contract class without this instance being deployed anywhere. Anyway, it's a funny construction. So yeah, I wanted to cover this document. I'm going to check if there are questions. I'm going to check if there are questions. Okay, so apparently people can't hear me anymore on Discord.
00:17:22.710 - 00:17:59.074, Speaker B: Too bad. Discord is not always perfect when we do these things. Okay, people can hear me on discord. Okay, perfect. And to check if there are questions in YouTube. And so get boot is asking, who do we have to thank for this external implementation? I'm guessing you're talking about the kitchak and Ethereum signature Cairo code. I don't know, so I can't give attribution, sorry.
00:17:59.074 - 00:18:51.390, Speaker B: But they were included by our team. By the way, I think this is also something that eventually will be done for other libraries. Today there's a lot of fragmentation of libraries and we need to come up with a way so that external libraries that are made by members of the community will be included in the Cairo length package globally. All right, so I don't see any questions, so I'm going to move on. So this feature contract classes, which will be released in 0.9, is not the only thing that will come in version 0.9. There are some other things in the pipeline.
00:18:51.390 - 00:19:27.914, Speaker B: Most notably there will be some changes around fees, so we'll keep you up to date with that. So it's not the only one, but it's an interesting one. It's the one I know has been implemented and will be shipped. So I wanted to present to you that. And now I want to switch the second part of the committee call. Let's talk a bit about Starknet education and Cairo education. So, as you know, there are three of us now in the Starknet.edu
00:19:27.914 - 00:20:13.402, Speaker B: team. There is Ben, who is on the Colorado time zone. There's Lucas and I who are in the european time zone. Basically what we do is try to come up with ways to facilitate onboarding to Starknet. One of the big issues we have is the lack of content and the lack of documentation, which is perfectly normal for a project this age. But so we're trying to come up with different tutorials and different ideas to teach people how to leverage and how to use stocknet. So we came up with these tutorials you might have seen.
00:20:13.402 - 00:21:03.930, Speaker B: So Cairo 101, which is a read only tutorial. People just need to go there, read the code, and interact with the different tools of the stocknet ecosystem. We wrote two others, which are ERC 20 and ERC 721, basically explain to people how they can do on Starknet things that are relatively common and easy to do in curium. And we release also this fourth one, which is the messaging bridge tutorial, which basically explains how to use the message bridge of Starknet to build cool cross layer application. So a few things about these. First of all, I think they're okay resources. If people ask you, how do I get on Starknet, don't hesitate and point them to these repo.
00:21:03.930 - 00:21:31.160, Speaker B: The second thing is that as Starknet evolves, these will need to evolve also. So sometimes we have time, sometimes we don't have that much time. And so if you see mistakes and errors in these tutorials, don't hesitate and submit. Prs. There are some here. So if you see typos, don't hesitate and contribute. They are much welcome and we're very happy to have them.
00:21:31.160 - 00:22:43.418, Speaker B: And we will be releasing more of these in the future and hopefully you, the community, will be able to do so. Also, we have seen various entities publish their own tutorials on how to build a front end, how to write smart contracts, how to get started with Starknet. And we're very grateful when we see these tutorials and also very excited to see how people take different approaches to teaching Starknet. And also, we quite often learn new things because we all use different tools and we use different features of different tools. So it's always really interesting to see how people build their own tutorial. And so for the second part of this community, call Luca, who is here with me, will take control. Luca will let you share your screen and he will actually show you one of these tutorials that was done by a team called only dust, which made an interesting tutorial around Starknet.
00:22:43.418 - 00:23:03.300, Speaker B: So Luca, if you want to show how to do this tutorial and you in the audience, if you have questions or suggestions, please state them in the question in discord or YouTube will be watching. And if you know people who are curious about getting into Cairo, this tutorial is worth checking out.
00:23:03.750 - 00:23:07.990, Speaker A: Sure. Thanks. First, can you hear me on Discord?
00:23:11.530 - 00:23:18.622, Speaker B: Let's check. I don't think people can hear you on discord.
00:23:18.786 - 00:23:40.942, Speaker A: All right. I'm not sure it's that important because it won't be that relevant without the screen sharing. But I mean, someone wants to hear in the background. I'm not sure. Can you hear me now?
00:23:41.076 - 00:23:42.638, Speaker B: Yeah, now people can hear you.
00:23:42.724 - 00:24:02.360, Speaker A: Okay, great. So let's go. Okay, can you turn on the screen sharing, please? And first, I want to apologize for the background noise. They are building something.
00:24:04.250 - 00:24:05.814, Speaker B: You can share your screen now.
00:24:05.932 - 00:24:54.600, Speaker A: Okay, great. And so let's share this. So the repo is called stock links. You can find it only just GitHub. Let me share the link. They had like this first implementation that they did for Starknet Hackathon in Amsterdam, but they did an update that they're still working on, I think. And so we're going to do like the old version because the new one is not available yet.
00:24:54.600 - 00:25:25.278, Speaker A: So let's start. So this is like the old commit. I can share too. If you want to do it at home, it's okay. So let's start. We're going to start with the beginner one and if we have time we'll check the advanced one. So what they did is they did like a bunch of exercises and they created tests.
00:25:25.278 - 00:26:33.350, Speaker A: And the goal is that the unit tests all pass on the smart contract. So here you can analyze the first one to see works here and it will run the unit test and it should not work because obviously we didn't start the exercise. It's a bit slow. We'll come back to that. So what we have to do, it's written in the comments here, we have to create a storage variable named dust that maps an address to an amount. We're going to assume that would be amount is a felt and for that we're just going to create a storage variable. I have Cairo skippets that I wrote myself that is available on GitHub, which basically allows me to do that.
00:26:33.350 - 00:27:30.700, Speaker A: And then I just have to fill in the variables. So it maps an address to an, here we've got storage variable that maps the address to the amount. And now we can rerun the test. So here it doesn't work because the storage variable desk doesn't exist. So just, I'm going to rerun that and it should be okay. By the way, they're explaining some interesting stuff for beginners. So how storage variables are defined, how an external function is defined too, and how views are defined for those who are not familiar with Cairo, external functions are like the entry points that you can call.
00:27:30.700 - 00:28:06.390, Speaker A: Views are like in solidity, they're views. You can just view stuff. It shouldn't modify the current state of the smart contract. And you can have internal functions which would look like this, but you don't have the external decorator so you can't call it outside of your smart contract. All right, so let's see. Okay, so the test passed. So let's go, we can continue, let's go to the exercise one.
00:28:06.390 - 00:28:44.500, Speaker A: And so here we have to define two storage variables. The first one is star, and the star will map an address and a slot to a size. So this one will be like a tuple because you can't have nested mappings. So you would have to give the tuple. So this variable will be called star. It will map an address which is a felt and slot which is a felt too, to a size. So it's felt also.
00:28:44.500 - 00:29:44.020, Speaker A: And then we'll have the slots storage variable define it also slots an address to the next available slots so we can keep track of the stars. So basically here this variable is like the stars of each address. Like everyone can create a star and it will have a tuple as a key because you can have multiple star and you can't store arrays. So you have to go with a mapping, but you can't have nested mappings. So you have to go with the tuple, which is like the address and the current index of your star. And here you have to keep track of each new slot of everyone. So you have to store like the next available slot for each address.
00:29:44.020 - 00:30:34.386, Speaker A: And so here we define the r two store required. Here we're going to create an event which will log the account, the slot in the size of the star, and then we'll just go like this. And so the event is, and so it takes an account which is failed, which is a failed, and the size which is also failed. Okay, so should be here. And these external functions allow people to create star. So we're going to write the body of the function. So we're going to have to get the caller address.
00:30:34.386 - 00:31:09.920, Speaker A: So we're getting the address. And so this is how it works in Cairo. You just call this function which is imported here, which is basic. Like you can have it when you install Cairo link. And then you have to put the address between parentheses because every function returns the tuple, but this one like single element tuple. So you have to unpack it. So we get the caller address.
00:31:09.920 - 00:32:12.158, Speaker A: Then we want the amount of dust owned by the caller and the amount of dust is stored in this variable. So we're going to go with the amount of dust here and the address of the user which is the caller here. And so we're going to get the balance. Then we are going to check that the amount of test is at least equal to test amount. So we're going to assert le which is imported here as well. And it's going to enable us to assert that the first element is less or equal than the second one. So we want to check that the dust amount is less than the balance.
00:32:12.158 - 00:32:53.178, Speaker A: So we're sure that he can pay for the star. Then we want to get the next available slot for the color. And so I'm going to call it the current slot because it's the one that will be used to sort the star. And so we created like the slot variable earlier, which is here. And it takes an address and will return our slot. So we got our slot here. And then we're going to update the dust amount on by the color.
00:32:53.178 - 00:33:40.270, Speaker A: So the dust amount is still stored in the dust storage variable. And we write the new balance, which is minus dust amount. Okay, so this is like the new balance. And then we want to register the newly created star. We're going to register it in the star storage variable. And it takes the slots of the new star and the address of the color. So I'm going to put color address and the current slot.
00:33:40.270 - 00:34:23.446, Speaker A: And the size of the star, which is the dust amount. So here we have it. And then we have to increment the slot of the user write cursor slot address. Because we want to put it here. And we want to put the increnated current slot. So you can actually perform operations in the function call, which is great. And you emits an event, which will be star is born.
00:34:23.446 - 00:34:48.166, Speaker A: Emits. And then the parameters, which are the accounts, the slot and the size. So the account is color. The slot is desk mount. So here we go. We have this. Okay, so this is good.
00:34:48.166 - 00:34:53.240, Speaker A: And we have to write views. And I'm going to use my snippet still here.
00:34:58.110 - 00:35:07.386, Speaker B: Luca Saboro is asking what's being used for auto formatting the code in vs. Code.
00:35:07.568 - 00:35:39.000, Speaker A: It's the Cairo formatter, which is built in with the Cairo laying package. And then I just set the format on save here. And then I put the path to the Carol format. If you want to have your Carol format path, you can just go with which Carol format. And there you go. You have it. And you can just paste it here.
00:35:39.000 - 00:35:44.760, Speaker A: I think I will send this one.
00:35:49.130 - 00:35:58.358, Speaker B: What can you explain a bit? What's this settings that, Jason, is it some thing you have? It's your vs. Code settings.
00:35:58.454 - 00:36:21.410, Speaker A: Yeah, it's the vs. Code settings that you can reach some way. It shouldn't be really hard. And then you can set whatever you want. These are my settings. Feel free to have your own. If you don't want to put the format and save.
00:36:21.410 - 00:37:06.574, Speaker A: You can also use the regular carrot format. Format your contract here. All right. Can format this like this will print out the formatted contract in your terminal. Or you can do it inside your file, adding the e flag and it will modify your file and format it for you. So let's come back to this. So the view, we want to view a stark and a star needs an address and slots.
00:37:06.574 - 00:37:44.618, Speaker A: So we're going to get them as parameters. Address. It's not mandatory to type every variable. I just like to do so. It's not mandatory. So we're going to get the star here, star read and then the address and the slot here. And for the slots, view slots.
00:37:44.618 - 00:38:54.702, Speaker A: It takes an address and it returns what you need. It returns a field from here it. The two variables here don't have to match. You can do whatever you want. I like to match them but my personal preference will be next available slot of the users. All right, so I think we're good for this one. And we're going to write this, by the way, did this because here it's the name that they wanted to implement.
00:38:54.702 - 00:39:29.710, Speaker A: So you have to go with the same name as they did in the unit test file. And here, second exercise, we want to start, we want to give a name to star. So let's create a struct. Struct. The name would be Star. The first member would name, which is a felt. Second member size, which is a felt.
00:39:29.710 - 00:41:17.780, Speaker A: This is the link to the documentation abstract. And here update the light star somewhere else it may take. Okay, the light star which we're going to copy paste from the previous exercise instead of dust amount. We're going to take a star, which we can conflict with the storage variable star and it's a star. And then we're going to do a lazy trick which is define desk mount equals to new star size. Here we've got the address, we've got the balance. The balance is all right.
00:41:17.780 - 00:42:19.830, Speaker A: And then we write okay, so this is still okay. And here we're going to write the new star, not the dost amount, increment the slot. And should we update the star. All right, this should work. We're going to create the views after we see the previous test worked and they didn't because I didn't put the right variable name, which is color. Here it's color, address should work it. All right, we're going to create views.
00:42:19.830 - 00:43:08.520, Speaker A: Create and select I and returns. And so we're gonna same right here because we're going to write.
00:43:12.090 - 00:43:22.306, Speaker B: Hey Lucas, there's a question mixabox is asking. Did you create a custom vs code shortcuts to complete the storage VAR implementation?
00:43:22.498 - 00:44:18.460, Speaker A: Yeah, I created vs. Code snippets here, which are here these are my snippets, but they're available on GitHub. Not sure if it's the latest version, but there is at least something. And the carousel are here and they're here and you can just copy paste them if you like. I'm going to put the link on discord because I'm not sure I can put them on YouTube. Yeah, you can just add them in your own snippet file, but this will save you like a lot of time. There are for revoke preferences too.
00:44:18.460 - 00:45:05.958, Speaker A: It will just go like this and you just have to wait three pieces, which a lot of stuff here we got. So the test pass for the previous exercise. Now let's go with this one. And we're going to go to the next exercise. So we're going to get recursive now. So we're going to create a batch of stars, which is an array of stars. And what this does is it writes a star into the storage.
00:45:05.958 - 00:46:25.058, Speaker A: So we'll just have to call this function on each element. So when the length of the array is zero, we want to return because it means that we created every star. Okay. And then we got to put, and then what we want to do is to create a star in the order the star is index. All right? So if we want to create it in the order we want to insert star, what it does, it takes, which is here and it takes the new star. This is like a pointer to each star that we will increment. You can view the memory as an array and this is like the index in the array, which it points to.
00:46:25.058 - 00:48:06.680, Speaker A: And so to access the value, you can just put the pointer into brackets, to square brackets. And so then you start because here it wants a value, it doesn't want a pointer. And after we've done that, we're going to decrement the length because we got one and we're going to increment the pointer. So if we want to do that, we have to go, but we decrement it because we already put one. And then we have to go with pointer, array. Think something like this and you go, all right, this should work also pretty shown because it has the same problem. This takes the address color and this doesn't take address goes and here's it.
00:48:06.680 - 00:49:03.250, Speaker A: And we hope for the best. Ah, okay, the first one passed. Now let's see the second. All right, we're going to go. This one wants to keep track of ranks. Okay. So this one is for revokes references, which you will see a lot if you go with if else statements.
00:49:03.250 - 00:50:19.322, Speaker A: So this one, pass it's okay. And this one, and so this one keeps track of rank, right, one for so three for. So here we have to increment the rank of the color. Okay, so we're going to check, okay, so this one, so if the new user slot is equal to one, we have something plus one because it's the new one equals to one. We're going to update the rank rank. So we do this and write the rank because it's the first rank else. If from slot plus one equals ten, they will include the rank.
00:50:19.322 - 00:51:22.850, Speaker A: It's two else. If 100, we're going to write rank three. And here we can end here, we can end here, we can end now this won't work because there will be revoked references. The test of this one worked. So let's try to compile this one's. And this will have revoked preferences. Okay, so this is called pointer has been revoked.
00:51:22.850 - 00:52:35.500, Speaker A: So what's happening here is that there is one instruction here and there are lots of instructions here. So the asokiro loses track of the implicit arguments. And what you can do to solve that is to create ten vars, which will place the mean, the implicit arguments at the same place so the compiler will know how to retrieve them. So which is that? And not sure where to put them but probably somewhere around here and this does not work and we're probably going to keep them. No, let's add some more. This is like a high level debugging technique. Just put them everywhere until it works and then you delete them until it doesn't work.
00:52:36.270 - 00:52:38.086, Speaker B: Is that best practice?
00:52:38.278 - 00:52:39.020, Speaker A: Yeah.
00:52:41.310 - 00:52:42.300, Speaker B: It works.
00:52:45.150 - 00:53:09.042, Speaker A: If you have like nested. If else is like that. It's probably easier to go like this. Um, let's put some more maybe here. Probably not the optimized way I should probably have done.
00:53:09.096 - 00:53:19.900, Speaker B: I think you need to, you need to put an else to your second if this one. Yeah, you need to put an else and put your temp bars in them.
00:53:42.230 - 00:53:53.540, Speaker A: It works.
00:53:54.810 - 00:53:55.560, Speaker B: Cool.
00:53:56.570 - 00:54:31.120, Speaker A: This should also work. But the point is it's probably not the most optimized way. You should probably go with if blah blah blah else, blah blah blah. And another if else not nesting like this because it's like unreal. And yeah, we're going to assume that it works. I don't know if anyone has questions.
00:54:31.490 - 00:54:45.186, Speaker B: There were some questions, I relate them to you. I think we couldn't wrap it up. So can you share again please, the URL of the repo and if you have suggestions for people to do it. Or if you want to say some.
00:54:45.288 - 00:55:25.730, Speaker A: Concluding word, I'm going to share it again. For people that are starting with Cairo, go with obviously the beginner one. It has a great path of introduction to Cairo. You start with basic stuff and you go to more complicated stuff. So this is a great tool. Obviously the Cairo 101 on start native is probably the best to really start off, but this one is cool too. Don't be afraid of revoked references.
00:55:25.730 - 00:55:43.700, Speaker A: We don't really care if you put like ten vars everywhere like I did, just have working code and improve it after. That's what I would say and what I would advise people to do.
00:55:45.990 - 00:56:05.774, Speaker B: So that's wonderful. Thank you Luca. Okay, so before we conclude the call, just wanted to mention two questions that were asked. One of them was thank you for the update. Is there a release date for 0.8.2 and 0.9? So 0.8.2
00:56:05.774 - 00:56:28.600, Speaker B: went to Testnet. Today it will go to Mainnet. I think you would usually push them to Mainnet. Two weeks later. 0.9 is planned for mid to end of May for Testnet. The second question was will improvements related to parallel execution in the sequencer be released in 0.9?
00:56:28.600 - 00:57:10.910, Speaker B: I asked the question to the team in charge of these improvements and they said that yes, these improvements are still in store to be shipped in 0.9, but we don't have a lot of insights on them yet. We would like to get some kind of metrics to make sure that they will make things better. So if we do, we'll ship them and we'll see. But basically this is ready. We just need to make more measurements to make sure that it doesn't break everything. And that's it for the roadmap update.
00:57:10.910 - 00:57:50.270, Speaker B: I also want to end this call with a reminder of upcoming events around Starknet. So the first thing is next week there is an event in Miami. There's going to be a hackathon where various team are going to be able to build on various ecosystems amongst which will have starknet. So if you're in Miami, do check this out. If you're in the US, you can still register. So go check it out and go build cool stuff on Starknet. We might organize an online hackathon in June which you'll be able to join from everywhere.
00:57:50.270 - 00:58:28.490, Speaker B: It has not been fully decided yet, but probably we'll do it. If you have thoughts on online hackathons. Do you like them? Do you not like them? How can we make them better or more engaging? Do let us know. We want to make them better. After that, in July there will be an on site hackathon in Paris around eTCc. Hopefully you'll be able to compete online also. But for sure if you're in Paris around ETCC, there will be a starknet hackathon so you can start planning for that.
00:58:28.490 - 00:59:21.660, Speaker B: It's going to be a lot of fun. And finally, we may have another on site hackathon in Europe in not this is not sure yet, but we're sharing alpha things with you. So not sure, but probably will happen. If you're interested in organizing hackathons or meetups, do reach out. We need more people to foster the community and help our community grow. So if you have an interest in organizing meetups and having fun with fellow Starknet enthusiasts and talk about cool projects in your area, reach out and we'll see how we can help. Send you some swag, support you any way we can.
00:59:21.660 - 00:59:46.910, Speaker B: And that's about it for me. I'm going to check if there are other questions. There doesn't seem like there is, so let's wrap it up. Once again, thank you all for joining and I hope and hope you all have a great week. Goodbye. Goodbye.
