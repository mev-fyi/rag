00:00:03.410 - 00:00:53.646, Speaker A: Okay. Hello everybody, I'm Max, I'm from source remission and I want talk to you a little bit today about Protostar, which is tool chain for writing smart contracts for Starknet. I don't know, I want to ask first maybe are you familiar with the tool tool or everybody here is new and just want to know what professor is capable of. If somebody else familiar with the tool can raise your hand maybe. Okay, so that's great because it will be a bit introductory overview today, not very deep down things. Okay. The workshop will have format of more like of interactive demo with some exercises.
00:00:53.646 - 00:01:51.110, Speaker A: If you want to follow up with me, you can access this QR code or you have like short here. We have some time right now to access it if you want to do so. And everything I will be going through will be available in the script. And if I will be going too fast a little bit or something, you want to get to it later, it will still available. So yeah, that's it probably we have some time and we will be starting. Okay, so what is protestar? As I said, it's a tool chain for developing startnet contracts. What does it mean? It basically gets you through the whole process of writing a contract, from creating a project to writing it and testing it and at the end deploying it on Starknet.
00:01:51.110 - 00:02:43.438, Speaker A: And why actually to choose Protestar? Because there are some other alternatives in the ecosystem, like Nile or Hardhat. So Protestar first is fast, it's much faster and in some scenarios even ten times faster than alternatives, which is a big deal because testing speed is one of the biggest pain points of current devtools. It's pretty frictionless because installation and everything is made as simple as possible for developers. So we are focusing on that. Also it's pretty flexible because we have something we call cheat codes. I will talk about it a bit later. But those allow you to test much more possible scenarios.
00:02:43.438 - 00:03:19.810, Speaker A: And it's actively developed. We have quite a big team. We are very responsive to the community needs. We sometimes implement features which not even sometimes we very often implement features which are requested by the community. So that's it. And today we will work through creating a very simple smart contract in Protestar and we will try to deploy it. Devnet probably, but yeah, because probably 25 minutes is not enough to wait for a transaction to get accepted.
00:03:19.810 - 00:03:59.310, Speaker A: Okay, so installing Protestar is pretty easy. You can just copy nice one liner which is available in our repository and you can paste it to the terminal and everything will do itself. So it's pretty nice. You don't have to set up any pyon for whatever other tools need to. Okay, that's great. After that we want to probably create a project. So we start with Protostar init.
00:03:59.310 - 00:04:44.386, Speaker A: First run often takes a little bit of time because Python implementation, but next comments will be much faster. Okay, waiting for that. I want. Okay, I'm asked, no, I don't want to adapt anything. It's the text automatically if there are some in some directory or some kind of files. Because frustrate allows you to adapt existing projects to its structure. But it's outside of the scope of this workshop right now we can create just our project name.
00:04:44.386 - 00:05:30.066, Speaker A: So let's call it workshops. And done right now we can CD into our directory. And we are here, we have some files, but we will check it out in ade to have it bit easier. Okay. Going through the whole tree structure of the project, we have basically three files right now and two directories. There is Minecario and Src, which is searchcat for source. And those are basically our contracts we want to write.
00:05:30.066 - 00:06:18.034, Speaker A: There are tests which as names suggest tests are located. And it's Protestar toml which is very nice config file which saves a lot of time and development process and has some very nice tricks to help you out. Okay, so this is it. Right now. We will go to our contract, I will go to the script and we will take a look on little too big blob of code. But don't worry, I will explain everything in a second. Okay, so what do we have here? We have a very, very simple, most basic possible smart contract here.
00:06:18.034 - 00:07:16.790, Speaker A: What is there? There is a balance which is a storage variable which basically stalls fl and you can just store it there. There are one external method which is increase balance and how name suggests it increases balance of your account. You just pass amount as an argument and by this amount the balance is incremented. Also it has some asserts to check if the number is correct because you cannot like for example, increment the amount by negative amount. Okay. Also we have flex view for getting a balance which as the name suggests, it gets the balance and exposes this to external users. And we have a simple constructor which sets initial state to zero when you deploy a contract.
00:07:16.790 - 00:08:13.758, Speaker A: Okay, so we won't focus on writing contract here because Protestar is more for testing and we will focus more on testing because of that. Okay, let's take a look on a test for this contract. I will pass it here. And what is happening here generally, like Protostar flow for testing is a bit confusing, at least for beginners. And we are working on changing that actually. But I will talk about it in the end for future plans if we have some time. But generally for now, how exactly testing works? Often you have some internal functions of a contract you want to test, like standalone.
00:08:13.758 - 00:09:33.140, Speaker A: So we have a function in Cairo and you want to check if this function is isolated, does what you supposed to do, does what you want it to do, and such testing we call generally unit testing and how we can do it in Protestar. So here we have like contract, it's also a contract, but it's a testing contract which we name a test suite, which is basically it, it's one file with tests, which itself is a contract. And here we import the methods from the contract we wrote just before. And what Kyo does here during compilation is basically merges the test contract with the original contract. So those are actually the same contract, but the tests have access. So because of that the tests have access to, for example storage balance and can manipulate the state however it wants and can execute the methods of the contract. So it's a bit weird, I believe, but yeah, I hope it gets easier in time and has some sense in it and has some benefits.
00:09:33.140 - 00:10:12.798, Speaker A: It may be for people coming from foundry background, because Protestar is heavily inspired by foundry and this is something that happens there as well. Okay, so this test is pretty simple. It calls the method increase balance and then read storage variable. It checks if the storage variable has been incremented. Nothing fancy. Okay, so we will go to a bit more complex scenario to show you the power of Protostar. I will call newfire integration test.
00:10:12.798 - 00:11:18.414, Speaker A: You will see in a second why. Okay, I will need to do once more m magic copying here, but don't worry, I will explain as well. Okay, so what do we have here? We have bit more complicated setup. We have also smart contracts here because as I said, every test suite in Protestar is a smart contract itself which is deployed on local chain. And as you see here, this is a pretty standard carrier flow. So we have the other contracts interface and we want to do, instead of like merging the test contract here with the tested contract, we instead want to deploy the tested contract from test. It's also possible to report a star, although it's not recommended flow.
00:11:18.414 - 00:12:07.314, Speaker A: It's useful when you want to test, for example, multiple contracts interacting together, but it's slower because deployment is one of the biggest bottlenecks. It has a lot of performance overhead. So if you want your test to be fast, you should use the previous approach in most cases and those like two limited setup set of cases which are testing more general architecture. But we are showing for the sake of example here. Okay, here's the interesting part, because generally you can deploy a contract from another contract. It's how it works. It's only possible way to deploy it, but you cannot declare it.
00:12:07.314 - 00:12:38.926, Speaker A: You have to do it through ClI or something like that. In Protestar. You don't have to because we have cheat codes. What are cheat codes? Cheat codes are external parts of implement. It's an API exposed by Protestar which can be accessed right now through hints. And it allows to do a lot of illegal stuff which is useful for testing. So here it is, deploy contract, but the documentation explains it.
00:12:38.926 - 00:13:47.090, Speaker A: But it's basically under the hood, declares and then deploys contract. So you can just do everything from test here and we can see like we declare the variable, we deploy a contract and then extract contract address and save it to the variable. After that we can use it like a standard carrier flow, so we can call the contract, get balance and pass the address there and then assert the value. After that we can call increase balance, gain the balance again and assert the new value, which is correct. Okay, we have two nice simple tests which expose some cool features we have. So let's run them then. Okay, we are here and how to run tests, probably Protestar test, which seems intuitive and indeed, indeed is.
00:13:47.090 - 00:14:54.302, Speaker A: And you can see it collected two suites and it's like two tests because each suite has one test and both passed because they were supposed to do so. Okay, so we basically can consider our contract developed and tested. Of course it's very simple and probably in real life scenario you want to test it more extensively. But right now we can just go on and try to deploy it. Declare and deploy it. Okay, so for the purpose of this presentation I will use local instance of Devnet, but it will work the same if you want to do it for testnet, just like for Devnet will be faster and I have to do it this way. So first things first, we have to provide the protostar with private key because to declare and to deploy protestar needs to know your private key to sign to resentious.
00:14:54.302 - 00:15:37.910, Speaker A: So we start with this and it's provided us environment variable to be consistent with how Starknet does it in their CLI. So have a Devnet instance here, but I have to restart it probably and I should get my deployed. So Devnet comes with some pre deployed accounts which have some balance. So I will just use them. So I get the account number nine here and I will copy the private key here which works like this. Great. Right now we can probably build our contract.
00:15:37.910 - 00:16:25.374, Speaker A: So it's also as simple as that. We run Protestar build and that's all. One important thing maybe you want to know is how Protestar knows what to compile and what to test. So by default what to test, it just searches for our files which start with or end with tests in the test folder directory. And for compiling you have Protestar tombo which is a configuration file. And here you can declare all of your contracts. And for this example here it's only like one contract which is named main and then it has some source so it just defaults it.
00:16:25.374 - 00:17:33.820, Speaker A: But you can have more contracts declare and contracts can be composed from more files. So you can build much more complex things here if you need to do so. Okay, so let's come back to our declaring and deploying. Then we have our contract built so we can see its new directory appeared and it's called built. And we have abi here of the contract and we have compiled contract itself so we want to use it to declare it right now. So there is a very simple component for that and it's named Protostare declare. So let's write it here we have to provide max fee which we don't care here so we do 1000.
00:17:33.820 - 00:19:08.090, Speaker A: We also have to provide account address and it will be from our devnet instance here and it is here so we copy it and go here. Okay, what else? We can use a parameter network. If you want to deploy desknets it's probably, it's enough to write it and it will work, but we don't deploying contestnets during this presentation. So I will have to do a bit more complicated setup for the devnet. And here I need to provide this URL which is a URL of gateway and we need to provide the chain id which we don't care that much about it because it's devnet but Protestar requires it for the sake of consistency. But I don't remember which was correct, but we'll see. Protestar will hint me to correct one in a second.
00:19:08.090 - 00:20:47.370, Speaker A: So I give a path to my contract, compile one and as I said we need to provide correct id and I will just go with here and it worked and what next? We want to deploy it so we need class hash for that and it will be quite similar to the comment before. So we just need to change declare for deploy and contract path for which supposed to happen. Okay, we need to deploy and we need to also replace our path here because we want to provide class hash because our contract is already declared. Okay, that's all. You can see that providing those arguments for those commands is pretty cumbersome. And we solve that because of Protestore config. Because you can provide all of this, because right now it's kind of similar to using Starknet Cli, but here each of these arguments can be provided in prestige config, so you don't have to write each time you want to declare or deploy new version, for example.
00:20:47.370 - 00:22:11.940, Speaker A: And what else? It's not only like you can declare one set of arguments. Protestar supports profiles so you can for example, write proto star profile, something which is your custom name, and then the command you execute will use this profile. So it's pretty nice thing to use. Okay, so that was kind of the overview of the whole process, but it's very small scope of what Protestar is capable of because feature sets right now is quite big, I would say, and there are lots of things you can use and learn about. So first thing is you can right now read about Protestore config which is included in docs which are linked at the top of the document, and learn how to use it properly to improve your workflow. You can dive into other cheat codes, because deploy contract is not only thing we have. For example, you can only declare contracts, you can expect some reverts, so you can test that your errors are handled correctly.
00:22:11.940 - 00:23:48.084, Speaker A: Also you can, for example, expect some events. You can modify the storage of different contracts, even the storage is not exposed and there are lots of lots of possibilities there. For example, you can mock other contracts methods so you don't have to deploy them, you can just simulate their behavior. Also, Frodastar supports fast testing or property best testing, which is very cool technique, also very popular among smart contract developers. And if you are not familiar with it, it basically allows you to instead of testing for one specific value like I did here, for example 42 instead we can instruct Protestar to randomize the argument so you can test it. For example for 100 random values you can of course control the size of the sample. Also, Protestar Cli is very compatible with various type of scripts because we have flag JSon which when you use the script instead of printing the nice pretty print output will give you a JSON which you can read for example from script, and it's compatible with whatever language you choose.
00:23:48.084 - 00:24:52.216, Speaker A: So you can write your, for example, deployment scripts in Python bash or JavaScript or whatever is used these days. Rust probably popular one if you want to write your deployment script in rust. Okay, and also the cool feature we have is transaction profiler, which even I will show you, but probably I don't have time for that. So basically you can generate visualized execution graph of your transaction so you can see which functions of your contract are actually I will show you fast screenshot because it's only I have time for. So you can get a nice tree over execution of your contract and get distribution of costs in terms of built ins, memory holes and steps of each method. So it's also very cool if you need to save on gas. And that's all for today.
00:24:52.216 - 00:25:18.030, Speaker A: Thank you for listening. And if you have any questions or you want to use protostar for any purposes you have, don't restrain to talk to me and we'll be open to talk. And for example, we are open to feature requests as well because we want to address the community needs as much as possible. Once again, I'm for software mentioned and thank you for your time.
