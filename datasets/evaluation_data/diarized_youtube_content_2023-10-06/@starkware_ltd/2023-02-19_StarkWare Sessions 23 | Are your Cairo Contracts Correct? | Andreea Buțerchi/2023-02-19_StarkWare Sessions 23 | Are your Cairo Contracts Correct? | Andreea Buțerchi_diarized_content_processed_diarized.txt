00:00:03.930 - 00:00:39.846, Speaker A: Hi everyone, my name is Andrea Buterke and I'm a vice president of engineering at Veridice. In today's talk, I will present the research and development efforts conducted at Veridice that aim to secure the startnet ecosystem. So if you don't know yet if your Skyro smart contracts are correct, then stay around. I have a few exciting things to share today, so let's start with a bit of motivation. 2020 was officially declared as the biggest year for hacking on record. As the statistics show us, bugs and vulnerabilities in smart contracts have severe implications, including loss of financial assets. So only in 2022, the attackers drained over 3 billion from Defi applications.
00:00:39.846 - 00:01:21.186, Speaker A: One thing to note is that the attackers didn't target only one ecosystem. Attacks have been observed in Binance, Ethereum, Solana, and others. Of course, we wouldn't want Starknet to be the attacker's next target. However, one thing to keep in mind is that Cairo smart contracts are not immune to bugs. So to prevent potential attacks, we need to be proactive about finding bugs, fixing them, and making sure that new ones don't surface in our Cairo smart contract. So this is where Veridice comes into play, because it can help Cairo programmers secure their smart contract. So what is Veridice? Veridice is a blockchain security company that provides state of the art tools for all layers of the blockchain ecosystem and also manual audit.
00:01:21.186 - 00:02:13.670, Speaker A: Our tools is to hunt down bugs in our clients'code and also to prove that the code is consistent with the expected behavior. In today's talk, I will present two of the tools developed at Veridice Magi, our former verifier used to reason about the correctness of Cairo programs, and Orca, our fuzzing framework used to spot bugs in both solidity and Cairo smart contracts. So before diving deep into the specifics of these tools, let me first give you an idea about the services veridice provides. More broadly. In a nutshell, Veridice builds automated security analysis tools that can give you real time feedback about the bugs and vulnerabilities in your code. We make these tools available through our SaaS, or security as a service platform. So how does our SaaS platform work? The first step the users need to do is to upload the source code, in this particular case, a set of Cairo smart contracts.
00:02:13.670 - 00:03:06.470, Speaker A: The next steps the users have to do is to provide the formal specification, or in other words, a programmatic description of the intended behavior of the smart contract. Once our SAS receives the request, our tool will analyze the code with respect to the formal specification. And finally, if the source code doesn't conform to the expected behavior, our tools will provide the users with a list of uncovered issues. All right, now that we know how our SAS works, let me briefly talk about the secret ingredient that powers our tools, which is the V specification language. First, let's understand the execution model of the V specification language. Because in real blockchain environment, users have multiple interactions with smart contracts over time. The V specification language models the blockchain transaction's history as a linear series of transactions.
00:03:06.470 - 00:04:08.300, Speaker A: Therefore, this allows us to reason about the state of the blockchain at specific moments in time, either before or after the execution of a transaction here marked as started and executed. All right, so the V specifications are composed of v statements, which have the following structure, action, target, and property. Let's analyze this simple example. A specification for an ERC 20 smart contract this specification says that a call to the mint function should execute successfully when the sender is the owner of this token contract. So, let's discuss a bit about the components of the V statement. An action is actually the transaction state, which can be started, executed, finished, or reverted. The target is a transaction to be executed, and the property is a Boolean expression over the state of the blockchain, as we previously saw.
00:04:08.300 - 00:05:29.030, Speaker A: So given that we can express smart contract interactions over time, the V statements can be also combined using temporal operators, which are always eventually next and others. And we will see an example in the next slides. Okay, so what makes v so unique? Well, you can easily express properties and invariants for your contract, where an invariant is a property that should hold throughout the execution of the smart contract. So to have a better idea of the vispecification language's expressivity and conciseness, let's consider the following specification for a crowdfunding contract. The informal specification says that a user can only withdraw as long as the amount to be withdrawn is less or equal to their contribution and the compelling on. Of course, we can express that in v by wrapping the call to the withdrawal function using the reverted action, and also to specify the condition under which the call reverts, which in this case when the contribution is less than the amount to be withdrawn, and also the campaign is closed. So one thing that I want to point out is that we can reason about functions in the smart contract and also public variables.
00:05:29.030 - 00:06:37.142, Speaker A: Okay, so now that we know more about the secret ingredient of veritize's tool, let's see the techniques behind them. So our tools make extensive use of the latest research into formal methods. So for those of you who are unfamiliar with the term formal method, they include mathematically rigorous techniques for finding bugs and vulnerabilities in smart contracts, and also constructing mathematical proofs about the correctness of software and also hardware. So at veritice we use three formal methods, automated testing, in this particular case, fuzzing static analysis, and also formal verification. Today, I will focus on the extremes of the spectrum, namely formal verification and automated testing. Okay, so the goal of formal verification is to prove the absence of bugs in software. Unlike testing, which mainly checks specific paths of execution, formal verification can reason about all possible paths of a code's execution, including the tricky edge cases that developers can miss and that can potentially lead to bugs.
00:06:37.142 - 00:07:56.610, Speaker A: Therefore, formal verification provides the strongest security guarantees of a program, and however the pros of this technique, it is not always scaling, and it is also requiring extreme precise reasoning about a particular program. So at veritice, we developed an open source tool, formal verification tool based on symbolic execution called magi, that can automatically reason about the correctness of Cairo smart contracts. As the majority of the tools under the SAS platform's umbrella, Magi takes in the source code, more precisely the Cairo smart contract and a v specification that provides the tool with the knowledge about the intended behavior of the source code. After this execution, the tool will either prove that the code adheres to the specification or will automatically find a set of values that violate the specification, and users can use these values in order to reproduce the bug. Okay, so a motivating example is the move function from the Makerdaos VAT protocol implemented in Cairo. This function is used to perform a transfer of a rad amount of DaI from the source to the destination account. The transfer is performed by subtracting from the source's balance and adding to the destination's balance.
00:07:56.610 - 00:08:54.626, Speaker A: So one interesting thing here is that rad is expressed as an union 256. So 256 unsigned ins are stored as a pair of field elements that should be 128 bits long for the low and the high bit. So keeping this in mind, it will soon become clear that there is a bug in the move function. The good news is that we can automatically discover that using Vegai. So if a call to the move function executes successfully, we expect the sources account balance to decrease or stay the same, and the destination account balance to increase or stay the same. Additionally, the balances of the accounts that are not involved in the transaction must remain unchanged, and this specification is expressed here in this square. So for this implementation, the move function of the move function major will output a counterexample.
00:08:54.626 - 00:10:20.420, Speaker A: So given that the felt can be expressed using more bits, more precisely, 252 bits, both parts of the unit 256 that make up red can be out of bounds. So this results in an integer overflow, which causes the balances of the source account to increase and the balance of the destination account to decrease, which is not acceptable of course. So supposing that the developers fix this bug by adding a check for uint 256 validity major can prove that the move function's behavior adheres to the specification. Okay, so this is the way we construct a v specification using a pre and post condition. So the precondition here is that given an arbitrary user order, this user is distinct from both source and destination. And the post condition indicates here the expected effect of the move function the move function call should have all right, so here you can notice a call to this old primitive, which is a construct part of the v specification language, and this one returns the prior state of the execution to check the old balances. The prior balances okay, so the main takeaway is that Magi detected a subtle bug in a real world project by using a fairly simple property.
00:10:20.420 - 00:11:01.662, Speaker A: One thing that I also want to highlight is that the move example was constructed for explainability, but Magi did find a similar but slightly more complicated complex bug in a different function called fold. So the bug was confirmed and fixed by the makerdao developers, as you can see here. You can also check the report we have on our website for more details. Now let's take a look at a demo of this tool. So this is the interface of our SAS. What I will do next is to create a job for running medji. You can directly upload the source code or the v specification, but here I have already uploaded those.
00:11:01.662 - 00:12:11.234, Speaker A: So I am just selecting the information I need and as you can see, I launch a new job. Here are the arguments with which the Magi was called, and as the job runs, Magi will give some information about its progress and in a few seconds you will see the result. Basically through the interface you can see that Magi found a bug. And with this reported bug, meji will give a set of variable assignments that can be used by the users to replicate the bug. All right, let's move to the automated testing framework. So fuzzing is a form of automated testing used for finding bugs and vulnerabilities in an application, regardless of its kind, by testing it against a number of cell door randomly generated inputs. So its main advantage compared with formal verification is that it scales better and it also has a higher degree of automation.
00:12:11.234 - 00:13:18.060, Speaker A: However, the drawback is that fuzzing is providing less correctness guarantees than formal verification. So Orca is our fuzzing framework, developed at veridice that can be used to test smart contracts that run on Ethereum or on startnet. So similar to Magi, Orca takes in the source code and the v specification and generates a series of transactions together with their inputs that try to violate the specification. So if the source code is buggy and give us sufficient time, Orca will eventually output a counterexample as a list of transactions that leads to a violation of the specification. So now let's see how work I can find a subtle bug that we have intentionally introduced in the spend allowance function from the ERC 20 Cairo library. All right, so we want to test if a general property for an ERC 20 smart contract holds, namely if users cannot spend more than they are allowed to. So we formally encode this statement using the v specification here.
00:13:18.060 - 00:14:31.518, Speaker A: One thing that I want to point out is that this property has a temporal nature, because you can see here we used the temporal operator always and also the negation. So we can read that as it's never the case that something finished successfully when this property holds. So you can also see here this star. This means that the property here in blue needs to hold for each transaction execution. All right, so how did we express this property? Basically in v we have this construct called f sum. So f sum sums up the amount that is passed to this transfer from and compares to the sum of the amounts that were approved. So in this case, if the user is able to transfer more than it was approved to, we have a violation of this property.
00:14:31.518 - 00:15:28.466, Speaker A: So we can see next that workai is able to to find a violation for the specification we discussed before. Here, the transaction section contains the minimized counter example as a list of transactions performed during orchest execution. And as you can see, the minimized example contains a call to the transfer from function that was executed successfully even if the users didn't had enough allowance. So now let's go back to the spend allowance function implementation to see how we can fix it. So the issue with the initial implementation was that we didn't check the amount to be transferred. Therefore the spender can spend more than desired and if the amount exceeds the actual allowance. So to fix this issue, we added the check over the amount to be transferred and performed the transfer with the correct values.
00:15:28.466 - 00:16:27.340, Speaker A: Now we can see that orca outputs a message informing the user that no country example was found within the given timeout. So the main takeaway is that worka can automatically find violation of a specification of the Internet behavior. All right, let's take a look at a demo for worker. We do similar steps as from AGI. We select the source code, we configure the tool, and then we select the specification that is able to catch this bug. And then we launch the job. In a few seconds we will see the counterexample produced by orca, and the first section here indicates that the counterexample was found in that time in 123 seconds.
00:16:27.340 - 00:17:31.124, Speaker A: The deployment section contains the deployment of all contracts involved in this example, and also the transaction section indicates the bucket was found, which is represented here by a call to the transfer from function. All right, so to summarize, veridice is developing tools based on formal methods that have complementary strengths. As we saw, mage and worka are powerful tools that can help you to secure your Cairo smart contract. And I also want to point out a few nice features of our SaaS platform. First of all, it provides users with integrated access to Veridice's tools. Second, the user don't have to worry about installing the tools and also configuring them because Veridize's engineers tune them already. In addition, our tools can provide guarantees for multiple languages and blockchains, including Ethereum and starknet ecosystems, zero knowledge proofs, circuits, rust and go blockchain protocols, and others.
00:17:31.124 - 00:18:01.550, Speaker A: And last but not least, given that our specification language is designed in a blockchain and language agnostic way, SAS allows user specifications to be used across all of our tools. Okay, that was it. I hope you enjoyed the presentation. I'm happy to address all of your questions and if you want, you can contact us using the information here. And also you can talk either with me or with my colleague colleague Daniel here in the room if you have any questions.
