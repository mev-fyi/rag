00:00:02.730 - 00:00:37.510, Speaker A: Hi everyone. Thanks for coming. It's Omer. I'm one of the senior engineers at Netermine, working on the Juno client that you just listened to Josh's great presentation about. But I won't be talking about Juno today. I'll be talking about Mev in Starknet, since I believe it's a fairly unexplored topic, at least in publicly. So I'm hoping that this presentation could serve as a brain teaser to get some community ideas flowing, mainly.
00:00:37.510 - 00:01:25.480, Speaker A: So I have a bunch of stuff that I want to talk about, so I'll just jump right in. So, first things first, what is Mev nowadays? It stands for maximally extractable value. So here's a definition from Ethereum Foundation's website. The key part here is that it is the value that can be extracted from block production by including, excluding and changing the order of transactions in a block. So being in a position that allows you to do so, duties are crucial to be able to extract mev. In Ethereum's context, this was miners for a very long time. And now, since they switched to PoS, it's the validators, the block producers, that are in this position.
00:01:25.480 - 00:02:42.030, Speaker A: So MeV at its core, it's mainly about information asymmetry. So there are privileged actors with more information than the rest of the network, which are mainly validators, block proposers, and people with capable, beefy hardware that are actually able to just go through the entire mempool and search for mev opportunities. These two, they leverage essentially the bird's eye view they have over the entire mempool to be able to extract value from unsuspecting users transactions. So let me switch to Starknet. This is a diagram of the network that we have currently in production. So at the heart of the entire network is the core contract on layer one. So what it does is it essentially verifies the validity proofs that provers are generating, and it gives a permissionless access to l two data that is being posted on there by the sequencer.
00:02:42.030 - 00:03:54.018, Speaker A: Currently it is locked down. The L1 contract is locked down in a way that it only allows starkware to submit proofs, but with the network, as the network gets decentralized, the centralized prover will be replaced with a proverbs market where essentially everyone can compete to be able to provide proving services to the entire network. So the interaction between core contract and the provers is not really subject to any meV. The proof being delayed or coming a bit earlier doesn't really change much, at least from a l two transactions point of view. What's interesting with respect to MEV is the sequencer and the network of non sequencing nodes that we have. This part could be subject to MEV today, even with a centralized sequencer. So the sequencer obviously is responsible of sequencing the transactions.
00:03:54.018 - 00:05:11.166, Speaker A: It's currently a centralized entity run by Starquare. And the full nodes are like the non sequencing nodes are the full nodes that are either run by the RPC providers or individuals that actually need access to starknet data, or they want to interact with the network. So Starkware and the RPC providers are decentralized entities here, although they are pretty much trusted, hypothetically speaking. Sequencer, since it currently has absolute authority over which transaction goes into a block and in which order it could potentially extract every bit of MEV that is currently being created on Starknet. When it comes to RPC providers, they are actually the first ones to know of a transaction, know about a transaction, because they are the relayers to the sequencer. So potentially they could decide to front run any user who are routing their transactions through an RPC provider. And with p two p coming.
00:05:11.166 - 00:06:08.114, Speaker A: Currently the mempool is not public. Sequencer doesn't give that information out, but with p two p coming, the MEM pool will become public as well. So although they'll be able to do that in a less profitable manner, anyone will be able to search for MeV opportunities in the mempool and try to extract them. So one other point that I need to make is that not all MEV is created equal. So the MeV extraction is an open generation race, right? It's open to anyone, anyone could do it and has an intrinsic value attached to it. So it is actually quite reliable to be included in a protocol's design. If your protocol is creating mev opportunities that are profitable, someone sooner rather than later will take it.
00:06:08.114 - 00:07:08.822, Speaker A: You can rely on that. So protocols have come to rely on it. Like dexes, they don't rely on, but they benefit from arbitrage to be able to provide better prices for their users or lending platforms. For example, they heavily rely on MEV for liquidations of barber positions. Essentially, anything that happens on chain automatically is a user of MEV. There's even a job board in GitHub that like protocols for protocols that need a bot for their application. So what if protocols don't address the existence of bad MeV? So the most obvious one is that the users are suffering losses here.
00:07:08.822 - 00:08:17.386, Speaker A: So the value that is being extracted here is coming straight out of the protocol's users. And also the MEV extraction, since it creates new demand for the block space, it creates additional confirmation latency on user transactions, and it increases the fees that users have to pay as well. So users are both users both suffer a financial loss and the experience they get degraded. So they might as well just decide to leave for another protocol. What's equally important is that MEV actually messes up validator incentives. So validators are mostly rewarded in blockchain protocols. But at the times of high MEV, where MEV revenue is really high, the rewards could definitely be dwarfed by the MEV revenue that a validator could get.
00:08:17.386 - 00:09:24.530, Speaker A: So validators might decide to just go rogue and act on their own benefit. Maybe like for example, they could just reorganate perfectly valid blocks just to be able to extract MEV from it and cause instability through the network. So to me, it is obvious that the MEV should be addressed at protocol level. There are a couple of ways to do it. You either make it quote unquote impossible, or you make it more accessible so that it even further decentralizes the network. So one way of doing it is encrypted mempools. So with encrypted mempools, transactions are encrypted in a way that the protocol only allows transactions to be decrypted only after either the transaction ordering is finalized or it is committed by the proposer in a way that the proposer can be held accountable.
00:09:24.530 - 00:10:40.310, Speaker A: So this eliminates information asymmetry by making the information needed for mev extraction private until it is too late for someone to extract mev from directly a user. So ideally, an encrypted mempool protocol should be non interactive, meaning that when a user broadcast their encrypted transaction to the network, they shouldn't need to be online and they shouldn't need to be there to decrypt it for the execution phase. There are a couple of ways of that. There are a couple of encryption schemes that enable this. One of them is timelock encryption, so it allows transactions to be decrypted, any message to be decrypted, but a transaction, in our case to be get decrypted after some time. But this requires an additional deadline on transaction inclusion, because otherwise the proposer can just wait out the time lag and decrypt the transaction before putting it into a block. So the user experience is not that great, because if the deadline is exceeded, then you have to retry.
00:10:40.310 - 00:11:58.820, Speaker A: And even if you don't retry or retry in time, the sequencer already knows what you intended to do so, they can still front run you. So another encryption scheme that it could be useful is threshold encryption. So in a m of n threshold encryption m participants out of n should collaborate to be able to decrypt the message. So participants in this case being the block proposers and the sequencers for Stacknet, we assume that majority of the block producers won't be colluding to decrypt a transaction before the ordering is finalized. So with the threshold encryption, the transactions are only decrypted after they're committed into a block. Some protocols employ a different set of nodes just to hold the keys, but that has its own trade offs. But I won't be going into them right now.
00:11:58.820 - 00:13:03.910, Speaker A: So the most obvious drawback of this implementation, this approach is the edit latency. So if you go with the timelock route, you either have to just time the transaction inclusion just right, so that you can decrypt the transaction to be executed fairly shortly. But that's not really something to depend on for threshold encryption. So some sort of consensus is still needed to be able to decrypt the transaction or like additional network communication. So if you require the commitment to be on chain for threshold decryption, this delays the execution by at least the one block. So even if the transaction is included in a block, it won't be executed. It will only be executed in a later block.
00:13:03.910 - 00:14:09.094, Speaker A: But you could move the commitment to off chain, but the key holders will still have to come to a consensus that the transaction was committed to and somehow decrypt that transaction, which increases the overall latency, overall consensus overhead per block. So one other approach that could be useful for could be applicable to starknet is distributed fair ordering. So it's a distributed approach to dealing with mev. So it aims to provide an ordering according to some fairness criteria. So we know that Starknet is aiming to adopt a version of a slightly modified version of tendermint. And tendermint is a leader based protocol. So each round, one of the proposers, one of the validators, sequencers are selected as a leader.
00:14:09.094 - 00:15:00.910, Speaker A: Does the actual block creation, and the rest of the participants actually check, double check? The leaders work, but neither tendermint nor the stagnet protocol define how the transactions should be ordered. So essentially, transaction ordering is completely arbitrary. Distributed fair ordering is trying to fill this gap by making the ordering part of the protocol, so that the voters can still double check the proposers transaction ordering. So it works in stages. First stage is gossip. So each node gossips the transactions in the order that they received them. So each participant in the network have a global view of when others receive the transaction.
00:15:00.910 - 00:15:56.480, Speaker A: Then the next stage is the agreement stage, which they essentially decide on which set of nodes whose local orderings will be used to define the final ordering. So it essentially minimizes the solution space and the final stage is the finalization. So this is where the final ordering is decided. So essentially, if a transaction a is before a transaction b, and majority of the like, from majority of nose point of view, in the final ordering a should come before b. So only a set of transactions will satisfy the entire. Only a set of orderings will satisfy the local orderings of everyone in the network. So there's both leaderless and a leader based approach for this.
00:15:56.480 - 00:17:00.914, Speaker A: But I'm already out of time. So the last approach that I will talk about is proposal builder separation. So the previous two approaches that I talked about is they are trying to counter MeV and PBS is trying to do the opposite and enshrine it and leverage it instead of countering it. This is really popular in Ethereum right now. When I took this stat, it was more than 90%. 90% of the blocks were using some sort of proposal builder separation for block creation. So the barrier of entry to block building was with the switch to PoS, it changed the capital investment of 32 e.
00:17:00.914 - 00:18:07.566, Speaker A: Prior to that, it was the computational power that was needed for mining to be profitable. It is arguable which one is a higher barrier of entry. But with staking services being built, the number of validators in Ethereum skyrocketed recently. So proposal builder separation actually helps Ethereum keep this high decentralization of the validator set. But Starknet doesn't really need that, since we already have validity proofs, Starknet could get away with a much smaller well later set. So what's in it for Starknet? So what PBS could provide for Starknet is an efficient builder market. So block building is not something that proposers or validators are really good at in terms of the MEV that is being extracted for protocols or users benefit.
00:18:07.566 - 00:19:08.154, Speaker A: So by employing PBS, we could extract that MEV for the entire protocol and the users of it. So this is what it looks like. This is what a PBS based MEV supply chain looks like. So the users create transactions, they get pulled, they get put in a private mempool and searches with capable hardware. They search for MEV opportunities in this pool of transactions. They create bundles out of them which extract the MEV, and the bundles get sent to builders which build entire blocks out of those bundles and eventually relayers collect these multiple blocks that are coming from multiple builders. They send enough metadata about it to block producers to be able to get a commitment on one of them.
00:19:08.154 - 00:19:56.900, Speaker A: And once the block producer commits to a block, the entire contents of the block is revealed to the entire network. And this way of doing PBS that I just described is actually an add on to any existing consensus protocol. What is being discussed in Ethereum community is actually enshrining that PBS supply chain into the protocol itself. And since decentralized Starknet is still in the make, we could even go with an enshrined PBS option even from the start. Yeah. Thank you.
