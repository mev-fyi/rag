00:00:00.090 - 00:00:02.542, Speaker A: With YouTube, and then we can do the intro.
00:00:02.676 - 00:00:03.118, Speaker B: Perfect.
00:00:03.204 - 00:00:24.574, Speaker A: Okay. I pressed go live on YouTube, and boom, we're live. Okay, cool. So, hello, everyone, and welcome for a new live coding workshop for Starknet. I'm Henry from Starkware, and today I have the Eroditus team. Hey, guys. Hello.
00:00:24.574 - 00:00:29.560, Speaker A: Nice. Nice to have you here with us. Yeah. Can you introduce yourself?
00:00:30.170 - 00:00:55.902, Speaker B: Sure. So, hi, my name is Casper. Casper Kozio. I'm one of the co founders of Herodotus. Essentially, prior to doing full time, like ZK storage proofs and this stuff, I was building option protocol called Pitch Lake at Euler Network. Before that, I was a software engineer at. Yeah.
00:00:55.902 - 00:01:02.782, Speaker B: And we're here with Tiago and Mache. Cool.
00:01:02.836 - 00:01:22.306, Speaker C: So, yeah. Hey, everyone. I'm Tiago. I'm a research engineer at Herodotus. I'm working mostly with the low level stuff, with some cryptography and with some Zika proofs, but sometimes also jump on the more high level stuff. Yeah. Before Herodotus, I was working a lot in the defi sector, so I was developing smart contracts, various Defi protocols, and.
00:01:22.306 - 00:01:28.220, Speaker C: Yeah, right now, I'm very happy to be focusing on this sort of more low level stuff and in my opinion, more fun stuff.
00:01:30.990 - 00:02:00.180, Speaker D: Hey, I'm Mache, and at Herodis, I'm doing back end and infra, more like kind of web two connected with web3, back end with a lot of infra work and basically making everything easy for you and taking away the boring stuff. And before, I've been doing a lot of things, I'm a full stack guy and did some stuff in hardware as well.
00:02:00.870 - 00:02:13.378, Speaker A: Super cool. Thank you, guys, and welcome again. Okay, cool. So maybe before we start, or. I don't know if you have this plan, but can you give us a small introduction as to what are storage proofs?
00:02:13.554 - 00:02:45.998, Speaker B: Yes, so there's. Storage proofs have been on Twitter quite a lot recently. Essentially. I think the best way to cover storage proofs is kind of, first off, explain how we got here, why we need them, why they are a big, kind of, like, breakthrough, especially these days now that we have ZK as well. So storage proofs in general, they're not a new technology. They have existed for a while, as far as I'm aware. They were first explored by Argon a few years ago.
00:02:45.998 - 00:03:35.940, Speaker B: That was in, like, I think, 2018. And at that time, that wasn't very feasible simply because we didn't have ZK. We had to do all the computation on chain. It was very expensive, and it was just not a very feasible approach. And what we're essentially able to do with storage proofs is be able to fine tune and fine pick very specific components within a blockchain and be able to cryptographically prove them. So for example, we can generate storage proofs for ERC 20 balances, ERC seven, two ones, for example, like nfds, like ENS domains. They're very powerful because they allow you to read beyond what's happening right now.
00:03:35.940 - 00:04:37.954, Speaker B: Normally, within a smart contract perspective, you kind of have this real time mindset, meaning that if you're a smart contract, you're able to read the data. That's right now, and to a certain scope, 256 blocks backwards. With storage proofs, what we're able to do is we're able to unlock historical data, which is one of the most beautiful components of it all, that we can go all the way back to the genesis block and read what happened in, for example, block number ten. If you ask me what was like your account balance a year ago, I can tell you how much USDC you had on your account. In a way that's just proof. It's cryptographically guaranteed to be correct. And what we're trying to do is essentially eliminate this off chain attestation factor, this off chain trust element in on chain applications, like in the future of blockchains, we see that we should really trust the underlying technology rather than external parties.
00:04:37.954 - 00:05:00.170, Speaker B: Even though it's very unlikely that something, let's say like an oracle, could be manipulated, it is technically possible, meaning that we can have an approach that everyone is always going to be a good actor. But at the end of the day, we want to be able to trust math, we want to be able to trust cryptography rather than individuals.
00:05:00.670 - 00:05:18.450, Speaker A: Absolutely. And I think this is something that resonates a lot. It feels weird that in the blockchain industry you have to justify why not trusting somebody is better than having to trust somebody. But it absolutely makes sense, right. If you can, it's much better to trust code than to have to rely on humans.
00:05:18.950 - 00:05:19.362, Speaker B: Exactly.
00:05:19.416 - 00:05:20.850, Speaker D: Don't trust, verify.
00:05:21.190 - 00:05:21.940, Speaker A: Exactly.
00:05:24.870 - 00:05:32.214, Speaker B: Yeah. So maybe we can kind of go over some very interesting short question.
00:05:32.252 - 00:06:14.178, Speaker A: So you're saying you can prove what happened in the past. You can also prove what happened on another chain, on chain a. What happened on chain b. What I think is also really interesting about storage, but maybe you were going to talk about it in interesting use cases, is you have the ability to take certain elements that have specific properties today, like, for example, events that are something that is related, that are fired once but can't really be used by the state of a smart contract. You actually, with storage proof, have the ability to reuse them later on. You can prove that an event happens, you can take back this data that was fired and forget and actually not forget it and enact stuff based on it.
00:06:14.264 - 00:07:09.990, Speaker B: Right, exactly. Data access has become only much harder over the past few years. If you think about it, in the early days of Ethereum, if you were looking at this situation from a smart contract perspective, you had access to all the data in the blockchain in the sense that you knew what all the balances were, you knew who all the token holders were, et cetera. But as Ethereum started to scale, the need for layer twos became a thing. We needed to increase transaction throughput. And while there have been a huge amount of benefits that layer twos brought and unlocked and enabled this increased transaction throughput. One of the consequences of this approach that was taken by the Ethereum ecosystem was sharded data access, meaning that suddenly it's very difficult to know what's happening if you're that same smart contract and you're trying to figure out what's happening on another blockchain.
00:07:09.990 - 00:08:11.274, Speaker B: The majority of the solutions available today, in fact, I'd say pretty much all of them, rely on some sort of off chain attestation. Even if it's secured by cryptography, it requires an off chain party to either do a signature, aggregate, multiple signatures, et cetera. And if you're that same smart contract, you lost this. It's. It's been a while since this kind of transition started happening, and I'm sure you'd agree, Henry, that over the course of the past few months, it's been at Denver recently, there's been so many new layer twos popping up left and right, and this data access problem will only get bigger. And that's what we really believe in, and we're working hard to solve it to enable applications to once again be able to go into those early days of kind of like in the early days of Ethereum, to be able to read this data in a trustless way. Cross chain perfect.
00:08:11.392 - 00:08:47.042, Speaker A: Sounds exciting. There are a few narratives that pop from time to time, and they circulate, right? And different people that get excited about different stuff, about Zk roll ups and layer twos. And sometimes it's one thing that people talk all the time about, and sometimes it's other. You've said that people start talking about storage proof on Twitter recently. I think this is one of such narrative, like, sometimes we don't talk about it that much. But then people start thinking, oh, wait, you can do this and this. And I think it's a really interesting primitive with which you can build a lot of stuff.
00:08:47.042 - 00:08:59.370, Speaker A: So I'm really excited to see what you're going to present and what people can build. All right, so I'm going to go out of the way and let you present your stuff. So who's starting the presentation?
00:08:59.950 - 00:09:16.640, Speaker B: Maybe I can kind of first explain. What we're building at Dot is from a product perspective, what the products are, how they're structured, and then Tiago can dive into the low level technicalities of how they work.
00:09:17.490 - 00:09:18.240, Speaker A: Perfect.
00:09:19.970 - 00:10:28.706, Speaker B: Great. Okay, so at Herodotus, what we're building is an API that essentially abstracts the complexity away from working with storage proofs. Storage proofs in general have a lot of moving components, and they will be very dependent based on which chain we're operating on. If we want to build a truly cross chain world, the support for a variety of chains and importing and exporting data from a variety of different layer twos is paramount. We want to be able to unlock these different use cases. And due to this, the construction of every single one of these different layer twos usually differs in some way. What we do at Herados is we essentially benchmark different proving systems, we deploy different verifiers, and we do all the dirty work and then provide you with a simple to use API where you're able to essentially come and send a request, be like, hey, I want to read this data on this blockchain.
00:10:28.706 - 00:11:07.540, Speaker B: So for example, I want to read what my USDC balance is on optimism from Starknet. We're able to do that. And you make that request, we generate a proof for you, and then we send it to you. Now, even though we generate that proof for you, you don't have to trust us. We don't want anyone to trust us because at the end of the day, it's a proof. If we acted maliciously in any way, this proof will be rejected on chain. And then you can take this proof and essentially ingest it directly into your smart contract, into an onchain destination, or you can receive it to a traditional RPC address.
00:11:07.540 - 00:11:53.600, Speaker B: You also don't have to run archive nodes, you don't have to run any of the heavy infra. And also maintenance of essentially upkeeping the system can get quite expensive. What we're able to do is we're able to do a lot of cost optimizations by simply aggregating requests from multiple clients, multiple users, and taking advantage of something. We call it coincidence of will situations, transaction scheduling, et cetera, to make sure that the request you make is fulfilled at the cheapest price possible. And, yeah, so that's kind of the main product. That's what we're building at Herdis and Antiago can now explain how this works under the.
00:11:55.730 - 00:12:00.180, Speaker A: Yeah, fantastic. Tiago, do you want to share your.
00:12:01.430 - 00:12:02.226, Speaker C: Sure, sure.
00:12:02.328 - 00:12:02.594, Speaker A: Cool.
00:12:02.632 - 00:12:49.730, Speaker C: So, yeah, thanks for the introduction, Casper. Yeah, maybe before I share my screen, I'll just give like a brief introduction before I show the slides. So, yeah, I just like to comment on what Casper said about storage proofs are being mentioned a lot around in Twitter nowadays, and I feel like nobody really gets the definition right. Yeah, there are some ideas of what it is, but still, it's not like 100% clear because it's fairly complex. So what I'll try to do now is try to explain you, without going super deep into the technicalities, what actually is a storage proofs and how our system works underneath so that we can leverage them to enable this cross chain data access and this historical data access that Kasper just talked about. So, yeah, Henry, I'll share my screen. Let me know if you can.
00:12:49.880 - 00:12:54.980, Speaker A: Yeah, I can see it. I'm going to remove those of us who are not speaking.
00:12:55.590 - 00:12:59.542, Speaker C: Sure. If I put it in this full screen mode. Do you still see the full screen.
00:12:59.596 - 00:13:07.698, Speaker A: Or we can up. No, actually we don't. It says click to exist full screen.
00:13:07.884 - 00:13:10.060, Speaker C: Okay. So I'll just put it like this.
00:13:12.030 - 00:13:17.260, Speaker A: Or what you can do is instead of slideshow, you can select a presenter's view. That should work.
00:13:21.470 - 00:13:22.122, Speaker C: Like this.
00:13:22.176 - 00:13:23.950, Speaker A: Right now we can see it. Absolutely.
00:13:24.100 - 00:13:24.558, Speaker C: Okay.
00:13:24.644 - 00:13:38.782, Speaker A: I'm going to remove myself and make the presentation easier. There you go. All right. And probably you want to make your font a little bigger. No, actually, this is your presentation. Okay, this is fine. I'm moving to the background.
00:13:38.782 - 00:13:39.774, Speaker A: The floor is yours.
00:13:39.822 - 00:13:40.034, Speaker B: Okay.
00:13:40.072 - 00:13:44.610, Speaker C: It's not super important to be able to read these letters. After, I'll have some images.
00:13:45.750 - 00:13:46.162, Speaker B: Cool.
00:13:46.216 - 00:14:14.506, Speaker C: So, yeah, thanks for the intro again. So, yeah, let's start by diving into storage proofs then. Okay. Before we understand what actually a storage proof is, we need to get at the bigger picture first and make sure that we are all on the same page. So, firstly, let me start by talking about what actually contains a block. So, as you know, a blockchain is basically just a bunch of blocks connected together. So each block saves the parent hash of the previous block.
00:14:14.506 - 00:14:43.526, Speaker C: So all the blocks are linked cryptographically. And so this is basically the information that it's inside a block header. So in this case I just queried the Ethereum RPC. Actually, I believe it was the goalie RPC, but it doesn't really matter. So I queried the RPC to get me the block number zero, x, one before, and this is what the RPC returned. So this is all the information that's inside a block header. And the block hash that all of you probably heard is basically all this information hashed together.
00:14:43.526 - 00:15:24.354, Speaker C: So that's in the end we have this final hash that is so called the block hash. Actually, before we hash information, we hash all this information, we have to encode it in what is called the RLP encoding. And so actually what we hash is we hash the RLP encoded version of all this data. So yeah, pretty cool. So what this means actually, is that just by having a block hash, we can verify that a certain piece of information is indeed present in the block whose hash it corresponds to. So let's say I want to prove that this hash corresponds to this block number. I can literally just pass all this information on chain RLP encoded, hash it together.
00:15:24.354 - 00:15:59.914, Speaker C: And if it actually matches with this hash, it means that it's correct. So yeah, essentially this is what a storage proof is. A storage proof allows you to prove any information that's inside a block by having the block hash as like the main point for the proving to happen. So yeah, that's pretty much it. And essentially you can prove anything that's inside a block. You can prove account balancers, you can prove code hashes, nonsense. Anything that's inside a block, you can prove, which is pretty exciting and unlocks a whole new bunch of possibilities.
00:15:59.914 - 00:16:39.386, Speaker C: I think so, yeah. Also you might be wondering, I think all these values are pretty self explanable. You can probably understand what most of these values mean and these entries, but there are like three specific entries here that might be a bit harder to understand, which are the root entries. So we have the receipts route, the state route, and the transactions route. And this is actually important. So I'll kind of explain what these routes actually mean and how this works. So, as you know, a block also has, I'm going to focus on the transactions route specifically because it's the one that's easier to explain, but all the other routes work in the exact same way.
00:16:39.386 - 00:16:50.554, Speaker C: So on a block, as you know, we have a bunch of transactions, we have a list of transactions, and it would be very expensive, storage wise, to having to store all these transactions.
00:16:50.602 - 00:16:50.766, Speaker A: Right.
00:16:50.788 - 00:17:38.186, Speaker C: Because the transactions themselves also contain a lot of information. And so if a block has many transactions, it would be very expensive to store a block. So instead, the transactions are stored in a data structure that is called a Merkel Patricia tree, which is basically a kind of a Merkel tree. I won't go into the differences between those, but the Ethereum paper does a very good job explaining it. And so, yeah, basically you can think of the roots instead of. The way you can think of the roots is instead of having, in this case, all the transactions, you have this transaction route, which is basically a way where all the transactions are compressed into this final output. And by having this route, you can verify that a certain transaction in this case, is indeed present in this route.
00:17:38.186 - 00:18:13.558, Speaker C: And we do the same for the receipts and for the state. Roots is also here. So, cool. Now that we understand what actually search proof is and how blocks are structured, we need to understand how can we actually store all these blocks on chain. Because if we actually want to have access to historical data, we need to somehow have all the block hashes accessible. Right? Because as I told you, we need the block hashes to verify this information. And so here comes Merkel mountain ranges.
00:18:13.558 - 00:19:06.582, Speaker C: So, as you probably can guess, storing all the block hashes on chain would be completely unfeasible. Right now, Ethereum has around 16 and a half million blocks. So storing 16 and a half million block hashes on shiny, it's something that would be super expensive and not scalable at all as the chain grows. So we need to have some sort of data structure that allows us to commit all these block hashes and still have access to them in a way that we don't have to store them directly. So you can think that a merkel tree would be a good suit for this task. And you'd be correct. Actually, a merkel tree would be perfect for this task, because just like ethereum uses the Merkel Patricia trees, a merkel tree, we can commit to all the block hashes, and we can just save the root of the merkel tree on chain.
00:19:06.582 - 00:20:00.982, Speaker C: And this would work perfectly if we're just interested in historical data. The problem is that the chain keeps on growing beyond the point that we created the merkel tree, right? So if we want to operate the merkel tree, then we have to generate it off chain and upload it on chain again. And basically, there is no easy way of operating a merkel tree on chain directly without passing the whole tree again, which would defeat the whole point of using a Merkel tree in the first place. So basically, a Merkel mountain range, it's a very similar structure to a Merkel tree, but the difference is that it allows us to append values to the tree and also to update. We are not so interested in the update part, but keep in mind that you can also do it. So, yeah, from an implementation perspective, a Merkel mountain range is basically a list of merkel trees. And the root of each merkel tree is called a peak.
00:20:00.982 - 00:20:35.000, Speaker C: And the root of the Merkel mountain range is simply the hash of all the peaks together. And just by having this final route, we can verify that a certain element actually belongs to this Merkel mountain range, which is pretty cool. We actually implemented, I believe to be the first implementation of a Merkel mountain range in Cairo. So you can use it on Starknet right now. It's fully available, open source, and this other structure is actually very useful. So I'm sure that you might find some use cases for it. So, yeah, feel free to use it.
00:20:36.250 - 00:20:36.662, Speaker B: Cool.
00:20:36.716 - 00:21:20.210, Speaker C: So now that we also understand how we can store these block hashes, you might be wondering. Okay, so this is very interesting, but the tree would also be very big. Even though we are only storing the root of the Merkel mountain range, the tree would still be very big. The proofs would be huge, right? So it require a lot of color and a lot of computation to verify a single Merkel mountain range proof. Right. And so this is where the interesting part comes in. So basically, we use both snarks and starks in our architecture so that we can reduce the amount of call data and the amount of computation being done on chain.
00:21:20.210 - 00:21:56.874, Speaker C: So let me start with the stark part. So, as I told you in the beginning, we have to feed all these blocks somehow on chain. And now we know that we feed them to the Merkel mountain range, but still having to feed them one by one, or even if we pass a list of them, would be very expensive. Again, we have 16 and a half million blocks. So if we have to feed six and a half million blocks to the Merkel mountain range, it would still require 16 and a half million updates. Even though we are only updating the routes, it would still require those updates. So what we can do instead is we can batch all these updates inside a stark and then just verify this stark on chain.
00:21:56.874 - 00:22:32.490, Speaker C: So instead of operating the Merkel mountain range on chain, we operate it inside a stark, and we just verify the stark proof on chain, and we verify that the upgrade is indeed successful. Even though we are providing the Stark ourselves, we can't lie because the verification happens on chain. So again, verify don't trust. Sorry. This is pretty cool. So we save a lot on bandwidth and on computation, because we don't actually need to send all these blocks to the verifier. We just need to send the first block, and then we can compute all these blocks inside the stark.
00:22:32.490 - 00:22:58.962, Speaker C: I think you got the point. So, yeah, this is the first point. The reason why we're using starks, it's for this. And then we are also using snarks. And the reason why you're using snarks, let me go back here, actually, is to verify the Merkel mountain range proofs. So, as we've seen, Merkel mountain range can grow very big, and we need somehow a manner to verify the proof that's not very costly. And so we verify these proofs inside a snark.
00:22:58.962 - 00:23:49.818, Speaker C: And the reason why we use a snark here, we don't use a stark, is because this computation is significantly less, it's not as big as the previous computation as batching all these blocks together. So a snark is more feasible for this specific use case. And also because we are doing this inside a snark, we have to use, of course, a ZK friendly hashing function also for the SArC. So we use Poseidon and Peterson, depending on which chains we are working with in the use we use. And also, this is more of an implementation detail, but this proof would probably take like a long time to generate. So we actually work with recursive proofs, and instead of generating this large proof, we generate these recursive proof so that we can prove proofs inside proofs. And then we just need to generate this final proof on shine.
00:23:49.818 - 00:24:29.538, Speaker C: And this is much more efficient on the proverbs. Yeah, but it is quite like a low level implementation detail. You don't really need to understand this. So that's why we created an API. So basically what our API does, it works with all these complexities and it abstracts away all the logic for you as the end user, as a developer, so that you can just simply call an API endpoint and you have your proof that is generated and verified, and then you have your callback on chain, which you can just consume in various different manners. So, yeah, that's it on my side. How do I stop the screen share?
00:24:29.624 - 00:24:40.680, Speaker A: Oh, I'm back. What do you mean? Yeah, it stopped. We can't see your screen. Don't worry. Cool. So who should I summon back? Cash?
00:24:42.010 - 00:24:42.760, Speaker C: Yeah.
00:24:45.610 - 00:24:47.160, Speaker D: I'll be taking over.
00:24:47.930 - 00:24:53.180, Speaker C: Macha will explain how the API works and how we are abstracting away all these complexities for you.
00:24:53.630 - 00:25:01.020, Speaker A: Cool, thank you. Thiago Mashek. You can share your screen and I'll run 1 Second.
00:25:06.830 - 00:25:07.542, Speaker B: Okay.
00:25:07.696 - 00:25:09.520, Speaker D: Can you see my screen?
00:25:10.930 - 00:25:14.340, Speaker A: We can see your screen. It says retrieve a lost account.
00:25:15.830 - 00:25:58.846, Speaker D: Exactly. Okay, so we're coming to a practical use case, and this is just a simple demo made for you. So one of the use cases for storage proofs we thought about is account recovery. So imagine you have an account that you, for example, forgot. Like you lost it, basically, and it's not been used for over a year, and you want to recover it. That's kind of the idea of this account recovery system. And how could we do that? The easiest way is basically checking your nons a year back and checking your nons now.
00:25:58.846 - 00:26:53.378, Speaker D: And if the nons hasn't changed, it means that the account made no transactions, which is kind of how this recovery mechanism will work. So first, starting with the demo itself, let's say we take my address from girly and we want to generate a proof for that. So we've started the generation of a proof. I will show you how it works with her address in 1 second. And in the meantime, I'm going to speed this up because generating a proof that is a year back for now, is taking a little bit of time. But in the near future we will have new approaches with the recursive proofs and with starks and snarks connected that will help us make it way faster. But for now, I'm going to speed this up for you.
00:26:53.378 - 00:26:56.610, Speaker D: So basically we send.
00:26:56.680 - 00:27:06.230, Speaker A: If I can ask what's taking time here? I'm sorry to interrupt. If I can ask, what is taking time here? It's making the request to the node.
00:27:08.410 - 00:27:14.440, Speaker D: Basically this application made two. Okay, I'll start with this one, then.
00:27:15.930 - 00:27:18.230, Speaker A: Maybe break your flow.
00:27:18.730 - 00:27:52.110, Speaker D: No, that's not a problem. So it basically made two requests. So we got our sense nons, which is like a block number from the current block number that we got from our RPC provider and minus the one year block distance, so on. Yeah, we calculated, but on different chains it would be different then obviously. Yeah. So basically we took those two blocks and we need to create two requests to our herds API. So the request look as follows.
00:27:52.110 - 00:28:15.782, Speaker D: So basically we want to prove it from girly. We want to prove it on Starknet Testnet. And we provide the block number. So we have two requests. The since and until. And basically we get the block number since here and then until here. And apart from that we have a Webhook URL.
00:28:15.782 - 00:29:10.074, Speaker D: I'll get to that in a second. And we set the task type to account access, and you basically provide the address for which accounts you want to access the nons and you wait for a webhook. So in here, this is the demo code. So basically in here we have some webhook endpoint that's basically awaiting a webhook from Herodotus API and what is taking so long. So the whole API itself is quite complex and the stuff that Tiago talked about are happening in the background. And we have something called an orchestrator that's basically optimizing all the tasks for you. So in the future you'll be able to ask, for example, to have a task that's very fast or have a task that's very cheap, and the times will depend on which path you choose, let's say.
00:29:10.074 - 00:29:42.278, Speaker D: But the overall thing is we batch a lot of tasks together. So we batch a lot of requests together, the ones that make sense to batch them. And the most time consuming thing is probably right now it's split between three things. So first you have to get something called a trusted block. I won't get into too much details, but just to visualize that. So getting a trusted block is probably one transaction. Then we need to get approved if we don't already have it.
00:29:42.278 - 00:30:23.954, Speaker D: So if we don't have the proof, we have to generate the proof. If it's historical data a year past, then generating a proof is a bit more tricky and needs more work. And in some use cases at this moment and at this hour, beta version of the API might take even an hour. And then you need to basically verify that proof and give the data to the user. So this is why the whole process takes some time. But in the nearest, I guess like month or two, we are going to take that down to something like two to 5 minutes. And if there are more users using it, the time will go down even more.
00:30:23.954 - 00:31:15.242, Speaker D: So this is why I created this thing, to just speed everything up for us so that we don't have to wait for insane amounts of time to get everything done. So basically in this example we just have those two things and basically we got the request back from the API. And the only thing more that this is basically the code of the example. So the code works like this, that we have two requests that come back to us and then we need to finalize the proofs themselves. And how do we do that? I'll show you in a second. So yeah, we have the proof and now you can see that the since nons, that's a year back is eight and the until nons that's now is eight as well. So the proof is valid.
00:31:15.242 - 00:32:03.698, Speaker D: So we would be able to trigger the account recovery based on this information and how it works. Basically, the only place where you worry about anything from Herodotus is creating the first request. When you have the first request, you just wait for a webhook. Or alternatively, instead of waiting for a webhook, you can actually query our API for updates on your task. Basically every request you make to us is called a task, let's say. And what you get back from us is you get a task id and based on that you can basically ask us spam the API asking whether it's finished or not. But obviously an easier way is just receiving a webhook itself.
00:32:03.698 - 00:32:55.906, Speaker D: So our API will call you back when it's finished. So after the callback, what we're doing in this example is we got the info that the proof is ready, but the proof is not passed to you in the webhook. We might add that if that's something you will require in the future, but for now, you basically get the info that the proof is ready and you get the info how to get it. So in this case, how to get it info tells us that we have to get the fax registry address. This is provided to you in the callback itself, in the webhook itself. So you basically start with a start netjs provider and you have a contract that you have to call. And in this case, we are interested in an entry point called get verified account nons.
00:32:55.906 - 00:33:41.950, Speaker D: So we basically ask the contract for a verified account nons for an account in time dimension. So at a current or at any given block number. So when I did this magic button and sent this cron request, we basically checked both of the block numbers. So the since and until. So this one and this one, we checked them for a non that's on chain, proven on chain. And we got that the since one is eight and the until one is eight as well. So the whole thing is done apart from having this encode.
00:33:41.950 - 00:34:22.960, Speaker D: We also created an example Kyra contract where you can basically provide the fax registry nons. Get the nons from our fax registry. The fax registry is our contract that basically has all those proofs stored for you. And these contracts are basically asking the fax registry and based on that triggering the account recovery thing, I think that's it. This is the whole example. Casper, you want to take that over?
00:34:24.130 - 00:35:31.670, Speaker B: Sure, yeah. So I guess the way we can kind of summarize this is that this is one simple example that kind of demonstrates a use case for historical data. So in this case, this could be used for a dead man switch for, let's say, a wallet deployed on Starknet, where we could essentially prove that the nonce has not changed, which essentially also proves that there was inactivity. You were not making a transaction for a period of over a year. So what we could build on top of something like this is, for example, a wallet mechanism that when you register your wallet initially, or you have some sort of like conditionals that you set, you pick what time frame you're looking for to prove that, let's say, your wallet was inactive before something like this gets triggered, and then what occurs after. The cool thing about this is that there is no limitation as to how far back you can go to generate that proof. It can go all the way up to, I don't know, the first week after the Genesis block.
00:35:31.670 - 00:36:50.570, Speaker B: And yes, so some more complex things that you could build on top of storage proofs could be things like cross chain lending. You'd be able to build a protocol that enables you to deposit your collateral on one end, send a storage proof to a destination chain that that collateral actually exists there, it's locked there, it's not under your disposal, and based on that storage proof, you'd be able to take out a loan from a secondary market. This could be interesting for simply just capital efficiency reasons, as well as actually designing things like KYC specific vaults where you only deposited KYC money and lend out. And then after, based on that approach, you take out loans of non KYC money. I previously mentioned ENS, which is one use case that we are looking into right now and have been exploring for the past few months. Essentially what this would allow you to do is show that you own an ENS domain name on layer one and relay all those storage proofs to pretty much every single EVM compatible l two. And based on that, you actually wouldn't have to create like a new attestation network, et cetera.
00:36:50.570 - 00:37:41.280, Speaker B: It would be done fully on chain. There are obviously downsides. The refresh rate of how often you actually send that storage proof would be constrained by a budget of a company or a protocol that would like to be relaying these proofs. Yeah, I think also our flagship kind of use case right now is snapshot. So snapshot x allows you to vote on an l two, vote on Starknet based on assets that you hold on layer one. This is very powerful because it essentially eliminates the need for bridging. I personally see a future where bridging becomes less common because you're able to actually reap the utility of an asset without actually having to move it.
00:37:41.280 - 00:38:18.726, Speaker B: And snapshot is a perfect example of that. Like users want to be able to participate in Dow votes, Dow proposals, et cetera. But moving assets from layer one comes at a risk. There's bridge hacks all the time, and maybe essentially you don't have many coins that you want to vote with. And if, let's say you have $20 of coins, you might not be able to justify a $10 transaction fee to bridge to a layer two. So it unlocks a lot of new use cases. Of course, you could technically build a bridge on top of storage proof.
00:38:18.726 - 00:39:12.858, Speaker B: In fact, a while back we did something called merge swap, which was essentially a storage proof powered bridge between the proof of work Ethereum chain and the proof of stake Ethereum chain. It works in a pretty simple and intuitive manner. On the origin chain, you have a smart contract where you deposit funds, you then generate a storage proof that the deposit was actually made. Send a storage proof over to the destination chain. Based on that storage proof, you mint an equivalent amount of tokens and then if you want to bridge back, what you do is you burn those tokens, then submit a storage proof that those tokens have been actually burned. So for example, sent to the zero address, and then based on that proof of burn, you're able to unlock the funds from the origin chain. So it would be a more secure bridge in a sense that doesn't rely on any multi signature setup.
00:39:12.858 - 00:40:14.926, Speaker B: No external parties need to be involved. But I would also like to highlight some drawbacks that we are currently facing. It's important to know that even though no one has trust us, that was the whole point of our whole architecture design, there is still currently a liveness issue in the sense that these proofs actually have to be generated. We are working on some different solutions to tackle this problem short term. What we're trying to do is essentially get it working, get it released as a proof of concept, get some main net integrations, and later on we will be exploring different ways to decentralize this proof generation process. Decentralize? Well, eliminate us our liveness as being a risk for any protocols choosing to integrate. But we really want to inspire developers and kind of like showcase the possibilities of what you can vote with this and to kind of gather that audience.
00:40:14.926 - 00:40:33.640, Speaker B: We really feel that our attention on decentralizing the proof generation when it's very dynamic, it changes all the time. Mache can attest to how fast things change within our code bases. We feel that this is the best way to prioritize things as of right now.
00:40:35.370 - 00:41:02.366, Speaker A: Very cool. Thank you. There's this weird concept that I like to contemplate sometime, which is so, you know, the Voyager spacecraft, which was sent in the. Sent with a golden record in outer space. And I think it's the first object that ever got out of our solar system. Hopefully one day we'll make a fast spacecraft and we'll catch up to it. Right? And we'll fly by this religion and maybe we'll do something with it.
00:41:02.366 - 00:41:28.146, Speaker A: Right. I feel like storage proof are a bit of that because there's a lot of data that was emitted in blockchains back in the day, like events or bitcoin, Utxos with op return that were emitted without hope of being used in a smart contract. Right. It was just something that, oh, this happened, but you can't really use it in an actionable way in a blockchain. Storage proof actually enable you to make use of that. Right. And to retrieve stuff that.
00:41:28.146 - 00:41:31.290, Speaker A: To revive stuff that was not supposed to be alive.
00:41:31.950 - 00:42:10.054, Speaker B: Absolutely. I'm sure you've probably seen our primary branding. The satellite is kind of our image and the brand we're trying to build. The idea behind the satellite is essentially that we rebroadcast things so you don't actually have to. We see the blockchain world as a bunch of planets. Every single blockchain is running in its own isolated system. And even though everything can be right, going well on your planet, without this interplanetary communication and rebroadcasting of information, you live alone, and we're here.
00:42:10.054 - 00:42:22.298, Speaker B: You can connect all these different planets through satellites floating through outer space. And. Yeah, that's a very deep analogy, but that's basically where it came from.
00:42:22.464 - 00:42:26.460, Speaker A: That's really cool. All right, guys, anything to add?
00:42:27.630 - 00:42:54.530, Speaker B: I mean, we're going to be releasing a stable version, testing version of the API shortly. We would greatly appreciate it if we could get some starknet projects to test it, to essentially push it to the limits, give feedback, and essentially help us fine tune this API such that it actually fills the needs of the developers and the users.
00:42:55.510 - 00:43:03.302, Speaker A: How should people follow you or know how to test this? Where should they look at? What's your website? What's your Twitter handle? What's the best way to keep in touch?
00:43:03.356 - 00:43:29.098, Speaker B: Yes, so our website is Herodotus dev and our Twitter is also Herodotus dev. If it's complicated, actually if you go on storageproofs.com, it will redirect you there, because a lot of people have trouble spelling, and our discord link is there as well. We will be dropping API keys there shortly.
00:43:29.274 - 00:43:42.346, Speaker A: Super cool. Okay. All right. Thank you a lot for your time today. Marcia Kashper, tiago, and looking forward to seeing people building cool stuff with eroditus.
00:43:42.538 - 00:43:44.298, Speaker B: Great. Thank you for having us, Henry.
00:43:44.394 - 00:43:45.974, Speaker A: No, my pleasure. Cool.
00:43:46.012 - 00:43:46.470, Speaker C: Thank you.
00:43:46.540 - 00:43:47.110, Speaker D: Thanks.
00:43:47.260 - 00:43:55.010, Speaker A: Absolutely. All right. And to the people watching us, have a good day. Bye.
