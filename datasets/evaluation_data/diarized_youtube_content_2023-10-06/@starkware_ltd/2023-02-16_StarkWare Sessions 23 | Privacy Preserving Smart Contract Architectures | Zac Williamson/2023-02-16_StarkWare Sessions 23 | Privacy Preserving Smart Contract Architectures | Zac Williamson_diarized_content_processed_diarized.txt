00:00:03.290 - 00:01:12.130, Speaker A: My name is Zach and I am the CEO of Aztec. We are a company that specializes in using zero knowledge proofs to enable, to create infrastructure to enable privacy preserving end to end encrypted blockchain transactions. And I'd like to talk about privacy preserving programmable blockchain architectures. And so basically how to use zero knowledge proofs to enable genuine private smart contracts where private state is a first class primitive, and tackling it from a slightly different approach to Xama where we don't use fhe. And basically it's using state of the art ZK proofs. And yeah, so what I'd like to do for this talk is basically try and almost from first principles derive with you work through how to construct a blockchain architecture where you have these programmability of private smart contracts like Ethereum, but where you have this private status, first class primitives, where transactions can be end to and encrypted, and you don't have to trust third parties or like hardware security modules or anything. It's just pure math.
00:01:12.130 - 00:02:04.914, Speaker A: And ideally preserve kind of existing traditional smart contract programming semantics, because the goal here is for these networks to be programmed by developers, not cryptographers. So having a concept of contracts, being able to call other contracts, and not having to understand any of the, expose any of the abstractions, like any of the cryptography under the abstraction layers. So I mentioned, go from first principles. I do want to just highlight the enormous corpus of work that this is all building on top of the zerocoin paper, Zcash. They were the absolute pioneers of creating private blockchains. The Zexi paper described the first practical way of creating proofs of generalized computation. You've got Mina, who are in production today working with ZK apps, and there's like 40.
00:02:04.914 - 00:02:32.574, Speaker A: An enormous corpus of ZK research. This is all being built off top of. So Isaiah's first principles, perhaps not this first, this deep, but I want to ask this question, because there's a lot of fluff and abstractions that are layered on top of the concept of a blockchain. And for our purposes, we don't need any of this. At its very core, a blockchain is. It's a state machine. Forgive the silly graphic, I wrote that at two in the morning.
00:02:32.574 - 00:03:03.720, Speaker A: But essentially it's a state machine. You have some input state, you send a transaction, you have some mechanism, some protocol that verifies whether the transaction follows predefined rules and will update the state based on those rules. That's all it is. It's pretty simple at its very core. But we want private state. We want a private state machine. And what even is private state? Because it's a deeper question that's going, oh well, the state's encrypted because as I've showed, that isn't enough.
00:03:03.720 - 00:04:18.778, Speaker A: If you want genuine privacy, anonymity, where you want to protect users information, prevent people from being able to spy on people's transactions, then it's not enough just to encrypt the state because you need to start with that. That also creates complications because now your state on your blockchain has an owner, which I'll get into the complications that produces the way we store, represent state in blockchains, in L2s, we always merkel trees or Merkel pitcher trees, but it's basically just a database. But the problem is that if you modify an encrypted state variable, then you're leaking information, right? Because you're leaking the transaction graph. If I'm sending encrypted bitcoin to somebody and making lots of encrypted bitcoin payments, then observers will be able to see if that's representative as a single encrypted balance. They'll be able to see that some balance is changing. They won't know what that balance is, but they'll be able to piece together a transaction graph of who's interacting with who just based on observing what encrypted variables are changing in that database. And so how do you avoid that? Well, you have to make your database appendoni.
00:04:18.778 - 00:05:16.974, Speaker A: And by that I mean once you've added something to that database, you can't change it, you can't delete it. All you can do is just add extra things to your database so that way you don't leak information about by modifying existing variables. But that seems rather limiting, doesn't it? I mean, that's not our conception of how blockchain like ethereum works. Because we want to update state, you want to be able to change balances. So how do you do that? Well, the way it's done canonically and the way that maximizes the anonymity set is by using this concept of a nullifier, where a nullifier is speculatively, it's the encryption of an encrypted state variable where if you don't know the decryption key, you cannot link a nullifier to its associated state. But what you do is basically the nullifier represents the deletion of a variable of some object. And so you have a state tree, you have a nullifier tree.
00:05:16.974 - 00:06:05.082, Speaker A: And if a state variable in your tree has an associated nullifier, then that's basically it, that's representing that variable being deleted. And so to prove that some state exists in your chain, it's not enough just to prove that it exists in the state tree, you also need to prove the non existence of its associated nullifier. And that gives you genuine privacy anonymity, because this is how blockchains like zcash work. It's how the aztec network today works, where the act of transferring cryptocurrency from Alice to Bob, all it does is it adds additional encrypted values into the state tree. It adds additional nullifiers into nullifier sets. But if you do not possess the decryption keys, you have no information about what those are linked to. Therefore you get very strong anonymity out of it.
00:06:05.082 - 00:07:26.166, Speaker A: And so basically that kind of private state, it's intrinsically based around Utxos, unspent transaction objects, the kind of data structure that bitcoin uses because of this need for privacy, because account states just the act of changing encrypted account state leaks information. So just like just some toy examples, if you have some data, like an owner of that data, you'd encrypt that to make your Utxo in the state tree, and then you'd encrypt the Utxo to make the nullifier. So here's a question, is that sufficient? Isn't like, okay, so if we have this model of subtraction for how to handle private state in a private state machine, is that enough to recreate the universal applications that exist in blockchain today? The applications that people want to build? And the answer to that is an overwhelming and resounding hell no. Which is a bit of a problem, because if you have to represent all of your state as encrypted unspent transaction objects, that creates follow on problems. Particularly you get raised conditions because within a single block you can't have two different people modifying the same to Utxo twice because they're both trying to delete an object. And objects can only be deleted once, and so one of those transactions will become invalid. You also have problems with the fact that encrypted state has to be owned by somebody or owned by a collection of people if you want to use npcs.
00:07:26.166 - 00:09:04.410, Speaker A: But ultimately you cannot have a deterministic algorithm running on your blockchain that modifies data like this. Not at least without fhe, because the state update would require the description key to decrypt if you want to prove a proof of correctness of a state update, then you need to cross instruct a zero proof where you provide the plain text, prove it equals a ciphertext, apply some logical operations. And so what if the only person who can make that proof is the owner of the decryption key? And what if they don't want to make that proof because that transaction is going to liquidate a position that they have because they haven't made their collateral payments? How do you compute the total amount of value in a liquidity pool to do an automated market maker if everything's encrypted and owned by individuals or groups of users? And so it's not sufficient just to have private state. You also need for privacy preserving applications on a blockchain, you need private and public state. And the abstraction that I used to think about this is that in an ideal world, to give, you want privacy for the user, but you want transparency for the protocol. For example, if you're interacting with a market maker, or a decentralized exchange or some trading house or whatever it is, you want to make sure that the rules of the protocol are transparent and that people have maximum data around what's going on, so they can properly audit it and vet it. If you want to put, for example, you want to package up mortgages and put them on chain, well, ideally you do that in a way where that's transparent, so that you can't end up with things like 2008, but you want privacy for the user.
00:09:04.410 - 00:10:04.218, Speaker A: We need both of these state models in a programmable private smart contract universe. And that, again creates some knock on problems. So how do you make a public and a private state machine? Well, that's tricky, because if you want to think about private state transitions because everything's encrypted, then you need proofs of correctness generated by the user to prove the correctness of any state transition. But for public state transitions, where you have an account model based state, those transactions must be ordered and executed sequentially led by third party. This is what happens on Ethereum with, well, miners and eth one, or validators in eth two. It's what happens in sequences in L2s. And so you have these two different kind of transaction models that you have to marry up with one another if you want to create a kind of like a holistic whole protocol solution to creating privacy preserving blockchain applications.
00:10:04.218 - 00:11:35.926, Speaker A: So how do you do that? Well, to wind back a little bit, it can help to think about what smart contract abstractions can we achieve given the conditions and constraints from those previous slides, and you end up with quite like a natural separation boundary here, where, well, your contracts composed of public and private functions, where your private functions can update the utxo tree, they can update the nullifier set, they can do everything associated with encrypted state. They can read from historical public state, can't write to it, but they can read from old state, because the idea is that a user is generating a proof of correctness for private functions, so they will have some understanding of the chain state. It just won't necessarily be up to date. And they can also make unilateral calls of public functions. And by that I mean a private function can call a funky function, but it can't have any return parameters because they're not being executed at the same time. Basically, what's going to happen if you're processing a block of transactions? Effectively all of the private function calls are executed before the public function calls are executed. So you can't have return parameters that are calling back into a private function because it's too late at that point, because the users already submitted their proof and have sent it to a sequencer or a validator or a minor, and similarly public functions, they're going to be run by some third party operating on behalf of a network, like a minor validator sequencer, and they can update all of the state trees, but obviously it's public, so you get no privacy.
00:11:35.926 - 00:12:26.950, Speaker A: So you probably don't want to update the Utxo tree that requires providing secret keys. And so how do you think about private these pirate functions at a protocol layer? Because if you have one of these private functions in a smart contract, then, well, that needs to be converted into a ZK snark circuit because you want to make a xenon's proof of correctness. You could also use a stark, although as I perhaps this is the wrong crowd for this, but snark stands for succinct, non interactive argument of knowledge. So starks can also be considered a kind of snark. But I mean, I'm not platform agnostic. Snark stark doesn't matter as long as it's zero knowledge. So each function is basically a ziki snark verification key, and your contract is defined by this set of function verification keys.
00:12:26.950 - 00:13:11.930, Speaker A: And how this would work in practice. Something we've been working with is we want to try and do this in a somewhat platform analystic way. We have a programming language called Noir, which turns programs into ziki snark circuits. And so we're thinking, how do we turn this from a programming language to a smart contract programming language? How do we add those heuristics or semantics? And so one way of doing it is you define a uniform AbI for how your snark circuits, public inputs are going to be interpreted. So you could say this is just an example. So you could say the first ten public inputs, they're going to be the argument parameters to your function. Some of these other parameters, some of the other public inputs will be interpreted as the state route of the Utxo tree, the nullify set, et cetera.
00:13:11.930 - 00:14:16.522, Speaker A: Maybe an encrypted representation of the message center. But one of the important things here is that each snark circuit that represents a function does not perform state updates themselves, as in they don't take the root of the state tree, insert a leaf into the state tree, and then compute the new root and spit that out, because that requires, again, you get race conditions there. Because if I'm making a blockchain transaction on my phone, I don't know what the state route of the state Tree of Ethereum or anything is going to be at the point that transaction is mined. What instead you do is you emit state update requests. So the snark circuit will spit out on its public inputs, basically leaves to add into the Utxo tree, leaves to add into the nullifier set, things like that. That's how you can make a snark circuit to represent a private function. But then how do you turn that into a transaction? Because most smart contract transactions consist of multiple function calls.
00:14:16.522 - 00:15:00.618, Speaker A: You might call a token contract that to approve another contract with spending tokens on your behalf. You then call some decentralized exchange contract and perform a swap. That swap contract will then make a call to a matching engine and then make transfer calls to other token contracts. You have functions calling functions, calling functions, calling functions. So you can construct a proof which proves the correct execution of a function. How do you turn that into a proof of correct execution of a transaction? Basically, we need call semantics in this private ZK snark world, which is a rather new topic to really tackle. And this is how we're thinking of doing it.
00:15:00.618 - 00:15:57.470, Speaker A: So basically by using this, what we're calling the private kernel circuit. And so we're very much borrowing the mental here from the Zexi protocol, where effectively your kernel circuit makes heavy, heavy use of recursion to sequentially construct proofs of correct execution of your functions via a call stack. So the idea here is that iterative recursive computation. Hang on, where you're going to represent inside your kernel circuit, you're going to have these various abstractions represented as your public inputs. You're going to have a call stack representing your private function calls. You're going to have a call stack representing your public function calls. You're going to have a bunch of a list of things that are going to be added to your state tree, to your nullifier sets, and also what I call, we're calling Oracle state, which is basically state that's been that chain state that has to be supplied externally, things like what are the state routes that you're using, what's the message sender, what's the block cache, what's the timestamp, et cetera.
00:15:57.470 - 00:17:02.350, Speaker A: And each of these calls onto this, what is a call stack in the world of Azksnarc? Well, it's because snarks don't like snark. Stackers don't represent programs. They represent the verification of the execution of a program. And therefore an entry in your call stack doesn't just describe the function that you're calling, but it also contains a proof of correctness of that function call and the return parameters that are expected from that function call. And so this is a toy architecture for this kernel circuit. The reality is more complicated than this, but this is roughly how such a circuit's logic would proceed, where basically you have one conditional branch where if you're basically the call depth of the number of calls you made, if it's zero, you're starting from scratch, so you don't have any previous recursive proof to verify. Instead, you like you verify a signature from the message sender, but then what you'll do is you'll pop a function off the call off the function stack.
00:17:02.350 - 00:18:06.838, Speaker A: You'll grab the verification key from a state route, you'll verify the key exists, you'll verify the proof is correct. You'll extract from the proof public inputs that you will interpret according to this contract API. And so those public inputs from that proof may contain instructions to submit additional function calls, so they get pushed back onto the function call stack, and then you have some output parameters of the snark circuit. By outputs I mean they're public inputs, but you interpret them as outputs. That represents the new states of all of your call stacks. And you just run this private kernel circuit iteratively until your private call stack is empty, and that represents at that point you've constructed a proof that proves the correctness of the execution of a sequence of private function calls and at that point, you're now ready to take that proof and hand it off to a sequencer, to a miner, to a validator to complete the rest of that transaction via a public execution layer. So this could be a L2, it could be a layer one.
00:18:06.838 - 00:18:46.734, Speaker A: It could literally just be a team of accountants with pen and paper doing manual calculations. It's a pure abstraction at this point. But what this execution a has to do is, well, it has to execute the public, like it has to verify the proof of correctness of this private kernel circuit, verify that the private call stack is empty, therefore nothing additional to do there. And then it'll execute all the public function calls on the public function call stack, and then it will perform all the state updates. So all of the UTXA requests that are made, it'll do those. It'll add all the nullifies to nullify set. When it's adding nullifiers to a nullifier set, it also performs check nonmembership checks, which basically that therefore forces.
00:18:46.734 - 00:19:30.686, Speaker A: Basically, if your contract is trying to delete a variable, delete some state doing the membership check verifies, it's not already been deleted. And verily, that the user, when they've constructed their private kernel circuit, they've used the correct oracle state. So they've used the correct state routes, or at least they've used state routes that at one point in the chain's history were correct. And this can be done as an l one or an l two roll up. So at AsTec, we're doing this inside a roll up for scalability. But in theory, this whole contract abstraction and construction doesn't require it. And so, yeah, that's basically once you have all of that, then you've constructed an architecture where, yes, you do have private programmable smart contracts.
00:19:30.686 - 00:20:15.326, Speaker A: They have familiar semantics where you have contracts with state variables and functions. Users can call functions, functions can call functions, contracts can call other contracts, just like you have in Ethereum or Solana or other l ones like that. It requires a lot of recursive start composition, and it requires a lot of client side proof construction. So you need utterly bleeding edge cryptography to actually pull this off and be remotely fast enough. So something that at Aztec, we're going to be publishing a paper soon, which we're calling honk, which is an iteration on hyperplunk that makes all of this tech fast enough. And so, yes, this is achievable with today's tech technology, and that's what we're building at Aztec. So this is what we call Aztec three.
00:20:15.326 - 00:20:59.022, Speaker A: So putting, putting three into practice. This is just a small slice of the architecture. We'll be publishing the proper design documents very, very soon. So this is only scratching the surface of the complexity you need to get something like this working. But it is a practical reality to pull this off with today's technology. And I'm extremely excited by this. I feel like anybody in this industry should be excited by the idea of actually being able to marry privacy with transparency, being able to do things like link identities to cryptocurrency accounts, protect user state, being able to have governance mechanics where your votes are private or secret, just like they are in the real world.
00:20:59.022 - 00:21:50.030, Speaker A: And so, yeah, this is what we're doing, that's what we're building, and that's a little bit. This is a slice of how we're planning on achieving that. So thank you very much. Anything? Oh, yep, very good question. So there's two things we think about the tornado cash event in two, there are two kind of separate incidents. One of them is the OFAC sanctions, and one of them is the arrest of Alex Percev. For us, the sanctions that the US applied are.
00:21:50.030 - 00:22:32.116, Speaker A: It is something that to be concerned addressed by. I feel like the arrest of Alex Petzev was. It's a tragedy, to be honest. We will see what happens there. But I gather he's still being held without trial. So with regards to that side of things, well, we're not planning on studying foot in the Netherlands anytime soon. But with regards to sanctions, it's very important that to establish the fact that you can actually create compliant privacy networks, ones where you have some way of distinguishing good actors and bad actors, without sacrificing the core principles of protecting users data, of having a completely permissionless, transparent network.
00:22:32.116 - 00:23:43.712, Speaker A: How do you do that? Well, we do have some plans and we feel like adding programmability at the protocol layer massively helps because app developers can program their own privacy solutions. But effectively there are things. So there is actually a specification that I've been writing up that I've been consulting with a few folks with. But what we're quite keen on to take a question directly, how do you create a compliant privacy network? Well, right now there is no formal definition of what a compliant privacy network is. So the best that you can do is create one where you establish moral legitimacy and then use that as a basis to effectively, to take a stand and try and try and argue and convince regulators and legislators that this is like an extremely positive development for not just like the Ethereum community, but for the entire world. The amount of economic innovation activity you can open up when you match new supremacy with decentralization is quite profound. And so the way that we're trying to establish that moral legitimacy is by providing solutions where you can distinguish good and act bad actors in a decentralized way.
00:23:43.712 - 00:24:44.260, Speaker A: For example, one thing you can do is you can have lists of deposits that are going into a privacy network that are considered somewhat like tainted or suspicious. They've interacted with hacks or with North Koreans. And the maintainers of this list can be from a decentralized group. So, like, anyone can maintain a list, it could be a foundation, it could be a centralized exchange. And the idea is that using our technology, you should be able to prove in the ZK snark proof. Or when you're withdrawing funds from a network like asset three, you should be able to prove that your tokens didn't touch any of the deposits in a tainted list, and therefore have a non interactive proof that basically saying, my funds haven't touched this list, I'm following the rules. And as long as those lists can be maintained by anybody, then the hope is that you would then develop social, like community, would develop social consensus around which of these lists are trusted.
00:24:44.260 - 00:25:17.930, Speaker A: They could be regularly audited, so that any provider that's a bit too zealous with adding deposits to the list that are actually legitimate or too lax and letting things slip through the gaps, that would all be very transparently viewable. And ideally, the hope would be that the community would settle on its own standards how to resolve this problem. But yeah, it's tricky. I feel like the best we can do right now is just provide solutions that have moral legitimacy and then go from there.
