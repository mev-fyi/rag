00:00:07.910 - 00:00:56.390, Speaker A: Hey, everybody, I think we should be all set up. Let me just double check. Okay, looks like Matt has confirmed it's my first time streaming, so let me just make sure everything's. If you have a couple more people watching, can you post in the chat and just make sure that you can hear me and see me? Okay, looks like we should be all set up. Hey, everybody, my name is Ben Goebel and I am a dev advocate at Starquare. Thanks for joining me. Today we're going to be talking about account abstraction.
00:00:56.390 - 00:01:35.928, Speaker A: Yeah, let's get into it. We're going to be live coding towards the end of the session. So everything that we do today, you should be able to follow along with me, code along with me. I'll try to monitor the chat. So if you have any questions, ping them out there, and if not, feel free to ping me afterwards offline. So first we're going to go over what account abstraction is, why it's important, and why we've decided to go that route on Starknet. And then after that we will get into the code.
00:01:35.928 - 00:02:13.350, Speaker A: I'm sure you guys want to get into the code. Cool. So Starknet account know, at its very basic level, account abstraction on Starknet is just that accounts are simply smart contracts. So the beauty of that is that smart contracts is that accounts on Starknet can implement any arbitrary logic that the developers want to implement. There are a few caveats to that. One is that there needs to be a canonical entry point denoted with the execute function that you see here. And we'll see today.
00:02:13.350 - 00:03:14.040, Speaker A: And so the way that works is two underscores in front, two underscores in back execute. This will change slightly in the upcoming platform release of V tutorial will have a pr that reflects that. But for right now, if you want to think about accounts on Starknet, the simple framework is that they have an execute entry point and they implement any logic that the developer wants to implement. So this is what that looks like in Cairo code. And again, we'll go over some more in depth examples and what this feature of account abstraction actually enables. But really, if you look at it, line eleven, the canonical entry point of execute, allows this to be a account abstraction. What is account abstraction? At a high level, it's that we want to execute some logic on chain from a known entity.
00:03:14.040 - 00:03:58.310, Speaker A: So that involves signing ECDSA signatures, which we'll get into today. But the way that looks like in Cairo is that we end up passing to another contract on line twelve and call the selector from that contract with a certain amount of call data that that contract expects. So really kind of the hello world of account abstraction looks a little bit like this. Now, there's a couple more pieces of the tooling that need to be aware of accounts. One of them is the compiler. So when we compile our hello Cairo account here, we need to have an account contract flag so that the compiler is aware that this is in fact an account contract. Cool.
00:03:58.310 - 00:05:03.844, Speaker A: Just double check the chat to make sure that you guys can hear me. Sweet. Okay, so why do we want it? Well, one of the benefits of being a second mover with a blockchain is that especially a smart contract blockchain is that we can kind of see what worked well at other layers, see what devs wanted at other layers, and it's become pretty clear from the dev community on Ethereum that account abstraction is an important thing to have. So if you're interested in kind of looking at the history of account abstraction on Ethereum, go check out EIP 29 38, EIP 43 37. There's kind of a long history of devs kind of clamoring for account abstraction. This is a quote from Vitalik, actually. So the fact that Ethereum protocol itself requires everything to be packaged in a transaction originating from an ECDSA secured externally owned account EOA makes account extraction very difficult.
00:05:03.844 - 00:05:42.400, Speaker A: So one of the benefits of kind of jumping on board the starknet Cairo ecosystem is that you get account extraction from day one, as opposed to an EOA, and just an account controlled by a public private key pair. So what does this give us? Gives us better wallet ux. We can use alternative signature algorithms. One of the things that actually brought me into the ecosystem was wanting the ability to implement some sort of wallet two FA with a secure enclave on your phone. This kind of opens that path. Upgradability. So smart contract wallets can be upgradable.
00:05:42.400 - 00:06:14.824, Speaker A: Social recovery key management makes the UX for all these things up to the developer's implementation of them. Session keys for gaming. This is a huge one. Gaming has kind of been a burgeoning ecosystem on Starknet, and we even have a hackathon participant that went into session keys for gaming, which we'll check out today. Multisigs and paymasters. So payment abstraction and Paymasters. This is the ability for a third party contract to actually handle the top level payments for a transaction.
00:06:14.824 - 00:07:00.600, Speaker A: I'm sure you can imagine all sorts of use cases for that. The ergonomics of this will get a little bit better as the platform evolves. We have various different paymaster mechanisms that aren't in the protocol yet, such as the validate entry point, which will I believe come in v 00:100 so keep an eye out for that. And then you can imagine a wallet that abstracts the fee token. So the base level fee will be paid in the starknet token. But if that's not especially, you can think of in some DFI protocols that might not be the most easy way to handle it for the users. So you can abstract the fee token payments and then flexibility for the devs standardization.
00:07:00.600 - 00:08:04.560, Speaker A: So with all this leniency and flexibility of account abstraction, you do actually need to standardize around some implementation of an account contract that everyone in the community and in the ecosystem can agree on. So one of the great things we have is openzeppelin wrote a bunch of good Cairo contracts at this path if you want to check it out on GitHub, but it gives us the best of both worlds. You can have these really unique wallet implementations while still having some sort of standardization that lets the community be composable, understand the call data layout, and understand the base signature implementation. So since you can implement really any signature that you want, any signature scheme, we need to know what signature we're using. And yeah, with that the goal is really to empower you. You know, we don't want to put any bottlenecks. One of the great things about Starknet and Starkware in general is kind of the optionality.
00:08:04.560 - 00:08:58.284, Speaker A: If you have some use case in your head, you can deal with it with, you know, all these DA solutions. And now you look at Starknet itself and you have the ability to implement account abstraction from top down. The entire stack is really built to empower you guys. And we're super interested in what you guys come up with, how to implement aa. So now we'll look at some of the actual implementation details and we are going to look at real code, so don't worry about that for now. The gaming session keys example that I mentioned earlier. So some community members brick and realms, we had an Amsterdam hackathon and they thought up this ux of basically on chain gaming, where if you had to sign every single transaction, you're ending up in one gaming session.
00:08:58.284 - 00:09:53.452, Speaker A: Signing, let's say, 20,000 transactions, which is just almost unusable, doesn't make any sense. So with account abstraction, they came up with a POC implementation of ephemeral session keys. And the way they did it was they created a one time key stored in the browser. And so every time they planted a crop, that's a transaction, that's a state change since they're planting the crop. So instead of signing that individual transaction, the one time key stored in the browser is a session key valid for some certain amount of time that's been authorized, and then that's valid for every transaction that propagates through that session. So you don't have to go in and open metamask for every single transaction as you plant every single plant. Some things that they mentioned that they wanted to add to that are spend limits.
00:09:53.452 - 00:10:32.272, Speaker A: So you can have a spend limit for your session key function call restrictions. So there are certain functions that you can't call that need to be whitelisted within your session key and more. The options are really unlimited. It's really, how creative can devs get? All right, so let's look at some code. I'm just going to check in one more time. Can everyone see my screen? I think there's a bit of a lag, so I'll keep going. Okay.
00:10:32.272 - 00:10:59.224, Speaker A: Like I said, you should be able to follow along with me. So if you want to open up a terminal and code alongside me, you should be able to do everything I'm doing. And hopefully. Okay, nice. Sweet. Okay, thanks, guys. Yeah.
00:10:59.224 - 00:11:29.580, Speaker A: So you should be able to code alongside me. Here is the repo. The repo is starknet.edu and Starknet accounts. So starknet.edu has a whole host of different tutorials that you guys might have already done. But from messaging bridge to debug to ERC 721 Cairo 101 erc twenty s, you might have seen that this is the start of a bi weekly workshop cadence.
00:11:29.580 - 00:12:00.620, Speaker A: So if you guys are interested in getting hands on into the nitty gritty of developing on Starknet, we'll go through these tutorials over the upcoming weeks. Yeah, but today we're going to be looking at starknet accounts. So here's the repo. There's a readme here if you're interested in kind of a little bit more of a breakdown. A lot of it is what we just covered in the slides. So right now, we will skip it. So clone the repo.
00:12:00.620 - 00:12:43.146, Speaker A: We will clone it in here, CD into that repo. So setting up the environment. We have a couple of different tools that we're going to use in this tutorial. So this is an account abstraction tutorial, but it also kind of masquerades around a lot of community devtooling. So we have Starknet Devnet, which is written by Shard Labs. If you're thinking about your dev cadence, this is one that I use. I think a lot of people use in the community is that you really want to test your code.
00:12:43.146 - 00:13:15.350, Speaker A: You don't want to be deploying buggy code, especially since the transactions can take a while to propagate on Gurley and especially main net. So this is the dev cadence I use and the dev cadence I recommend, which is unit tests first. Devnet testnet mainnet. So we're going to start with Devnet. There's a link here if you want to go look at how to set Devnet up. It's in our requirements as well, so don't worry about that. The Cairo environment, the Cairo environment is in our main docs.
00:13:15.350 - 00:14:06.370, Speaker A: If you're brand new to Cairo, check it out. There's a couple of dependencies to install and then lang itself and then Starknet PI. Starknet Py is written by software mansion and it's a Python SDK for Starknet. There's a lot of really good sdks and libraries for Starknet, so if you are familiar with Python, I know a lot of developers are, that's the one we use in this tutorial. But if you're familiar with other languages, I recommend checking out awesome Starknet and that has a whole host of different libraries. Let's say you're a JavaScript dev. There's Starknet Js, Starknet RS, Golang Dev, there's Kygo.
00:14:06.370 - 00:14:44.814, Speaker A: Check this out. There's a bunch of good resources here, so we'll install our requirements sorry, one sec. So we're going to init our Cairo environment. So back to the setting up the environment. I have just a bash alias here to do this, but it is basically a wrapper around this with a couple more environment variables set. So Cairo dev to init the virtual environment and activate it and then we will install our requirements. One thing to look out for.
00:14:44.814 - 00:15:48.642, Speaker A: So as the platform upgrades from v zero nine one to v next few weeks, like I mentioned, there will be a few account contract breaking changes, so we'll update this repo to reflect that. So keep an eye out for that. And then there's been a few changes to Starknet PI, so the version here is frozen in the requirements txt, but those will also be updated. Okay, so like we said about dev cadence, we're going to start with unit tests Devnet. There are unit tests in this repo, but it's kind of built to have some things omitted for you guys, so some of them are hard too. There's a lot of code to write in this tutorial and if you get lost along the way there's a feature branch of this repo called hints all. And in hints all, you'll see that all of the tutorials and all of the examples work.
00:15:48.642 - 00:16:52.850, Speaker A: So if you do want to go through and test the code, as I said, with the unit tests, there are unit tests in here that you can test, and they should all be working on this branch. But in the main branch it's kind of a bit of a labyrinth for you guys to figure out. Some things might not make sense, some things might be broken, but basically you'll need to code your way through it and look at hints all for reference implementations. If you do want to see what that looks like to test, feel free to use Pytest. So in hints we have the hello contract, which is just what we looked at in the slides. It's just a simple hello contract with an execute function so we can run Pytest hello Py, and that will run our unit test for hello Py eventually. So let's look at the code while that's running.
00:16:52.850 - 00:17:38.320, Speaker A: Okay. Hopefully the font size is okay. There just a breakdown of how this tutorial is laid out. So on the main branch, these hints will be mostly broken for you to implement the correct answers. Contracts. So contracts has the contracts and the Starknet PI SDK helper scripts. And I'll show you what that looks like in hello contracts.
00:17:38.320 - 00:18:04.168, Speaker A: Let's see if our unit test passed. Yes. Okay, so the unit test passed. Let's look at what we just ran. This is using the starknet testing framework. So Pytest and the starknet testing framework, we imported it. We deployed this hello contract that lives at contracts hello.
00:18:04.168 - 00:18:59.784, Speaker A: And those are the contracts that we'll be looking at. Contracts and the exercise name. So signature, multisig, multicall hello and abstraction will come with a Cairo file and a Python helper script. So this deployed via the testing framework, the hello Cairo contract, and made sure that the execute function worked okay. So when you're looking through these tutorial series and when you're looking through Starknet.edu, most of the tutorials are broken down in a similar fashion. We have an on chain evaluator that expects certain contract deployments to be made and expects certain contract interfaces to be maintained, and then expects certain selectors to be called with correct call data.
00:18:59.784 - 00:19:39.790, Speaker A: So this is where the labyrinth of kind of you guys as the devs see this main branch, and you need to go do some mission to make sure that you get something. And what is that something? It's an absolutely useless ERC 20 token. Cool. So it's an absolutely useless ERC 20 token. If you want to see the implementation of that, it's here in token contract. You don't need to worry much about it. It's really mostly just an ERC 20, the same way that open Zeppelin has implemented the ERC 20.
00:19:39.790 - 00:20:24.750, Speaker A: And then we're going to kind of reverse engineer what the tutorial is looking for. And I recommend going about it this way for most of the Starknet.edu tutorials. So we have an evaluator Cairo here and there's a lot of code here, but you don't need to parse through everything. But this is the smart contract that will expect to be called in a certain way to pay you in useless ERC 20 rewards. So for our purposes we're just going to look at the external functions down here at the bottom. The first one is validate hello.
00:20:24.750 - 00:21:26.972, Speaker A: So validate hello is going to validate that the deployer and caller of the hello world account Abstraction contract called it with this input and this address, it's going to make sure the caller is not zero. It's going to get the transaction information and the account contract address. So if the compiler didn't know that we had compiled an account contract, and if the starknet OS was not notified that this was an account contract address, this line would fail. So the two pieces of the toolchain that need to be aware of this being account contract are starknet OS and the compiler. We're going to make sure just for teaching purposes that the signature is zero. We'll go over ECDSA signature implementations, but for now the signature must be zero. It's going to read from random.
00:21:26.972 - 00:22:11.000, Speaker A: Random is a storage variable assigned to this evaluator contract. So the hello world account abstraction contract will need to get this value in order to satisfy this requirement. We emit an event here. So if everything has been satisfied for this validate hello, we'll say hey cool, payday. You get paid in worthless eRc twenty s and we're going to reward you with 100 of them. So that is what you'll also see in this hints py. We deployed the evaluator mock contract.
00:22:11.000 - 00:22:56.876, Speaker A: So just for unit testing there's certain things that we needed to mock out. You can diff this against the evaluator Cairo if you're really interested. Don't worry about it too much for now. And then we tested the validate hello selector with the random value from the evaluator contract. Let me double check the comments to see if there's any questions? Stretch his hands. Cool. If you do have any questions, feel free to put them out in the YouTube and I'll try to ping them.
00:22:56.876 - 00:23:50.030, Speaker A: I might be a little laggy to getting to them, but ping them out there if you have any questions. Okay, so we've gone through unit tests in our cadence, so that puts us to Devnet. So Devnet, like I mentioned, it's written by software mansion and it's a really good place to test your smart contract business logic before deploying to mainnet or Testnet. So here's how do you start Devnet? We're going to start it on port 5000 and we're going to start it with a seed of zero. I'll show you why we do that. And again, we need to be in our virtual python virtual environment. So I'll init that with Cairo dev.
00:23:50.030 - 00:24:58.500, Speaker A: Okay, so why do we init the devnet with a seed of zero? Devnet comes with these pre deployed accounts, and these pre deployed accounts are funded with a certain amount of way. When you execute a transaction on Starknet that requires some sort of state change, the account contract will be paying a fee. We talked about the abstraction of fee payment which will be implemented down the line. For now, the easy way to think about it is the contract with the execute entry point will need to be the fee payer. So that means that it will need to have gas to pay the fee. What is the fee? The fee is a little bit of a rabbit hole, but for all intents and purposes you can think of the fee as that you're paying for the l one footprint of the transaction. If you are curious about kind of going down the rabbit hole with fee payments, we have some good docs here at Docs Starknet Ao and head into fees.
00:24:58.500 - 00:25:49.076, Speaker A: It'll go over the actual breakdown of, okay, how many steps, what parts of the Cairo code cost, what, how much does signature verification cost? This might be too small to see. How much does signature verification cost? Peterson hashing, how much does that cost? And then how much does storage cost from l two to l one? Super interesting stuff. I mean, it's some of the internals and the bones of Starknet and Cairo. I highly recommend looking at that a little bit out of the scope of this tutorial. Cool. So we have the Devnet init. We have these pre deployed accounts that we know the address, the public key and the private key.
00:25:49.076 - 00:26:31.152, Speaker A: And we know that they're funded with gas for transactions to go back to the repo. So this hints Json, since we've started the Devnet with a zero seed. We know that this account will exist. So when we go through some of our tests, we know that this account exists and we know that it has gas. Okay, so let's go back to the readme. We've been working with this hello contract. You saw the hello contract in the slides and we will look at it in the code base.
00:26:31.152 - 00:27:28.828, Speaker A: It's the same thing. So we'll declare the language as Starknet. That means that we're going to be using a subset of Cairo specifically for Starknet smart contracts. And we will call the execute external entry point, pass along the call data to a contract at this selector, and we will call the contract pretty simple. So we'll check out the Python script. Now, the Python scripts are just kind of helpers wrapper functions to make some of the calls for you. If you think about what each of these contracts will need to do, they'll need to have an interface to the chain, they'll need to deploy whatever exercise we're currently working on, and they'll need to fund the contract that's deployed.
00:27:28.828 - 00:28:42.376, Speaker A: So we know that the pre deployed account has gas, but when we execute this after deploying it, this account abstraction contract will need to have gas to pay for this transaction. So what we do is from the account we know has gas, we fund the hello contract that we just deployed with gas evaluator. So in order to check that our functions work on Devnet, we need to be checking them against the evaluator contract. And then this is the starknet Python version of calling a selector on a function. So we know that we have the contract here, we know that the execute function lives on that hello smart contract. And we call it with this call data random and reward account. What is random on line 42? This is how we call a view function of a smart contract on starknet.
00:28:42.376 - 00:29:26.090, Speaker A: So some of the low level functionality of starknet smart contracts are a little bit out of the scope of this tutorial. If you're interested in what is a view function, what is an external function? We have some good tutorials for that. Check out Starknet Cairo 101. For now, I'll just assume we know what a view function and an external function is. This is Starknet PI's version of calling a view function. So again, we can kind of flip back and forth between what is the evaluator looking for and how do we provide that to the evaluator. So let's check out the evaluator one more time.
00:29:26.090 - 00:30:16.090, Speaker A: Okay, get random. So get random should exist in here and it does. It's a view function that just gets the random storage variable from the evaluator. Cool. So fairly straightforward. If you look at the rest of the examples, these lines 23 to 36 are relatively static. So every time we want to deploy an account abstraction implementation, and we do that with the interface of a client, and then we fund that account abstraction implementation so that we can execute transactions on it.
00:30:16.090 - 00:30:56.732, Speaker A: So we'll head over the terminal. We have our devnet running here, we need to be in contracts. If you are following the readme, it'll just be here. So CD contracts, the devnet starts with an empty state, so we have the evaluator Py and we know we need to deploy that, so we have something to test against. So Python three evaluator Py is how I deployed the evaluator on Testnet as well. But we'll need to do the same on Devnet. So don't worry about this too much.
00:30:56.732 - 00:32:07.328, Speaker A: Just know that every time you restart Starknet Devnet with a new state, you do need to have an evaluator to check against. So we'll deploy this evaluator on Devnet. If you're tailing the logs up here on Starknet Devnet, you'll see all of these interactions that the Python SDK is propagating against the Devnet, and then what are those transactions? And again, you don't need to look too far into the evaluator py. But if you are curious, it's going to deploy the players registry. So we know which players have done the tutorial. It's going to deploy the ERC 20 token so that we have a token that we can reward participants that did the exercises correctly, and then that evaluator that we've been touching on to the devnet, and then a couple administration functions here for setting the teacher and setting the admin. Cool.
00:32:07.328 - 00:32:47.950, Speaker A: So the registry is deployed here, the ERC 20 token is deployed here. We should see the evaluator coming through here soon. So you don't need to copy and paste a bunch of contract addresses. They will be saved here in this cache. So this is the URL for the devnet, and you'll see that the ERC 20 token is deployed at this contract address. Player address is deployed there. Once you do start executing these transactions on Testnet, these are the static contract addresses, just so you have them.
00:32:47.950 - 00:33:28.930, Speaker A: Okay, so everything got deployed, evaluator, ERC 20 and player registry. Just going to double check the stream comments. Cool. Okay, so we have the evaluator ERC 20 and player registry deployed. And we want to see if our hello world account abstraction contract is correct and gets us money. Again, this is all in the readme. So next step in the readme Python hello PI.
00:33:28.930 - 00:34:20.034, Speaker A: Each of the Python scripts has some information for you. So we're going to be doing, since you can basically do any implementation you want with account abstraction, we're just showing you a subset. So this is kind of explaining what are we doing with each exercise. The first one is to deploy an account contract with this execute entry point, fetch the random storage variable from the validator contract, and then pass that random data point in the call data to your account contract. We're going to cache this hello contract as well. Yeah, and it looks like everything succeeded. Since this is just a hello world, everything's set up for you.
00:34:20.034 - 00:34:59.582, Speaker A: This is just to get you oriented with the tutorial and get your bearings. So we got the random variable and we passed it on to the evaluator. Cool. Reward account reward account for Devnet is going to be this Devnet account. The reward account for your testnet account is going to be whatever you populate here. So you can go into your argent wallet and populate your address, your public key and your private key. I hope we have enough time to go over that.
00:34:59.582 - 00:35:34.012, Speaker A: We might run out of time. It's also in the readme, so I'll show you. We have a payday. How do we ensure that we got paid on Devnet? I personally like to use Postman. I believe that there is a Voyager implementation locally that at least is in the works. But if you are familiar with postman or would like to use Postman, we have a workspace set up for you guys. So starknet.edu
00:35:34.012 - 00:36:21.648, Speaker A: search for that in the workspaces search bar. And it has almost every feeder gateway, endpoint, gateway, endpoint and some more functions down here. So we have an environment for Devnet that's going to point to localhost 5000. And how do we make sure that we did indeed receive our payday accounts? JSON has our ERC 20 address, so we'll put that in the contract address entry point selector. There's a couple of different ways to get the selector. You can do it in a repl in your terminal. The way I prefer to do it is this tool.
00:36:21.648 - 00:36:50.090, Speaker A: It's called util Turbofish Co. We might host this somewhere else in the near future. If you enter in an integer here or any encoding here, it'll give you all of the representations of that, including the selector. So on that ERC 20 address. ERC 20 contract. We want to know the balance of. So this is the selector for that.
00:36:50.090 - 00:37:17.200, Speaker A: And whose balance do we want to know? We want to know our Devnet accounts balance. And again, make sure you're pointing to the Devnet. Sweet. We got paid. How much do we get paid? We got paid. 100 useless tokens. Score.
00:37:17.200 - 00:38:00.840, Speaker A: No questions. Okay, cool. So let's get into some more interesting stuff that's kind of orienting you with Devnet, Starknet, Python and this and the tutorial structure itself. So let's look at some more interesting account abstraction. Before that, let's actually talk about signatures. So eoas, you guys might be familiar with eoas. It's a public private key pair that manages, that is for all intensive purposes, an account.
00:38:00.840 - 00:39:06.154, Speaker A: So since we've said that accounts on Starknet are just smart contracts, how do we manage signing? So there's a signature field that each block has that's separate from the call data and the rest of the transaction information. So there's a signature field here that you'll see it in the block explorers. You'll see it if you use the sdks or the CLI. We need to provide that signature to the chain now we can handle it a couple of different ways. The way that most account abstraction contracts have been standardized on chain is that the account itself has a storage variable for a public key. The transaction is then signed by a private key that's held in some private key management. For Argentx, it's in an encrypted blob in the browser, I believe.
00:39:06.154 - 00:39:51.706, Speaker A: I hope I'm not getting that wrong. That's used to sign the transactions in your chrome extension and then sent on chain where the public key is used to verify that that signature is correct. But this is just an implementation detail. So we'll look at signature two. So signature two has a public key storage variable and then a view function for is valid signature. So this is where we need to check that that signature is valid. And then when we call the constructor, which is a call once function to set up the contract, we init it with a public key.
00:39:51.706 - 00:40:33.320, Speaker A: So the flow for ECDSA signing in this sense is generate a public private key pair and then deploy an account abstraction contract on chain with a public key. Cool. So is valid signature. You'll notice that there's no implementation here of checking for a valid signature. So this could be with the stark friendly curve, which it most often is. It could be with the Ethereum curve, which you're starting to see, implementations from open zeppelin come out with Ethereum curve signing and validation. It could be anything.
00:40:33.320 - 00:41:46.980, Speaker A: But if we look at our evaluator contract, we will see what we expect. Okay, so the validate signature two is getting the tx info. So when we provide the signature to the chain, the block is included with that signature info in Tx info. So TX info has that signature. So we check that that signature has at least two, two points. I don't know if you guys are familiar with ECDSA signing schemes, but it's the r and the s and that the caller has an account contract address, so it needs to be an account and that the transaction hash for this transaction does indeed sign and has a valid signature. So again, reverse engineering this evaluator contract, we see that.
00:41:46.980 - 00:42:27.114, Speaker A: How is it checking it? It's reading from a public key in the contract storage, and it's checking with verify ECDSA signature. So verify ECDSA signature is going to go with the stark friendly curve. It's kind of the default curve that we use for signing. So we know that we will most likely need to verify that as well. And we already have it there, and for sake of time, we're kind of run out of time. I might actually just swap to the hints branch so that we can look at this. It is reference code.
00:42:27.114 - 00:43:12.970, Speaker A: So if you do want to swap to the hints branch to know you're doing everything correctly but still read this information, that's probably a decent way to go about it. One more time. Check. Could you paste the utils URL? Yes. Here's the utils ui, and then I'll also post the postman collection if you guys are interested in that. Cool. And again, feel free to reach out to me if you have any other questions once we're done with this stream.
00:43:12.970 - 00:44:43.240, Speaker A: Okay, so we're going to switch to the hints all branch. We'll see that, yes, in order to validate the signature, we'll use verify ECDSA signature, and we're verifying the hash, the public key cigar sig s one thing to take note of, right? So with account abstraction, we don't want to make any assumptions. We don't want to make any assumptions that the account sent through the call data in the specific order that we think it sent it through. An account abstraction can really do anything. So in this example, we embed the signature into the call data, just as an example that even if you did want to have a signature verification scheme that wasn't involved with the actual passing of the signature in the signature field, you can do it in call data too. So that's kind of the trick or the gimmick with this exercise is that we pass the signature in the call data instead of the signature field and then we parse it out here. Cool.
00:44:43.240 - 00:45:28.584, Speaker A: That account needs to adhere to this interface, this contract interface. So let's go through and deploy these and see if we're getting paid. Okay? Yeah, I should probably mention that. So as we're going through the mission criteria, this will kind of get you started with what this is expecting of you. So find the first two EIP numbers discussing account abstraction. You actually have already seen them in the slides today. Deploy an account contract with an execute entry point.
00:45:28.584 - 00:46:14.330, Speaker A: Use the private key to sign the values using the start curve, and invoke the validator. Check with the signature in the tx info field. So on the main branch this looks like this, zero and zero, with the expectation that the user goes and finds those implementations or those eips. We get the client and deploy the account, fund the account, and here is the signature. So here's some interesting things. Peterson Hash this is a stark friendly hashing algorithm that we use. We hash the first input and the second input, and then we hash both of those inputs with the contract address.
00:46:14.330 - 00:47:09.992, Speaker A: And then we sign that final hash with our private key. Another thing about account abstraction is you don't need to sign the transaction information. So there is a uniform transaction information, metadata that's assigned to the transaction info. So when we call get transaction info, there's a transaction hash that is assigned to that. That's one that the Starknet OS uses. Let's actually look at it in here. So TX info transaction hash this is used by the Starknet OS to make sure that we don't have duplicate transactions, to make sure that the OS is aware of each transaction hash.
00:47:09.992 - 00:48:29.950, Speaker A: So that is typically the transaction hash that your wallet signs, that your private key signs. When you look at Argent's implementation of account abstraction and open Zeppelin's implementation of account abstraction, they're signing the same transaction information that's propagated in the block itself. If you want to see how that works on our side, we have just a function here called invoke TX hash. So these are some of the things that the OS needs to know about the transaction, the prefix, which is, it's an invoke transaction, the version of transaction. So as the OS and system updates, you're going to need to know which version of transaction that we're signing. The contract address, the specific entry point selector that we're calling the call data that it was called with the max fee that we're calling with and the chain id of which we're on. So we need to make sure that we encompass all this information in a hash that the owner of the private key then signs basically saying yes, I sign off on all of this.
00:48:29.950 - 00:49:24.190, Speaker A: Now that's a bit complicated and it's a bit under the hood. So we've wrapped it in this invoke transaction hash, and as we call it in our Python helper scripts, we just say as long as you format the hash correctly, just sign invoke TX hash and that wraps the call data. Let me double check. Cool. Okay, so signature one, we provided these two EIP numbers, 2938 and 4337. We hashed both of them. We hashed them with the contract address and we signed it with our private key.
00:49:24.190 - 00:50:07.960, Speaker A: Just a quick recap. We know that that's our private key because we started the devnet with a deterministic seed. And then we call the execute function and the validate signature one. So we'll check validate signature one. What is it expecting? It's expecting an input and an address. Oh, sorry. Okay, we're calling execute on our function and then this is going to show you that, hey, the account abstraction can actually pass any number of arguments it wants.
00:50:07.960 - 00:51:23.860, Speaker A: It doesn't need to pass anything at all to its call contract. That's why one of the important things from the user side and the user perspective is you need to understand which version of account abstraction you're using. So even though we pass three call data, three call data felts into this account contract, we actually only call this contract with two, which is the hash that we hash here and the third piece of call data. So we end up calling the final function with the hash of these two values and the reward account, which is exactly what the function is. Looking for input and address. One more time, we'll just check in postman that we have gotten more money. We like more money, so we'll call that contract again and we should see more money.
00:51:23.860 - 00:52:16.090, Speaker A: All right. Last time we had 100, this time we got 100 more. Sweet. We're running low on time a bit, so I'll kind of go high level with the rest of the tutorial. Signature one is showing that the call data that's propagated through the system does not have to be the call data that you call the account abstraction with. And it's also showing that the signature can be signing something that is not the official transaction hash, even though that is what is usually signed. So signature two is going over how to include a nonce.
00:52:16.090 - 00:53:29.260, Speaker A: So we want to make sure that we're signing transactions from a known entity, but we want to prevent replays. If I sign off that I give alice $5 and I don't have the concept of announce, then she basically just re executes that transaction that has been signed and says, okay, give me $5 until his balance is zero. So we need some concept of a nonce which we store in, which we store in the contract storage count nonce and public key count nonce, right. And then we increment it with each valid signature that we get sent to the account. Okay, that's all kind of vanilla. Signature implementations is not super interesting, just in the sense that you do have to have a valid signature in an EOA. So where does the rest of account abstractions value come from? It comes from these other implementations like multicall.
00:53:29.260 - 00:54:04.970, Speaker A: This is actually the interface that argent and Openzeppelin use as their default. So we pass in an array of calls instead of a single call. This has a lot of different benefits. I'm sure if you guys have been in blockchain long enough, you know that an atomic multicall helps with your limiting your JSON RPC request. It makes certain operations atomic as a whole. Let's say you want to execute contracts in a certain step pattern, all or nothing. So you can execute a multi call like that.
00:54:04.970 - 00:54:39.808, Speaker A: Again, this is what Argent and Openzeppelin are using. And then if you just have one call, it still satisfies the multi call. It's just a multi call with one contract invocation. Pretty cool multi sig. This one gets a little bit in the weeds, but basically you have an example of three signers. There's tons of different use cases for multi sigs, and account abstraction makes multisigs really easy. It also makes it easy for who is going to pay for the multisig transaction invocation.
00:54:39.808 - 00:55:28.752, Speaker A: Once paymaster functionalities come out, you'll even be able to split those across the different multisig members. Pretty cool stuff. This is kind of a reference example. You'll see that you can submit a transaction, go down here, one of the members can submit a transaction, two of the others need to confirm, and then that transaction can be executed like we've been talking about, and then other signatures. So part of the beauty of this, and like I mentioned, it's actually what brought me into the space, is that you don't actually need the stark friendly curve and native curve to sign. You can use anything. So this is an example of SCP.
00:55:28.752 - 00:56:38.364, Speaker A: Two hundred and fifty six k one. There's various different projects for verifying bitcoin and the one that really stands out to me is being able to use secure enclave and secure element and web authentic to have kind of a two factor authentication wallet where you can have one key for trivial signing and one key for transaction signing. So let's say you wanted to have your wallet function exactly like your argent wallet in 99% of the cases. But if you wanted to verify that you are a certain entity or a certain id and you're at a venue, you can essentially have a view function that has a different signing key that attaches to your web authentic or your secure element of your phone. And with a fingerprint you can call a view function, which again it's not a state transition function, so it doesn't cost any money and it returns quickly. And you can basically verify that you are that id with a signature verification on chain in a view function. So the mind kind of spins at this point.
00:56:38.364 - 00:57:15.812, Speaker A: There's a bunch of different interesting implementations. For the most part that's basically it. That's basically all I have. I hope you guys enjoyed this tutorial. Again, we're going to be doing these biweekly, so you'll start to see a couple of these other tutorials come out. A couple of the other really 101 tutorials, if you want to do those prior to something like stacknet accounts might be a good idea if you're new to this space and if you're interested, check out what we got in here. And yeah, I appreciate you guys.
00:57:15.812 - 00:57:30.570, Speaker A: Let me double check the, let me double check the. Cool, not much left. Yeah, thanks for your time again. Feel free to reach out, put a pr in, put some issues into the GitHub repo and yeah, appreciate everything. Have a good one.
