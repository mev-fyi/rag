00:00:00.570 - 00:00:03.582, Speaker A: You. I can see it.
00:00:03.716 - 00:00:42.856, Speaker B: All right, cool. All right, so quick question, Philippe, just to be sure, we need to finish all the exercises from starknet.edu, including Cairo 101, Starknet ERC 721 and so on. No, let me see if I have the graduation requirement here. I do. Okay, so you'll need all the points from Starknet, Cairo 101, this tutorial going over the basic syntax of Cairo except for exercise 14. So you can skip exercise 14.
00:00:42.856 - 00:01:23.740, Speaker B: We don't need the points from that, but the points from the rest of the exercises in there. The other one from Starknet.edu GitHub organization that you'll need to do is the Starknet messaging bridge. And then we're going to skip accounts right now too, because with some of the most recent minor upgrades to the system, I believe we've broken a couple of things in accounts. So an argent wallet with all of points from Cairo 101 and messaging bridge, except for exercise 14 on Cairo 101. No worries. And then an educational related smart contract or a pr to either base camp or one of those tutorials.
00:01:23.740 - 00:02:39.008, Speaker B: Cool. So just to recap where we're at in basecamp, we started everything with the moon math. We started everything with kind of talking through Starks, the math of starks, why starks matter? What we're proving, we connected that up with Cairo. How does Cairo sit in comparison to starks? What are the differences? What does Cairo employ to be provable at the end of the day? And then last time we did a high level architecture overview of Starknet. So the only things that we missed from last session are l two to l one, messaging. And then I wanted to show you guys what a state update looks like. And so when you hear these terms like data availability, data availability guarantees, what does that mean for Starknet? Why is it important and what state are we updating at the end of the day? So before we jump into, oh, and then after we talk through the rest of Starknet architecture, David and Lucas are going to be going over community tooling, devtooling how to use it, best practices.
00:02:39.008 - 00:03:26.046, Speaker B: So that's what's on the docket for today. Did anyone else have any questions as far as the exercises that were given in the off days or last session? Feel free to ping them out in the chat. All right, cool. As always, if you do have questions, if they pop up, just put them there. Okay, so let's start off with our map. This is the same map as the last session. Today, after we talk about these starknet features, this is a lot of what Lucas and David will be going over clis front ends.
00:03:26.046 - 00:04:19.570, Speaker B: Client libraries devtooling sequencers. So we talked about sequencers at this point, are FiFO first in or no? Yeah, first in, first out. But at some point sequencers will not be written just by us. They'll be written and run by other third parties. You'll see some type of consensus protocol as far as coming to consensus on blocks, Manmeet said. So once the sequencer becomes decentralized, will they basically act as shards, or will all of them hold all of the same info and process the same transactions? It's more going to be the latter. It's going to be that they all hold the state, they all execute the Cairo code in the invocation transactions, but that they come to consensus on which block is where and where the transactions lie in the block.
00:04:19.570 - 00:05:14.434, Speaker B: There was a recent post by Ilya, I'll send it out in the chat and in the discord after I give up screen share. But he has a lot of interesting ideas about the path moving forward for decentralization and what that looks like. But yeah, very much still an open conversation that we'd love to have you guys be part of Starknet. So starknet is this execution environment made up of the starknet Os, which is written in Cairo, and all the smart contracts that make up the state. Hey Omar. We prove via the shared prover, we prove the execution and the validity of the state update and the state transition function, which is really the starknet Os. We write that proof to the verifier on l one.
00:05:14.434 - 00:06:25.274, Speaker B: And then, like I said, today we'll be looking at this leg of the transaction, which is we write the data that made up that state transition to l one. And the reason we do this is so that we can always see from the state of ethereum l one. We can always recreate the state of a starknet l two. And that's important because if our goal is to be a real validity roll up, we need to be able to inherit the security properties of Ethereum layer one and fully understand the state of l two from l one. I'm probably not going to get too on a soapbox today, but it is a crazy day in crypto and it's a funny day to be talking about things like data availability and the inherent security of Ethereum l one and the security properties. Because at the end of the day these things really matter. And if we're building high integrity systems and we're building systems that minimize trust, and what we're aiming for is really, for people to not delegate any trust at all.
00:06:25.274 - 00:06:59.030, Speaker B: These things are hard, but they're important. And it's become pretty apparent today and over the last couple of days why those things are important. Sorry if anyone on the call has had some hardships lately, but at the end of the day, it's important to build with integrity and it's important to build with a vision. I'll get off my high horse. Okay, cool. So this is the transaction flow. So clients submit a transaction, transactions get aggregated into a block, proof is generated and submitted, and a state update is written.
00:06:59.030 - 00:08:19.946, Speaker B: Okay, so we'll fly by all the stuff we talked about last time. Okay, l one to l two messaging. We are a generalized expressive validity roll up. And so one of the things that we want to enable, since we're an l two that's operating on l one, is this message passing, the ability to send and communicate with either a bridge that's been built by us and audited by people that are going to audit our bridge, or anybody, anyone can build a bridge. Anyone can build these message passing formats from l two to l ones that you can do things that aren't even just regular withdrawal and deposits, but you can send arbitrary information across these l one to l two messaging bridges. So you can come up with, I know we've talked about a lot about giving developers the power to kind of build these systems and come up with crazy ideas. So the goal of this message passing is that you guys get to define your own payload format and then you can kind of come up with these crazy architectures for message passing from l two to l one and start really leveraging some of the cool properties of Starknet.
00:08:19.946 - 00:09:06.858, Speaker B: So you get cheap computation at l two, and you don't have to pay high gas fees like you do on l one. So what kind of instruction sets can you come up with on l two that you can communicate to l one? Here's how that architecture looks. So we're going to walk through it from the l one to l two first, and then we'll walk the inverse of that. So from l two to whatever the opposite is that I just said. So one, we have an l one dap here, written in solidity. It's going to register a message with the Starknet core contracts. And then we have the Starknet os basically looking for updates in this message queue.
00:09:06.858 - 00:09:41.958, Speaker B: So once we have the message registered, all of the parameters of that message are hashed and that hash index is incremented by one. So what we see over here on the right. Is going to be a status for each leg of this message passing architecture. So on the very top, number one, we have send message to l two. A smart contract on Ethereum, layer one interacts with the core contracts and it says, I would like to send a message to l two. And so the l one contract initiates the message with the designation address. So that'll be which contract.
00:09:41.958 - 00:10:17.570, Speaker B: On Starknet, layer two is invoked, and what's going to be invoked is the selector that's passed into the message here. So then the next status down, we have l one handler. L one handler is what's going to be called. I actually go through each one of these step by step. So I'll just go high level here. So we have the l one handler that's called on the Cairo contract that's deployed on Starknet. We have a proof that's proving that that message was consumed.
00:10:17.570 - 00:10:47.040, Speaker B: And then in the state update, we do acknowledge that that message was consumed by a smart contract on layer two. And that increment that we did in the starknet core contract for the message hash then gets cleared, it gets decremented. So let's look at each one of those a little bit more. Prashant says, is it correct that for l one to l two messaging one can't bypass starknet core contracts? That is correct. That is correct.
00:10:49.410 - 00:10:49.822, Speaker A: Cool.
00:10:49.876 - 00:11:31.420, Speaker B: So the first status here, the first leg send message to l two. This is on those core contracts. So we're calling this actual, this is the actual solidity selector. Name message is indexed and the counter is incremented. So if you want to read through what's actually happening, here's the actual code, the actual solidity code, and we are registering that message hash to send to l two. Nothing really more specific in here, just that we need to pass the message recipient. That's going to be the smart contract on l two, that's called, and then at which selector it's called.
00:11:31.420 - 00:12:25.322, Speaker B: All right, so if you do want to handle some type of message passing, and you do want to specify a payload architecture, you need to have a decorator, a specific decorator in your smart contract, your Cairo smart contract that has an l one handler. And so this is telling the OS that yes indeed, this selector is built to handle this message passing. Yeah, so we have this handler here on line 20 at l one handler. But the interesting thing is it can run arbitrary logic in here. So now you can kind of express the arbitrary business logic that you want to pass these messages. And I just realized that you guys have already done. The message passing the l one to l two tutorial.
00:12:25.322 - 00:12:57.206, Speaker B: So you guys should have a pretty good understanding of how this happens, but it'll be good to look at it at a conceptual level. Okay, so after ten block confirmations, your message is confirmed on Starknet. And then that's when Starknet initiates the corresponding l two business logic in the l one handler. Here. Cool. As with everything on Starknet, the whole point is that we're proven the validity of it. So we need to prove it.
00:12:57.206 - 00:13:31.860, Speaker B: We need to prove that that l one handler execution was run, it was valid. And so, yeah, we included into the proof written back to l one, everything from here just looks like the normal operation of Starknet. We're just proven Cairo code execution. It's just the only thing that was different was the decorator for l one handler. And lastly, the state update. So any state or storage that's attributed to a smart contract that's been updated in the execution of that Cairo code needs to be written to l one. Cool.
00:13:31.860 - 00:13:54.890, Speaker B: And last, the message is cleared. So we have a key value store. It's indexed by the hashing of the message parameters. That's the key. The index is just the increment. So we incremented it by one to say that we passed it to Starknet. And then once we've gone through this full circle, we can decrement and say, yes, this message has been consumed and handled.
00:13:54.890 - 00:14:45.324, Speaker B: Do let me see. Okay. Yeah, you guys should have a good understanding of what this looks like in code. But the interesting things to me is that you define the length of your payload so you can pass as long as your layer two contract knows exactly what it's doing. With the digestion of the information from its l one message, you define the payload so that a lot of the times is just going to look like deposit or withdrawals. But you can really get into some interesting things there. There's a tutorial that Henry wants to write, and I think he's in the process of writing around zombie contracts.
00:14:45.324 - 00:15:42.032, Speaker B: So a contract on l one that's basically a zombie that's sitting there without a brain, and its brain is actually on l two where it's just sending messages into this l one contract for it to do what it needs to do. You can come up with other interesting things like ens. I think we talked about this briefly. I don't have the full architecture kind of in my head, but basically, let's say I want to manage my ens name and I want to manage my ens entry, but gas fees are kind of prohibitive on l one. Well, can I come up with some message passing architecture where I can do all of the ENS domain management on l two really cheap, and I can just message pass down to l one some really cool things? Nadai says, hello, everyone. I had a problem with exercise zero b. I can't get one of the rest.
00:15:42.032 - 00:16:02.420, Speaker B: One, two, three. Okay, I need the last exercise. Okay, so, nadai, let's take that offline. Maybe just ping me or one of the other panelists on today's session, and we can get you helped out. Okay, one quick question, Ben.
00:16:02.580 - 00:16:10.670, Speaker C: Can you create a bridge between Starnet and maybe another layer, one talking about maybe, I don't know, bitcoin or something like that?
00:16:14.480 - 00:17:33.184, Speaker B: You can let me go back up here. So, these deployed smart contracts here that we interact with and that have a definition of this function, which is send message to l two. Those are enabled because solidity is an expressive, smart contract language that becomes hard to do if you're trying to do something in, like, bitcoin scripts. I'm not saying it's impossible, but you basically have to define these starknet core contracts in a way that facilitated all of this execution. And then the other caveat to that is that we talked a little bit last session about source of truth. So, if we have a reorg on ethereum, and we've passed all these messages from l two to l one or back, and then we've done the same thing on bitcoin, what is the source of truth? What is the state of l two? Is the state of l two the accurate one that was written to ethereum, l one, or is it the accurate one that was written to bitcoin?
00:17:33.312 - 00:18:15.316, Speaker D: I'd argue something else, Ben. Is that right now, Starknet has a Cisco to send a message to l one, and there's only one l one, right? So you can't really send a message to any other chain. You could theoretically deploy an instance of starknet on any evm chain. You could theoretically deploy on any chain that is able to interpret a validity proof. So you could do it on stuff like maybe tezos or something. But right now, Starknet is meant to be deployed on a single chain, so it's not meant to be to allow multiple chain communication. I'm sure it will one day because it's a really interesting stuff to work on.
00:18:15.316 - 00:18:17.110, Speaker D: But right now, this is not our focus.
00:18:19.800 - 00:18:42.990, Speaker B: Cool. Does that answer it? Yes. Thank you. Olivier says, I have a question about gas fee estimation. When we have l two, to l one messaging. How does a TX initiated on l one know how much gas will be needed for the business logic on l two, since in my mind, it does not see it. That is a good question.
00:18:43.760 - 00:18:59.760, Speaker D: It's simple. You get to fix how much gas you associate to your message, you, the user. So when you're crafting your transaction, you just need to assess how much the transaction will cost to execute on l two and set this as a parameter for your l one transaction.
00:19:02.420 - 00:19:25.000, Speaker B: Yes. Cool. We don't specifically get into fee estimation for l one to l two messaging, but at the tail end of today, or at least this session, we'll talk about fee estimation a little bit. But yeah, I think Henry answered it well there. Okay, cool. So let's go the other way. We'll inverse it l two to l one messaging.
00:19:25.000 - 00:19:59.876, Speaker B: So I have a Cairo contract on l two that I want to pass some messaging down to a contract on l one. Okay, so the flow here is we submit a transaction. You can think back to our handy dandy map. A client submits a transaction that's formatted to call a selector that sends message to l one. So again, we have a selector to tell the OS that we are doing some message passing here. Tx has initialized the l two contract syscall to send the message to l one. Yes.
00:19:59.876 - 00:20:44.244, Speaker B: So the Os needs to understand that it needs to perform some extra function here, proof everything else is basically the same. So we send a proof, we prove validity of the execution. We update the state. So the message attached to the state update for the core contract increases the counter. So now we have that same key value pair here, where the key is the message hash, the message parameters hashed, and then the value is a counter that's increased by one. This is now a little bit asynchronous. So we've passed this message down to the core contracts, and we've said we have a message for an l one contract to consume or to ingest, and that counter has been incremented by one.
00:20:44.244 - 00:21:42.532, Speaker B: But the async operation here now needs to be that this message needs to be consumed. So the consumption is done manually, or someone needs to come in and basically consume this message for that message to then be in a cleared state. Let's make sure I didn't miss anything. L one recipient contract can consume the message in l one tx via consume message from l two upon valid message parameter counter decrements, and the message is considered handled. So let's just look a little bit at that. By this stage, you guys are aware of what an argent wallet looks like, but a client is going to format that execution, that invocation transaction, and send it to the sequencer. Now we have this send message to l one.
00:21:42.532 - 00:22:15.010, Speaker B: Okay, so I think I said decorator earlier, and it's not a decorator, it's a messaging format from the standard library. So we have this function here, send message to l one coming from starkware, starknet common messages. And again, this is where we get into the really cool concept of this, is that you define the payload format. You get this payload size here. Payload size equals three. Payload size could equal ten, it can equal whatever you want. Your l one dap deployment to consume and operate on.
00:22:15.010 - 00:23:09.080, Speaker B: So you see this here at the very bottom. Send message to l one. We have a defined l one contract address. And then how many values are we sending to that? And the real simple format that you're going to see, probably more often than not, is just withdraw. You'll probably see O withdrawal is a typical l two to l one and then amount, which will actually most likely be two fields of this payload size to handle the low and high bits of the 256. Un 256. Is there any limit on the size of the payload? Based on the current architecture of starknet core contracts? That is a good question.
00:23:09.690 - 00:23:18.940, Speaker A: I don't think there is a limit hard coded, but you will reach a limit with the gas of your. No, that's probably.
00:23:22.590 - 00:23:49.278, Speaker B: It's. Yeah, it's probably not hard coded, but like Lucas said, there's going to be some resource limit that you hit where it becomes infeasible to pass a message. Okay. Message registered. So Starknet os registers the message as well. Up here again with a hash of the message parameters and we keep it indexed. This is the withdrawal call flow.
00:23:49.278 - 00:24:38.130, Speaker B: So this kind of steps out of our transaction propagation flow. I just wanted to show it to you guys because I think it's interesting. This is one that you'll see most often from l two to l one. So you have the un 256 here, which is comprised of two felts to handle the larger integer depth, but the amount and then where to send that amount on l one. And then down here, as we get through account abstraction, we call the execute on the account and we delegate that to a contract where we initiate the withdrawal and we have the permission burn. I believe this is actually from our bridge. So this is what a production l two to l one message will look like in its Cairo execution.
00:24:38.130 - 00:25:23.710, Speaker B: Cool. Message received. Starknet state is updated on ethereum and the sent messages are updated to pending the core contract increments, the message counter and all data can now be retrieved on l one. And then lastly we have this async. This async where consume message from l two on line 134 near here needs to be called counter decremented by one, and the full payload needs to be sent as call data. Okay, that's the round trip for l two to l one. Message passing.
00:25:23.710 - 00:26:20.408, Speaker B: Any questions on that direction? All right, last thing I wanted to go over with you guys, state transition and fees. So if we look back at our map number four here. So this is the status of your transaction, right. You've initiated a transaction, it's either been accepted or rejected. It's been put into a block. You have some degree of finality on l two that we say that, yes, this transaction now makes up one of the valid transactions in this block, which means that it's in the blockchain, it's in l two. But at this stage, we have not proved our execution on l one to the verifier and we've not written our state.
00:26:20.408 - 00:27:22.460, Speaker B: So at the very tail end of last session, we went through what contract storage looks like in Cairo code and how to access contract storage in Cairo code. One of the things we need to understand is if a slot of storage is updated and that update is not written anywhere, we've lost that information. And we've also lost the ability to call ourselves a full validity roll up. Because if we've lost that information and that state update is nowhere, we can't recreate the state of Starknet l two from l one. So your question might be, well, what exactly is written in the state update? And that's what we're going to check out. All right, so open up, Postman, if you'd like to follow with me. If not, we're just going to do one request.
00:27:22.460 - 00:27:49.640, Speaker B: So if you just want to look at my screen, you can do that. Open up. I'm going to do it with Starknet node. You can also do it with the feeder gateway. The feeder gateway has an endpoint for get state update, so you can do it that way. If you think that's easier. Since we looked at only feeder gateway and gateway last time, I want to show you guys the true interaction with the chain, in my opinion, which is through JSON RPC, which is a full node.
00:27:49.640 - 00:28:37.930, Speaker B: If you pick Starknet back up in five years, you're not going to see people interacting with it via an API. You're going to see people interacting with it the way they do ethereum layer one, which is a JSON RPC interface. So I have my infura node URL details in here and I think I actually might have saved them. So you guys might be able to run it as well, but head to node environment and then open up, get state update. Cool. So in this JSON RPC we have JSON RPC 20 method, Starknet getstatupdate and we'll just get the latest, and again, we can get it for any block, but we'll just get the latest to show you guys.
00:28:38.540 - 00:28:43.068, Speaker C: Okay, could you give a little bit more zoom there please?
00:28:43.234 - 00:28:43.950, Speaker A: Yes.
00:28:49.930 - 00:28:51.080, Speaker B: Is that good?
00:28:53.370 - 00:28:54.726, Speaker C: Yes, it's good.
00:28:54.828 - 00:29:40.758, Speaker B: Thanks. Okay, cool. So for this block, for this block, which is the latest block, and again not the latest block on Starknet. L two, this is the latest block that's been updated and written to l one. In this block we had this array of storage updates. So for all the transactions that have been submitted to the sequencer, all of these calling the externally decorated Cairo selectors, and they are updating storage at these various slots. So in storage diffs we can see at this address and this key.
00:29:40.758 - 00:30:39.174, Speaker B: And so from the last session you should understand how this key is hashed and what makes this key up. This value is now this value. So it's changed from whatever it was to this. And again, we have that for all of these interactions that took place in this block. And we're writing that these storage diffs change to these new values. So that way if we reverse engineer it, we can say okay, and we look at each state update that was written from the very genesis of Starknet, we can say, okay, this is how this system has propagated itself from the very first block to today, and we can recreate the state of what it looks like today. So the other things that we need to know, besides just the storage diffs for already deployed and declared contracts, is were there any deployed contracts? Because that's going to affect the state of that merkel try, it's going to have another contract address to basically add to its state.
00:30:39.174 - 00:31:44.206, Speaker B: So not only do we need to know what changed with the deployed contracts, we also need to know were any contracts declared and were any contracts deployed. So yes, in this block we have 12345 deployed contracts. Yeah. So when you start to hear things about data availability, data availability guarantees, when you start to hear things from starkware, like we have these hybrid solutions, or what we're looking to have is hybrid solutions that have different data availability guarantees, volitions, this is what Starknet has because we want the absolute maximum data availability guarantees. We want to have this data available on ethereum l one secured by the billions of dollars in chain security that l one has. Cool. Manmeet says, so basically I need to consume a message from l two to l one, but it gets automatically consumed the other way.
00:31:44.206 - 00:31:53.300, Speaker B: What's the point of that? Why not consume on l two as well? Does it have anything to do with da? Why not consume on l two as well?
00:31:54.710 - 00:32:42.850, Speaker A: I think he meant on l one also. Basically, we can't automatically consume a message on l one because the chain cannot call itself. We consume the messages on l two because we operate the sequencer and the sequencer can consume the message automatically. But there is a world where the sequencer doesn't consume automatically your message on L two either. So it's just a design choice that we made, and we think it's better to automatically consume the message on L two. But on L one, we can't do that because we don't operate like any node on L one. And we wouldn't do that even if we operated the node because we can't.
00:32:42.850 - 00:32:59.720, Speaker A: Will that stay when the sequencer is decentralized? It depends on the client. I would tend to say yes, but some people might just have a client that don't automatically consume a message on l two.
00:33:02.490 - 00:33:36.210, Speaker B: Sweet. Does that answer it? Amy? Awesome. Okay, so cool. Now that we've seen a state transition, we've seen what needs to update. We've seen what the l one needs to know about the l two in order to feel convinced that it's fully valid, it's a validity roll up. Let's talk about the fees. So we say that the fee that you pay for your invocation transaction, or your transaction in general, covers the l one footprint of your transaction.
00:33:36.210 - 00:34:43.830, Speaker B: What does that mean at the end of the day? So not only do we have to pay for the specific call data that went into that storage update, which we do need to do, and that's here. So, storage updates, contract address, number of updated keys, keys to update, and the new values that they're updated to, that one should feel somewhat obvious. We are calling a solidity contract that we need to pay for. You're going to pay for the gas price at the current time times the amount of words that we're writing in call data times two. Oh man, have I forgotten what this means? Okay, unique contracts and unique keys. So if you wrote multiple different keys, if you wrote multiple different keys, then you need to pay for the keys. Why is it two x? Why is there two x because we're writing the contract address and the key that was changed.
00:34:43.830 - 00:35:30.000, Speaker B: So that is what you'll pay for for storage updates. If you did send a message from l two to l one, you are going to pay for that. So gas price times the amounts of words in your call data payload as we talked about. There's some theoretical limit as far as resources that will be taken, but nothing hard coded. Contract deployments we talked about briefly, l one needs to understand if there's a new contract in the state of l two. So it'll need to know the contract address, class, hash, number of constructor args and constructor args. So gas price times the amount of call data we're sending.
00:35:30.340 - 00:35:31.090, Speaker D: Cool.
00:35:32.420 - 00:36:40.310, Speaker B: This is the one that kind of was non intuitive to me. So we have all this DA that we pay for, which is important for us to reconstruct the state. But if you think about our map, we are also sending a proof, we are also constructing and sending a proof that we are checking on the verifier on l one. So you need to pay for the amount of steps that were run in the execution of your Cairo code at that selector and any built ins that were used. So are you verifying an ECDSA signature? Are you doing arrange checking? Are you doing Peterson hashing? Since it's arbitrary business logic at that, know you could essentially be doing anything, you'll need to be paying for that because it will affect the proof size, Shevan says. Does that mean the l one handler decorator function should also have a normal function which can be called like the consume function. Whatever that decorator decorates is the function that will be called.
00:36:40.310 - 00:36:59.850, Speaker B: So from 121 here to 140. If that message is sent to that contract, this is the function that will be the normal function that we called. Does that make sense?
00:37:00.380 - 00:37:15.630, Speaker A: And actually you can call the function, can't remember the way, but you can, like if the sequencer doesn't consume your message, there's a way to call it, I think. I don't have the details, but I think it's possible.
00:37:17.520 - 00:37:51.610, Speaker D: The way it works. I think if I remember correctly, the l one endler can be triggered by any sequencer or anyone who wants to trigger it, but it still needs to be included by a sequencer, right? So you need a sequencer to trigger it. And it will only trigger it if there's a message, because otherwise the proof that will be generated won't be accepted by Ethereum. That being said, I don't think the tooling to trigger the l one Endler yourself is out already. Is it?
00:37:52.540 - 00:37:53.704, Speaker A: I have no idea.
00:37:53.822 - 00:38:00.750, Speaker D: I haven't seen it yet. So I think it's something that will come later, but for now it's waiting for a sequencer to pick it up.
00:38:03.600 - 00:38:38.908, Speaker B: Cool. Chevin, does that answer you cool? All right, that wraps up our section on Starknet architecture. Yeah, do you guys have any kind of last roundabout questions here? I think we fielded most of them. You guys should know where the docs are. I think I've sent those out. This is awesome. Starknet is a really good repo for a list of community tooling docs, tutorials.
00:38:38.908 - 00:39:11.520, Speaker B: If you haven't seen this yet, I would highly recommend checking it out. I'll put it in the chat and discord and then the community forum here for talking about various things. That's where the decentralization post that Ilya just sent out lives. Okay, so for now, I think we're going to take our break now and then regroup and talk about tooling and best practices. You guys have already done Starknet l one to l two. So yeah, let's take a five minute break and meet back at 17.
00:39:17.530 - 00:39:22.674, Speaker D: Do you have some kind of elevator music we could play in the meanwhile, like, you know, for Atlanta?
00:39:22.722 - 00:39:24.630, Speaker A: Ding din din.
00:39:28.890 - 00:39:30.082, Speaker D: Thank you for attending.
00:39:30.146 - 00:39:30.878, Speaker B: Bastard.
00:39:30.994 - 00:39:46.160, Speaker D: I'll be back shortly. More information. Have you checked our repos? Have you checked our sick repository? Call and learn more stuff@starknet.com.
00:39:51.650 - 00:39:54.560, Speaker B: You know you got to keep this going for four more minutes, right?
00:39:55.250 - 00:40:21.130, Speaker D: Subscribe to our newsletter. Come find out our newest offer, a special promotion from l one to l two messages. Have you noticed that I haven't said anything in an hour? I'm just here to play dumbass.
00:40:27.630 - 00:40:33.340, Speaker B: Mammy says this is how we bring the next billion users into web3 and I 100% agree.
00:40:33.870 - 00:41:00.260, Speaker D: Nice. Well, I mean, think about it this way. It is actually how you bring the next billion one user because I get devs to stick around and then they build the thing that will bring the next billion user. I mean, you obviously, with the content, do most of the work to get people to stick around. Anyway, if you wanted to disconnect Ben and have a breather, because I know talking for a while can be so like, please don't use your break.
00:41:02.150 - 00:41:15.980, Speaker B: Anyway, I want to let everyone know that the next session is going to be run by Henry. And I think you can now expect about 2 hours of elevator music with a few pieces of content thrown in.
00:41:16.590 - 00:41:17.340, Speaker D: Exactly.
00:41:19.310 - 00:41:22.330, Speaker B: And Che is making it his ringtone.
00:41:22.670 - 00:41:43.220, Speaker D: I can record a few for sure. I should have a box, like, know you can send me starknet eth. And then I recorded a tune for you. Welcome to SHIELd's ringtone. She is not available. Please come back, leave your message or send him an email. Have a good day.
00:41:43.910 - 00:41:46.530, Speaker B: I'd make it in nfts.
00:41:46.970 - 00:41:48.482, Speaker D: What do you mean about nfts?
00:41:48.546 - 00:41:50.760, Speaker B: We make them nft ringtones. We sell them.
00:41:52.490 - 00:42:13.950, Speaker D: That'd be nice. Well, I mean, the market is kind of dead for nfts though, right now. Should I miss my vocation? No. I used nfts a long time ago. I actually minted nfts a while back, but never was smart enough to monetize them correctly.
00:42:17.170 - 00:42:19.280, Speaker B: Anyway, what were they?
00:42:21.090 - 00:42:55.146, Speaker D: It's actually a cool project. But a while back, I wrote an algorithm that allowed me to take an image and turn it into a path. And I used this to essentially make a big picture which was made of smaller pictures which were just path engraved with a laser engraver. I used it for a familiar reunion, which was really cool. Doesn't make a lot of sense when I say it that way, but I'll share it with you at some point if you want. And then I figure, oh, this is nice. I can do it for something else.
00:42:55.146 - 00:43:41.954, Speaker D: So for ETCC in 2020, actually, I made this huge mural which was like, I think like 4 meters by six or something, which was made of a four paper. So a four paper for the Americans amongst you don't use proper measuring system. It's a sheet of paper like this, right? And so there were like 400 of these. And if you stick them all around, it would make a huge picture of the group picture from ECC 2018. I printed them all and I deployed an NFT with any sheet of paper you would get. You could claim an NFT just with a signature that was printed on paper. And I think something like, I put them everywhere in the venue.
00:43:41.954 - 00:44:19.426, Speaker D: And after 50, I was like, okay, this is long and not everybody's interested and I want to go to listen to talk. So I just dropped a few in the venue. I think something like 15 or 20 people claimed it amongst them. Like a few interesting people. But at the time, I wasn't super familiar with how you do metadata for NFT. So instead of doing something where I would point to an image, I was a good boy and I attached the ash of the image, which was hard to interpret, so you can't really see them in explorer. And I wasn't good at promoting it, so it never got anywhere.
00:44:19.426 - 00:44:25.430, Speaker D: But I did do my own NFT in 2020, so I'm super proud.
00:44:25.930 - 00:44:28.040, Speaker B: Revive it. Revive the project.
00:44:29.210 - 00:45:04.258, Speaker D: No, I was a good boy, and I can't change the metadata. I don't have control over the NFT anymore. I can't even make it nice to. But now, you know, I'll revive it one day because the program I wrote, which designs the picture with the path. Okay, let's try to make it more clear. Imagine you have an image which is black and white, and you have shades of dark and black. The idea is that if you scroll your pen more in certain places, you have more shades of black.
00:45:04.258 - 00:45:46.160, Speaker D: And so the idea is that you turn the image into a set of points which your laser engraver has to pass through. And so you can make shades of black just with an engraver. And you solve, like, the idea is, how do you do this in the shortest time possible? And so you need to solve traveling Salesman problem where you go through all these points. What's cool is that if you look at one picture, it's just a set of points, but it's an algorithm that is, in your everyday life, everywhere. It's a graphical representation of something that is everywhere in your daily life. And if you put all of them together, then things start to make sense, which is nice because it's kind of life. We all have our own optimization, our own path through our own constraint, but we're part of a bigger hole anyway.
00:45:46.160 - 00:46:18.540, Speaker D: And the thing is, I did that on my computer because there's no way you would solve a traveling salesman program on a blockchain network, right? Except now you can. So now the next thing would be to do that in Cairo or something, generate the proof on my computer and then make an in out of it. So when I have time in 50 years or something, I'll do that. Anyway, back to our regular program. Thank you for following base camp.
00:46:19.150 - 00:46:23.040, Speaker B: I was just going to ask you for an outro. That's awesome.
00:46:23.490 - 00:46:23.994, Speaker D: Sweet.
00:46:24.042 - 00:47:00.090, Speaker B: Hard to follow that. Cool. So now we're going to be talking about tooling best practices, how to choose the tooling. One of the cool things is starknet kind of attracts these really motivated builders, and we end up with a lot of projects, a lot of tooling, a lot of really good, competent systems. So there's more than one thing for you guys to choose from. I'm going to give it to David to kind of talk about what each one of them is at a high level and how to go about choosing.
00:47:01.550 - 00:47:32.900, Speaker C: Yeah. Just a few weeks ago, I wrote an article, the medium website for stagnet.edu, where I did like a high level overview of different editors that we have, sorry, the tooling that we have for Stagnet. So I'm going to share with you first of all the link to the medium post. And then I shared my screen so we can talk about it before we go deeper with Lucas in one of these tools. So let me share my screen now.
00:47:33.670 - 00:47:35.220, Speaker A: Desktop three.
00:47:36.550 - 00:47:41.106, Speaker B: All right, so this is the article in question.
00:47:41.288 - 00:48:36.950, Speaker C: So the idea is that if you are a solidity developer, if you're coming from already working on Ethereum and now you're going to Startnet, you probably have used either foundry or hard hat. Those are like the two main tools that you use in solidity. So if you like foundry and solidity, the suggestion here is that try Protestar, because it follows a similar pattern to try to test your smart contract using the same language that you use for the smart contract like foundry. You will use solidity to write unit tests for solidity. Smart contract in the case of Protostar, you will use Cairo to write unit tests for Cairo smart contracts as well. The main difference is that Protostar is not built with rust while foundry is. So there's a difference in performance, but you get the benefit of having less context switching between two languages, one for testing, one for the smart contract.
00:48:36.950 - 00:49:19.342, Speaker C: If you don't come from web3, you actually come from web two directly to stagnet. Then you have a couple of different options. So if this is your first time, oh sorry, I forgot that if you come from web3 and you don't like Foundry, you probably use hardhut, which is the other tool that is using JavaScript. Basically you can continue using hardhut for starnet. You just need to enable a plugin for the starnet network, and then you can write your unit test using JavaScript as well. So you have that as an option. Now, if you actually come from web two, and it's the first time you try starnet, which I don't think is your case, but you have a remix that is also available for solidity.
00:49:19.342 - 00:50:26.378, Speaker C: Just in this case you will have the installer plugin, as you can see in this screenshot. Just go to remix, install the starnet plugin and you can use it as well. So in this case you wouldn't have to install nothing in your computer, just everything is online. But if you want something a little more complex and you feel familiar with Python, then you can use the Caroline package developed by Stargare or Nile developer opensepling. These are just as I mentioned, Python packages that you can use in this case to compile and deploy just to deluxe a lot of basic operations with your smart contracts. But if you're more of a JavaScript developer, right, coming from web two again, maybe you want to use Harha directly because you can write the unit test and the deployment the scripts using JavaScript as well. But I think overall, if you don't have a preference between Python and JavaScript and you just want probably the best tool right now, I think Protester is a safe bet at the moment in my opinion, like the most developed and mature tool out there.
00:50:26.378 - 00:50:37.050, Speaker C: But here you are, you have some options to which tool to use, so I pass it on to you now, Lucas, which one are you going to use? I guess in Protestar or you're going to use ape?
00:50:37.210 - 00:50:47.358, Speaker A: No, I'm never going to use ape, but here I'm going to show how it works with hard hats Protestar and the Python framework.
00:50:47.534 - 00:50:48.260, Speaker C: Awesome.
00:50:50.630 - 00:51:55.780, Speaker A: Yeah, so just for a bit of context, I don't like ape because I tried it when it was out a while back and it was so hard to make everything work that I just stopped using it and I just went back to the Python framework because everything works easily, you have a lot of functionalities, so I just sticked with that. You need that. Okay, so you should see my terminal right now. So we're in the biddle directory in the base camp repo and I'm going to zoom in here also. Okay, so what do you want to start with? David? Hard hat Python protestar.
00:51:57.080 - 00:51:59.972, Speaker C: What would be the easiest, the simplest tool?
00:52:00.106 - 00:52:03.960, Speaker A: The simplest tool. Okay, it's probably hard hat because it's Javascript.
00:52:05.180 - 00:52:10.136, Speaker B: Lucas, Carlos is wondering if you could boost the font size just a bit.
00:52:10.318 - 00:52:19.230, Speaker A: Yeah. Okay. Is it big enough or is it too big? It looks super weird on my screen.
00:52:19.680 - 00:52:21.052, Speaker B: He says looks good.
00:52:21.186 - 00:52:21.900, Speaker A: Okay, perfect.
00:52:21.970 - 00:52:22.492, Speaker C: That is better.
00:52:22.546 - 00:52:23.148, Speaker B: Yes.
00:52:23.314 - 00:53:30.230, Speaker A: Okay, so hard ads, so you can use hard ads for l one also. So if you have a bridge or something, you can use hard hat and it will be way easier to manage than other frameworks, I guess because you could have hard hat set it up for l one and hard hat for l two. For example, maker, Dow and other bridges use that so they can handle everything really easily. So how it works, basically you just install hardat, you init the repo so you can install with NPM and you save it in your dev dependencies. Then you init the repo with NPX hardat in it. I won't do it because it will break, but then you set up everything that you need, then you need to install shardlabs. Hardhat plugin? Yeah, it's here.
00:53:30.230 - 00:54:24.224, Speaker A: And this will allow you to interact with the Starknet contracts. So in your hardat config you can use two different things. So you can either use a dockerized environment, which is easier to set up because you don't have to install anything locally except docker. It will pull the container from Docker hub and everything will run without you setting up anything. Here, I added some arguments. This is the light mode, because you will see soon enough, maybe you have seen it, you probably have seen it, that everything is slow on Starknet, even unit testing, because the VM is in python. So child labs added a mode where they try to mitigate slowness of the Python VM.
00:54:24.224 - 00:55:05.136, Speaker A: And it's the light mode. And basically what it does is that it doesn't compute the transaction hash and whatever. They tried not to compute any hash because Peterson is really slow. So this is what light mod does, gas price. So it's just you said the gas price and this is the seed. So it's for pre deployed accounts. So when you spin up the devnet, it has pre deployed accounts funded with ETH, and the seed will change to the address of the account.
00:55:05.136 - 00:55:44.524, Speaker A: So here I'm fixing it to one, so I don't have to do anything except then copy pasting the address and the private key of every contract. So it's easier for me to manage. Here I'm declaring my accounts because I will need them to interact with Stocknet. Here is my smart contract. For a bit of context, I created like a dumb multisig. Basically every user can say, I approve this ERC 20 transfer. And I deployed of course, in yearc 20.
00:55:44.524 - 00:56:30.350, Speaker A: So here I'm loading the accounts, and then I'm deploying the multisig contract with the addresses of the account. Because this array is the array of Signers, it's the people that will be allowed to vote. Here is how many signatures I will need for a proposal to be accepted. It's divided in low and high because it's a UN 256. And Ben probably told you, but fails are only 251. So you need two fails to represent a 256. Okay, then deploying the contracts and whatever.
00:56:30.350 - 00:57:06.504, Speaker A: Now the real test. So here what I'm doing is that I'm invoking the multi c contract through my account, and I'm invoking the create proposal function that is here and that just as it says. So just store a new ERc 20 transfer that's waiting for votes. Then I'm calling the view, because I need to want to check that.
00:57:06.622 - 00:57:11.672, Speaker B: Hey Lucas, real quick, this is camp four, right?
00:57:11.806 - 00:57:12.296, Speaker A: Yeah.
00:57:12.398 - 00:57:16.700, Speaker B: Okay, so, yeah, so men meet is just wondering for following along purposes.
00:57:17.200 - 00:57:17.564, Speaker D: Yeah.
00:57:17.602 - 00:57:21.870, Speaker B: So this is base camp four. You should just be able to CD into camp four.
00:57:23.680 - 00:58:01.080, Speaker A: In the biddle folder. Okay, cool. So I created the view because when you invoke something, you don't get the return value. So I created a view to view any proposal. And here I want to check that the proposal created here is correct. So I view my proposal as the proposal zero. Here I define my expected, what I should get, and then I expect the proposal that I got like the amount to equal the expected amount and same for all the properties.
00:58:01.080 - 00:58:46.164, Speaker A: And then I do the same thing for a lot of other functions. And here is how we check for errors, because there is no built in expecting, like in solidity. In solidity you can expect your contract. So multisig, I don't know, create proposal to be reverted with or something. And then you just add your error message and it checks. If it's right here in starknet, I don't think we can do that, at least we couldn't do before. So what we do is a try catch.
00:58:46.164 - 00:59:47.740, Speaker A: So we try the transaction that should fail. We catch it, we get the error message, and then we expect the error message to include this error message, because I'll run the test right after. But you'll see the error trace is huge, so you can't check specific the whole error. It's too hard. Also, you now have a special function in on hardat to decode the transaction received. In ethereum, when you want to check for events, you expect your transaction. So mut create, blah, blah, blah, to emit, to emit the event of the contract, multisig, the event will be created.
00:59:47.740 - 01:00:31.080, Speaker A: And then with arcs, you can do that and specify the arc. In Starknet, you can't do that. You need to get your transaction received. So the transaction received, I think, yeah, Ben probably showed you one, but basically it's a summary of what happened and what events have been emitted. So you get this and you can call CX decode, decode events. And then you can assert on the events. I didn't do it here because it's fairly new, but you can do it, and that's a great thing because events are important to index the chain.
01:00:31.080 - 01:01:15.930, Speaker A: So let me revert all the changes. That would be all the functionalities of hardat. And this is how it would run. So I use NPM, you can use jar and you can use whatever you want. So it compiles the contract with the Docker image because I chose to use the Docker image. But you can choose also your local environment and we'll compile all the contract. It's a bit slow also because the compiler is in Python, but it's being rewritten in rust, so we should see a big improvement here.
01:01:15.930 - 01:01:46.768, Speaker A: And then it will run the test to the dockerized devnet. And as they run in the same terminal you can have the output of the devnet, which is cool because you'll see after that we can do great things with that. If it finishes compiling someday should be good. Trust me. Maybe Henry wants to sing a bit.
01:01:46.854 - 01:01:49.228, Speaker B: Because you got a scat or sing.
01:01:49.334 - 01:02:33.762, Speaker A: I told you I won't do that after Henry, you can't do that. Just going to be ridiculous. Okay, so these are the pledry poloid accounts that are funded and my tests are going to run here. Scroll up. Right now it's deploying the contracts and I assure you that the test will run, see first test, so it passed. Second test, also third, also fourth. Here is the error.
01:02:33.762 - 01:03:07.762, Speaker A: So the devnet outputs the error, so we can't really hide it. But you see that the test passed. So the error message was include here and it was code. So you see this is the full error, I think. So it's quite big and you can't test everything. Also you don't know the pcs by heart, so it's kind of pointless. But yeah, this is basically what hard test looks like.
01:03:07.762 - 01:04:00.292, Speaker A: And you saw that it was a bit slow. I mean, nine tests, 43 second is quite slow, but with Python or protestar it's a bit faster because what the devnet does is that it wraps this testing framework in an API. So we got like the API time added and now let's switch. First, any question on the hardat? On the hardat plugin? No. Okay, perfect. So the Python framework. So basically you're free to do whatever you want with the Python framework.
01:04:00.292 - 01:05:00.368, Speaker A: This is how I chose to organize my tests. But you can do like more complex thing, you can do easier things. I just do what I'm used to. So what I'm doing here is that I'm inheriting from the test case class, so that the unit test framework, this framework would detect this as a test pipe. You can use pytest and use fixtures and use whatever you want, but I prefer to do it that way. So here we have a class method that this function will be called before every test. So I use this one, because, well, the functions are asynchronous in starknet.
01:05:00.368 - 01:05:53.500, Speaker A: And I had to use a modified package called async test, which is not great. And actually you can use something else from the unit test package, which is better, but I didn't know it at the time. But anyway, so this package only overrides the setup function that is run before every test. Also there's the setup class, which I prefer, which is run once, and you can set up your starknet. So this creates a mock stocknet with no state and blah blah blah. This deploys the contract, this deploys the ERC 20. This is just for assertion, we don't care.
01:05:53.500 - 01:06:32.490, Speaker A: And this creates a proposal. So this is run before every test. This is a context manager. If you're not familiar with Python, well, you probably don't know what it is, but basically this will help me assert on errors. So what I'm doing here is I'm testing create proposal. So what I'm doing is that I'm creating a proposal, and it's a data class that I created here. So a data class is just a class that has no logic, it just holds data.
01:06:32.490 - 01:07:22.440, Speaker A: And then I created this function in the data class to override this symbol, which checks for equality. So without it, it wouldn't work. I think that you can extract the type from the contract, but I didn't do it because it's a bit harder to do than just defining this class. Okay, so I create the expected proposal. Then I view the proposal. So the proposal was created here, and I view it so the zero tuple because it's a un. And then I assert that the proposals are equal.
01:07:22.440 - 01:08:02.390, Speaker A: I check the approved signers if they're the right one. And then I check if the function fails as expected with the error message. And this is the context manager. And here basically same thing. And I should also check for events here I check that the event is the right one. I also created a data class for this to be able to check easily. So yeah, I prefer this.
01:08:02.390 - 01:09:17.620, Speaker A: That's the framework that I prefer, because I think it's like the more complete one. You can check for events easily, you can interact with starknet easily, you can tweak some parameters, you can modify the starknet config, you have all the flexibility of python, and you can also add breakpoints. So for example here, if I want to debug it, I can add a breakpoint here. And let's say I want to print a value of zero un. I can do that, I can do that. And when I will run, when I will run the test, it should stop at the breakpoint and I should be able to log the memory, to log the variables. Okay, so it doesn't work because I didn't say disable hint validation.
01:09:17.620 - 01:10:29.320, Speaker A: Okay, so this basically tells the compiler not to check for unwhitelisted hints, and this is just to avoid all the warnings. I guess you're all familiar with hints, but it's just a python block embedded in Cairo. So you can have a python breakpoint in your Cairo contract to have easier debugging. You can also print variables because, well, it's Python basically. So you can even import whatever library you want to debug that I might not be aware of, and you can do whatever you want. You can also have that with hard at, you can print, but you can't have a breakpoint because the Devnet blocks the, it blocks the STD in. So you can't write anything with the breakpoint and so it fails.
01:10:29.320 - 01:11:01.060, Speaker A: And here it also fails. I don't know why, but it's not really important. If you want to know more about how to debug a smart contract, there is an awesome tutorial that someone from starknet.edu wrote. I'll send a link after. But basically you have advanced patterns on how you can debug. All right, so that's it for Python.
01:11:01.060 - 01:12:23.282, Speaker A: Any question, just as in c language, I could inject assembler code into routines. Is it feasible to inject native cargo into a contract made in Starknet? Or is it a fallacy what I'm referring to? I'm not sure to understand what you mean, because a starknet contract is written in Cairo. So what you would want is to eject Cairo in Cairo, but in Starknet you cannot inject anything. I would say once your contract is deployed, you can't inject more code. It's fixed and you can't deploy your contract with any hint you want. Otherwise you would be able to destroy the sequencer, which we really don't because the sequencer holds the network. So yeah, you have to use whitelisting.
01:12:23.282 - 01:13:34.890, Speaker A: Hint video freezing tool addressed me? No, it might be because of my Internet. I don't know why, but it says that my connection isn't stable. Okay, so you see now the breakpoint works and I can run any python I want. In this breakpoint I can also print the memory. So AP is not defined because memory of AP is not defined because it's like the last available cell, but AP minus one should hold a value and it holds color, which makes sense because this is a let. This is a let, so they're not saved into memory, and this is a return from a function, so it's saved into memory. So AP minus one is this, and you can mess with whatever you want SP, you can define other variables to help you debug.
01:13:34.890 - 01:14:45.850, Speaker A: But anyway, if you want to know more, refer to the amazing tutorial. Any question on Python? No. All right, let's go to the star of the show, proto star, which is here. I'll close others. Okay, so proto star is great if you don't know any other language than Cairo, and if you don't want to have other dependencies like you can fully rely on Protestar. It would be the equivalent of forage without the performances, as David says. But you will soon have something more performant because the VM is rewritten in rust right now, and I guess they will integrate that VM soon.
01:14:45.850 - 01:15:32.980, Speaker A: Also there is a project done by only dust called Cairo Foundry, which would be the equivalent of foundry, but for Cairo. So proto star copied everything from foundry. So if you're familiar with Foundry, you won't be lost here. Here I need to define some stuff here the interface to be able to interact with my contract. Here is the setup function, which enables me to set up everything. So deploy contracts. Yeah, basically deploy contracts.
01:15:32.980 - 01:16:23.530, Speaker A: And also we can save data in context and this will be available in all the functions. So here I saved mock ERC 20 address and I can access it in this function. So this is nice to be able to interact with the contracts. Yeah, and basically we prank Starknet. This is a cheat code that allows you to impersonate an address. So here I will impersonate signer one for the next call or for all the calls, I can't remember. Yeah, for all the calls, because here I say stop.
01:16:23.530 - 01:17:26.750, Speaker A: Here I expect Evans this one, and it should be emitted in the next call, otherwise it won't be detected. So expect Evans is a cheat code that allows you to check that the next transaction indeed emits this event. This I start prank again to be signer one because he's whitelisted. And here we can expect a revert to check error messages and the next function call as the event. Only the next one should revert actually like all the end of the function. And if you have a certain equal to here, this won't be detected. So you should check for errors at the end of the function.
01:17:26.750 - 01:18:37.280, Speaker A: Here, same thing, we will create proposal. We check for the events number thing, we check for the error messages and yeah, that would be it. Also for Prostar for now, they added cool features recently and they added a profiler so you can run your test and you will have a graph of all the functions called what steps did they use? How many built in? Oh no, not how many built ins they use, but you could have also a flame graph to know what function is the longest to execute. So you can have a lot of information to optimize for your smart contract. But this is recent so it might have a few bugs. So if you run into one, don't hesitate to open issues and to notify the team. Yeah, so that would be it for Protestar.
01:18:37.280 - 01:20:03.070, Speaker A: Any question on this? So is the carrot test being run in the hardat extension? Like does this integrate protestar? Not sure to understand the question, but proto store what it does is just you have your smart contract, like you have your test file, which is a carrot file, and it should use this framework to call your function to deploy your contract. Check whatever you want. So in the end it's just using this but without writing a single line of python. The downside of Protostar is that you can't have a breakpoint because it captures std, whatever. I'll run the test to show you and you can't write anything there because it just runs the test. Um, so that's, I think it's problematic, especially if you have a complex smart contract that you need to debug. But once more I would strongly encourage you to do the debugging tutorial.
01:20:03.070 - 01:20:25.240, Speaker A: You will surely find something that you didn't know and that would ease your life. So all the tests run because it's cool and you see there was no time. Like if I add a breakpoint, let's see here.
01:20:28.650 - 01:20:31.080, Speaker B: Do you have python alias to p.
01:20:31.450 - 01:20:56.320, Speaker A: Or is that proto star? Okay, because Proto star is too long to type. Hopefully this will work and it will just output an error because we can't add a breakpoint. But yeah, I put alias for everything. Why would I type full Proto star when I can just type p?
01:20:57.010 - 01:21:01.700, Speaker B: Especially when you have to explain it and teach people and make it really clear.
01:21:02.950 - 01:21:29.160, Speaker A: That's a good point, but I can't have everything. I have Qmax, I can't have everything. Yeah, so no, it breaks. I add compile time, maybe I need to disable and this would compile hopefully and run the test and output still an error, but not the same one.
01:21:33.930 - 01:21:39.850, Speaker B: Hey Lucas, Luis is know you as a developer. Is there one of these solutions that you prefer?
01:21:40.750 - 01:22:47.726, Speaker A: Yes, I strongly prefer this because you have all the python flexibility. It's easy to interact with your contract, you have easy access to the events, to the return data, to the resources consumed by your test. You have all the features you can think of, while second choice would be Protestar because it's fast and you got a lot of features also. And third choice would be hard hats. It's close to Protestar, but I think it's lacking some features for events. But if you have a bridge no brainer, go for hard hat. It's way easier to manage everything.
01:22:47.726 - 01:23:30.570, Speaker A: But if you have only an l two contract, my personal preference is that. Also, I like Python, so it plays a lot. Yeah. And you see, I've got an error because the debugger, I couldn't type anything in the debugger, so it just broke down. And that would be like the main problem of proto start to me. All right, any more question on that?
01:23:32.940 - 01:23:41.070, Speaker C: When you deploy a conference in your day to day, then you would prefer to use a python script like this one?
01:23:43.520 - 01:24:18.128, Speaker A: No, I would use Starknet JS because I think it's easier to use. I think that Py has a very complicated architecture that is unnecessary, whereas just starknet js, you just install Starknet JS, you create like your JS file and you can just import whatever you want. So you want to create an account, account from Starknet and that's it.
01:24:18.234 - 01:24:29.740, Speaker C: Lucas, are you showing something in your screen? Because it got like, freeze for a moment. Okay, now I can see, yes, you're in a typescript file, right?
01:24:29.810 - 01:25:12.404, Speaker A: Okay. Yeah. And that's it. You just have this, you import this, you get your private key, get key pair, you can export it from your urgent contract and you got your key pair and then you're free to go create your account with default provider, blah blah blah. And it's really easy to use. Whereas like structure py, it has a weird architecture, I think, for. Yeah, no, yeah.
01:25:12.404 - 01:25:51.300, Speaker A: To have your account, you have to go there and find the right class. You need to create your provider. Like, you need a bunch of things that are, I think, inconvenient. But I would also use Kygo probably is the best SDK ever created. So Kaigo is the Golang SDK of Starnet and Ben is the daddy of Kaigo. He created it. It's his baby.
01:25:51.300 - 01:25:57.590, Speaker A: Mean go is fast, so it's quite cool.
01:25:58.120 - 01:26:07.240, Speaker B: Use Kaigo, contribute to Kaigo. Manmeet says he's running into the start. Do you see the error he posted in the chat?
01:26:07.980 - 01:27:45.480, Speaker A: Invalid transaction, nons message and even transaction. So what you're trying to do is to send a version one transaction, a version zero transaction to like a version one account contract. Because in starknet we have another transaction version because we added the nonce at the protocol level because we could have potential replay attacks if the account contract doesn't check the nonce. If the account contract doesn't change the nonce, you could just take a null transaction, get the signature and just replay the transaction, which would be problematic. So we added a nons to every smart contract at the protocol level. So now you don't need to play with nons. So do I need to structure it as a v one transaction? Any docs on that? Yes, I'm pretty sure there are docs on that in the great website that has been reworked here.
01:27:45.480 - 01:28:28.060, Speaker A: Think you got something for transaction? Maybe not transaction. Transaction. You have invoked transaction version one here. I zoom in. So this is transaction version one. And this is transaction version zero. So this is the old one where basically the nonce was in the call data because every smart contract would handle the nonce as it wanted.
01:28:28.060 - 01:29:38.780, Speaker A: And now as it's handled by the protocol, you have to add it in the json of your transaction and I will send here to. Okay, that's it for transactions. Sorry, this question is a bit out of context, but from the point of view of metadata, which tool should we use? Depending on the use you want to give and the time you want to keep the data, I would suggest ipfs. Any question related to testing or Starknet? No.
01:29:42.530 - 01:30:16.150, Speaker B: I'm trying to find the Starknet JS documentation for defining a transaction version one. I'm having a hard time finding it in their docs. One thing I sent out was the release when they did add support for it. So if you check out that release tag, you can see that's when they added support for type one. And unfortunately you might have to go into that commit hash even though that seems really cumbersome.
01:30:18.330 - 01:30:37.040, Speaker A: Yeah, I don't think they update the documentation that often, but if you go into the account class, you'll probably have all the information that you need are in their test because everything is tested, so you'll have examples there.
01:30:39.010 - 01:31:21.882, Speaker B: Yeah, but based on your error, I'm assuming that it says if you don't provide, this is the way I'm guessing it works. I'm not actually 100% sure, but so it says version doesn't equal zero. So if you don't include a version it probably defaults to zero. And in the transaction version zero there was not a protocol level nonce. So it's just telling you if you want to include a nonce, you have to either use version one or define it in the right schema in version zero. But we can take that offline too. Cool.
01:31:21.882 - 01:31:26.240, Speaker B: Any other questions for Lucas or Lucas? Do you have anything else to add?
01:31:27.410 - 01:32:08.490, Speaker A: Yes, you can try ape if you want and give us feedback on it. And actually, if you try ape and you think it's good and you want to keep it, like you want to work on it really hard, you can add a section to the debug tutorials on ape to basically help everyone understand how it works, understand how to set it up, and to give interesting patterns on how you could debug anything. That would be really cool. Sweet.
01:32:09.230 - 01:32:49.742, Speaker B: Okay, so we have a little bit of time. I wanted to show you guys a couple of things. Okay, so this is the release for Starknet. JS supports new transaction type version one only. Here's that commit. So if you go into some of these files, like estimate fee, there should be a transaction invocation type. Yeah, so invocation details.
01:32:49.742 - 01:33:18.430, Speaker B: Invocation details with knots. So check out the difference in those and how to instantiate them, and then I think your error will probably go away. And like Lucas said, I think there's some tests in there that give you examples on how to define them. Okay, cool. In the last little time we had here, yes. Can you drop man meet the link to this hash?
01:33:21.090 - 01:33:21.840, Speaker A: Okay.
01:33:24.930 - 01:33:25.246, Speaker C: Cool.
01:33:25.268 - 01:34:19.282, Speaker B: So that was super good to overview all the tools. One thing I wanted to mention, at least in my development activity, sometimes the testnet can be hard to work with just because the actual times and block times make things a little difficult, especially when the network gets bogged down. Currently, the Testnet currently is a little backlogged. So the cadence I would recommend is to have a unit test description in the way that Lucas showed today with the Python framework. But then the next step up as an integration environment, I always suggest using the Devnet. I think the devnet is a really crucial tool for developing starknet smart contracts. The block time is as fast as your local host, so that's one thing I really like using.
01:34:19.282 - 01:35:34.564, Speaker B: I'll just give you guys kind of a brief example of it. If you don't have it locally, it's called starknet Devnet, and if you want to run it, you just call the name of the package and you'll need to be in your Cairo environment, virtual environment. So Devnet spins up, it gives you a lot of useful things, like it comes with pre deployed accounts at these addresses, with this public key and private key funded with a certain amount of gas, so you can pay for transactions. So what I like to do is I like to run my unit test, see if my unit tests pass, and then if I need to go deploy instead of deploying to Testnet, I'll deploy to Devnet. You can do it through any of those, the tooling that Lucas showed today, or you can just do it with the CLI. So Starknet Devnet deploy or Starknet Devnet declare, and then you can still use a lot of the tooling. I'm not sure if any of the block explorers have added support for Devnet yet.
01:35:34.564 - 01:35:35.632, Speaker B: Do you know Lucas?
01:35:35.776 - 01:35:40.580, Speaker A: Not yet. Wallets do, but block Explorer don't.
01:35:40.740 - 01:36:31.444, Speaker B: Okay, so one thing you can do is you can use the Postman collection. There is a section here for Starknet Devnet, and you'll need to change your environment to Devnet, but you can check various different things. They expose a couple different APIs, check that it's up at its location, at its port, check the pre deployed accounts that have come with Devnet, a couple more things. Their documentation I'll send out, it's written by a team called Shard Labs here. They expose the JSON RPC API. So you can still use a lot of this tooling that we've used throughout basecamp just under the devnet environment. So even such things like the feeder gateway and the gateway API.
01:36:31.444 - 01:37:17.610, Speaker B: So you can check out what you can call the contract. So this is the ERC 20 for ETh on the devnet. I'll just show you what it looks like if we wanted to interact with a view function on that contract. So here's the contract address. The entry point selector, like we've talked about, is a hex encoding of the selector name. So let's say we wanted to check balance of get the selector for that, and then which address are we checking the value of? We will just check this last one. Account nine.
01:37:17.610 - 01:37:26.680, Speaker B: This gets into some of the hairy details of which encoding do you need? Do you need the integer or the.
01:37:26.750 - 01:37:27.480, Speaker D: Hex.
01:37:29.600 - 01:38:14.670, Speaker B: For passing this one in? You actually need the felt representation of it. So we'll just grab that felt. And now we're querying on the local devnet at listening at port 50 50. What is the balance of that contract in the ERC 20 address? So these kind of things I think are helpful to develop locally before you push your contract or deploy or declare your contract to Testnet, where you can kind of be stalled out and waiting for a while to get a response. Does anybody else, any of the dev advocates have anything to add as far as kind of their development flow?
01:38:15.970 - 01:38:21.650, Speaker A: Yes, there is a question when Testnet two do you want to answer? Ben?
01:38:23.190 - 01:38:30.146, Speaker B: Testnet two. Now it's out. Lucas, do you want to share the details of it?
01:38:30.248 - 01:39:29.670, Speaker A: Yeah, of course. So we've got an awesome website called Docs Startnet IO and it basically has all the documentation, maybe not all, but a lot of documentation that you will need. And it includes the documentation on Girly two. And I didn't send it to everyone here. The only thing missing here is the bridge address. To be able to bridge your funds to jolly two you'll need them to have Eth to pay for fees. And I think this is the address and this is dot, so I would need.
01:39:29.670 - 01:39:32.120, Speaker A: No, it is.
01:39:32.890 - 01:40:05.010, Speaker D: I will add something about girly too. It's a shitty name. The thing is, the network came up really recently. So as some of you may know, or maybe not, there's a lot of people building on Starknet and the network is not yet able to accommodate everyone. We're hard at work working on this, so just a heads up. When you're working on Testnet right now, Girly two is much less congested. It's much less congested because we deployed it recently.
01:40:05.010 - 01:40:20.520, Speaker D: It doesn't have a name yet, we just call it Curly two, which is not great. So I just posted now in the chat I can share it to everyone. Wait here, there's a request for.
01:40:21.370 - 01:40:22.018, Speaker A: Shit.
01:40:22.114 - 01:40:38.490, Speaker D: Just a sec. There's a request for naming proposals for Starknet, Testnet or Starknet networks actually. So if you want to get involved and give a better name to Girly two, answer there. We need your suggestions.
01:40:39.230 - 01:40:41.600, Speaker B: Girly two. This time it's personal.
01:40:43.490 - 01:40:45.950, Speaker D: Girly too. Starknet, Boogaloo.
01:40:47.730 - 01:40:49.120, Speaker B: Robson too.
01:40:49.730 - 01:41:03.830, Speaker D: Can you imagine? Honestly, naming in crypto is so fucked. We could actually give if we could call it Robston and it wouldn't be out of fashion to name it so badly that we would give the name of another network that already exists.
01:41:07.930 - 01:41:17.610, Speaker B: Sweet. What about any like Omar or David or Henry? Do you have any kind of like dev tooling dev local dev feedback?
01:41:21.630 - 01:41:32.686, Speaker D: No, we were talking about the bridge earlier. Do you guys shared how you debug the fact that your messages go through when you're using the bridge or.
01:41:32.708 - 01:41:33.520, Speaker A: Not really.
01:41:33.890 - 01:41:40.654, Speaker B: Not really. I just shared the starkscan message logs. But if you have something to add.
01:41:40.692 - 01:41:44.260, Speaker D: There so the message logs shows message that didn't go through.
01:41:45.830 - 01:41:52.146, Speaker B: I believe it'll show a status update at the last.
01:41:52.328 - 01:41:59.670, Speaker D: The question is what happens if I send a message that is badly formatted and the l one and lur fails the main issue.
01:41:59.740 - 01:42:00.166, Speaker A: Right.
01:42:00.268 - 01:42:04.278, Speaker B: Okay. No, we have not talked about it.
01:42:04.444 - 01:42:27.182, Speaker D: Okay. I know Luca has a better way to do it. I'll just share what I do. When I do this kind of stuff, I create a dummy contract on l two that just receive a payload with l one alert, that is ping, and it emits an event. So when I'm triggering a function on l one, then I wanted to send something to l two.
01:42:27.236 - 01:42:28.638, Speaker A: I will call ping and then I.
01:42:28.644 - 01:42:49.382, Speaker D: Will send another message to the contract I want to send a message to so that I know when the payload was transmitted on l two. So if I see ping and not the message I'm sending, then I know that something was transmitted, but that my function didn't work. It's a bit hacky, but that's what I do. Luca, I know you have a better workflow, right?
01:42:49.436 - 01:42:58.460, Speaker A: Yeah. So the real way to do it is to compute the transaction hash of your message and you can do it.
01:42:58.910 - 01:43:02.140, Speaker D: It'd be great to have a script for that.
01:43:02.830 - 01:43:07.260, Speaker A: Actually, we do. I'm not sure if it's up to date.
01:43:07.650 - 01:43:08.670, Speaker D: Where is it?
01:43:08.820 - 01:43:19.486, Speaker A: It's on stack overflow. Let me get the message. This is it. So that's an easy pull request to.
01:43:19.508 - 01:43:29.086, Speaker D: Do for one of the students here, right? Take the script, add it to a tutorial or something, and just make it usable so that you can debug your messages easily.
01:43:29.278 - 01:43:40.134, Speaker A: Yes. And it could be a nice pr to Nile. I think they're looking for this kind of stuff to ease experience.
01:43:40.252 - 01:44:39.270, Speaker D: That's something that is really interesting for most of the developer user experience for writing smart contracts, we stand on the shoulders of giant because designing smart contract is something that was really new and it took a bunch of time for Ethereum to come up with proper tooling, stuff like foundry testing, stuff like that. And so now we know what works and what doesn't work. And so even though Starknet is newer, we know where we should go to to at least catch up with Ethereum. But for cross chain communication, nobody really did that before. So all the tooling to create cross chain communication applications and make it efficient is still yet to be built. So this kind of script and this kind of tooling, I think need to be built and need to get much better. I think another thing that is going to need a specific tooling is client side proving.
01:44:39.270 - 01:44:44.170, Speaker D: But that's another topic anyway.
01:44:44.240 - 01:45:35.930, Speaker A: Yeah, that's another topic. Yeah. Basically you can use this python script to compute your message. Transaction hash. So basically what you do is that you send your message from l one to l two and you have the payload and whatever information that's needed and you just copy paste them in the script to have your l two transaction hash. And when you have your l two transaction hash you can just query, star scan, view block, Voyager, the feeder gateway, whatever you want to have the status of the transaction. If it fails, you will have the error message, which I think is really convenient, but Henry might think otherwise.
01:45:36.590 - 01:46:01.060, Speaker D: Oh, I think it is really convenient. I agree with you. It's just know in my workflow it's much easier to do it that way because I get immediate feedback. If I had something where I could run a command really easily, I would do it. It's just that I don't have an easy way to do. It's probably something that should be in our cli or something. I don't know.
01:46:01.060 - 01:46:06.774, Speaker D: I just shared what I did because it works, but I know you can always do it better.
01:46:06.972 - 01:46:14.790, Speaker A: Yeah, that's the information for messages.
01:46:15.530 - 01:46:41.170, Speaker B: Sweet. I know a couple of people were looking for the link for the debug tutorial. Any of the tutorials we're doing in the off days will be at the top of the camp that we're currently on. So for this one, Starknet debug will show you that tutorial. That's the homework. There's no graduation requirement for that one. It's a helpful tutorial to show you how to debug locally.
01:46:41.170 - 01:47:20.110, Speaker B: Yeah. So as far as administration stuff, David sent out a feedback request form. So if you wouldn't mind taking the time to give us some feedback on today's session. Next session? Next Thursday is our last session of basecamp, so keep an eye out in the discord. We're going to send a form out. That form is going to have graduation requirements in it. So we're going to need your argent wallet or whatever starknet wallet you're using the address to verify that you've done the tutorials.
01:47:20.110 - 01:48:15.150, Speaker B: We're going to want the pr or commit hash of whatever pr you've done to our repositories or whatever repository you made as an educational resource. And so we'll verify that you did the graduation requirements. And then for those of you that do have it already, for next Thursday's session we have about 30 to 40 people, so I don't think everyone's going to be able to present. But if you are interested in presenting to the base camp cohort what you've done what you have. Reach out to me or David or any of the dev advocates here and we'll have some time for you guys to present what you've done. Yeah. So if you've done all of that, we'll also in that form have a place to put in your address.
01:48:15.150 - 01:48:29.940, Speaker B: Completely optional. But if you do want some swag for all the hard work you've put in here, you guys definitely deserve it. So thanks for joining today. Keep an eye out on the discord and that's all I have. Does anyone have anything else to add?
01:48:32.550 - 01:48:42.580, Speaker D: Nope, everything good on my side. Thanks Ben for hosting. Thank you Luca and David for talking and looking forward to seeing everyone next week.
01:48:43.430 - 01:48:43.938, Speaker B: Awesome.
01:48:44.024 - 01:48:47.450, Speaker A: And to have the next song from Henry.
01:48:48.350 - 01:49:07.720, Speaker D: Yeah, for sure. I'll see what I can do. A mixed tape about Starknet. How nerdy at this one though. Anyway, cool. Have a safe weekend. Stay away from Twitter and drama, eat well and rest a little bit.
