00:00:00.330 - 00:00:50.990, Speaker A: It's YouTube. All right, so apparently I'm live on Twitter and Twitch and on YouTube. This is a bit intimidating, but it's going to be fun. I'm not sure how many people will show up, but I guess we'll see. Cool. All right, so I'm not sure if I should wait a bit. So let me wait five minutes if you're here, basically, this is the first for me.
00:00:50.990 - 00:01:42.468, Speaker A: I'm going to show you a project that was done on Starknet a while ago by some builders in the space. And it's a puzzle. So basically it needs you to read code, understand it, maybe write a bit of code, try to figure it out and make it work. So I'm basically going to look at this comment, what I do, you can follow along and I'll share the repo of what I do eventually. Yeah, actually it's recorded, so I'm just going to start. Let me just close the window behind me and you should be able to hear me. You can write your questions also in the chat.
00:01:42.468 - 00:02:11.268, Speaker A: I guess I can read them directly from streamyard. So happy to take them and answer. So, yeah, let's start. I'm going to share my screen. Going to share my full screen. No, I'm going to quit slack and emails first. Okay.
00:02:11.268 - 00:02:34.184, Speaker A: Voila. You should see my screen now. Well, you should see streamyard. So what are we doing today? So we are working on solve to mint. So solve to mint is. Well, the first interaction you might have with solve to mint is this. I'm going to post it here.
00:02:34.184 - 00:03:13.220, Speaker A: Not sure if you guys can see this. And so the first interaction you'll have with solve to mint is this interface. Right. So what is it exactly? You have a link to their discord? There is an article here on mirror explaining what it is. So I'm not going to go over it by reading, I'm going to explain it quickly. But basically, soft to mint is a set of smart contracts that are deployed on Starknet in Testnet. And they leverage a physics engine that was written by the folks at Topology.
00:03:13.220 - 00:03:52.310, Speaker A: Topology being this company, you should give them a follow. Giving them a follow. Right now they're really building interesting stuff. They released an interesting new game and primitive called Isaac, which is also based on the physics engine we're going to study today. And they've done softmit in partnership with Matchbox. Dao should give them a follow also, which is basically a Dao for on chain games and on chain gaming primitives. So they do a really cool job at onboarding people and having them.
00:03:52.310 - 00:04:26.552, Speaker A: I'm wondering if people can hear me, but I hope you can. Let's see, I'm going to check on YouTube real quick if your sound appears correctly. Yes, there is a sound. All right, so you can hear me. That's good. So basically they did this game in partnership. So Matchbox objective is to build gaming primitive for Starknet that leverage the high computation of Starknet.
00:04:26.552 - 00:05:04.484, Speaker A: And they also do a lot of onboarding. They help new devs get into the space, contribute to projects and work on fun stuff. So they did this project together. So what is soft to mint? You wouldn't know necessarily by the UX, but basically soft to mint is pool game. So you have a table and you have four balls on the table. I have a whiteboard behind me, so I'll probably try to joe some stuff later on. And it's a pool game where you have four balls and you can imprint some velocity on one of these balls.
00:05:04.484 - 00:05:37.024, Speaker A: Two balls give you points when you eat them and one ball resets the whole score, so you don't want to eat. And we're going to take a look at how it works. So, first of all, here you can see, you can select a level, then you can imprint a move. So I'm going to send twelve and 500. I can send my move. And here you can see that Arjun X, I'm using Argentine X here. Gives me some feedback.
00:05:37.024 - 00:05:59.596, Speaker A: So the first thing to notice is this. See, I entered twelve, but it added a bunch of zeros behind it. So we need to be careful with that. When we will be using the UX. We shouldn't put the actual data I want to send. I should remove a bunch of zeros. I'm actually going to take note of this here.
00:05:59.596 - 00:06:15.650, Speaker A: So this is however much zeros I need to remove. Right. And here the transaction is predicted to fail. We'll check that in a while. For now. Okay. So I could just shoot here in the dark and see what happens.
00:06:15.650 - 00:06:46.990, Speaker A: But I'm not going to do that because it's going to fail miserably. Or actually I could. You know what? Why not? And I'm going to send this. Do I have ETH here? I need ETH to send transactions on testnet. I added my address here to the faucet a while back. Let's see if I've managed to get some funds. I'm going to ask for some here.
00:06:46.990 - 00:07:28.970, Speaker A: All right, so I'm sending a respect, no more money in the faucet. Well, I'm going to cry to a colleague to ask for girly ETH in a sec. All right, so in the meanwhile, you know what I need ETH. So I have an old account here with some money, theoretically. So I'm just going to transfer it to my new account. So I have this much I still need to pay for a fee. I'm going to hope this works.
00:07:28.970 - 00:08:12.470, Speaker A: Seems a bit slow, but it looks like it work. So let's see. All right, so I should receive girly Eth on l two. First thing to start working is to actually be able to pay the network fees. Right. Then I'm going to take a look at the actual contracts of salt mint. I'm waiting here because I want to have the transaction id to check it, that it worked correctly and this is taking some time.
00:08:12.470 - 00:09:00.790, Speaker A: All right, not good. Let's try again. Maybe it was less, who knows? So here, maybe you've seen this pop up in your azure x. There was recently a change in starknet which makes your old account not usable anymore. And Arjun X is offering you to transfer your assets. You have a limited window of time to do that. You might not be able to transfer all of your asset and you might want to reuse your asset, your account with, I don't know, your Cli or Javascript or whatever.
00:09:00.790 - 00:09:53.942, Speaker A: If you want to do that, you should check our repo because there is a tutorial that was made by Luca here, basically allows you to transfer assets using key that you can extract. So it's a tutorial, you get points using that, but it's a tutorial, you can collect points, but even if you don't, there is actually useful code inside of it that can help you extract your older Arjun account. All right, now let's take a look at softements. Contract check if there are questions. No questions. All good. All right, so there it is.
00:09:53.942 - 00:10:19.920, Speaker A: I got the leaderboard, a bunch of people. Okay, now let's check the contract. Right, so this is the article, this is the GitHub. All right. A small set of instructions, so to be fully transparent. I did solve this before, so I know what I'm doing, but I'm starting everything from scratch. So I'm going to redo a new repo and write all the code as we go along.
00:10:19.920 - 00:10:42.246, Speaker A: So instructions read through the game. Cairo levels, Cairo and other contracts. Use any programming language or tool of your choice to find a unique solution to any of the level. Can you beat the current high score? I hope so. Register through sns. I'm going to be lazy and not do that. Submit your solution through the puzzle front hand.
00:10:42.246 - 00:11:00.750, Speaker A: Okay. And join the discord of course. All right, so game Cairo levels Cairo. There they are. So the first thing to notice is that this is not the root of a repo. We're in the repo of fountain, which is the physics engine written by topology. This is just an example.
00:11:00.750 - 00:11:36.518, Speaker A: Right. It's called puzzle v one. So let's take a look. So what is inside game Cairo? All right, so this is the global usual syntax for Starknet. Contract a bunch of imports an interface to interact with their naming service. I'm going to make the font a bit bigger to make sure that everyone is able to read correctly. All right, so now what do I see? Okay, a structure called solution record.
00:11:36.518 - 00:11:50.478, Speaker A: All right, so discovered by, that's going to be me. The level, that's the actual level. Solution family. I'm not sure what that is. We'll discover later. Score how much I did and block number when did I found it. Okay, cool.
00:11:50.478 - 00:12:16.280, Speaker A: Then a bunch of storage VAR how many solutions were counted. Okay, that's self explanatory. Solution record by id. Okay, so each solution record here gets an id. That's a view for how many solutions were found. And that is a view where you provide the id and you get a solution record. Okay.
00:12:16.280 - 00:13:04.870, Speaker A: And that is actually a view to see all the solution records. So you can pull all the solution records with a single view function. That's helpful actually, let's try it because I'm guessing here I have the records and here the addresses are here. Game Cairo. So if I go for example to Gordy Voyager online and I want to check a contract, I'm so lazy. I'm just trying to do this. Copy paste this here, right, read contract here I can see all the methods.
00:13:04.870 - 00:13:27.286, Speaker A: View solution records. I should get them all. It's going to take a while obviously, but it should appear. Yes. So here for example, you see it returns an array. So I get member one, and here I have the address, the level, solution family score and number, and then I have all of them. That's useful.
00:13:27.286 - 00:13:53.138, Speaker A: I'm going to be able to look at all the records that were published. All right, so now let's see, I have a function to return these as HTML. I'm not sure what's this used for? I'm going to leave it aside for now. So what's this? It's a recursive function that's used just above. Okay. And now I have an external function submit move for level. Interesting.
00:13:53.138 - 00:14:25.102, Speaker A: So this is probably what we're going to call right, this is where the meat is. So this is where I'm submitting a solution. So I'm calling with a level, a move. So two coordinates it seems, and then it returns. Basically a solution regarding is it a solution? Is it new? The solution id the solution family and the score. Cool. So what does it do? Move gal equals vec two.
00:14:25.102 - 00:15:21.120, Speaker A: So what is vec two? Vec two is imported from contract structs. So let's see what is in contract structs. Structs. So what is vector? All right, so it's just a vector with coordinates, right? And I was here, okay, so it seems like this is a velocity, right? So basically what I'm sending is not a position, it's a velocity. So I'm imprinting the velocity on a ball. First function that's called isertly equal velocity, right? Where is that? It's in example, puzzle one level. So it should be at the same root as these things I saw before.
00:15:21.120 - 00:16:10.766, Speaker A: Let's see, puzzle one. It's in levels. So assert liquid velocity. It's here. So I'm sending velocity here. And what does it do? Okay, so this is a constraint. So basically vx square plus v y square must be inferior to twice 150 times fp square, right? What's fP? Okay, so basically what it's doing is it's calculating this thing which is v square, right? Wait, okay, so it's this, it's this side of it.
00:16:10.766 - 00:16:35.590, Speaker A: So this v square is this side of the equation, right. It's not exactly v squared, but squared I'd say. And then small typo, illegal initial velocity, magnitude out of bounds. So assert lower equal. So we're checking that this is below this. What's fP? Let's see, what is fP? Okay, contract constant. So it's a constant.
00:16:35.590 - 00:17:02.410, Speaker A: I'm checking it. This might come useful later on. Constant, okay, fp times to ten to the power of twelve. Take notes here. Take notes of what this is. Number of zeros in Solomon ux. So that's fP.
00:17:02.410 - 00:17:48.490, Speaker A: I'm going to take note also of the constraints on assert legal velocity, I think, because that might be useful later on if I want to calculate this. All right, so cert legal velocity. And that's basically this. I'm going to note it in Cairo because it's more explicit to me than this. All right, so let's take a look while we're there in levels Cairo. What else is there? So there's only one other function which is pull level, okay. Public function to load a level, okay, there are levels.
00:17:48.490 - 00:18:20.086, Speaker A: Right. In softer mint. I can see here there are five of them. And what is actually return when I call pull level. So I specify an id and it gives me a level state. Level state is basically a struct with, I'm guessing, the position of each ball. So here, this is not very explicit.
00:18:20.086 - 00:18:41.914, Speaker A: They use the same structure to symbolize position and velocity. Right. You saw before that vec two was used for velocity, and now it's used for position. So that's not very explicit. But these are positions basically. Right. So for each level, we know where score zero ball is, score one is four bit ball is, and where player ball.
00:18:41.914 - 00:19:17.610, Speaker A: Okay, so when I'm imprinting velocity, I'm going to imprint velocity on player ball. These two balls apparently give me score and forbid ball is, I guess, the ball I'm not going to want to touch. And these are there for their position. So I'm guessing fp is used kind of a resolution constant. So to make the map bigger, but not have to deal with huge numbers. So we'll consider these as the position, like, right, 6160. And so here you can basically get a sense of where your balls are.
00:19:17.610 - 00:19:44.902, Speaker A: Right. So we'll come back to this later on to check when we actually want to manipulate the ball. And we figured out how the contract works. We'll go back to this contract to actually see where they are and see how we can do this. Okay, let's go back to game. Okay, so circle equal velocity. So here we check, basically that the move I'm sending, the velocity is not too big.
00:19:44.902 - 00:20:12.970, Speaker A: So there's an upward bound on how much velocity you can imprint. Okay, then we're pulling the level. We just saw that. So basically, level state is the position of each ball. Assemble initial scene and state parameters. All right, so this is hard to read. Basically it's doing an array with four values.
00:20:12.970 - 00:20:48.234, Speaker A: So what is this? Okay, so it looks like they're actually making. Okay, so it looks actually like for each ball, they're building three values. One is the position, one is the velocity, and one is the acceleration. Right. Does seem like this is what's happening. So here they're just taking from the level state we pulled before the position of score zero ball. Right.
00:20:48.234 - 00:21:04.954, Speaker A: Score one ball. Score zero ball. And here, this means that this ball has zero velocity, zero acceleration. This one also. This one also. And this one, which is player ball. Okay, so it has a velocity.
00:21:04.954 - 00:21:32.566, Speaker A: So you're imprinting velocity and zero acceleration. Okay. So it means that you're basically sending. So you're basically imprinting suddenly, a move on your ball and it has zero acceleration, so it's only going to decelerate from that. All right? And then you have constants. So I know what these are. It's a bit hard to figure out later on.
00:21:32.566 - 00:22:21.682, Speaker A: So I'm going to explain now, basically, the way solve to Mint works. It's a physics engine, right? And so you want to calculate the trajectory and the relative positions of objects in space. Calculating the trajectory of an object is not something like, you can't do it analogically, you can't determine the position everywhere. So basically, you have to choose a division of time, right? And this is DT. So you're choosing how much time passes for each iteration, where you're going to interpolate the position of each object. So if the object is going from position a to position b, you're not going to calculate the position everywhere, you're going to sample it. Right? So it's going to be a discrete series of measure.
00:22:21.682 - 00:22:54.830, Speaker A: So DT is how much time passes between position and cap is how many times. You're going to repeat this interpolation because you're not going to say to the physics engine, calculate the trajectory from here to there. You're going to say, hey, because you don't know what there is, you don't know the final state. You're just going to say, hey. Here are the condition. Iterate one step. And what cap is, is basically cap on the number of time you're going to repeat this so that your transaction doesn't fall out of gas.
00:22:54.830 - 00:23:15.430, Speaker A: Right. So what we're doing here is that we're saying, okay, so we're going to sample the position of our ball every zero point 15 fp. And we're going to do it at most 40 times when we're playing. Right. All right, I hope this makes sense. Let me check. There are no questions.
00:23:15.430 - 00:23:29.214, Speaker A: There are no questions. Okay. And there are not much of a lot of people watching. So it's fine. If you have questions, feel free to ask them. I'm happy to answer them. And, yeah, we'll see.
00:23:29.214 - 00:23:54.258, Speaker A: All right, so now he's allocating an array of length seven. What is in this? Okay, so radius. And that's not very explicit, but that's the radius of each ball. So each ball has a radius of 20 times fp. That's, I guess, something that is useful down the line. Let's see. X min, x max.
00:23:54.258 - 00:24:26.842, Speaker A: Y min, Y max are basically the size of your board. So X min means that if you want your objects to move in a Grid zero is the limit on x. 250 is the limit, the upper limit on x. And the same thing for y. It's zero and 250. You're basically playing in a square board of length. It's square and it's 250 in length and frictional acceleration.
00:24:26.842 - 00:24:50.294, Speaker A: I'm not 100% sure what that is, but I guess it's related. I mean, like it's friction. So I'm guessing this is something that would decelerate your ball in time. All right, we're getting into the meat of it. Run simulation. Simulation. All right, so what is it doing exactly? So we are retrying a bunch of stuff.
00:24:50.294 - 00:25:39.960, Speaker A: So an array, which is array objects and an array of records. Okay, so we're getting back here, the states of each ball at the end of this function call. And here we're retrieving an array of all the collisions in the scene, right? And we receive that by calling this function. So forward scene capped counting collisions. So it's basically a wrapper that is going to forward the scene up until a max number of step named cap. Right, and it's made specifically to return the collision record because we're interested in collision. We'll see that later on.
00:25:39.960 - 00:26:16.542, Speaker A: Okay, you know what? Let's dive into that later. First, let's see what happens in the global function, and then we'll dive later on to see what happens. All right, so here we have the final object, the final state, and here we have the final collision record revert if scene is not reset after one transaction. Not sure what that means. Okay, so check if is solution score in non zero at the end of the call. Okay, so we don't have score here. So first is going to calculate score.
00:26:16.542 - 00:26:40.540, Speaker A: So he's going to take score. We're going to look at that later on also. And then he's going to check if a solution. So he's going to check first. He's going to check if it's a solution. Right? So he's going to check if the score is different than zero. Oh, yeah, sure.
00:26:40.540 - 00:27:02.898, Speaker A: I'm not sure why this is useful. Because you could just do like it could use score instead. Oh, no. Because here it needs solution to be either one or zero. Right? So in score can be probably bigger than one. Right? So here it's basically a boolean to check whether the score is different than zero. Okay, so we want score to be different than zero.
00:27:02.898 - 00:27:53.250, Speaker A: Understood. Now obtain family number and check for a general entity naively using on storage array. Not going to pretend I understand what that is. All right, so, serialized collision record to family. So this family, it looks like this family number is a unique identifier for the array of collisions. Okay, so basically the trajectory and all the collisions, when you're sending your ball and going to generate a unique identifier for your solution to solve to mint. And then you're going to check how many solutions were found in the past, and then recurse, check for family collision is solution family new.
00:27:53.250 - 00:28:30.670, Speaker A: Okay, so we're checking if your specific list of collisions when you send your ball is unique if nobody made the same move as you did before. So he's calling a function to basically iterate over all the solution and check if. Is this the right one? Is it the same one? Is it the same one? Is it the same one? So you're sending the level, the target, which is this family. Right. And then the length and the index. Okay, I guess you could have made a storage VAR where you have the family as an identifier, and you basically store one or zero, maybe. I mean, it's storage.
00:28:30.670 - 00:28:49.790, Speaker A: Yeah, it's more storage, less efficient. Okay, makes sense. And then basically, cert non zero is familiar new. Okay, so basically, this means two things here. This is what is. It's an important part, actually. So this means that this will fail.
00:28:49.790 - 00:29:35.122, Speaker A: Assert not zero. It will check if is solution family new and is solution are both different than zero. So it means that your move has to be valid, and it also means that your move has to be unique, which is not ideal, because if your transaction fails, you don't know if your solution was valid, so you're in the dark. Or if your transaction failed, you'll get the same error whether your solution is valid or your solution is not unique. Maybe there are evidence solutions. You could try them, see that they work, and you understood the physics, but they're not unique, and so you're kind of screwed. Okay, so this is something I might need you to tweak in the future.
00:29:35.122 - 00:30:14.270, Speaker A: Spoiler I will. All right, if not reverted. Houston, we have a solution. So, basically. All right, so he's getting my address, getting the block number, and then he's just writing that we find a new solution and is recording my solution with its id, and it returns. All right, I understand now. So this means that when I call this, I want to have collisions, right? And then when I call this with my collisions, I want this to return something that is not zero.
00:30:14.270 - 00:30:35.320, Speaker A: So, first, let's look at this one. Calculate score from record. Where is it and what does it do exactly? Right. Okay, so I'm sending my collision record here, and it returns a score. What does it do exactly? It's called. Okay, so it's a recursive function. Does it do.
00:30:35.320 - 00:31:02.174, Speaker A: So I'm sending it a collision array with its length and the index at which I'm checking. Right. And the score. Right. That's what it's doing. Yeah, and it's initial aging with the score and the index. So what does it do? So if I'm at the end of the array, it just returns the current score, and then.
00:31:02.174 - 00:31:31.110, Speaker A: Okay, there is a new function. Parse single collision record. Actually, I might need to check what is a collision? Because it's a felt collision. Should be a felt. Right. It's a felt array. All right, so when I call this parse single collision record, I get is reset and score increase.
00:31:31.110 - 00:32:00.640, Speaker A: All right, so if is reset is set at zero, then it resets the score up until this point. Otherwise it adds. Okay, so basically, every time there's a collision, it can reset it or not, and it can increase the score, and then the final score is the function recursing over itself. Understood. I hope it makes sense for you guys who are watching. All three of you. How crazy.
00:32:00.640 - 00:32:33.398, Speaker A: Okay, so let's see. How do you calculate the score? And if it's reset in a single collision record, right, so I'm sending the record, it's a felt. Right. And then I return the score. And if it's reset, okay, so if record is inferior to 16, it means I collided with the boundary. If it's over 16, it means that I have collided with something else. Okay, so basically, the function we saw earlier.
00:32:33.398 - 00:33:39.060, Speaker A: Let's see. Right? Where was it? Okay, so this one, this is where I'm getting my collision record. So here it's going to send back a collision record, and every time some objects interact with each other, it's going to get a specific felt, apparently. And here, each collision gives me a specific combination, I guess. Okay, so it means that if record is 19, it means that player ball collided with score 00:23 collided with score one. And 27, it collided with a forbidden ball. All right, so when I'm calling this function, basically what it does is it returns a number of unique identifiers for collisions.
00:33:39.060 - 00:34:22.310, Speaker A: And if I hit ball number zero, I get ten points and the score is not reset. If it's 23, I get 20 points. Okay, so it means that score one is the better ball score is not reset. If I hit 27 here, the score is zero and is reset is one, which is worse, actually, because it means that basically. Okay, so it means that if I hit ball zero, then ball one, then the forbidden ball, then I'm screwed. I get zero points, which is not what I want. I want points, but it also means that if I eat the forbidden ball first and then over balls, I'm good, I'm in the clear.
00:34:22.310 - 00:34:45.660, Speaker A: All right, so this is how the score is calculated. So moving back, I get the collision record here. The score is calculated here. Right. Recursively calling calculate score. Calculate score from record. And it's returned.
00:34:45.660 - 00:35:13.988, Speaker A: Sorry. And then the score, if it's a solution, I get one point. And then if the solution is unique, I can get points. Okay, cool. At this point, do I actually need to dive into that one? Time is flying and I'm not sure. I need to take a look quickly. Right.
00:35:13.988 - 00:35:30.330, Speaker A: Just a sneak peek. Not sure if people who are watching are curious to have me watch let down. Oh, I see some people are writing on YouTube. Okay. It resets the max cap every ten minutes. Oh, cool. So for the faucet, I'm going to try.
00:35:30.330 - 00:36:21.188, Speaker A: And Surab is asking, do I need to learn Cairo language to build on Starknet? You'll do better things if you do so I strongly encourage you to do so. All right, let's go into that. Contract contracts, scene forwarder array. What's the function we're looking for? This one. So this one is basically specifically looking for collision records. Then it's moving the simulation forward. Okay, so here, this is where we find back cap.
00:36:21.188 - 00:36:43.260, Speaker A: Right. It's the maximum amount of step we want to reach. Maximum number of iteration of interpolating the object position. And then we just forward the scene by one step. Right. This is here. Right.
00:36:43.260 - 00:37:13.540, Speaker A: So that's just one step. So here you're basically passing a series of object states. So this is where each object is. And possibly, actually you're just passing the state, right. And I think for object state, you have velocity and then you just have the collision record. Oh, my God. Okay, so basically here, object I've moved.
00:37:13.540 - 00:37:38.476, Speaker A: And you're checking who is eating who. Right. Okay, so you're just taking position and radius, stuff like that. Right. And you're checking whether they hit each other at some point in time. That's confusing. I'm not going to dive too much into that because I don't really need it.
00:37:38.476 - 00:37:59.410, Speaker A: What would be useful is to know. What would be useful is to know, basically how the record are calculated. So let's see. Do I get. Yeah. Collision record in steps. So this should be in that function.
00:37:59.410 - 00:38:22.008, Speaker A: This is returning a record the length. Right. That makes sense. It's in another thing, it's in the physics engine. All right, I'm going to take a look real quick. What's the name of the function I'm looking at? Probably this one. Right.
00:38:22.008 - 00:38:58.010, Speaker A: Actually it's written here. Okay, so for the position and velocity of one circle by one step with the older method, where the circle is bounded by an axis line box. So that's what this does, right. It moves a position by one box. All right, and so this return collided with a Boundary and C. Next. All right, so it's basically calculating the position and checking whether this collided with something, I guess.
00:38:58.010 - 00:39:37.924, Speaker A: What's the scene forwarder look like? Okay, so I not sure where to find this information. Okay, you know what, let's do it simpler. I'm here in game and I can see that. Basically I want records to be 19, 23, 27. Let's try and shoot a few balls. I think we have enough elements. We know we need to imprint some velocity and that our solution needs to be new.
00:39:37.924 - 00:40:17.824, Speaker A: So what I'm going to do is first I'm going to clone the repo on my computer. So I'm going to actually start live coding right now. I'm going to go inside of it and now open a window. What can I do with that? So the first thing I'm going to do is two things. I'm going to try some solution and see what comes out. And then I'm going to make my code better. So let's see here.
00:40:17.824 - 00:40:51.964, Speaker A: Okay. I need to open my environment because it's always a shame when I do these things, but I don't know, I prefer to copy paste it from the website. Boom. Now I can use Starknet, Lang, right? And so now I can basically send, starknet works, right? I can send comments. Good. So what I'm going to do is I'm going to try to call the, I'm going to try to call the submit move function, right. And send some shit here.
00:40:51.964 - 00:41:19.650, Speaker A: Okay. So I won't do it with an actual transaction. I think I can do call instead of invoke. So if I do invoke, it's going to actually send the transaction. If I do call, it's going to simulate the transaction and I'll get the result. So I'm going to do this darknet call. Okay.
00:41:19.650 - 00:41:42.444, Speaker A: Right. So what happens here? I'm going to need some stuff. So address Abi function. And I'm going to need the network also. All right, so I'm going to need the address of the contract on chain. Where is it? It's here, right? No, it's here. All right, so the game is here.
00:41:42.444 - 00:42:14.900, Speaker A: This is the address, right. So address is this Abi? Oh, I need the ABI. So I'm going to first do stocknet compile this compile work. Is it here? I think it is. So I'm going to compile the contract that is in Example puzzle view one and game Cairo doesn't like it. So I'm going to go Starknet compile, which is probably the good tool. Starknet compile contract.
00:42:14.900 - 00:42:47.440, Speaker A: It's an example puzzle game. Right. What's missing? All right, so that's a whole lot of takes I'm not going to paste. So I'm going to do basically this output. This means that solve to main Json. So this is the output. So this is the compiled contract and I'm going to output the Abi also to s two Abi json.
00:42:47.440 - 00:43:11.220, Speaker A: Did it work? Yes, it did. Okay, cool. So now I get these two files, right? So here you can see s two m is you have everything. So you have Abi entry point and everything. And here just have the Abi. So I'm going to use the Abi for now. So going back to the comment I was writing, abi.
00:43:11.220 - 00:43:33.568, Speaker A: So I'm going to work at the same thing in the same folder I was in the function. The function I want is submit move for level. Obviously I need to specify a bunch of stuff. This is going to fail, but let's try. All right, so it expect inputs. Yeah, sure. When I mean up.
00:43:33.568 - 00:43:52.630, Speaker A: Let's put the contracts here. I'm not sure you guys can see correctly my screen. So I'm going to make it a bit bigger. Let's check. Still no comments here. Five people watching. Not too bad.
00:43:52.630 - 00:44:14.270, Speaker A: Okay. All right, so where's my function? It's submit move for level. Right? It's here. Submit move for level. All right. What kind of argument does it expect? Okay, so free felt. So level move.
00:44:14.270 - 00:44:40.336, Speaker A: Okay, so let's try to just add level one. And I'm going to add move 23, then 24. Oh, but remember that the UX adds zero. So I'm going to add these behind. So that's the equivalent of putting 23 and 24 in the UX. What is he going to say? He's going to tell me that the network, I need to specify the network. So I'm just going to add this network.
00:44:40.336 - 00:45:26.600, Speaker A: Alpha girl, there you go. You didn't like this? Probably I should add this inputs. Let's see if this works. So this is taking some time. Yeah, girly, the toughness is pretty stimulated these days. So it's taking some time to answer. And now I have a whole bunch of stuff that popped back.
00:45:26.600 - 00:45:44.762, Speaker A: What is this saying? All right, so status 500. The transaction failed. The transaction failed. Error message is family. New times is solution should not be zero. All right, interesting. So this means that this was actually executed in the contract.
00:45:44.762 - 00:46:40.240, Speaker A: And if you remember, this is the error that is right here. Right. So either this was not a solution or either the solution was not new, which kind of sucks because I don't know which it is. Is it not a solution or is it not a new solution? So I'm going to, you know what? I'm going to take this function, submit move for level, and I'm going to duplicate it. And basically I'm going to turn it into a function that I can call and it will return a bunch of value that I'm interested in to debug my solution. So that way I can check first if my move is correct, and then I'm going to check if my move is new. Right.
00:46:40.240 - 00:47:09.160, Speaker A: So let's do that. And if I write a new function, I'm obviously going to have to deploy it somewhere. I'm not going to deploy it on testnet because it's going to take too much time. So I'm going to run the Devnet later on. All right, I need to change the name, obviously. So I'm going to do Henry function. Right.
00:47:09.160 - 00:47:38.706, Speaker A: Should I commit this code somewhere? Yes, probably. So what I'm going to do is I'm going to go on here, I'm going to fork the repo. Actually, let's fork it. No, Stocknet, Eddu. I'm going to call it fountain created. Right. And then I'm going to clone this one, actually.
00:47:38.706 - 00:48:07.720, Speaker A: So, no. And now I can clone that report, which I have pushed. Right. I'm going to create a new branch. So git. Branch new. How do you branch b? No, that's not b.
00:48:07.720 - 00:48:23.020, Speaker A: Git. No, it's git checkout. B solving, not slothing, solving. Right. I'm in branch solving. All good. I'm going to compile my program again.
00:48:23.020 - 00:48:36.430, Speaker A: This should work. Didn't change the repo in the meanwhile. This should work. Still, no question. More people watching. Good. Okay, now we're getting into the meat of the subject.
00:48:36.430 - 00:49:04.534, Speaker A: All right. It compiled, so now I can modify my contract. And actually, I think I made it smoothly. So that sublim text did not notice? No, it did. See, I need to paste it again. So I'm going to put this here, right, go back up. I've duplicated this function.
00:49:04.534 - 00:49:45.302, Speaker A: So now I'm going to call it this one. I'm going to call it test move for level Henry's fancy debugging function. All right, so let's first compile, right? Because I just want to make sure that I like to compile every time I do something that's not great because it takes some time. Okay, so it compiles. This means that this code works. Now obviously I just copied the function. That's not going to help me now what is it returning? So it's returning is solution, is solution family new? So I'm interested in both of that, right.
00:49:45.302 - 00:50:07.180, Speaker A: Solution id, solution family and score. It's actually pretty cool. That's what I'm looking for. An assert liquor velocity. So where are there asserts that trip me up. So I think we're going to go right after the one that blocked me earlier, which is this one. Let's remove it.
00:50:07.180 - 00:50:37.142, Speaker A: Right. Actually, you know what, at this point I'm pretty sure that this is just recording the solution, right. And I don't want to alter this. So maybe I can even delete this. Let's try it. Compile. It does.
00:50:37.142 - 00:51:25.254, Speaker A: Good. So now this basically means that I now have a function with which I can test my moves and I will receive isolution is solution family new count and this family, which is good. But let's see, if I do this basically and I deploy this, I'm going to know if my thing is a solution. But every time I'm going to try a new move, like it's going to start with a blank state basically. So it's going to tell me if my move is a solution, but it's not going to tell me if it's new or not, which is not great. And also I'm kind of shooting in the dark. I wish I knew more stuff about what I'm doing.
00:51:25.254 - 00:51:44.094, Speaker A: So I'm going to add some return function. I want to know more stuff. Like for example, I'm curious with what is in this array. So I'm actually going to just return this shit too, right? So I'm going to add it here in the return arguments. Right. This should work. I'm just saying.
00:51:44.094 - 00:52:00.340, Speaker A: Yeah, send me back an array also with all the collisions I made, right. This should work. No. And I'm going to put this here. Let's see. Does this compile? It doesn't. All right.
00:52:00.340 - 00:52:19.690, Speaker A: No, copy pasting is not always good, guys. Yay. It worked. So now I guess I have a way. I have more visibility. I can deploy my code. I'll know what collisions I made if it's a solution.
00:52:19.690 - 00:52:46.050, Speaker A: And if it's a new solution. You know what, for this one, let's figure it out later on. Okay, so now I have this. I want to deploy it and test my moves. So what am I going to do? Yeah, let's do the Devnet. I don't use the Devnet that often, so I'm actually just going to google how to do this shit. Starknet Devnet.
00:52:46.050 - 00:53:12.390, Speaker A: This is the repo by Stark, by shardlabs. Still no question. But it's okay. Don't hesitate if you have questions, guys. And let's see. Okay, so I've installed Devnet before, I don't need to install it again. Now how do I run it? So I just do Starknet Devnet.
00:53:12.390 - 00:53:41.410, Speaker A: Let's do that. I'm guessing I'm going to have to run a new terminal. So let's do that. I need to open up to basically activate my vm again in that window too. And now I can run the devnet. The devnet is working all right. So I have a Devnet working locally.
00:53:41.410 - 00:54:12.430, Speaker A: Now I should be able to deploy my contract. So I'm going to use stocknet deploy. I just do like two m dots. No, of course it doesn't work. So I need to specify the contract and the network. Maybe they have something for the network to specify it. Easy, easily.
00:54:12.430 - 00:55:11.336, Speaker A: All right, so I need to specify the gateway URL and the feeder gateway new URL. All right, let's copy paste this because I'm going to use it a bunch of times. Right. And then I'm going to need to specify this gateway URL and feeder gateway URL. Maybe I can find this, maybe I can just go be paste this. Will it work? Will this work? Who knows? And it's quite slow, I have to say. Well, that's the Devnet for you.
00:55:11.336 - 00:55:24.908, Speaker A: You can't ask it. I mean, the whole Starknet stack is fairly slow. Oh, it did go froze. So my contract was deployed. Now that's good. So now I have a contract address. Good.
00:55:24.908 - 00:55:42.636, Speaker A: So now I'm just going to take the same thing I did earlier. So this is the move that I know fails in solve to mint. I'm going to try to do this. I'm going to take the same gateway URL, feeder gateway URL. I'm going to put these here. Right. The address has changed.
00:55:42.636 - 00:56:02.010, Speaker A: It's not this. So this is the address of the contract, the abi. So I compiled it. It's the same one. And the function I'm going to call now is not submit move for level. It's test move for level. So when I do that, it should return me a bunch of stuff, which we'll see in a sec.
00:56:02.010 - 00:56:26.332, Speaker A: All right, let's see. All right. What is that mess? So what does my solution record is? Solution. No, it's zero. So it's not a solution. Is solution family new? Yeah. Nobody did that before.
00:56:26.332 - 00:56:49.216, Speaker A: So it's zero. There's zero collision. The family is called zero. The score is zero. And then there is zero collision. That's boring. But I know that my first thing failed because this was basically a dumb move, not because it was recorded earlier.
00:56:49.216 - 00:57:00.264, Speaker A: So now let's try to shoot a ball correctly. So let's see. Let's look at the levels. Okay. So let's try level. Yeah, let's take one. Like level one.
00:57:00.264 - 00:57:51.920, Speaker A: Right? So in level one, my ball is at 40 times 40. So at x equals 40 and y equals 40. And I want to eat either of these balls, but I don't want to eat that one. So if I shoot at this one, I have, on the x axis, I'm separated by 20. On the y axis, I'm separated by 120. And this one, like the forbidden one, is actually further away. It's on the same line in y as this one, but it sits behind this one.
00:57:51.920 - 00:58:16.816, Speaker A: So I guess there's a line between this one and this one. So I could shoot at this one and see what happens. Right. And if I do it, I'm going to see it in the collision record. Right? So I need to imprint velocity. I'm not going to bother calculating velocity, I'm just going to do it dumbly. Like, see, there's a difference of 20 here, so my move is going to be 20.
00:58:16.816 - 00:58:31.956, Speaker A: And here there's a difference of 120. So my move is going to be 120. Fancy. So let's see. So this was 23. So this is now 20, and this was 24. Now this is 120.
00:58:31.956 - 00:58:58.956, Speaker A: Let's see what happens. And what matters here is not really the direction is going to be a result of the ratio between both values. So I could divide them both by two and it will still go in the same direction. So if I get no collision, I'll just multiply it by two. If I'm above velocity, I'm just going to. If I'm above velocity, I'm going to divide it by two. If I don't hit any ball, I'm going to multiply it by two.
00:58:58.956 - 00:59:17.516, Speaker A: Okay, cool. Luke, I have some values here. One again. What's this? So is solution is one. Okay, so this is a solution. Wonderful. Is it new? Okay, what's the score? I want to know my score.
00:59:17.516 - 00:59:29.700, Speaker A: Okay, so, family here. This is the identifier. This is the score. So I scored 20 point and there were two collisions. Right. This is the collision record. So this is the length of the collision record.
00:59:29.700 - 00:59:53.084, Speaker A: And these are the collisions. One which is 23, and one which is eight and. Right. Remember that? If I look at 23 here, it means I did hit ball. Score one, which makes no sense. I was shooting this one, dude. I have no idea why I ate ball one instead of ball zero.
00:59:53.084 - 01:00:23.130, Speaker A: But hey, you know what I did? I ate it. It doesn't matter. Let's look at it. It makes no sense. How could I miss it? All right. Yeah, I don't understand that. Let's see in a sec.
01:00:23.130 - 01:01:14.760, Speaker A: What is it? Well, as you remember here, it says, basically, if it's under 16, I hit a wall. So it probably means that I hit a wall at some point and that it's another ball. But I see this makes no sense. Went from 40 to 160 here. They're all in a line here, by the way. So, not sure if you guys can see me, but, yeah, I'm puzzled. It seems like I basically missed this one, then hit the wall above and then hit this one.
01:01:14.760 - 01:01:45.818, Speaker A: But that. Wait, no, I was looking at level zero and here I entered level one. Okay, so it's good. I know I have a solution in level one, but that's why it's not the one I was looking for. Let's try again now, it should be more coherent. Instead of level of 23 here, I should see 19, which is when I hit ball zero, right? Yes. So it's a solution.
01:01:45.818 - 01:02:03.460, Speaker A: Id is five, three, six. Now level. The first collision is 19. This works. Now let's test it on the live solve to mint on testnet. Sorry. So you know what? I'm just going to take this one here.
01:02:03.460 - 01:02:18.540, Speaker A: This I'm including submit move for level. Right. I can reuse the same API because what matters is how this function is formatted. And I'm going to say a. Here's the input. So let's see. And let's see what it says.
01:02:18.540 - 01:02:51.970, Speaker A: So what does it say? I'm pretty sure this move is fairly basic and somebody probably did it before me. So we'll see. Something interesting to see, though. Yeah. See, basically this move was done by somebody else before the good news, though, is now that I can validate my moves and then send them to see if they were done before, something else I can do. See here, this is the identifier. This is the family.
01:02:51.970 - 01:03:27.840, Speaker A: So instead of just calling dumbly here, I can go on the solve to mint instance on Voyager. You remember we did that before and you have a method to pull all the solution records, right. If I call it, it's basically going to tell me every single collision that was recorded. So I'm pretty sure if I look for five, three, six. Yeah, see, somebody submitted it before. Not the first one, funnily enough. So now my challenge is going to be to find a move that nobody has done before.
01:03:27.840 - 01:04:18.238, Speaker A: So what can I do? Something interesting. What matters is not like in the family identifier. The family depends on all the collisions. So not just the balls you hit, but all the balls and the walls you hit during your move. So it means that, for example, maybe if instead of shooting straight at ball zero, I were to shoot at a wall to then have it come back on ball zero, then this would be a new family. So I could try that. How do I do that? This basically means that instead of.
01:04:18.238 - 01:05:08.832, Speaker A: I wish I could draw here to explain, but basically it means that if I want to shoot at the ball at 60, I need to shoot a bit before it probably at like 50, because that's half the speed I need here. Right. But then what matters is also the velocity I'm going to send. Let's try to, instead of doing 40, instead of trying to hit the ball at 60 here, I'm going to try to hit it at 50. So here I'm just going to say, instead of sending 20, I should send ten. This will basically make it so that my ball first hits a wall and then hits the other ball. All right, so let's wait.
01:05:08.832 - 01:05:38.504, Speaker A: Let's see. I may have done a mistake, but. No, see, it works. Now, look, it didn't really work. I'm guessing it kind of worked. No, I think my calculation is incorrect. Basically, if I wanted to do an arc and then reflect, I should just take the second arc and mirror it above.
01:05:38.504 - 01:06:03.972, Speaker A: So if I actually want to do it correctly, I need to target a ball that is like here, this ball, right, is. Okay, 40. You know what? I get a solution here. Let's just check if somebody found it before. Maybe. Who knows on a. Nah, somebody found it.
01:06:03.972 - 01:06:28.910, Speaker A: Okay, it's fine. So my ball is at 40. 40. The one I want to hit is slightly above, slightly there. So actually I need to basically hit a wall and then I have it come back. So I'm going to try to hit a ball that is. That is.
01:06:28.910 - 01:06:50.432, Speaker A: I want to hit the wall above here. So I'm going to hit it in the middle. So I still need ten. Now what matters is the y. So I want to go from 40 to 160. I'm just going to take the difference between 250, which is the top of the square, and 160. So that's 90.
01:06:50.432 - 01:07:22.030, Speaker A: And add it to the previous velocity I added, and that should work. I'm not sure that makes a lot of sense to you guys, and I apologize for that. So that's 120. That's the difference I wanted to reach, but now I kind of want to target a ball that is kind of like as if it was behind. So I want to hit 120 plus 90. So that's 90 plus 90. That's 210.
01:07:22.030 - 01:07:49.030, Speaker A: But I'm guessing that if I want to do this also, like, for this one, also, let's try this. Let's try this and see if it works. It's hard without drawing on a piece of paper, but we'll see. Maybe this works. I should eat the wall before. And again, what matters here is that I find a new solution so that I can brag. Oh, interesting.
01:07:49.030 - 01:08:13.612, Speaker A: Like, for this one, there's ten collisions. The score is still ten. There's ten collisions. So interesting. Let's see if this solution is taken. But you can see that I first eat a wall and then I eat ball 19. My thing worked.
01:08:13.612 - 01:08:48.810, Speaker A: I'm psyched. And then there were a bunch of other collision, I'm guessing because I shoot it quite strongly because I imprinted more velocity, then there were other stuff that eat each other, right? Basically just trying to eat one. And then we'll see what happens now. Okay, so I want to check this. If this appears here, I could convert it, or I could just paste this in, solve to maintain, see if this works. Like, right, this is probably faster. I'm just going to paste it in the testnet and see if this solution is taken.
01:08:48.810 - 01:09:21.808, Speaker A: So that's ten, 210. Please don't steal my move. If it works. Anyway, there's not a lot of people watching anyway, so I doubt somebody will front run me on this. If you do, good for you. But I hope you don't break my tutorial just to claim fake Internet points before me. All right, it's taking some time, and Darknet said basically, no, too much for me.
01:09:21.808 - 01:09:34.896, Speaker A: Okay, I'm going to try it again. Let's see if there are comments on YouTube. Okay. Some people are watching six people on YouTube. Hi, guys. And then some people on streamyard. I'm not sure who's looking anywhere.
01:09:34.896 - 01:10:01.190, Speaker A: I haven't checked Twitter or twitch, so I'm just going to keep doing some. I'm going to check twitch on my phone. I'm going to check Twitter on my phone. Quick, quickly, to see if maybe some people have questions. Or I could do it from my computer also. Right, let's go to my profile. Are there some comments? No comments.
01:10:01.190 - 01:10:23.150, Speaker A: That's fine. If you want to comment here, don't hesitate. And look, it worked. It basically said, so that's the alpha girly deployment. If I submit ten times 210, this will work. Okay, I'm just going to do it quick before somebody steals it from me. My precious.
01:10:23.150 - 01:10:45.530, Speaker A: So that's level zero and 210. Submit my move. I hope nobody steals it. Please let me complete my tutorial. I'd be so happy. Fuck. Do I have girly eth? I hope I have girly eth.
01:10:45.530 - 01:11:16.836, Speaker A: Let's see if this will work. Let's see if this will work. Come on. Please don't front run me. Nothing happened. All right, that's not great, but maybe it means this works. Okay, let's check the TX later on.
01:11:16.836 - 01:11:40.270, Speaker A: Actually, I'm going to use. I don't like waiting for Voyager here, and for some reason it doesn't show you when a transaction appears. So I'm just going to use. There's a tool in to get transaction status. Right. TX status. I'm going to do starknet network alpha early.
01:11:40.270 - 01:11:58.496, Speaker A: I need to put TX status first. TX status network girly. And then I need to specify the hash. There you go. Let's see. Okay, my transaction is received. Let's.
01:11:58.496 - 01:12:38.544, Speaker A: Fingers crossed. Let's see what happens. Anyway, so the fun thing with this tutorial is that first, basically, you've seen that we've been able to leverage it. We've been able to solve the game and look at it and use a physics engine basically by just reading it. And you can basically just use this function. You can basically use four objects and then say, yeah, they have velocity and position, figure out what happens, and it tells you what is the next state and if there were collisions, which is pretty cool. So I was thinking about it.
01:12:38.544 - 01:13:06.376, Speaker A: I'm probably just going to try to write another game on top of that. So stay tuned for that. If there's an interest. I'll probably do another one of these widely successful live streaming sessions. If there's interest. And by the way, I'm very grateful. I see there are some people watching, and I saw that some people came and went and grateful for you spending some time with me.
01:13:06.376 - 01:13:31.170, Speaker A: I hope you learned something. I need to make it better next time so that I can read your comments and stuff like that, but grateful for your time. Don't hesitate to ask your questions. And if there's interest to do this more, I'd be happy to do it again. And actually, I know that Lucas is also interested in doing this stuff. So we'll be doing a bunch more of life coding. We'll try to experiment, and if it works, then we'll do more.
01:13:31.170 - 01:14:17.010, Speaker A: So, basically, this tutorial allows you to use a physics engine, and you basically get in your app to deal with objects that collide or not and see what happens with them. So we'll try to do something funny. Let's see. So my transaction is still received and has not been executed. I hope it will go through. So let's check on Voyager. What happens? What's happening? Is the next block supposed to come out? There were blocks two minutes ago and three minutes ago, so you should be actually just pop out very soon.
01:14:17.010 - 01:15:04.370, Speaker A: So, still waiting. So I think that's one of the hardest thing when you're developing with Startnet, you noticed for Devnet, it's a bit long. Tooling is slow, so that's one of the major impediment of developing. We're hard at work working on that. We do hope to have performance announcements in the coming months, both for the tooling and for the network. The fact that this is taking a lot of time is I want to know if I solved. Solved to mint and what's my score here? So the score here should be ten.
01:15:04.370 - 01:15:22.950, Speaker A: Not too bad, not too good. So, let's see. For level zero, there's a bunch of ten. 2623. Hundred and ten. Friggin Kobe Gerkin. How did he do that? Look at that.
01:15:22.950 - 01:15:55.968, Speaker A: Let's take a step back. Remember, guys, when you shoot a ball, if you hit one of the valid balls, then you will get collisions, and each time you hit one of the valid ball, you'll get either ten or 20 points. And they don't multiply, they add up. So how did Kobe. Did that, do that? He got 320 points. Did he hit the ball, like, 30 times? I doubt it. I doubt it.
01:15:55.968 - 01:16:27.770, Speaker A: I mean, he's smart, obviously, Kobe, but I doubt he's that smart to calculate trajectory that then resonate and stuff like that. And also, there's this. Remember, like, you can't just imprint any kind of velocity I could basically say, yeah, you know what, I'm just going to shoot the ball super fast. There's going to be a lot of collision. We'll see what happens. I could do that. Let's try to add a bunch of zeros here.
01:16:27.770 - 01:17:05.700, Speaker A: Try to add a bunch of zeros here and see what happens. Right? Let's just shoot the ball a bunch of time and see what happens. And basically what it says here is, I can't. No, it says here, look, illegal initial velocity magnitude out of bounds. Yeah, that fucking sucks. Look, it basically gives me that error, which is that I can't shoot this ball as fast as I did. So I could try to top that.
01:17:05.700 - 01:18:12.140, Speaker A: But by sending my ball correctly before I had what, like ten collisions, and not all of them were the actual collisions, there's no way I can increase it to a point where I'm going to do 30 valid collisions. So what gives? How did he do that? I'm wondering if some of you, by looking at this here, are starting to get, oh, yes, my transaction was accepted. So I solved solved to mint live happy. We'll look at it in a second. Let's go back to that question. How did freaking Kobe Gerkin did 310 solutions? Or how did this guy do 620? That's even more mind boggling. So let's see.
01:18:12.140 - 01:18:40.882, Speaker A: That's his core, right? If I go here, I can see all the solutions, right? So let's cheat. I'm going to see what his move was. Right? So let's check. I'm just going to check what his move was. It's the blockchain, it's public. It's fair game. Like, the data is valid, it's public.
01:18:40.882 - 01:18:57.100, Speaker A: So I'm just going to check how he did that. Dude, various people did 620. No, that's just an account. Various people did though. That's crazy. But okay, let's check. So that's record 37.
01:18:57.100 - 01:19:34.758, Speaker A: So that's the guy who solved this. And he discovered it in block number this. That's his family. I can't see his moves, but if I can find the transaction which he used to send this, then I can find his move. So let's see. Okay, so I copy pasted his address here, right? That's his address but in decimal form. So I'm just going to use converter, swap it.
01:19:34.758 - 01:20:03.200, Speaker A: All right, so that's his address. Who is this guy? So that's the transaction. I don't know the API, so I always do this, which kind of dumb. But this contract has no transaction. No, that's impossible. That's just the thing I copy pasted. It's the x value of it.
01:20:03.200 - 01:20:25.974, Speaker A: Funnily enough, it found it when I did that. So this should transaction that was sent to the account. Okay, let's do it differently. Let's do 620. Let's try with record 33. I don't know, I feel like using this one. That's level two.
01:20:25.974 - 01:20:43.420, Speaker A: No, that's not the one I want. I want level zero. Okay, so I'm stuck with that guy. All right, so that's his account from decimal to exit decimal. So that should be his account address. So probably I'm missing a leading zero or something like that. So I'm just going to be.
01:20:43.420 - 01:21:03.006, Speaker A: All right. Missing a zero. This should be the proper address in Voyager thing. It's pending. This makes no sense. The contract should be. Oh, no.
01:21:03.006 - 01:21:30.852, Speaker A: It should appear here. Don't know exactly what this means. Maybe I need to lower cap. I do up a lot of this. I use a lot of online tools like that when I'm lazy. Yes, it was a case of lowercase. So that's my contract.
01:21:30.852 - 01:22:06.484, Speaker A: Right. So that's the guy who solved it. And now I can see that he had a bunch of transaction, probably up to 100. How do I find this transaction? So what do I know about this transaction? I know it happened in block. Maybe there's an event, right? Should there be an event? All right, so let's see. There were messages if there were events. Oh, interesting.
01:22:06.484 - 01:22:37.292, Speaker A: So now there's transaction ash. So I'm guessing that. Okay, so every time you call this function, you call your contract, there's an event. So I'm just going to do it the lazy way. I'm just going to go check all the transactions and try to randomly check. So this one, I took the one at the bottom of the list. Right? So what is the.
01:22:37.292 - 01:23:02.292, Speaker A: I got the block hash, not the block number. Fuck. This is going to take some time. Let's see. Maybe with the events, I get more stuff. Um, I'm guessing the id of events here. This is probably the id of the ash, is it? Yes, it is.
01:23:02.292 - 01:23:39.570, Speaker A: Okay, now we're talking. Because now I know that I have the list of events from this dude who solves, solve, submit with a crazy score. And if I find an event that starts with the block number that is here, I'm going to find his transaction and I'm going to find how he did it. Yes, got it here, let's see. So what did he do? So here, the recipient, basically, this is the transaction he made, right? And so this means this is the address of the contract he targeted. And turns out it is solved to mint 39 a. Right.
01:23:39.570 - 01:24:30.380, Speaker A: Then that's the selector. So that's the ash of the function he was trying to call, which is basically submit move for level. That's level one, that's level two, that's x one and that's x two. And here, take a look at that value. Like basically I'm going to ask it in default, right? The value is, there you go, decimal. So he sent a crazy big value here. There is no way that this squared plus this squared is inferior to two times 150 times fp.
01:24:30.380 - 01:25:36.248, Speaker A: Let's actually calculate that, right? So let me open a python script. So if I do, Fp equals ten, and now I'm going to calculate this. No, actually ten to the power of twelve. Right? Okay, so Max, I'm going to call it this one right now I'm going to take this value, then his over value here. Then I'm going to try to do like result equals x times x plus y times y. All right, now I'm going to try, is result inferior to Max? Of course it is not. This is a way bigger number.
01:25:36.248 - 01:26:49.120, Speaker A: So what gives? How come he managed to pass this? And I wish I could see more exchange message like more messages and interact a bit more with you all, but I can't because I'm pretty sure some of you are screaming behind your scream. It's modulo FB, it's Modulo P. So it's basically spinning around. It's basically put minus one and yes, that's what it is. So basically here there's basically, would you call it a bug, a loophole, I don't know, in the smart contract, which is that basically this is supposed to prevent you from putting crazy value in x times in x and Y. But it is checking the square of both of these numbers and not the square of each number individually, which means that you can imprint very big velocity, because the square of both added will go above the prime that is used as the modulo in Cairo. So let me rephrase that a bit.
01:26:49.120 - 01:27:35.490, Speaker A: Let me see if some people commented some stuff. I'm curious if some people so did. So Gaz is saying, could it be that it's not it? The solution is that you know that in Starknet, in Cairo in general, all the arithmetics you're doing is modulu p, where p is a very large prime number in the order of 200 to the power of 251. Let's actually try to look at the documentation and find that. So building on Starknet, I guess it's here. Technical documentation, yes. Is it here? No, it's not here.
01:27:35.490 - 01:29:04.248, Speaker A: So what is darknet? I'm going to look for p 51 maybe? No, so I'm going to look at the definition of felt, right field elements, the primitive type, fill them and felt. And that. Did they write somewhere what p is 51? So I want to find P. But basically what he did is that if you take minus one modulo P and you multiply it by itself it's going to do one modulo P. But it means that if you take p and subtract one to it then this very large number and you square it, it's going to make one also. And that's the same thing for y. So basically what it is, and the thing is that both x and y impact the game individually, not with their square or not with their square combined they impact them individually.
01:29:04.248 - 01:29:54.274, Speaker A: So basically you can put very large numbers for x and y by just using x and y there are minus one or minus two or minus ten or minus something. I'm trying to find the value of p first and then I'll come back to that. But I wish I could find the value of p. Where does darknet? Maybe that's here, maybe on Google. Cairo. Value of p. There you go, google at the answer.
01:29:54.274 - 01:31:09.640, Speaker A: So what is p? Is this right, so let's go back to Python actually. So if I do p equals two to the power of 251 plus 17 times two power of 192, one p, that's p, right? Now if I try to do like for example p minus one and p -67 and I use both of these values, they're obviously way too big to be legal here. But they're the biggest value I could ever use. Right? And I can't use something bigger because otherwise it's not a felt. And if I add this here, this move, I'm not sure there's going to be a solution, but this move is going to be valid. To be clear, I did figure this out before. I didn't figure it out live.
01:31:09.640 - 01:31:58.596, Speaker A: I'd like to role play a little bit, but I didn't figure this out live. This doesn't work. But the movie is legal, it's not telling me that the movie is illegal. So I didn't figure this out live. What I didn't figure out, basically what I figured with this is that you can have very big numbers but you're reduced to shooting square coordinates. You can basically shoot in a perfect diagonal whichever way, and that's not ideal because you can't do complex trajectories. I wish I could, but I don't know how to find a large enough number that satisfies a third velocity and works modular p.
01:31:58.596 - 01:32:28.704, Speaker A: Anyway, it's a bunch of math question. If you have the answer and want to dig a bit more into that, I'd be very curious to see your answer. Okay, so let's wrap it up. There are still some people here. That's cool. So we solved solved to mint. We read the game Cairo file and we figured out how to use it and how to move the scene forward.
01:32:28.704 - 01:33:24.050, Speaker A: We managed to make a bunch of collisions and we made dummy smart contract that lets you debug what you're doing. I'm going to do two extra things. If you're interested into that. I'm going to record this here. I'm going to call this, I'm going to put it at the root because why not? No, I'm going to put in the example, right? So I'm going to call it Henrynotes TXT, right? And I'm going to commit all of this. There's going to be the APIs and the notes, then I'm just going to push this. I'm going to do it in a sec.
01:33:24.050 - 01:33:49.308, Speaker A: I'm going to do it in a sec. And then if you want, you can take a look at what I did, reuse the contract, try to manipulate it a bit, look for solutions. There are a bunch you can find. If I managed to find one like this, you probably can find one too. And that's about it. We're done for this session. I hope you learned something.
01:33:49.308 - 01:34:29.556, Speaker A: I don't know how long you stayed. I hope it's clear what you can do with Starknet. Something I want to underline here again, is that, what's really cool with that is that you have a scene and you're just forwarding it, making all this complex computation couldn't happen anywhere else than starknet. And that's cool. So yeah, that was the goal of solving soft to mint. You can find me on Twitter or whatever if you have questions or remarks. If you did look at the video and found it interesting, let me know because we'll do more of these.
01:34:29.556 - 01:34:52.520, Speaker A: If not, it's fine, we won't. And yeah, that's it. So thank you for your attention. Let me check. There are questions this somewhere like on YouTube, for example, and no questions. So let's wrap it up. Thank you guys for watching and I have a great afternoon.
01:34:52.520 - 01:34:52.920, Speaker A: Bye.
