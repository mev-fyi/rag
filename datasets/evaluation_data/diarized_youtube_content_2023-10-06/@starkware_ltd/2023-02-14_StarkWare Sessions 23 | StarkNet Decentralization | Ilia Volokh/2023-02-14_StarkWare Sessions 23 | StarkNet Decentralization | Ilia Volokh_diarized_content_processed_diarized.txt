00:00:03.710 - 00:00:32.170, Speaker A: Okay, guys, I think I'll start. This is not the topic of the talk. So we'll be here to talk about Starknet decentralization. And my name is Ilya, I'm at Starknet product team. My boss just came in. He's the one with his hands raised up. Right, so what's on the menu? So we're going to start by discussing the journey to decentralization.
00:00:32.170 - 00:01:00.894, Speaker A: Then we're going to talk about the goal of decentralization. We're going to talk about a slight change in methodology, about how we've been conducting research. Where are we right now? And then what's next? Okay, so let's start with the first item. So the vision of Starknet. So this d just imagine it's here. Okay, so the goal is to be decentralized. We want to be a validity roll up, we want to support general computation and we want to be an l two on top of ethereum.
00:01:00.894 - 00:01:41.502, Speaker A: Three of those we already have. One we don't have. So what's our roadmap towards decentralization? The way we decided to go after it is to start with functionality, then to improve performance, and then to go to decentralization, because decentralization gets in the way of the other two. So by performance we mean we want to increase the throughput, we want to reduce costs. Now functionality, we have performance we're working on. And decentralization is something that I owe you. So what are the goals of decentralization? The things we want Starknet to be? We want it to be robust in the sense of having as few central points of failure as possible.
00:01:41.502 - 00:02:18.214, Speaker A: And we want it to be accessible not only in the sense of being censorship resistant for transactions for users. We want all modes of operations to be as accessible as possible. So we want the sequencing layer to be accessible. We want the proving layer to be accessible. We don't want, let's say, a cartel of people who may wake up in a bad mood to stop the liveness or operation of Starknet. And the way to achieve these things is through decentralization. So I guess decentralization, you could divide it into two main areas, the decision making and governance and the protocol.
00:02:18.214 - 00:02:56.710, Speaker A: And Silv, he's very good looking. He talked about decision making before. And I am bald and not as good looking. I will talk about this part of the protocol. Okay, so just to make sure we have a common background, the difference between Starknet and Ethereum is they have one square and we have two squares with an arrow between them. And the presence of these two squares introduces many unpleasant complications, which we have to deal with. But in particular, we have to decentralize two distinct layers of operation, as opposed to just the mining or sequencing in Ethereum.
00:02:56.710 - 00:03:32.738, Speaker A: Right? So what does a decentralized protocol actually involve? First of all, we need to decentralize the sequencer layer, which right now is operated only by starquare. And this is a famous piece of da Vinci. This is the generic starquare sequencer. And unsurprisingly, we have to also decentralize the proving layer. This was studied by Raphael at the Renaissance. There is a few more things we need to decentralize the actual l one state update protocol, right? So people compute proofs, but something needs to happen with those proofs. In particular, they need to be verified on l one.
00:03:32.738 - 00:04:05.230, Speaker A: And somebody has to do this copy paste operation of taking things that people computed and posting them to l one. Another thing we need to figure out is we need to think and decide about the transaction fee mechanism. So maybe I'll get a bit more into that later. But Noam spoke about it at length, and he's sitting here. So if you can find him, you can ask him stuff. And the last question, which is also implicitly directed at Noam, is the whole question of rewards and tokenomics. So these are the basic constituent parts of the decentralized protocol.
00:04:05.230 - 00:04:45.498, Speaker A: Okay, so we first started thinking about decentralization at the end of 2021. Apparently I wasn't there. And the initial approach, again I'm told I wasn't there, is to basically suggest concrete protocols for a complete solution. And it appears that there was no convergence to any protocol that everyone was happy with. So we decided to sort of change the methodology. So about six months ago, we stopped trying to tackle the entire protocol at once, and we tried to start to divide and conquer it into, let's say, bite sized parts, which we could then understand. And we think it worked.
00:04:45.498 - 00:05:17.400, Speaker A: We think we understand the problem better now. So by understand the problem better, we think we've been able to isolate the parts which are independent. We think we better understand which parts are optimizations and which parts are at the real core of the protocol. And we think we think more clearly. But I guess that will be determined in the upcoming months. Right, so where are we now? Here's some stuff we've done without any details or explanations. You just have to trust me or catch me at gunpoint after the talk.
00:05:17.400 - 00:06:09.622, Speaker A: We've distilled some key design choices and their consequences and their dependencies. So by key design choices, I mean things like do we care about certain properties of the consensus protocol? For example, do we want it to be something which is BFT style? Do we want it to be something which is longest chain style? Do we want it to interact with l one and on what frequency? We think we have a pretty good idea of what we want there. We've externalized some thoughts and questions to the community in a series of horrifically long posts, which you are welcome to read. You can also send me hate mail. And we think we have some sensible protocols in mind for the entire operation of Starknet, which achieve very different properties, but they are definitely not as stupid as the ones that were there before. Sorry, I should not have said that out loud. Right.
00:06:09.622 - 00:07:00.566, Speaker A: So the things we haven't done are we haven't made any really fundamental design choices about proofs in the protocol. So all kinds of problems, like does the fastest prover always win? What are we really trying to achieve by decentralization of the prover? What level of accessibility do we want? Do we want anyone to be able to run approver? Does it have to be people with MacBooks? Can it be people with special macBooks? Or all kinds and so on and so forth? That's the sort of thing we have not decided yet. We have also not decided on things that pertain to fees. Okay, so the bird's eye view is something that I think I already gave, but just to make sure, I'll go over it again so we can think about the entire protocol in three big steps, which we think are useful. Separation. So first of all is the stuff that goes on off chain. This is the sequencer layer, which is now a bunch of people.
00:07:00.566 - 00:07:44.082, Speaker A: They talk between them, they yell and they scream, and then hopefully they agree. And there is no evidence of this thing on chain with an asterisk, because there probably will be some evidence, but that's the gist of it. Then there is the question of proof production. So you have all these transactions, people execute them, but they need to be proven, because that's what we do. We scale by averting computation away from ethereum and taking it off chain. And third, there's the l one state update protocol, which I've discussed before, where you have this copy paste procedure where people take results of computation and they paste them to ethereum. So here's an example problem, something we have not solved, the sort of the designation of labor problem.
00:07:44.082 - 00:08:15.280, Speaker A: So in the context of the proof production process, like any production process, you can divide it into a problem of division of labor. What are the jobs? And a designation of labor, who does each job? So the question here is, who are the provers who do each job and how are they rewarded? So you have two extremes. At one extreme, you have a competitive model. You have all sorts of those. But an example of a competitive model would be an open race. So every proof is given to the entire world. Whoever proves it first gets money.
00:08:15.280 - 00:08:46.742, Speaker A: Another example would be something which is a bit more subtle. So it would be something more like proof of work. Just to elucidate the difference. Proofs are deterministic computations. So if I'm better than all of you by an epsilon, I will always beat all of you, and I will always take all of your money. And that is probably a big centralization risk. In proof of work, the random aspect basically gives it a very different property, where if I expend a third of the effort, I will get a third of the rewards.
00:08:46.742 - 00:09:26.100, Speaker A: So even different competitive models have very different trade offs. But something is pretty sure that they're simple and they're efficient in the sense of finding the best people that are equipped for the job. So that's one extreme. On the other extreme, we have all sorts of turn based models which are they can be simple, and it seems that they support decentralization more than, let's say, an open deterministic race. On the other hand, they are not efficient in two senses. First of all, it's not clear that the people who perform the jobs are the best equipped for the job. And I forgot the other thing I was going to say, so maybe I'll remember it later.
00:09:26.100 - 00:10:21.270, Speaker A: Yeah, I didn't plan to dive into these problems, so I think I'll leave it for now and maybe we'll get back to this at the end of the talk. But the question of what's next is also apparently interesting. So you have this nice graph with all sorts of lines, and I'm just going to read the words above every point. So the first thing we want to do is we want to strengthen community involvement, and specifically what we've done to that end is we've externalized this series of posts that we discussed, and we would really like for you to yell at us and say how stupid we are or suggest ideas for improvement, because this is something I think we're sort of lacking. We don't really feel that the community is guiding us into a particular direction. So this is something we would love to have. The second thing is to start converging on design choices that pertain to proofs in the protocol.
00:10:21.270 - 00:10:56.670, Speaker A: The one after that is just to start proposing complete protocols with hopefully more than rudimentary analysis and then let people, I guess, destroy them. And then hopefully we will start to really converge on a concrete protocol and then we will be able to implement, test and integrate. Those are all the words I have. Here are some more words. So we want Starknet to be owned and operated by the community. And obviously that's you. So please participate, discuss and get involved.
00:10:56.670 - 00:11:36.150, Speaker A: This is a nice thing if you care about the posts and you don't want to google, so take out your phones and do something. And this is my true form, which you can also find on the starknet forums. That's it for me. So of questions. No questions. Question. I'll just repeat the question.
00:11:36.150 - 00:11:48.530, Speaker A: Yes, way of damage is.
00:11:50.580 - 00:11:52.130, Speaker B: Expected to.
00:11:53.060 - 00:11:54.016, Speaker A: Thank you.
00:11:54.198 - 00:12:00.036, Speaker B: If the prover that's expected to give the proof is offline. Did you already have a backup system?
00:12:00.218 - 00:12:14.888, Speaker A: Right. So the question was, one of the things I mentioned is a turn based protocol for the proofs. And if I understand correctly, the question was, how do you deal with failures of people whose turn it is in case they either fail maliciously or honestly? Is this the question?
00:12:14.974 - 00:12:21.212, Speaker B: Yeah, I'm also thinking, because I suppose this has to be public information, so you could attack the proverb beforehand, maybe, right?
00:12:21.266 - 00:12:59.668, Speaker A: So the simplest answer is the frequency of the turns is the easiest way to tackle this. So if turns are very long monopolies, let's say of several hours, then we think there is inevitably a risk of the proverb going down. And if the monopoly is defined by the protocol, then there is no way to recover. So the simplest way would be to have short turns. An alternative would be something like, while it's your turn, only you can get the money or you can get the most money. But anyone else who wants, for some reason, who is incentivized to produce the proof and post it, can also do so. So people can front run you, but they cannot steal your reward.
00:12:59.668 - 00:13:03.848, Speaker A: So that is also a possible backup mechanism. Does that answer the question?
00:13:04.014 - 00:13:10.860, Speaker B: Yeah, I'm just curious why not giving money for someone contributing is desirable?
00:13:11.200 - 00:13:12.472, Speaker A: I don't think it's desirable.
00:13:12.536 - 00:13:17.308, Speaker B: Okay, because isn't this what you said? Like if someone proposed out of turn?
00:13:17.474 - 00:13:32.724, Speaker A: I'm saying this is a fallback. If you want to defend against the liveness failure of approver, when it's their turn, one thing you could do is you could tell other provers, look, if you really care about this, you can do this work for free, you won't earn anything. But if you want liveness then you can take care of it yourself.
00:13:32.842 - 00:13:35.350, Speaker B: Okay? Yes.
00:13:37.960 - 00:13:49.044, Speaker C: Thanks for the nice talk. I'd like to ask about privacy constraints. Are there any privacy constraints that are already decided, or it will be decided later, depending on the protocol.
00:13:49.172 - 00:13:51.192, Speaker A: Privacy? What do you mean?
00:13:51.326 - 00:14:02.332, Speaker C: The privacy of the provers and the people who pick up the job of doing the various computations, not only for the prover, but for sequencing and for submitting, as you mentioned.
00:14:02.466 - 00:14:08.780, Speaker A: So I'm not sure I follow. Are you asking whether the address of the provers and the sequencers will be hidden?
00:14:09.600 - 00:14:16.428, Speaker C: Yes, their addresses, their IP addresses, any data that could be identifiable.
00:14:16.524 - 00:14:37.530, Speaker A: Okay. So anything that has to do with tangible reality is out of scope for me. I don't know anything about IP addresses, and we did not think about hiding the addresses themselves at the protocol level, so I wouldn't know about that. Anyone else? Spectacular. Okay. Oh, hello.
00:14:41.100 - 00:14:43.448, Speaker D: Here, I guess.
00:14:43.454 - 00:14:43.624, Speaker A: Yeah.
00:14:43.662 - 00:14:57.240, Speaker D: It's relating to the sequencer in the decentralized prover model. Are they also able to make choices around what they're sequencing, or is the sequencing decided at another layer and the provers are sort of bound to what's already been sequenced?
00:14:57.320 - 00:15:27.512, Speaker A: Right. So I think this is a very good question. So the way we're thinking about it now, at least for the sequencing, is to imitate Ethereum, where there is a direct market between users and sequencers. Specifically, sequencers sell their block space in exchange for transaction fees, and the provers do not get to participate in this direct exchange. Instead, they are only able to prove things that are output by consensus. So in particular, provers will not be able to pick and choose transactions. Does this answer your question? Yeah.
00:15:27.512 - 00:15:59.114, Speaker A: Okay, cool. Okay, so because I have two more minutes, I think. Oh, I don't, I do. Okay. I do. So I do want to mention another interesting problem, which is related to designing transaction fees. So what I've just said is that we're imagining the sequencer market to be sequencers selling block space in exchange for transaction fees.
00:15:59.114 - 00:16:40.662, Speaker A: And as we've said, the provers themselves will not be able to interact directly with the sequencers. They will not be able to participate in the consensus and to choose transactions. So there is an interesting question of how is the price of proofs discovered? Right. We would like people to know what they should pay for, but we would also like not only to set some protocol level pricing, but to have it actually reflect, let's say, with some efficiency, the actual price of computing proofs. And I think this is an interesting problem. So just to give a concrete approaches, one option would be to have an auction on l one where everyone can participate. And by everyone I mean provers who sell their services at particular rates.
00:16:40.662 - 00:17:08.340, Speaker A: And another option would be to take everything completely off chain and to basically say to the users, you'll go figure it out. And these are also interesting radoffs. You could plug something which is like 1559 as a sort of intermediate solution. And if any of you are interested in this sort of problem, please find me after and give me good ideas. Thank you.
