00:00:00.330 - 00:00:25.698, Speaker A: You. Hi, everybody. My name is Pascal. I'm a cryptographer. My background is publicly crypto and especially amorphic encryption. I carried out my phd, like, 25 years ago about amorphic encryption, and it's something that is booming right now. So I'm here to share with you what we're doing in Zama about amorphic encryption and applying that to the blockchain chain.
00:00:25.698 - 00:00:57.390, Speaker A: But I have a question first. So how many of you? So raise your hand if you know what fhe is. All right, so keep your hand raised if you think that the impact of fhe on the blockchain is going to be at least as major as zero knowledge. Okay. Not so many people. People are questioning. Raise your hand if you think that it's good to have a morphic encryption, but it's not ready for primetime because it's too inefficient.
00:00:57.390 - 00:01:37.914, Speaker A: Oh, boy. Okay, so my challenge is to convince you otherwise. That's good. Okay, so, as you know, everything on the blockchain is completely public. It's actually a feature. When you talk to people, they think that there's no other way to make things inspectable, right? So everything is done in the open, and as a consequence, you have all these negative effects, which are typically people know how many tokens you have on your balance, so they can try to identify you and then mug you or something. There is surveillance because you can use all this information to basically track activity and track people.
00:01:37.914 - 00:02:24.838, Speaker A: And there's also, like, mev extraction and bots that try to frontproon you. So the magic thing with amorphic encryption, for those of you who do not know exactly what it is, is that amorphic encryption is a specific type of encryption where you encrypt the data, but you can still process this data in encrypted form without ever decrypting it. So that sounds a little bit magical. It's something that cryptographers have been after for almost 50 years. It was like a cryptographer's dream to actually achieve that. And it was only like this past decade that things were put into place and actually that polymorphic encryption was made a reality. But even for us cryptographers, it's like, excruciatingly difficult to operate.
00:02:24.838 - 00:03:29.550, Speaker A: So basically what we do at Xama is to provide tooling so that developers can actually deploy homophic applications without having to care about all the gory cryptographic details, the parameters and so on. So we want to make fhe easy. But specifically for the blockchain, once you applied homophic encryption to the data, the on chain data, the data that is being manipulated in the smart contracts, you suddenly become capable of doing a lot of things like you can encrypt data, the data that is manipulated during the transactions. You can also encrypt the states, and you can update the states in encrypted form without actually making them public. You can also have data that is create a marketplace for data processing while protecting this data on chain. So this is absolutely awesome. And as a beneficial side effect, you have also all these problems that are solved simply because the data is not public anymore.
00:03:29.550 - 00:04:25.890, Speaker A: But in addition to that, you have also the effect that suddenly with FHC, you have a number of new business models or user experiences that you can create that were not possible before, just because all the data couldn't be made public. So typically you can think of identity like a biometric database, for instance, is always like a hot potato because it's too dangerous to manipulate. There could be like data leakage or whatever. With amorphic encryption, you can put that directly as data on chain and have it processed homomorphically. And so it can be a game changer. Because of these features, you can think of on chain gambling or games like poker. And suddenly you can have encrypted secrets so that you can implement using FHC very trivially, you can implement poker or any kind of games where you have secrets at the same time.
00:04:25.890 - 00:04:52.490, Speaker A: Blind auctions typically so far you have to rely on zero knowledge and have your bids and information off chain. But it's trivial actually. Once you have fhe put in place, you can trivially have solutions for blind auctions using encryption. So I'm going to give you a few insights about what aomorphic encryption is. So bear with me. There is not a single equation in there. It's just like concepts.
00:04:52.490 - 00:05:40.326, Speaker A: Also, feel free to interrupt me. I think I won't have time for questions. So if you have questions, just raise your hand and ask me live. Okay, cool. So it's not the case always, but for the main schemes that are out there, encryption mechanisms for cleomorphic encryption in general, when you encrypt something, the payload behind the ciphertext actually looks like this. So you have some data like the yellow bits here where you put your payload, the real message, the plain text, and then you have to add some noise, some randomness. Gaussian, actually not uniform, but you have to put some randomness in the least significant bits, and you cannot avoid having to put noise in there, otherwise there is no security.
00:05:40.326 - 00:06:18.254, Speaker A: It is not known how to get rid of this noise. It's another cryptographer's dream, but so far we don't know that it's possible to get rid of it. So you have to deal with it. So what's happening is that typically you would have some padding before and after the data that you're encrypting, so that you can perform operations. But there is always this noise in the least significant bit positions. And the problem is whenever you do an operation, if you add like two ciphertext, there's an addition occurring behind the encryption envelope. And so what's happening is that you're adding your two encrypted numbers, but you're also adding noise.
00:06:18.254 - 00:07:14.230, Speaker A: So the noise is only going to grow. And that's why at some point, if there is no space for the noise to grow anymore, it starts overflowing over the plain text and you lose the consistency of your processing. But we want homophobic processing to actually exactly reflect what's happening in the plaintext domain, like if nothing was encrypted. So that's bad. And in particular, if you think typically of a contract where you can like an ERC 20 token where you have a basic functionalities where you can transfer over tokens from one address to another address, you have all the states that are the balances of all the users. And typically these get updated at every transactions simply because they are encrypted. So you have to consider them as a big encrypted state and update everything at each and every transaction.
00:07:14.230 - 00:07:59.746, Speaker A: So whenever you do that, you apply some more amorphic processing. So the noise grows as well. So eventually, at some point it means after a given number of transactions, suddenly you start making errors. And so the balances start to be like incorrect. And this is something that nobody wants. So all the game with homophic encryption, when you put that in practice, is actually to be in a position where this never happens, like probably, but fortunately enough, we have this operation that seems a little bit magical called the bootstrapping, where you give an encryption, like a very noisy encryption of X, and you end up with a clean encryption of X. So you don't modify actually what is the payload like.
00:07:59.746 - 00:08:48.114, Speaker A: The plain text is not modified, but you kind of reset the noise to a nominal level where you can suddenly have more room to do some more operations. So you would do some operations, then you would bootstrap, and you would go on and on and on like that. And there is also another problem that we have, is that usually with amorphic encryption, the operations that are supported are additions and multiplications. And so everybody in that space except what we do at Xamar because we use a different technology. But what they do typically with ckks or BAv or BGV, is that they decompose everything into graphs of additions and multiplications. So they end up computing over polynomials. And for them it's good enough because polynomials can approximate virtually any function.
00:08:48.114 - 00:09:32.530, Speaker A: So they don't care about that aspect. But actually it's kind of very bad when the approximation is not perfect. As you know, you cannot use a polynomial to approximate a function, but on a certain given interval. So what happens if you're like out of range or something? So you cannot guarantee the exactness. And they can be pretty bad because of the requires that you have in contracts. So when you do a comparison, you cannot be approximated, right? Because otherwise there are cases where transactions will happen and actually they shouldn't happen because the require is not actually fulfilled. So this is where we actually using a completely different technology called TFHe.
00:09:32.530 - 00:10:20.462, Speaker A: So TFHe is a scheme that is fantastic for two reasons. One reason is that there is a bootstrapping in TFHe, like in the other schemes. But instead of taking like ten to 30 seconds to bootstrap a single ciphertext, it's actually 1000 x faster. It's actually around ten milliseconds depending on the parameters. So it goes like super fast. And also at Zama we made it like programmable, meaning that at the same time that you're cleaning the noise in a given ciphertext, you also apply a nonlinear function for free on the plain text. When you do that, and suddenly we have a way of decomposing, like whatever operations we want to do into this small linear nonlinear operation.
00:10:20.462 - 00:11:18.706, Speaker A: So at the same time that we are cleaning the noise, we can also apply computations over plain text. And so you can keep the noise in check at all times because you do some leveled operations, you do operations and then you do the bootstrapping all the time. So your ciphertext are actually always clean. So you can go on and on and on forever. And so this applies directly to the states, where typically the unchanged states can be updated indefinitely because you're just resetting the noise every time that you're updating the state, refreshing it. So this is fantastic for this reason. And at the same time there is a big question, as I saw before, by just probing you guys, which is how efficient it can be done efficiently, you can actually bootstrap, which is the bottleneck operation with any fhe scheme.
00:11:18.706 - 00:11:45.802, Speaker A: And as it happens, what we're observing on our side is that performances are multiplied tenfold every couple of years. So right now we're in the middle of experimenting with fpgas. It went through the classical stages of technology. Like you have a cpu implementation, you switch to GPU because things are highly parallelizable. So you can use a GPU. It can be beneficial to performances. Then eventually you want to go further.
00:11:45.802 - 00:12:48.500, Speaker A: So you design your own architecture to have like a homomorphic coprocessor in an FPGA. And then you could go all the way to the ASIC, where you want to put things in production and actually provide cards to data center and so on, so that they can actually doomorphic processing for real. The metrics is the million bootstrapping per dollar, which is, we think is the dictating indicator or how fast we're progressing in the space. And as you can see, there's kind of something that looks like the Moore's low, which is like typical of a field that is quickly evolving, but still relies on hardware. So what we did at Zama very recently, historic moment, is that we performed the first ever encrypted, homophobically encrypted transaction. And so actually, if you look at the solidity code, you have something like that. So there's a few differences with what's happening in the clear.
00:12:48.500 - 00:13:28.782, Speaker A: You can see that by exposing this type of 256 bit integer. But encrypted in FH, you're certainly. And overloading the natural operations, certainly you can expose all these homomorphic processing to the developer. But there's a change, there are several changes. Like, first of all, you need to add another function, which is, I want to view my balance, because before everything was done in the clear, so I could just go on chain, look at my balance. I would know it. It would be public, everybody else would know it in this.
00:13:28.782 - 00:14:12.154, Speaker A: Now everything is encrypted. So as a user, and because typically the encryption key is maintained and hold by the network itself, as a user, I don't have access to this key. I cannot decrypt. So what do I do to have access to my balance at some point, just to read it, it's now becoming like a non trivial issue. But fortunately enough, with fhe, we have cryptographic superpowers. We can do stuff that no other encryption mechanism can do. Like there is something called the key switch, where you take an encryption under a certain key, like under Alice's key, and you can convert that without decrypting or anything.
00:14:12.154 - 00:15:28.760, Speaker A: You can convert that into an encryption of the same thing under Bob's key. And so it's fairly easy for the network to just do a key switch to a particular user's key, and then the encrypted balance will be key switched to the key of the user, and then it can just decrypt with its own individual key. So this is the kind of stuff that you can do with homomorphic encryption because of all these superpowers. But basically you have to expose that in the language so that the contracts, you have this functionality of actually viewing the balance. And also there is like the requires, which are a little bit complicated because at some point you have to validate the transaction if and only if everything that has been required is actually fulfilled. But when you process encrypted data, you can compute conditions on this data, but you end up with an encrypted bit and you have to know at runtime whether you're going to validate the transaction and push it on the next block or not. So how do we solve that? So there are plenty of issues in there, I think I won't have time to explore everything, but we're here basically all day, so we can talk more if you want.
00:15:28.760 - 00:17:05.934, Speaker A: And so there are a bunch of problems in there, of questions, but the good news is we have solutions for all of them. So the first thing is, because of the requires that validators that are executing the transaction are actually computing these encrypted bits, there is nothing you can do about it except providing a decryption oracle to them. So we have somehow the network has to have this decryption oracle where the private key of the network is going to be used to just decrypt and help with taking the decision. And you can secure that instead of having like a single bottom failure using threshold decryption, which also applies to fhe. So instead of having a single decryption key, you can split that into different shares, you have different actors, and where you need typically a certain subset of the actors to jointly do the decryption in a way where they cannot cheat, basically. So the decryption oracle has to be implemented in like a distributed fashion, and at the same time so the validators we have at some point to operate the decryption of the encrypted require, the validators will all compute, execute homophobically the operations. And we have a consensus based protocol where basically they compare their outputs.
00:17:05.934 - 00:18:01.538, Speaker A: And if there's like a high enough number of validators that are presenting the same result to the decryption oracle, like two thirds of them, then at that moment the decryption oracle will apply and will decrypt. The require will be taken into account by the validators and typically the transaction will be either rejected or the states will be refreshed. But there are other problems in there. Typically when you send an encrypted input to somebody who runs like a homophobic processing, and there is a decryption oracle somewhere, you have to guarantee that you cannot hijack this decryption oracle and just break the whole system. And this is something that we call chosen cybertext security. And basically fhe is not known to be in CCA. So you have to protect access to the decryption oracle.
00:18:01.538 - 00:19:00.442, Speaker A: And the way we do that is by adding zero knowledge proofs of what we call plaintext awareness. So basically, whenever a user provides an encrypted input, there could be an attack where instead of providing a fair encrypted input, it's actually a piece of a key somewhere, or it's actually a replay attack, because this ciphertext is coming from like a preceding transaction or whatever. And so what we want to avoid any kind of attack of this nature, what we require is a proof of plaintext awareness. That is, the user is providing the encryption of some x we don't know, but she has to prove that she knows x without revealing x. And so having access to decryption Oracle is not beneficial for an adversary simply because you prove that you know the plain text. So using the oracle to decrypt is actually useless to an adversary. So we have to put that in place.
00:19:00.442 - 00:20:25.620, Speaker A: And so at the moment when the validators verify the ZK proofs of the plaintext awareness, we know that there cannot be like an adversarial attack. So what is missing at this point is doing one step further, which is actually merging starks and with fhe, like putting them together and making sure that you can actually delegate a computation that's happening on chain of data that is encrypted, but that all the processing is proven correct with the snark or with the stark. When you do that, you're actually solving the real holy grail of cryptography, which is not only is the processing completely confidential, but it comes back to the user actually also proven correct in execution. And we think that this is going to be very, very important for the paradigm of collaborative computing, data processing in general. So yeah, that was it. Yeah, you can ask a question.
00:20:29.430 - 00:21:01.918, Speaker B: Oh yes, it sounds like your attitude is going to be quite heavily to scale. So I guess my question is like, if I understand the architect, without FHG computation, every network node would need to possess one of these asset chips in order to validate the integrity of the.
00:21:02.084 - 00:21:03.200, Speaker A: Yeah, correct.
00:21:04.710 - 00:21:19.440, Speaker B: Yeah, I guess. Do you have concerns around how that may, how that affects. It's only quite a limited number of.
00:21:27.970 - 00:21:51.030, Speaker A: Yeah, maybe. I think it's a very interesting question, but it's not technical. I think we should have this discussion offline, maybe. Sure, no problems. Yeah. Also, I forgot to mention, but this is actually real. We have like an fhe EVM implementation end and we're going to launch a testnet like this year.
00:21:51.030 - 00:22:06.120, Speaker A: So this is actually coming to reality, which is very exciting for us. Also, if you understood the power and the potential of a morphic encryption, should be very exciting for you. Thank you.
