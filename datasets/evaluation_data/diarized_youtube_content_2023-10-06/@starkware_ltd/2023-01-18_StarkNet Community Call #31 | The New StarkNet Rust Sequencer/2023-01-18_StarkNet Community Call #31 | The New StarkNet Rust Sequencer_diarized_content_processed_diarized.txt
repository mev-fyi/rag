00:00:00.570 - 00:00:21.018, Speaker A: And I've pressed go live on YouTube. We're now live on YouTube. Fantastic. I think we're all clear everywhere. Everywhere. So, hey, everyone, and thank you for connecting for one more community call today I have with me Ellen and Alon, who both work at Starkware. Hey, Ellen and Alan.
00:00:21.194 - 00:00:21.920, Speaker B: Hi.
00:00:22.770 - 00:00:37.560, Speaker A: And today we're going to talk about. About sequencing Starknet and specifically Elaine and Alan. This is what you're working on. Before we start, could you give a brief introduction of what it is you're doing?
00:00:40.030 - 00:00:41.660, Speaker B: Yeah. Can you hear me?
00:00:42.030 - 00:00:43.340, Speaker A: We can hear you.
00:00:45.310 - 00:01:11.090, Speaker B: So, my name is Elaine. I've been working in Starquare for three and a half years now. In the past year and a half, I've been part of the Starknet development group, and we've been writing the Starknet sequencer, which is now live for like, I think a year. And now I'm currently the team leader of the new effort of rewriting the sequence.
00:01:14.310 - 00:01:16.230, Speaker A: Thank you. What about you, Alon?
00:01:19.290 - 00:01:40.730, Speaker C: Hi, I'm Alon. I'm a software developer on Elaine's team. I joined Starkware a year and a half ago, joined Elaine's team, like I said, and been working on Starknet in Python, and recently moved to work on the sequencer in rust.
00:01:43.870 - 00:01:55.390, Speaker A: I need to find. Yes. Okay. I always have to unmute myself on Discord. It's a bit. Sorry if there's a bit of a delay in the questions. All right, so thanks, Elena and Alon.
00:01:55.390 - 00:02:06.550, Speaker A: So let's start with the sequencer. Can you briefly introduce, what is the sequencer? What's this task and what it is supposed to do? What is it exactly we call a sequencer?
00:02:07.610 - 00:02:42.240, Speaker C: Sure. So the sequencer is similar to miner and ethereum. Its responsibility is to take transactions from a pool of transactions and order them. That's where it gets its name from. It sequences the transaction. So first it sequences the transactions, and then it executes them on the state. So we get a state diff, which is the difference between the previous state and the next state.
00:02:42.240 - 00:02:54.930, Speaker C: And after a bunch of these transactions are executed, a block is created and can be published, and the new state is introduced to the Starknet network.
00:02:56.730 - 00:03:13.500, Speaker A: Okay, cool. So the sequencer is in charge of. It's basically the engine of Starknet in a way. Right. It processes transaction, aggregates them and produces block from it. So, yeah, critical piece of infrastructure, if there is one. Right.
00:03:13.500 - 00:03:47.426, Speaker A: And following up to me, I've been at Starbucks for about a year, a year and a half. Kind of like you, Alan. I joined in October last year. I think you joined maybe a bit earlier, right? And it feels like things have moved a lot for a year. Ellen, you've been here three years and a half. It must have been quite a ride. I'm really curious to hear you talk a little bit about how did Starknet emerge, in a sense, because three years and a half ago there wasn't Starknet.
00:03:47.426 - 00:03:52.280, Speaker A: I don't even think there were Starkx. So how did you start working on this?
00:03:55.050 - 00:04:42.150, Speaker B: I'm trying to talk. Okay, you can hear me because I have a hard time with discord. I'm going to get it. Okay. So I joined when Starkx, which is a specific app which allows a spot trading, was in its alpha stages. So we rewrote the system. We rewrote the infrastructure for a pipeline starting from a gateway that receives transactions by HTTP and then gives them transaction ID, and then batches them into batches which are sent to sharp for proving in the stark protocol.
00:04:42.150 - 00:05:12.320, Speaker B: We had the Starkx system, which was written in Python. The transactions were known. We had like six instant transactions, which are deposit from l one, withdrawal to l one, settlement, transfer of monies, and so on. And the transactions were written, their logic was written in Python. We didn't have the need to run a Cairo at that stage, only afterwards in order to create the trace for.
00:05:13.270 - 00:06:00.240, Speaker A: So can I interpret you here? Just a second. Can you hear me? Cool. So when I describe Starkx often I don't describe it from the systems point of view like you did, but I describe it as a white label trading engine in the sense that people interact with it through a set of APIs that execute, as you mentioned, predefined bundles of code. And so what you're describing here is that there's a difference between executing the code and actually proving it, creating the trace which goes to sharp, which then is aggregated into proof and interpreted by Starknet. Is that correct?
00:06:01.490 - 00:06:52.678, Speaker B: Yeah. So the first part is when receiving a transaction is executing them and realizing what are the changes they apply on the state, on the previous state. That can be done in Python or in any language it doesn't require in Cairo. And in startup specifically, it's a specific app which the logic is known to us. So executing the logic to execute them was written in Python. Then when we know what's the batch or the block of transactions, that is one to one, like a Cairo job, or proof to send to sharp. And before it's sent to the prover, it's ran in Cairo.
00:06:52.678 - 00:07:07.650, Speaker B: But the first execution, in order to be fast, it doesn't require Cairo, it can be written in any language, the transactions which we don't in startup. I'm going to get to that soon.
00:07:07.800 - 00:07:30.800, Speaker A: Okay, so what you mean is that as long as you know that the code you're executing first is the same that the code that will be executed in Cairo after you can execute it in another language, in another context, because you know that you're going to get the same thing once you get to proving. But that's for code, you understand and you know in advance what it's going to do.
00:07:32.130 - 00:08:36.542, Speaker B: Yeah, exactly. So that was Starkx. We also implemented a stark perpetual, which allowed a perpetual exchange. And then there was this natural generalization of things, which is Starknet. Why not run any generic code as a transaction, right? Why not give people the ability to write their own code? So for that we started writing, developing Cairo as a language, and once we had that, we could process any transaction like any code with my users, given our VM in Python. The first vm was in Python, which isn't very efficient, unfortunately. And so the first thing we did, given a system of Starkx, which takes a stream of ordered transactions, executes them an output box, we took that infrastructure and we integrated a Cairo runner inside the business logic, which could run any Cairo code.
00:08:36.542 - 00:08:45.810, Speaker B: That was the very beginning of Tarknet. We didn't have like l one, l two communication yet. We didn't have l two, l two communication yet. We only had DAC.
00:08:46.330 - 00:09:23.730, Speaker A: Okay, so basically before that on Starkx, you were able to execute predefined pits and snipets that would later at the proving stage, convert into Cairo code. But since on Starknet you want to allow arbitrary code writing by the users, you basically had to re import Cairo inside the python environment to be able to execute it. That's really interesting. It sounds also a bit scary now. I mean, you had a piece of infrastructure and you know what goes inside of it, and all of a sudden you let people execute arbitrary code on your machine. That's kind of scary.
00:09:25.190 - 00:10:05.102, Speaker B: Yeah, it is. And that's why we had different limitations. For example, we don't allow an infinite number of steps to be run inside a transaction. We have like a limit of, I think, 1 million Cairo steps. We have also limits on the built in usages. And now with the new Sierra code, which is the new intermediate representation of Cairo, one, we won't even allow code that doesn't stop running, or we will allow code that fails, but we will be able to prove a rejection. But we'll talk about it later, maybe yeah, sure.
00:10:05.156 - 00:10:29.860, Speaker A: Sorry. Okay, sorry. So you were saying in the beginning you didn't even have like, l one, l two communication. So basically you took arbitrary code. I mean, you took the predefined code that is sort of arbitrary for Starkx. You could code whatever you want in Starkx. Right? Then you turned it into.
00:10:31.930 - 00:10:41.430, Speaker B: Sorry, I'm interrupting you. In Starkx, it was a predefined set of transactions. In Starknet, we allowed arbitrary code to be executed.
00:10:41.590 - 00:10:46.620, Speaker A: What I meant is that you, Ellen, you can code whatever you want into Starkx, and then people can use.
00:10:49.950 - 00:11:15.540, Speaker B: We had, yeah, it's true, or like any app, but we wanted the ability to give the users the ability to write their own code so that we won't have to write a backend and a business logic and start quer for every app. We wanted to give freedom to developers to write their own code without the need to go through us.
00:11:16.170 - 00:11:41.710, Speaker A: Understood. And so little by little, you added these all functionalities. And for the past years, things have moved forward quite a bit. But in the past few months, I'd say we've started hitting the ceiling of starknet capacity. Right. There has been a few days where the network was at capacity. It took a long time to run transactions.
00:11:41.710 - 00:11:54.980, Speaker A: Well, that must have been an eventful year for your whole team. But at that point, you were still involved in the Python effort. Which road did you explore to scale this? Basically.
00:11:56.630 - 00:13:04.038, Speaker B: So, before scaling, I'll start with the first effort. The first milestone we had is writing a full functioning blockchain. We didn't put effort into performances yet because we wanted to get to production as fast as possible to give people the possibility to write and run their Cairo code and testnet, and then maintenance. And then once we had full functioning blockchain, besides maybe feed mechanism, which will be added to and mempool, then we decided, and we had high tps by then. We decided to move our efforts to performance. So first we started implementing optimistic concurrency, to execute the transactions in parallel, to try to execute them in parallel and see if they're touching the same storage cell. Then I invalidate future transactions, and so on.
00:13:04.038 - 00:13:17.930, Speaker B: So that was the first implementation in Python. But then as a strategic move, we decided to start rewriting the sequencer in rust, which is faster, more efficient language.
00:13:19.630 - 00:13:47.160, Speaker A: Very nice. Well, now, Alan, can you talk a bit more about the exact scope of the sequencer effort you're running right now about the rustifying of the pythonic sequencer? Because it sounds like you had a whole piece of infrastructure running a lot of transactions and now you're just starting from scratch. Is it the case?
00:13:50.810 - 00:14:21.230, Speaker C: Yeah. So the sequencer right now is, all of it is in Python. And like you said, the project is working on rustifying the code. Kind of like replacing parts in a car. You'd replace one part at a time and eventually you get a new and faster car. So we're not exactly starting from scratch. The core of the sequencer is the Cairo VM.
00:14:21.230 - 00:16:01.790, Speaker C: There's a Cairo VM written in Rust by a talented team in Lambda class, a company of developers. And the core of the sequencer is just running pure Cairo code and also common Cairo hints. And on top of that we're building the standard library of Starknet, which is the syscalls, the way that the Cairo code can interact with the state, because all the interesting transactions need to interact with the state. So we have entry points in turning from regular Cairo code to starknet contracts, running entry points in starknet contracts and entry points are the building blocks of transactions, which there's accounts and account contracts that send transactions, users that send transactions, and the sequencer executes them. The first milestone or the first replacing is, like you said, the engine of Starknet, which is just getting transactions from the Python sequencer, transactions that were sent by account contract, performing them and executing them in rust and the rust part of the sequencer, and then producing a state diff, which is what I talked about earlier. And from that we can get the blocks and publish them back into the network.
00:16:02.450 - 00:16:46.110, Speaker A: That's really cool. So you mentioned earlier that this Cairo VM that is now written in Rust, it used to be written in Python. And you mentioned that Lambda class, which is a partner developing on Starknet, developed it recently. How was it for you guys who had been working for months or years on a system where you were the only developers basically? I mean, Cairo emerged as an internal tool at Starquare to write applications we needed. And then you have somebody from the outside saying, hey, can I contribute? And hey, here's my code. How was this whole process? I imagine must be quite in the way you work. It must have been quite a change.
00:16:46.110 - 00:16:46.800, Speaker A: No?
00:16:49.250 - 00:17:32.960, Speaker C: So from my side, and Lincoln say how she felt it from her side. My interaction with Lambda class was really good and smooth. They were also working with some of our developers on the VM, which helped them and tried to do it in the same lines as the VM that is written in Python. So it was pretty comfortable to work with them and we did it pretty quickly and the communication is very good with them and we're always talking back and forth and giving points to help one another. So it's been great.
00:17:35.250 - 00:17:37.198, Speaker A: Ellen, do you want to add something?
00:17:37.364 - 00:18:45.118, Speaker B: Yeah, I think in general, the thing that we're writing is an infrastructure which is not of Starquare or it won't be soon of Starquare. And what we want is as many developers and partners to contribute to the ecosystem to build next web three. That's for me a good sign. It enriches the ecosystem and people getting into core components in Cairo and implementing them. It's a good sign of us communicating the language to devs and cooperating with them. It was at first surprising because I wasn't used to that, because we were used to be first. But I think that's what our goal is in the end to make starknet independent of software.
00:18:45.118 - 00:18:46.760, Speaker B: So that's a good thing.
00:18:47.210 - 00:19:27.780, Speaker A: I agree that it's a good thing, but still, changing the way you do things and working with new people is always extra work. It's not always easy, not because it doesn't work, it's just that it's a new context. It's a new thing. It must have been basically going from a single company, going from a single maintainer to various maintainer is already a big thing. Going from a single company to various entities collaborating together is also a big thing. So it must have been like, in terms of pure engineering experience, regardless of Starknet, must have been quite interesting to see new patterns, new ways of collaborating and stuff like that.
00:19:29.350 - 00:19:57.980, Speaker B: Yeah, it's true. But those are engineers like us. Those are colleagues. So the communication is very, as Alan said, is very comfortable. We work in pull requests, we have multi repos. Now. The first sequencer is a monorepo, so I think it's a healthier, open source way to work and I think it's a good change.
00:19:58.430 - 00:20:17.540, Speaker A: Very nice. Cool. Okay, so we talked about how you're going to switch the core, the engine from a Python VM to a Cairo VM. What's next, Alan? Ellen, up to.
00:20:20.150 - 00:21:07.010, Speaker C: After? Right, so like I mentioned a little bit before, after replacing just the VM. So we're going to replace also around the VM, like what I talked about, the standard library of Starknet, the syscalls, and then just executing transactions, which should boost performance and TPS. And later on we'll start introducing maybe more performance enhancements like parallelization and things like that. That also maybe will be more comfortable to implement in rust than in python.
00:21:09.350 - 00:21:48.990, Speaker B: Let me add to that our next components. To also implement and integrate into the system is a mempool. We currently don't really have a mempool. As soon as a transaction goes into our system, it gets an id and it's ordered in the order it's received in the HTP protocol. So we're going to add an appropriate mempool. We're also going to add, I think we're going to add the part like the OS run to the system to produce an input to the sharp algorithm. But we're currently focused on the executor because things change all the time.
00:21:48.990 - 00:22:18.070, Speaker B: We're currently discussing internally and also with the community the decentralization protocol. So we're not really sure where the line is going to pass between the approver and the sequencer. So we're not really sure what's going to be a part of the sequencer in the centralized world. So we're focusing now on the executor, and as time passes and we release first version, we're going to see what are the requests and future milestones.
00:22:20.010 - 00:22:46.740, Speaker A: Super cool. And I guess a lot of developers right now on Starknet are kind of in limbo in the sense that they're not sure whether they should start developing stuff on Cairo zero or Cairo one. How does this affect your team? Because in a way this is the same for the work you're doing. Are you working on Cairo zero code? Cairo one code? How do you approach this?
00:22:49.430 - 00:23:50.946, Speaker B: So currently we're writing the new rest code. Okay, I'll start with the current version. So currently we have the zero point ten version running on all systems, which is supporting only Cairo zero. We're working on zero point eleven, which is going to come up out, I think in a month or so, which is going to support Kyro one compilation and running like minimal Cisco, which I think we're going to be storage read. Right? Maybe we're going to implement call contract too, in order to release a preliminary version fast so that people can start interacting, start writing their code in Ky one and experiencing with it. And internally we have the same thoughts, right, because we don't want to implement the future functionalities. For example, a memple, a theme mechanism in Python and then translate it to rust.
00:23:50.946 - 00:24:29.300, Speaker B: It's double work. What we aim to do is release our rust version as soon as possible and then continue developing future functions in Rust. But maybe we'll have to write a few more features in Python because we won't be able to release it in time. So I think these are the same discussions we also have internally, but we want to be able to allow the community to start writing in Cairo one ASAP and start experiencing with that.
00:24:31.910 - 00:25:00.830, Speaker A: Interesting. So you mentioned we want to try to release it ASAP. Can I add, you have a rough notion of timelines non committing. The objective here is not to give a big, a big disclaimer for you. All of you are listening, this is just us talking. You shouldn't take this for a promise. It's just us exploring what we think may happen, but who knows?
00:25:01.570 - 00:25:37.798, Speaker B: Yeah, so I think what we're talking about is releasing the next Darknet version, which is going to support Taiwan in around the end of February. So it's a month or so, and I'm thinking the same timelines for the sequencer. We're going to have to internally test it and see it's equivalent to the pythonic sequencer. So that may take a week or two more. So maybe zero point 11.1 is going to include Sarc. I'm sorry, rust already.
00:25:37.798 - 00:25:43.020, Speaker B: Sark is always there. So yeah, a month, a month and a half, something like that.
00:25:43.870 - 00:25:54.830, Speaker A: That's really exciting. And when you talk about redesigning the whole infrastructure starknet relies on in a few months, I think it's pretty impressive.
00:25:56.770 - 00:26:47.440, Speaker B: About that. What we're doing is looking at our python code with the knowledge we now have for the whole system. And part of the evolution the Python code was going through is healthy. And for example, we have a component that symbolizes a single entry point and it's executable. So that's a good component we also implemented in rust. But sometimes we ask ourselves, is this specific python component needed or is it exists only because of legacy reasons and timeline and the way this darknet existing system developed? So we're questioning as we go, and we're redesigning it, as you said.
00:26:48.210 - 00:27:05.940, Speaker A: Really interesting. Yeah, sorry. And what do you think will be the impact of this rewriting in terms of performances or in terms of adding new feature? How will it impact the network and the evolution of the network in the coming years?
00:27:08.310 - 00:27:11.300, Speaker B: Yeah, in the coming years is a big question.
00:27:12.090 - 00:27:16.310, Speaker A: The coming months, what are benefits to rewriting everything in rust?
00:27:17.290 - 00:27:50.770, Speaker B: Yeah, so I think CPS wise, hopefully a sequential execution in Rust will give us order of magnitude, maybe two. So I think we're going to get to like 100 tps of sequential execution. Again, no commitments, because we still don't have benchmarks. Those are coming soon, and I think we're going to get much bigger improvement once we implement the full optimistic concurrency algorithm.
00:27:54.230 - 00:28:09.130, Speaker A: Okay, so we're going to get a one time speed up by moving from Python to rust, but then there are more functionalities you'll be able to implement, one of them being the transaction concurrency algorithm.
00:28:11.390 - 00:28:44.450, Speaker B: Yes. So I think both of the two big improvements are going to be moving to rust, then implementing the parallelization, and then they're going to be like small improvements, but I think they're always going to be like a bit more to squeeze from that. Lemon, I'm confident in the team. We have, the creative team and very brilliant people that we'll have more and more ideas and also the community on how to keep improving the executor.
00:28:45.910 - 00:29:02.860, Speaker A: Fantastic. Moving from Python to Rust is not just about changing the code base, it's about writing it. Right. And I'm not sure if you were familiar, either of you, maybe alon, were you familiar with Rust before starting that project?
00:29:04.670 - 00:29:59.226, Speaker C: So, no, I wasn't familiar with Rust at all. We started from zero knowledge of rust. First learning rust. It wasn't simple because it has a lot of limitations, especially coming from Python, which is very convenient and intuitive. It was difficult in the beginning, but as you go on and progress and learn, you notice the compiler, there's reasons for the limitations and it actually guides you extremely well and helps you write more efficient and safer code. And as of now, I feel fluent in Rust and I really like the language and I recommend it.
00:29:59.408 - 00:30:02.480, Speaker A: Nice. How did you learn it? Which resources did you use?
00:30:07.010 - 00:30:35.190, Speaker C: There is a few options. We did a course called rustlings, which is just starting to write rust. You need to correct Rust code and there's also the docs of Rust. It references the documentation and I think that's a very good place to start rustlings.
00:30:35.850 - 00:30:38.330, Speaker A: Wonderful. How about you, Ellen?
00:30:40.110 - 00:31:24.070, Speaker B: Yeah, so the same, actually. We had a submarine of the team learning rust in the first, I think two weeks before we started project. I started learning from reviewing CoD because I was abroad in the beginning when they studied rust, and then from reviewing code and starting to write myself and referring to the docs once in a while. And also there's a big community of brass, which is very wrapping and you feel like you have answers to all the questions you have. So, yeah, so it was very supporting.
00:31:25.610 - 00:31:50.926, Speaker A: Nice. I'm going to use that opportunity really quick to say that if people listening on discord or on YouTube or on Twitter have questions, feel free to ask questions. There's a community call channel on Discord. You can write your questions there. You can send us your questions on Twitter. Also going to check if there are some and you can write them also on YouTube, mostly people saying, hey, hi, Aline. Hi.
00:31:50.926 - 00:32:17.314, Speaker A: Hi, Alan. Let me check if there are specific questions, mostly people saying that this is amazing and interesting. I agree. Anyway, it's an interesting conversation. Cool. All right, so I realized recently that we're talking about the rust sequencer, but we haven't announced it yet. So maybe I front run, we front run some of our colleagues.
00:32:17.314 - 00:32:51.970, Speaker A: I'm sorry. And I'm not sorry at the same time, because I feel like it's good that we're having this conversation. But let's go back to another announcement that was made two weeks ago. There is now a new rust node implementation for Starknet, paparazz, which is also developed internally at Starquare. I'm curious if you can talk a little bit about how do papyrus and your effort complement each other or interact with each other? How do one benefit from the other, and what's the relationship between both projects?
00:32:52.870 - 00:33:36.498, Speaker B: Yeah, so that's a good question. Sopopirius is the full node effort that is done in house since Starkware, a full node of Starknet. So it was published last week with a partial implementation. They're still working on it. What we are using right now in the first milestone is their storage. They have a very efficient storage, which allows the sequencer to have a view to the state. So anytime a transaction wants to access the storage of a contract, it's non to ask, what is the contract, the class hash under some address, and so on and so on.
00:33:36.498 - 00:34:26.100, Speaker B: This is done through pure storage, which is super fast. So right now, our ground truth is our pytonic sequencers DB. So we're syncing between full node storage and this database. But in the future, when we'll have a sequencer which is implemented entirely in rust, and it's all unit in a decentralized world, sequence will have a full full node component inside of it, which is going to be synced at any given moment from its peers. But the goal of the job of the full node in terms of the sequencer is going to be the same. It's going to supply the sequencer a stage view.
00:34:28.070 - 00:34:52.700, Speaker A: Really nice. Understood. So what you're saying is that the pepperis team has also delivered a lot of innovation, and part of it is an improvement on the current pythonic sequencer, because the pythonic DB is working, but maybe a bit slow, and maybe the new papyrus DB will be much faster and so the sequencer will benefit from it. Is that correct?
00:34:54.910 - 00:35:35.160, Speaker B: Sorry. Yeah, it's correct. The reason the current Python storage is pretty slow is first of all python. And the second reason is because our storage is implemented with a patricia tree, which is the reason for that is because the service that batches transactions or blockifies them. The commitment on the storage was done in the same service. So we work with a Patricia tree because of that. And every time we needed to access some key in the storage of some contract, we needed to go from the root down all the way.
00:35:35.160 - 00:36:07.438, Speaker B: It's Patricia, but it still can be a lot of steps to go down to the leaf and then reading it from the storage. What appears have they have like a b tree implementation, but it doesn't have to do with commitment. And also it's a different database and it's a lot faster. And we don't have this constraint of having the database in the form of nodes and a merkle tree.
00:36:07.614 - 00:36:20.920, Speaker A: But ultimately the sequencer is going to be responsible for the state commencement. Right. So won't it need a patricia tree and a way to represent the state as a patricia tree? So won't it slow down anyway?
00:36:21.850 - 00:36:59.010, Speaker B: Yes, so in the beginning we said. I'm not sure we did say that, but we meant to say that the execution is decoupled from the OS, run from the commitment to know what the new state is. What is the influence of the transactions on the state is independent of the commitment of the state. We can output a state if, which is not hashed, not committed. It's like open, we can see the whole leaf, and this is enough to know the content of a block.
00:37:00.710 - 00:37:41.454, Speaker A: Okay, maybe it's a wrong parallel, but earlier we talked about the fact that in Starkx you were able to run a piece of code in a specific language, and then later commit to the execution by executing Cairo code in a specific context. Is it kind of the same thing where you will get to execute the code in a specific context with a specific database, and then later on when you need to prove and commit the state diff, you'll execute it in that new context. That will take a bit more time, but it's a synchronous, so it doesn't matter that much. Is that correct?
00:37:41.492 - 00:38:13.930, Speaker B: Yeah, exactly. We're actually debating internally if the commitment phase is going to be part of the sequencer or not, because we want to give users the best user experience and the fastest feedback they can get on a transaction, on a transaction status, on what's the next block. And for that a commitment isn't necessarily needed. Right. They just want to know how transactions affected the state. And for that we can publish status and even intermediate checkpoints of status, and.
00:38:14.000 - 00:38:19.180, Speaker A: The commitment could be done later on by another entity. Say the prover, for example.
00:38:19.970 - 00:38:21.280, Speaker B: Exactly. Yeah.
00:38:22.610 - 00:38:36.210, Speaker A: I really find it fascinating how the decoupling from block ordering and block producing and producing the proof allows this kind of distinction. It feels like we're exploring things as we go. It's really fascinating.
00:38:37.350 - 00:38:38.340, Speaker B: I agree.
00:38:41.350 - 00:39:14.960, Speaker A: All right. I think I've asked most of the questions I had. There's a big topic here, which is the transaction parallelization effort. I think there's a lot of things to say. So I hope I'll be able to get you both on another call to talk about that because I know you've been working on it and so far you've implemented a little bit, but there's a lot more. But let's keep it for next time. So people listening and interesting into that topic connect back on another community call and we'll talk about it again.
00:39:14.960 - 00:39:23.440, Speaker A: In the meanwhile, are there topics you wish we had talked about? Is there anything else you want to mention?
00:39:29.290 - 00:39:46.860, Speaker B: No, I think we're good. Maybe many more features to come. And we're working hard on user experience. We want you to have the best experience setting transactions, working on top of circnet, and I hope we can achieve that.
00:39:49.570 - 00:40:10.180, Speaker A: Fantastic. Well, with that, thank you again, Ellen and Alan. Well, thank you for your work and what you're doing. I'll be very curious to see. I was going to say I don't know the name of your project. Do you have an id for the name? You don't have to tell us, but do you have an id?
00:40:13.830 - 00:40:14.734, Speaker B: Go ahead, Alan.
00:40:14.782 - 00:40:18.120, Speaker C: Maybe Alicia, the name for the project.
00:40:18.570 - 00:40:22.978, Speaker A: You don't have to say it, but do you have some ideas?
00:40:23.154 - 00:40:38.506, Speaker C: Well, we have a name right now. We call it the block of fire because it makes blocks. But, yeah, that's the name we're using for now.
00:40:38.608 - 00:40:40.270, Speaker A: That's the internal name. Nice.
00:40:40.340 - 00:41:00.340, Speaker B: Yeah. The thing is that I think next week we're going to publish our initial repo. So that's the specific part we talked about, which is a blockifier, and the sequencer is like a big component that contains it. If you have good ideas, we're happy to hear.
00:41:01.190 - 00:41:25.850, Speaker A: That'd be fun. Cool. All right, so let's wrap this up. Thank you for being here. People in the audience, thank you for attending. Yeah, let's run ads real quick for the end. As most of you know, probably by now, but there is a really cool conference coming up in the next two or three weeks in Tel Aviv, Starquare sessions.
00:41:25.850 - 00:41:54.834, Speaker A: There are still some tickets, so make sure to book them if you want to attend. The session, there will be a lot of really interesting talks about cryptography in general. Ethereum account abstractions. Account abstraction. And if you have more questions on the rust effort, Ellen and Alan are probably going to be around. So you'll be able to say, hey, I saw you on community calls. I have a question for you.
00:41:54.834 - 00:42:14.220, Speaker A: And so you'll be able to talk with. And so be sure to be there in the meanwhile. I will. We will do another committee call in two weeks, and that's it for this week. Thank you, everyone, and see you soon.
00:42:15.230 - 00:42:17.590, Speaker C: Thank you very much. Bye.
