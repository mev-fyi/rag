00:00:00.490 - 00:00:44.934, Speaker A: Hey there, my name is Sir Kynes, and welcome to the fifth episode of the scalability series. Today we'll explore Sharp, the proving system developed by Starkware, and we'll see how it's scaling Ethereum. Sharp, which stands for shared prover, is a proving system used by Starknet and Starkx that takes as an input a program execution and outputs a stark proof that attests to the validity of the program. This proof is then sent to the l one verified contract on Ethereum once verified, the updated states of Starknet and Starkx are accepted and settled on Ethereum. This means that L2 transactions inherit the security of Ethereum. But why are we talking about a shared prover? Who shares what? Let's say that we have a perpetuals, a spot trading app, and an NFT platform, all running on the same network. As apps are being used and transactions are being made, their execution is sent to one common system, which is sharp.
00:00:44.934 - 00:01:25.698, Speaker A: The transactions cause a change in the state of the network, and Sharp is responsible for telling Ethereum that this change is correct. As all transactions go through the same proving system, the apps share the same stark proof at one point in time. This method saves costs in the proof generation and increases efficiency. So how does sharp scale Ethereum? Sharp scales Ethereum because it aggregates multiple transactions into a single proof that is later validated on the mainet. We're splitting one Ethereum transaction among multiple L2 transactions. Costs are lower because verifying a stock proof on Ethereum is much less computationally intensive than naively redoing the transaction to check its validity. So how does sharp work? The sharp system takes as input the caro jobs, which are the executed caro programs.
00:01:25.698 - 00:02:05.134, Speaker A: This is also the execution trace of the program, the description of every step that took place during the program's execution. Ultimately, we're proving to Ethereum how the execution of a L2 smart contract changed the state of the network through the steps of its execution. So how does sharp deal with these Cairo jobs? Initially, Sharp worked on a linear schedule, meaning that as Cairo jobs would enter the system, it would wait for enough jobs to fill a batch. Sharp would then create a stark proof of the filled batch. This method of creating proofs allowed for roughly 128,000,000 Cairo steps to fit into a single stark proof. But waiting for the batch to fill up and proving all the transactions at once would cause blocks to take several hours to settle on Ethereum. So sharp now operates on the recursive scheduling.
00:02:05.134 - 00:02:30.918, Speaker A: Instead of waiting for the Cairo jobs to fill up a batch, we send the Cairo jobs directly to the approver the moment they get into the system. Suppose that we have four Cairo jobs. We create a proof for each individual Cairo logic. We then verify, using the L two Cairo verifier the proofs in pairs. This verification is then proven. In other words, we're proving the validation of the proof of the two Cairo jobs. You might have guessed it, but next we verify the proofs of the verifications, and so on and so forth.
00:02:30.918 - 00:03:00.354, Speaker A: This is what we call a recursive tree. Once enough Cairo jobs have entered a tree and we created our recursive proof. Then we send this proof over to the on chain solidity verifier. Even though we're generating a lot more proofs, there are significant benefits to using recursive proofing. Sending a stark proof to Ethereum is now four times faster, because instead of waiting for a batch to fill up, we prove Cairo jobs as they enter the system. We can also create larger proofs because we're compressing a proof multiple times. Since we're verifying recursively, we can now fit 16 times more Cairo steps in a single star proof.
00:03:00.354 - 00:03:24.300, Speaker A: In other words, more transactions are sent to the main net. Also, the recursive verification leads to lower cloud costs because the decrease in the time we take to create a stark proof consumes a lot less memory compared to linear scheduling. And that's it. Sharp is a proving system that scales Ethereum because it aggregates multiple transactions into a single recursive stark proof that is later on verified on Ethereum. I hope you enjoyed this episode on sharp, and I'll see you in the next one.
