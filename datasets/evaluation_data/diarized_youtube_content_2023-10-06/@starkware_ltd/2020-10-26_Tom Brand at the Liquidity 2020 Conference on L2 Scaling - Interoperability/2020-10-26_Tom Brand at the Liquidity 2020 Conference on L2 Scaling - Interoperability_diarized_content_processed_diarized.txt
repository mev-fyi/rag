00:00:02.280 - 00:00:02.830, Speaker A: You.
00:00:06.240 - 00:00:21.070, Speaker B: Hey everyone, welcome to day three of Liquidity 2020. We are kicking things off with Tom from Starkware. He'll be doing a talk on L2 scaling interoperability. Once he starts talking, can you guys confirm in the chat that you can hear him?
00:00:22.400 - 00:00:49.956, Speaker A: Hi everybody, good evening, or good morning, and thank you for having me here. My name is Tom Brand. I'm a product manager and a researcher at Starquare. Before I begin, I just wanted to say this is like all this corona time is a bit hectic. Time. I don't know. 20 minutes ago I put my baby to sleep.
00:00:49.956 - 00:01:48.488, Speaker A: Then I have to get my other child out of the room, and now I'm here and I have to do the contact switch. So this is on one hand, and on the other hand, it's kind of nice because it's much more intimate. There's no big stage, it's just me sitting here, the same place I sit a few hours ago and describing to you what we do in our work at the same place. Anyway, I'll stop rambling. Let's get to what you came here for. So today we're going to talk about L2 scalings and specifically how do we plan to solve the problems it creates from interoperability point of view. So I will talk a little bit about Starquare, then I will describe our L2 scaling solution again very shortly.
00:01:48.488 - 00:02:24.970, Speaker A: If you have any questions, don't be afraid to ask. And then I'll describe in a stepwise approach to solve those interoperability issues. One step at a time. So let's begin. Yeah. Okay, so Starquare is a startup based in Israel. It was funded almost two and a half years ago, and we are already close to 40 team members with the majority of us are engineering and product.
00:02:24.970 - 00:03:30.072, Speaker A: We have funding in two equity rounds of approximately $36 million, and also a very generous ground from the Ethereum foundation, which was for us to develop an open source Stark prover, which David, also from Starcore, will be speaking about it tomorrow, 1 hour from now. And our first product was Starkx, which was a L2 scalability solution. And our customers for Starkx are diversify, which already have a deployed exchange working on Mainnet immutable, which will hopefully soon we'll have one UIDX and paraswap. And today we're going to discuss how we take all those targets, deployments and turn them into a connected ecosystem. So this is a bit intimidating. Slide. I won't go into the details.
00:03:30.072 - 00:04:52.616, Speaker A: So just to give a very quick overview on Starkx, so Starkx is a L2 scalability solution. It uses validity proofs, which are also known as ZK proofs. And like all other L2 scalability solutions, its main purpose is to offload both computation and storage from the layer one and do them on L2 and still maintain the security that layer one gives us. So generally speaking, how we do it here we have the Ethereum, we have some off chain services, and Startx maintain his state in the off chain and on chain we have only a commitment to the state a root, and we push state updates to this commitment representing state updates in the off chain state. Now, how do we make sure that those state updates are correct? We also generate proofs attesting to the validity of those state updates. Okay, so whenever a state is updated in a Starkx system, a proof attesting to the validity of this state is also submitted to the chain. And so every state is always final.
00:04:52.616 - 00:05:48.664, Speaker A: How do we achieve scalability with this kind of solution? The way we do it is by batching together many user interactions into a one state update. And since the proofs are sublinear at the size of the computation, the actual cost on chain is also, sorry, polylogarithmic in the size of the computation. Also the cost of making a state update on chain is polylogarithmic in the actual computation that was done off chain. So it is very fast. The main things you need to know is that users do transactions off chain when they want to interact. With Ethereum we do a state update and it is accompanied by proof. And I think this is mainly now this is very good.
00:05:48.664 - 00:06:50.700, Speaker A: It creates a massive scalability. As you can see, this is some of the key features of Stark, but for example from scalability point of view, we demonstrated on Mainet a tremendous scalability of 18k transfers in seconds and also nine k trades. We demonstrated various functionalities of minting and burning and token distribution, stark support, transferring and trading in multi assets. And as I've said, the scalability is gained through the gas reduction that we achieved by the tools. More than that, Starkx and the technology that Starquare is developing supports general computation. So I think it was two weeks ago we announced maybe more. We announced Cairo, which is the language that we are using, and the architecture of a proof system that we are using, which allows us to generate proof for arbitrary logic.
00:06:50.700 - 00:07:46.844, Speaker A: And in the system, for example, that we are developing with the DyDX, we demonstrate exactly how we can custom tailor a system for the customer needs. And the last feature is what we're going to talk about today, but is the interoperability between Starcake systems. So let's first understand what is the problem. The problem is that our apps, which are deployed on mainet in the naive implementation, are siloed and moving between them or moving to the layer one is inefficient. Let me explain exactly what I mean. So here we have the bottom, the Ethereum blockchain. Here we have the Starkx ecosystem, and we have two applications now just to compare some interaction.
00:07:46.844 - 00:08:45.120, Speaker A: So when users want to, for example, trade in an option system, it is very fast. You can see here with the three rabbits, it is very cheap. An onchain transaction is more expensive, much more, and is also more slow because it is only in a block. And the two main things that we need to understand is that there's no way to interact between those two applications and going on chain. For example, if Alice wants to withdraw her funds to her on chain account, usually what you need to do is do it through a proof. And this takes more time than trading or Ethereum transaction. It can be on the orders of tens of minutes, and it costs on the same order of magnitude as the regular Ethereum transaction for Alice.
00:08:45.120 - 00:09:37.836, Speaker A: Okay, now that we understand the problem, let's see how we solve those two problems. First, how do we interact with Ethereum in a fast and efficient way? And then how we transfer funds between two startup applications in a fast, efficient way. And I forgot to say it, but we're in blockchain. So what we describe here is trustless mechanism. Let's see how. So, step zero, which is already implemented in our upcoming version, which at the end I will share a bit more timelines, but it will come in the coming weeks, is fast and process exit. So the purpose of this step is to allow users to exit from the system in one Ethereum transaction.
00:09:37.836 - 00:10:08.940, Speaker A: What does it mean? It means that we are not dependent improved. Right. And the cost is one et transaction. And furthermore, we want to allow users to interact with Ethereum not only to transfer funds to their accounts, but maybe to see more interactions. And we'll see in a second. And in order to facilitate those requirements, what we use is a conditional transaction. Conditional transaction is an off chain transaction means it is a transaction that is done in the off chain state, not on Ethereum.
00:10:08.940 - 00:11:13.532, Speaker A: And the special property of a conditional transaction is it is valid only if an onchain transaction has occurred. Okay, maybe it's a bit confusing. Let's see a diagram. So again, we have here one startx application and the Ethereum blockchain and what we want to achieve here is for Alex to move her funds from her off chain account to her on chain account. What we do is we use a liquidity provider which has available funds on chain. And what I just described, a conditional transaction. So Alice is signing a conditional transaction, transferring some amount, let's say of east, to the liquidity provider, when the condition of this transaction is that the liquidity provider will transfer funds to Alex, right? So this transaction is not valid, meaning we can't generate a proof to it unless the liquidity provider transfer funds to Alice.
00:11:13.532 - 00:12:19.792, Speaker A: So once the liquidity provider has this transaction, he can execute the transaction on chain and then the transaction off chain can be executed because the condition has met. So what we achieve here is a fast and trustless exit for Alice, but we can also expand. So this is just for comparison. But what we just described is Alice withdrawing funds to her account on chain. But we can also do the condition on a much more complicated ethereum transaction, for example an Amm trade or lending token to compound, for example. So Alex can say, I will give Dai to a liquidity provider if he will lend them on compound and return to me CDAI. So what we achieve here is that we can now use all the funds that we have in the Sarkic system to interact with Ethereum in a fast and process manner.
00:12:19.792 - 00:13:26.296, Speaker A: Okay? And I hope this was understandable. If you have questions, please ask. Now, we solved the first problem, and the second problem is how we construct bridges between different Starkx applications, right? So again, we have here two applications and we saw how we can do a fast withdrawal, how we can do a fast exit. So if we want to move funds from Alice account on app two to application one, we can do it in a naive implementation, right? We can do a fast withdrawal, then Alice can immediately deposit the fund to the application. The problem with this approach is that first of all, it costs a lot of money. Meaning for each transfer you have to do at least two ethereum transactions, which today is not negligible and is also not very fast because you have to move to Ethereum. And the idea to solve this is also to use conditional transactions.
00:13:26.296 - 00:14:08.520, Speaker A: But now we condition on an off chain transaction. Before we said we condition an off chain transaction on an ethereum event. Now we are saying we have an off chain conditional transaction, which is the condition is now a different off chain transaction. Let's see what happens here. It is a bit more complicated, but you'll be fine. Okay, so again, we have here Ethereum, we have two applications and we have here Alice with their account on application two, an account on application one. And we have liquidity provider, which has an account on application one, an account on application two.
00:14:08.520 - 00:14:56.920, Speaker A: Note that there is no accounts on Ethereum that are involved. Right? So the first step is that Alice signs a conditional transaction. But now the condition is not the liquidity provider transferring funds on chain to Alice, but the liquidity provider transfer funds on a different application to Alice. Now, once the liquidity provider has this transaction signed, knows he can transfer the fund. So we execute the transaction. And now this is a bit more tricky part, but I promise you it's fine. The problem here is that application two need to know about what happened on application one.
00:14:56.920 - 00:15:44.744, Speaker A: And as we've said before, it's not the same state and they cannot communicate, so they somehow need to verify it through the blockchain. Let's see what happens. So application one batches transaction as it always do, and post a state update as part of this state update. One of the transactions that is included in the state update is the execution of this transaction. Now once this application see that this transaction is indeed final, it can execute the conditional transaction transferring the funds from Alice to the liquid provider. Now we need to finalize this batch. So what happened is that we have, I just moved it, so it will be more clear.
00:15:44.744 - 00:16:40.890, Speaker A: We have a state update from application two. And what happens in this state update is that the onchain contract checks in the other application contract if the transaction was indeed included. If it was included, the proof gets accepted and the state is finalized. If it was not included, meaning Alice didn't get her funds on application one, the state is reverted and Alice gets her funds on application two. So what we get here is that Alice, in a processed way, received her funds on application one. And first of all, it was very cheap because we didn't go through Ethereum. And it was very fast because from Alice perspective, all she did was sign an off chain conditional transaction and then immediately the transaction was executed on the other application.
00:16:40.890 - 00:17:22.996, Speaker A: Okay, anyone have a question about it? So far, very good. Okay, we're approaching the end now. We need to understand, so we said it was very inexpensive from the perspective of Alice, but let's understand if there are maybe other costs that are involved in this process. So the first cost that is involved here is the capital efficiency cost. And what I mean by that is that we are using a liquidity provider to enable the breach. Right. And this liquidity provider has some costs involved with the capital that he's providing.
00:17:22.996 - 00:18:18.250, Speaker A: And here the effective parameter is the finality of the state rendition. So what I mean by that we need to understand, going back to the diagram, we need to understand when the liquidity provider gets his fund and he can use it for anything else. He can use it when the conditional transaction was executed on application two. Now when this conditional transaction can be executed once this application sees that the state of application one was finalized. Now, as I've said before, those state updates can be very frequent. The generation of the fruit depends on the size of the batch, but it can be every few ten minutes, right. The locking of the funds of the liquidity provider is on the order of tens of minutes, which is very short.
00:18:18.250 - 00:19:17.710, Speaker A: Now, the other cost that we have here is the on chain cost. If you remember the state update of application two involved somehow validating on chain that the transaction was included. Now you may think that this is a big overhead, but actually it is quite a small overhead because I'm not getting into the detail. We will publish it soon. But most of the validation is done off chain and is done by the cooks. And the actual validation on chain is very small and it's actually constant per state update and it does not increase with the number of transactions. So what we get here is that both the cost of the liquidity provider and the on chain cost of validating the transaction was indeed included, is very small.
00:19:17.710 - 00:20:21.970, Speaker A: This is the end of step one. Step two for us is increasing those bridges to other l two technologies. We do not believe that at least in the following years, there will be only one L2 scalability solution which will rule them all. And so what we plan to do at the next step is to define a standard which will allow anybody who implement what are the minimal requirements to construct these trusted bridges between Starkx and their l two technologies. Just I will brief through it, because it is the topic for a whole other presentation. But very generally speaking, you need to have two things in order to be compatible with this protocol. One is you need the ability to prove the execution of a transaction in your state.
00:20:21.970 - 00:21:35.144, Speaker A: For example, you can have history tree representing all the transactions that occurred in your system, right? So this is the first requirement. And the second requirement is the ability to condition a transaction in your system on the execution of a transaction in a different system, right? The same way we did in what I described. And if we look at the leading technologies that we have today for L2, then this requirement works pretty natively with other Zk rollups, because the state structure and cryptographic primitives that are being used is quite efficient. In both cases you can also work with optimistic roll up, but there we have much less efficient. First of all, from the perspective of the liquidity providers because again, finality is the queen in optimistic roll ups, the finality times are much, much higher. If we said the tens of minutes there, it can be on the order of days. We have a factor of almost 1000.
00:21:35.144 - 00:22:38.270, Speaker A: So this is also the factor of the cost for the LP. And the cryptographic primitives that are being used are not always proof sufficient. Okay, so this is a very quick summary of the left step. Now I'm running out of time, so this is fine because we're at the last slide. So just talking about timeline step zero, which we described as best trustless exit and also interaction with Ethereum is ready now and will be deployed in the coming version of diversify in the coming weeks and will also be included in the deployments of immutable UidX and Paraswap. Step one will be a shift in the next version of Starkx, which is pretty close. It will be quarter one of next year.
00:22:38.270 - 00:23:20.490, Speaker A: And connecting to other l two s is hopefully from then and onward. Yeah, and that's it. So thank you very much. I'm very excited for everything that's happening in this space and specifically to how the stark system will look like in few months from now. This is my handle on Twitter and Telegram. Feel free to reach out and ask whatever you want and have a good evening or morning or wherever you are. Thanks.
00:23:20.490 - 00:24:45.670, Speaker A: I don't know how to close it, but it's a good time for a question. Oh, there's a question. Okay, so Jacob, and forgive me if I'm not pronouncing it correctly, but he's from the galactic council, is asking what about interoperability with other chains like Polkadot Parachain? So this is a very good question. With other chains there are many possibilities. One of them is to actually deploy proofs verifier on those chains and then you can have two places which are connected to your state and on both of them you can update the chain. But this is a totally different, totally different problem because now you have problems of synchronicity between the state updates. But generally speaking, I think the first part of deploying Stark verifier on another chain is something that we know we want to do and it's not a problem.
00:24:45.670 - 00:26:14.556, Speaker A: And then you have the question on how you create the synchronicity between the state updates on Ethereum and chains. And this is something that I haven't thought about a lot and I think it's a very interesting problem. Hi Chloe, Chloe is asking, is there any work being done allowing Viper to be used with Cairo, or is solidity the only language being implemented currently? So yeah, Cairo is okay. So I will give a bit of a background. Cairo is the architecture of our group system that we are using which allows us to have one verifier and write Cairo programs to it, allowing us to use to basically write programs and not errors that we had to write before. Now we demonstrated two weeks ago how we take a simple solidity code and compile it to. I mean we didn't choose either Cairo, either solidity or viper.
00:26:14.556 - 00:26:57.050, Speaker A: And I think there are advantages to each choice. In the coming weeks or months we'll start share more about Cairo, and once it's open I think that anybody will be able to start writing those compilers. Everything is open. Thanks. Any more questions? You okay? Thank you. Not sure how I close it.
00:26:58.560 - 00:27:08.830, Speaker B: Awesome. This was a really great talk. So we're going to transition to our next session now. Do you have any final words you want to share?
00:27:12.340 - 00:27:19.952, Speaker A: At the beginning I gave a bit work and family life, asked a third.
00:27:20.006 - 00:27:21.024, Speaker B: Question if you want to answer.
00:27:21.062 - 00:28:20.836, Speaker A: Oh nice. Okay so sora hi. Do Zika roll up applications share the same group of aggregators for the proof generation? I'm not sure I completely understood the question, but I will try to answer. Correct me if this is not what you asked. So different ZK roll up applications on our ecosystem Starkx. So they use the same technology and so they use the same verifier on chain. And looking into the future again, maybe you'll hear about it more in the coming weeks, but they will also be able to share proofs, meaning we'll be able to take programs from different applications on the Starkx ecosystem and to generate one proof for all of them.
00:28:20.836 - 00:29:18.170, Speaker A: And then they will be able to share the cost of the proofs. When you're looking at other zkarolok applications, then there you have a wide variety of proof types and different proof types do not share I'm not sure this is the correct term, but do not share the aggregator for the proof generation. So they will be in different proofs, not using the same verifier. But for Starkx application we have the same verifier and we can batch those proofs together to one proof and each application is represented by its own Cairo program. Hope this answered your question. If not you can reach me. I'll be happy to answer.
00:29:19.020 - 00:29:27.140, Speaker B: Tom, this was fantastic. Thank you so much for taking the time and have a wonderful weekend remaining. All right. Bye.
