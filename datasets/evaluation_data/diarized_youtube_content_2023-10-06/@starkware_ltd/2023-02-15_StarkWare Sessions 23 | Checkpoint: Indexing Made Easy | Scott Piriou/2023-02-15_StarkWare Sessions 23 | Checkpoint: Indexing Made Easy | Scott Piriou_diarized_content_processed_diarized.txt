00:00:03.050 - 00:00:28.306, Speaker A: So thanks for coming to my talk. I'm Scott Pierreu. I work at a company called Snapshot and not Snapchat. We do voting solution for daos. Maybe you've used us, maybe you haven't. If you haven't, come and say hi. And basically, a year ago, we started working on something called Snap X, which is basically snapshot, but on chain.
00:00:28.306 - 00:00:55.550, Speaker A: And not only on chain, but on top of it. It was designed to be on Starknet. So we set out ourselves to work on this and we quickly realized that we were missing a big tool that was an indexer. So basically we needed a way to know when people created new proposals and new votes. And we didn't have a tool to do that. So we built an indexer for ourselves. And this indexer is called checkpoint.
00:00:55.550 - 00:01:46.080, Speaker A: And now some of you might be wondering about what the hell is an indexer, and I'm here to explain it to you guys. But in order to understand what an indexer does, we first need to make sure that we all understand what an event is. So what are events? Events, you can see events as like a little piece of code that you put inside a smart contract. And that can be used for basically two things. The first one is like to kind of communicate with what I call the outside world, with everything that is not inside the smart contract, so that people looking at the smart contract can know what happened on the blockchain. And you can also use it as a kind of little trick for cheaper storage form. A good example of that is an ERC 20 token transfer.
00:01:46.080 - 00:02:35.546, Speaker A: So for example, if I'm sending, I don't know, ten Ave tokens to Bob, I call the function transfer on the contract and it updates my balance. It decreases my balance, increases Bob's balance, and it also emits an event. And with this event emission, anyone looking at the blockchain can see, oh, actually Scott sent 20 token to Bob. And that's really useful because for example, when you go on ether scan, you're really happy that you can go into click, is it called ERC 20 or token transfer or whatever and see exactly how much you sent or how much you received. It's quite handy for everyone who's looking at the blockchain. So now that we know what events are, we can talk about checkpoint. So what is checkpoint? Checkpoint is an indexer.
00:02:35.546 - 00:03:18.102, Speaker A: So what is an indexer? It's like basically a piece of code, a program that you run and that allows you to look at all the events and pick the one that you want to track and do stuff accordingly. So it works out of the box. There's very little setup to do. And in our checkpoint implementation, you basically look at events and if you see them, you can insert them into a database. But not only can you insert them into the database, but you can also run other custom code. For example, we could set up an email notification system or other stuff. It also generates and exposes a graphql API.
00:03:18.102 - 00:03:58.354, Speaker A: So that's like code jargon to say that it's really easy to interact with. It's fast and modular. And you can think about it as the graph on Starknet with the little sublet heat that it's written in javascript and not in assembly script or anything that compiles to wasn't. Okay, so how do I use it? It's really easy to use and that's why what we had in mind when we designed checkpoint, we wanted to make sure that it was really easy to use. So the first one is you just set up a configuration file. So I want to track this contract and I want to track this and that event. Then you define a graphql schema.
00:03:58.354 - 00:04:20.270, Speaker A: So that's basically structure. You want to say it's like a couple of lines of code. I wanted this and this and that information to get stored in the database. Then you define what we call writers. So that's the writing logic. I'll talk more about this in next slides. And then you simply profit.
00:04:20.270 - 00:05:04.058, Speaker A: So for this talk, I wanted to have an example, because I tend to work with examples to make sure I understand correctly. What I found pretty amazing is like the Stargate web page doesn't have an analytics page, actually. So there's no way to monitor how much money came in and how much money got out. For those that don't know what the Stargate bridge is, it's basically a bridge where you can send Ether from Ethereum to Starknet and Starknet from Ethereum to Ethereum. Okay, so let's fix that with checkpoint. So step number one, as I said, configuration file. So see here, you can see the configuration file.
00:05:04.058 - 00:05:44.230, Speaker A: I don't know if you can read, but basically we provide the contract, we provide the ABI. So the ABI is something that you can get on stark scan. Then we provide the start block number because it doesn't make sense to track, I don't know, the event of a smart contract that was only deployed on block number 200 and start looking at block zero. It's not even live, so it doesn't make sense. And then you provide the events. So in our case, we're going to want to look at the events withdraw initiated, which is when people will take back their money from startnet to ethereum and deposit handle. When people deposit from ethereum to startnet, then we define the schema.
00:05:44.230 - 00:06:12.334, Speaker A: So the schema is a simple structure. Here we have id to make it unique. The deposit count, the deposit amount, the withdrawal count, the withdrawal amount, the day, the month and the year. So that's what we are going to insert into our database. And then we define the writers. So what are writers? Writers are the functions that get called when events are found. So checkpoint is going to run some code, and for every block it's going to look at every transactions.
00:06:12.334 - 00:06:43.214, Speaker A: For every transaction it's going to look at every event. And if it sees one event that you specify that you wanted to listen to, it will call the writer function. So those functions, they take the event, they format the information, and then they insert it into your database. For example, in our case, we need to write two writers. So handle deposit and handle withdrawal. Then we need to get the deposit amount, format it into a human readable format. So for example, 0.5
00:06:43.214 - 00:07:06.020, Speaker A: ether. Then we need to retrieve the block timestamp and determine to which month it corresponds, to which year corresponds, and to which day it corresponds. And then we can insert all of that into a database. And once we have that, then we can profit. We start up our database. In our example, we simply need to run Docker compose up. Then we start a server yarn dev.
00:07:06.020 - 00:07:45.886, Speaker A: And then we actually provide you with a simple interface to interact with your database. So if you go to localhost 3000, you can see this playground and start interacting with your data. So here, for example, you can write first or you can order by or skip. You can do lots of really useful stuff like this to play around with your data. And what we did for this example, we actually took this data and created a little graph. And that's the data we came up with for the withdrawal and deposits from the November 1 till today. It's actually quite funny.
00:07:45.886 - 00:08:22.270, Speaker A: We didn't look really into it, but it's quite funny that the withdrawal amounts spike up regularly like this. We don't know if it's linked to maybe the weekends or stuff like this, but interesting data nonetheless. And so, just to recap of the whole process I had to go through, I simply copied a file, the ABI file that I found on star scan. I defined two different structures. I wrote two handler functions, and it works. So it took me about 15 minutes. And I'm sure, I could get this to like eight minutes if I were faster.
00:08:22.270 - 00:09:19.710, Speaker A: And now a little bonus slide is why is it called checkpoint? So as I said earlier, when we run checkpoint the first time, we go through every block, and for every block we look at every transaction. And for every transaction, if there's an event that got emitted by the contract that you specified, we basically checkpoint it. We write it down in the database. And what this allows us to do is that if you ever need to resync your database, say, if, I don't know, I want to edit one of the schemas, or I want to insert a new thing or listen to a new event or something like this. Instead of resyncing everything from the start, we won't be looking at every block, but we will just be looking at the blocks that were previously checkpointed. And this makes resyncing really, really fast. And that's actually quite nice, because as we all know, sometimes we write code and like two weeks later, oh, I need to track this other event or stuff like this.
00:09:19.710 - 00:09:48.210, Speaker A: And since resyncing is really fast, it's quite convenient actually to use, well, I think I had ten minutes or 15 minutes. I don't see the timer, but I think it's this. You can look at the code. Everything we do at snapshot is open source, so it's on GitHub.com, Snapshotlabs checkpoint example. And if you want, you can play around with the API on example checkpoint, FYI. Thank you for listening.
