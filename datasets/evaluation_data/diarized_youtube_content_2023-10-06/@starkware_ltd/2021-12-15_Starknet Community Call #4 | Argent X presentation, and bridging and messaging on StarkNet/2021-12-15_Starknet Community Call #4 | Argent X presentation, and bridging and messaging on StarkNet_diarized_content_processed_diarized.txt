00:00:00.570 - 00:00:17.470, Speaker A: It. Okay, I think we're all set. I'm starting to record. It's 237. Let's get started. Welcome to this fourth community call. I'm happy to see so many people connected once again.
00:00:17.470 - 00:01:07.278, Speaker A: We have about 140 people connected both on Discord and on Zoom for. So our last community call was an improvised one for the launch of Starquare on Starknet on Mainnet. Since then there has been a few application that have been released. One of these is Argent X. So today for our community call, we'll have Julien from Argent presenting Argentix and speaking about the work they're doing both on Argent and on Starknet. And then we'll have Tom joining us and we'll have a small AMA as we usually do. And today we want to talk about the roadmap.
00:01:07.278 - 00:01:47.870, Speaker A: What's ahead? Transaction status update and bridging and messaging on Starknet. So that's the program for today. You can ask your questions in the community call channel and we'll answer them during the AMA. For those wondering, there won't be popes today. And that's it. If you're on discord, there's a zoom link on discord you can join to see Julian's screen. If you want to stay on Discord, you can follow the slides on the Google Doc Julian just shared.
00:01:47.870 - 00:01:53.220, Speaker A: And with that Julian, I'll let you present.
00:01:54.310 - 00:02:06.840, Speaker B: Thank you, Henry. I still think you need to enable me to share my screen so people on Zoom can see the slides and then we will be all set.
00:02:07.450 - 00:02:09.400, Speaker A: I think that's fine now.
00:02:11.850 - 00:02:12.600, Speaker C: Cool.
00:02:13.930 - 00:02:14.680, Speaker A: Yes.
00:02:15.850 - 00:02:20.090, Speaker B: Can you see my screen okay for those on Zoom?
00:02:21.150 - 00:02:22.380, Speaker A: Yes, we can.
00:02:23.790 - 00:02:49.170, Speaker B: Fantastic. Okay, so first of all, thanks for having me. I'll try to be as short as possible. But yes, I want to take that opportunity to present Argentx. I'm Julian, one of the three co founders of Argent. Hopefully some of you know the Argent mobile wallet. But today I'll speak about a different product, which is Argentx, the first wallet on Starknet.
00:02:49.170 - 00:03:25.920, Speaker B: But before I start explaining what Argentx is, I wanted to say what Argentx is not to make things completely clear. So Argentx is not a browser version of the Argent mobile application. These are two completely separated products. For now, our mobile app works on Ethereum L1, and on Zk sync, and Argent X runs on Starknet. So two completely separated products. The fact that you have an account on one doesn't mean that your account is translated to the other. So please, for the moment, treat it as two separate products.
00:03:25.920 - 00:03:29.230, Speaker B: So this being clarified.
00:03:34.070 - 00:03:34.820, Speaker A: Okay.
00:03:36.630 - 00:04:07.366, Speaker B: So now what is Argentx. So Argentx is a wallet for Stacknet. It comes as a chrome extension. That means you can download it from the Chrome store. Its main feature for now is that it supports multi accounts, so you can have multiple accounts. On Argentx, it is multi stacknet network, which means that you can use Zed on Testnet and on Mainnet, and then it provides the key features of a wallet. You can send and receive tokens and you can interact with dapps.
00:04:07.366 - 00:04:42.854, Speaker B: So from a user's point of view, it's more or less equivalent to a metamask, but of course in ten times better. But again, I want to emphasize that Starknet still is alpha in alpha and so is Argent X. So please do not store any meaningful value. These are really the early days. We release Argent X as soon as possible because we wanted to help DAP developers build great dapps on Starknet and focus on their DAP and not on the wallet side. But of course these are the early days. We are iterating fast, so it will be an amazing product in a few weeks.
00:04:42.854 - 00:05:29.666, Speaker B: So it's starknet. But for the moment, be careful. If you breach tokens as soon as it will be available, do not bring any meaningful value on Argentx. So how does Argentx works? First, to take a step back, it's important to understand what account abstraction is. So on Ethereum Mainnet, when you have an account, actually this account is tied to a private key. So when you have a private key, you can derive an account which will be located at the address of that private key. And actually these two objects are one and the same thing, because at the level of the Ethereum protocol, the account was hard coded.
00:05:29.666 - 00:06:15.460, Speaker B: The logic of the account was hard coded, and that helped Ethereum iterate fast. But it has some consequence in terms of security and user experience. An important one, for example, is that the entire security of your account lies in this private key. And that's one of the reasons why people like Vitalik Butrin, for example, have tried to bring account abstraction to Ethereum mainnet for the past four years. But of course that's complicated because Ethereum is a life system with a lot of money. So it is hard to make this change at the foundation level. But fortunately, Starknet, starting from scratch, has decided to enable account abstraction from day one, which I think is a fantastic opportunity.
00:06:15.460 - 00:07:06.594, Speaker B: But that means that with account abstraction, every user account is actually a smart contract that you need to deploy and operate. So that means that to interact with the network, you need to have an account contract. And so now coming back to Argent X. Argentx, the extension, the wallet then manages these two objects. It manage keys that can authorize transaction and it manage an account contract that can execute operation on the network. So that means that when you create a new account with Argentx, we are actually in the background deploying an account contract and making a private key, the only key that is authorized to make transaction on that account contract. So that may seem a bit complex at first, but the good news is that actually the wallet, like Argentx, abstract that complexity for you.
00:07:06.594 - 00:08:06.338, Speaker B: So as a user, you don't necessarily need to understand all that. All this is abstracted and managed by Argentx. But since I believe we have a lot of developers on this call, I just wanted to explain that, for example, when you create a new account, it will take some time for that account to be ready, because actually we need to deploy a smart contract on the network. Now, how does that work? Well, it actually works exactly like your metamask works today. If you go on a DAP that supports Argent X, you will connect your wallet to the DAP. And then if you trigger an action on that DAP, so you click on a button to do something on the blockchain, then ArgentX will actually sign that information with the private key and then tell the account contract to execute the operation and it will pass the signature as part of the call data. And then the account contract will relay that transaction to the target DAP contract.
00:08:06.338 - 00:09:30.194, Speaker B: Again, as a user, exactly like in Metamask, you see an action on your DAP, you click do something Argent X opens, you confirm the transaction and it's automatically executed on chain. Now if you want to understand a bit more as a DAP developer, if you are building dapps today, you're probably building using Starknet JS. So Starknet JS is a great library that basically let DAP developers interact with Starknet. And so if you're programming against Starknet JS in your DAP, actually when you connect your Argentx wallet, what it will do is that it will inject a signer into starknet JS, so that for you as a DAP developer, it is completely transparent. You program against Stacknet JS and Stacknet JS will, through the signer object, will interact with ArgentX and everything will be executed transparently to you. To make these things even simpler, we have created a lightweight NPM package called Get Starknet, which will basically get the Starknet object for you and manage the connection through Argent X. So if you see my screen, you can see that you can literally add support for Argent X in three or four lines of code.
00:09:30.194 - 00:10:32.274, Speaker B: So there's literally no reason to do so today. And actually that's basically what there is to know about Argent X. So just to recap, as a user, exactly like you would do with Metamask, but again with a better user experience, I believe as a DAP developer, again, exactly what you used to do, except that not using ETL JS, but for Stacknet, you're using Stacknet JS and things will work exactly as you expect them to do. So as I mentioned earlier, Argentx is still early, these are the early days. So we are iterating fast to add all the features that you expect. So to maybe mention some of the coming next step, we are adding support for signing of off chain messages. So that's the ability to sign something off chain that can then be validated by your DAP off chain.
00:10:32.274 - 00:11:29.282, Speaker B: So for example, if you look at Zigzag, which is a great decentralized exchange using an order book, when you want to do something, you actually sign an order off chain and then this order can be used later in the protocol. And for that you need to have support for off chain signing. So that's something that is actually already in the latest main if you install from sources and that should be available probably in a week on the release version on the chrome store. We are also adding caching, because today every time you close and open the account, you need to reload its state. So that's again, the user experience is not great yet. So we're adding caching, we're adding transaction history, as you would expect. We are also discussing with several partners that will maybe integrated signers.
00:11:29.282 - 00:12:14.310, Speaker B: For example, in the slide that I showed earlier, there is a private key. Today this private key is managed by Argentx, but you can imagine this key to be a ledger, for example. And we actually already have a proof of concept with ledger around that id. So we'll add ledger we are discussing with torus. So basically we will add more support for more types of signers. For those of you who know Argent, you know that we've been building a smart contract wallet on l, one with two important pillars, one being social recovery and one being fraud monitoring. And so actually we want to bring this model to Starknet and that's something that will come later.
00:12:14.310 - 00:13:10.086, Speaker B: So social recovery in a nutshell, it's basically a possibility for you as a user to define trusted parties that can help you gain back access to your account. If you lose your private key. So fully noncustodial, fully transparent. But that means that if for some reason your computer is stolen or you lose your private key, there is still parties that you have selected that can help you gain back access in a completely non custodial way. And we also want to bring fraud monitoring and maybe to give an example of what fraud monitoring could look like in Argentx. So because with account abstraction, every account is a smart contract and we can program custom logic in that smart contract. So in the default example that I've discussed so far, there's one private key and only that key can trigger transaction on the account contract.
00:13:10.086 - 00:14:31.502, Speaker B: Now let's imagine that instead of having one keys, there is two keys that are needed to approve a transaction on your argent account. On Starknet, one of these keys can be in your ArgentX extension, but the other key which is needed to approve can for example be stored in an external service. What that means is that every time you need to make a transaction, you will need that fraud monitoring service to approve that transaction, because you need both signatures to execute something. And where it becomes interesting is that this fraud monitoring service can, for example, have a list of trusted dapps, or it can have a list of dapps that are blacklisted, or maybe it can contain a list of per users of trusted addresses or daily limits. I mean, you can program a bunch of logic into that service and that means that every time you want to execute a transaction transparently, Argentx can call that service and say, hey, do you approve that transaction? And based on logic that you have defined, the phone monitoring service will say yes. If he deems that the transaction is secure, provide his signature and the transaction is executed on chain. Of course, for those who want to look into the Argentina account smart contract today, this is purely under the control of the user.
00:14:31.502 - 00:15:18.414, Speaker B: So you are free to remove that service, you are free to add another one. But this is just to show the kind of things that can be achieved. And where that becomes interesting is that let's now say that the DAP that you're interacting with becomes malicious. For example, the website has been hacked. So as a user you still think that you are doing some legit action on the DAP, but actually in the background the DAP will try to do something evil, say drain your account for example. Well, again, because the fraud monitoring service needs to approve that transaction, it will detect that instead of interacting with the target DAP, it is interacting with a DAP that it doesn't know or to adapt that has been blacklisted. And so it can block the transaction.
00:15:18.414 - 00:16:28.386, Speaker B: If it's just adapt that it doesn't know, the fraud monitoring service can maybe just ask you to approve, to confirm that you are indeed the legit owner of the account and ask you to confirm with a second factor like your phone or another wallet or an email and so on. And what it becomes even more interesting is that actually even the ArgentX extension can be compromised and you will still have security, because ultimately the security is at the level of your account contract. So this is the kind of things that we will bring in the future. Again, these are the early days, so we first want to tackle properly and improve the experience for the main use case. But as starknet matures and as argent matures, this is the kind of features that you should expect coming into your Argent X wallet. And to conclude, if you find that interesting, please do download Argentx on the Chrome store. You can go on the Chrome store, you type Argent X and you will find a link to install it in your chrome browser.
00:16:28.386 - 00:17:02.270, Speaker B: Also works in brave. And please send us feedback if you're interested about the argent account. That is the smart contract that supports your Argentx wallet. It's fully open and public on GitHub. So if you go to Argent Labs on the repository, you will find a repository for smart contracts in Starknet. If you want to contribute, you can contribute to Argentx or you can contribute to Starknet JS I think every contribution will be welcome. And finally, if you have questions, you want feedback, you can join us on Discord.
00:17:02.270 - 00:17:15.080, Speaker B: We actually have a dedicated channel on the Stackware discord where we try to answer questions as soon as possible and that's basically it.
00:17:15.930 - 00:17:59.720, Speaker A: Awesome. Thank you Julian for this great intervention. So if some of you have questions, please ask them in the community call channel monitoring them and we'll be able to review them. There was one question actually somebody was asking what apps can you try with Argentex today? So I know you published a demo app last week. Do you want to maybe just explain quickly what it is and if there are other apps you recommend using and want to share them? That'd be great.
00:18:00.570 - 00:18:57.622, Speaker B: Yes, that's a great question. Unfortunately there isn't that many Dapps today running on Stacknet, but we are in discussion with many builders. So I think it's a question of days for Dapps to come online. But yes, if you want to have a quick preview of what Argentx can do, if you go to our repository on GitHub Argent X we have in the readme you will see there is a demo Dap and what this demo Dap lets you do is to mint some test tokens so that you have some tokens to play and then you can transfer token to another account. So if you want to play with it, create two accounts, go through a test DAP min some token with account one and then transfer some tokens from account one to account two. So that's something you can do to get a feel of how it works. As of yesterday, there is actually a DAP that went online and that integrated Argent X and again, that's the power of web3.
00:18:57.622 - 00:19:37.718, Speaker B: We didn't even know they existed and suddenly we saw that DAP with an Argent X button, which is great. I think it's called Minsquare and it lets you mint nfTs. I did actually mint my first NFT yesterday with Argentx. So if you go to minsquare you can start playing with NFT. I know Sean, who is behind Stacknet JS is working on a couple of dapps. I think he's working on an AMM and he's working on an NFT marketplace as well. It is still early, but I do believe that one of the two of the two will be available very soon, if not already.
00:19:37.718 - 00:19:51.290, Speaker B: And if they are shown, feel free to send the link on discord. And overall we are in contact with several dapps. But if you want to try it today, you can go on a test DAP or you can go to Minsquare.
00:19:52.270 - 00:20:29.734, Speaker A: Wonderful. Thank you. By the way, if some of you are like me and you created only one wallet on Argentex to try it, and then you figure oh, I want to send tokens to somebody but I don't know who, or you want to receive some tokens, drop your wallet address in the discord, I'll send you some test tokens and then you can send me back some so we can actually try this out. I'm super curious to test Min square. I saw their announcement, but I haven't tested it yet. Okay, so this is great. So some people are asking when will it be available for the general public? It already is.
00:20:29.734 - 00:21:02.142, Speaker A: If you didn't follow the beginning of the presentation, you can download Argentex on the Chrome web store. You can install it on brave or on Chrome. And you can start with these two apps that Janek just posted on Discord. I learned something today actually. The fraud service. I didn't know you wanted to deploy something as a fraud service. Can you expand a bit more about that? Somebody is saying Arjun could have its own App Store.
00:21:02.142 - 00:21:20.660, Speaker A: So I'm guessing some kind of operator would need to monitor this activity and approve it or not. Is it something you see as an open ecosystem where anyone can select their own validator? Do you see Arjun playing a role as a validator? Or how do you foresee this? And do you have an idea of when this will be?
00:21:22.070 - 00:22:11.074, Speaker B: I mean, first of all, the idea is not to make a closed system. If you look at the contract you see that as the owner you have the full control. So that means that you can decide to set up a second key that needs to confirm transaction, but you can actually choose what that second key is. So for example, as a user you can choose that second key to be a hardware wallet or to be someone you have completely freedom. But what we are considering offering is a backend service that will hold that key and that can be used to approve transactions. So the way we see if you know the Argent wallet today, for example, we have trusted contacts. Today, these trusted contacts, they are on chain, which is great, but of course in terms of gas, it's not really efficient.
00:22:11.074 - 00:23:04.754, Speaker B: So a simple example of fraud monitoring would be to say, but now every user can define a set of trusted contacts. And if you choose to have the argent fraud monitoring service, again, this is your choice, you don't need to do that. But if you choose to do so, you will have the possibility to add the argent fraud monitoring service and for example that will let you define trusted contacts. And what that means is that every time you interact with a trusted contact, the fraud monitoring service will automatically sign and provide a signature. So it will be completely transparent to the user. But you can also imagine that fraud monitoring service to basically inspect previous transaction, inspect activity on chain or have a list of blacklisted Dapps, for example. Because every time there is a scam, people will basically say this is a scam.
00:23:04.754 - 00:23:57.318, Speaker B: And you can imagine the fraud monitoring system using that kind of information to basically decide if the transaction is deemed secure. And if that's the case then it will automatically approve transparently. And if the DAP is considered not secure or unknown by the front monitoring system, it will just ask the user for a second factor. Because in the end the power of web3 is that with your account you're free to do whatever you want. So the point is not to prevent you from doing something, but it's just for the monitoring system to say, this is something that I don't know, this is something that could be potentially dangerous. So please confirm me that you are you prove me that you are the legit owner of the system and if so, the transaction is executed. But again, you can imagine that argent will make a fraud monitoring system, but maybe stackware will do one or maybe your bank will do one.
00:23:57.318 - 00:24:06.060, Speaker B: The point is that as a user you'll have the possibility to choose who you want to act as a monitoring system for the monitoring system.
00:24:08.110 - 00:24:39.400, Speaker A: I think this is a really interesting design space. We often say, oh, be your own bank. But I'm not sure a lot of people would feel comfortable being their own bank. And what you're doing with this is you're opening up the access to being not a bank per se, but being a guardian and being a safety provider to whatever social mechanism any user see fit, whether it's family, friends, a company, a bank, whatever. I think that's really interesting.
00:24:40.010 - 00:25:07.786, Speaker B: Yeah, I think you're completely right. In the end, I think it's a question of choice. I think the users should have the choice. We should be transparent about these choices, but the choice should be in the user's hands. So maybe some users will be completely okay to use the argent fraud monitoring system because they trust argent. But again, it's their choice. At any moment they can revoke that and go to something that provides them more control or more such as their own hardware wallet.
00:25:07.786 - 00:25:28.830, Speaker B: So in the end it's a question of choice. But yes, that's the beauty I think, of account abstraction is that your account, your smart contract, can have custom logic. So we can start experimenting and I think go towards a direction which can provide both more security and more usability to users. And of course that's what we are passionate about at argent.
00:25:28.990 - 00:25:30.100, Speaker A: Super cool.
00:25:32.570 - 00:25:45.770, Speaker B: Before I forget, I just want to highlight that we are always hiring at Argent. So if you find this product very cool and you like Argent, please drop me a line because we are always looking for talented developers.
00:25:46.910 - 00:26:41.310, Speaker A: Awesome. Thank you. So user scratch is asking, let me find the question. Will users be able to add custom signing requirements? Like for example add transfer limit per week and need an extra key to sign transaction that go past the limit? I think globally the question if I had to reframe it was how do you design the constraint? Will it be something like, you will propose design patterns for this access control or will it be totally open and people will write their own smart contract? How do you see this happening? Or maybe you can even imagine like an App Store, a security App Store where you can select the security module you want to deploy on your own account. How do you imagine this happening? Do you think Arjun will do most of the writing of conditions or can anyone participate?
00:26:42.050 - 00:27:29.366, Speaker B: I think that's a very good question. I think today what's great is that the protocol from the account contract standpoint is completely open, meaning that for the urgent account contract, it's just a key, just a signer, or it can be multiple keys, but on top of that you can build what you want. So what I think is that Argent will offer one such service, and as a user, you will have the choice to configure that service. For example, the user mentioned daily limit. This is something that we had previously in the Argent wallet on L1, where gas was cheap a long time ago. So that's the kind of things that we want to bring back in Argent X. But again, that will be the choice of the user.
00:27:29.366 - 00:28:07.634, Speaker B: So the user can decide to set up a daily limit or not. So to tell you which form it will take, honestly, I don't know yet. What is certain is that Argent will provide one such fraud monitoring system, but it will be possible to offer others. And so you can imagine indeed that we work with partners. And within the Argentx wallet, if you want to enable fraud monitoring, we will give you a few options depending on which partners we've worked to. But again, the fact that we will provide you partners doesn't mean that you are not free at the contract level to add whatever service you want. So in the end, it's a completely open protocol.
00:28:07.634 - 00:28:22.320, Speaker B: But I imagine that we will provide one such instance which we believe as the correct trade off between security and usability. But then users will be free to choose another service or to manage that second key themselves.
00:28:23.570 - 00:28:54.114, Speaker A: Awesome. Thank you for the answer. Okay, so I think we have answered most question here aside from support question. So actually I'm going to use this opportunity to move on to the next part of our community call. So first of all, thank you Julian, for this intervention. It was very interesting. And thank you for your work on Argentex.
00:28:54.114 - 00:30:31.042, Speaker A: I think this is going to bring a lot of value to the community, both to interact with the apps and to build an app. We won't have to think about smart, I mean, account contracts because we'll be able to work on the work you did. We were exchanging on Discord right now, some tokens in the channel, and I'm using Mainnet and Janak is saying you should use Gorli as it's the default because most people post Gorli address and also it's much faster. I think it's a great switch to the next part of our community call where we'll have Tom who want to discuss some topics around Starknet, among which the update to the status of pending. So more broadly, Tom, I think you're with us now if we can explore a bit what happens when you're doing a transaction with Argentex. So first of all, if you deploy your Argentex wallet on main net, you'll realize that it takes a while for it to deploy, right? It takes a couple of hours until it is in an l, two block, and then it takes about half a day before it reaches main net. And so when you're sending a transaction, when you're sending tokens through the example dapps, the status of the transaction doesn't appear immediately in Voyager.
00:30:31.042 - 00:31:22.710, Speaker A: Right. So if you look for example in discord on the transaction as sent, if you click on them, you can see that it says, sorry, we're unable to locate this transaction. This doesn't mean that the transaction would not taken into account. It means that it will be included in an upcoming block, but it is not in a block yet. So Tom, I don't know if you want to comment a bit on this or explain what is happening behind the scene and what users should assume when they see these kind of things. So I think I can hear you on Discord and no, I can't hear you on Zoom. I can't hear you on Zoom.
00:31:22.710 - 00:31:48.880, Speaker A: Okay, so guys, if you're on Zoom, we have finished with presenting the slides and you can move to discord to listen to the rest of the call. I'm going to finish the Zoom session. Yeah, let's wait for. There are still about 20 people over there and we can start. Okay, I'm going to finish it.
00:31:50.770 - 00:31:51.374, Speaker B: Now.
00:31:51.492 - 00:31:55.380, Speaker A: You can go to discord, to the community call channel.
00:31:58.660 - 00:32:05.490, Speaker C: Yeah, I see people are joining. So I will wait one more minute and then I will explain a little bit.
00:32:06.760 - 00:32:07.510, Speaker A: Awesome.
00:32:16.490 - 00:32:48.160, Speaker C: So maybe in the meantime, Julian, I wanted to say that we are working very closely on how exactly should account obstruction look like. And I don't know, everything very technical, but it was very nice to hear again the nice things that you can build on top of those foundations. So yeah, it was nice to be reminded where all this account model are going. Thank you.
00:32:48.850 - 00:32:50.000, Speaker B: Thanks to you.
00:32:51.170 - 00:34:07.420, Speaker C: Okay, so I will try to explain what was the latest update that we introduced, which was Cairo version 0.6.2 and what you should expect to be able to see now both on Gurley and on main. So the latest update, the main change that we introduced was basically a new finality status for transactions. Generally speaking, when you think about finality of a transaction in an l two and an l one environment, then we have few steps. The ultimate and final step is when a transaction which was included in some block was proved and verified on l one, and the state of the l one starknet contract was updated to the latest state. And this means that the transaction has an l one finality, or as you can see it on the API, it is called accepted on l one. And this basically means that the finality is the finality of l one, and up to some massive reorg, which shouldn't happen and we haven't seen on Ethereum, the finality of the transaction won't change.
00:34:07.420 - 00:35:12.730, Speaker C: Now, between that and no finality at all, we have a wide spectrum of finality that we can give to transaction. If we look a bit into the future. We are designing more flexible finality mechanisms that on one hand you won't have to wait for the proof to be generated and accepted on l one. You will be able to get some faster guarantees that this transaction will indeed be included in a block, and each one of those finality steps will have its own safety guarantees. We have a nice discussion on it on the Starknet shamans, which you can take a look. Maybe I will post this later, but if I'm focusing on what is currently available on Starknet Alpha, so we have two steps of finality. So after you've sent a transaction, the first status of the transaction you will see is pending.
00:35:12.730 - 00:36:26.946, Speaker C: And before the latest update, pending meant that it was included in an l two block, and it is now waiting to be proved and accepted on l one. And we've now changed the semantics of pending, and we added another step between pending and accepted on l one, which is called accepted on l two. So basically what pending means now is that the sequencer executed the transaction. It was a valid transaction, and it is included in a block, but the block is not yet closed, meaning more transactions might be added to this block. But the important thing to understand is that once a transaction is in the status of pending, every call that you will make to the sequencer, if you will query on the pending block, and we will post exactly a tutorial on how to do it. The state that you will see is the state which is the result of this transaction. So for example, if you want to create an account, you've downloaded Argentix and you want to deploy a contract.
00:36:26.946 - 00:37:56.930, Speaker C: So now you don't have to wait for the block to be closed. As soon as the sequencer received the transaction and executed it, it will reflect the pending status on the transaction and you will be able to see it by querying on the latest pending status. So this means that from UX perspective you get an almost instant confirmation that the transaction will be included in the upcoming state update. This is currently deployed on Gerley and generally speaking looking into the future, every new version that we will have will first be deployed on guerrelli and approximately one week afterwards if no bugs were found, we will also apply it to the main net version. So we deployed it yesterday. So approximately on Monday next week, if everything will be fine, it will also be an update to Mainet and then both on Voyager and basically every application also argent. Once it will make the argent x, once it will make the adjustments, the confirmation that the transaction was accepted and what is the state after this transaction execution will be much much faster, hopefully on the order of a few seconds, maybe tens of seconds.
00:37:56.930 - 00:38:48.180, Speaker C: So this is a great improvement, which will allow a much easier interaction, mainly with Mainnet, but also a much faster interaction with Gerling. So just to repeat, the lifecycle of the transaction is first of all it is received, then the sequencer executed, and immediately after it was executed, the status is changed to pending, and all the states can be queried based on this transaction. After the block was closed, the transaction status is changed to accepted on l two, and after the block was proved and verified on l one, the transaction status is changed to accept it on l one. So I hope it was clear. Maybe Henry, if you have any questions, or anyone else has any questions, I can further clarify it.
00:38:49.190 - 00:39:16.570, Speaker A: There is one question actually Janak is asking. How safe is it to assume a transaction in a pending block is valid? So my understanding from what you're saying is that once it's marked as received, if it is valid, it should move to pending, right? Which means that the sequencer received it and executed it. What happens if the transaction is invalid?
00:39:17.150 - 00:40:39.330, Speaker C: So if the transaction is invalid. So first, to answer your question, Janic, if the status is pending, it means that we were able to execute it and it is valid and it will be included. Of course, if you look at from a security point of view, then since it's an alpha and we basically don't have those kind of security guarantees, then this also has the same type of security guarantee, right? It's not a permissionless sequencer layer, so you can't have, for example, other sequencers confirming it as well, or other mechanisms that we will have once we will move to the decentralized version of Stargate. So at the moment it has the same security guarantees that you had up until now on the accepted on l two status. Does that make sense? And to answer your question, Henry, if a transaction was executed and it was invalid, then the status will be rejected and you will also receive the reason for why it was invalid as an error.
00:40:41.270 - 00:41:19.402, Speaker A: Perfect. Thank you. Okay, thank you, Tom. I don't think there are other questions yet, both for Arjean or for you, Tom, so maybe we can move to the next topic. I wanted to discuss a bit the roadmap of Starknet, but actually I forgot something in the middle. So we will come back to the roadmap in a few seconds. I just wanted to make a quick aside about Discord and the way we manage our discord.
00:41:19.402 - 00:42:07.134, Speaker A: So as you may have noticed, things have changed a bit on discord. For the past two weeks, there has been phases where the discord was flooded with requests for airdrop tokens, GM and everything. And then we set up a new ingress system to the discord, let's say to filter out the noise when we did it. Filtering out the noise is a bit of a double edged sword in a way. In a sense, you reduce noise until you put more of an emphasis in qualified discussions, which is great. On the other end, you may alienate part of the community which is here and wants to have fun. And so it's not an easy decision to make.
00:42:07.134 - 00:43:12.254, Speaker A: So that's why we wanted to explain a bit what's the rationale behind this and get your feedback if you have an opinion on that. So basically what we're seeing is a lot of people arriving, flooding channels with GM, with requests for off topic discussions and also for discussions where we have a very simple stance, right? Every time you ask us about token, you know where to find the answer. It's in the when token channel and a lot of users arrived and didn't really read this and then ask the question. And a lot of members had to ask the same question over and over and over again. So what we did is we created, there was initially one role for members in the discord, which was Dev and we introduced two new roles. One is apes and the other one is Starknet star. Starknet stars are community members that have shown by their action that they're willing to answer question and help newcomers.
00:43:12.254 - 00:44:16.578, Speaker A: And so we gave them a special status to show that they're helping, fostering good community and answering questions. The ape status is designed in a way that it is for people that arrive in the discord and want to rush into asking questions without reading the documentation and we want to a bit avoid that, because I was going to say laziness. It's not exactly laziness, but their will to rush comes at the expense of other people's time. So basically what we did is if you go on the channel verification bot, you can see there that there's a new announcement. Probably if you joined the discord more than a week ago, you have not seen it. And so basically what this is, is it's a small announcement explaining how the network, the discord, works. And if you look on point free, there's a way for users to select an emoji and join the server.
00:44:16.578 - 00:45:16.140, Speaker A: When people go get to zero free and select the ape emoji, it means that probably they haven't read the announcement until the end, and so they get the ape role. And with the ape role, they're able to read all the channel, but they can't write in any channel except for the random channel. Right? So that way they get to read and understand what happens and hopefully figure out that they need to go back to the verification bot, read all the documents, all the points we put in order to guide them through their Starknet journey. And at the end, they'll figure out that by selecting the Starknet emoji, they'll be able to have read and write access to all the channels. Right? So that's what we did. To reduce noise on the server. We have also set up a moderation bot that bans certain words.
00:45:16.140 - 00:45:50.710, Speaker A: So it's the same. It's a double edged sword. So, for example, we banned the token keyword because the question was coming over and over and over again, and we felt like it was a waste of everyone's time. But at the same time, people will want to design tokens on Starknet. So probably at some point, we'll need to remove that ban once things quiet down a bit. We did notice that in the past week, things have been better. So we think that all of this was sort of successful until now.
00:45:50.710 - 00:47:29.554, Speaker A: I don't know if this was all clear to you, and if you have questions or comments about how we could manage the discord, please do mention them and let us know what we can do better. And while we're on the discord topic, I wanted to mention that we have added in the builders category a new channel, which is Starknet bug report. So if you ever find a bug in Starknet and you want to reach out to the team to say, hey, I've broken something, you can write it there. Okay. All right. So this was my small discord parenthesis and now we can go back to our Starknet Ama with Tom and Tom there are regularly some questions about the next features we want to ship and I wanted to know if you can maybe explain a bit when will the next release be pushed? So I know you mentioned that we have a new alpha version on Testnet, so it should be by next week on mainnet. Can you tell us aside from the transaction status updates what kind of enhancements we can expect? And amongst the list of awaited enhancements, I know a lot of members are waiting for timestamps and block numbers in Starknet smart contract.
00:47:29.554 - 00:47:31.480, Speaker A: Do you know when we can expect that?
00:47:33.850 - 00:48:36.380, Speaker C: Yeah, sure. So just to clarify, the latest update was call it a minor upgrade because it was mainly only this new status change and it didn't have any effect on the Starknet OS and on the Starknet L1 contract. So this is generally how we differentiate between minor and major updates. So first of all, I think I mostly maintain the Starknet tentative roadmap notion page that we've shared. So usually you can go and look there and it is updated with the latest approximate time estimation and also what will be included in the next version. So just a reminder but to elaborate here. So the next version will be.
00:48:38.270 - 00:48:38.586, Speaker A: I.
00:48:38.608 - 00:49:17.510, Speaker C: Think Alpha five and we are aiming for it to be released on Testnet hopefully by the end of this month. But maybe it will be delayed for the first week of January. Actually it's a quite exciting update because it will include, I hope many new features. So the first one will be the proxy pattern, which will allow contract upgradability on L two, which is something which is currently missing.
00:49:20.330 - 00:49:43.454, Speaker A: Just to be clear, when you say upgrade contract, you're not saying that it is possible to modify a contract after the fact, right? You're saying that basically it's delegate call that allows to send a message to another contract and that contract allows forwarding to another contract and then you can manipulate, you can basically implement proxy pattern, right? Exactly.
00:49:43.572 - 00:50:45.726, Speaker C: So proxy pattern is a way to deploy contracts with the ability to upgrade them. So it's not a built in mechanism for all contracts. But if you deliberately choose to have your contract be deployed in such a way, it means you will be able to upgrade its logic while still maintaining its state, its storage, which is widely used in Ethereum. And it also makes a lot of sense in the context of account contracts because you as a user will probably want to have the ability to add functionality or remove functionality, just like Julian explained. For that reason you will probably want to use proxy pattern. So this is the first thing which will be available. The second thing is we will have all the building blocks for fee mechanism.
00:50:45.726 - 00:51:22.880, Speaker C: So by that time we should have token bridges deployed and we will add all the necessary components to pay fees for transactions. We will still not enforce it at this version because we want to give the time for all the infrastructure and applications to adapt to this new requirement, but we will probably start enforcing it from the next version after this incoming one.
00:51:25.730 - 00:51:44.600, Speaker A: Wow, those are great. At that point people will be able to add transaction fees in their transaction, even if it's not enforced, but we won't have yet a vision of how much transaction will cost, but we'll be able to build the tooling around having the fees, is that it?
00:51:45.050 - 00:52:37.910, Speaker C: Yeah, and we will also have the exact pricing. So I plan to post in the coming weeks on Starknet chairmans an explanation on what will be the mechanism and how it will work. So we will update also on Discord once I post it, but it will also include the mechanism for the pricing of the transaction. Okay. And also we have some features that I hope that they will be included, but I'm not sure, so please keep that in mind. So these include events. We're trying to add the support for events, which is the equivalent of logs in EVM.
00:52:37.910 - 00:52:44.778, Speaker C: This is one which is a major.
00:52:44.944 - 00:52:50.700, Speaker A: Feature that is a lot fees plus proxy plus events. Nice.
00:52:51.550 - 00:52:53.950, Speaker C: Yeah. I'm saying events is a maybe.
00:52:54.020 - 00:52:56.094, Speaker A: And I hope it's a maybe. It's a maybe.
00:52:56.292 - 00:53:02.270, Speaker C: Yeah. And also block timestamps and block numbers are also planned.
00:53:05.750 - 00:53:06.740, Speaker A: That's awesome.
00:53:07.190 - 00:54:18.674, Speaker C: Yeah. One small feature which was requested by the account contract builders, which is mainly Openzeppelin and Argent, was the ability to accept as an input in external functions array of stack, which will allow supporting for multi calls. So this will also be included. And we're also working on few new APIs which will help the infrastructure around Starknet to support better visibility on Starknet. So one of them is get state update. Basically today, the state update that happens after a block is published only on l one, once proof is verified on l one. So we will add an API that allows you to query on the state update as soon as the block is closed on l two, which is an important building block in the upcoming full node, which is written by equilibrium and it's called Pathfinder.
00:54:18.674 - 00:55:13.130, Speaker C: So this is one. And another one is the ability to see the internal calls of the transactions. So as you may have seen currently on Voyager and basically everywhere, you don't have the visibility to what are the internal calls that was done during an execution of a transaction. So if I want to call an ERC 20 contract via my account contract, then basically, currently I don't have visibility to it because it's an internal call from the account contract to the ERC 20. So once we will hopefully add this API, all those internal calls will also be displayed on Voyager. So this is the version which is.
00:55:13.280 - 00:55:15.100, Speaker A: So that's alpha five, right?
00:55:16.190 - 00:55:18.140, Speaker C: Exactly, that's alpha five.
00:55:19.150 - 00:55:40.690, Speaker A: So Janak has an extract, so he's asking, okay, so we get delegate call, but what about the fallback function that you get in Ethereum when you send a transaction to a smart contract, and either you don't specify a function or you specify a non implemented function, is it something we have on our radar?
00:55:43.590 - 00:56:09.670, Speaker C: Delegate call is already supported. Really? The missing piece is the default fallback function, which is what will be added in this version. Delegate call is already supported as of the latest version, and what will be included in the upcoming version is basically the default fallback function, which will allow us to implement the proxy pattern for proxy.
00:56:09.750 - 00:56:30.546, Speaker A: Okay, understood. That's interesting. Okay, there's another question. Can we expect the compile contract JSON to contain only x string strings instead of begins in the next update? This will Javascript. Yes, it's know.
00:56:30.568 - 00:57:07.600, Speaker C: I know, janek, I will give you an answer. I don't know, it's not currently planned, but I know the problem with this change is that even though it's a small change in the compiler, we need to understand that changing the compiler does not break anything. So this is why we are a bit hesitant about it. But I know the problems that it's causing, so we will take a look.
00:57:09.490 - 00:57:29.000, Speaker A: There's another question. I'm not sure I understand it fully, but are there plans to retrieve historical block ashes in contract? So, darkest nightmare, you're asking this question. Can you do that on Ethereum? Say, oh, I want the ash of block 100. Is that what you want to do on.
00:57:29.690 - 00:57:42.086, Speaker C: Yeah, I think Ethereum allows you to query the block hash of the last 256 blocks or something like that, which is used by some protocols as a source of randomness.
00:57:42.278 - 00:57:42.826, Speaker A: Okay.
00:57:42.928 - 00:58:07.342, Speaker C: Which is indeed lacking today on Starknet. I think I saw it today somewhere written, so I've added it to my we also need to discuss it. Currently it's not possible and not planned, but it's a very good feedback which we will think how to support and when understood.
00:58:07.406 - 00:58:14.430, Speaker A: So it's on our radar, but since very recently and we have not researched much, so we can't give an ETA.
00:58:14.510 - 00:58:17.380, Speaker C: But we've heard you exactly.
00:58:18.010 - 00:58:49.360, Speaker A: Wonderful. Okay, well, thank you for that really comprehensive presentation. That's great. I'm really stoked for Alpha five. This is going to be a really interesting one. It will allow a lot of cool things, events, I mean, all of these features are really interesting, but events will start to allow really rich dapps too, because you'll be able to display historical data. So that's going to be really interesting.
00:58:49.360 - 01:00:08.210, Speaker A: So there was another question. So I think there's some confusion there. But the question was, okay, so how does composability work on Starknet? I've read that it's composable, but if a transaction is reading and writing from various apps, don't they all need to be on Starknet for it to work? Is it compositable between chains and main charts, et cetera? So the person asking this question has the right intuition. When we say composability in Starknet, we say that smart contracts on Starknet are composable with each other. So you can write a smart contract on Starknet that interacts with other smart contracts on Starknet. You don't really have composability in the same sense that you hear on Ethereum, with other Ethereum dapps, in the sense that, for example, if you write a smart contract on Ethereum, you can call uniswap smart contract and interact with them in a single transaction. You can't, on a Starknet smart contract, interact with Uniswap and expect an answer in the same transaction.
01:00:08.210 - 01:01:23.658, Speaker A: But you can from Starknet smart contract send messages to l one, and you can from l one, send messages to l two. And I think that leads us nicely to the next topic. We wanted to discuss a bit, Tom, which was around bridging and messaging on Starknet. So the way information transmission works on Starknet and between Starknet and l one is that there is a messaging protocol that allows people, I mean, that allows smart contract to send data to l one and to L1 to send data to l two to Starknet. So there's a way to send instructions and to authenticate who sends these instructions. And now we have a nice building block, and you can build any kind of bridge. But do we expect anyone to build any bridge? Like, do we expect as many bridge as there are tokens? Should teams start working on their own tokens? Will there be a canonical bridge? So can you expand a bit on that? What should we expect in terms of bridges for tokens? Like for most tokens? ERc, twenty s and nfts.
01:01:23.658 - 01:01:29.970, Speaker A: And aside from that, what kind of cool applications can we expect with messaging?
01:01:31.190 - 01:02:58.350, Speaker C: Sure. So I think at least on the fungible tokens, and also on the non fungible tokens, it makes a lot of sense to have one canonical bridge. And by one canonical bridge, I mean if I want to transfer, I don't know, let's say, dai, from Ethereum to Starknet, it doesn't make sense to have. It makes sense to have only one ERC 20 contract that represents die on Starknet, because otherwise you have fragmentation of liquidity, which is very bad. And since you have one ERC 20 contract of die, it also makes sense to have one bridge, because otherwise it's not very clear who is eligible to add bridges and how they interact with each other and et cetera, et cetera. So in that sense, I think that there will be at least the way we recommend using bridges is to use the one canonical bridge for each token. So all the liquidity on Startnet will be in one contract that anyone can interact with and not fragmented across multiple contracts.
01:02:58.350 - 01:03:56.020, Speaker C: And I think it also makes sense to do that for nfts, although we still haven't dived deeply into it. But I know there are some discussions on it, on the open Zeppelin Cairo contracts repository. But for tokens, I think it makes sense to have one canonical bridge. Of course anyone will be able to interact with it. Interoperability solutions will be able to provide maybe their own solutions based on it, but the source of transferring tokens from l one to l two should be through one bridge. And of course, nothing will prevent users from deploying more bridges. I just don't think that.
01:03:56.020 - 01:04:01.010, Speaker C: I think at the end, one bridge will have the most adoption.
01:04:02.790 - 01:04:08.740, Speaker A: Thank you. When can we expect this? Okay.
01:04:13.110 - 01:04:55.650, Speaker C: Yeah, so it's not internally, we just didn't yet exposed it, but internally we deployed the token bridge on Gerley. I think it was either today or tomorrow, either today or yesterday. So very soon, hopefully we'll be able to open the Gerly version to the public again very soon. And we're also working on front end to the bridge, which will allow users to easily transfer their tokens from Ethereum to Starknet, which by the way, also is integrated directly to Argentix.
01:04:56.070 - 01:04:56.820, Speaker A: So.
01:05:01.290 - 01:05:13.750, Speaker C: This will be the way that the bridge will allow users to handle their funds on Starknet. So this is for the fungible tokens bridge.
01:05:16.830 - 01:05:34.786, Speaker A: Okay. So for DRC 20, it is being tested on testnet. So we should expect being able to test it on testnet for end users soon, and then if everything goes as planned then main net and for nfts we haven't timeline and it's not well.
01:05:34.808 - 01:05:50.420, Speaker C: Defined mean there are Walker in it and discussions on open zeppelin. Maybe it will just come from the community without mean nothing directly from us, which will be.
01:05:52.230 - 01:06:03.260, Speaker A: Yeah, that's what I was going to say. A few teams are working on NFT breach, so maybe it won't come from us. I agree with you. It would be great if it was deployed by someone else too.
01:06:05.470 - 01:06:21.840, Speaker C: Yeah. And regarding your second question on what else can be done with the messaging protocol? So I think one cool solution or one cool use case that was discussed a lot is defi pooling, but maybe you want to explain on it.
01:06:22.210 - 01:07:13.710, Speaker A: Yeah, sure. We were talking about this and I think that's a really interesting use case. So right now, say you're a user on Ethereum mainnet, and you don't have tens of thousands of dollars of liquidity, and you want to use a big protocol like say curve or Aave or Uniswap or actually any kind of protocol. It costs you a lot of money to deposit in these protocols, you're going to have to make at least two transactions. One to approve sending your ERC 21 to deposit the liquidity, right. And this transaction will cost you a lot of money because there's a lot of logic to be executed, right. And so it's not really feasible for you to access these money markets.
01:07:13.710 - 01:08:15.630, Speaker A: So you have the solution of moving to l two, but then on l two you get other money markets, right? I mean, you get Ave on other chains, you can get Ave on Polygon, you can get Uniswap on Arbitrum, or, I'm sorry, on optimism on arbitrum also. But you don't get access to uniswap on l one, so you don't have access to the same conditions and incentives and things like that. So it can be a bit frustrating. The thing with defi pooling the id, the global id basically would be to have users on l one approve one specific contract on l one, which is a d five pooling. So let's say shared. The analogy with pooling is when you want to move around in a city, right? So sending a transaction is having your own car. Defi pooling is basically having public transportation.
01:08:15.630 - 01:09:56.178, Speaker A: So a bus, a train, or something. So instead of using a car to go to your preferred app of choice, you can authorize a specific smart contract, which will be a train, because it will onboard a lot more users to move your funds and then deposit these funds into Aave. And so instead of you going to depositing money to say Aave, you will gather with other users on Starknet and you will be able from Starknet to interact with another smart contract on Starknet, which will use the messaging tool from Starknet. And by a special protocol that the Defi pooling team will have to design, will it be able to transmit instruction to the train on l one? And so that smart contract regularly will be able to aggregate deposit orders or withdraw orders from users on l two and act on their behalf on L1. What's really cool is that it allows the brain of the operation to sit on l two on Starknet while the liquidity is on l one. And so it really allows you to manipulate liquidity on l one from l two and have access to this same money market, which I think is really cool. The other cool thing is that once you've done that, basically probably ownership of a share in the train will be represented by a token on L two.
01:09:56.178 - 01:10:43.218, Speaker A: Right? So basically what you've built is a bridge. It's a token bridge in the sense that the liquidity is deposited on L1 and is represented on L two. But instead of sitting in a smart contract idle, it sits in a money market and it gains yield. So you can basically have, say, AUSDC or a eth on Starknet and have them move there. You can probably say, for example, deposit your money on Ave, have it tokenized on L two on Sharknet, and then change it for any other thing you like. So I think this is a really interesting design space too, with messaging. I'm not sure if that was clear or if you want to add something regarding that.
01:10:43.218 - 01:10:43.940, Speaker A: Tom.
01:10:49.270 - 01:11:01.980, Speaker C: I think there's a nice blog post by, I think it was Louis that explains it. And it's basically applicable to with Starknet as is.
01:11:03.470 - 01:11:44.066, Speaker A: Yeah, so do look it up. I'm going to see if I can find it and I'll post it later on. Okay, so these are the few topics we wanted to discuss with you. The next update, bridging and surging on Starknet and then talking a bit about discord. If there are no other questions, we are reaching the end of our community call. So one last public service announcement. Remember that we have the Stanford blockchain summit at the end of January tickets where we added a few more tickets for those of you who want to attend.
01:11:44.066 - 01:12:17.060, Speaker A: So you can still purchase a ticket if you want to join the summit. I want to underline that you should buy a ticket if you want and can join the summit, but don't buy one with any other kind of expectation other than just joining the summit and being there. So if you can be there, that's cool. If you can't, that's fine. Also, you'll be able to stream the talks online and you learn a lot of cool things too. So it's coming up soon. Make sure to book your slot if you can.
01:12:17.060 - 01:13:01.470, Speaker A: It is still in design on our end, but we will organize a series of meetup in Europe in the first Alpha 2022 to get user to get devs up to speed with Starknet and explain how you can build stuff on Starknet. So stay tuned for that. If you have favorite cities you think we should visit, do let us know. Paris is obviously an easy one, Berlin probably. But if there are others, do let us know. Okay, so I think that's it for today. Thank you for joining.
01:13:01.470 - 01:13:49.100, Speaker A: And I look forward to the next one, which should be in about two weeks. Actually, two weeks is the week between Christmas and New Year's Eve. So if that's fine with everyone, let's catch up during the first week of January. Okay? And yeah, with that, I thank you all for your time and attention. Thank you again to Arjun for presenting with us, and thank you all for this time you spent in that community. We're very excited to have you all along for the ride. And this is going to be, 2022 is going to be great.
01:13:51.390 - 01:13:54.610, Speaker C: And with that, good.
01:13:54.640 - 01:13:57.360, Speaker A: Goodbye. Until next time. Thanks, Tom.
