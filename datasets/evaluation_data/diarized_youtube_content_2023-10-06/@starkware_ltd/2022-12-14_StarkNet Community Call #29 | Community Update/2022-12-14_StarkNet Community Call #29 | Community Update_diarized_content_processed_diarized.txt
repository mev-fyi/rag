00:00:00.170 - 00:00:23.902, Speaker A: Backend. So I'm just going to click go live and we should now be live on YouTube. Very nice. All right, so Ohad, if you're with me still, I think we can start. So people are going to trickle in a little bit. Usually we're late, but this time we're fairly on time. But I think it's good if we start now.
00:00:23.902 - 00:01:27.400, Speaker A: So welcome for this new community call. I realized that I wasn't tracking exactly when we started, but I think it's been almost a year since we started doing these community calls, which is pretty cool. And today we're going to have two persons from Starquare talking with us. The first one is Ohad and the second one is Ariel. And we are going to talk with Oad about data availability and what we can expect of Starknet. On that topic, what are the design choices, what are the things we're considering? Then we're going to talk with Ariel about Cairo one a bit more in depth and specifically what Sierra is, which is also a major thing that Cairo one is going to bring into the mix. So I just want, before we start, to underline that these discussions were not like, it's a bit new for us and it's a bit of a different process than we are used to.
00:01:27.400 - 00:01:54.190, Speaker A: We are basically going to talk about what we are considering for the design of Starknet. You shouldn't take these things as a commitment or as a specifications. This network is currently being built and we're just going to talk with you about what things we think are good. What things we're not sure. And what are the questions we're pondering? Is that an accurate description, ohad?
00:01:56.290 - 00:02:04.762, Speaker B: Yes. I mean, we are here to share our thoughts and we can't commit on anything yet. It's already like fresh from the oven.
00:02:04.926 - 00:02:22.300, Speaker A: Super cool. Very nice. Okay, so actually let's start. So let's start with data availability. So ohad, you've been working as a product manager at Starkware for a while. You focus. You spent a bunch of time on Starkx, right?
00:02:23.870 - 00:02:35.710, Speaker B: Yes. So I've been with Starkware for the last two and a half years. The last one and a half years were around Starkx and the DydAc environment we have with them, and then I shifted to Starknet.
00:02:36.290 - 00:03:15.370, Speaker A: Very cool. So you have worked with zekureolabs for a bunch of times. And the topic we're going to talk about today is the data availability. I don't know exactly how to describe it, the data availability problem or solutions around DA, but I think your insight is really interesting because Starkx already has some really interesting flavors of data availability, and Starknet is in the process of designing this. Can you, in a few words, just describe what the data availability problem is? What is the problem we're trying to solve?
00:03:16.270 - 00:04:23.040, Speaker B: Sure. So data availability means that all the relevant parties would have all the information needed to either continue the state of the system or to exit the system. So with tartex, for example, it's a fully self custodian environment and you basically have a scape edge, which means that if someone sends us your withdrawal, the entire system is freezing. And then users need to have the data in order to actually exit the system. And then the question is, how do they obtain it? Are they doing it from Ethereum archive node or from azzle source? With Darknet, the point of data availability long term is to allow anyone to set up a sequencer and sync on the data and be able to continue to process transactions. Right. And then the question is when the data is stored and where the data is stored, and how to build up a decentralized protocol around that.
00:04:24.230 - 00:05:04.494, Speaker A: Okay, really cool. So usually when we talk about data availability, there are two terms that come up. So the first one is fully on chain data or off chain data. Another flavor of these two words is Zk roll ups or validity roll ups. And on the other side, validiums. So Zk roll ups is when data is on l one, right? So our on chain data, meaning the l two data that allows you to reconstruct the state that you just described, is sent to l one. And to a certain extent it is stored there.
00:05:04.494 - 00:05:16.020, Speaker A: Right. Now for validiums, where data is not on chain here, it's a bit more fuzzy, right? I mean, the data is not sent to l one. So where does it live?
00:05:17.590 - 00:06:18.550, Speaker B: So this is part of the challenge in actually designing an off chain data availability system that would still be secure if you look on the stock situation, even if you don't send data to Ethereum, obviously, besides the stock and sequencer that's currently stalker, operates, all the full nodes sync on the data. So it's not like you have no backup. Still, the security assumptions are different, right? You could say that potentially some crisis happened and there was a state update without the data being available on Ethereum, and all the phone nodes in the world didn't receive it or deleted it. So it's not the same security assumptions. And this is why we will try to walk and walk with the community on what to do in these areas. But we really should do something and we can't just remain with onchain data availability.
00:06:20.090 - 00:06:25.750, Speaker A: Why can't we like, I'm sorry, I'm not sure I follow. Do you mean because it's not safe or because it's too expensive?
00:06:26.650 - 00:07:29.174, Speaker B: I mean, a system with only on chain data availability is obviously secure, right? It's the most secure as it gets because all the data is enforced to be on Ethereum, and everyone that listens to Ethereum can reconstruct the state. The issue is that on chain data availability is extremely expensive. I mean, the old novelty of zero knowledge proof is that you can add many more transactions and the verification costs roughly stay the same. But it's not the case for on chain data, right? Because the more transactions you have, the more data differences you have. And this grows roughly, linearly. So if we want to build a very scalable system that gives exponential scaling over Ethereum and not some constant factor, we can't settle on on chain data as being the only alternative. Obviously we need to allow it for any project that say we care more about security and less about costs.
00:07:29.174 - 00:07:34.030, Speaker B: But we should, as Darknet suggests, another alternatives to on chain data availability.
00:07:34.850 - 00:08:20.234, Speaker A: Okay, I see what you mean. So you're saying that basically you're saying security is a spectrum and that people who want something very safe want on chain data. People who are fine with taking some security assumption should be able to do it also. Okay, so where do we go from what? What are the design choices we have? Can we talk maybe about how Starkx operates? Because Starkx has some off chain data solution, right. And you can have Starkx as both validium, where all the data is off chain, and Starkx as a ZK roller pool. All the data is on chain. And then you can also have it as something that is in the middle, which is volition, right.
00:08:20.234 - 00:08:23.870, Speaker A: Where you can decide, some things are on chain, some things are off chain.
00:08:25.170 - 00:08:34.640, Speaker B: So you had a slight confusion between the terms. So volation is when everything is off chain and validium is when people can choose.
00:08:35.350 - 00:08:36.100, Speaker A: Really?
00:08:39.190 - 00:08:46.862, Speaker B: Yeah, I think maybe, I'm sorry if I did the mishap there early, confident.
00:08:46.926 - 00:08:50.950, Speaker A: That volition is when you can choose, but it's fine.
00:08:51.020 - 00:08:57.574, Speaker B: Yeah, volition is when you choose. I'm sorry. Volition is when you choose. And voladium is the option. Data availability, I'm sorry.
00:08:57.692 - 00:08:58.422, Speaker A: No problem.
00:08:58.556 - 00:09:49.980, Speaker B: It's confusing terms, always the vis. At least Starknet doesn't start with v. So what we do with volition in Starknet. So this is like the off chain data availability is basically we have a data availability committee which is like a quorum of very respectable organization in the web. Three industry such as like consensus and obviously Starquare and Starkx partner also in this committee. And basically each state update is conditioned on the quorum attesting that he has the data. This means that even if you use off chain data you can be certainly confident that many reputator like reputation parties with reputation attested that they have the data which shows some security.
00:09:49.980 - 00:10:38.390, Speaker B: This is not something we consider for Starknet in the short term. I mean this is a solution that I think is relatively secure. It also very centralized in its flavor and we don't want to go to what feels like a permanent and centralized route as a design decision by Stalkware. I'll get soon to what we are going to do, but the rationale is to leave things open ended and let the Starknot foundation and community and governance decide on what concrete action items to take and whether the solution should be something like a data committee or working with celestia, or 100 other alternatives.
00:10:38.810 - 00:10:52.270, Speaker A: When you say 100 other alternatives, meaning that there are 100 other choices and we should pick one, or can we imagine a future where there will be various data availability flavors on the same network?
00:10:54.130 - 00:11:31.100, Speaker B: I think long term we should definitely aim for several data alternatives within stocknet. But I do think that we need to decide as a community what is like the default or the most vanilla flavor of data availability. For example, is it okay if only the full nodes know all the data or we say that all the data should be backed by something and then potentially contracts could opt in to also have onchain data availability or also have other protocols attesting the relevant data.
00:11:32.750 - 00:11:52.590, Speaker A: Wait, I'm not sure I follow here. So you're saying that there should be various solution but one will be the default that most people will use. Right, but can you expand a little bit on what you said? Like should all full nodes have it or. I'm not sure what you mean here.
00:11:52.740 - 00:13:12.666, Speaker B: Sure. So by default all the sequences and all the full nodes of stocknet have the data, right? And this is like you could view it as an off chain data availability. I think that long term it's the responsibility of the community, the governance to say what other solutions can starknet offer to the relevant contracts? What do we enforce in the smart contract, if any? Maybe we stay at this level. Some applications choose to go with the data is only available in the full node and some applications want to have onchain data availability and some applications want also like a committee that to test the data and so on and so forth. Alternatively, the governance could say, okay, so all the contracts in the network should be backed by Celestia and we somehow integrate. I just give Celestia because it's a concrete example. We actually don't have current discussions with Celestia and maybe I should move to imaginary name, but this is like long term decisions about how the protocol, and.
00:13:12.688 - 00:13:49.654, Speaker A: Also you're talking about Celestia specifically. I don't think like data availability is a weird problem because there are actually two aspects in it. Right. Was the data available for everyone to see at a given point in time? And is the data available in the future? And it feels like Celestia is solving the first one. It's showing that, yes, the data was accessible to everyone at a certain point in time, but it doesn't give you a guarantee that it will be accessible for everyone to retrieve in the future. Right. It doesn't solve the storage issue, does it?
00:13:49.852 - 00:13:56.530, Speaker B: I mean, I don't want to deep dive into celestia. I gave it because I know it's a concrete protocol.
00:13:56.690 - 00:14:08.540, Speaker A: So let's take EIP 4844 because it's the same kind of issue. Right? 4844 allows you to show that some data was available, but it doesn't guarantee you that it will be stored for the future.
00:14:10.110 - 00:15:04.558, Speaker B: Yeah. So I think we should, obviously, when we talk about that availability, four eight four is like they are fronting the room and I want to address it shortly. I just want to say around selastia, I actually don't know. I think that it's up to research done by the community about the foundation to survey different protocols, different routes to tighten the data availability offering celestia is just one example that they'll probably take a look at. I'm sure they'll take a look on many other things that can be done around 4844. So, yeah, I mean, we are definitely aware to this Ethereum improvement proposal. For those who aren't familiar with it, each Ethereum block would have like two blobs of data.
00:15:04.558 - 00:15:51.840, Speaker B: You can put stuff in there. It would be a different market to the gas market of the Ethereum transactions and archive nodes would be expected to store it for one to three months. So the data is available when it's fresh, but not for very long. It's projected that like 4844 would give some significant cost reductions. And I think that long term, if we have no other alternatives, we definitely will shift to 4844 as some backing mechanisms. But there are also some disadvantages to 4844, like it's not a silver bullet. That would solve everything.
00:15:53.250 - 00:16:09.140, Speaker A: Okay, perfect. Thank you. All right, so I am sorry because I went on a tangent here and I think you wanted to explain something before I mentioned the difference between both.
00:16:11.110 - 00:16:12.420, Speaker B: Sorry, say again?
00:16:13.030 - 00:16:23.606, Speaker A: I think I went on a tangent talking about the issue about data being available and data being stored, but you were about to say something or not?
00:16:23.788 - 00:16:24.614, Speaker B: No.
00:16:24.812 - 00:16:25.560, Speaker A: Okay.
00:16:26.410 - 00:17:23.370, Speaker B: I think maybe it's time that we delve into like, okay, so far we covered why it's a problem, right? We covered why we can't stay with on chain data availability only. We covered why we are not going with a stark solution, which is like choosing some data availability committee, like, this is too centralized solution for Starknet. Maybe in a year the starknet governance would decide to have it. We don't want to start with it as the default. Maybe now we can move to what we will do and why we are doing it. So what we plan to do in a high level, we plan to offer off chain data availability alternative. This means that some parts of the Starknet state will be available only to all the full nodes initially.
00:17:23.370 - 00:18:33.120, Speaker B: And while this solution is in place, we will walk in two parallel lines. So first we will walk to ensure that 4844 would happen and stagnant will be able to use it. I view it as like the fallback route. And in parallel we will research like, okay, how can we back up this data beyond just keeping it in the full nodes now? I think that there are really short term gains here because as long as tarknet is centralized and this phase is expected to happen for quite some time, there's really no additional security benefit from publishing all the data on chain because effectively now the system is centralized and people can't really use this data. So we still have, I would say a noticeable period to come up with several alternatives and discuss with the community. Okay, so the data that is being stored only off chain, what do we want to do with it and where do we aim to publish it long term in order to create as secure system as possible.
00:18:35.490 - 00:18:42.900, Speaker A: Just to make sure. I understand. So you mean the data that you will go through, 4844, you will consider it off chain or on chain data?
00:18:46.710 - 00:19:22.062, Speaker B: I think that it's left to be seen how exactly 4844 would be implemented. I think that like on chain data means that the data is always there. So to this extent, 4844 is not as secure as the onchain data we currently have. And we will very much consider it as a route for our off chain data when it is available. I would love to see other options though, because I don't think that 4844 is a magic bullet. It is like a second market. We can't know ahead.
00:19:22.062 - 00:19:37.910, Speaker B: It would be scaled enough, it would offer enough compelling advantages. So I'd rather have other solutions in my arsenal in addition to this one. But this is one solution that I can be certain it will come eventually.
00:19:38.410 - 00:20:01.360, Speaker A: Okay, makes sense. I think I understand. Thank you. Okay to track back a little bit. Also, when we're talking about data availability on chain data and off chain data here, we're talking about having both of these coexist on the same network. Or are we talking about a starknet with on chain data and another network with off chain data?
00:20:02.210 - 00:20:36.710, Speaker B: No. So if for sure talk about one network, I think that it makes no sense to declare two different stock nets. It creates some unreasonable fragmentation. Obviously, if you are security maximalist, it's not enough to use on chain data contracts. You also need to see that they are not dependent on off chain data contacts, right. In order to preserve these security assumptions. But I think that there is no strong enough justification to split the network into two parts.
00:20:36.710 - 00:20:58.800, Speaker B: Now what? We are not sure yet, right. So until now I told staff that we are sure if we go to the lower level, a bit more design related areas. And here we are still not sure if on chain or off chain decision will be done in the contract level or in the storage variable level.
00:21:01.170 - 00:21:18.278, Speaker A: So you mean when you're writing a smart contract, whether you decide your smart contract it is fully off chain or if it's fully on chain, or if inside your smart contract you can have some variables that are on chain and some that are off chain. Is that correct?
00:21:18.444 - 00:21:26.520, Speaker B: Yes, exactly. So we didn't decide yet. I think that there are many polls and calls to both direction here.
00:21:26.970 - 00:21:29.018, Speaker A: Can you present a few?
00:21:29.184 - 00:21:52.634, Speaker B: Yeah. So just in a nutshell, obviously decide at the storage variable level is what makes you the most flexible, right? Because you can decide, okay, a user want to have his balance on chain, cool, I'll write it in this mapping and the other wants to have off chain balance.
00:21:52.682 - 00:21:52.906, Speaker A: Cool.
00:21:52.948 - 00:22:36.334, Speaker B: Write it in the azure mapping and everything happens in the same contract. I think the disadvantages, just from the developer perspective, I don't even get to other aspects which are more in the level of how we are going to implement it. But from the developer perspective, let's consider ERC 20. It's very easy to keep the interface ERC 20, like when you say okay, I have off chain or on chain ELc 20, right. But if suddenly whenever I do transfer or whenever I handle a deposit I need to say, oh, go to this mapping, go to that mapping. I'm not sure we can be fully compatible. Right.
00:22:36.334 - 00:22:40.800, Speaker B: And it's something we also want to have. So the non trivial trade off here.
00:22:41.970 - 00:23:14.422, Speaker A: Understood. Thank you. Okay, I think it's fairly clear and I'm curious to hear as to. We're not here to talk about timelines and commit to anything. The goal here is just to be transparent in the reflections we have internally. So I'm curious, where are we in this reflection and how far are we from having this usable?
00:23:14.486 - 00:23:57.234, Speaker B: Basically, yes, sure. So there is wide internal consensus that this is a very important topic to address. Like just off the top of my mind, more than 90% of costs in starknet right now is due to onchain data availability. So we keep saying starknet is carrying because calculations are extremely cheap and it's correct. And actually this is the battleneck for significantly reducing the cost of starknet. And this is why there is internal agreement that this is very important topic to address. Now obviously 00:11 is focusing on Cairo one and starting their genesis.
00:23:57.362 - 00:24:01.410, Speaker A: So 00:11 is the next version of Starknet, right?
00:24:01.580 - 00:24:34.494, Speaker B: Yeah. So it's the next version of Starknet. It's planned for like one and a half, two months from now. Like end of January hopefully. This is like all around Cairo one and the regenesis. Now the question is what is the most important topic to address in 00:12 and here? Definitely offshore data availability is one of the leading candidates, but it's not the only one. Another example that we strongly consider to refactor is like the fee structure.
00:24:34.494 - 00:25:22.946, Speaker B: So currently if you are not aware, if you have a transaction on Stocknet, you actually pay according to the maximal amount of built ins you use. And the fee structure itself is a bit premature for what you'd like to network. There is no any gas variables. You can't say what is your gas limit and what is your gas price? I'm not much into the fee restructuring team, so maybe those particular examples is something that is not in scope for the first milestone. But it's for sure something that we need to tackle if we want to mature starknet. And potentially we have other candidates like Starknet currently work with FIFO and we don't have mempool. Right.
00:25:22.946 - 00:25:44.300, Speaker B: So it's also part of the fee structure to like. Okay, I want my transaction to be prioritized. I think it's definitely in the top three, but we can't know for sure which of these top three would make it into 00:12 because all of those are relatively large features and we can't help, I think, to address more than one of them in zero point twelve.
00:25:45.790 - 00:26:01.120, Speaker A: Yeah, definitely. But there is zero point 13 and zero point 14 after that. So hopefully this will come not too long after. What would be your argument for putting it before the others?
00:26:05.750 - 00:27:05.638, Speaker B: I think getting a significant reduction of what is today 90% of the start net cost is a no brainer. But again, we have a lot of people and a lot of opinions here and this is not committed. I can also see reasoning to start working on gas price and gas metering all of those areas that are still missing. I think that a potential appealing to have this feature available during the regenerasis period is if we can find a way for direct migration from Cairo zero code to Cairo one code with off chain data availability. I think that this is something that sounds really good on paper, but we still can't commit that it would be executed like this. Designing the off chain data availability would be much simpler if we don't have to consider migration flows in mind. Right.
00:27:05.638 - 00:27:45.422, Speaker B: And also if we say, okay, we have this migration scheme, even if we do succeed to enable it real time, it will slow down migration to Cara one. And most of the motivation for the regenerates is get it done with and start leverage on the Cara one features. So this is another big decision point. Obviously it would help the project, but it would delay the network development potentially even significantly, and would make this feature more complicated. So again, no clear trade off here, I think from the network design perspective.
00:27:45.566 - 00:27:59.400, Speaker A: So the bottleneck is how fast can we ship features and how finding a balance between the features we ship and how people are able to leverage them and build on top of it.
00:27:59.770 - 00:28:01.800, Speaker B: Exactly, yeah.
00:28:02.170 - 00:28:33.120, Speaker A: And in a way, we're very lucky. It's a double edged sword, having a network that evolves a lot. We're on the frontier. We have new things that are available. I don't think there is a network I know of that would allow you to have a differentiation of the cost structure for the kind of variables you want to use depending on your level of security. But it comes with finding the right way to do it and then finding the right way to do it on a live network. So it's not that easy.
00:28:33.120 - 00:28:50.694, Speaker A: Ohad, we've been talking for half an hour. I know you have something else planned. So I want to thank you a lot for your presentation. I'm going to add Ariel, who just joined us. Hey Ariel, good to see you.
00:28:50.812 - 00:28:51.686, Speaker B: Hey everyone.
00:28:51.868 - 00:28:53.480, Speaker A: Are you in the same room?
00:28:54.410 - 00:28:57.078, Speaker C: No, but we're close, I think.
00:28:57.244 - 00:29:02.280, Speaker A: Okay, so we just have whiteboards with cryptic stuff on them in every room, right?
00:29:03.450 - 00:29:04.662, Speaker C: Probably, yes.
00:29:04.796 - 00:29:15.950, Speaker A: Cool. So, oad, thank you for your time. Anything you want to say to before closing off on the topic of data availability?
00:29:16.290 - 00:29:34.420, Speaker B: Yeah, just thank you for having me. And if you want. If this news inspired you to start a discussion and give your opinions and reasons. Obviously we are currently in design phase and we can't address everything, but we would love to hear from you.
00:29:36.230 - 00:29:43.400, Speaker A: What's the best way for people to give their opinion? Is it on the Starknet community forum? Is it on Twitter? Is it your personal email?
00:29:45.530 - 00:30:04.140, Speaker B: I think the community forum is definitely a place I'd love to see off chain data availability discussion spark up. If you have something less materialized, feel free to approach me on telegram as well. It's Ohad Starkware, but most definitely the community forum is the best place.
00:30:04.510 - 00:30:08.478, Speaker A: Fantastic, Ohad. Thank you and see you soon.
00:30:08.644 - 00:30:09.950, Speaker B: Thank you. Bye bye.
00:30:11.730 - 00:30:39.542, Speaker A: All right, so I'm going to remove kick from studio, no, remove from stream. There we are. Okay, so it's me and Ariel now. Ariel, thank you for joining us today. And to everyone who is listening, I hope this discussion about data availability and how we think about it in the context of Starknet and what you should expect in the coming months or weeks, hopefully was interesting. Don't hesitate. If you have questions, you can ask them on YouTube.
00:30:39.542 - 00:30:54.990, Speaker A: You can probably ask them on Twitter also. And you can also send them if you're on discord, you can ask these questions in the community calls channel. Ariel, have you connected to the community call channel on Discord?
00:30:55.650 - 00:30:58.030, Speaker C: No, but I will now.
00:30:58.180 - 00:31:02.320, Speaker A: She can. That would be perfect. There is 180 person waiting for you.
00:31:03.410 - 00:31:08.530, Speaker C: I'm sorry, I should mute there. Or I should mute here. How does it work?
00:31:08.680 - 00:31:20.200, Speaker A: So when I'm going to talk, you're going to hear me in Echo, which might be a bit painful. There is an icon with headphones on discord. If you click on it when you're not talking, you will hear me only once.
00:31:23.370 - 00:31:32.042, Speaker C: Okay. I joined the community call, I joined the stage and I muted the discord. Does this mean everybody can hear me?
00:31:32.096 - 00:31:40.646, Speaker A: So this means people can't hear you on discord now? They can, but now you're muted on stream.
00:31:40.678 - 00:31:43.486, Speaker C: Okay, I need to be unmuted in both. Okay, got it.
00:31:43.508 - 00:31:50.910, Speaker A: You need to be unmuted in both. When I'm talking, you should click the add phone button in discord.
00:31:51.490 - 00:31:52.298, Speaker C: Done.
00:31:52.484 - 00:32:51.810, Speaker A: Okay, perfect. All right, Ariel, thank you for joining us today. So we wanted to have a technical community update today for the community call. So we discussed data availability with Oal, and we thought it would be interesting to dive a bit more in depth with you in Cairo one and Sierra specifically. So I have a bunch of questions, and I guess before we start, can you give us a small timeline of where we are in the Cairo one transition? Cairo Zero was released a bunch of months or years ago and people have been starknet is written in Cairo, Cairo Zero. And right now when you write a Starknet smart contract, you write it in Cairo Zero. Then in September we announced Cairo one, right, which is a new version of Cairo.
00:32:51.810 - 00:33:06.680, Speaker A: And then two weeks ago we released a repo for Cairo one. Where are we in this transition? You can't write Cairo one contracts on stocknet. So what's the plan?
00:33:07.050 - 00:33:11.094, Speaker C: Yeah, so first of all, am I unmuted in all the appropriate places?
00:33:11.142 - 00:33:12.220, Speaker A: Yes, you are.
00:33:13.470 - 00:34:29.746, Speaker C: Okay, so where we're at now, currently the team is working on building the compiler for Cairo 1.0 and reaching initially the capabilities of the current version of Cairo. And then obviously more things will be added like loops and fancier stuff that aren't in Cairo zero already. The language, if you go to the repository now, contains stuff that are not in Kyrozio, not maybe functionality wise, but let's say code style wise, everything is much more similar to rust. There's no more revoked references, there's a uniform way to define a variable, no more of the temp VAR to handle revocations nonsense, or three different ways to define a variable. So this is no longer so they're currently working on the language itself and also on the Starknet representation of it. So like today we have native Cairo and the Starknet Cairo pretty much.
00:34:29.746 - 00:34:51.240, Speaker C: So there the separation will be probably less emphasized, but there will be some syntax to define contracts in Cairo one, so this will be added shortly. This will allow writing contracts with very basic functionality. And yeah, this is where we're at today.
00:34:52.190 - 00:35:21.220, Speaker A: I have a question for that. You say that this will allow you to write contracts with very basic functionalities. From what I understand, the first versions of Cairo one, you will be able to deploy like the first version of Cairo one that is deployable on Starknet. You'll be able to do certain stuff. Will it be at feature parity with Cairo zero from the start, or should you expect to be able to ship more stuff in the following months?
00:35:22.310 - 00:35:57.870, Speaker C: You'll have feature parity from the start. When I said very basic functionality, I meant today. So today you can't interact with Starknet at all. But if you want to separately just write Cairo one on your computer and simulate it, then you have only basic functionality available and soon you'll have contracts, basic functionalities available. But as we move forward it will get richer and richer until we'll be satisfied enough and say, okay, we have feature party with Kyrozio, it's time to integrate with Starknet. And that will be Starknet eleven.
00:35:59.170 - 00:36:15.620, Speaker A: Amazing. And so Starknet eleven, I heard it was for Q four, 2022 on the 35th or maybe sixtieth of December. So basically end of January, 2023, is that correct?
00:36:16.710 - 00:36:23.190, Speaker C: I am going with early Q one, and I feel this is flexible enough to accommodate all possible scenarios.
00:36:24.250 - 00:37:04.820, Speaker A: Cool, good to hear. Well, if it ships, that's the most important thing. Okay, so we should expect Cairo one to be deployable as Starknet smart contract soon. So early Q one. Understood. I don't know if there are specific points you want to emphasize, but my first question here is, is the Cairo one transition something that will entail only writing smart contracts on Starknet, or is it something that all of Starknet will like? Starknet currently is written in Cairo zero. Will starknet be written in Cairo one?
00:37:08.550 - 00:38:02.950, Speaker C: Okay, so this leads me to detail a bit. So the idea behind Cairo one is that it first compiles to an intermediate representation we call Sierra, which stands for safe intermediate representation, and Sierra compiles to the current Cairo assembly, which won't change. So today Cairo zero compiles to this very same Cairo assembly. This means that core Cairo code of Starknet, for example, the Starknet Os, doesn't have to be rewritten in Cairo one. Maybe for maintenance purposes. It will eventually be written in Cairo one, but it's not necessary from the get go. However, some parts would have to get rewritten.
00:38:02.950 - 00:38:18.982, Speaker C: For example, library functions, which are now written in Cairo zero. You have the Cairo Common library, you have different hash functions there, you have, I don't know, different arithmetic capabilities there. This will have to be rewritten.
00:38:19.126 - 00:38:24.960, Speaker A: So anything that is used inside a smart contract will have to rewrite in Cairo one, is that correct?
00:38:25.810 - 00:38:59.400, Speaker C: Yes, but the reason for rewriting those library functions is also because there will be the only, let's say, interface with hints. So like today, users won't be able to write arbitrary hints. But even more so, the only place hints operate are inside library functions. And since we want, the very important property we want to achieve with Sierra is that every deployed Cairo code can never fail. So today you can deploy a simple.
00:39:01.050 - 00:39:09.100, Speaker A: You say when you say never fail, what you mean is failure is provable. You're not saying it can't ever fail, right?
00:39:10.290 - 00:39:10.894, Speaker C: Yes.
00:39:11.012 - 00:39:56.234, Speaker A: So here there's a distinction between, so right now, when your Cairo code has, for example, an assert that doesn't pass, your contract failed, but it's not really failure as we hear it in the common blockchain world. It's just that the execution doesn't complete. But since it doesn't complete, you can't generate a proof for that. So the goal with Sierra and with Kyra one is for you to be able to have contract that fails gracefully so that you can generate basically that the shell of the program doesn't fail, the logic fails, and then you're able to say, oh, there was an error. Here's a proof that there was an error. Exactly.
00:39:56.432 - 00:40:26.874, Speaker C: The keyword is graceful failures. But you need to know that no contract in the system has those, let's say ungraceful failures. For example, failed assert instructions because those we just cannot prove. I can't prove that your transaction failed because it hit an assert instruction with assert one equals two. I can't prove that if you did. If equals one succeed, else fail, this I can prove, but the former I can't.
00:40:27.022 - 00:40:35.030, Speaker A: So like Sierra is just a way for us to abstract these asserts and put them in a way that is easier to handle, is that correct?
00:40:35.180 - 00:40:58.910, Speaker C: Exactly. And even more, it's not up to the user actually, because the guarantee with Cairo one and Sierra is that the eventual generated Cairo assembly just won't contain those. It won't contain those failures that we cannot prove because you now control which Cairo assembly gets generated. You're only generating safe Cairo assembly.
00:41:00.050 - 00:41:32.650, Speaker A: Okay, I think this is really interesting. So CR is in a way, yeah, it's an abstraction layer between raw Cairo and what you're writing. Wouldn't there be a benefit in writing the whole of Starknet OS in Cairo one? I mean, I understand that there's a time constraint. Obviously rewriting the whole starknet OS would take a lot of time. Would there be a benefit long term to rewrite starknet in that you can generate a proof that yes, there was an issue here, and this failed?
00:41:33.070 - 00:42:19.926, Speaker C: I think that, okay, there's the obvious advantage of your writing nicer code because that's also something we're achieving with chira, one code, which is more maintainable, easier to spot bugs, et cetera, et cetera. So you have that. But let's say soundness or completeness wise, I think it's not very important for the OS itself to always be provable. Because you're controlling what you're eventually going to prove. If user code can never fail, if user defined code can never fail, then we don't need such guarantees for the OS. The OS can be audited manually and you can say, okay, every valid block, I can wrap it in the OS and prove its validity. That's the role of the OS.
00:42:19.926 - 00:42:49.842, Speaker C: The OS, for those who don't know, it's a big chiro program that verifies the validity of a given block. It takes a sequence of transaction, executes them, and computes the new state commitment. So if you manually audit so that the OS cannot break your process, it cannot fail in some transactions, then this is good enough. And that's not the case with user defined code, because there you can have someone maliciously injecting some very specific code.
00:42:49.976 - 00:42:52.642, Speaker A: Yeah, but there can be a bug in the OS also.
00:42:52.776 - 00:42:53.780, Speaker C: That's true.
00:42:56.870 - 00:43:03.560, Speaker A: I guess the follow up question is, even if you found a bug in the OS and you were able to prove it, what would you do with it?
00:43:04.650 - 00:43:28.080, Speaker C: But there's also the question of what is a graceful failure of the OS. So I wasn't able to prove the entirety of the block, but what I will partially update the state? Probably not. So I think those guarantees are very important for user defined code. Outside this context, maybe, but I don't see an immediate reason.
00:43:28.690 - 00:43:40.002, Speaker A: Understood. Thank you. I don't know if there was a specific topic you wanted to touch on. Otherwise, I have a bunch of questions.
00:43:40.056 - 00:44:35.650, Speaker C: I can still follow up. Maybe I can also mention a change that happened again, it's abstracted from the users, but in the realm of hints. So one of the things we need with Cairo one and Sierra is that the execution should be deterministic. For example, today we have the common library function find element. What find element does is it takes an array, a pointer to a beginning of an array, and size doesn't matter, and a key you want to look for. And what it does is it searches in the array within a hint. The hint produces an index, and you then verify that the index from the hint does contain your element, the element you want to find.
00:44:35.650 - 00:44:38.280, Speaker C: And that works well with Cairo zero.
00:44:40.490 - 00:45:25.070, Speaker A: I don't know if everyone on the community call is aware of how hints work. I just want to make a short parenthes here. So hints are like, I consider it kind of a superpower of Cairo. It's kind of weird, but to me it's a way to give shortcuts to the person executing Cairo code. Hints are essentially a way for you to, inject Python code that is executed by the sequencer or by the prover when he's generating the Cairo code. So this has the nice property that if there are some things you want to write in Python and you can't write them in Cairo, you can tell the proverb, oh, take that python code and then use that result. Right.
00:45:25.070 - 00:46:17.734, Speaker A: So the example that is often taken in the documentation is, for example, to calculate the square root of a number. The downside to that is that int should really be treated as a user input, but by the prover. You're basically letting the prover input whatever he wants, because when he executes kyotin code, there is no way for him to prove that he executed correctly. So you should sanitize and check everything that comes out of a hint. But still, it's a nice tool. And what you're describing here, for example, for finding an element in the list, is that instead of writing the Cairo code to go through the list and finding the element, you can just tell it, hey, execute this python logic, find this element in my list, and then when you go back to the carrier code, you just verify that indeed this element is in the list. Is that correct?
00:46:17.932 - 00:47:04.802, Speaker C: Yes. What's interesting here is Sierra context is the case where the element is not in the list. So what happens today is that find element will fail and I won't be able to prove it. So you should only use find element in the case where you know the element exists and you want to find its index. In that case, the hint helps you save a lot of Cairo instructions because you only do like two whatever Cairo instructions instead of searching through the whole array, because the hint gives you the index. And if it's not there, whatever hint the proverb gives you, the assertion done in Cairo that the array in this index contains the searched value will fail if the element is not there. So in Sierra we can't have that.
00:47:04.802 - 00:47:09.810, Speaker C: We can't have a flow that ends in something we can't prove.
00:47:09.890 - 00:47:40.798, Speaker A: Okay, I think I understand. Basically, if the prover doesn't find the element in the list, it will give a random index, and then the Cairo code will say, well, I can't find it. So it's the same to have this and to have a malicious sequencer, because anyway, there's no way to prove that the element was there or not. But in Sierra we want stronger assumptions. We want to be sure that if somebody tells you no, it's not in the list, then it is indeed not in the list, correct?
00:47:40.884 - 00:48:28.270, Speaker C: Yes, because otherwise we can't really charge fees. We have to trust the sequencer and et cetera, et cetera. So what we have to do, for example, in this case is to change the logic and say, okay, if what was given in a hint was not the requested element, then I actually have to loop in cargo through the entire array to verify that the element was indeed not there. And then I can say, okay, it wasn't there, and I move forward. So I have to handle all cases. I am still searching through the entire array in the worst case, but if the element is there, the hint can help me. But I can't have a branch where I am not certain of the result.
00:48:28.270 - 00:48:33.410, Speaker C: And I'm leaving it up to the prover who gave me the hint.
00:48:33.910 - 00:49:22.766, Speaker A: What I think is really interesting with all these topics is that this whole computing paradigm is new, and so there are a lot of attack surfaces we haven't really thought of yet. The first thing I'm thinking is that if I'm a sequencer, there's a very niche attack where I can just figure out, oh, there's not enough gaff to go through all the list. So I'm not going to execute this call. I'm just going to give some random value, and the Cairo program will have to go through the loop to prove that it's not in there. And even though if it's somewhere down the line, the call will fail, and I can basically make a transaction fail that wouldn't fail otherwise. But it's edge cases and corner cases anyway.
00:49:22.948 - 00:49:45.686, Speaker C: I'm not sure I understood the attack, but the point is that you don't want to allow the proverb to cheat, because if the element is there, okay, if he gives the right hint, everything's good. But if he says the element is not there, then you will actually find a mistake in Cairo. So there's not a lot of damage you can do.
00:49:45.868 - 00:49:56.906, Speaker A: Sure. If there's gas metering and there's just not enough gas to go through the whole list because the list is very big, then there's a way for the sequencer to misbehave. Right.
00:49:57.088 - 00:49:59.340, Speaker C: I see. I need to think about it.
00:50:00.030 - 00:50:22.180, Speaker A: It's just an edge case, right. I find it fascinating for a lot of the things that are being built, there is such kind of edge cases. So security researchers are going to have a fun time for the coming years, but they're here for that. That's cool. All right. Okay. Really cool.
00:50:22.180 - 00:50:40.810, Speaker A: Yeah, I think that's mostly what we want. I don't know if there were other topics you wanted to dive into with regard to Cairo one. Oh yeah, actually another one. So right now hints are in python. Can we expect Cairo one to have hints written in rust or other languages?
00:50:42.350 - 00:51:19.030, Speaker C: So the short answer is that, I don't know, I'm not sure, but probably you shouldn't expect them in python. That would be super weird. Whether we will allow the native Cairo to use arbitrary hints written in rust like we do today? I think the answer is yes, but it's not a priority now because now we're focusing on integrating with starknet, and Starknet doesn't allow custom hints, but I don't see a reason not to do it in the future. Obviously with rust and not python.
00:51:19.610 - 00:51:30.380, Speaker A: I have a question, actually. With arbitrary ints. So currently you cannot execute arbitrary ints in Starknet, but you can execute arbitrary ints with sharp. Why?
00:51:31.310 - 00:51:59.474, Speaker C: You can't execute because the input to sharp is a finished Cairo execution. And the first thing sharp will do before starting to prove is making sure that everything is indeed valid. So sharp doesn't execute the hints, you execute them locally when you construct the entire execution trace, and sharp doesn't care how you produce them.
00:51:59.672 - 00:52:11.400, Speaker A: Interesting. So in other words, when you're sending a job to sharp, you're constructing the trace locally, and so ends are executed on your machine, not on the sequencer, not on the sharp train.
00:52:13.210 - 00:52:17.400, Speaker C: Like interacting with the sharp for the playground, for example.
00:52:18.030 - 00:52:18.730, Speaker A: Okay.
00:52:18.880 - 00:52:19.580, Speaker C: Yes.
00:52:20.430 - 00:52:29.580, Speaker A: Okay. Really cool. All right. I think that's most of the questions I had. Anything you feel we should mention?
00:52:32.530 - 00:52:36.350, Speaker C: I feel like there are a lot of things and considerations now.
00:52:36.420 - 00:52:37.182, Speaker A: Go ahead.
00:52:37.316 - 00:52:47.938, Speaker C: The whole issue of how exactly gas metering is done this is still in the works, so we'll probably discuss it in the coming weeks.
00:52:48.104 - 00:53:01.640, Speaker A: Can you introduce briefly what's the matter with that? Because right now starknet is able to measure how much gas is consumed by a contract coal. Correct.
00:53:02.010 - 00:53:56.230, Speaker C: So what is done today is completely sort of off chain sequencer level estimation of the fee. And the only thing that is proven is that the fee charge does not exceed the max fee that was signed by the user. There is no metering in that sense. There is only sequencer level of chain metering. We don't charge the maximum always, we charge according to our metering. But this is not proven and we want to improve the situation and actually have a proven gas metering. So the very short TLDR is that in the compilation from Sierra to Cairo assembly, you will have low level gas instructions that will basically every few opcodes they will update a counter.
00:53:56.230 - 00:54:48.582, Speaker C: And that's how you're going to do the metering. For example, you have five static commands, five additions. Then, okay, you update this counter, you subtract the cost of five additions, and eventually the stagnatos will use this information when it charges fee, unlike today, where the actual fee is just given in a hint. So the actual low level assembly generated from Sierra is in charge of counting the guests. But there are a lot of complications with function calls and recursion. And you can imagine how this complicates things, like how is the cost of a recursive function defined in compile time? Because again, those instructions are hard coded in the contract. But I'll just mention this issue.
00:54:48.636 - 00:55:35.570, Speaker A: But interesting topic. Well, it sounds like yet another thing that's here I will solve. I love that Cairo one will be easier to write and more comfortable, and that we'll have for loops and stuff like that. But I feel like focusing on the language. Syntax is kind of missing the forest for the trees in the sense that having Sierra, I think, code that can gracefully fail, having gas metering inside a contract, is a much bigger deal for the future of the network than whatever syntax improvement can be. I mean, syntax improvement will bring a lot of new devs and a lot of new things, which is amazing. Right? We need people to build on the network, but CRI brings resilience and DOS protection mechanism.
00:55:35.570 - 00:55:41.020, Speaker A: This is huge. We can't do anything without that. Right?
00:55:41.710 - 00:55:55.402, Speaker C: Yeah, I completely agree. CRi is going to be a key component in said the syntax. You can always improve.
00:55:55.466 - 00:55:55.694, Speaker B: Yeah.
00:55:55.732 - 00:56:19.030, Speaker C: It's important to have a language that is more convenient to devs, especially in rust spirit, if we're going in that direction. But Sierra has independent guarantees for the network entirely that are independent from Cairo one even. All these discussions happen in the transition between Sierra and Cairo assembly.
00:56:19.770 - 00:56:39.434, Speaker A: Wonderful. All right, Ariel, thank you a lot for your time. I think we're going to wrap up this community call. I don't see any questions. I've looked on discord, I see Dirkos nightmare thinking, oh, hard for his intervention. I'm sure yours was also very much, very well received. Thank you for your time.
00:56:39.434 - 00:57:06.226, Speaker A: Let me check if there are questions on Twitter. I don't see any. So I'm guessing everything was super clear. If there are questions following up on our discussion, don't hesitate and send us a message. So, darkest nightmare is also saying, thank you, Ariel, for your. The community is listening. So, yeah, thank you everyone for sticking with us to the end.
00:57:06.226 - 00:57:39.982, Speaker A: I hope you learned something. And this is a bit of a new format we're trying. We want to discuss more of these things in public. As you can see, we have a lot of disclaimers. We don't want to commit to timelines or to features too much because we don't want to create disappointments. At the same time, we feel like it's really interesting to give you an insight as to what are the problems we're tackling and where we are in the development of starknet. So this is part of the process of opening up.
00:57:39.982 - 00:57:55.360, Speaker A: Hope this is useful. Don't listen and send us feedback if you want to hear more of this or if you're more interested in other stuff. But yeah, thanks, everyone, for attending. Thank you again for Ariel, for joining us today, and I hope to see you soon.
00:57:57.450 - 00:57:59.410, Speaker C: Thank you. Bye, guys. Bye.
