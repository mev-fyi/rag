00:00:00.650 - 00:00:48.966, Speaker A: Okay. Hello everyone. We are live everywhere, so this is a great time to start. First off, I would like to welcome everyone to our workshop number 14. So what is this workshop all about? This workshop is going to be all about account abstraction in practice with our amazing speaker Darlington here. Darlington is a blockchain developer passionate about leveraging cutting edge technology to build secure and decentralized solutions with a deep understanding of blockchain fundamentals and expertise in both ethereum and Starknet protocols. I have to say this at this point that I started learning Starknet through Darlington's medium articles.
00:00:48.966 - 00:01:32.410, Speaker A: There was a series of medium articles that he wrote and I really found them super intriguing. And of course he specializes in developing. He specializes in developing smart contracts and exploring innovative use cases within the blockchain ecosystem. Currently he's the ecosystem associate at Azure, a contributor at Starknet Africa, and the dev lead at a university blockchain club in Nigeria. Blockchain Unm. Welcome Darlington. We are super excited to have you and I think it's been a while since we have done a workshop and we are really excited to account abstraction has become such a spoken about topic.
00:01:32.410 - 00:01:46.298, Speaker A: Everyone is talking about account abstraction. How can account abstraction be the next big feature in the overall web3 ecosystem to onboard billion users?
00:01:46.394 - 00:01:46.654, Speaker B: Right?
00:01:46.692 - 00:02:34.720, Speaker A: We always say that the user experience in web3 has like miles to go, but can account abstraction be that key to success? Maybe. Not a lot of hype around this topic, so let's get to know from Darlington about account abstraction. So maybe, Darlington, if you could just start us off with what is account abstraction? And of course walk us through a little bit about how protocols like Starknet implement account abstraction right at the protocol level and not just at the application level. And yeah, stage is yours. Go ahead. Please feel free to share any slides that you have and speak to our audience, get them introduced to this topic, and then we'll get started with the hands on.
00:02:35.650 - 00:02:46.670, Speaker B: Right, thank you so much gan. Good day everyone. I'm so excited to be here. So shortly before we begin, right, I'm just going to try to share some slides.
00:03:22.010 - 00:03:26.598, Speaker A: Have you been able to find the present button? That's below in the.
00:03:26.684 - 00:03:31.820, Speaker B: Sorry, yeah, I've seen the present button. I'm just trying to share the screen. This.
00:03:35.810 - 00:03:48.240, Speaker A: Of course, yeah, there's an option called share screen. That's probably the easiest way to present because the other options are. Okay, I see your slides. Okay, here you go.
00:03:50.790 - 00:04:50.270, Speaker B: Yeah, so thank you so much. Sorry for that brief delay. All right, so just like Jan said, right, we're going to be looking at the concept of account abstraction and it's actually supposed to be a hands on session, right, practical session. So we're just going to take a few minutes first of all to understand the concept of account abstraction, right? Probably take a look at the history of account abstraction and then we could probably dive into codes, right? So just a brief introduction about myself, right, Darlington, currently the ecosystem associate at Argent, right. You could catch me up on Twitter at xericalington and on telegram at Darlington 68. So this is what we're going to be looking at today, right? I'm going to be looking at an introduction to account obstruction, history of account obstruction. Going to be taking a look at the error seven standards, then going to look at native account abstraction on Stacknet.
00:04:50.270 - 00:06:22.306, Speaker B: Then finally we're going to go into writing codes, right? Implementing simple account models such as an account multicolor and multi Sigon stacknet. Finally we're going to look at some basic ee use cases like what we do at agent basically. So let's just get started, right, because time. So what is account abstraction? So account abstraction basically this is buzzword that's been going on for a very long term recently, right? So we consider it a new paradigm in blockchains because it aims at making accounts programmable, right? So with the concept of account abstraction, every account is a smart contract that can basically contain logic and search opens us to new possibilities such as social recovery, fraud monitoring, multicolored and so on. So before we understand why account abstraction is important, right, we need to take a look at the status quo, how accounts are implemented currently on Ethereum. So basically on Ethereum currently we have contract accounts and externally owned accounts, right? So basically contract accounts are normal smart contract codes or externally owned accounts, usually weird transactions are initiated from, right? So currently for anything to happen on chain, the transaction must have to be initiated and paid for by an externally owned account. This externally owned account is controlled through a private key.
00:06:22.306 - 00:07:29.634, Speaker B: So you know the popular Manchester, right, not your keys, not your coins. So basically an externally owned account is controlled from a private key. So whosoever owns a private key automatically is the owner of that externally owned account, right? So basically use this private key to create a signature that proves to the blockchain that the transaction you are trying to initiate, right, eats from your own account like you're a legitimate owner of the account. So basically this is how externally owned accounts. This is how transactions work with externally owned accounts, right? So you initiate a transaction and you sign the transaction with a private key. So Ethereum currently uses the elliptical digital signature algorithm. So you generate a signature, and if that signature is valid, that transaction is added to mempool before it is finally added to the block by validator, right? Basically, like I said earlier, there's a lot of controls with the Ethereum implementation of accounts, right, that having an externally owned account and having a contract account.
00:07:29.634 - 00:09:00.734, Speaker B: So basically the whole idea of account abstraction, right, is to the user experience for users, basically introduce a way better experience than what we have with externally owned account, right? So basically with account obstruction, we have a lot of new possibilities being opened up, right? So there's the concept of social recovery. I could remember I got into crypto spaces at 2020, right? And just a few months later, after getting to crypto space, I think I lost money from hacks, right? And the second time I actually lost my life savings was like 2021, right? And that was because I got my phone stolen and I couldn't recover my wallets, right? Because I thought I could cram my seat freeze, because I was scared of writing down in people and probably keeping it somewhere at home and probably having indirect access to it. So I said, probably, I'll cram it. But then I guess all of us are very smart, right, to cram twelve citras is very young to cram, right? So I forgot it, and that was how I lost everything I had in that wallet. But account obstruction aims to make these things better, right? For example, with the concept of social recovery, going to those days when losing your keys equates losing your savings. For example, at urgent, we have the concept of guardians. So in a case where you, let's say, lose your keys, right, you have this certain guardians, which could help you recover your wallets back.
00:09:00.734 - 00:09:45.922, Speaker B: So losing your keys automatically does not equate to losing your savings. There's also the possibility of multicolored. So a lot of us have probably interacted with, let's say, uniswap and other emms, right? And there's this very annoying thing of having to always approve before you carry out transactions. But with multicolored, multicol can help improve this, right, because you could aggregate multiple calls into it. So rather than approve before carrying out the transaction, right, you could aggregate the two calls into one call. And this can only be possible, right, with account obstruction. So account obstruction, like I said earlier, it makes user experience better.
00:09:45.922 - 00:11:09.334, Speaker B: Basically, for example, we implement something called fraud monitoring, which helps you inspect every transaction to make sure it complies to different security rules, thereby helping you reduce cams and haps, right? There's also the ideas of section keys, which helps in general to improve the current gaming user experience. We're going to be looking at some of these use cases right towards the end of the workshop. So let's just take a brief look at the history of account obstruction, right? Basically, while account obstruction has been making a lot of ways at the moment, right, it has been a long time dream of many developers. So it's not just a concept that originated recently. Right. Let's take a look at different proposals that have been made over the years that lets what we have to do, right? So I think the first proposal was EIP six, which was proposed in 2016 by italian buttery. I think that was the year after Ethereum was founded, right? The whole idea of EIP six, right, was to abstract the nonsense signature model from Ethereum, right? So basically DAP developers and users on Ethereum could basically use any custom signature scheme and non model on Ethereum, right? But the problem with this proposal, I think, was the fact that it required changes to the consensus layers.
00:11:09.334 - 00:12:07.946, Speaker B: It was not the alternative we are looking for. Then I think we had 298 in, I think in 2020 we had 298 proposed. So 298 aimed to introduce a new type of transaction, right? So this new transaction was basically supposed to have tripute, I think that's in non target any data. But while tonight models the current for 37, it does not eliminate externally owned accounts completely, right? And you also had a lot of shortfalls. For example, you couldn't implement some of the use cases that make account abstraction as interesting as this. For example, you could not implement meta transactions with so many leads and so many more, right? So there was 30, 74 proposed. I think that was still in 2020, which aimed to basically make externally owned accounts function like delegate calls, right, from externally owned accounts to smart contracts.
00:12:07.946 - 00:13:14.630, Speaker B: And I think that was supposed to be done by introducing two upcodes. That was the OD opcode and the OD call, right? So basically it wants to delegate calls from standard owned accounts to smart contracts. But this like API 36, right, square changes to the consensus layer. And so I wouldn't say it was the alternative we're looking for, right? So finally, I think in 2021 ERC 47 was proposed, right? And I think was the best alternative because firstly it had the advantage of not requiring changes to the consensus layer. So basically introduced a high level new transaction, right, which was called user ops, right, user operations. So in the next few slides, we're going to look at ERC four two seven and basically how it works. So the ERC 4237 standard before ERC four two seven, right? There were still smart contracts, smart accounts on tune, but this was how they worked, basically.
00:13:14.630 - 00:14:21.846, Speaker B: So you had relayers, centralized relayers, which took transactions which was processed on smart accounts. And basically these centralized relayers was responsible for adding these transactions to the main pool. Right? But with ERC 47, ers for two seven came in and did a lot of things, for example, decentralizing the relayer. So as you can see here, we no longer have a centralized relayer, basically. But this is how ERC 47 works in a high level sense, right? So every account that implements ERC 47 must have this user op. User op is like a high level type of transaction, right? When user signs the user op, basically it gets added to what we call an alternative mempool. So this alternative mempool was not the normal Ethereum mempool, right? It's just like I said, an alternative mempool for just user ops, right? When I say user ops, I mean this special transaction that was created for now these alternative members can be picked up by what we call Bondla.
00:14:21.846 - 00:15:16.774, Speaker B: So Bondla, unlike the real, was decentralized, right? Basically what bondlas do is they carry these user ops and they bond with them into a single transaction and then pass it to an entry point smart contract. So this entry point smart contract is like a single thing, generalized smart contracts, that basically processes Bondo transactions and finally adds it to the main pool, and if valid, the transaction can be added to the block. So basically ERC 47, amongst every advantages it came with, right, it helped decentralize. So as you can see here, we no longer had need for the. This was before ERC 47, we had Relia, which added since the mempool, before the Nova validator processes the transaction. But ERC 47 introduced the second transaction. So basically, if you have an externally owned account, remember on extreme I said we still have UE.
00:15:16.774 - 00:16:46.886, Speaker B: So the introduction of smart accounts basically did not basically make UE's invalid, right? There are still UAS, we have metamask and the rest, right? So basically this is how UAs work, right? So when you initiate a transaction from an UE, as you can see, it goes into the mempool and validated by node or validator right before you added to the block. But with ERS 457, as you can see, it starts from a smart account, right? The smart account creates a user which is added to the alternative mempool and then picked up by a bondlab. Bondlab bond with the transaction sends it to an entry point smart contract, which is picked up by node or validator from the mempool. And finally before it is added to the block. Right? So although we could see that smart accounts on Ethereum has gone a long way in improving the user experience on site on Ethereum rights, but account subtraction adoption on Ethereum still remains quite challenging. It still remains quite challenging and very complicated to implement. So the question is what? Take the ERC four trick one step further, right rabbit, to unlock the full potential of AE, how about we build on, let's see, zero of like staff net, right? So basically first of all we have the advantage of building on ZK roll up, which automatically helps us build scalable dapps, right? Then we have, sorry, then we have an integration at the protocol layer.
00:16:46.886 - 00:17:46.554, Speaker B: So basically because we are building after DVM has been built, right, after etchm has been built, right, we have seen the implementing what Ethereum implemented. So we could go for that to do it better, right, that implement smart contracts, sorry, smart contract accounts basically on the protocol level. So they are no compromise, there are no centralized relayers, there are no off protocol bondlas automatically smart accounts become first class citizens. So we just have a single mempool and we have a simple transaction flow. So there's only four complications, like well core cotton joints that we had on Ethereum, right? So that brings us to native account abstraction on Stacknet. So basically on Stacknet, account abstraction is impute, right? Account obstruction is native to Stacknet. So stacknet basically maintains a model where accounts are represented by contracts but with a more defined structure, basically.
00:17:46.554 - 00:18:30.634, Speaker B: So accounts obstruction on stacknets is too modeled after the error support. So basically all accounts on Stacknet, right, are expected to implement two major functions as the validate function and the execute function. So this enables, ensures that the sequencer is effectively able to validate a transaction and get it for it with minimal risk, right? So I think in the next slide we don't know if this is visible enough, right? But this shows how basically account obstruction, the flow of account obstruction on stacknets, right? Is this very visible? Can you see this?
00:18:30.832 - 00:18:55.538, Speaker A: I can, but it is very small. I tried to make this big, but maybe if you could just like for example, if you want to explain this, then I think you can just go like component by component, like there is one at the top left and then there is like a big chunk in the center or something like that. You can zoom in a bit.
00:18:55.624 - 00:19:34.202, Speaker B: Okay, yeah, sure. Try and see if I could. I don't think I can zoom this. I'll just try my best to explain basically, like I said earlier, in obstructed accounts, right, account obstruction on Staffnet, an account, sorry, implementation. An implementation of account obstruction on staff. Net, right, is expected to have two methods. That's the execute method and the validate method.
00:19:34.202 - 00:20:48.162, Speaker B: So just to have a high level view of it, right, just like we see in this picture, right? So when a transaction is initiated by smart account on Stacknet, right, the transaction is expected to be validated, right? And if the transaction is valid. If it is valid, right. The account is expected to pay gas fees for the transaction, but if it is invalid, the transaction is basically rejected. So basically every valid transaction, right, whether the transaction is reverted, once the transaction is a valid transaction, it's expected to pay gas fees, right, to the sequencer. So basically if the transaction is valid and it pays gas fees, then it passes through the execute function, right? Execute function, basically is that single entry point that is responsible for executing those transactions. As we'll see when we get into building, when we get into practicalization writers implementing our smart contract. So basically, if the transaction, when it gets to the execution stage, right, it checks if the execution is successful.
00:20:48.162 - 00:21:27.460, Speaker B: So if the execution is successful, the transaction and its output, right. Is added to a batch, but if no, the transaction failure is still added to the batch too, right? So it's expected. Few transactions are to be proven. So basically what the sequencer does is, I think from the sequencer's own part, right, the sequencer face validates the nons of the transaction checks if the nonsense is valid, right. And if the nons is invalid, the transaction is rejected. Or if the nons is valid, right. I think it simulates the validates function, right? And the simulation is expected to check that.
00:21:27.460 - 00:22:33.086, Speaker B: The transaction basically just assesses the required state it is meant to assess, right. And does not call any forbidden system calls, right? So basically if the transaction simulation, if it is valid, right, then the transaction is added to the batch, which after the batch gets cleaned up, it is sent for proving, right. So probably later on, I don't know if we saw this clearly sha, but I'm going to share the slides later on and we could probably take a look at it and probably ask questions if there are any. So we're just going to move on to building, right. Since that's the main focus of the call and we are going to be looking at three major types of accounts, we're going to first implement a simple account. So basically simple accounts just contains, just invalidate and execute function. We're going to implement that, then we're going to be looking at implementing multiple accounts.
00:22:33.086 - 00:23:06.194, Speaker B: So the multicolored example, we're going to be building an account that has multiple capabilities, right. Has the capabilities to batch calls, like get multiple calls into one. Right. And finally, we're going to be working on a multisync account implementation, basically. So multisync, as we all know, is basically wallet that requires more than one signature to execute a transaction. And I added links to the code in the slide. Right.
00:23:06.194 - 00:23:23.686, Speaker B: So you could probably check that out later. All right, proceed. Let's just. I think I'm going to share my screen, figure out how I would do that.
00:23:23.868 - 00:23:25.254, Speaker A: Yeah, sure.
00:23:25.372 - 00:23:26.040, Speaker B: Okay.
00:23:32.350 - 00:23:50.500, Speaker A: So, Darlington, would people need any setup right now to do this workshop live with you, or is this something where you are going to do a code walkthrough and people can try with the set up and things later?
00:23:51.830 - 00:24:22.220, Speaker B: Yeah, so basically we are going to do a hands on session simple account. And because we just have less than 30 minutes remaining, we'll probably do a code walkthrough for the multicolored and the multisig. But basically anyone who wants to follow Truica and we just need to install scab. I think Scab would be all. Just install and set up scab and you'll be able to write. Yeah, sorry. To share my screen.
00:24:22.220 - 00:24:27.294, Speaker B: I want to share my screen now. Do I need to stop sharing slides in order to do that?
00:24:27.492 - 00:24:40.340, Speaker A: Yes, that's how. So meanwhile, I can just remove your screen share from the screen, and you can stop sharing this and share the other one and I'll add it back.
00:24:41.510 - 00:24:42.500, Speaker B: All right.
00:24:43.350 - 00:24:58.760, Speaker A: For those of you who are going to do this workshop right now, like live and hands on, if you want to set up scarb, let me share the link with you and you can just get that going.
00:25:02.410 - 00:25:07.100, Speaker B: Yeah, I think I'm trying to share my screen now. Could you probably add it to.
00:25:07.470 - 00:25:14.380, Speaker A: Yeah, I can add it to. Let's see, is it this one?
00:25:14.990 - 00:25:21.280, Speaker B: Yeah, I think that's it. We can see my screen now, right?
00:25:23.410 - 00:25:29.934, Speaker A: Yes. Do you have a folder open with like a bunch of other folders?
00:25:29.982 - 00:25:46.710, Speaker B: Yeah, exactly. Let's just create a new folder. Let's call this account workshop. So I'm just going to open this in my terminal.
00:25:47.210 - 00:25:49.080, Speaker A: Sure. Going to get.
00:25:54.190 - 00:26:25.966, Speaker B: All right. And I'm just going to initialize a new scab project. So basically for those new to scab, right, you could just head over to. Head over to scab Docs is docs swmanshion.com. Right. And you could find whatever version is compatible with your system for installation here. And for the documentation, I think Scab has a pretty good documentation.
00:26:25.966 - 00:26:55.114, Speaker B: So you could just check out the scab documentation for whatever command. So for example, creating a new package, working on an existing package. Right. So we're not going to walk through the process of installing scarves since that's not what the workshop is directed towards. But it shouldn't take you a lot of time to do this. Very simple to do. So we're going to start with implementing a new, pretty new scalp project, right.
00:26:55.114 - 00:27:23.800, Speaker B: So let's just call this car new account. Right. And I'm going to move into the account package. Wait to open this in my. Yes, right. Hanging a little bit. All right.
00:27:23.800 - 00:28:01.890, Speaker B: Sorry, my system is pretty slow. I haven't shut it down in a very long while. It's all right. So we're just going to create a new file here and we're going to call this, let's call this account. So coming to delete. I'm just going to remove all this. Let's just add the account module here.
00:28:01.890 - 00:28:28.620, Speaker B: Right. To get started, right. Implementing our account contract, we're going to need to import some methods from the core library. Right. Probably need to use, I think we need to use start with this. Right. Okay.
00:28:28.620 - 00:28:47.360, Speaker B: Then we're going to need the retreat. Sorry. Right.
00:28:47.730 - 00:28:58.740, Speaker A: Tell a little bit about the third package for those of them who might not be familiar with serializing and serializing data.
00:28:59.830 - 00:29:33.760, Speaker B: Okay. So basically from my understanding of what the serializing and deserializing does, right, it basically changes because we're going to be using it for our custom structs, right. It can help you serialize your structure. Type your custom structure into an array, serialize it back into the structure, right. Because without this we're going to be running into some errors with the compiler. Right. You could just check on that.
00:29:33.760 - 00:30:33.202, Speaker B: Okay, so if you head into this is exactly where we are importing our methods from, right, the Cairo colib, right. Just head into there and you definitely find a lot of helpful libraries methods that you could probably use. So for example, deserialize is we are importing the treats, right, from this particular file. Like I said earlier, I think the serialize would help you serialize a custom data type, right. Like for example chopped into an array, serialize does just the exact opposite. So we also get to import the contract address type, right. This contract address enables us have access to the contract address data type, right.
00:30:33.202 - 00:31:04.250, Speaker B: Then we import the AR retreat. So the ARi treat is imported from the arifile. You can see the arifile here and importing the ARi treats would give us access to these methods contained in the streets, right. Such as the appends, the pop front, the gates, the Atlanta, and many more. Right. So first of all, we're going to create a custom structure, right, called call. And the two is going to be of type contract address.
00:31:04.250 - 00:31:36.338, Speaker B: Because it's going to be an address. Then we're going to have the selector should point to the function which you want to call in the target contract address. Right. It's going to be of type field 252. And we're going to have a call data. So the call data is going to be an array of fields, right. So we're just going to derive some treats for our custom struct.
00:31:36.338 - 00:32:00.714, Speaker B: We're going to derive the serialize. The serialize and we're going to derive the truck treats. Right. So next up, we're going to start with creating our account contract. So as probably know, if you are working on the mall contract, right. You would use the contract macro for an account contract. Basically we normally use the account contract macro.
00:32:00.714 - 00:32:21.926, Speaker B: So we're going to call this account contract, right. And we're going to specify module, right. Let's call this module account. And inside here, we're still going to import some things. We'll still be using module. Like, we're going to be needing the contract address data type. Sorry.
00:32:21.926 - 00:32:48.654, Speaker B: We're going to be using the get call address. The get call address method, right. We're going to be using, I think, the get transaction info method. We're going to be using the. What else? I think we're going to be using here. The call contracts is call. Okay.
00:32:48.654 - 00:33:22.070, Speaker B: We're going to need the arrete also. Sorry, retreat. We're still going to be needing the span treats, too. All right. The span treat. And we're going to need the. Can't think of anything for now.
00:33:22.070 - 00:33:45.022, Speaker B: Okay. We would need to import our call since it's outside our module. Right. So using this power, we're going to import our call struct. Then we are going to go forward, first of all, to defining our storage variables. And in our storage variable, we want to basically just store the public key of this account. So this is going to be field 252.
00:33:45.022 - 00:34:28.240, Speaker B: Right. The first thing we're going to be working on is our constructor. Right? So basically constructor is a function which is called and used to initialize certain storage variables, right. On deployment. So this is going to be the constructor basically is going to take a public key, public key argument, right. And we are going to initialize this public key, which is in the story, that's a public key for the account, on the account deployment. So basically we are just going to call the public key, we'll call the read method on the Public, sorry, the write method on the public key.
00:34:28.240 - 00:35:15.506, Speaker B: And I'm going to pass in our public key. Right. Let's just simply return and next up we are going to be needing our first external function. Okay, just use this using all this. Okay, so this function we're going to call the validates declare validates declare. So the validates declare function basically is going to take in the class hash, the class hash of our account, right, which is of type fail 252. I'm going to return valid invalid.
00:35:15.506 - 00:36:12.046, Speaker B: And it's going to return an error otherwise. So basically this validate declare validates your accounts declaration, right. Let's just pass the logic for this validate declare into an internal function validate transaction, since we are going to be calling this function in multiple places, right. So I'm just going to come down, right, and I'm going to implement the validate transaction function. Now, the validate transaction function basically is going to validate the signature of our account, right? So the first thing we probably want to do is let's just get our public key stored somewhere. So let's call this instead public key. Right.
00:36:12.046 - 00:36:50.758, Speaker B: And the public key is going to be called to public key reach, right. And we're going to get our transaction info by calling the get transaction info method, right. And I think this returns Bookstreet. So we're going to need to unbox it and to have access to this method, right. You probably have to import from box. We're going to need to import the box treat, right. So what else do we need to do? Let's get our signature, let's get our signature.
00:36:50.758 - 00:37:44.134, Speaker B: So we could get it from transactioninfo signature, right? And we want to check that the signature lens is valid, right. It contains both the r and s component. So we're going to assert that signature lens, right. We're going to assert that signature lens is equal to two, contains the component. We're going to throw an error that says invalid signature, invalid signature. Okay then next up we are going to validate the signature, right? So we're going to import from ECTA. We are going to be importing the, I think this is called check EDSA signature and just confirm.
00:37:44.134 - 00:38:31.290, Speaker B: So going to the Colib and into the Source Folder from the ECTA file, the check EDSA signature, right. So we're going to be importing the Check EDSA signature. Okay? And basically we're going to call that method and it takes in some certain things. So the first thing it takes in is, the first thing it takes in is a message hash. It takes in a public key. It takes in the array component of the signature and the s component of the signature. So we are going to come in here and for the message hash we are simply going to query the transaction info for its transaction hash.
00:38:31.290 - 00:39:35.502, Speaker B: Transaction hash. And for the public key we'll simply use the public key we got earlier, right. As the public key of the account. We are going to need signature r right now, for signature r we're going to need to dismp, I'm going to explain why we are using the asterisk sign. So basically we want to get the fourth element as zero utet to write at zero index. So the reason why we are using the disnap function, right, is, if I remember correctly, signature basically Span is snapshots of an array. So basically in order to get the elements, the signature zero Utah for signature r, right, we need to desnap the elements we would get out of it, right.
00:39:35.502 - 00:40:17.150, Speaker B: Since it's snapshots, we need to despite it in order to get the main signature, right. So for signature s, we also need to snap the elements at position one. And I think that would be about it. So I want to check this and if it is not valid, right, we want to return Invalid signature. Just differentiate boot error. Let's call this invalid signature length, since the length is basically what we're checking. So in here we're going to just call, we're just going to return an Invalid signature.
00:40:17.150 - 00:41:02.954, Speaker B: And so in the case of the transaction being valid, right, we want to return validated to think that we need to import that here. So just use net validated. And if you check out what the validated returns, right, let's go into think that should be in here. Sorry, down here. So basically the validated is a constant which returns a field 250. So that's a short string valid, right. So basically we want to return the short string validated if our transaction is valid, the short string valid, right.
00:41:02.954 - 00:41:30.100, Speaker B: And that means we need to return our validate transaction function. We need to return if else 252. All right, I think that works. So we're now going to move forward to implementing, just use this.
00:41:32.810 - 00:42:12.260, Speaker A: Sorry to interrupt you. What I wanted to maybe shed some light on is before we move to the next function, could you just shed some light on what is the use case of this contract? Like what does an account contract do? What does a simple account contract do? And what is the structure? For example, when we create an account contract, what are we doing? And these different functions that you're writing, what are these functions supposed to do as part of the account contract? So if you can quickly shed some light on that.
00:42:13.670 - 00:44:00.100, Speaker B: All right, sure, no problem. So basically, like we explained earlier, right, we are implementing a very simple version of abstracted account on Stacknet, right? So basically this account is supposed to, I don't have an interface implemented, right? But basically this account is supposed to have two major functions, like we explained earlier, right? An account implemented on Staffnet is expected to have two major functions, that's the validate function and the execute function. So basically the validate function checks that the signature is valid, right? That the transaction was originated from the account by the account owner, right? So basically the validates function checks the account checks the signature, right? If it is valid, the account is expected to pay gas fees, gas fees for the transaction. So after the account pays gas fees for the transaction, it goes further to an execute function, which we are going to be implementing later. So what the execute function does, basically the execute function is the entry point that executes the transaction, right? So it calls the target contract. What I'm going to do to make things easier to explain is I'm going to write the function bodies out, right, without the logic inside to make it look more like an interface, right? So we could basically explain what the functions do before we move on to implementing the logic. Would that be okay?
00:44:00.650 - 00:45:12.298, Speaker A: Yes, that would be perfect. And for those of you who are trying to understand terminologies like declare, and if you're new to Cairo contracts, then just the workflow for Cairo contracts is that you have to first declare a contract, and that gives you something called as a class hash. So every contract before you deploy, you'll have to declare it, because that is something like telling the blockchain that this is the contract that I'm going to, this is the class hash that I'm going to deploy. That's why you see a function called validate declare. That means when you declare, you use an account that you will use to declare that contract, right? So you need that account to actually verify validate whether that particular declare is correct or not. So that's why you can see that validate declare, and then all the other different transactions that you mentioned, there's validate transaction, there's execute, which is executing the transaction and things like that. So just to give you an understanding of how Cairo contracts work.
00:45:12.298 - 00:45:21.150, Speaker A: First you have to declare the contract. You will get a class hash. Then you have to use that class hash to deploy the contract. Yeah, please go ahead.
00:45:21.300 - 00:46:40.020, Speaker B: This is good, right? So I'm just writing out the function. Body writes without go ahead to implement the logic. So this takes in the contract address entry point, the code BZP, which is going to be an array of field 252. Then last function we're going to be implementing, right, is always implementing the execute entry point. And the execute is, I think, going to just, we're just going to pass in this, we're going to pass in the call. It's going to be an array, array of, sorry, call, and it's going to return a span of span. All right, so basically these are the four major functions we are going to be implementing, right? The first is the validate declare, which I explained earlier, validates.
00:46:40.020 - 00:47:10.428, Speaker B: This function, I think is called on when you're trying to deploy the accounts, right. This one validates the declare function for your account. Then we have the validate deploy, which validates the deploy function when you are deploying your accounts, right. Then the two major functions I want us to concentrate on are the validate and the execute function. So like I explained earlier, the validate basically takes in for each call, that is each transaction, right. I'm going to be using transaction and calls interchangeably. Right.
00:47:10.428 - 00:47:51.516, Speaker B: For each transaction that the user wants to carry out, right. The validate function basically takes in the contract address, takes in the entry point selector and the call data. These are the tree. Check out the tree major fields in our call structure, right. And it is going to check, it's going to check that the signature for this particular transaction is valid. Signature is valid means that we're trying to check that the transaction was originated by a valid account, by the valid account owner. Right? So we're going to check that the signature is valid in this validate function.
00:47:51.516 - 00:48:56.800, Speaker B: Finally, the execute function is what carries out the execution logic. So basically in the execute function we can do a whole lot of things. I think in here we can carry out functions like writing the logic for executing a multicol. For example, as you can see inside here, the arguments I supplied here, we supply equals arguments, right. Rather than just taking a contract address, entry point selector call data. So the whole idea was, although we are not going to probably, we may have enough time to implement multicolored, right? But in the case you want to implement multicolored, we'll go to a multicolored account contract, which I already implemented, right? You can simply swap out the logic we have in here and look through the calls, aggregating them before calling the call contract syscall. So in here, basically what we do is we take the call and if it is a single call, we are going to just take out that single call and pass it on to the call contract system.
00:48:56.800 - 00:49:33.544, Speaker B: But if it's multiple calls, right, we are probably going to run like loop with a match statement, right? And try to aggregate these calls. And finally, before calling the call contracts call. So that's exactly what these functions do. So the validate deploy function basically is just still going to call the internal validate transaction function, which we already implemented, right. Then we're going to have the validate function which is still going to do the same thing. We're going to call the validate transaction function, right. We're simply just checking that these transactions are valid.
00:49:33.544 - 00:50:36.270, Speaker B: But things begin to get interesting in the execute function. So this execute function is where we're going to write some interesting codes, right? So first of all, I would want us to get, so the first thing I would want us to get all the things I think we need, right. Let's get the transaction info, right. Let's get the transaction info using the get transaction info. And we're going to unbox this louise, this. And next one, I would want us to check the transaction version, right, to ensure the transaction version is valid. So to do that, we're going to say, let's just say let transaction version, right be equal to transactioninfo version, right? And we're going to assert that the transaction version is not equal to zero.
00:50:36.270 - 00:51:55.208, Speaker B: We're going to have issues in my Carolina server again, okay? So if it is equal to zero, want to show an error that says invalid transaction version, right? Invalid transaction version. Okay, something I want us to check again is I want to check that the caller is a zero address, right? Unless we want to assume that it's probably faulty and true. Invalid caller error, right? So we're just going to get, let caller be equal to the get call address, right? And we want to check, right, that the caller is from the zero address. If. No, I'm going to just throw an invalid call, all right, I'm going to come here and use the variable which enables the zero to be available for use, right. The zero mod method to be available for use. So we're checking the caller is zero and we're going to throw an invalid caller if it is not, right.
00:51:55.208 - 00:53:03.836, Speaker B: Having done all this, we can now go ahead and we're going to get our call from this. So the first thing I want us to do, right, is because like I said earlier, we're not building a multicolored contract. We're just simply going to check that calls contain just one call contain just one element, right? And if not, we're going to see multicol, multicol not supported to avoid bugs. Right. Then over here we're going to deserialize our call. We're going to come here and we're going to say two selector and the call data, right? And we're going to say that should be called to call front and we are going to unwrap whatever we get. Okay, so to use the unwrap method, to make the unwrap method available, probably we need to import option treats.
00:53:03.836 - 00:53:42.110, Speaker B: The option treats, right? Yeah, the option treats coming over here. We're going to go ahead to write. Next we're going to call, use the call contract syscall. Is that imported? Yeah, we already imported that. Right. So the call contract syscall, basically we're going to pass, it takes in an address would be two. It takes in an entry point selector, right.
00:53:42.110 - 00:54:21.992, Speaker B: I think entry entry point, remember, I think it's the other way around. Entry point selector, which is going to be the selector. And finally it's going to take in the call data. Now the call data, we're going to change it to span. And basically whatever we get from here, right, we want to unwrap syscol using unwrap syscall method on it because there's no comma semicolon. Right. We'll probably return whatever we get.
00:54:21.992 - 00:54:54.484, Speaker B: And just to ensure we get the route put, we're going to use this, the route put macro. All right. So basically let's check if this compiles before we go ahead to take questions because they're running out of time. Just going to go in there and run scabbard drive. Okay, we have a few errors. So the first is type not found calls. Yes, that's an error on my end.
00:54:54.484 - 00:55:08.790, Speaker B: So we're going to come here and this is supposed to be call not calls, right. And the second arrow says the two identifier is not found. Okay. The two identifier is not found selector is not found.
00:55:12.860 - 00:55:18.350, Speaker A: I think to import it from use or something.
00:55:21.120 - 00:55:59.892, Speaker B: I don't get. Let me change this to entry point select. Let me try this again. Yes, I think that was where there was some. So basically that, yes, so basically that's an implementation of a simple contract on Stacknet. Right? So just to go by what we did again, right. We imported some certain methods, right, to create a call struct.
00:55:59.892 - 00:56:45.850, Speaker B: And like I said earlier, this can be optional. Now we could probably just pass in if we want, because our account doesn't implement in multicode, right. We could just go ahead instead of what we did here, right, we could just pass in the contract address, the entry point selector and the call data directly, right, and just pass that directly into the call contracts call. But we did this because doing this this way, right. Makes it easier to probably swap our logic for a multicolored logic. Now let's look at how we could implement a multicolored logic. So because of time, we'll probably not write the code from scratch, right, but I'm just going to go into an implementation I made, right, which you could probably check out later, and we are going to just explain the codes, right.
00:56:45.850 - 00:57:46.504, Speaker B: If you go into the multicolored section of this repo, you could see here that this is exactly same codes, right, as what we have in our simple account, right, but where the difference is, as you can see here, when we got here, rather than just making a simple call to the call contract, we pass our execution, our logic, right, into an internal function called execute multicolored. And let's see what this execute Multicolored function does. So if you come down here, you can see the execute multicolored internal functions, or contains the multicolored logic, right. What we basically do is basically we specify a result, right? This is an MTRA. We're going to populate this with the result of our calls. Then we go forward to make our calls arguments, right. The calls we are getting, right.
00:57:46.504 - 00:58:24.004, Speaker B: We go forward to make it immutable value, because we want to do some manipulations on it, right? So we go ahead and make it a mutable value. Then we loop through it, right. We loop through the calls value. And while we loop, right, we pop an element. So basically what the pop front method does, right, when you call a pop front on an array, it removes the first element from that array. So what we are basically doing here is we are removing the first element from the calls array. And when we remove the first element, we want to check that our first element indeed contains some call.
00:58:24.004 - 00:59:03.408, Speaker B: And if it does contain some call, we are going to make a call to the call contract syscall. And as you can see here, even within the call contract syscall, we still use image expression, right, to check results, okay? Right. Checks if the return data doesn't throw an error. So if it doesn't show an error, right. All we simply do is we get the result and we append the return data, right, to that result array, which we created earlier. So the empty results array we created earlier, we're going to add to the append, unlike the pop front, where the pop front removes the append, adds a new element to immutable array. Right.
00:59:03.408 - 00:59:37.176, Speaker B: So we are going to append the return data to the result. Like I said, we're going to be populating this result with the return data from our function, right. But if you choose an error, right, we're going to simply panic. We're going to simply panic. So the panic, we chose to just choose the panic saying multicolored field, right. And we continue. So once there's always called, right, so this option, none will not be called till we get to the last element of the array.
00:59:37.176 - 01:00:20.132, Speaker B: So once we pop out the last element of the array, right, there will be no element anymore in the calls array. So we are going to once the non basically is what detects that there's no element anymore in the calls array and automatically breaks the loop. And as you can see here, we then return the results with our populated by now the results has been populated with the return data from our calls, right. So we just simply return the results. And what we can see here, you don't necessarily need to know this by heart, right. This is just a temporary fixed table. Probably the span serialized serialize is added to the colib.
01:00:20.132 - 01:00:49.936, Speaker B: So you probably just copy and paste this. You don't need to exactly understand what's going on there, since we don't have enough time to explain that. So there's also a multi Sig implementation. There's a multi Sig implementation. So as you can see here, as always, we start with specifying the account contract module, right? There is a sign module to the account contract macro. Then we sign module called multisig. We go ahead to import some certain libraries we are going to use for the contract.
01:00:49.936 - 01:01:34.352, Speaker B: And just like we did earlier, we're going to create a call struct. And as you can see here, the multi sig is a bit more complicated than both the normal and the multicolored contract. So as you can see, we have some certain storage variables. We have the num owners, we have the threshold, we have the previous transaction, the ownership. So the num owners, as you summarize, the Num owners basically save the number of owners in the multisync. The threshold is the number of owners that must approve a transaction, that must confirm a transaction before it can be executed. Then the previous transaction basically stores the idea of the last transaction that was submitted to the multisig.
01:01:34.352 - 01:02:05.392, Speaker B: Then we have the ownership. The ownership basically tracks the ownership of the multisig. So as you can see here, it's just a legacy map of the contract address of the owner to the bowl. So we have another storage variable, which is a mapping of the owner's address to his public key. Then we have transaction info. So the transaction info is basically what tracks each transaction, right. It's a mapping of the transaction id to the call structure.
01:02:05.392 - 01:02:38.884, Speaker B: The call structure, as you can see here, contains certain information about the call. For example, the two is the target contract address. The selector is the target function, right. The call data is the call data being passed in. Then we added two new stuff. We added confirmations, which returns the number of confirmations that have been confirmed for that particular transaction. And we added executed, which is a boolean value that returns whether or not a transaction has been executed.
01:02:38.884 - 01:03:02.712, Speaker B: So as you can see here, we have some certain events that emitted. So submitted transaction is emitted. This time, a new transaction is submitted. We have confirmed transaction which is emitted each time a transaction is confirmed. And we have executed transaction which is emitted each time a transaction is executed. In all the cases, what we just emit is the owner. That's the contract address of whosoever made the call to that transaction.
01:03:02.712 - 01:03:33.956, Speaker B: And the transaction index, that's the id of the transaction being operated on. Then in our constructor, we do something very basic, right? So we take in an array of owners. So the array of owners is the array of the multi Sig owners. And the threshold. Threshold is the number of persons who would want to confirm a transaction before it is executed. Right? And then we check that the multi sig has a minimum of two owners. So we do not want multi sig basically supposed to have multiple owners.
01:03:33.956 - 01:04:13.508, Speaker B: So we can't have a multi sig with just one owner. So I want to check that the multi sig has a minimum of two owners. Then we go ahead to check that the threshold is less than or equal to number of owners, because it only makes sense. For example, I have a multisig of four owners and I want to make sure that my threshold should be three. Because it doesn't make sense that I have emotion of four owners and I'm having basically a threshold of five. We would not be able to have a value transaction in that case, because you can't have five persons approving a transaction when they are just four owners. Right? So next up, we store the number of owners, right? In case to be available.
01:04:13.508 - 01:04:37.736, Speaker B: In case anybody wants to make a call to it. Then we store our threshold. And finally we dedicate the logic to an internal function called setunas. Let's just go down to see what our setunas does. So, the set owners, so this is set on us. Internal function. Basically it's a function that sets the multi sig owners on deployment.
01:04:37.736 - 01:05:09.924, Speaker B: So basically we get the multisig owners, we get the array into immutable variable. Because once perform some operations on it, right? Then we loop through it. And each time we pop an owner. When we pop an owner, if there's an owner, using the option sum, right? If there's an owner, we simply write it to the storage variable. And when there's no, just simply break the set owners basically is what adds the owners to the mapping. The mapping we have here as the ownership mapping. All right, so next up we have the get confirmation.
01:05:09.924 - 01:05:58.548, Speaker B: So the get confirmations basically returns the number of confirmations for any transaction index to supply. So if we want to check how many persons has confirmed a transaction, we can simply call the get confirmations. With the transaction index. We have the get num owners, right? Which basically returns the number of owners in our multi seed. Then get owner key can be used to get return the public key of any owner in our multistage, right? Then there's a function to set a public key. So this is the compulsory function, something that must be done for every owner in the multistage, right? Then the first interesting function I want us to look at is submit transaction. So basically, what does submit transaction do? So it takes in the contract address, the entry point selector and the call data for that particular transaction.
01:05:58.548 - 01:06:43.140, Speaker B: And as you can see, we get the call address. And the first thing we want to check is that we want to check that whosoever that is calling this function, right, is a valid owner, is a member of the multisig. So that's an internal function, it's owner. So you can see here, it checks the ownership value of that particular address. So if it's true, then we can proceed. If it is a false value, then we assume that that user is not a member of the multi sig. So next up, I think the second thing we check, we do check, is whether the user set the public key, like I said, is a composite function for every user on a multi sig, right? So this is the internal function that handles that to just simply check if an owner set his public key, if it returns, is zero.
01:06:43.140 - 01:07:12.124, Speaker B: Then if it returns to zero, then we assume that the owner doesn't set his public key and we ask him to set his public key first. Right. So next up we proceed to creating our call. So we populate our call shops with the two, the selector and the rest. Right, so we create the call using whatever we got from here, right. And finally we're going to get the previous transaction id. We're going to get the previous transaction id and create our new transaction id.
01:07:12.124 - 01:07:43.460, Speaker B: So our previous transaction id is stored in the previous transaction story variable. So when we read that we're going to add one to each and it will become our new transaction id. Right. Then we come here and we're going to store call in transaction info. So basically I'm going to create, remember, the transaction info is what tracks the transaction id and the call information, the content of the transaction which is stored in the call. Right. So I'm going to write that through this transaction info mapping.
01:07:43.460 - 01:08:18.484, Speaker B: And finally we are going to update our previous transaction to a new transaction id, as you can see here. And once we do that, we are going to emit the submitted transaction, which is an event that is supposed to be emitted. If a transaction is submitted with the caller and the transaction id, then we have the confirmed transaction. The confirmed transaction function basically takes in the transaction index for a transaction. As always, it gets the caller address. It performs some check that the caller is a valid owner, it checks that the transaction exists. It checks that the caller says the public key and he hasn't confirmed before.
01:08:18.484 - 01:08:35.928, Speaker B: And finally, that he hasn't confirmed before. Right. This is a very important function, right. We do not want one person confirming multiple times. That would be a huge loophole in our multi C contract. Right. So we have to implement a check for that.
01:08:35.928 - 01:09:15.316, Speaker B: The next up we get and we deserialize the call. As you can see here, we get the transaction info, we deserialize it into this. Next up we are going to update the number of confirmations by one, right? So if the confirmations currently is zero, right, you want to increase it by one and then update the call. So we're going to create a new call, updated call, a new updated custom data structure. The updated call using the call structure, right. And once we do that, we are going to write the updated call to the transaction info. And finally we are going to confirm that.
01:09:15.316 - 01:09:55.380, Speaker B: We're going to update the has confirmed with the call and the transaction index to true. So you've checked the heart confirmed. Basically the heart confirmed is a legacy mapping of the contract address, which is basically transaction id that this is two pole, right? To the bold value, which should be true or false. So in this case, we update it to let everybody know that this particular owner has confirmed this transaction. Then finally we go ahead to emit confirmed transaction. That's the confirmed transaction event. Then as you can see, the validate declare validate deploys.
01:09:55.380 - 01:10:37.312, Speaker B: These are just functions that we've talked about. Basically, they do not do so much, do not implement a logic so different from what we have previously, right? I think should be the last important function I want us to look at, right, is the execute function. So the execute function is basically what executes function in our multi sig, right? So basically we want to first of all check if transaction exists. As the first thing, once check the transaction exists, right. We go ahead to serialize the call. I'm going to get the call for this particular index when we read the information to get the true selector and call data. Now this is very important.
01:10:37.312 - 01:11:40.768, Speaker B: We want to check that the number of confirmations for these particular transactions is greater than or equal to the threshold. So if the threshold is three out of four, we want to assume that at least three persons had confirmed the transaction. If not, we're going to show an error that says the minimum threshold has not been attained yet. So next up, we are going to make contract call using the low level contractors call, right? As you can see here, we saw this in our simple contract, right? So we're just going to make a call to this, passing the address, the entry point selector and the call data, and finally return the data, right? The next up we are going to want to update our transaction status. So as you can see, we have executed in our transaction status to track if the transaction has been executed or not, right? So in the beginning this is going to be false, right? So we want to update it to two. As you can see here, we're going to update it to two. Then finally we're going to write that new info to our transaction info.
01:11:40.768 - 01:12:32.870, Speaker B: And finally we're going to emit the executed transaction and return whatever was data gotten from executing that transaction. Now, it's worth it to note that this particular multi sig function does not support multicoles. But like I said earlier, if you understand the multicol account implementation, right, we simply just need to swap the logic. Swap this logic, this logic that calls for a single call and simply just run a loop to look through the multiple calls and aggregate them into one. So that should not be very difficult to implement. You could probably try that later in your free time. And I'm very sorry we're rushing through this, right? Just we are very much out.
01:12:32.870 - 01:12:40.490, Speaker B: I don't know if there are any questions before we probably proceed to other things.
01:12:41.500 - 01:13:42.988, Speaker A: There are a few questions on the YouTube live. I'm just going to run them through very fast and we'll try to close it in the next one or two minutes. There is one question by an anonymous user about I think earlier slides that you had shown. Can you describe a bit more about nons and why it may fail? Check? I think this is from the earlier slide so I'm going to skip this and maybe move to the contract related one if we return not validated but something different. For example message will the transaction fail the check? So I don't know if you are able to see this, but I sent you this question on telegram as well. And I also sent you the YouTube live link where you can. So maybe what we can do is just in the interest of time.
01:13:42.988 - 01:13:57.330, Speaker A: Darlington, you have access to this YouTube live link and you have access to all the questions that folks have asked. So maybe you could just answer in the comments. Does that sound good?
01:13:58.980 - 01:14:06.790, Speaker B: Okay, you mean probably after the call, right? I could probably answer. Sure, no problem.
01:14:09.400 - 01:14:56.304, Speaker A: Yeah, because we are already 14 minutes over and I just want to make sure that I respect your time and everyone else's as well. Just on a closing note, thank you so much Darlington for joining us. I know you shared the slides as well, so maybe if you can share the link to the slides if it is open source on the YouTube channel link, I mean over there as a comment that would be helpful. And last but not the least, just like one of our users who commented on the YouTube live, this was a dope session. It was super awesome. We all learned a lot. And for those of you who asked if the recording will be available, yes, it will be available on YouTube as it is being live streamed.
01:14:56.304 - 01:15:39.760, Speaker A: So you can always go back, check out the contracts and once Darlington shares his slides as well, there are GitHub repo links that you can go to. Look at the contracts and feel free to ask questions in the know different groups, whichever groups you are a part of, whether you're part of the Africa group, whether you're part of the India group, whether you're part of the North America group or just the ecosystem group, feel free to ask questions. You can also come back and ask questions on this YouTube channel as well, and we'll hope we can monitor that and get your questions answered. Is there anything that you want to share Darlington? Any other information that you would like to share with folks.
01:15:41.460 - 01:15:51.460, Speaker B: We also time, but I think I promised to share some interesting use cases we've been working on, probably if you still have one or two minutes to spare.
01:15:51.960 - 01:15:56.070, Speaker A: Okay, sure. Yeah, why not?
01:15:58.380 - 01:16:01.210, Speaker B: Could you help me add slides part to the screen?
01:16:02.940 - 01:16:06.250, Speaker A: Yeah, slides, yeah, this one.
01:16:08.140 - 01:17:14.828, Speaker B: Basically the account abstraction use cases, right? So I talked about social recovery rights. I explained how I lost access to my life savings in 2021 just because I had forgotten my teacher. For example, if you're in a social wallet like an account abstraction wallet like agents, right, we have something called social recovery implemented, which enables you to add guardians to your wallet. So basically another wallet, you could add the hardware wallet, you could add friends and family as guardians. And in case you get locked out of your wallet for any reason, you could probably hit up the Guardian. They would help you get access back into your wallet. So we have agent Shield, right, which can help you protect your account with a two factor authentication using an email address, right? Basically giving you that web two UX experience with the ethos of web3, right? And we also have multicolored, which I explained earlier, which you could see in EMMs, NFT marketplaces, like aspect.
01:17:14.828 - 01:18:02.336, Speaker B: And we finally, we are working on sessions, right, together with the influence team, which would enable you carry out, if you play games, right, on blockchains, you know, they can really be very annoying with the whole signing stuffs within games, right. So basically with session keys, you could basically just sign once and just play your game without interruptions, right? And I think that's about it. So basically, the whole idea of account abstraction, right, is combining web3 magic with the web two user experience. And I think that's about it. Thank you so much for the opportunity to be here. And I hope we learned a whole new. So let's just build a new web3 ux together.
01:18:02.336 - 01:18:03.250, Speaker B: Thank you.
01:18:03.940 - 01:18:32.644, Speaker A: Of course. Thank you so much. Thank you, Darlington, for your time. We really appreciate it. And I hope that all of you are able to just watch this workshop again. Look at the contracts, write your own contracts. If you write your own account contracts by following this workshop, and you're able to successfully deploy it, build it, and deploy it, please tag Darlington and Starknet on Twitter.
01:18:32.644 - 01:18:47.912, Speaker A: Please take a screenshot and tag us and we'll be happy to retweet your successful deployment contracts. And thank you so much once again, Darlington. I hope to see all of you at our next community call workshop call. Thank you everyone. See you.
01:18:47.966 - 01:18:49.710, Speaker B: Yeah, thanks so much. Like.
