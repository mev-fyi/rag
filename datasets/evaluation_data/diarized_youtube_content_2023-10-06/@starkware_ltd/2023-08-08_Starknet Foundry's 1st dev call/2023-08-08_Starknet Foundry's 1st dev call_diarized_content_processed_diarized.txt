00:00:01.290 - 00:01:21.910, Speaker A: I guess we'll start. So just briefly, I guess to introduce, I'm Alex, I work at Starkware in case we haven't met. And I'm on the product side of the developer tools. And Max here is leading the effort of stagnant foundry from a software. And basically what we want to go over today is introduce a bit the architecture of the project, what is currently possible, what is currently being worked on and what are the plans for the near future. Then hopefully to go over again structure and what is the best way to help, and hopefully then have some discussions on ideas you have, how to get involved, et cetera. So I think here I'll leave the stage to Max.
00:01:22.810 - 00:02:01.490, Speaker B: Okay. Hi everybody, nice to see you. I'm Maximilian and I'm currently leading the effort of Starfish Foundry. And I'm from source formation and I want to first start with briefly introducing Starnet Foundry to you in case somebody is not familiar with bits. Until now, I believe everybody are familiar, so I will keep it brief. So generally, Starknet Foundry. The goal of Starnet Foundry is to bring the foundry quality and speed to starknet and to bring all contract development capabilities of Ethereum foundry to Startnet.
00:02:01.490 - 00:02:41.840, Speaker B: So basically it's a contract development tool chain. So right now what it does, it's Ethereum counterpart, it's like modular toolkit. So it right now consists only of two modules. Maybe in the future there will be more of them. First one is forge is the main one. And this one can be considered a testing tool for Keira contracts and for Keira itself as well. And its main purpose is just, you can test your contracts and it introduces different utilities to help you do that.
00:02:41.840 - 00:03:20.490, Speaker B: And the second module or subtool is cast. And cast is kind of DevOps tool for Startnet. So it's basically a CLI. You can deploy your, if you finish your contract, you can deploy those contracts on Testnet or Mynet. And this is it. And those two are right now marine focus of the development effort. Yeah, and right now I believe we try to maintain roadmap of the features because the product is under active development.
00:03:20.490 - 00:04:14.750, Speaker B: As it started, like it was released, initially released I believe two weeks ago. It is still a lot of things happening. And yeah, first of course it allows you to run tests written in Karao. And aside of testing kyo fancies, you can also test contract interactions. So you can deploy your contracts and call them also cast supports, I think all of the important interactions we started, and also supports multicols with a nice interface. And important to note, it's an improvement over traditional foundry if somebody is coming from the Ethereum background, because mind foundry uses sub modules and we have it better here and we are using Scarp for package management. So it's actually pretty neat.
00:04:14.750 - 00:04:48.300, Speaker B: I won't go over it right now, but if you are interested in those things and how those work and you want to get started working with this tool, we maintain start with Foundry book, which provides introduction to every feature that we support currently. So I think it's the best resource to learn Starklift Foundry. Yeah, and I think this is the main introduction of the project. Does anybody have any questions at the moment?
00:04:53.150 - 00:05:27.720, Speaker C: Hello Maximilian. I would just like something quickly about. I talked about with Alex and Jonathan about SNcast, just about the redundancy with stockly. There is any projection on that because for instance, when I checked the repo for the first time, I was trying to see where I can collaborate and I just see that how this will go because I can understand that perhaps SNCast will have other features or differently implemented. So what the plan for that? Just to be aligned with the project?
00:05:28.250 - 00:06:15.534, Speaker B: Yeah, of course. I think at this moment there are some overlaps over starting cast. Okay, so right now cast is how we say we, and Alex as well is cast will be more focused for developer utilities. So it will provide very good support for deployment of your contracts or, I don't know. For example, right now we're starting working on something like deployment scripts in Cairo, so you can embed complex flowbooks of deployments and stuff like that. And this will more focus of the cast as well. It's kind of heavily integrated with scar.
00:06:15.534 - 00:06:46.000, Speaker B: So basically you have to work with cast effectively. It generally needs to have whole projects set up and it works well and it's designed to work well in context of a project you have already. And we see Starc as a bidding, being a bit more of a lightweight startnet client for people who just want to, for example, read Starknet or just use it. But there can be developers, but not only those, we are targeting developers more. That's the goal here.
00:06:47.090 - 00:06:50.846, Speaker C: That's pretty clear. Thank you very much. That's nice explanation. Thank you.
00:06:51.028 - 00:08:01.240, Speaker B: Great. Okay, anybody else has any questions, I'm happy to answer any doubts or concerns or, I don't know, explain something, go to go deeper into something, if somebody's interested. Okay, so I think we can right now, after we got over what the project is, I would like to keep this call more focused on how you can help, because this is the most important part, because we believe Starknet Foundry is a project that we want to get community involved. It's very ambitious, it's large, and I think we bootstrap the effort in star formation, but we really hope that people in Starknet community will get involved into that and we can build this tool together. So we really want to work on it and develop a good framework to work with external developers as well. And there are a couple of ideas. I will be very open to your ideas, how we can improve on that.
00:08:01.240 - 00:08:43.550, Speaker B: And also I would like to also give you some introduction to the project structure and how you can start right now. So yeah, I think first, as I said, we are really open to onboarding several contributors and we try to. The best way to start. So for people want to quick info, best way to start is to just select some issue labeled with issue. We have a solid list of those. I think those are already like close to 20. And we try to mark issues like that if they're good for new developers.
00:08:43.550 - 00:09:32.754, Speaker B: So basically, if you just want to start working on start with foundry, you can just select one of these issues. You can write in the description that you like the work at home and you want to work on it. And the best way to proceed further is get touch with us so we know you're working on it and we can keep in contact and help you if you get any roadblocks on your way. So this is how I would encourage to start because even though project is new, it's already got pretty big and there are a lot of complex stuff there. So it's the best way to learn. Yeah, and generally going a bit deeper. There are two modules, but technically we written started following this way.
00:09:32.754 - 00:10:16.850, Speaker B: It's like proper rust like modular project. So it consists of different modules. If you go to over the crates, there are multiple separated parts of the application. So there is a test collector which is responsible for collecting tests. As Navy says, it's forge, which is responsible for running your tests. It's cheatable startnet, which is kind of backend execution engine, which is used by forge to exit your contracts. If you call your contracts from tests.
00:10:16.850 - 00:10:44.760, Speaker B: And this is cast, which is CLI. Yeah, and we generally try to mark our issues with those components so you can kind of know which component you will catch when you're working on the issue. Sometimes there are two of them, but generally we try to keep it like issue per component so those are not overlapping too much. Okay, does anybody have any questions here?
00:10:49.530 - 00:10:53.630, Speaker A: What the difference between Forge and the test collector?
00:10:54.370 - 00:11:15.580, Speaker B: Test collector is very small crate. It's basically responsible only for finding tests and compiling them. And forge is responsible for executing compiled code, but those are pretty tightly coupled with each other. Anybody else has any questions?
00:11:19.950 - 00:11:38.466, Speaker C: Okay, sorry. Yes, just a quick one. I am reading a bit the code too, but cheat codes, can you just explain a bit more what exactly the philosophy about them? Because I know a bit ethereum but not a lot. And I see also this vocabulary but can you just give a little introduction to that?
00:11:38.568 - 00:12:59.180, Speaker B: Of course. I think it's pretty new feature to the startup foundry just yesterday, so it's still not check marked on the roadmap and it's also still work in progress because we are adding them progressively. But generate cheat codes are functionality which allows you to provide preset states which you can test your contract on. So for example you can kind of mock some situations on chain without writing special code for that. So example of this is for example prank is good, I believe it's basically what it does when you call start prank from a test, you give it a contract address you want to target and you give it a value of color address. And what it does for the contract you targeted here it will modify like mock the value is returned by the contract you primed. So basically, so basically get color address, will write here, it will return a different value you provide here.
00:12:59.180 - 00:13:18.530, Speaker B: So here you say like hit after it passes because it just mocks this value. And for example useful for testing some kind of this contract will reject something this contract will reject something in case the caller want to be an owner.
00:13:21.990 - 00:13:39.690, Speaker C: Under the hood, where do you connect that? Because the test runner for instance that is run under it is like you modify the test runner to be able to alterate the tonic state which is inside or what the strategy for the execution of this on the test runner.
00:13:40.430 - 00:15:16.220, Speaker B: It'S getting a bit deeper and technical part, but generally how it works is test runner is somewhat an instance of Cairo VM, like forge itself. It's like instance of Cairo VM people were running only Cairo codes, not exactly a starnet code, but it's likenet code. But basically you don't run it on chain context, you just run test function and we expose set of library functions like we expose like Starknet Foundry library which you can like this start prank is like part of this library and you can call this and under the hood I'll go back here it basically what it does, if you are familiar, I don't know if you know how you're new to the Kyo or not, but the old carrier was concept of hints. Hints is way you can embed it, not cable logic, into carrier. Yeah. And those are utilized to do so. So carrier VM, this carrier VM holds some startlit state and those hints are used to call this state and execute actions on them.
00:15:17.710 - 00:15:19.980, Speaker C: Okay, thank you.
00:15:22.270 - 00:15:25.900, Speaker B: Okay, does anybody else have any questions?
00:15:28.050 - 00:15:49.010, Speaker A: Maybe for later when we have time. But I think it would be interesting to go over how to implement a cheat code. So take an example and go over the components in the code that needs to be modified for a new cheat code to be added.
00:15:49.910 - 00:16:26.510, Speaker B: Okay. Actually it would be interesting if we'll have time to get drilled into the code. I think it's like showing how those existing implemented I think will be interesting. But sometimes it goes a bit like we are still working with abstract is better. So sometimes it's a bit low level in some places. But generally yes, I think we can go over that maybe from perspective of organization. I think if somebody wants to get involved on regular basis, we're involved on regular basis and work on some things.
00:16:26.510 - 00:17:10.960, Speaker B: I think we can make this community call a regular thing. So you can, for example, some specific questions to think you are working on, you can join in and we can discuss this bit more specifically. Yeah, I think we'll be doing something like this. I think there are not many of us today, so I think it will be a good place to just discuss stuff and it's enough small group so we can go into the details and explain things. Okay, so does anybody else have any questions? Or we right now can go and maybe I can just show you how for example stir Frank is implemented, which might be interesting.
00:17:16.000 - 00:17:37.750, Speaker A: So maybe just before we dive into that, maybe a short overview of what's planned soon or what maybe is already currently in the works in terms of the features and the roadmaps and the open prs and maybe where people can already pick up some.
00:17:38.600 - 00:18:44.744, Speaker B: Okay, I think the best place if you just want to do your first issue is just start with precision and I think those are dogs, but some of them are more interesting and you can just start there and then you can get some familiarity with the code base. And further, I think generally if you are interested in implementing some bigger feature you definitely should get in touch with us and we can discuss it. But sometimes it's a bit more stuff to think about. But generally we try to have some kind of roadmap of things we plan to work in next couple of months. So basically what we are working right now, we are adding more cheat codes. So mocking calls is right now one in progress as well as expect events. So those two will be soon implemented by us, but there are many more to do.
00:18:44.744 - 00:19:56.224, Speaker B: So for example, there are cheat codes which can modify transaction signatures and there's lots of data which can be mocked or added. So probably there is a lot of work to do there if somebody's interested in that. This one is one general task, but I think this will be splitted into smaller ones and added as good risk issues as well soon from the bigger things that we plan to work estate forking, I think we start thinking about it next week and it will be like we start creating some more issues regarding that. So this will be like a bigger milestone to work on so we can create some tags from that. Probably also we are collaborating right now with fuzzing clubs to support fast testing. I think also gas usage reports will start be in progress from next or next two weeks. And right now this feature is big.
00:19:56.224 - 00:20:34.620, Speaker B: We generally have one general big task for that. And after we start to investigate what has to be done there, we'll split it into smaller ones. So I'll be more specific. If you want to work on something which is a big kind of vague task, probably just should get in touch and discuss. So this is the best way if you want someone to want to work on something bigger. I think Telegram group is the great place to start because it will be hard to get those bigger tasks. We also welcome people to contribute on them, but those require a bit more communication from both sides.
00:20:34.620 - 00:20:46.864, Speaker B: I think from Goodreads issue you can generally do it mostly on your way, just like you probably should let knowing the issue so nobody will take it from you.
00:20:46.982 - 00:20:57.170, Speaker A: Yeah, we can use the signing option GitHub to set someone who is already working on it.
00:20:58.740 - 00:21:05.072, Speaker B: If you can do that, that's the best way. I'm not sure if anybody can do that outside from, but definitely you can comment.
00:21:05.136 - 00:21:11.064, Speaker A: Yeah, I mean if someone comment on the issue and we'll assign it to you.
00:21:11.102 - 00:21:42.572, Speaker B: Yeah, okay. We'll do that. Definitely. If you would say that you want to work on it, we'll assign it to you and it will be yours. Yeah. Also we are working on starting some work on deployment scripts in Tayo, so I think related issues will be appearing soon as well. It's forecast and the last three are a bit more like long term plans, like store loads, kit codes or like some l one o interoperability testing and test coverage.
00:21:42.572 - 00:22:49.692, Speaker B: I think those will be a bit more for in the future because those are not critical. Okay, does anybody have any questions here? I think I skipped data from files. We started working on this, we started some design work on this this week, and we plan to because it was like a lot of requests on that, but it's just started, so I don't can tell you much more. Okay, any questions here? Okay, should we go over something else before we delve more into the code itself? I've got a question. Of course. For those that have previously tested their contracts in Protestar, what are the main.
00:22:49.746 - 00:22:52.640, Speaker A: Differences between Starknet Foundry and Protostar?
00:22:55.460 - 00:23:49.410, Speaker B: I think main difference is in starknet foundry, tests are not contracts anymore. In Protestar, it was like Protostar was this way, was a bit more similar to Ethereum foundry because tests were contracts here, tests are code executed outside of chain, but you can still have a lot of view into the chain itself, I think maybe a bit hard to grasp, but generally, generally it works a bit like how would you write your tests in Python, but you write them in Cairo and you have some Devnet instance. So the relationship between tests and Chain is a bit similar here. Does that answer your question? Okay, yeah, great. Anybody else has any questions?
00:23:50.660 - 00:24:15.176, Speaker D: Yeah, just to ask, on the, when you said that the contracts are not contracts anymore, it doesn't change the way the interaction between contract calls. Right. They should sort of tell the same as in protestar, for example.
00:24:15.358 - 00:24:48.644, Speaker B: Yeah. Calls work the same. Like you don't have to transact, you don't have invoke and call. We're actually thinking about adding some capabilities so you can test it in more like integration way. But right now what it does is basically you can call your contract with dispatchers on tests. So maybe I will show some examples. That will be the simplest way we can carry a book like the Caribbean starting foundry book is the best way to look into that.
00:24:48.644 - 00:25:16.572, Speaker B: So if you have, for example, deploying new contracts and invoking contracts. No, it's cast, sorry, test. External contract is here. So basically you have a test function, which is like standalone carrier function marked with tests. Test. And from this function you can declare your contract and you can deploy it. You have some address.
00:25:16.572 - 00:25:19.260, Speaker B: You basically can use this address in dispatcher.
00:25:20.900 - 00:25:25.170, Speaker D: Got it. So just like the normal dispatcher should be. Okay.
00:25:27.540 - 00:25:29.170, Speaker B: I didn't hear you, sorry.
00:25:30.980 - 00:25:36.150, Speaker D: Just the normal dispatcher. The caro one patcher should be fine.
00:25:37.160 - 00:25:42.710, Speaker B: Okay. I'm not sure if I heard what you said, but. Okay.
00:25:44.040 - 00:25:46.550, Speaker C: I think he said it's okay.
00:25:46.920 - 00:25:55.770, Speaker B: Sorry, I'm in a conference room and not the best headphones. So thank you for your help.
00:25:56.300 - 00:26:00.220, Speaker C: Okay, I have two quick questions. If we have time.
00:26:00.290 - 00:26:00.910, Speaker B: Sorry.
00:26:02.080 - 00:26:18.960, Speaker C: The first one is about the core lib which is inside the repository. This core lib is not a sub repo of stackware, which means it will be maintained internally because there is some changes required or just to know a bit the philosophy of the repo.
00:26:19.380 - 00:26:48.116, Speaker B: Okay, so basically it is there, but it will be removed next few days. So basically Corlip will become, will come from compiler. It is there, sorry. It's like some leftover from the past, but it will be removed and cheat codes will be located in a start and foundry std library which you will download with scarab like any other Cairo library.
00:26:48.308 - 00:26:50.616, Speaker C: Oh, makes sense. Okay, thank you.
00:26:50.718 - 00:27:40.684, Speaker B: So you can also possible for example to use a different Cairo library of the Kitkat or something. It will be really flexible in terms of development there and people can do interesting things with the ts they want to do. Okay, anybody else has any questions? Okay, goodbye. For some reason it got muted. Okay, so we can right now go into the code itself. If it's nothing else they can delve into. I think it will be brief for you because it's like awful stuff to cover.
00:27:40.684 - 00:28:55.284, Speaker B: I'll just give you an idea how things work. So basically if you have a cheat code, it's implemented in two places. So first, good achietable start, which is like we can think about it as how to describe it. It's a bit new thing we extracted. I'm still looking for proper wording for that, but I think about it as a starknet instance, like blockifier, like starknet execution engine, but which exposes additional methods to modify it. So if you go into this SRC, basically you have a set of functions which are cheat codes. And those cheat codes implementation itself.
00:28:55.284 - 00:30:10.910, Speaker B: Basically here are like just a function. If you go into the definition of this function which is here, and go here for example rocky to the prank cut code, it basically, like, it basically gets, just adds to the. Maybe it's not the best example to show because it won't be very prison. Okay, basically it's an implementation for implements some functions on cheated state, which is like extension of starting state. And it basically adds like okay this contract is ranked to this state. And if you go back here and here is RPC which is a bit coordinating right now. But basically you have a call contract function.
00:30:10.910 - 00:31:22.220, Speaker B: And this call contract gets both document state and cheated state think it will be a factor. So it will be like merged into one state. But right now adults are two. And what it does here, so it basically in cheated state you have contract cheated and if you call contract, this executes this entry point. And there's some lots of not important stuff here. But if we go to the hint GwSisco handler, which is an object in Dockyfire, which is responsible for handling Cisco and hints in general. So basically here what we do, we have an if here and we basically capture like no, we don't capture all hints, we capture only Cisco.
00:31:22.220 - 00:32:21.940, Speaker B: And we have overwritten method for executing the Cisco. And what happens if you go there? I cannot jump here effectively, I can jump like this. So basically here right now, it's not very well abstracted. So it's basically if which checks VM, which stores no, it's stored in the SQL handler. This cheated state I showed you before, and basically address is cheated. What it does, if we go here, it basically checks if there's any cheat code called on it. And if it is there, basically it checks in like if you just look into this function, for example, it basically checks inside of the cheated state.
00:32:21.940 - 00:33:14.564, Speaker B: If it contains the key we put it before. And if we go back when we were. So basically here, if it's cheated, this address is cheated, we modify the logic of this system call. So basically we execute the logic which writes to Cairo memory values, we want to be mocked. And if it's not cheated, we basically fall back to the original Cisco hunter. And basically how those are implemented in Starknet, like in GW, starknet how we call it. And basically what happens then if you have implemented it in Gwstarknet, have an often second issue for that.
00:33:14.564 - 00:34:50.100, Speaker B: And it's implemented in port. And in port you often can, but you have a lot of stuff here, so it will be hard to go into exact details. But if you have, I believe it's running, and running runs some specific test case, and a specific test case is run with other hint processor, just a bit similar to the Cisco hint processor we've seen before. But this one is for this carrier vm we use for testing, not for the starting itself. And here you can see we just call this, if we for example search for start ranked, it basically calls this cheated state start prank. So from a testing environment, we call this prank on this call, the prank on this table state. And then like for example, if you execute here, example would be contract call.
00:34:50.100 - 00:35:13.772, Speaker B: Contract call basically calls this cheatable state. And cheatable state has the logic of like overriding this behavior. I show you before. So it's basically brief overview how it works. I know it's pretty complicated, it's hard to explain briefly and it's best a bit to look into it and ask some questions if you are interested in implementing a cheat code. But yeah, it's generally it. I think it will be better abstracted soon.
00:35:13.772 - 00:35:29.010, Speaker B: It's just work in progress still. And this stuff is new and we don't have very good abstractions for those. I believe it will be easier to explain us. We have better abstractions for them. Okay, anybody has any questions here?
00:35:32.660 - 00:35:51.130, Speaker C: Actually, thank you. Because it's amazing to see this a bit deeper, even if there is no lots of abstraction. It's very interesting to know how it works and what the direction you took for this implementation. So that looks very awesome because really, I think possibilities are just huge.
00:35:52.380 - 00:36:21.628, Speaker B: I think it's pretty flexible. I think long term we have been considering having cheat codes being kind of extensions to start with foundry, so people can write their own cheat codes as a start with foundry extensions. So you don't have to even contribute in my repository. You can just have an extension which is maintained by a different team. But as an idea, it won't happen. Maybe very soon. Okay, I think that's it from me.
00:36:21.628 - 00:36:28.470, Speaker B: If anybody has any questions about it, I can happy to answer. If not, I think we can start wrapping up.
00:36:28.840 - 00:36:31.140, Speaker C: Thank you very much for this, Maximilian.
00:36:33.080 - 00:36:35.076, Speaker B: Thank you, thank you.
00:36:35.178 - 00:36:37.840, Speaker C: Thank you everyone who attended, keep in touch. Bye.
