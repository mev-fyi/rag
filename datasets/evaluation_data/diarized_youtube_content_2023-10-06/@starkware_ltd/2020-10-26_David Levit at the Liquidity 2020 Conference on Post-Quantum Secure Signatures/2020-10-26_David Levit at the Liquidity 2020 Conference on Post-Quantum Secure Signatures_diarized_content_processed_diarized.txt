00:00:07.030 - 00:00:48.840, Speaker A: Hey everyone, we are live here with our next session. Before we hop in, we just want to thank our community partners I forgot to name earlier. So, Crypto Soul, Stanford Journal of Blockchain Law and Policy, youngside blockchain Labs, DSRV, Nonce, Bitford Defolios, Knowledge, Soul chain, news Collider Ventures and global coin research and ZK proof. And I'm sure there are others. And we're going to go to our talk now, which is by David from Starkware. He'll be doing a talk on ZK, stark based post quantum secure signatures, and I'll let him take it from here. Thanks so much.
00:00:49.690 - 00:01:33.480, Speaker B: Thank you very much. So welcome everybody to my talk about post quantum secure signatures based on zero knowledge stocks. My name is David and I work in stockware. This is a joint walk. I'm going to tell you about my joint work with Ellie Ben Sasson, Alessandro Nkiesa, Shai Kigdao, Ilya Lesochin and others. So, this work is based on an existing open source that is called Easter. This open source was published a few months ago.
00:01:33.480 - 00:02:49.850, Speaker B: It was a scalability project funded by the Ethereum foundation, and on top of it, we developed a signature scheme using this code. So before I jump into details, let me say a few words about stackware. So, we are a team of 45 members. We have customers like diversify, immutable, dyDx, and power swap, and we have raised so far $40 million. So, the main products of Starquare are based on a technology that is called Starks, which is a family of poor systems with the following properties. So, first of all, it's succinct. That means that the verification time is poly logarithmic in the original computation time, and the proverb is quasilina.
00:02:49.850 - 00:03:26.330, Speaker B: So this is the best result that we could achieve theoretically. Second, it can be zero knowledge. Okay, I'll discuss it later in more details. It is universal, meaning that it is during complaint. You can prove any computation. It's transparent. There is no trusted setup, like in other zero knowledge constructions like snarks.
00:03:26.330 - 00:04:50.130, Speaker B: It is post quantum secure, meaning that it's post quantum secure, because the only assumption that we are using is the existence of a one way function, or we can call it a hash function. So this is the most conservative assumption in cryptography that we could rely on. So because it's so conservative, it actually has almost no security assumptions, then it makes it future proof. Actually, if this one is broken, then all the cryptographic primitives that exist today are broken. So this makes it the most conservative, the most conservative construction that exists. Okay, so this all starts in general. And as I said, we are relying on open source project that is called estart.
00:04:50.130 - 00:06:07.322, Speaker B: You can see the GitHub repo here, and you can also scan this QR code if you'd like. This talk is recorded, so you can always get to it later if you like. So this open source project, as I said before, was funded by the Ethereum foundation. And it was originally a scalability project where we generated a prover and a verifier for a very large computation, in which we proved a long hash chain sequence. And it had, and it has the best performance that was ever achieved for pover and verifier. And this is why we call it the fastest pover to date. So this what we had a few months ago, and on top of it now, we added also zero knowledge.
00:06:07.322 - 00:06:58.154, Speaker B: So now it makes it the fastest zero knowledge proverb to date. We didn't publish it yet, but we are going to publish in the next few days. It is going to be a branch of the same repository. Okay. After having this zero knowledge added to our project, we are going to make it a digital signature. So what are digital signatures? They were first introduced by DC, Elman and Dariusa. And they have three components.
00:06:58.154 - 00:08:04.658, Speaker B: So the first component is g, a generator that generates a public key and a secret key. Then there is a signer s, which, given secret key and the message, it generates a signature. And we have this verifier v that given a public key, a message and signature, decides whether to accept or reject the signature. Most popular schemes, signature schemes are RSA, DSA and ECDSA. They are all breakable by quantum computers. And this is why we are trying to develop a new kind of signatures that will be post quantum secure. This problem of quantum security is such a big problem that NIST, the National Institute of Standards and Technology of the United States, is launched in August 2016.
00:08:04.658 - 00:09:37.310, Speaker B: A project, actually a competition, so called, to standardize a set of post quantum cryptographic primitives such as encryption key establishment and digital signatures. The candidates for the digital signature, the candidates for this competition, they can be classified into several types. So there is lattice based, there is one that is based on solving random multilinear polynomial systems, and there is the hash based. Okay, the first two types are actually new types of assumptions, of cryptographic assumptions that were introduced very lately. So they have not been tested and studied as much as the hash based assumption. Our project is hash based and it is stateless. Okay, so stateless.
00:09:37.310 - 00:11:07.520, Speaker B: The hash based signatures can be classified as stateless or stateful. The stateful signatures need to modify the secret key after each signing. So our signature is stateless, but most of the stateless hash based signature have long signature, but ours has actually short signature. So it has both advantages of a stateless signature, but still a short signature. So let's dive deeper into how do we produce, how do we produce post quantum signature out of post quantum zero knowledge proof? So, zero knowledge proofs are usually interactive proofs. And Fiat and Shamir were the first to introduce a way to transform these interactive proofs into non interactive proofs. And moreover, these non interactive proofs are secure in the quantum random oracle model.
00:11:07.520 - 00:12:58.830, Speaker B: So our construction is very similar to that of the phamyo, and we are using a one way function. In our case, it is the rescue hash function. So the generator is to generate the keys is just to sample a random secret key and to set the public key to be the hash of the secret key to sign. We just prove that we know a pre image to that public key, and then we generate a non interactive poof PI such that in this transformation into a non interactive poof, we use the message as a source of randomness. So then afterwards, when the verifier verifies the proof PI, which is non interactive, first of all, he is convinced that the signer knows the pre image for the public key, meaning that the signer is indeed the owner of the secret key. Moreover, he's convinced that the signer had in mind the message m, because the verifier needed to use the message m during the verification process. So this gives us the construction.
00:12:58.830 - 00:14:08.230, Speaker B: So now we are only left with how to make zero knowledge system, zero knowledge proof system. So from now on, this is going to be a bit technical. So I'm sorry for that. The starts have three main steps. So the first step is to record the execution trace of the computation of the hash. The trace is just a table finite set of columns where each row is actually the state of the computation at some point. Okay, so this is a two dimensional array and it is subject to some constraints.
00:14:08.230 - 00:16:07.386, Speaker B: These constraints verifies that the computation is legitimate. The second step is to commit with the mercury on the low degree expansion of the. So the load degree expansion is actually an error correcting code, which we call ritzolomon. And the third step is to apply the fry protocol to prove that this load, the gear extension is indeed code word. Okay, so we do not expose the real loading extension, we only expose the commitment on it, and we have this fry protocol that can prove that the committed word is a real code word, and moreover that it is a code word of a legal trace that satisfies these constraints that I talked about earlier. So, completing these three steps, we have a proof, not yet zero knowledge proof, but a proof that we do know this pre image of the public key. But we have three places where we leak information about the secret.
00:16:07.386 - 00:17:23.510, Speaker B: So let's take a look at what are those places. First place is in the Merkel tree. Actually, each query to the Merkel tree, each decommitment path reveals information about the neighbors of the decommitted leaf. So even if I decommit only one leaf, then data about its neighbor is leaked. Because if there are not many candidates for the neighbor, then we could exhaustively search it. Then we have this loading extension, which is actually a linear combination of the trace. So by revealing a leaf, we actually expose some linear combination of the secret, because the trace contains the secret.
00:17:23.510 - 00:18:50.210, Speaker B: And finally, we have this phi protocol, which proves that the linear combination of all the columns, all these load degree extensions, is a low degree polynomial. Yet again, this is a linear combination of secret which we do not want to expose. So let's take a look at how do we solve this problem, these three problems. First of all, the Merkel tree is sorted, meaning that we add the proverb adds some randomness to each leaf, making it impossible to exhaustively search on the leafs, the log extension. For the logo degree extension, we inject a series of random values to the end of each column. It makes each query to the loaded extension actually be distributed uniformly. So it is independent of the original trace.
00:18:50.210 - 00:20:09.770, Speaker B: And for the fry protocol, we are blinding with an extra column that is also filled with random values uniformly distributed. That's making the overall linear combination uniformly distributed low degree polynomial, which is independent of the original trace, thus making it doesn't leak any information. So this is it. Now we have zero knowledge proof system and we showed how to generate signature scheme out of zero knowledge proof system. So now let me show you the performance. This number were measured on my laptop, which is quad core cpu, and they are pre optimized. So we see here two versions.
00:20:09.770 - 00:21:04.720, Speaker B: These two versions are because there is a trade off between the signing and verifying time and the signature length. So we decided to show both versions. The keys are sorted to bytes, both private and public key. And this is the minimum possible size theoretically for this security level. The security level is 122 bits of security. So let's see a quick comparison between our project and other signature schemes. So, sphinx and picnic are also hash based.
00:21:04.720 - 00:21:54.170, Speaker B: All the schemes in this table are post quantum secure. Yes. So spring and picnic are also hash based. And you can see that our performance is very competitive with these constructions, other constructions that are lattice based. We can see that they can have better performance in some of the parameters. But first of all, as I said before, the key sizes are the minimum that are theoretically possible in our project. And again, the lattice assumption is less conservative.
00:21:54.170 - 00:22:14.820, Speaker B: So, this is it. Thank you very much. Do you have any questions? If you have questions, you can ask them now.
00:22:20.720 - 00:22:24.780, Speaker A: So, David, there are three questions in the ask a question section.
00:22:26.160 - 00:23:00.760, Speaker B: Yes, I see them now. So, Dioka is asking. I'm aware that error is universal, but it's not an arbitrary arithmetic circuit. Can you comment on how that affects efficiency and expressiveness in practice? So the expressiveness is quite good. We. The basic. The basic.
00:23:00.760 - 00:24:40.538, Speaker B: The basic element that we use is a filterment, and not a bit. There are statements that are more expressive, like elliptic curve arithmetics or field element arithmetics, but still, everything is possible to express. When you pass into bit everything, you can always represent bits as field elements. Let me know if I answered your questions well enough. So, the next question I see is, snarks have been suggested as a reliable VDF to immediately solve the dark force problem. Do you see starks as a potential VDF in the same way? As far as I know, yes, there is a possibility to make a VDF with Tarx. So, the third question is, you pointed out that our proposal has 122 bit security.
00:24:40.538 - 00:26:37.590, Speaker B: How did you measure the security length? So, first of all, we relied on the hash in the statement that we used is a rescue hash, which has 122 bits of security according to the analytics that it was conducted. Second, in the Merkel trees that we used, we used Blake, which is 128 bits of security. And finally, we have the zero knowledge scheme itself, which has unlimited security in the non interactive model. And when you transform it into the non interactive, then it has the security of the hash that is used, and we used Blake for that. I hope that I answered your questions for your satisfaction. Are there any other questions? Someone asked if this is recorded? Yes, this is recorded. So thank you very much.
00:26:37.590 - 00:27:03.310, Speaker B: I see another question. How well do stack support recursive proof composition? Well, I'm not aware yet of such project, but I assume that it should be at least as good as Snox.
00:27:10.210 - 00:27:13.950, Speaker A: Okay. Yeah, this was fantastic. Do you have any closing thoughts?
00:27:16.360 - 00:27:26.710, Speaker B: And thank you very much for listening to me. And I want to thank again to everyone who was part of this project.
00:27:28.600 - 00:27:38.000, Speaker A: Yeah, for sure. And again, thank you so much for taking the time to present. It was a really great presentation. We're going to transition to the next talk now. Thanks. Bye.
