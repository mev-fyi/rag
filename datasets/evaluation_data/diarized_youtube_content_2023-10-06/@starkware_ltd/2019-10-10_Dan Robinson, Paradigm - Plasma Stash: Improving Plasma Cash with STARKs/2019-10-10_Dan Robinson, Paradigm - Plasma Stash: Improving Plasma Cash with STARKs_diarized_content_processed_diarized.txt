00:00:05.030 - 00:00:11.450, Speaker A: So next up we have Dan Robinson from Paradigm, who's going to be talking about plasma stash.
00:00:12.030 - 00:00:37.038, Speaker B: Great. Hi everyone, my name is Dan Robinson. I'm a research partner at Paradigm, but I'm here representing my own views or crypto asset investment firm. So I'm going to talk about plasma cash. If you're not familiar with it, plasma cash is plasma. It's an off chain scaling solution on Ethereum. And what's particularly useful about it as a scaling solution is that it doesn't require data availability of these state transitions.
00:00:37.038 - 00:01:23.310, Speaker B: So it shares that in common with state channels. And when you're talking about how starks actually are a really good fit for plasma cache and for fixing some of the problems with plasma cash, because there are these proofs that are part of it that I'll tell you all about. So plasma is called a non custodial side chain. I think Patrick calls them commit chains. It's a side chain that's committed to, say the Ethereum main chain, and you can move assets onto and off of it, but it's operated by, say, one operator. And the key thing is the operator can't steal the funds and can't prevent you from withdrawing them. And withdrawing them can be done in constant steps, even if no matter how many times the asset has been transferred.
00:01:23.310 - 00:02:41.866, Speaker B: So these are the nice things about plasma. There are some alternatives in terms of scaling that have different advantages and disadvantages, and one of the major ones that's relatively sort of adjacent to plasma is roll ups. So Starkdex, Starkpay, stark exchange, all the stuff that Starkware has been working on, generally falls in the roll up category, because that's something where it's similar to plasma, except it requires that you guarantee data availability of these state transitions in some way, typically by just sort of splatting them onto the main chain in the call data. So that means that you no longer have this sort of infinite scalability, where you can have as many state transitions as you want without any kind of scaling burden on the main chain, but you can get something like a ten x to 100 x to 1000 x advantage from this. So the big disadvantage that plasma has compared to roll ups is that it supports a much more limited set of applications, specifically, really only sort of like payments and exchange. The one I'll be talking about today is just simple payments and transfers of non fungible tokens, whereas roll ups, you could run whatever kind of computation you want. Anything you can verify in the EVM can be done with that, but I'm going to be talking about plasma cache here.
00:02:41.866 - 00:03:32.460, Speaker B: So just to start, the core of plasma cache is based on this data structure called the sparse Merkel tree, or similar ones, an optimization of which I'll be talking about. So a sparse Merkel tree is a commitment, a normal Merkel tree is just a commitment to a list of values. And a sparse Merkel tree is a commitment to a mapping to something where there's particular keys, and you can only open one key to one particular value. So here, most of this tree is empty, but the fourth key is some value v. And so it's very efficient to prove that slot four has value v, and you can only open this commitment to that one value. There's no way to prove that slot v is empty or anything else, and that's in just sort of logarithmic and the number of, total number of slots. So in this case it's four.
00:03:32.460 - 00:03:50.030, Speaker B: Similarly, it's very efficient to do a non inclusion proof, so you need to have these two primitives in order to support plasma cache. There's an optimization to sparse Merkel trees that's sort of the one that's currently used, which is Merkel interval tree.
00:03:50.110 - 00:03:54.260, Speaker C: And this one, it just allows this.
00:03:54.790 - 00:03:58.114, Speaker B: Leaf here, this leaf at index one.
00:03:58.232 - 00:04:00.514, Speaker C: To cover a whole range, because all.
00:04:00.552 - 00:04:02.790, Speaker B: These values were empty, if you recall.
00:04:03.690 - 00:04:06.934, Speaker C: In the sparse Merkel tree. So we just compress them all, and.
00:04:06.972 - 00:04:09.394, Speaker B: It just says, this is the hash.
00:04:09.442 - 00:04:11.320, Speaker C: Starting at one, and then.
00:04:13.530 - 00:04:26.826, Speaker B: You only have to actually put leaves when there's a value or one that isn't identical to its adjacent value. So it's a bit of a compression. So this means now our proofs are log m in just the number of non empty slots in the Merkel tree.
00:04:26.938 - 00:04:29.338, Speaker C: So that's just an efficiency improvement.
00:04:29.514 - 00:05:24.382, Speaker B: Okay, so how do we use these commitments? So the structure of a plasma chain is that it's divided into a set of coins, and a coin is some asset, and that asset is tracked by some particular slot in the Merkel tree, in the sparse Merkel tree or Merkel interval tree. And the key thing here is that the coin doesn't move, the coin stays in the same place, and the owner comes to it and changes with each j transition in plasma. So if you're familiar with on the isle of Yap, this is some like monetary history 101. On the isle of Yap, there are these rise stones, and these are used as money. And that's like, I don't know, I don't know how big it's, it's very big. It's really convenient. Because it's very hard to steal this as money, but of course it's very hard to transfer it to somebody.
00:05:24.382 - 00:05:30.126, Speaker B: So instead of when you transfer someone one of these, you don't actually have to move it, you don't give it to them.
00:05:30.148 - 00:05:31.458, Speaker C: You just tell everybody.
00:05:31.544 - 00:05:39.582, Speaker B: And maybe a public ceremony to this effect, you just say that you're transferring one that everybody already knows that you own, and now everybody knows that someone.
00:05:39.656 - 00:05:53.222, Speaker C: Owns, the recipient owns it. So it's just like with these coins, each of these right now is owned by some particular party. But then if Dave wants to transfer.
00:05:53.276 - 00:05:54.870, Speaker B: It, he just signs a transaction.
00:05:55.770 - 00:06:02.966, Speaker C: Or if Alice wants to transfer something, she signs a transaction that sends it to Bob, and that transaction has to go in her slot, in the slot.
00:06:02.998 - 00:06:07.840, Speaker B: For the coin that she's transferring. So in this case, or here, it says slot four, because it's slot one.
00:06:08.690 - 00:06:13.358, Speaker C: Alice just says, I'm sending this coin, and then that transaction is included at.
00:06:13.364 - 00:06:14.714, Speaker B: The right spot in the Merkel tree.
00:06:14.762 - 00:06:17.550, Speaker C: And it actually just moves the asset.
00:06:21.430 - 00:07:00.094, Speaker B: That gave you a little preview of that transactions end up being merklized and put into one of these sparse merkle trees or Merkel interval trees. And so each plasma block is just a commitment to, here are all the state transitions, here are all the things, the coins that change donors. And this is committed into the parent chain. And this is what allows plasma to prevent double spending, because once it's been committed to the parent chain, there's just no way for someone else to exit. And I'll describe how the exit game kind of protects you now, once you've been committed to the chain. So in order to exit, you can.
00:07:00.132 - 00:07:06.446, Speaker C: Initiate an exit just by showing that at block five, you provide an inclusion proof that says Bob owned this as of block five.
00:07:06.468 - 00:07:21.082, Speaker B: And block five is some block in the past. Now, what happens if somebody exits from this outdated state, but Bob is actually already double spent it? Bob's already sent it to Charlie. In that case, you can just reveal.
00:07:21.166 - 00:07:28.038, Speaker C: This transaction here from Bob to Charlie, and that proves that this is an.
00:07:28.044 - 00:07:48.554, Speaker B: Outdated exit, and that just cancels the exit right away. So Bob is enabled double spend. Slightly more difficult to prevent is a malicious exit. And so the way that works is just, this can only happen if the invalid exit. This can only happen if the operator is malicious. But what happens here is just Charlie never received this coin.
00:07:48.602 - 00:07:59.874, Speaker C: Bob owns this coin. Bob thinks he owns this coin, but then the operator just says, at this point, Charlie owned this coin, and Bob knows that Charlie doesn't actually. So what Bob can do is just.
00:07:59.912 - 00:08:07.986, Speaker B: Exit his coin and the prior uncancelled exit wins. So whatever exit is earliest succeeds, and.
00:08:08.008 - 00:08:11.170, Speaker C: So Charlie's exit won't succeed because Charlie has no way of canceling.
00:08:14.550 - 00:08:16.374, Speaker B: So this exit game basically works.
00:08:16.412 - 00:08:26.460, Speaker C: I papered over a few sort of subtleties that aren't really important for what I'm talking about here. But there's this problem, right, which is.
00:08:27.550 - 00:08:41.198, Speaker B: When I get a coin, I need to know that no prior owner still owns that coin, or rather that I need to know that I can cancel any prior owner's claim on that coin. And in order to do that, I.
00:08:41.284 - 00:09:13.718, Speaker C: Need to receive a proof that, say, when Charlie receives this coin, we need to send Charlie a proof. The operator of the chain or the prior owner needs to show, look, here's your transaction at this Particular I received it in block, this coin in block three. It was deposited in block three, and then it wasn't spent in any block since then. And then now you're receiving it. And so once Charlie sees all of this, Charlie knows that he owns the coin.
00:09:13.814 - 00:09:18.918, Speaker B: So this history is independent of any other coin.
00:09:19.094 - 00:09:41.746, Speaker C: This is only Charlie's rhinestone that's actually being tracked by this particular slot. But it is linear in the length of the history and the number of blocks in the plasma chain's history. So that can be kind of a large proof. Fortunately, it's an off chain proof. And this is what's really cool about plasma cash, is that you have this proof, but it's only verified, needs to.
00:09:41.768 - 00:09:46.562, Speaker B: Be verified by the user because on chain it's verified by this interactive exit game.
00:09:46.696 - 00:10:44.694, Speaker C: But when Charlie receives this coin, they're not able to take advantage of this on chain interactive game because that wouldn't be scalable. So they actually just need to verify this proof off chain. And that's where the problem we're going to be solving with starks, because these are big proofs. So like I mentioned, it's linear in the size of the number of blocks in the history, and it's also logarithmic in the depth of each of these proofs because there's a non inclusion proof or an inclusion proof, or each of these sort of merkel proofs. So if we want to support 1000 transactions per second, and I think we know that we do, and we want to say no, we're not sacrificing any latency compared to the Ethereum chain, we're just going to have five blocks every minute and 12,000 transactions block that comes out to be about 2.6 gigabyte proof of proofs per year. And so I checked my iTunes library and 2.6
00:10:44.694 - 00:11:06.778, Speaker C: is almost exactly the size of Pirates of the Caribbean Dead man's chest, the second film in the Pirates of the Caribbean film, Pirates of the Caribbean series. So it's a good way to remember it if you're familiar with my itunes library. But generally it's a pretty large file to have to send somebody 2.6gb every time you want to transfer them a coin.
00:11:06.794 - 00:11:15.870, Speaker B: So remember this doesn't go on chain. We're not lunatics. But you have to send this to somebody every time you transfer them a coin.
00:11:18.290 - 00:11:33.058, Speaker C: Fortunately here what we want are efficient. I was so undecided between Tony Stark and Arya Stark, and then Ellie used Tony this morning and it was like a. So we have a case here where.
00:11:33.064 - 00:11:37.682, Speaker B: We have these proofs and it's a pretty simple proof, but it's really large and we want it to be smaller.
00:11:37.746 - 00:11:39.474, Speaker C: So this is a perfect use case for starks.
00:11:39.522 - 00:11:55.646, Speaker B: And what's cool is we're not going to verify any starks on chain here. And in fact there's nothing about this construction that needs to be built into the plasma cache contracts or anything. This is all just an upgrade that you sort of just layer on top of plasma cache and it can make.
00:11:55.668 - 00:12:12.094, Speaker C: The proofs a hell of a lot more efficient. So looking at this example, 1000 transactions per second, five blocks a minute for one year. If you just give people the explicit Merkel proofs, that's 2.6gb.
00:12:12.142 - 00:12:14.098, Speaker B: With Starks, it's only around 100.
00:12:14.104 - 00:12:35.290, Speaker C: Do a stark. And thanks Avihu, for helping with the benchmarks here and estimating these numbers. One downside of this is I checked, and 100 kB is actually about the size of the screenshot I took for the lame iTunes joke that I had earlier. So that's much smaller.
00:12:37.470 - 00:12:45.306, Speaker B: Now, there's a downside here, which is if you were to just sort of do this on your laptop, it would take about five days in order to.
00:12:45.328 - 00:12:46.010, Speaker C: Approve.
00:12:49.570 - 00:13:10.178, Speaker B: Just one of these. Now that might be okay because you're proving a whole year. So you only really have to do this like at the end of every year you go, okay, I'm going to do my stark proof for the previous year and you run your laptop for a couple of days. This is also a very parallelizable process. So you could have this run in the cloud and figure out how to.
00:13:10.184 - 00:13:21.026, Speaker C: Generate this quickly or the operator could run a service that generates these proofs for users. But if you want, you want a slightly more efficient system, you can reduce.
00:13:21.058 - 00:13:24.354, Speaker B: The number of blocks, the frequency at which blocks are committed to the main chain.
00:13:24.482 - 00:13:44.922, Speaker C: So you get these deeper blocks, but fewer than the proof. And so for that, you'd still have an 80 megabyte Merkel proof per year, which is not a trivial amount to download just in order to receive a transaction. But with Starks, you get the same space savings, but also it's a lot quicker.
00:13:45.066 - 00:14:00.686, Speaker B: So, one final optimization. It's a bit of a problem to have to prove the entire history of your chain, of your coin. If that goes back a couple years, it'd be really nice if we could just checkpoint the whole chain at some point. And you can do that off chain.
00:14:00.798 - 00:14:02.098, Speaker C: Using starks as well.
00:14:02.184 - 00:14:51.282, Speaker B: So what could happen is the operator can just generate a proof of the current state of the chain and some information about the prior transactions that you need to cancel them and just create a proof that this is the current state as of a particular point, and just provide that off chain to anybody who wants it. This is still a compact, like 100 to 200 kilobyte proof, but once the job operators generated this for this particular point, now all the other history proofs, all the coin specific proofs, can just start at the point that was checkpointed. So this takes a lot more. The proving time here is about linear in the number of transactions over that period. So 1000 transactions per second. It turns out it takes about 10 seconds to prove every 1 second of history. So you're never going to catch up.
00:14:51.282 - 00:15:38.386, Speaker B: But you could parallelize this and run this on a server, or you could just run something sort of, that lags quite a bit behind, but still would be materially reducing the amount of sizes of these proofs. So starks do also give us, I think, potentially some interesting ways to extend plasma cache and to make more complicated state machines viable in it. But I think that's going to have to wait for further work. So is building it, because I don't build stuff anymore that much, but I do make t shirts. So if anybody builds plasma cash, plasma stash, I will make them a t shirt. But it's something that if you're building plasma cash georgios, I think you need to. This is just sort of like, it's just a layer on top of it.
00:15:38.386 - 00:15:58.780, Speaker B: This isn't something you even have to worry about in the base layer. It's pretty cool. The one thing is probably you should be using Patterson hashes. So if you want to tell me about stuff you're working on, you want to ask more about this or my other work, you can reach me easiest at Dan Robinson on Twitter. All right, thanks, everyone.
00:16:02.350 - 00:16:04.300, Speaker A: All right, does anyone have any questions?
00:16:06.930 - 00:16:28.500, Speaker D: Thanks. Do you mind to announce about this in plasma calls that we have? Because just recently on the last one I talked about similar approach. And the huge question is, is it possible to put proof for sparse merkel tree inside the starks? Did you try to do this?
00:16:30.630 - 00:16:42.546, Speaker B: Talked to, I haven't tried implementing this, but I talked to Avihu about it, and I think it's a relatively straightforward process. Especially, I think if you use the Merkel interval tree rather than a spark merkel tree, it gets a lot more efficient.
00:16:42.738 - 00:16:43.590, Speaker D: Thank you.
00:16:43.740 - 00:16:50.234, Speaker B: I'm sorry I haven't been on the plasma calls recently. I moved to the west coast, so we're there at 07:00 a.m. It's just a pain, but I'm sure they're great.
00:16:50.352 - 00:16:57.102, Speaker D: But it's a great point just to continue because that's the point that we start to talk about this.
00:16:57.156 - 00:16:57.566, Speaker B: Yeah.
00:16:57.668 - 00:16:58.414, Speaker D: Thank you.
00:16:58.532 - 00:16:59.200, Speaker B: Cool.
00:17:02.210 - 00:17:22.770, Speaker E: I had a question regarding the. I didn't quite get the negatives of the roll ups, and so my experience is building roll ups for crypto collectibles, and the way that you've done your Merkel trees are very similar. I just didn't quite get the negatives of why a roll up. I didn't quite get the negatives of that.
00:17:22.840 - 00:17:27.622, Speaker B: So with the roll up, you have to put all the data for the state transitions on chain. Right?
00:17:27.676 - 00:17:27.990, Speaker E: Yeah.
00:17:28.060 - 00:17:52.522, Speaker B: So at least in theory, that gives you some limit to the scaling benefits. Right. Like, if you couldn't do a million transactions, you probably couldn't maybe do a thousand transactions per second. I'm not sure if you can with roll ups on ethereum today. That said, honestly, I think there's a good argument to be made. That's enough for now. It's probably good enough just.
00:17:52.522 - 00:18:17.330, Speaker B: And you get like a ten hundred x maybe scaling benefit. So I think. I think that's a pretty good argument. So, yeah, I think plasma research is very helpful. For one thing, I think it informs some stuff about how to design roll ups and to potentially make them more efficient and because for sort of the eventual day when we want to kind of break free from the bounds of on chain data ability. Perfect.
00:18:17.400 - 00:18:19.120, Speaker E: Thank you. Thanks.
