00:00:00.170 - 00:00:17.200, Speaker A: Syntax. We are now live on YouTube also, so introducing again. Hey everyone, committee call number 46. We're with Ariel and Shahar and we're going to talk about the syntax, the new syntax of Cairo one. Hey guys, how's it going?
00:00:18.210 - 00:00:19.902, Speaker B: Hey, great, thank you.
00:00:20.036 - 00:00:30.200, Speaker A: Cool. Maybe first, I think a good number of people know you, but we may have newcomers, so can you introduce yourself in a few words please?
00:00:30.810 - 00:00:44.282, Speaker C: Sure. So, I'm Ariel, a product manager in Starkwell, working basically on anything Sparknet needs me to. You're the PM for the new syntax? Yes.
00:00:44.336 - 00:00:44.986, Speaker A: Nice.
00:00:45.168 - 00:00:45.850, Speaker C: Cool.
00:00:46.000 - 00:00:46.970, Speaker A: Shaha.
00:00:47.470 - 00:00:52.474, Speaker C: Sorry, yeah, I was about to present the actual brains of Cairo one.
00:00:52.672 - 00:01:03.300, Speaker B: Hi, I'm Shah, I work on the compiler team for Cairo one and on Starknet related engineering stuff.
00:01:04.710 - 00:01:31.978, Speaker A: Cool. So thank you for joining the call today. The topic, you introduced it briefly, Ariel, the topic today is that Cairo one was released a few months ago. I think we started working on it publicly. Good. Six months back actually. But the first version of Cairo one was released a few months ago, a few weeks ago, and it had a.
00:01:31.978 - 00:02:03.314, Speaker A: I don't know how to call this like a module, a syntax, a specific way of writing Starknet smart contracts. And this is now changing. So the way you write Starknet smart contracts in Cairo one is changing, and we're here to explore these differences. I guess the first question I got yesterday actually from the audience is, so is this going to be Cairo two or is it going to be Cairo 1.2? How do you plan on maintaining the name going forward? It's actually a serious question.
00:02:03.512 - 00:02:29.706, Speaker C: So the TLDR is Cairo one with compiler version V 2.0. I think that once Cairo zero will be phased out, eventually we will just say Cairo and talk about the compiler version up until the regenesis. I think it will be Cairo one and compiler version to distinguish between the very old syntax and the existing one.
00:02:29.808 - 00:02:34.160, Speaker A: Okay, so it's Cairo one, version two. Can we say it's Cairo 1.2?
00:02:38.290 - 00:02:39.440, Speaker C: Probably not.
00:02:40.930 - 00:02:46.340, Speaker A: So Cairo one version two it is. Cool. So tell us what's in it.
00:02:46.950 - 00:03:53.862, Speaker C: Cool. So yeah, there has been some changes in the way we write smart contracts with Cairo one. Initially we sort of continued the syntax from Cairo zero in a lot of ways. For example, the event treatment was pretty much exactly the same, even though it doesn't really fit naturally with the new rust like language and was originally a bit weird if you ask me, treating events like functions. Basically the changes deal with how you arrange your smart contact, where you put your external functions, where you put, how you define your storage and how you define your events. So it's essentially the outer layer if you want to call it. But maybe before we discuss the actual changes, I want to emphasize a few points that at least I've been getting a lot of questions on.
00:03:53.862 - 00:04:33.330, Speaker C: So now there's a breaking change in the syntax. How is it dealt with on the Starknet level? Will my contact continue to work? What do I need to do? So I think we should clear this before we move to deal with the actual syntax. So first thing first, everything that's deployed or declared on Starknet already will continue to work as usual. If you have a contract and it's deployed, or if you have a class and it's declared, then you have nothing to worry about. Nothing is changing there. Okay. And that will always be the case.
00:04:33.330 - 00:04:45.462, Speaker C: Breaking changes in the compiler can't affect classes that are already declared or contracts that are already deployed. Okay, what about. Yeah, go ahead.
00:04:45.516 - 00:05:28.634, Speaker A: So if I had to explain it in simple words, and correct me if I'm wrong, so when you declare a smart contract on Starknet, you send Sierra code which gets compiled by the sequencer to chasm that code. We know it's safe because it was compiled from Sierra. So we know that that contract is safe. Right. So since it was controlled at some point by the sequencer, it can live on on the network. But the sequencer only has one way of checking a contract version, which is a compiler version. So when you send a contract to him, it needs to be the version that the sequencer uses.
00:05:28.634 - 00:05:52.190, Speaker A: So if your contract was declared then it's all clear. If it wasn't declared yet, it needs to fit the properties of the sequencer. It's kind of like if you add a passport and every two months the format of the passport would change. But as long as you enter the country, you enter the country and you're fine. Right, but if you want to enter the country later on, then you need to have the updated version of the passport.
00:05:52.690 - 00:06:46.430, Speaker C: Yes, but with another update on the expiration dates of the passports. But if you think about being deployed as being in the country, then in a world where you can't be deported, then that's how it works. Okay, so the second thing is. Okay, I was in the middle of writing my contract, now the syntax has updated, how should I go about it? Okay, so first of all, this upcoming version of Startnet twelve. Currently we are on eleven two and the new compiler hasn't been updated on the sequencer. So there are no changes on the stagnet level yet. This will only hit when twelve is released in a few weeks, let's say in around one month to hit mainet.
00:06:46.430 - 00:07:53.630, Speaker C: So yeah, how it will work is as follows from the next version of Stacknet. Basically the sequencer will handle different compiler versions. So if you wrote a contract in the old compiler, you can continue using the old compiler, eventually deploy it on Starknet and it will still work as usual, just like before. The only difference is that you can also work with a new compiler, so you can write in the new syntax compile and this will also be accepted on Starknet. And the guarantee that we want to have moving forward as it's in every breaking change in the compiler will also accept contracts written with the old compiler for a period of at least six months. So if you are worried about you are just about to finish writing your contract, you are just in the middle of an audit, so you would be able to deploy your contract to startnet. There is no need to rush and get your contract in there just before the new syntax hits.
00:07:53.630 - 00:08:03.030, Speaker C: So you have a period of six months to adjust to writing contracts in the new way and you can still deploy your older code in the meantime.
00:08:04.010 - 00:08:41.506, Speaker A: So gad boot is asking is it the case for Cairo zero class ash? I'll be forever able to deploy a contract with Cairo zero class ash, and the answer is no, because their passport wasn't checked, they weren't compiled from Sierra, so eventually they're going to be deactivated. So you won't be able to declare new Cairo zero class ash, you won't be able to deploy new Cairo zero contracts, or declare zero classes exactly, or interact and use existing deployed Cairo zero contracts exactly.
00:08:41.688 - 00:09:21.280, Speaker C: And I want to emphasize that that's sort of an orthogonal question, because that's related to the Regenesis question and handling multiple versions of the compiler. The six months period only deals with Cairo one. At the moment you can still write and deploy Cairo zero, but upon regenesis, which will come around the end of the year, then you will not be able to do it any longer. Okay, amazing. I don't know if you have any more questions on Discord or Twitter about the let me check compatibility issues.
00:09:22.630 - 00:09:31.394, Speaker A: Robert is saying zero point twelve, but no meaningful question aside that okay, that.
00:09:31.432 - 00:09:43.478, Speaker C: Was a very good contribution, thank you. Shah, you want to add anything about, I don't know, anything infrastructurial around the new compiler before we dive into the.
00:09:43.484 - 00:10:19.780, Speaker B: Syntax, but the compiler itself, yeah, I'd say the changes to the contract syntax, I like to think of them as it changes to the Starknet plugin of the compiler. So it's not necessarily changing the core compiler itself, just for all the Starknet annotations and plugins and how it embeds these starknet concepts in Cairo one. So it's even a smaller area of change. Just start and plug in most of these changes.
00:10:22.630 - 00:10:36.870, Speaker C: Okay, cool. Yeah, I think it's good to keep this distinction in mind. Let me present share screen. Have no idea what I'm sharing.
00:10:41.690 - 00:10:45.450, Speaker A: Once you're going to share, I'm going to have an option to add it to the stream.
00:10:50.950 - 00:10:52.820, Speaker C: Okay, I think I shared it.
00:10:53.850 - 00:11:00.840, Speaker A: Yes, let me add it. Inception recursion. Recursion, sorry.
00:11:01.530 - 00:11:03.926, Speaker C: Okay, can you see the code now?
00:11:04.108 - 00:11:06.120, Speaker A: We can, and the size is good.
00:11:06.510 - 00:11:42.260, Speaker C: Okay, amazing. So what I thought was going to do is go over the contract that's published in the community forum post and basically explain the different aspects now. And feel free to stop me at any time and attack me with questions. Shahar, if you want to emphasize something, then feel free to do so as well. Okay, so let's see the contact in the old format. Ignore the colors. Since I'm on the new compiler version, it was either rust coloring or no colors at all.
00:11:42.260 - 00:12:27.780, Speaker C: Okay, so we have a pretty dumb counter contract. It has two storage variables. One counter, which is U 128, and a dispatcher to call another contract, which is basically a contract that says am I allowed or not to decrease the counter? Okay, so there are three functions. Let's see them. I can increase the counter, that's an external function. I can decrease the counter, that's an external function, and I can read the counter. And the decrease counter function also interacts with our other contract here to see if I'm allowed to decrease it.
00:12:27.780 - 00:13:01.760, Speaker C: Okay, so nothing too fancy going on here. Three external functions, two events, counter increased and counter decreased, which are emitted when you would expect them to in the decreased counter and increase counter functions. And that's basically it. So that's our contract. And let's see how we write it in the old style. In the new style. Any questions so far? Okay, great.
00:13:01.760 - 00:13:06.058, Speaker C: Okay, so something you can notice.
00:13:06.234 - 00:13:17.870, Speaker A: Actually, I have a very dumb question. Can you summarize in a few words, what is a mod and what is a trait in Cairo?
00:13:19.410 - 00:14:04.530, Speaker C: Okay, and shah, feel free to correct me if I'm saying stupid things, but a trait is just like grass rates. It's basically defining a collection of methods which I can use for this specific type, which is given itself here. And module is just a way to gather some logic under a module. So for example, contracts were written inside a separate module and are still written inside a separate module. So here I have my contract interface, which I defined in a trait, but my module with the actual logic in a separate module called counter contract.
00:14:04.870 - 00:14:11.970, Speaker A: So is a trait like a specification? Yes. Okay, so a trait is a specification.
00:14:12.470 - 00:14:15.618, Speaker C: And I can have implementations for the trade.
00:14:15.794 - 00:14:17.766, Speaker A: Okay, understood, thank you.
00:14:17.788 - 00:14:33.980, Speaker C: And this is not smart contract specific, again, just like rustrates, or maybe I should say cairo one trades, but at least for now you don't see, other than the attributes which I'm going to talk about, there's nothing stucknet specific.
00:14:34.830 - 00:14:35.850, Speaker A: Understood.
00:14:36.270 - 00:15:41.418, Speaker C: Okay, let's ignore the other contact for now and focus on the interface for the counter contact. So you see that I'm defining here the interface of my contract. So these are my three functions, increase counter, decrease counter, getcounter, similar behavior, they're getting the amount, but you see the additional self argument here. This self argument is basically representing the contract state. I'm using this argument to be able to access storage or emit events, which is the way external functions sort of interact with your contract. So here I'm seeing it explicitly, rather than seeing somewhere in the middle of the function body that I want to write to storage here. If I want to write to storage, I must get the contract state argument, which is a generic argument of this trait by reference.
00:15:41.418 - 00:16:25.920, Speaker C: If I get it by reference, it means it's also modified and returned in the end. And that's again cairo one reference behavior, not contract specific. And by seeing this signature, I know that increased counter wants to modify the state. And the reason this parameter is generic is because I didn't yet define what is my countercontract. This is yet to be defined. What exactly is its state? What storage does it have? But I can define the generic traits, I can still say what it means to be a counter contact. And I see the three functions from before with the additional generic arguments that represents the contact state.
00:16:25.920 - 00:17:15.360, Speaker C: And maybe before I'll stop, I'll just say that you can already see the difference between view and external functions. View functions are just taking a snapshot of this generic type instead of getting it by reference. So when I see this, I know getcounter cannot modify the state because it gets a snapshot of it. And I don't have to look at the function body or count on the attributes view and external, which actually weren't enforced. So you could say, hey, but it's just like this attribute here. But I could have written counter right here, and it's not really nice while here I can't do it.
00:17:16.930 - 00:17:17.438, Speaker A: Interesting.
00:17:17.524 - 00:17:19.200, Speaker C: So I think it's a good point to stop.
00:17:19.650 - 00:17:54.374, Speaker A: Yeah, so there are some questions. So Nicola is saying my concern is about current and existing documentation related to Cairo one. With a mix of both Cairo one compiler version one and Cairo one compiler version two syntax, it will be hard to keep track. I share your concern Nicola. I think we need a better documentation for Cairo. It is something we're working on. And correct me if I'm wrong Ariel and Shahar, but this new syntax change, we're not doing it lightly.
00:17:54.374 - 00:18:28.920, Speaker A: We're not doing it because it's fun, we're doing it because it's useful. And following feedback that came early on from builders, we're shifting this now fast so that we can avoid that problem. There is right now a small body of content about Cairo one. It will be much easier to correct it now and to have only Cairo one version two rather than if we do it in six months. So hopefully the problem you describe will be able to handle it quite easily or at least quite fast.
00:18:30.730 - 00:19:41.760, Speaker C: Maybe just to add something small on what you said, the reason we want to ship it as a peers, to be able to say okay, we're easing off the breaks with the breaking changes. We knew for a while that smart contact syntax changes are upcoming. This was discussed at least on the compiler repository and we knew that we're going to change the old style. And we also knew that there was this feeling in the developer community that hey, maybe I should wait for things to stabilize. So this is it guys. With the recent changes in the contact syntax we're going to make sure that the next steps are not going to be anywhere near as demanding, even though I think we'll see now that these changes are very much self contained. But now with a new syntax, we feel comfortable with recommending you to migrate existing Cairo zero logic to Cairo one.
00:19:42.530 - 00:20:02.306, Speaker A: Yes. All right, so then Gadwood is asking why do we need to specify Starknet double double x? Is it because later we'll be able to do to have something like not Starknet double double x? I'm not sure I understand the question that maybe you guys do.
00:20:02.488 - 00:20:58.358, Speaker C: Okay, so any attribute which is Starknet specific, we wanted to have the Starknet prefix for it. And this is only required outside the contract module. So the logic behind this is okay, in the contract module everything is starknet. So no need to specify it here, but outside the module. When I say okay, this is a counter contact, I need to say that this is a starnet related attribute. And what this attribute does is actually generate a dispatcher for me. So by moving to a standard where the interface of all the contacts defined like this, I can guarantee that external contracts that are interacting with countercontact don't have to write something similar like this, for example.
00:20:58.358 - 00:21:17.930, Speaker C: Instead they can just import this trait or use this trait from my contract, which is published somewhere, and just interact with the existing dispatcher. So basically this attribute generates a dispatcher for me that can be used to interact with a counter contract.
00:21:19.890 - 00:21:22.960, Speaker A: Okay, I think this makes sense. Thank you.
00:21:23.730 - 00:21:25.440, Speaker C: Do you want to add something?
00:21:26.130 - 00:22:20.080, Speaker B: Yeah, the reason we want to add the Starknet column column is for name spacing. I mean, if we look at rust, for example, the things that appear, the attributes are actually real crates or modules that direct to where this plugin exists. And we don't want, especially for the Starcrant plugin to have something that is built in or global, because Starcraft is a kind of extension on top of Cairo one. So if you take ownership of the global name interface or contract, it be a bit too invasive, lead to collision with other plugins. So we feel it's better to namespace these attributes with.
00:22:24.530 - 00:22:55.900, Speaker A: Thank you. So Teomitov is asking, so is it better to start updating libraries now, since now it's like we have six months time frame. Yeah. The answer is yes, you can start moving your code to Cairo one now. You'll be able to deploy it. If you start working on the current version of the compiler. You will have at least six months to deploy it, though probably in four or five months.
00:22:55.900 - 00:23:02.990, Speaker A: You will benefit from updating the compiler and making the small changes, but you won't have to do it at every compiler version.
00:23:05.810 - 00:23:21.838, Speaker C: Just let me say that the syntax we're seeing now is part of v two of the compiler, and that will be deployable on startnet only in twelve, which will come in a few weeks, like three weeks to testnet and one month to main, something in that order of magnitude.
00:23:21.934 - 00:23:31.240, Speaker A: Okay, Robert is asking, can you explain the meaning of v zero in external in the attribute? External v zero?
00:23:31.610 - 00:23:35.862, Speaker C: Yes, but we'll get to it. We still have a bit of.
00:23:35.916 - 00:23:37.590, Speaker A: No spoiler. No spoiler.
00:23:40.270 - 00:23:45.850, Speaker C: Okay. Any more questions about the interface? The generic argument.
00:23:48.030 - 00:23:52.560, Speaker A: Thank you for your answer. He says it's very clear. No other questions now.
00:23:53.250 - 00:24:35.340, Speaker C: Okay, great. Okay, so let's go inside the contract now. Okay. Storage basically unchanged up to the storage attribute, which didn't exist before. In the future this may help us to allow not necessarily calling it storage, but for now this tact has to be named storage and also denoted with the storage attribute. It may allow more flexibility in the future if the community decides is a good idea. Okay, so that's a very minor issue.
00:24:35.340 - 00:25:15.590, Speaker C: Let's skip events and discuss the implementation first. Then we'll go back to events. Okay, constructor, that's new. So basically instead of the constructor name, you just tag the function with a constructor attribute and choose the name for yourself. I think there was an issue that was related to a function called constructor which wasn't meant to be the contact constructor or something like this. It was raised on the compiler repository. Shah, I don't know if you remember what I'm talking about.
00:25:15.590 - 00:25:17.500, Speaker C: Pretty sure that solves it.
00:25:17.870 - 00:25:32.320, Speaker B: No, it's not about solving. If you make a function that's called constructor, but it doesn't have the attribute, it's not a constructor. It needs to have the attribute constructor to be a constructor. That's the point.
00:25:32.770 - 00:26:17.818, Speaker C: Okay, so pretty straightforward, not much difference here. Okay, so let's see the function body and I'll get to the external VZO in a second. So now I'm basically implementing the countercontract trait. And since in kyo one impulse are named, and I will say more about it in a bit, I'm calling it countercontract. And here I need to give it a concrete type, and the concrete type has to be contact state. So what is this type? You don't see a definition for it anywhere. So contact state is generated from the storage you define here.
00:26:17.818 - 00:26:35.486, Speaker C: So basically the contact state type will allow you to access counter, it will allow you to access other contracts, and it will also allow you to emit events. Okay, so that's the instantiation of the generic parameter in the trait.
00:26:35.598 - 00:26:43.940, Speaker B: I just want to say if you have the language server you can control, click contract stated and see the generated code.
00:26:44.970 - 00:26:45.960, Speaker C: Let's see.
00:26:46.890 - 00:26:51.160, Speaker B: Yeah, this is generated code, so you can see what actually goes on inside.
00:26:52.010 - 00:26:53.000, Speaker C: Very interesting.
00:26:53.930 - 00:26:56.280, Speaker B: Okay, close this window now.
00:26:58.030 - 00:27:57.980, Speaker C: Okay, so the function implementations, as you can see, other than the parts that emit events and access storage variables, all the implementation remain the same. And in the signatures, just like in the trait, I need to get the self argument either by reference or a snapshot of contract state. So just like we discussed in the trait, I should also do it for the implementation. And now let's discuss storage accesses and then stop for questions. So if before I did counter column, column read, then now I do it by using self. So I want to read the counter storage variable. So I'm doing self counter read and basically the same for write self counter write.
00:27:57.980 - 00:28:16.050, Speaker C: And yeah, that's pretty much it in regards to changes in accessing storage. So maybe let's check if there are questions before we'll move on to discuss this attribute and then events.
00:28:18.150 - 00:28:27.320, Speaker A: Let me check. There is a question, but it seems like I can't see it. It's kind of weird. Check.
00:28:28.090 - 00:28:29.414, Speaker C: It looks like there is a question.
00:28:29.452 - 00:28:33.240, Speaker A: But I can't read it anyway, no question for now.
00:28:35.770 - 00:29:15.474, Speaker C: Okay, so let's discuss the implement here. So first of all, we don't necessarily have a single implement in the contract. Let's say I wanted to have two different unrelated traits. I want to be both a counter and an ERC 20. Then I could have the ERC 20 trait defined here and have another impel. Where was my impel? Just another impel, also marked as external of the other trait. And it would also add to my external logic.
00:29:15.474 - 00:30:04.130, Speaker C: This would define more ways to interact with my contract. And this is possible today with v two of the compiler, as long as the two different traits don't have collisions in the function names. So if for some reason my rc 20 has get counter function, then I'll get a compilation error, and that has to do with the selectors of the generated function. How do I call the contract? And if two different traits have the same function name? This could be weird when thinking, okay, what do I actually specify in the transaction when I want to call this contract? So at the moment, collision in the names isn't allowed, but you can have multiple impers as long as they're not colliding.
00:30:04.790 - 00:30:17.660, Speaker A: There are two questions here, so contrary cousin is asking, can you explain a bit more about contract state? Not sure what he means by that. Or maybe what a contract state is.
00:30:18.270 - 00:30:54.660, Speaker C: Okay, so think about how in your external function you interact with the contract. If I'm looking at this and I see increased counter only gets an amount and we like fewer functions. We don't like functions with side effects. Then I look at this signature and I see, okay, it gets an amount, it returns nothing. Then I don't know, it's weird that it can affect my contact in any way. But if you see this, you know that it gets the contact state as an argument and also returns it at the end so it can modify it.
00:30:55.030 - 00:31:47.190, Speaker B: Yeah, I want to add that caro one as a language is almost pure, like everything here is pure computation, like a functional language, except for the unfortunate Cisco PTR. So that's why we can have side effects. Because everything that interacts with Cisco PTR is currently implicit. We could think about changing it at the future, but for now we just want to make this side effect explicit in maybe a more fake way using this contract state. So this contract state is supposed to represent other things that can do side effects with Cisco PTR?
00:31:47.850 - 00:32:25.570, Speaker C: Yeah, maybe more words about this. So syscall PTR is what gives me the ability to do syscalls. And in Starknet, syscalls are needed to do anything starknet related. Read from storage, write from storage, emit events, call another contract, do a library call which is analogous to ethereum's delegate call. All these are syscalls, and now I can sort of access them through, or at least the storage part of them through this argument.
00:32:27.350 - 00:32:52.378, Speaker B: Yeah, I would say that in Sierra, Sierra actually doesn't have side effects, and the Cisco pointer is indeed an object there. It's just the car. One high level abstraction makes the passing of Cisco PTR implicit, and that's why it makes these side effects implicit. And that is what we want to avoid here.
00:32:52.544 - 00:32:58.150, Speaker C: If I look at the generated Sierra code of increased counter, I'll see the Cisco PTR argument.
00:32:58.310 - 00:32:59.020, Speaker B: Right.
00:32:59.330 - 00:33:09.246, Speaker C: Okay, very nice, Henry. I don't know if this answered the original question, but I think it does.
00:33:09.428 - 00:33:17.700, Speaker A: Thank you. And then there's an extra comment by saying, oh, a meeting event looks like it's quite cumbersome and long.
00:33:19.830 - 00:33:22.322, Speaker C: Okay, let's get to events in a second.
00:33:22.456 - 00:33:37.926, Speaker A: Okay, country cousin is asking, is there any reason we don't have strings in this update? And with the exception of short strings, why don't we have strings in Cairo? I think the short answer to that is strings are coming. It's just that it takes time to implement them properly.
00:33:38.118 - 00:34:13.860, Speaker C: Yes. So if we had to choose between doing breaking, changes to the contract syntax, which we know are useful, and answer some concerns raised by the community, and we had to choose between this and long strings, then we wanted to do what's breaking as soon as possible to allow devs writing contracts without fear that in the future things will break. So it was definitely a priority over strings, but we will have strings and it is prioritized. So I hope that answers the question.
00:34:14.170 - 00:34:15.640, Speaker A: It does.
00:34:16.890 - 00:35:44.062, Speaker C: Okay, I discussed multiple impers when there's no collision in the names. What if there are collision in the names? Let's say I can imagine that I'm in the same contract, two different types of ERC 20 I can be, for whatever reason, USD and E, and I can't do it with the current syntax, again, because of the collision in the names, which will lead to the functions having the same selector. But in the future, one way to tackle it would be to have something like changing the way that you call a contract by specifying an address and something else which would indicate what impel do you want to access? Do you want to access the if impel, or do you want to access the usb impel? And today there's no way to do it. But basically what this v zero refers to is the selectors of the function. When you write this line above your impel, basically you're saying, hey guys, the get counter function selector, don't ever change it. I want it to be the current selector for the get counter function. So if you write your contract in Cairo and a year from now there's a fancy way to add multiple impels.
00:35:44.062 - 00:36:14.090, Speaker C: If you want it and you didn't want it but you didn't write this line, then suddenly your selectors may change because maybe they now depend on the impel name, for example. And that's very bad because any contract interacting with you will now break and a lot of people can get very sad. So since we're forcing you to write this, you're basically saying, unless you intend to modify your selectors, it won't happen by mistake.
00:36:15.550 - 00:37:04.650, Speaker B: Yeah, I think the v zero means that the selectors are compatible with the old version of the syntax, or Kyra zero, same way of computing selectors as in Kyra zero, just from the function name. And in the future we want to support not just visio, but selectors that depend on other stuff, like the impulse name, for example. To solve the issue you said before, even if I just have two impulse that share a function name, and I want to not have a collision there, even for this case. This is what we want to support in the future, but for now to be compatible with everything, we add v zero just for compatibility.
00:37:06.670 - 00:37:07.420, Speaker C: Okay.
00:37:10.930 - 00:37:20.090, Speaker A: I understand. It's not exactly that. Yeah, okay, makes sense. It specifies how the selector below are constructed.
00:37:20.170 - 00:37:33.410, Speaker C: Yes, basically. Okay, so I hope that answers the person who asked about v zero. And if there are no pending questions, we can move to.
00:37:33.480 - 00:37:41.110, Speaker A: There are a question actually. So someone is asking can I have multiple impulse logs for the same trait interface?
00:37:42.330 - 00:37:46.194, Speaker C: No, because that would in particular have collision in names.
00:37:46.242 - 00:37:50.822, Speaker A: Yeah, okay, right now, but maybe in v one or v two it would change.
00:37:50.956 - 00:37:51.640, Speaker B: Yes.
00:37:52.990 - 00:38:03.818, Speaker A: Then there is confusion about when this update is coming. So this update right now is on the main branch of the Cairo one repo. When is it coming to Starknet?
00:38:03.994 - 00:38:28.418, Speaker C: When you say this, you mean not v one, v two, yes. So it's coming to Starknet. It's already as part of the v two release of the compiler, but it will be available on startnet only as of v twelve, which will come to mainnet in about one month. Testnet before that noise understood.
00:38:28.514 - 00:38:30.600, Speaker A: Cool. So it's part of zero point twelve.
00:38:34.410 - 00:39:25.906, Speaker C: Okay, so events, events, okay, so we define the event enum and mark it with this event attribute. Here we basically define all the possible events of our contract. And every event has a type. So the variants are the event name. And actually, just like in Kyle Zero, this name will induce a key in the emitted event. So for those who don't know, an event in statnet consists of an array of keys and an array of data elements. This is analogous to solidity's index keyword.
00:39:25.906 - 00:40:31.050, Speaker C: So basically everything that you desire to be indexed goes under keys, and everything that you don't care about being indexed by full nodes goes under data. And just like in the old syntax, not this, just like in the old syntax, this name eventually became a key of the event. Then here the variant name is also a key of the emitted event. Once you actually emit this event, and every event has a type at the moment. In this version, we force that the type of the event is a struct of the same name as the variant key counter increase twice. Here it's the name of the variant which induces the key in the emitted event. And here you see the type of the event, which in this case has a single variable which is 128 bits integer.
00:40:31.050 - 00:40:38.110, Speaker C: Okay, question Shah, you want to add something?
00:40:38.260 - 00:41:41.874, Speaker B: Yes, I would like to add things about events. Okay. The change here basically is that now the event of a contract is its own type. And why is it good? First of all, it helps with safety, with ensuring that you can only emit your type of event. The self dot emit function accepts this specific type, the event type of your contract. And this basically enforces that you only emit these kinds of events that you don't, by mistake call some other contract function that emits some other event that you didn't plan on. Another benefit of having it in a type is being able to in your tests, for example, to test your events, to check all the events that are written and get them as instances of your type, the enum event.
00:41:41.874 - 00:42:26.978, Speaker B: And then you can easily check what happened there, or maybe even other kinds of integrations. Okay, so basically it's a generalization that makes the event of the contract a type, and it can actually be any type if we dig deep closer. There is a trait called starknet event, which basically determines what an event needs to implement in order to be an event, which is basically just to be able to say, these are my keys and values in the other direction, given keys and values to bring back the event itself.
00:42:27.144 - 00:42:29.426, Speaker C: Well, can I find the event rate?
00:42:29.608 - 00:42:39.910, Speaker B: It's in the colib. I don't think you have access to the colib here. It's in events.
00:42:45.610 - 00:42:50.506, Speaker C: Probably this neither. No, never mind, never mind.
00:42:50.608 - 00:43:54.986, Speaker B: Yeah, it's in the core, but we don't have access to it here. Okay. Yeah, so I think it's also kind of similar to the storage we have. The storage is also a single type, in a sense, that holds together all the members. And this gives you another kind of safety and event in a similar way gives you safety, and it's very generalized. Right now, like Ariel said, you need to write your event in a very specific way, where the event is an enum and each variant is a struct events. Can you specify the keys and values? And this is in order to be compatible with how events look in the old syntax, or Cairo zero, basically just have a flat list of events.
00:43:54.986 - 00:44:32.620, Speaker B: Each one has a specific list of arguments or inputs. But like with the V zero and V one change in the future, we can extend on this and let you do maybe crazier things with event. The event doesn't have to be an enum. The nested variants don't have to be struck. They can be maybe nested enums, maybe events of other contracts, if you want to encapsulate events of subcomponents and things like that. This is in the coming future.
00:44:33.310 - 00:45:16.870, Speaker C: Yeah. So let me add a bunch of stuff. So the reason to change it in this way now is that we can do it in a way that we can generalize it in a non breaking manner in the future. So part of the wild stuff that Shahar mentioned is maybe I can somehow get the events of a different contract by writing them explicitly here. So I will choose a variant name, but the type will be the event type defined somewhere else. And in that way I'm able to emit nested events in a way. But right now this structure basically fits very well in the previous structure of events.
00:45:16.870 - 00:46:19.694, Speaker C: But again, regarding the self dot emit function, getting expecting this type, then we didn't see how to emit events yet, but you use contact state, which you get by reference to emit an event. And here it's expecting one of the variants of the event. Inam. And that syntax is just a regular initialization of one of the events variants. So I need to specify the name and to give it an instance of let's go back to the event, the counter increase type which is defined here. Okay? And some of the things that you can already do now that you couldn't do with the previous syntax is to control the keys and values the keys and data elements of the event. So let's say I want this amount indexed for some reason.
00:46:19.694 - 00:47:07.660, Speaker C: Then in the old syntax there was no way to do it. We didn't have something like the index keyword and no, I wanted this. So everything here would be considered as data. You had one key which corresponds to the name, and all the arguments here were emitted as data. But now let's go back thanks to this trait which basically specifies how the event is serialized, I can use this new attribute, and by writing this I'm basically saying amount is a key. I do want it indexed and emit it as part of the event keys. And maybe I have another field which is not a key, whatever address.
00:47:07.660 - 00:47:33.300, Speaker C: And it's whatever contract address, okay? And in that case only amount will be indexed. So that's something I was not able to do with the old syntax and I can do now, thanks to this trait, which allows me to control how the event type is serialized into an array of keys and an array of data.
00:47:36.090 - 00:47:36.546, Speaker A: Sweet.
00:47:36.578 - 00:47:40.262, Speaker C: So I think it's a good time to see if there are more questions.
00:47:40.316 - 00:47:41.320, Speaker A: Yeah, there are some.
00:47:45.930 - 00:47:46.390, Speaker C: Wait.
00:47:46.460 - 00:47:54.762, Speaker A: Actually Gaeton removed his question. He was asking if it was possible to test events in Cairo tests, but.
00:47:54.816 - 00:47:59.180, Speaker C: I guess he wanted to remove his. I think it is possible. Now.
00:48:02.850 - 00:48:08.254, Speaker B: Let'S see. I think it was merged like yesterday. Today, yes, it's possible to test.
00:48:08.372 - 00:48:17.890, Speaker A: Nice. Then Robert is asking internal function remain unchanged? I'm asking because open zeppelin add internal and private in one of their Cairo repos.
00:48:20.390 - 00:48:43.034, Speaker C: Yes. So Shah, correct me if I'm wrong, but internal functions are basically unchanged and you see that they're internal by them being defined not in the impel marked as external. I can just write them inside the contract module, but not under this impel. And I can call them from here.
00:48:43.152 - 00:48:57.600, Speaker B: Yeah, internal functions probably need to get self or snapshot contract state or snapshot contract state just so that you can read and write to the storage, but nothing other than that.
00:48:58.210 - 00:49:01.280, Speaker C: So what you're saying is something like this.
00:49:04.310 - 00:49:14.760, Speaker B: Yes, but I would recommend putting them inside an impel because then you could access them as methods on self, which is nice.
00:49:15.610 - 00:49:31.900, Speaker C: So impel giving it the very bad name. Private functions of traits that I'm not going to define now and sorry about you can do this generate trait, very nice.
00:49:33.150 - 00:49:36.250, Speaker B: Private section trait. And do the generate trait.
00:49:36.990 - 00:49:38.122, Speaker C: What's the name?
00:49:38.256 - 00:49:49.760, Speaker B: Generate, generate and put the name of your job, private section treat. Implement private section of private section treat.
00:49:50.450 - 00:50:29.470, Speaker C: Very nice private section trait. Okay. And then I can do inside get counter self private section like this. Very nice. Okay. It doesn't return a counter so it's mad, but I don't care about it compiling. So you're saying I can just throw it and have it outside the impel, but by writing it in an impel I can access those private functions by having self dot something.
00:50:29.620 - 00:50:30.320, Speaker B: Yes.
00:50:30.690 - 00:50:38.922, Speaker C: And I don't have to write a separate trait for it. I can just use this fancy attribute.
00:50:39.066 - 00:50:39.760, Speaker B: Yes.
00:50:41.190 - 00:50:48.740, Speaker C: And maybe you want to say why I probably don't want to use this attribute for the main contact.
00:50:50.230 - 00:51:34.740, Speaker B: Yeah, this icounter contract, it's a contract interface that you probably the reason you wrote it is so that other contracts can use it and called your contract through it. This is the reason you made it an interface. And that's why it's better for it to be explicit in some other commonplace. So that other contracts can use your crate as a package, as a scar package, and just import this trait in their project instead of writing it on their own. So you probably want it somewhere else, somewhere exported somewhere that other people can use.
00:51:35.670 - 00:52:44.374, Speaker C: Okay, so if I wrote a nice contract and I created a scalp package, then by having the interface explicitly defined with this attribute, anyone else can just import it and nicely interact with my contact and not have to redefine it and maybe only define it partially because he only calls decrease counter and not increase. Yes. Okay, so I think we've covered everything. We talked about storage, we talked about the new self argument, the contact state, the trait versus the impel, the weird v zero attribute for future compatibility with many impels that will allow collision in names, private functions and events. And looks like we also managed to do it on time, which is rather impressive. But Henry, now the floor is yours to attack me with. Further question or.
00:52:44.412 - 00:52:56.986, Speaker A: Shahar, I think this was pretty exhaustive, honestly. And I don't see any more questions, so I think I just see people putting art. So I guess that's good, right?
00:52:57.168 - 00:53:00.922, Speaker B: Yeah, if I can add one more sentence.
00:53:01.066 - 00:53:01.920, Speaker C: Of course.
00:53:02.450 - 00:53:54.542, Speaker B: This is part of trying to make starknet or developing contracts on top of Starknet a lot more structured and safe to make sure we don't do weird stuff. Caravan zero was very low level. Also in programming and in the way you define contracts, and you can do a lot of mistakes, call functions that don't exist, with types that don't match. So with the power of Cara one, we want to enforce as much as possible that everything is correct, that your interfaces are correct, that you explicitly defined everything that you have in storage, and you don't write to other places, you didn't explicitly define an events as well. And there are also other province we can do upon it in the future. All kinds of features, but these were.
00:53:54.596 - 00:53:56.078, Speaker C: In a very non breaking way.
00:53:56.164 - 00:54:00.862, Speaker B: Non breaking way, definitely. Please write chiro one. Thank you.
00:54:00.996 - 00:54:03.234, Speaker C: Just look at this beautiful type.
00:54:03.432 - 00:54:51.198, Speaker A: Yes, it's amazing. Cool. Well, I see a lot of thoughts was put into that, and it's really good to see Carawan evolving like that. I think the guarantees for compiler lifetime is a pretty strong argument for people to start to move, and I know that a lot of people were blocked by this syntax. So I feel pretty confident that a lot of people will start moving soon, if for no other reason, that everybody's talking about car one and how exciting it is. So I guess everyone want to try to give it a spin, which I all encourage you to do. All right, Shahar, Ariel, thank you for your time, and I'll see you on the next breaking change in two weeks.
00:54:51.284 - 00:54:51.994, Speaker C: No, I'm kidding.
00:54:52.042 - 00:55:07.880, Speaker A: That's fun. I guess I'll see you. We'll talk about zero point twelve soon, or further improvement to starknet, and if there are enhancement to the Cairo syntax, once people can leverage this without breaking changes, be happy to have you again.
00:55:08.330 - 00:55:10.040, Speaker B: All right, thank you very much.
00:55:10.730 - 00:55:12.034, Speaker C: All right, bye.
00:55:12.082 - 00:55:13.538, Speaker A: Have a good day. Bye.
