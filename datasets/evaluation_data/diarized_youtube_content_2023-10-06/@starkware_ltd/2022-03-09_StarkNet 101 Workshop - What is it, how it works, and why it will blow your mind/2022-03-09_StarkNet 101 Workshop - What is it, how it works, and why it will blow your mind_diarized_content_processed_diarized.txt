00:00:10.090 - 00:00:14.906, Speaker A: Hi everyone, my name is Henry. I work at Sparkware and today we're.
00:00:14.938 - 00:00:24.042, Speaker B: Going to be talking about Spark net. And more generally we're going to be talking about L2s and ek rollouts, availability rollouts.
00:00:24.186 - 00:00:27.094, Speaker A: So we actually have two workshops this.
00:00:27.132 - 00:00:28.898, Speaker B: Week here in Denver.
00:00:29.074 - 00:00:30.934, Speaker A: The first one today we're going to.
00:00:30.972 - 00:00:39.210, Speaker B: Talk generally about ZP rollups, why they're different, how they work, what they can offer to you as a developer.
00:00:39.710 - 00:00:44.490, Speaker A: And I'm going to show you a small tutorial to get a feel of.
00:00:44.560 - 00:00:49.078, Speaker B: How it is to develop and write on startm.
00:00:49.254 - 00:00:52.510, Speaker A: Then on Thursday we'll have another workshop.
00:00:53.090 - 00:00:55.280, Speaker B: It's at nine in the morning, so.
00:00:55.730 - 00:00:59.614, Speaker A: Either don't sleep and come straight away or don't go too late at night.
00:00:59.652 - 00:01:02.000, Speaker B: On Wednesday I'll be watching you.
00:01:02.930 - 00:01:04.302, Speaker A: This one will be a bit more.
00:01:04.356 - 00:01:06.720, Speaker B: Applied, so do come with a computer.
00:01:07.090 - 00:01:09.026, Speaker A: Make sure if you can set it.
00:01:09.048 - 00:01:22.440, Speaker B: Up before so that you'll be able to start coding right away. That would be great, but the objective for that workshop would be for you to create and mint nfts on start. So if you want to go give your thought on the first day.
00:01:26.090 - 00:01:26.418, Speaker C: I'm.
00:01:26.434 - 00:01:29.154, Speaker A: Going to send them to you afterwards.
00:01:29.282 - 00:01:30.680, Speaker B: But you'll find them on.
00:01:31.290 - 00:01:31.990, Speaker C: Cool.
00:01:32.140 - 00:01:45.038, Speaker A: So I'm Henry, I work at Startan and my job is developer advocate. My job is to explain what is Starknet, what you can do with it, and how you can get a hold of it.
00:01:45.204 - 00:01:48.350, Speaker B: Let's make a smaller show of hand here.
00:01:48.420 - 00:01:52.830, Speaker A: So who here has already interacted with Ethereum?
00:01:54.070 - 00:01:55.138, Speaker C: Right, fair enough.
00:01:55.224 - 00:01:59.540, Speaker B: Who has ever written a smart contract? Very cool.
00:01:59.990 - 00:02:04.820, Speaker A: Who has ever interacted with a L2 in general?
00:02:05.130 - 00:02:05.590, Speaker C: Nice.
00:02:05.660 - 00:02:07.894, Speaker B: Most of you who has interacted with.
00:02:07.932 - 00:02:21.850, Speaker A: A L2, but it was not performing good. Pretty cool. Okay, who here is aware of Starknet? Very cool. Who here has done the Starknet 101 tutorial?
00:02:22.350 - 00:02:23.146, Speaker C: Nice.
00:02:23.328 - 00:02:30.086, Speaker A: Very cool. So for those of you who are here who already did the tutorial, I think the first part of the presentation.
00:02:30.118 - 00:02:32.654, Speaker B: I'll be talking, you learn a bunch of stuff.
00:02:32.852 - 00:02:36.186, Speaker A: For the second part, if you want to go further, you can get straight.
00:02:36.218 - 00:02:38.410, Speaker B: Away on the following tutorial.
00:02:38.570 - 00:02:39.374, Speaker C: Cool.
00:02:39.572 - 00:02:44.718, Speaker A: So let's start with the beginning. Why ZK wallets?
00:02:44.894 - 00:02:56.290, Speaker B: Why are they interesting and what do they allow? Let's start with this first basic possibility. Why do blockchain sucks today? Right?
00:02:56.360 - 00:03:03.538, Speaker A: It's 2022. This technology has been around for 1015 years and yet we can't get scale.
00:03:03.714 - 00:03:12.406, Speaker B: Alipay is able to scale. Visa is able to scale. PayPal is able to scale. Why can't blockchain scale.
00:03:12.598 - 00:03:20.890, Speaker A: Well, it all comes down to the security postulate of this network.
00:03:21.050 - 00:03:27.562, Speaker B: The way the world at large works in general for securing assets is the following.
00:03:27.626 - 00:03:44.130, Speaker A: You have one set of trusted parties who care for the ledger, right? And their job is to maintain the ledger, secure it. For a very long time, it has been in books behind big walls with men in swords in front of them. Now it's in data centers with name.
00:03:44.200 - 00:03:47.714, Speaker B: With assault rifle in front of them.
00:03:47.832 - 00:03:48.882, Speaker A: To keep them safe.
00:03:48.946 - 00:03:49.510, Speaker C: Right.
00:03:49.660 - 00:03:52.918, Speaker A: The big advantage of this is that it scales pretty well.
00:03:53.004 - 00:03:53.350, Speaker C: Right.
00:03:53.420 - 00:03:54.790, Speaker A: You can just throw a bigger computer.
00:03:54.860 - 00:04:01.162, Speaker B: At the problem and you can do a lot of. How do blockchains work?
00:04:01.296 - 00:04:04.902, Speaker A: They're a bit different in the sense that you don't have a single party.
00:04:05.046 - 00:04:09.698, Speaker B: Doing all the transactions and executing and maintaining the ledger.
00:04:09.894 - 00:04:31.422, Speaker A: Every single participant of the network has to maintain the ledger. So every single participant of the network has to re execute and recompute everything in the network. We often say that blockchains are distributed systems. They're not distributed systems, they're replicated systems.
00:04:31.486 - 00:04:31.954, Speaker C: Right.
00:04:32.072 - 00:04:35.540, Speaker B: You don't split the workflow between everyone.
00:04:36.070 - 00:04:40.246, Speaker A: Everyone does the exact same thing. There's a lot of redundancy and you.
00:04:40.268 - 00:04:43.446, Speaker B: Get the feel instinctively why blockchains are expensive, right?
00:04:43.548 - 00:04:46.518, Speaker A: It's more expensive when you have 10,000.
00:04:46.604 - 00:04:53.946, Speaker B: People doing the same work rather than when you have one person doing the same work. Very easy, right?
00:04:54.048 - 00:04:59.786, Speaker A: If this work costs you a bit of money, then if it costs money to 10,000 people, it's more expensive than.
00:04:59.808 - 00:05:02.078, Speaker B: If it costs money to just one person.
00:05:02.244 - 00:05:03.214, Speaker C: All right?
00:05:03.412 - 00:05:36.006, Speaker A: So the issue we have today is this, is that we have inclusive accountability in the blockchain. Everyone verifies everything, but it's expensive and it's low. And why exactly? I like this slide better. So the main reason you can't scale a blockchain network the same way you.
00:05:36.028 - 00:05:39.450, Speaker B: Would scale, for example, a bank network.
00:05:40.110 - 00:05:44.390, Speaker A: Is that if you raise the workload.
00:05:44.550 - 00:05:51.386, Speaker B: Of a network, any network, whether it be a bank network or a blockchain network, the person who will compute the.
00:05:51.408 - 00:05:59.182, Speaker A: Ledger has to have a bigger computer. So when it's one computer, it's fine and it's in a big data center and they get money from it, so.
00:05:59.316 - 00:06:00.574, Speaker B: They can afford it.
00:06:00.692 - 00:06:06.946, Speaker A: If you want every person at home to be able to process all of Visa's network, then everyone has to have.
00:06:06.968 - 00:06:14.020, Speaker B: A very big machine at home. This obviously doesn't work, so we can't do that in the blockchain world.
00:06:14.550 - 00:06:19.510, Speaker A: One of the first attempts at scaling was basically saying that.
00:06:19.580 - 00:06:24.754, Speaker B: Right, let's just augment the throughput of the network and increase the scale.
00:06:24.802 - 00:06:32.426, Speaker A: Let's increase the block size. Let's increase the gas limit, which basically boils down to each participant of the.
00:06:32.448 - 00:06:34.346, Speaker B: Network should get a bigger computer.
00:06:34.528 - 00:06:45.306, Speaker A: But this never ends. You'll never be able, for your blockchain network, to have every participant operate the same kind of machines that Visa operates.
00:06:45.418 - 00:06:45.982, Speaker C: Right?
00:06:46.116 - 00:06:49.902, Speaker A: So automatically, if you choose this road.
00:06:50.036 - 00:06:51.278, Speaker B: You'Re going to exclude people.
00:06:51.364 - 00:06:53.886, Speaker A: You're going to exclude smaller people, smaller.
00:06:53.918 - 00:06:56.990, Speaker B: Players who can't afford to run a big machine.
00:06:57.150 - 00:07:15.074, Speaker A: So, for example, do you know any network who chose that solution? Increase the scale. Increase the block limit. Increase the gas limit. Sorry. Bitcoin cash. Yes, sure. They were the first to very explicitly make that choice.
00:07:15.074 - 00:07:16.200, Speaker A: Any over.
00:07:17.470 - 00:07:21.626, Speaker B: I'm sorry, BSC, of course. Solana also.
00:07:21.808 - 00:07:24.454, Speaker A: And basically, you get into a network.
00:07:24.502 - 00:07:26.810, Speaker B: Where it's expensive to operate the network.
00:07:27.150 - 00:07:30.102, Speaker A: It might be beneficial to you, right?
00:07:30.176 - 00:07:31.002, Speaker B: But it's expensive.
00:07:31.066 - 00:07:34.014, Speaker A: So automatically, you exclude players who may.
00:07:34.052 - 00:07:38.366, Speaker B: Want to figure out what is happening in the system.
00:07:38.468 - 00:07:44.450, Speaker A: And for these smaller players, their only solution is to trust the big players.
00:07:45.910 - 00:07:53.620, Speaker B: With the information that is being given to them. They don't have the capacity to re execute everything.
00:07:54.710 - 00:07:59.922, Speaker A: And where's ethereum on that balance? Right, so bitcoin made the radical choice.
00:07:59.986 - 00:08:06.278, Speaker B: Of having the smallest blockchain possible, just basically freezing it in time.
00:08:06.364 - 00:08:10.166, Speaker A: Their target is probably that within a few years, you'll be able to operate.
00:08:10.198 - 00:08:12.586, Speaker B: The bitcoin blockchain from your phone.
00:08:12.768 - 00:08:13.594, Speaker C: Interesting.
00:08:13.792 - 00:08:17.162, Speaker A: Ethereum has aimed more or less at.
00:08:17.216 - 00:08:24.958, Speaker B: Having you being able to operate a node from your computer. Okay, it's a trade off, something different.
00:08:25.124 - 00:08:45.006, Speaker A: But still, it's pretty accessible. Okay, so what other strategy do we have? We could have fraud proof roll ups. Fraud proof roll ups are a bit different in the sense that you still rely on big computers to process the network and give you a correct output. But this time, if they try to.
00:08:45.048 - 00:08:47.206, Speaker B: Screw you, you have recourse, you can.
00:08:47.228 - 00:08:48.230, Speaker A: Do something about it.
00:08:48.300 - 00:08:48.918, Speaker C: Right.
00:08:49.084 - 00:09:02.838, Speaker A: If your bank messes up accounting on your bank account, your recourses are legal, but they take time. They don't scale very well, and they're very limited in terms of geography.
00:09:02.934 - 00:09:03.338, Speaker C: Right?
00:09:03.424 - 00:09:07.638, Speaker A: So you don't have that much resources. With proof roll ups, you have a recourse.
00:09:07.734 - 00:09:09.754, Speaker B: If they try to cheat, you can.
00:09:09.792 - 00:09:11.546, Speaker A: Always go to the blockchain and say.
00:09:11.568 - 00:09:13.326, Speaker B: Hey, these guys try to screw me.
00:09:13.428 - 00:09:17.438, Speaker A: Please give me back my money. It works well up to a certain.
00:09:17.524 - 00:09:18.160, Speaker C: Point.
00:09:19.890 - 00:09:21.600, Speaker B: But it works, right?
00:09:22.550 - 00:09:25.330, Speaker A: And now I'm going to explain how.
00:09:25.400 - 00:09:29.234, Speaker B: We solve this problem, right?
00:09:29.432 - 00:09:37.334, Speaker A: The way we solve it is. So I just want to underline something here in the part on the right.
00:09:37.452 - 00:09:39.314, Speaker B: With fraud proof roll ups.
00:09:39.442 - 00:09:42.322, Speaker A: All the participants in the network don't.
00:09:42.386 - 00:09:44.598, Speaker B: Do all the calculations, right?
00:09:44.684 - 00:09:46.770, Speaker A: They don't compute all the transactions.
00:09:46.930 - 00:09:52.150, Speaker B: They just trust that all these transactions are done correctly because of game theory.
00:09:52.230 - 00:09:52.810, Speaker C: Right.
00:09:52.960 - 00:09:59.610, Speaker A: But the guarantee they have on the validity of these transactions are still based on game theory.
00:10:01.570 - 00:10:05.066, Speaker B: What validity proofs are, or ZK rollouts.
00:10:05.098 - 00:10:10.254, Speaker A: Are, are basically a novel piece of cryptography, which I'm going to explain very.
00:10:10.292 - 00:10:13.890, Speaker B: Briefly in a bit, which allow you.
00:10:13.960 - 00:10:25.814, Speaker A: To collapse a certain amount of computation down to what we call the ZK proof. And this ZK proof basically assures you.
00:10:25.852 - 00:10:32.738, Speaker B: That some computation was done correctly without you having to do the computation.
00:10:32.914 - 00:10:38.122, Speaker A: So now we have a network that is a bit different. You have different players, you still have.
00:10:38.176 - 00:10:41.482, Speaker B: Big players that concentrate a lot of.
00:10:41.536 - 00:10:48.362, Speaker A: The network capacity that operates for everyone. But you have a mathematical guarantee that.
00:10:48.416 - 00:10:56.590, Speaker B: Everything they did was according to rules. It's not trust, it's not legal. It's mathematics, very simple.
00:10:56.740 - 00:11:00.974, Speaker A: It's either true or it's not true. And the beauty of it is that.
00:11:01.092 - 00:11:10.100, Speaker B: These proofs can be verified by Ethereum. I'm going to get into that. So what are proofs exactly?
00:11:13.190 - 00:11:20.598, Speaker A: I won't go deep into how words, but you should assume it's a new.
00:11:20.684 - 00:11:23.026, Speaker B: Type of cryptographic primitive.
00:11:23.138 - 00:11:23.606, Speaker C: Right.
00:11:23.708 - 00:11:40.426, Speaker A: If I talk about ashes, you all have in your head that ashes are sort of a digital fingerprint. And if I put some data in and out, I'm going to get a very specific ash that is unique to the data that comes in and so on. Right. But you don't all necessarily understand how.
00:11:40.448 - 00:11:42.634, Speaker B: Ashes work, or you don't remember it.
00:11:42.672 - 00:11:46.062, Speaker A: And that's fine, it's okay to use it. I want you to have the same.
00:11:46.116 - 00:11:49.310, Speaker B: Reasoning with computational proof.
00:11:50.450 - 00:12:01.666, Speaker A: A proof is basically a way for you to tell somebody I did this amount of computation. Here is a proof for it, with the proof being field of data.
00:12:01.768 - 00:12:02.274, Speaker C: Right.
00:12:02.392 - 00:12:08.694, Speaker A: And this person can take this field of data, he can take the initial instructions of the program and verify that.
00:12:08.732 - 00:12:14.520, Speaker B: Yes, the result you gave to him or her is correct.
00:12:16.250 - 00:12:28.474, Speaker A: And the cool thing is that it takes you less work to verify approved than it takes you to generate, to actually execute the program.
00:12:28.592 - 00:12:29.018, Speaker C: Right.
00:12:29.104 - 00:12:32.910, Speaker A: So the example I like we can take is a bit of proof of work.
00:12:32.980 - 00:12:33.502, Speaker C: Right?
00:12:33.636 - 00:12:35.470, Speaker A: Proof of work is an elegant design.
00:12:35.540 - 00:12:37.230, Speaker B: Where you can prove that some work.
00:12:37.300 - 00:12:40.350, Speaker A: Has been done without the person having.
00:12:40.420 - 00:12:41.678, Speaker B: To redo a lot.
00:12:41.764 - 00:12:52.750, Speaker A: So for example, if I want 1000 calculations to be done to find a specific hash, I can give you the hash, and you'll be able to verify.
00:12:52.830 - 00:12:55.426, Speaker B: That, yes, this hash was done on.
00:12:55.448 - 00:12:58.022, Speaker A: Average by doing 1000 computations without you.
00:12:58.076 - 00:12:59.794, Speaker B: Having to do the thousand computations.
00:12:59.922 - 00:13:02.934, Speaker A: Well, ZK proof are sort of similar.
00:13:03.132 - 00:13:03.926, Speaker C: Okay.
00:13:04.108 - 00:13:17.290, Speaker A: The way they work is basically this. You get what we call approver, an entity that will receive the computational payload, execute everything, then generate a proof of execution.
00:13:17.870 - 00:13:20.510, Speaker B: That proof of execution and the result.
00:13:20.580 - 00:13:23.166, Speaker A: Of the execution is then sent to.
00:13:23.188 - 00:13:25.370, Speaker B: A person called the verifier.
00:13:25.530 - 00:13:37.090, Speaker A: And the verifier can verify that? Yes, when executing this program, I indeed got this result, and there is no way I could have executed the program.
00:13:37.160 - 00:13:39.780, Speaker B: Differently to generate that result.
00:13:40.710 - 00:14:03.114, Speaker A: And the very basic primitive with that, that is really cool is that all of a sudden, you don't need everyone to compute everything in order to get to a common state of affair. If you have notes today, all have to execute all the transactions in order.
00:14:03.152 - 00:14:04.426, Speaker B: To get to a common state.
00:14:04.528 - 00:14:05.130, Speaker C: Right?
00:14:05.280 - 00:14:20.590, Speaker A: Now, all of a sudden, you can have one person executing a shitload of transaction, sending, approved, sending the state of date, and say, hey, look, this is the new state of the system. There's no way I could have cheated. And then everyone can just say, yeah, this is the new state.
00:14:20.660 - 00:14:22.240, Speaker B: I don't need to do all the work.
00:14:22.690 - 00:14:32.114, Speaker A: So first you eliminate a lot of redundant work, and now you can specialize. Instead of having everyone do all the computation, you can have just a few.
00:14:32.152 - 00:14:34.798, Speaker B: Entities do all the computations for everyone.
00:14:34.984 - 00:14:37.686, Speaker A: And still everyone benefiting from having one.
00:14:37.788 - 00:14:40.680, Speaker B: Common state of the world.
00:14:41.690 - 00:14:44.358, Speaker A: Okay, so that's basically how it works.
00:14:44.444 - 00:14:46.280, Speaker B: On Ethereum today.
00:14:48.250 - 00:14:49.046, Speaker A: We have a layer.
00:14:49.078 - 00:14:52.634, Speaker B: Two that executes some computational work that.
00:14:52.672 - 00:14:54.666, Speaker A: Generates a proof, and this proof is.
00:14:54.688 - 00:14:56.214, Speaker B: Then sent to Ethereum.
00:14:56.342 - 00:15:20.434, Speaker A: I mentioned this briefly earlier, but something that's really cool is that Ethereum has opcodes that allows it to verify a computational proof. And that's an extremely important primitive because it's not just us generating a proof and you verifying it and you saying to Ethereum, yeah, I verified it, it's fine.
00:15:20.552 - 00:15:26.498, Speaker B: No ethereum native beacon understands that proof is authentic.
00:15:26.594 - 00:15:30.850, Speaker A: There's no middleman between Starknet and Ethereum.
00:15:30.930 - 00:15:32.950, Speaker B: When it comes to authenticity.
00:15:34.170 - 00:15:40.570, Speaker A: It's a bit like an example I like to take is in the evolution of blockchains.
00:15:41.070 - 00:15:47.818, Speaker B: You have various new blockchains emerged, right? We had bitcoin, then we had Ethereum that could do new stuff.
00:15:47.984 - 00:15:51.302, Speaker A: And it's really cool when you get to use bitcoin on Ethereum.
00:15:51.366 - 00:15:53.218, Speaker B: It would be great if you could do the opposite.
00:15:53.254 - 00:15:54.814, Speaker A: But it's really cool that you are.
00:15:54.852 - 00:15:57.578, Speaker B: Able to use bitcoin, the asset on Ethereum.
00:15:57.674 - 00:15:58.126, Speaker C: Right.
00:15:58.228 - 00:16:17.626, Speaker A: How do we do it today? Basically, there is no way for bitcoin and Ethereum to talk, so we have to have humans who translate between Ethereum and bitcoin. Specifically we have Bitglow that receive bitcoin on the alpha view on bitcoin and then send them to you as ERC 20 on Ethereum.
00:16:17.678 - 00:16:20.200, Speaker B: And you have wrap BDC, right?
00:16:20.730 - 00:16:23.382, Speaker A: Well, most l ones work that way.
00:16:23.436 - 00:16:25.686, Speaker B: Most bridges work that way.
00:16:25.868 - 00:16:39.094, Speaker A: We make sure that the people in the middle are not misbehaving by having them take some money, by having them do whatever complicated group where we're reasonably sure they're not going to cheat.
00:16:39.222 - 00:16:43.390, Speaker B: But still we have humans between chains doing the translation.
00:16:43.730 - 00:17:02.066, Speaker A: With this basic primitive, you don't need them. You can have Starknet talk directly to Ethereum and Ethereum talk directly to Starknet. That's very powerful. Basically eliminate some intermediaries from your network. I'm personally excited and really interested to.
00:17:02.088 - 00:17:05.140, Speaker B: See what kind of applications will emerge from that.
00:17:06.550 - 00:17:09.934, Speaker A: Okay, so that's for a theory of ZK proofs.
00:17:09.982 - 00:17:13.720, Speaker B: Then I'm going to talk a bit about the application. Do you have questions?
00:17:14.170 - 00:17:16.498, Speaker A: You don't have to wait until the end. If you have questions, you can raise.
00:17:16.514 - 00:17:19.000, Speaker B: Your hand and I'll be more than happy to answer, yes, please.
00:17:26.830 - 00:17:43.294, Speaker A: So the question is, how do we manage proof sizes? Well, the cool thing about stark proofs is that the size of the proof you generate scales logarithmically with the amount.
00:17:43.332 - 00:17:45.166, Speaker B: Of computation you make, right?
00:17:45.268 - 00:17:50.402, Speaker A: So the more computation you make, the bigger your proof, but it augments less fast.
00:17:50.456 - 00:17:50.674, Speaker C: Right?
00:17:50.712 - 00:17:52.414, Speaker A: So it means that the more transaction.
00:17:52.462 - 00:18:00.646, Speaker B: The more, the less the cost per transaction. But still, you still need this proof to be validated by Ethereum. Well, it's just like how do you.
00:18:00.668 - 00:18:05.846, Speaker A: Manage your transactions in your smart contract to not be too big to be.
00:18:05.868 - 00:18:06.754, Speaker B: Entered in the blockchain?
00:18:06.802 - 00:18:07.894, Speaker C: You monitor them, right?
00:18:07.932 - 00:18:16.906, Speaker A: And you batch them. If you have to do 100 calculations and 100 doesn't work in Ethereum. If you're limited to 50, then you.
00:18:16.928 - 00:18:19.626, Speaker B: Split it in batches of 40, 40 and 20.
00:18:19.728 - 00:18:28.862, Speaker A: We basically do the same. Once our proof becomes too big, we send it to l one and we're done with it. Does that make sense?
00:18:28.996 - 00:18:29.680, Speaker D: Yeah.
00:18:31.330 - 00:18:32.080, Speaker B: So.
00:18:36.630 - 00:18:45.842, Speaker A: What kind of limitations are introduced in terms of scale, you mean? Yeah, I think right now this primitive.
00:18:45.906 - 00:18:49.702, Speaker B: Is too new for us to really know where the limit is.
00:18:49.836 - 00:18:58.874, Speaker A: And we actually have in theory, a bunch of tools that can enable you to imagine skills that are just like.
00:18:58.992 - 00:19:01.180, Speaker B: Hard to wrap your head around.
00:19:01.790 - 00:19:38.806, Speaker A: Basically today, the way it works, the proof we generate is interpretable by Ethereum, but in the framework we use to generate the proof, we can't validate other kind of proofs. Right, but this is something that we know we can solve, that we're working on. This means that within the next six months, you'll be able to operate a starknet instance, generate a proof, and validate it on startnet. So all of a sudden you get layers upon layers upon layers of potential networks that can verify each other.
00:19:38.908 - 00:19:44.534, Speaker B: And this all is compressed and condensed to Ethereum l one.
00:19:44.652 - 00:19:51.274, Speaker A: So the limit to scaling is really not the cryptography. Maybe it's more computational. We don't know yet.
00:19:51.312 - 00:19:54.650, Speaker B: The truth is we're scratching the surface on this.
00:19:54.800 - 00:19:58.794, Speaker A: I think the main limitation we have.
00:19:58.832 - 00:20:03.018, Speaker B: Today, but it's a temporary one, is adoption.
00:20:03.194 - 00:20:23.906, Speaker A: How do you move people away and developers who are comfy using the EVM, who know a specific smart contract language and who are used to somehow make compromises with decentralization or with security, how do you say, hey, this is interesting.
00:20:24.008 - 00:20:27.400, Speaker B: You can go much farther with it and jump on the train?
00:20:29.210 - 00:20:29.960, Speaker C: Yes.
00:20:32.410 - 00:20:34.840, Speaker A: I'm sorry, can you speak louder, please?
00:20:38.970 - 00:20:40.040, Speaker D: Very easy.
00:20:41.390 - 00:21:08.114, Speaker A: No, the simple answer is no. We're talking about a cryptographic primitive here, right? The way you design the network to spread, who generates the proof, who is allowed to push the proof to Ethereum is largely just a consensus problem, and it's something that has been solved by.
00:21:08.152 - 00:21:11.890, Speaker B: Many blockchains and that we're confident we'll solve eventually.
00:21:13.350 - 00:21:14.100, Speaker C: Yes.
00:21:23.690 - 00:21:43.694, Speaker A: I'm sorry, I don't hear you're verifying is the. So the question is, is the verifying approved on Ethereum based on linked any.
00:21:43.732 - 00:21:45.118, Speaker B: Way to proof of work?
00:21:45.284 - 00:21:46.000, Speaker C: No.
00:21:46.530 - 00:21:57.534, Speaker A: Ethereum basically operates the EVM, and its consensus algorithm is proof of work today, it's going to be proof of stake tomorrow, but it's not going to affect how the EVM works.
00:21:57.652 - 00:21:58.222, Speaker B: Right.
00:21:58.356 - 00:22:00.858, Speaker A: And so the capacity to verify proofs.
00:22:00.874 - 00:22:04.640, Speaker B: Is in the EVM, not in proof of work?
00:22:08.330 - 00:22:09.720, Speaker A: Yes, yes.
00:22:11.530 - 00:22:26.310, Speaker D: Right now, driven. And are they gonna have validated?
00:22:30.130 - 00:22:35.918, Speaker B: Sure, I think that's a great point. So right now, a lot of the.
00:22:36.004 - 00:22:39.370, Speaker A: Ethereum ecosystem is centralized around certain entities.
00:22:39.450 - 00:22:45.730, Speaker B: That provide invaluable services that are so centralized. How do we avoid this in building startup?
00:22:46.710 - 00:22:52.226, Speaker A: That's very much an open discussion. That's very much an open discussion that.
00:22:52.248 - 00:23:01.080, Speaker B: You'Re welcome to join on our community channels. We're super happy to have contribution and ideas on how to do that.
00:23:01.610 - 00:23:09.654, Speaker A: But basically, I think designing a system where each players who spend computational time.
00:23:09.692 - 00:23:12.794, Speaker B: On generating a proof is paid for.
00:23:12.832 - 00:23:16.330, Speaker A: That sort of solves this issue.
00:23:16.400 - 00:23:16.634, Speaker C: Right?
00:23:16.672 - 00:23:21.114, Speaker B: So for example, why do we have infura on Ethereum?
00:23:21.242 - 00:23:31.886, Speaker A: Because operating a node is expensive and it doesn't bring you any monetary gain, right? So it's expensive on starknet operating a.
00:23:31.908 - 00:23:40.660, Speaker B: Node, full node, it's basically just operating an Ethereum node, right? So there's no extra cost associated to that.
00:23:42.150 - 00:23:43.234, Speaker A: If you don't want to do more.
00:23:43.272 - 00:23:45.230, Speaker B: Stuff, like for example, generate the proof.
00:23:45.310 - 00:23:51.138, Speaker A: Yes, this will cost you more money. But if you're generating the proof, probably, I mean, there's a lot of designs.
00:23:51.154 - 00:23:52.886, Speaker B: We can imagine where you can get.
00:23:52.908 - 00:24:11.770, Speaker A: The fees from the transactions, things like that. You know what I think if there are other questions, I'll take them, but then I'll move on to explain exactly. I presented the cryptographic primitive. I'm going to explain to you then how we build a product around it.
00:24:11.840 - 00:24:14.880, Speaker B: Where we are in their development and what we want to go with it.
00:24:17.410 - 00:24:17.994, Speaker C: Characters.
00:24:18.042 - 00:24:20.042, Speaker A: You'll have probably nfts for the weapons.
00:24:20.106 - 00:24:25.278, Speaker B: And you'll have a marketplace where people can sell them to each other. You'll have an ERC 22 count points.
00:24:25.444 - 00:24:28.762, Speaker A: How will you calculate the ballistic trajectory.
00:24:28.826 - 00:24:30.338, Speaker B: Of the bazooka that will go from.
00:24:30.344 - 00:24:33.426, Speaker A: One end of the map to the other, and then all the shrapnel and.
00:24:33.448 - 00:24:35.246, Speaker B: All the damage that will do to the map?
00:24:35.358 - 00:24:39.074, Speaker A: The answer is you can't do that on Ethereum.
00:24:39.122 - 00:24:40.758, Speaker B: It will cost you way too much money.
00:24:40.844 - 00:24:42.498, Speaker A: And also you have the famous tag.
00:24:42.514 - 00:24:47.846, Speaker B: 2D color here, who knows how to do what this is, right? So you can't do that, but you.
00:24:47.868 - 00:25:04.106, Speaker A: Can on start now, because computation is cheap. Only one person will do it, and it will calculate the trajectory of the bazooka. All the damage it did to the map, it will just provide you with the result. And you will be sure that this calculation was done according to the rules.
00:25:04.138 - 00:25:05.434, Speaker B: That are on the blockchain.
00:25:05.562 - 00:25:14.674, Speaker A: So it really pushes the boundary to what you can do with the blockchain. You can have the gameplay of your game, not just the asset, live on, share.
00:25:14.792 - 00:25:15.940, Speaker C: That's pretty cool.
00:25:16.790 - 00:25:26.502, Speaker E: Just one comment about this. This is not just a theoretical construct. There is a company building this to the onsark. It's called topology. One of the founders is probably around.
00:25:26.556 - 00:25:28.758, Speaker B: A detender and they are making a.
00:25:28.764 - 00:25:30.806, Speaker E: Physics engine in Cairo where you can.
00:25:30.828 - 00:25:33.810, Speaker B: Make proven computation and prove trajectories.
00:25:33.970 - 00:25:40.358, Speaker E: They also did like an inference model for CNN, like a recognition on the.
00:25:40.364 - 00:25:43.946, Speaker B: Blockchain to do other kind of cool stuff for games. So I just want to say it.
00:25:43.968 - 00:25:46.038, Speaker E: Is not just a theoretical thing, it's.
00:25:46.054 - 00:25:47.866, Speaker B: Actually people being building it.
00:25:47.888 - 00:25:51.440, Speaker C: Right? Yes.
00:25:54.770 - 00:25:55.866, Speaker A: You need to speak louder.
00:25:55.898 - 00:25:56.560, Speaker B: I'm sorry.
00:26:01.170 - 00:26:11.410, Speaker A: I can't hear you. Privacy. Yeah, there's no privacy on target. That's an interesting point.
00:26:11.480 - 00:26:13.870, Speaker B: People hear zero knowledge and they assume privacy.
00:26:13.950 - 00:26:14.580, Speaker C: Why?
00:26:15.270 - 00:26:20.726, Speaker A: Because zero knowledge proofs are a fairly novel concept, right?
00:26:20.828 - 00:26:24.086, Speaker B: They are like, what, 1020 years old? Something like that.
00:26:24.188 - 00:26:28.022, Speaker A: And initially when they came up, a lot of people were like, oh yeah, this is great.
00:26:28.076 - 00:26:36.122, Speaker B: We can prove something happened without revealing. We can prove we transferred coin to somebody without disclosing how much or to.
00:26:36.176 - 00:26:37.302, Speaker D: Whom or from whom.
00:26:37.366 - 00:26:39.260, Speaker B: And this is indeed a very cool application.
00:26:40.350 - 00:26:44.286, Speaker A: One of the founders of Starware is Eli Ben Sasson, and he's one of.
00:26:44.308 - 00:26:46.698, Speaker B: The founding scientists of zcash.
00:26:46.794 - 00:26:47.246, Speaker C: Right?
00:26:47.348 - 00:26:49.886, Speaker A: So privacy has very much been a.
00:26:49.908 - 00:26:53.810, Speaker B: Focus of zero knowledge proof in the beginning, and when people first talked about.
00:26:53.880 - 00:27:00.418, Speaker A: Them, then people had privacy in mind. The way we use them is a bit different.
00:27:00.504 - 00:27:00.850, Speaker C: Right.
00:27:00.920 - 00:27:09.910, Speaker A: We use them so that we don't aim to prove you that something happened without disclosing any data. We aim to prove you something happened.
00:27:09.980 - 00:27:12.898, Speaker B: Without you having to do the same computation.
00:27:12.994 - 00:27:13.990, Speaker C: So it's different.
00:27:14.140 - 00:27:23.846, Speaker A: So by default on Starknet, when you're going to send a transaction, the transaction, the payload will be in the clear and then everyone will be, I mean.
00:27:23.868 - 00:27:25.546, Speaker B: The emsquenter will be able to see.
00:27:25.568 - 00:27:27.386, Speaker A: It, the pooler will be able to see it.
00:27:27.408 - 00:27:30.380, Speaker B: So you shouldn't assume privacy on start.
00:27:30.830 - 00:27:43.086, Speaker A: At until somebody builds. I mean, we have the primitive to build it. We have the primitive to verify the same kind of cryptography you have in.
00:27:43.108 - 00:27:55.140, Speaker B: Tornado cash or with DK snarks or starks eventually. So you will be able to build privacy focused applications on top of start.
00:27:55.990 - 00:28:05.910, Speaker A: It's not native, but you'll be able to build a lot of stuff on it. And there's also this concept I talked about earlier. Recursion will allow a lot of very.
00:28:05.980 - 00:28:08.662, Speaker B: Cool applications to emerge in that field.
00:28:08.716 - 00:28:16.410, Speaker A: Because then if you're able to verify your proof on Starknet, then you're able to generate the proof on your computer.
00:28:16.480 - 00:28:19.494, Speaker B: That you transferred something, and then it's verified by Starknet.
00:28:19.542 - 00:28:32.640, Speaker A: Or you are able to operate an exchange where people send all the transactions to you. You have access to them but nobody else. So it does open a very big design space for privacy. Does that answer your question?
00:28:34.310 - 00:28:35.060, Speaker C: Yes.
00:28:41.190 - 00:28:45.490, Speaker A: There'S recently a paper published on Nova on recursive.
00:28:46.390 - 00:29:09.990, Speaker D: Really great, really, but the original backwards compatible with the same. My question is, are you or can you adapt later scheme?
00:29:34.130 - 00:29:45.926, Speaker E: I mean as starkware or in general, we could do whatever we want, of course. But the reason why I kind of focus on stars is because people, I.
00:29:45.948 - 00:29:46.982, Speaker A: Like to explain that a lot.
00:29:47.036 - 00:30:15.038, Speaker E: People love to talk about the theoretical aspect of proofs like quantum resistance and sign of proof, et cetera, whatever. I think that's actually nonsense, no one cares. What I do care about is approving time. And a start proof is just three times faster than a start prover for the same thing. And the reason is very simple, is the snark prover requires any cpu operation and there's shiftload of them. When the start prover requires a shiftload of hash function. And so one are natively efficient on.
00:30:15.044 - 00:30:16.562, Speaker B: Cpus, the other one are not.
00:30:16.696 - 00:30:18.754, Speaker E: And so if you ask me why.
00:30:18.872 - 00:30:21.118, Speaker A: We are focusing on stark, although they're.
00:30:21.134 - 00:30:40.586, Speaker E: Heavier and they're more expensive to compute, it's simply because the prover is so much faster. And so we could use another proof system. And actually, I think someone is actually trying to convert Cairo to snarky to the Mina protocol. The thing is the efficiency, from our perspective at least, it's not efficient to.
00:30:40.608 - 00:30:58.974, Speaker A: Have a production system. Also, I'd add that you mentioned circuits, because a lot of time when there are zero knowledge application people say, oh, circuit. Right, you have to set up a circuit with gigs, and then you can pass your program into it. And so the question I think you have is, okay, so basically you design.
00:30:59.012 - 00:31:01.822, Speaker B: Your circuit, which means you designed your.
00:31:01.876 - 00:31:08.318, Speaker A: Chip, your silicon chip, and then you want to do something else, something new that is not prevent program for this chip.
00:31:08.414 - 00:31:09.330, Speaker B: How do you do it?
00:31:09.400 - 00:31:40.662, Speaker A: That's your question, right? There's no circuits in start, it doesn't work that way. Cairo has no circuit associated to it. It's a general purpose programmation language. You can build anything, we're not limited by the size of the circuit or anything, which is also know, when you set up a network with a circuit, one of the big question is how big do you make the circuit? Because if you make it very big, then it's very expensive to verify, even for small applications.
00:31:40.726 - 00:31:42.826, Speaker B: And if you make it too small, then it's not virtual proof.
00:31:42.858 - 00:31:46.254, Speaker A: And then extending it later on will suck. We don't have that issue because we.
00:31:46.292 - 00:31:48.000, Speaker B: Don'T have circuits based on.
00:31:49.810 - 00:31:50.558, Speaker C: Would.
00:31:50.724 - 00:31:58.606, Speaker E: Even more specifically, technically, Cairo is one unique circuit, but it's a circuit, it's never a circuit, it's like a cpu, which is technically why it's called Cairo.
00:31:58.638 - 00:31:59.778, Speaker B: It's called CPU Air.
00:31:59.864 - 00:32:09.170, Speaker E: So it's an error presentation of a cpu. So whenever you're writing Cairo, it's not like writing in circum or any other language. You're not writing damn constraint.
00:32:09.250 - 00:32:11.446, Speaker A: You're writing a program which compiled to.
00:32:11.468 - 00:32:25.820, Speaker E: Bytecode, which is verified by the cpu air by Cairo, which is also why this performance 20 x difference is so fundamental, because it's not just a difference of speed, it's a difference of capacity for the same thing.
00:32:28.830 - 00:32:31.514, Speaker A: It's also the reason why we have.
00:32:31.552 - 00:32:32.934, Speaker B: A specific programming language.
00:32:32.982 - 00:32:33.194, Speaker C: Right?
00:32:33.232 - 00:32:38.010, Speaker B: Stop me if I'm wrong with it, but basically we have a specific cpu, which is Cairo.
00:32:38.170 - 00:32:40.446, Speaker A: And you can't just use any kind.
00:32:40.468 - 00:32:45.106, Speaker B: Of programming language on top of it. We had to design a new one.
00:32:45.208 - 00:32:51.090, Speaker A: That is adapted to our cpu. That's why we came up with a language.
00:32:55.270 - 00:33:02.326, Speaker B: It's a new smart contract programming language. It's a bit scary, it's a bit more difficult to use than solidity, but.
00:33:02.348 - 00:33:03.958, Speaker A: It'S not impossible to use, and you.
00:33:03.964 - 00:33:05.880, Speaker B: Can do way more stuff with it.
00:33:08.010 - 00:33:09.222, Speaker A: Nowadays anyway.
00:33:09.276 - 00:33:10.538, Speaker B: You have a transpiler, so if you.
00:33:10.544 - 00:33:11.894, Speaker A: Want to write your code in solidity.
00:33:11.942 - 00:33:24.060, Speaker B: You can port it from solidity to Cairo very easily. So yeah. Wanted to mention that we have a native smart contract language. It's a bit more difficult to use, but you can do way more stuff.
00:33:24.510 - 00:33:29.514, Speaker E: Yeah, you introduced me to one more thing, which is Cairo for all purposes.
00:33:29.562 - 00:33:30.846, Speaker A: Is a black box.
00:33:31.028 - 00:33:48.006, Speaker E: The same way you don't need to understand CuDA, how CuDA is implementing to write use. You don't need to know how Carol is implemented to write in Carol, same things with CPU. When you're writing Python, you don't understand the low level stuff that happens in the interpreter and what happened in cpu at the end.
00:33:48.188 - 00:33:49.734, Speaker B: This is what makes a big, big.
00:33:49.772 - 00:33:52.920, Speaker E: Difference when comparing to other system out there.
00:33:57.790 - 00:33:58.154, Speaker A: Yeah.
00:33:58.192 - 00:33:59.050, Speaker B: Oh, there's a question.
00:33:59.120 - 00:33:59.740, Speaker C: Yes.
00:34:08.830 - 00:34:09.740, Speaker D: And then.
00:34:13.490 - 00:34:16.974, Speaker A: I think it's a bit too early to answer these questions right now.
00:34:17.012 - 00:34:29.630, Speaker B: We know that theory works. We are able to have a network that works. It's hard to project exactly how this whole scale.
00:34:30.550 - 00:34:35.634, Speaker E: Yeah, I can say one thing right now, we don't care.
00:34:35.752 - 00:34:37.806, Speaker F: And they're going to be very simply.
00:34:37.838 - 00:34:58.330, Speaker E: Why the performance of the prover is practical on generic public cloud. And the recursive proof that we discussed very briefly enable us to paralyze on smaller machines. And so we don't need specific hardware today to make proof that scale to the level of immutable sore to 200 tps, 1000 tps is needed.
00:34:58.400 - 00:34:59.862, Speaker B: Yeah, but it'd be cool if you.
00:35:00.016 - 00:35:17.040, Speaker D: To that point though. One of the things I'm interested in is the volition, right? One of the things that excites me about star program on a chip that you interact with.
00:35:19.250 - 00:35:22.894, Speaker E: But you don't. Okay, so this is where I think.
00:35:22.932 - 00:35:24.378, Speaker A: There is a tiny bit of confusion.
00:35:24.474 - 00:36:05.920, Speaker E: You don't need to run the program, you don't need the main thing that startped brings. What does ZK Rollup brings to the world of blockchain? Because maybe this is something people don't understand. What ZK rollup brings to the blockchain world is the following thing. It splits the hardware requirement between a full node, a mining full node, a sequencing full node, and a regular full node that you want to have on your laptop. And so you give that the miner, the sequencer can have a database. What I care about, and you will be able to verify on your phone without any change, any specific cheap or anything. It just works on your phone.
00:36:05.920 - 00:36:14.434, Speaker E: That is what Vkola brings to the world. And so you don't need specific cheap for you to verify the chain on your phone.
00:36:14.552 - 00:36:15.490, Speaker A: You don't.
00:36:16.010 - 00:36:17.400, Speaker E: Is that answer your question?
00:36:18.810 - 00:36:21.030, Speaker D: Specific use case of connection.
00:36:28.010 - 00:36:29.480, Speaker A: I think you have the question.
00:36:29.850 - 00:36:32.066, Speaker B: If I boil it down, maybe I'm wrong.
00:36:32.108 - 00:36:34.106, Speaker A: But basically it would be cool if.
00:36:34.128 - 00:36:44.926, Speaker B: I could generate a proof on my phone, because that way I would get a lot of flexibility in terms of privacy. Just even that, right? If I could generate a proof on my phone, I could have a lot.
00:36:44.948 - 00:36:46.362, Speaker A: Of privacy and a lot of scale.
00:36:46.426 - 00:36:48.110, Speaker B: Not sure if that's exactly your question.
00:36:48.180 - 00:36:51.406, Speaker A: Yes, and right now, as I mentioned.
00:36:51.508 - 00:36:53.922, Speaker B: We are focusing on proving for very.
00:36:53.976 - 00:36:54.580, Speaker D: Much.
00:36:56.310 - 00:37:07.480, Speaker B: For very large payloads, right. And so we haven't explored that side of the spectrum yet, but I agree, it's a very exciting one.
00:37:12.250 - 00:37:16.038, Speaker A: Today. Startware. So as I mentioned, Starknet right now.
00:37:16.124 - 00:37:28.554, Speaker B: Is running the proverb basically because we set up the mathematical part to ensure it works and eventually this code will be decentralized. Right. The cool thing though is that we.
00:37:28.592 - 00:37:30.714, Speaker A: Can'T prove something you didn't agree to.
00:37:30.912 - 00:37:57.350, Speaker B: We can't generate a proof that will steal your front. Otherwise this proof won't be valid. The only thing we could do was not include, would be not include your transaction, which sucks. But that will get rid of eventually, unless you have a follow up. Is there a plan for how you to decentralize approving?
00:38:01.050 - 00:38:06.034, Speaker A: We are considering right now we're in the process of figuring out which consensus.
00:38:06.082 - 00:38:10.454, Speaker B: Algorithm we should use for leader election and for splitting the proverb.
00:38:10.502 - 00:38:15.798, Speaker A: And also, we're considering whether we should split sequencing.
00:38:15.894 - 00:38:19.034, Speaker B: So deciding which transaction goes into the.
00:38:19.072 - 00:38:22.650, Speaker A: Proof and generating the proof and how.
00:38:22.720 - 00:38:28.078, Speaker B: You distribute these roles in the network, because they're a bit different.
00:38:28.164 - 00:38:35.186, Speaker A: So we are trying to come up with an interesting mechanism. We plan, actually, in the next few.
00:38:35.208 - 00:38:36.386, Speaker B: Days, we're right in the middle of.
00:38:36.408 - 00:38:40.610, Speaker A: That, to publish on our community forum.
00:38:41.110 - 00:38:45.058, Speaker B: The fruit of our reflections. And we want to take input from.
00:38:45.064 - 00:38:47.650, Speaker A: The community people saying, oh, this is nice. This is not nice.
00:38:47.720 - 00:39:04.246, Speaker B: I'd rather have five finalities and this stuff like that. So it's being decided right now. We're trying to be as open as we can. And it's a really interesting discussion with you, Mr. Bender.
00:39:04.358 - 00:39:06.300, Speaker C: Yeah. Yes.
00:39:11.970 - 00:39:19.194, Speaker A: To mitigate Mev, I mean, some sort of mev, probably all of mev.
00:39:19.242 - 00:39:20.240, Speaker B: Probably not.
00:39:20.610 - 00:39:23.134, Speaker A: And right now also, I'd say that.
00:39:23.172 - 00:39:25.822, Speaker B: Since the topology of the network is not well defined.
00:39:25.886 - 00:39:26.114, Speaker A: Right.
00:39:26.152 - 00:39:28.606, Speaker B: We don't know how the sequencing role.
00:39:28.638 - 00:39:31.090, Speaker A: Will be distributed and the proof will be distributed.
00:39:32.470 - 00:39:34.514, Speaker B: It's hard to really answer this question.
00:39:34.632 - 00:39:35.678, Speaker A: It will be an open one.
00:39:35.704 - 00:39:38.550, Speaker B: But we have people working on something on the topic.
00:39:44.090 - 00:39:44.662, Speaker A: I'm sorry.
00:39:44.716 - 00:39:59.820, Speaker D: For outreach, how you see competition, obviously not perfect. And whether like.
00:40:05.630 - 00:40:07.840, Speaker A: No, that's, that's a great question.
00:40:09.090 - 00:40:17.406, Speaker B: So I come from solidity. I was familiar with solidity, and I.
00:40:17.428 - 00:40:19.694, Speaker A: Think if you had asked me a.
00:40:19.732 - 00:40:32.520, Speaker B: Year ago whether a system that doesn't use solidity for smart contracts would be via book, I wouldn't have said yes, because basically other people tried and it didn't work.
00:40:33.050 - 00:40:39.434, Speaker A: The reason I changed my mind today are twofold. The first one is that we're seeing.
00:40:39.632 - 00:41:02.110, Speaker B: Smart contract platforms with different programming languages, specifically Solana, gain developer traction. People who want to do more things go to another programming language. And that reason is very linked to that, is that people want to do more things. You can do more things on Solana than you can do on Ethereum, right. And you can do more things on startup.
00:41:02.690 - 00:41:10.274, Speaker A: To me, it's like, I'm obviously not objective, but ZK Rollups are a step function.
00:41:10.392 - 00:41:13.262, Speaker B: You can do stuff you just couldn't imagine on Ethereum.
00:41:13.326 - 00:41:18.902, Speaker A: And so the analogy I like to take is, who here played Nintendo 64.
00:41:18.956 - 00:41:20.760, Speaker B: And Pokemon Stadium on.
00:41:22.490 - 00:41:27.474, Speaker A: Okay, so in Ethereum Stadium, you could have a small cartridge where you played.
00:41:27.522 - 00:41:35.050, Speaker B: With your game boy game on your Nintendo 64, which was nice, right? You could, on your tv, played with your Game Boy game.
00:41:35.200 - 00:41:36.506, Speaker A: And I think we are more or.
00:41:36.528 - 00:41:42.358, Speaker B: Less at this stage in terms of ZK rollups and Ethereum, people want the.
00:41:42.384 - 00:41:46.878, Speaker A: EVM and we should give them the opportunity to port their program from the.
00:41:46.884 - 00:41:49.646, Speaker B: EVM to our zural level.
00:41:49.748 - 00:41:51.294, Speaker A: People should be able to use their.
00:41:51.332 - 00:42:00.546, Speaker B: Game going game on the Nintendo 64, but writing programs on Nintendo 64 is pretty cool and you should try it.
00:42:00.648 - 00:42:10.774, Speaker A: So I think in terms of developer advocacy, I think our goal is twofold. First of all, explain to people that.
00:42:10.812 - 00:42:14.614, Speaker B: It'S not that hard to use startnet and you have immediate benefits.
00:42:14.732 - 00:42:18.518, Speaker A: It's cheaper. You can do your application, same application you have, you can run it and.
00:42:18.524 - 00:42:21.080, Speaker B: It'S cheaper and it's nice and it's not that hard.
00:42:21.390 - 00:42:22.140, Speaker A: Right?
00:42:23.150 - 00:42:27.946, Speaker B: Writing smart contracts is hard, but once you have the general logic of how.
00:42:27.968 - 00:42:30.294, Speaker A: You write smart contract, the specific syntax.
00:42:30.342 - 00:42:37.662, Speaker B: Of it is not that important. What really matters is the mind that you have. And so we want people to feel.
00:42:37.716 - 00:42:40.526, Speaker A: Like, oh yeah, I know how to deploy an ERC 20, I know how.
00:42:40.548 - 00:42:47.038, Speaker B: To deploy an ERC 721 to, and now I know how to do it on Stockman because it's not that difficult.
00:42:47.124 - 00:42:49.598, Speaker A: And actually that's what we're going to do on Thursday.
00:42:49.694 - 00:42:49.954, Speaker C: Right.
00:42:49.992 - 00:42:53.198, Speaker B: So do join at that time and we'll show you how to deploy ERC.
00:42:53.214 - 00:42:54.740, Speaker A: Twenty s and ERC 720.
00:42:55.110 - 00:42:56.466, Speaker B: So that's the first thing I want.
00:42:56.488 - 00:43:04.966, Speaker A: People to feel like, oh, I know what I know how to do on Ethereum. I can do it. And then once they're booked, figure out.
00:43:04.988 - 00:43:08.358, Speaker B: That you can do a lot more stuff with start.
00:43:08.524 - 00:43:13.270, Speaker A: And this is where the fun really began. To be honest. It's nice. Two transactions are nice.
00:43:13.340 - 00:43:49.160, Speaker B: I'm really more interested in the right. Does that answer your question? There was a question, I think, around there. Cool. Mr. Yeah, sure.
00:43:49.850 - 00:43:53.480, Speaker A: I mean, I'll, if.
00:43:55.450 - 00:43:57.718, Speaker B: You have, yeah.
00:43:57.804 - 00:44:01.078, Speaker A: I think the low, I'll give you.
00:44:01.084 - 00:44:04.620, Speaker B: The low answer level and then we can go higher.
00:44:06.190 - 00:44:11.718, Speaker A: The basic assumption is that DVM is inherently constrained.
00:44:11.814 - 00:44:20.218, Speaker B: It was meant to run on cpus, that is dispute that are replicated amongst a lot of users. Hence why you have stacked to give errors.
00:44:20.314 - 00:44:21.694, Speaker A: There are a lot of limitations with.
00:44:21.732 - 00:44:22.558, Speaker C: What you can do.
00:44:22.644 - 00:44:24.394, Speaker B: We don't have that constraint.
00:44:24.522 - 00:44:26.718, Speaker A: And so just limiting what you can.
00:44:26.724 - 00:44:28.498, Speaker F: Do on our rollout, what you can.
00:44:28.504 - 00:44:30.142, Speaker B: Do on the evidence, felt like a waste.
00:44:30.206 - 00:44:34.110, Speaker A: If you could use the Nintendo 64 just to write new Game Boy games.
00:44:34.270 - 00:44:39.240, Speaker B: It felt really like a waste to us. So that's why we decided to focus first on.
00:44:41.210 - 00:44:43.142, Speaker E: Mean. Yeah, I can explain a bit more.
00:44:43.196 - 00:44:44.280, Speaker B: Sort of low level.
00:44:47.130 - 00:45:01.494, Speaker E: First of all, ZKP doesn't have a single computation model than regular computers, and that's actually quite easy to understand. And there is multiple more complex differences. But the simplest one is the following one, and it is also why we're using felt.
00:45:01.542 - 00:45:02.742, Speaker B: Okay, so now I'm going to explain.
00:45:02.896 - 00:45:50.854, Speaker E: On the cpu, on a regular computer, Python, whatever, when you use whatever language you work in, x 86 architecture, right? And what your cpu knows how to do very, very well, ignore or not boolean logic, right? That is super good at doing boolean logic. The thing is, what is not good at, for instance, is division. Division is a lot more expensive than boolean logic, because you live in a binary environment. When you live in a ZKP environment, you live in an arithmetic environment. And so division is free, Bugsor is expensive. And so just this shift of mental model is just enough to justify developing new language that's optimized for that purpose. And so what, the basic element of a cpu is a bit and a byte.
00:45:50.982 - 00:45:51.660, Speaker C: And.
00:45:53.390 - 00:45:57.646, Speaker E: In CKP in Cairo is what we call a felt, which is a field element, which is basically a big.
00:45:57.668 - 00:45:58.926, Speaker B: U eight modulo big one.
00:45:59.028 - 00:46:06.306, Speaker E: There is a bunch of other differences, like non determinism, like for instance in Cairo, from the perspective of a program.
00:46:06.488 - 00:46:08.100, Speaker B: X squared equal one.
00:46:09.030 - 00:46:18.054, Speaker E: It's a program that has two different runtime, but both for a particular program are the same. You don't see a difference? I mean, there is a bunch of differences. I will invite you to read the paper.
00:46:18.092 - 00:46:20.358, Speaker B: It's really interesting, the low level of.
00:46:20.444 - 00:46:22.374, Speaker E: What Cairo is and what it does.
00:46:22.412 - 00:46:23.414, Speaker B: And why it does these things.
00:46:23.452 - 00:46:24.040, Speaker A: This.
00:46:27.130 - 00:46:32.086, Speaker E: Mean star can actually be instantiating in the different field elements. You can even do binary fields, like.
00:46:32.108 - 00:46:33.494, Speaker B: A lot of very complex.
00:46:33.622 - 00:46:53.214, Speaker E: There is a lot of design space even in that domain. And to go back to the question about the proof site, even the proof site, there is a shitload of design space based on cost of data and the hash function and plenty of stuff. And the time you want to prove stuff. My point is that we are not Cardano. We didn't invent things for the pleasure.
00:46:53.262 - 00:46:54.434, Speaker A: Of inventing new things.
00:46:54.552 - 00:46:58.180, Speaker E: We do things because they're practical and useful. So that's a short answer.
00:47:00.070 - 00:47:00.980, Speaker C: Thank you.
00:47:02.630 - 00:47:06.242, Speaker A: If there are questions, I can address them. Or if you want, we can move.
00:47:06.296 - 00:47:10.214, Speaker B: A bit more to a practical session. Start with that.
00:47:10.252 - 00:47:11.046, Speaker C: Do you want?
00:47:11.228 - 00:47:19.298, Speaker A: No, not really. Who's hungry here? I am a bit. Who wants to wait until the end to go to go eat? Yeah, stay around a bit.
00:47:19.404 - 00:47:20.380, Speaker C: Okay, cool.
00:47:24.430 - 00:47:26.106, Speaker B: I think we have t shirts also.
00:47:26.208 - 00:47:32.854, Speaker E: Yes, we do have t shirts. But because they are limited edition, we.
00:47:32.912 - 00:47:34.574, Speaker B: Need to prove to give proof of.
00:47:34.612 - 00:47:36.682, Speaker A: Points from only tutorial.
00:47:36.826 - 00:47:48.846, Speaker E: So I'm sorry, all the guys that just show up here, you're looking t shirt. But if you get those points by Thursday, you might so look at only tutorial.
00:47:48.958 - 00:47:50.546, Speaker A: It's only 101, right?
00:47:50.648 - 00:47:54.866, Speaker B: Yeah, I'm going to show it my way. So get the point, get the t.
00:47:54.888 - 00:47:59.682, Speaker E: Shirt if you want t shirt, we have like a box over there with Levon and you need to show your.
00:47:59.736 - 00:48:01.480, Speaker B: One argent wallet to get it.
00:48:02.730 - 00:48:08.086, Speaker A: Okay, so what we can do now is the following. I'm going to present to you one.
00:48:08.108 - 00:48:14.314, Speaker B: Of our learning resources that will basically explain to you how a smart contract in Cairo is written, okay.
00:48:14.432 - 00:48:21.214, Speaker A: How you read it, how you manipulate variables and stuff like that, the way it is designed. You will collect points in the form.
00:48:21.252 - 00:48:23.418, Speaker B: Of ERC 20 tokens.
00:48:23.514 - 00:48:24.014, Speaker A: Right.
00:48:24.132 - 00:48:28.000, Speaker B: They have obviously no value, actually, don't even transfer them.
00:48:31.490 - 00:48:36.242, Speaker A: And I'm going to explain a bit this. There's a bunch of us around and you can ask questions if you have them.
00:48:36.296 - 00:48:40.098, Speaker B: I'm going to show how to do the first and then we can correct a few.
00:48:40.264 - 00:48:48.950, Speaker A: Who here has a computer and want to start working on that? Okay, who here is not really interested in the tutorial, but is more interested.
00:48:49.020 - 00:48:52.840, Speaker B: In asking questions or stuff like that? Which is fine also.
00:48:54.570 - 00:49:01.820, Speaker A: Okay, so let's start with the tutorial and then if you have more questions, you can ask. Okay, so it's very small.
00:49:02.270 - 00:49:03.114, Speaker B: It's very small.
00:49:03.152 - 00:49:03.594, Speaker C: Actually.
00:49:03.712 - 00:49:07.660, Speaker B: Not sure how I can show this. Let me see.
00:49:12.450 - 00:49:13.760, Speaker A: So this is.
00:49:17.090 - 00:49:25.354, Speaker B: Where. Yeah, big enough now you should be able to see.
00:49:25.492 - 00:49:30.446, Speaker A: Okay, so go on that GitHub. And there's a bunch of disclaimers.
00:49:30.558 - 00:49:31.666, Speaker B: So what is this?
00:49:31.768 - 00:49:34.398, Speaker A: It's basically a repo with a set of smart contracts.
00:49:34.414 - 00:49:36.260, Speaker B: And you can read its code?
00:49:37.450 - 00:49:39.254, Speaker A: You can read its code and your.
00:49:39.292 - 00:49:42.214, Speaker B: Objective is to read the code and.
00:49:42.252 - 00:49:44.694, Speaker A: Figure out how to trigger something that.
00:49:44.732 - 00:49:45.880, Speaker B: Will give you points.
00:49:46.890 - 00:49:54.934, Speaker A: The way you will receive points is by deploying what is contract because mindflow.
00:49:54.982 - 00:50:00.300, Speaker B: Number x, there's no such thing as an EOA on start.
00:50:00.750 - 00:50:01.546, Speaker A: Right.
00:50:01.728 - 00:50:04.794, Speaker B: You know how maybe, you know, maybe you don't.
00:50:04.922 - 00:50:08.622, Speaker A: Ethereum, one of the something that people.
00:50:08.676 - 00:50:10.206, Speaker B: Have been chasing after for a long.
00:50:10.228 - 00:50:11.294, Speaker A: Time is a way to have something.
00:50:11.332 - 00:50:15.954, Speaker B: Called account abstraction, basically dissociating, holding your.
00:50:15.992 - 00:50:20.030, Speaker A: Asset on chain in the way you sign and transaction.
00:50:20.190 - 00:50:23.666, Speaker F: And we've had the chance of on.
00:50:23.688 - 00:50:32.694, Speaker B: The shoulders of giants, bitcoin and Ethereum and we invested from day one. And so basically in order to hold.
00:50:32.732 - 00:50:35.430, Speaker A: Points you will have to have a smart contract wallet.
00:50:36.410 - 00:50:38.498, Speaker B: And today, the easiest way to deploy.
00:50:38.514 - 00:50:40.566, Speaker A: Your smart contract wallet is to deploy.
00:50:40.598 - 00:50:42.234, Speaker B: A wallet with Arjon X.
00:50:42.352 - 00:50:44.218, Speaker A: So, who here knows about Arjon the.
00:50:44.224 - 00:50:45.558, Speaker B: Smart contract wallet material?
00:50:45.654 - 00:50:46.202, Speaker A: Right?
00:50:46.336 - 00:50:47.242, Speaker B: Great product.
00:50:47.376 - 00:50:51.514, Speaker A: And we have actually Matt from Arjon Pierre. If you want to ask him question.
00:50:51.632 - 00:50:52.974, Speaker B: He'Ll be happy to answer.
00:50:53.092 - 00:50:58.958, Speaker A: So, Arjon recently deployed a new wallet, which is called Arjon X, which is.
00:50:58.964 - 00:51:01.870, Speaker B: A startlet specific wallet.
00:51:02.690 - 00:51:06.398, Speaker A: So you'll need to install it, and then you'll have it here in your browser.
00:51:06.574 - 00:51:07.700, Speaker B: Looks nice.
00:51:08.310 - 00:51:17.826, Speaker A: And you need to deploy a new account. Once you've done that, then you can go to the tutorial, read a bit how this works, and the basic gist.
00:51:17.858 - 00:51:18.950, Speaker B: Of it is the point.
00:51:19.100 - 00:51:21.430, Speaker A: Here you have the list of exercises.
00:51:22.010 - 00:51:24.566, Speaker B: Here you have the code that you.
00:51:24.588 - 00:51:29.686, Speaker A: Need to really know, and here you have a link to interact with the contract on Voyager.
00:51:29.878 - 00:51:32.570, Speaker B: So, for example, let's take the first contract.
00:51:33.230 - 00:51:44.030, Speaker A: What exactly is happening there? So, here there's a bunch of comments.
00:51:44.930 - 00:51:46.926, Speaker B: In order to make it easier for.
00:51:46.948 - 00:51:50.462, Speaker F: You to understand, if you think some.
00:51:50.516 - 00:51:53.440, Speaker B: Comments are missing or something, comments are wrong.
00:51:53.890 - 00:51:56.142, Speaker F: Your pr welcome.
00:51:56.276 - 00:51:58.110, Speaker B: Do contribute to the rebel.
00:51:58.190 - 00:52:01.300, Speaker A: If something is not clear to you, submit an issue.
00:52:02.070 - 00:52:05.234, Speaker B: Tell us. We want to get as easy and onboarding as possible.
00:52:05.432 - 00:52:09.234, Speaker A: So you start by reading your contract, and then there's a bunch of explanations.
00:52:09.282 - 00:52:15.766, Speaker B: So these are the imports we're using. Then this is our constructor. And then you have functions, and one.
00:52:15.788 - 00:52:23.334, Speaker A: Of them is called flame for us. Okay, I'll go back to what is happening inside this function later on. But what I want to show you is the following.
00:52:23.382 - 00:52:30.162, Speaker B: So, remember, here the code, and here you have the link to the contract deployed on Voyager.
00:52:30.246 - 00:52:47.934, Speaker A: So that specific smart contract was deployed on starknet test. And here on Voyager, you can actually see the contract and interact with it. You can read its variables.
00:52:47.982 - 00:52:50.606, Speaker B: So there's a bunch of functions.
00:52:50.638 - 00:52:56.734, Speaker A: So, for example, I can here read what is the address of the ERC.
00:52:56.782 - 00:53:03.782, Speaker B: 20 token that is associated with the points of the tutorial, and you'll have to use these functions later on.
00:53:03.916 - 00:53:21.322, Speaker A: And then you can write the contract, and you can call a function. It's kind of like the interface in etter scan right now, they allow you to verify your contract, and then you can natively interact with it. It's the same when you use these functions.
00:53:21.386 - 00:53:23.102, Speaker B: Make sure to connect Arjun X.
00:53:23.156 - 00:53:29.546, Speaker A: Here, for example, here it saw that Argentine X is activated in my browser.
00:53:29.578 - 00:53:32.190, Speaker B: And so I can send my transactions through Argent.
00:53:32.930 - 00:53:42.786, Speaker A: Okay, so where do I go from here? My objective is basically to trigger these two functions. One is called validate magnifying and it will make sure that I have not.
00:53:42.808 - 00:53:44.786, Speaker B: Completed the Zega file before and the.
00:53:44.808 - 00:53:46.360, Speaker F: Other one will give me post.
00:53:47.050 - 00:53:48.310, Speaker B: Pretty cool, right?
00:53:48.460 - 00:53:49.414, Speaker A: How do I do that?
00:53:49.452 - 00:53:54.520, Speaker B: Okay, and here is the counter of ERC 20. Let's go see.
00:53:55.530 - 00:54:01.402, Speaker A: So there's the contract. I have an account with Arjon X.
00:54:01.536 - 00:54:03.980, Speaker B: I'm going to copy my address here.
00:54:04.430 - 00:54:13.550, Speaker A: And then I'm going to go read the contract. It's an ERC 20, right? So who here has already deployed an ERC 20 contract?
00:54:14.850 - 00:54:15.678, Speaker B: Yeah, right.
00:54:15.764 - 00:54:18.734, Speaker A: Okay, so you'll be used to that.
00:54:18.772 - 00:54:19.022, Speaker C: Right.
00:54:19.076 - 00:54:21.358, Speaker A: How do you know how much tokens you have?
00:54:21.524 - 00:54:22.350, Speaker F: Balance.
00:54:22.690 - 00:54:24.906, Speaker B: Very nice. It's here.
00:54:25.028 - 00:54:32.930, Speaker A: Okay, so now I can query and see how many tokens do I have? I have not done the exercise. So how many points should I have? Zero?
00:54:33.080 - 00:54:33.780, Speaker C: Yes.
00:54:34.230 - 00:54:46.070, Speaker B: Okay, so I'm going to read that and it's going to tell me you have zero points. So why are there two numbers here? I'll go back to it later.
00:54:46.220 - 00:54:50.810, Speaker A: Okay, so I have zero points. Now what is happening exactly?
00:54:50.880 - 00:54:54.854, Speaker B: So this function here selects several functions. It can be called by any contract.
00:54:54.982 - 00:54:59.078, Speaker A: It's called claim points. It has a bunch of implicit arguments.
00:54:59.174 - 00:55:03.230, Speaker B: Which I hate and I want to get rid of because I need to convince my co workers.
00:55:08.210 - 00:55:13.026, Speaker A: Cairo is a fast evolving language. There are a lot of things that.
00:55:13.048 - 00:55:15.730, Speaker B: You'Ll see here that are very raw.
00:55:16.070 - 00:55:19.140, Speaker F: And you.
00:55:20.870 - 00:55:22.226, Speaker A: Have the ability to do.
00:55:22.248 - 00:55:25.598, Speaker B: A lot of stuff and eventually will abstract some of the complexity.
00:55:25.694 - 00:55:29.958, Speaker A: So if you're able to do it now, for sure you'll be able.
00:55:30.124 - 00:55:32.294, Speaker B: It's only going to get simpler from now.
00:55:32.412 - 00:56:01.120, Speaker A: Okay. And it has for the past six months, and it takes no argument. What does it do? It basically uses this to get my address, the equivalent of calling MsG sender. And then it gives me points. So there's not much I should do besides calling claim points. And then Arjo is saying, ok, so do you want to send this transaction? And I send it? Yes, there's a question. Yeah, sure.
00:56:01.120 - 00:56:10.180, Speaker A: So I'll finish that in the line. So here there's a transaction hash. And actually if I click on it, what's going to happen?
00:56:11.510 - 00:56:12.820, Speaker B: Because it's not yet.
00:56:13.910 - 00:56:14.562, Speaker C: Right.
00:56:14.696 - 00:56:28.086, Speaker A: So if you want to know what is happening with your transaction in the tutorial, I've added a small here, a link, you can open it and you.
00:56:28.108 - 00:56:31.370, Speaker F: Can paste your transaction hash here.
00:56:31.520 - 00:56:34.090, Speaker A: See, actually this is.
00:56:34.240 - 00:56:34.922, Speaker B: I love it.
00:56:34.976 - 00:56:40.426, Speaker A: It's a good improvement. This was not here last week, so it's telling me. Okay, the transaction will receive. It's going to tell me in a.
00:56:40.448 - 00:56:41.914, Speaker B: While if it works or not.
00:56:42.032 - 00:56:56.830, Speaker A: Okay, so your question, why are there implicit arguments? Because basically the way Kyrie works is when you run a program, it imports.
00:56:56.910 - 00:57:00.482, Speaker B: Some pre written functions which are called.
00:57:00.536 - 00:57:03.266, Speaker A: Built in, which are placed at a.
00:57:03.288 - 00:57:06.600, Speaker B: Specific place in memory when you're running the program.
00:57:08.490 - 00:57:19.146, Speaker A: When your function needs one of these tools, it needs to know where they're stored. So where you're calling the function automatically, this value will be added there so.
00:57:19.168 - 00:57:20.314, Speaker B: That it knows where to look for.
00:57:20.352 - 00:57:21.322, Speaker A: Does that answer your question?
00:57:21.376 - 00:57:22.858, Speaker B: Layman? Yeah, please.
00:57:22.944 - 00:57:25.050, Speaker D: Is this like imports or namespaces?
00:57:28.030 - 00:57:30.714, Speaker B: It's been way too long since I programmed c plus plus.
00:57:30.752 - 00:57:31.258, Speaker C: I'm sorry.
00:57:31.344 - 00:57:33.898, Speaker A: No worries. Sounds similar.
00:57:33.984 - 00:57:34.620, Speaker C: Yeah.
00:57:36.690 - 00:57:40.640, Speaker A: Okay, so my transaction, what is happening with it?
00:57:41.330 - 00:57:44.866, Speaker B: It's been received now maybe it will.
00:57:44.888 - 00:57:46.098, Speaker A: Move to a new state.
00:57:46.184 - 00:57:47.140, Speaker B: Let's see.
00:57:49.430 - 00:57:56.510, Speaker A: My transaction has been accepted on l two. This mean it has been included in a block and the state should have been updated.
00:57:56.590 - 00:57:56.930, Speaker C: Right.
00:57:57.000 - 00:58:00.406, Speaker A: So it has been accepted on l two. It's in a block, and eventually it.
00:58:00.428 - 00:58:03.558, Speaker B: Will be included in approved, which will be included on l one.
00:58:03.724 - 00:58:06.006, Speaker A: Okay, so maybe I can see if.
00:58:06.028 - 00:58:07.240, Speaker B: I have points now.
00:58:07.870 - 00:58:09.420, Speaker C: I hope I have points.
00:58:11.790 - 00:58:12.822, Speaker B: Okay, it's query.
00:58:12.886 - 00:58:21.846, Speaker A: Yes, I have two points. Yeah, you know there's an 18 decimal go me. I can do the demonstration, but you'll.
00:58:21.878 - 00:58:24.010, Speaker B: Learn a lot more if you actually do it yourself.
00:58:24.080 - 00:58:25.630, Speaker A: Is anyone trying to do it?
00:58:25.780 - 00:58:26.878, Speaker B: Sort of, yeah.
00:58:26.964 - 00:58:27.358, Speaker C: Good.
00:58:27.444 - 00:58:28.734, Speaker A: Okay, so the first step is to.
00:58:28.772 - 00:58:32.286, Speaker B: Actually deploy your account smart contract. This will take a bit of time.
00:58:32.468 - 00:58:36.542, Speaker A: Okay, so why are there two value here?
00:58:36.596 - 00:59:01.318, Speaker B: For balance, it's not settled to layer one. When you store values, you store things we call felts.
00:59:01.494 - 00:59:08.106, Speaker A: Felts, which are field elements which are basically integers that just go up to.
00:59:08.128 - 00:59:09.914, Speaker B: A certain point, right?
00:59:09.952 - 00:59:13.774, Speaker A: In Ethereum, when you store a uint 256, you can store a value from.
00:59:13.812 - 00:59:15.982, Speaker B: Zero to two to the power of 256.
00:59:16.116 - 00:59:23.086, Speaker A: When you're storing a belt, you can store a value from zero to a large prime number that is of the.
00:59:23.108 - 00:59:25.700, Speaker B: Order of two to the power of 51.
00:59:26.150 - 00:59:31.362, Speaker A: Okay, close enough, right. But if you want to manipulate un.
00:59:31.416 - 00:59:37.318, Speaker B: 256 from Ethereum, then you really need 256 bytes, right?
00:59:37.484 - 00:59:42.390, Speaker A: And so how do you get 256 bytes using 251 bytes?
00:59:43.050 - 00:59:44.790, Speaker B: Well, use two slots.
00:59:47.130 - 00:59:50.298, Speaker A: It says stupid, right? So in the smart contracts we have.
00:59:50.304 - 00:59:54.006, Speaker B: A small abstraction which is called unit.
00:59:54.118 - 01:00:00.070, Speaker A: 256, which basically manipulates two files. Okay, so I did the first exercise.
01:00:00.150 - 01:00:00.490, Speaker C: Fine.
01:00:00.560 - 01:00:16.258, Speaker A: So fun fact is, this is usually the exercise that takes the most time because you need to read the data, figure a bit how you want to interact with it and the transaction, and once you're there, you've done most of.
01:00:16.264 - 01:00:21.170, Speaker B: The work because then after that it's just reading code. Okay, so let's go to the following.
01:00:23.110 - 01:00:36.200, Speaker A: So what's happening in the following existing exercise, two. All right, let's read it. Okay, so here's a bunch of import stuff.
01:00:36.650 - 01:00:38.342, Speaker B: Then there's a variable here.
01:00:38.396 - 01:00:39.682, Speaker A: Okay, storage variable.
01:00:39.746 - 01:00:41.226, Speaker B: I'll go read that after.
01:00:41.408 - 01:00:43.674, Speaker A: What I really want is this.
01:00:43.712 - 01:00:43.962, Speaker C: Right?
01:00:44.016 - 01:00:46.646, Speaker A: I want to trigger these two functions.
01:00:46.678 - 01:00:47.482, Speaker B: I want to get the function.
01:00:47.536 - 01:00:47.754, Speaker C: Okay.
01:00:47.792 - 01:00:52.960, Speaker A: So in order to get to that function, I need to validate everything that is happening here.
01:00:53.410 - 01:00:56.110, Speaker B: Okay, so what is this contract doing, really?
01:00:56.260 - 01:00:58.554, Speaker A: Okay, so this is an SGC sender.
01:00:58.602 - 01:01:08.498, Speaker B: This is my address. So here it's reading a value from storage. It's called my success value. Interesting. Okay.
01:01:08.584 - 01:01:22.120, Speaker A: And then it's verifying, oh, look, this function is different. It takes an argument, right? So I'm sending something to my function, and then it's just verifying that the value I sent is equal to my secret value.
01:01:22.650 - 01:01:28.490, Speaker B: And this assert is the equivalent of required and solidity.
01:01:29.150 - 01:01:35.306, Speaker A: Okay, I understand. So I need to figure out what is this value and provide it to the function.
01:01:35.408 - 01:01:36.060, Speaker C: Right.
01:01:40.350 - 01:01:41.530, Speaker F: How do I do that?
01:01:41.600 - 01:01:50.666, Speaker B: Okay, control f. Okay, so it's a storage variable. So it's just reading the storage variable called my secret value storage.
01:01:50.778 - 01:01:51.614, Speaker C: Okay, cool.
01:01:51.652 - 01:01:53.682, Speaker A: So I'll just go on Voyager and read it.
01:01:53.736 - 01:01:54.340, Speaker C: Right.
01:01:55.510 - 01:02:14.790, Speaker A: So let's go there. All right. Read contract, a bunch of stuff. My secret value, wait, this is not what exactly I seen in the contract. Right here it says my secret value. And here it says my secret value storage.
01:02:16.010 - 01:02:16.760, Speaker C: Okay.
01:02:17.210 - 01:02:19.914, Speaker B: All right, there's a view function here.
01:02:20.032 - 01:02:20.700, Speaker C: Yes.
01:02:21.470 - 01:02:29.414, Speaker A: That's the point of this exercise. It explains to you how you store a value in Cairo. So you don't have public or private.
01:02:29.462 - 01:02:42.174, Speaker B: Variables in Cairo, you just have private variables. By default. Your storage variables here are, by default, private people can't see them if you don't provide a getter. So if you want to build a.
01:02:42.212 - 01:03:05.222, Speaker A: Public variable, you have to implement a getter. What does the getter do? Okay. Basically just takes nothing as an input and it returns a value, which is my secret value, and it goes to read my secret value storage. And it returns it. Okay, so actually my secret value in Voyager is my secret value storage. Fine. So what should I do?
01:03:05.276 - 01:03:06.886, Speaker B: Okay, thank you.
01:03:06.988 - 01:03:07.926, Speaker A: Thank you.
01:03:08.108 - 01:03:09.770, Speaker B: I'm going to keep this here.
01:03:09.920 - 01:03:11.660, Speaker A: Okay, so let's read that.
01:03:12.430 - 01:03:15.242, Speaker B: Oh, the date of birth of myself.
01:03:15.376 - 01:03:16.394, Speaker C: Very cool.
01:03:16.592 - 01:03:23.998, Speaker A: So this is a sequence value, right? I should implement it in the contract. I should send it, right? So if I send it here, I.
01:03:24.004 - 01:03:25.280, Speaker C: Should get the points, right?
01:03:26.130 - 01:03:29.774, Speaker A: So do you want me to try to put something else?
01:03:29.892 - 01:03:32.000, Speaker B: Let's see what happens. Will I get the points?
01:03:32.790 - 01:03:37.826, Speaker A: Okay, sending the transaction. Thank you, Mr. Arjon. I'm going to send my transaction and.
01:03:37.848 - 01:03:39.060, Speaker B: Let'S see what happens.
01:03:42.550 - 01:03:44.366, Speaker A: Okay, so the transaction has been received.
01:03:44.398 - 01:03:45.940, Speaker B: Let's wait a bit and see what happens.
01:03:48.390 - 01:03:53.494, Speaker A: Okay. Obviously reading out loud the exercises, but.
01:03:53.532 - 01:03:55.000, Speaker B: I know that I wrote it.
01:03:55.690 - 01:03:58.040, Speaker A: If you have any questions, please ask.
01:04:00.810 - 01:04:01.560, Speaker C: Yes.
01:04:08.810 - 01:04:11.120, Speaker D: Define there.
01:04:17.570 - 01:04:20.080, Speaker A: So you mean the ability to import from.
01:04:23.110 - 01:04:29.140, Speaker D: Contracts? There's no, like.
01:04:31.910 - 01:04:32.882, Speaker A: That's a good question.
01:04:32.936 - 01:04:43.990, Speaker B: I've never tried it, so I'm not sure, but no, I think you can't. One contract, one file. There are some things you can define.
01:04:44.730 - 01:04:49.926, Speaker A: Specifically for contract interfaces. You can define an interface inside a.
01:04:49.948 - 01:04:58.938, Speaker B: Contract, and you will be able to interact with it. But no, I think you have to have one contract. Okay.
01:04:59.024 - 01:04:59.562, Speaker C: Oh, wow.
01:04:59.616 - 01:05:01.606, Speaker A: My transaction has been rejected.
01:05:01.718 - 01:05:02.282, Speaker B: Cool stuff.
01:05:02.336 - 01:05:03.406, Speaker A: I didn't even upload it.
01:05:03.428 - 01:05:05.070, Speaker B: It pushed it to my browser.
01:05:05.650 - 01:05:08.286, Speaker A: Okay, so I don't get that much information here.
01:05:08.388 - 01:05:09.934, Speaker B: I want to show you this.
01:05:10.132 - 01:05:15.434, Speaker A: Basically, here, if I use the URL I gave you, it will give me a bit more info.
01:05:15.562 - 01:05:16.106, Speaker C: Right.
01:05:16.228 - 01:05:17.460, Speaker B: So what is happening?
01:05:18.790 - 01:05:24.226, Speaker A: So here it's saying, okay, so something. It's not very explicit, right?
01:05:24.248 - 01:05:26.054, Speaker B: But it does tell me what the answer is.
01:05:26.172 - 01:05:34.280, Speaker A: It's telling me. Okay, so this value was different from this value. So actually, if you go back to the code, you can actually see that.
01:05:39.070 - 01:05:40.140, Speaker C: Oh, my God.
01:05:40.750 - 01:05:42.042, Speaker A: You can actually see that.
01:05:42.096 - 01:05:43.210, Speaker B: This is what.
01:05:43.360 - 01:05:49.206, Speaker A: Remember that assert, okay, it very equal.
01:05:49.238 - 01:05:50.122, Speaker B: To the secret value.
01:05:50.176 - 01:05:51.180, Speaker F: It was not.
01:05:52.690 - 01:05:55.342, Speaker A: Okay, did I get point?
01:05:55.396 - 01:05:56.000, Speaker C: Maybe.
01:06:01.890 - 01:06:03.460, Speaker B: Come on, give me a point.
01:06:04.390 - 01:06:06.642, Speaker A: Okay, so let's try with the right value this time.
01:06:06.696 - 01:06:21.854, Speaker B: Okay, so let's do this one. Of course we should have a point. Okay, so you have the general gist of it, right?
01:06:21.912 - 01:06:24.230, Speaker A: And understanding this should give you enough.
01:06:24.300 - 01:06:27.366, Speaker B: Tools for you to move to the.
01:06:27.388 - 01:06:29.030, Speaker F: End of the tutorial.
01:06:29.770 - 01:06:31.494, Speaker A: As Louis said, the more you will.
01:06:31.532 - 01:06:34.234, Speaker B: Progress in the tutorial and the more you'll get points.
01:06:34.432 - 01:06:36.506, Speaker A: And if you're proving to us that.
01:06:36.528 - 01:06:39.866, Speaker B: You have, I don't know if we close the threshold, I don't know how many t shirts we have.
01:06:39.888 - 01:06:43.438, Speaker A: Ten points. I say ten points for you to.
01:06:43.444 - 01:06:48.080, Speaker B: Be able to save your spot for the next workshop. But I think there'll be spot anyway.
01:06:48.770 - 01:06:50.302, Speaker A: But we need to figure out something.
01:06:50.356 - 01:06:51.550, Speaker B: For the t shirt.
01:06:54.370 - 01:06:56.834, Speaker A: So if you are able to show.
01:06:56.872 - 01:07:01.630, Speaker B: Us your address and show us that you have points. Then you will get a picture.
01:07:01.710 - 01:07:02.434, Speaker A: Pretty cool, right?
01:07:02.472 - 01:07:08.120, Speaker B: And you'll gain knowledge, you'll know how to win. Pilot smart contract, which is pretty cool. You had a question.
01:07:10.810 - 01:07:13.590, Speaker D: Delay transaction.
01:07:16.970 - 01:07:17.720, Speaker C: Yeah.
01:07:21.050 - 01:07:32.720, Speaker D: Background means yeah.
01:07:35.170 - 01:07:41.278, Speaker A: So on the back end, what is happening when you're sending a transaction, the.
01:07:41.284 - 01:07:44.274, Speaker B: Payload is sent to our infrastructure, which.
01:07:44.312 - 01:07:47.586, Speaker A: Basically will include your transaction in a.
01:07:47.608 - 01:07:49.422, Speaker B: Block for it to be later proved.
01:07:49.486 - 01:08:11.298, Speaker A: So first it will execute your transaction. So it receives constantly a bunch of transactions, some of them more complex than others, and these transactions are deputed and executed. Once they're executed and they're deemed valid by our infrastructure, then they are marked accepted on l two, you know that.
01:08:11.324 - 01:08:13.660, Speaker B: They will be included in a block, right.
01:08:14.430 - 01:08:17.894, Speaker A: Then they move to the states where, okay, we have finalized the block.
01:08:17.942 - 01:08:24.060, Speaker B: Like this is a block. So this is the second following state.
01:08:24.850 - 01:08:26.666, Speaker A: I'm not sure if this is accepted.
01:08:26.698 - 01:08:29.902, Speaker B: On l two, if there's a state in between, but this is what's happening.
01:08:30.036 - 01:08:32.206, Speaker A: And then eventually the proverb will take.
01:08:32.228 - 01:08:34.786, Speaker B: A bunch of blocks, prove them, and.
01:08:34.808 - 01:08:36.914, Speaker A: Then send that proof to l one.
01:08:36.952 - 01:08:38.530, Speaker B: For it to be authenticated.
01:08:39.350 - 01:08:41.794, Speaker A: Now I think your question is also.
01:08:41.832 - 01:08:44.754, Speaker B: Like, this is slow, and this is.
01:08:44.792 - 01:08:46.686, Speaker A: True, it is very slow.
01:08:46.718 - 01:08:50.850, Speaker B: It's alpha software. And I think there's two reasons why it's slow.
01:08:51.010 - 01:08:59.210, Speaker A: The first is that it's still in development and we are constantly pushing the limit.
01:08:59.790 - 01:09:03.514, Speaker B: Soon as you offer more bandwidth or.
01:09:03.552 - 01:09:07.082, Speaker A: More computational capability, then you get it's built.
01:09:07.136 - 01:09:08.790, Speaker B: Instantly you have more people joining.
01:09:08.870 - 01:09:09.306, Speaker C: Right.
01:09:09.408 - 01:09:13.614, Speaker B: And so we're a bit battling with that. We want to focus for the next.
01:09:13.652 - 01:09:17.294, Speaker F: Six months rf on making this much.
01:09:17.332 - 01:09:19.440, Speaker B: Faster to solve exactly the problem.
01:09:20.690 - 01:09:27.650, Speaker A: And one of the reason why this is the case is that there's no fees on startnet.
01:09:28.470 - 01:09:29.780, Speaker B: Weird, right?
01:09:30.390 - 01:09:33.186, Speaker A: Basically because in order to operate the.
01:09:33.208 - 01:09:35.786, Speaker B: Network centralized, we don't really need fees.
01:09:35.838 - 01:09:36.294, Speaker C: Right.
01:09:36.412 - 01:09:39.286, Speaker A: And so we basically first implemented the.
01:09:39.308 - 01:09:43.670, Speaker B: Network and the programming language and the platform.
01:09:43.820 - 01:09:47.746, Speaker A: And then we said, okay, so let's add fees, then let's add the centralization.
01:09:47.858 - 01:09:49.240, Speaker B: And stuff like that.
01:09:49.610 - 01:09:54.778, Speaker A: So fees are in the process of being added. They will be added, I think in.
01:09:54.784 - 01:09:56.874, Speaker B: The next month, in the next few.
01:09:56.912 - 01:10:06.894, Speaker A: Weeks, you'll have a way to include in your wallet the fees so that they will not be taken into account, but you'll be able to include them.
01:10:06.932 - 01:10:08.830, Speaker B: In your workflow, in your wallet.
01:10:09.170 - 01:10:12.798, Speaker A: And then they will be enforced, meaning that they will be taken when you.
01:10:12.804 - 01:10:16.942, Speaker B: Want to pay fees, and then they will be mandatory, meaning that you will have to pay fees.
01:10:17.006 - 01:10:18.814, Speaker A: But today you can broadcast a transaction.
01:10:18.862 - 01:10:20.190, Speaker B: Without paying any fees.
01:10:20.270 - 01:10:20.706, Speaker A: Of course.
01:10:20.728 - 01:10:28.760, Speaker B: The network is tab, right. If things are free, why care about optimizing your code?
01:10:31.370 - 01:10:38.440, Speaker A: The short answer is six three. So it's occupied and we're working on it.
01:10:48.170 - 01:10:51.520, Speaker D: Question right now I put it.
01:10:57.570 - 01:11:05.570, Speaker A: Okay, so I think your first question is what you should expect in terms of performances. Is that it?
01:11:05.640 - 01:11:06.260, Speaker C: No.
01:11:10.470 - 01:11:12.900, Speaker A: Okay, sure. Yeah, sure.
01:11:16.330 - 01:11:19.800, Speaker B: I've asked this question a lot in the past week and I probably.
01:11:22.330 - 01:11:26.534, Speaker A: So we have short term solutions then.
01:11:26.572 - 01:11:37.066, Speaker B: A longer term solution, I think for the short term solutions which will be deployed next week, I'm not sure, to be honest, what exactly this is.
01:11:37.088 - 01:11:39.766, Speaker A: So I don't understand medium term.
01:11:39.798 - 01:11:42.166, Speaker B: What I can tell you is we're.
01:11:42.198 - 01:11:44.890, Speaker A: Working on three things. The first one is recursion.
01:11:45.050 - 01:11:47.114, Speaker B: So if you're able to prove proof.
01:11:47.162 - 01:11:49.230, Speaker F: Inside the proof, then you can parallel.
01:11:49.730 - 01:11:54.190, Speaker B: What you're receiving and you can write multiple syntaxes.
01:11:55.110 - 01:12:08.406, Speaker A: The second thing is that right now Cairo and Starknet are implemented. It's linked to Python, right. And the ecosystem is in python, which.
01:12:08.428 - 01:12:19.900, Speaker B: Is not the most efficient. So we're working to reimplement it, the Kyro VM in rust to make it faster. So that's the things we're going to work for the next few months.
01:12:21.310 - 01:12:26.346, Speaker A: So yeah, in terms of execution, it will be faster and then you'll be.
01:12:26.368 - 01:12:29.338, Speaker B: Able to parallelize way more.
01:12:29.504 - 01:12:41.294, Speaker A: Okay, then your second question is, what makes it possible, impossible for you to make an infinite loop? Basically each action you're doing in a smart contract is called a step, and.
01:12:41.332 - 01:12:48.242, Speaker B: There'S a limit in terms of steps you can do in your own transaction. There was another question.
01:12:48.296 - 01:12:48.900, Speaker C: Yes.
01:12:52.470 - 01:12:59.240, Speaker A: Can you speak louder? Do you have any plans to build some time up.
01:13:01.530 - 01:13:04.280, Speaker B: Web three wrapper? Yeah, thank you.
01:13:05.050 - 01:13:06.440, Speaker A: Yes, actually.
01:13:09.310 - 01:13:10.874, Speaker B: We are not building it.
01:13:10.912 - 01:13:27.534, Speaker A: In house, but we have a team from the community who is working on start net JS. And you already have some actually pretty cool website. The guys who are working on it, actually, I'm saying there's three different companies working on that.
01:13:27.732 - 01:13:29.230, Speaker B: There is Oasis.
01:13:32.930 - 01:13:34.526, Speaker A: NFT marketplace, which is.
01:13:34.548 - 01:13:39.426, Speaker B: Live now, and you can basically build.
01:13:39.448 - 01:13:43.278, Speaker A: Their own interface around it. Then ours obviously is contributing to Starknet.
01:13:43.294 - 01:13:46.610, Speaker B: Js, and then another company called Shorty.
01:13:47.030 - 01:14:00.666, Speaker A: So we do have a webflow wrapper. So the tutorial I'm showing to you is just the first one of a very long series. The next one will be ERC 721, then ERC 20, then I want to.
01:14:00.688 - 01:14:02.646, Speaker B: Have one around how to build kick.
01:14:02.678 - 01:14:07.034, Speaker A: Ass UX around Starknet, and then I.
01:14:07.072 - 01:14:16.560, Speaker B: Want to do one on the l one l two bridge mechanism, which is super cool in Starknet. And that really allows you a lot.
01:14:18.370 - 01:14:23.374, Speaker A: So there will be materials eventually to.
01:14:23.412 - 01:14:25.294, Speaker B: Help you do that.
01:14:25.492 - 01:14:30.514, Speaker A: Okay, so maybe what I can do. I know a lot of you have already, I mean, a quite decent number.
01:14:30.552 - 01:14:32.610, Speaker B: Of you actually have already done the tutorial.
01:14:33.190 - 01:14:36.278, Speaker A: And those of you who haven't, now you have the keys to move on.
01:14:36.284 - 01:14:37.698, Speaker B: To the next exercise.
01:14:37.874 - 01:14:39.986, Speaker A: Be careful. Don't be too much on ape.
01:14:40.018 - 01:14:45.320, Speaker B: There are some traps here. And there are some traps here.
01:14:47.630 - 01:14:48.380, Speaker C: Yes.
01:14:51.630 - 01:14:59.260, Speaker D: About the famous security issue, how.
01:15:07.330 - 01:15:07.694, Speaker C: I.
01:15:07.732 - 01:15:12.430, Speaker F: Think it's, the ecosystem is emerging.
01:15:15.910 - 01:15:24.674, Speaker A: There'S not a lot of real value stored sarknet. And so these things, you get to learn them eventually. I think a lot of them will.
01:15:24.712 - 01:15:28.422, Speaker B: Be applicable from solidity to mean like.
01:15:28.476 - 01:15:39.430, Speaker A: If you're building lending platform on Ethereum, you know that you're not supposed to use a price oracle from an Amm because it's gameable. Because of, I mean, this is obviously.
01:15:39.500 - 01:15:40.982, Speaker B: The case also in Starknet.
01:15:41.046 - 01:15:43.900, Speaker F: So a lot of all those things.
01:15:44.270 - 01:15:46.378, Speaker A: You'Ll be know that if it's the.
01:15:46.384 - 01:15:48.422, Speaker B: Case on ethereum, clickable on Starknet.
01:15:48.566 - 01:15:50.882, Speaker A: Are there some things that are specific to Starknet?
01:15:50.966 - 01:15:56.240, Speaker B: I'm not sure. I'm not sure yet.
01:16:00.930 - 01:16:02.110, Speaker D: Overflow?
01:16:03.890 - 01:16:08.546, Speaker A: Yeah, so I think overflow will be.
01:16:08.568 - 01:16:12.594, Speaker B: An issue for sure because the number system is a bit different.
01:16:12.792 - 01:16:16.158, Speaker A: I think where we're going to learn a lot is going to be around.
01:16:16.184 - 01:16:18.086, Speaker B: The l one l two interaction, because.
01:16:18.188 - 01:16:19.602, Speaker A: You don't really have that on ethereum.
01:16:19.666 - 01:16:20.182, Speaker C: Right.
01:16:20.316 - 01:16:30.634, Speaker A: And the fact that you're able to send a message will include very different dynamics and vulnerabilities. And this is going to be very.
01:16:30.672 - 01:16:35.834, Speaker B: Interesting to watch play out because first you'll have people who will implement it.
01:16:35.872 - 01:16:38.074, Speaker A: Incorrectly, and then you will have people.
01:16:38.112 - 01:16:41.260, Speaker F: We implement forgot something?
01:16:43.570 - 01:16:47.086, Speaker A: But it's a very. Sending messages from l one to l.
01:16:47.108 - 01:16:48.734, Speaker B: Two feels a bit like sending a.
01:16:48.772 - 01:17:02.754, Speaker A: Pro because you're sending a message that will take hours to reach the destination and something happens and then it can come back. And so it's a different kind of smart contract tool. This is going to be very fun.
01:17:02.792 - 01:17:09.110, Speaker B: To play with, to be honest. The bridge is really a fun tool. You can build all kind of stuff.
01:17:09.260 - 01:17:19.594, Speaker A: Like recently I realized that you can actually have the smart contract wallet on L1, and from l two you can send him the payload to tell.
01:17:19.632 - 01:17:23.260, Speaker B: Him, call this contract with that function, which is.
01:17:27.230 - 01:17:27.642, Speaker C: Okay.
01:17:27.696 - 01:17:33.806, Speaker A: So those of you who have done the tutorial, maybe you're still a bit hungry, so I'm going to show something else those of you who have not.
01:17:33.828 - 01:17:35.246, Speaker B: Done the tutorial, now you know how.
01:17:35.268 - 01:17:42.042, Speaker A: To do it, so get, we're here, we have starknet t shirts and we are on discord.
01:17:42.106 - 01:17:43.354, Speaker B: We're live on telegram.
01:17:43.402 - 01:17:44.254, Speaker A: So do reach out.
01:17:44.292 - 01:17:47.060, Speaker B: We'll be more than happy to help you out and answer your questions.
01:17:47.510 - 01:17:50.580, Speaker A: And for the others, I'm going to show you another.
01:17:51.910 - 01:18:01.574, Speaker B: Actually, I'm going to show you something cool. So this one is public, it's ERC 721.
01:18:01.612 - 01:18:11.606, Speaker A: It's the one I'm going to show you. And this one is still private, fancy, but we're going to release it, I.
01:18:11.628 - 01:18:16.522, Speaker B: Think, within the next two weeks. And it's going to be basically how to use ERC 20 for start test.
01:18:16.656 - 01:18:17.738, Speaker A: And then this one will be a.
01:18:17.744 - 01:18:19.938, Speaker B: Tutorial on how to use the messaging bridge.
01:18:20.054 - 01:18:20.718, Speaker C: Okay?
01:18:20.884 - 01:18:21.760, Speaker B: But now.
01:18:25.010 - 01:18:31.562, Speaker A: It'S a bit of the structure of a big readme and then you have to read some code and do some action.
01:18:31.706 - 01:18:34.046, Speaker B: The main difference with this all, for.
01:18:34.068 - 01:18:48.550, Speaker A: The first tutorial, all you have to do is read code and interact with it. You don't need to write code. Okay. For this one, I want you to write code, deploy it, and then have my smart contract.
01:18:49.050 - 01:18:49.800, Speaker C: Correct.
01:18:50.410 - 01:19:07.706, Speaker A: Okay, so instead of having a bunch of contracts here in the contract folder, there's one contract called the evaluator. In the evaluator there are various parts. The first one you should care about is this one.
01:19:07.728 - 01:19:09.050, Speaker B: It's called submit.
01:19:10.110 - 01:19:12.942, Speaker A: It's basically a function where you will.
01:19:12.996 - 01:19:21.850, Speaker B: Send the address of an ERC 721 deployed on Startnet. So your job is to deploy one on startnet.
01:19:21.930 - 01:19:24.546, Speaker F: Then you send it to the, this.
01:19:24.568 - 01:19:47.170, Speaker A: Is the equivalent of you turning your homework to, right. And once you've submitted that exercise, you can tell the teacher, okay, so please now correct it. And above this you have a bunch of functions. And all of these functions will basically interact with your smart contract and verify.
01:19:47.250 - 01:19:50.234, Speaker B: If your smart contract does a certain number of things.
01:19:50.352 - 01:19:50.970, Speaker C: Right.
01:19:51.120 - 01:19:53.398, Speaker A: And so the objective of that tutorial.
01:19:53.494 - 01:19:55.610, Speaker B: Is for you to deploy your contract.
01:19:55.950 - 01:20:00.474, Speaker A: Implement specific things in them, but also.
01:20:00.592 - 01:20:03.774, Speaker F: Read the evaluator, figure out how to.
01:20:03.972 - 01:20:06.240, Speaker A: So what does the evaluator do exactly?
01:20:06.610 - 01:20:13.390, Speaker B: So here it's going to get your address here, it's going to come back to this later.
01:20:13.540 - 01:20:24.998, Speaker A: Then it's going to verify that you submitted smart contract address as a solution. It's verifying that you gave your homework. Then what is it doing?
01:20:25.044 - 01:20:29.446, Speaker B: It's going to check that it's going.
01:20:29.468 - 01:20:31.810, Speaker A: To retrieve here from your contract.
01:20:31.890 - 01:20:32.326, Speaker C: Right.
01:20:32.428 - 01:20:35.190, Speaker A: You specify it will retry from his.
01:20:35.260 - 01:20:37.794, Speaker B: Storage the address of your homework.
01:20:37.922 - 01:20:40.358, Speaker A: And it will verify that when he.
01:20:40.364 - 01:20:42.666, Speaker B: Calls the function owner of with the.
01:20:42.688 - 01:20:44.794, Speaker A: Parameter token id that was defined here.
01:20:44.832 - 01:20:51.580, Speaker B: Which is token one, it will retrieve the owner of token one.
01:20:51.950 - 01:20:57.066, Speaker A: Okay, so what is corrected here exactly? Well, corrected that you have implemented owner.
01:20:57.098 - 01:21:01.966, Speaker B: Of as a function, right? Because if you didn't, then it failed at this point.
01:21:02.068 - 01:21:13.202, Speaker A: And then evaluates that the address of the evaluator is the same as the own. In other words, it verifies that you deployed an ERC 721, that you gave.
01:21:13.256 - 01:21:15.250, Speaker B: Token one to the evaluator.
01:21:15.770 - 01:21:29.466, Speaker A: Pretty straightforward, right? And then it will verify that you implemented basic us 721 function. So it will retrieve the balance, then it will do a transfer, then it.
01:21:29.488 - 01:21:33.898, Speaker F: Will balance change, and so on and so on.
01:21:33.984 - 01:21:37.706, Speaker A: It's very simple. And really what you have to do.
01:21:37.728 - 01:21:40.058, Speaker B: Is just deploy an ERC 721.
01:21:40.144 - 01:22:06.850, Speaker A: I should probably in the tutorial explain a bit more how to deploy an ERC 721 token. But you're lucky, because if you look here in the repo, there's a bunch of implementation. And so here you can use the ERC 721 template that was designed by open Zeppelin. And basically you'll have to figure out how to deploy a token from these files.
01:22:07.430 - 01:22:09.222, Speaker B: The goal of that tutorial is really.
01:22:09.276 - 01:22:11.430, Speaker A: To push you to do the same.
01:22:11.500 - 01:22:13.730, Speaker B: Thing you do when you're on Ethereum.
01:22:13.810 - 01:22:18.086, Speaker A: You go to open Zeppelin, you take their contract, you customize it, maybe you.
01:22:18.108 - 01:22:22.090, Speaker B: Add a mentor, maybe you build some token in the contractor, do all this kind of stuff.
01:22:22.240 - 01:22:23.786, Speaker A: And basically it pushes you to do.
01:22:23.808 - 01:22:26.586, Speaker B: Exactly that with Cairo and start.
01:22:26.768 - 01:22:29.830, Speaker A: Okay, so that's the first question of my tutorial.
01:22:29.910 - 01:22:31.114, Speaker B: But then you get a bunch of.
01:22:31.152 - 01:22:32.446, Speaker A: Others, because then I want you to.
01:22:32.468 - 01:22:39.120, Speaker B: Make the contract more rich. I want you to add some specific characteristics for the.
01:22:41.170 - 01:22:43.690, Speaker A: I want you to add some characteristics to your token.
01:22:43.770 - 01:22:50.146, Speaker B: I want you to be able to mint them, burn them, all of this. Right, so this is really just a.
01:22:50.168 - 01:23:07.106, Speaker A: Tutorial for you to get a quick on how you. And the next one we're going to deploy. Okay, so that's about it for the tutorial.
01:23:07.138 - 01:23:08.040, Speaker C: Yes. Question.
01:23:10.350 - 01:23:29.162, Speaker A: What was. Yeah, so what was the Starknet graffiti about? Starnet graffiti is from, and it's basically a small demonstration how you send messages.
01:23:29.226 - 01:23:38.510, Speaker B: From to l one. Basically the way most side chains and l two work today is that there's a bridge.
01:23:38.670 - 01:23:42.590, Speaker A: So there's a smart contract and you can transfer assets which are basically ERC.
01:23:42.670 - 01:23:44.340, Speaker F: 20 and ESC 720.
01:23:45.450 - 01:23:46.806, Speaker C: But that's it.
01:23:46.988 - 01:23:51.640, Speaker B: If you want to just say, send a message that say, I want to l one.
01:23:52.170 - 01:23:53.798, Speaker F: It's not true, right?
01:23:53.884 - 01:23:59.034, Speaker B: Or for example, one thing you could want to do is say you want.
01:23:59.072 - 01:24:02.874, Speaker F: To and you think the people will.
01:24:02.912 - 01:24:10.298, Speaker A: Use your NFD, want to play with it, not necessarily sell it, right? So it's important for the NFD to.
01:24:10.304 - 01:24:11.350, Speaker B: Be on open sea.
01:24:11.430 - 01:24:15.600, Speaker A: But the thing is, if you mint them on l one, it's going to cost money to a lot of people.
01:24:15.970 - 01:24:20.954, Speaker B: Well, you could mint them on l two capacity to somebody else to bridge.
01:24:21.002 - 01:24:23.802, Speaker F: Them back and this is not trivial.
01:24:23.866 - 01:24:25.342, Speaker B: In order to do that, in most.
01:24:25.396 - 01:24:29.266, Speaker A: Platform you first have to mint them on l one, transfer them on l.
01:24:29.288 - 01:24:34.014, Speaker B: Two and transfer them back. This costs a lot of money with the messaging bridge.
01:24:34.062 - 01:24:35.806, Speaker A: What you can do is basically deploy.
01:24:35.838 - 01:24:40.870, Speaker B: A near system 21 on l one and not mint anything.
01:24:41.020 - 01:24:54.554, Speaker A: But you can tell the contract when you receive that specific payload, 721 on start net, mint a token. And so you can basically have things happen on l one.
01:24:54.592 - 01:24:58.406, Speaker F: Conditioning to things that happen on graffiti.
01:24:58.438 - 01:25:04.206, Speaker A: Was basically it would just give a message from l two, display it as.
01:25:04.228 - 01:25:13.200, Speaker B: An event so that you could just write stuff in l one. We have a cool tutorial coming with that for sure.
01:25:16.210 - 01:25:18.530, Speaker A: All right, I don't know if there are other questions.
01:25:18.600 - 01:25:25.380, Speaker B: I'm going to use one last thing and then I think we're going to wrap up because it's ten minutes to.
01:25:28.410 - 01:25:38.440, Speaker A: So some community member actually built a nice ux which allows you to see how many points you get in each tutorial. So if you connect with.
01:25:40.510 - 01:25:41.178, Speaker B: Our job.
01:25:41.264 - 01:25:43.162, Speaker A: Then you're able to see how many.
01:25:43.216 - 01:25:45.366, Speaker B: Points you got from each tutorial.
01:25:45.478 - 01:25:45.946, Speaker C: Right.
01:25:46.048 - 01:25:50.570, Speaker A: So it shows you your progression, how many points you got on each tutorial.
01:25:51.010 - 01:25:51.760, Speaker F: And.
01:25:52.370 - 01:25:53.440, Speaker C: Pretty cool.
01:25:54.130 - 01:25:55.200, Speaker E: I like it.
01:25:58.130 - 01:25:59.840, Speaker A: What's the website link?
01:26:00.610 - 01:26:03.300, Speaker B: Yeah, let me show you.
01:26:03.990 - 01:26:09.486, Speaker A: The idea here is to make something kind of like DJN's core, but you're.
01:26:09.518 - 01:26:11.060, Speaker C: Learning stuff, so that's fine.
01:26:12.790 - 01:26:21.638, Speaker A: Okay. All right, so I think I said most of what I wanted to do to say this was interesting.
01:26:21.724 - 01:26:29.260, Speaker B: So thank you for your attention. I hope you learned a lot of stuff and that this made you want to explore more what we are building.
01:26:31.150 - 01:26:36.522, Speaker A: For this session. We talked a lot and then I showed you the tutorial for the next session on.
01:26:36.576 - 01:26:39.402, Speaker F: First I think it would be really.
01:26:39.456 - 01:26:40.460, Speaker B: Cool if.
01:26:42.350 - 01:26:44.778, Speaker F: I'll give the tutorial the.
01:26:44.784 - 01:26:52.126, Speaker B: Same one idea at the end and then I'll just shut the mic and.
01:26:52.148 - 01:26:53.850, Speaker A: Then I'll go around and then we'll.
01:26:53.930 - 01:27:00.800, Speaker B: Answer your question and help you deploy stuff. Okay, so I'll just showcase how we do stuff and we'll do the tutorial live.
01:27:02.610 - 01:27:04.914, Speaker A: I think what would be very beneficial.
01:27:05.002 - 01:27:07.206, Speaker B: You want to attend this session and.
01:27:07.228 - 01:27:21.274, Speaker A: Make the most out of it is clone the repo and set up the environment, meaning go into the set of the environment, instruction in the GitHub and install all the tools and make sure.
01:27:21.312 - 01:27:24.262, Speaker B: You'Re able to compile the smart contracts.
01:27:24.406 - 01:27:26.554, Speaker A: If you're able to compile, you will.
01:27:26.592 - 01:27:28.220, Speaker B: Have saved so much time.
01:27:31.630 - 01:27:35.280, Speaker A: I know there's a lot of people coming here to act and build cool stuff.
01:27:36.050 - 01:27:37.534, Speaker B: If you want to build a cool.
01:27:37.572 - 01:27:41.166, Speaker A: App with Darknet this weekend, we'll be here.
01:27:41.348 - 01:27:43.230, Speaker B: So do reach out.
01:27:43.380 - 01:27:47.040, Speaker F: We're more than happy to give you our time.
01:27:47.890 - 01:28:01.782, Speaker B: We flew all the way to from Europe here with you guys, so don't let us down. Otherwise you're going to spend time in coffee shops drinking coffee. I had one smart thing to say.
01:28:01.836 - 01:28:02.440, Speaker C: But.
01:28:07.850 - 01:28:15.606, Speaker A: We have start net focused hackathons coming. We have one in April. It's an online hackathon, so wherever you're.
01:28:15.638 - 01:28:26.054, Speaker B: From you can join and we'll have online sessions to explain to you how to get a hold of Startnet and do worksheet. And then you'll build stuff on Startnet.
01:28:26.102 - 01:28:28.286, Speaker F: Then we'll have another hackathon which be.
01:28:28.308 - 01:28:31.166, Speaker A: On site in Amsterdam during Devconnect in.
01:28:31.188 - 01:28:33.774, Speaker B: April, which will be pretty cool actually.
01:28:33.812 - 01:28:34.826, Speaker A: We're closing on the venue.
01:28:34.858 - 01:28:41.040, Speaker B: It's going to be magnificent. You had a question?
01:28:43.010 - 01:28:43.326, Speaker C: No.
01:28:43.348 - 01:28:47.080, Speaker A: So these are two different hackathons. One is online. Was it on site?
01:28:47.450 - 01:28:50.760, Speaker B: One is on site. Both will be great.
01:28:51.130 - 01:28:51.734, Speaker C: Cool.
01:28:51.852 - 01:28:54.760, Speaker A: Okay, so thank you for your time, and until next time.
01:28:59.530 - 01:29:00.340, Speaker F: You our channel.
