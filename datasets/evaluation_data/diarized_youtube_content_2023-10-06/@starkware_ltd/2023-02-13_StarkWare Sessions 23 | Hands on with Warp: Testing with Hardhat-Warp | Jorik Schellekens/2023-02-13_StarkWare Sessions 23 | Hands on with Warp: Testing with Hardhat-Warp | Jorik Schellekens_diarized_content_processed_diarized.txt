00:00:00.810 - 00:00:01.360, Speaker A: You.
00:00:03.650 - 00:00:21.710, Speaker B: Good to see you all here. And I'm actually very, very happy to see that there are a bunch of laptops out onto the tables and that you guys might actually be following along. I recommend I'm going to just, like, throughout the talk, I might actually just stop for, like, a couple of minutes and let you guys play with what I've just been discussing and then move on.
00:00:21.860 - 00:00:22.560, Speaker A: Right.
00:00:23.970 - 00:00:47.046, Speaker B: It's a bit unorthodox. Everything is in terminal here. So if I fluff up or accidentally delete everything that I'm trying to present, just bear with me and we'll get everything back on track. My name is Yurik Schelekens. I work at Nethermind. Nethermind does a lot inside the stackware ecosystem. We've got the full node, we've got warp, we've got the new formal verification tool called Horus.
00:00:47.046 - 00:01:34.874, Speaker B: I'm just going to plug that in here because we released it, like, yesterday. And I'll actually be showing a little demo of that at the end of this talk as a little bonus round for anybody interested in formal verification. And we, of course, have warp, which does transpilation from solidity code to Cairo code. The fun thing with this is that today, in quasi real time, I'm going to deploy uniswap V three tada onto testnet, which is the first time we've done it publicly, and it'll be the first actual address that you can go reference and play around with. So that's kind of cool, right? So what is warp? Basically, you just have your. If you know what warp is, just stick your hands up and I'll skip this section. Okay, that's not enough.
00:01:34.874 - 00:01:57.170, Speaker B: I'm going to explain what warp is. So if you write in solidity code. So say you just have your basic set of functions here. This is like a little subset of ERC 20. You just give it the solidity file, and then you just say warp transpile, and it'll just, boom, put out your cara file. That will work perfectly. Well, now, these are the similar functions.
00:01:57.170 - 00:02:40.734, Speaker B: You can see here that the types are similar. Like an address is inside a felt, so it's represented inside a felt, right? And then all the names are kept the same. Now, if you are familiar with Warp, you'd be like, Yurik, you're a big liar and I am a big liar, because this is not what warp does right now. It does this, which is kind of nasty. So what's happening here is that the names are being mangled with the function selectors from solidity and the reason that we did this was because in solidity you have function overloading. You can say approve, unfelt or approve, sorry, un 160.
00:02:40.852 - 00:02:41.182, Speaker A: Right.
00:02:41.236 - 00:03:05.926, Speaker B: And they will be considered different functions and the selector will be computed differently. So you're allowed to have both instances of the function, and we would just decide them at compile time based on the types. So in order to support that, we mangled everything with the correct selectors. But this leads us into a problem. Here is the Cairo ERC 20 implementation, and you'll see that the names are the same, but they don't have the mangling on them.
00:03:05.948 - 00:03:06.520, Speaker A: Right.
00:03:07.610 - 00:04:02.710, Speaker B: So the long and the short of this, I'm not going to get into this too much because it's not very interesting, but the new version of warp, which will be coming out in a week or two, is going to drop all the mangling on the function interfaces and you can optionally opt for it if you want to have overloading in your solidity contract. And then all of your ERC 20s will work out of the box. So now uniswap V three will work with the standard deployment of wet, right, which is pretty sick. So yeah, that's warp today. Now this is the repo that I'll be working with today. First of all, you need to install warp, so please do that if you've got a laptop in front of you. And check out this unistark repo, which is uniswap modified slightly to be warpable, the list of the modifications should be either listed in the repo or linked in the documentation.
00:04:02.710 - 00:04:23.280, Speaker B: Today, I'm not going to go through the modifications, but if you're around afterwards and you want to talk about what needs to be done, we can talk about that, right. Also, some of the modifications we made in that repo are now supported by warp, so you don't have to do them anymore, which is good. Someone just like give me a nod when things are kind of ready.
00:04:25.030 - 00:04:27.380, Speaker A: Cool. All right.
00:04:29.270 - 00:04:43.698, Speaker B: So the process is quite simple. It's just a compiler, so you just say warp, transpile the file, right. And then if you're familiar with your Starknet, you also have to declare the definitions and you also then need to deploy the contract.
00:04:43.794 - 00:04:44.438, Speaker A: Right.
00:04:44.604 - 00:05:06.638, Speaker B: The inputs that you are providing are just the solidity inputs we will do in the warp compiler, the translation of the solidity types into the Cairo representation of those types, right. So if you pass a u into 56 here, we will do the splitting, and then we will pass it off to Starknet so that it's done correctly. That all makes sense.
00:05:06.804 - 00:05:07.520, Speaker A: Yeah.
00:05:08.850 - 00:05:10.560, Speaker B: These on. Turn these on.
00:05:18.470 - 00:05:19.780, Speaker A: Yeah. Okay.
00:05:20.150 - 00:05:23.874, Speaker B: I'm just going to show you what that looks like.
00:05:24.072 - 00:05:31.366, Speaker C: So here we have the Unistark repo and then. Is this on?
00:05:31.388 - 00:05:31.718, Speaker A: Yeah.
00:05:31.804 - 00:05:46.582, Speaker C: Okay, cool. This is the Uniswap source code. This is everything that is already defined in Uniswap. You've got the base contracts here, you've got uniswap v three pool. You've got the deployer, you've got the factory method.
00:05:46.646 - 00:05:47.162, Speaker A: Right.
00:05:47.296 - 00:05:48.346, Speaker C: One of the really nice things about.
00:05:48.368 - 00:05:50.646, Speaker B: Uniswap of the way they structured is you just have to deploy the factory.
00:05:50.678 - 00:06:22.898, Speaker C: With no arguments in it. Like it all just works out of the box. So if you want to deploy Uniswap today on Starknet, all you have to do is first do just specify the two contracts that you want, which in our case is the factory and the pool. Okay, this is what I meant by quasi real time. I'm not going to run this because 90% of it is spent in Cairo compile.
00:06:22.994 - 00:06:23.446, Speaker A: Right.
00:06:23.548 - 00:06:55.246, Speaker C: And it does take a long time, it's a big contract. So in the interest of keeping this short, I'm just going to control c, this command, and show you what the output looks like. But please try it on your own laptops. Now, while I'm talking and just chatting, shit, you guys can give it a go, right? Cool. So if you're familiar with hard hat, the outputs of what you compile is under artifacts. Now with warp, they're under warp output.
00:06:55.358 - 00:06:56.018, Speaker A: Right.
00:06:56.184 - 00:07:30.578, Speaker C: And then here we actually just have all of the contracts just cross compiled correctly with their associated solidity Abis, which we need to keep a track of so we can do the changes. And also is useful for you if you want to reference later like how a Cairo interface maps to a solidity interface. You can see both the solidity interface under Solabi and the Cairo interface under just underscore Abi, and then the actual compiled contract under underscore compiled.
00:07:30.614 - 00:07:31.198, Speaker A: Right.
00:07:31.364 - 00:07:32.846, Speaker B: And then you would just usually go.
00:07:32.868 - 00:08:12.186, Speaker C: Through the normal like warp, declare your factory. Right, I'm just going to skip over to warp deploy. So here we're going to. Okay, and that's it. You've just deployed one of the biggest amms on solidity to Starknet, and it's going to work just perfectly out of the box. So I'm going to let this run. It's doing a little compile so that there compute some class hashes and make.
00:08:12.208 - 00:08:13.738, Speaker B: Sure that everything is consistent because you.
00:08:13.744 - 00:08:16.454, Speaker C: Can get inconsistent class hashes when it comes to deployments.
00:08:16.502 - 00:08:17.980, Speaker B: So it takes a little time.
00:08:18.590 - 00:08:33.022, Speaker C: Here is one I baked earlier which we can find on Voyager. I have to ref the Voyager as another mind person. But this is our class hash I believe.
00:08:33.156 - 00:08:33.840, Speaker A: Right.
00:08:34.370 - 00:09:05.626, Speaker C: And as you can see it has all the functions that you would expect from an amm. It's got your owner, it's got your get pool, and it's got methods to create pools and set the owners right. And a little while ago I deployed one of these contracts. I think we should now have a new one coming in soon so we can go straight to that address. And here is your just normal class and we can write to the contract. Connect my wallet, no political choice in.
00:09:05.648 - 00:09:06.746, Speaker B: Wallets there, just the first one that.
00:09:06.768 - 00:09:16.298, Speaker C: Shows up and then the create pool is just as you would expect. Token A is you just pass in the address of like maybe Ethereum.
00:09:16.394 - 00:09:17.040, Speaker A: Right.
00:09:17.410 - 00:09:27.940, Speaker C: Does anyone need a particular pool? Ethereum dai USDC what are we feeling? Let's go with raft bitcoin, see how that price is going.
00:09:28.790 - 00:09:29.758, Speaker B: Excellent.
00:09:29.934 - 00:09:33.570, Speaker C: And then just put in the fee and transaction.
00:09:35.270 - 00:09:36.066, Speaker A: Right.
00:09:36.248 - 00:09:48.614, Speaker C: It's happy with it, it's doing some thinking, like how much is this going to cost? This is the point where it's actually quite expensive to deploy. The pool is a very big contract. Now, is it expensive in terms of starknet expensive, not expensive in terms of Ethereum?
00:09:48.662 - 00:09:49.110, Speaker A: Expensive.
00:09:49.190 - 00:09:50.940, Speaker C: So what is this?
00:09:52.190 - 00:09:54.218, Speaker B: Yeah, it's fine.
00:09:54.384 - 00:10:09.166, Speaker C: All right, cool. That is it. That's uniswap V three deployed on testnet, working perfectly. And I recommend that you guys play with Warp, try to do this for your own projects, or try and hook into uniswap V three and see what.
00:10:09.188 - 00:10:10.720, Speaker B: You can build on top.
00:10:12.770 - 00:10:13.520, Speaker C: Q.
00:10:15.830 - 00:10:23.298, Speaker B: Right, well enough of that into some testing. Okay, I'm going to switch back to this.
00:10:23.464 - 00:10:24.180, Speaker A: Cool.
00:10:28.970 - 00:11:00.814, Speaker B: Right, so warp is useful when you want to deploy your contracts onto Starknet. But how do you test this? There are three parts to testing it. One is that we need to test that the semantic transformation of warp is correct, and that is a process that is constantly ongoing. And nevermind. The next steps here are to fuzz the compiler to also do some formal verification of the way that we create the memory model and the storage model. And all of this is still pending work and is to do. There are no guarantees of warp at the moment.
00:11:00.814 - 00:11:15.186, Speaker B: It's like the solidity compiler when it first came out, but it is an incredibly fast way to come over to Starknet. So it's definitely worth playing with and reading the output and understanding what's going on and convincing yourself that it might be correct.
00:11:15.288 - 00:11:15.986, Speaker A: Okay.
00:11:16.168 - 00:12:22.474, Speaker B: Now if you want to test your own code, because you need to change some small things in the solidity to make it work. For example, an address is a UN 160 in Ethereum land, but it's 251 bits in Starknet, right? So if you're trying to convert an address to a UN 160, our compiler will say that's an illegal operation because you're losing information about the address, right? So you need to go through your solidity and make some minor modifications to make sure that those semantics map over. We can't do it for you because if you start treating something as a u and 160, and then you pack it into some buffer and then you send it off and then you unpack it somewhere else, we can't know that that UN 160 unpacked is actually an address, right? So we can't stop you from blowing your foot off. So you have to do the things yourself. There's a list of this on the website, but once you've done all those modifications and you want to be sure that everything is working, what we've done is we've hooked into hard hat, right? So everyone familiar with hard hat and how it works, like no one needs to brush up.
00:12:22.512 - 00:12:23.500, Speaker A: Okay, cool.
00:12:24.190 - 00:12:47.780, Speaker B: What we've done is we've just, like, it was quite an, like, just slammed warp right into the middle of hard hat. And we've said that every time that you're interacting with a contract on the fly, we will convert all the types that you're using and just send the transaction to starknet instead of sending it to Ethereum. So the way that this looks, once again.
00:12:58.870 - 00:13:33.940, Speaker C: Is very simple, right? You have your normal hard hat. This is your hard hat repo. Everyone familiar with the format, the way everything is configured, is in the hardhat config ts in there. You just import the hard hat warp library. And that's literally almost the entire change that you need to make to start testing with warp. You also need to add this thing, which is a very small config to say where your Devnet is for Starknet. That's it, right? Once you have those, you can just do this.
00:13:33.940 - 00:13:53.446, Speaker C: This will take all of your normal hard hat tests, and it will compile all of your solidity contracts to Cairo. It will deploy them all onto this darknet devnet. It will run through your completely unmodified tests, translate all the types and make sure that they are all correct.
00:13:53.628 - 00:13:56.454, Speaker B: And then just give you, like, well done.
00:13:56.492 - 00:13:58.998, Speaker C: All your tests passed, right? And so you just tested all of.
00:13:59.004 - 00:14:01.154, Speaker B: Your solidity code against the Cairo instance.
00:14:01.202 - 00:14:02.410, Speaker C: Which is really cool.
00:14:02.560 - 00:14:04.058, Speaker B: What you're seeing here are parts of.
00:14:04.064 - 00:14:07.574, Speaker C: The devnet, like, printing out because of an annoying routing with Devnets.
00:14:07.622 - 00:14:14.958, Speaker B: We're talking to the Shardlab guys to fix this, but, yeah, don't know if.
00:14:14.964 - 00:14:16.254, Speaker C: It'S worth waiting for, but there's four.
00:14:16.292 - 00:14:17.470, Speaker B: Tests, and they all pass.
00:14:17.540 - 00:14:18.160, Speaker A: Okay.
00:14:20.610 - 00:14:28.514, Speaker C: This same test suite we ran against the entirety of uniswap v three, and it all passes as well. So it seems like we're doing well.
00:14:28.712 - 00:14:29.460, Speaker A: Right?
00:14:32.790 - 00:14:36.594, Speaker C: What does this mean for you? This means that you can actually start developing like this.
00:14:36.632 - 00:14:36.834, Speaker A: Right?
00:14:36.872 - 00:14:49.462, Speaker C: You don't actually need to transpile a project that exists. You can start deploying to starknet using the solidity code that you are now writing, and write the test for it and see that it's working like Starknet immediately.
00:14:49.526 - 00:14:50.042, Speaker A: Right.
00:14:50.176 - 00:14:51.882, Speaker C: Which is pretty cool.
00:14:51.936 - 00:14:52.540, Speaker B: And.
00:14:54.350 - 00:15:04.954, Speaker C: It'S cool that this is just a normal hard hat test file. I didn't have to change anything here. I don't have the types loaded, so it's erroring. But yeah, this is the same deploy.
00:15:05.082 - 00:15:06.240, Speaker B: These are the same.
00:15:07.970 - 00:15:11.630, Speaker C: Checks for your expectations. It all just works out nicely.
00:15:12.370 - 00:15:17.346, Speaker A: Okay. Yeah, right.
00:15:17.528 - 00:15:20.146, Speaker C: Okay, so now you have your solidity code.
00:15:20.328 - 00:15:32.710, Speaker B: Sorry, Matt. Keeping the sound guy on his toes. Okay, you have your solidity code, and it's running on Starknet, and you're like, this is amazing.
00:15:32.780 - 00:15:33.014, Speaker A: Right?
00:15:33.052 - 00:15:40.342, Speaker B: Okay, your ERC 20s work, but I wrote this really cool starknet contract, and it uses felts in the API. What the hell am I going to do now?
00:15:40.396 - 00:15:40.566, Speaker A: Right?
00:15:40.588 - 00:16:05.034, Speaker B: Because solidity doesn't understand what a felt is. And we thought about putting felts into solidity, but it's a very bad idea. So we're not going that way. We have a tool that can help you with this, which is called the warp gen interface tool. So here you have your Cairo contract, which I've called the very cool contract. It does some cool stuff, and it takes in a felt and it returns a felt, right. So in solidity land, you would have no way to interact with this data correctly.
00:16:05.034 - 00:16:06.962, Speaker B: You don't know how it works.
00:16:07.016 - 00:16:07.620, Speaker A: Right.
00:16:07.990 - 00:16:26.754, Speaker B: What this gen interface will do is you point it at the contract that you want, and then it will produce a solidity interface that you can import into your code. So it'll say, this cool contract is, now, I messed up the name here, Cairo contract, and it is function a. And it has a UN 256 argument.
00:16:26.802 - 00:16:27.350, Speaker A: Right.
00:16:27.500 - 00:16:41.574, Speaker B: Now, if you understand your bounds checking, you're going to go like, oh, that's bad. Because if I pass in like max Un 256 in this function and what it receives is a felt. How do we map those types?
00:16:41.622 - 00:16:42.220, Speaker A: Right.
00:16:43.230 - 00:17:32.842, Speaker B: What we do to defend against this is we generate a Cairo contract called a forwarder and it will take in a Un 256 and at runtime do some bounds checking on it, and it will then also safely pack it back into the type that the solidity expects. This is not perfect. And if you've got some cool ideas about how to make this better, come talk to me. I would love to sponsor a project that fixes this in warp, right. But at the moment this works. Now this forwarder gets delegate called by the contract that you have, and there's a special annotation that we've added to the solidity semantics that tells it like don't do a normal call on this delegate call to this, because that contract then needs to call the actual implementation and it needs to look like it came from the original contract.
00:17:32.906 - 00:17:33.230, Speaker A: Right.
00:17:33.300 - 00:17:39.280, Speaker B: Does that make sense? More or less. Running this is just a matter of.
00:17:43.650 - 00:18:09.880, Speaker C: VP gen interface and then boom. Okay, so that's your cool contract there. It's just going to run through it, just going to do a quick compile check to make sure everything's okay. This constant recompilation is something we're going to improve in warp in the next couple of weeks.
00:18:11.290 - 00:18:13.418, Speaker B: Then you get the solidity interface for.
00:18:13.424 - 00:18:15.274, Speaker C: That particular contract just dumped out with.
00:18:15.312 - 00:18:16.538, Speaker B: A class hash here so that we.
00:18:16.544 - 00:18:35.186, Speaker C: Can do a library call. And then you're free to just import this into your code and you just deploy both of these. And then you specify the address that you want this contract to forward to. And then you have contract to contract calling between solidity code and Cairo code unless your AbI is matched, in which.
00:18:35.208 - 00:18:37.394, Speaker B: Case you don't have to do any of this. So if you can get into that.
00:18:37.432 - 00:18:39.090, Speaker C: Case, then you're cold.
00:18:39.910 - 00:18:42.420, Speaker A: All right. Okay.
00:18:47.850 - 00:18:49.910, Speaker B: I think I accidentally closed my slides.
00:18:52.650 - 00:18:53.400, Speaker A: Right.
00:18:55.690 - 00:18:58.730, Speaker C: Okay, so what's on the roadmap for warp?
00:19:00.990 - 00:19:50.042, Speaker B: First of all, in the hard hat warp testing framework, we are going to start dockerizing the Cairo lang. Well, we were thinking of doing this, but actually Cairo one doesn't need this anymore. So we're going to replace this with the Cairo one implementation as soon as it comes out. And we're also going to start supporting the hard hat deployment plugin. So you can just write all of your deployment scripts in hard hat and then it'll just take care of everything for you, right. So then it's just like you're just doing normal solution development for all of your projects then in warp, the big one is Cairo one, right? Because all of your contracts that are being transpiled now are slowly going to have to be phased out. So the Cairo one support has started because we now have ERC 20 supported in Cairo one.
00:19:50.096 - 00:19:50.602, Speaker A: Right.
00:19:50.736 - 00:20:16.786, Speaker B: So we have all the basic primitives that are required for warp to work. We will be improving the storage model because we developed our own one, and I don't like it. So we're going to make a better one. But there's actually a cool open question here that I'd love to talk to people about if anyone's interested. Okay, I'm just ad living. Do I have time? Can I just like. Yeah, I've got like another ten minutes, right.
00:20:16.808 - 00:20:17.380, Speaker A: Okay.
00:20:17.750 - 00:21:15.540, Speaker B: So you're just going to have to focus on me and picture in your head how this works. In a solidity contract, you have all of the inheritance chain, right? You've got the linearized base classes is like the technical term for it. And the way that you lay stuff out in storage is according to slots. The first thing that's declared in the very first contract in this linearized series of base contracts gets the zero slot, right? And for all of the basic types, it's laid out nicely in slot zero up to n. And then if you get to a more complex type, like an array, you just store the length, and then you store the first element at the hash of the array location in memory. So it goes to some random part of storage over here, and then the next one goes over here somewhere, right? So you start hashing around in the memory space. Okay, so I actually don't like this.
00:21:15.540 - 00:22:18.970, Speaker B: What we want to do is we want to take a page out of Cairo's book and we want to say that the storage slot is just the hash of the name, right? So you just say, like, okay, if this is your balances, then we just hash this and we put it in that location, and then we continue. If it's a struct, then it's just like all the subsequent ones. And if it's an array, then we start doing this hash thing around the memory location, right. My question here is, can you hack this? Like if we deploy a contract and it's based off the hashes of the names, can you start defining a structure or maybe pass in like a really long struct or an array that collides with something in the future? Now, I don't think you can do this because the space that you're in is so massive. But I'm wondering if you can reverse engineer any example that's close. So if anyone's interested in thinking about attacks and memory space or storage space, come talk to me afterwards and see if we can figure this one out. But right now I don't see any problems with it because you just lose.
00:22:18.970 - 00:22:36.106, Speaker B: I think it works. All right, cool. Yeah, we're going to have a better cli slant stack. So you're not going to be like doing paths to Cairo files. You just do the path facility files at all times and then just specify the contract in like a suffix.
00:22:36.138 - 00:22:36.286, Speaker A: Right?
00:22:36.308 - 00:23:05.734, Speaker B: That's a very small change. It'll come like in a couple of days and we're going to start doing cached compiles. So right now you'll notice that when you warp declare that we recompile some stuff to check that that class hash is match, we're going to start maintaining a cache and just see like, oh, we've done this compile before, so we're not going to recompute the class hash. That should make things faster. But it's not so relevant when Chiro one comes out and it'll just be like, well, we finished the compile already. I would like to save it. Like it's good housekeeping, but it's not actually that relevant for you guys.
00:23:05.734 - 00:23:23.494, Speaker B: Once Chiro one comes out. And then we're going to break out the part of the hard hat warp that is the ethers library so that all of your front ends can start working nicely with the Starknet version of your code.
00:23:23.552 - 00:23:24.160, Speaker A: Right.
00:23:25.250 - 00:23:32.302, Speaker B: This is most of the way there. Currently it has some requirements that it has expectations that you're using the Devnet, which we just need to get rid of.
00:23:32.356 - 00:23:33.006, Speaker A: Right.
00:23:33.188 - 00:23:43.074, Speaker B: And then the next step after that is that we need to start working with all of the wallets and make sure that their interface is mapped over to the way the wallets on Ethereum expect.
00:23:43.192 - 00:23:43.858, Speaker A: Right?
00:23:44.024 - 00:24:10.490, Speaker B: So you have to write an interface for that. And once you have that in place, literally every front end, every solidity like front end will just work out of the box. So that means you can bring over your uniswap V three front end as well. And you can bring over like maker can come over and just be like, all we need now is graph support, although they're already working on their Kyra implementation. Okay, so that is the end of my talk. I hope it was useful. It's very high level.
00:24:10.490 - 00:24:35.220, Speaker B: So if you want more details, I'm at the booth downstairs. I can tell you about all the transformations you need to do your decode I can tell you some of the implementation details about how we tackled various semantic transformations. And if people are interested, I've got five minutes to talk about the performance of uniswap V three. Is that something that people would be keen on? Let's go.
00:24:35.670 - 00:24:36.900, Speaker A: All right. Okay.
00:24:39.370 - 00:24:53.240, Speaker B: I don't know if that's going to open. Oh, yeah, actually, the pool did deploy. So, guys, if you want to start trading Eth for bitcoin today on testnet early, like, go for it.
00:24:54.170 - 00:24:54.790, Speaker A: Oh, boy.
00:24:54.860 - 00:24:55.522, Speaker B: Low battery.
00:24:55.586 - 00:24:56.440, Speaker A: Let's see.
00:24:57.130 - 00:25:08.320, Speaker B: Right, here we go. I'm not going to get into all of this, but this is a performance analysis of. Oh, that's me over time.
00:25:08.690 - 00:25:09.978, Speaker C: Okay, come talk to me and I'll.
00:25:09.994 - 00:25:19.950, Speaker B: Tell you all about performance of Uniswap e three. And thank you guys very much. I hope it was helpful. Please start deploying some projects. Come and talk to us. We will help you with literally everything. We want to see this in use, so come talk to us, please.
00:25:20.020 - 00:25:20.574, Speaker A: Okay, great.
00:25:20.612 - 00:25:23.200, Speaker B: And good luck. Get your projects out there and see where it goes.
