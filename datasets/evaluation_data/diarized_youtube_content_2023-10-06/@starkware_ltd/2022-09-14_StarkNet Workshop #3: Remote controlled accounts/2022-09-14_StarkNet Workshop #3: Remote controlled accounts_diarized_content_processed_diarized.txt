00:00:00.170 - 00:00:38.334, Speaker A: The project a bit. And I'm going to, little by little, try to add a few elements with you. Feel free to comment. I'm going to try to read them both on YouTube and on. I'm going to try to read the comments. And let's go. So what exactly is it I want to build today? Let me share my screenplay.
00:00:38.334 - 00:01:00.938, Speaker A: Right. Just going to make sure I don't get anything embarrassing in there. All right. And I'm good. So you should now be able to see my screen. I'm going to make font a bit bigger. That's one feedback we got from the past sessions.
00:01:00.938 - 00:02:20.250, Speaker A: And so what exactly am I building? So, as some of you may know, Starknet has a messaging bridge that allows it to talk and exchange messages between Ethereum and Starknet. Something I've been thinking about, and I've wanted to put a bit of code together to try and play with, is the concept of remote controlled account. So basically, accounts that are split between l one and l two. So the goal is to have an account where the brain is on one layer and the muscle is in another one. So one obvious example is to have, for example, a dow where a wallet with assets sits on l one, and you want to have the logic of your dow on l two so that people can vote, people can interact, and it's relatively cheap to do so. But the actual assets are on l one. That's in a nutshell, the concept of account contract of a remote controlled account.
00:02:20.250 - 00:03:03.640, Speaker A: It's not crazy difficult, but that's what I want to do. The other side of this, which is also interesting, is having your decision on l one and something executed on l two. And you might think, I mean, what's the point of doing that? And think about it in another term. Imagine you have a dow that works on l one and all your governance is on l one, and you want to deploy a new contract on l two. Well, you're going to need to figure out a way to deploy your contracts and manage your assets on l two. And maybe it's fine for you to re implement all your governance on l two to manage your l two deployment. Or maybe you want to reuse your l one governance to do that.
00:03:03.640 - 00:03:38.206, Speaker A: And so you just want to have your usual, I don't know, multi sig governance, whatever on l one sending messages to be executed on l two. So to, for example, deploy an account, I'm sorry. So for example, to deploy a smart contract or manage l two dow, treasury, I don't know, to each his own. So I'm going to explore both side of the fence. So here I have two files. One is called zombie l one and zombie l two. So when I started this project, I was thinking, okay, so I'm going to do the zombie and then the brain.
00:03:38.206 - 00:04:30.000, Speaker A: And it turns out that I really just need to do the zombie. I really just need to do one contract on one layer that will accept messages from another layer and execute it right. So that's what I don't need to have specific logic about the brain, because the brain can be anything you want, and it can even be for the case of l one to l two, it can just be a regular eoa. So it turns out I only need to do the zombies. So I'm going to share the repo. Actually, the repo is currently private. I'm going to make it public first.
00:04:30.000 - 00:04:59.258, Speaker A: Just a sec. I'm going to make it public so that people can follow along if they want to today or later on. Tag. There you go. I'm going to have to confirm with two factor authentication. No, that's good. The current repo is public, so you can find the repo there.
00:04:59.258 - 00:06:02.198, Speaker A: Still need to do a readme, but you guys have access to it there, and here's the link. So if you want to see what's inside of it, basically I've committed just free files. So the zombie for l one, the zombie for l two, which has not been updated yet to the zero point ten syntax and the interface for starknet course, in order to be so that it is usable. All right, now up to date this back here. So now let's start with one. I'm going to start with the zombie l two account I worked on a little bit. So as some of you may know, the Cairo syntax changed lately, and so it's a bit fucked.
00:06:02.198 - 00:06:50.734, Speaker A: My outline here, it used to show as Python, and now it's a bit of a mix of everything. So my file looks like it doesn't look good. So I'm going to try to explain it, to explain what's in there a little bit first. So the first thing I want to do really, with that brain, with that zombie on l two, is I wanted to be able to receive a message from a brain that is on l one, which is identified by its address, and to say, okay, if a message comes from that person, I'll accept it. So I need to store that brain's address somewhere. So I created a storage VAR here, which is called l one brain address. Right.
00:06:50.734 - 00:07:15.974, Speaker A: It's a felt and I've created a view that allows you to see this brain address. Right. When I'm deploying it, I need to specify a brain address or otherwise it's going to be set at zero. So in my constructor. Constructor, I've just added the l one brain address when you want to deploy it. Okay? So up until now, it's fine. I have one storage VAR.
00:07:15.974 - 00:07:55.638, Speaker A: I initialize it when I deploy my account. Now what do I do? Before we go into the l one and learn thing, I want to mention that sometimes you might need to change the brain. Sometimes you might need to, maybe you want to transfer the zombie to another brain. So how can you do that? Well, it's simple. You can modify here you can write a new brain address with this function, which is called set brain. Right. You specify the new brain and you write in the slot for the brain address, the address of the brain you're interested in.
00:07:55.638 - 00:08:50.506, Speaker A: Okay, let's put this down here. But you don't want anyone to be able to call that. So I'm going to make sure that the only person that can set a new brain is the zombie itself, because you really just need to be sure that the current brain is the person changing to the new brain. So basically, if the brain wants to change to a new brain, he needs to send a message that is executed and that is calling back the zombie to change the brain. Right. So this is accessible exclusively through the l one endler by the old brain. Okay, now let's take a look at the l one endler.
00:08:50.506 - 00:09:18.602, Speaker A: The first l one endler I wrote was this one. And so I just called it execute. Right. And I use the same syntax we usually have. So I say, oh, there's going to be an address from. And then there's going to be an array of data. Turns out this doesn't really work well because the issue we may have with execute is that execute may have various arguments.
00:09:18.602 - 00:10:18.466, Speaker A: Right. Depending on what contract you want to call, the call data you may specify might be a few values, like one value long or ten. It turns out that this didn't work out for that. I didn't dig that much into it because it didn't work exactly for what I wanted to do. So I commented it and I used another kind of l one endler, which is the l one endler, where you specify raw input. So when you specify raw inputs, see the difference between this one and this one is the following. When you're using classical nl one endler, the first argument is always from address so that you know who is calling you know who on l one is calling that function? When you're using raw input, you're just receiving the selector and the call data and that's it.
00:10:18.466 - 00:11:20.726, Speaker A: The first argument of the call data is always the caller from l one, but you get to manipulate it exactly as you want. So what I'm going to do with this is the following. First of all, I'm going to remove this because I'm not going to use it. And now I need to figure out a way to up need to figure out a way to have this function receive a payload from l one and execute it. So the first thing I'm going to do is first I want to make sure that the brain, the person calling it is indeed the brain, right? So I'm going to retrieve the value of the brain. I'm going to check that it is equal from address. I'm going to do it somewhere here, right? No, I haven't done it yet.
00:11:20.726 - 00:11:51.294, Speaker A: So, okay, what I'm trying to do here is basically this is work in progress, right? So this is where I left off up until now. I'm explaining stuff. Now I'm going to have to try and figure out things. So I get the call data here and I get the selector. So the selector is the selector that points to execute. It's not really useful to me, so I don't really need to use it. I'm just going to discard it.
00:11:51.294 - 00:12:39.102, Speaker A: Right, so I'm going to not use this. And here I need to figure out how I want to organize the data that is sent to the zombie. So I'm going to define that up. Full data should be organized this way. Slot zero is from address by default and then this is not by default. This is what people need to specify. So slot one will be which contract you want the zombie to call.
00:12:39.102 - 00:13:31.600, Speaker A: So two, I call her on l one, then I'm going to say that slot two is going to be. So what do I need in order to call a function on l two? I can use this call here. So I need who I want to send it to, what function I want to call and then the call data. So I'm going to say that this should be the selector. I'm going to call this, how can I call it so that it's explicit? I'm going to call it target selector. This one is also set by the color on l one. I'm calling it this way so that we don't confuse it with this selector, which is the one to execute that function here.
00:13:31.600 - 00:14:01.594, Speaker A: By the way, I hope everyone can see my screen. I don't see comments on streamyard or on twitch. I can see them on YouTube so I can see there are some people watching. Let me check if there are comments on twitch. We don't use twitch that much, but if some people use it why not? And I don't see comments there either. So it's fine. I'm going to check if I see some stuff.
00:14:01.594 - 00:15:26.050, Speaker A: Okay, nothing yet on twitter either. All right, so I basically need these four things. So now this I've decided the slots now I need to initialize targets call data with something. So I'm going to have to create an array and store the latter part of this into target call data, right. So from address I've had then I'm going to create something for this one. This is confusing. I'm going to remove it now I'm going to call this target selector and I'm going to first check whether, I'm going to first check whether this works.
00:15:26.050 - 00:16:34.634, Speaker A: So I'm going to check first that the brain is indeed from address, right? So I'm going to check if this works, right. I'm going to check that the person who wants to execute the cell one handler is the correct one. Now I want to execute the call. So I'm going to try to execute this first and see, like to compile this first and see if this work, right. So I'm going to go in my folder workshop Cairo remote controlled account, right. I'm going to make this bigger so that you can see I've used, I've initialized a project with art ad, so I'm going to do NPX, arthat, Starknet compile and it will compile all my file. See it doesn't like this thing so I'm just going to comment it for now.
00:16:34.634 - 00:17:19.114, Speaker A: Okay, interesting thing. The error I have now is basically that I've set up sublime text so that when it sees a Cairo file it assumes that it's python syntax. When I'm commenting it, it's not commenting it correctly. So I'm going to do it this way manually. There's a bit of a mess. Now does it work? Okay, so now my file works, right? I've commented this away. What is interesting is that it seems that it didn't convert when I use Cairo migrate, it didn't use this thing.
00:17:19.114 - 00:18:05.000, Speaker A: Let me see if I uncomment this stuff. If I reuse Cairo migrate it is able to deal with it. Maybe it will. So I think it's Cairo migrate. Oh, I need to set up my to be in the proper environment to, in order to have access to the Cairo migrate command I need to be in the proper virtual environment. So I'm going to activate it and now I can try again Cairo migrate and then my file is in contract. It's called zombie l two.
00:18:05.000 - 00:18:48.290, Speaker A: Now he doesn't like this. Okay, so I'm just going to remove this, right? Let's forget about this for now. Too bad, but I won't spend too much time on this. Basically you can't take a file that has both the former syntax and the new syntax. So it needs to be everything at the same time. Okay, so I'm not going to add the check this thing I just removed, I'm going to comment it because I'm going to need to add it later on. But as a first step I want to make sure that I'm able to read the call data correctly.
00:18:48.290 - 00:19:44.566, Speaker A: So now what I'm going to do is I need to get the last part of this call data. So how do I do that? I need to create an array. I need to create an array and I'm not exactly sure how to do that because it's been a while since I coded some stuff. So I'm going to take a look at, I think I'm just going to take a look at some files that are here in Cairo 101 and see how I did that when I did this in the past. So I just need to figure out someplace with an array. So which contracts are this? If you want to, if you want to shout the answer somewhere so that I can read it, please don't hesitate. I can see the comments in YouTube if you want to help me.
00:19:44.566 - 00:20:29.140, Speaker A: So importing functions, I'm guessing that there might be an array, right? Where do I see that? No array. Here's maybe. Okay, I'm going to have to take a look at the documentation. Hello, Starknet. Do I deal with array? So I know that to do that I know I need to do alloc, locals or something. So I'm going to try for this. This doesn't work either.
00:20:29.140 - 00:21:11.230, Speaker A: Okay, this is not exactly what documentation in Cairo. Let's look at Cairo. Oh my, this is embarrassing. So can I do this? No, I can do that. Let me check. I need to see how I can create an array. God, this is embarrassing.
00:21:11.230 - 00:22:05.920, Speaker A: No need. Okay, an array. Need to use a look. All right, so here, apparently this is something I can do. So temvar r felt equals new. Okay, so maybe I can do that. No, because I need something that is not actually I can, actually I can probably, as long as I can define the length of my array, I can probably get around that.
00:22:05.920 - 00:22:45.920, Speaker A: So let me try to do that. Let target call data up. It's a filter, right? Filled up equals alloc. This work, try and compile it. It doesn't, it's because I need to have some kind of parentheses. Right. And probably I need to do that also.
00:22:45.920 - 00:23:12.134, Speaker A: Okay, so I've add alloc here. Now I can call it as a function. And now this should compile. It does. Nice. Now I'm relieved. Now what do I need to do? I need to allocate each cell of the call data to this one.
00:23:12.134 - 00:24:21.558, Speaker A: So ideally I'd want to do a for loop, but I'm guessing I'm going to need to do some kind of recursion here. So what am I going to do? I'm going to create a funk recurse, get call data. Right. I'm going to put all of these in because I'm not sure, to be honest, exactly what should be done with these if I need all of them. But by default they're not going to bother me back. All right, so my function is here and what does this thing return? Okay, so this is not what I need. What do I want here? I want to get back the target call data populated.
00:24:21.558 - 00:25:11.750, Speaker A: Right? So I'm going to say that it returns target call data. Len, it's a felt and forget called data is a felt array, right. Will this work? Probably not, because I need to initialize, I need to return an array. And here it's not returning anything. I give it the same name. How smart of me. All right, this compiles, but it returns nothing with a return instruction.
00:25:11.750 - 00:25:58.710, Speaker A: Okay, so I'm going to say that as an entry, I'm going to send it, actually the same thing. I'm going to send target call data. Right. So this is what I want to send. And I'm going to tell him to return these two that I've just sent. Right. Should that do the trick? So I've created an internal function that takes an array as input and returns an array as output.
00:25:58.710 - 00:26:33.990, Speaker A: Nice. Okay, so what I want to do really is to populate one with the other. So I also need to send the other array as a parameters and these I'm going to send first. So with the screen that is big like this, it's a bit confusing, but bear with me. So I'm going to call this origin call data, right? So I'm trying to get the origin call data and just take part of the array to put it in. Right. So this should work also, right.
00:26:33.990 - 00:27:12.706, Speaker A: I'm just receiving two arrays and sending them back now. All right, so I've received origin call data, I've received its length. Right. I'm probably going to need to tell him where I want to read inside the array. So I'm going to say to call this like the cursor. Right. So in a nutshell, I'm trying to get this array, I'm sorry, this array here.
00:27:12.706 - 00:27:49.546, Speaker A: And I want to get just the end of this, right. I don't need the first free slot, I need the four remaining. So what I'm going to do is first. So I'm going to try to take part of it. So what I'm going to assume is that. I am going to assume that I'm going to start from the end of the array and then go back up. Actually, no, I don't want to invert them.
00:27:49.546 - 00:28:27.274, Speaker A: So I need to start with the beginning. So since I passed the full origin call data, I'm going to say, look, I want the, I'm going to return. So I'm going to return this call, right. It's recursive. So I'm going to say this and I'm going to feed it with what origin call data at the beginning. Right. It's going to be here.
00:28:27.274 - 00:28:50.580, Speaker A: So origin call data up here is actually origin call data. Len. Recurse. It's not what I wanted to do. Okay, I'm going to return with this and that, right. So first are the two things, and then I need to update the cursor. So the cursor is the value I want to input in.
00:28:50.580 - 00:29:11.942, Speaker A: So here I'm going to iterate over the cursor. I'm going to put cursor plus one. And let's see if this works. This compiles. Yes, this works. Nice. So here when I'm calling this function, I'm going to iterate over cursor and it's never going to stop.
00:29:11.942 - 00:30:04.860, Speaker A: So now what I'm going to do is I'm going to have some kind of break, some kind of breaker so that when cursor is the size of origin called data, len, I'm going to return zero or something, right? That's what we do when we do recursion. So let me check here. Actually, I like the example I had on Cairo 101. I'm comfortable with it. Let's see the example on recursion. So here I'm doing an if. So I'm doing if length is something, return nothing.
00:30:04.860 - 00:31:00.620, Speaker A: So I'm basically going to do the same thing. So if cursor is equal to original call data length, what do I return? I'm going to basically populate. But see, I can't start from the, in this way. I can't iterate over it because I can't populate the length of the array. I actually need to here do cursor minus one. And here I'm going to say when cursor reaches the first pole for a position I want to populate, which is the third position. Right.
00:31:00.620 - 00:31:58.494, Speaker A: So when cursor is equal to free, I'm going to say that I want target call data cursor to be equal to origin call data at cursor. Right. And then I'm going to return this, which is same as usual. Right. Now, once I, so that's when cursor is equal to free. So this is when I'm starting to bubbling up my recursion. And now I'm going to return cursor plus one.
00:31:58.494 - 00:32:47.134, Speaker A: No, that doesn't make sense. Yes, I'm actually going to, wait, I'm confused. Recursion is hard. So I'm going to start from the bottom of the array and go all the way to the third position. Or maybe let's do this the following, instead of doing that, wait, let's start from a blank state. I'm confused now. So I'm going to, this is the end call, right.
00:32:47.134 - 00:33:32.634, Speaker A: This is when we're done. So at that point I'm going to assume that the cursor has reached the end. So when the cursor, if cursor is equal to origin call data, Len, since we have reached the end. So this means that this is one step too far and I want to return. Right. So now I'm going to just return, just going to return the data I'm interested in, which is target call data and target call data, Len. Right.
00:33:32.634 - 00:34:12.574, Speaker A: So I'm going to say return this thing here. Right. This is when we've reached the end of the array, right. Okay, I'm not there. So have I reached the end of the array? No. So now I have not reached the end of the array. Reach the end of the array.
00:34:12.574 - 00:34:50.820, Speaker A: So I'm going to say that I'm going to allocate target call data cursor and put it target call data cursor. Right. I'm going to say, okay, I'm taking the value of the cell and then here I'm going plus one. Is that correct? Does that compile? Let us see, and it doesn't, nice, I forgot semicolon. There you go. Does it work? It doesn't. Let me see.
00:34:50.820 - 00:35:19.020, Speaker A: See, this is the issue with the formatter is that now it doesn't understand exactly what I'm doing. Okay, so where is this one? Who is this one talking to? It's here. So where is he? Confused. Oh, this is where he is confused. Right. Forgot a line. That should do.
00:35:19.020 - 00:36:09.920, Speaker A: So let me, oh, I'm seeing now that Philip Lorenzo is saying you don't need to copy your, you just say origin call data plus free, or use memCPI. Call data equals origin call data plus start index seems to be what you need. All right, I should have read this earlier, and here it's saying something. So wait, you mean that if I remove this and I do let target call data equals. I'm imagining origin call data plus free. This should work. No, maybe not, but let's see.
00:36:09.920 - 00:36:50.850, Speaker A: Let's test this another way. Right? So I just want to check if this works. Like this line here, this should work, right? I have two. I have selector and I'm going to use call data len here, which is just right here, and call data. So this should work, right? And it doesn't like it. Line 74, what is that thing? Oh, semicolon. Or maybe it doesn't like this either.
00:36:50.850 - 00:37:20.200, Speaker A: Yes, this works. So now if I follow Philip's suggestion, should I do call data size minus free, and here, called out plus free, should this work? And it does. Oh, my God. I just spent so much time trying to do some recursion and embarrassing myself for nothing. You learned something. I learned something. This is great.
00:37:20.200 - 00:37:55.606, Speaker A: Thank you guys for the help. So I'm going to remove this. This is confusing. All right, so how does this work, do you think? This is the new syntax here, here, cert brain equals from address, do this back. This work. All right, so this should work, right? So this should work. It should.
00:37:55.606 - 00:38:48.322, Speaker A: Now, the issue I have here is that if this doesn't work, I'm not going to see it because failed transaction are hard. I mean, like failed transaction, when you're sending an l one to l, two messages, message are not easy to debug. So what I'm going to do is I'm going to try to deploy it just because I want to try, but probably I'm going to make some kind of debugging contract out of that, right? In order to be able to diagnose what I'm doing wrong. Okay, so I'm going to do starknet deploy, which contract do I want to deploy, it should be in starknet artifact contract, lombl two, Cairo. And this one is what I want to do. It's going to tell me, oh, you need a wallet. So I'm going to say, no, I don't want to use a wallet.
00:38:48.322 - 00:39:17.678, Speaker A: I should, but this is not the goal for today. And, right, I need to have at least one input and I got zero. So what I'm going to do is I'm going to check in metamask. So if you remember, when I deploy my contract, I want to do this. I want to specify the l one brain address. So I'm going to use my whale girly account, which is this one, right. And I'm going to tell, okay, deploy this.
00:39:17.678 - 00:39:52.674, Speaker A: So I'm going to say pack inputs and try and do that. He doesn't like it because I need to specify the network up. Alpha girly. Now we're talking. All right, so now I should have a contract that is there. I'm going to wait for this to be passed in Gurley, right. And then I'm going to try and I'm going to wait for this to be passed.
00:39:52.674 - 00:40:46.064, Speaker A: So it's going to tell me, oh, there's no contract. I'm just going to wait for a bit for these to appear. And now in the meanwhile I'm going to do two things. First of all, I'm going to, let's see if this doesn't work. I'm going to try to first log that I have everything done correctly. So let me try this. Can I have a log that is narrate up, can I do that? Does this work? It doesn't, it doesn't like it.
00:40:46.064 - 00:41:18.476, Speaker A: Array arguments. Two log must be preceded by length arguments. All right, that's fine. If you want to have the length of it, that's fine for me. So I'm going to say two log len and does this work? It does. So now what I'm going to do is I'm not sure this is going to work immediately. So I'm going to copy this, right, and I'm going to deploy a second function here.
00:41:18.476 - 00:42:02.184, Speaker A: I'm going to call it execute test. Instead of calling with this, I'm going to tell him to log stuff so that I can exploit it later on. Again, this might not be necessary, but since deployment time is taking a lot of time, I'm going to try this here, right from address up. I'm going to do it with two, with the target selector. And then here, this is the name. I give it right log array, something. And so I'm going to say yes, two selector.
00:42:02.184 - 00:43:11.912, Speaker A: This one turns out I don't need by the way, this is a mistake I made here, I want this here, right, target selector. So I'm going to emit target selector here, and now I want to execute here, call data size minus free and call data plus free, right, and this should work, let me see if it compiles. And it doesn't like that, l 280 and this I don't really need. So I'm just going to remove that, I'm going to tell him, don't worry about that. And this works. So now I've compiled it, I'm going to deploy it again and this should do it. I have a new contract, I'm going to store these because I might be needing them.
00:43:11.912 - 00:44:09.560, Speaker A: So contract with debug function. This is the output, right? All right, so while this is being deployed, let's take a look. So we now have a remote controller count or at least an attempt at it. Now let's try to look at the other side of things. How do I send a message from l two to l one? And here I'm going to use the same construction, right, so in the sense that I'm going to have a function to set the brain, right, and I'm going to have a value that is called the brain. And the brain here I define it in the constructor, right. So I need to specify also starknet core because l one, as you may know for the messaging bridge, the calls to the l one ender are not made automatically.
00:44:09.560 - 00:44:39.088, Speaker A: For a message to be used by your smart contract. You need to consume it. So you need to specify where they need to go look for it. So you need to specify which darknet instance you're pointing to and then you need to specify who is your l two brain. So I'm storing both these variables here and I'm setting them in the constructor. Now I have function called set l two brain that allows you to change the l two brain. I could probably also make it possible to change darknet core optimization.
00:44:39.088 - 00:45:17.170, Speaker A: I haven't done it yet, and here I've basically done the same thing. I have a function, execute and execute test. Let's look at what I have in execute. So execute here you need to pass it the payload. So the payload is what you want executed on l one, right. And in order to consume a message from l two, you need to specify who is sending it and what is the payload that is being sent, which is a un to 56. Now in this array you should be able to retrieve what you need in order to make a smart contract call on l one.
00:45:17.170 - 00:45:57.016, Speaker A: So what I'm having here is I'm using this line here where my execute function will specify who it is sending the call to. It's going to need to specify the value associated with that. It's going to need to specify how much gas is attached with that. This is probably unnecessary, but maybe it is. And then it's going to specify the call data that needs to be sent. Right. This call doesn't need to be permissioned because anyone can trigger it because it will check that it comes from the brain.
00:45:57.016 - 00:46:55.168, Speaker A: So anyone can pick up the message and say, hey zombie on l one, l two brain sent you something. Now the issue I'm having here is, okay, so how do I turn this payload, which is a bunch of you, into 56 into a byte array basically because that's what this is. Right. So what I'm doing here is that I'm taking the payload, which is a bunch of un 256 and I'm going to skip the first three rows because same thing, I need to have two and the value and the gas. Then I'm going to encode it. Does this work? So initially this is empty and then I just add the payload un right and I pack it. Will this work? Well, the thing is it may work, it may not.
00:46:55.168 - 00:47:37.016, Speaker A: In order to test that I'm basically going to do the same thing. So I have an execute test function here that won't retrieve a message from starknet. Right. I'm going to just send a payload basically and I'm going to take a look at what execute call data here looks like. So I'm going to remove the execution of the call and I'm going to add some kind of event here. So is this how you do it? I don't remember. Solidity.
00:47:37.016 - 00:47:56.950, Speaker A: Wait, I think we have events in other tutorials. I'm going to go take a look at it. So I probably in the messaging bridge one. Right. So you have stuff on l one. Sure there is. Okay, so this is how you define an event.
00:47:56.950 - 00:48:25.564, Speaker A: All right, so I'm going to say a, please define this event. Call data reconstructed. And here what I want is byte memory. Execute call data. All right, now I need to compile this. I'm going to use NPX arthat compile. See if that works.
00:48:25.564 - 00:48:47.956, Speaker A: It doesn't like that. It doesn't. Oh wait, so this is an arbor error. It's because I forgot to remove something here in the test. So this function won't return anything. I don't need to return anything. So I'm just going to remove this.
00:48:47.956 - 00:49:53.210, Speaker A: Right? This one, I just want to use it for events. And this probably. Okay, so this probably I can deploy it with ganache, right? All right, so let us see here. The challenge is that with the payload you want is to convert the payload you usually send with a two call and to convert that into a UN. I'm not going to dive that much into this because it's out of scope. I just want to make sure that I'm able to send some data from starknet there. So how do I do that? How do I go from a bunch of UN 256 to actually having an ABI compatible? Wait, this is harder than I thought.
00:49:53.210 - 00:50:38.664, Speaker A: Or not, basically. So this is an array of bytes and each unit 56 will be one of these. So let's take an example, right? Want to go on Etterscan? Gurdy. Gurdy. ET scan. This is a contract, right? And when I'm sending a transaction here, the payload I'm sending is this, right? So if I see view input as original, this is basically what, this is what I need to encode as a bunch of uns. Okay.
00:50:38.664 - 00:51:12.244, Speaker A: I see time passing and it's taken me longer than I thought. Go figure. And so I'm not going to dive into that now. Maybe I'll leave it for another time, or maybe I'll just work in a less embarrassing setting with everyone watching. There's not a lot of people, but still. Instead I'm going to check if what we did here on Gurley with the l two zombie worked. So let's see, where was our contract? Here is our contract, right, so this contract is here.
00:51:12.244 - 00:51:46.540, Speaker A: Let's use this one, right. Did it appear? It didn't appear yet. So tech, let's check. Did the previous one appear? It didn't appear yet. So let's see. The transaction should have gone through, though. Does this mean that the transaction failed? Let's see.
00:51:46.540 - 00:52:24.344, Speaker A: So I should be able to do starknet, right? There's something to get the transaction status. Yes, this one. So I'm going to start net TX status. And what does he want? It's going to help me. The network say alpha girly and then the ash, which is this one. The transaction is still in received mode, so this is going to take longer than I thought. It's all right.
00:52:24.344 - 00:53:41.420, Speaker A: So what I'm going to do in the meanwhile is I'm going to go on Ethereum and I'm going to go talk with the messaging bridge to tell him hey, send a message or see how I can do that at least. By the way, which value did I send here? Oh, I sent my address directly. This should work. So let's see, where is the Starknet bridge? Where's the Starknet messaging bridge? Probably used it in the past. So wait, if I were you and I had never used the Starknet messaging bridge, where would I go to find it? That's actually a good question. Probably the best way to do that is to go on Starkgate, right? So girly, Starkgate, Starknet IO. And when I want to bridge money there from Ethereum to Starknet, it's going to tell me it's going to send a transaction.
00:53:41.420 - 00:54:05.996, Speaker A: Wait, this is not the one I want. So it's going to send a transaction to the bridge so then I can find out where I'm trying to go, which is not ideal. We should have this value elsewhere. But bear with me. All right, I'm going to connect Argent X here. Oh, I understand. Trust me, I understand now.
00:54:05.996 - 00:54:30.064, Speaker A: Okay, let's do this. Transfer. Beep, beep poop, beep. Aha. And it's sending here, right? So, no, is this my address? It is my address. So who do I want to send my transaction to? Wait, no, this is the bridge. So it's pointing to the Stargate bridge.
00:54:30.064 - 00:55:10.224, Speaker A: It's not pointing to the messaging bridge. It's all right, so you're going to need money regardless. So let's bridge less. And in fact I probably already sent some money there. Wait, I'm just going to go see my history of transaction and see when I deposited money in the past, see, oh, I've done this in the past but see I could also just go into the deposit thing here and I go into logs and now I can see that an event was emitted from there which is Starknet core. I do write as proxy and now I can send messages to l two. Nice.
00:55:10.224 - 00:56:00.464, Speaker A: So sending a message to l two, who do I want to send my message to? Well, I wanted to send it to this contract, this gentleman here. Wait, ha, oh, this is the payable amount. I'm not going to send any money with this one to address is who I want to send the call to, then the selector. So which function should I call first? I want to try to call. I'm going to try execute test. Right, so how do I get the function selector? I think here in the documentation there's something to interacting with l one contract, l one. To l two.
00:56:00.464 - 00:56:17.928, Speaker A: You're going to need the selector somewhere, right? Oh cool. I need this snippet of code. How useful. Tag. Wait here. So I'm going to open python paste it. Okay.
00:56:17.928 - 00:56:47.840, Speaker A: The function I want to call is called execute underscore test, right. It's called execute test. So I'm going to try and call this one. So this is the selector I'm looking for, right. And where is I'm going to put this in full screen. Here's the selector, right. And what kind of payload do I want to send? I can send an array of bytes of un.
00:56:47.840 - 00:57:10.360, Speaker A: So I'm just going to try to put a small sequence and see what happens. So I'm going to do like 1256, right? And I'm going to write this. All right, I need to connect my Webfree provider and now this is not going to work. It's fine. I'm going to do it again right now I call write. Oh, it actually works. Very nice.
00:57:10.360 - 00:57:43.376, Speaker A: So I'm going to send this and see. I hope the contract will be deployed before this goes through. Now I've tried execute test but I really want to try to see if this works. So what I'm going to do now is I'm going to say, okay, now try to call execute. I need a function to know to try to execute. So now I'm going to do a new call here. I'm going to tell him execute this selector.
00:57:43.376 - 00:58:07.204, Speaker A: So now it's going to call this function here. And now this is different here. This is from address. So it's whoever is calling this we don't really need. It's fine. Now I need to say who I want to send a message to and then which function I want to call. This is where things get tricky.
00:58:07.204 - 00:58:48.752, Speaker A: So I'm going to use Cairo 101 here and try to validate an exorcist of Cairo 101 with the zombie. I'm just going to do the first one. It's not going to be difficult. I'm actually going to do the second one. So in the second exercise I need to validate and send claim points using a special value and this special value is free 1020. So I'm just going to call function claim points with free 1020. So the function I want to call, the selector is called claim points, right? Claim points.
00:58:48.752 - 00:59:14.960, Speaker A: This is the selector I want to call. Right? So remember I'm here. The first one is who am I calling? Who is going to be. I forgot to add that. So who am I calling? It's this exercise here, right, exercise two. So the contract is deployed there. So I'm going to say a, please try to call that contract.
00:59:14.960 - 00:59:55.790, Speaker A: The selector I want to use is this one do. And the value I want to send is free 1020. This may not work because this is exadcimal, but let's try. It doesn't like this, right? So I'm going now to say, hey, can you convert this to decimal? X to decimal. Oh my God. Should really have some kind of short key on this, but there you go. And now I'm hitting right and it doesn't like that.
00:59:55.790 - 01:00:30.658, Speaker A: Why? Because I've pasted both of these without a space here. Okay, wait, too long, too late. So this is the decimal contract. Let's do it that way. Free 1020. This work? It should. One, two, three.
01:00:30.658 - 01:00:57.530, Speaker A: This shouldn't like. Okay, so if this works, this means that Michael is fucked. Okay, so he doesn't like some value in there. Oh, there was a space and he didn't like that. Okay, so I'm sending a second message now. All right, off you go to starknet. Let's see if it deployed and let's see if this will work.
01:00:57.530 - 01:01:24.018, Speaker A: I really hope it will. Nice. Wait, which contract did I use again? Did I use the one with the testing function or. Not yet. Oh well, so wait, this is a contract address, right? And wouldn't you know it, I use the right one. Okay, I'm happy. So is the contract deployed? It is not deployed yet.
01:01:24.018 - 01:01:52.714, Speaker A: Okay, so the call I just made should work with this one. So I'm also going to try this one. I really want to see if this goes through DAC. But wait, this is not what I want to do. I should send this to the c. No wait. So this is the zombie, right? So this is the zombie I'm going to use.
01:01:52.714 - 01:02:19.640, Speaker A: The endpoint I want to use here is execute. So this is the zombie without the testing function. So this is the selector I want to use on the zombie. And this is the selector I want it to execute. And this should not change. This is silicon I want to send. So I'm going to write this and we will see if this works.
01:02:19.640 - 01:02:57.890, Speaker A: All right, so now a transaction is usually like a message is sent after like say, I think it's ten confirmations or something. So we're going to have to wait a few more minutes for first transaction to be included. Then we will see if the message is triggered on Starknet. So let's see this little guy here. I'm going to open another tab. Who knows, maybe the others contract will also get included. Right? And this is the one I'm looking for.
01:02:57.890 - 01:03:41.662, Speaker A: WHOOP. Too slow. Too slow. All right, so now this guy should get some message somewhere, right? I wonder what will happen if my message arrives before this contract is deployed. Probably it won't work and then I'm going to have to resend it. But okay, so this is still in received status. All right.
01:03:41.662 - 01:04:05.414, Speaker A: So I'm going to wait and see if there are some comments or questions. I see there are some people flowing. Hi everyone. I hope you're having fun watching me fumble. It's a bit embarrassing to be honest. It's been a long time since I've coded enough for this not to be embarrassing, but I hope you learned something. I really want this concept to work.
01:04:05.414 - 01:04:49.474, Speaker A: So remote control account. I'm basically working on it. Let's say I really want to get a proof of concept work worked out. Where do I want this to go? The goal for me would be first as a concept from l two to l one. I'd want to have some kind of first an account contract that can execute easily payload on l one with. So this I need to be to work a bit more on the smart contract. And then I would need some kind of interface for you to be able a I want to call this contract on l one and then it would format everything for you in order to call and send the transaction on l two to l one.
01:04:49.474 - 01:05:09.580, Speaker A: So that's one thing. And the second thing I want to try from l one to l two. I can test it right now with an account with an EOA. Obviously I really want to try to do this with a multi sig. So with a gnosis safe wallet. I haven't played enough with these to know what to do. But same thing.
01:05:09.580 - 01:06:07.838, Speaker A: At some point you're going to need some kind of interaction in the UX that allow you to format your call data to be executed on l two. So there's a lot of directions you could go in with that. But I don't know. There's something fascinating to me to have an account on a chain fully managed by one on another one. And that's what I wanted to explore with you. I'm not sure what to do. I'm probably going to stop this stream in a while because I've been on it for a while and I'm not sure if this will work and I don't want to waste too much of your time.
01:06:07.838 - 01:06:43.660, Speaker A: I'm basically waiting for transactions here. So see if my message doesn't go through. I have no way to check that. Which kind of sucks, and this contract is taking way too much time to deploy. I think Starknet is very congested, so I'm not sure how I can work on that. And unfortunately, this is not the kind of projects where you can use Devnet because it's hard to simulate l one to l two messages or l two to l one messages with Devnet. So I can't really do that.
01:06:43.660 - 01:07:19.140, Speaker A: So you know what? You're going to have to wait for the next episode or follow on the repo. I'm going to add a readme and then commit the code I sent today if you want to play with it. I'm going to log off now. So to all of you who waited a bit and looked at the stream, thank you for attending. Let me know your thoughts. I hope you learned something. And until then, until next time.
