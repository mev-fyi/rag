00:00:03.450 - 00:00:55.242, Speaker A: Hi everyone, I'm Shakao, I work at Starquare. I'm one of the co inventors of Cairo, and I'm here to talk to you today about Sierra. Okay, first of all, what is Sierra? It's part of the new car one compilation stack. It's an intermediate representation. The flow that was at Cairo zero either just have some high level syntax in Cairo Zero and compiles directly to Cairo assembly. The new flow in Cairo 1.0 is that first the compilation is compiled to Sierra, a safe intermediate representation, and then the Sierra is later it's deployed to Starknet, and there it's compiled down to Cairo assembly.
00:00:55.242 - 00:01:46.590, Speaker A: And I'll explain a bit why we chose this and what the important point to note that the Sierra is a bit low level. It's like the furthest low level we could get. So you're not supposed to program in Sierra, but it's supposed to be like the artifact of the compilation from Cairo one. All right, so a bit of the motivation why we have Cr previously in Cairo Zero. This is how a transaction flow occurs. First, a developer writes a contract in Cairo. The compiler is down to Cairo assembly to QASM, and then the developer deploys this QasM contract to a Starknet.
00:01:46.590 - 00:02:33.114, Speaker A: This is an example contract that could be written with, let's say, function called deposit. It gets an amount to deposit and it verifies that you have enough balance to deposit. This code gets compiled to QASM, the second square and then deployed to Stocknet. Now, after it is deployed, a user wants to call this function deposit. So he signs the transactions. A transaction asks some sequencer on the Starknet network to include this transaction in a block. The sequencer runs this transaction in hopes of getting the user's fees.
00:02:33.114 - 00:03:25.134, Speaker A: When he signed the transaction, he said he's willing to give this and this fee for a sequencer to include it. And the sequencer runs it and is supposed to get some of this fee. After it is included, it gets to approver and a proof is generated of this entire block includes this transaction. And when this block is included in Starconnect the sequence of profits, some of this fee. But there is also a not very happy flow. The user tries to deposit more money than the balance he has. So when the sequencer tries to run it, if you see below, the assert we have fails because it didn't have enough money.
00:03:25.134 - 00:04:24.420, Speaker A: So the run fails on this assert and the transaction is not included in a block. The sequencer can't get his money because in Kyo you can't prove invalid things, which is good. But what happens here is that the sequencer did work for nothing, which is a problem, all kinds of reasons. I'll explain in bit. But for example, it's some sort of denial of service vector. Today in Starkland we are dealing with it with some kind of an economical mechanism, but we can do better. In Ethereum, for example, a failed transaction is actually included in a block, even though it's failed, but it includes as reverted, which means state changes don't happen, but free collections still happen.
00:04:24.420 - 00:05:00.734, Speaker A: And we would like to have something similar in stocknet. All right, so the problem here is invalid caro runs. Caro runs that failed. Cairo has this property that only valid statements can be proven, which is a blessing and a curse. It's good. That is the purpose of Cairo. So you can't prove bad stuff, you can't prove invalid stuff, so people can't steal your money, so you can deposit maybe more money than you have.
00:05:00.734 - 00:06:13.220, Speaker A: But the downside is, for example a denial of service issue. People can bombard you with this invalid transaction, bombard the sequencer sequencer, and they won't have any repercussions, any consequences for this thing and the sequencer just not be able to respond. For those who maybe know a bit more, one other disadvantage is for an antisensorship mechanism that could be implemented. For example, if we want users to be able to put their transaction on l one and say hey, you got to put this transaction in, otherwise say you are censoring me and maybe the stocknet will freeze in response. But we can't really do that here because if user posts a transaction and no one decides to include it, I can't know if it's because they're just censoring me or because transaction is actually invalid. So I can distinguish between these two cases. So it's also a problem.
00:06:13.220 - 00:06:59.246, Speaker A: So what are actually our requirements here from this proof system? The first requirement is completeness. This means an honest prover should always be able to prove a run, any run, even one that supposedly failed or is invalid, because we want to include invalid runs and collect their feeds even if we don't do any state changes. The other requirement is soundness. Approver must not be able to reject good runs. That's pretty clear, I think. Right. So what is the solution suggested here? It's called Sierra.
00:06:59.246 - 00:07:48.514, Speaker A: The approach is safety by construction. Let's start with the basic idea. We want the user to write branching code instead of failing code. So for example, instead of writing assert amount is less than balance, I'll do an if instead. If amount is more than balance I'll return false and the entry point will just return bull saying if it's valid or invalid. And in response the operating system of Starknet would know if it's valid and then it should apply the state updates or invalid and not apply the state updates but still collect fees. So if every user would have written his code in this way, then maybe to be better.
00:07:48.514 - 00:08:45.770, Speaker A: But we can't really trust users to do this. Users can't even trust themselves to do this. All right, so what we actually want to do is somehow enforce on starknet that there won't be any failing code in any contract deployed anywhere. So we want to only allow developers to deploy code that cannot fail. How can we make sure their code has no failure flows? We uphold this by introducing this intermediate representation, which we call Sierra. You can see safe intermediate representation with carefully chosen letters Sierra. The idea is that it doesn't have any failing semantics inside, so it's safe by construction.
00:08:45.770 - 00:09:44.262, Speaker A: Only introduce things inside this representation that don't fail ever. And this will later compile down to chasm, which means the generate chasm also can't fail ever by constructions because that's how we constructed from non failing semantics. So this is idea to make sure nothing on starknet can fail. So how do we design this intermediate representation that cannot fail? Well, first of all, let's have a brief overview of what actually can fail in Cairo. Zero, what can be illegal and cause something to not be provable. First, we have dereferencing illegal addresses, which is bad. We have undefined opcodes, we have asserts that are wrong.
00:09:44.262 - 00:10:16.740, Speaker A: For example, assert one equals two. But more things that can fail are multiple writes to the same address. Cairo memory is immutable, so you cannot write different values to the same address. You can't overwrite things, you can only write once. So if you write the same address it's bad. Another particular case of assert is arrays. There is some problem of multiple appends I'll talk about in a second.
00:10:16.740 - 00:10:52.474, Speaker A: But basically if you take an array and you append the value to it, and then you try to append to this old instance of the array, both will try to append to the same position in memory. And again we'll have a failure because trying to write to the same position in memory. Another issue is long runs. I call it long runs. Basically when we have like transactions that run and runs and runs and runs, and we don't know if it's going to stop or it's in an infinite loop. So this is also an issue. So the design goals of Sierra is to solve this to be safe.
00:10:52.474 - 00:12:04.274, Speaker A: We also want an efficient compilation from Sierra to chasm because this might later be done in the operating system itself and might be expensive. So we want it to be efficient, obviously want it to be simple and we want it to have low overhead because we don't want our generated chasm to be expensive, to have overhead, to have runtime, want it to be as efficient as possible. This is supposed to be one of the main features of Caro, that it's fast and scalable and want to keep it that way. All right, so first of all, how can we solve the invalid references to make them valid? First of all, we still want to enable low level dereferences, not just simulate it, maybe in addict or some way because it would have overhead and we want low overhead, so we want to allow the reference somehow. So let's look at this simple example. We have this struct a that has a pointer to b, b has a pointer to c, c has some felt. And when we start with a we can dereference three times because get c but can dereference four times.
00:12:04.274 - 00:12:35.600, Speaker A: This is invalid. So that means Sierra needs some more information regarding instances and places memory. It specifically needs some type system. So we can describe a is a pointer to a pointer to a pointer to a felt. So it will not allow only three references, not four. So we need some type system in this representation. And now we can introduce this type called box.
00:12:35.600 - 00:13:43.490, Speaker A: A box type is supposed to be always a pointer to a valid instance. And the only functions we allow on box are these two box new, which will be the only way to create boxes, just taking some value and returns box its pointer in a way. And then we have the box d ref which takes this pointer at returns t. And it's important to note that this function cannot fill because the only way to create box is using valid addresses of types t because this function is the only way to create boxes. So this is a way to enforce safety by construction you only dereference things that we know that are initialized valid instances. And what will happen in the example before which you look like this now is the compiler from Sierra to cosm will allow dereferencing three times. It will say the type here is felt.
00:13:43.490 - 00:14:23.710, Speaker A: And when I try to dereference again I will get a compilation error, not a runtime error, not a failed proof. The developer would not be able to deploy his code because his code has a compilation error. Okay, so now what about the array append issue? As I mentioned before, this is an example of the same append way problem in car zero. Let's say I have this array a allocate. I try to do first append of the value zero. This is how it looks like in car zero. It's good.
00:14:23.710 - 00:14:43.526, Speaker A: I append again to a plus one, the value one. It's good. And now try to append to the same address, a plus one instead. And this is like invalid and asserts two different values. And this is an error and covers zero. The run will fail. So what we want to do here is introduce a new type called the array t type.
00:14:43.526 - 00:15:33.702, Speaker A: It has an array append, and what it does, it gets the old pointer to the array and a new value, and it writes that value and returns the incremented pointer. So if I gave it the pointer a, it will return a plus one because a plus one a plus two. And now what we actually need to make sure is that no one reuses old instances of our array. How do we do that? Using a linear type system definition from Wikipedia. Linear types correspond to linear logic. They ensure that objects are used exactly once. That means if we implement a linear type system in Sierra, it means values can't be used more than once.
00:15:33.702 - 00:16:18.818, Speaker A: The compiler will check it. So how this example look like in Sierra? First we'll define a new array. Then if we call append on this instance, we get a new instance b, append again, get new instance c. And if we try to append to b the old instance, we'll get compilation error again. Not runtime error, not fail proof, just a compilation error and the developer won't be able to deploy his code. So we are making sure everything is safe. And what about other object that it's okay to use multiple types like felt or any other simple object? We introduced a duplicating function called dupe.
00:16:18.818 - 00:17:02.290, Speaker A: It gets a value and returns two values. So you can use the first one and still have the second to do other things, possibly more dupes. And we implement them only for things that are saved to duplicate. Usually just things don't contain array or dict. Okay, now a dictionary also has a similar problem with multiple pens like arrays. So we do the same thing on it. We have dict new and we have dictate that increments a pointer and dictates have another issue of soundness in car zero.
00:17:02.290 - 00:17:39.214, Speaker A: You must remember to call squash dict on the array. It's sort of finalizing the dict you must do it, otherwise your program is not sound. So we don't want to allow users to do these bad things. We don't want sierra code to allow this unsafe pattern. So instead we force them to finalize the dict. Again, linear type system comes to the help here. Another requirement of linear types, if you remember from before, actually that must be used exactly once.
00:17:39.214 - 00:18:16.550, Speaker A: So if they are not used at all, it's also an issue. So we introduced the dict squash function that gets addict and returns nothing. And this is actually the only way to get rid of dictionary instances. So let's look at this example. If I use draw function, I initialize a dict, I get a value and I squash at the end, but I have this branch in the middle that does if blah blah, then just return false. I want to revert. And I forgot here to call squash dict in this val doesn't equal one branch.
00:18:16.550 - 00:18:54.118, Speaker A: And here I'll get a compilation error. It will say, hey, d is not used in the slow, you must use every value. And the only way I can get rid of this value is by calling dict squash. So I enforce this soundness safety. And again, for other simple types, I introduce the drop function, just takes an instance and returns zero instances. Okay, what about long runs is one that may be in infinite loop and maybe not. You can see ore's talk about the halting on the halting problem.
00:18:54.118 - 00:19:38.434, Speaker A: Talk, something like that. Okay. One of the benefits we have here in Sierra is that we have a very lean core that just checks linear type system. On top of this linear types core, we have a lot of extensions, dict, the array, the box, all kinds of things. That makes it very easy to audit. You can audit this very small core of things and then just everything else is implemented on top of it. The analogy I like to think about is that sierra to starknet is like evm to ethereum.
00:19:38.434 - 00:20:09.582, Speaker A: It's sort of intermediate presentation, an instruction set that is the semantics of this blockchain. In ethereum, the semantics are running EVM, and in starknet the semantics are now running Sierra. And everything else is just an implementation of this. In ethereum, we simulate EVM. In Starknet, we compile Sierra to chasm one time when deploying. All right, conclusion. Linear types are very strong.
00:20:09.582 - 00:20:31.160, Speaker A: We can force a lot of invariants using it. Simple core extendable. And users now need to deploy Sierra code on Starknet to make sure that the contracts are indeed safe. They don't deploy Cosm and deploy Sierra. Future, I don't have time to talk about? You can ask me about later. Don't have in time for questions. Thank you very much.
