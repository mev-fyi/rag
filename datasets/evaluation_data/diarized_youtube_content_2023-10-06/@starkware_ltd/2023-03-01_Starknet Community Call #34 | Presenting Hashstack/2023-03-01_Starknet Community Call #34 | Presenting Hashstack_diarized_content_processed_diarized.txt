00:00:00.410 - 00:00:01.054, Speaker A: It.
00:00:01.252 - 00:00:30.342, Speaker B: All right, so welcome to community call number 34 for the stocknet community. Today we have special guests from Hash Stack who will be presenting on their interest rate protocol. We have quite a few team members from the hashtag team. So I think before we turn over to you for your demo, let's go. Maybe a bit of intros, maybe each of you introduce yourselves, your name, what you do at hashtag, a bit about yourself. Aris, you want to.
00:00:30.476 - 00:00:54.142, Speaker C: Yeah, yeah. Thank you, Leroy, for hosting us and it's great to see you again after the sessions in Tel Aviv. So my name is Aris. I'm Devreal. At hashtag, we have together Venkat. He's leading our Cairo development. So he's our lead blockchain, Dev.
00:00:54.142 - 00:01:03.650, Speaker C: We have also Rajiv from the dev team, Zephyrin from the dev team, and mark, who is devinter.
00:01:06.310 - 00:01:26.040, Speaker B: Okay, great. So welcome, everybody. So without further ado, maybe were you going to give a bit of a deep dive into a demo of how your protocol works? Maybe if you want to share your screen and go straight into that demo, and then after that we'll ask a bit of questions.
00:01:28.990 - 00:02:10.950, Speaker D: Sure. Larry, can you see my screen? Yeah. Thanks for the opportunity. So hashtag is an under collateralized lending protocol. You'll be able to borrow up to three x the collateral that you provide. The main idea is to help you get better access to better capital efficiency on blockchain, while keeping things fully transparent and you having control of your funds. So with hashtag, we are going to launch on the main net soon.
00:02:10.950 - 00:02:57.990, Speaker D: And this is a good opportunity for us to talk about our product. So there is basically two things that you can do. You can supply funds to the protocol or you can borrow from the protocol. Currently we support these assets, BTC, Ethan Stocknet, and it's pretty simple to supply assets. You just have to go through whatever token you want to supply. So one of the unique things about us is we have a commitment period on how long you want to deposit, depending on the commitment period you choose. Currently it's flexible.
00:02:57.990 - 00:03:39.700, Speaker D: One month and two weeks. Depending on the commitment period you choose, you can get a higher interest rate to your deposits. So the longer you choose, the higher interest you get. This is a way from us to ensure we have better capital management within the protocol. And for anyone who wants to borrow, for example, let's say I want to borrow using my USD. Currently I have a little bit of USD in my wallet. So let's say I want to put 50 USDC and I want to borrow more USDC and that is possible.
00:03:39.700 - 00:04:20.560, Speaker D: I can take up to three times of this depending on the constraints or the availability of liquidity. So even borrowing there is different commitment periods that you can take. Flexible is when there is no lock in. You can repay whenever you want or you can hold it as long as you want. One month is when you take lock in. So by taking one month, you end up paying a little bit less interest than the flexible thing. So when you're sure there is a commitment you want to hold on to something, it is better you go for this so that you end up paying less interest.
00:04:20.560 - 00:05:57.098, Speaker D: Let's see if this goes through. So once the wallet is connected, okay, I already have an existing loan, so that's where it's not allowing me to take. I'll show the loan directly itself, but there are some constraints like where we ensure you cannot borrow again and again on the same markets, et cetera, or beyond certain limits as per our risk metrics. So once you supply your assets, you can see your assets that you have supplied and their details, the total supply you have done, even the APR would be shown if there is enough time between the time you have supplied enough. Once you supply, you can go for adding more supply or withdraw certain supply whenever you want, and you get to see all the fees, et cetera, that is applicable. And when you try to go to your borrow screen, you can see your current borrow positions. And basically if you see here, I was able to supply a collateral of $30 and I was able to borrow $60 worth here and I can use this borrowed amount into doing anything, like I can spend this loan.
00:05:57.098 - 00:06:42.234, Speaker D: So I'll go more in detail for how you can spend the loan. So I think that's where the main part of the protocol is. So aside that there are some basic functionalities like any lending protocol would have, you can close your loan anytime using self liquidate, repay the loan itself. The best part here is you can withdraw the loan as well outside. So currently, if you see though I have borrowed this amount, I don't get to get these funds in my wallet directly. Hashtag provides integrations on how you can use these funds. That is how we secure someone from running away with the funds.
00:06:42.234 - 00:07:42.592, Speaker D: So though there is this $60, if you, let's say, swap this $60 using the spend borrow feature that we have, we are working with various integrations on Startnet right now. And some of the things that work currently is swap, let's say. Just a second. Sorry, just a second. So my list loads whenever, let's say, you borrowed USDC, and you think you want to go long on BTC. So you would swap this USDC that you have borrowed to BTC. Maybe you can do this normally with yourself as well, where let's say you have $100 and you can just buy $100 worth of BTC.
00:07:42.592 - 00:08:34.180, Speaker D: But if you are able to take $300 worth of loan, and if you're able to buy $300 worth of BTC, you end up making higher profit if you are right. So that's where hashtag comes in. Even you can borrow BTC and you can swap BTC to USDC or something. And that way you're able to short BTC as well as per your trading strategies. Eventually, we want to provide a lot more options, like staking or adding funds to a liquidity pool so that you can earn those yields, et cetera. Maybe even trade on a decks. So that's where we are primarily focusing on even l two s as well, like start net, so that we can work with other dexes, et cetera, to ensure we can give good capital efficiency to our users.
00:08:38.040 - 00:09:11.360, Speaker B: Avanka, I wanted to ask a question. At the beginning, you showed us the ability to borrow $150 while only depositing $50. So that's an example of under collateralized lending, right? Quite an awesome product, actually, as you're familiar, ethereum layer one, like compound die. All those sort of platforms you have to have over collateralized, typically 100, 200% over collateralization. What's the mechanism that enables you to do this under collateralized lending?
00:09:13.140 - 00:09:56.188, Speaker D: Right. Major difference, I would say, is we have understood what is the use case of the borrowers. Usually is most of the borrowers in our way of compound, et cetera, at present, a lot of them want to borrow to trade more. They might want to take exposure to BTC or ethereum anyways, that they want to trade more. That is one of the major use cases. So if trading is the motive, when we provide this three x loan, the funds stay within our protocol. You are allowed to do things like trading on using those funds.
00:09:56.188 - 00:10:22.068, Speaker D: If you make a profit out of those things, the profit is yours. If you make a loss, the loss is yours. At the end, the protocol recovers the loan that it has given using the collateral. So, to quote in simple terms, it is something like margin trading. I would say that is one example of how hashtag helps you get three x collateral, three x loan. Does it make sense?
00:10:22.234 - 00:10:34.300, Speaker B: Yeah. So I understand basically what's happening here is the funds are being used within hashtag protocol, and therefore, if liquidation is required, you're liquidating within the protocol.
00:10:38.160 - 00:11:30.552, Speaker C: Sorry to interrupt you guys, but can I add a crucial point in your question, Leron, please. Yeah. So with the overcollateralized lending solutions like Ave compound, as we said in maker, you have the chance to get a loan, a smaller loan against your collateral, and withdraw it off chain. Okay. The same thing can be done also with hashtag. So there is an option for the user to withdraw up to 70% of their collateral if they want off chain and use it for their personal capital needs. And the rest can be utilized, as Venkant said, only as in platform trading capital.
00:11:30.552 - 00:11:54.340, Speaker C: So in that sense, you are already getting what the use case have been until now with over collateralized scenario. But with us, you remain with a lot more as assets to be used and utilized within hashtag.
00:11:56.440 - 00:12:04.888, Speaker B: Fantastic. Basically what you're saying is that you have the capabilities of compound and maker plus more.
00:12:05.054 - 00:12:11.896, Speaker C: Yes, exactly. Van Kat, please continue. Sorry.
00:12:12.078 - 00:13:12.540, Speaker D: Yeah, so, like Ari said, this is the screen where you'll be able to withdraw the loan, a part of loan that you have taken. So since my collateral is about $30 here, I can withdraw to 70% of this collateral, into my 70% value of the collateral in the loan term, directly into my wallet. So in this case it would be some $20 and I can still use my remaining loan to trade as I want. So, like you said, we are able to provide you more options than what avian compound is providing. And earlier I was showing, I guess, the spend borrow section where you can swap your loan into some of the integrations that we support. Currently it's Jedi swap and Myswap. You can convert into the token that you want, depending on the support of this protocols.
00:13:12.540 - 00:13:39.992, Speaker D: And if eventually ETH grows up, it's your profit. You can sell the ETH back to USDC and you can close your loan. Just not doing transactions for now. It will take. Yeah. Besides that, you can always add further more collateral to your loan to help to ensure you don't get liquidated. Yeah.
00:13:39.992 - 00:14:10.850, Speaker D: So this is broadly some of the major things you can do on this protocol. Yeah, we can talk more about how we manage the risk, how we ensure the interest rates are computed correctly. We use something called dynamic interest rate algorithm. We can talk more details about them soon, but I think this is the overall protocol, in short.
00:14:11.220 - 00:14:34.040, Speaker B: Okay, great. So, yeah, in terms of the demo, I think that gives a lot of color to the people listening. We can move over to some product questions in the protocol. I think we can actually start before we get into the interest rate stuff. Somebody's asking the chat about whether in the future there'll be an option to auto pay loans with gains from yields on deposits.
00:14:37.900 - 00:14:40.170, Speaker D: Can you repeat the last part again?
00:14:40.860 - 00:14:54.210, Speaker B: Let's say you take out a loan and then you have a deposit that's earning yield. Can you automatically repay that loan with the yield without needing to manually go and claim the yield and repay it?
00:14:56.100 - 00:15:25.690, Speaker D: That is a good thought. I think we can definitely work on doing something like that. I think we could create some auto compounding or auto repaying loans kind of system, where, depending on the integration where you have staked and if you're earning good yield there, we can always use that yield to repay the loan, plus any interest that is due to hashtag, yeah, it is possible.
00:15:26.700 - 00:16:09.030, Speaker B: Okay, so I think even before we get into the interest rate algorithms, so you started before showing, if I deposit and I lock up the money for seven days or for 30 days, I'll obviously get higher interest rates depending on how much you lock the money for. So maybe before we actually get into the deep calculations, I guess, how is that? Maybe let's go into how these interest rates are being calculated. So, I don't know if you want to jump straight into the algorithms you have or talk high level, I'll let you take it.
00:16:10.540 - 00:16:54.180, Speaker D: I'll not go too technical in here, but I can give you an impusion of how this works. So, depending on the, let's say you want to supply, and we are providing you three options, flexible, one month, two weeks like this. So each of this tranche will pay you 20% higher interest. So if the flexible currently is paying 5%, if you go for two weeks, you will almost get 6%. And if you go for one month, you will get 20% more than the 6%. That's how we have designed. And this is a variable that is adjustable.
00:16:54.180 - 00:17:38.564, Speaker D: And the overall interest rate algorithm uses on the intuition that we have borrowers and we have to pay them x percent of interest as a protocol. Sorry, the borrowers are paying us some x percent interest to the protocol, and we have our suppliers whom the protocol has to pay the interest. So we try to match the net interest, payables and interest that we would receive. And that's how we put it to a dynamic logic into the protocol to ensure the interest rates are always subject to supply and demand in the market. Yeah, that's how, in short, I would.
00:17:38.602 - 00:17:55.640, Speaker B: Say maybe this specific example of increasing the interest rate by 20%. Is that 20% something that's hard coded or it's dynamic depending on the supply and demand in the protocol.
00:17:57.180 - 00:18:12.930, Speaker D: So as of now, it is set by the protocol. It is how much interest rate we have to, it can increase, is set by the protocol and it can be changed, but it is not very dynamic, I would say for now.
00:18:14.020 - 00:18:25.170, Speaker B: Yeah, got you. So if I recall correctly, there's an abbreviation for this protocol like dial, I think.
00:18:25.960 - 00:18:29.220, Speaker D: Yes, dynamic interest algorithm.
00:18:29.800 - 00:18:46.010, Speaker B: Okay. But then in the long term equilibrium, once, let's say there's millions of dollars of TVL, then there's something more. Market forces will sort of decide the interest rate based on supply and.
00:18:47.820 - 00:18:52.920, Speaker D: Correct. Yeah, I think that's what dial does as a proof.
00:18:53.080 - 00:19:31.930, Speaker B: Right. Okay, great. I think some listeners are probably wondering why use this as opposed to other lending protocols out there? I have some good answers. I want to see what you say. So firstly, I'll start with one answer. You've shown the ability to do under collateralized lending as long as you're trading within hashtag, which provides basically this margin lending capability that doesn't really exist on other protocols. Anything else you want to add on that?
00:19:33.500 - 00:20:16.710, Speaker D: Yeah, so there is something, what we see that is easily seen in front to users like you were able to get better interest rates, maybe you are able to make better money by able to go under collateralized lending. That is something you can directly understand. But behind the hoods as well. I think our risk management is very, we take risk management very critically since it's under collateralized lending protocol. We always have to ensure protocol. The depositors or the suppliers never make a loss. And it is on us and the community to ensure the risk that we set within the protocol is correct.
00:20:16.710 - 00:20:52.080, Speaker D: So we do several things in that aspect. Some of them include actively monitoring the protocol, all the loans, et cetera, and also include limits on how much someone can borrow. We do not want to issue loans that more loans than something we cannot liquidate or we cannot liquidate without a loss. So that is something we take very seriously. Yeah. I think safety also is an important factor that everyone should see when using these protocols.
00:20:54.580 - 00:21:19.640, Speaker B: Yeah, that's a good thing. I think risk management, especially in the on chain world, is very important. You also mentioned the responsibility of the community in contributing to risk management. Maybe. Do you want to give a sentence about different ways a community can help? Maybe bug bounties, maybe other ways to contribute?
00:21:20.640 - 00:22:18.540, Speaker C: Yes. Can I elaborate on that? We are launching bug bounty, which starts from March 1. So tomorrow, and it will end on the 15 March. The details will be shared tomorrow through our official hashtag account. And we are open and we will be excited to see some developers joining in and take a look at our smart contracts and find some bugs and get rewarded on that. And after the Cairo 1.0 we will have a dedicated Cairo audit also because until now we did one with certic but it was around our EVM smart contract.
00:22:20.400 - 00:22:26.450, Speaker B: Okay, great. So once again developers, if they want to look into that bug pounty program, where's the best place to look?
00:22:27.780 - 00:22:43.188, Speaker C: They can join our discord, but also we will share it on our twitter also with a link towards details and everything they will need.
00:22:43.274 - 00:22:48.810, Speaker B: Regarding that, the link to the Twitter and the discord will be in the.
00:22:50.220 - 00:23:20.530, Speaker C: Yeah, our discord is hashtag community, our twitter is, our website is hashtag finance. So either way, every way of this can work and they can be sure that they will have our full support in anything they will need towards that.
00:23:22.100 - 00:23:34.470, Speaker B: Great. And we also send out those links after the call. So I guess Aritha is also segues into my final question, just in general the roadmap. So you're waiting for the Co 1.0?
00:23:38.140 - 00:24:17.590, Speaker C: Yes, we are launching our main net on March 15. We are gathering interest so people can apply to take part on our main net so we can start gaining traction. And I guess our next big step is the full transition on Cairo 1.0. Venkat is more appropriate to elaborate on that. Of course.
00:24:20.680 - 00:24:37.290, Speaker D: Yeah, we will be transitioning. I think we're expecting Cairo 1.0 and regenessis to happen in the next two, three months, I guess so that is something we are actively looking forward to.
00:24:39.340 - 00:25:16.790, Speaker B: Yeah, great. I think it's good for the community here that they don't need to wait for Cairo 1.0 in order to play with your protocol on Mainet, that your protocol will still be going live on Mainet already in the middle of March and not waiting for regenerates. And I think that's a really exciting move. And it's one of the first examples of Defi with real money on main net on Starknet, which is really exciting. All right, I think that's it from me with my questions. Anybody from the hashtag team want to add anything that I didn't mention?
00:25:21.640 - 00:25:49.440, Speaker C: Yes, begat, please go ahead. So I would like to share some key metrics so people who listening can have a better clarity. So we measure 26.3 thousand Twitter followers. Our discord is 15.4 thousand members. We are currently on six months on Stacknet Testnet.
00:25:49.440 - 00:26:55.700, Speaker C: Total users who engaged in testnet are around 11.5k. We have around 85,000 total transactions. PvL as of now is 72.3 million and dominant market is bitcoin. And an interesting key point that it might be very intriguing to our people who are listening is that we also have a contribute to earn program. So we call it c two e. And this in a nutshell is that we are throwing tasks through cruw three and people can go and do their tasks and claim XP points which later can be converted into our native token.
00:26:55.700 - 00:27:01.770, Speaker C: And this will be done later on after our TG token generation event.
00:27:03.740 - 00:27:09.320, Speaker B: Very good. And if people want to look at the contribute to earn program, they can just go to the website and follow the links, I assume.
00:27:10.140 - 00:27:10.890, Speaker C: Yes.
00:27:12.640 - 00:27:34.370, Speaker B: Okay, great. So I think this wraps it up. I think those listening in, we'll send out the links on all the social media channels and if you want to get in touch with the hashtag team, follow their Twitter. You can also message us and we can connect with them. No problems. Great. I think we'll transition now to the second half of this call.
00:27:34.370 - 00:27:54.308, Speaker B: Get Ariel, one of the Starknet product managers working at Starquare, to talk a bit about the Starnet roadmap bit. High level, just not real timelines, but much more about content. Okay, great. So we'll transition to Ariel. Ariel, greetings.
00:27:54.484 - 00:27:55.210, Speaker A: Hey.
00:27:56.060 - 00:27:57.320, Speaker C: Hi Ariel.
00:27:57.660 - 00:27:58.410, Speaker A: Hello.
00:27:59.180 - 00:28:10.670, Speaker B: Great. So Ariel, I think everybody's talking about Kyrie 1.0. Let's not talk timeline, just maybe talk, just general updates and comments about where things are at right now.
00:28:11.520 - 00:28:55.980, Speaker A: Yeah, so think like we've talked about two community calls ago or something like that. The next version of Starknet Eleven focuses on introducing basically Cairo 1.0 to Starknet. This means that for the first time you'll be able to declare and deploy contracts that were written in Cairo. One. This involves a bunch of, let's call it infrastructure changes in starnet. For example, instead of sending Cairo assembly, which was what users sent so far, they would have compiled their contracts from Cairo Zero and sent this result.
00:28:55.980 - 00:30:04.928, Speaker A: They are now sending this new intermediate representation which is called Sierra, which we then compile to Cairo assembly. And this gives us some very important security properties. And maybe I will also add that the planned version for the compiler that will be used throughout eleven. And this is another delicate point, which is also new. Each startnet version has a fixed compiler version with it. This means that if Chiro one added more library functions, for example, more lib functions, this is the terminology in Sierra, then they are not necessarily immediately applicable in starnet. So we're going to fix a compiler version and this will be the version used throughout the Stagnet version up until the next upgrade, which may upgrade the compiler version as well.
00:30:04.928 - 00:31:04.016, Speaker A: So some language upgrades will be seen immediately on Stagnet and some won't, depending on whether or not they touch some low level things. And maybe the final thing which is important for developers is that the upcoming compiler version which we plan to use will include almost all the interesting things that we're missing so far for feature parity. With Cairo Zero in the current version there are some important things missing. I think a lot of the syscalls are missing. Calling other contracts is also missing. Account functionality is missing, and all of these are planned to be added to the compiler version that would be used throughout or eleven. So maybe there will be some minor things missing.
00:31:04.016 - 00:31:12.280, Speaker A: So we wouldn't call it feature parity as of day one, but it will be feature parity adjacent.
00:31:15.500 - 00:31:51.380, Speaker B: So let's just break this up a bit. So you've got Karo and Pano, the language, you've got the compiler which is separate to the language, and then you've got how that interacts with the Starknet operating system. And it's not maybe I'm just repeating stuff that's been said in earlier calls, but I think it's for the benefit community. It's still worthwhile. All those three things can be developed separately and not necessarily be upgraded together. So you can introduce new features to Kyo 1.0 without needing to update the compiler.
00:31:51.380 - 00:31:54.260, Speaker B: You could also update the compiler.
00:31:54.680 - 00:32:27.600, Speaker A: That part actually Chiro one itself is completely coupled to the compiler because while you only have one compiler, the language is completely defined by it. So I don't know. CPP has many compilers, so you have the language semantics and different compilers. But in this world where you only have this one Chiro one compiler, then it basically is the language defining the language. But upgrades to it won't immediately be acceptable in Starknet, or at least not necessarily.
00:32:28.260 - 00:32:39.776, Speaker B: Okay, the Starknet operating system is bound to, at least in the future upcoming release. It's bound to a specific compiler version.
00:32:39.968 - 00:32:40.468, Speaker A: Exactly.
00:32:40.554 - 00:32:42.420, Speaker B: And that is done to ensure stability.
00:32:43.560 - 00:33:51.880, Speaker A: I see. That is done for a lot of reasons, but eventually compilation will be proven. The whole reason to introduce Sierra in the first place I don't want to go on a tangent here, we can talk about it a lot, but the whole reason for introducing Sierra is that we'll be sure that only safe Cairo assembly was put into Starknet, one that cannot fail. So eventually this compilation from Sierra to Cairo assembly will be proven. And this means that one specific compiler will be proven and you can't immediately decide, and it will lose a lot of the guarantees if you can decide without consequence to change this compiler version, because a lot it carries a lot of weight. The code that will eventually be proven depends on this compiler. So we should get used to the idea that the Starnet version is bound to this specific compiler version.
00:33:52.300 - 00:34:13.692, Speaker B: You get what you're saying? Yes, so the Starknet version will be bound to a specific compiler version. Somebody's asking in the YouTube chat how easy will it be for projects to update with these changes. So they've built some Cairo 1.0 code with a certain compiler version, the compiler gets upgraded. Will there be backup compatibility, et cetera?
00:34:13.836 - 00:35:08.484, Speaker A: Yes. So let's say if you don't give it any thought, then you won't get into scenarios where you think your code is starknet compatible. And it won't be, because by default the compiler will only allow stuff that are acceptable on Starknet. If you specifically want to try out new functionality that was added in whatever recent commit to the compiler, then by changing the compilation parameters you could just say okay, I know it's not supported in Stagnet, but I want to compile it and try it out locally anyway. And this would work. I don't know if different toolings will support it immediately. It will probably take time tools for example like Devnet, but you would be able to compile them.
00:35:08.484 - 00:35:27.530, Speaker A: And in the future when some tooling start integrating, probably also test them independently of Starlet. But generally if you don't care about very recent additions, then what you will compile is also what will be supported on start.
00:35:29.020 - 00:35:38.270, Speaker B: And maybe just repeating this, Cairo compilers will be backwards compatible or there's no guarantee of that.
00:35:43.300 - 00:35:50.210, Speaker A: I don't want to say only basically up to bugs, but yes.
00:35:53.620 - 00:35:54.096, Speaker D: This is.
00:35:54.118 - 00:35:59.910, Speaker A: A complicated question and I'm not sure, so I will avoid it for now.
00:36:02.920 - 00:36:19.692, Speaker B: Okay, this is helpful I think. I guess the last question is, you would still encourage projects to explore Curry 1.0 even while Starknet builds out support for the language, right?
00:36:19.786 - 00:36:56.550, Speaker A: Definitely. I mean, with a version that will be released in a week, you will have almost everything you have in Cairo zero. So today there are still very, let's say, legitimate excuses. I mean, you can't call external contracts if your project involves five different contracts. This is already a big problem for you. But now with almost all Ciscos in place, there are a very small number of applications that are missing on Kyo. One functionality that exists on Kyro Zero.
00:36:56.550 - 00:37:08.920, Speaker A: So on the next compiler release. I think that all the big stuff are in there. Modulus, some very specific use cases.
00:37:10.480 - 00:37:23.970, Speaker B: That is very exciting to hear. And that will be with Guosnet zero point eleven. Yes, great. Anything else you want to add?
00:37:28.580 - 00:37:45.030, Speaker A: I don't think so. Try it out. There's a bunch of contracts on the compiler repo. You can check out the prototype for the account. Yeah, great. Yeah.
00:37:45.960 - 00:37:55.480, Speaker B: Those listening who are curious about the need for carry 1.0 and this intermediate representation through Sierra. We have previous community calls where that's discussed.
00:37:57.260 - 00:37:57.720, Speaker A: Please.
00:37:57.790 - 00:38:02.568, Speaker B: Maybe we'll link that in the show notes to know which community call to go to there.
00:38:02.734 - 00:38:10.556, Speaker A: I'll be happy to also talk about it now in case people don't memorize every community call as they should. As they definitely should.
00:38:10.658 - 00:38:24.240, Speaker B: You know what? Yeah, let's talk about it now. I think it's an important topic, and I think it really underpins a lot of what's unique to we need. Yeah, why do we need CRO. Why do we need this intermediate representation?
00:38:25.220 - 00:39:18.928, Speaker A: Yeah, so so far we have this problem of not being able to prove reverted transactions. People who are familiar with Starnet, familiar with Starnet know that starnet blocks don't contain reverted transactions at the moment, which is a very critical feature. You would need to be able to include reverted transaction in blocks and charge fees up to the point of failure. And this is something we can't do now, because if your contract hits an assert zero equals one instruction, I can't put it in a block, I can't prove it, I can't do nothing about it. Either I can prove something or I can't put it in a block at all. And that obviously creates a denial of service risk for in the future decentralized network. And this is something that needs to be solved.
00:39:18.928 - 00:40:39.176, Speaker A: And the direction that we eventually chose is that users will not write immediately in the language that we are approving. They will not write immediately in Cairo assembly and send this to us, as there may be cases where we can prove it, but they will send us some intermediate representation which we will then compile to Cairo assembly, which we know how to prove. Then the way we avoid this reverted transaction problem is that in this compilation from the intermediate representation to Chiro assembly, it is our goal, and we try to guarantee that the generated chiro assembly cannot fail, or more precisely, it can only gracefully fail. So there will not be assert one equals zero instructions. But imagine if else instead of assertions. This is the canonical example that I have in mind, which I think is useful and with those graceful failures, we can then say, okay, this is a transaction that failed at this specific point. We can now put it in a block and even charge fees up to the point of failure.
00:40:39.176 - 00:41:00.310, Speaker A: Note that this is not part of 411 Sierra and Cairo one is, but using these new properties that Sierra gives us for including reverting transaction will only happen in a future version. But now the infrastructure for doing so is there.
00:41:01.000 - 00:41:24.270, Speaker B: I just want to emphasize something. Maybe I'm not setting this there's a difference between a reverta transaction that failed because you reach an assert one equals zero and one that failed because you ran out of gas. On ethereum, your gas limit might not be sufficient enough in the Cairo setting. Both of those have issues, but you could have a situation where you didn't pay sufficient fees for them to write enough code.
00:41:25.920 - 00:42:14.744, Speaker A: I'd say that they're not different. They are both examples of reverted transactions for different reasons. But today we don't have this gas metering separate problem. Today the fees are calculated on l two, sorry, off chain. And the only check that happens in regards to fees is that the fee that was charged in practice is not greater than the fee, the max fee that was sent by the user. This is the only thing that is proven, but no connection between the actual resources and the fee goes into the poof. This is all done by the sequencer and let's call it off chain.
00:42:14.744 - 00:42:46.390, Speaker A: And this is another important thing that Sierra solves, the ability to do gas metering, the ability to update the consumed resources after every instruction. This is actually another very important thing that Sierra gives us. It is not directly related to these reverted transaction issues, but it also gives us gas metering, which again, we're not going to use immediately in eleven. But the infrastructure is there.
00:42:48.780 - 00:43:06.316, Speaker B: We should probably be getting this measured across more. So CRO now enables gas metering. Yes, fantastic. Okay, great. So we need the intermediate repositions. I think I asked this on Sunday night. I'll ask it again for the benefit of the public.
00:43:06.316 - 00:43:14.960, Speaker B: Other teams in the space also, like the Zkevm teams, how are they dealing with these issues of reverted transactions?
00:43:16.260 - 00:44:08.908, Speaker A: Yes, so I think some of them maybe simply did not tackle this issue yet. Because once you're focusing on the proverb, you're still not dealing with DOS prevention in early stages. I don't think it's a concern, just like it wasn't a concern for us until we were happy about the current state of the prover and started thinking more about the status of the decentralized network. The issue came up. Oh, what if users will send a bunch of failed transactions? We can't prove those. What are we going to do? That's one for some roll ups. They circumvent or can circumvent the issues this issue, because they are not directly proving instructions that the user are sending.
00:44:08.908 - 00:45:02.332, Speaker A: They are sort of executing user code in a sandbox. And I think kakarot is a very good example for that. Because kakarot, which is basically a contract that knows how to execute EVM opcodes, why doesn't it have a problem with failed EVM transactions? Because you have eventually this Cairo code, this single Cairo code which is a sort of template and it runs in a sandbox, the EVM opcodes. And he can say, okay, if the EVM fails, I'm going to do such and such. So as long as kakarot code is fine, you don't have to worry about failed EVM instructions. For Kakarot it's just return zero instead of return one. But with Cairo there is no sandbox.
00:45:02.332 - 00:45:54.512, Speaker A: Users are writing Cairo assembly. We are trying to prove execution of Cairo assembly. So once you don't have this nice wrapper around user code, you're facing this problem. So certain roll ups, I think CK sync, I'm not sure who else are executing transactions inside their big circuit, which they're proving. So this can also be thought of as a wrapper around actual transactions. So sometimes you can circumvent this issue. Each solution has different pros and cons.
00:45:54.512 - 00:46:13.050, Speaker A: We chose to go down that path of having an intermediate presentation which does not eventually change the contents of what we are proving. We are still proving the exact same thing. We are still keeping the same Cairo assembly. But we solved it another way, basically.
00:46:15.260 - 00:46:26.220, Speaker B: Great, that does make sense. I think if I'm playing back, what you're saying is if you're running the code within the sandbox, you can basically check it before it reaches the sequencer.
00:46:28.720 - 00:47:16.190, Speaker A: I don't know if I would put it that way. When I run a code in a sandbox, I decide what does it mean for the code to fail? And I can just do some graceful failure in case the internal thing fails. But if we're proving Cairo, and users are sending Cairo, then if it fails I can prove it. But if I take again the Kakarot example, you have their Cairo code, and assuming it's fine, they decide how to simulate EVM internally and they can decide okay, if the EVM fails, I return zero instead of returning one, I write if else and not assertions. Basically. Okay, this is a delicate issue. I hope I'm making some sense.
00:47:18.160 - 00:47:50.360, Speaker B: No, I think you're making sense. I think it's a very subtle topic to explain and just for context for the others. I always like telling the story that Kyra was first developed internally within starkware when we were building Starkx backend just for the benefit of generating these stark proofs without having to write polynomial on the whiteboard every single time. You would want to do a new circuit. And then. So it was very low level. No for loops, no while loops using field elements instead of integers.
00:47:50.360 - 00:48:23.280, Speaker B: And then we realized this is probably worth externalizing and being the smart contract language for Starknet. And then with Starknet you encountered this issue of reverted transactions before. In a centralized world, you can check. As Ariel said, you can always check these things beforehand. So I think the evolution of Cairo is really exciting to watch. Great, so we'll end there. Thank you to hashtag Venkat Arius, all of the whole team for presenting.
00:48:23.280 - 00:48:51.390, Speaker B: I'll send out links after the call in the next few days. I encourage everybody to look into the bug bounty program there to also play on main net come March 15. Don't wait for the regenesis and to join the discord. Follow them on Twitter. I think it's very exciting times for the world of defi. Take everybody. You want to say something?
00:48:52.240 - 00:48:58.300, Speaker D: I have a question, if there's time. Sorry, it's feed the fed.
00:48:59.280 - 00:49:00.030, Speaker A: Yes.
00:49:00.640 - 00:49:14.512, Speaker D: Okay, so how fast do you think we'll be able to consume messages from l one to l two? Either ways in the post regenesis, how.
00:49:14.566 - 00:49:23.540, Speaker A: Fast will we be able to consume l one to l two messages. You said after regenerasis.
00:49:24.760 - 00:49:28.410, Speaker D: Yeah. I want to know more from a state.
00:49:30.380 - 00:50:06.790, Speaker A: L one to l two either way. Okay, so l one to l two is the easy part. And it improves as the sequencer improves in performance. Because for the sequencer to include this l one message as a transaction, it's just catch it on l one, create a corresponding l two transaction. So now when we're moving to rust and the sequencer can process more transactions, same goes for l one to l two messages. So I think there we have a natural, I don't know, improvement vector. And I don't think there's an issue there.
00:50:06.790 - 00:50:42.460, Speaker A: The other direction, l two to l one. An l two message reaches l one only when the block is proven, which currently is on mainet several hours. So there, I can't really say anything about timeline. I can throw some prover optimizations that we have in mind that will help with this. But for example, right now all the proofs on mainnets are recursive.
00:50:47.200 - 00:50:48.670, Speaker D: Sorry, I can't hear.
00:50:50.720 - 00:50:52.030, Speaker B: You yourself.
00:50:55.680 - 00:50:57.568, Speaker A: Sorry. Can you hear me now?
00:50:57.734 - 00:50:58.512, Speaker B: Now we can.
00:50:58.566 - 00:50:59.170, Speaker D: Yeah.
00:50:59.620 - 00:51:13.890, Speaker A: Okay. This is weird. My Airpods now stopped working. 1 second tickets because I played with the box. Let's see now. Okay. Can you hear me? Yeah.
00:51:13.890 - 00:51:53.730, Speaker A: Okay, cool. So in the next chart version we plan to optimize each recursive step and go from 40 minutes to closer to ten minutes for this step. Again, it's not trivial to say what's the actual reduction for the large proof that reaches l one because again, the large proof consists of a lot of those recursive steps. Sorry for the vague answer, but we have some ideas. We're working on them and hopefully I will be able to give more concrete estimates in the near future.
00:51:55.780 - 00:51:58.290, Speaker D: Great. Okay, thank you.
00:52:00.600 - 00:52:10.020, Speaker B: All right, well, with that we'll conclude this community call. Thank you everybody for attending and to Hastech for presenting.
00:52:11.100 - 00:52:33.690, Speaker C: Thanks for having us guys. Looking forward to more interesting spaces or conversations together as we both progress and we wish Starkworth in all the best. And it was a great talk.
00:52:34.860 - 00:52:35.350, Speaker B: Take care.
