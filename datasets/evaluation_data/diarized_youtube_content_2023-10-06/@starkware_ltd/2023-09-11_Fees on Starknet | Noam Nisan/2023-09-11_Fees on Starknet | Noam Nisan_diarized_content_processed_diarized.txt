00:00:02.410 - 00:01:09.860, Speaker A: Okay, so, good morning. I want to tell you a little bit about how we are thinking about fees and startnet. So let me start by sort of framing this talk because I'm not going to be very specific about what exactly are we doing at any point in time, because really the specifics will come out in a snip, in a startnet in improvement proposal in the near future, in the very near future. And that will go through the usual governance process. And then we'll get like the next fee mechanism that will be used in the intermediate time when we still have centralized sequencing and proving, which is the current thing. And of course, once the fee mechanism, like the rest of starquare, will keep on evolving, and once we get to a full decentralized situation, we'll also have the fully decentralized fee mechanism, as you would expect. So the goals, the way that we see that now for the fee mechanism is first of all, we have to make sure that we cover costs, we don't get any DOS attacks and so on.
00:01:09.860 - 00:01:39.578, Speaker A: We have to handle congestion. That's something that the current mechanism does not still do. The current mechanism is like first come, first serve. And when there is congestion, we have to make sure that the most valuable transactions are the ones that get on the blockchain. And finally, we want to do everything in a way that's forward looking. So we're laying the correct foundations for the fee mechanism to actually work in a completely decentralized setting. So actually, let me say one thing.
00:01:39.578 - 00:02:15.058, Speaker A: So again, as I said, I'm not going to give specifics. At 02:00 we're going to have a sort of little workshop where we can get into more into details, answer questions, hear suggestions and so on. So please come to it if you're interested. So just let us begin with the life of a starknet transaction, which is more complex than just your normal layer one transaction. Okay? So first the transaction goes, and the sequencer, sort of validator miner needs to put it into a block. So a transaction with many other transactions goes into a block. The block together with many other blocks goes into the prover.
00:02:15.058 - 00:03:24.542, Speaker A: Actually there's a more complex recursive kind of thing, but let's say for our purposes it's enough to look at many blocks, go into approver, and the prover puts a proof and actually needs to upload it to l one. We pay the fees, we calculate the fees, we decide which transactions are committed into the block at the sequencing time at the beginning, but we still have to pay the fees for the l one actually, the cost for l one gas, when we actually upload the transaction, the proof onto the l one network. Okay? So that's the basic setting that we're in. So when we come to design a fee mechanism, the first question that we need to ask ourselves is what are the resources that we're really trying to handle here? What is going to be congested? And it turned out that there are lots of resources. Also, even in l one, there is more than one resource really underlying what's going on. And in the l two, there are many more. So for example, the first one that you think of sequencing time, sequencer time, okay, we can't take all the sequence, all the transactions that want to run.
00:03:24.542 - 00:03:57.890, Speaker A: Perhaps the sequencer is going to be limited by, because it has to be in a distributed fashion. So we want to make sure that reasonably strong, reasonably weak, if you wish, sequencers can actually share in sequencing. So there is going to be some kind of limit on sequencer time. The same thing is about prover cost. So provers, again, we want to make sure that reasonable computers can do proving. And these are different costs and sequencing costs. So for example, if you look at cryptographic hash functions, some of them are very cheap for the sequencer and expensive for the prover, and some of them are the opposite.
00:03:57.890 - 00:04:37.170, Speaker A: So we need to make sure that you have to take care of both. And of course, we have to worry about the full nodes that need on to always be synced once we have volition. So once our storage is not all on l one, we also will have to worry about the cost of actually taking that into account and so on. So almost all our cost, we are going to try to put them into a single gas measure that will take care of all of them. And there are like two exceptions that I will talk about separately. One of them, the l one data costs, these are going to be very expensive, so you will have to pay that separately. And the other thing is the staking cost.
00:04:37.170 - 00:05:13.098, Speaker A: When people actually start doing the staking in a fully decentralized setting, of course you will have to compensate them with some kind of block reward, but that's only when decentralized. I'll talk a little bit about that at the end. Okay, so can someone take that off? Okay, good. So let's start talking about the l two gas. So again, we're trying to take a lot of resources into account into a single gas measure because that's much better. Ux. It's much simpler to handle.
00:05:13.098 - 00:06:00.990, Speaker A: And the question is, to what extent can we actually pull that off. So, for example, even in ethereum, which is much more, much simpler, there are questions whether storage is really, it's a good idea that storage is also taken care into just like the normal l one gas. In our situation, where we have multiple resources, that's an even bigger question. So our basic strategy of trying to do that is basically we're going to handle the worst case in the worst case and the average case in the average case. What does that mean? We have to first make sure that we are not susceptible to denial of service attacks. So we have to make sure that none of our resources is going to be completely overwhelmed because we didn't account for it completely. So we're going to have to take the worst case cost for the worst case operations.
00:06:00.990 - 00:06:52.750, Speaker A: Now that could in principle theoretically be a real penalty and a real hit on performance. But the hope is that on the average, the things will sort of even out in the sense that what we really believe that is most likely to be a real bottleneck, and the one that really limits our throughput is a sequencer time. Most of the other stuff can be sort of, for example, prover time, which is also very expensive, can be paralyzed. Sequencer cannot be paralyzed, at least theoretically. I mean, in principle there are some tricks of course, of doing parallelization, but in principle it's a sequential operation and that cannot be paralyzed. So that's going to remain a bottleneck. Of course, we'll have to see the actual loads that we get from users, and we may need to change things as that improves.
00:06:52.750 - 00:07:55.854, Speaker A: One interesting thing is that the resource that we are probably going to be able to completely ignore is a full node sync time. And that's interesting because that's exactly the opposite from Ethereum, where there, the node sync time is what they consider to be their main bottleneck. So the reason they limit gas in Ethereum is exactly because they're worried about weak enough full nodes that they can syncing quickly enough. The reason why we should be able to actually ignore that is because we get proofs, intermediate proofs about. Can you go one back? Okay, so the reason why we can probably ignore that is because we get intermediate proofs of validity. So you don't really have to think all the way from the start, because you get proofs in the middle, and then you can just continue thinking from there. Of course, we're not 100% sure that we will be able to keep on working with only a single resource.
00:07:55.854 - 00:08:30.234, Speaker A: And probably the most suspicious resource is going to be the storage off chain storage the l one storage, anyway, is going to be its own resource, as we said. But we'll see. Hopefully we can pull it off just like Ethereum has kept on pulling it off. Otherwise it will need to be split to a different resource. Let us talk about l one gas. So l one gas, really, there are two different l one gas used, let's say, in our system. The first one is the data costs of a transaction.
00:08:30.234 - 00:09:14.860, Speaker A: Transaction uses data, it keeps it on l one. And that's really the most expensive part of the transaction. And for that you need to pay directly. There's no question about that. There is also l one gas that we actually, we pay for the proof, and that's sort of amortized over all transactions in your proof, and that's maybe an order of magnitude smaller than the first one, and that we can basically absorb into the l two gas in different ways. Now, an important point about l one gas is there is this time gap between the time we need to charge you for the l one gas, which is at sequencing time, and the time that we actually pay for the l one gas. Let's say the data cost, which is when you upload the proof to the l one.
00:09:14.860 - 00:10:31.038, Speaker A: So someone needs to take the risk, the exchange risk, if you wish, between the currency that you're paying and the l one gas on l one, and the gas price on l one. And while we are in a centralized situation, that will just be the sequencer that we trust, and the sequencer will just use its best estimate, if you wish, like a simple learning mechanism, trying to figure out what is going to be the l one gas price when at upload time, and charge that when sequencing. So the point is you need to determine the price at sequencing, because you need to make sure that only transactions that are willing to pay this price will be sequenced. And once we're in fully decentralized mode, you will not be able to trust the sequencer to actually do this estimate correctly because they may gain from it. And there you will need to have some kind of futures market for gas that sort of the protocol actually specifies and does not let sequencers do any manipulation. Okay, but that's going to be in the second stage, so I'm not going to discuss it further now. So how is a fee auction actually going to be done? So we were looking basically at three reasonable possibilities.
00:10:31.038 - 00:11:29.554, Speaker A: One of them is doing like in bitcoin, a first price. One of them is doing like in ethereum, something like 1559, that basically you get a posted price that's determined by previous blocks. And we also looked at the third valve variant, which is like uniform price, where you let the sequencer decide on the price per block, but it's going to be a single price. So we looked at all of the three things and the way we're thinking, we're probably going to go with something that's similar to eip one one two Ethereum. So basically it means that the price of l two gas is going to be determined by previous blocks in a way that sort of tries to figure out the market equilibrium price, the market clearing price, and that price is going to be decided upon before the next block starts. Of course, you also need the other kind of things that you have there. For example, we will need an extra tip when we're just like in Ethereum.
00:11:29.554 - 00:12:23.358, Speaker A: At a certain point, this kind of market clearing of previous blocks could not solve everything. So you need a tip, and we're going to have that, but we're going to have a few deltas, a few differences from Ethereum. One of them is we're going to allow ourselves variable time for blocks, at least at the beginning. So we're going to do the adjustment according to gas per time rather than gas per block only. We're going to be in a different point with regards to difference between the target gas and the maximum gas, because we are more leaning towards the worst case optimality rather than the average case, because we don't have the problem with full nodes. So there are going to be a little differences. So the bid format, basically you're going to give for each one of the two resources, l one gas and l two gas.
00:12:23.358 - 00:13:08.354, Speaker A: You're going to give a maximum price and a maximum quantity for the l two only. You're also going to give a tip amount and you can also have a maximum total payment. And the basic idea is that what you can take into the block, what the sequencer will actually put into the block, is the only transaction that are willing to pay the current l one price and the current l two price for the two resources that they use. So that's going to be the thing. And if we're at the end, we have too much more than the block can carry, then we prioritize by tip, just like in Ethereum. So that's in a very short slide. The basic idea of how we're going to do the auction.
00:13:08.354 - 00:13:43.010, Speaker A: More details. If you want, you can come at 02:00. Okay, a few more things. So as long as our sequencing and proving is centralized, we are not going to do any new minting. We don't need to do new minting or block rewards for minting until we decentralize. The whole point of block rewards from minting is to actually give rewards to the stakers which together operate the system. So until we're there, we don't need to do any new minting or burning and we don't intend to.
00:13:43.010 - 00:14:14.250, Speaker A: And by the way, also burning. So in 1559 in Ethereum, you burn stuff. Until we decentralize, we don't need to burn the stuff. Once we are decentralized, we of course will need to pay the opportunity cost of the capital cost of the stakers. We'll need to pay from that. And that should come optimally mostly from new minting. And the reason why you do want to do it from new minting is because basically you want to keep the transaction fees low.
00:14:14.250 - 00:15:23.278, Speaker A: You prefer them to be at the marginal cost rather than the average cost. That way you get more usage, the platform grows more, and that's probably the right thing from an economic point of view. The last thing that I want to talk about is starkware has already declared, I think that was even before Starknet, the Starknet foundation was formed, that they want to actually share some of the fees with the developers. So there are two variants of developers here. One of them is those that actually write contracts for which we can measure the use and the way we can measure how many much fees are being paid to use a contract. Okay, so if the contract takes so and so l two gas, we can actually count that and see that people are actually paying fees to use this piece of software. And in that case we can just give a fraction of the fees paid by users, which someone found that to be useful, down to the contract writer, to the Dapp developer.
00:15:23.278 - 00:16:11.040, Speaker A: So that's going to be the conceptually easy kind of way we allocate money to developers. So that's going to be one thing that we're going to do. But also there are some developers that write more generic infrastructure that we can't measure directly, and we're going to try to find a more clever way to actually be able to compensate them. The details of this are not completely figured out yet, but this is a basic idea that we're trying to do and. Okay, so I'll stop at this point again at 02:00 we have more discussions, you can ask questions, get details, give us opinions. Also, we're there to listen as well as tell and thank you.
