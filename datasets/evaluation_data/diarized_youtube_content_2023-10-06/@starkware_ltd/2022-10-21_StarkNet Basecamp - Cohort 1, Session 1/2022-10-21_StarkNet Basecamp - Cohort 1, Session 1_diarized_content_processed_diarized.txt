00:00:04.170 - 00:00:16.400, Speaker A: Know, and you're going to start a live stream on YouTube. Not for people to watch live on YouTube. It's just so when we finish the session, the video will be available on YouTube, so you can watch it later if you want to.
00:00:23.970 - 00:00:24.382, Speaker B: Right.
00:00:24.436 - 00:01:13.576, Speaker A: It seems to be working. Let's check on Ben to see where he is. If you want to ask any question during the session, you can ask a question here on Zoom.
00:01:13.608 - 00:01:17.980, Speaker B: You can either use the Q A.
00:01:18.130 - 00:02:13.358, Speaker A: Option, or you can just also raise your hand if you want to actually talk, or you can ask a question on discord as well. I'm going to be monitoring both. If I can, I'm going to answer the question myself directly. If not, I'll interrupt Ben so he can answer the question. By the way, can someone on Discord. Let me know if you can hear me? All right, if you can see me, is the zoom webinar working fine for you? Hello, Ben? Ben, I cannot hear you.
00:02:13.524 - 00:02:15.120, Speaker B: Hey, can you hear me?
00:02:15.490 - 00:02:17.214, Speaker A: Yes, now I can.
00:02:17.412 - 00:02:20.750, Speaker B: So I was getting all the instructions.
00:02:21.990 - 00:02:54.666, Speaker A: The chat disabled. I'm just looking at some of the questions. The Q A section. I believe that for the webinar, because usually not a regular Zoom meeting, we're using the webinar version. I believe there's no chat because it's made up to be used for larger audiences. But I keep thinking with the option to see if we can find it. For now, the Q A or discord could be a place you can use, but the Q A is a good.
00:02:54.688 - 00:03:00.220, Speaker B: Place to ask your question and get an okay. Okay, that sounds good.
00:03:01.630 - 00:03:09.790, Speaker A: We are also live streaming to YouTube, Ben, just having us an unlisted video. So as soon as we finish session, this video will be available for people there.
00:03:09.940 - 00:03:10.350, Speaker C: Cool.
00:03:10.420 - 00:03:16.642, Speaker B: And is this trainer, is this live streaming to the Starkware channel?
00:03:16.776 - 00:03:17.460, Speaker C: Yeah.
00:03:18.310 - 00:03:27.410, Speaker A: So once we're done, I'll send the link. I sent an email with the link for the video, so you can watch it later at your own pace if you want to, for the audience.
00:03:30.870 - 00:03:39.900, Speaker B: Cool. I think we'll just wait for just a couple of minutes to see people trickle in. David, do you know if people can talk.
00:03:41.710 - 00:03:43.082, Speaker A: They will have to raise their.
00:03:43.136 - 00:03:46.026, Speaker B: Hand and then we have to give.
00:03:46.048 - 00:03:50.460, Speaker A: Them permission to talk. By default, they cannot use the.
00:03:56.910 - 00:04:46.414, Speaker B: I was thinking about having know give an intro of yourself and your background because this really is meant to be a cohort. I want everyone to be able to ping questions to everybody in the cohort and ask questions of their cohort members along with us. So it might just be a bit of a pain. If everyone's going to have to raise their hands, so we call on them. So if everyone doesn't mind, can you just kind of give a brief description, a brief intro of yourself, maybe your history with layer ones or layer twos in the Discord channel, just so people can get a feel of who everyone is, what everyone's name is. I'd like this to be a collaborative effort at the end of the day. Cool.
00:04:46.414 - 00:05:12.290, Speaker B: We have people kind of trickling in. I might give it just another couple minutes here. I see a couple of members from the cohort zero, which is pretty cool. Good to have you back today. I'll start by giving just a brief introduction of myself. My name is Ben Goebel. I'm a developer advocate here at Starquare.
00:05:12.290 - 00:05:42.300, Speaker B: Been working here the better part of the year. I got into blockchains as kind of moonlighting in blockchain dev. I got into the infrastructure side of everything, did some work with the Ethereum foundation, and then found my way to the coolest part of the ecosystem, zkps and hardcore cryptography. That's a bit about me. David, do you want to just intro yourself and who you are?
00:05:43.710 - 00:06:14.600, Speaker A: Yeah. So I'm a developer advocate. I'm locating in Toronto. Just joined Starware maybe like two months ago. I'm actually here to answer as many questions as I can, but also as another person learning from Ben. I think Ben has a ton of knowledge that I also want to absorb, especially when it comes to the math behind starks and things like that. So, yeah, I ask whatever I can and also I learn as much as I can as well at the same time.
00:06:15.610 - 00:06:24.220, Speaker B: Awesome. And then we should have Henry on. Yeah, cool. So he's raising his hand. So let's see if we can allow to talk.
00:06:25.230 - 00:06:29.402, Speaker C: Hey, I don't think you can see me though.
00:06:29.536 - 00:06:30.220, Speaker B: No.
00:06:31.390 - 00:06:38.430, Speaker C: How can I activate my camera? Maybe it's because I'm like people attendance.
00:06:39.330 - 00:06:49.730, Speaker A: It's because the Zoom webinar, right. It's made in this way because it's made for larger audiences. So it's not meant to be people putting the camera on, only the host or panelists.
00:06:50.230 - 00:07:16.314, Speaker C: Okay. So it's fine, don't worry. Okay, so I'll say hi. So my name is Henri. I work at Starquare also as a dev advocate with Ben and David. So I just wanted to say to everyone, hello and welcome for this session. I wanted to mention that this is like a very special program for us.
00:07:16.314 - 00:07:34.400, Speaker C: As you can see, we did not communicate much about it. It's the second session we're running, we had quart zero and you all are quart one. This is kind of a special ops for us because our mission is to scale Stark education and up. Nice. I think you're going to be.
00:07:37.990 - 00:07:41.300, Speaker B: I'll just promote Henry to panelists so he can hear. Very nice.
00:07:44.470 - 00:08:12.570, Speaker C: You can see me. Hey, so wanted to mention that this is a big project for us. We really want to scale education around Starks, Cairo, Starknet and writing dapps on Starknet. So congratulations on making it here. This program is still in development and we actually need your help. I mean, Starknet needs your help with a lot of things, but this program also needs it. You're going to be working off of a repo.
00:08:12.570 - 00:08:51.110, Speaker C: Feel free to make prs anything you see that, even if it's just a typo, even if it's just a piece of code where you feel like one comment would be better, feel free to add it. Please send us a pr. We really need your help to make this better and I want to tell everyone that I hope you make it through the course right now. Sometimes I receive curriculum from people who say, yeah, I'm a solidity developer. I was in court three of the consensus academy. Well, hopefully you can put in your cv that a while back you were in court one of Starknet basecamp. So make sure to follow through.
00:08:51.110 - 00:09:07.118, Speaker C: It's not just about the t shirt you may get at the end, it's also about the friends you'll make along the way and the knowledge you'll be able to spread. So be sure to stick around, ask questions, and we hope to have you in the ecosystem for a long time.
00:09:07.204 - 00:09:29.958, Speaker B: Thanks. The t shirt that you may get at the end is very cool, FYI. So we'll go over some administration stuff, how you would potentially get that t shirt. We got about 40 people in attendance, which is awesome. I see people giving intros to themselves in the discord. So yeah, if you guys can keep doing that, that'd be great. It's good to get to know you guys.
00:09:29.958 - 00:09:43.500, Speaker B: And again, this is a collaborative effort like we've all mentioned. Cool. Can someone just verify you can see my screen?
00:09:47.840 - 00:09:48.812, Speaker A: I can.
00:09:48.946 - 00:09:49.340, Speaker B: Okay.
00:09:49.410 - 00:09:50.510, Speaker C: I can too.
00:09:51.680 - 00:10:18.884, Speaker B: Awesome. We're going to have, for most of these sessions, we're going to have two of the dev advocates on. So if I am not monitoring the comment section, feel free to ask questions as we go or raise your hand and then one of us will pick on you. So yeah, definitely feel free to kind of ping me as we go. Yeah, we're going to get some administrative stuff out of the way. So base camp overview. We're going to do a lot of our communication in the Discord channel.
00:10:18.884 - 00:10:45.836, Speaker B: If you're not already on the Discord channel, here's the link. David also sent out an email with all of this information. So we're going to be doing our talking and all the intros right now even are going on in the Discord channel. The channel is basecamp cohort one contacts. We'll have contacts for each of the presenters during the day. Today it's going to be me. I should have put Henry on there, but for Henry it's just he NRI at Starkware Co as well.
00:10:45.836 - 00:11:12.500, Speaker B: Feel free to reach out if you have any direct questions for us. Setup. You should have had this in the link as well. So we're going to be working off this repository under this GitHub organization. The GitHub organization is starknet.edu. There's a lot of good tutorials under there. We have quite a few different tutorials talking about different parts of the Starknet ecosystem and platform messaging, bridge debugging.
00:11:12.500 - 00:11:52.224, Speaker B: We'll go through almost all of these concepts in basecamp, so don't feel like you need to jump to those now, but just know that that's where they live. We'll be working off base camp and I'll go over a little bit about how base camp is structured. The one thing that we'd love for you to set up, definitely before tomorrow, but hopefully you already have it set up, is this Cairo quickstart here. This is in the Cairo docs, just how to get your environment set up, how to init your python virtual environment, get all your dependencies managed. If you have any questions, again, ping. The discord will get you set up. Ultimate setup.
00:11:52.224 - 00:12:38.992, Speaker B: This is not something you need for today or tomorrow. Not tomorrow, next week. You'll need it in two weeks from now. It goes over some extra dev tooling, like postman collections, extra dev tooling about kind of how to set up environments with certain system d files, docker containers, so on and so forth. So you won't need that for today or next week, but the week after. Cool. So this epic t shirt that we've been hinting at, at the end of the day we want you guys to come out as competent members of the ecosystem and there's a couple of ways we're going to try to measure that.
00:12:38.992 - 00:13:08.172, Speaker B: One of them is with the tutorial points. So the way basecamp is structured this time around is we're going to do one two hour session per week for five weeks. And those sessions will be at the same time of today as today on the same webinar link that was sent out by David. In the off time you're going to have homework assignments. So in the last session there was only a one day off time. So pretty quick turnaround here. You're going to have a whole week.
00:13:08.172 - 00:13:44.164, Speaker B: So you'll have a whole week to do some of these tutorials and workshops. One of those is the Starknet Cairo 101. So you'll need a wallet on Starknet with all of the Cairo 101 points. You'll need a wallet on Starknet with all of the messaging bridge points. And then, like Henry alluded to, we'd like this to be a collaborative effort. So we're hoping to spit out competent people and we'd like to see that competence reflected in the repo. So if you guys can go in and contribute to basecamp, contribute to the tutorials in starknet.edu,
00:13:44.164 - 00:14:25.220, Speaker B: that would be awesome. And we're going to do a presentation of those graduation requirements just to see what you guys came up with. If you guys don't want to do a pr to the base camp or the tutorials, you can also come out with just an educational material. Educational smart contract on Starknet. There's the last cohort, we only had about 15 participants, but we got some really good contributions out of that. And at the end of the day, why do you want to graduate? Because you're going to get some cool swag, t shirt, water bottle, stickers, socks, discord role. So you're going to get a discord role for base camper and also mentor.
00:14:25.220 - 00:15:05.164, Speaker B: Base camp is meant to be a deep dive on the entire stack. So when you come out, you should have some idea about how the entire Starknet stack works. So we're hoping that we can point some newcomers to you guys as mentors. Henry, on the last day is going to go over a bit more in depth about the mentorship program, access rights, bragging rights, and my favorite, learning new stuff is cool. Who doesn't love learning new stuff? Right on. We don't need to do this for any swag. Cool schedule.
00:15:05.164 - 00:15:07.324, Speaker B: We went over it a bit starks.
00:15:07.372 - 00:15:54.672, Speaker C: Today, but aside from that, if I may see something here, Sophia, I was talking with Ellie earlier and I was telling, you know, Starks are difficult and how do you reconcile with the fact that there's so much mathematics involved? And he told, you know, blockchain has a lot of different branches of mathematics involved and you don't have to know each branch perfectly to understand blockchain and Starks are the same. You don't need to know prime field stuff deeply to know Starks. The thing is that the material doesn't exist. So this class is an attempt to cover this. So these things will get clearer in time. But for an hour, you'll have to learn a new stuff and a lot of new stuff that's super exciting, new mathematical stuff you didn't know. Anyway, sorry I cut you.
00:15:54.806 - 00:16:46.272, Speaker B: No, no, it's a really good point, because as we're teaching basically everything from Starks to Cairo, there's always things that you can blackbox. You can blackbox a lot of this really in depth cryptography. But if you really want to get to first principles on this stuff, if you really want to dig down and see how the layers are built on top of each other, you do kind of need to take the time and at least get the concepts through your head. So especially today is going to be an attempt of that. It's going to be an attempt to kind of demystify some of these crazy cryptographic primitives and these words that you hear that if you're not a math major, you might run away. I know I did. I mean, I come from a software engineering background, so when I hear things like finite field cryptography, at first I kind of shied away.
00:16:46.272 - 00:17:28.160, Speaker B: But if you really dig down, all these concepts are learnable and it's not too bad and it's fun to do. Okay, so let me see where we're at. I'm going to give a brief. I know we just sent out the primer basically yesterday, so you guys might not have had a chance to look through it. Everyone's going to be coming from different backgrounds. Some people will have development experience in web two, some will have development experience in web three. So the primer is really to get everyone on kind of the same footing with why roll ups are important, what the history of roll ups is, where they come from in the history of bitcoin, smart contracts, ethereum, so on and so forth.
00:17:28.160 - 00:18:18.860, Speaker B: But it's also an attempt to show how basecamp is laid out. So I don't know if you guys have done programming bitcoin, but the goal of basecamp is to give you guys piecemeal scripts that you could run as one off scripts as illustrative of what's going on under the hood. So in the primer, one of those is talking about block verification for the bitcoin blocks. We also have one going over how to hash a merkel. Patricia, try if you did go through it. This is how the rest of basecamp is laid out. One of the contributions I would love to see is that everyone comes with different levels of comfort in different programming languages.
00:18:18.860 - 00:19:03.580, Speaker B: So the stack of Starknet started out being written in Python. So a lot of the example code is written in Python. But if you come to the table or if you're looking at like Lambda classes, repos that are written in rust, we would love to see some examples come through in rust. I personally am a go developer, so some examples here in go. And then if you are going to contribute in that way, you'll see that the subdirectories for these concepts are named by the programming language and that will become clear throughout basecamp. So block verification in go. You can just as easily do bitcoin, ethereum, block verification in Python.
00:19:03.580 - 00:19:21.060, Speaker B: If you haven't read the primer yet, I would recommend going and reading it, especially if you don't come from a web three context. Okay, cool. So feedback. I'm going to throw it to David just briefly to talk about feedback, and then we'll start digging into some crazy math.
00:19:23.080 - 00:19:53.928, Speaker A: Yes. So maybe before we end each session, I'm going to be sending you a link for a Google form. It's going to be only like three or four questions. It's going to be collected anonymously. Basically, we just want to improve, not only improving even for the next session. So any feedback you give us now will be incredible useful for the next session that we're going to have for base camp, but also for next iteration that we're going to do of this for different cohorts. So please take the time to provide your comments.
00:19:53.928 - 00:20:09.520, Speaker A: It's a short one and I'll make sure to send you by email the link for it. And at the end of the whole course we send another feedback form just to have an idea of your feedback of the whole course, not only individual sessions.
00:20:13.680 - 00:20:29.780, Speaker B: Sweet. Let's dig in. Okay. Oh man, I thought we were done with administration. We got a little more administration. Bear with me. We're going to start each day with a map.
00:20:29.780 - 00:21:12.876, Speaker B: The goal of this is to get you guys really comfortable with Starknet as a layer two validity roll up. So we're going to start each day with this map, and we're going to talk about different parts of this map each day. So I'm going to tell you what this map is, and we're going to reiterate it each day so we know where we're looking. So Starknet is made up of some infrastructure pieces and some execution pieces, just like Ethereum layer one. The infrastructure pieces are clients like clis front ends and client libraries that structure transactions and send them to the sequencer. The sequencer sequences transactions. It's written in a general purpose programming language.
00:21:12.876 - 00:22:14.980, Speaker B: So one day we're going to have sequencers be, hopefully we're going to have sequencers not just be built by us, but be built by the community. So you'll have different client implementations just like you see in Ethereum, the execution flow. So we have the Starknet OS written in Cairo, smart contracts written in Cairo. And again, some of this might not make sense to you now, but by the end of it, you're going to look at this map and have a deep understanding of each of these blocks. So Starknet l two, execution by the Snarknet Os in Cairo, smart contracts written by you guys in Cairo, and that execution is proved by the sharp, the shared prover, which is a stark prover. It's going to execute the Cairo VM at Starknet l two, and it's going to broadcast that proof to the stark verifier written in solidity on Ethereum layer one. And then we'll get into data availability just a bit later in camp three.
00:22:14.980 - 00:22:43.040, Speaker B: But essentially, in order to reconstruct the state of our validity roll up, we need to have the state that is transitioned be written somewhere. And we're going to do that with Ethereum layer one. Okay, so, yeah, Stark prover. Stark prover written in a general purpose programming language. And you'll see these little magnifying glasses here. That's going to be where we're looking. So today we're looking at sharp and the verifier.
00:22:43.040 - 00:23:11.480, Speaker B: Cool. And then this is the transaction flow. So, clients submitted transaction to sequencers. Sequencers include the transaction in a block, proof is submitted, and a state update is written. Okay, now we're getting into fun math. All right, zero knowledge proof. Zero knowledge in general is kind of a buzword, a hot topic all over the industry.
00:23:11.480 - 00:24:14.440, Speaker B: So to level set with everybody, I think we're going to do some definitions here. When people say ZK proofs, they're really talking about a ZK proof system that doesn't exist outside of multiple entities within the system. So a proof system is one in which a zero knowledge proof system is one in which there's a secret information known by approver, not known to a verifier, and the verifier is still convinced of the computational claim without learning the new information or the input. So, a lot of times this is kind of explained with the where's Waldo? Book, where the prover can basically have the entire page blocked out, except for a tiny slit in the paper that shows where Waldo is. And the verifier is convinced that the prover knows where Waldo is without knowing all of the information of the page. Interactive proof system. So, an interactive proof system is one in which the model has the prover and verifier go have bi directional communication.
00:24:14.440 - 00:24:50.180, Speaker B: So the prover is trying to convince the verifier, and the verifier sends multiple different queries back to the prover, and they have multiple different rounds of communication in their proof system, until the verifier is finally convinced of the claim. Non interactive proof systems. So these are proof systems like snarks and starks. This is what we're going to work with. It's unidirectional. So the difference is there's only a one way communication from the prover to the verifier, and the verifier still remains convinced of the computational claim. Succinct.
00:24:50.180 - 00:25:36.472, Speaker B: A succinct proof is one where the verifier can run an order of magnitude faster than a naive re execution of the program. This is really important. It basically enables all of the new things that the ZK proof systems kind of enable, like validity roll ups without succinctness, none of this really matters to some point. The verifier is written in solidity, and it's written in a resource constrained environment of the L one. So the verifier needs to have some version of succinctness in order to prove. In a resource constrained environment, snarks are succinct, non interactive arguments of knowledge. So that should make a little more sense.
00:25:36.472 - 00:25:53.900, Speaker B: Now, what a snark is. And starks are scalable, transparent arguments of knowledge. Cool. Okay, so a stark proof. When we talk about a stark proof, we're talking about.
00:25:53.970 - 00:25:59.708, Speaker C: Can I interrupt you just a sec? Do you want to address questions now or later?
00:25:59.794 - 00:26:01.664, Speaker B: Yes. No, let's do it now. Cool.
00:26:01.702 - 00:26:15.184, Speaker C: So, there's a question by Prashant, who is asking on what all factors does syncs depend? What does make a proof succeed? Like, are there specific parameters, or is this just a general concept?
00:26:15.232 - 00:26:34.424, Speaker B: For now, that is a great question, one that I am not sure I have all the answers of. I believe that succinctness has some, I think, the order of magnitude that we have in the definition does have some metric behind it? I don't actually know that, Henry. Do you?
00:26:34.542 - 00:27:01.010, Speaker C: That's a good question. I think basically, succinctness is the fact that it takes you less effort to verify proof than to generate it. I think it depends, like a few factors, and you'll see it later down the line. And it will be much clearer at the end of this class when you'll know how exactly the proof is generated. I think one is how many samples you take to verify the proof. Right. Because there's some, like.
00:27:01.010 - 00:27:29.960, Speaker C: Don't want to say anything stupid, but you take some samples. What I would like to know is how to make it more succeed. You can make it more succinct by lowering your risk tolerance. Something like that. And, yeah, the succeedness is, right now it's log square of n because of fry. Now, how can you make it more succeed? I think it's always like a trade off between security and succeedness. That's how far I would go right now.
00:27:29.960 - 00:27:33.580, Speaker C: But I think at the end of the class, it will be a bit clearer.
00:27:34.720 - 00:28:11.684, Speaker B: Yeah, no, I think that's a great point. When Henry said you can lower your risk all. At the end of the day, these are all statistical, you know, we're. We're. We're making claims based on these probabilistic proof systems, which I'll get into in just a sec, but if you lower your tolerance there, you can make the verifier run in slightly less time. Risk tolerance as in acceptable wrong proofs?
00:28:11.812 - 00:28:38.400, Speaker C: Yeah, essentially, like all of these proof systems, they're probabilistic. You're dealing with the probability of accepting a proof thinking it is valid when it is not. And are you ready to accept a 5% risk? Probably not. Right, 0.5%. It just depends on where you put the scale, where if it takes that much time to generate it, then I'm fine with it, essentially.
00:28:39.860 - 00:29:11.592, Speaker B: Sweet. Yes. Cool. So, optimistic roll ups are on the other extreme of risk tolerance. I would say that it's a completely different paradigm. I don't think that you can say they're on the other extreme because the risk tolerance that we're talking about is a complete obfuscation of trust. You actually don't need to trust anything except for the fact that there's less likelihood of an invalid proof being sent than there is of a hash collage in Shaw.
00:29:11.736 - 00:29:31.250, Speaker C: Yeah. And also, I'd argue also that with stark proofs, you're basically having. Your risk tolerance is related to math. Whereas for optimistic roll up, your risk tolerance is related to a social risk, a game, theoretical one. So it's not the same. Like we're not dealing with the same primitives. They're really not comparable in that sense.
00:29:33.620 - 00:30:00.250, Speaker B: Cool. Yeah, this is great though. If you guys have these questions like this, keep pinging them out. I think if we can have some sort of like a conversation like this, it's better than just saving all the questions at the end. Cool. Just. Okay, so we've gone over proverifier just at a high level.
00:30:00.250 - 00:30:53.448, Speaker B: We know that the verifier, in order for it to be a stark, so that's a scalable, transparent argument of knowledge, needs to run in exponentially less time than the prover that the prover took to prove it. I'm just going to send out one thing real quick. There's a good article here, and it's actually about Starkx, but it goes over some optimizations to the fry protocol and some ways to make the proofs a little more succinct. So I'm just going to send that out in both discord and chat. And then at the end it says proof length optimizations. And it kind of goes over that a little bit. To be certain, you need to go through polynomials degree plus one test with probability.
00:30:53.448 - 00:31:20.070, Speaker B: It allows to be log smaller on the degree size and the probability of being wrong is super low. Yeah, that's correct. Cool. Okay, so this statement, let's get into the statement. What is the statement we're proving? A statement from approver is proving a statement to a verifier. And the scalability which is the s in stark is defined here. It's that the verifier runs in exponentially less time.
00:31:20.070 - 00:31:46.748, Speaker B: And also that the prover does not take an inordinate amount of time to generate the proof as it's running through the execution. And I don't think I talk about the t transparent, is just that there's no trusted setup needed. Actually, I might. 1 second. Okay, the statement. The statement is a statement of computational integrity. So that's defined like this.
00:31:46.748 - 00:32:43.434, Speaker B: It's a starting state, the initial state of a system of a state machine. We define the program that changes the state, and we define the number of steps that that program took to get to a final state. S one. This is the statement of computational integrity that our prover is proving to a verifier. This opens up, because the program p that changes the state can be defined, as you guys will see today, in kind of a generalized manner. It opens us up to turing machines and we can start doing things like Cairo. Okay, here's a brief kind of visual look at what the compilation steps of an air and arithmetic intermediate representation look like.
00:32:43.434 - 00:33:17.410, Speaker B: So this is a zoom out of the stark prover, the sharp here on our big map, and the stark verifier here. So we have some computation, which we'll go over today. We run it through arithmetization, which is running it through a set of arithmetic constraint systems. We evaluate it with this interpolation. So we evaluate it as a polynomial, and we'll look at that today. So, polynomial iop. And then at the very end of all of this, we have a cryptographic compilation and a cryptographic proof system.
00:33:17.410 - 00:34:39.182, Speaker B: This gives us the non interactive version of the protocol. So instead of having the verifier query the prover and them doing a multi round bi directional communication, we get one commitment to this polynomial, and the verifier can say, yes or no, this is correct or not. Like I said, I am not a math whiz. So it helped for me to have this analogy that Ellie Ben Sassan, who is the math whiz, basically gave us. So he says, let's say you're a drill sergeant and you walk into the barracks and you want to the. Do the barracks have any dust anywhere? Is he going to go through and run his finger across every single surface to make sure that there is or is not dust on any part of the barracks? Maybe, but that is kind of analogous to a re execution to make sure that everything is up to snuff. So instead, what he can do is he can take a leaf blower and he can run it throughout the room, mix everything up, mix the air up, and then check in random spots in the room to see what the measurement of the dust moat count is.
00:34:39.182 - 00:35:03.240, Speaker B: I don't think Ellie said dust moat, but I will. The dust moat count is. And then he can know with some degree of certainty. And this is the probabilistic nature that we've been talking about with some degree of certainty. Yes, this room is dirty, or, yes, this room is clean. So it helped me to have this analogy kind of sitting in my head as we walked through all this.
00:35:07.850 - 00:35:08.600, Speaker A: Okay.
00:35:11.210 - 00:35:49.060, Speaker B: Just briefly, let's talk about starks versus snarks, because it's kind of a hot topic. Some of these have already been posted in the chat, but, yeah, there's no trusted setup needed. The algorithmic complexity of the prover. So, for snarks, it's on log n. For us, it's polylog n log, it's n polylog n. This slide is sent out to you guys. I won't kind of read every single column to you, but if you want some breakdown of what is a snark versus stark and how do they compare, it's here for you.
00:35:49.060 - 00:36:22.590, Speaker B: Some of the interesting things to me is just the proof size. The proof size is smaller in snarks, but the proving time is. I think it's on my next slide. It's slightly different, and it's also collision resistant hash for starks. So there's some version of post quantum security that starks give you that starks necessarily don't. And there's no trusted setup needed for starks. And that's the t in Starks, transparent.
00:36:22.590 - 00:37:11.950, Speaker B: Okay. Yeah, so proof sizes. Proof sizes is small for a snark, it's slightly larger for a stark, but the rest of the measurements kind of get a little more manageable. And it's the reason why we go with Stark. So proving time is far less. And so when you have these massive proofs that you need to generate for all the transactions that have gone on on your validity to roll up, we've taken this trade off of having a small proof time, and the verification times are basically negligible in the differences. Okay, we're going to dig into some of the math that sits behind starks and snarks.
00:37:11.950 - 00:37:55.498, Speaker B: And a lot of this math actually applies to a lot of stuff in cryptography, like ECDSA signatures. And again, just like we mentioned up at the very top, the goal here is to demystify some of these terms and give you guys an idea of what's going on under the hood. So, modular arithmetic, you can think of it like clock math. The amount of hours on a clock is only twelve, and yet we're able to define an entire day. We're able to define time with twelve discrete units. And the way we do that is with a modulus. The modulus here is twelve.
00:37:55.498 - 00:38:21.854, Speaker B: So two mod twelve. Let's say it's 02:00 a.m. There's no remainder, and so we can just represent it as two. Let's say that we have 14 hours from midnight. We have a mod twelve, which is 14 divided by two, and we basically wrap. So every time we hit our modulus, we wrap around. So the remainder after 14 is two, and we have a quotient of one and a remainder of two.
00:38:21.854 - 00:39:11.602, Speaker B: And same thing with 26 hours, we just keep wrapping and wrapping and wrapping. You'll see why this is important in a little bit. Yeah. Modular arithmetic is what is the stepping stone to finite field arithmetic. Finite field arithmetic is just a version of this clock math, this modular arithmetic over a finite field, which, again, I'm going to try not to use mathy terms. So even though we are working in a set, you can just think about it as basically the name a set of numbers from one number to a prime number. So one of the questions is, why do we need a prime number? We'll talk about that in just one sec.
00:39:11.602 - 00:39:41.262, Speaker B: So here are some definitions. A finite field contains a set of finite numbers of elements, and we can still do arithmetic operations, all the arithmetic operations that we know and love. So, addition, subtraction, multiplication, and division. Division gets a little hairy. We'll get into it, and we'll get into why it can't contain a subfield. This one is important. So if you look down at this example here below.
00:39:41.262 - 00:40:23.786, Speaker B: So, twelve is not a prime number, and the reason that it can't contain a subfield is that we can't make any strong assumptions if we're doing modular arithmetic on a set that doesn't contain a prime number of elements. So let's say that we have a clock field like we've defined it in the previous slide. Zero through eleven, that's twelve elements. And by twelve, that's the order. The Q order is the number of elements. So let's say that we wrap around twelve. Let's say that we wrap 14, we're back in our field.
00:40:23.786 - 00:41:05.478, Speaker B: But since that field can actually be a set of smaller fields, we can't make any strong assumptions about our arithmetic. We can't make any strong assumptions about what field we've landed. And have we landed in a field of three sets of four, or a field of four sets of three, or a field of one set of twelve? Now, that problem goes away. Once we have a prime, we know that if we wrap 13, we land in this field and only this field. And that's why you need to have a prime number at the end of a finite field. Arithmetic, a prime number needs to be your order for your finite field. A generator is an interesting concept.
00:41:05.478 - 00:41:54.370, Speaker B: It comes up quite a bit in starks and in a lot of cryptography. A generator is basically a number that's capable of generating the entire set or the entire field. And here it says by exponentiating the generator. So I'll show you what that actually means. At the bottom here, we say let g equals two, then g equals this. Let's bring out our handy dandy calculator. Okay, so the claim here is that two is a generator of the finite field of order 13.
00:41:54.370 - 00:42:27.294, Speaker B: And that all sounds mathy, but you should at least have an understanding of what that means. This is the finite field of order of 13. We know that there's no subgroups because it's a prime. Its order is prime. And let's prove that two is a generator. I've noticed a lot with a lot of this cryptography stuff, I'll make an assumption that these things are really hard. And then once I've kind of come to the other side of it, I realize, oh, a generator is literally just a generator.
00:42:27.294 - 00:43:17.582, Speaker B: It generates the set. So generator is capable of generating all the elements in the set by exponentiating the generator. So two to the second is four, two to the first is two to the second is four, two to the third is eight, two to the fourth is 16. But our set has an order of 13. So we'll mod 13 and we get three. You see, if we keep doing this over our finite field, because we're wrapping, we actually generate the original set of non zero numbers. And that's what we mean when we say a generator.
00:43:17.582 - 00:43:42.122, Speaker B: And that's what we mean when we say it has a cycle. You can basically cycle through the whole set. Cool. Let me just check to see any questions. So, yes. So that means not all elements are generators. That's correct.
00:43:42.122 - 00:44:07.042, Speaker B: Not all elements in the set are generators. So it's just the size of the set that has to be prime. The elements in the set can be any integers, or it has to be a sequence. Set size prime. It's an interesting question. It kind of gets into set theory. A set can be made up of anything.
00:44:07.042 - 00:44:16.020, Speaker B: But when we're doing finite field calculations, it does have to be something that can be generated. Okay.
00:44:17.830 - 00:44:28.490, Speaker C: Wait, just to be sure. This means that you're saying that the size of the set has to be a prime, but we can only use generators inside of the set, so not all the elements inside of the sets.
00:44:32.030 - 00:44:44.160, Speaker B: For finite field arithmetic, yes, it has to be of order of a prime, and not all members are a generator. What was the last part?
00:44:45.490 - 00:44:53.278, Speaker C: So the elements on the set can be any integers, or does it have to be a sequence, or does it have to be a set of generators?
00:44:53.374 - 00:45:12.440, Speaker B: I see. So you can have a finite field that doesn't have a generator, but it's not as useful in cryptography like starks specifically require a generator with a cycle. And I don't want to say something wrong.
00:45:12.970 - 00:45:20.650, Speaker C: Okay, that's fine. I'll just say clears the question and if somebody in the audience has the answer, don't hesitate.
00:45:20.990 - 00:46:18.220, Speaker B: Yeah, that's a good point. I'll just show I believe three is not a generator for an order of 13. Let's just see nine to the third. 13 is one. All right, we will only do one more, but I believe three is not a generator for mod. All right, so it looks like it, but again, you can go through all of these. I believe that starkware specifically went through mathematical algorithms to find the generators of our finite field.
00:46:18.220 - 00:46:54.110, Speaker B: And there's easy ways to do it. Just basically go through and make sure that you're generating a set and only a set, generating this field and only this field. Okay, another one of the useful things that we've mentioned is that finite field can have arithmetic defined in a certain way, how to find if an element in a generator, without actually going through this exercise.
00:46:56.050 - 00:46:59.070, Speaker C: You can ask somebody to run it and give you a zero knowledge.
00:47:01.350 - 00:47:44.590, Speaker B: That's right. There's a formula for it. There's a formula to tell you the number of generators in a field. It's kind of out of scope for this conversation, but there's a formula that tells you how many numbers depending on the order of the field there will need to be in that field. But yeah, if you go google finite fields and finite field generators, you'll find some information on. I think actually Vitalik has some pretty good posts. I'll track down the Vitalik post and post it in the discord after this conversation.
00:47:44.590 - 00:48:22.010, Speaker B: Okay, cool. So another benefit and reason we use finite fields in cryptography is that we can define arithmetic operations on them. We've already seen what that looks like with addition. It's just addition that wraps p. So mod p multiplication is fairly easy. It's just the regular multiplication you're used to. Mod P and then subtraction we start to get, with subtraction we start to get this idea of a negation or an inverse.
00:48:22.010 - 00:49:08.042, Speaker B: So here's examples on the right. So if subtraction 35 minus five mod 13 is the same thing as saying 35 plus five times negative one mod 13, which will become obvious why we need to do that in a little bit. So we're talking about the negation of the right hand instead of just negative five. And that's going to be. So in the finite field of order, 1335, minus five is four. Division is the tough one. So division you have the left hand times the multiplicative inverse of the right hand.
00:49:08.042 - 00:50:23.170, Speaker B: So it ends up being this format of something that satisfies this formula, which is a left hand times a that satisfies a times x plus b times p mod p, which sounds tough, but I have some code examples that we can look at, which we will look at right now. One question you might be asking yourself is, why are we doing this? Why do we use finite fields at all? So today we're going to be looking at the Fibonacci squared sequence, and it gets pretty obvious pretty quickly why this is the case. Once we get into this sequence and we're dealing with even the fifth number in the sequence, we're already starting to get this exponentially large integer value. So your machine has some bitwidth that can handle large values. But even if you're talking about, let's say, the 15th element of this set, you're dealing with a number that's too large to really handle with a modern architecture, or at least becomes very inefficient to handle with a modern architecture.
00:50:24.310 - 00:50:29.458, Speaker A: Sorry, someone raised their hand. Okay if I give them the microphone to talk?
00:50:29.544 - 00:50:30.580, Speaker B: Yeah, for sure.
00:50:36.130 - 00:50:38.574, Speaker A: All right, you can talk now. I don't know how to pronounce your.
00:50:38.612 - 00:50:40.320, Speaker B: Name, but.
00:50:46.180 - 00:50:47.772, Speaker A: You seems to be muted.
00:50:47.916 - 00:50:48.616, Speaker B: Now this.
00:50:48.678 - 00:50:50.680, Speaker A: Just raise the hand just by mistake.
00:50:53.260 - 00:50:54.040, Speaker B: Um.
00:50:55.980 - 00:51:00.330, Speaker A: Sorry. I think we can. We can continue.
00:51:01.200 - 00:52:00.140, Speaker B: Okay, cool. We will keep going. Yeah, so we were just saying that this is why we need to use finite fields, because this becomes pretty prohibitive to use pretty quickly. All right, let's look at some code. So if you're like me, I come from a software engineer background, not a math background. So it helps me to see these things in code rather than kind of look at a proof or look at the gobbledygook that is proof or formal writing about a proof. So you can do this along with me, I'm going to open up a terminal, and you all should have python on your machine.
00:52:00.140 - 00:52:18.470, Speaker B: These examples are in Python. And again, if you want to go through and rewire them in a programming language that you know and love, feel free to do that. I'm just going to blow away my version of base camp. Is this font size okay for everybody.
00:52:24.730 - 00:52:36.140, Speaker A: If you can? Maybe mine say yes. Bigger? Yeah, I think bigger. Especially the right side. I think the terminal is big enough. Maybe it's the browser. That is not.
00:52:36.830 - 00:52:37.900, Speaker B: How's that?
00:52:39.870 - 00:52:44.582, Speaker A: Much better? Yeah, for me it's good. I don't know people from the chat, but I'll keep monitoring.
00:52:44.726 - 00:53:01.614, Speaker B: Okay, cool. Okay, so let's clone base camp. And we're going to CD into camp. CD into base camp. CD into. We'll just look at the layout. Camp one, camp two, camp three, camp four, blah blah.
00:53:01.614 - 00:53:30.460, Speaker B: Primer. If you're searching for those definitions, the Zk terminology definitions, they're in the miscellaneous folder in a markdown file. Feel free to add to those definitions. So what is a zero knowledge proof system? Interactive proofs. Fiat shmer transforms. Yeah, feel free to add to that. Camp one.
00:53:30.460 - 00:53:55.914, Speaker B: All right, we're talking about finite fields. So let's look at. Let's start with modular arithmetic. This is a pretty simple one. This just does the clock math in python. So hours in a day, how many times we carry or wrap. And then what our modulus is.
00:53:55.914 - 00:53:57.340, Speaker B: Our modulus is twelve.
00:54:00.190 - 00:54:02.960, Speaker A: Can you create the font size? Yeah, that's perfect.
00:54:05.570 - 00:54:30.194, Speaker B: Okay. And then this will just kind of print to our terminal CD, camp one. And this will be the layout for a lot of the different concepts that we talk about. So when we talk about hashing a smart contract address on Starknet, it'll be the same thing. We'll just run Python. And the example that we're running. Python.
00:54:30.194 - 00:55:08.930, Speaker B: Three finite fields. Ah, Python. Python three modular arithmetic. All right, so time of day is nine. Once we hit twelve, we've had 20 hours, but we have this many days just because we are carrying. And each time this resets when we wrap, I think everyone probably gets that by now. So, finite fields.
00:55:08.930 - 00:56:00.770, Speaker B: This is our greatest common divisor. This is that function that we talked about for division. So what we're satisfying is we're satisfying a function that the multiplicative inverse can be found with this Euclidean algorithm, which is the greatest common divisor algorithm, which gives the coefficients that satisfy that output. If you want to read this in depth, it's right here. We have an example of it down here in division on 49. So our prime is 13, the left hand operator is four, the right hand operator is twelve. And all we do here is left hand plus right hand mod prime.
00:56:00.770 - 00:56:31.978, Speaker B: Same as the slides, but it always is good to see it in code, how it's actually codified in Python. Left hand plus right hand times negative one, which is the multiplicative inverse. Yes, the multiplicative inverse. Mod prime. Multiplication is just regular multiplication. Mod prime. And then here we have our division.
00:56:31.978 - 00:57:29.982, Speaker B: So we get the greatest common divisor of. And we're dividing two by three, and then we get that, and we do dividend two times the divisor mod prime. So we can print that all out. Okay. Addition four plus twelve is 335, minus five is 490 times ten is three. Two divided by three found the greatest common divisor three. So we have this function that's in the slide negative four times three plus one times three satisfies that division equation and gives us five.
00:57:29.982 - 00:57:44.340, Speaker B: Feel free to comment in that python script anywhere you want. Comment in this greatest common divisor, and you can kind of get a feel of exactly what's going on with this function.
00:57:45.190 - 00:58:02.700, Speaker A: I do have a question, because I think division is one of the most complicated things in this arithmetics. How is a regular division like x divided by y connected to the function that you have there ax plus by equals one? What's the connection between a regular division formula do you have there.
00:58:06.030 - 00:59:28.810, Speaker B: In general? I wouldn't phrase it like that, because what we're doing is we're defining these arithmetic operations on a finite field. It's almost hard to define it as if you're taking it back into the paradigm of what you're used to. I can give you kind of a. Let me see if we can do just like an example by hand. So, okay, so let's say we're gonna have, let's say we're gonna have this number two, one divided by 107, and the order of our finite field is 13, we need to have some function such that a times y plus b plus 13, which is the order of our field. So in the slides, I think that was denoted as p. Yeah, p here.
00:59:28.810 - 01:00:25.690, Speaker B: And we'll start kind of filling in some of these values so we know that we want to solve such that this equals one, because that is the definition of this multiplicative inverse on the bottom right font size might not be big enough. One might be. David, this might be the link back to kind of the real world. We do have these multiplicative inverses just in regular math. So like, five times one over five is one. So what we're doing is we're trying to get this algebraic function such that we're equaling one on the right side. And that's what this gives us, a times x plus b times y equals one mod p.
01:00:25.690 - 01:01:19.290, Speaker B: So we'll go through it step by step. All right, so we have a times y plus b plus 13, which is our order minus one. Y here is going to be our divisor. So we'll substitute y for 107. So now we have a times 107 plus b times 13 equals one, and that's where we find our greatest common divisor. So in this situation, our greatest common divisor is negative four GCD. Here, let's look at this.
01:01:19.290 - 01:02:06.200, Speaker B: Okay, so while R does not equal zero and r starts as our y. We kind of brute force this. I think Danilo Kim just said this, and he's totally right. So we basically brute force this. We say divide this until we get these values, until we get these values such that a times x plus b times y equals one. And we know that this is 13 and this is whatever our divisor, our dividend is. And so we just keep running this, running this over and over and over and over again until we find the correct answer.
01:02:06.200 - 01:02:54.850, Speaker B: So for us, in this example, it was three. So we plug that into our equation here. Minus four times three plus one times 13 equals one, and we've satisfied that equation, which gives us two divided by three, mod 13 is five. I feel like there's some good examples here in the comments, too. Yeah, Danilo mentions it here, so you can keep trying. Three times one mod five, three times two mod five, three times three mod five. Three times four mod five.
01:02:54.850 - 01:03:17.914, Speaker B: In this case, three times four mod five equals twelve mod five. So x equals four. So once we've solved for x, we get the multiplicative inverse and we can solve that equation. I feel like I might be muddying the waters here, so let me give you a more clear answer in discord once we're done. Okay?
01:03:17.952 - 01:03:18.780, Speaker A: Thank you.
01:03:21.490 - 01:09:03.700, Speaker B: Okay, one more thing we're going to look at before we keep going is what a polynomial looks like in code. No, actually, we're going to keep rocking with the slides. We've been going for an hour, so I'm going to give everyone kind of a five minute break for everyone to stretch their legs a little bit. And when we come back, we're going to start talking about how we are going to prove this statement on top of the primitives of finite field arithmetic and modular arithmetic. So everyone take a five minute breather and we'll come back at 36. Welcome back. Welcome back.
01:09:03.700 - 01:10:05.894, Speaker B: Yeah, so I just saw Carlos said, fellow T muxers, T muxers unite. Also, I'm in Colorado, Carlos, so ping me after this and maybe we can go grab a beer or something. Cool. Anyone else in Colorado, do the same? Okay, I do want to clear up this division thing at some point, David, I don't want to leave you an alert, so I'll definitely ping the discord after with a more clear example of this multiplicative inverse. But for now, we're going to move on. Okay, so how are we going to use these kind of really primitive finite field domains to prove a statement of computational integrity? The example that we're going to use and we should know what a statement of computational integrity is. Now, it is some initial state.
01:10:05.894 - 01:10:50.386, Speaker B: It's the definition of a program that alters that state the number of steps it took to get to its final state and that final state. So, the way that we're going to represent that is the Fibonacci squared sequence. So the Fibonacci squared sequence is going to be an plus two is equal to the square of n plus one plus the square of an. So we start with one and three. One squared plus three squared equals ten. Three squared plus ten squared equals 109, so on and so forth. This is the example of why we need to use finite fields.
01:10:50.386 - 01:11:32.020, Speaker B: Because once we get into the 15th element here, we are dealing with some crazy integer depths. So, the prime that we're going to use here is this prime. This prime. I should give a little more context into this because I think we might run out of time. And you guys'assignment for the off days is to complete this assignment. So I'll show you where this example comes from. If you head into base camp one, you'll see that there's the presentation for today.
01:11:32.020 - 01:11:56.250, Speaker B: We'll have the video. So this video will be the video of the recording today. We'll post that once it's rendered and up. And then the workshop that you need to do in your off time. So, this workshop needs to be done before next Thursday, same time. And we're going to start that next session with questions. So we'll just go over questions.
01:11:56.250 - 01:12:26.326, Speaker B: We'll go over anything unresolved from this day. So we'll probably go over a more in depth division example. And then, yeah, we'll go over any questions from Stark 101. And since we have a whole week from now to then, feel free also to ping the discord with any questions as well. And then Henry, myself, Lucas, David, Omar will help you out, or your fellow classmates will help you out. It seems like we got quite a few experienced people in this cohort. So, this example comes from Stark 101.
01:12:26.326 - 01:13:19.800, Speaker B: And I think we'll probably end up getting about halfway through. We'll probably get through statements of low degree extension and commitments, polynomial constraints, which will leave you guys with fry commitments and fry queries. So, yeah, it's a pretty good workshop series here with YouTube videos, Jupyter notebooks, and GitHub repos. Cool. But hopefully we can get through at least some of it. Okay, so this prime, kind of the same thing. As we mentioned before, this prime was found with some algorithm that defines a prime with a multiplicative subgroup that has a cycle, which we now understand what that is.
01:13:19.800 - 01:14:14.010, Speaker B: And the statement we're going to be proving is that the 1023rd element of this sequence, of the Fibonacci squared sequence, is this number. If you go out and write it by hand, you'll see that it's that number. But as we've said, the problem that we're trying to solve is this asymmetry of the verifier running succinctly compared to the prover, and the prover proving this statement in quasilinear time. So quasilinear time, meaning that it doesn't take an exorbitant amount of time to generate this proof. And then I can just show the prover, hey, this sequence is valid. And it ends in this statement. And it starts in this statement.
01:14:14.010 - 01:15:14.690, Speaker B: Yeah, which is pretty cool. It should kind of get your head spinning into what the other use cases of things like starks are. If you have some large machine sitting somewhere that can run these heavy computations, that can generate this heavy sequence of Fibonacci squares, or any computation, and then generate a proof that can be verified succinctly anywhere else, my head starts spinning. I start thinking about kind of like SSL certifications or, I don't know, I think that there are wide reaching implications of this technology. But we'll be talking about it in context of blockchains, which also makes sense. We have the verifier written in solidity on Ethereum layer one in a resource constrained environment. So to come back to it, get my head out of the clouds, low degree extension.
01:15:14.690 - 01:16:12.370, Speaker B: Let me go briefly back to our whole stack. Okay, so we have computation. The computation here is just going to be the actual Fibonacci squared sequence. So some naive computation that we've predefined, and then we're going to take that into this domain of arithmetic constraints. The arithmetic constraints are in this world of polynomials, and polynomials have this property that they are just numbers. So when we use polynomials in conjunction with finite fields, we get the ability to use the arithmetic that we've defined over the finite field just on the polynomials. And polynomials have a couple of other properties, which we'll talk about that you can basically interpolate the polynomial.
01:16:12.370 - 01:17:18.620, Speaker B: But this finite field arithmetic in conjunction with the polynomials is really what enables some of this cryptography. So how do we get to the domain of the polynomial? It is this concept of low degree extension. And low degree extension is if you guys are coming from a network background, a networking background, you might have seen concepts like this in error, correcting code and crcs and how packets cross a wire. Basically, there's some information that's sent across the wire. And in order to make sure that it came through unobstructed and uncorrupted, we also send this error correcting code or packet that basically says, here's a checksum, and everything in the packet on the other side of the wire checks out, even though I'm not checking the entire packet. So that's the general looking for the dust in the room. I don't have to check the entire packet to know that the checksum is correct.
01:17:18.620 - 01:18:10.122, Speaker B: Okay, so how do we get there? We generate an input. This is called the trace. Basically, if we wrote out by hand every single value in the Fibonacci squared secrets, we plot it in this two dimensional table here, and then you can visualize it as being plotted on a graph. And then we interpolate a polynomial between those points that we've plotted, and we extend. So extend. You can think of it like increasing the resolution. We basically take more plot like, we expand this to more plots on this polynomial interpolation so that we get some more degree of confidence of what's going on on this line.
01:18:10.122 - 01:19:01.498, Speaker B: And then if anything deviates from that, we can say with a high degree of confidence that, no, that does not look like it lies on this polynomial. And we can say that something is wrong in this trace, in this trace of elements. Okay, so a little more explicitly, the input for us will be a zero, a one, a two, all the way up to the, since we started, zero, indexed all the way up to the 1022, which is the 1023rd element. This is how we denote the polynomial that runs through as we interpolate this. And then when we extend, it's called a blow up factor. When we increase the resolution on this polynomial, it's called the blow up factor. So in our example, we're going to use five.
01:19:01.498 - 01:19:28.702, Speaker B: In the actual protocol, I believe it's eight. And this is known as the input domain. Yeah. The trace is viewed as evaluations of the polynomial f on top of the domain. So we'll look at what that looks like. Okay. And then the prover is going to commit, the prover is going to commit to that low degree extension.
01:19:28.702 - 01:20:24.830, Speaker B: And the way it's going to do that is each one of these leaves is a code word, which if you want to look a little more deeply into that, look for Reed Solomon encoding, it's going to be slightly out of the scope for today's talk, but basically a point on this interpolated polynomial is going to be these leaves, and we're going to commit to it just the same way we would with a Merkel root. If you haven't done a Merkel route before, I would recommend going back and looking at the primer. Merkel roots are used in almost every blockchain. The Merkel Patricia tries. What? There's a couple different Merkel Patricia tries that are used in the state of Ethereum. And then the Merkel route hashes all the transactions. Hashes all the transaction of the transaction tree.
01:20:24.830 - 01:20:52.042, Speaker B: Carlos, is there a place where all the material is shared? At the moment, everything is going to be in this base camp repo. Yep. Okay, David. Got it. And then anything subsequent is going to be in the discord. So once this video is rendered from today, I'll add it to this section of the base camp, and then I'll ping the discord. Okay? Yes.
01:20:52.042 - 01:22:21.622, Speaker B: So once the prover generates this commitment, it's going to send it to the verifier. Okay, so that's low degree extension, and now we have polynomial constraints. Let's look back at our flow here. Polynomial constraints and interpolation. Okay, so we've already dealt with some arithmetic, but really what these polynomial constraints are is framing this statement of computational integrity in a different way that lets us use polynomials for basically this interpolation. So what we get for polynomials is that we get this low degree extension, and we can get, with this incredibly good probabilistic nature, that if this proof is sent and queried at certain spots in the polynomial, and that matches the interpolation that we've created, we know with a very high degree of certainty that this proof is correct. But if we just did that on top of our domain of the trace, without running it through these constraints, you wouldn't have what we call an arithmetic intermediate representation.
01:22:21.622 - 01:22:56.770, Speaker B: So passing it through these polynomial constraints gives us an arithmetic intermediate representation, and we're going to be talking about an error quite a bit through this course. Okay, so the constraints we have to prove, we have to prove s zero, which for our computation is going to be one. The first element of the sequence is one. The 1022nd element of the sequence is this. And then if we can also prove. So that's s one. No.
01:22:56.770 - 01:23:41.410, Speaker B: So the question Alex summer asks is, do we need to also specify that a one is three? No. And that's a good question. The only reason we don't is the third constraint here, which is that if every single n plus two does follow this program, you can think of it like a program. It's a computation. It does follow n plus one squared plus an squared. So if we have the initial, the end, and this program is followed throughout the trace, we know that we've satisfied the constraints and the original statement is true. We can prove that this Fibonacci squared sequence has been followed for this amount of steps.
01:23:41.410 - 01:24:22.770, Speaker B: And we'll keep saying this. We'll say that we're proving that the constraints are true. So how do we get to a polynomial representation of this information? Well, we run it through a couple sets of reductions, which are arithmetic reductions. So the first constraint is to represent the trace in a polynomial, so f of x instead of just a straight a of zero. So g. Here is the generator. Our generator is five for the example, which we'll go into, and then g, zero, you can also think of in this tabular format.
01:24:22.770 - 01:24:45.320, Speaker B: So, we've plotted our points here. This is the a representation. This is just a flat representation. And then here's our polynomial representation. So, g, which is the generator. Zero, applies to a zero, which we've plotted here. Now, when we take a step through this finite field, g is the generator of the finite field.
01:24:45.320 - 01:25:53.102, Speaker B: We're doing it via the exponential, the exponentiation of g, which we looked at earlier. So, two to the second generates the element, two to the third generates the other element. If we know that g is a generator of the finite field, we can cross through these domains of the polynomial by exponentiating it one at a time all the way up to 1022. Cool. So now we're just looking at this in this format. Okay, so g to the power of zero, or the first element of the generator in the field equals one. The 1022nd element of the generator equals this, and the g squared, which is us moving two columns two rows down.
01:25:53.102 - 01:26:56.210, Speaker B: G squared, same thing as x squared equals f of gx squared plus f of x squared. So we're taking this and rephrasing it in the terms of polynomials. The question here is. So, we're proving there exists some a one a at a to the end of the sequence for which it works. Not necessarily. A does not equal three. I might be misreading the syntax of that, but yes, basically, if we say that we know the beginning of the sequence, and we say that we know the end of the sequence, which also means we know the amount of steps that the sequence took, 1023 steps, and we say that this sequence holds throughout each step, we can say that we've proved this.
01:26:56.210 - 01:27:44.310, Speaker B: So we don't need to go in and prove anything else except for these three statements. I hope that makes sense, because we know that the mutation of the state for each round was held. And we can express this in a polynomial, which looks like this. This is the first reduction. Okay, so another really cool concept around polynomials is roots of polynomials. So, if a polynomial equals zero on the right side, we call it a root polynomial. And it's pretty easy to do the arithmetic here.
01:27:44.310 - 01:28:24.372, Speaker B: We just take one, and we subtract it from both sides, and we get the second reduction, which is f of g. Zero minus one equals zero, which is the root polynomial. For this statement, we do the same thing here. We just subtract the right side, the right side from the right, and the right side from the left, and we do the same thing with the last. So, we're rephrasing the Fibonacci squared sequence into this version of a polynomial constraint. And the last is probably the hardest to understand. The workshop does a pretty good job of getting you there.
01:28:24.372 - 01:29:07.152, Speaker B: But basically, in order to get to our end goal, we need to come up with these rational functions, and this lets us do some combinatorial math. And I don't want that to scare anybody. It just means that we can take these functions and multiply them by each other, and we'll go through why that's important. So we take these constraints and we represent them as rational functions. Okay, so let's go through the first constraint, and, um, we need to prove that a zero equals one. A 1022 equals that. We've already gone through that.
01:29:07.152 - 01:30:05.610, Speaker B: Can you reduce these strengths to another statement that implies their validity? If that satisfies the constraint, the original statement is true. Okay, we go back to our root polynomials here. I think we've really said all of this already. I'll just point you to this last one. So, we've taken the right side and subtracted it from the right and the left. And what we're saying here is that for every g greater than zero and less than the end state that we know they're all roots of this equation, which is the Fibonacci squared sequence represented as a polynomial. The reason it's important to have root polynomials is that we can start zeroing things out.
01:30:05.610 - 01:30:31.910, Speaker B: And if we can zero things out, our equations get a little simpler. So, here's a theorem. So z z is a root of px. If x minus z divides px, x minus z divides px. If px divided by x minus z is a polynomial. So the same thing. Like I said earlier, we get to use polynomials as if they're just numbers.
01:30:31.910 - 01:31:04.910, Speaker B: And when you divide numbers, sometimes you'll get an integer, and sometimes you won't. So, four divided by two gives us an integer. Three divided by two does not give us an integer. We can take that same concept, and we can adhere them to polynomials. So, if we can reduce a polynomial to a polynomial, which is x minus one, we know it's a root. So two is a root of this polynomial. Now, there's no canceling out on each side that we can do here.
01:31:04.910 - 01:31:46.990, Speaker B: X minus one times x minus six divided by x minus two. So two is not a root, which means that it's not a polynomial. You can't have this concept as a polynomial. So this is our final constraint. This is the hardest one to kind of get through your head. The other ones are fairly easy, where it's just some simple arithmetic, and then this kind of gets to rational functions, which is a little bit more mathy. If you do want to take the deep dive, it is this part two polynomial constraints on stark 101.
01:31:46.990 - 01:32:24.524, Speaker B: But we'll talk about it briefly. All right, so, we have this theorem and these definitions. So what do we do, and how do we format it as a constraint? So, this is our first element, our first element in the trace, and we take x. Let me look back. Okay. We take f of x minus one divided by x of the first element in the trace. And.
01:32:24.524 - 01:33:28.576, Speaker B: Yeah, like I said, this last one is the hardest. We'll look at it in code in just a sec. But once we get here, there's a polynomial of f such that there are three functions that will create from this f p zero, p one, and p two that are also polynomials, which means that we can interpolate them, and it also means that the verifier can interpolate them. Okay, we're going to look at some code, and it should clear things up a little bit at a high level before we jump into the code base. We'll just reframe this one more time. So, computation is an execution trace, a sequence of the machine state. So, just the next round of Fibonacci squared run through the arithmetic constraint systems, which gives us an algebraic intermediate representation of the polynomial constraint on the trace.
01:33:28.576 - 01:34:22.340, Speaker B: And then at the very end, this is where we get the non interactive proof, because we run it through a fiat shmir transform on the right side here. This shows you what all of this math gobbledygook looks like in kind of a visual representation. So the top left is saying that this polynomial and all of these spots that we don't agree on, that are not on. The polynomial that we've come up with are pretty close. We've basically formed a polynomial that the prover has committed to. Now here we're getting slightly less, it's getting slightly less clear that we're dealing with the right polynomial. All of these spots that are interpolated don't match the polynomial.
01:34:22.340 - 01:35:12.688, Speaker B: And as you can see, we kind of go further and further until we can say up top left with a high degree of certainty. This is a visual representation that we do in fact have a polynomial that matches the one that's committed to by the prover. And then down here at the bottom right, we basically have no coherence. We can say with a high degree of certainty that this does not match a polynomial of low degree. Okay, let's look at some code, because I think it's a little hard to get these equations through your head just by looking at them. Okay, so, finite fields, stark 101 utils and starks. We'll actually start with polynomials.
01:35:12.688 - 01:36:24.268, Speaker B: So how do we represent a polynomial in code? We've looked at polynomials, but how does that look like if we're actually going to try to represent something in code? You can represent it as a bit pattern, as just a layout. It's one of the cool properties of polynomials is that I can basically just say x to the second has this second bit raised to some power, or that each bit in the sequence represents some coefficient. That's not the way we do it. It's not the way that the protocol is defined in Python, but it is an interesting property of polynomials. Okay, here's how we'll do it. We have this definition 19 times x to the fifth, minus three times x to the second, plus nine. So we have the polynomial that, if you just wrote it out by hand, it looks like that, and you can trace through what x is.
01:36:24.268 - 01:37:16.590, Speaker B: We kind of just have x as this object that exists and is defined to sit within this function. All of this arithmetic that we've talked about, addition, subtraction, multiplication and division, can now be run on top of these polynomials. And another question you might be having is where does the finite field come into play? So we have this concept of a field element here. That field element has a lot of these helper functions attached to it. So we've defined a field element as a class, and that class has a modulus. So now we can have everything in the set up to this prime number, which we've defined in the slides. The generator value is five.
01:37:16.590 - 01:37:56.580, Speaker B: We've just given it to you. But it's five. You could brute force it if you wanted. And then we have the definitions of our arithmetic operations. So add, we're just going to add a finite field and typecast it. And then you can see here we have modulus, k modulus, subtraction, modulus, k modulus, multiplication, multiplication by the modulus. And then check out the division.
01:37:56.580 - 01:38:37.100, Speaker B: Should be in here somewhere. Our second. Okay, here you go. So we're dividing by the inverse of this operator, which we looked at in the slides. So inverse is going to be that greatest common denominator algorithm that we looked at earlier. And again, everything is modulus, the prime. That's where your field elements start to come to play.
01:38:37.100 - 01:39:56.710, Speaker B: Okay, so let's look at how this is it. Out it. Oh no, I've messed up my path. Let's see. Need to be one higher it. Okay, I am going to run this side by side, unfortunately, I hope that the font size isn't too miserable for you guys. Just so we can see how this polynomial is represented from these prints.
01:39:56.710 - 01:40:33.620, Speaker B: It's really up to you to define it. This is how it's defined in the examples. But you have this high level math term that's being defined, and you have a certain amount of language syntax to use. So we use an array. The array now is populated by the term. So let's look at, here's the bit pattern, if you're curious about that empty poly. So poly of no degree plus one is just an array with nothing in it.
01:40:33.620 - 01:41:26.510, Speaker B: Now we have a field element of nine in the zero th index of this polynomial. So right now that would just be a polynomial of a number nine. Now, as we start populating these, we take the index of the array, and that is the degree of that term. So raw poly, two field element, negative three. We see negative three is populated at the third index. Sorry, the second index, it's the second, so you can take it from the zero th index. So it's two and 19 012345.
01:41:26.510 - 01:42:28.124, Speaker B: So we've reconstructed this polynomial that looks like this. Okay? And then since it's a class, we have this dot polyhelper function, but we're looking at a raw array of field elements, and there is an equality here. So raw poly equals p one poly, and we can start appending these helper functions on top of these Polynomial definitions. Does anyone have any questions on how the polynomial is laid out in this array? Since this term is subtracted by this term, it becomes a negative term. Pretty straightforward. Cool. Here we go.
01:42:28.124 - 01:42:48.496, Speaker B: How's the degree of the polynomial described in the array. Okay, so it's the index. So let's write this out by hand again. All right, so nine is the first term. It's the polynomial of lowest degree. So we just have nine. It's a positive, not a negative.
01:42:48.496 - 01:43:19.630, Speaker B: So if we didn't have anything else in this array, this polynomial would just be nine, and we're populating the free term there. Okay, so now let's look at it again and kind of reverse engineer it. So nothing in the first index. Let's say that we did have something in the first index that would look like this. Let's say that we had a two in the first index. So that would look like two x plus nine. And then this would be.
01:43:19.630 - 01:44:04.004, Speaker B: So we're taking the index of the array. So zero, one, two, this becomes negative, three x squared, taking the index and raising it to the degree. We have nothing in this index or in this index, but we do have here. So. 012345. Now we have 19 x to the fifth. And that's how we reconstruct this polynomial as an array of integers.
01:44:04.004 - 01:44:43.560, Speaker B: Does that make sense, Amaran? Okay, cool. Now we get all these cool features we can play with. We can add polynomials, we can subtract polynomials, divide. So here's another polynomial. Seven x to the second plus 15 p one plus p two. Okay, so the same way we group terms, this is going to get a little into polynomial math, but you group terms of the same degree. If you want a refresher, there's a bunch of good stuff on the Internet.
01:44:43.560 - 01:45:28.164, Speaker B: It'll all probably come back to you pretty quickly. But basically, you group these terms, and you can see that the addition add poly here gives us a polynomial add. You can reconstruct that if you want. 24 plus four x to the second plus 19 x to the fifth subtraction. Same thing. Pretty descriptive. You can look at all these.
01:45:28.164 - 01:46:07.250, Speaker B: The interesting thing gets into when we're starting to wrap. So you'll start to see that some of these values start to wrap our field prime. And that's where you start to see the finite field calculations come back around and start to make sense in the context of what we're doing. And that's defined with the field element. So you'll start to see some of these exponents and terms wrap. Is there anything else interesting I want to say here? No, we do division down here, if you're curious. All right.
01:46:07.250 - 01:46:58.170, Speaker B: That's how you represent a polynomial in python. Okay, we're going to get into low degree extension. Okay, we talked about all those math terms, all those math functions. At least for me it makes a lot more sense when we're looking at the code. And I'll take. Okay, sorry if this is getting tedious for people. The math is dense.
01:46:58.170 - 01:47:57.262, Speaker B: The rest of the days aren't quite as dense. We get into Cairo. The reason that this part of the course is really important is because Cairo builds on top of these concepts of arithmetic intermediate representations. So this part of the protocol and this part of the stack is something you can blackbox. If you don't want to get into the weeds of polynomials and multiplicative inverses, you can blackbox this portion of it. But if you really want to start seeing how the internals of Cairo work, including when we say that we're going to deal with a felt, I'm sure some of you guys have already gotten into Cairo a bit. You've probably dealt with felts well, all of a sudden, if you start from this level of the protocol stack and work up, even though it's really hard and it's really cumbersome, a felt starts to make a lot more sense.
01:47:57.262 - 01:48:48.398, Speaker B: A felt is a field element. If you don't dig down this deep, you're probably looking at a felt and saying what the hell does that even mean? It's some native scalar type of Cairo y. And now you know that. Well, the reason that we have that is because the entire stack is based on finite field modular arithmetic. And so we need some defined finite field with an order with a multiplicative subgroup, that's the generator. And a field element is just one of the elements in that finite field. Everything starts to kind of click and all these kind of disparate components and disparate ideas start to make sense.
01:48:48.398 - 01:49:42.580, Speaker B: At least I hope so. That's the goal. And if it's not clear, if you guys have some feedback, again, feel free to do the form or. What I would love is if you guys could contribute to the code base. We are running a bit low on time and I do want to kind of open the end of this up to questions, not only around what we talked about today, but around the format. So what I'm going to do is I'm just going to continue with low degree extension. I'm going to point you to the parts of stark 101 that we've covered and the parts of stark 101 that might be good to go into in the off days, and then we'll kind of just open it up as far as format and everything.
01:49:42.580 - 01:50:30.030, Speaker B: Okay, so generate the input of the Fibonacci trace. So we start with an array again, we have the field elements which are populating our array on line 15 here. And for while the length of a is less than 1023, we're going to append the Fibonacci sequence, the Fibonacci squared sequence here. That should look pretty familiar, especially if you look at the very beginning of these slides. It is this encode. Okay, field element, generator. The field element of this is five is the generator.
01:50:30.030 - 01:51:27.886, Speaker B: So five raised to our prime, gives us a domain to work on top of. So for each element of g, we generate the finite field with the generator. So this looks like this. G zero g one g two. We now have a generator that's generated our field. So we can operate on interpolate the polynomial. So g everything but the last element, and a, which is our trace or trace of the Fibonacci squared sequence.
01:51:27.886 - 01:52:19.284, Speaker B: We're going to interpolate that. What does that mean? See what it means? You can kind of dig down the stack here. It gets fairly mathy to the Grange interpolation. And an easy way to think about it is that we're just doing this interpolation. Okay. We get random values of g just to print it out, just to show you. Um, and now we extend the evaluation domain.
01:52:19.284 - 01:53:15.290, Speaker B: So this is the blow up factor that we talked about. We're increasing the resolution. This is the error correcting code that we mentioned. If we increase the domain size and we blow up the domain size to be five x, as we do here, we get a stronger degree of certainty that this polynomial will match on any given point. So that is what it looks like here. Okay, we blow it up by the field generator size. Alex Summer says, looking around line 17 in this code, if we only define a minus one and the last value as a the 1022nd element, how do we get started generating the sequence? That's a good question.
01:53:15.290 - 01:53:51.750, Speaker B: And 17 is the answer. This is a while loop. So it basically just says for 1022 times, this might be the answer to your question. So that we populate the first element and the second element, and then we say a minus two times a minus two plus a minus one times a minus one. So the second iteration of this loop will have another element in a.
01:53:54.780 - 01:53:55.096, Speaker C: That.
01:53:55.118 - 01:54:39.090, Speaker B: Is our fibonacci squared sequence. So, 1310. But what it will really look like is a field element, which is this wrap. Each element depends on two preceding elements, but for a two have only one preceding element. This array starts with two elements. If I'm understanding what you're saying correctly. Let's print it out.
01:54:39.090 - 01:55:58.680, Speaker B: Sorry, guys, I'm losing it. Talking for so long is messing with me. All right, where am I? Okay, camp two. Oh, man, I'm really losing it. Sorry if I. Sorry if I've kind of confused anyone. And feel free to ask me questions through the week, and I'll give a more concerted answer to some of these.
01:55:58.680 - 01:56:33.460, Speaker B: Just when you need something to work, it doesn't. Starky tills Python 101. All right, I'm looking in the wrong directory here.
01:56:40.760 - 01:56:41.172, Speaker C: Okay.
01:56:41.226 - 01:59:00.180, Speaker B: It takes some time to generate this field. So the question is a two is the big number starting with 31. Let's print this it. So we start walking through our representation of a representation in g, which is the polynomial, and our representation in f, which is the third constraint. So your question really is, what is a minus two? On the first iteration, a minus two is one. Is that your question, Alex? So, like, one times one will get plus the next element, times the next element will give us the result of the Fibonacci squared sequence for a three. Okay, sorry if I kind of lost my train there at the end.
01:59:00.180 - 01:59:45.300, Speaker B: All right. Oliver says, I guess the second element in a is just to initialize the list with two elements, because our program depends on n minus one and n minus two elements. And I guess it is chosen at random by the author, since it looks like PI 3.141,592,754, the value has no meaning per se is my understanding. I would tend to agree. I'll need to go back and do Stark 101 again. Okay, just briefly, I'm going to open it up to questions about the format of base camp.
01:59:45.300 - 02:00:21.294, Speaker B: And let me reiterate where we're going. So make sure that you have cloned this repository. If there's any changes made to the base camp repo, I'll ping it out in the Discord channel, and I'll make sure to tell you guys to clone basic setup. You should already have that. Stark resources so the stark paper is here. The slides have been sent out in the chat. So the stark paper is here.
02:00:21.294 - 02:00:49.686, Speaker B: It's fairly dense, but it's a really interesting read. Stark 101. This will be your assignment in the off time between now and next Thursday. Vitalik has some really good blog posts about starks, and then there's another guy here who has a really good write up. There's a lot of formal math language in this anatomy of a Stark, but it is very interesting. The assignment in the downtime will be to finish Stark 101. I'll show you where we left off.
02:00:49.686 - 02:01:17.226, Speaker B: And again, the link is here. On workshops on the start of camp one, we did statement of low degree extension and commitments. And we left off in polynomial constraints. If you're confused about any of those or how to get to those final functions, make sure to do polynomial constraints. And we didn't touch on Fry today. So fry and the final proof, Fry is a big piece of the protocol. So that's your assignment.
02:01:17.226 - 02:01:30.230, Speaker B: And the off time, we'll start the next session with a conversation about any questions that people have. We'll try to have an open discussion of that. And then right now, I just want to open it up to questions about the format of basecamp.
02:01:42.430 - 02:01:50.400, Speaker A: You can comment now, or you can wait for the feedback form. Also, give your feedback there anonymously. So whatever you feel more comfortable with.
02:01:51.810 - 02:02:13.110, Speaker B: Okay? Yeah, that's a good point. Thanks for joining, everybody. Everything from here on out gets a little less dense. So the math behind starks is definitely difficult. And everything kind of gets a little more straightforward from here. So looking forward to see you guys Thursday. Next Thursday, same time.
02:02:13.110 - 02:02:23.410, Speaker B: Time, same place. And we'll send you an email about how to join, where to join. Cool. Thank you, guys. Bye.
