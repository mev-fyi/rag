00:00:03.050 - 00:00:50.990, Speaker A: Hey, everyone. Thanks all of you so much for coming. I'm really grateful to be able to present today a little bit of context. A few weeks ago, I reverse engineered the Ethereum's stark verifier and built approver, and I generated proof and submit edit it to their Ethereum contracts. And today I'm really excited to be able to talk to you about that process and some of the challenges that I faced with that. So today I'd like to talk about that. I'd like to then talk about the role of Sandstorm, the name of the prover afterwards, and then at the end, just very briefly, kind of talk about the future that I see for Sandstorm.
00:00:50.990 - 00:01:38.202, Speaker A: Okay, so let's start with the reverse engineering. So before we get into the reverse engineering, I just want to give a little bit of context on the verifier and this slide. What we have here is this is a diagram from l two beat, but it's basically like the contract architecture of Starknet on Ethereum. And there's two main parts to this. There's the sequencer, which manages the state, so it'll take the state from a to b. And there's also the prover and verifier, the stark verifier, which will basically verify a stark proof to make sure that it was a correct state transition. And what I focused on wasn't the state side of the things.
00:01:38.202 - 00:02:18.490, Speaker A: I just focused on the verify and basically generating a stark proof that would pass. But I didn't want to overcomplicate it and I decided like, I will leave the state out of it. So, yeah, that's what's on this slide. I'm just coloring in blue, kind of like what I was focused on reverse engineering. Now I just want to give a bit of insight into that part, into the verifier part. So the verifier actually verifies a hard coded program, and this is the bootloader program, and it's always the bootloader program. And this bootloader program is responsible for booting other programs.
00:02:18.490 - 00:02:57.090, Speaker A: So like Starknet's a program, immutable is a program, and it'll boot those generate proofs of it, and then they all get recursively verified within bootloader. And then you just have one proof that you need to verify on Ethereum, which makes it a lot cheaper. But like I said before, I didn't want to deal with any state. And if I wanted to do this approach, I would have had to figured out how to do take the previous state of Starknet and get the next state of Starknet. And I didn't want to do that. So what I ended up proving looked something like this. It's basically like the bootloader, but it doesn't run any programs.
00:02:57.090 - 00:03:42.530, Speaker A: So it's kind of the equivalent of turning your computer on, getting to this screen here and then turning it back off. So it seems a little funny, but it proves that being able to prove this is like a proof. And to be honest, to get to the stage where you're actually proving sub programs with the bootloader, it's more or less the same thing. So this was what my goal was and this is what I was working on. Okay, so that's kind of the context we need for the verifier. And now I'd actually kind of like to get into the challenges that I faced with reverse engineering. And the first challenge was trying to figure out the constraints.
00:03:42.530 - 00:04:25.380, Speaker A: The constraints are basically like, with a stark. The verifier is checking that this set of constraints hold over this gigantic table. And the way I like to think about it is this table is like a spreadsheet with millions of rows. And if you had no constraints at all, you could basically put whatever values you want in this spreadsheet and the verifier would pass. But the constraints are what enforce structure between the values in this spreadsheet. And in the case of Starquiz verifier, or in the case of Cairo, these constraints enforce that. This massive spreadsheet or this massive table is the correct execution of a Cairo program.
00:04:25.380 - 00:05:18.740, Speaker A: So what's cool about a stark is that the verifier evaluates the constraints on a single row and the prover evaluates the constraints on every row. So the constraints are actually within the verifier. And what's awesome about Starquiz verifier is not only are the constraints in the verifier, but they actually have comments. And I've taken some comments from Starquiz Verifier and included them on this slide. So these comments are really great because they basically mentioned the constraint and they gave it a title which gave me some context about what the constraint was for. And we can take a look at the first constraint in this slide, which is for the initial program counter. And when I read this for the first time, I realized, okay, so the program counter goes in column four, row zero.
00:05:18.740 - 00:05:53.770, Speaker A: And what I did was there's lots of these. And I didn't want to remember like column four, row zero, column five, row six, and whatnot. So I created this spreadsheet, and that's what you see in the bottom here. So I would see initial program counter, and I would basically jot in column four, row zero. That was the program counter. And I did this for all the easy constraints and then some of the tougher constraints that involve several terms I was able to come back to. And I noticed that a lot of them used values that I'd already added to my spreadsheet.
00:05:53.770 - 00:06:52.218, Speaker A: And when you had the title of what the constraint was, and that gave you some context, and then I had all of the kind of the values that they used, suddenly the constraints started to make sense. And doing this was actually really satisfying, and it was kind of like solving one big puzzle, but this was a lot of fun. And, yeah, so these are the constraints that I reverse engineered. And I just want to quickly mention that you have constraints for each of the individual built ins, and you have also constraints for the Cairo control flow range. Check is the simplest built in that only has three constraints. And I've also got not a built in, but like the constraints for the chira control flow, there's one built in that I didn't reverse engineer, which is ketch. And yeah, Ketchek is quite a monster.
00:06:52.218 - 00:07:57.590, Speaker A: It's got more constraints than all the other built ins. So also how I'd done the constraints was a little bit rough, and I wanted to refactor how I was doing it. So I decided I'll leave Ketchek out now and I'll just work on the other built ins, but I plan to add this in later. So that was the first challenge with reverse engineering the verify. The second challenge was figuring out was basically getting feedback on whether changes that I was making to my prover or changes that I was making to the proof was making any progress with being able to submit it to the verifier. And one way I could have done it is I could have generated a proof, submitted it to the verifier on Ethereum, or submitted it to Starquase verifier on the testnet, and just submit it to the verify proof. But if the proof failed, I wouldn't get much feedback on why it failed or what was wrong, or get some insight into what I needed to change in the prover.
00:07:57.590 - 00:09:04.694, Speaker A: And so what I did instead was I went to Ethereum and downloaded all of the individual contracts and then put them into a foundry project. And foundry is for those who aren't familiar, foundry is a library and a tool for testing Ethereum smart contracts so I downloaded all these contracts, updated the dependencies, and got to a stage where I could call methods on the verifier locally and see if they work. So there was a bunch of private methods in the verify proof that would verify very small pieces of very small pieces of the proof, and I would change the visibility of them so that I could call them. And I would just focus on getting those working, and I would update the prover to maybe do a very specific part of the verification. And I did that for all of them and all of the small little parts. And then when I submitted the proof, it just worked. There was a few integration tasks as well, but more or less, it made their job a lot more manageable to make incremental progress.
00:09:04.694 - 00:09:41.858, Speaker A: And foundry was amazing for this. It was seriously such a helpful tool. And not only that, but I also used foundry for debugging. So a lot of the time I wouldn't necessarily know what I needed to change in the prover from the code alone. And foundry has the ability to do console logs. And yeah, I'm not sure if this is the best way to debug foundry projects, but this was really helpful. So what I've got here is a snippet of the code in the verification of the memory for the proof.
00:09:41.858 - 00:10:44.470, Speaker A: And I wasn't sure what the values needed to be, and I ended up just doing a whole bunch of console logs, and I could see what the verifier was expecting the value to be, and I was able to modify the Peruva to just produce the correct value. Foundry was amazing. And then this was kind of solving the challenge of getting feedback on making progress and whatnot. And after that, it was just a matter of grinding out the work for the prover. That's a little bit about the reverse engineering and the challenges that I faced. Now, I would like to talk about kind of sandstorm, the applications and the role of it in the ecosystem. So just quickly, what is Sandstorm? Well, sandstorm exists to basically generate proofs of executions of Cairo assembly.
00:10:44.470 - 00:11:34.998, Speaker A: So this means because Cairo zero and Cairo one both compiled the Cairo assembly, it supports both of those. And these proofs can target different verifiers. So it can target the verifier that I was reverse engineering, which was the verifier on Ethereum. And this would give you the ability to submit like a proof to Ethereum, but it also can target the Cairo verifier, which is very useful, because when you can target a verifier written in Cairo, you can do recursive proving. So this is great to have. Also, what Sandstorm is, is it's a prover, but it also has verifiers in rust. So it has the equivalent Cairo verifier in rust, and it has the equivalent Ethereum verifier in rust as well, which is super helpful.
00:11:34.998 - 00:12:56.230, Speaker A: And I'll talk about that in a bit. Bear in mind that these verifiers are not audited, but yeah, they're there. So we just heard a great talk from Kinnerette about stone, and a question you might all have is like, what now? Does Sandstorm offer? Does Sandstorm have to offer? And to that, I would say that I think Stone and Sandstorm are actually complementary to one another. So while stone is, and bear in mind, I haven't looked at the code, and I'm hearing about Stone for the first time today as well. But I think Stone's obviously optimized for big workloads, generating proofs for the Starware Cairo verifier and for Ethereum and big jobs. And I think where Sandstorm can kind of find a niche is in being able to generate proofs on the client side, on consumer devices, where there's a different set of things you want to optimize for. So if you're designing a prover to generate client side proofs, you can afford to have maybe the prover run a little faster and then verifications to be extremely cheap.
00:12:56.230 - 00:14:04.330, Speaker A: It'd be great to be able to develop approver such that recursive verifications on Starknet were really cheap, for instance. This is also where I think that it's been a good decision to use rust for Sandstorm. So I've personally really enjoyed my experience writing rust for the last little while, and I think it has the best tooling of any language that I've used. It has very rich community of developers and libraries, and the rust crypto community is great as well. And I just want to take this opportunity to acknowledge the great libraries that Sandstorm's built on, which is like arcworks, rust, crypto ruined, Starknet, RS and Rayon. These were so helpful for making the progress nice. The process nice and quick, like using the primitives from these libraries sped up the process immensely.
00:14:04.330 - 00:15:06.606, Speaker A: I also want to mention some libraries that I haven't used directly, but have been a source of great inspiration, such as like the Winterfell libraries, OpenZkp, and also plonky three. Actually, just briefly, I want to touch on how I think this is actually a win for decentralization. So I think having multiple implementations of something like approver. While this isn't like super tangible, I think it adds to the decentralization of a system. For me, I think of something like Ethereum, and I think one of the things that in my mind makes it feel more decentralized is that there's multiple implementations of everything. I think this adds a lot of robustness to a blockchain or to a network. And it gives you the sense that maybe if Starquare was to cease to exist tomorrow, the community would be able to pick up the baton and keep things going.
00:15:06.606 - 00:16:18.014, Speaker A: And I think this is something that, it's a gut feeling for me that makes ethereum feel so decentralized and so great. And to me, I think this is a win for decentralization quickly. I just want to touch on some of the applications of Sandstorm and how you might want to think about using it. So with Sandstorm you can target the Cairo verifier so you can do recursion. I work on a project called Zerosync, and the goal of Zerosync is to create a stark proof to basically sync a bitcoin full node. And we've been using like the team and I have been using Sandstorm to generate proofs that target the Cairo verifier to generate a proof of the headers chain. And this is where having Sandstorm have the verifiers that you can compile to Webassembly is really handy because at Zerosync we're always generating proofs, recursive proofs, but we also want to use the proofs of the headers chain in web applications or any applications, but like in the web as well.
00:16:18.014 - 00:16:57.278, Speaker A: And if you're using in a web application, you have to verify the proof to check that it's correct. And you don't want to have to ship Cairo with your web application and verify it there. So, yeah, so what you're able to do is you're able to right now, today, compile Sandstorm's verifier for Webassembly and verify recursive proofs there. So having the Webassembly verifier from Sandstorm is very helpful. And I want to make stone proofs a first class citizen from Sandstorm as well. So all of this can be supported for the stone proverbs as well. The other thing is like dispatching proof to the verifiers.
00:16:57.278 - 00:17:48.782, Speaker A: So Sandstorm and stone both create proofs, but there's another layer of parsing and dispatching that's required in order to ingest the proof into either the starkware verifier or into the Cairo verifier. And this is something that Sandstorm can provide. So it's not open source right now, but it's kind of done and I'm just getting it ready and I want to open source this very soon. That's the role of Sandstorm in the ecosystem and some of the applications. And very briefly, I'd just like to talk about the future of Sandstorm and what I'm excited about going. So like the first thing is the performance. Up until now I've just been focused on generating a proof that's compatible with starware verifiers.
00:17:48.782 - 00:18:42.480, Speaker A: And to give you an idea of performance of right now of Sandstorm, it can generate a proof on my laptop, which is an M one Mac of 8 million Cairo steps in about 30 minutes. And this uses about a terabyte of ram. So there's a lot of improvements to be made and going forward, performance will be a focus of mine and I really want to make that amazing focus on that. And then also the other thing that I think is interesting is going to be adding zero knowledge to the Cairo proofs and that will allow safety on proving on private and secret data. I think this could open up a lot of really cool applications. Those are a couple of things I'm excited about. The future.
00:18:42.480 - 00:19:03.380, Speaker A: The. That's all I want to mention today, but I want to say thank you to Starkware and Starknet for having me speak here today and supporting my work. And I want to thank all of you for coming to my talk today. Thank you very much.
