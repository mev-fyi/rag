00:00:00.090 - 00:00:23.358, Speaker A: Thanks for joining me. Today we're going to be talking about Starknet indexers. And if you followed me or if you've been on a workshop with me. Okay, thank you. So, yeah, thank you, pong chai. It looks like I was given a presentation on Starknet indexers to nobody because I did not press the go live button.
00:00:23.444 - 00:00:27.880, Speaker B: But we're here, we're indexing. We're going to do it.
00:00:30.730 - 00:00:39.154, Speaker A: Okay, thanks for joining me. We're going to be talking about Starknet indexers. And like I said, I typically like to take things from kind of first principles.
00:00:39.202 - 00:00:39.800, Speaker B: So.
00:00:41.770 - 00:01:36.806, Speaker A: Some of this, I hope we're not treading too much old ground and mostly new ground. If you know what indexers are, if you know why they're important, bear with me. We will look at some code. We will go over what an indexer looks like in code. But for right now, we're just going to go over a brief kind of description of what indexers are and why they're important. Okay, so indexing Starknet, why do we need indexers? If you think about what a blockchain is under the hood, it is a data structure that is not built for any type of modern paradigm, any type of web two application layer. It is a Merkel Patricia tree in the case of Ethereum, and it's a linear propagation of immutable blocks with a networking layer.
00:01:36.806 - 00:03:08.554, Speaker A: So that serves specifically the use case of the blockchain, in the case of a know something with a Turing complete language on top of it, like Starknet and like Ethereum, you're going to have all of these decentralized applications that are built to utilize that. You know, there is some version of the world where everyone is cypherpunk and they all come to the blockchain and they all know exactly how to interact with the CLI. But the more pragmatic view is that there's going to be a whole bunch of people that have no idea what the blockchain is, no idea how to interact with it, but still want to use the myriad of applications that are built on top of it. So that's where indexers come in and that's where these kind of periphery infrastructure live. So even though we have this core data structure of a Merkel Patricia try and a consensus layer, we need to have these peripheral infrastructure layers that serve useful information to people and applications. So if you think about Ethereum and Etherscan, you can think about a couple of different dapps. You can replace Etherscan here with Uniswap or Aave there's some piece of information on the blockchain that is very important to that smart contract and also that application.
00:03:08.554 - 00:03:55.800, Speaker A: So we have some ingestion service that parses out the specific information from that smart contract or interacting smart contracts that interact with the main smart contract and present them to a user. If you think about the context of a web, two UI or even an application, this is the way that these applications are architected, even just twitter.com Dr. Spiceman it is not only just the URL, it's the way the entire single page application flows. So the API guy is looking specifically for a username. That username sits in a user's table. It's this complete schema of data that works specifically for this application.
00:03:55.800 - 00:04:52.380, Speaker A: We don't have that paradigm in web three in blockchain just because the underlying layer one is not built to serve uis. So the other purpose of having an indexer is to reduce the query time. So what do we get for all of this kind of data parsing and well thought out schema is we get a reduced query time when we go and query a block on Etherscan. We don't need to sit there and have it reexecute its state from scratch. Yes, and to format the data schema. Okay, so what specifically is an indexer then? An indexer is this infrastructure piece that facilitates all of those things that we mentioned. It fetches and filters the pertinent blockchain information.
00:04:52.380 - 00:05:39.210, Speaker A: It formats that relevant data and then it serves the relevant data. So if you think about this in the context of the graph, let's say that is a defined graphql schema that's published to the decentralized indexers. And then those indexers go out and do these steps. They go fetch and filter this blockchain information so that these applications have some fast, speedy, useful lookup. And yeah, like we mentioned already, if you are coming from the web two world, that's exactly what it looks like. You'll see these types of services all over the place. An API hook parser, a database and a predefined schema and an API.
00:05:42.510 - 00:05:44.250, Speaker B: One thing that the graph has that.
00:05:44.320 - 00:06:38.554, Speaker A: We'Re not going to be talking about today is that the graph really is, or at least what it aspires to be, is a decentralized indexing protocol. Today we're going to be looking at basically just the first principles of indexing. And how does that look on Starknet specifically? Okay, so one really important part of indexing is contract events. Smart contracts like written in solidity and written in Cairo can emit events on the right side here. These are the events that are emitted from the open Zeppelin ERC 20 contract, transfer and approve. So events at their core are a way for the smart contract to communicate from its execution. So these events are emitted during the execution of the smart contract code.
00:06:38.554 - 00:06:58.974, Speaker A: And we want to communicate with this peripheral layer, that peripheral layer being this infrastructure that's provided by indexers, and indexers aren't the only thing that sit at this peripheral layer, but especially for events, it's really meant for communication with indexers.
00:06:59.022 - 00:07:02.226, Speaker B: So we want to communicate with some.
00:07:02.248 - 00:07:48.814, Speaker A: Outside party that a transfer has happened on chain. So smart contract communication and logging and then rich asynchronous triggers, you could have a trigger to this external infrastructure based just on the contract and the event name. Let's say the event name here is transfer. But what we really want is we want some rich version of that that has some information in it. And so you can see in the event, even in the event signature here, we're not only saying that there was a transfer, but we're saying it's from this person to this person for this much money or value. And that's where the richness comes. These events are triggered with useful information, cheaper storage.
00:07:48.814 - 00:08:25.230, Speaker A: So when we emit these events, and we know that we've set this smart contract up to interplay with a peripheral infrastructure, we can use it as storage. This information is part of the block, it's hashed into the block, but these events have nothing to do with the contract storage. So as you walk through your smart contract design and your decentralized application architecture, you can think about how exactly am I going to use these events to operate within my protocol.
00:08:27.490 - 00:08:27.902, Speaker B: Cool.
00:08:27.956 - 00:09:07.558, Speaker A: So this is what the contract events look like in a block. And as it's served from the blockchain, this is a transaction receipt on the right. An event on starknet consists of the from address, and that address is the contract that's emitting the event. So it would be the ERC 20 in the previous slide keys, which is a list of field elements, and data, which is also a list of field elements. So here we have events from address keys. Keys is going to be the hash of the event name, and then data. Data is what makes these events rich.
00:09:07.558 - 00:09:10.570, Speaker A: It's where we get the richness that we mentioned earlier.
00:09:11.570 - 00:09:12.320, Speaker B: Cool.
00:09:13.010 - 00:09:21.310, Speaker A: You'll see that this transaction specifically has multiple different events that it triggered along its execution path.
00:09:23.510 - 00:09:24.018, Speaker B: Great.
00:09:24.104 - 00:09:33.940, Speaker A: If anyone has any questions for me as we go through this, please just reach out in the chat and I'll answer them.
00:09:34.970 - 00:09:38.840, Speaker B: Okay, great. So now we're going to look at some code.
00:09:40.330 - 00:09:43.560, Speaker A: We're going to struggle through some live coding here.
00:09:46.090 - 00:09:46.854, Speaker B: Let's make sure.
00:09:46.892 - 00:09:49.442, Speaker A: Okay, it looks like you guys should still be able to see my screen.
00:09:49.596 - 00:09:54.314, Speaker B: If you have any questions for me yet, reach out.
00:09:54.352 - 00:10:13.582, Speaker A: We're going to be working on the repo that I sent out in the chat. The repo is called starknet stack. So I'm going to start from scratch and you guys can code along with me. If not, no worries. And then yeah, feel free to ask me any questions. This is where I was at when I realized I was talking to the void.
00:10:13.726 - 00:10:32.260, Speaker B: So we'll start here. And this is the repo.
00:10:36.200 - 00:10:40.724, Speaker A: Okay, so we mentioned these different pieces and how they look a lot like web.
00:10:40.762 - 00:10:45.012, Speaker B: Two services that will become more evident.
00:10:45.076 - 00:11:04.482, Speaker A: As we start building it out. CD Starknet stack and let me know if the font size is okay. I know we had some issues with the font size of editors in our previous stream, so let me know if the resolution and font size is okay.
00:11:04.536 - 00:11:08.290, Speaker B: Here, let me just head back to the chat.
00:11:11.130 - 00:11:57.570, Speaker A: Okay, so for us, we're going to kind of go from first principles, which means using the simplest mechanisms that kind of get the thought across in big production grade indexers, big production grade systems. You're probably not going to see SQLite, but you might. There are indexers on Starknet. One of them is actually a project called Starknet Indexer on GitHub. If you want to look at a more advanced version of this, go check that out. It uses some really cool data structures and really cool mechanisms, but for us, we're just going to use SQLite as simple as a data storage as you can get. If you're following along with me, install sqlite.
00:11:57.570 - 00:12:28.718, Speaker A: If you're working on Ubuntu or Linux, you can just install it. It comes with a lot of distros, but if you do need to install it, install it like this. SQlite is pretty pervasive. So if you're on Mac, there should be a pretty simple sqlite. It's probably brew. It's probably just brew. Install SQLite three CD into the indexer subdirectory and we will start our data store.
00:12:28.718 - 00:12:39.054, Speaker A: So thinking through the pieces that we need in an indexer, we need a predefined schema. And the goal of what we're doing is to have fast lookups.
00:12:39.182 - 00:12:39.860, Speaker B: So.
00:12:42.470 - 00:13:12.554, Speaker A: The predefined schema and the thinking through of how the schema works is going to be important. For the lookups. And you're starting to get into a lot of web two trade offs, web two terminology here, because this has nothing with the protocol rules of Starknet. It's just going to be specifically how you want to index your data from the blockchain. So this is just a real simple one. We're going to walk through an example of an ERC 20. The ERC 20 that we're looking at.
00:13:12.592 - 00:13:16.960, Speaker B: Is just the open zeppelin code.
00:13:23.550 - 00:14:06.514, Speaker A: So the open zeppelin contracts for Cairo has an ERC 20 with presets. And then if we go into the library, we can see these are the events we saw from the slide. So transfer and approval. When I was going through and thinking about the schema, it starts to become pretty clear what you need to parse from the smart contract. We have an ERC 20 name, ERC 20 symbol decimals, total supply balances, allowances. We probably want all of that information so that we can show it to the user. But some things like balances and allowances, you can see that there's a mapping between accounts and balances.
00:14:06.514 - 00:14:44.734, Speaker A: It's not a single address. So that's when you start thinking about your database schema in an SQL world. I broke it out like this. You can break it out into maybe a join table, but this is the simplest thing I kind of thought of. So all of the token metadata is here. It's id in the table name, symbol decimals, token supply high for the low bits of the UN 256 and token supply high for the high bits of the UN 256 and address. So address where that token is deployed to owners.
00:14:44.734 - 00:15:15.502, Speaker A: So since this is a mapping, we're going to have which owner has which balance. The beautiful thing about indexers is we know that the blockchain has the state. So let's say that our local Sqlite DB gets corrupted or something goes wrong, we can always sync our table back to the state of the blockchain, which is the purpose of the blockchain at the end of the day. Allowances. So who has the allowances to spend?
00:15:15.556 - 00:15:16.160, Speaker B: What?
00:15:18.210 - 00:15:53.370, Speaker A: If you're building your own sequencer or your own indexer? This is a good thing to probably do. Look at the storage variables that are being stored to the contract because obviously those are important to understand. If you're building out your own smart contract, this is also where you want to start for your indexer. So what am I storing to my smart contract? And then what are the interactions with that storage? As you think through the interactions with that storage, you might be thinking about what to emit as an event. So here is obviously transfer from owners and approval.
00:15:54.670 - 00:15:55.420, Speaker B: Cool.
00:15:57.390 - 00:16:20.766, Speaker A: Okay, so we have our schema here. Three tables, ERC 20 owners and allowances not to beat a dead horse, but this can be set up however you want. This doesn't have to be an SQL schema. This can also be a graphql schema. Anything that works and operates within your index or in your architecture.
00:16:20.798 - 00:16:23.730, Speaker B: Well, so we'll go to the readme.
00:16:24.710 - 00:16:48.330, Speaker A: I'm going to do this on Devnet. Everything that I'm doing applies to Testnet. It's just that things take a little bit longer and workshops get a little more tedious if you do things on Testnet. So we'll start the devnet and we're going to deploy.
00:16:50.670 - 00:16:54.800, Speaker B: Looks like I have Devnet started somewhere else.
00:17:14.770 - 00:17:42.480, Speaker A: Started Starknet, Devnet. Okay, we have not written our schema yet to the indexDB, which is the sQlite dB. For the most part, SQlite is going to be out of the scope of this workshop. Just know that it is a data store. It's a structured data store. It's one of the simplest structured data stores you can have select.
00:17:43.890 - 00:17:50.640, Speaker B: Let's see, what is it? Tables. Sorry.
00:17:52.290 - 00:18:05.730, Speaker A: To open the specific file, since it's one of the simplest ones, it's just written to this flat file, this index db, 16 kb.
00:18:06.070 - 00:18:11.986, Speaker B: So we'll open that index DB and we'll say, what are the tables?
00:18:12.018 - 00:18:38.480, Speaker A: The tables are what we just created. Allowances. ERC 20s, ERC 20, and owners. Okay, and what we're going to do is we're going to deploy an ERC 20 to Devnet. You should have the ERC 20 compiled here, which ERC 20 jSon. So we'll deploy this to.
00:18:40.690 - 00:18:41.790, Speaker B: Devnet.
00:18:44.390 - 00:18:45.570, Speaker A: The inputs.
00:18:48.070 - 00:18:50.450, Speaker B: Got to be in my Cairo dev environment.
00:18:55.670 - 00:19:33.950, Speaker A: The inputs to that deploy command are the metadata for the token. So this is the token name in felt format. This is the token symbol in felt format, decimals, total supply. And who will be the recipient of the total supply? To start, just for demonstration purposes, I put the first deployed account on Starknet, Devnet, which is this account. Just so we know that we have some account that we can look at and see if they own the supply.
00:19:35.030 - 00:19:35.780, Speaker B: Great.
00:19:36.150 - 00:19:44.066, Speaker A: So this is where we might start to struggle a little bit with the live coding, but we'll see how we do. Any questions?
00:19:44.168 - 00:19:44.770, Speaker B: No questions.
00:19:44.840 - 00:20:14.350, Speaker A: Okay, so thinking about our architecture, we have a predefined schema. So what's the next thing we need? We need to parse information from the blockchain. That's going to be with some programmatic interface to the blockchain. So Starknet has a lot of different sdks. Some of the most popular are for Javascript. We have some popular ones for Python, a new one spinning up with Java. There's actually a brand new one coming for Swift.
00:20:14.350 - 00:20:51.740, Speaker A: The one I'm going to use is the Golang version, which is called Kaigo. So here's a main go file. And actually we might just do it in raw go just for demonstration purposes. But there's a Golang SDK where you can say just get transaction receipt. Here is the. You don't have to focus too much on this. Just understand where in the indexer architecture we're looking.
00:20:51.740 - 00:21:04.746, Speaker A: This will be the parser parsing off the pertinent information. Here's an escalate driver for our escalate.
00:21:04.778 - 00:21:10.238, Speaker B: DB and just some example SQL to.
00:21:10.244 - 00:21:20.994, Speaker A: Make sure that our driver is working. We're going to manually insert the information for this ERC 20 token to just.
00:21:21.032 - 00:21:24.238, Speaker B: Remind you this is the table we'll.
00:21:24.254 - 00:22:18.034, Speaker A: Be working with to start insert into ERC 20 values. If you think about all these things going on on the blockchain, you can also have an indexer that looks for deployed contracts. So if you see a deployed contract and you have something parsing information off the blockchain, you could have something that's filling up a contracts table with the contract address and including anything else you want. Maybe even like a JSON B column with all of the ABI you can really go as detailed or as high level as you want. So we'll input just the first id the name which is index token, the.
00:22:18.072 - 00:22:20.770, Speaker B: Symbol which is index token.
00:22:22.890 - 00:22:25.682, Speaker A: And this is the short string representation.
00:22:25.826 - 00:22:31.020, Speaker B: Of this and this.
00:22:33.150 - 00:22:35.770, Speaker A: So decimals, 18 decimals.
00:22:36.750 - 00:22:38.090, Speaker B: Total supply.
00:22:38.750 - 00:22:52.960, Speaker A: This is 1000 with 18 decimals. We don't have a high u in 256. And the last column in our SQL is address.
00:22:53.330 - 00:23:04.690, Speaker B: So the address deployed will be this address right here. I'm not positive SQlite prompt can handle.
00:23:07.450 - 00:23:25.820, Speaker A: Hex encoded data, so I'm going to flip this to an integer. Forgot my semicolon. Just to make sure we got it. Select star from Erc 20s.
00:23:26.750 - 00:23:27.500, Speaker B: Great.
00:23:29.070 - 00:23:40.494, Speaker A: Okay, so like we said, we need a programmatic interface to not only our data schema and our database, but also to the blockchain. So pick your favorite programming language I'm going to use.
00:23:40.532 - 00:23:41.118, Speaker B: Go.
00:23:41.284 - 00:24:07.080, Speaker A: Feel free to use Python rust. Really anything. So here is just going to be some bit of proof that we are indeed communicating with our data store here. Select name from erc 20s. Go run main go. If you are doing this one with me, you'll need to install go.
00:24:08.890 - 00:24:19.742, Speaker B: I'll just point you in the right direction there. One of the great things about Go.
00:24:19.876 - 00:24:27.390, Speaker A: Is it's real easy to use, easy to install. Just run that guy and you should have go in your path.
00:24:27.550 - 00:24:28.162, Speaker B: Cool.
00:24:28.296 - 00:24:36.066, Speaker A: So you saw that we are hooked up to the data store. ERc 20 name index token.
00:24:36.178 - 00:24:36.840, Speaker B: Awesome.
00:24:37.530 - 00:25:07.280, Speaker A: And now we also know the address at which that contract is deployed. So the next piece of information that we need is what's happening on the blockchain. These indexers can have various different configs of how often you're pinging. You don't exactly know what the specific down to. Let's say second that the block will be.
00:25:09.010 - 00:25:09.870, Speaker B: Added.
00:25:10.210 - 00:25:28.840, Speaker A: So we will have to have some logic for pulling this information at some interval. This is where the live coding might be a little tedious, but we'll see how far we get. Any questions so far?
00:25:32.930 - 00:25:33.680, Speaker B: Okay.
00:25:36.690 - 00:26:12.490, Speaker A: Here is a postman collection. I say this in a lot of my workshops, but we have this postman collection called starknet.edu. I find it really useful just for having predefined API requests and also predefined RPC requests in a real world indexer. You're going to be pulling from the JSON RPC interface to the blockchain. This is something that's exposed by pathfinder or Juno or any full node just for demonstration purposes. I'm going to just use the gateway.
00:26:15.550 - 00:26:35.704, Speaker B: So we will do get block 1 second. Okay.
00:26:35.742 - 00:27:12.310, Speaker A: We actually will use. Okay, postman comes with these stubs. So these stubs are going to be a lot of what your specific languages library does for you. So if we wanted to look for the raw go code to interact with this URL, with this format, we can pull it out here, but your SDK is going to give you a lot of this information formatted in a much nicer way.
00:27:15.750 - 00:27:33.450, Speaker B: All right, so we will grab this and we will say fetch block.
00:27:40.590 - 00:27:47.050, Speaker A: So for go specifically, we need to also include our standard library packages.
00:27:49.870 - 00:27:57.180, Speaker B: Here. Okay.
00:27:57.590 - 00:28:04.462, Speaker A: And then instead of the testnet, we're going to be working with the Devnet.
00:28:04.526 - 00:28:36.136, Speaker B: Localhost, 50 50 feeder gateway, get block. And we're going to get the latest block. Okay, get the latest block. And one more thing we're going to do is we're going to make sure.
00:28:36.158 - 00:28:40.304, Speaker A: That we have a way to interact.
00:28:40.372 - 00:28:40.990, Speaker B: With.
00:28:44.320 - 00:28:45.710, Speaker A: Our return value.
00:28:52.270 - 00:28:53.226, Speaker B: Which means that.
00:28:53.248 - 00:29:03.674, Speaker A: We will need, especially in typed languages, that means that we need to assign.
00:29:03.722 - 00:29:21.340, Speaker B: A type to this. So I will pop this in a little.
00:29:24.430 - 00:30:07.074, Speaker A: Converter for me. And we have a handy dandy type. This tutorial, if you check back in probably later this week, will have all of this expressed for you. So right now we're live coding it, but this tutorial at the end of the day will include some predefined steps that you won't have to go through and write the code for. So here is the information that we get back from the get block API.
00:30:07.122 - 00:30:13.046, Speaker B: So we'll call this block and we.
00:30:13.068 - 00:30:15.760, Speaker A: Need to read it into a.
00:30:28.950 - 00:30:30.370, Speaker B: Block is a block.
00:30:40.230 - 00:30:57.370, Speaker A: I realize now that I'll probably end up be teaching some go here, which I hope is interesting to you guys. So when we fetch a block, we need to return a data type. The data type that we're going to return is a block.
00:30:58.110 - 00:31:08.326, Speaker B: And right here we'll return block. If we have an error in fetching.
00:31:08.358 - 00:31:15.866, Speaker A: A block, we'll panic for now because as the indexer, if we can't fetch.
00:31:15.898 - 00:31:19.300, Speaker B: A block, that's not a good thing.
00:31:30.730 - 00:32:05.306, Speaker A: All right, so in terms of our slides that we went over earlier, this is the API hook as well as the parser. So we're parsing out relevant information right now. This is actually not parsing, we're just fetching. So we're fetching information from the blockchain. And then since we've typed our return here, we can parse which of these things is important to us. So in the context of an indexer, you can see that the blockchain itself needs all of this information for it to propagate its state. It needs the version of Starknet.
00:32:05.306 - 00:33:06.450, Speaker A: It needs l one l two consumed message. Because the way that the blocks propagate and the way the blocks are hashed, they need this information to make sure that the state is correct and accurate and the execution is correct and accurate. But we don't, as the person that's looking out at this ERC 20 token, we don't need all this information. We just need, hey, was there an event that was emitted? And did that event have anything to do with my specific contract? You can start to see why indexers are important and why indexers are especially important for these expressive smart contract blockchains. You even can see all the way back up the stack to the Cairo code because what are we parsing out? Well, we're parsing out events which from this big old data type and big old blockchain data return, this is actually the only piece of information we need. This piece of information is an array of which we actually don't need. All of the elements of the array either.
00:33:06.450 - 00:34:06.390, Speaker A: So you start to see all this superfluous information that's needed for the blockchain that's not needed for these periphery infrastructure pieces. It's also the reason that a general purpose indexer, let's say for every single NFT or NFT mint, it'll work for a lot of different use cases. With these protocol standards, you can have an indexer that indexes every single thing that's happening if everyone's using the same open zeppelin contract. But let's say that you're creating a new protocol, creating a new DeFi application, and you need to know specific pieces of information from your smart contract. You're going to need to start coming up with the architecture of where, when and how you emit events and then how you ingest them on the other side outside of the context of the blockchain.
00:34:07.370 - 00:34:12.040, Speaker B: Let me just pause real quick and ask for questions.
00:34:14.510 - 00:34:16.540, Speaker A: Anybody that's on have any questions?
00:34:21.960 - 00:34:22.710, Speaker B: Okay.
00:34:24.920 - 00:34:28.116, Speaker A: I'm going to run this and then we're running out of time a.
00:34:28.138 - 00:34:31.688, Speaker B: Bit, so I'm going to run this.
00:34:31.774 - 00:34:36.410, Speaker A: And then we might just have to pseudocode some of the rest of this here.
00:34:40.480 - 00:34:41.710, Speaker B: So for this.
00:34:43.520 - 00:34:47.260, Speaker A: We know that we have a good connection to the database.
00:34:49.280 - 00:34:53.804, Speaker B: And instead of name here we're actually.
00:34:53.842 - 00:34:55.492, Speaker A: Going to parse out the address.
00:34:55.666 - 00:35:49.240, Speaker B: It I have messed up some of my imports. Let's just make sure that we're printing out the good address. What have I screwed up? Let's see. FMT redeclaim this block. We don't need FMT twice imported and not used. We'll use this in 1 second.
00:35:51.450 - 00:35:59.370, Speaker A: Okay, that address is most likely the correct address in scientific notation.
00:36:02.510 - 00:36:16.014, Speaker B: All right, so let's fetch the block. Let's see what we have screwed up.
00:36:16.052 - 00:36:19.854, Speaker A: Here and maybe we can make this a little more descriptive.
00:36:19.902 - 00:36:43.580, Speaker B: Fetch latest block. All right, and we will say block hash it.
00:36:56.050 - 00:37:07.710, Speaker A: I changed the postman script just slightly so we now need a JSON package. And the one that we don't use to parse out that information from bytes is irutil.
00:37:10.130 - 00:38:03.156, Speaker B: And this is no longer the correct syntax. And my editor is now borked. Let's get it back up. Let it. All right, let's give this a shot. Error does not need to be redefined. Believe that?
00:38:03.298 - 00:38:07.200, Speaker A: Yeah, so I was pulling from htps.
00:38:07.280 - 00:38:22.190, Speaker B: But we serve on HTTP and block hash will now become block number.
00:38:23.360 - 00:38:26.430, Speaker A: The pains of live coding. Okay, great.
00:38:28.800 - 00:38:29.308, Speaker B: Awesome.
00:38:29.394 - 00:38:38.640, Speaker A: So this is the address of the ERC 20 token we deployed. This is the latest block. In that latest block.
00:38:40.500 - 00:38:49.310, Speaker B: We have all sorts of information, including.
00:38:51.490 - 00:39:23.030, Speaker A: The transactions. So we can now sift through this list of transaction receipts. And again, you can do this in any programming language you're comfortable. You should have access to, any programming language you're comfortable. If there's not, I would encourage you to maybe even go create the SDK for the language you're comfortable if you are a starknet enthusiast.
00:39:24.490 - 00:39:29.770, Speaker B: Index TX receipt.
00:39:31.710 - 00:39:36.170, Speaker A: All right, so we'll range over the list of transaction receipts.
00:39:40.130 - 00:39:51.298, Speaker B: And we'll print everything that happened and.
00:39:51.384 - 00:39:59.874, Speaker A: We'Re not going to use the index for now. All right, not much happened in this.
00:39:59.912 - 00:40:00.500, Speaker B: One.
00:40:02.230 - 00:40:23.706, Speaker A: And we are running out of time, but this is a pretty good place to stop. You're getting a good idea of what exactly is happening. We're parsing through. We have the blockchain, which is this immutable data structure or immutable propagation of.
00:40:23.728 - 00:40:27.434, Speaker B: Blocks and execution that we don't need.
00:40:27.472 - 00:40:54.550, Speaker A: All the information from. So if none of these transaction receipts actually have anything to do with this ERC 20 address, then I can throw them away. My indexer doesn't need to know anything about them because I'm just indexing for my specific application. Now let's say that it does have something to do with my information, my contract. Now what I do is just to go back to the slides earlier.
00:40:59.450 - 00:41:03.014, Speaker B: Now I can parse out the so.
00:41:03.052 - 00:41:31.646, Speaker A: I check that this from address is from my ERC 20 token. And now I can check which key it was. So if it was a transfer, I know that I can update my sqlite dB to reflect the transfer of from.
00:41:31.748 - 00:41:36.642, Speaker B: This address to this address with this value.
00:41:36.776 - 00:41:39.540, Speaker A: So what does that look like in the sqlite terms?
00:41:39.910 - 00:41:42.594, Speaker B: Well, the way we laid out our.
00:41:42.632 - 00:41:47.030, Speaker A: Schema is that it will be an update to the owner's table.
00:41:49.930 - 00:41:52.040, Speaker B: Just write out some pseudocode here.
00:41:56.170 - 00:41:58.840, Speaker A: I don't know what the comment format is.
00:42:01.550 - 00:42:30.020, Speaker B: Anyway. Update. Okay, so update owners where account equals, this will be the from equals from.
00:42:32.150 - 00:42:43.014, Speaker A: Set balance equal to new balance. And that new balance will be done.
00:42:43.052 - 00:42:48.066, Speaker B: In the go code here and it'll.
00:42:48.098 - 00:42:59.450, Speaker A: Be the subtraction of the value. And then we'll do another update function below it where account equals to set balance equals to new balance.
00:43:00.510 - 00:43:01.066, Speaker B: Nice.
00:43:01.168 - 00:43:56.356, Speaker A: And then next time, the whole point of this, just to circle all the way back around, is for fast lookups. So the next time we look up, hey, what's the account balance of this owner in the ERC 20? It's literally just a single table lookup to owners on the SQ light DP cool. I hope that this was useful. Let me double check with time. Does anyone have any last questions as we round this out? Looks like no. Follow this repo. It's going to be the entire star net stack, not just indexers, but how to spin a full node of both layer one Ethereum and layer two starknet along with how to spin up one of these indexers with some examples.
00:43:56.356 - 00:44:04.100, Speaker A: Thanks for joining everybody and make sure to keep an eye on when the next one is. I think it should be in two weeks. And have a good day. Bye.
