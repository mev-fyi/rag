00:00:00.250 - 00:00:09.520, Speaker A: Do this, I always get added into a zoom and then they stream the zoom instead. That's what they used to do and they never ever use this. But this is amazing.
00:00:10.290 - 00:00:57.710, Speaker B: Okay, so we are live. Hello everyone, and welcome to community call number 48. I am super excited about this community call personally because this is a subject that I've been wanting to explore this week and being hosting this community call is really a win win for me in every way possible. And hello everyone. I'm Gyan and I'm one of the developer advocates with Starkware, working particularly towards education, content and everything around that in the stocknet space. And today we have Jonathan with us, Jonathan Ley, the co founder and CTO of ZK lend. You might have heard of ZK lend quite a bit.
00:00:57.710 - 00:01:45.594, Speaker B: They have been doing some amazing job, both in terms of building in the defi space as well as building on Starknet, advocating Starknet. And he is of course the creator of Starknet RS and Starkly. And today we are going to be talking all about Starkly, which is the new ClI client for Starknet, written in rust. I feel like if you are a developer and you want to build on Starknet, now is of course a great time to start building. But also this community call specifically is going to be really important for you because Starcly helps sort know simplify the setup process for builders. So that's what today it's going to be all about. And Jonathan, the stage is yours.
00:01:45.594 - 00:02:26.150, Speaker B: I'm going to be adding your presentation as well. If I missed out something on your introduction, please feel free to share that. Let the builders know. What is the current state of the Cli? What are some of the operations that Cli does? And why is it incredibly important to have that component? And how can builders now look at Starcly and what does this do? Jonathan, are you here? I think there might be some.
00:02:26.920 - 00:02:27.830, Speaker A: Are we?
00:02:29.720 - 00:02:31.140, Speaker B: Yes, yes.
00:02:31.210 - 00:03:07.868, Speaker A: Okay, sorry. Maybe some network problem. And so thanks for the introduction. And today I'm going to talk about Starlight, which is again a new Cli that's been built for some context. Though we already have the net command from Kyolang. Why would we ever need another CLI? Well, the reason that I built this a while ago is because the current one just isn't that good, to be honest. The chiral lang version of the CLI is written in Python.
00:03:07.868 - 00:03:29.992, Speaker A: It's hard to install in the sense that it has some dependencies. If you install the thing, sometimes it fails because you don't have some dependency on your computer. Or maybe of course, you have to install Python first, and for the Python, it only works with certain versions. So if you have another version of Python installing your computer, you need some virtual environments set up to make things.
00:03:30.046 - 00:03:31.492, Speaker C: Work, which is terrible.
00:03:31.636 - 00:03:34.476, Speaker A: It's hard to install, it's slow to use as well.
00:03:34.578 - 00:03:46.236, Speaker C: If you invoke literally any command, it will wait for, if you're lucky, one to 2 seconds to get anything done, because interpreting the entire thing is just slow.
00:03:46.428 - 00:04:01.824, Speaker A: And that's why I actually created another one that's just simply to replace the current CLI and to actually to do more and better. And that's how stock light was born. And I started doing this in rust.
00:04:01.872 - 00:04:07.510, Speaker C: Because basically I am a huge rust lover and I do everything in.
00:04:09.260 - 00:04:18.868, Speaker A: Yeah, and that's pretty much the background. And now this is now what we have, Rust ClI. And I'm going to introduce today, what's.
00:04:18.884 - 00:04:45.968, Speaker C: The feature, how is it better than the current one, and how we are going to be using it? What's the major differences? Because I actually look at the currency and I wonder, hey, is this actually the correct decision, the right design to solve this, or is there a better way? And this is why I put into stocklight as well, in terms of actually designing something new that's actually better.
00:04:46.134 - 00:04:48.544, Speaker A: So it's not exactly a drop in replacement.
00:04:48.592 - 00:05:15.800, Speaker C: It's not like you can replace all your combined invocations with startlight and then everything is worse. It's actually not the case. It's different, because again, some design decisions of the original CLI might be questionable. I mean, questionable is kind of like maybe just something I don't personally like. So let's just get into you the features of Starnet. So first of all, of course it's.
00:05:15.880 - 00:05:24.860, Speaker A: Very fast because usually in rust, so it's compiled, it doesn't use any interpretation. So it's not Javascript, it's not python.
00:05:24.940 - 00:05:28.716, Speaker C: It just runs out of the box and it just runs natively.
00:05:28.908 - 00:05:52.084, Speaker A: So that's why it's really fast. And there's actually another reason that it's fast. It actually uses the JSON RPC by default, meaning it actually encourages you to use the JSON RPC. Because the JSON RPC is much faster. You don't get very limited by startware. There are many benefits of using JSON RPC, including the fact that startware will.
00:05:52.122 - 00:06:07.196, Speaker C: Deprecate the sequence API anyways. So everyone's kind of encouraged to use JSON RPC, and that makes JSON RPC the default of Startlight. Of course, like Startlite as we talk about, we're going to talk about this a bit later.
00:06:07.378 - 00:06:17.904, Speaker A: So the next one is that it's really easy to install. You just have to get a tool called Startlight up, which when you run.
00:06:17.942 - 00:06:49.960, Speaker C: It will simply fetch the pre built binaries of the startlight. And to get the startlight up itself is extremely easy. There's a curl bash command that you just curl a certain script and then you pipe it into an asset which we will demonstrate later. You just get the startlight up install and once you have startlight up, whenever you want to get the latest version of Startlight, maybe you see hey, there's a new release coming out, there's some feature that you want, you just run startlight up and then boom, you get the latest version.
00:06:51.760 - 00:07:01.048, Speaker A: And you do this without having to compile anything because everything is pre built. We have a few platforms, macOS, ARM.
00:07:01.144 - 00:07:10.784, Speaker C: X 86 64, Linux and Windows supported. We have pre built binaries that's like triggered from GitHub actions, that's built by.
00:07:10.822 - 00:07:27.348, Speaker A: CI and automatically pushed to the releases. And for those you can just download the pre built binaries. What this means is that even if you are not a rust developer, you don't have to be a rust developer to use this. You don't have to install rust, you don't have to install cargo, nothing is needed.
00:07:27.434 - 00:07:53.740, Speaker C: You just have to have curl or maybe wget or something, and then you just have to have a shell and that lets you execute the installation script and everything gets downloaded. Of course you can always install from source, and that's super easy as well. If you are a trust developer, you just have to do a cargo install command and things get installed automatically. There's no extra dependency, everything is in rust.
00:07:54.480 - 00:07:56.544, Speaker A: But then for those who don't want.
00:07:56.582 - 00:07:59.264, Speaker C: To and who only want to get.
00:07:59.302 - 00:08:01.372, Speaker A: The easy way, you have start layout.
00:08:01.516 - 00:08:34.140, Speaker C: It's super easy to use, which I will demonstrate. And also another one is that it has shell completion. This is really important for NCLI. What this means is that you can type a command, half of it, maybe the first two letters, and then you hit tap and then the command automatically finishes for you. And this is not limited to the command name. So it's not like yeah, if you do bl, it gets blocked for you, you do TTR, it gets transaction for you. But it's more than that, it actually applies to the flag as well.
00:08:34.140 - 00:08:45.868, Speaker C: So if you do double dash and a it knows you want to type account and double dash account finishes, things like that. It makes the use of startlight a.
00:08:45.874 - 00:09:04.816, Speaker A: Lot easier than the current one because the current one doesn't really come with any shell configuration at all. And the best for is this is all set up automatically when you use stoplight up. If you install from source with cargo and rust, this doesn't get set up, but you have commands to do that. And if you are installing from source.
00:09:04.848 - 00:09:08.660, Speaker C: Anyways, I believe you can have the expertise to do it anyways.
00:09:09.240 - 00:09:21.384, Speaker A: But again, the easiest ways is to use startle is the easiest. And then apart from shell completion, there's another issue that's going to make the.
00:09:21.422 - 00:09:38.690, Speaker C: Transition between the current CLI to end the new one really easy. The current CLI is actually using sequencer gateway all the time. It uses sequencer gateway by default, and it doesn't really support JSON RPC. But the JSON RPC is really the thing that's going to be the thing going forward.
00:09:39.940 - 00:09:49.924, Speaker A: The whole ecosystem is pushing forward towards the JSON RPC spas and the sequencer API is going to be that created as mentioned. But then stoplight doesn't really just say.
00:09:49.962 - 00:09:59.188, Speaker C: Hey, let's just use JSON IPC anyways. And because we understand that there are hardles that makes setting up a JSON.
00:09:59.204 - 00:10:07.240, Speaker A: RPC node or maybe just getting infuriator API are kind of difficult, and maybe sometimes it's why.
00:10:07.390 - 00:10:23.070, Speaker C: And we want to make things super easy to get started. So the good thing about the screens API is that you don't need anything to get started. It's just there available free of charge. I mean, you get really limited sometime if you make too many requests, but.
00:10:25.040 - 00:10:51.336, Speaker A: That'S kind of given because it's free and it's open. But then startlight supports both. So this will also be demonstrated, obviously, and everything we mentioned on this screen we've demonstrated. And this is actually one feature that's the clean account insider separation. This is something that's not just a feature, but also a major difference between the current CRI and starline. With the current CLI, whenever you create.
00:10:51.358 - 00:11:08.780, Speaker C: An account, it gets stored in a net account file, actually start accounts file something somewhere around your home directory, and it stores all the addresses, private key, public keys, and things you use to just deploy this account in the first place.
00:11:08.930 - 00:11:11.916, Speaker A: Everything is bundled together, which is kind.
00:11:11.938 - 00:11:26.292, Speaker C: Of like defeating the purpose of account abstraction, because with account abstraction what you have is that you have an account which is an implementation, and then you have something else that controls the account.
00:11:26.426 - 00:11:50.392, Speaker A: These two are actually separated. I think it helps to get developers into this mindset that accounts are different from signings. They are two different things. You can have a private key that's written in plain text, of course, not recommended. It's bad practice. You can have an encrypted key store. You can have a hardware wallet, maybe it's a ledger or something.
00:11:50.392 - 00:11:58.088, Speaker A: You can have a Bravo signer, Argentin, whatever, that's signed stuff. And then you have a contract which is on chain.
00:11:58.264 - 00:12:05.752, Speaker C: This is the account and the signer. They are two different things. We should be separating them because they are separated.
00:12:05.896 - 00:12:07.504, Speaker A: One account should be able to work.
00:12:07.542 - 00:12:42.612, Speaker C: With a lot of signers. And these signers are not limited to single signers, single key signers. Maybe in the future we can have multi signer. Maybe there's one signer that's connected to multiple keys that they will kind of collect initiatives before putting on chain, because it's a multisig or something. Different accounts needs different signers. And in stocklight, you actually see how this is actually cleanly separated. Actually, last feature is that this may.
00:12:42.686 - 00:12:56.224, Speaker A: Look, it doesn't make sense right now, but I will show you what it means. This is like argument input expansion, meaning that this actually makes your life much easier when you input stuff. But yeah, it's kind of hard to.
00:12:56.262 - 00:13:02.770, Speaker C: Actually talk about this without actually demonstrating it. So maybe let's just start the demo.
00:13:06.520 - 00:13:54.400, Speaker B: Okay, sorry, I had a quick question on the previous slide when you mentioned the account signer separation. Can you throw a little bit more light about that for people? Maybe? I'm sure folks know that starknet has native account abstraction embedded at the protocol level. That means every account that you create is actually a smart contract account. But can you share maybe an example of how the account and signer separation sort of happens? Like what could be a potential scenario where an account could be different than signers that are required to sign a particular transaction?
00:13:55.080 - 00:14:13.240, Speaker A: Okay, yeah, I think it's actually a bit more complicated than that. I would say an account is, again, all accounts are smart contracts. They can have any logic they want, and this is not necessarily bundled.
00:14:17.420 - 00:14:18.024, Speaker C: Right.
00:14:18.142 - 00:14:29.084, Speaker A: So the way I was trying to say it is that the current CLI actually puts something into a file. And that's like bundling each of the.
00:14:29.122 - 00:15:00.456, Speaker C: Private key and thing as if it's some ethereum account on day one where you have one private key, you always have this address, and things are like. I think that's not helping in terms of getting people to understand account abstraction. So I actually split them. These are already separated on the blockchain, on the network in the first place. It's just the mental model of what.
00:15:00.478 - 00:15:01.688, Speaker A: I'm trying to build here is a.
00:15:01.694 - 00:15:36.508, Speaker C: Mental model that helps people understand and realize this is the difference. When they use this, they will clearly understand that this is kind of separate because I want to break this one to one impression because with the current model, you have this, like, I have this key and this key belongs to this account. This is not right. This is not right. I mean, on layer one, this is correct, because there's always a one to one relationship. But on layer two, at least on spotnet, this account obstruction, this is not right. You can have one key that signs for ten accounts.
00:15:36.508 - 00:16:15.208, Speaker C: This is not something that you can do on layer one. But with the current CLI, the mental model is that, hey, I have this key and this key belongs to this account. And it's always the case. Obviously, I'm not changing anything on the network because this is just a CLI. But what I'm trying to talk about is the mental model and the design of the CLI that makes you think about, makes you realize, hey, this is actually something different. And in terms of backing up data, this matters a lot as well. When you backup data, for example, I'm.
00:16:15.224 - 00:16:39.780, Speaker A: Sharing to a new computer, a new phone, I need to back up my key. But what's important here is that you don't really have to backup your account because the account is something on blockchain and your key is what's actually the secret. But with the current implementation, you have the account and the key bundled together in a single file. So you are backing up everything. But this is actually not strictly the case.
00:16:39.850 - 00:16:58.030, Speaker C: And it actually confuses people. Backing up everything is nice, don't get me wrong, but it actually confuses people in the sense that for users that are not familiar with how things actually work, they would be asking themselves, hey, what should I back up? Actually.
00:17:00.880 - 00:17:05.296, Speaker A: It hides away the complexity, and I don't like the fact that it.
00:17:05.318 - 00:17:15.004, Speaker C: Gets hidden away in that it doesn't really help in terms of getting people to understand account obstruction and understanding what's.
00:17:15.052 - 00:17:21.190, Speaker A: Actually important that they need to backup and et cetera. Hope that answers the question.
00:17:21.640 - 00:18:16.550, Speaker B: Got it? Yeah, that's an interesting take, because I think right now the way CLI works is that people think that it is similar to an EoA sort of concept where you just create an account and then you have something associated with the account which is backed up like your key pairs or something on like a JSON file that you find on your computer. But however, the whole idea of account abstraction is the fact that you can deploy accounts that can do more than just sign for a transaction. You can have an account that by default has multicols, that by default could be multi signer and all of that. And I think, as you mentioned, that some of these capabilities are probably not highlighted in the way the current CLI functions. And I'm excited to see how what you have built sort of could potentially bring this.
00:18:20.920 - 00:18:57.524, Speaker A: Yeah, I would agree. And I would say with the current iteration of startlight, it doesn't really support multi sign and everything. The, the way that I designed this to be separated is kind of like setting the stage to have it supported in the future. Because for every startlight user, they will know they have to have this mental model that they separate things and they will easily accept, and they will easily learn how to use signer feature in the future, because that's just really just swapping out the signer part for a different implementation, and they should be able.
00:18:57.562 - 00:19:03.936, Speaker C: To kind of easily start using it. So that's kind of like not supported.
00:19:03.968 - 00:19:08.490, Speaker A: Today, but it's a high level design decision, I would say.
00:19:09.740 - 00:19:13.384, Speaker B: Got it. Awesome. Yeah, I'm looking forward to the demo.
00:19:13.582 - 00:19:16.440, Speaker A: Okay, so let's proceed to the demo.
00:19:16.510 - 00:19:22.120, Speaker C: And I think I will need to kind of share the screen for this window.
00:19:23.760 - 00:19:51.520, Speaker A: I think I shared it. Okay, now we have the window for the terminal. And the first thing I'm going to demonstrate here is obviously the installation. Without installation, we can't really do anything. So from the GitHub repo, you will find this command, and I'm just going to type it out because it's short, this command. You just have to paste this command into your terminal.
00:19:51.600 - 00:19:53.104, Speaker C: If you want to inspect the installation.
00:19:53.152 - 00:19:58.344, Speaker A: Script before you proceed, which you should, you can do that. But if you just want to get.
00:19:58.382 - 00:20:04.584, Speaker C: Things done, this is how it would work. It's super easy and you just hit.
00:20:04.622 - 00:20:08.328, Speaker A: Enter and it downloads what's called the start light up.
00:20:08.414 - 00:20:10.504, Speaker C: As you can see here, the start.
00:20:10.542 - 00:20:11.988, Speaker A: Light up is being installed.
00:20:12.084 - 00:20:16.296, Speaker C: And you just have to do something to start a new shell.
00:20:16.488 - 00:20:25.100, Speaker A: Right now here, I don't have to start a new shell because I already done this before. Then after this, you just have to run start I up whenever you want.
00:20:25.170 - 00:20:35.264, Speaker C: And that curl step. This one here is actually a one time process. You don't have to do this anymore. Once you get the star I up. So once you get Starlight up, you.
00:20:35.302 - 00:20:53.876, Speaker A: Just have to run Starlight up. And for starlight up, it basically just updates the start installation. It always gets you the latest installation. Whenever something's not working. Maybe there's a bug or something. Maybe you can try starlight up first to make sure you're actually using the latest version and make sure the bugs.
00:20:53.908 - 00:21:12.680, Speaker C: Is still in the latest version. And then you can maybe file a bug or something on GitHub. And once you run this, it automatically detects your platform. You say you are on Linux, you are on X 86 or something. By the way, this is a remote, so I may appear to be on a map of this is remote, so.
00:21:12.770 - 00:21:23.068, Speaker A: It says it's a Linux, it downloads the latest Linux. And note here that it actually gets shell completion generated for bash and Zsh.
00:21:23.164 - 00:21:29.570, Speaker C: For you, which should cover the majority of our users. And then there you go.
00:21:29.960 - 00:21:36.164, Speaker A: Installation is now complete. If you run Startlight version now you will see hey, we have stoplight and.
00:21:36.202 - 00:21:39.888, Speaker C: This is the version number which matches with what we just installed.
00:21:39.984 - 00:22:04.350, Speaker A: And whenever you actually, maybe there's a new version coming out. Of course there's no new version coming out right now, but you can always run this command again and you always get this same setup again. So whenever you just want to see, you see a new version of something, you just run this. And there you go. And here, that's for the installation part. Like I mentioned, it's extremely easy.
00:22:06.240 - 00:22:46.510, Speaker C: If you run stock light up, it doesn't download a valid version. Or maybe it says unsupported platform. There's no problem because you can always install from source and that does require some trust knowledge in terms of installing rust and using cargo. But the code base itself of Starlight is extremely portable, meaning that it should be able to install on anything. I tried it on my Android phone and something, and it works and everything's working. So basically on any platform you should be able to do this. But yeah, the installation process will be a little bit more difficult if you choose a platform that's not that popular, but that's kind of a given.
00:22:47.840 - 00:23:10.240, Speaker A: Now let's move on to the shell condition demo. So I just mentioned that you can actually have shellcovision working out of the box. What I mean is that when you type something like this, first let's go to the help screen. Actually you will see the help screen here that we pick up a lot of. Maybe Tmux is not working very properly.
00:23:10.400 - 00:23:25.784, Speaker C: Okay, so with startlight here, you can see a lot of commands. Maybe let's just try selector the first command actually here so we can type startlight and actually se.
00:23:25.982 - 00:24:16.004, Speaker A: And then when I hit tap it gives you this automatically and you don't have to type the whole thing. And this makes the whole experience much nicer as long as you're on bash and you're on DSH. There are actually a few other supported shells, including Powershell and maybe some other shells, but those are not automatically configured right now, so you have to set it up manually. But once you do you will get the same experience of automatic completion and you can actually even the flags would support completion as well. For example, for this command, the only flag supported is help. So when I add to double dash I will just get help automatically. And this is the demonstration of the shell configuration.
00:24:16.004 - 00:24:42.364, Speaker A: It makes it much much easier to use the commands as we will also see going forward when we demonstrate other features. And the next one, this is an interesting one. So we have the backend agnostics support for JSON PC and sequence API. What do I mean by that? Is that for example, let me try a combined, let me try block number. This really just fetches the latest block.
00:24:42.412 - 00:24:50.896, Speaker C: Number of the network for you. But where we fetch it from is what I mean by backend by default.
00:24:51.008 - 00:25:07.636, Speaker A: If we don't give it anything, it will show a warning and it says hey, no valid provider option found. Falling back to use the sequencer gateway for quality one and it gives you a broad number. What this means is that hey, sequencer.
00:25:07.668 - 00:25:22.744, Speaker C: API is really not recommended. You should use JSON IPC, it will give you a warning, but then you will happily continue to use that because maybe you have a good reason to use that. And if you want to be explicit.
00:25:22.792 - 00:25:28.384, Speaker A: About this, this is equivalent to using network quality one, this is the same.
00:25:28.422 - 00:25:33.216, Speaker C: Thing as you can see that the block number is actually the same. And if we can actually change the.
00:25:33.238 - 00:25:48.852, Speaker A: Network as well, quality two, we will see the network. And we actually see here that the quality to feed the gateway is extremely slow right now, and I believe software is running some stress tests on that network.
00:25:48.916 - 00:25:53.560, Speaker C: And this is kind of like expected, I would say. So maybe let's try mainnet.
00:25:56.310 - 00:26:08.614, Speaker A: Okay. Somehow Minnesota seems to be, oh, it's not that slow, actually, it's faster than maybe Minnet is under stress right now. So as you can see here, all.
00:26:08.652 - 00:26:29.674, Speaker C: You have to do is to specify a network and if you don't give one, you get already one. And this can be actually be specified via an environment variable flag as well. So you can actually set this up in your shell profile so you don't have to type it every single time. So for example, if I do this network equals minnet, I run this same.
00:26:29.712 - 00:26:38.010, Speaker A: Command, there's a typo and you get this same result. So you can actually set the network.
00:26:38.090 - 00:26:49.294, Speaker C: Through a environment variable or a flag as you wish. But then this is not really what this is about, because the current CLI.
00:26:49.342 - 00:27:14.154, Speaker A: Can already work with gateway. So what we have here is actually more interesting. We have another flag called RPC, which I already have behind the scene, I already have another variable that contains the URL to my node, which I'm going to replace here with the environment variable here.
00:27:14.272 - 00:27:16.058, Speaker C: And if I do this, as you.
00:27:16.064 - 00:27:18.826, Speaker A: Can see, it's much, much faster compared.
00:27:18.858 - 00:27:20.590, Speaker C: To when using the sequencer gateway.
00:27:20.930 - 00:27:39.426, Speaker A: Okay, sometimes maybe some, okay, maybe it's just some network problem on my side. Yeah, but then it's working. And there you go. Okay, looks like there's some network issue on my side, but maybe we just stop using RPC right now.
00:27:39.448 - 00:27:49.078, Speaker C: But we saw a few successful implications there that we can actually see that the RPC is working. And for JSON RPC it's actually the.
00:27:49.084 - 00:28:12.254, Speaker A: Same, that we can actually also use the stock net RPC. The environment variable as well is also going to work, though I'm not sure if it's going to work in this case. It works. The network program is always there. So you can see here, what we can do here is that we can set up in our shell profile, either.
00:28:12.292 - 00:28:25.250, Speaker C: We set an RPC or we set a network, depending on what you want to use, maybe JSON RPC, maybe sequencer gateway, and then for subsequent invocation we will just be doing this stoplight broad number.
00:28:25.320 - 00:28:45.618, Speaker A: So for example, because the RBC doesn't seem to be working very well, so I will just be doing this anchorly one, once I export this to my shell, or maybe I should sit down in my shell profile, I can just do this, and it's always going to work automatically. And this is the back end of the startlight.
00:28:45.714 - 00:28:47.286, Speaker C: What it does behind the scenes is.
00:28:47.308 - 00:28:50.886, Speaker A: That startlight is actually 100% JSON RPC.
00:28:50.918 - 00:28:55.766, Speaker C: Centric, meaning it's only able to deal with by default.
00:28:55.798 - 00:29:14.110, Speaker A: On the surface, it's only able to deal with anything that's on JSON RPC. But what happens here behind the scenes is that whenever it's asked to use the sequencer gateway, it will go to the sequencer gateway, send the requests, and then convert the responses into the format that's expected by JSON RPC.
00:29:14.190 - 00:29:42.438, Speaker C: And then startlight itself would interpret it as if it's coming from JSON RPC. So actually, from the perspective of startlight, at least from the processing, the logic layer, it makes no difference where the data comes from, it's actually unaware of where the data comes from once it gets past the network layer. Once it gets past the network layer, everything gets translated into JSON RPC format.
00:29:42.534 - 00:29:50.030, Speaker A: And of course if it already comes from JSON RPC, there's no translation required. But if it comes from sequencer, then it gets translated.
00:29:50.610 - 00:30:01.520, Speaker C: That's why it's able to work with both. And that's also why it's limited to what the JSON RPC spec is able to offer. Actually, there's something missing from JSON RPC spec right now.
00:30:03.190 - 00:30:23.080, Speaker A: For example, the execution resources, the number of steps, the number of something is actually missing in the design pc specs compared to the sequencer gateway. So from the design pc specs, there would be no way for you to tell how many steps steps were used for this specific transaction. But then I hope that by using.
00:30:23.930 - 00:30:57.540, Speaker C: When you are using stocklight, even if you use the sequencer API, there will be no way you get those data because everything gets converted into JSON RPC first before being processed. But I hope that the adoption of stocklight will actually force it the other way around, meaning that we will actually be able to force everything to be added to the JSON RPC spec first before it gets added to the sequence of gateway somehow. So that we basically make sure that JSON RP spec is actually better off over time, because this is the thing that we are going to use over time.
00:30:58.710 - 00:31:19.066, Speaker A: So this is to demonstrate that you can use both back end at the same time. It doesn't really matter what this is coming from. Okay, then maybe we can move on to the next feature to demonstrate, which is the account separation. So what I'm going to do here is.
00:31:19.248 - 00:31:43.140, Speaker B: Sorry, Jonathan, just quick question. So you mentioned that we can add like a RPC flag to add this. So basically right now, does it support the ability to use our own JSON RPC as well? I think even going in the future when people start running their own.
00:31:48.230 - 00:31:52.654, Speaker C: If you actually look at this here, this is my own RPC.
00:31:52.782 - 00:31:53.362, Speaker B: Okay.
00:31:53.496 - 00:32:01.046, Speaker C: I'm just making it easier to read for people that hide their weight, but this is my own RPC and it's working 100%.
00:32:01.148 - 00:32:03.090, Speaker A: So this is not inferior.
00:32:03.170 - 00:32:03.750, Speaker C: Yeah.
00:32:03.900 - 00:32:05.160, Speaker B: Okay, awesome.
00:32:08.910 - 00:32:13.062, Speaker A: We are actually encouraging people to use their own office anyways.
00:32:13.126 - 00:32:17.180, Speaker C: So this has to be supported from day one.
00:32:17.630 - 00:32:20.986, Speaker A: So the next one is account signing separation.
00:32:21.098 - 00:32:23.662, Speaker C: And instead of just talking high level.
00:32:23.716 - 00:32:25.342, Speaker A: About how this should be separated now.
00:32:25.396 - 00:32:34.420, Speaker C: I would just demonstrate from end to end how you create an account in the first place and then how you start using this account. And here.
00:32:37.190 - 00:32:45.046, Speaker A: I've started to ask the audience to think about when you create an account, what do you do first? You have to have a key first.
00:32:45.148 - 00:32:50.022, Speaker C: That's what you do in the first place. So in startlight you have to do.
00:32:50.076 - 00:33:00.166, Speaker A: Something called creating a signer. And these commands are exposed. In the signer command there's a subcommand.
00:33:00.198 - 00:33:20.618, Speaker C: Called Signer that has a few options. Right now, the only one that's actually helpful here is the keystore. Keystore is actually invented by stocklight because up until stocklight invented this, there was no way to securely store a private key for Stopnet.
00:33:20.794 - 00:33:25.778, Speaker A: If you look at the current CLI, look@the.net accounts file. The private key is stored in plain text.
00:33:25.864 - 00:33:27.758, Speaker C: So it's like in a way secure.
00:33:27.934 - 00:33:34.326, Speaker A: Anyone getting access to your file, you're doomed. So startlight brought this keystore into the.
00:33:34.348 - 00:33:37.494, Speaker C: Space and essentially not too much.
00:33:37.532 - 00:33:51.610, Speaker A: I mean, startlight didn't invent Keystore, it just brought Keystore into the space. Because Keystore has been around for a while, it's been available for other blockchains, for Ethereum, but there was no library using it for startlight, start. Net.
00:33:51.680 - 00:33:54.940, Speaker C: So startlight was the first to actually make use of.
00:33:56.510 - 00:34:08.366, Speaker A: And right now this is the only supported option. For the actual useful supported option, of course you can use a plain text if you want, but in the future what you have is that we will.
00:34:08.388 - 00:34:35.086, Speaker C: Have multi signer signer support. We have like hardware signer, one ledger as support for Startnet, which I've been waiting forever. So we will have more sequence here once we get those. But for now, the only thing and the one that you are actually recommended to use is the key store, which is an encrypted key store that you can save as a JSON file.
00:34:35.218 - 00:35:08.546, Speaker A: And I'm going to demonstrate here the key store, the command here you can create a new key store. You can create a key store from an already existing key. This is useful, maybe when you are importing an account from somewhere else, maybe from the current ClI, and you can inspect the public key or the private key of a key store file. It's pretty straightforward. And maybe let me just create a new key store. And when I create a new key store, I will have to provide an option. And you can actually also see one big difference from the current ClI is.
00:35:08.568 - 00:35:14.834, Speaker C: That the current ClI, whenever you give it a help flag, what you get is extremely unhelpful.
00:35:14.882 - 00:35:43.854, Speaker A: I would say you just get a bunch of text that's hardly useful. But right now, here for each command, and I remember you actually get pretty much the same thing, whatever, which command you append the help for. But here it's actually context based. You can actually see like it knows you are using the new command. It knows that this is the command you're using. So it actually gives you helpful options and arguments that are specifically for this.
00:35:43.892 - 00:35:49.130, Speaker C: Command, which is kind of expected for Cli.
00:35:49.290 - 00:36:17.994, Speaker A: And then maybe I will create the file to save the key store here as demo key Json. And it asks me for a password, and I'm just going to do some password. And I created my encrypted key store file here at this location. And I can see my, maybe just let me find it so that it's easier to read. Okay, I can open my newly created key here.
00:36:18.032 - 00:36:30.586, Speaker C: So this is the key I created. And this is like encrypted. There's a cipher text here. This is the encrypted key here. So it does not expose randomly.
00:36:30.698 - 00:36:48.354, Speaker A: So I will also be able to inspect the key, the key address created. And when I do it, of course, it will ask me for a password. I enter the correct password, you'll be able to show me the public key, which is the same one, of course, the same one as what I just created. And this is the key.
00:36:48.472 - 00:37:01.320, Speaker C: And it does nothing more than just being a key. It can be used to power an account. And this is the part where we actually create an account. And now that we have a key, we'll create an account.
00:37:02.090 - 00:37:09.370, Speaker A: The account part is actually completely separated from the signing. It has another command that's called account.
00:37:09.520 - 00:37:34.882, Speaker C: And this is exactly what I was talking about when I was saying like, hey, this is in stocklight. This is clearly separated. When you are in the current CRI, when you create an account, everything gets taken care of magically. But that's actually unhealthy, in my opinion, because you don't know what's going on. But right now, here, when you create an account, the CLI will actually ask.
00:37:34.936 - 00:37:46.402, Speaker A: You which signer you want to use so you actually know what you are doing. You know, like, hey, these are two separate things. This account is powered by this signer.
00:37:46.466 - 00:37:55.510, Speaker C: But this another account could also be powered by the set signer if I choose to. That's really the part where it matters.
00:37:57.210 - 00:38:01.478, Speaker A: Here. What I'm going to do is that I'm going to show you the help command.
00:38:01.574 - 00:38:38.958, Speaker C: So under account, there are a few commands. Right now, we are going to look at the Oz account, which is for managing open zeppelin accounts. This is also one notable difference between a stock like CLI and maybe something for Ethereum that you can actually manage accounts of different flavors. This is what I call flavor. Oz is the only supported flavor right now. But going forward we will be supporting argin and Barbo and other water contracts as well. So you will be able to deploy an argin account or something from directly without using something.
00:38:39.064 - 00:38:47.162, Speaker A: So maybe we look into Oz and we can see the only supported command here is really just init, which is.
00:38:47.216 - 00:39:01.680, Speaker C: The creation of an account file. This is actually something that someone new to starnet will find kind of confusing. Why would I have to initialize an account? But this is just kind of something.
00:39:02.130 - 00:39:34.054, Speaker A: That stopnet is like. Maybe something with account abstraction is kind of special about. And maybe it's clear if we just go through the process. So we go to this stoplight account, OC init and then I will do a demo account, JSON and this actually creates an account. But if you actually go with this, it will tell you there's no valid signer option file. Because again, you cannot just create an.
00:39:34.092 - 00:39:36.754, Speaker C: Account, you have to give it a key.
00:39:36.892 - 00:39:58.286, Speaker A: And the key has to be something that you already created before. And the only signer that supported right now is the key store. So we just do key store and what we just created the demo key. And when you do this, startline will ask you for the password. Not because it needs to sign something, but when you create the account, it.
00:39:58.308 - 00:39:59.874, Speaker C: Needs to know the property key.
00:39:59.992 - 00:40:14.166, Speaker A: So this password here is just for knowing the property key. So when we enter the password, this is actually something interesting. You see, you have created a new account config file, which is demo account.
00:40:14.268 - 00:40:19.254, Speaker C: Which is something that we asked for, which is expected, but it also gives.
00:40:19.292 - 00:40:39.246, Speaker A: You the address once you deployed it. How does this work? If you look at the demo account file, we will actually see that it records the variant, which is the open Zeppelin type version. This is just for making sure it's backward compatible, but public key, this is.
00:40:39.268 - 00:40:47.946, Speaker C: The public key that we just created. And then for deployment the status says undeployed. It's a contract that's not deployed.
00:40:47.978 - 00:40:54.814, Speaker A: It's only created locally because no transaction has ever been sent out. This is again a notable difference between Starnet and Ethereum.
00:40:54.862 - 00:41:04.718, Speaker C: Ethereum, you generate a keypad and then you have an address that address is ready to use. Not no further action required. As long as you have money inside, you can send out stuff.
00:41:04.824 - 00:41:13.870, Speaker A: But for this it's going to start out with an undeployed status and it's not going to be very helpful until you do it. And then there's a class hash that's.
00:41:13.970 - 00:41:35.662, Speaker C: Generated when we chose the Oz flavor, which is the only flavor right now, and there's a salt that's automatically generated. These three things together actually determine the address. And it's important that this is generated at initialization because once this changes, the.
00:41:35.716 - 00:41:44.558, Speaker A: Address will change in the standard account deployment process. We will need to fund the account. So if the account address changes, it's.
00:41:44.574 - 00:41:49.374, Speaker C: Going to be extremely problematic because it means that whatever you fund it into, the account is lost.
00:41:49.502 - 00:41:52.558, Speaker A: So this is persisted at this stage.
00:41:52.654 - 00:41:56.966, Speaker C: And for now this file is extremely important that you need to backup if.
00:41:56.988 - 00:41:58.518, Speaker A: You already have money in it, but.
00:41:58.524 - 00:42:05.640, Speaker C: You haven't deployed the account because once this file is gone, there's no way you can get back. This sort, this sort determines the address.
00:42:06.170 - 00:42:32.898, Speaker A: And it actually comes with help tat that says hey, you can deploy this account by running this command. And if you run this command, it will say hey again, no value sign option provided, but you can actually do something like you can give it the same thing, demo key, and then it will ask you for the password. And then here's another screen.
00:42:32.984 - 00:42:42.194, Speaker C: This is the account deployment experience of startlight. So you create a key first and then you create an account.
00:42:42.312 - 00:42:45.320, Speaker A: And for the account file you have to deploy it.
00:42:45.770 - 00:43:09.550, Speaker C: And notice here we don't have to say startlight account, oz deploy, you don't have to because it's already in the file. And startline knows is an oz account once you initialize it. And for this you just have to say deploy this account file. You give it a valid signer, it's able to sign something out of this signer so that is able to send our transaction and then it will say.
00:43:09.620 - 00:43:24.898, Speaker A: Hey, we got your key and we help you do the estimation of the transaction fee. And this is the estimated fee, but you should give it a buffer and fund something like this to this address.
00:43:25.064 - 00:43:48.700, Speaker C: And it asks you to press enter once you fund it, this whole thing, and then it will proceed to actually do the thing and send out a deploy account transaction type. But we are not going to proceed here because this account we just created has no funds inside. But I do have another account. Let me just remove these two.
00:43:49.230 - 00:43:54.700, Speaker A: I do have another account that's account funded here that has already been funded using another key.
00:43:55.150 - 00:44:11.570, Speaker C: As you can see it's also undeployed. So I didn't deploy this one, but this is just for demonstration purposes. I created this key in advance, this account in advance. So maybe we should repeat this same command, but instead of using that thing we use this account funded.
00:44:13.270 - 00:44:17.042, Speaker A: And this will work. And here is what I would like.
00:44:17.096 - 00:44:20.466, Speaker C: To also show you something that you.
00:44:20.488 - 00:44:22.434, Speaker A: Don'T really have to type this out.
00:44:22.472 - 00:44:30.630, Speaker C: Like the whole thing every single time. There are environment variables that help you with that. And for example there's a stopnet keystore.
00:44:31.290 - 00:45:04.946, Speaker A: This environment variable is helpful in that it actually saves you this. You don't have to do this anymore. And we can do like the current directory key JSon. And once you export this, whenever you run this command again, even if you don't give it the key store, it's still going to work and we're going to try it right now. So once we enter the password it gives you the same screen and then because we've already funded this ahead of time we can just press enter and.
00:45:05.128 - 00:45:30.282, Speaker C: It'S going to be sending out a transaction. And once it send out the transaction it automatically waits for the transaction to finish. And once it confirms, meaning that the transaction goes from received to accepted on l two it says hey, the transaction has confirmed and your deployment of this account has succeeded. And if we look at the account funded again, you see the status here.
00:45:30.336 - 00:45:33.914, Speaker A: Changes deployed and actually the slot is.
00:45:33.952 - 00:45:40.640, Speaker C: Gone and instead we have an address here, this is a deployed address and.
00:45:41.250 - 00:45:47.550, Speaker A: We will be able to start using the account from this address and this account file.
00:45:47.890 - 00:45:51.134, Speaker C: What's interesting about stocklight is that once.
00:45:51.172 - 00:45:55.654, Speaker A: You deployed it, this whole account file no longer matches.
00:45:55.802 - 00:45:57.026, Speaker C: You can delete it, you don't have.
00:45:57.048 - 00:46:01.826, Speaker A: To back it up because it's already on chain. The only reason that it used to.
00:46:01.848 - 00:46:05.086, Speaker C: Be important is that that information wasn't.
00:46:05.118 - 00:46:29.658, Speaker A: Available once you delete it because the source is random, there's no way you can get it back. But once you do this, I'm going to demonstrate right now. We already know the address is this one. What if we delete this thing, our account is gone, right? We don't know how to use it. But that's not true. We already have its address and we can do something. There's another command called stop account fetch.
00:46:29.658 - 00:46:51.826, Speaker A: It fetches the account file for you, but it only works if it has already been deployed obviously. And we can do this, paste the address here again. We can use output account funded through the same account name, same file name as before. And once we hit it says hey.
00:46:51.928 - 00:47:19.406, Speaker C: Account contract type identified as open zeppelin. And we know this account contract opens up in 0.6.1 compiled with open rob or something. It recognizes what this account is. And this command, this whole thing here works solely with onchain data, so it does not need anything from your local stuff. You can have a fresh installation of startlight, nothing else. And then you run this command, it's going to get you the same file as before, and if you want to.
00:47:19.428 - 00:47:23.422, Speaker A: Check out the content, it's exactly the same as before.
00:47:23.556 - 00:47:28.400, Speaker C: We just deleted this thing and then we fetched it from onchain data. So.
00:47:30.930 - 00:47:34.242, Speaker A: This really helps with migration and things.
00:47:34.296 - 00:47:37.586, Speaker C: For example, if you have an argin account, you want to use it on.
00:47:37.608 - 00:47:39.938, Speaker A: Startlite, no problem, you just have to.
00:47:40.024 - 00:48:36.710, Speaker C: Copy the address, you fetch it from startlight, you have this whole thing, you don't even need a key, you just need the address and you fetch it and it generates this entire account file for you. And you are going to be able to use this account file to do a lot of stuff. And of course to actually send out transactions. Of course you would absolutely need the key as well, but just for the account itself, as you can see, as long as you have the address, you don't have to worry about backing up the file once it's deployed, it's on chain and everything else is inferred from onchain. And how does stoplight get access to the public key and something? Well behind the scenes, stocklight will look at the address you provided and look for the class hash. And then once it gets the class hash, it will be able to actually see the public key because it's able to recognize this and open japanese account. And then of course the relevant function to figure out the public key.
00:48:36.710 - 00:48:43.494, Speaker C: And the philosophy behind a startlight is that everything should work very easily and.
00:48:43.532 - 00:49:29.622, Speaker A: You don't have to worry too much about stuff. And as you will be able to see, for example, now that we have an account, yeah, we can use this account and there's another flag for this, you can actually export another environment variable. That's net account equals I'm going to do this. And once we do this, we are able to use it without anything, without providing the account flag at all. No account flag, no key, store flag, and every command. We just look extremely simple. And for example, we can declare a class, there's a lot of things we can do with this account.
00:49:29.622 - 00:49:33.174, Speaker A: We can declare a class if you want. And to show you that startlight is.
00:49:33.212 - 00:49:41.194, Speaker C: 100% ready for zero point twelve, we will declare a chiro one class and a chiro one class that's compiled with.
00:49:41.392 - 00:50:19.640, Speaker A: 2.0 compiler which is only supported on 2.0 actually the compiler. And what we're going to do here is that start by declare, it's really just as simple. And I want to show you that we can actually deploy declare both class zero class and Carol one class at the same time. And you don't have to worry about how it works behind the scenes because all you do is this subway declare this class file. And once you hit this, I should be adding the watch flag as well because we want to watch the transaction to finish.
00:50:19.640 - 00:50:36.922, Speaker A: And I enter the password, it's able to figure out which key store to use because I gave it the environment variable. And then now we hit enter, it says hey recognize, this is a deprecated Kyro zero class and we figure out the hash. And now we are sending out a deployment transaction.
00:50:36.986 - 00:50:55.490, Speaker C: And this is slow because the sequencer gateway needs some time to figure out the class edge and it's going through. And then it sends out a declaration transaction and then it waits for the transaction to confirm. Simple as that.
00:50:55.560 - 00:51:35.722, Speaker A: You don't have to say hey, declare legacy, declare that. No, startlight knows what you are giving it, so it's able to figure that out. And for Cairo one it's a bit more work if you are using the current CLI. A lot of people actually complain about deploying Chiro one class is messy because you have to go through the process of getting the serial class first, and then you have to also get the custom class and you have to use the right version of the compiler to actually get that to make sure you are not using an old version. Because even if you compile with the old version, the sequencer will be running a different version.
00:51:35.786 - 00:51:40.082, Speaker C: And then when you submit it will say hey, the custom hash you are providing is wrong.
00:51:40.216 - 00:52:28.186, Speaker A: And with startlight, nothing like that you have to worry about. You just do this same thing, same combined with carrot one carrot one class. And what happens behind the scenes is a little bit more complicated, as we will see. But as you can see here, once we hit this not declaring, it's already declared, because right now the network no longer allows declaring the same class. But we can treat here, we just change the API here to bump this number and then we pretend it's a different yeah, so now it's different class and we can declare it again. And once you declare it, it says hey, we are actually figuring out which network you are on and it says hey, you are on grody one. Okay, we are using the default compiler.
00:52:28.218 - 00:52:59.210, Speaker C: Version for you, which is 2.0.1, and you can change it if you want. It actually figures out a custom hash for you by using this 2.0.1 compiler and the declaration sent out and you get the class has declared. And what's amazing about this process is that you don't even have to install the Kyo compiler. It says it's using the Kyo compiler, version 2.0.1. But what happens is that startlight comes bundled with the Sierra compiler.
00:52:59.210 - 00:53:13.566, Speaker C: What this means is that you don't have to worry about installing, you don't have to worry about installing it in the first place. That means if you already have a compiled class Sierra class, somehow, if you want to declare it, you don't have.
00:53:13.588 - 00:53:42.120, Speaker A: To do anything like installing rust. You don't even have to install rust or the Chiro compiler, nothing like that. You just have to guess. Startlight, it comes with the compiler bundled and it's able to choose between different versions. So for example we can like yeah, again this already gets declared, so we will have a cheat again. We change this number again to make it a different class. And hey, what if we deploy it again but we use a wrong compiler version? We use 1.1.0.
00:53:42.120 - 00:54:01.162, Speaker A: Well you fail. You end up failing because Cairo 1.1.0 compiler isn't able to compile something compiled from the 2.0 compiler. So that's why this fails. But the startlight figures it out for you automatically.
00:54:01.226 - 00:54:11.586, Speaker C: So this is really an exception for those who know what they are doing. Like hey, I know this network I'm using here is actually using an old version. I know what I'm doing.
00:54:11.688 - 00:54:15.394, Speaker A: But by default startlight figures out everything for you.
00:54:15.432 - 00:54:19.106, Speaker C: And this is the experience of using startlight. You do something as simple as that.
00:54:19.208 - 00:54:41.206, Speaker A: And startlight declare and that's it. The experience is like you just do what you want and startlight figures out every single detail for you and it actually chooses the different compiler version depending on which network you're on. And that's a good thing because you don't have to worry about them anymore. We just want to hide these complexities from the users.
00:54:41.238 - 00:54:43.254, Speaker C: I mean, the account signer separation complexity.
00:54:43.302 - 00:54:45.302, Speaker A: Is a necessary evil because they don't.
00:54:45.366 - 00:54:59.370, Speaker C: Understand how things actually work. But things like this, like compiling a double, compiling the car one class into custom and figuring out which version to use and stuff like this is just like making the develop experience worse.
00:54:59.450 - 00:55:11.186, Speaker A: So we think these complexities are not worth exposing. So we actually try to do something like make things as easy as this. And one last thing to demonstrate, which.
00:55:11.208 - 00:55:23.790, Speaker C: Is the argument input expansion, which is hard to understand, but we will not no longer be in a second. So for example, we do something like this invoke, as simple as an invoke.
00:55:23.890 - 00:55:35.594, Speaker A: Which is quite straightforward, right? You invoke something, but here, for example, let's say I want to transfer some.
00:55:35.632 - 00:55:37.070, Speaker C: ETH to another address.
00:55:37.220 - 00:55:43.294, Speaker A: I can paste in the ETH address, and for example, I can do the.
00:55:43.332 - 00:55:55.826, Speaker C: Transfer, which is the function selector, and I will transfer the thing to someone with address x 1234, which is a non existent black hole address. And for the amount, because we all.
00:55:55.848 - 00:56:00.914, Speaker A: Know for the ERC 20 token, you have a recipient and then you pay.
00:56:00.952 - 00:56:11.030, Speaker C: An amount, but the amount is actually like two numbers. Actually, if you ever use this currency, you will know if you want to send 100 weight and you put this.
00:56:11.100 - 00:56:15.014, Speaker A: You get an error because innet u.
00:56:15.052 - 00:56:26.522, Speaker C: 256 is actually two numbers. This is the actual 100 number because this is the low 128 bits, and this is the high 128 bits. Because it's a small number.
00:56:26.656 - 00:57:00.274, Speaker A: The high bits are zero. So this is the correct amount. So we just do something like this and we watch it to finish. This is the default thing that you would be able to do with starlight. This is exactly, almost the same experience as the current CLI, which is bad. Who wants to memorize all these? And who wants to figure out these are two numbers? Fortunately, startlight has something to rescue. And for this same command here, let's.
00:57:00.322 - 00:57:02.840, Speaker C: Start with maybe this.
00:57:03.610 - 00:57:19.146, Speaker A: Who wants to memorize this and copy paste this from another place every single time? We already know this is a famous address. We all know this is the ETH address. And how about we just do something like this? This is what startlight supports.
00:57:19.178 - 00:57:37.166, Speaker C: This is what I mean when I say scheme based argument expansion. This will, at runtime, this gets expanded into what we just typed. But instead you have a scheme and you have a content. And then with this scheme, an ADBR, which stands for address, you guess expenditure.
00:57:37.198 - 00:57:55.094, Speaker A: Into the whole thing and we can do this again. I typed the wrong password, okay, and it works. And it's also sending out stuff to sending out ETh. Stoplight understands what this means and because.
00:57:55.132 - 00:58:00.306, Speaker C: It'S able to understand because it has a built in address book, a built.
00:58:00.348 - 00:58:09.630, Speaker A: In address book with famous address that are automatically hard coded into the CLI. Right now, Starlight doesn't support custom address.
00:58:09.700 - 00:58:18.430, Speaker C: Books yet, but in the future it will. And once it s, you will be able to do something like this. Addr Alice, no problem.
00:58:18.500 - 00:58:35.618, Speaker A: Because once you save it, you can actually save your own account into your address book. And then you'll be able to send stuff over between your friends and something. And you don't risk introducing typos in your commands because this gets expanded into something. And if you add something that's non.
00:58:35.634 - 00:58:47.306, Speaker C: Existent, it just says, hey, address books entry not fine for Addis, because for now there's no Addis and everything is just hard coded. But in the future this gets added and we'll be able to do that.
00:58:47.488 - 00:58:53.530, Speaker A: And this is just the beginning. Hey, what if I don't want to figure out this part?
00:58:53.600 - 00:58:54.934, Speaker C: This is too annoying.
00:58:55.062 - 00:58:58.026, Speaker A: And what we have here is, this.
00:58:58.048 - 00:59:36.502, Speaker C: Is still easy, you just have to add a zero behind. But what if this is a number big enough that you actually have to do the splitting between the lower and higher? You actually have two numbers, both are non zero. It's going to be extremely hard and very error prone. What if you swap the high and low and you screw up and you put the low here, put a high here, and you end up sending a huge amount. For example, I remember, maybe we should put high first and then something like this, and then you end up sending a huge amount. Of course for ETH this is not going to work because you should not be that rich. But for some other tokens maybe this works.
00:59:36.502 - 00:59:42.618, Speaker C: And then you end up sending a wrong amount of money. So there's another scheme called U 256.
00:59:42.784 - 00:59:47.994, Speaker A: And you just have to do this, u 256, and then you put a.
00:59:48.032 - 01:00:00.802, Speaker C: Number here, this thing here gets, and you can actually see here what we had here is like one to one expansion, but this here expands to two. It actually expands into 100 and zero.
01:00:00.936 - 01:00:12.034, Speaker A: So when we do this again, we are still on Alice. So we change back to ETh. And once we go, this is the.
01:00:12.072 - 01:00:34.326, Speaker C: Exact same transaction as we said before, and it works. The network never compare the sequence, it doesn't complain. Hey, this is missing one argument here. You're not giving enough arguments. It's because it's not the case. We actually have enough arguments because this expanded into 100 and zero. And this is like how this is going to help you type commise easier.
01:00:34.326 - 01:00:37.440, Speaker C: And this is actually not the end of it.
01:00:37.810 - 01:00:41.882, Speaker A: There are certain places that an address is always expected.
01:00:41.946 - 01:00:45.200, Speaker C: I mean, for these following things, maybe.
01:00:45.650 - 01:00:50.978, Speaker A: It'S not expected to be an address. It's not always an address. It could be a number or something.
01:00:51.064 - 01:00:51.940, Speaker C: But here.
01:00:53.750 - 01:01:18.714, Speaker A: The one that's right after invoke, this is always an address. And for this one you can actually even omit the addr prefix. You can just type something like this. And this is an extremely simplified command that you can actually see startlight, invoke eth, transfer some address, or maybe in the future we can even do addr lst and then an amount this gets turned into from a math that's like.
01:01:18.752 - 01:01:27.034, Speaker C: Hard to understand, into something that's actually usable. And zero is 1234 because Alice thing.
01:01:27.072 - 01:01:30.526, Speaker A: Is not supported right now, and then it still works.
01:01:30.628 - 01:01:34.030, Speaker C: That means stocklight understands that this means.
01:01:34.100 - 01:01:37.934, Speaker A: Addr Eth because it's able to figure out, hey, you are trying to type.
01:01:37.972 - 01:01:44.354, Speaker C: In an address and this is not actually a valid address, so it has to be an address book entry and.
01:01:44.392 - 01:01:47.182, Speaker A: It figures out an address book entry for ETH.
01:01:47.326 - 01:01:56.326, Speaker C: This is the kind of experience that you would get from startlight. If you find something that can be shortened and make easier and it's not.
01:01:56.348 - 01:02:38.180, Speaker A: Implemented, it should be considered a bug in startlight because this is something startlight is trying to offer, something extremely easy to use. And one last thing to demonstrate is that you actually have multi core support out of the box. Because this is startnet, you always have to have multicore support. And this is actually extremely easy. And it's as simple as repeating this part of the command and adding a separator. And a separator means a forward slash, a backward slash and a pipe or something. But I would personally use a forward slash, something like this.
01:02:38.630 - 01:02:44.706, Speaker C: Again, ETH transfer, I will transfer something to someone else, maybe I will approve.
01:02:44.738 - 01:02:56.550, Speaker A: Something on the second transaction and I will approve to zero X 4321 instead. And the amount here, I'm going to show you another scheme which is the const scheme.
01:02:56.630 - 01:03:09.662, Speaker C: There are a bunch of commonly used amounts or values that are just hard coded into the scheme and YouTube max is one of them.
01:03:09.796 - 01:03:31.042, Speaker A: And for this I'm really saying, hey, I want to send out a transaction that has two calls. One is to transfer something ETH and another is to approve the maximum value, basically the infinite value to be spent by zero x four, three to one of ETh. And I will do the watch here.
01:03:31.096 - 01:03:31.700, Speaker C: Again.
01:03:34.410 - 01:03:36.694, Speaker A: And it sends our transaction and.
01:03:36.732 - 01:03:41.174, Speaker C: For this one we actually go to the explorer to figure out what this.
01:03:41.212 - 01:04:13.298, Speaker A: Transaction, to actually see it by ourselves, that what this transaction is. As you can see, the transaction is now confirmed and I'm switching my demo to my browser tab where we will be able to see this 1 second and stop screen and present share screen. Yeah, this is the explorer tab. Yeah, we can see here.
01:04:13.464 - 01:04:18.306, Speaker C: This is the thing that we just sent out this same hash and it.
01:04:18.328 - 01:04:22.986, Speaker A: Got accepted and we can look at the course. This is the first call that's transferred.
01:04:23.038 - 01:04:36.114, Speaker C: Which transferred this same amount that we were intending. And the second one is approved, which is this amount. When we use hex to encode it, it becomes this, which is exactly the.
01:04:36.172 - 01:05:08.740, Speaker A: Maximum amount of one, two, three, v six. And you can see that this is a multicore transaction. It has transferred and approved. And all this in a very simple and very expressive way of simply adding a slash, adding a slash, another call, adding a slash, yet another core. This is the multiple core support with Starlight. It's very intuitive and easy to use and that's, I would say, pretty much what I'm going to demonstrate. And it's been longer than I intended because I actually still have a lot of issues.
01:05:09.510 - 01:05:19.766, Speaker C: But yeah, I will leave the rest for you guys to actually figure out yourself. Because right now the documentation of Startlight, yeah, this is worth mentioning actually this is quite early.
01:05:19.948 - 01:05:43.886, Speaker A: We're still working on the documentation, so the thing is working quite well. As you can see in the demo, everything is working pretty well. But the documentation is not ready. We are trying to get it ready before start SCC so that we can, because we are also going to have a workshop during start SCC for startlight. So we hope that by that time we will be able to have documentation 100% ready.
01:05:43.988 - 01:06:30.480, Speaker C: And because startlight is going to replace the current CLI officially, meaning that Startnet IO will be pointing to startlight and telling you to install startlight for interacting with the network. So we need to have documentation ready as soon as possible because it's extremely easy. It's going to be a lot easier for people to get started. So documentation will be ready as soon as this week, but then everything else is ready. The tool itself is ready and you can try it out today by installing it, installing startlite and then installing startlight. And things should work out of the not. Trust me, you will not miss the current CLi because it's just better in every way.
01:06:31.330 - 01:07:01.222, Speaker B: Amazing. Thank you so much Jonathan. And I am definitely going to go ahead and start using stack live because I've been waiting for something that can replace the current CLI. And after looking at this demo, it looks like there are a lot of cool features that I can try out. And then also some of the models are like, the commands are very similar to the older Cli. Like I just can invoke a function, call a function, deploy an account and stuff like that. So that's great.
01:07:01.222 - 01:08:01.494, Speaker B: And I think this distinction between signer and account or the clear separation as you mentioned, will also get people to sort of start wanting to dive deeper into how you can maybe use the same signer for multiple accounts, or how you can sort of mix and match and what are the different things that you can do. And that I think leads to more sort of a creative explosion, which is very interesting, keeping in mind that rest of the things are fairly simple to use. So this was super helpful. Thank you so much Jonathan. I know that we are a little bit over time, but I feel like it was totally worth it. And for those of you who are interested to explore starcly, I think there's a GitHub repository that we can point users to. And if there's any other resources that you think Jonathan will be useful, please do share it with me and I'll share it on the YouTube live stream.
01:08:01.494 - 01:08:14.000, Speaker B: Or if anyone has any questions, feel free to drop us a line on Twitter or Telegram or join one of our community groups. And we are always here to help you get up and running with.
01:08:18.530 - 01:08:26.734, Speaker A: Google. The GitHub link is just a special way, pretty easy to find, but I will send it to you and make.
01:08:26.772 - 01:08:30.560, Speaker C: Sure it's available for everyone who wants to take a look.
01:08:31.610 - 01:08:36.342, Speaker B: Amazing. Thank you so much once again Jonathan for joining us. And thank you.
01:08:36.476 - 01:08:37.750, Speaker C: Thank you for hosting.
01:08:38.170 - 01:08:44.760, Speaker B: Yeah, I hope you all have a great week and if you're coming to eat CC, then we'll see you all next week.
01:08:45.850 - 01:08:47.720, Speaker A: Yes, see you.
01:08:48.970 - 01:08:49.826, Speaker B: See you. Bye.
