00:00:02.970 - 00:01:21.350, Speaker A: Okay, so what is the art project? To understand what is the art project, we have to go back in time two years ago actually, and you have to imagine that a world where creators could create nfts, raise money, work hard and create value and actually earn fees. And then suddenly, boom, no more fees. Welcome to web free, at least centralized NFT marketplace. Web free NFT Marketplace having centralized order book lead to market fragmentation, that lead to market share war and that lead to disempowerment of creators. No more fees. So given that statement, with the art project, we aim to build a decentralized NFT exchange protocol to create the opposite effect, enforce creator rights, open order book share liquidity, open empower marketplace to help each other actually and get rewarded for that. This is where business meet infrastructure.
00:01:21.350 - 00:01:46.460, Speaker A: So the main component of the art project are an open order book, obviously trading APIs, NFT APIs, indexer and a forkable front end so you can bootstrap your own project. So to deep dive into the technical details, Pierre will explain you.
00:01:47.870 - 00:02:22.182, Speaker B: Yeah, so basically as Christoph said, building a decentralized order book has some challenges. And here we will give you a quick overview of what we have designed in the day. But it's evolved because we already have some feedbacks, some hacker house feedbacks and people feedback. So this is a design we will show you. It already evolved, but it's interesting to see how it works. So basically we can start with the user sending a transaction through a marketplace. And this marketplace will add like a signature just to be sure we know from which marketplace the order is placed.
00:02:22.182 - 00:03:28.842, Speaker B: And from this we can then send the transaction directly to the arc project contract on Stocknet. And when it's here, then we will run a nap chain to our l three where using the messages, the messaging of Stocknet, the event that is emitted on the message that is emitted on Stocknet will be certain on the arc chain. Okay, so the app chain, and once we have the message then we can process it, we can evaluate the order validity, et cetera. And then we can also go back on starknet using also messaging. So you know, messaging is working between Starknet and Ethereum, but we can also use it for an upchain and starknet. So basically when the order is placed it can then be executed, getting back on the starknet contract to move the assets then on the NFT or any other smart contract. So the idea here is we can do this with Stocknet and we can send the orders on Stocknet, but we can also work with appchains.
00:03:28.842 - 00:03:59.926, Speaker B: So here at the bottom, we can have appchains talking to the order book to send some orders. So the idea is having a share liquidity on this appchain. And any marketplace can came, any person can came and check what are the orders because it's all open, accessible to anybody. And the idea is to build this with Stocknet and with appchains. So as I told before, the scheme just evolved a bit. But this is the actual idea. Okay.
00:03:59.926 - 00:05:00.858, Speaker B: And I wanted to talk about a bit about messaging and testing. So for those who don't know about Stacknet, messaging is a very interesting way that we can send messages from contract in l one to contract on l two, and also from l two to l one. And the messaging is a bit tricky, because if we go to l one to l two, we have the sequencer of stocknet listening from the Evans or the logs on Ethereum. And when it detects a message, it can send a transaction directly to our contract. Okay, so that's cool because it's automatic, but it is asynchronous, but it is asymmetric, because if we want to go in the other side, we have to emit to send the message. And Stocknet will only carry the message hash like only an identifier for the message to be consumed securely on the l one. But it means then we also have to make a transaction on ethereum to consume this message.
00:05:00.858 - 00:05:37.474, Speaker B: Okay, so it means it's asynchronous because we cannot wait one side to finish. And it asymmetric, because in one sense it's automatic and the other way it's manual. We can say we can automate it just with programs, but we need to consume it. So what we did actually is we just derived a little bit this concept. So let's start for the settlement layer, it can be stocknet or any other, but let's take for Stocknet, we have the same concept of listening. For Evans, we take an event and we can then fire a transaction exactly as stocknet sequencer is doing. That's fine, that's automatic.
00:05:37.474 - 00:06:27.586, Speaker B: And for the other way, we can do the same actually, because we can customize a sequencer. So what do we do is when we use the send message to l one, Cisco, we just format a little bit differently, the message and then the transaction of the appchain is able to directly send the transaction on Ethereum. So it means we can have a loop which is fully automatized by the sequencer of the appchains, which is a stocknet sequencer, but just a little bit modified. So it's super interesting how we can derive this and we use this for the order book like this. We have orders coming from Evans, we don't need any API. Everything is working with chains, talking together and sending orders, executing orders and validating orders. So how did we test that? Because here is the challenge, and I see Alex here about stock.
00:06:27.586 - 00:07:04.658, Speaker B: We're talking about, about toolings, et cetera. So basically integration testing is in ethereum side, we can use foundry, which is very nicely tooled with scripts and testing. And in starknet we have kero testing, which is already built in, in the kero compiler and kero language. But we also have a new tool coming like Starknet Foundry. And we are aiming to developing this tool to reach the capabilities of foundry on Ethereum. So basically integration testing were made like this, each chain on each side. It was fine, but then we had to test all of this.
00:07:04.658 - 00:07:36.874, Speaker B: Like how can we test Ethereum talking to Stocknet, stocknet talking to app chains. So this is where challenges are a bit interesting. So what we did is we are using Anvil from foundry. So we spin up anvil and we can set up Ethereum setup. And then we use two sequencers, katana and Madara. So mostly katana for now, because katana is very nice to test locally, some end to end testing. And Madara is very interesting when we try to decentralize with PTP network.
00:07:36.874 - 00:08:21.158, Speaker B: So basically what we did is we have our sequencers, we set up our sequencers with a tool. So foundry and Stocknet foundry. And then we have to make some scripts. For now it's bash scripts, but we have to make some script because we want to initialize each chain, run the test, and at the end of the test verify that each chain at the correct state in relation with the messages we are expecting in each chain. So this is how we solve this problem. But the idea now is to go a bit further, being able to integrate this in the tooling like this, anybody can then test messaging, because messaging is not a feature part, it's completely part of how stocknet works. And it's super interesting that we can integrate it in all the testing sets.
00:08:21.158 - 00:08:47.700, Speaker B: So basically this is what we wanted to present today to you, that how messages can be very interesting for cross chains applications and. Yeah, so at the end, Stocknet arc project, which is around nfts, is supported by lots of partners from the ecosystem that I think you all know. So we are very lucky to work with these people and trying to propose this infrastructure for everybody on Stocknet. And thank you very much.
