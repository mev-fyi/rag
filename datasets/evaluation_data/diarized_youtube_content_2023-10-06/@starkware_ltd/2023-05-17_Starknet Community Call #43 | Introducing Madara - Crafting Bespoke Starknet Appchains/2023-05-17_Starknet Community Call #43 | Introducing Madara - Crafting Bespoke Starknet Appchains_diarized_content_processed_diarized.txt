00:00:00.170 - 00:00:47.204, Speaker A: A momentum. Okay. Hello everyone, thank you so much for joining us. So basically they say that the ultimate question of life, the universe and everything is the answer to that is 42. But we are way, way ahead today because we are at our community call number and we are introducing today an amazing, very cool and forward thinking project called Madara crafting bespoke Starnet app chains. I know the title is so overloaded with so many cool words. So everyone is super excited to figure out or to break down the title.
00:00:47.204 - 00:01:44.436, Speaker A: Before that, I just want to take a minute to sort of share the architecture of Starknet. So for those of you who are fairly new may have the context to what we are going to be speaking about at this community call. So as I said, welcome to community call number 43. Today we are going to be introducing the project Madara crafting bespoke Starknet app chains. And just to give a quick context as to what the stocknet architecture is like, Stocknet is a L2 validity roll up solution which uses the underlying mathematics of zero knowledge proofs. And the specific algorithm that Starknet is built on is called stark proofs. So what happens in this L2 is that the transactions that go onto this L2 are captured by the sequencer or the Starknet OS and it creates the blocks for you from the sequencer.
00:01:44.436 - 00:02:16.180, Speaker A: There are several things that are happening. The execution trace goes to the prover. The state difference is recorded in the starknet core and there is a verifier that verifies the proofs that are generated. So this is like a quick look at the Starknet architecture. But the component that I've highlighted today, the green element is the sequencer element. And project Madara is very closely linked to the sequencer element which we will be talking about today with Abdel. So that was a very quick introduction and I also want to introduce my colleague.
00:02:16.180 - 00:02:59.030, Speaker A: Really, really thankful to you Abdel, for joining us today. Abdel Hamid, the exploration lead at Starkware. He has been a computer science engineer with a flair for electronic banking and system security. And of course his never ending enthusiasm for innovation is nothing sort of contagious. With eight action packed years in fintech under his belt, he has helped bring a cloud based payment solution to life and a two decentralization maximalists like me. His passion for blockchain technology knows no bounds and he's always eager to explore its world changing potential. Before joining Starkware, Abdel dropped the Ethereum community as a core developer as well.
00:02:59.030 - 00:03:32.220, Speaker A: We could not be more honored to have such an amazing presenter today. At this community call. Thank you so much, Abda, once again for joining us. Over to you. I want to open the floor up to you, of course, but I know we're going to be talking about a lot of serious stuff. But one really curious question that I also get asked sometimes at conferences, what is this exploration team at Starkware all about? What are all the cool things that you're doing? Please share with us. And then definitely let's talk about Madara, the amazing project that we are here to talk.
00:03:32.370 - 00:04:18.348, Speaker B: Sure, sure. So thank you for the invite. So yeah, I can say a few words about the genesis of the exploration team at Starquare, how it began and whatnot. So it all started during Starknet CC in Lisbon, October of last year. At this time I spent a full week with builders from the community during an amazing event which was organized by Omnidust and also by Silv and brick. The event was a hacker house with a lot of builders from Starknet community all together in the building and hacking together on different projects. It was an amazing event.
00:04:18.348 - 00:05:29.830, Speaker B: And at this time I realized that at Starquare we were not as familiar with our own technology and tooling as the builders. And it was hard for us to understand the pain of the builders without actually developing with our own stack and make sure we understand their pain and whatnot. So I was thinking about developing some stuff with our technology, like with Skyro developing Starknet smart contracts and basically feel the reality of starknet builder. I also realized that we have in the ecosystem amazing builders and a lot of them are pretty young, which is very cool. And there is something that I really love in starknet ecosystem. The fact that those people think out of the box, really, they are really able to imagine new cool stuff with the technology and they are really thinking out of the box. And this is amazing.
00:05:29.830 - 00:06:50.584, Speaker B: But on the other hand, I was feeling the lack of some kind of reference projects that could help them to have a better feeling of the best practices and whatnot. And I thought it could be useful to try to create some projects that could be used as showcase of best practices in the ecosystem, to kind of try to help to increase the level of quality on the project in terms of coding practices, security testing, documentation and whatnot. And also I wanted to collaborate more with the community and develop hands in hands with them because it was also a good way to understand what they are feeling, what they need. And it's also a good way to spread the knowledge when we develop together with the community. And also the reality is that we have an amazing community of builders and they are really willing to help and et cetera. So this is a very amazing opportunity to leverage all of this and to have this open source mindset in the community where people collaborate together on different projects. And yeah, the first project was Kakarot.
00:06:50.584 - 00:08:20.170, Speaker B: So the idea of building this zke VM in Cairo, which was a crazy idea from Shah, he sent a tweet about that let's build a Cairo evm. And then we thought that it could be actually a good idea as a showcase of the power of Cairo. Then I bootstrapped it also only just did an effort in parallel to build it. Then we converged the two approaches and during this event, the hacker house, there were many interesting builders and there was a team of people with Clemont, Elias, Gregory, PETA and few others and they were hacking on Kakarot and they participated to a hackathon, to the hat Lisbon Hackathon. It was really the beginning of something special with Kakarot where progressively the builders from the community took the lead on the project and now the project is fully autonomous and the project is led by Clemont and Elias and they are doing an amazing job in running the project as a community effort and whatnot. So this was the first example of what kind of project we could do in the exploration team and then we tried to reproduce the model on different projects. So another goal is to kind of attract new developers on stocknet ecosystem to build on cool and innovative technology.
00:08:20.170 - 00:09:07.080, Speaker B: That's why after Kakarot we started Beerus to showcase the power of storage proofs and it was built on top of Elios which is an interim by client that uses storage proofs. And then people from Starknet community contributed to alios as well, which is good. I also want to kind of stimulate the interaction between Ethereum community and Starknet. So yeah, it's really the goal of the exploration team to kickstart exciting projects and having people collaborating together and spreading the knowledge and the best practices. And hopefully some business and projects can come out on top of those projects. Kakarot is the first example, but hopefully there will be many other examples.
00:09:10.410 - 00:10:18.510, Speaker A: This is really amazing and I think this is such a wonderful idea, right? To be able to start something from within Starknet because that also gives you the sort of leverage to explore like what problem statements might work and what problem statements might not work and you have some sort of fallback. Okay, if this doesn't work, it's fine. We explored and we learned something out of this and for those projects that work, for example, Kakarot, biras and Madara. Of course, I can see that these projects are becoming a place for people to come and contribute, like if they attend Cairo workshops or they come and attend a Starknet 101, especially from an education perspective. Where do we send them next? And some of these projects that are coming out from the exploration team are super cool, super interesting, and most of them are becoming their own, spawning up their own entities, et cetera. So that's also a great way to bring quality startups on a particular network. And I'm only in anticipation in terms of what are the next things that are lined up for the exploration team.
00:10:18.510 - 00:10:46.520, Speaker A: But today we are going to be talking about Madara. And of course I believe that it all started from the fact that we wanted to decentralize our sequencer in terms of everyone being able to run their own sequencer or most people being able to run their own sequencer. Can you talk a little bit about what is the importance of the sequencer and how did you sort of kickstart Madara and what is this project all?
00:10:46.970 - 00:11:32.550, Speaker B: Yes, exactly. So, yes, first of all, I want to say that Madara is still an experimentation for the publicnet sequencer, and I will explain more later about that. But this is important to say that this is an experimentation. There is no decision taken at all about that. It's a good way to iterate and experiment different mechanism for the decentralization, which is great because we can try and implement different proposals and whatnot. For example, Idia from Starpress started to think deeply about the decentralization of concert, so he wrote a bunch of proposals in the community forum. So I encourage anyone to read those proposals.
00:11:32.550 - 00:12:14.178, Speaker B: But the idea is that it will be cool to have a software that enable us to quickly experiment different kind of configurations for the decentralized network and whatnot. Even if it happens that we don't use Madara for the public startnet, it's still useful to be able to experiment quickly. So I think it is still an option for the public startnet. But there are still many things in order to make that happen. But at least it's a good way to experiment quickly. So this is what I say is valid for the public stocknet. And then there is the whole story around stocknet ad chains and layer three.
00:12:14.178 - 00:13:25.850, Speaker B: And for that, Madara is more than an experimentation, it's actually aiming to be a projection grade product for projects that want to run their stocknet app chains. So I will explain later on what is a start net app chain what are layer threes and whatnot? And now a few words on the importance of the sequencer. So the sequencer is really a central piece in a validity roll up. It is really the component that is the entry point of interaction for the user, because when the user will send some transaction, basically it will interact with the sequencers through the RPC layer. So the idea is that the sequencer takes transaction and then it executes them and pack them in the block, and then asynchronously and in parallel the prover will prove them. But this is really the main entry point for the user. And also currently this is the bottleneck of the network.
00:13:25.850 - 00:14:53.606, Speaker B: And the reason why it's the bottleneck is that there are many reasons, but one of them is that because the proving is done in parallel, the proving is massively parallel, visible. Whereas the sequencing is sequential, we cannot execute multiple stock net transactions in parallel. That's why the sequencer is a bottleneck. Obviously there are legacy reasons about the technical stack of the current sequencer and whatnot, but this is being drastically improved with the move to rest for all the stack of the sequencer. And the sequencer has a special role, because when the sequencer is centralized, basically it can censor transactions and it can also go down and whatnot. This is why it will be important to decentralize the network and have multiple sequences, because it will improve and increase the likeness of the network. And also it will be better in terms of censorship resistance, which is really something very important, even if we have also other directions to bring censorship resistance, like what we do on Starkx, for example, which has the possibility for users to force transactions on the layer one.
00:14:53.606 - 00:15:40.530, Speaker B: That means that even in a centralized context, with a single operator, the operator cannot censor users because they will have the possibility of forcing transactions on the l one. But we don't have that for the moment on stocknet. And it's not easy to have the generic way of having this escape mechanism. It is easier to do it for specific use cases. But if you want some mechanism that is very generic and can work for any kind of decentralized applications, it's way harder. So that's why decentralizing the network is one good way of improving the censorship resistance of the network.
00:15:42.710 - 00:15:56.326, Speaker A: And I know you already spoke about this a little bit, but the current state of the sequencer is such that it is being run. There aren't so many community run sequencers. Right? It is still being run by the Starware team.
00:15:56.508 - 00:16:09.710, Speaker B: Yes, exactly. For the moment, starware is the only entity that operates the sequencer. So stockware runs a sequencer, it receives all transactions, and it operates stocknet as a single entity.
00:16:10.370 - 00:16:50.838, Speaker A: Yeah. So I think if this experiment moves a little bit towards success, this would be a great milestone in terms of decentralizing the whole network. Right. Irrespective of whether from a sequencer perspective this experiment succeeds or not, it is, I think, the next milestone to be able to eventually decentralize the sequencer, thereby decentralizing the network. So this seems like a very significant step towards that, towards that decentralization. So that's pretty cool. And I know you also briefly mentioned that the sequencer that you have written is in rust, or project Madara is built in rust.
00:16:50.838 - 00:17:43.740, Speaker A: And we have been hearing a lot about rust being one of the preferred programming languages. And of course, it's been rated the most loved programming language by developers in stack overflow for the past couple of years. But for those developers who are trying to now understand, trying to get into web3, trying to understand if solidity is a good programming language because it's EVM compatible and stuff like that, or is learning rust worthwhile their time, because it is probably more having more memory related constructs and things like that, and slightly harder than solidity. And you chose rust. So I want to understand maybe a little bit for our audience, what is the thought process behind choosing Rust as the programming language to program this entire sequencer, and what are some of the benefits of learning this programming language, if any?
00:17:44.110 - 00:18:37.754, Speaker B: Okay, so, yeah, first of all, I would say that one of the main consideration to using rust is performance. Performance, because rust provides very good performances. So aside from performance reasons, I think that rust has an amazing tooling, and this is one of the reasons why it is so appreciated by developers. It's very rare in a language to have everything out of the box with the default tooling. Like, for example, when you have cargo, you can generate documentation websites very easily and publish them. You can publish to a dependency manager, you have testing, you can run performance benchmarks and whatnot. So this is a very complete and powerful tooling out of the box.
00:18:37.754 - 00:19:44.500, Speaker B: For me personally, it's one of the main reason why I love rust. So obviously, I would say that the learning curve of rust is pretty big compared to many, many languages, but I think it's definitely worth it, because then you will be able to implement and write very performance applications. And there are some fields and area where rust is very efficient. One of them is cryptography. And why is that? Not only because of the performance, but also because of the memory safety, et cetera. Also the fact that it does not have a garbage collector, like for example in some languages like go or Java, and this can be bad for cryptographic operations where you want very strict determinism of your application, like you want every time you run something you want to act exactly the same. And when you have garbage collector in the language, it can kind of affect the execution flow of the program.
00:19:44.500 - 00:20:20.254, Speaker B: Yes. So it comes also with a strong memory safety guarantees. So there is a meme in rest community that in fact you are fighting a lot to make your program compile. But when it compile, usually it works. And there is also another meme which is about how great the rest compiler is. There is the meme of by default you are already doing some pair programming because there is you and the compiler that guide you to fix the errors. And it's true.
00:20:20.254 - 00:21:20.290, Speaker B: Actually the rust compiler is amazing in guiding you to fix errors, et cetera. So I would say that I would strongly suggest people wanted to learn rust, to not directly jump and play code in rust directly. This is what I did with many languages and it works for many of them, like go javascript. You can very quickly try and build them, just take a playground and build them. But I would not suggest to do the same with rest. And the reason is that if you don't understand some of the reasons behind the language, you will be only frustrated and you won't get why it is powerful. Like for example, if you don't understand the ball checker and the ownership of variables in rust and stuff like that, that are very unique to rust, you will be only frustrated and you will say what a shitty language that cannot even do some simple stuff.
00:21:20.290 - 00:22:27.266, Speaker B: But once you understand why, you kind of get the feeling that, you know why rust is so powerful and you accept the price of this kind of high learning curve because you understand the reasons. So yeah, performance, memory, safety, tooling are one of the most important reasons for the success of rust, in my opinion. And I will say also that the community is pretty welcoming and talented, and there are many strong and passionate people. And specifically in the crypto industry, rest is very trending. We see more and more people wanting to learn rest also because there are some other networks where you can also use it for the protocol itself, the infrastructure, and also for the Dapps. There are some smart contract languages, there are some smart contract ecosystem where you can actually develop your smart contract in the last. So yeah, those are the main reasons.
00:22:27.458 - 00:23:27.146, Speaker A: Yeah, I can definitely attest to two of them. One, the compiler being your best friend, compiler literally points everything that could be a potential issue for you. And the second being the frustration with the ownership. So many times when I was on my learning journey it just threw errors like why are you copying this thing haphazardly? Like it's not available to you here? And I was like, why is it not available? I don't understand. But yeah, I think it's a fun journey and I definitely can relate to all of these pointers that you've mentioned. Going on to our next section, and this is the last one before we actually deep dive into Madara as a project. I know you spoke about app chains and l three s a bit very briefly that Madara is very much focused on that and even our title of this session is curated in a way that it focuses more on the bespoke app chains rather than the sequencer part of it.
00:23:27.146 - 00:23:41.658, Speaker A: So can you tell us a little bit about what are app chains, what is l three? Are they both the same? Are they different things? And what is the significance of building app chains perhaps versus adapt?
00:23:41.834 - 00:23:47.200, Speaker B: Okay, sure, I will share my screen.
00:23:48.690 - 00:24:18.410, Speaker A: Yes, and for those of you who are watching the live as well, please feel free to keep putting your questions on the YouTube live stream. I'm going to be checking them and we have about 15 minutes or towards the end for q and a as well. And we'll be happy to take any of your questions, anything from basics to complicated. We are here, Abdel is here. He has all of the knowledge. So let's try to get maximum out of him in this 1 hour that he has given us. Awesome.
00:24:18.480 - 00:25:14.054, Speaker B: Yes. So I will start the story with this post by Starquare, which was in December 2021. So it was a long time ago and this was the idea of presenting the fractal scaling. What is the fractal scaling? Basically the idea is simple, what we do on the L2. For the layer one, we can apply that to different layers, like for example we have ethereum and then we scale it by running a validity roll up on the L2. But with something called the recursion of proof you can apply this principle to many different layers, basically. And the first benefit is that you can gain a lot in terms of scaling.
00:25:14.054 - 00:26:13.840, Speaker B: So each time you add a new layer you can have more scaling. But this is not only the only benefit. Like for example, when you are on the layer three, you have more flexibility basically. And the whole idea of an upchain is basically about the sovereignty for the project. So I would say that the layer one provides the security and the decentralization. The L2 provides the scalability and then layer threes and ad chains in the general provide sovereignty and full flexibility for your ad chain. I will give some examples, but for example let's say you want to have your own custom fee mechanism for your project because for whatever reason you have some specificities on your project that makes it impossible to run on the L2.
00:26:13.840 - 00:26:58.526, Speaker B: So in this case you could run your own app chain. And basically Starknet app chain is an app chain that uses the Starknet execution engine as a basis. Like instead of the EVM, for example, it would use the Starknet execution engine. What is the Starknet execution engine? Basically at the core of it there is a Cairo VM that is able to run Cairo programs. And then on top of that you have the execution enzyme. We currently have two of them, the blockifyer which is an effort from Starquare. And there is Starknet in rust which is an effort from Lambda class.
00:26:58.526 - 00:27:47.310, Speaker B: And both of them basically they take the Cairo VM and they add some specificities of Starknet protocol. And then with that you can integrate that into a full sequencer. To make it a full sequencer you will need to add transaction mempool, storage and stuff like that. Everything to handle the state obviously and whatnot. So a starnet app chain is an app chain. So basically it's a blockchain that uses a stocknet execution engine. Okay? And then you can apply very specific stuff you need for your project.
00:27:47.310 - 00:28:53.070, Speaker B: For example, there is Pragma which is an oracle on Starknet and they are implementing high frequency Oracle. And their idea is to basically pull data from other chains and use storage proof to validate them. Like for example you could with this system, query some data from, I don't know, Ethereum itself or arbitram or decay or whatever chain and make those data accessible to stocknets through their layer three, Oracle. They also have some very specific needs. For example, they want to explore the possibility of using encrypted mempool and whatnot. So when you're on the L2 you cannot change easily the features because obviously there is a protocol, then there will be some governance mechanism. So for the moment starquare is pretty much defining the roadmap and talking with the community to see the priorities.
00:28:53.070 - 00:30:00.022, Speaker B: But for the moment this is pretty much defined by Starkware, but at some point it will be decentralized and whatnot and it will be really difficult to do some changes in the protocol. And obviously each individual application does not have the power to make a change in the protocol, it will take time and they will need to convince the whole community and whatnot where on your Starknet appchain you have the full control. You can define the rules. Really like you take a second server, you take Madara and let's say imagine you want to do free transactions, you can if you want, if you don't want to have any kind of fee market or any kind of spam protection you can. Obviously you probably don't want to do it, but if you want you can do that. You can implement whatever crazy stuff you want. Like for example, let's say you have some constraints related to the regulation and you need to do some KYC for people to interact with your app chain for whatever reason.
00:30:00.022 - 00:30:34.142, Speaker B: On the layer three on an app chain you can do that. Basically. Another good example of what you can do with layer three app chain is privacy. Because for the moment we don't have privacy enabled on the public startnet. So if some projects need privacy they could do it on the layer three. So really this is all about having your full sovereignty. And obviously on your app chain you are not coupled to the congestion of the whole network.
00:30:34.142 - 00:31:35.206, Speaker B: Like for example if there is a lot of traffic on the public n two all Dapps will be impacted. But if you are on your app chain only your users will interact with your chain. So you have more control on the congestion of your chain as well. So yeah you have your full sovereignty, you can do the upgrades whenever you want. Obviously you can also have a decentralized governance on your layer three if you want, but if you want to control all the grades and whatnot, you can do that on the layer three. So it will be also a good way to kind of innovate and iterate quickly exactly like we are seeing with different layer tools. They have much more flexibility to try and innovate around execution engines and do some stuff that are different from the layer one.
00:31:35.206 - 00:32:39.020, Speaker B: And we can apply this mechanism to layer three and L2. They can improve and innovate and propose some stuff that could be later applied to the L2 itself. For example, we could imagine to experiment the move to a smaller prime field like for example on Stocknet. Currently we are using 251 prime field and for performance reasons we might want to move in the future to for example Goldilock which is a small prime field of 64 bits. But obviously migrating on the public stocknet will take a long time, but we could experiment on the layer three and at least do the engineering part and whatnot, do some actual benchmarks on some layer three ad chains and then maybe it will facilitate a move for the public partner. I will do a post there if you want.
00:32:41.390 - 00:33:24.566, Speaker A: This sounds really interesting, Abdel, and I think one of the core things that I sort of took away from this is the importance of this execution engine. Right. Like you can essentially use an existing Cairo Vm, or maybe take the logic of how the Cairo VM is built and add components yourself to make the VM, maybe do more things according to what you would like to do. So it is essentially not an app, but an app chain because this chain is meant to produce its own blocks. Is it? And it can have its own consensus mechanism. And it can have its own consensus logic. Okay, that's interesting.
00:33:24.748 - 00:33:49.360, Speaker B: Exactly. Yes, exactly. You can apply whatever consensus mechanism you want. For example, you can have a single sequencer on the layer three, or you can have a proof of authority network, or you can have a proof of stake mechanism or proof of work. Really whatever you want. It's really about having the full flexibility for your app chain and do whatever you need for the needs of your specific application.
00:33:50.130 - 00:34:29.754, Speaker A: Yeah, that's very interesting. And I have a lot of questions around interoperability of appchains, but I think that's a whole topic by itself. And some of the existing things like Polkadot are also trying to go in that direction. So I believe, yeah, that's a whole session in itself. Maybe another community call for an hour. So without further ado, what I want to do is just dive into Madara itself as a project. And for those of you who have questions around app chains, l three s, maybe examples of what could be some potential use cases for app chains.
00:34:29.754 - 00:35:22.878, Speaker A: But I see, like, it's very clear that you want to obviously have faster settlement rates, et cetera, et cetera. And having that decentralization and publicness is not that much of prime importance, perhaps, but having that settlement finality is important. So then app chain sort of makes sense. And then of course, for performance reasons and things like that, definitely. But if you have more questions, please feel free to put it on the YouTube live and we'll take it up during the Q A sessions. And Abdel, if you can just walk us through what is project Madara? What are some things that people can do using Madara right now? How are you looking at? Maybe just a quick overview of the architecture, if you can. And then how can people contribute? Yeah, I will keep reminding you if you miss something.
00:35:23.044 - 00:36:06.702, Speaker B: Yeah. So I will start by talking a bit about the different primitives of stocknet upchain. So at the core of it you have the execution and here you will use the Cairo VM. So actually as I said, on top of the Cairo VM you have either the blockifier or starknet in rust to add the starknet logic, like for example the Ciscos and whatnot. But at the core you have the execution engine. Then obviously you need some kind of settlement, which is how you will prove your chain and submit the state and whatnot. So this part is missing for the moment.
00:36:06.702 - 00:37:27.138, Speaker B: On Madara we are only focusing on the sequencing, so we don't have anything related to the probing part. But the idea is that because Madara is compatible with the RPC layer and in any case we will have to implement this component for the publicnet sequencer. So I will show you a concrete example. Yes, okay, so we simplify in Zishema with the sequencer and the prover, but in fact in the architecture there is a component in between that takes the block and do some kind a bit of custom logic and then send them to the prover which is sharp. So sharp is a share prover operated by stockware and it has the strong power of sharing the cost between all the different applications that use it. So sharp is used by stocknet but also by stockx. And the idea is really to amortize the cost of transaction because people use the same proverb and with the recursion of proofs you can leverage the benefit of scaling.
00:37:27.138 - 00:38:26.902, Speaker B: But what I wanted to say is that in any case there is this component in between that will be agnostic to the implementation of the sequencer. So once we have that, and if Madara is fully compatible with the RPC, we'll have for free this part. So this is why we don't bother too much on that part. So obviously in the future if we want to provide maximum flexibility and modularity for starknet appchains, we might want to support other provers. There are many initiatives from the community to build open source proverbs, maybe for stacknet app chain we want to support many kind of provers, even if they are not fully compatible between one and node and other. But in the future we might want to add multiple proverb implementation. Then you have the sequencing a, which is a creation of blocks of transaction, mem pool and whatnot.
00:38:26.902 - 00:39:24.570, Speaker B: Then you have the question of data availability, which is very important question. Again, we want something that will be very modular, so you will be able to submit your data to either the staff net l two or to Ethereum directly or to celestia or to some again, layer data availability solution or off chain data, whatever you want. Again, we want to be as much flexible and modular as possible to fit all the needs for different kind of app chains that have different requirements, constraints and whatnot. Again, for governance we want to provide different solution off chain or on chain. Yeah. Then I can tell a bit more about the architecture of the project. So Madara is built using substrates.
00:39:24.570 - 00:40:18.894, Speaker B: I will show a jagram about substrate architecture. Okay, so basically substrate looks like that you have two main parts in your sequencer node. Basically you have the runtime and then you have the client side. So the runtime is really the state transition function of your chain. It is the logic that enable you to go from a state to another one by applying a set of transactions. So this is really the core of your blockchain. The runtime is the state transition function, and then the client is all the services that are needed to run the node and also to interact with the outside world.
00:40:18.894 - 00:40:59.050, Speaker B: Like for example, this is where we provide the RPC layer, the storage implementation. We can choose different underlying database mechanism. By default we use parityDB, which is a fork of rockdB, but we could use other storage implementation. This is where there is implementation of the networking part, the peer to peer connection with other nodes and whatnot. This is where there is a logic for the transaction mempool, some monitoring functions and so on. And then there is a runtime, which is again the say transition function. And the idea of substrate is to be really modular.
00:40:59.050 - 00:41:48.406, Speaker B: This is one of the main reason of why we chose substrate. I can tell a bit more about the arguments later, but really the idea is to have some, what they call pallets. And pallets are custom modules that you can pick and combine together to build your own runtime. So when we talk about the runtime, the idea is to take some palettes, you can take some existing ones, then you can implement your custom ones. This is what we did with the Starknet palette. And I will show a concrete example later, but basically then you will say, okay, my runtime is that I want for the consensus to take this palette for the fee mechanism, I want this palette for the execution, I want this palette, and so on and so on. And by doing that you can combine your runtime.
00:41:48.406 - 00:42:35.340, Speaker B: And the cool thing is that you leverage the tooling of the substrate ecosystem because your chain will be compatible with existing toolings. For example, block explorers, SDK. That's why we are able to use, for example, Polkadot JS SDK, to interact with Madara, obviously we don't have to. We can interact with Metara using the regular pc layer, but if we want we can use existing substrate SDK. So it can be a good way for adoption and interoperability with existing ecosystems to have this kind of compatibility. So yeah, you have your runtime and then you assemble the different palettes. So what it looks like in the code.
00:42:35.340 - 00:43:17.800, Speaker B: So basically we have the palette. So for the moment we have one palette which is a stocknet palette, which is the core logic of the stocknet appchain. I will show you. Then we have the primitives, which are really some basic logic that is shared between the runtime and the client side and whatnot. Then you have the client part where we have mainly everything related to the RPC layer and so on. Then you have the node where you define the chain specification for your network. For example, you can define a development environment network with a list of pre configured accounts, stuff like that.
00:43:17.800 - 00:44:01.970, Speaker B: You have all the command line basically lives there. You have by default all possible command lines that substrate nodes have. Like for example a command to export the state, import the state export or import an account or whatever you want. And yes, then you have the runtime where you define the different palettes. To show you a concrete example, this is where I will define what is my start netapp chain. So I say, okay, my runtime is the following. I will use the frame system for the base of my sequencer.
00:44:01.970 - 00:44:30.258, Speaker B: I will use this palette for retrieving the timestamp. Ora and grandpa are used for consensus. So Ora is the leader election mechanism. This is where it says who will be the block proposer for the next block. Grandpa is for the finalization of the chain, and so on and so on. And then those are existing palettes. We did not implement those palettes.
00:44:30.258 - 00:45:23.070, Speaker B: We took them as is and we applied our custom configuration for our needs. But this is important to say that we did not implement those palettes. There is a large set of palettes from the substrate community that you can use, official ones, some palettes from the community, whatever you want. And then we define our own custom palette where leave the main logic of the starknet sequencer. So this is really how you define your runtime. And now if I show a bit what is a palette? It will look a bit similar to what you can find in a smart contract in some way, but it's actually a part of the blockchain logic. So an important part of the palette is the configuration.
00:45:23.070 - 00:45:48.422, Speaker B: The idea again is to be modular. So we don't want to enforce some choices for the user. For example, Evans. For the hash function that we use in Madara, we make it configurable. This is why it's easy for us to switch from Pedarsend hash to Poseidon, for example, and even other custom functions. Let's say someone wants to build a stocknet action, but use a different hash algorithm. You will have the possibility to do so.
00:45:48.422 - 00:46:22.382, Speaker B: Okay, then you have some hooks. Hooks have some specific functions that you can run. For example, when the block is finalized, when there is an upgrade on the runtime, you can also define some off Chain workers that are capable of connecting with the outside world. For example, we use off chain workers to query messages from the layer one, et cetera. Then you have the definition of your storage. This is all you need to store in your palette. And then you have the genesis configuration.
00:46:22.382 - 00:47:07.310, Speaker B: For example, we want to be able to start with a predefined set of contract classes. An obvious use case is for stock netile chain, you need a fee token because there is no native currency on the stock netapan. So the fee token itself is near c 20, and we want it to be deployed at the genesis of the chain. For a stock netapp chain, for example, this is why you might want to have already defined contract in your storage. And then you have a bunch of events, obviously some custom errors, and then you have the main functions of your palette. For example, we have one function to invoke a startnet transaction. We have one function to declare contract, et cetera, et cetera.
00:47:09.270 - 00:47:33.530, Speaker A: So, Abdel, I just want to take a minute to zoom out a little bit and just, can you throw a little bit of light on what is the context here for runtime? I know we see application runtime, but is there like a chain runtime? And just like, what can people think of when we use the word runtime?
00:47:33.870 - 00:48:02.798, Speaker B: Okay, when we use the word runtime, you can think of the EVM. Basically, the EVM would be the runtime. It is how you go from a state to another. So you take set of transactions, you execute them. So it's more than the EVM, because there are some stuff that are not strictly related to the EVM. But this is really the consensus rules that enable you to go from a state to another. This is the main unit of your blockchain.
00:48:02.798 - 00:48:09.890, Speaker B: This is really where you define the logic of your blockchain. Those are consensus rules.
00:48:10.250 - 00:48:12.600, Speaker A: The way the state change happens, basically.
00:48:13.210 - 00:48:14.280, Speaker B: Yes, exactly.
00:48:14.890 - 00:48:18.920, Speaker A: Okay. Yeah, sorry, please continue.
00:48:19.850 - 00:49:12.294, Speaker B: Yes, I guess that's it for the overview on the code base. Okay, how you can contribute so basically we have a telegram group or you can also directly comment issues. So we have a dance shop issues. So usually what you can do is filter with the good first issue label and then you can try to pick any issue that is not assigned. Let's say for example you want to try this one. So what you will do, you can comment it and say hey, I would like to pick this one and then we can assign it to you and then we can ask questions, obviously if you have some issues or if you need any help. And an important thing is that yes, we are using only deskt platform.
00:49:12.294 - 00:50:22.910, Speaker B: The idea of this platform is to reward contributors. So basically it means that we pay the contributions on Madara. So of course we have a limited budget, but still we have a budget to pay the contributions on Madara. So I will strongly suggest you to, if you want to contribute, to look at the contributor startup pack that has been done by one community member working on Madara. So in the contributor startup pack you will have basically some stuff related to the ethos of the project and the open source mindset and collaboration and whatnot. Then you have a section about learning rust, a section about understanding blockchain basics, a section about a section about substrate and some resources, and then an explanation of the different part of the code base, the role of each different kind of component in the code base. And then you have explanation on the steps to contribute like searching for issues, et cetera, et cetera.
00:50:22.910 - 00:51:22.820, Speaker B: Links to the different channels like the Telegram group, discord of Talknet. And then you have a section about how to get the rewards on only this platform. It's simple, you go to the app, you create a link, connect it to your GitHub profile, and then once you do a pull request that is merged, you will be paid through the platform either in fiat or in stablecoin. And yeah, I strongly encourage all the listeners to come and contribute to Madara. Even if you have some feature requests and you are not a builder, feel free to discuss them there. You can always suggest some stuff by the way. So Pragma will do a proper announcement but there will be a hackathon soon and there will be Madara track.
00:51:22.820 - 00:52:28.038, Speaker B: So I don't want to front run the announcement of pragma, but they will share information soon. There will be a virtual hackathon soon and there will be a track for Madara with obviously a price pool for people hacking and building on Madara. So feel free to submit some hackathon ideas. We have suggested some idea, for example, compatibility with Ethereum addresses implements again data availability layer. Louis suggested this idea of sovereign bitcoin rollups on madara, et cetera, et cetera. So feel free to submit idea and participate to this exciting hackathon and more generally, always looking for more vendors to contribute to the exploration project and to sparknet in general. So everyone is more than welcome and we have very welcoming people from the community that are really dedicated to help others and support them and onboard them.
00:52:28.038 - 00:52:32.440, Speaker B: So I really love the vibes in the ecosystem on this one.
00:52:33.770 - 00:53:17.042, Speaker A: Yeah, this is great. I love the way the contributor guide is structured for those who are new. They are also not so overwhelmed. And if you don't know rust, then really this is a great way to learn and contribute, because one of the barriers that people I feel have in terms of getting into web3 is the fact that they feel like they need to know so many things to start contributing. But it's not true, right? You can see that there are resources to learn rust right from the get go, which is the rust programming book where it takes you from zero to hero of rust and rustlings and all of that. So this is such a great project also to contribute from an open source ethos. You get to learn, you get to work with peers who are all having a similar open source mindset.
00:53:17.042 - 00:53:46.000, Speaker A: So this is great. And I would encourage all of you all to check out the Madara repository. I've also added it on the YouTube live comments. And last but not the least, I know we have only like six more minutes and there are some questions from the community that I quickly want to pick. One of them was what is substrate and how does Madara use it? I think you have already addressed this, so probably we can move on to the next one.
00:53:46.370 - 00:54:09.026, Speaker B: I can say just one word about substrate. So substrate, basically you can see it as a nezdk or a framework to construct your own blockchain. Instead of repllementing everything, you can take existing components and then just implement your custom logic for your blockchain. But really you have this powerful framework that enable you to construct your blockchain with different components.
00:54:09.218 - 00:54:31.886, Speaker A: Yeah, the palettes and all of that. So lovely to see everything coming together, you have to write everything from scratch. So that's great. Stephen has a question, but it's more general to Defi. I don't know if you want, you could take it, but how do you envision defi in Starknet? Is there any difference with defi in Ethereum? And what's Starknet focusing on okay, I.
00:54:31.908 - 00:55:25.600, Speaker B: Can say a few words on that. So basically Defi on Starknet will have much more computation power. Obviously this is a premise of Cairo and Starknet in general. So you could imagine very powerful use cases that will run on chain that are not possible to do on Ethereum or on any other EVM based chain. So really the computation power of Kyivo can unleash a lot of potential use cases. Aside from that, I would say that we have much more flexibility in the design. For example, in the roadmap we will integrate volition that will offer new data availability mode for projects or it will bring cheaper fees, for example.
00:55:25.600 - 00:56:02.870, Speaker B: So developers will have the full flexibility. And because we are not coupled to the EVM, we don't have to be compatible with the layer one on that front. It means also that it's not like if the EVM was immutable, it will still change and so on. And for example, a ZKVM will always have to adapt and implement new EVM features to stay compatible and so on. We don't have to do that. That means that we are fully flexible and free to implement new kind of features. That means in terms of lifecycle and flow of features we can go faster.
00:56:02.870 - 00:56:19.760, Speaker B: And we already prove it with the pace of features on the roadmap. So we have more flexibility with Cairo. We are not limited by EVM and the computation power of Cairo can enable a bunch of new use cases for Defi in general.
00:56:20.930 - 00:56:30.290, Speaker A: Awesome. Thank you Abdel. I have two more questions. I'm going to pick one just in the interest of time, what projects would be interesting to build on top of Madara?
00:56:31.290 - 00:57:09.870, Speaker B: Many of them you can implement new data availability layers. Kakarot can be a good example of running a Startnet app chain to run EVM programs. So this is a very good example. We are discussing with Elias N. Clement to try and build a testnet with Madara that will run Kakahot EVM program. Yeah, you can build whatever crazy stuff you want with the different kind of data availability solution. A very good one I would like to see is privacy, to try to implement some kind of privacy on Madara, for example with encrypted main pools and whatnot.
00:57:09.870 - 00:57:45.050, Speaker B: Even user level privacy, stuff like that. Yeah, more generally people can build new features on Madara, but also just generally take Madara and deploy on it and tweak the parameters, for example the limit of ko steps in the block, stuff like that. So you can either add new features on Madara or you can just take Madara and deploy on it even for development purposes if you want the flexible sequencer.
00:57:47.390 - 00:57:57.040, Speaker A: Okay, I will take this last question because we have another minute and a half. What are your thoughts on how Madara will integrate with Dojo and how will that work?
00:57:57.990 - 00:58:40.974, Speaker B: Yeah, very excited by Dojo. I did not want to tease too much, but we are planning some great stuff with Dojo people generally. Yeah, I don't want to front run an announcement because there will be something big related to Dojo and Madara. This is why I did not mention Dojo. But yeah, basically Dojo is a very powerful enzyme for games on chain games. It is an ECS framework entity component system that will be very important for the development of gaming on Snarknet. And this is an important vertical because basically games are one of the vertical that requires a lot of computation for.
00:58:40.974 - 00:59:29.818, Speaker B: That's why Cairo is a very powerful execution engine for games. But as Dojo people explained it well, in the past, many video games in the web two world failed because first they had to implement their own engine. Okay. And then after that the players implemented the game engine and then it was easier for games to focus on their core logic and use those engines. So Dojo is aiming to do that for on chain games with the idea of having an extensible and powerful framework to develop your own custom on chain games. And we want to showcase crazy stuff with Dojo enabled game on Madara. So stay tuned.
00:59:29.818 - 00:59:34.640, Speaker B: You will hear more about Madara and Dojo in the coming weeks for sure.
00:59:35.490 - 01:00:00.502, Speaker A: Awesome. We are right on time. Thank you so much, Abdel, and thank you everyone who joined today. For those of you who are watching the recording, you can ask questions on the Madara telegram as well if you want to contribute. And then you have the GitHub issues. The repo link is already here, so you can go check it out. And of course we are here to help you in terms of whatever you need from us.
01:00:00.502 - 01:00:30.382, Speaker A: All of the resources are actually on the contributors page. I love that all the resources are already there you can explore. As Abdel mentioned, the team is also very community focused. It's very open, it's very welcoming to new folks. So I highly suggest you to kind of go and check it out. And of course, with all of this integration with on chain games coming, it's a very exciting time. And for all of you, it might be a great time to get in early and get that early advantage, early mover advantage.
01:00:30.382 - 01:00:37.394, Speaker A: So thank you so much and thanks once again, Abdel, for your time. Thank you very much. Next community call. Thanks, everyone.
01:00:37.432 - 01:00:38.290, Speaker B: Bye. Bye.
01:00:38.630 - 01:00:39.600, Speaker A: Bye. Have a good day.
