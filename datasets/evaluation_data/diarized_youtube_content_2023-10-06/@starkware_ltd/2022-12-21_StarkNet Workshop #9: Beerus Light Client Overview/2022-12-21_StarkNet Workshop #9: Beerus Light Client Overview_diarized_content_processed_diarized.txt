00:00:07.260 - 00:01:39.996, Speaker A: All right, hey everybody, my name is Ben Goebel. I'm a developer advocate here at Starkware, and today we're going to be talking about the Burus lite client. We're going to start talking about lite clients in general and then get into Burus and a little bit of how to install it, how to use it, you know, how to, how to help us develop, it's still in beta and development stage. So another purpose of this conversation of this workshop is to get you guys on board. Light clients are one of the really interesting new greenfield architecture paradigms of kind of where especially Ethereum is going. I know a lot of different chains are looking to implement something similar to it, but Ethereum, it's been a large initiative to keep light client development and light client fundamentals inherent into the protocol. So today we'll get into how do we use that in beerus? What's that going to be good for in the starknet ecosystem? Let me just make sure that my audio is coming through, if you're on the stream and can just verify for me that the audio is coming through 1 second.
00:01:39.996 - 00:02:11.376, Speaker A: Also, give some people some time to join on. I know we might have some stragglers. Okay, sounds like audio is all good. Cool. Thanks for joining. Let's jump into it. I am technically sharing, but I want to do the slideshow.
00:02:11.376 - 00:03:10.420, Speaker A: Okay, so beer is light client. Let's start with what is a light client? Since the mechanisms are so new to Ethereum and these kind of production systems are just kind of recently getting spun up. We'll talk about helios, which is a development initiative by a 16 z. But these things are fairly new to the ecosystem in terms of them getting kind of productionized and further than just specification. So what is an Ethereum light client? The Ethereum foundation has come out and said these are the kind of the basic definitions, the basic level setting for what a light client is. It's low on resource usage, meaning cpu, memory, storage, I ops, it's embeddable. So it's embeddable in a desktop application, on mobile, within web apps, and even kind of this blows my mind and is one of the reasons why I want to kind of keep going down this path is smart contracts.
00:03:10.420 - 00:04:29.680, Speaker A: What if we have a light client inside a smart contract? What does that enable us to do? One of the things you might be wondering is, well, technically, isn't that metamask? Metamask runs inside the browser, it's a chrome extension and it allows me to have low resources, cpu memory usage. So it's really this last definition that kind of solidifies what a light client is, that it remains trustless. Okay, so one of the kind of really intuitive reasons of why we need light clients in general is because of the size of a full node. So over the years, as more and more transactions are propagated on Ethereum, we have a bigger state. Each one of those nuke smart contracts that's deployed and each one of the interactions, it's going to bloat the state. So the more usage that Ethereum gets, the more state that it uses, and the full nodes have to run a bigger machine to keep everything stored. So we can see that there have been certain different software implementations that have helped alleviate the gigantic state logs bloom on Geth is one of them.
00:04:29.680 - 00:05:35.856, Speaker A: It's helped with certain sync times, but the overall trajectory of what the state is for a full node is going to keep increasing. That's just the nature of Ethereum state and full nodes. So as you can see here, we go from 250gb from about a year ago, to somewhere near 900gb today, sorry, 2019, to around almost a terabyte today. So that's not going to slow down, that's going to keep going. We need to have, and so if we want network participants to come in and be able to verify that everything is happening on Ethereum correctly and in a valid way, we need to have some way of dealing with it. So that's the most intuitive way to think about it, is just that state is going to keep ballooning. And how do we as operators and users on the chain, make sure that we're interacting with valid information? So what's the state of it today? Well, most users interact with Metamask.
00:05:35.856 - 00:06:28.072, Speaker A: And so where's Metamask pulling that information? It's a little obfuscated at first. You open up a metamask wallet, it doesn't explicitly tell you that it's searching for an RPC provider in Infura. Some of the people who've been around for a while know that consensus is the operator of both tools, so it kind of makes sense. But yeah, we are relying on a centralized node provider that runs these high capacity machines in the cloud and under the hood. What metamask is doing is it's just calling this endpoint called Ethereum get balance. So, like, let's say we're doing a transfer, we need the balance, or we need to just show the balance of the user's wallet. This is what that request looks like.
00:06:28.072 - 00:07:04.652, Speaker A: Metamask is reaching out to a centralized infrastructure provider, most likely infira saying eight, get balance. And it responds with this information, just the balance of the address. So most of the time that'll work. That's probably correct. Infira has probably set up their infrastructure to maintain the chain state, and that's probably correct. But there are these situations where you can get a man in the middle attack. You can have someone sitting on your network and basically feeding you fake responses.
00:07:04.652 - 00:07:53.600, Speaker A: So we can trick the local wallet into basically believing any version of the history we want. Yeah, so no validation of Ethereum data. And then if you decide to go in and you've been given this phony information, you'll verify. So you'll click verify, you'll click sign the transaction, and that signature will verify. So if your nonce hasn't incremented and you sign your signed data that you don't realize is incorrect, we've got a problem. So this is where light clients come in. Instead of just getting this request response, and the response being just some plain text data that makes up the balance, we instead get this Merkel proof.
00:07:53.600 - 00:08:37.280, Speaker A: By and large, Merkel proofs are going to be slightly out of scope for the conversation today. But what you need to understand is that Merkel proofs resolve into a root hash, and that root hash is a commitment to all of the data that makes up that merkel tree. And Merkel trees are what the state of Ethereum is stored in. It's what the state of starknet is stored in these merkel. Patricia tries in practice, the tree is quite more complex than this. But what we can see from the diagrams on the right is that if instead of just this one simple payload, we get back, which is just the user has 5.29 eth.
00:08:37.280 - 00:09:29.420, Speaker A: If instead we can say that at the very base or leaf of this merkel tree, there's this balance and we get, I'll use my clicker here. So what the full node will have is it will have every single one of these leaves at the base. And what the full node does is it hashes all of these leaves until we resolve into a merkel root. And each block is a commitment to the state of Ethereum. Well, in order to store all of these leaves at the base here, I need to take up what we saw earlier, which was a large amount of data, to have the entire state stored. Well, for the Merkel proof, I don't need the entire state of Ethereum. I just need to operate on certain values.
00:09:29.420 - 00:10:17.410, Speaker A: And so let's say one of the values that I need to know is just my balance. So I know my balance, or I don't know my balance, but I'm querying my balance and it's the base leave here. Well, if I can resolve the leave pairs up to this path and up to the hash, then I know that that Merkel commitment of that merkel proof was valid is correct. So in this way, instead of just getting some plain text back, I can resolve this merkel tree all the way up to the root hash and say, okay, I am not being lied to. 4.75 ETh balance does actually exist because my root hash matches the root hash that I trust. We'll get into why you can trust the root hash in a bit, but hope that makes sense there.
00:10:17.410 - 00:11:28.360, Speaker A: Okay, so in this light client paradigm, instead of an API response request response cycle, which we see a lot in web two, I am just going to resolve a response with you, and I'll trust the data you have. Now we have a bigger payload that we're receiving from something. We'll get into what that something is, and we can resolve that Merkel proof to make sure that we're verifying that piece of information, in this case, the balance. Okay, so instead of the ETH get balance that we saw earlier, now we're making an RPC call to ETh get proof. And that gives us the resolution path here. Yeah, and if we have the path and can verify the path, we know we're not being lied to. So the other important part of this information here is basically that since we don't need to store all of this, all of this on our light client, we can save all this space and we can become portable and mobile and embed these applications into some pretty cool projects.
00:11:28.360 - 00:13:06.896, Speaker A: Okay, so the question then becomes, how do I get my root hash? I realize that I can verify that this piece of information in the state is going to be valid, but someone could basically give me hand out a phony root hash and then could prove any leaf in the tree resolves however they want. So a full node stays away from being tricked because it is literally verifying all of the signatures and coming to consensus with all the other validating nodes and doing all of that computationally heavy work that leads to a full state resolution. Like we talked about a little bit at the top of the call, not all protocols at the base layer are optimizing for light clients. Some are just basically saying, well, give me the beefiest full node available, and in that way we can resolve everything quickly. Well, this is kind of another way to look at it, which is to say, what if we optimize the base layer to enable these light clients to operate in these resource constrained environments? So the way that Ethereum has gone about that is with this light client protocol, which enables sync committees. This is as of the merge transition, and we have this concept of a sync committee. So sync committees, it's a sampling of the broader validator set who signs the blocks, and light clients sample the signatures.
00:13:06.896 - 00:14:27.152, Speaker A: So out of this epoch of validators that we have all with a certain amount of stake, all with that stake being able to be slashed, which gives us some economic guarantees of the underlying consensus, we have this validator set that is rotated daily, and there's only 512 validators in the sync committee that's rotated daily. And if you think about the size of the validator pool, it's really a minuscule part of that whole set. So only 512 validators that the light client keeps track of, and it's rotated daily and it's randomly sampled, they sign the latest block. So the light client has to basically keep that state of all of the validators set of that day. And it says, okay, if all of you, or if more than two thirds of you have agreed on the latest block, on the consensus, then mathematically it's pretty likely, and by pretty likely I mean very likely, that I can trust the current head of the state. And what the sync committee is telling me and what they're telling me is what the root hash is. Cool.
00:14:27.152 - 00:15:10.216, Speaker A: So sync committees are cool and they are new. So all of this stuff is fairly new. Another reason why it's a fun problem to work on. There's not a lot of production grade implementations of this software out. So it's really fun to look at. So again, if you guys want to come in and contribute to Beerus, that'd be really cool. Okay, so what does this give us? The Ethereum community especially kind of has these base values of decentralization, and you can kind of see how we're taking trust of centralized node providers out of the system with these light clients.
00:15:10.216 - 00:16:29.248, Speaker A: So we shift the paradigm of the current web3 infrastructure. It's ironically, we say infrastructure and infura, we are literally being enabling the ability to verify locally the chain state, trustless bridges. So the way a lot of bridges work right now is kind of with multi sigs, multi sigs that are typically run through the same entity, be it a company or something, that trustless bridges let us verify the chain state and have no need for something like a multi sig to be the predominant operator of the chain like we've talked know, the main example I've given so far is metamask. You can see how when metamask by default reaches out to the inferior RPC, it's not the most ideal thing for decentralization. So we're going to enable this entire future of wallets that basically don't need to look anywhere. They can just look at the actual chain for information Iot. I think it's on the next slide, but one of the implementations of this light client protocol helios compiles down, it's written in rust and it compiles down to a 14 megabyte binary.
00:16:29.248 - 00:17:23.636, Speaker A: So we can start embedding these things in iots. I saw one talk kind of recently of this guy who basically mentioned we can be running these light client protocols just in the background of Android or iOS, and that might be the way that the future looks. So you can imagine if you have these light client protocols in the background, in maybe a secure element or a secure enclave that's managing a public private key pair, you basically have a trustless chain operator on your mobile phone. Pretty cool stuff. Oracles are another way to kind of inject meaningful information into our smart contracts, but they are subject to manipulation. We do have to trust these oracle operators, to be honest. Operators.
00:17:23.636 - 00:18:36.930, Speaker A: There are some signing mechanisms that we at least know where these data points were originated from, who owns the keys. But with storage proofs and with light client protocols, we can at least get some of these Oracle data points removed for trustless data points. And the last one, also super cool, is to spice it up with ZK. So you can imagine if I am a light client operator and I need to come online to get the new sync committee every day. Let's say one thing that is cool is you could come up with, let's say I haven't sunk my light client for four months, I can have a ZK proof that comes in and says hey, this is the way that the sync committee has been chosen up until the last four months, and I can just verify that ZK proof. And I can sync far less often, as with all ZK, another new tech primitive. So you might see this kind of get sprinkled in in more places than just that.
00:18:36.930 - 00:19:04.280, Speaker A: Cool. So Helios mentioned Helios. It's been written by a 16 z. It's a rust based implementation of the light client protocol executable binary size 13 megabytes. They state one of their missions is to basically enable the embed of this in webassembly wallets. Dapps. And again, like we said, at the very top, it needs to remain trustless.
00:19:04.280 - 00:19:42.384, Speaker A: And this does do that. This is a little blurb from a blog they wrote. So it says syncs in around 2 seconds, requires no storage, and allows users to access secure chain data from any device. Pretty neat. Okay, so what is beerus then? So beerus is a lot of these same concepts as they apply to starknet. So beerus is a starknet light client inspired by and using helios. The goal is to provide a simple and easy to use client to query starknet state and interact with contracts.
00:19:42.384 - 00:20:44.760, Speaker A: So pretty much everything we just mentioned as it applies to starknet, and you'll see that a lot of the concepts that we mentioned do get abstracted, basically one layer up. So this is the basic call flow of Beerus. We have Beerus core, which is some of the core software that runs Beerus. There's a couple of different interfaces that you can do to interface with beerus, which we'll get into in this little working session coming up. But beerus core basically is the core unit that operates this, so we don't have to duplicate the effort into the different interfaces APIs. So bureau syncs with helios. Helios, like we mentioned, I think it's like subsecond or a couple seconds to sync helios just because it needs to find the bits of information that we've gone through which are minimal syncs with the sync committee based on weak subjectivity checkpoint.
00:20:44.760 - 00:21:30.344, Speaker A: That weak subjectivity checkpoint is just basically saying how helios knows that it can trust the root hash that it's getting acknowledges to beerus core. So in this call flow, we're basically checking that a certain storage key and a contract is there. So the user is going to query starknet contract storage. It's going to get a storage proof at the last proven block. So the last block that the sharp prover has proven to ethereum one and that the state has successfully transitioned. So we verify that storage proof and then we run through. This is kind of where the l one, l two interrupt gets kind of cool.
00:21:30.344 - 00:22:17.508, Speaker A: So we query the Starknet state route from helios. This would just be if you were like using vanilla helios. But we've written all our state variables and state transitions to l one, so we can query that, query the state route, verify the proof, and we can get a trustless answer to what is the current state of this starknet contract storage value back to the user. Cool. So that's a high level overview of light clients in general, and also what Beerus specifically is. I don't have the ability to open up a chat, it looks like, but feel free to reach out to me. I'm Dr.
00:22:17.508 - 00:22:44.972, Speaker A: Spaceman, Dr. Spacheman on Telegram and on Twitter. So if you have any questions, if you'd like to follow up on this talk afterwards, feel free to reach out to me. So we're going to get into setting Beerus up locally. And again, Beerus is under active development. It does not currently have a release. So that typically means that you'll run into a couple of bugs, you'll run into a couple hiccups here and there.
00:22:44.972 - 00:23:22.326, Speaker A: And what I would say is that come in and help fix them. Because that's the cool thing about all of this software, is it's being built out in the open, open source. We'd love your contribution. Okay, so it's in a repo, the repo, and it's in an organization that GitHub organization is called Keep Starknet. Strange. There's a lot of cool stuff in here. If you are a starknet enthusiast and kind of want to be tinkering with what's happening at the edges, this is where cockroach is.
00:23:22.326 - 00:23:51.378, Speaker A: It's the Zkevm interpreter. There's a lot of cool things in here. If you do have interesting ideas, just go in there and submit a discussion for an idea that you'd like to see a group of people all contribute to. Beerus kind of is an obvious one that is going to be a big public good to the ecosystem just to enable kind of trustlessness all over. Cool. So here's beerus. We'll get into how to set it up.
00:23:51.378 - 00:24:41.610, Speaker A: Here's another kind of call flow if you're interested in the logical flow of the application. When I mentioned that there's multiple different interfaces to Beerus, this is kind of what you know, you can operate via Cli, you can operate via rest API. We're going to install both today, but both of them are going to be calling this Beerus core unit and then just a different layout of the previous call flow that we looked at. So we do have let me blow away my beerus locally so we can start from scratch. The install script is going to give us that in our path. The install script also installs it at this beerus route. So we'll remove that.
00:24:41.610 - 00:25:06.596, Speaker A: So cool. So we want to start from scratch. Let's install with this installation script. This takes just a little bit of time. Like I mentioned, there's not a current stable release of Beerus. Once that stable release does come about, this is just going to pull the binaries attached to that release. But as of now, we are just building Beerus.
00:25:06.596 - 00:26:12.580, Speaker A: So we're basically doing a lot of similar things that cargo build would be doing or if you were to pull it manually. Okay, so if you think about the call flow we looked at earlier and what we need in order to operate Burus, it becomes kind of one thing we. Okay, so I'll just back up slightly with the merge. The merge split out the clients into these two different application flows, one of them being the execution layer and one of them being the consensus layer. So the execution layer running the EVM basically makes sure that all the transactions are operating within the scope of the EVM. And then the consensus layer, basically the thing that operates the beacon chain, the thing that keeps the entire chain together, that makes sure the entire network of validators is coming to consensus in a way that matches the protocol rules. So that happened in the merge, which also enabled.
00:26:12.580 - 00:26:46.304, Speaker A: I'm getting, my computer is freaking out because I got streaming and building going on. So hopefully I don't lose you. If not, I'll keep going. Okay, yeah, so we need to know which ethereum network that we're operating on. This will be one of the environment variables we need. We'll operate on Gurley execution RPC. Right now you need to have an alchemy URL for this.
00:26:46.304 - 00:27:18.410, Speaker A: Infura is currently not working for this. So grab an alchemy URL API consensus RPC. So there's a couple public endpoints for this. I'm using the nimbus endpoint and I'll show you that. Actually I can show you that now. Okay, here on the top pane here, my network is gurli. The execution RPC URL is alchemy.
00:27:18.410 - 00:28:19.378, Speaker A: And then this is the public nimbus consensus RPC URL. Since I am using a public API, sometimes this does kind of lag a little bit and it can cause some issues, but it's good for testing. And then for starknet RPC, you can use inferior as well. Starknet has an RPC provider in infira, so get your key here, get your alchemy key and export all those variables. There's also a little example file here, examples m example. And so you can also just manually source this thing to give you your environment variables. But that should make sense to you now, as far as why you need each one of those to keep up with this light client protocol here is the copy examples m example.
00:28:19.378 - 00:29:02.510, Speaker A: Populate those and then just run m and that will populate your environment. Okay. Some other things in the readme that are important if you guys do want to come in and contribute unit testing. So because some of this infrastructure is very new, sometimes it's easier to run to develop via unit testing. So cargo test all if you're familiar with rust. If not, this will run all of the testing within the crates here. And that's a good way to start developing.
00:29:02.510 - 00:29:47.454, Speaker A: And then if you weren't running through the installer here, we would run cargo buildall rust. Especially if you pass this release flag, which will run some optimizations for the executable that it spits out. It'll spit it out into target release and then you can run it from there. So some of these examples here have target release. If you've done it the way I've done it, which is just put it in my bash RC, then you won't need source m. And this will be installed in your path. And you can see the installer has installed the path add on right here.
00:29:47.454 - 00:30:34.060, Speaker A: So path homemyhome directory, Beeruspin. This might spin for a while, just because I'm also streaming. So let's keep going down. Okay, so we will do a quick overview of the CLI usage and then Beerus rest API. Just going over the architecture. Some interesting thoughts that I have, and maybe you have, is that if you look at this architecture flow diagram here, Beerus core is the thing that's doing a lot of the proof verification, be it merkel or storage. And we just have these interfaces to.
00:30:34.060 - 00:31:30.040, Speaker A: So, you know, as we embed these things in webassembly in various, various different things, it's kind of cool to think about what all could populate this row. One thing that I've worked with in the past is GrPC. It's a really performant HTP 20 library that operates on top of GrPC. And you can kind of multiplex these calls and you can start thinking about these really high performance applications that can be zero trust that operate with the chain. It's really a cool new paradigm. All right, I think we've gone over most of it, so now we just need to watch this thing build. Installing beerus root pulling beerus repo building Beerus that'll build the binaries and put them in our bin.
00:31:30.040 - 00:32:31.216, Speaker A: Some of the examples we provide know you have a subcommand here for the Beerus CLI, and the same thing exists for the rest API. But since we have this ability to trustlessly verify state, we can do it on both. We can do it on Ethereum and we could do it on Starknet. So we need these ergonomics within the CLI and rest to query both Ethereum or Starknet. One thing that I'm going to start populating, if you guys have watched my workshops before, you know I'm a big fan of postman. Postman is just a really clean rest client for API requests, so I'll start pushing it here. The rest API endpoint looks like this Starknet state root.
00:32:31.216 - 00:33:09.244, Speaker A: It's going to be the same thing. You're going to see the Cli basically mimic the command set in these API endpoints. And then here you can see that we're searching from localhost. The default port is 8000, and we can run the same commands with the CLI that we can with the API. So if you do want to pull this collection of API requests, there's a couple other ones in here. The really useful ones for me are feeder gateway and gateway. So that just lets you interact with the sequencer or Starknet Devnet.
00:33:09.244 - 00:33:47.870, Speaker A: So if you haven't pulled this rest API collection, I would suggest you to. It's called starknet.edu. And you can just search that in the search bar here. There she is. Okay, let's see how our build is faring. It's lagging, it's hurting. In the meantime, I'll see if I can find the chat here to see if there's any questions which will most likely hurt the build even more.
00:33:47.870 - 00:34:45.618, Speaker A: So bear with me everybody. Okay, note most likely. Okay, no questions. No questions yet. One thing we can talk about briefly while this is building is know we obviously operate with Helios as a first level API to Beerus, but let's say that you just wanted to install Helios. There's a lot of similarities within the Helios repo to Beerus, mostly for what it says in the Beerus readme. Just that Helios is kind of the inspiration.
00:34:45.618 - 00:35:19.650, Speaker A: They're both rust based. A lot of the repos is configured the same way, so you should have some level of familiarity with both if you have a level of familiarity with one. Same thing here. Helios up to install and some of the same environment variables need to be set. Obviously not all just because we're operating on one level down. So we just need to know the chain state from ethereum instead of the chain state from Beerus. There we go.
00:35:19.650 - 00:36:08.450, Speaker A: Okay, cool. So we have installing beerus root pulling Beerus repo building Beerus and we have beerus installed at version zero 10. Like I said, not a stable release yet, but working on it. A lot of talented people in the community contributing and really it's just a fun project to be a part of. Once we have this, we'd like to add it to our path so we can run some of these without giving it the full path, which is just kind of annoying. So I'll run source that and then we should have beer Cli in our path. Now let's check the version, check the usage.
00:36:08.450 - 00:36:40.220, Speaker A: Awesome. Okay, cool. I have set these. You will need to go in and set these either via the example M that we showed or in your bash RC, whatever you like better. So let's start with the CLI. We'll start with this first example. Just getting the querying the balance of this address.
00:36:40.220 - 00:37:41.880, Speaker A: No, like any good demo, it's going to fail on me. Okay, this might be that the Helios light client hasn't fully spun up. All right, let's try one of these other ones. Give it a second. We'll just do beerus, but notice that it's in your path now, so you can operate with it. This is going to go through the no. All right, let's make sure all my environment variables are set.
00:37:41.880 - 00:38:25.980, Speaker A: I don't want to show you, it doesn't really matter. I'll show you my key. Don't steal it though, whatever you do. All right, so I'm just going to make sure that some of my environment variables are indeed set and we are looking at the right endpoints here. All right, that looks okay. Let's give it a try one more time. So this could be an issue with those public endpoints falling out of sync.
00:38:25.980 - 00:39:25.846, Speaker A: One thing that it looks like we might need is a little bit of better error logging and error catching. So we'll definitely need to check that out. But like all good demos, they do not work when you need them to. Hey, badabing bada boom. Okay, so we'll need a little bit more verbose error logging in there, but you can see that this beer cli Ethereum query balance queried the balance for this Ethereum address and came back with this information. But it got that balance the way that we have discussed in this presentation, trustlessly. And it verified the current state to get that, and it went through the sync committee to get the current root hash.
00:39:25.846 - 00:40:01.460, Speaker A: So pretty cool stuff. And then there's more than just that interface to Beerus. So depending on the way that you want to embed this in your system. One of them might be a rest API. You can think of an IoT device that just spins up a rest API first for Beerus and then runs its actual application next, but on a known port. So that IoT device knows exactly where to query Beerus at. If you do want to do something like that.
00:40:01.460 - 00:40:30.820, Speaker A: This will also be in that same Beerus route, so it should be available to you. And it's going to be Beerus API. Beerus rest API. That'll spin up netstat lp net. Looks like I might have another one. Old. Okay, I already have one up.
00:40:30.820 - 00:41:08.380, Speaker A: We will kill it and we will start it again so we can show you bureaus rest API. So now that should be up. Let's see what's running on port 8000. That's the default. I don't have Netstat. Good God. All right.
00:41:08.380 - 00:42:03.740, Speaker A: No. Anyway, that is definitely not important to this demonstration. Another way we can check that it's running on port 8000 is to go into our collection here. And we have Beerus. This will eventually be populated by more than just this state root query. You'll have all the ability to query the entire API surface area with that, but so localhost port 8000, Starknet stateroute again. All right, so you've seen two spots where we will probably need a little more of roboce error handling.
00:42:03.740 - 00:42:25.900, Speaker A: This should respond with the current trustless state route that we're fetching. There it is. Okay, so there's a state route. Yeah, a little raw, but again, we'd love your help. Okay. That's really all I have today on light clients. I hope it's helpful.
00:42:25.900 - 00:42:54.340, Speaker A: I hope it sheds some light into what BrIs is doing behind the scenes and why BRS is important in the landscape of trustless l ones and l two s. Again, like I said, we'd love to have you guys contributions. Reach out to me at Dr. Spiceman on Twitter or telegram. And yeah, make sure to tune in in two weeks for our next workshop. See you guys. Happy holidays.
