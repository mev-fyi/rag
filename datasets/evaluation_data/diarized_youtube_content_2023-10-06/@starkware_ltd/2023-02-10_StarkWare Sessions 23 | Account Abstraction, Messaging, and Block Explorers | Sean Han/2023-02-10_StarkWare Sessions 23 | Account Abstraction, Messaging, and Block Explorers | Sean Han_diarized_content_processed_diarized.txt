00:00:04.130 - 00:00:50.754, Speaker A: Great. Thank you so much Louis, for the kind introduction. It's so great to be here and thank you Starkware, for hosting us in such an amazing event. So really appreciate it. So today I'm going to be talking about account abstraction, roll ups and explorers, right? That's what Starkscan is, a block explorer on net. And I think on account abstraction and being a roll up is really the unique feature that makes Starknet different from maybe other ecosystems or l one blockchains. So just to give a brief introduction about my journey through Starknet in October 2021, I was working@blockchain.com
00:00:50.754 - 00:01:49.794, Speaker A: and I was exploring different layer two ecosystems to support in our wallet. And I was obviously looking at side chains, optimistic roll ups, and stumbled upon ZK roll ups. And I found it very interesting and I thought it had a lot of potential to ultimately scale blockchains in the long run. A problem that sort of plagued the industry since the inception of bitcoin in 2008. And when I joined the ecosystem, there wasn't a lot of tooling yet. I would say the first half full develop external developers looking at Starknet and I was like, oh, what kind of very scalable app can I build on Starknet? And then I realized there was no library for me even to talk to the Starknet sequencer. So that's when I started Starknet JS and shortly after, Argent was also looking at the growing Starknet ecosystem and it was a joint effort with Argent.
00:01:49.794 - 00:02:44.780, Speaker A: Since then, obviously other parties like Shard Labs has taken over this effort and huge shout out to them for the great work in 2022. Based on the thesis of building very scalable experiences on Starknet, I think we were very excited to build a very social and consumer facing product. And that's why we launched like NFT Marketplace. And we were one of the first apps to go on Mainet on Starknet as well. But I think what we saw was sort of the developer growth, which I'll go into more detail later. And that's when we sort of decided to work on Starkshan that we thought was sort of the bigger problem or the bigger pain point in the ecosystem. And now today we are sponsoring Starcore sessions and I'm giving this talk to all of you here.
00:02:44.780 - 00:04:00.130, Speaker A: Thank you. So I guess the big question is, why do we need another Explorer, right? So there was already explorers in the ecosystem, but I thought we had sort of a unique spin on an Explorer on Starknet. So I think the big sort of need is the growth of the developer ecosystem, the utility we could bring to the ecosystem and our expertise and our experience in the ecosystem. So to go more into depth, when we started Starknet JS, I never expected it to sort of grow so quickly. And obviously over the past year a lot of developers have been looking into the Starknet ecosystem. And I really commend the Starquare team for taking the approach and opening up Starknet and launching really quickly, allowing and giving space to companies like myself to build on Starknet. I think a lot of other ecosystems they might want to be building, their tooling themselves, for example.
00:04:00.130 - 00:04:51.966, Speaker A: A lot of other ecosystems might build their own sdks, their own explorers and their own wallets. And the fact that Starquare allowed us to be part of this growth is also really a blessing for us. So I think that speaks volume in terms of the developer activity because it's just something that was available for any developer to use and play with, even though I would say it's still a work in progress. So I think in terms of the utility starks we thought we could really bring to the ecosystem at that time was we support pending transactions. Right? So when you run a transaction, you could actually see a pending transaction on the Explorer. So then you can actually keep track of when that transaction can complete. And then we also decode transactions, events and calls.
00:04:51.966 - 00:05:40.290, Speaker A: Like the data type on Starknet is called felt, right. It's a really big number, but developers don't understand numbers, they understand English and functions. So we decode that into functions that developers can understand. And then we also verify contracts very easily. Like we took the CLI approach because we can crawl through your Cairo code and verify contracts easily that way. And something I'll go more into depth in this talk is l one and l two messaging and also account calls which relate to account abstraction. Yeah, so I think we really had the expertise at that time because we were seeing Starknet sort of growing really and iterating and changing really quickly.
00:05:40.290 - 00:07:21.810, Speaker A: And because we built an NFT sort of product, we already had indexing infrastructure and we had experience around indexing data from Starknet. And before we were only indexing NFT data, but obviously with an explorer you're now indexing everything on the really good. I got a question related to account abstraction, like why do we need account calls? And I think this is a question only unique to starknet because of account abstraction, which I'll go into more detail in the next slide. So just to give an overview of what is account abstraction and what it allows you to do, essentially, account abstraction allows wallets to be more programmable and then because of that, every account or wallet is a contract, and every transaction goes through an account contract before going to the intended contract. And I think the challenge for explorers is how do you know what contract the user intended to call? Because from a developer point of view, you might just see users just talking to accounts all day, you don't actually know what their intention is, right. Maybe if they're trying to swap a token on the amm, what you sort of see on chain is they're talking to an account contract because you're not actually going one level deeper. And I think that's sort of a challenge we solved with our explorer that I think really brought a lot of value to developers.
00:07:21.810 - 00:08:35.750, Speaker A: Yeah. So if you look at sort of directly, I guess, what's on chain you would see the execute function, which is part of an account contract. Like an account contract has an execute function, and in that execute function that's where they actually do the thing that the user wants to do, right? So if I'm swapping a token on Amm, I would send a transaction to an account contract, and then contract would call execute, and then execute would call the amM contract and then do a swap. And then, so don't know if you can tell, but on the purple on the top left, that's execute. So if you were maybe in Ethereum, that's all you would see because you would just see the account call what it's directly calling on chain. But what we were able to do is actually decode one level deeper so you can see what the execute function is actually calling. So I think in terms of challenges that could like we have to make some assumptions and make some smart guesses.
00:08:35.750 - 00:09:38.350, Speaker A: So we know that the second layer is actually what the user is intending. But I think there are edge cases where maybe an account contract caused another account contract that caused another account contract and then cause the end contract. And then in that case it's much more complex for an explorer to understand. Right, but I think most contracts are interacted in this format, so I think we handle probably most cases like 99% or more. So some examples of account calls, right, so account calls are calls that are forwarded by a account contract or I guess a wallet contract. And if you look at the transactions table on Starksend, you will see all the calls and that's actually forwarded from the account contract. So you see like approve swap, all the actions that are actually intended by the user on Starkscan.
00:09:38.350 - 00:10:02.834, Speaker A: And then we also have an account calls table. So in the current block. This is what users are doing. Like you can see users minting an NFT, claiming a name on Starknet ID, adding liquidity or swapping tokens. You see it all on this table. And then you can also see this in contracts as well. So this is an NFT contract.
00:10:02.834 - 00:11:16.262, Speaker A: And if you look at the account calls, like a user is calling mint through an account contract, right, that's why we called it account calls. And then this is a sort of table that we launched recently called the token table. And you can see all the transfer events. So when you look at the account calls for the Ethereum ERC 20 token, you can see people swapping ether via amms or other D five protocols. So essentially what account calls on Starksand allow developers to do is they can actually see what users are running on chain, right? So previously maybe you would just see felt or you would just see execute, but you wouldn't actually see the user's intention on chain. And I think by us, by visualizing that, developers can actually know what users are doing on chain. So the next topic I'm going to be talking about bridging for roll ups.
00:11:16.262 - 00:12:20.462, Speaker A: And I think you can read our article on medium for more details. But I think bridging is a bit unique because of how roll ups work, which I'll go more into detail. So I think the challenges with bridging in general is when you bridge to another ecosystem or another chain, you always ask yourself, like, are my funds safe or where are my funds and when will my funds arrive? And I think Starkscan sort of makes that process a little bit clearer and I explain why and how we do that. So how bridging works on Starknet is because it's a roll. So from Ethereum, when you bridge to Starknet, it gets rolled out back to Ethereum. So ultimately Ethereum is the true state, is the source of truth. It's always going to be Ethereum because ultimately everything gets rolled back to Ethereum.
00:12:20.462 - 00:13:17.442, Speaker A: So when you're bridging Ethereum to Starknet, you essentially send a message to Starknet, and then it gets rolled back to Ethereum. And when it gets rolled back to Ethereum, you know that it's confirmed on Starknet. And then if you're bridging from Starknet to Ethereum, you just bridge to Ethereum, and then you would have to send a transaction on Ethereum to confirm it. The reason you need to do that is because when you send a message from Ethereum to Starknet, Starknet understands messages from Ethereum. So you don't have to really do anything. But when you're sending a message from Starknet to Ethereum, Ethereum doesn't natively understand Starknet, so you still have to run a transaction on Ethereum to confirm sort of what happened on Ethereum. I'll go more into detail so you'll sort of see this more clearly, but this is a very simplified version of how the bridge actually works.
00:13:17.442 - 00:14:42.762, Speaker A: So if you want to get more into the nitty gritty, I would recommend you to read the Starknet documentation. So to sort of give an example of how this works, when you're bridging from Ethereum to Starknet, you can basically just check the status, and then when the status reaches the end, you know that your funds will arrive. It's more of waiting then you don't really need to do anything else. But I think the more interesting thing is, even if it looks like Starknet to Ethereum is more simple, it's actually more complex from a user's point of view because Ethereum doesn't natively understand Starknet messages. So if you're looking at Starknet to Ethereum, you send the transaction on Starknet, and then when it gets rolled down to Ethereum, you actually have to run another transaction on Ethereum so that you can confirm the funds has been withdrawn. So I think that's an extra step that's required when you're bridging from Starknet to Ethereum. So using Stark's and users can bridge in a more clear and confident manner, just because they know when the funds will arrive.
00:14:42.762 - 00:14:52.160, Speaker A: And then they can take the necessary actions to receive the funds through bridging. Yeah. Thank you very much. I appreciate your time.
