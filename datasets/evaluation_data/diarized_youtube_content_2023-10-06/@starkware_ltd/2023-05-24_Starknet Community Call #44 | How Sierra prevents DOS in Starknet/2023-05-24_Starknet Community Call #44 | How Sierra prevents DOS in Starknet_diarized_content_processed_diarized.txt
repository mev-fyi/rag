00:00:00.090 - 00:00:17.710, Speaker A: Please bear with me. And we are now live also on YouTube. So hey everyone, again, welcome to this 44th community call for Starknet. I'm Henry, your host for today, and I'm joined today by Ariel. Ariel.
00:00:18.130 - 00:00:18.878, Speaker B: Hello.
00:00:19.044 - 00:00:25.222, Speaker A: So, Ariel is a PM at Starquare. You're Mr. Cairo one, right?
00:00:25.396 - 00:00:31.078, Speaker B: I mean very new title, but yes, let's go with it.
00:00:31.244 - 00:00:57.646, Speaker A: Nice. But today we're not here to talk exactly about Cairo one, we are here to talk about Sierra. Let me give maybe a small introduction. Currently Starknet is in version zero point 11.2. So the measure version is zero point 11.1. Sorry. Well actually I just saw that zero point 11.2
00:00:57.646 - 00:01:28.822, Speaker A: was released on integration. Okay. But no, you're right, the major version is eleven and version eleven arrived in March. It was hailed as Chira one arrived on Starknet. And it is true you can now use Cairo one on Starknet, but underneath Cairo one is a major innovation, which is Sierra. I personally feel like in the way we presented Cairo, we often say, oh, Cairo is going to be so much nicer to use. It's a great language, it's more comfortable and everything.
00:01:28.822 - 00:01:53.950, Speaker A: And it is true, it's absolutely true that Cairo one is good, but it's a bit like reducing Chira one to its looks. It looks good, but it can do a lot more stuff. And one of the major thing that it came with is Sierra. And today we're talking about Sierra, the impact of it on Starknet and everyone is most welcome to ask their question. So Ariel, the floor is yours.
00:01:54.110 - 00:02:09.080, Speaker B: Amazing. Let me open the slideshow. Right now. Correct.
00:02:09.450 - 00:02:11.880, Speaker A: Not yet. Now I can.
00:02:12.490 - 00:02:50.450, Speaker B: Okay, great. Yes, so the title is Chir one and Sierra, but we'll mostly talk about Cr since Chiro is always at the very center. We'll also mention Cairo. Okay, let's go. And again, feel free to stop me at any time, also with questions from the audience. So a very rough Cairo timeline. Basically towards the end of 2020 we first released the very first version of the Caro Zero compiler.
00:02:50.450 - 00:03:42.706, Speaker B: Back then the white paper explaining the car assembly and the Caro VM was not even published. I'll say a few words about that. So first we had the first release of the compiler, then we had sort of expository paper of the VM itself. A few months after that we launched Sparnet on Mainnet, and then a year and a half later we had the first release of the Cairo one compiler. And a few months after that it was finally made available on Startnet. So it was quite a journey between the Cairo assembly and the first Cairo compiler from Cairo Zero to the new Cairo one compiler. So I'm going to talk about a bit about what we had initially, what still exists now.
00:03:42.706 - 00:04:00.790, Speaker B: Not everything was thrown away with color one. Actually a lot of the stuff remain the same under the hood at yeah, we're going to talk a lot about the new layer that was added with Kyra.
00:04:01.630 - 00:04:19.440, Speaker A: I'm going to just use this opportunity to say people, if you want to ask questions, you can ask them on Twitter, you can ask them on YouTube and basically on YouTube and Twitter we're looking for. Please, please ask any question you have. It's much more fun when people interact and ask us questions.
00:04:20.290 - 00:04:46.950, Speaker B: Definitely. Yes. So what's Cairo? So Cairo is probably the most overloaded word in the ecosystem. It is used for both the underlying vm, the cpu architecture, the high level language which is Cairo Zero. Cairo one is also Cairo. Cairo assembly is also Cairo. So basically everything is Cairo.
00:04:46.950 - 00:05:26.814, Speaker B: Actually Cairo stands for CPU L, which is basically a cpu architecture that we can make efficient proofs. So basically it's an entire cpu architecture. You have the registers, you have the memory model, you have the semantics of instructions how instructions affect the memory. So that's actually what Cairo is in a very few roles. That's the cpu architecture. And part of this is the Cairo assembly, the instructions for this cpu. And above this you have higher level stuff which compile down to this assembly.
00:05:26.814 - 00:05:29.380, Speaker B: So that was Cairo Zero, for example.
00:05:31.290 - 00:06:08.100, Speaker A: Funnily enough, when we talk with people who are used to zero knowledge or doing zero knowledge stuff, especially on Ethereum, they think circum in their head and they think, oh, so you have a toolkit to build my own circuit and my own prover and my own verifier. And one of the major thing to explain them is no, no, you don't have to deal with all of this. Cairo is itself a circuit. We abstract away the need to construct your own circuit to have your own proverb, your own verifier. You're just using one circuit which is the cpu which allows you to code arbitrary things.
00:06:09.830 - 00:06:51.774, Speaker B: When you're writing the Kyo program, you're basically writing for that cpu which we can prove executions for. So if we had efficient ways to prove x 86 executions, we wouldn't be here. But we don't. So that's where Cairo comes in. Okay, so the good old days we had Cairo assembly, which again is part of this cpu architecture. These are the instructions. So you had for example, instructions to put something in memory, whatever addition, actually addition and assignments are the same thing in Cairo assembly, but I won't really go into that.
00:06:51.774 - 00:07:39.194, Speaker B: You only had four different types, types of instructions, but that's the Kyo assembly. After that you had a high level language that compiles down to it. So can be funny to call Cairo zero high level, but you could write in it and it didn't feel like you're writing assembly. And people wrote pretty sophisticated things with chiral zero. So that's a snippet of things who are not likely to see for long anymore. So that's a very nice piece of history here. Okay, so what did we want to change in Colorado here? Why even looking at other things? So we wanted a more abstract language.
00:07:39.194 - 00:09:08.300, Speaker B: We wanted, for example, the memory model to be hidden from the developer, having to simply use defined variables with simple expressions and modify them with regular syntax from other language. We wanted higher level constructs like rays rectles the type system, and not have to walk directly with pointers. So yeah, the situation was here was not trivial, but a lot of the community members did fight with it and did name and very interesting things. But eventually we wanted to cater to a much larger audience, and not only people will like really seeing what happens with the memory with nearly every instruction that they could. Okay, so that's why we started with the whole Cairo one project. And you can see already in the snippets in the left side a lot of things that are completely non existent with chiro zero. You see arrays, you see generics, you see types everywhere for other than felt, you see different size of urines, and essentially a completely different world in that regard.
00:09:08.300 - 00:10:08.122, Speaker B: Things you don't see in these snippets are a lot of concepts from us. You have traits, you have implementations, you have matching. So a completely different world in this regard. But the topic of this talk isn't really Kyle one and the benefit it brings, but a safety property that it brings to starknet via an intermediate layer between Chiro one and Cairo assembly. So just to make the picture more clear, the Chiro VM and Cairo assembly over here at the bottom level did not go anywhere. It's pretty much unchanged from the original paper. And all we did was change the high level language and create an intermediate representation between the high level language and Cairo assembly.
00:10:08.122 - 00:10:31.442, Speaker B: So basically a user writes Cairo, one compiles, it gets VR compiled, it gets Cairo assembly. So it's not like we threw the Cairo VM away, actually, we're still using it as is. We just introduced a new intermediate representation and completely rewrote the high level language.
00:10:31.586 - 00:10:39.560, Speaker A: So we already had a virtual set of instructions, and now we're adding another one in the middle.
00:10:40.570 - 00:11:24.630, Speaker B: I mean, the VM and assembly are still the same. I don't know if I'd call it a virtual set of instructions, but yes, Sierra also comes with its set of instructions. So yes, I guess you could say that. Okay, so Sierra stands for safe intermediate representation, and if you take the right letters at the right places, you get Sierra. The representation is not unique, but yeah, we like the name. Okay, so like I said, you write Chiro one, you compile and you submit CR code to the network. Actually, the last step in the compilation is done by the start sequencer.
00:11:24.630 - 00:12:47.858, Speaker B: I won't go a lot into the structure of Sierra, but you can think of it as a very small core with all the different types of instructions being what we call leapfunks, which are basically logical units. So addition is a lib funk, substruction is a leapfunct, putting something in memory is a lib funk. And if you look at CR program, you basically see type, declaration, function, declaration, and a bunch of libfunk applications. So you can pretty much think of a CR program as a sequence of leadfunk applications, which I'm going to talk more about them in the talk. And the most important thing is that it compiles down to the same Cairo assembly that we had before. So again, this part is completely unchanged. Okay, so why do we need the color assembly? Why do we need Cr? Why do we bother with all those different types of representations and languages? Okay, so the most important point about Cairo assembly is that we need it to pull things.
00:12:47.858 - 00:13:36.770, Speaker B: That's why it was developed. We need the Cairo VM in order to efficiently prove execution. So I can't prove a sequence of Xav six instructions or EVM instructions as easily as I can prove a sequence of KyoVM instructions. So if I want to prove a computation, I need a way to express it in Chiro assembly. So if we want to prove things, we're going to need to use the same Cairo assembly as before or completely rework the proving architecture. But if you want to keep proving what we proved so far, we need Chiro assembly. So that's not going anywhere.
00:13:36.770 - 00:14:37.286, Speaker B: Okay, so what properties should these proofs have? Okay, soundness makes a lot of sense, or it should at least. You don't want the proverb to be able to prove an execution of program that does not execute correctly. And completeness, every execution can be proven. And I'm adding something that is only relevant in the context of Startnet, which means that I want reverted computations to also be provable. What do I mean by reverted? Same thing as it means in Ethereum and pretty much every other blockchain I have. Transactions that fail throughout the execution can happen basically to any reason. Maybe it's out of guest, maybe he tried to divide by zero.
00:14:37.286 - 00:15:52.380, Speaker B: Maybe a user used an assertion which does not hold, and in that case the transaction stops mid computation, but fees still charge. The sequencer still puts this transaction in a block. The Ethereum validators, for example, include those in a block, and if they couldn't include those in a block, it would have been a very difficult problem because it's work that you're doing as the sequencer, as the entity creating the blocks. If you're not being able to include even failed computations, then you're very easily exposed to denial of service. Because I can simply send a very complex transaction that fails after a huge number of steps on a very simple assertion, and you won't be able to get paid for the work done so far. So I have to be able to somehow prove even failed execution. I need to be able to prove that your transaction executed for such and such steps and reverted at this point is this.
00:15:54.370 - 00:16:59.986, Speaker A: I think it's really interesting when you look at the evolution of Starknet, I mean Starkx and then Starknet, how we got to Cairo one, and this exact problem you're describing is the code is not executed in the same environment. With Cairo Zero, we were trying to prove that we were honest operators, so we were assuming the operator wanted to prove that he is honest, but it didn't really take into account the possibility for somebody to execute code for somebody else and then prove that this execution would fail. Right. It was not fought in the beginning, as it was not fought for an adversarial environment where somebody would send you code that wouldn't execute and you couldn't prove. So it's really interesting to see this paradigm of proving computation evolving to get more robustness, more resilience. Now we're getting to a point where we actually want to prove that your code is failing. So I don't know, I think it's really interesting.
00:16:59.986 - 00:17:02.162, Speaker A: I don't know if that makes sense, but I agree.
00:17:02.216 - 00:17:20.842, Speaker B: Yes, it wasn't a concern initially, but as startnet evolved and we started thinking about decentralization and potential denial of service on the sequencer, then it became a very big and concrete concern, and one which Cairo assembly did not have an immediate answer for.
00:17:20.976 - 00:17:48.078, Speaker A: Yeah, and it's also an interesting evolution that impacted the performances of the Cairo Vm. Right before that we could do away with the performances of the Cairo VM for sequencing, and now we can't. That's a question for a topic for another day. But I find it really interesting to see the stack evolving with, oh, we actually need something else. So it's one of the logical.
00:17:48.174 - 00:18:00.280, Speaker B: Yeah, I'll also talk about that. So it's the definition of a great question. We have some slides about it. Okay, any questions from anyone in the audience so far?
00:18:01.050 - 00:18:06.486, Speaker A: Let me check. No, there's people watching, but no questions so far.
00:18:06.668 - 00:18:54.386, Speaker B: Okay, so we'll push him on. Okay, so basically that's the big problem that CRI is attempting to tackle. Revert the transaction and DOS attacks. And I'll explain what I mean with the unsatisfiable. Okay, so let's focus on this library function in Cairo zero, which looks for an element in the array. You don't really have to know the syntax, but it gets a pointer to an array, it gets a key to search, and it should return a pointer to the element if it's there. So you see here an index variable being defined, and then you check that index is within the bounds of the array.
00:18:54.386 - 00:19:55.286, Speaker B: But then you see an assertion that the element you're trying to look for is indeed in the index, which is inside the index variable. So you define an index variable and without putting anything in it, you expect that it would be the index of the element you're looking for. So as a standalone code, it makes no sense. Like I define a variable and I somehow magically hope that it will contain the index of the element I find, I want to find. But that's where hints came in, which I omitted them for the remedy. So in line four, basically, since there are no constraints over index within Cairo, you don't see a substitution into index. It basically means that the proverb has complete freedom to put whatever it wants in this variable.
00:19:55.286 - 00:21:07.134, Speaker B: And this hint basically looked inside the array and found the appropriate index if it existed. So that's work that's being done outside of the context of kyra before the program is being proven. But once you know what the index should be, you just put here five and the code will compile successfully because the assertion in line eight will just walk. And an interesting thing to notice here is that the element, if the element is not in the array, if I called find element with an array and the key which is not present, then nothing will cause this code to execute correctly. This code is unprovable in this case because this assertion induces constraints that will never be satisfied. Nothing that you will substitute into index will cause the constraints induced by line eight to be satisfied. So maybe a few more words on the Cairo VM and Chiro assembly.
00:21:07.134 - 00:21:32.078, Speaker B: Basically, the way that we're proving chiro executions is that every instruction translates to constraints on the execution trace. And these constraints are either satisfiable or not. And a simple assert instruction with the left hand side being not equal to the right hand side means that your constraints are no longer satisfying.
00:21:32.274 - 00:21:44.960, Speaker A: So with a dummy analogy, if you try to find an element and it doesn't work, then your Cairo CPU will throw a blue screen of death and crash and there's no way to recover from it.
00:21:45.650 - 00:22:34.030, Speaker B: Exactly. The Chirovm can't proceed after line eight if the element is not there and we cannot prove it. Okay, but there is an advantage here that if the element is there, then I only needed a constant number of chiro instructions to show that the element is there. I don't have to do the entire search within Cairo. So that makes the proof much more efficient. Okay, so that's Cairo zero and which compiles down to Cairo assembly and had the hint syntax. I want to claim that this code contains a very dangerous weakness.
00:22:34.030 - 00:23:37.682, Speaker B: Okay, so if the element is in the array, the proverb can easily substitute the correct value for index and create a valid proof. In the happy flow, nothing goes wrong. However, if the element is not in the array, there's nothing we can put in the index variable that will result in the program running successfully. This means that I won't be able to prove it, which means I will never be able to charge money for it, because if I can't prove the block, I can't get fees for it. Okay, so what's the problem? I have a very simple service attack on the SQL server. Just define a very large array and call find element on a key which is not there. Since this transaction is not provable, you will not get compensation for the work that you did up until the point you discovered the element is not present.
00:23:37.682 - 00:24:15.440, Speaker B: Because again, recall that someone does the work on line five, which is hidden in the hint. Someone is going to actually look through the array and figure out the element is not there. It's just not happening within Cairo instructions. So the sequencer is expecting some compensation. But if you defined an array of size, whatever, 1 million, and you figured out that the element is not there, then tough luck, no money for you. You can't put this transaction, you can't include it in a block and you can get paid. Is the attack clear? Any questions?
00:24:17.250 - 00:25:06.720, Speaker A: It is clear. Let me see if there are questions. So Siberjun is asking, are there any necessary necessities where we would need to prove rewarded transactions? I think we discussed these, but what you described, yeah, on Ethereum, you're safe from that because as soon as your transaction enters the vm you can prove that you executed some instruction as a validator. And if the transaction reverse, you can charge for gas. In that case you can't prove that the transaction is shit, so you can't charge people for it. So this is a big attack vector because then the sequencer has to do a lot of work and it doesn't get compensated for it.
00:25:07.970 - 00:25:57.070, Speaker B: Exactly. Okay, so what are we going to do about it? This means we can't keep the situation as is. This can't be the way to look inside arrays within target smart contracts. Okay, so basically the question I'm asking is how find elements would look like in Sierra. So recall that I said that Sierra is basically, Sierra program is basically a sequence of what we call libfunk. Let's say I want to write down a lib fund for find element and it should compile to chiro assembly. So how would I compile it to Cairo assembly? What would the Cairo assembly look like? Because the Cairo assembly generated from this is not good enough.
00:25:57.070 - 00:26:49.280, Speaker B: We already discussed it. Okay, so we must be able to handle the keynote found case. So in the happy flow nothing changes. We can still get the appropriate index from a hint and just assert that the given element is in this hinted location. But in the unhappy flow we must go through the entire array and actually verify that it is not there. So if you go back here, this means that I would have to replace this assertion with something like if else. And in the else clause I would have to actually go through every member of the array to verify that it is not there.
00:26:49.280 - 00:28:29.870, Speaker B: And in that case actually, instead of failing returning something like not found or returning zero or whatever. But I would have to handle this case within the chiro assembly generated from, from this instruction. And this is a very crucial point when lead functions are being added to Cl, let's say we want to add some logic to the language and whatever we want to add, maybe find elements, maybe some hash function so you can think of, okay, you just have to write some chiropractor assembly for it, and then add this to the compiler, add the find element link punk and compile it to the chiropractor assembly that you want. But this is not good enough because you have to make sure that the associated chiral assembly is complete in this very precise sense, that there is no flow in which I cannot prove it. There are no cases like this one where for some set of parameters, the resulting assembly is unprovable. It has to run successfully for every parameter for every possible input. So the addition of new lip funks is very sensitive in this regard because it involves the DOS security of Startnet.
00:28:30.450 - 00:28:39.490, Speaker A: Are lip funks something that can be formally verified or formally verified? Like is it possible to formally verify?
00:28:40.390 - 00:29:34.622, Speaker B: I think so. I don't know enough about formal verification to know if it's a good candidate, but it sounds like a good candidate from the limited knowledge that I have. What happens now is basically manual audits, which did reveal some completeness issues that were fixed. That's why when we add the leadfunts to Starknet, they are not immediately allowed on the actual startnet. So if you played around with Chiro one and the compiler told you something like this libfunk is not included in the allowed lib funk list, that's exactly about it. This leapfunk was not yet audited, so it's not available on the real startlet. But locally, when you're compiling, you can use the allowed leapfunct flag and allow to use all what we call the experimental leapfunks, the ones that are not yet audited.
00:29:34.766 - 00:29:49.100, Speaker A: It's funny you mentioned that, because a bunch of people recently have had this exact issue. They were like their code used to compile and be deployable on Starknet, and now it uses a new leapfunk or something that is not allowed yet on Starknet, and so they can't deploy it.
00:29:49.470 - 00:30:50.010, Speaker B: Yes, so in the initial versions there were some lead functions that were renamed or changed, and that basically broke this compatibility. We hope that up to bugs, the only change essentially in CR is the addition of new lead. Yeah, but let's say we add the lead font, then you write Kyle one code. You don't write CR instructions, so it can be in a way transparent to you. Like you see a new fancy Kyle one syntax and you try to compile it and you get this error. And that's because the new fancy syntax relies on league funks that are not yet audited. So if you come across this error, know that this is about this, and these leak functions are waiting to get audited, and they will eventually be part of the reinstallet.
00:30:50.010 - 00:31:56.794, Speaker B: Okay, so there are other benefits we can get from Sierra except security against denial of service. So I'm going to talk about two main things. One is provable gas metering, and the other is different execution environments, which you mentioned in the beginning. So let's start with a provable gas metering. Let's think how gas metering happens in Ethereum. So assuming that if you go and look at whatever guest code or any code that executes EVM instructions, you will see something like a loop that runs an instruction, and after every instruction it updates some gas counter which lies outside the context of the VM. Possibly you just maintain it, and every instruction you have a small overhead which has to update this counter.
00:31:56.794 - 00:33:03.480, Speaker B: Like if you did the f store, then you got to add 20k guests to this counter, or decrease from it, whatever. But there's an overhead for each instruction, and it's not a problem why you don't care about actually proving this. But if your intention is to actually prove that executing your transaction cost ten k gas, then adding an instruction, even if it's just a matter of updating something in memory, adding an instruction on top of every single existing one, is a very significant overhead. You essentially double the proof complexity by doing this, which is very not something you want to do. MCI gives us a way to sort of overcome it. There is still an overhead, of course, but it is not the overhead of updating a gas counter after every instruction. And I'll talk about it in a bit.
00:33:03.480 - 00:34:04.330, Speaker B: The second big thing is separation of execution environments. So recall that back here I said that we need cousin to prove things. So the proverb has to know how to execute and prove Kyra sends no way around it there, but the sequencer that only puts the transactions in a block. It has to do it in a very short time span, or in future we'll do it in a very short time span. There are no constraints on his execution environment. Like maybe it shouldn't run Cairo assembly, maybe it can somehow translate Cairo assembly into something else. Or maybe since we now have an intermediate representation before Cairo assembly, it can use Sierra directly and not go through this compilation, which is only necessary for proving.
00:34:06.350 - 00:34:22.250, Speaker A: When you say this compilation, the compilation to chasm, that is necessary for proving. It's more like in order to prove it, you need to execute the Cairo assembly in a specific context. That instantiates the Cairo CPU, right, which has a big overhead.
00:34:22.410 - 00:35:04.258, Speaker B: Exactly. And I mean Sierra has link functions like 64, so 64 is a native cpu instruction on any architecture or U 32. I don't really need to work with a Chiro VM for that I have cpus who know how to edit. So why go down to the much more specific representation and not use the intermediate representation directly, which is more about the semantics of what you want to do rather than how exactly to use the memory of the Cairo VM to do this operation.
00:35:04.454 - 00:35:33.906, Speaker A: Why couldn't you do this before with Cairo Zero? First of all because felts are weird, and second because Cairo zero, you can't know in advance whether this will be provable or not, whereas with Sierra, if you're able to execute Sierra, you know it will be provable. And so the sequencer knows that eventually he will get paid for it, even if he can't generate the proof.
00:35:33.938 - 00:36:13.970, Speaker B: Right now I think the reason is slightly different, because you could have executed something else, and let's say if it failed, ignore the transaction as it happens today. I think the biggest reason for why it's possible now is that you have an intermediate presentation between user code and proven code. Before the user sent you Kyo assembly, he may have wrote in Kyo Zero, but it sent Kyo assembly to the sequencer. The user did not send Sierra, so nothing you could do. At the sequencer. You get Cairo assembly, that's where you os, but now you're getting Cl.
00:36:14.040 - 00:36:57.060, Speaker A: Okay, so Cairo assembly, you still can't execute it, for example, more efficiently on x 86. So when you received it as the sequencer, you had to execute it on the Cairo CPU. Now if the user sends you Sierra, that one, you don't have to execute it on the virtual Cairo CPU. That has a lot of overhead. You can execute it directly on the metal of your machine and use the transistors. But I think there's also my point, maybe it wasn't clear is also that if you're the sequencer, you need to know whether your transaction will fail or not.
00:36:58.790 - 00:37:03.842, Speaker B: If you're the sequencer, you need to know the transaction. But you could still do that with.
00:37:03.976 - 00:37:10.840, Speaker A: Cairo assembly, and you could still do that with okay, sorry.
00:37:11.850 - 00:37:54.142, Speaker B: The difference is that unlike the Cairo assembly case where you're just send because it failed, and you know you can prove it now, you don't care. It's the user's problem, you're getting the fee, and that's a big difference from the sequencer point of view. Okay, so a few words about gas metering. Essentially there's gas counting. That happens at compile time. There's what we call the local gas wallet. And there's a new league funk which is designed specifically for updating discounter, which is called withdraw gears.
00:37:54.142 - 00:38:57.720, Speaker B: So let's look at how it works in partly. So that's roughly CR instructions. I mean not this high level function declaration, but at least here you see a bunch of CR instructions. But let's assume every line here is a CR instruction and I have two branches, if and else, and how we handle gas metering instead of updating the counter after every single instruction we can ahead of time say how much gas is needed and every instruction can, and this is something that can be checked in compile time decrease from this counter. So let's say I added a sort of artificial instruction here which is called withdraw get, and it requests 30 guests. Okay, and if I'm looking at the if branch, the first instruction took a step, another step, and eventually I paid whatever some number of steps. So I end up with 28 steps available.
00:38:57.720 - 00:40:07.230, Speaker B: The else branch also has some requirements. I think the number here should be 35. Okay, so the point is that this is a property that I can check at compile time. When I get the Sierra code, I can check okay, does this function ask enough guess for what's happening inside? Do I have enough guess for the entire if branch and the entire else branch? So I don't know ahead what's going to happen, whether the if is going to run or the else is going to run. But I can statically check that I have enough guests for the worst case. And very roughly what happens is that instead of updating the counter every single step, we update a counter only at branching point. So let's say calling a function or an if else branch or some loop, but the counter update itself can look at a block of code statically.
00:40:07.230 - 00:40:10.640, Speaker B: Does that make sense?
00:40:13.650 - 00:40:36.982, Speaker A: And yes, I think I understand that instead of having something being executed at each instruction, the compiler will check whether we make sure that we are paying enough. Yeah.
00:40:37.036 - 00:41:10.898, Speaker B: Okay, let me try it with a concrete example. So basically the goal is to reduce the granularity of this counter update. But let's imagine you submitted CR to the sequencer which does not have this line, which does not have withdraw guards 30. The sequencer looks at this function and it says okay, but you have an if branch that requires, I don't know, 20 steps. This is checked statically by the compiler. And where is the gas that pays for these 20 steps? You did not withdraw gas. This is the problem.
00:41:10.898 - 00:41:55.570, Speaker B: I'm not going to compile this to Cairo, send it. This is something that is checked by the Sierra two cousin compiler, and if the compilation fails you can submit it. So if you want to trick someone and let's say write withdraw guard zero here it won't work because you don't have enough guests to pay for static instructions and in case there was some dynamic thing happening like a loop inside fib. Okay, you don't know ahead of time how much gas you need for the entire loop, but you do know how much gas you need for every iteration. So you would see inside the loop body one withdraw gas instruction. So every iteration of the loop will give you an overhead of one counter update.
00:41:57.750 - 00:42:15.734, Speaker A: Okay, I think it makes sense. I guess my question now is so does this mean that you can't update the price of opcodes or instructions later down the line?
00:42:15.932 - 00:43:08.120, Speaker B: Very good question. So that makes pricing very sensitive because this thing compiles to chiropractor assembly. And if I wrote here withdraw gas 30 and it was okay because a plus b costs one and whatever, initializing the constant costs two and so on. These numbers now appear in Chiro assembly, like this number 30. You find it in the Chiro assembly of the program which is being proven. So let's say now you want to update, you say okay, actually doing addition doesn't cost seven five units, it now costs ten units. Then there is no immediate way to do it other than recompiling your CR.
00:43:08.120 - 00:43:53.960, Speaker B: So these are actually being added by the compiler. You as a user, you don't have to. In the Cairo one code you don't have to manually insert this withdrawal guard instruction. The Cairo to Sierra compiler can actually put the appropriate numbers for you. But if the Sierra was maintained and it is kept by the sequencer today, then if we want to increase the price of some lib funk, then what we can do is recompile the Sierra with updated numbers and then it will look at the code and say okay, plus b cost ten. Now I need a different number here.
00:43:55.690 - 00:44:05.290, Speaker A: So what happens if one. So you're saying the sequencer is basically in charge of checking that gas is paid properly.
00:44:06.190 - 00:44:11.870, Speaker B: It's the responsibility of the compiler. The sequencer runs the compiler.
00:44:12.530 - 00:44:34.626, Speaker A: And is there any way for the sequencer to use to tweak the compiler so that he accepts Sierra code with much lower prices that then become a burden? Is this an attack vector where one sequencer can say yeah, actually allow free contract on Stacknet and then you guys deal with it?
00:44:34.728 - 00:45:08.350, Speaker B: Yeah, it's a really good question. And the answer to it is what we internally call full Cr. Eventually compilation will be proven, it will be part of the starnet OS. So there is one compiler which is being proven and you can deviate from it. So if the compiler expects one set of prices, you can just say as sequencer a I want different numbers. You can do it because you won't be able to prove the compilation.
00:45:09.090 - 00:45:12.350, Speaker A: Let me prove you that I prove you something provably.
00:45:13.590 - 00:45:41.690, Speaker B: Exactly. Then no, you won't be able to do it. But it is an attack we need to handle. Because you're right, a malicious sequencer would maybe want to include a contact that does not pay guests everything. All the withdrawals here are zero. So we'll handle it by having to prove the compilation.
00:45:42.590 - 00:45:49.050, Speaker A: Nice. Is there any kind of timeline or rough estimate for that, or is just on the horizon?
00:45:50.270 - 00:46:13.598, Speaker B: Not yet. Actually proving the compilation? Not yet. So now you have the Cairo one to Sierra compiler written in rust, and you have the Sierra to Cairo assembly compiler also written in rust, and one day written in Cairo, maybe in Cairo, one which will compile to Cairo assembly. And no, I can't give a timeline for that, but it's definitely in the horizon.
00:46:13.774 - 00:46:14.500, Speaker A: Nice.
00:46:15.830 - 00:47:02.958, Speaker B: Okay. Yes, so we have a few minutes left, which is great. So now I want to say a few words about separating the execution environment for the sequencer. So the idea is don't go between Scara to Cairo assembly, you're the sequencer, you are not responsible for proving the block which you are now executing. Why care about Cairo assembly? Just run the stuff on your native architecture. Okay. And what's interesting here is in a lot of the instructions, CR has information which basically lends itself to optimization.
00:47:02.958 - 00:47:26.966, Speaker B: Let's consider U 32 ed. That's a link funk. And if you see this link funk being used, you have an immediate way to translate it into a native assembly instruction, which is amazing for you as the sequencer. You definitely not want to go down to Caio assembly just to perform 32 bytes addition.
00:47:27.158 - 00:47:30.658, Speaker A: So that's why we tell to people don't use felt anymore.
00:47:30.854 - 00:48:34.850, Speaker B: Yes, this is one of the reasons. Indeed, it will also help to transition between fields in the future. But yes, this is one of the reasons. And this is actually not Sci-Fi this is a project that is now happening by lambda class, and they already translated many lib functions to MLIR, which I think stands for multi level intermediate representation. And this then compiled down to native code. So they were actually able to move from Sierra to native code and run some functions written in Pokiro much faster compared to the Cairo VM runner. There's still a lot of work to do on that front, but it's definitely not Sci-Fi and we expect that in a few months, small number of months, they will already be able to interface contracts.
00:48:35.190 - 00:48:41.602, Speaker A: The concrete impact of this will be what better performances for sequencing and also.
00:48:41.736 - 00:49:38.360, Speaker B: For native testing and locally working with standard contacts. If you're using Devnet, why go through Kyle assembly? You're doing tests you don't care about proving unless you're actually working on proving. But if you're starting a developer, you really don't need to run Kyle assembly on your day to day. Nice. Yes, very exciting stuff. So in the future we can expect a lot of more leaf funks, more chiro one improvement, freedom in the execution environment, also more of the ecosystem transition into rust, which is apparently already happening. And yeah, you can go to the Cairo book, Cairo Docs Discord, start writing and join the fun, basically.
00:49:42.810 - 00:49:43.800, Speaker A: Very nice.
00:49:44.490 - 00:49:45.446, Speaker B: Thank you.
00:49:45.628 - 00:50:20.942, Speaker A: Thank you a lot for your time. This was really interesting. It's really in depth, but I think it's. Well, it's really interesting for people to understand the rationale between doing all of this and all the doors it opens. I think that Cairo one is one step on the journey of Starknet, but it's a massive one, right. And it's really important for decentralization also, I don't think we can really think of decentralization without DOS resistance and censorship resistance. So it does lay the foundation for having a resilient network decentralized.
00:50:20.942 - 00:50:44.250, Speaker A: That's pretty cool. Let me check. I don't think we've had any questions. I'm pretty sure that in two weeks, Elias, we'll pop up in Twitter saying, hey, I watched a call with Ariel on Cairo one. Can I ask some questions? Well, Ariel. Sorry, where? Elias, you should have been there today. Fine, we'll answer your question regardless.
00:50:44.250 - 00:50:54.560, Speaker A: No, but. All right. I don't see many questions. Thank you for answering mine, Ariel. Always a pleasure to have you. And I'll see you soon.
00:50:55.810 - 00:51:00.480, Speaker B: Cool. Expecting questions on this call and Twitter, everyone.
00:51:01.090 - 00:51:14.060, Speaker A: I'm sorry. Yeah, sure. So please tag Aryav on Twitter at feedthefed, the one and only. All right, so without further ado, thanks everyone. Have a good day.
