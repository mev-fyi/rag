00:00:03.930 - 00:00:20.590, Speaker A: YouTube live. So you guys should be able to see us now on YouTube. Let me turn on my camera and say hello. Hello. And I'm going to activate screen sharing for Abram.
00:00:25.370 - 00:00:26.120, Speaker B: It.
00:00:30.090 - 00:01:08.654, Speaker A: And going back to the community call on this call. All right, so we're ready to start. We have 100 people in the audience. Thank you everyone for joining us today and welcome to our 15th community call. Pretty cool. We've been doing this for a while now. So today we're going to have a presentation by Braavos, who is a Starknet wallet and then we can have a short ama if you guys have questions on Starknet.
00:01:08.654 - 00:01:33.240, Speaker A: As usual, there are no specific points I want to cover for the roadmap. So it's really up for discussions and what you guys are interested in talking about. We lost Abram on Zoom, so I don't know if you're still on YouTube. Welcome back Abraham. And you'll be able to share your screen.
00:01:34.250 - 00:01:35.000, Speaker B: Hello.
00:01:35.790 - 00:01:40.800, Speaker A: So let's go. The floor is yours, Abram. Welcome and thanks for joining us today.
00:01:41.810 - 00:01:44.800, Speaker B: Hello everyone. Can you see my screen?
00:01:45.730 - 00:01:53.280, Speaker A: Yes, we just a note. Oh yeah, no, we can hear you on this card now. Perfect.
00:01:53.990 - 00:02:52.580, Speaker B: Okay, great. So hello everyone, my name is Abram and I'm from the Bravos team. And today we'd like to talk to you about Getstarknet, which is a library wrote a few months back with the purpose of easily integrate Dapps and wallets, cover for connectivity and discoverability of wallets, offer built in multi wallet support for Dapps and of course maintain an open source set of APIs between Dapps and wallets. So the fourth section in this keynote will be motivation, the ideation solution and community. Motivation is basically about why we thought we should build something new. The ideation part is about what we thought could be the best solution for dub developers. Solution is basically how we did it and the community is about who uses the library and how you can take part in the action too.
00:02:52.580 - 00:03:26.026, Speaker B: Let's start. So what options dubs had before get Starknet. So the first option would be access Windows Starknet object directly. They use that to look up a wallet installed in the browser and interact with it directly based on the APIs they assume it exposes. So yeah, it's simple, it's quick, no dependencies. Sure. But of course there are a few issues with this approach.
00:03:26.026 - 00:04:30.900, Speaker B: Well, the first one is there is no guarantee for the key to be used in future wallet projects. So you just assume that window Starnet will lead you to a stagnet wallet which can be wrong. The second issue is that wallet APIs change over time, and there is no beating way for DAP to know about deprecated or newly added APIs within the code because you don't have the types, you assume that you are listed on some kind of subscription mainly about changes in the wallet. But there is no built in way for you to do that. And of course there is the possibility that there is no wallet installed. So as dub developer you have basically two options. A you losing the user or you are forced to implement and maintain your own wallet discovery UI, which leads to multiple issues.
00:04:30.900 - 00:05:49.750, Speaker B: For example, how do you know about new wallets in the ecosystem? And even if you know about new wallets in the ecosystem, how do you make sure that all these wallets suggest and expose the same APIs your code is currently assumed they have? And of course it forces you as a data developer to implement and maintain your own UI, which is a burden you probably don't want to do. So we covered about the problems for accessing widow Starknet object directly, and of course there was another solution which came later. It was a library called Argentarknet which came with a few solutions for this pain point. The first one is just that encapsulates the window of the taxes. As a DAP developer you call Getstacknet and the library encapsulates all the logic about looking up the window starknet object if the key changes. Another logic is involved in the way between the DAP request and accessing the actual object. All this logic is encapsulated in the library.
00:05:49.750 - 00:06:49.482, Speaker B: And as a DAP developer you don't care about it and just getting the wallet object or just passing the request to the wallet. It also offered strongly typed wallet APIs in the library typescript APIs, so you could explicitly know about exposed and deprecated APIs either while developing your DAP or during build time. You get warning on deprecated methods, things like that. So the problem of not knowing about APIs is also solved. And it also aimed to solve the problem of no wallet is installed. So it exposed a wallet discovery pop up that the DAP shows implicitly once it tries to connect to a wallet which isn't installed on the browser. But there was no multi wallet support, and as we know, there was more than one wallet in the ecosystem.
00:06:49.482 - 00:07:43.522, Speaker B: And every healthy ecosystem has more than one solution for wallets. So what argent didn't provide developers, it assumes there is only one wallet on startnet. So assuming the user installed another wallet that DAP couldn't know about it. The user can't use it with the DAP, so it leads for frustration on post DAP and that now needs to implement per wallet integration. And for users who downloaded a wallet they use to maintain other assets and now they can't use it with this particular DAP. And for the wallet discovery pop up, there was only one wallet listed in there. So a Dapps can't seamlessly promote other wallets, assuming it's something they tend to do.
00:07:43.522 - 00:08:32.320, Speaker B: And also Dapps implicitly promoted only one solution in the ecosystem for wallets, which is not necessarily what they're trying to do. There was also no building way for Dapps to know which wallet they are connected to. So Dapps needed to assume that if there is a connected wallet, it is probably the one we had till today, but it's not necessarily so. So it leads to complaints from users that I'm connected with wallet X but it shows me that I'm connected with wallet Y and now the developers need to handle these use cases and there is also the inevitable conflict with other wallet needs. And this is of course definitely something that developers shouldn't be worried about.
00:08:32.870 - 00:08:33.620, Speaker A: So.
00:08:35.510 - 00:09:58.022, Speaker B: We just covered what was the options back then and let's jump to the ideation phase. So we thought to can we build something better? And by something better we mean that a solution that allows us to seamlessly connect to any wallet on Stocknet. So as developer you should spending your time building new products and not integrating with new wallets every now and then, allow wallets to seamlessly connect to any Dapp and get discovered by user which needs a new wallet. It's all about the ecosystem. It's simple solutions for wallet providers to know which APIs dapps are currently expecting them to expose an open source wallet app API controlled by the community. Well, there were no big legacies to end back then. Stacknet didn't say days and we really thought it would be good to avoid some of the layer one obstacles around APIs standards, which we really don't need to go through the same cycle, and to have a clear roadmap for new and deprecated APIs, community standards for these APIs.
00:09:58.022 - 00:11:02.750, Speaker B: So as developer you have time to plan your features and future roadmap based on this future APIs, the prosperity roadmap and the clear roadmap for all world providers in the ecosystem and an open source darknet wallet discovery list modeled by the community. It's very important for the community to have a place to give feedback about new world providers. Make sure that new wallet providers listed in the Discover list are all aligned in terms of security and APIs with the rest of the wallets on that list. And it's a safer approach for the community at all. So we also wanted to do everything we just mentioned by changing a single line of code. So yeah, that's possible. The solution was to create Getstarknet, which is Starknet Wallet DaP bridge.
00:11:02.750 - 00:11:50.670, Speaker B: It's integratable with zero burden for all existing dapps and zero burden because it exposes for each world provider the same APIs you as DAP developer expect to have on the Windowstacknet object and enforces the same API events and flows that you as DAP developer already familiar with from Argentarknet. So if you already use the Argent library, the only difference in code is now that instead of importing ArdentGetstarnet, you will import Getstarnet, the exact same API, but from the community, from Getstarknet, it's that easy and gets darknet features.
00:11:55.750 - 00:11:56.066, Speaker C: A.
00:11:56.088 - 00:12:44.578, Speaker B: Few innovative methods for DAP developers. First of all, it encapsulates the entire stacked wallet discoverability for dapps. It looks for all installed wallets in the window. It formalizes the key mechanism to make sure that there can be multiple wallets installed in parallel and for the Daps to be able to connect with each one of them without overriding each other. It allows us to control which wallets to list, exclude and promote. It's very important for dapps to have this control over which wallet is the first on the list. Maybe it's a wallet that supports their needs better.
00:12:44.578 - 00:13:59.274, Speaker B: Maybe they have some kind of business opportunity with that wallet provider, et cetera, or a way for them to exclude specific actors from the list. Assuming there is a problem currently with the integration between the DAP and the wallet. It also offers violent wallet Connect mode like Silent Connect, which allows you as DAP developer to connect silently to previously authorized wallet. So you don't even need to show the connect button for users, you just attempt to silently connect with the wallet. If you succeeded, great. If not, you can show the connect button and let the user connect explicitly. You can force the Connect UI to show up using the visible mode or fall back to the smart default, which is constructed automatically based on which browser you are currently using, which wallets are available for this browser, which words are currently installed on your browser, and of course which word you use last.
00:13:59.274 - 00:15:00.526, Speaker B: So there's some kind of smart combination in there. The entire logic and flow is written in the project and also in docs. It also allows new features such as switching wallets on runtime. This is a feature we couldn't do as developer before, and probably most importantly is that one API to align them all. It's to make sure that all players in the ecosystem have a single place for discuss and moderate new APIs. It's very important for both DAPP developers and forward providers to have a single API scheme for working together and making sure that they know which API they should expose. Where and where, what is the flow, what are the expected requests and responses and things like that.
00:15:00.526 - 00:15:57.226, Speaker B: It saves lots of time for developers while developing their applications, of course sends lots of promise for web providers to make sure that they are providing their dapps the best experience. So community first of all, Getsnet is backed by stockware. It's hosted on a neutral repository under stockware name. There is an organization for community libraries created by Stockware, and Getstocknet is the first library listed over there. It's already used by various dapps in the ecosystem. As you can see, the first one on the list is actually ardent Getsnet, which nowadays actually wraps Getsnet. So if you are a DAP currently using Ardent Getsnet, you're actually using Getstacknet implicitly.
00:15:57.226 - 00:17:11.442, Speaker B: So it will be safer for you to just move directly and use the community library explicitly. It is also used by stockware owned dapps such as Stargate, the bridge between L one and l two NFT platforms such as brick players and Minsquare AMM such as my swap, and other dapps such as.com and actually even more infrastructure libraries such as web three Stocknet React. Soon it will be used by Voyager, jDexwap, and hopefully by you. As for the roadmap, the first plan is to formalize the interface, the istacnet window object interface, to becomenet community's standard web API. And make sure that Getstocknet repository is the place where developers and wallet provider devs are discussing and iterating on new and improved APIs. It's natural to do so in the same place where the code is written, where the prs are created, when the issues are listed.
00:17:11.442 - 00:18:23.070, Speaker B: So having all these discussions about the future APIs, the current and future APIs. Of course for Stocknet wallet providers and DAP available APIs, it just makes sense to edit all dell. This is actually an already open discussion we have with other players in the ecosystem. And second phase is to separate core and UI to different packages and support more UI frameworks. So nowadays Getsnet encapsulates the entire connect phase and discovery phase for dapps. So as dap you just call the getstarknet or the Connect API and implicitly the library injects compiled HTML five code into the DOM showing the connect options, showing the discovery options, following the users through the installation phase of new wallet, et cetera. And it was created like that to make it as simple as possible for that developer to start using the library.
00:18:23.070 - 00:19:36.626, Speaker B: But of course other core libraries such as Stacknet, React and others would like to have more control over the flow and allow different frameworks to have different callbacks and hooks around the core logic of the library. So soon we'll start separating the core and the UI. It's not a big task, but it's something we need to design correctly and do with the community and of course give dapps and users even more control over the library. We have multi chain support in the to allow users to disconnect from the connected wallet implicitly from the connect API. So dapps don't need to implement their own disconnect or wallet switch UI. It all will be built in in the library mechanism that involved with default wallets and thinking about keeping the default setting. Of course Dapps, we also have down the road some thoughts on how to vote for new wallets on chain.
00:19:36.626 - 00:20:07.040, Speaker B: Please take a look at the readme and of course, oh sorry. And of course prs are welcome. This is the link to the library. You can look at it now. Please use it, give us feedback and join the discussion and help us shape the future of. Net. Yeah, so any questions?
00:20:08.450 - 00:20:09.402, Speaker C: Thanks Abram.
00:20:09.466 - 00:20:33.634, Speaker A: This is really interesting. Thanks a lot. So to the people in the audience, your questions are welcome. Don't hesitate and send them in the chat. You can write them in the community calls channel and we'll be happy to answer them for the people following on YouTube. You can also write your questions in the comment and we will answer them. There are no questions right now, Abram.
00:20:33.634 - 00:21:51.898, Speaker A: So I was wondering if you could talk to us a bit more about Bravos, which is also a wallet for Starknet that you guys are developing. And specifically I'm curious to hear your thoughts about how different it is to develop a wallet in a network with account abstractions, which is the case for Starknet. And before you start, I'm just going to make a short resume of what account abstraction is for people who are listening to us. So in a blockchain network such as Ethereum, your account and the way you identify towards the blockchain are the same thing. Meaning that when you're sending a transaction, you're signing an object with a private key, and that signed object has an identifier attached to it, which is your public key. This identifier is used to hold your assets, which means the blockchain considers your public key to be the owner of your assets. Account abstraction is a construction that basically allows you to write a smart contract that will be the holder of the assets.
00:21:51.898 - 00:22:59.160, Speaker A: And instead of authentifying the users using the transaction, we will authentify the users at the smart contract level, at the wallet level. So now your transaction doesn't really have an owner or an account attributed to it. It is sent to a wallet contract that does the identification. And this wallet contract is used to hold your funds, and this wallet contract will authenticate you using a private key or a public key. Now, the fact that you're adding authentication at the smart contract level allows you to have a lot of interesting features and to do a lot of things in the future. You can think about a lot of things. And I'm just curious, Abram, if you have thoughts, things you want to add on my description of count abstraction, and if you could talk to us a bit about how Bravos approaches this development process and what kind of features you guys are excited about for account.
00:23:01.770 - 00:23:36.262, Speaker B: Right? Sure. So first of all, Bravos is a wallet for. Net. We launched about a month back. It was around a hackathon in Amsterdam and we were the first wallet to list NFTs on Starknet. And we also launched on Firefox originally a few weeks back. Now about the account obstruction.
00:23:36.262 - 00:24:51.830, Speaker B: So first of all, the smart contract based account allows us to do lots of cool things that aren't possible on layer one. First of all, it's account proxy. It allows us to upgrade your account capabilities over time without the need of creating new accounts. The entire process is more or less transparent for the user and it's very powerful concept, allows a lot of cool features without the burden on users of creating new accounts. It also allows other features such as social recovery, two factor authentication, designated guardians and multisignature account segmentation. Things like withdrawal limits on the account which make it safer to hold funds, personal whitelist, blacklist, fraud alerts coming from the wallet and things like that. All these feature are possible because of the account obstruction.
00:24:51.830 - 00:24:58.060, Speaker B: So yeah, that's pretty much what I can say right now.
00:24:58.830 - 00:25:43.066, Speaker A: Perfect. Thank you. So one of our listener is asking, so is account abstraction like a proxy? And the answer is no, it's different. A proxy is in an address and when you call it, it will redirect your call to another wallet. So it will redirect all the call data, meaning the function you're trying to call and the call data associated to it. So the arguments you're trying to call when you're doing that, basically it means that your endpoint remains the same. So the smart contract you're sending the transaction to, but this contract itself doesn't necessarily hold.
00:25:43.066 - 00:26:30.742, Speaker A: Wait a minute. Yeah, when you're using a proxy, it's holding the state, but this is a generalized version. Basically, when you're calling address a and it's a proxy and it redirects to address b, address a holds the state, but this is not an account contract. This is a generalized contract. So address a can have the storage of whatever contract you want this to be. An account contract is not a proxy in the sense that it's all the state of a smart contract designated to all assets, so its API will never change, or it will offer the same basic functionality. Now that being said, wallet contracts are evolving.
00:26:30.742 - 00:27:57.910, Speaker A: So right now most of the wallets you guys are using are proxies in the sense that they will deploy a proxy contract that will point to an account contract, which is yours, so that later on when new functionalities are shipped, the logic can be updated. And if all of this is fuzzy, it's normal. So don't hesitate and ask more questions if you have them. I also want to mention that this is about to get even fuzzier or clearer, depending on your view, because when you're using a proxy today you have a smart contract a, which is your proxy, which is pointing to a smart contract b, and smart contract b holds logic and storage, and smart contract a holds just storage. And so when you're pointing to it with smart contract b, smart contract a will update its storage by using the logic of smart contract b. Now with version 0.9 of Cairo, Lang and Starknet that is about to ship in the next few weeks, we're going to have this thing that our smart contract has, classes, meaning that now your smart contract will exist.
00:27:57.910 - 00:28:06.760, Speaker A: What we call a smart contract would be an instance of some code. Actually, Tom is here, so.
00:28:08.730 - 00:28:09.178, Speaker D: He'S going.
00:28:09.184 - 00:28:26.800, Speaker A: To be able to correct me if I'm saying anything stupid. So welcome, Tom. Big round of applause. Okay, so guys, give us a sec. I'm just going to plug the octopus so that everyone hear everyone.
00:28:30.370 - 00:28:46.822, Speaker C: All right, can you guys still hear us? I can see that you can hear us on YouTube. Let us see now. Let us see now how I can connect on discord. I'm not sure, if people can hear me.
00:28:46.876 - 00:28:53.400, Speaker A: Oh, yes, actually, no, not yet. So voice and video? Yes.
00:28:54.650 - 00:28:55.734, Speaker C: No, actually it works.
00:28:55.772 - 00:28:55.974, Speaker A: Now.
00:28:56.012 - 00:28:57.510, Speaker C: Can you guys hear me on discord?
00:29:02.910 - 00:29:05.770, Speaker A: Let's see. Yes.
00:29:05.840 - 00:29:06.522, Speaker B: Okay, good.
00:29:06.576 - 00:29:38.558, Speaker C: People can hear me. So welcome, Tom. Joining us, we have Abraham on the call with us. He's just presented git Starknet. I stopped the camera because the connection is not great and I want everyone to hear us correctly. So we talked a bit about account subtraction, and there was a question about, oh, is account abstraction some kind of proxy? Which is not. And I was just explaining the difference between having an account as account abstraction and what is a proxy.
00:29:38.558 - 00:30:39.142, Speaker C: And I was saying that this is very confusing, which is normal, but it's about to be a bit more confusing or a bit more clear, because with version 0.9, we're now having contract as classes, which means that we will basically separate the logic of a contract and its storage, meaning that when you want to deploy a contract, you will first deploy its code somewhere in Starknet. And when you want to actually deploy your contract as an entity you can interact with, you will now have a smart contract that will point to a code, which will be a class, and then it will have its own storage and its own address. And so this will make it a bit easier. It will make it a bit easier for, I mean, it will make it easier for the network to run. It will save time. I'm curious if you have insights on what went into this decision to do that.
00:30:39.142 - 00:30:43.820, Speaker C: And then the follow up question is, what other good stuff can we expect in version 0.9?
00:30:44.830 - 00:30:48.230, Speaker D: Okay, so no need to comment on proxy and accounts.
00:30:48.390 - 00:30:49.402, Speaker C: No, this is good.
00:30:49.456 - 00:31:36.330, Speaker D: Okay, great. Yeah. So actually, from both a developer perspective and a user perspective, this change shouldn't affect a lot. If you just want to use contracts as your regular, using it on Ethereum, you won't really feel the difference. The motivation for this kind of change was that we wanted to find a way to support two new features. One is being able to pay fees for contract deployments, and the second one is being able to deploy contracts from contracts. So to create what is called on Ethereum contract factories.
00:31:36.330 - 00:32:52.240, Speaker D: And the problem with that on Starknet is that the definition of a contract is not only its bytecode like in the EVM, but only contains a much wider part, which are the hints. And this didn't allow us to create contract factories in the old way, which we defined contracts. So the way we solved it is we say, okay, if you first want to define a new class, you create a transaction which is called declared, which is very similar to what you have today. But basically you compile a contract and you declare it as a new class on Starknet. So for example, I can declare ERC 20 now when I want to actually deploy a new contract, a new ERC 20, let's say, I don't know, and retoken or something like that. Basically what you do is that you create a new instance of the ERC 20 class and deploy it to a specific address and initialize it with the constructor. And now you have the exact same contract that you have today.
00:32:52.240 - 00:33:51.126, Speaker D: But as Andrit said, the logic of this contract is the class that was declared. Does that make sense now? How does it allow us to deploy contracts from contracts? So basically, when I want to deploy a new contract from contract, I'm saying, please let's create a new instance of this class which is identified by a class hash, right? And I can do it. So we have a new system call that you can use in contracts. And what this system call gets is basically the class hash of the new instance that it wants to create and the constructor arguments to initialize it. So this was the motivation and this was some explanation to it. Now, other things that I have a question regarding that.
00:33:51.148 - 00:34:15.710, Speaker C: The first thing that comes to mind here is that right now on Ethereum, most ERC 20s that are deployed are open zeppelin. They're based on the logic by open Zeppelin. And to the best of my knowledge, open Zeppelin doesn't get paid for that work. With this paradigm, you could imagine that somebody that writes really useful code could do the declaration of it, and everyone.
00:34:15.780 - 00:34:16.400, Speaker D: That.
00:34:19.490 - 00:34:57.498, Speaker C: Wants to inherit from this code or instantiate a contract using this class. I mean, there's a direct link here on chain where you're saying, I'm using this logic. Would it make sense to have some kind of mechanism where you would say, hey, when you're declaring an instance, you're paying fees to the sequencer, or you could pay fees to the person that declared the instance. And that would be a way to incentivize people to first not declare the same code various times. Because probably it's cheaper to pay to use the instance that was instantiated from someone else rather than declaring your new instance. It's also a way to pay for people's good work. Was there any thoughts put into that?
00:34:57.664 - 00:35:30.854, Speaker D: Yeah, so we actually have a lot of thoughts on how to compensate developers through the protocol, right? Having mechanisms that will compensate developers based on the usage of their contracts. I actually haven't thought about what you described. But it does go along those lines. And it's very interesting thought. And in five minutes we have a discussion around it. So I will raise it up.
00:35:30.892 - 00:35:31.142, Speaker A: Sorry.
00:35:31.196 - 00:35:37.110, Speaker C: Okay, so I'll be quick. Let's finish with 0.9. Can you give us a brief of when and what?
00:35:37.180 - 00:35:50.094, Speaker D: Yes. So when we plan to deploy it on Gurley, probably not next week, but early the week afterwards. So I think it will be the first week of June, probably something like that.
00:35:50.252 - 00:35:50.960, Speaker B: And.
00:35:53.010 - 00:36:15.170, Speaker D: What it will include is the changes to contract and treating them the contracts as classes. Very important point is that since starting 0.9, fees will be enforced. So transactions that are not paying fees will not be accepted.
00:36:15.610 - 00:36:18.950, Speaker C: Can you still send the transaction directly to a contract?
00:36:21.450 - 00:36:24.630, Speaker D: No, it must go through an account contract that will pay for it.
00:36:24.700 - 00:36:25.320, Speaker B: Okay.
00:36:27.530 - 00:36:34.166, Speaker D: Specifically it must goes first to the execute function of the.
00:36:34.268 - 00:36:39.034, Speaker C: So starting 0.9, all transaction have to go through an account contract that has the execute function.
00:36:39.152 - 00:36:39.578, Speaker D: Yes.
00:36:39.664 - 00:36:39.914, Speaker A: Okay.
00:36:39.952 - 00:36:40.826, Speaker C: And pay fees.
00:36:40.938 - 00:36:41.598, Speaker D: Yes.
00:36:41.764 - 00:36:43.082, Speaker C: Can I pay zero fees.
00:36:43.146 - 00:36:45.022, Speaker A: I specify fees, but I pay zero.
00:36:45.156 - 00:36:46.458, Speaker D: You will be rejected.
00:36:46.554 - 00:36:46.958, Speaker B: No.
00:36:47.044 - 00:36:49.582, Speaker D: Okay, you can try. Let's see.
00:36:49.716 - 00:36:50.400, Speaker B: Okay.
00:36:51.010 - 00:37:04.450, Speaker D: And probably it's 0.9. Maybe in a minor version a week after. But we will include the first version of sequencer parallelized execution.
00:37:05.190 - 00:37:05.566, Speaker B: Right.
00:37:05.608 - 00:37:13.154, Speaker D: So this will hopefully improve significantly the throughput of the sequencer.
00:37:13.282 - 00:37:14.454, Speaker C: This is really interesting.
00:37:14.572 - 00:37:17.862, Speaker D: Cool. We should have a community call about that.
00:37:17.916 - 00:37:19.286, Speaker A: Yeah, we should. Definitely.
00:37:19.388 - 00:37:37.680, Speaker C: What you're doing in two weeks? Actually it will be on girly. While we're talking about fair promise, one last question. A few weeks ago we said we want to do ten times the amount of transactions for 1% of the cost by meteor. Meteor is round around the corner. How do you feel about that?
00:37:38.290 - 00:37:39.326, Speaker D: Not very good.
00:37:39.428 - 00:37:39.886, Speaker C: Okay.
00:37:39.988 - 00:37:45.650, Speaker D: But this is still the goal. But I think it will be a bit later.
00:37:45.720 - 00:37:47.490, Speaker C: So maybe q three or something.
00:37:47.640 - 00:37:48.498, Speaker D: Hopefully, yes.
00:37:48.584 - 00:37:55.140, Speaker C: Cool. Let's cross fingers. Well, once it take you more time. Thanks for your time. Thanks for the amazing.
00:37:55.610 - 00:37:59.080, Speaker D: And thanks for everyone who came.
00:37:59.850 - 00:38:00.600, Speaker B: Cool.
00:38:01.370 - 00:38:13.770, Speaker C: All right, people, I think that wraps up our community call. I don't see any more questions. Happy to take them if you have them. Whether about the specific topic or something more global.
00:38:14.830 - 00:38:18.220, Speaker B: And with that.
00:38:20.270 - 00:38:31.310, Speaker C: Let'S wrap it up. I'll see you in two weeks. I see somebody is writing something. No, he stopped. All right. I feel like a teenager on MsN messenger waiting for the message to be sent or not.
00:38:31.380 - 00:38:32.718, Speaker A: Reza, do you have a question?
00:38:32.804 - 00:38:41.694, Speaker C: Farnzara. All right, thanks for the information. Well, thank you for your attention, everyone. There are 600 people connected.
00:38:41.742 - 00:38:43.154, Speaker A: I have a hard time believing it.
00:38:43.192 - 00:38:59.014, Speaker C: I'm not sure if everyone is a bot or everything. I feel like I should try to inject SQl stuff to see if you guys are bugging or something. Very happy to have you all and have a good time.
00:38:59.132 - 00:39:02.470, Speaker B: Until next time, thank you all. Bye bye.
00:39:05.130 - 00:39:08.994, Speaker C: And I forgot to thank Abram for coming and presenting gets darknet.
00:39:09.042 - 00:39:09.654, Speaker A: Sorry about that.
00:39:09.692 - 00:39:11.310, Speaker C: Thanks again being here.
00:39:11.380 - 00:39:11.902, Speaker B: Sure.
00:39:12.036 - 00:39:18.190, Speaker C: We're looking forward to seeing all the great integrations of Bravo in new apps. Have a good day.
00:39:18.340 - 00:39:18.780, Speaker A: You too.
