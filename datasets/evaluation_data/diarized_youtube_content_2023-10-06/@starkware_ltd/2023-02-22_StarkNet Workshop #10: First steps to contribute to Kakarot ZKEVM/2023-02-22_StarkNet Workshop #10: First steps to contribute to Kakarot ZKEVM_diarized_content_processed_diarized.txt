00:00:00.170 - 00:00:32.440, Speaker A: First contribution to the Kakarot Zke EVM. And I'm pressing go live now on YouTube. And we should be live on YouTube also. So welcome to the stream YouTube. Today we're going to talk about the Kakarot Zke EVM and we're going to walk you through how to make your first coding contribution to Kakarot. Today I'm joined by Fresh Pizza and Danilo. Hi, guys, how's it going?
00:00:33.050 - 00:00:37.080, Speaker B: Hi. Doing well. How about yourself? Doing good.
00:00:37.390 - 00:00:46.940, Speaker A: Always happy to be in good company here. So I basically prepared nothing for this workshop. You guys run the show.
00:00:47.950 - 00:00:50.700, Speaker B: Wait, what?
00:00:51.070 - 00:00:53.710, Speaker A: I prepared the stream. Now the floor is yours.
00:00:55.250 - 00:00:56.000, Speaker B: Okay.
00:00:56.450 - 00:00:57.530, Speaker C: That's why I invited.
00:00:57.610 - 00:01:08.260, Speaker A: I don't know. Do you want to start with presenting maybe what Kakarot is for the people who just joined and lived in a cave and don't know about Kakarot, the sexiest DKVM around?
00:01:08.870 - 00:01:51.066, Speaker C: Yes, I can give a quick intro on Kakarot. So Kakarot is Zke EVM. EVM is an Ethereum virtual machine that process Ethereum opcodes. And it's in ZK because we are right now as a smart contract on Starknet. And Kakarot is a project that was born last year by the initiative of Abdel and Elias and some amazing builders. And we started as an open source project. And actually that's also where I started really deep my Cairo journey.
00:01:51.066 - 00:02:05.522, Speaker C: So I think I'm very excited about to share how people can also contribute to. Yeah. Would you like me to go a little bit deeper on what Kakarot is up to you?
00:02:05.576 - 00:02:22.780, Speaker A: So today we're going to dive into how people can actually contribute code. We're not here just to talk about Kakarot. We're here to show to people how they can use it or how they can contribute to it. So be the committer you want to see in your.
00:02:24.750 - 00:02:25.594, Speaker B: You.
00:02:25.792 - 00:02:32.742, Speaker A: It's up to you. Do you want to get right into it? Do you want to talk a bit more about the general architecture of Kakarot?
00:02:32.806 - 00:02:42.398, Speaker B: Yeah, maybe quick TlDR like, I guess with only does for the people that don't know that relation. So it's part of that program. Maybe.
00:02:42.484 - 00:03:09.820, Speaker C: Danilo, if you want to. I have prepared a presentation about open source projects and we'll be talking about only this. And I think then when fresh pizza do live open source contribution, he can also go deeper into Kakarot. So I'm going to share my screen. I'm feeling a bit nervous. I didn't expect to be live.
00:03:12.590 - 00:03:14.380, Speaker A: Sorry you thought this was recorded.
00:03:15.310 - 00:03:18.554, Speaker C: No, I mean like on YouTube. I thought it was going to be.
00:03:18.672 - 00:03:19.594, Speaker A: Don't worry about it.
00:03:19.632 - 00:03:20.860, Speaker B: It's just us.
00:03:22.130 - 00:03:29.680, Speaker A: We can edit it in post recording. Everything is going to be fine. I see you share your screen. I'm going to add it. Nice.
00:03:32.870 - 00:04:03.834, Speaker C: I'm just going to talk a little bit about some tips around open source contributions. Just disclaimer. These tips are 100% based on my own experience. So if someone disagree or think there are better ways, I think that's 100% fair. But I feel like I can only share things or path that I have walked through. So this is the path that I walked. This is what worked for me.
00:04:03.834 - 00:05:22.580, Speaker C: So this is what I believe I could be sharing today. So one of the things about open source, I think first I would say one of the exciting things about open source project is that at least for me, it really feels nice to, or I really feel excited to contribute to projects that can be used by anyone. And usually the open source ecosystem is a bit more friendlier than other, let's say, closed projects, as I think the mindset and the vibe is usually different. That's why I love it so much. And for me it's been a journey that I've learned a lot. And I would say that when I wanted to start contributing open source and from all the things that I did, what worked for me best when I started was to first identify what I wanted to learn particularly and what are the projects that I wanted to learn particularly. And I think that's one of the beauties of open source as well, because you have all these different projects and you're free to choose.
00:05:22.580 - 00:07:03.202, Speaker C: And sometimes I would feel like I really want to contribute to this project, but I have some feeling of doubt and I don't know if I can do it, especially in Cairo in the beginning, which was a bit overwhelming to tell the truth. But I remember that when they open sourced or initiated the open source project for Kakarot, I really, really wanted to do it, because for me the idea of ZKVM was very exciting and also I really wanted to learn really in a deeper level. So for me, when I saw that, I thought, okay, I want to do this, but at the same time that I thought that I also had the feeling of, but can I do it? What I realized after doing some open source contribution to Kakarot, burus and even elios from a 16 z is that it doesn't matter how hard it is with time and effort, you can always make it. So instead of starting with things that you think you can do start with things that you really want. And one mindset that helped me is that if I could work on anything, what would I be working? And then I worry about the other parts, the technical and the other parts. So always start with something that you really are excited about because that gives you energy to go through the learning process and the growth process. The second tip I would like to give around open source contribution is okay.
00:07:03.202 - 00:08:16.598, Speaker C: Once I have chosen what I want, once I have a clarity of I'm excited about this project. So when I first come to a project, I try to understand things. I try to understand the flow. For example, for Kakarot, I didn't know Cairo that much. But even though if you don't know Cairo, you can understand the flows. And as you go through the flow, then I would just focus on some key parts that if I don't understand this I can continue, then I would go and look what this is and learn and then continuing. But mostly what I felt is that if you know how imports and how functions connect to each other, how files connect to each other, even though you don't know what the function is doing, but you know a little bit about how everything is connected, and you can have a visual map or just a map of the flow in your mind, that really helps you to start contributing after you have this flow clarified.
00:08:16.598 - 00:09:20.766, Speaker C: I think the next step that I always take is I read all the issues. I try to read all the available issues in that moment, even the comments, even though I don't understand what they are about, just to have them in the back of my head. And after I read all the issues, then I go and start reading the previous prs and the discussions. So the previous prs are hints on how to commit PRS basically. And what I realized when I did that is that a lot of times when I was reading the prs and comments after having all the issues in my mind, is that sometimes it would just click, oh yeah, that issue, it links to this pr, it has a similar vibe, or sometimes it's very similar. For example, when implementing an opcode, there's several opcodes. How the opcode is structured, it's very similar.
00:09:20.766 - 00:10:28.920, Speaker C: Like you have to put the opcode function in this file and connect this file with this other file, and the only difference would be the logic of the opcode. So even though I didn't understand the full project, if I can't find similar issues with PRS and understand a little bit around discussion, you can implement things even if you're not proficient on that. And the fourth tip that finds similar issues. Yes, I think this I already mentioned, maybe I made it wrong here. I think once you start reading issues and once you start reading the PRS, I think one thing that a lot of times people are afraid of, but for me it. It has been the opposite, is to make a lot of questions, like literally make a lot of questions and don't be afraid of being wrong. I remember that my first pr in Kakarot was completely wrong.
00:10:28.920 - 00:11:07.150, Speaker C: Basically, I thought it was something, but it was something completely else. But the moment I made the pr and I said, hey. And I sent Abdel, hey, I did this pr. Can you take a look? And then he would say like, hey, this is wrong because of this, this and you should be doing this. And then I started to learn. So making a lot of questions and not being afraid to be wrong, I think is something that with time have proven to me. Actually, I got more involved in the stocknet ecosystem because I did a lot of questions around Cairo on the Discord channel.
00:11:07.150 - 00:11:15.810, Speaker C: I remember that I was doing a lot of questions. Then after three days, Louis was, hey, I see you doing a lot of questions. Can we have a chat? And then my life changed.
00:11:16.150 - 00:11:46.400, Speaker A: And I think there is a counter side to this. Not a counter side, but there's the other side of the coin also, which is once you're in the ecosystem, take time to answer people and be nice to newcomers. I think that the fact that people can ask question and that people should feel welcome and that there are no dumb questions is extremely important. This is an asset of our ecosystem that we need to cherish. Because this is how you onboard more people.
00:11:48.290 - 00:12:34.526, Speaker C: Yeah, I totally agree. I feel so grateful for all those people that have helped me during my journey, that if I can reproduce 10% of the help that I received, I think I'll be very happy. I don't come from a CS background or engineering, so I had really dumb questions and people were still very patient and they really helped me out. So for me, discord and telegram have been my school. I totally agree with that. Yes, I think I missed some points.
00:12:34.708 - 00:12:50.130, Speaker A: But before going, but I think it was a great introduction on how to make your first contributions to an open source project, what things to look out for and the general flow. I think this is really valuable for anyone wanting to jump into open source.
00:12:51.350 - 00:14:12.846, Speaker C: Yes, I think I would just like to add just one more thing, which is, I think it's more of a mindset level that really have helped me go through the challenges is the importance of learning how to learn. One thing that I always had in mind whenever trying something is that it doesn't matter if this becomes useful or not later on, but if I can improve my ability to learn new things fast, that's already again. So it doesn't matter what you're doing. Observe how is the learning process. And what I've observed until now is that the biggest challenge when learning something new, more than the technical part itself, is the feelings of doubt and basically the ideas of can I really do it? And being able to overcome this again and again and again actually have been the biggest asset that allowed me to unlock many stability. So I think this is more of a mindset part. When I look into all these projects and I have this feeling of I want to do it, but I don't know how to do it, or I don't feel like I can do it.
00:14:12.846 - 00:15:11.950, Speaker C: I know that's the place I need to be and to finalize this. This is where I started my open source journey and I would like to just share a little bit on why I think it's so powerful and how it has worked for me. If you go to app Onlydeust XYZ, you will see that there is all these different projects, all these different languages in all different segments of more focus on web3 and for only in the starknet ecosystem. So today we will be sharing around about Kakarot. But if you go here and if you're interested in doing open source contribution, please take a look once again. Start. Try to find something that enlightens your heart, like makes you feel like, oh, this is exciting.
00:15:11.950 - 00:15:40.490, Speaker C: And also if you want to learn any specific language. And then I think this is a very good starting point. This is fantastic. My take from how to start contributing. And now I think we can go with pizza to fresh pizza, not just pizza. On doing a live contribution.
00:15:42.510 - 00:15:49.098, Speaker B: No, it's good. Fresh pizza is too informal. Pizza is fun. Let me see. Can go present.
00:15:49.184 - 00:15:52.270, Speaker A: When people know you well, do they call you pizza or fresh?
00:15:53.330 - 00:16:22.544, Speaker B: Either or. Like if yourself, you just go fresh pizza because that's what he thinks is the most fun. But I don't mind. I've heard both enough. Now, I always say fresh sometimes because people seem to be more comfortable with saying fresh in public instead of pizza, but share screen. There we go. Entire screen.
00:16:22.544 - 00:16:50.730, Speaker B: Yes. Okay. Here we go. There we go. Yeah. Cool. We don't have that much time left, but I think the important part that I'll do at the very beginning is what Danino actually talked about, which is just the base flow that will help you sort of get into Kakarot and what is actually happening, because the majority of the code is just sort of supportive structure like utility functions and all of that stuff.
00:16:50.730 - 00:17:38.868, Speaker B: But I think Damina has said what cacro basically is, which is all we're really doing is we're writing the EVM in Cairo, and what that enables is for us to have a Zke EVM. But to simplify it, the main thing we want to just create is the EVM in Cairo. So our main components here are actually an eoa. So in starknet that's actually a contract on ethereum that's just a private public key pairing. And what it basically does is from there your eoa. So your normal user account basically calls the executed address function in the Calcrot smart contract. And the main purpose here is all that does is it fetches the bytecode from a smart contract, an existing smart contract, and then it runs that bytecode.
00:17:38.868 - 00:18:24.410, Speaker B: And whilst it runs that bytecode, it potentially performs some state changes. Right? So in the Ethereum world, the smart contract is called a contract account. It's confusing for us in startnet because for us an account contract is what an eoa would normally be. But in cockroach these are the terms that we use. So these are actually just our main big components that you need to know of, and this is the main flow that we're working with. So a user gets the bytecode from a contract, executes that bytecode with some call data that they also provide usually, and that results in some state changes. Okay, now let's actually look at some code.
00:18:24.410 - 00:19:27.080, Speaker B: I'm not sure to what extent people are actually working along with this, or looking at the recording and working along, but in general, of course, I hope you've gone through the basic documentation and know how to set up, install the kyo Lang and set up a virtual environment that you should be working in. But in general, the readme of the Carcrowd GitHub page also has a pretty detailed description of what you need to install in order to get started. Contributing primarily, if you've already set up your virtual environment, then the main thing you need to do is install poetry. Run the command make setup, which installs a bunch of dependencies for you, and then you're actually good to go. In some cases you might need to run some tests that require you to also install foundry. So in that case that's what you'd have to do with these commands right here. But yeah, to get started, mainly all you need is basically poetry as an extra installation besides Carolang.
00:19:27.080 - 00:20:32.784, Speaker B: Now on the left side here we see sort of the folder set up for cockroach. Once again, there's a bunch more here that you don't actually need to know for your first contribution. So a bunch of different folders, like the build folder where we have binary files, or the CI deployment files, or just in general, existing deployment addresses, documentation, different scripts for deployment, these are all not really needed in the docs. However, there's actually a practical little text snippet under contribution that again goes a bit through all the different things that you need to have installed, which like I said, if you've already got Kyra installed, it's not much. But then also here, if you're not that familiar with also creating prs for specific projects or open source projects, this will also give you sort of a step by step. So it gives you the commands to create a separate feature branch, commit that feature branch, and then create a pr basically. Hopefully we'll get to that as well.
00:20:32.784 - 00:22:04.072, Speaker B: But this is a very handy little step by step instruction as well. But yeah, we have, like I said, the main focus actually that you need to be aware of are the source folder and the tests, of course, where we have all the unit integration tests for cockroach. And this is something that if you've been only been tinkering around with smaller projects, this is of course something that is maybe more prominent than maybe you're used to if you've only had your private projects until now. But yeah. So inside of cockroach, the main three components that we talked about before are basically here under accounts you have the EOA and the contract, right? So these are the smart contracts and the user contract, the normal account as well as here we have the cockroach file. And as you can see, there are a bunch more folders, there are a bunch more files, and they're all loaded with a bunch of different other contracts that have complex names and sound complicated, but really, once again, you don't need to understand a lot of those to make your first contributions. So what you need to be aware of that, especially in Starknet, usually the setup for contracts is the following, that you have the cockrod, for example here file contract, and this almost only acts as an interface where you have the different selectors, the functions that you can call, but the actual implementation is in a library file.
00:22:04.072 - 00:22:27.540, Speaker B: You'll see the same thing under accounts you have a contract account file, but underneath we have a library file. Again, same for the Eoa, where the actual meat of the code is inside. So if we go through our steps we can see execute that address inside of cockroach and Henry. Feel free to chime in with any questions or clarifications.
00:22:28.120 - 00:22:33.110, Speaker A: I'll ask you for some questions. In the meanwhile I can put banners. It's really cool.
00:22:33.960 - 00:22:43.272, Speaker B: I need to switch over. I don't see anything. Can I add banners? Don't worry calculator, you're good. Okay, so I won't be seeing whatever you're trolling me with. That's good.
00:22:43.326 - 00:22:43.736, Speaker A: It's fine.
00:22:43.758 - 00:22:44.570, Speaker B: Maybe I'll.
00:22:47.340 - 00:22:57.708, Speaker A: Ask questions for sure. I can see your screen when I look on YouTube. I can't really on streamyard. If you can make it maybe one size bigger it will be even better, I think.
00:22:57.794 - 00:22:59.500, Speaker B: Can I make my screen bigger?
00:23:00.740 - 00:23:02.130, Speaker C: I need the text.
00:23:03.380 - 00:23:10.550, Speaker B: The text. You guys actually have to tell me how to do that because I actually have no idea.
00:23:11.720 - 00:23:13.670, Speaker A: Or something like the zoom or something.
00:23:14.760 - 00:23:41.870, Speaker B: There you go. Yeah. Does this work? We don't need the terminal right now. We can actually remove the terminal. Okay, so our main entry point in the whole calcut EVM is executed address. So a user sort of sends an address where he wants to execute some bytecode together with some call data. The first thing that we of course do is we jump to our library where the main execution actually happens.
00:23:41.870 - 00:24:23.928, Speaker B: And here basically two things happen in essence. One, we create an execution context. I'll talk about that in a sec. And then down here, down here we run this execution context which also includes the bytecode. Okay, so that's where we start already, this execution context, it's a struct that is stored inside model Cairo. And this is sort of the main context. The main information whilst running through that bytecode that sort of updates the current state of the EVM in that sense, or of your execution of that code.
00:24:23.928 - 00:24:47.248, Speaker B: So inside here we have the core context, which is another structure includes the bytecode of the contract that we fetched and are now executing the program counter, which you also might know from starknet if you're familiar with the general setup there, the stack, the memory, the amount of gas that has been used while you're executing the address of the contract whose bytecode we're executing all of this stuff.
00:24:47.414 - 00:25:00.180, Speaker A: So wait, the execution context here, is it the equivalent of the EVM state? Does it model the EVM state when your contract gets executed? Or is it related to starknet?
00:25:01.560 - 00:25:39.010, Speaker B: Yeah, this is not related to Starknet. Exactly. This is sort of supposed to mirror the logic inside of the EVM doesn't have to do anything with the state in the sense of any storage that is being changed. But yeah, it's sort of the state of the EVM in that sense, or your program that is being executed. Right. So for example, for that one transaction that you're performing, how much gas has been used, what is the limit on what you're actually doing? What is the current gas price whilst this is being executed? No, actually we don't need these ones. Let me close those.
00:25:39.010 - 00:26:47.432, Speaker B: So yeah, we now initialize this context depending on the parameters that you gave, which is the address. And before that within this function we also fetch the bytecode. Now we run this context and the main thing, and this is also sort of one of the main files in this EVM is actually this function, we decode the bytecode opcode for opcode, and for each opcode we call one of any of these many functions, right? So these are all, instead of having basically different if else, a very large if else tree here we have these jump calls. So for example, if the one byte, the very first byte of the bytecode that we want to execute, if this is now an ad opcode, we jump to stop and arithmetic operations. So you can find that under instructions, all of these. So in that category, execute add. Right.
00:26:47.432 - 00:27:20.144, Speaker B: So go to execute add, that's right here. And so for that one bytecode we now perform, we get the execution context. Still we always forward that to these functions. We get the current stack, we pop the first, the uppermost values, so we get those, we add them together, put them back on the stack, save the stack in the context, return the context, and now we get the next opcode process, the next opcode and so on and so forth.
00:27:20.272 - 00:27:26.832, Speaker A: Implemented de vm wizard stack and everything inside of Cairo.
00:27:26.896 - 00:27:27.510, Speaker B: Yes.
00:27:28.280 - 00:27:32.480, Speaker A: What do you mean? This is not meant to be executed in Starknet.
00:27:32.560 - 00:27:34.730, Speaker B: No. Well you can deploy this on.
00:27:37.500 - 00:27:50.270, Speaker A: Cairo is what you mean. Yeah, I see what you mean. It's a great question. And I guess this is out of for this live workshop, but is this a starknet or is it a Cairo provable thing you can write by itself?
00:27:50.640 - 00:28:47.292, Speaker B: Yeah, so I guess in that context, is this basically the main identifier for this, if it's darknet ready or not? To some extent you could say so. I think the big difference is to what extent. I mean it now also gets wishy washy in the sense of because we're also moving to Cairo one of course, but with the current state of Cairo, the differentiation, I guess the main one is to what extent you use system calls, right. To what extent do you actually make use of starknet in that sense? Or any functions related to starknet? Or is it purely just Cara? And then maybe are you using hints or not? Right. For example, we've eliminated all hints that are not whitelisted on Starknet so that we can actually deploy on starknet. Right. So in that sense you can say this is starknet ready code and not just color code.
00:28:47.426 - 00:28:48.110, Speaker A: Perfect.
00:28:49.620 - 00:28:51.520, Speaker C: I would like to add one thing.
00:28:51.670 - 00:28:52.128, Speaker B: Sure.
00:28:52.214 - 00:29:39.040, Speaker C: Usually it's just something I do when I'm looking into new code and I don't know where this will link to. For example, from the jump you already knew that it was going to a specific jump, but as a newcomer I might not know. So I use a lot. For example, let's say, can you copy the stop and arithmetic operations or the exact ad? Yes, and then I would go to search and then do a global search and then look into other places where it's done and see where it's defined. So I do that a lot to understand where the flow is and when I don't know what is happening and where a specific part of the code is coming from. And that really have helped me a lot.
00:29:39.110 - 00:30:12.824, Speaker B: Just wanted to share this 100%. For those using visual studio code, that's control shift f, which basically gives you a global search. And it's very easy, especially if you do prs. Sometimes you change a small thing and then you create a pr and then you notice actually all of the tests are failing. Why is that? And to actually see whatever you're changing. If you want to find out what this actually touches, doing a global search, seeing where it is actually being used helps a lot. That is true.
00:30:12.824 - 00:30:47.540, Speaker B: Good point. Yeah, so this is the main, main structure. Once again there's a lot of things that you'll find out. For example, utilities. Right, what are these utilities? There's a lot of functions in here in regards to converting u int, two, five, six to felts, or to an array of bytes, or to fill an array with zeros or whatever. So a lot of utility functions. Rp encoding is something that is used, especially inside of the EOA contract.
00:30:47.540 - 00:31:46.552, Speaker B: But once again it's something that you don't necessarily need to know for most feature implementations. And now let's actually have a quick look at the actual carcrat repo. If you go to issues, you'll see a bunch of issues. Usually they have this feature tag in front of them and these are free issues that people can basically grab state that you have an idea how to execute it or implement this, and they will get assigned to you. Right now, for example, you can see most of them have convent existing issues. They're probably being worked on right now. But especially for this workshop, we've sort of created some issues that are not time sensitive, that are basically good representations of issues that you can always basically create prs for, that you can always work on.
00:31:46.552 - 00:32:13.516, Speaker B: These are typically things like, and these are not as fancy as a feature, a proper feature, or probably not as fun, but if you want to just get started. And sometimes it's also a matter of getting to know the people that are running their repo. It's stuff like adding comments, adding more unit tests, optimizing the code, removing imports that aren't being used anymore, et cetera.
00:32:13.628 - 00:32:26.628, Speaker A: It's also really much less intimidating. I mean, as a first time, it would feel much easier to pick up small things and little by little get more involved. So this is a great first step.
00:32:26.794 - 00:33:01.250, Speaker B: Yeah. And because it's a time sensitive, it also doesn't matter if for some reason you start working on something. You said, I'm going to do this, and then for some reason for a week you're not available or something. So, yeah, I personally also definitely really like those. Hopefully, of course, the goal is for you to then jump to something larger, but this is, I think, a great starting point. And Danima, unless you also have something else maybe to say in regards to the repo structure, we might as well just maybe pick out one of these issues.
00:33:04.740 - 00:33:54.690, Speaker C: With the issues itself. Just wanted to maybe share a little bit the purpose of these workshop issues, which is, like Henry mentioned, to make it more feasible so that you have a lesser feeling of doubt, or can I do it thought process? Because actually, once you experience your pr being merged, I think that that's a really great feeling, especially when you thought you couldn't do it. But it's not about the pr being easy or hard, it's just about trying. So if you want to try to contribute, just try it out one of them, and then you experience the rest for yourself.
00:33:55.140 - 00:34:42.508, Speaker B: Yeah, I'll just pick this one as an example, because actually these are very common. So this is just one that I identified. But for example, the thing that we'll be fixing here is something that is very common and actually relatively, unfortunately, easy to find. Let me see. Which file is it? It's the accounts contract library. So this is basically the implementation of a smart contract in that sense, an EVM smart contract, where we have a function called bycode length. Are we in the library? There we go, bycode length, which basically this fetches the size of the bytecode that that contract holds.
00:34:42.508 - 00:35:40.080, Speaker B: For whatever reason we might want to fetch that information. So the first thing that it does is it actually goes to the library and calls bytecode length. So basically our implementation of this function here it is, and all it really does is it reads from storage. So this storage slot being bytecode length up here, or storage variable, it just reads, it returns it, and here it is returned as a view function. So this is a very simple. There is actually, we can reduce this function by quite a bit, even though there's barely anything in it, just because there's stuff in here that is actually not know. Danilo, can you spot one thing already? Because I think I haven't showed you this, but these are very sketchy.
00:35:40.240 - 00:35:42.230, Speaker C: I think you created hard issues.
00:35:45.880 - 00:36:15.980, Speaker B: One very common thing is, especially in this repo, just because people copy pasta a lot and they copy pasta a lot of functions. And Cairo has this thing where you have implicit functions, right. I think hopefully whoever's listening to his knows about them. And for example, this bitwise pointer is actually, for example, for doing this like a storytree. These three are actually needed, unfortunately. I mean, Henry, correct me if I'm saying anything wrong, but these three are needed. But this one is only needed for bitwise operations.
00:36:15.980 - 00:36:26.704, Speaker B: So this one is actually, we can remove this. This is unnecessary code. Another one here. Go ahead.
00:36:26.822 - 00:36:28.416, Speaker C: Yeah, please, go ahead. I was going to.
00:36:28.438 - 00:36:32.950, Speaker B: No, go ahead. It's good. Yeah. Mention one. If you're wrong, I will laugh at you. That's good.
00:36:34.440 - 00:36:41.328, Speaker C: Maybe we can just remove the let and have the return read directly.
00:36:41.504 - 00:37:33.060, Speaker B: Yeah, and that's going to be an interesting one, because this is relatively new to Kyra, but now you basically have the options to either return just a felt or return this as a tuple, I would say. So you can return this basically named, which case it would look like this, but it has an impact. You're basically only returning a felt as well, but it has an impact in the way that you can return something. So because we are only returning a felt, we, for example, we couldn't do this. Why? Because if we read this from storage, what does it return? It returns this tuple. Right. So what we can do though is if we adjust this, we can let this be a tuple with the same name.
00:37:33.060 - 00:37:59.528, Speaker B: That has to be the same name, otherwise it doesn't work, as far as I know. And now we've turned these two lines into one. I'm not sure if this is actually a performance increase, probably isn't properly. And this is more discussion about maybe readability. Of course we're returning this. So on this end, you would have to make a change like this. The felt is needed, but just to make sure that we're returning the tuple.
00:37:59.528 - 00:38:35.224, Speaker B: So this is something that now it's very almost subjective what you want to use, if you want to use felt or not, because the alternative here is what we can actually do is we could also, if you don't return a tuple and just felt, we can do this. Right? So let's just have this be a felt and we're returning. Oh no, let me control z a bunch. There you go. I think that's fine. Wait, let me go all the way back too far. Like this.
00:38:35.224 - 00:39:02.160, Speaker B: Now we're returning a felt. And now we could compress this to be smaller, but someone could probably argue that this is actually worse for readability. So this is a bit of a subjective one, but one thing that we can definitely change is this. A local locals, you only need this if you actually use local variables, which we don't. So this can be removed. So just by doing this, removing those two lines is definitely something we can do. And I would say is 100% an improvement.
00:39:02.160 - 00:39:59.750, Speaker B: And then in regards to compressing this, in order to comply for this, to reduce the lines of code, that's something we can do. It's just questionable if it's actually an improvement or not. That's something that maybe if you create a PR, what you can do is actually create a PR that is not final yet, that is still a draft and you can put that in the comments, basically, hey, I would like to do this change. Is this something that we want or not? What is the standard? Because if we look at difference functions, this is actually the only one that only returns a felt and all other ones actually return a tuple. Right. So why is this? Probably we should at least be uniform in what we're doing. So in that case, actually, let's let this be for now and let's just go to the next step, which would be creating a PR out of this small change, usually.
00:39:59.750 - 00:40:19.544, Speaker B: Because if you see this entire file has similar issues, you might as well do it for the entire file right here. Probably we need to investigate. Does this one need a bitwise pointer? Probably doesn't. We'd have to look what is inside here. Assert only owner. But very likely a lot of these functions don't need that one. So you could do a bunch of cleanup.
00:40:19.544 - 00:41:25.970, Speaker B: And so one last point that is actually important because we have so many people of course, contributing and everybody has a different writing style. There's one command called make format that will go through the code and format it after a different way, or format it after a different standard, a certain standard. And as you can see, actually, because we removed the bitwise implicit function, whatever ruling we have, it states that if we have three implicit functions, it's supposed to be in a one line. As soon as it's more, it starts stacking them like it's just an important thing to do. The best thing would be to have this in some way incorporated into UCI. So every time you create a pr or a commit, it checks if your format has changed or you formatted your code in a way that isn't up to the standard, which you can also just check with. Make check.
00:41:25.970 - 00:41:50.008, Speaker B: I think it's make format check. Right. Format check. There you go. But yeah, so this is now nice and formatted for us. And now let's actually, I'll prepare the. Yeah, if you guys want to.
00:41:50.008 - 00:42:21.410, Speaker B: Danilo, if you have something to chime in as well. But otherwise, like I said, even I, sometimes I forget how they actually prefer it. So the nicest way is just to actually copy past these GitHub commands. So what do we have? We have. Wouldn't call it a feature, right? You could call it a feature is going to be totally fine if you look at a lot of commits. Oh no, this is actually a branch name. So yeah, I don't know, let's call it a feature and we'll just call it.
00:42:22.840 - 00:42:24.932, Speaker A: Can call it amazing workshop or whatever.
00:42:24.986 - 00:43:16.720, Speaker B: Amazing workshop. PR, yeah, usually try to make it informative. So if someone sees the PR name, they know what it is. We've basically done is just create a new branch and from here we'll be committing our work. Of course, if you have a handy nice ide, you can also just use the IDE build in. This is one of those things where I struggled a lot for a long time just using the command line. Just because when ides give you something like a good overview of what you've actually changed, this is very helpful for you to track down, because it's very easy to include sometimes a library that forgot to remove or whatever, just getting a good overview of what you've actually changed.
00:43:16.720 - 00:44:06.230, Speaker B: And look at that before you commit, because of course every time someone has to review your commits and your prs, and that actually feels the worst. If you've committed something that now you're producing work for others basically, right? You get 1000 comments of people saying oh no, this is actually wrong, this is different, blah blah blah blah. Which it's always nice actually. I'm super grateful when you get these comments and you get to learn from those. But of course it would always be the best if your pr was actually as ready as possible when you created. So why have we committed clean bytecode function? By the way, I always promote using emojis in commits. I'm pretty sure people love it.
00:44:06.230 - 00:44:33.064, Speaker B: Yes, commit and then. I mean, the rest we can also do in the actual GitHub web interface. You need to push, I need to publish. I need to push. Actually, we just committed. Let's publish. Or in the Cli can go get push or get push.
00:44:33.064 - 00:45:00.068, Speaker B: Origin. Now I need to actually go to my private repo. This is how you would usually do it. So you would clone the main cargo repo. I've already done that. Inside of that you have your main repo and from there you create feature branches. Right? So we've now created this specific branch right here.
00:45:00.068 - 00:45:24.556, Speaker B: Our amazing workshop. Yar compare and pull. And then you actually get this template that you have to fill out. So what? Meaning it's describing what you've actually done. So first of all, there's like a category here. Yeah, we could call it actually refactoring. Right.
00:45:24.556 - 00:45:28.572, Speaker B: We've done no functional changes, no API changes. Cold style update.
00:45:28.636 - 00:45:30.210, Speaker A: Make it a bit bigger, please.
00:45:30.740 - 00:45:34.592, Speaker B: Bigger. Let me see. I've learned this just now. There we go.
00:45:34.726 - 00:45:35.410, Speaker A: Nice.
00:45:35.780 - 00:45:52.420, Speaker B: Okay. Yeah, sometimes it doesn't fully match whatever we're doing, but I think formatting union codes are updates, I think. Daniela, what would you put it in codes updates or refactoring?
00:45:53.400 - 00:45:56.260, Speaker C: Just remove code, basically. Refactoring.
00:45:56.940 - 00:46:28.768, Speaker B: Okay. Put an x in there. You can always preview to see that what you're doing actually makes sense, the time spent on the pr. So this is actually relevant for. Because at the end of the day, there are rewards for, you know, the ones vinalpa only does. And your time here is, as far as I know, also used for estimating certain salaries. I mean, the people reviewing that, they also know, of course, what the quality is.
00:46:28.768 - 00:46:55.832, Speaker B: And I'm sure that's taken into account as well. But let's say this took us. This didn't take us long. A lot of time. What's our current behavior? So our current behavior is actually. We have an issue number. That one is actually nice, just so we can check, or others can check what issues are being resolved.
00:46:55.832 - 00:47:44.072, Speaker B: So let us see, what is the issue number of this issue removed unused function. This one. So it's five one three is the issue number. It is existing behavior. What is current behavior? What is new behavior? In this case, because we're not creating a new feature, we can keep it short and just say behavior is the same. And just be straightforward with what you've done. Basically removed unused code or even say optimize code.
00:47:44.072 - 00:48:20.644, Speaker B: Because in theory, after we've created this here, usually I create a draft pull request. We can actually do it. Now if you still want to have discussions about what you're doing and you're basically signaling this is not final. This is sort of what I'm doing right now. Others feel free to comment on what I've done this far. And it will automatically trigger our sort of running, building and testing. Optimally, you should be building and testing whatever you've done locally to check that it's correct, but afterwards it will be done here.
00:48:20.644 - 00:48:56.704, Speaker B: And part of this is also a test, basically, or an evaluation if the changes that you've made have actually increased or optimized the code or not. Right. Is it now running longer? And maybe our two lines that we changed actually has a performance increase, which would be nice. Or if you've created tests or actually say is you've increased test coverage. But yeah, once this is done, we could press ready for review. Or I can add some comments regarding the one thing I was unsure. Right.
00:48:56.704 - 00:49:18.570, Speaker B: Do we want to return fails or tuples? Right. And then usually I've already approved this pr. Usually there's a very charming but eccentric french man on the other side here, checking your prs, having discussion with you.
00:49:19.260 - 00:49:24.360, Speaker A: Charming but eccentric french man. Cool. Ben.
00:49:25.020 - 00:49:37.868, Speaker B: Yes. Not sure if we actually want to merge this. At the very least, I think these tests have or should pass first. But at that point, I think we have the flow already.
00:49:38.034 - 00:49:41.504, Speaker A: We show them what's most important. It would be epic. Put it in.
00:49:41.542 - 00:50:13.016, Speaker B: But I'm not sure if we can or if it's actually blocked. Yeah, I don't want to get in trouble afterwards, but I mean, we can actually see, right. This is always, just always check what are actual, the lines you've changed. We can see this looks bad, obviously deleted this much, but we've just compressed it in here now. We actually didn't double check if we still compile something that is something we should have done, but I'm pretty sure we've done nothing wrong. Merging is blocked. Yeah.
00:50:13.016 - 00:51:04.120, Speaker B: So let's wait for these tests to pass. This can take hours or at least many minutes. So it's not something that will be completed within this session. But yeah, I think it that'd be most of this, of what I was going to present. And yeah, just as a last note, maybe especially right now, it can be tough to get, I think, larger features just because of the state that Carcrowde is in right now. But as soon as, for example, the Cairo 1.0 repo I think is in a basic solid state, I think there's going to be a lot of work there that needs to be done in terms of getting all the features that we've created in the current repo and converting them over to kyle one or also doing them differently.
00:51:04.120 - 00:51:27.472, Speaker B: So there's going to be a lot of work in the future, but right now for this specific repo, it might be a bit tougher to get actual feature requests, but I'm sure that's all to get a larger feature in and actually implement that. But I guess that will change very soon. And like Daniel said, there are tons of other projects on only dust as well that are actually really fun where you can dive into different tech.
00:51:27.526 - 00:51:45.370, Speaker A: By the time you'll be set up and you'll have done your first pr on a small feature, the repo will be ready to get your bigger. Like getting started now is the best way to be able to commit meaningfully the next few weeks.
00:51:46.220 - 00:51:46.970, Speaker B: Exactly.
00:51:47.420 - 00:52:20.390, Speaker A: All right, let's check on YouTube if there were some questions. I see a bunch of people saying, wow, how handsome and how great are these coders? This is great. Some people giving advices on how to make the font bigger, Abdel making a few meaningful comments, and Abdel is actually making good comments there. All right, that's pretty cool. And I don't see other questions. Look, fresh pizza. Danilo, anything else you want to mention?
00:52:23.480 - 00:53:11.600, Speaker B: Yeah, I think I can just also reiterate what Danila said, which is this is a very great space to actually just start just learning programming itself as well. Either that or just very, let's call it the web3 space. Getting involved there. It's the easiest way. And some people scoff at, oh yeah, don't work for free or don't work for. For me, this was the way I entered, was doing work for free, but also having this free resource of learning, learning how to work in a team, and I think it's super valuable. Also, when it comes to just learning a new language, you have so many practical use cases of actually being able to implement something that will be used and something that is useful and you don't even have to think of a project.
00:53:11.600 - 00:53:19.028, Speaker B: They're right there in the form of issues. Right. So for me, this is an amazing way to get started.
00:53:19.114 - 00:53:38.892, Speaker A: You don't have to invent something, you just have to code it and integrate it. I'd add on the part you say working for free. I think software is eating the world. Open source is eating software. Also, there's more and more open source code everywhere. And writing open source code, collaborating with others is nontrivial. It's not something that you learn in school.
00:53:38.892 - 00:54:01.330, Speaker A: It's not something that you know how to do right off the bat. So finding a good community where you can learn how you do these stuff is you learning stuff in the beginning. It's you receiving, you receive people helping you learn new stuff. It's great. And then you give back to the community and you help people on board. So anyway, the great circle of Dev.
00:54:02.420 - 00:54:36.480, Speaker C: Yeah, I would just like to add, if any of you guys have any question or would like to start and please ask it on the Kakarot channel or you can also dm me or fresh pizza. We are there in the channel so you can find our telegrams easy. We'll be more than happy to answer any question you have or help with anything you need to start this amazing journey. So feel free to contact or.
00:54:36.670 - 00:54:50.060, Speaker A: Yeah, very cool. All right people, thank you for your time today. To all of you listening, thank you for being here and we'll see you soon. Cheers. Bye.
