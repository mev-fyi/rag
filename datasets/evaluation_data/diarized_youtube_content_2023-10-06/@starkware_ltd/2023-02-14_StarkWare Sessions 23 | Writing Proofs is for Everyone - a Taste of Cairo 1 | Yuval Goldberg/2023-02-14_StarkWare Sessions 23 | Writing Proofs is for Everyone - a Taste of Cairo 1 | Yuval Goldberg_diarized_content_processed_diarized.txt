00:00:03.530 - 00:00:07.610, Speaker A: Hello everyone. Please try to take your seat.
00:00:07.690 - 00:00:08.320, Speaker B: Thanks.
00:00:10.130 - 00:00:29.046, Speaker A: Okay, so, hi, I'm Yuval Goldberg, I'm from Starquare. I'm a developer at the compilers team. So we develop Cairo one which you might have heard of, and I'm going to talk about this in this talk and give you a bit of a.
00:00:29.068 - 00:00:34.854, Speaker B: Taste of it, but first, okay, it works.
00:00:35.052 - 00:00:58.090, Speaker A: Let me introduce my dog. So this is my dog. His name is Skippy. He deserves it. Guys, as you can see, skippy like the peanut butter. As you can see he's light brown, he's one year old and he likes to eat stuff, but his favorite snack is ice. This is on his first birthday when we cooked him an ice cake.
00:00:58.090 - 00:01:53.470, Speaker A: So he's eating ice here. And I know you might have think that I told you more about my dog than about myself, and this is not important, but it is, trust me. Okay, so this is what I'm going to talk about today. So a little bit about what color one is and why, then how it looks like a bit about start and contracts and what we are expecting in the soon future. Okay, so Cairo one is a high level turing complete language for creating stark provable code. If it doesn't mean a lot to you, that's okay, you can check it later. It's very similar to what we have in Kyro Zero, but it adds some more features over Cairo Zero, and it might look prettier and more talented.
00:01:53.470 - 00:02:23.962, Speaker A: So one more thing you need to know about Cairo one is that it's open source, so you're welcome to see it on GitHub. You can read the code, discuss, contribute. This is welcome and we expect your contributions. And there's a lot more in the roadmap. So we are excited about what's coming up. And again, I'll mention part of it soon in this talk. Okay, so why Cairo Zero one?
00:02:24.016 - 00:02:24.620, Speaker B: Sorry.
00:02:25.310 - 00:02:53.794, Speaker A: So we have our purpose. The purpose is to create tark probable code. And for this we already have chasm. So if you know Cairo Zero, Cairo Zero is built on top of chasm. Chasm is Cairo assembly. So this is the set of instructions that are directly translatable to bytecode or error, and programs that are written in chasm can be proven. So we start with this and we build on top of this.
00:02:53.794 - 00:03:25.902, Speaker A: And we want to add two important features to create Cairo one. So one is safety and the second is ergonomics. And by safety I mean that even runs that fail can be proven. I know it's not very detailed and if you didn't understand that's okay. But later in Shaqa's talk, he'll mention it in much more detail. So be sure to be there. And we achieved this safety feature using the Sierra layer that we add.
00:03:25.902 - 00:04:17.098, Speaker A: So Sierra is an important building block that we added in Kyra one. And it's an intermediate language that compiles to chasm, and it has the feature that every program written in Sierra will for sure compile to a chasm code that cannot fail, or again, putting otherwise, even failed runs can be proven. And this is again an important thing. And more details in Shahostock. And on top of this, we add the Cairo one layer. So Cairo one is a high level language that is compiled to Sierra, and this adds our ergonomics that we want. So now we have two compilers from Cairo, one to Sierra, and from Sierra to chasm.
00:04:17.098 - 00:04:36.290, Speaker A: So we have ergonomics and safety, and the same purpose that we have. The ergonomics are very similar to rust. So if you know rust, Cairo code may look very similar to you. And the purpose, as I said, is Cairo zero, but provable failures.
00:04:37.910 - 00:04:38.660, Speaker B: Okay?
00:04:39.430 - 00:04:43.222, Speaker A: So as you can see, he said, I have laser here.
00:04:43.356 - 00:04:44.760, Speaker B: Okay? It doesn't work.
00:04:46.170 - 00:05:20.402, Speaker A: Anyway, as you can see, we have many features. This code may look very similar to you if you know rust. We have users, we have constants, we have types like colors, like enums and structs, we have comments, we have functions like this, it eyes function, and the return type, literals, tail expressions, everything is an expression like this, match expression variables and so on. So the basic syntax is very similar.
00:05:20.456 - 00:05:21.330, Speaker B: To rust.
00:05:23.990 - 00:06:08.260, Speaker A: Traits and impulse. So we have traits. Trait is, if you know rust, it's similar to rust. If not, then it's very similar to interfaces in other languages. And we have here the ice eater trait with a generic type t, and we have this struck dog, and an implementation of this trait, ice eater, with the generic type dog. So this is somewhat similar to Rust's implementation of ice eater for structog. And if you can see here, we implement the same function.
00:06:08.260 - 00:07:18.650, Speaker A: What is achieved by this, compared to what we have in rust is that it's much more flexible. So we can define, for example, this it ice function with self of type t, but we can define another function, for example, with a different self, with a different type for self. Or we can even define a function without self at all. And it also can achieve the same thing that is implemented in rust if we do something similar to this. And then of course, we have the dot operator, which we can use, like here, skip it ice one more important feature is that we can implement traits everywhere, so not necessarily near in the same file of the trait or the struct that we the relevant struct, but everywhere in our code that is accessible from this implementation. One more important thing is that we have a name, if you noticed, for this implementation, in this case ice eater dog. And this lets us refer to this implementation, if for example, we want multiple implementations for the same trait.
00:07:18.650 - 00:08:04.322, Speaker A: This is something, again that gives us some flexibility. Ref parameters, again, you might know the concept from different languages. It is a bit different in Cairo, because in Cairo, behind the scenes, everything is immutable. So the memory is immutable and we cannot change it. So what happens here actually is not that we change the reference, the memory that the call site passed to us, but we actually copy a value into the function and then back out of the function a new result. So we have one additional input value and one additional output value. And it's important to understand that, because it's hidden.
00:08:04.322 - 00:09:01.686, Speaker A: So the cost here is hidden, and you need to understand that. One more thing is that we can use refs for both normal parameters like ice amount here, or for the self parameter that we have. And as you can see in the implementation, we can actually change these parameters and it will change on the call site. Again, in the call site, we define mutable variables to use for the ref parameters, because otherwise they cannot change. And we enforce the ref keyword in the call site, so that it's very much readable that something might change. The only exception is that if we have the self parameter like Skippy here, it doesn't specify ref. Okay, so panics again, concept similar from, to other languages.
00:09:01.686 - 00:09:36.414, Speaker A: In rust we have panic. In other languages we have exceptions, for example, and the idea is that it exits the entry point of the program with the failure. So this is an example, this is taken from the colib, Cairo colib. And as you can see, we can panic the third line. In the third line we panic with some data. And this for example is a function built on top of panic, that can assert conditions and panic with the relevant data in case of failure. Implicit parameters.
00:09:36.414 - 00:10:38.330, Speaker A: So implicit parameters are a concept you might know from chiro zero. The idea is that we have some parameters or types that we pass mostly, not mostly, but we pass to many locations in our code. So instead of writing it again and again in every function, we decided we want it implicit. So in Cairo zero, it looks a bit like this. So we actually define the implicit parameter in the definition of the function, and this makes it a bit of somewhat half implicit, not completely implicit, and also on the call side, most of the times we don't specify it, but sometimes we need to somehow specify and then it becomes not completely implicit. And what we did in Cairo one is to actually do it completely implicit. So the same hash two function here doesn't specify anything about the hash built in that we use, which is the implicit parameter.
00:10:38.330 - 00:11:32.950, Speaker A: And only the fact that the first function here use hash built in uses this built in tells the compiler that this function, hash two also uses the built in, so everything is computed automatically for you by the compiler. One more thing to note again is that this is very similar to ref parameters. So the value is copied into the function and then back outside, and there is a hidden cost that you need to notice here as well. The same thing happens with panic. So for example, if validate can panic, for example, then hash two also can panic and the compiler knows it automatically. Okay, name the arguments again concept that you might know. We also decided to use it in function calls.
00:11:32.950 - 00:12:20.054, Speaker A: So for example, we have the add function here with many parameters. And imagine that this function is defined in a different file so you don't see it in your eyes. And now we have the full function that calls it. So the first line doesn't use named arguments, and it's very clear that it's not clear what each argument means. So what this call means, but with the named parameters named arguments, sorry, you can much more easily understand what's going on. And these are the different forms of named arguments that we have. We allow every combination that you want of named and unnamed arguments, so you can choose for each argument if you want to name it or not.
00:12:20.054 - 00:12:59.138, Speaker A: The only thing that needs to be retained is the order of the parameters. So for example here three is unnamed, but then the rest are named. And as you can see, last argument is a shorthand that we introduced for when the name of the parameter and the name of the value or the variable that is used as a value are the same. So we have colon is new, which is equivalent to is new, colon is new. Okay, a bit about starnet contracts. So this is a contract in a simple contract in starnet. So as you can see, the first line is an attribute contract.
00:12:59.138 - 00:14:00.666, Speaker A: This means that there is a plugin that is not part of the core of the language, but an outside utility that acts on the language. And this module is an item in the language. And the plugin, startnet plugin in this case acts on it to generate the code of your contract. So in the contract with these attributes, you can specify the storage that you have with some values or variables in it, and you can define functions like events, external and view functions. You also can use internal functions which are the same functions, but if you don't specify them as events, external or view functions that can be used inside your code, you have also mappings in storage that you can use. You can declare a contract API and you can call another contract similar to.
00:14:00.688 - 00:14:01.740, Speaker B: What we have here.
00:14:03.070 - 00:14:49.930, Speaker A: Okay, so a bit about what's coming on soon. So first, well, I know you've been waiting for it for a long while, or at least some of you for loops. Yes, thanks. So we are excited about it too. It's coming up in the coming months. And yeah, we also have more things like Cairo package manager scarb by software mentioned that already exists and can compile contracts, but is going to be improved more. We have the language server that's going to have more improvements and features for you to easily develop.
00:14:49.930 - 00:15:38.620, Speaker A: In Cairo we're going to introduce short circuiting, which means that if you have a binary expression, and once you already know the definitive answer, you don't continue computing the rest of the terms. We'll have improved compiler errors, support more types in dicts, more features in contracts like extend other contracts, or implement AbI. We have syntactic sugars, efficiency, better economics, visibility, and a lot, a lot more. So we are excited about the future, and I hope you are too. That's it. I didn't see my timer, so I don't know how much time I have for questions. Two minutes, four minutes?
00:15:41.570 - 00:15:46.400, Speaker B: Yes, of course.
00:15:48.130 - 00:15:59.060, Speaker A: I'll just repeat the question, because not sure everybody heard whether we are going to have if and else. So of course we have it already.
00:16:05.700 - 00:16:06.160, Speaker B: Okay.
00:16:06.230 - 00:16:22.890, Speaker A: No, in Cairo zero, we have some strange things we need to do when we have if and else. This doesn't exist in Cairo one. Cairo one looks exactly like any other high level language. You know, you can write if else and everything is handled for you.
00:16:24.060 - 00:16:24.810, Speaker B: Yes.
00:16:27.980 - 00:16:47.664, Speaker A: I might have skipped it in the first slide, but it was written there. We also have options, results and question mark operator again, if you know Russ, it may mean a lot to you. If not, maybe not. But these are powerful tools that you can use. More questions?
00:16:47.862 - 00:16:48.610, Speaker B: Yes.
00:16:53.820 - 00:17:19.804, Speaker A: Will there be a simplified layer over DiCt access? We wouldn't have DICt access. We have DICT. We're going to have DICT. I mentioned it, we have already DICT. It doesn't support all the types. You don't need DICt access as in Kyro zero. You can use DICT again as similar to high level languages and we are going to support more types for it.
00:17:19.804 - 00:17:26.300, Speaker A: So essentially everything that might be in addict should be supported eventually.
00:17:30.490 - 00:17:31.240, Speaker B: Yes.
00:17:34.730 - 00:17:44.554, Speaker A: With the for loops use recursion. Yes, the question was whether for loops are going to be internally recursion.
00:17:44.602 - 00:17:46.080, Speaker B: The answer is yes.
00:17:50.530 - 00:17:54.960, Speaker A: The question was again, what is the maximum depth for the recursion? I don't know.
00:17:56.390 - 00:17:57.540, Speaker C: Shouldn't be.
00:18:03.140 - 00:18:10.900, Speaker A: We haven't concluded this decision yet, but there shouldn't be something very restrictive.
00:18:11.400 - 00:18:12.150, Speaker B: Yes.
00:18:15.980 - 00:18:37.088, Speaker A: The question was whether we are going to have default arguments. We don't have such plans for now, but it is an option. You might suggest it in GitHub or some other discussion form and then we can discuss if this is something that we want but it's not planned for super soon.
00:18:37.254 - 00:18:37.970, Speaker B: Yes.
00:18:43.960 - 00:18:57.598, Speaker A: We already have U 256, the first classic like felt. One last question or I don't know how much time.
00:18:57.684 - 00:18:58.320, Speaker B: Yes.
00:19:01.330 - 00:19:24.092, Speaker D: How do you feel about language hiding all this complexity of the runtime? But on the surface normally, but under the hood, like dealing with this immutable memory model, what challenges does it provide and what do you think about that?
00:19:24.146 - 00:19:31.100, Speaker A: So do you mean in the manner like from the view of the user or from the view of the developers.
00:19:32.080 - 00:19:36.780, Speaker D: Because you do something simple but under the hood?
00:19:40.270 - 00:19:40.922, Speaker B: Yes.
00:19:41.056 - 00:19:44.378, Speaker A: I think Shah wants to urge us to answer.
00:19:44.544 - 00:20:12.190, Speaker C: We try to strive to get zero cost abstraction as much as possible. You don't have runtime. Pretty much what you get for loops are called functions. Everything should be explicit that it does something you are not supposed to get. Things that are invisible.
00:20:13.570 - 00:20:56.910, Speaker A: Let me just repeat approximately for anyone to hear and to add my view. What Shakhal said is that we are aiming to add as least as possible such things that are hidden. But we do have them in Cairo, for example, in Sierra, and Shah will talk about it later. We don't have them. So everything is what you see is what you get. But for it to be a high level language we needed to hide some costs and I talked about some of them previously, but most of them are not. And yes, because thing behind the scenes is much more complex.
00:20:56.910 - 00:21:14.240, Speaker A: It enforces us to choose between some trade offs. And for it to be a high level language that is easy to use, we do need to hide some of the stuff. Okay, thank you.
