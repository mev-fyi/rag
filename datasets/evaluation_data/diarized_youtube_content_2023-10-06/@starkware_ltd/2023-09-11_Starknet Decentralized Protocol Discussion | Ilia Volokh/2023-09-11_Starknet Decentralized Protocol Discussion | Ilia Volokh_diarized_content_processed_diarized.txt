00:00:04.050 - 00:00:34.750, Speaker A: Hi, I can't see anything, so I just assume people are here and are listening. My name is Ilya. I'm from the starknet product team, and I'm here to talk to you about a bit about starknet decentralization. So our agenda for today is we want to start with presenting the problem we're trying to solve. Then we're going to talk about what we're trying to do to solve it. We're going to try and outline a complete proposal for a decentralized protocol, and I'll try to outline exactly what that means. Then something mysterious is going to happen, and we're all going to profit it and go home happy.
00:00:34.750 - 00:00:56.950, Speaker A: And you can see my mascot is the arctic God of wisdom over there, which is also my avatar on Twitter. So if you want to discuss decentralization, I'm happy to do it. Find me there. Okay, so we'll start with the architecture of a centralized roll up. And very roughly speaking, the flow is as follows. You have a bunch of users and a centralized sequencer. Users send transactions to the sequencer.
00:00:56.950 - 00:01:41.042, Speaker A: The sequencer picks out the transaction. It likes, it orders them, it creates a block. Then it sends these blocks to a proving service. This proving service gradually aggregates these blocks and proves them, posts the proof to l one, and then as soon as the proof is verified on the l one verifier contract, we achieve l one security seems to be the end of the story, except not really, because we have a major problem with this centralized architecture. Some things can go wrong. So is the problem having a bunch of people print money out of nowhere? No, it's not exactly the problem, because validity proofs basically prevent people from doing all sorts of fishy things. So this is not the problem.
00:01:41.042 - 00:02:16.746, Speaker A: The main problem is censorship. We want to avoid censorship, and that's the fundamental reason we'd like to decentralize the entire architecture of the roll up. Now we have to discuss what exactly it means to decentralize a roll up. Okay, so our goal is to build a simple protocol with four layers. We want to have decentralized staking, we want to have consensus among the stakers, we want to decentralize the proving layer. And lastly, we want to decentralize the process by which l one state updates happen. On the right you can see our starknet sequencer, which is centralized and therefore ugly.
00:02:16.746 - 00:03:02.798, Speaker A: And on the right you can see a beautiful human being named Andrew Milson, who recently built a starknet prover and also appeared on the COVID of Sports Illustrated magazine. He's wandering around here somewhere, and I think he'd love to talk to you about provers and maybe also swimsuits. Okay, so I think we'll try and give an outline of a complete proposal for protocol. The goal is not to give details, so there are going to be many details missing. It's just sort of to convey the gist of it. And if you want details, there's a long series of posts which are available on the Starknet forum. There are some discussions there, and I guess I'd be happy to take any other discussions offline, but for now, the goal is just to convey the gist of it.
00:03:02.798 - 00:03:30.600, Speaker A: Okay, so as we roughly described, there's going to be four layers to the protocol. One of them is going to be, the first one is going to be the proposer schedule. So this is the part of the protocol which decides whose turn it is. The protocol in the decentralized setting has a bunch of stakers. These stakers put stake to obtain turns. And it's part of the protocol's rule to determine whose turn it is when. Which staker is supposed to propose a block when.
00:03:30.600 - 00:03:59.706, Speaker A: Right. So that's the first part. The second part is getting these people to actually agree on the order of transactions and perhaps also on the state. After that, after they agree and output a bunch of blocks, someone needs to prove these blocks. And then after that, these proofs need to be sent to l one for verification. So we'll try to more or less go over these four layers and outline what should happen in each of them. Okay, so we start with a proposal schedule.
00:03:59.706 - 00:04:44.350, Speaker A: And again, our goal is to, I guess our fundamental goal is to first of all agree on the effective stake distribution for a given l two block. What does that mean? It means we have to know who are the set of stakers and what is the stake distribution out of which we are trying to count two thirds. Right. We can't have people disagreeing on who the stakers are, because otherwise they will disagree on whether or not a block has been finalized. For example, if one set of people thinks I'm the only staker and another one thinks I have no stake, this can cause problems because some of them will listen to my chain and others will ignore it completely. So this is definitely something we have to take care of. Another thing we want to take care of is to have staking operations that are maximally decentralized.
00:04:44.350 - 00:05:52.290, Speaker A: So to achieve this, what we would like to have is to just have all the staking operations take place on l one and the property we want to get out of that is to make sure that the staking operations don't require the permission of the l two consensus. So even if nobody on l two likes you, you can still go on ethereum, you can still stake your stark tokens, and you can join the staking pool, and you have no fear of being censored by the people who don't like you on l two. Okay, so from now on, let's divide all of time into slots, and we'll group these slots into epoch. So in a nutshell, the schedule is selected by using or magically generating randomness once per epoch and then fixing the stake distribution once per epoch, and basically having the randomness act as a random coin flip on this pie chart of stake, and wherever the coin lands, you look at whose stake portion you landed on, and that's going to be the leader for each slot. So you do this coin flip using the same randomness at every slot once per epoch. That's more or less the idea. There is some attacks, there is some unpredictability questions.
00:05:52.290 - 00:06:19.590, Speaker A: I want to delegate all of that to discussions later. This is the rough idea. You flip a coin every few seconds, and then you know whose turn it is. So that's the proposer schedule now for the l two consensus. First of all, we want to go with proof of stake, not with proof of work. And actually, there's been a bunch of very interesting recent advances in proof of stake consensus. Specifically, I'm referring to all the dag based protocols.
00:06:19.590 - 00:06:51.222, Speaker A: And we actually have one guy in the audience who's extremely handsome. His name is Oded, and he's one of the pioneers, actually, of this whole field of DaG based BFT protocols. Nevertheless, we decided not to use them at all because they haven't been battle tested yet. So it's just cool trivia for now. And we wanted to go with a maximally battle tested protocol. We figured tendermint would be a pretty good idea in that regard because it's been battle tested in production in the cosmos ecosystem since 2018. So we figured that's a pretty safe way to move forward.
00:06:51.222 - 00:07:19.546, Speaker A: And this nice diagram, which I incidentally also stole from ode, outlines from the global perspective, more or less what tendermint looks like. Again, I'm glossing over a bunch of details, but very roughly speaking, you have three phases. Every round somebody proposes. In this diagram, it's p one. P one is the proposer, a bunch of people. There are two voting phases. After there is a proposal, people vote and collect votes, and then they vote again to finalize.
00:07:19.546 - 00:07:54.250, Speaker A: If they reach consensus, the block they agree on is finalized forever. You can never go back, no matter what. This should not sound good to you because that's a recipe for a disaster, but let's pretend it's a good thing. So that's more or less l two consensus. Okay, what do we have so far? So far, we have a proposer schedule that determines whose turn it is to propose blocks when using proof of stake, and we have a method for these people to also agree on the order of transactions. We have two layers left to go. Somebody needs to prove all of these blocks, this chain that's been agreed on.
00:07:54.250 - 00:08:12.500, Speaker A: And then after it's been proven, somebody needs to make sure these proofs are sent and verified on l one. So these are the two layers we have left. So for the proving, you have this pretty picture. You really have to look at a pretty picture. We'll try to go over it now. I'll give a simple example where. Okay, first I'll outline the problem.
00:08:12.500 - 00:08:44.282, Speaker A: So we want to decentralize the proving load. And maybe the most naive proposal for decentralizing the proving is to say something like, if you propose a block, you should also prove that block. So everyone is in charge of proving the block they propose. However, that sort of runs into problems. So what I said now bifurcates into two possibilities. The first one is that I put the proving into the critical path. I say you can build a block, but before you disseminate your block on the network, you have to prove it.
00:08:44.282 - 00:09:21.334, Speaker A: This really sucks, because proving takes a long time. So if we do this type of protocol, most of the protocol will be waiting without any progress. At any given time, it's very likely that all of us will be waiting for the proposer to be computing a proof of their block. So that's probably a no go. The other option would be to say something like, you can propose and disseminate your block, and after you do that, we really hope you'll prove your block and share the proof with the rest of the network. But there's a bunch of incentive problems there, and a bunch of things could go wrong. So I think that's also not the best route to go down.
00:09:21.334 - 00:10:01.726, Speaker A: So what I want to focus on is a proposal that's supposed to alleviate the concern with the first proposal specifically. Instead of asking the proposer to compute a proof of the block they propose, I'll ask them to prepare in advance a proof of a previous block. So that way there is no waiting for proofs when it's going to be my turn in, let's say ten minutes, I will begin computing a proof. I will have ten minutes to compute this proof. By the time it's my turn to create a block, my proof will have been ready and then I can construct the block, append the proof and disseminate. Okay, so we've eliminated waiting and this is more or less the idea of this recursive strand protocol. So I'll try to go over this picture.
00:10:01.726 - 00:10:45.986, Speaker A: Now let's assume just for simplicity that it takes three slots to compute a proof. In reality it's probably going to take a few dozen slots, but that would make the picture a lot uglier. So I think this conveys the gist of it. We're assuming it takes roughly three slots to computer proof. And what we see, the horizontal stripes are basically three separate strands depending on the remainder of the slot number mod three. Okay, so we have these three separate slots and the idea is that let's look at, say slot number seven. I want the person who is supposed to propose a block at slot number seven to compute a proof of the block at slot number four.
00:10:45.986 - 00:11:41.426, Speaker A: So the whole point is that if I give the proposer of slot number seven enough time, they will have enough slots to compute this proof as soon as there is consensus on slot number four. More generally, in each strand, I want a person in the strand to be in charge of computing the previous proof of the block in the strand. And if the strands are sufficiently spaced apart, this will give plenty of time for everyone to compute the proofs without anyone waiting, basically ever. Okay, so what I've said so far is, I mean, it sounds nice maybe, but it's not really convincing because what I've described outputs a proof per l two block and that's not viable for l one. It's too expensive. It's too expensive to put many small proofs on l one. We would really like to compress these many small proofs into one proof and save a bunch of l one gas on our footprint.
00:11:41.426 - 00:12:28.766, Speaker A: So we can do this by tweaking this idea of recursive strands a bit and adding a bit more to the proof. So what I've described so far, we've said that the leader of slot number seven needs to only compute a proof of the block in slot number four, meaning a proof of the execution of the transactions in slot number four. Now I want to change that. I want to add something additional. So we said before that every proof contains transactions and also a proof. And what I want to add to the proving load is you don't only prove the previous transactions in your strand, you also prove the verification of the proof in that block. Okay, so specifically in slot number seven, I'm looking at the block.
00:12:28.766 - 00:12:53.882, Speaker A: In slot number four. This block has a bunch of transactions and a proof. So I want to prove the execution of these transactions and the verification of that proof. So this gives me a sort of interesting recursive structure in each of these strands. Note, this recursive structure is completely horizontal. The different strands don't interact with each other at all. But it turns out that it's pretty good.
00:12:53.882 - 00:13:21.860, Speaker A: It's pretty good. And the only thing left to do is you have to merge these strands together before posting them on l one. Now if this makes sense to you, please come work at Starquare. And if not, then you should read the post later or discuss it with me because it took me a while to figure it out too, but it seems to work. So I don't want to elaborate too much on that. Now, suppose you have this recursive strand protocol. You have each of these strands going along.
00:13:21.860 - 00:13:59.230, Speaker A: Each of them is growing, right? Every time someone is trying to propose a block, they've computed a proof of a previous block. And it seems that there is no increasing backlog of proofs because the proving is coupled to the ordering. The only thing you have left now is to somehow take these separate strands and to merge them into a single proof, which you can stake on l one. And this is basically the idea. The idea for the l one state update protocol is to have fairly long turns. And during these long turns, two things are meant to happen. First of all, the person whose turn it is is supposed to run sort of a recursive proof that merges these strands.
00:13:59.230 - 00:14:25.506, Speaker A: That's the first thing. And second, they have to have enough time left over to also post this proof on l one and perform the l one state update process. And that's pretty much the fourth layer. I think that pretty much covers it, so I'll try to review it very quickly. We had four layers. We had proposal scheduling, we had l two consensus, we had proving, and we had l one state updates. For the proposal schedule.
00:14:25.506 - 00:15:03.206, Speaker A: We want to have staking operations on l one, and from the information on l one, you'll be able to derive the proposal schedule completely. Then we will execute tendermints to determine the order of the blocks proposed by these stakers. After that. Not after that. Coupled to that, we will require people who propose blocks to also prove things according to the strand structure we specify. And finally, we will have long terms for people to merge these strands and post the proofs on l one. So I think that that sort of conveys the picture, I hope.
00:15:03.206 - 00:15:14.920, Speaker A: Let's see what else I have here. No time to talk about that. Question marks. No time. Profit. No profit. I guess that's it.
00:15:14.920 - 00:15:16.280, Speaker A: Thank you.
