00:00:00.330 - 00:00:22.430, Speaker A: Live. And we're live. Hello, everyone, and welcome to that 25th community call for Starknet. Actually, is it a milestone? I don't know. When should we count community calls as milestone? Like the 10th, the 25th, 100 for sure. Or should we do like powers of two? What do you think, ohad?
00:00:22.930 - 00:00:27.000, Speaker B: I think we should do a genesis to community call at some point maybe.
00:00:27.770 - 00:00:33.560, Speaker A: And start the block. Note the numbers from zero, but still take into account everything that I was saying before.
00:00:34.010 - 00:00:37.720, Speaker B: Yeah, 50 sounds good to me as well.
00:00:38.090 - 00:01:17.640, Speaker A: Super cool. All right, so for all of you tuning in today, the goal for today's call is to talk about Regenesis and the roadmap of Starknet for the coming weeks and months. So today I have with me Ohad from the product team. He's going to be our guest for today. So we can talk about Regenesis. And in the first step, we're going to talk about Regenesis and then about the roadmap. Ohad, any way you can get your hand on headphones or something?
00:01:20.410 - 00:01:24.840, Speaker B: I don't have headphones. I can try hunt somebody to take a few minutes at least.
00:01:26.730 - 00:01:34.300, Speaker A: Okay, give me. There is a bit of an echo is the issue, but we'll make it work.
00:01:36.910 - 00:01:37.660, Speaker B: Okay.
00:01:39.630 - 00:01:43.600, Speaker A: Let'S see. We'll try to make it work.
00:01:44.930 - 00:01:47.840, Speaker B: So I just speak clearly or do you want to ask me questions?
00:01:50.610 - 00:02:06.520, Speaker A: Let's talk first about Regenesis. So Regenesis was. Let's try to retrace a bit the story of the network if you can, ohad. So Starknet started what, a year ago? More than a year ago.
00:02:08.650 - 00:03:10.682, Speaker B: Yeah, we were on Testnet on July 2021 and Mainnet on November 2021. And Starknet really started as like, evolving project. Right. I think we were the felt, or among the felt teams to start being like a general purpose roll up. We started without knowing fully what challenges we would face and how severe they would be. So in earlier communication, in order to not over promise anything, we said, okay, Starknet is an evolving process and there is an option that we'll have to do some heavy change or backward incompatible change, potentially even migrate the entire network. But as the network advance and things became clear and clearer, it became apparent that we actually don't need to do a very disruptive change.
00:03:10.682 - 00:03:14.220, Speaker B: So I'll talk now about what we will do.
00:03:15.550 - 00:03:31.710, Speaker A: Actually, if I may ask, why was the decision made to start working on Starknet with a very basic version instead of, I don't know, finishing everything and then shipping it without a state migration?
00:03:35.270 - 00:04:07.740, Speaker B: Like in the end, Starknet would be a useful ecosystem only if it's useful for a lot of developers, right, a lot of applications. It was very important to us to have people building on Starknet and get a proper feedback of what is good, what is not so good, so we know to improve it. And without people giving this feedback, we can't really guarantee ourselves that we indeed finish the development of this environment. Right.
00:04:09.710 - 00:04:52.854, Speaker A: I understand. Okay, so basically instead of developing a full product for a long time and then releasing it, we decided to have a short product lifecycle feedback loop, right. Small functionalities and then iterating a small feature set and then iterating quickly to ship little by little. So yeah, you're right. As you mentioned, this has a lot of advantages because you get to have feedback from users and you get an ecosystem growing. You can see what are pain points and it's easier to sort urgent ones and less urgent one. The less good thing is that not really that you don't really have time for optimizations.
00:04:52.854 - 00:05:03.440, Speaker A: It's mostly that you ship things and later on you figure out, oh, I can do these things differently, but it's hard to roll them back once they're on a live network. Right?
00:05:04.050 - 00:05:55.214, Speaker B: Yeah, I mean some changes it's possible to do it as long as our backward compatible. Nice. For some changes it's harder. So what we try to do is to map the minimal things we need to change in order to really promise this point in time would be as good place as ZK Rob l two can get with guarantees that at least salco wouldn't be behind any other such movement in the future. And what we actually come up to realize is that most limitations of Starknet are not due to starknet or due to the current version of Cairo. So currently Cairo allows you to prove any computation in the world is correct. And it sounds really strong.
00:05:55.214 - 00:06:19.030, Speaker B: But the pain point that currently Cairo has is that it doesn't allow you to prove that an incorrect computation was actually incorrect. Right. If I try to send you money and I have the money, then Cairo can prove that all the calculations were done correctly. But if I try to send you money I don't have currently the Cairo code would just crash and say association failure.
00:06:19.690 - 00:06:41.310, Speaker A: Okay, so essentially it means that if you want to send me money, you can generate a proof for it. If you want to send me money but the program doesn't work, you can't generate a proof for that. So for me it's the same if you don't send me anything or if the program fails and I have no way to distinguish between both, right?
00:06:41.380 - 00:07:13.510, Speaker B: Yeah, exactly. So currently, if I try to do something which is wrong, it can't be inside the sequence of transactions in starknet because there is no way to attest the fact that it was wrong. And this is problematic from a variety of reasons. Right? First of all, it opens some attack vectors on the network, right? Because you would force sequence cells to process transactions that they can't include in a block and can't get compensated for.
00:07:13.660 - 00:08:04.930, Speaker A: And that's a big difference with Ethereum, because if you send a transaction on Starknet and it gets rejected, it's not added to the blockchain. The sequencer just says, well, I can't generate a proof for that. But from the blockchain's point of view, it's the same if the sequencer doesn't execute the transaction or if the transaction is rejected. And so there's no way to pay the sequencer for that. So if I send very heavy transactions to Starknet and they fail in the end, the sequencer has no way to check that they will fail. It will just execute them for a long time and then you won't be able to generate the proof for that. Contrary to Ethereum, where in Ethereum you can have a transaction that runs for a very long time, but if it fails in the end, the sequencer, I mean, the validator gets paid for that because there's a small check done at the beginning to check that the person is able to pay for her transaction.
00:08:05.090 - 00:08:56.466, Speaker B: Yeah, but I think the even more crucial disadvantage of this limitation is synergy persistence. Right? So now starting to centralize, but say, in airtime, give or take, we do plan to be decentralized and we actually have like a long stream of research on the best way to decentralize. And part of decentralization is also to ensure that you as a user can always add a transaction to the transactions queue. And the ability to prove that the transaction was there and that it was incorrect is a key ability, right? Because you could imagine a solution, a fuser communicates with target, even with l one, like with a term, and say, please execute my transaction.
00:08:56.658 - 00:08:59.074, Speaker A: So that's the concept of like forced transactions.
00:08:59.202 - 00:09:23.790, Speaker B: Yeah. And this solution can't happen if you can't say to l one. Look, I tried to run this transaction and the result was nothing. Because this transaction is malicious, right? If you can't tell it to l one, then l one can't distinguish between a user that sent a malicious transaction and just a sandalship by the sequence cells.
00:09:24.470 - 00:09:33.090, Speaker A: Okay, I understand. As you said, no way to distinguish between a shitty transaction and sensor transaction.
00:09:33.910 - 00:10:26.262, Speaker B: Yeah, so this is why we understood, okay, this is the inherent limit, the current design of caraput on Starknet, and this limit is acceptable for an alpha stage. But obviously it can stay with us when starknet grows to a fully production ready environment. To be able to have those protection, and we need to have strong anti celenship properties. If you wanted, Starknet would be a leading blockchain. And this is why a few months ago we started to develop Cairo 1.0, which is like the next generation of Cairo, Cairo 1.0. The main feature that it would have blockchain wise is the ability to prove everything.
00:10:26.262 - 00:11:06.282, Speaker B: Even like that stuff didn't change the state because it's incorrect except paying fees, et cetera. But we're taking the opportunity in order to make Iro much better language better means that you'd have easier time writing in it. It would be inspired by rust with a lot of primitives like the question mark operator to move error values quickly between calls, or like the match expression. So if you are familiar with rust or those familiar languages, you'd find that color one is much more intuitive and easy to program.
00:11:06.436 - 00:12:12.530, Speaker A: It's quite interesting, by the way, I'll just mention that if you have questions, feel free to ask them on the community calls channel on Discord, or to ask them on YouTube and we'll answer them. One thing that you said that is really interesting is that from a features perspective, we tend to hear about Cairo one because we usually push forward the fact that it's going to be better for users, that it's going to be nicer to write in, nicer to read and everything. But this is just nice to have in the sense that the developer experience side of it is just an add on. In reality, what really matters is the ability to prove everything. So like the must have is the fact that Cairo one is provable. In any case, nice to have is that it's easier for developer. It's quite interesting because people usually, I think that we framed a lot Cairo one in terms of developer ease of use, when actually it's a prerequisite for decentralization.
00:12:12.530 - 00:12:17.830, Speaker A: It's one of the must have. We need to make their network more robust and decentralized.
00:12:20.830 - 00:14:00.460, Speaker B: Yes, exactly. So I think that this is what motivates us to do the regenerative mode, because if we take a step back and say like, okay, we have this amazing language, Cairo 1.0, but some of the code inside the stocknet code stack is still old code, right? It's still Cairo v zero code. So whenever you have a call from Cairo one to Cairo zero, suddenly those places that are written in Cairo v zero, you can't prove that they felt correctly, right? It's just written in language, it doesn't allow you to do it. So if we want strong anti soundship authorities on stocknet and if you want to leverage those advantages of Cairo one, then the entire code stack should be written in Cairo one, right? Because otherwise the moment you have just this tiny bit of call into Cairo v zero code and it spreads like the plague, right? And all the contacts that rely on it, even like ten level up, they just can't enjoy the properties of taking fees for transactions that failed or proves that something that stock in the blockchain tried to do and it failed. And this is why we will have the regenerasis transition period where gradually, slowly, without any downtimes, without any disturbance to the state, without single need to do fund migration at all. And I'll elaborate next on how we're going to achieve that.
00:14:00.460 - 00:14:06.982, Speaker B: We are planning to slowly migrate into Cairo 1.0 based environment.
00:14:07.126 - 00:15:32.370, Speaker A: I understand. So the fact that Cairo one is provable and Cairo zero is not means we need to basically phase out from the network all of Cairo zero. So it's not exactly a hard fork, because like a hard fork restricts, usually restricts what you can do, but things that you did in the past, you can still use them. Not sure exactly it would be the equivalent to deactivating the use of specific opcodes in ethereum, but meaning that it's not just that you can't deploy these bytecodes, it also means that the smart contracts that use this bytecode in the past can't be used anymore. So we basically need everyone to phase out their Cairo zero code and have a Cairo one code in its place. As you mentioned, it's kind of disruptive on paper and that's where I think maybe it's the testimony of the fast paced development of Starknet here. But we toyed with the id for a long time to try to figure out how we could do that in the less disruptive way and to make it as much as we can easy for developers.
00:15:32.370 - 00:15:43.450, Speaker A: And eventually we found a solution. And actually when I say we, it's not exactly us, right? It's one of the partners we're working on Starknet with who came up with the solution. Right? Oad?
00:15:44.190 - 00:16:41.360, Speaker B: Yeah, I mean, as part of thinking on how to do it in the least disruptive way possible, we discussed a lot with the community, both in our community forum and had a lot of intense discussions with leading individuals from the start ecosystem. Eventually it was Kuba from the software mentioned team that came with this idea. And in general we try to be responsive and cooperative as possible with the community. Right, because we are going all of this together for the goal of starting being a better blockchain to build on say six or twelve months from now. And we don't presume to know everything on behalf of the developers. So this is what guided us through this process and what would continue to guide us. Yeah, so maybe I can start a deep dive into how it would actually work.
00:16:41.890 - 00:16:42.640, Speaker C: Perfect.
00:16:43.330 - 00:18:24.058, Speaker B: So if we think about it, what we really want, like the hard requirement that we understood we can't compromise on, is to remain with the same starknet where the state is fully backward compatible, right? Imagine for example even an ERC 20, right? So this ERC 20 contract is now written in Tyro v zero, and it needs to get written in Tyro V one. What we don't want and will not have is that users need to burn their old tokens in the old ERC 20 in order to mint them in the new one, right? This would be a not nice user experience. What we will have instead is a seamless upgrade of this ERC 20 contract. Meaning that this ERC 20 contract would come to Starknet and say, hey Starknet, here's a new and shiny implementation of my code in Cairo one. Please have this code instead in my address. What would it mean? It means that the address of the LC 20 contract doesn't change at all. Right? So all the users, all the wallets, all the applications that are used to query this ERC 20 contract, to query balance, to approve anything, they still talk with the same address, right? The fact that the ERC 20 implementation just got shifted from Cairo zero to Cairo one is completely transparent to them.
00:18:24.224 - 00:18:39.890, Speaker A: So a contract is a triplet of an address, some code and some storage. So what you said is that of these triplets, we really only need or don't need to change one. So how do we keep both others intact to minimize disruption?
00:18:40.710 - 00:19:25.634, Speaker B: Yeah, exactly. So the way we keep the address constant is by adding a new library call. We'll add it in a month or two, we'll get into timelance really soon. Maybe we should have talked on timelines before, but never mind. And so this system call would be our library call would be something that any contract can call, and it would be like, okay, here is my new class of implementation. Here are the constructor arguments I want to initialize this implementation with. Please call this class with constructor and deploy it in my current address.
00:19:25.634 - 00:20:20.402, Speaker B: And the deployment with this current address would mean that it get deployed with the same state. So let's continue with the LC 20 example. So I'm a user of DLC 20 and DLC 20 for example. Let's take USDC. So it saves that my address maps to 1000 USDC. Now, in the Cairo V one version, my address as the Cairo V one contract sit would continue to map to the same storage cell in starknet. This means that if your Cairo v one code still expects, say, to find my balance under the same variable name, say hash of balances, and my address, then this state cell would still be 1000, right? DRC 20 state would continue to be the same and all of the information would still be there and it would still be accessible in the same way.
00:20:20.402 - 00:20:49.750, Speaker B: So like, if you keep your variable names consistent with the old implementation, everything can continue to work without any downtime, without disruption, without your users even noticing that your upgrade can happen, right? I'm as the user can send transaction to your contract, and then before it gets executed, your contract would move to v one, like to car one, and then my transaction can be executed and everything would work.
00:20:49.920 - 00:20:58.142, Speaker A: It's essentially like having an upgradable contract. But it's a native cisco for upgrading the code of your contract, right?
00:20:58.276 - 00:20:58.960, Speaker B: Yeah.
00:21:01.090 - 00:21:29.050, Speaker A: Okay. Can I ask two questions on that? Sure. So the first one is that, does this mean that addresses of contract won't be related? Like right now, the address of a contract is the hash of the code and some other parameters. So this means that the hash won't map as before to the code, right. I understand this is a sacrifice we're willing to make, but is there a security risk here? Can there be hash collisions?
00:21:32.350 - 00:21:49.742, Speaker B: There can't really be hash collisions. This is like an exception. We added the rules, right? We said like, okay, others would continue to be hash of your class hash and arguments unless you use this specific mechanism, right?
00:21:49.876 - 00:21:50.560, Speaker A: Okay.
00:21:51.170 - 00:22:11.398, Speaker B: And this is totally equivalent to find like a collision between a new contract, right, and an old contract, right. You could say that someone could manipulate the system and find a new class and constructor argument that map to existing contract, right?
00:22:11.564 - 00:22:11.894, Speaker A: Okay.
00:22:11.932 - 00:22:14.082, Speaker C: Because the only way without this mechanism.
00:22:14.146 - 00:22:40.846, Speaker A: Because the only way to have matching would be to redeploy the exact same code, which is Cairo zero code. So you can't really redeploy it. Understood. Okay. The second question, how? Right now, the API of the call is not deployed. And what should I do in order to be able to upgrade the call of my contract later on?
00:22:41.028 - 00:22:51.906, Speaker B: Yeah, okay, maybe I can answer this question by presenting the overall timeline of this process and then highlight the action items at each point.
00:22:52.008 - 00:22:52.610, Speaker A: Perfect.
00:22:52.760 - 00:23:41.486, Speaker B: So right now we are like mid October, as you say, the scheme is pretty much laid out, but the API call is not implemented yet, as we just thought of this scheme a couple of weeks ago, but it's already finalized. So you can be convinced that what we are saying wouldn't change in the high level flow. And what you can do is that you can write your contracts to be upgradable. Technically it's relatively easy. We have reference implementations by Openzeppelin on how to do upgradable contracts. And this way you can be sure that whenever we do release all the details on this system call, you can upgrade your implementation behind the proxy very easily to use it. Now I get to the next milestone.
00:23:41.486 - 00:24:45.494, Speaker B: So around by the end of the year two things would happen. First, you would release the API like the library call for this library call to change your contract into Kyra one. The second thing that it will happen is that by end of the year Chira one specs would be released. This means that you can start to look on Kyra one, teach it yourself, play with it, and then start to rewrite your application with Kyra one now by say few weeks afterward. At most say beginning of next year, the transition period would start on Starknet. What do I mean by the transition period would start? I mean that a Starknet version that would launch around January next year would enable you to upload Cairo one contracts to Starknet, like would fully support Cairo one. Cairo Zero would still be supported as well.
00:24:45.494 - 00:25:38.522, Speaker B: So the transition period is called the transition period because over it or like during it, applications slowly move from Cairo zero to Cairo one and everything works. Because intercourse between Cairo zero and Cairo one would be supported during the transition period. So beginning of next year you can already start to rewrite your applications in Cairo one and then say you finish to write your application with Cairo one. So what would you do, right, you would say uploaded now or November, like an upgradable Kyro v zero contract. So what you should do is that you first upgrade the implementation behind the proxy to include a call to this library call, right. You need to have it in order to update eventually into Chiro one code.
00:25:38.656 - 00:26:12.878, Speaker A: Okay. To make sure it's clear. So if you deploy behind a contract, an upgradable contract, there are actually two contract codes. There's your application code and the proxy code. Right. And the syscall doesn't affect the proxy storage, so it doesn't affect where the proxy points to, it affects where the address points to. So when you're calling the new Cscall from proxy, it will change the proxy implementation.
00:26:12.878 - 00:26:35.340, Speaker A: So what you're saying is that the first step is to first move your proxy implementation to version 1.0, is that it? And at that point you've changed the, so the proxy code, like the code manipulating how you can change the implementation of your application is now in Cairo 1.0. Right. But your application is still in Cairo zero.
00:26:35.950 - 00:27:03.490, Speaker B: Yeah. So at this point your proxy is in Cairo zero. The implementation is either zero or Cairo one. But what's important is that it now contains the library call. Right. Because what would happen next, you would run this library call through your proxy and this would cause effectively to change the address of the proxy itself. Right.
00:27:03.560 - 00:27:26.570, Speaker A: Okay, so I actually said something incorrect. The first step is not to change the proxy's code, it's to change the application of your app so that it can change the proxy's code, which is quite fun because usually proxies change the implementation, but implementation are not aware or are not able to manipulate proxy. And in that case the implementation is able to modify the proxy.
00:27:27.550 - 00:27:56.722, Speaker B: Yeah, exactly. Because what we really need is to modify the proxy. For example, you may say, I don't want an upgradable app. Right. So whenever you use this scheme, you can actually change the implementation of the proxy to contain the entire logic, like a non upgradable contract. And after you finish to use this pattern, then your application is non upgradable. Right.
00:27:56.722 - 00:28:01.960, Speaker B: You just updated the proxy to contain the entire logic in Kyro v one code, right?
00:28:02.650 - 00:28:03.400, Speaker A: Yes.
00:28:04.010 - 00:29:25.860, Speaker B: Okay, so this is what we expect people to do over the transition period. And whenever the transition period ends, tentatively, we aim for a transition period of around three months. Obviously the length of the transition period depends on the rate of adoption from the community. We wouldn't say we are sorry, the transition period ended where significant portion of the contracts didn't adapt yet, but whenever it happens in the transition period ends, we would stop supporting Cairo v zero code. This will be implemented by saying that like contacts written in Chiro v zero are v zero contracts and contacts written with Kyra one are v one contacts. And the start and OS wouldn't false as part of its probability mechanism that no contacts with v zero are ever being called. What would it mean? It means that as a user, let me recap and say what does it mean to you all this process, if you are a user, and if you are a developer, if you are a user, all process.
00:29:25.860 - 00:29:34.870, Speaker B: You're breaking up, right, applications, yeah. From which point shall I repeat?
00:29:35.370 - 00:29:37.154, Speaker A: From a user's perspective.
00:29:37.282 - 00:30:21.670, Speaker B: Okay, so from a user perspective, this whole process is almost totally transparent to you. Why is that? Applications that you use, and this includes your account contract are slowly updating to Cairo one, but all the state is fully compatible. All the operations, if the developers didn't broke things on the application level are the very same. You just continue to use Darknet as you used to, you don't feel any difference. The only caveat to this declaration is that the user is still required to update his account to Cairov one account. Right? So it means that a user is expected to log in over the transition period. He would see like a pop up of please upgrade my wallet.
00:30:21.670 - 00:31:14.162, Speaker B: And the moment he clicks on this button. And this is identical to his experience currently, right? Even with minor start net versions, he would have Cairo v one contract and everything would continue to work for him as a developer. It's true, you would have to rewrite your code in Kyov one, but you can start starting today, build like base of users or funds into your app, because those funds wouldn't move anywhere. Those users wouldn't move anywhere. You can view it as sort of like enforced upgrade to your application, right? But anything would continue to walk out of the box with the same liquidity it has worked with. Priority dera, Genesis.
00:31:14.306 - 00:31:32.380, Speaker A: You do need to expect your users to connect at some point within the next three months so that they update your account. So maybe it's a good idea to either have a pop up telling them about it, or keeping their email, something like that, and just telling them it's an offer platform. We expect you to connect every so often to check that you need to do something.
00:31:32.750 - 00:31:46.980, Speaker B: Yeah, exactly. I think that from this point I'll move the mic to Tom, which is a colleague from the product team, and he knows at least as much as I do.
00:31:47.350 - 00:31:49.940, Speaker A: Hello Tom, thanks for joining us.
00:31:50.630 - 00:31:51.380, Speaker C: Hello.
00:31:52.070 - 00:31:57.046, Speaker A: So are you leaving or are you sticking around? Tom, if you can connect on Discord, it's awesome.
00:31:57.148 - 00:32:01.302, Speaker B: Please, unfortunately I need to leave.
00:32:01.436 - 00:32:06.358, Speaker A: All right, well, thank you a lot for your time, Mohad. Have a good day and thank you for explaining everything.
00:32:06.524 - 00:32:07.014, Speaker C: Thank you.
00:32:07.052 - 00:32:07.910, Speaker B: Bye bye.
00:32:08.810 - 00:32:50.280, Speaker A: So Tom, I will connect in Discord in a second and I can see somebody raising their hand on Discord, but I'm not sure who this is. So once again, let's do a small commercial break. While we're waiting for Tom to connect on the discord, if you have questions, please ask them. You can ask them on YouTube in the comments to the video, or you can ask them on discord in the community calls channel. And you can ask these questions right now, or you can ask them later on. We're happy to answer them. You can send them to us on Twitter on Slack, whichever channel of communication works for you.
00:32:50.280 - 00:32:59.450, Speaker A: We'd be happy to talk with you. Tom. Are you able to connect on Discord?
00:33:03.470 - 00:33:16.720, Speaker C: Yes, I'm trying. Just a second. Sure gave me a really hard capture. I need to tag all the hummingbirds. Okay. Apparently I made it. Okay, nice.
00:33:17.330 - 00:34:02.814, Speaker A: Wonderful. Just a second. So while you're connecting, just to give you a summary of what we discussed, essentially we discussed the need for Regenesis. Where did it stem from and why it was needed. We underlined the thing, which is quite fun, that we usually think of Cairo one as an upgrade for developer is of use, when actually developer is of use is just nice to have for Cairo one. The main objective of Cairo one is to have always provable smart transactions so that the network can be censorship resistant essentially, and resistant to DOS attack. And what's the plan to phase out Cairo v.
00:34:02.814 - 00:34:50.750, Speaker A: Zero code? Ohad mentioned the timeline, which is that Cairo one, the syntax and how it's used should be available by the end of year. And around the beginning of next year we should have the ability to develop to deploy Cairo one code on testnet, then Mainet. At this point we're going to get Cairo one and Cairo cohabitating and eventually the code will move to exclusively Cairo one thanks to this brand new Cisco, which will appear a bit later on. We're not sure exactly when. There was a debate whether this Cisco will stay. Do you think it will stay after the transition period?
00:34:51.810 - 00:34:52.906, Speaker C: No, it won't.
00:34:53.018 - 00:34:58.240, Speaker A: Yeah, it sounds like a big security assumption if it were to stay, right?
00:34:59.650 - 00:35:09.140, Speaker C: I mean, it's not a different security assumption than just using the upgrade mechanism with the proxy pattern, right?
00:35:10.790 - 00:35:12.020, Speaker A: No, you're right.
00:35:12.790 - 00:35:40.880, Speaker C: If you read the code, you know exactly if the contract can use it or not. But it's just a bit hacky. Right. So you have a way to attach an address to a contract and this Cisco breaks it a little bit. We think it is worth it because it makes the transition much better. But in the long run we don't see a reason for it to be.
00:35:41.330 - 00:35:49.550, Speaker A: And so if we deactivate it, does this mean that all the proxy contract written in Cairo 1.0 will contain a syscol that is not usable.
00:35:52.530 - 00:35:54.270, Speaker C: They can always upgrade.
00:35:55.350 - 00:36:01.810, Speaker A: They can retire that before the call is phased out, I imagine.
00:36:02.790 - 00:36:14.678, Speaker C: No, even before, when you upgrade your implementation, you will upgrade to an implementation that does not include the syscall. Yeah, does that make sense?
00:36:14.844 - 00:36:29.820, Speaker A: Sure. But what I mean is the first step will be to upgrade to a Cairo one code that will contain this implementation. So once you're done, should you again update so that you remove this fiscal or will it still work?
00:36:30.350 - 00:36:35.630, Speaker C: It's up to you. It will be a fiscal which if you will fail.
00:36:36.050 - 00:37:08.940, Speaker A: Okay, understood. Cool. So this is the timeline we have roughly, right. So beginning of next year, you'll be able to deploy Carol one code, and then you'll be able to test it, play with it. What's next and what do you think is the, this is the overall goal. What are in between versions? Which version should we expect, on which timeline, implementing which features? And once this is done, what else should we expect? Or in between?
00:37:09.870 - 00:37:51.320, Speaker C: Yeah, great question. So I think that currently the main, I mean, I know it by myself and I also hear it a lot. The main issue we want to improve and solve is the performance issue of Starknet. And on one hand, it's quite frustrating that it is in this situation for some time now, but on the other hand, I'm happy that this is the most burning issue, because at least from my perspective, this is also the biggest advantage of validity roll ups on any other solution. Right. And why is that.
00:37:53.050 - 00:37:53.558, Speaker A: So?
00:37:53.644 - 00:38:18.330, Speaker C: Because validity roll up generate proofs to the state transition of the network. Full nodes never need to actually execute the transactions. Right. They only need to verify the proofs. And what this allows us, it allows us basically to decouple between the sequencer and the full node and to constantly keep upgrading and improving the sequencers while still allowing anyone to be a full node and participate in the network.
00:38:18.410 - 00:38:19.040, Speaker B: Right?
00:38:19.490 - 00:38:43.000, Speaker C: So even though currently we are far from where we want to be, the constraints on how I can continue to improve and evolve the sequencer are very small. And basically this is what I will describe now, but we have like a very concrete roadmap on how we want to improve it.
00:38:45.130 - 00:39:06.910, Speaker A: We're much less constrained than in a general purpose blockchain network, where you're limited by the side of the smallest node in the network, you're okay, you want to accommodate, right, which is for bitcoin or raspberry PI, or for ethereum end user laptop. Here we can think about way more. So the question is, how do we scale the sequencer?
00:39:07.250 - 00:39:23.934, Speaker C: Exactly. So for example, the first example is, let's say I want to add parallelization right? Now, parallelization scales, I wouldn't say linearly, but in some cases almost linearly, with the number of cores that you can have in your machine.
00:39:24.062 - 00:39:25.750, Speaker A: What do you mean parallelization?
00:39:26.890 - 00:40:18.902, Speaker C: Okay, so when I want to construct a block, I have a mempool with transactions, and I want to construct a block and then execute it. So the way, for example, Ethereum works today, or Starknet works today, is that I assemble a list of transactions and then I execute them sequentially. I first execute the first transaction. After the execution is done, I move to the next transaction, et cetera, et cetera. Now, most of the transactions are not really dependent, right? So let's say you send a transaction that want to mint an NFT, and I've sent a transaction that want to transfer some USDC to my brother. So those transactions does not touch the same state and they can actually be executed in parallel because it doesn't matter.
00:40:18.956 - 00:40:23.574, Speaker A: If one is executed before the other, right? The order doesn't really matter.
00:40:23.772 - 00:40:38.010, Speaker C: Exactly. And specifically how we define it is that in my execution, I don't read any storage cells that you write to, right? So you don't change any storage cell that I'm using during my execution.
00:40:39.150 - 00:40:39.754, Speaker A: Yeah.
00:40:39.872 - 00:40:46.960, Speaker C: So if I have two processes, I can just run those two transactions in parallel and basically not wait for one of them to finish.
00:40:47.650 - 00:41:04.910, Speaker A: Okay, so if one thread can, let's say, process 100 transactions a second, and you have 200 transactions that are totally independent, you can run two threads, two cores, and you've executed 200 transactions in a second, is that it?
00:41:05.080 - 00:41:44.830, Speaker C: Exactly. And the nice thing about is that the bigger machine you're giving the sequencer, the bigger the advantage you're getting because you just have more processes. Now there is a limit, of course, and it depends on the throughput. But again, this is something that if I was confined to, I don't know, the laptop that I have here, which has, I don't know, eight cores or four cores, I was not able to require it from the network. But since we are not bounded to it, then we can just have a very big machine and have a great increase.
00:41:47.030 - 00:42:03.990, Speaker A: There's a question Masik is asking, what about fee accounting? And I'm guessing his question is, what if I have two transactions in two threads and I'm paying for the fees with a single address and I only have enough to pay for one transaction?
00:42:06.410 - 00:42:50.358, Speaker C: Okay, so there are two things we need to take into account here. So the first fee Storage cell that all the transactions are touching is the sequencer fee. Right. Which every transaction pays to it. So this is quite, let's say, an edge case that we just need to add an exception and we don't take this into account as for the fee of the user that it is paying. So this indeed won't be allowed to be in parallel, because again, it touches the same storage cell. And indeed, transactions that originate from the.
00:42:50.364 - 00:43:01.130, Speaker A: Same user, they end up in the same user account. So. Okay, I see what you mean. Essentially, you and I can parallelize. I can't parallelize various of my transactions from the same wallet.
00:43:01.710 - 00:43:04.134, Speaker C: Exactly. You should use multicolored.
00:43:04.262 - 00:43:04.940, Speaker A: Okay.
00:43:07.950 - 00:43:43.910, Speaker C: So this is the first thing, and this is actually now working internally. Hopefully this week we'll be able to run it on like, I don't know, a couple days of garly blocks to see what are the improvements and if there are things that needs to be improved. And hopefully somewhere in October we'll be able to also release it as a new version, which will be zero point 10.2.
00:43:44.060 - 00:43:51.946, Speaker A: So you're going to test it on Gurley in parallel. So you're going to shadow it, is that it? To measure how impactful it is and.
00:43:51.968 - 00:43:53.660, Speaker C: Also that we get the same state.
00:43:54.030 - 00:43:55.466, Speaker A: Cool. Yeah.
00:43:55.648 - 00:43:56.700, Speaker C: Which is important.
00:43:57.470 - 00:44:11.040, Speaker A: That's a good point. I'm guessing you're not going to get the same state though, because if people use timestamps or something like that, there might be small differences. I mean, the blocks won't necessarily be finalized at the same time.
00:44:12.370 - 00:44:24.670, Speaker C: Let's say you have the same block context of each block, right? And I just take the block and run it. With this parallelization, I should get the same. I mean, the execution is exactly the same.
00:44:24.840 - 00:44:37.420, Speaker A: Okay, cool. Essentially what Masik is saying in the comments, can we test it on historic workloads? What you mean is in parallel. Not necessarily historics, but parallel. Cool.
00:44:38.350 - 00:44:40.298, Speaker C: By the way, where can I see the questions?
00:44:40.464 - 00:44:43.530, Speaker A: They're on YouTube, these ones. They're on YouTube.
00:44:45.310 - 00:44:50.750, Speaker C: YouTube. Nice. Okay. In the chat.
00:44:53.010 - 00:44:59.818, Speaker A: That'S for increasing the throughput of the network. Then somebody is asking, I don't know if you want to add something on that topic.
00:44:59.994 - 00:46:03.220, Speaker C: Yeah. So another thing that we are already in the process of doing, and it will be rolled out in few steps in the upcoming month, is basically replacing the whole infrastructure with a rust based performant infrastructure. Because as you remember or not remember, but Starknet Alpha was built upon the infrastructure of Starkx, which was written in Python and generally was not built with only performance in mind. Right. So now that the requirements are getting bigger and bigger. We need to transition out of this infrastructure and basically rewrite everything when we have this in mind. So the first thing that hopefully will be incorporated soon is the implementation of lambda class.
00:46:03.220 - 00:46:10.598, Speaker C: So they implemented the Cairo VM in rust, and we see huge gains there.
00:46:10.684 - 00:46:25.450, Speaker A: Yeah, if I may, there are huge gains here on two fronts. I mean, one is speed of the network, which we all agree is great. The second one is that this is a core component of the system that was developed by somebody else in Starkware.
00:46:26.750 - 00:46:27.660, Speaker C: To me.
00:46:29.790 - 00:46:37.390, Speaker A: It'S almost as exciting as the upgrade itself. I mean, from a long term perspective, I think this is extremely encouraging.
00:46:37.890 - 00:46:59.846, Speaker C: Yes, I agree. And after they will write the adapter to allow using it in the current Python kind of execution environment, I think there will be more nice surprise and projects from them.
00:47:00.028 - 00:47:01.000, Speaker A: Very nice.
00:47:03.370 - 00:47:48.350, Speaker C: Then the second part is actually the block creation and the execution itself. So even the parallelization that I described right now is implemented in Python. So actually in the room here behind this wall, the project is just now starting, and hopefully some first milestone will be ready in a few months and later, the last part is basically just taking everything out and having it as a single component that anyone can run. And this is also like a step towards the ability to per everyone to be a sequencer. So this is currently the roadmap.
00:47:48.430 - 00:47:57.900, Speaker A: Do we have a rough estimate on sequencer anyone can run? I. I.
00:48:00.270 - 00:48:01.018, Speaker C: Don'T know.
00:48:01.104 - 00:48:01.980, Speaker B: I think that.
00:48:05.710 - 00:48:10.602, Speaker A: Is 2023 reasonable? Yes. Cool.
00:48:10.656 - 00:48:11.500, Speaker C: Of course.
00:48:13.550 - 00:48:42.198, Speaker A: Very nice. So at worst, sometime next year we'll get decentralized. At least sequencer anyone can run, and decentralization should come with it, but at least we'll have that. There's a question, so pancash is asking, when will speed increase on Mainet? I'm guessing that. So there's two things. There's throughput and there's speed of blocks, which are two different things. They're a bit related, but not really.
00:48:42.198 - 00:48:50.810, Speaker A: Right now there's a block every 30 minutes on main net. Can you explain a bit the choice to have this and what prevents us from having blocks more regularly?
00:48:54.110 - 00:49:23.650, Speaker C: Yes, of course. So there's actually a hot debate on it currently internally. So I don't know, maybe my answer will change. And I think it's like a chicken and an egg problem that we maybe need to solve somehow. But as long as you don't have a lot of throughput on Mainnet and you have a very frequent blocks, then there's actually like a constant cost per block that you need to somehow subsidize. If you don't have enough transactions.
00:49:25.350 - 00:49:25.666, Speaker A: That.
00:49:25.688 - 00:49:26.978, Speaker C: Are included in it, is it a.
00:49:26.984 - 00:49:29.010, Speaker A: Cost for proving or for verifying?
00:49:30.230 - 00:49:53.582, Speaker C: So for proving, it's actually not for proving and not for verifying. But when you do the state update, you call the starknet core contract and call the state update. Then there is some constant cost, which is not a lot. But if I want to have, I don't know, a block every 15 seconds, then it gets to a point where it's a lot.
00:49:53.716 - 00:49:55.438, Speaker A: Okay, I see what you mean.
00:49:55.604 - 00:50:25.880, Speaker C: Now, there are many ways to solve it, but it just needs to go on the roadmap, right? I can have the state update be not per block, but per proof, right? I can batch the state updates together and also just do one call. So there are ways to solve it. But I think now it's become more problem for applications and users and maybe we will address it.
00:50:26.590 - 00:50:35.500, Speaker A: Okay, but it's a direction we're looking at for now. For now, as usage will pick up, there will be more frequent block time.
00:50:36.270 - 00:51:16.070, Speaker C: Yes. And the second problem, which again now with the version that was released today, will be solved, is that there was some part of the protocol that we subsidized right up until zero point ten l one messages were not, you were not paying for or account deployments were not paid for. In order to somehow scope the amount of subsidy, we limited the number of blocks. But again, this now will be solved. So many of the limitations can be lifted.
00:51:18.190 - 00:51:50.980, Speaker A: Perfect, thank you. I see a question on discord about transaction parallelization. Is there any transaction ordering in place or is it kind of random? So I'm going to answer for like, at least for now. In a single thread environment, transactions are just ordered by the sequencer as he receives them. So it's kind of random, but not really. It's like as they arrive, they're organized by the sequencer, right? We can't hear you.
00:51:52.390 - 00:52:18.502, Speaker C: Yes, you are correct. Currently it's Fifo. And really one big feature which is missing, and I don't want to commit, but we aim to have it probably in the version which will be in the middle of the transition period, is to add the fee market to starknet.
00:52:18.646 - 00:52:18.954, Speaker A: Right.
00:52:18.992 - 00:52:36.260, Speaker C: So right now, if you want to pay more, for example, for a transaction and to get it before or something like that, there's no mechanism for that. And this is something which is missing and that we already in the works.
00:52:37.830 - 00:53:01.942, Speaker A: Okay, perfect. Thank you. If there are any other questions, feel free to send them. I'm getting the sense that millenn wants to run something but that there is slow mode activated. I'm just going to deactivate it for a while so that if people want to ask questions, they can. Okay, cool. This is really exciting.
00:53:01.942 - 00:53:10.750, Speaker A: So changing the engine with the rust VM and then transaction parallelization should get a nice throughput bump.
00:53:11.890 - 00:53:22.350, Speaker C: Yes. This, together with Cairo one remains our main focus until we will see a major improvement.
00:53:23.510 - 00:53:25.860, Speaker A: Okay, cool. What's major?
00:53:27.990 - 00:53:47.114, Speaker C: So at least we want to reach a point where the throughput is ten x of ethereum. Right. I don't think this is the end goal, but this is, I think, something that is very meaningful and will allow major activity to happen.
00:53:47.232 - 00:53:49.580, Speaker A: And is there a goal in terms of block time?
00:53:51.230 - 00:53:51.546, Speaker B: Yeah.
00:53:51.568 - 00:53:54.330, Speaker C: So the end block time will be sub 15 seconds.
00:53:54.830 - 00:53:55.580, Speaker A: Right.
00:54:00.050 - 00:54:09.358, Speaker C: Again, there are ways to solve the problem that I mentioned now that we don't have this limitation, so maybe we'll just do it.
00:54:09.524 - 00:54:10.046, Speaker A: Okay.
00:54:10.148 - 00:54:11.840, Speaker C: And reduce the times.
00:54:12.310 - 00:54:25.060, Speaker A: Perfect. All right, look, we're reaching the 1 hour mark. I think there are no more questions. Is there anything you think we forgot and you want to add, Tom?
00:54:29.510 - 00:54:36.870, Speaker C: There's starting to see in Lisbon. Yeah, but maybe there are no more tickets, so I'm not sure if it's good that I'm mentioning it.
00:54:36.940 - 00:54:54.266, Speaker A: I'm sure there will be really cool events around then, so it's worth checking. Yeah. For upcoming community events. You're right. We have Starknet CC in Lisbon at the end of this month. There are a bunch of meetups around the world, and if you want to organize your own, you should ask us. We'd be happy to help you do it.
00:54:54.266 - 00:55:13.140, Speaker A: And we will also be present. I mean, me at least, and probably somebody else on the team will be present in India at the beginning of the month of December. So if you're from India, please say hi. We'd be happy to meet. All right, let's wrap it up.
00:55:14.390 - 00:55:16.094, Speaker C: Yeah. Thanks. It was a pleasure.
00:55:16.222 - 00:55:24.560, Speaker A: Fantastic. Thank you, Tom. I'm going to stop YouTube. Cheers, YouTube. And I'm going to say bye bye to.
