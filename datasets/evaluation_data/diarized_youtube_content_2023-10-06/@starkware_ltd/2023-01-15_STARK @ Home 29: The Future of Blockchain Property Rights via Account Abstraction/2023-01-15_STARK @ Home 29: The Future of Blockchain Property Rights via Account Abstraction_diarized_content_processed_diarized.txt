00:00:02.580 - 00:00:03.130, Speaker A: You.
00:00:06.140 - 00:00:06.840, Speaker B: Okay?
00:00:06.990 - 00:00:30.288, Speaker C: Good morning, good afternoon. Good evening to everyone joining us. I start with my typical first question. Can you hear us? So if you can use the chat just to say something, if you can hear us, please let us know to make sure that we're not speaking just into the ether. Let. Okay. Can you hear us? Okay.
00:00:30.374 - 00:00:31.840, Speaker D: Thank you, momo.
00:00:32.580 - 00:01:19.730, Speaker C: So welcome to another Stark at Home episode. By now, I don't remember which number it is already. We've been going at it quite a while. I'm very excited to have three account abstraction experts here, and you may see that there are four people. So one is not an account abstraction person, and that is me. So I'm going to try and be silent for most of the time and hand it over to the bigger experts. Stark at home is a webinar intended to talk about very deep things related to Starks and more generally to things built with Starks, things like Starknet in this case, but to talk about very deep things in an informal and casual way.
00:01:19.730 - 00:02:23.216, Speaker C: If you have questions, please use the ask a question button that you see at the bottom and not the chat because it's very hard to follow the chat. And let's get to it. So today I am joined, as I said, by three big experts on account abstraction. Yoav Weiss, who is a security researcher at the Ethereum foundation and co author of ERC four three, seven, which is going to play a very important role in our discussions today. Julianne Nissette, co founder of Argent, pardon my french, and Tom Brand, who is the Starknet product lead at Starquare. And without further ado, I'm going to basically hand it over to Tom. I will say that if you're going to be interested about what you hear today, please consider registering and joining to the in person event that is Starkware sessions.
00:02:23.216 - 00:02:40.490, Speaker C: I'll add it to the call to action button because you will see there a lot more and hear a lot more from the folks here about account obstruction and other cool topics related to Starks. So Tom, please take it over.
00:02:42.380 - 00:03:14.244, Speaker A: Thank you. Ellie, can you hear me as well? And thanks for the comment on the beard. It is mostly due to my lack of time of removing it, but maybe I'll, I don't know, consider keeping it. Yeah, thank Yannick. Ok, great. So, yeah, again, thank you for joining us here. We want to just walk through account obstruction and discuss, I don't know, various topics of it.
00:03:14.244 - 00:03:59.410, Speaker A: So we'll start with basically what existed or what exists before account obstruction, what is account abstraction, and why it might have some benefits then we'll discuss basically some concrete examples of account abstraction implementation on Starknet, which is based on the ERC four, three seven that we have, you have, which is the co author of it. And lastly, we will try to think about the future and what proves, or in general what can be the future of account obstruction. So let's start, and maybe, Julian, you want to start by explaining what is currently available on Ethereum or what was the state of accounts before account.
00:04:01.960 - 00:04:58.448, Speaker B: Mean? As most people know, on Ethereum natively, the account that users can interact with are called eoa, externally owned accounts, and they are special in the sense that with an eoa, everything is outcoded. So when the user makes a transaction, you know exactly how the transaction will be validated. All this is outcoded in DVM. So you need to sign with the key and you use ECDSA using a specific elliptic curve and so on. And once that verification process is done, then the transaction will be executed. And so Ethereum started with this model, which is great because it's simple, but the main issue is that everything is hard coded. And if you think of it, the key that you used to sign, because everything is hard coded, the key that you used to sign is directly coupled to the account on chain, which holds the token.
00:04:58.448 - 00:05:46.980, Speaker B: Why? Because the address of the account is derived from the public key of that key pair, and only the private key can authorize transaction from a given account. And what that means is that there's a strong link, a strong coupling between this key that a user has and the account on chain. And because of that, it means that if you lose that key, you basically lose the account. If I have your key, I have your account. And because of this strong link, we've seen all the issues we have and the difficulty there is with managing keys and self custody on Ethereum. So I think it's a very simple model, but the problem is that it's a model that's difficult to implement for non techie users. I mean, even for us, we are all stressed about losing our keys.
00:05:46.980 - 00:06:11.310, Speaker B: And so this has, I think, plagued Ethereum from the beginning. And my fear is that if we want to scale Ethereum and bring Ethereum to a more mainstream audience, we need to find a way to scale this user experience of self custody. And we believe that true account abstraction is actually the only way to make that happen.
00:06:12.960 - 00:06:23.708, Speaker A: Great. But you in argent did something different than just using the EOA. Right? So what was the second option? Know, managing accounts on Ethereum.
00:06:23.804 - 00:07:01.020, Speaker B: Yeah. So when we started, Arjun we really recognized that difficulty and we wanted to really crack that. We really believed that we could make a mainstream experience, even on Ethereum. And so we needed to find a way to really scale this experience of self custody, because again, we think self custody is essential for what we are building. And so I mentioned that there's this EOA account, but actually on Ethereum, there's a second type of account called contract, or smart contracts. And these accounts, they're different from eoas in two ways. One is that they can contain logic, which is really great, but they cannot initiate transaction.
00:07:01.020 - 00:07:51.340, Speaker B: So that's why when you want to initiate a transaction, you always need to start with a new way. So what we did at Argent is we really wanted to abstract the concept of an account, but for that, we used the existing tools, and so we used the smart contract. And so that means at Argent, we really started making the user account a smart contract, so that we could put all the logic that is needed for this management of self custody. And that's really great. But the problem is that this is not a native top level account. On Ethereum, you still need to trigger transaction with the NEOA. And so that means that to use smart contract wallets today on Ethereum, you still need quite a lot of infrastructure, because you use a technical metatransaction, which means you need to have relayers that will prepay for the execution of transactions and so on and so on.
00:07:51.340 - 00:08:33.732, Speaker B: But from a user's point of view, actually, it solves all the issues that you can have with EOS. And so I think that's why people have loved argent from the beginning, because it's really unable to bring that user experience that user expects. But as we will probably discuss more, the problem is that we are building that on a protocol that's not really meant for that. And we still need to have all that complexity because the protocol was designed for eras. But to my understanding, I mean, smart contract wallet is a form of account abstraction. It's the first form of account abstraction. Then you can go further and make that even better and easier.
00:08:33.732 - 00:08:55.200, Speaker B: But I do see smart contract wallet as some form of account abstraction. So you can say that account abstraction has existed on Ethereum for the past four or five years, since people started doing smart contract wallets. But of course, as we discussed, this is not the end goal, and it's probably not a satisfactory solution. And so we need to go one or two steps further.
00:08:55.700 - 00:09:45.120, Speaker A: Okay, amazing. So the basic account on Ethereum is an externally owned account, which means just an address which is controlled by some private key which derived the address. And because the need for more complicated account logic, I don't know, was there. You basically used the current infrastructure to create this abstraction, but still you had to go through the EOA account to initiate the transactions. Okay, amazing. And if we want to talk about trying to define account abstraction, maybe, I don't know. Johav, do you want to try and define what it means? Yeah.
00:09:45.190 - 00:10:11.930, Speaker D: So in general, account obstruction means obstructing all the aspects of the account. It's not any particular. I think we're going to discuss some use cases later. But account obstruction is not about any of the specific use cases. It's about being able to replace every aspect of the account with code, meaning you can abstract the signature type.
00:10:14.300 - 00:10:14.664, Speaker C: You.
00:10:14.702 - 00:11:37.670, Speaker D: Abstract the signature type so that you can support different kinds of authentication and authorization methods, such as multisig social recovery using quantum resistance signatures, or the signature types that are used on mobile devices, secure enclaves, so you can sign with your fingerprint or your face id. So this abstract the signature and then it also needs to obstruct replay protection. So instead of having a linear nonce where the order always matters, you can implement more complex replay protections that will still protect the account from replay, but without enforcing order where it's not necessary. One of the important things is to obstruct the gas payment so that you don't need to keep an eoa or to use a centralized relay. But also it's not necessarily the account paying for the gas and not necessarily paying it with ether. So you could have Dapps sponsoring their users, similar to the way that web two companies pay for traffic to onboard their users. Or you could have the users pay with a token instead.
00:11:37.670 - 00:12:45.816, Speaker D: We want this completely abstracted so that the gas payment is also implemented by code and can implement any business logic that makes sense in each case. And we've seen some interesting cases such as wallets sponsoring their paying users, which is great for users who are not users, who don't come from crypto and they don't own ether, and they want to start to get started with something. So if the user can pay, fiat can pay with a credit card to the wallet developer and then the wallet developer sponsors the transactions. It's another form of abstracting gas. The idea is to abstract everything and we want it to be a first class citizen, meaning that you don't need to have an eoa in addition to that, and it can be used just like any other normal account. And it also means that it shouldn't be easy to censor. It should be as censorship resistant as any account.
00:12:45.816 - 00:12:54.700, Speaker D: So it needs to have a decentralized mempool. And these are all challenges that we need to solve in order to get to a full account obstruction.
00:12:55.360 - 00:13:19.952, Speaker A: Right. So we'll get to challenges in a moment. Let's try to understand why it's good. But basically you're saying account obstruction is replacing the hard coded account structure that is defined in the protocol with code. And you abstracted and you splitted it into three levels, which was very nice. Right. The first is the validation abstraction.
00:13:19.952 - 00:13:38.984, Speaker A: The second one is the replay protection abstraction. And the third one is the fee payment abstraction. Three categories that you can think of how we abstract stuff and it will be actually relevant when we talk about Starknet and what is the status today. Right.
00:13:39.182 - 00:13:43.416, Speaker B: Actually, Tom, I would add the fourth category, which is the execution of the transaction.
00:13:43.528 - 00:13:47.356, Speaker A: Right. I wanted to say, yeah, this is.
00:13:47.378 - 00:13:50.028, Speaker D: Where you implement features like batching, for example.
00:13:50.114 - 00:13:53.312, Speaker B: Exactly. Multicolored and stuff like that. So I think it's important as well.
00:13:53.446 - 00:14:41.810, Speaker A: Right, okay, great. So we're starting to dive into why we need account obstruction, but maybe we'll talk about it in a minute. But when we first thought about Starknet, we started with Starknet alpha, right? So we were like designing the system as we go. And at some point we reached the point where we had to decide what will be the account structure on Starknet. Right? And then there were a few options, and actually the most obvious one was, okay, let's just go with the EOA like Ethereum did. But we also saw at that time that optimism decided to go with some form of account obstruction. So we also started to think about that and we also had also other few options.
00:14:41.810 - 00:16:06.110, Speaker A: And when we ask ourselves internally, why do we need account abstraction or what is the biggest motivation to do something like that? So to me, as a protocol designer of Starknet, the biggest answer, or the answer was basically I want to give the developers as much freedom as possible to do crazy stuff with accounts. I'm sure that even if I'll try to, I don't know, come up with whatever I think is the correct account structure or correct account usage, or probably some types, what account obstruction gives the developers is the ability to come up with their own logic and we'll discuss it at the end. But who knows where will this be in five years from now, right? So from my point of view, this was the motivation to add account obstruction, or to start, or to start and try to add account obstruction because it has its own difficulties, which we'll discuss in a minute. But Julian, I would like to hear from your point of view, like everything you're thinking about, or I wouldn't say everything, but most of what you're thinking about is how I can make the interaction of users with the blockchain like the best experience that they can have. So what, account abstraction in that sense? I think you have already mentioned a few stuff, but I would like to also hear from you.
00:16:06.720 - 00:17:19.280, Speaker B: I think it's interesting because from your point of view, because you're building a protocol, a blockchain, you want to give freedom to developers. For us, we want to build a wallet for users, and for us, the main motivation is actually to kind of save self custody. That's kind of a bold statement, but I really do believe that if the technology is too complicated, people are naturally, I would not say lazy, but we go for the simplest solution. And I think the next wave of users that will come to the blockchain might not care as much about self custody as we care today, or as even people cared before us. And so if you give us them two alternative one, which is extremely complicated when they have a high probability to lose everything, and then you give them a simple one, meaning a centralized exchange, people will naturally go to the simple solution. So I do believe that us as an ecosystem, and that's why we started argent, and that's what motivates us about solving that problem. In account abstraction is really, can we build a user experience with self custody, with self custody baked in it, that is as good or even better than what a centralized exchange can do.
00:17:19.280 - 00:17:51.452, Speaker B: And so for us, that's the real motivation. And so when we started looking at that, at Argent, we started identifying all the friction points. And I think basically you have mentioned a lot of them. I think the first one is seed phrase. So it's related to the signature verification today on Ethereum, because you need to protect your key at all costs. We tell you to write that on a piece of paper. And I mean, if you take a step back, this is completely insane, right? I mean, we've tried to convince people on the Internet to not write their password on a postit or a piece of paper, and we're building an Internet of value.
00:17:51.452 - 00:18:16.032, Speaker B: And you ask to write that same password on a piece of paper, but not one time, but four or five times in case your house burned down. This is completely silly. So our first motivation was, can we get rid of seed phrase? And that's one thing. And so to achieve that, we came up. I wouldn't say we came up. I think it's a bunch of ideas that were around. We kind of collected them together, but with something that is now called social recovery.
00:18:16.032 - 00:19:16.376, Speaker B: And the idea of social recovery is, again, because your account is a smart contract, it's abstracted. You have a signer, a controller, but actually that controller can be replaced or can be exchanged under a certain condition that you can program. And so us, for example, we wanted to replicate the experience that you have with a credit card, with your bank. If you lose your credit card, what do you do? You call your bank and you say, hey, can you block that one and send me a new one? And so we wanted to replicate that flow, that mental model, but purely on chain using smart contract logic. And so social recovery, it's actually a way to do that, except you choose who act as your bank instead of identify yourself to a centralized party. You decide who can prove that you are you and reset your account with a new controller, new owner. And so it can be one person, it can be a majority, three out of n n out of m, two out of three, you can pick and choose.
00:19:16.376 - 00:19:41.008, Speaker B: And so the first friction point that we wanted to remove is really seed phrase. And we achieved that through what people call social recovery. Another thing that we wanted to achieve is abstracting gas. Again, something that you have mentioned. And so for those who've been using argent for a long time, they might remember that we used to actually sponsor transaction on argent. Everything was free. That was amazing.
00:19:41.008 - 00:20:31.088, Speaker B: With gas, when transaction fees were at a few cents, of course it turned out to be not that a good idea when gas went crazy, and so we had to roll back to that. But I still feel that that's part of a good experience. People, again, if it's free to do something on a centralized exchange, and you need to pay fifty cents or a euro to do that same thing with self custody, people will start using the centralized solution. So again, part of that experience which needs to be as good with self custody we need to have cheap transactions. So either the technology enables that through scaling, or we find a way to subsidize transaction. So the second thing we wanted to solve is really all that concept around gas transaction fees, which is very complicated. And again, account abstractions enables you to solve that.
00:20:31.088 - 00:21:17.608, Speaker B: And then the third thing is on blockchain, it's very easy to make mistake, it's very easy to make a typo when you copy an address. It's very easy to interact with the wrong website and so on. And so again, using account abstraction, you can enable some form of fraud monitoring with two FA confirmation, for example. So these are the kind of things that we've been building an argent on Ethereum and that we are now replicating on Stacknet. But of course you can go much further, you can be much more creative. Something that we actually did on Ethereum four years ago was the idea of DAP keys. Letting a Dap create a key with certain permission so that you can interact with that DAP without having to sign with your wallet.
00:21:17.608 - 00:21:37.728, Speaker B: And so we kind of refresh that id and rename it session keys. But again, this is something that we are working on, on Starknet and that's a great way. For example, for onchain gaming, all these use case, I can list you four or five other ones. They are all enabled by account abstraction.
00:21:37.824 - 00:21:37.988, Speaker A: But.
00:21:37.994 - 00:21:58.380, Speaker B: So, to answer your original question, for me, a great user experience is an experience where you don't need to know you are using a blockchain. You come for an application and actually you interact with that application, you do stuff without really having to know that you are using a blockchain, but still you are doing that with self custody. And I think the only way to do that is through account abstraction.
00:22:00.400 - 00:22:05.630, Speaker A: Okay, amazing. Seems like you're thinking about it. I don't know, for the past few years.
00:22:06.160 - 00:22:08.850, Speaker B: 2017, we started. So it's been a while.
00:22:09.380 - 00:22:36.890, Speaker A: Yeah, amazing. Okay, so actually there is a good question here, and someone is asking, can you explain Starknet in one sentence? So, yeah, maybe. I assume that everyone knows what Starknet is, but this is still not the case. So before we continue with the discussion, I will just very briefly explain what Starknet is for all of you who don't know. Ellie is back.
00:22:37.580 - 00:22:41.032, Speaker C: I want to hear your explanation, but then maybe I'll offer another one.
00:22:41.166 - 00:23:20.096, Speaker A: Okay, so what is Starknet? Starknet is a system that we've been building in Starkmore and together with the ecosystem for the past, almost two years now. And it's basically a permissionless and decentralized validity rollup. What is validity rollup? Validity rollup is basically a method for scaling Ethereum or for scaling blockchains in general using the power of proofs of validity proofs. Yeah. He wants to know what Starknet is exactly. Yes. So this is stagnet.
00:23:20.096 - 00:23:42.750, Speaker A: And the functionality that it offers is basically the same functionality that Ethereum allows you to do. Right? You can write contracts, you can deploy them, those contracts can interact with each other, and users can, through their abstracted accounts, can interact with those contracts. So this is basically starknet. Anything to add?
00:23:44.800 - 00:24:34.648, Speaker C: Well, I'll give another complimenting answer. So, blockchains are a social technology. They solve a social problem, one of trust and consensus, and they do so by having a very inclusive system anyone can join. And that's we base our trust in numbers and then everyone verifying everything. But because of this inclusivity, blockchains are very slow as a computational system. So we want that inclusivity and that integrity and that level of trust, but we want much greater scale. What Starknet is, is it's a system that drastically increases the scale without any compromise in the security and trust level by using validity proofs, and in particular, stark proofs.
00:24:34.648 - 00:25:14.250, Speaker C: And the way it is used is that if you think of Ethereum as a very trusted but somewhat slow and expensive computer, you use that slow and expensive computer to execute a verification process for a much greater state and much greater amount of computation that is done off chain. And that off chain, from the point of view of Ethereum, is starknet. So it's basically an exponential increase in the computational scale of Ethereum with no reduction in its security via math. I hope that helps. And now I'll go back to listening in.
00:25:18.560 - 00:26:06.380, Speaker A: Okay, thank you very much. Please write us later. Which explanation was clearer? Okay, great. So let's continue. So I think we understood what was the situation before account obstruction? What is account obstruction and why we have a motivation to have it in a protocol. So, just to give short history of what was the state of account obstruction in Ethereum on Starknet? So, as I've said, when we started working on Starknet, it was almost two years ago, and we had to come up with what should be the structure of accounts on Starknet. And we decided that account abstraction should be part of the protocol.
00:26:06.380 - 00:27:16.560, Speaker A: And initially, what we did is we just said, there will be no rules at all. Right? Every smart contract, or there are only smart contracts in the protocol, and every smart contract can initiate a transaction. The only thing we will verify is that this smart contract paid some amount of fees to the protocol, and this is the only thing that we will verify. This is how it started. I think Julian, he implemented the first account on Starknet based on this structure. As thing progressed, I think something like, I don't know, nine months into, or even four months into Starknet Alpha first release, we basically started to face the problems that you have. Will elaborate in a second, but basically, when you give this amount of freedom to the contract, you have some properties in the protocol level that are not that easy to enforce.
00:27:16.560 - 00:28:18.550, Speaker A: And then we had to basically rethink our approach to account abstraction. And this is where we met ERC four, three, seven. And in some magical way, it just answered all of our problems. So I will try to explain very briefly what problems we faced, and then Joaval would be happy if you can explain a bit on your work on ERC 34337 and how it tries to solve them. So the first thing that we faced is that how can a sequencer guarantee that it's being paid? Right? So if I receive a transaction to the mempool, I want to somehow verify that I'm getting paid for the execution of this transaction. Otherwise I don't have any incentive to include it. The problem is, if I don't have the guarantee, when I start processing the transaction, I can process it for a very long time and only at the end find out that I'm not getting paid for it.
00:28:18.550 - 00:29:13.476, Speaker A: And this creates a very big problem in the protocol level, because it is very easy to attack the sequencer and to make it work for a very long time without getting paid. Right? So from the attacker perspective, this attack is free. They're not paying anything. And from the sequencer perspective, it is unbounded. They can basically try to run transactions all day long without being able to include them in the block and without being able to get paid for them. So this was the first problem. The second problem that we faced was, how do we ensure uniqueness of transactions? Basically, if we just allow any contract to behave as the account, and the contract will be in charge for enforcing whatever replay protection they want, we don't get the guarantee in the protocol level that transactions are unique.
00:29:13.476 - 00:29:48.450, Speaker A: Right. And this create a big problem from the API perspective, which we didn't want to. There might be some ways to solve it, but we decided that it doesn't worth the effort. So then we tried to see, okay, how we can still pose some structure on accounts while still giving the devs the ability or the freedom to come up with the innovative stuff. So this is where ERC 4337 comes into the picture. And yava would love to hear your point about it or your point of view about it.
00:29:49.140 - 00:29:49.890, Speaker C: Yeah.
00:29:50.660 - 00:30:41.670, Speaker D: So, as I said, the ERC four, three, seven tries to obstruct all the aspects of the account. And in doing so, it has to solve the problems. You mentioned about DoS attacks against the sequencer, among other things. First, we need to make sure that to somehow limit the amount of unpaid work caused by every single transaction. The first thing we needed to do is to separate validation from execution. Each obstructed account implements a certain validation function. This is the function that enforces the signature or any other kind of access control.
00:30:41.670 - 00:31:46.808, Speaker D: It also handles replay protection and the gas payment, unless it is abstracted and delegated to a different contract. Validation from the sequence of standpoint, this is the only part the sequencer cares about, because afterwards, if during the execution, the transaction is going to revert, it doesn't matter because the account still has to pay for the revert. But if it reverts or otherwise fails validation, then you cannot charge the account. So this amounts to unpaid work by the sequencer. So we needed to separate the logic to have an explicit separation and perform the validation before the execution. And we limited the amount of gas that can be spent during validation, so it can be a reasonable number that would be enough to perform any reasonable validation, but that it wouldn't be an unbalbed number. So you have to limit the work.
00:31:46.808 - 00:33:14.096, Speaker D: But this only solves part of the problem, because another problem is that it relies on state, it relies on on chain state, which means that a previously valid transaction could get invalidated due to a state change. Or if we allowed accessing the environment, then even based on changes that the user doesn't have to pay for, such as if you could make it depend on the block number, and then it would be valid in the current block, but invalid in the next block. And the problem is that the sequencer would have to simulate the validation, see that it's okay, and then later, when it will want to include it, it will realize that it's actually not okay anymore. Now, this could happen in any case, but we needed to limit the number of times it happens so that it cannot be used for an attack. And our guidelines were to allow validation only in a way that invalidating an operation, invalidating a transaction, will require paying an on chain fee, and it will have to be in order of n. So in order to invalidate n operations, you need to actually pay for n state changes on chain, which means that the cost for the attacker is much higher than the cost for the sequencer. And this keeps the economies in favor of the defender.
00:33:14.096 - 00:33:32.644, Speaker D: So in order to do that, we needed to limit access to anything related to environment, such as block number and time, and anything that keeps changing on chain. And this solves part of the problem. Another part is accessing shared storage.
00:33:32.772 - 00:34:21.780, Speaker A: If you could refer to me, it took like, I don't know, a month to get it. So maybe I will try to reiterate it. I don't know, I'll do a better job. But I don't know, let's just repeat it. But, but the point is, how do we make it non free for attackers, or non constant cost for attackers to dose the sequencer? Right? And by dosing, I mean making the sequencer work without getting paid. So basically, the whole limitations on what the account can do tries to achieve that. If you want to invalidate a transaction, it will cost you some price per the amount of transactions that you want to invalidate.
00:34:21.780 - 00:34:43.360, Speaker A: Right. So this is the motivation, and if we achieve that and we make the cost somehow comparable to the amount of work that the sequencer needs to put into the execution, then we're basically somehow mitigating this line of attack. Right? Is that a clear description of the motivation?
00:34:44.180 - 00:35:38.130, Speaker D: Right. Yes. So we needed to enforce a minimum set of limitations during validation to solve this problem. And it's important to know that these limitations are only during validation. After it passes validation, the transaction can do anything. There are no limits because it's already paying for it. As I said, we limited access to environment, and then we also needed to limit access to storage, to shared storage, so that you wouldn't be able to attack the system by having many accounts look at a certain storage slot, which starts as true, and, and then after you send many transactions, you only spend one change to change it to false, and now you have to invalidate all of them.
00:35:38.130 - 00:36:47.400, Speaker D: So we needed to make sure that each account can only access its own storage, whether inside the account or in other accounts, but hashed with the account address, such as token balances in different contracts. So we enforce this minimum set of rules, and this allows us to protect against DOS attacks. We also defined, in order to make it censorship resistant, we created a shared mempool. So the mempool is protected by these rules, and therefore you can have multiple bundle, multiple nodes that participate in the mempool and can send blocks, which actually, in the case of Starknet, as long as there is one sequencer that you are working with, it's less of an issue because the sequencer can defend itself. But in a network like Ethereum.
00:36:49.260 - 00:36:49.576, Speaker A: You.
00:36:49.598 - 00:37:35.290, Speaker D: Need to protect this mempool, and you need to protect each of the bundlers in this mempool against such attacks. Let's see what else. So that's it. So that's basically, that's basically what ERC four, three, seven wants to do. But we needed but one important requirement we had is that there will be no protocol changes. There were many attempts, actually, since I think the first attempt was in 2016, shortly after Ethereum was launched, there were already attempts to move it toward account obstruction. But doing it with a consensus change is really difficult.
00:37:35.290 - 00:38:25.850, Speaker D: We don't know exactly what's the right way to do account obstruction, so we ended up not doing anything. We ended up just endlessly debating it. So ERC four, three, seven is an ERC rather than a normal eap, meaning that it does not require changing the protocol. The consensus remains the same. Everything is enforced by a smart contract. There's a singleton, a smart contract called entry point, which on Starknet is part of the OS, but on other chains it gets deployed as a normal contract. This contract enforces the protocol, ensures that everything happens the right way, the validations happen separately from the execution and everything, and that the transactions get paid.
00:38:25.850 - 00:39:22.040, Speaker D: By doing that, we allow starting to innovate. Now anyone can start innovating, building new kinds of wallets and paymasters and implementing different models. And we already saw some interesting ones, and I'm sure we'll see a lot more because by enabling this mem pool and this mechanism for submitting account obstruction transactions, we let people start innovating on all the chains without having to make changes or to wait for any permission from that chain. So this was also a design constraint that we had to deal with. And in the future I do hope that we'll see enshrined account obstruction. We are discussing various ways of doing it, but it will be much easier to get there. It will be much easier to get there after we experiment with different models and know what really works and what doesn't.
00:39:22.040 - 00:40:01.670, Speaker D: But having said that, I think that on Starknet it was the right approach not to have to start like Ethereum and evolve it, because you can learn a lot from the evolution we had so far. So having account obstruction from the start, this eliminates a lot of technical debt that we have in Ethereum. Removing EOA is quite painful and it's taking a lot of time. So having a network that takes what we know so far and enshrines into the protocol, it makes perfect sense to me.
00:40:02.540 - 00:40:47.940, Speaker A: Okay, great. So this is a great point to come back to Starknet. So we tried to find a different solution to what we started. Yoav and the team wrote the amazing ERC and it just fell from heaven. So I remember reading it and saying, okay, it really solves my problem. And we had the luxury of adding, as you have said, adding this as part of the protocol and not as a separate memp pool with some smart contract that handles those bundles of transactions. And this was actually added into the protocol since I think it was four months ago.
00:40:47.940 - 00:41:19.580, Speaker A: But Julian, you can correct me if I'm wrong. Something like that. So what is the status of account obstruction today? On start, basically from the three or from the four categories that we defined initially. The execution, the validation, the replay protection, and the fiat function. We currently implemented two of the three. Right. So execution, Julian can do whatever you want in the contracts.
00:41:19.580 - 00:42:01.884, Speaker A: Validation, same thing currently. We started with a simple ethereum like nons, where we have sequential single nons for the account. But there are many suggestions and discussions in the ecosystem on how this can be improved. And I hope that sometime during this year we'll also add some kind of non generalization. And the last one is fee abstraction. And there, there's actually a good design by ERC four, three, seven. And this is called paymaster, which is basically another smart contract that can pay the fees for you.
00:42:01.884 - 00:42:46.830, Speaker A: And this basically allow many nice stuff, but specifically, for example, paying fees with other tokens or wallet subsidizing the tokens. So this is the current status of account obstruction on Starknet, and what we plan to add, I think in the coming year is a good bet. Okay, so before we move to the future and other places, does anyone have questions on what we said so far? I see when Argentmobile will support Starknet. It's a good question, but not for now, but soon. Julian can answer. Will account obstruction solve all security issues? No, I don't know what's the.
00:42:48.960 - 00:43:09.810, Speaker D: It won't solve all of them, but any security issue. I mean, security is always a trade off, but being able to write code in the account lets us get to the best trade off for each particular use case. So it can solve specific security questions as you need to encounter them much better than an EOA would.
00:43:11.060 - 00:43:20.196, Speaker A: Yes, that's a great answer you have. Okay, so I don't see anything, which.
00:43:20.218 - 00:44:07.536, Speaker D: Is, I see someone asked about. It's a specific use case, but can a next of kin be included in account abstraction? So this is actually a use case that I like because it allows us to encode certain things into an account, such as transfer of ownership in the event of the owner's death. And this has been a huge issue for EOA. Accounts get lost. If something happened to the owner, the account is lost. And if the owner gives the key to someone for safekeeping, then there is always the risk of funds getting stolen. So I see it actually as a subset of, it's a subset of a social recovery.
00:44:07.536 - 00:44:39.070, Speaker D: Suppose you have social recovery where one of the keys is one of the keys is the next game. But this key cannot be used. It's not considered valid unless there hasn't been any activity on the account for a year, for example. Now you can use the account safely, but if you don't use it for a year, then your next of kin gets access. So it's just one of the questions here. And I think it highlights yet another use case.
00:44:39.440 - 00:45:06.090, Speaker B: And by the way, I think this can be done today with something that is emerging as well, which is storage proofs. Because using a storage proof, you can show that the nonce of an account hasn't changed for a year, for example, and use that as a trigger to enable the next of kin to do the transaction. So this is something that we are working on at argent and considering, because I do feel it's a great use case. But again, everything is there.
00:45:07.100 - 00:45:27.064, Speaker A: Yeah, I'm talking to Julian almost every week, and there's always surprises, I hear, in those public talks. Okay, nice. I'm glad to hear you're working on it. Yeah. So let's continue. We talked about Ethereum. When we talk about Starknet, I'm less familiar with other places.
00:45:27.064 - 00:45:37.810, Speaker A: So maybe you guys know to say what is the state of account obstruction on other places. By the way, how much time do we have? Ellie? Only ten more minutes.
00:45:42.740 - 00:45:48.340, Speaker C: Well, usually we run a bit over.
00:45:48.410 - 00:45:49.670, Speaker D: But not a lot.
00:45:52.120 - 00:46:23.424, Speaker C: Okay, I'll tell you my trade secret. I see how many people are still tuning in and asking questions. And I can say that right now, like live, we have steady number of more than 200 people still watching and enjoying. So I would say based on that, let's go for another 15 or 20 minutes, unless if you exhausted, you want to talk, but you can go on.
00:46:23.462 - 00:46:24.656, Speaker D: Let'S say another 20 minutes.
00:46:24.758 - 00:46:35.556, Speaker C: Let me just pause to remind folks if you're enjoying the kind of topics and level of depth that you hear here. So please, there's a button, you can.
00:46:35.658 - 00:46:37.636, Speaker D: Click it, see a whole bunch of.
00:46:37.658 - 00:46:49.610, Speaker C: Other things scheduled for the in person event startware sessions in Tel Aviv February 5 and six. I hope many of you can join, so please sign up there if you want.
00:46:49.980 - 00:46:50.440, Speaker B: Yeah.
00:46:50.510 - 00:46:53.400, Speaker C: And see the gentleman.
00:46:55.200 - 00:47:02.190, Speaker A: Okay. Yes. So let's briefly discuss other places like, I don't know, four or five minutes.
00:47:03.280 - 00:47:42.552, Speaker B: Yeah, maybe I can jump on that. Because we are heavily active on the Stacknet ecosystem, but we are also working with Zksync in parallel. And Zksync V two will launch with native account abstraction, again inspired by 4337. So in a sense, I think very similar to what you guys are building at starknet, but there's still a few differences. ZK sing because they want to be vm compatible. You will still have eos. And so account abstraction is kind of co living with know pros and cons for that.
00:47:42.552 - 00:48:07.740, Speaker B: But I think that's really the main difference is that contrary to Starknet, I think you guys started from a blank page and so you can make all the choices that you want. They come with a legacy that they want to be EVM compatible for now. But anyway, they are launching with native account abstraction. You mentioned before. Optimism. Optimism. When they started, they mentioned that they were launching with account abstraction.
00:48:07.740 - 00:48:50.320, Speaker B: I think they were tackling too many things at the same time and they decided to drop that one, seeing the pressure from arbitram, which was pushing as well at that time, I think. But we've had many chats with them and that's clearly something that they are very interested in. There are people that are implementing 4337 on optimism. So again, there will be account abstraction, but at the application level using 4337. But I know the optimism team is also really interested by account abstraction at the protocol level. And so I think it's not a question of if, it's a question of when. Having talked to many layer twos, I do feel that's kind of the sentiment.
00:48:50.320 - 00:49:40.864, Speaker B: There's also in Polygon, there's different team at Polygon, but Polygon midden, for example, they are working with account of native account abstraction as well. But we've discussed with the other teams and they all would like to have it. I think the difficulty is what you have mentioned is that a lot of the layer twos, they want to be EVM compatible for now. And so they are struggling to see how to go from being EVM compatible with the new a to enabling account abstraction. That's actually part of the job we're doing at Argent, is trying to convince the ones that haven't launched to go natively with account abstraction, because I do feel it's much easier, as you have mentioned. But I also feel that's kind of the role of layer twos. We should use layer twos to experiment and then bring that knowledge back to the VM at some point.
00:49:41.062 - 00:49:51.330, Speaker A: Nice. And also, if I recall correctly, you mentioned that there was some innovation by ZK sync that you've then added to your proposal, right?
00:49:52.020 - 00:50:22.028, Speaker D: Yes. So ZK made some changes to four, three, seven. Some are specific to their system and are not relevant to everyone else. But at least one thing was at least one thing which I already mentioned in this conversation is something that we ported back from them. Initially, ERC 437 only allowed access during validation. It only allowed accessing the storage of the actual account. And this made certain things difficult.
00:50:22.028 - 00:51:12.220, Speaker D: For example, if you wanted to implement a token paymaster and transfer tokens, or check the token balance of the user in order to see if the user can pay, this was ZK. Singh added an interesting rule. Looking at ketchup, looking at the hash, looking at the hash, and then allowing access to a certain storage slot. In any contract, in third party contracts, as long as it looks like a mapping and it remains safe, because as long as you don't allow two transactions from the same account in the same block, then you are safe, then you are not going to have a collision. So we like this rule, and we backported it to the standard. So the new version supports that.
00:51:12.370 - 00:51:27.490, Speaker A: Amazing. So, basically, because the fact that they use the same structure that you introduced and then innovated on, that you could also benefit from it, and we now can also benefit from it. So, yeah, that's very nice.
00:51:27.940 - 00:51:49.880, Speaker D: Yeah. And I hope that it will converge. Ultimately, it needs to be a standard so that wallets don't need. I mean, I don't think wallet developers should have to implement the wallets differently on Starknet, on ZK sync, on Ethereum, on polygon and whatnot. So, ideally, we should converge on a standard that works for everyone. That's what we're trying to achieve.
00:51:51.660 - 00:52:45.048, Speaker A: Yes. Okay, amazing. So, yeah, now let's go to a topic that I really don't have any clue what will be the answer. But let's try to gem together. So we have account obstruction and we have ZK proofs, right? And now we can ask ourselves, okay, what can we do with the two together? So, I'll give a nice example on a protocol that uses proofs in its base layer that maybe Ellie knows a few things about it. But Zikesh is a good example to a protocol that does not have. Or it does have eoas, but those eoas are not.
00:52:45.048 - 00:53:27.876, Speaker A: Okay, maybe I will take a step backward. Zikesh is a protocol that implements the functionality of bitcoin, only that it implements it in a privacy preserving manner. Right. So when you want to transfer Zkesh between one another, nobody knows who was the sender, who was the recipient, and how much tokens has been transferred. And the way this is being achieved is through the use of validity proofs. So this is an example to a protocol that uses proofs in its account structure. Maybe you can say that in order to preserve privacy.
00:53:27.876 - 00:53:43.710, Speaker A: So I don't know what can else be achieved with the validity proofs or ZK proofs. Finally, we're saying it in the correct context. So zero knowledge, which actually gives you zero knowledge on the statement what can be done together.
00:53:45.200 - 00:54:26.104, Speaker D: Yeah. So I've already seen a couple of interesting projects starting a privacy oriented project starting on ERC four, three, seven that are using validity proofs. One being a multitenant account so that multiple users can live within the same account, they can transact as the sender of the same account. Which means that the account essentially acts as a mixer. It's a mixer, but instead of having to send your funds and getting mixed, you are always in the mixer. It's a little bit like implementing zcash inside a wallet and everyone live in the same wallet.
00:54:26.232 - 00:54:27.004, Speaker A: Nice.
00:54:27.202 - 00:55:12.090, Speaker D: Yeah. So basically the idea is that all the assets, whether it's ether or any tokens or nfts, all the assets actually are owned by the same account, by the same contract. But this contract tracks the real ownership, the more granular ownership per user, using validity proofs. So users can transact without. Users can transact and can use their assets, send them either inside the contract or even make the contract, send it elsewhere. But you don't need to know which user owns which asset and what they do. So this is one use case and someone actually started, they're working on it.
00:55:12.090 - 00:55:50.436, Speaker D: And another interesting idea that's being discussed is to create sub accounts for privacy. Let's say you have a wallet. Now it's a single tenant. It's not a multi tenant account, but you also need to create a few more accounts. For example, you want to receive an NFT. Or like a pro app, you want to receive it in a different address that is not associated with you and you want to be able to transact with it. But there's the problem of gas, because if you keep creating more addresses, you need to set.
00:55:50.436 - 00:56:19.472, Speaker D: Yeah, you need to fund them in order to transact. But then you are doxxing yourself. Then you are associating it with your main account. So an idea that is being discussed is to create a mixer. Paymaster. It's like a mixer, except that you can't use it for money laundering because it doesn't allow withdrawals. What it does instead is it allows you to prove that you have funds in the mixer and use these funds to pay for.
00:56:19.472 - 00:56:52.280, Speaker D: To sponsor a transaction from a different account. So now from the main account, you would fund the paymaster and then from other accounts whenever you need to transact with them. Let's say you want to do something with an NFT you have in another account, you can prove that you still have a certain amount of funds left for it and use it for. So by combining validity proofs and account.
00:56:52.350 - 00:56:57.272, Speaker A: Abstraction validation and Utxo, I assume it's Utxo based, right?
00:56:57.406 - 00:57:30.980, Speaker D: Yeah. So you end up with a model similar to Utxo and you don't need to worry about funding accounts for gas. And I think this is only the tip of the iceberg. I believe that once initially people are going to exhaust all the obvious use cases for account obstruction, and there are plenty of those, but I think that later people will start coming up with more and more ideas and many of them, I believe will have to do with privacy. So I think ZK is going to play a major role in these projects.
00:57:34.140 - 00:57:46.990, Speaker A: Wow, this blew my mind because it's a real problem I'm facing. Right. How can I, I don't know, buy something without me being associated with it? Not that I have anything to hide. Right.
00:57:49.120 - 00:57:55.240, Speaker D: So you don't need privacy. Only people who have something to hide need privacy.
00:57:55.400 - 00:58:05.890, Speaker A: Privacy is the most basic thing one should have. Right. Wow. So very nice. Okay.
00:58:08.260 - 00:58:26.570, Speaker C: I can add one thing, one much more prosaic one, which is when quantum computers actually break a lot of the standard signature schemes, then you'll probably anyways want to use a ZK stark based signature scheme for something like.
00:58:28.380 - 00:58:28.744, Speaker A: That.
00:58:28.782 - 00:58:30.344, Speaker C: Could be another use case.
00:58:30.542 - 00:58:38.396, Speaker A: So just switching the simple validation method that you have in the account to something which is quantum secure. Yeah.
00:58:38.418 - 00:59:14.808, Speaker D: And this has been discussed as one of the first use cases. It wasn't not necessarily with stock, it could be done with other signature schemes that are quantum resistant. But yes. So one of the reasons to obstruct the signature as early as possible is so that Ethereum and other networks can become quantum resistant without having to change the entire protocol. This is something that we couldn't possibly achieve with an EOA because the EOA is derived from the, is actually derived from an ECBSA key.
00:59:14.974 - 00:59:47.280, Speaker A: Yeah. Okay. I'm glad we chose that road. Okay, great. No, you know, sometimes it was really hard to stick with this decision because it does create a lot of complexity. Right. So when you have it as a trade off and you're saying, okay, on one hand I need to give freedom to developers and on the other hand it really makes the protocol complicated, then it's hard to stick with this decision.
00:59:50.200 - 00:59:52.020, Speaker D: By the way, there are some cool.
00:59:52.090 - 01:00:08.970, Speaker C: Questions I mean further down the line? I'll try this one. Will account abstraction solve all security issues? Does it offer absolute account security guarantees? Can it be integrated into every layer of blockchain? Is it layer specific? I'll just answer the first two.
01:00:09.420 - 01:00:11.130, Speaker A: Now we know you didn't listen.
01:00:16.400 - 01:00:18.300, Speaker C: Well, maybe just for a minute.
01:00:19.920 - 01:00:21.356, Speaker D: Okay, so I'm not going to answer that.
01:00:21.378 - 01:00:23.532, Speaker C: So why don't you press the start.
01:00:23.586 - 01:00:28.076, Speaker D: Answer and then I'm going to shut.
01:00:28.108 - 01:00:29.330, Speaker B: Up and just let.
01:00:29.700 - 01:00:50.740, Speaker A: No, I think we're done with the general flow and we can move to questions. Everyone agrees. Yeah. Okay, so the most urgent question is when Argent mobile will be supported on Starknet. And I also want to know that Julian.
01:00:51.720 - 01:00:58.376, Speaker B: Very soon. Very soon. As soon as regenesis is over, the body is on your side.
01:00:58.478 - 01:01:10.510, Speaker A: Back to me. Yeah. Okay, so not Regenesis, but when you have your Cairo one contract safe and deployed, you can have that.
01:01:11.520 - 01:01:21.488, Speaker B: Yes, we'll still probably wait for a bit of an ecosystem to be right. Very soon. We are working on it. Yes, very soon.
01:01:21.654 - 01:02:39.770, Speaker A: Okay, so just to give more context to what Julian threw back at me. So right now Starknet is going through the process of, let's phrase it good, making it more secure and more ready for its decentralized future. And this is done by moving to Caro one. So Cairo is the smart contract language of Starknet and it's also the language that the Starknet, it's called OS, but the Starknet system is written and Cairo is basically a language that allows you to write programs and then just generate a validity proof that they're correct execution. So Cairo one is basically the next generation of Cairo and has been released actually last week and it will be supported on Starknet in three weeks from now, something like that. Probably the week after Starko sessions and when we will support that, all argent wallet accounts will be ported to Cairo one. So I think Julian is saying that they don't want to release the mobile wallet when they know there is an upgrade in the foreseeable future.
01:02:39.770 - 01:03:14.724, Speaker A: Okay, great. So I hope this answer, I love Starknet and have used it a lot. Yes, but it could be painfully slow. I agree. Is speeding up the transaction confirmation time on your radar or is it possible? Yes. So first of all, I'm glad that you love Starknet and I agree that times can be improved and it is on our radar. The priorities as we list them currently are first of all moving to Cairo one.
01:03:14.724 - 01:04:02.690, Speaker A: So this is the first priority of the network and indeed the second priority is the performance. And this includes both the throughput of the network and the latency of transactions. So, yeah, it is on our radar, and it will be the next version after the introduction of Cairo one, which is, as I've said, in the coming weeks, will be the transition of the sequencer into a rust sequencer, which will highly increase the throughput and will also highly increase the latency or decrease the latency. So, yes, it is coming. Will account abstraction solve all security issues? Do we want to say anything more about that question? I think we're okay.
01:04:03.300 - 01:04:08.420, Speaker C: I can just say that nothing will solve all security. There's nothing that can solve all problems.
01:04:08.570 - 01:04:13.960, Speaker A: Yes, but you have had a good comment that it's all about trade offs.
01:04:15.100 - 01:05:07.620, Speaker D: Account obstruction allows us to make different trade offs for different accounts and not have just one trade off, one key that controls the account. For example, another question, another very long question that someone wrote. If I would summarize, I would say that he's concerned what happens if the key is compromised, since the account is now the person's id and cannot be changed easily. I'm saying that, for example, here, you could have different radars for one person. It would be okay. It would favor a user experience. Another person who is more concerned would enforce delays, like on chain delays, time locks for any critical operation, so that if the computer is compromised and the key is somehow stolen, or a mobile device is stolen, it can freeze it and change the key before it causes any real damage.
01:05:07.620 - 01:05:23.260, Speaker D: So this is an example of different trade offs being made by different users. So it doesn't solve the security, a general security problem, because there isn't such definition, but it can solve your specific problems by making the right trade offs.
01:05:25.280 - 01:05:34.816, Speaker A: Thank you. Okay, how is social recovery different from MPC, multi sig? So I can answer it, but I don't know, Julian, maybe you want to answer it as well.
01:05:34.998 - 01:06:42.896, Speaker B: I can say if so, first of all, I think there's three different things here, because MPC is not the same as multi sig, right. Typically when we speak about multi sig in blockchain, it's actually an account or smart contract which has multiple signer, and you need N-O-M-A-B signer to trigger transaction. MPC is one way to achieve something more or less similar, because you have multiple signer, which when they sign together, they basically produce the signature of a single UA. But so MPC, it's kind of a way for multiple people to recreate the valid signature for an UA. While a multi sig is a smart contract with multiple signers, and social recovery is a mechanism to gain back access to an account, to a smart contract account. So I do think there are different things, but for. So that's a question people get a lot what's the difference between MPC and smart contract, or account abstraction in general? I do feel that one thing that's very important is that MPC is recreating the signature of a newa.
01:06:42.896 - 01:07:24.368, Speaker B: So it's still a new way. And there's a question of what happens if some of the keys are compromised or lost. Even if you can recreate a new set, sometimes, depending on which tech, but you can recreate a different set of keys that will lead to the same signature, the lost keys are still there potentially. Maybe they can be in the hands of someone malicious. So you have less guarantees. With a smart contract, if a key is lost, you can actually replace it on the smart contract, and everybody can transparently see that a key has been revoked and another key has been enabled. So I do feel that account abstraction or smart contract wallet in general offer much more flexibility with respect to MPC.
01:07:24.368 - 01:07:43.800, Speaker B: And that's also important if you want to think about censorship resistance, because if you have multiple party settings, you want to make sure that no party can actually block the execution of a transaction. And it's much easier to bake rules to protect yourself against that scenario with a smart contract than it is with a purely off chain scenario like NPC.
01:07:45.500 - 01:08:10.000, Speaker A: Okay, you answered it much? No, it's much better. Thank you. Okay, can the next of kin be included in account obstruction? So we already answered. We said we can. An argent dropped a bomb saying they're working on it, or maybe. Okay, kindly post links to some of your resources. So thank you for anyone who posted.
01:08:10.000 - 01:08:47.260, Speaker A: We should probably prepare the page with many resources. So for next time we do a start at home on account and in EOS, we can generate a key pair without a transaction, without any computational requirements from the blockchain. But with account obstruction, every account creation will need to be a transaction. Okay, so I see Yannick already answered. So thank you Yannick. But I can also answer. So, yes, this is generally correct, but there are many ways in which this can be abstracted from the users.
01:08:47.260 - 01:09:42.476, Speaker A: Right, so in ERC four three, seven, this is basically done by having a special field in the transaction, which if transaction is sent to an address with no contract, it uses the information from this field to deploy a contract. And so this is basically bundled together with the first transaction that this specific account is sending. Right. So from the perspective of the user, this is transparent. Currently on Starknet we really have a different transaction to do the deploy. And this has been asked by Julian to have it baked together with the first transaction. But if I recall correctly, this is also almost abstracted from the user.
01:09:42.508 - 01:10:04.120, Speaker B: In argent, it's fully abstracted, so the users, they don't see, but technically there's still two transactions. So we would much prefer having that atomically, because that means you have the guarantee that they either both fail or both succeed, which is much cleaner in terms of if something wrong happened, it's easier to handle from a UX point of view. But for the users, this is abstracted already today.
01:10:04.190 - 01:10:04.424, Speaker A: Yes.
01:10:04.462 - 01:10:07.940, Speaker B: So you don't see that you are deploying your account on Arginix.
01:10:08.100 - 01:11:14.856, Speaker D: And I would also add, okay, so I would also add, aside from ERC 437, baking it into the first transaction, so there's no separate one. There's also the question of what do you want to do with the account when you say that it needs to be created, because in EOA it's quite the same, in order to do anything with the account, you essentially create it by sending eth to it. You cannot transact until you send eth. So there is an EOA creation, unless the use case doesn't involve performing any on chain access, for example, if you just want to receive something to add the address. So in this case, ERc 43 seven gives you the same thing, because it's a counterfactual address, you can calculate it off chain. We have a function for that. You can calculate the address of your account, so you can receive assets, and then only when you want to transact with these assets on chain, you're going to deploy during the first transaction.
01:11:14.856 - 01:11:18.720, Speaker D: So this is quite similar to how it would work with an EOA?
01:11:19.060 - 01:11:59.020, Speaker A: Yes, completely. And this is also the way it works on Starknet. And just to finish answering the question, so even in the case of a multi sig, it doesn't require another person or something which is not validated by the multi sig in order to deploy it. Right. The way we constructed it on Starknet is that even the validation for the deployed transaction can be verified with the same logic that you have in the account itself. Okay, so I hope it answers your question, but if not, you know where to find us on Stockwell sessions. I hope you'll be there, Adam.
01:11:59.020 - 01:12:31.010, Speaker A: And if not, you know where our offices are. So drop by. Okay, so I think with that question, we'll finish our session today. Really good questions. Really, I don't know. I had a great time and I also learned a lot of new stuff, and it made me happier on the decision to stick with account abstraction. So thank you very much.
01:12:31.010 - 01:12:35.450, Speaker A: And, and see you all in February. Right.
01:12:36.700 - 01:12:44.730, Speaker C: Thank you, everyone, for joining. Thanks. Your advice, Julian Yssette, Tom Barnes, and thank you, everyone.
01:12:45.100 - 01:12:46.952, Speaker A: See you next time. Right.
01:12:47.006 - 01:12:47.510, Speaker D: Thanks for having.
