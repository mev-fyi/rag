00:00:03.610 - 00:00:39.786, Speaker A: Okay, so yeah, let's start. So what Herodotus does is we provide an API for storage proofs, but simpler. So let's first start with some herodotus with some proofs. So obviously I hope everyone knows what the proof is because that's a bit out of disco for this presentation. So I'll just say a few things that's good about them and a few things that's a bit tricky. So the good things are the storage proofs unlock many new use cases. You will see even the use cases that we present now and there is unlimited more.
00:00:39.786 - 00:01:13.460, Speaker A: So this is the first big thing that it has a lot of use cases. It's very secure. It relies on math and zero knowledge, as you heard everywhere. And it allows us to access historical data on blockchains as well as current data across blockchains. So this data is also processed and it's proven. And the bad stuff is that it's quite complex. So if you were to do everything by yourself, it will probably take you the amount of time that we spent on it.
00:01:13.460 - 00:02:16.994, Speaker A: There is a bit of hard work, there is high maintenance costs, a lot of infra work, and you have to also have archive nodes and everything is not really well documented. So there's a lot of guessing work, research, knowledge needed. So we simplified the thing that basically the bottleneck is just generating a storage proof, verifying the proof inside AZK proof and verifying AZK proof on the j. So this sounds very easy, but it's actually quite complex. That's why we created the storage proof API. So what it does, it batches requests for cost savings so that you get the best price possible. You can schedule the proofs so that, for example, I don't know when to prove something in the future or when another request comes in, it simplifies the whole process, because the only thing you need to do is send a request and it's very easy to integrate.
00:02:16.994 - 00:02:58.806, Speaker A: I hope so. You'll see. And the infrastructure maintenance is not required. So the current capabilities of our API is proving statements from any tree, such as the state tree, so account or smart contract, so state of any account or smart contract as well as receipts and transactions. And all you have to do is just send a request and then wait for a webhook or query our API for updates. This is the link for docs, but the docs are in our v one version, like old version, that's not really what is happening right now. So we are not giving the APIs keys just yet.
00:02:58.806 - 00:03:32.978, Speaker A: When the API drops and it's open, the docs will be updated and you will be notified. Okay, this is how a request to our Hedosis API looks like. So it's basically you provide the origin chain from which you want the data. You provide a destination chain where you want to access the data. Then you provide a block number. So basically a point in time where the data should be accessed from. You provide a webhook so that we give you a callback when everything is ready.
00:03:32.978 - 00:04:08.510, Speaker A: You provide what? Sorry. Okay, you provide what you want to request. So in this case it's just an example, account access. So you provide the account you want to access and the properties you want to take. In here it's a balance, but it could be also, for example, nons or whatever. Okay, now we're going on to the on hands experience. So we want to present you a case study with full code that you can view that's public and basically showcases how to use our API in this use case.
00:04:08.510 - 00:04:52.086, Speaker A: So we are presenting the account recovery thing. So basically using account abstractions on StarcAd, you could probably write a wallet that has some account recovery logic written into it that would probably work. Like you present a proof that the nons in the past, let's say a year ago, was the same as the nons that it is right now. So to do that you need two proofs. You need to prove the nons in the past, a year ago, and you need to prove the nons now. And if those nons is much, then it means the account wasn't used for a year. This is the link to the repo.
00:04:52.086 - 00:05:30.470, Speaker A: You can just view it, but there is no need to download code today, there is no time for it. And their Internet is not that great. So everything is prepared for you here, I will present it. But this is just for reference. You can view the repo, you can do anything you want. I would just give 30 seconds and go on it. You can just go into like Hereditary's GitHub and it will be there.
00:05:30.470 - 00:06:26.460, Speaker A: Okay, I'm going on, sorry. Okay, so this is how the front end for the thing looks like. So basically you take an address, let's say that we take my address and we click generate and we have initiated the process of proving. So this is a demo that we've built for this workshop and it doesn't have the Cairo code of the address itself. So this is just the proving part of the thing. So when it's proven you would probably create an account abstraction that would use the proof and somehow transfer the money from the account or whatever else. This is just the proving.
00:06:26.460 - 00:06:52.716, Speaker A: So we first have the proof and we started the proving part. So going to the API. This is the demo code of the API for the workshop. We want to prove an activity and the only thing that we actually have to do is call Herodos'API for two things. For the. Until. So for the.
00:06:52.716 - 00:07:13.184, Speaker A: Since nuns. So like since a year ago to. Until nuns. So until today the account was inactive. So we basically just take the nonsense from address js. We just ask for the current block number and then we divide the year block distance. And we want two things from Herodotus.
00:07:13.184 - 00:07:51.792, Speaker A: So this is just a simple API call. So we have the URL of the Herodotus API and we call it with this body. So the body is origin chain, destination chain webhook, which is a webhook that we have here. So the webhook will be received by this API and then we have type account access and we want none for the account that we've inputted on the website. And the only thing you need is the API key and then everything is saved to the database. The database for this demo, I'm saying. And we basically wait for a webhook from Herodotus to say that everything is done and ready.
00:07:51.792 - 00:08:22.148, Speaker A: So let me show you how the database looks like for this example. It's just there is this inactivity proofs thing. And basically we're waiting for the syns block number and since nons to be done. So this is one Herodotus thingy. So the syns. So we take it from Herodotus, we have an id from Herodotus that will be the task in the Herodotus API. And we basically wait for it to be done, to be finalized in the task status.
00:08:22.148 - 00:08:48.404, Speaker A: And there is also the until one. And basically when both of these come through and we have proofs for both of them, we get the nons and everything is ready. So what I will do is I will trigger the webhooks as would the API do. So this is the synth webhook. So imagine the hurdle is giving you a response. Okay, 1 second. Yes.
00:08:48.404 - 00:09:15.020, Speaker A: Okay. And until. Okay, so now we can see 1 second. Yes. Now we can see that the task status is finalized and we have the nons. So how did we get here? Is basically in here. When we get the webhook from Herodotus that everything is done and proven, the only thing we have to do is check the nons.
00:09:15.020 - 00:09:54.248, Speaker A: 1 second. I'll just get there. So what we do is we query a contract on Starknet that's called the fax registry where the proven nonsense land in the end. And we just get the nons how it looks like you have the stark, this is the contract, that's the fax registry, and you basically query the verified nonsense. This is the address that I've started and this is the until nons. When I query it, I get the response eight. So the nonce was eight, and then in here I can see that the until nonce was eight and the since nons was eight.
00:09:54.248 - 00:10:45.096, Speaker A: Okay, coming back to the main thing when we refresh it now. Okay, the last thing to do is to. This is just the architecture of this thing built for this demo is to update the tasks to finalize the inactivity proofs. So another, this is actually a chron job, but I've also made it manual so that we all see what the steps are. We just update the thing and give it a second. Yes, the since nonsense is eight, the until nonsense is eight, and the whole thing is finalized, so the proof is valid. This is basically the whole use case.
00:10:45.096 - 00:11:17.090, Speaker A: So you've seen that the whole code is not very complicated. And the only actual part where you use Herodotus is just doing a request. In this case, two requests, and then receiving a webhook and updating stuff in your database. Two interactions with Herodotus. Very simple and not much to do here. Coming back to the presentation, let me just present this. This was just one use case that we wanted to present.
00:11:17.090 - 00:11:46.648, Speaker A: You have the demo code. You can see how to use the Heroditis API, but there are many, many more use cases. Just a few. To spark your ideas is cross chain data access, which basically means that with the API you are able to access data from different chains. And then you have governance. We are for example, working with Snapshot and they're going to use us in the snapshot X. So if you're interested, just check out snapshot X wallets.
00:11:46.648 - 00:12:20.100, Speaker A: So basically the thing we presented, for example, proving that the account was inactive for a time and then recovery. Then there is finance. So for example, cross chain margin account, so that you can buy more and there is no need for bridging assets to cover your ass. There is also gaming. So for example, imagine you're playing some game on some cheap chain, and then you want to use assets from Ethereum. You have a sort NFT on Ethereum. You don't need to bridge this asset to this cheap chain for the game to run.
00:12:20.100 - 00:12:49.188, Speaker A: You can just use a storage proof to prove that on the other chain, you have this asset, which is way better. Then you have social. So, for example, we've built a short demo hackathon project, which is basically using lens protocol and proving that you own the account so that you can log in. So imagine an Oauth like you log in with Google but with lens protocol. Pretty cool. Then there is identity. So, for example, using Ens crush chain.
00:12:49.188 - 00:13:06.084, Speaker A: So there is no need to bridge stuff. Try to create more ens on different chains. You can just use the main one and everything will work with storage proofs. Then there is bridges. This is kind of an obvious one. And airdrop eligibility. So, I don't know.
00:13:06.084 - 00:13:47.780, Speaker A: Imagine you want to airdrop tokens to someone who held your NFT in the past. This is also provable. You can also, for example, drop your tokens to people who have over 50 e because you're, I don't know, rich, exclusive. Whatever you can think of any possibility you want, you're pretty much covered. Okay, thanks. And do you have any questions? No. Okay.
00:13:47.780 - 00:14:12.350, Speaker A: So it's actually a very nice question. So we are doing another workshop on that. That's tomorrow. A lecture, not a workshop that's done by Tiago. I recommend going to that. So, basically, that workshop will be telling you how to sync a whole chain from Genesis to now, and then syncing the future as well. And basically, when we get that done, that will be done probably pretty soon.
00:14:12.350 - 00:15:00.150, Speaker A: Proving anything on the chain, no matter how far in the past you go, will be the same price. Any more questions? No? Okay, thanks. If you have any questions, just find a guy with a herodotus t shirt and just. Or go into our discord. Yeah, we thought about that, but actually everyone seems to notice us because it's like a funny name, and it's just. Yeah, we like the name. Okay, thanks, everyone.
