00:00:00.250 - 00:01:01.930, Speaker A: With this presentation. So first of all, what exactly is Starknet? So some of you may be a bit familiar with what Starknet is and for the hours we will present. So Starknet is a general computation platform secured by Ethereum. So it's a layer two network that allows writing smart contracts that can manipulate Ethereum assets. In general, Starknet is able to connect with Ethereum and interact with it, so it can manipulate assets, ERC 20s, ERC 721, or actually really any kind of interactions you may imagine with the Ethereum blockchain. The cool thing about Ethereum, about Starknet being an l two, is that it allows to do more things than Ethereum. And this more can be seen under two axis mostly.
00:01:01.930 - 00:01:48.970, Speaker A: One is the volume of transaction scaling. So you can do a lot more transactions for the same price, or say differently, you can do transactions cheaper. The other axis is that you can do transaction with complexity that is much higher than on Ethereum. The reason for that is that Starknet is organized a bit differently than Ethereum, and we'll see it in just a while. So this is what Starknet is in a nutshell. It's a network that allows you to run smart contract, that is coupled to Ethereum. Now, if you're familiar with Starknet, probably you've heard about Cairo.
00:01:48.970 - 00:02:59.790, Speaker A: So what exactly is Cairo? Cairo is a programming language that allows you to write programs, arbitrary programs. You could imagine anything, really. The particularity of these programs is that they are what we call provable, in the sense that if you run a Cairo program, a person a can run a program and give to person B the output of this program, and a proof that the program did indeed reach that conclusion without person B having to run the program herself. And the very specific property of Cairo is that when you run a code, you can generate a proof with that. So the advantage for person B is that they're able to what we call verify, approve without executing the program itself. The really cool thing about Cairo is that the person who verifies this program can run this code in many languages. Among the languages that are able to verify these programs, we find Ethereum.
00:02:59.790 - 00:04:18.414, Speaker A: Ethereum has codes that allow it to verify a proof of execution. So that if you give to Ethereum the proof that the program computed correctly, the Ethereum, the EVM, is able to validate that this program ran correctly without executing the program itself. So what exactly is the link between Cairo and Starknet? Well, Starknet is a Cairo program. So Starknet is a network, and the software running these networks allow you to run sub Cairo programs, which are smart contracts. And when you run this Starknet program, which is a Cairo program, you can generate a proof of execution that you run this program correctly and the EVM is able to interpret it. So now you are able to run your network, and the EVM itself is able to control that the network indeed worked correctly and that there were no incorrect state transition. This is a key difference with over l two s, where you rely on the assumption that the validators of the chain will behave correctly, and that when they send information to l one, they are incentivized to do it correctly because they have something at stake here.
00:04:18.414 - 00:05:13.162, Speaker A: We don't trust game theory, we just rely on mathematics, advanced mathematics, but mathematics nonetheless. That's the main thing. So how exactly does that work? Well, basically on Ethereum, when you send a transaction, this transaction is sent to the mempool, right? It is received by all the nodes of the network, and it is executed by all the nodes of the network. Then a miner will select some transactions, put them in a block, and broadcast the block, right. At that point, all the nodes in the network will take the transaction that were included in the block and execute them. So each and every node will run the full payload of that block. Right? On the other side, on Starknet, when I send a transaction, the transaction is sent to a mem pool.
00:05:13.162 - 00:06:01.194, Speaker A: It is received by all the nodes of the network, but not necessarily executed. A specific kind of node, which we call a sequencer, will select the transaction and batch them in a block, which will then alter the state to move one block forward. This block is transmitted by the sequencer to the prover. The prover is a specific machine that will run the payload and update the state, but also prove the execution of that execution. So out of the prover will come a new state. So a state update and a proof. And now every participant of the network is able to receive the new state and to receive the proof and to verify the proof.
00:06:01.194 - 00:07:17.074, Speaker A: The really cool thing is that verifying the proof is much less complicated than actually executing the payload that generated the proof. So that means that in Ethereum on the left everyone has to run the full load of the network, while on the right only one computer will run it, generate a proof, which is extra burden, but is compensated by the fact that no one else will need to run this execution. And you can just take the state update for granted, because mathematics. Okay, and exactly how transactions are processed by Starknet. So, as we mentioned, this is a bit of a focus from the previous diagram. So from the Mempo the transactions are sent to the sequencer, which will update the state of the chain and then the prover will take as input all the code of the OS. So how exactly you execute Starknet, what's the engine? So similar to the EVM, but it's the Cairo VM, right? It's the Starknet VM.
00:07:17.074 - 00:08:15.050, Speaker A: He takes the previous state, the new state, all the transactions that were executed and now improves the transition from state a to state b, and everyone can update the state and move on to the next block. All right, so that's in a nutshell. That's what we're working on. There are a lot of moving pieces and I'm sure you have a lot of questions, so feel free to ask them and we'll answer them during the workshop. And exactly what are we going to do today? In this workshop today we will cover basically the general syntax of Starknet smart contracts. So as I mentioned, Starknet runs on Cairo and smart contracts in Starknet are written in Cairo. So we want to show you how you declare variables, how you declare mappings, how you write functions, how you import modules, which we call built ins, which are the equivalent of say library.
00:08:15.050 - 00:09:02.262, Speaker A: We're going to show you how you deploy a contract and how you have your contract interact with another contract. So composability, there are other things that we won't cover for now because a workshop is a short amount of time to show all of this. We won't cover exactly how l one to l two communication works, right? So we won't show you today how to deploy and build your own bridge, but you should know that it's something that is possible. It's not like there's just one bridge where tokens can transfer. It's an arbitrary messaging system where you can build rich applications based on signals from L one. So do get interested in that. We won't talk about how to build a front end on Stocknet, which is also a very important part of when you're building a DAP.
00:09:02.262 - 00:09:47.720, Speaker A: Know that there's a library called Stocknet JS you can use to do this. And we won't cover general Stocknet architecture. Part of it is time. The other part is that the stocknet architecture is still being built. So we could present you a scaffolding, but we think right now you'll make a better use of your time learning how to use the engine. And then we'll discuss architecture a bit later on once all of this has solidified. Okay, so today, what exactly are we going to build to learn how that Starknet engine works.
00:09:47.720 - 00:10:22.114, Speaker A: We're going to create a voting system. So some of you are probably familiar with remix. And if you're familiar with Remix and you try to write your first solidity smart contract on remix, you may remember that there's a voting example in remix. It's not exactly the same, but it's similar in spirit. Today we're going to create a smart contract that is able to create polls to register users and to have them vote on polls. And specifically, we want to control that. Some users have access to polls and they're able to vote on them and manage access.
00:10:22.114 - 00:10:58.880, Speaker A: In that sense, that's the scope of what we will cover today. And with that, I can end it over to you, Ariel, and we can start talking about code. I'm going to take a look at the questions. The way we are going to work is Ariel is going to present some concepts and then have some exercises that you can work on. And while you'll be working on these exercises, we will also take questions and answer them. So without further ado, Ariel, you can go ahead.
00:10:59.330 - 00:11:42.286, Speaker B: Thanks. Let me just share my screen for a second. I'm going to need you to close yours, unfortunately. Okay, great. So I'm guessing you're seeing my screen now. Okay, so, like Henry said, I'm a product manager at Stockware working on Starknet in general. And basically today we're going to walk you through writing Starknet contacts, a bit of syntax, and there will be some exercises and you will have some time to work on them.
00:11:42.286 - 00:12:26.682, Speaker B: In the meantime, we'll be answering questions. You're definitely welcome, more than welcome, to ask questions about the code itself or about general stocknet architecture. We'll try to give you a few minutes to walk quietly once the exercise begin, and then we'll probably just choose some questions and discuss them. Okay, so let's start. So you should already have the links to both this notion document, which contains all the exercise, and the code in a copy based table format. You should also have a link to the Starknet playground. So that's where you're expected to write your code.
00:12:26.682 - 00:13:25.950, Speaker B: And we won't be deploying until the end of the workshop. So basically it's just a place for you to write the code and you can verify that your syntax is correct by compiling. Okay, so that's what we're going to use throughout the workshop, the notion document and the stocknet playground. Okay, so let's dive straight into the details. Okay, so that's the beginning of a Starknet contact. As you can see it starts with specifying that it's starknet contact as opposed to just a program written in Cairo. So starknet contacts are written in Cairo with a few differences, which makes them more smart contract oriented than standalone programs.
00:13:25.950 - 00:14:26.770, Speaker B: This is obviously one of them. After declaring that this is a contract, we're declaring the built ins that we're going to use throughout the program sort our contract. So the built ins, you should think of them as pre compiles certain logics that are too complicated to implement in native Cairo and are written in a different form for performance purposes. So here you can see that the built ins are the Peterson hash function, a rain check, which you'll see, we'll use it, I'll mention it, and another built in for verifying signatures. This is the ECDSA built in. Okay, so after the built ins we have the regular imports, which are just the modules that we're going to use in our program. So these are structs you will see once we start writing the actual contacts where exactly they come into play.
00:14:26.770 - 00:15:22.162, Speaker B: So we just have the contact declaration built ins that we're going to use and library modules that we're going to use. Okay, now we're going to show how storage variables appear in Starknet. So just like in solidity, in Ethereum, each contract has its own storage, which is a mapping between an address and a value. And we'll see how exactly to declare and add storage to a given contract and how to modify it. Okay, so that's the way storage variables appear on Starknet. So you'll notice the storage VAR decorator and the actual syntax of declaring a storage variable is through a function. So if I want to declare a mapping between a key and a value, that's the way it would appear on my contact.
00:15:22.162 - 00:16:29.210, Speaker B: So I have a function, this is the variable name, and the fact that it receives one argument and returns one argument indicates that this is a mapping from a single key to a single value. Here you will also see the type of the keys and return value which is felt, it's short for field element, which is the basic type in Cairo, analogous to Un 256 in solidity. So this is the first storage variable in our contract poll owner public key. And this storage variable is supposed to map between voting polls and the public key of their owners. So we're going to design a system where there are several poll ids and each poll id is owned by a specific person, and he will be the one allowing users to register to a given poll. Okay, so that's the mapping between the poll id and the identity of the owner of that poll. And then we have another storage variable which maps the poll id to all the voters registered to it.
00:16:29.210 - 00:17:20.440, Speaker B: So the fact that this function receives two arguments and returns one value means that we interpret this storage variable as a mapping between two keys to a single value. So the key now is a pair of poll id and the public key of a voter, and the value is a single value which is a flag that indicates whether or not the given voter is allowed in this poll. So on the one hand, we have a mapping between every poll id to its owner, and on the other hand, we have a mapping between pairs of poll ids and potential voters to an indicator that specifies whether they're allowed to vote on this poll or not. Sorry, I can't really hear anybody.
00:17:23.150 - 00:17:27.900, Speaker A: Chinonso Gabrielle, you have your microphone open? Please close it.
00:17:29.230 - 00:17:33.546, Speaker B: Maybe we can somehow mute and allow it to do in the exercise.
00:17:33.578 - 00:17:35.438, Speaker A: No, it's fine. You closed it.
00:17:35.524 - 00:18:12.380, Speaker B: Okay, thanks. Okay, so now you're ready to define your own storage variables. So you have five minutes for the next exercise. So basically what we want you to do here is define two additional variables. The one is called voting state, and it should be a mapping between a pair poll id and a given possible answer. So we'll have polls with only two possible answers, yes or no. And voting state will be a mapping between an id, a potential answer, yes or no to the number of people who voted on this answer.
00:18:12.380 - 00:18:46.040, Speaker B: And the second storage variable is voter state, which indicates, which will allow us to track which voters already voted on a given poll. So it will be a mapping between a poll id and the public key of a voter to an indicator which states whether or not this particular user has already voted. So try to follow this pattern and define those storage variables. You have five minutes, so we'll give you a minute or two to think about it and then we'll start referring to questions.
00:18:48.730 - 00:18:57.190, Speaker A: All right, thank you, Ariel. So do you want to wait a minute or two to give people time to think without us talking in the background?
00:18:57.850 - 00:19:02.280, Speaker B: Yes, let's give a minute. So disturb anyone?
00:19:59.640 - 00:20:16.764, Speaker A: So the way we did last in the last workshops is that we left time for people to work. But in the meanwhile, we answered a few questions. So we can do the same now, but don't hesitate and mute us if you need to. A minute and a half has passed. Now we can.
00:20:16.802 - 00:20:18.270, Speaker B: Yeah, you can go talk.
00:20:19.120 - 00:21:16.300, Speaker A: So there were some questions, and there's three of them I'd like to take. The first one is what's the difference between the output of the program which Cairo executes, and the proof. Are those the same? So specifically, in the context of starknet, the output of the program is a transition from block one to block two, for example. So say your chain is at block one and I send you one eth, then in block two, your balance of eth will be plus one eth. Right. This is part of what we call the state of a block and the state of the blockchain. And so what we are proving is that the new state of the chain is the state I'm providing, and we're proving that the transition was made according to the code that you can audit.
00:21:16.300 - 00:21:49.560, Speaker A: That is valid. That allows me to transfer one ETH to you without cheating. The proof itself is different. It's a value, I don't like to say it that way, but it's a cryptographical value that you can mathematical result that you can put in an equation and get Boolean out of, which will say true or false with a higher probabilistic certainty. And so you're sure that the state I gave you is correct. Do you want to add anything on that, Ariel?
00:21:50.700 - 00:22:16.850, Speaker B: No, that was great. So just keep in mind that in the end, you're basically proving the correct execution of a program. And part of the statement is to say that the contract outputted the value five. So when we say the output of the program, we mean exactly this output in the context of Starknet, like Henry said, this output is actually the root of the new state, for example.
00:22:17.380 - 00:23:26.244, Speaker A: And the cool thing is, you don't really have to bother, and I mean, you don't have to understand all of this to write Cairo smart contract. It's not that hard to understand. It's not that easy either, of course, but you can write your smart contract and be confident that they will move forward and that the blocks will be executed without cheating, thanks to this state transition function. There's another question, which I like. So one is, can anyone run a sequencer and or prover? Do sequencer and prover have reward for securing Startnet, just like a miner receives eth? So the short answer is, right now, Starkware runs the sequencer and the prover. But this is on our roadmap to decentralize. For Starknet, we have no interest in running proprietary network, and we want it to be decentralized so that anyone can run a sequencer, anyone can run approver, and it is decentralized.
00:23:26.244 - 00:23:55.788, Speaker A: So TlDR not yet, soon. Okay. And yes, it would make sense to incentivize provers and sequencers to receive reward. I mean, if you want to have a standalone system, it's better if everyone can get incentivized properly. And we had another question regarding EVM compatibility, which we'll cover next time because we've reached the end of the five minutes. So I'll let you correct Ariel, I'll.
00:23:55.804 - 00:24:52.772, Speaker B: Just say that if you're more interested into sigma cells and povers, and what is the role exactly, and how do we imagine this happening in the decentralized phase which we call Starknet universe? Then you can hop into Starknet shamans, which is a new form for discussions about potential research topics, and you'll see a more elaborate discussion there with a few ideas. So Henry, if you could touch the link or something, you could just look there. Okay, so let's go to the solution. Let me just move this. Okay, so you can see we added our two new storage variables, voting state and registered voters. So voter state and voting state, my bets. These were the new ones, voting state and voter state.
00:24:52.772 - 00:25:54.570, Speaker B: So voting state is just a mapping between a pair poll id and an answer to the number of people who voted for this option. So a single value and the voter state is a mapping between a pair, again, poll id and the public key of the voter to an indicator which specifies whether or not he has voted. So while maintaining this storage variable, we'll only substitute values which are zero or one for our purposes. So now we have the storage in place, we can actually start talking about maintaining it and implementing the voting logic. Okay, so this takes us to function and we'll look at the first function of this contact, which is init poll, the initialization of a poll. Okay, so the first thing you might notice is the external decorator. This means that you can interact with the contact using this function and calling such a function can change the contact state, meaning that it will change potentially the storage of this contact.
00:25:54.570 - 00:26:50.704, Speaker B: Then you can see a bunch of parameters taken by this contact. And in Cairo you have a separation between what we call implicit arguments under the curly bracket syntax and the regular arguments which appear under regular parentheses. So you can see that the arguments, the explicit arguments, are the poll id and the public key of the poll owner. So when you want to initialize a poll, you just specify your public key and the poll id. The implicit arguments actually appear here because they're used under the hood in order to access storage variables. So these are three arguments that you need in order to access storage variables. So every function that touches storage will have those, and if you want to know exactly why the separation exists, then I'll refer you to the Cairo tutorials.
00:26:50.704 - 00:27:30.836, Speaker B: For example, you can look for how Cairo works and then you'll see exactly why do we have this separation. But essentially you shouldn't consider yourself so much about this, at least at this point. Think of this function as just accepting two parameters, the poll id and the public key of the voter. Okay, so the first thing we do is read the current poll owner of the given poll id. So how do we do it? This is the storage variable name. So we simply call read and give it the key that we want to read. Let is a syntax for defining a reference.
00:27:30.836 - 00:28:37.228, Speaker B: So now we have a reference to the return value of the read function and then we're verifying that it is equal to zero. So in stocknet all the default values are zero. So our way to know whether or not the poll is already initialized is to check whether in the mapping between the poll ids to the owner, the value of the owner is zero. So this is exactly what we're verifying, that the public key of the owner for this given poll is actually equal to zero. So this line will fail unless it is, and if we manage to pass it, meaning that the poll isn't already initialized, then we now update the mapping, update the poll owner public key storage variable and we're updating under the key poll id and the value which is the public key of the voter in our parameter, and then we simply return. So nothing too special going on here. We're simply reading the current owner, making sure that it's zero and updating it.
00:28:37.228 - 00:29:34.940, Speaker B: You'll notice that write has one extra parameter over read because we have to specify the value that we're going to write in addition to the key. Okay, so this was the initialization of a poll, okay, and now we want you to write a declaration of a new function and start implementing a small part of this function body. So the function that we want you to start writing is called register voter. And the semantics of this function is to allow the owner of the voting poll to register different voters into this poll. So the function will get the poll Id, the public key of the voter, and two additional arguments. These two additional arguments represent the signature. Whose signature? The signature of the poll owner.
00:29:34.940 - 00:30:25.292, Speaker B: But we'll get into that bit later. Basically those represent a signature of the poll owner that this voter public key is allowed into this poll. Okay, so we have four arguments and the function is supposed to update one of the storage variables to remember that this voter is allowed into the given poll. Okay, so after declaring the function, we want you guys to start by verifying that the poll is initialized. So you can start by reading the current owner from the poll owner. Public key mapping. Okay, and also add a line to update eventually the registered voter storage variable.
00:30:25.292 - 00:31:14.770, Speaker B: So we'll later implement together the part where we actually do the signature verifications. But for now let's assume that the signature is valid and just update the registered voter storage variable, meaning update a storage to indicate the fact that this voter is allowed to vote on this poll. And we had a dedicated storage variable for it. So it shouldn't be a problem for you to update it. We've seen how to do it. So you have 15 minutes, good luck. And maybe, I suggest that maybe you guys can mute us if you're interested in doing this peacefully and we can maybe start discussing questions.
00:31:15.300 - 00:31:19.490, Speaker A: I have managed to deactivate the doorbell. I'm so happy.
00:31:22.180 - 00:31:26.752, Speaker B: So everybody learned at least one thing in this workshop.
00:31:26.896 - 00:32:29.924, Speaker A: Exactly. Okay, so there are a few questions. I think we can answer them. So the first one, going back to before what you were answering, I'm going to put the timer is, there were two questions actually, which are the same topic, and one is, okay, so basically the proverb converts Cairo contract into EVM bytecode. And the second question is, okay, so is Starknet EVM compatible? So I think the global question here is what's the relationship with the EVM and how can we run solidity contracts on Starknet? So the first thing is no, the proverb does not convert Cairo contract into EVM bytecode. There are different machines, so they work similarly in the sense that they both are able to keep track of state of smart contracts, have function updated and have anyone interact with it. But they work differently.
00:32:29.924 - 00:33:25.540, Speaker A: The EVM is a very specific computation engine and what we run on Starknet is different. So no, we don't compile it to the EVM bytecode. The reason for that is that, the reason for that is basically that with Cairo you can do a bit more than what you can do with mean. When I think really about the simple answer is this one, we can do more with Cairo. And so we don't want to limit what can be done on Starknet just to fit DeVM. That being said, we do recognize that a lot of you are familiar with solidity and will want to port your, and will want to port your solidity code to Starknet. Hence the second question is starknet EVM compatible? Up until recently we would say no, we're not EVM compatible.
00:33:25.540 - 00:33:59.780, Speaker A: And it turns out the answer to this question is it depends on your definition of EVM compatible. It seems like the consensus right now is that EVM compatible means you can take your solidity code, transpile it, and execute it on an availability roll up. And this we will provide. We're working with Nevermind to build a transpiler that will make you able to transpile your solidity code to Cairo. And so take your solidity code and run it on Starknet as is. Do you want to add something, Ariel?
00:34:01.160 - 00:35:49.800, Speaker B: Yes, so I definitely agree with this point that we should probably define better what we mean by EVM compatibility. So if we want the stone interpretation that were actually proving execution of the EVM, that want to prove that for a certain input execution of the EVM bytecode resulted in a certain output, then no, we're not EVM compatible. But if the definition is being able to take Cairo code, which we know how to prove the execution of, and being able to transpile solidity code into Cairo code, which we can actually reason about in our proof system, then yes, we are compatible in that sense. And we're developing warp. Actually it is developed by Nevermind, and so far they managed to transpile certain contracts. They're working towards transpiling Uniswap V two, I believe, so you can look more into the warp project to see where exactly things stand, but it gets stronger every day with the capabilities of transpiling more contracts from solidity to Cairo with some overhead. Of course one can expect overhead in this transpilation, so it doesn't make learning to write in Cairo completely useless, but it does add another direction of getting into starknet from solidity.
00:35:51.500 - 00:37:03.516, Speaker A: Thank you Ariel. So there's another question which is interesting. In starknet universe phase is the plan to have a queuing system of nodes so that only one node runs the prover, while the others simply verify the proof? Or do multiple nodes compete to generate the proof? That is a very interesting topic. I'll give you the short answer. The short answer is we're considering both solutions in order to provide liveness, but we favor the system where only one node generates the proof in order to avoid wasted computation, and also because it's easier to reason about and it's easier to design the system around this, though we want to make sure that eventually a proof will be provided. So we are working on fallback mechanism so that if the prover doesn't show up, others can take its place to make sure the proof is generated. So that's the short answer, the long answer, I won't give it to you.
00:37:03.516 - 00:37:23.910, Speaker A: Now, I will tell you. Come and join discussions on shaman, because this is the kind of topics we want there, and this is the kind of topics we have there. So if you're interested in these architecture choices, make sure to follow the discussions there, and you'll find plenty of content you like. Ariel, do you want to add something there?
00:37:24.840 - 00:38:11.350, Speaker B: No, this is an active research question for us. And like you said, there's a certain trade off between having more computational work done in general and being sure that the next ensuring liveness easier so each side has its merits. You could argue that essentially, you don't need multiple provers doing the heavy work of proving, because exactly like you said, other parties can just verify the poof. But the final protocol is still to be determined. Yeah.
00:38:12.200 - 00:38:46.252, Speaker A: Cool. Thank you. So there's another extra questions on the question of transpilation. Since the solidity contracts are written, considering the gas limitation of the Ethereum chain, will the transpiler eventually make the transpile code to be better, to be able to take advantage of Cairo? So I want to say two things. The first thing is that if you write your code in solidity, it will probably be less efficient than if you write it in Cairo. The same logic. Why? Because you will have the transpiler overhead.
00:38:46.252 - 00:39:16.360, Speaker A: We're working hard to reduce this, but the latest estimate I've seen is that writing the same logic in Cairo and writing the same logic in solidity introduces five times over x overhead. Something like that, in that ballpark. But the thing I really want to say here is that, and I've been trying to find a meaningful analogy here, but I don't know. Ariel, have you played Nintendo 64, and were you playing Pokemon Stadium?
00:39:17.740 - 00:39:20.920, Speaker B: No, I have. I'm too old for Nintendo.
00:39:21.340 - 00:39:32.648, Speaker A: Oh, my God. I feel whole. Now. Has anyone played Pokemon Stadium? And the reason I'm bringing it up is that Pokemon Stadium. Jill? Bertie. Yes. You know the real one.
00:39:32.648 - 00:40:39.584, Speaker A: Cool. Okay, so Pokemon Stadium. Now, do you remember that you could have a little cartridge on your Nintendo 64 where you could play your Game Boy cartridge? You could play Pokemon blue, green, or red on your Nintendo 64. You would still have the same graphics and everything. And to me, arguing about gas costs of solidity code that you want to transpile to Starknet is a bit like arguing about trade off of programming a Game Boy program in order to run it on Pokemon Stadium. It doesn't make sense. Just build the game for Nintendo 64, or at least when you start to reason about like, oh, okay, I don't have to limit myself to the Game Boy ecosystem and I can think about the Nintendo 64 capability, then you really start to get a sense of how you can exploit this in the full spectrum.
00:40:39.584 - 00:41:33.328, Speaker A: So that's what I wanted to mention. Gas cost is indeed important on Ethereum. It will be important on Starknet, of course, because you're spending money on computation and storage, but it allows you to do fundamentally new things. And if you really want to explore the limit of what is doable with a blockchain linked to Ethereum on Ethereum, then you should take a look at Cairo and you'll learn a lot of things. Okay, so I need to come up with a better analogy or format it better, but it really made me think of this. Anyway, so there was another question. Is there any different limitation between the NFT minted by starquare and the NFT directly minted on Eth mainnet? So first of all, NFTs are not minted by Starkware, they're minted on Starknet.
00:41:33.328 - 00:42:39.172, Speaker A: Just wanted to mention this, but basically, and there are also questions between l one to l two communications. What happens is that when you prove the execution of Starknet to Ethereum, you update the state of Starknet on Ethereum so that the state is stored on Ethereum. When you update the state, you also have the availability to transmit messages to and from each blockchain. So now you have a mechanism where you can have a smart contract on Starknet, sending messages to smart contracts on l one and the other way around in overworld, you can have an l two smart contract calling an l one smart contract. The call is synchronous, but you have the possibility to do that. The question becomes a bit like, oh, okay, so what's the difference between NFTs minted by a minter contract and NFTs minted on the NFT contract? And the answer is like, they're basically the same. It depends on the logic you want to put on the minter.
00:42:39.172 - 00:43:03.344, Speaker A: So it really depends on how you implement and you design your bridge. So it depends on how you structure your system. But you can pass arbitrary message, so you could pass almost anything you created on l two to l one and have them interact. I don't know if that answers the question, but I hope so.
00:43:03.542 - 00:43:50.560, Speaker B: I just want to mention that this question is not necessarily limited to nfts, but you could ask the same of ERC 20. What's the difference between Ethan Ethereum and Ethan Stocknet? So essentially, if you know the security guarantees of Starknet and you know that, for example, nobody can arbitrarily change your amount of ETH in Starknet. And you know that once you want to transmit it back to l one, you will be able to do it. Then you could argue that one is not less secure or lessened than the other, as long as you're aware of the differences. So the same is also true for nfts.
00:43:51.460 - 00:44:37.680, Speaker A: Thanks Ario. So there were also other questions. One was, oh, I'd like to know if this is the first tutorial or if there were other classes before now. Will we cover different topics in the future? It would be cool to have one with a workshop on how to run your own prover or a workshop on L one and l two communication. So this is not the first time we do this workshop, but it is the first workshop we give publicly and we've designed so there will be others and we plan on doing them on site. So we will go to meetups physically in cities. So if you know of meetup group that is interested in having starknet workshops do reach out.
00:44:37.680 - 00:45:06.410, Speaker A: We'll be very happy to come and have a workshop with you on a specific topic and then have a few beers and talk about all the magnificent things you'll be able to build on Starknet. But we'll also have them, all of them online of course, so that you can catch up. So that's the first one, but we'll do others. Thank you for the suggestion. So Julie noted, running your own node and l one, two, l two communications. L one tool, two communications. We're already working on it, actually.
00:45:06.410 - 00:45:37.632, Speaker A: It takes time to produce material, so it won't come immediately, but we're working on it and we'll make sure to post it on discord and we'll find a way for you to stay in touch if you're more interested on educational material like that. And with that there are two other interesting questions. But we've been talking for 14 minutes and we will, I think, answer them later to take our time maybe.
00:45:37.686 - 00:46:06.380, Speaker B: Regarding l one and l two communication, the example written by Henry actually, which you can find on Twitter, but I'm not sure if only on Twitter that actually walks you through communicating between l one and l two to graffiti contact. So we can also link you guys to that. This actually takes you by hand in sending a message between the layers.
00:46:06.720 - 00:46:14.240, Speaker A: Right? I'm going to share the repo, so if you want to run it, you can have fun with it.
00:46:14.390 - 00:46:18.652, Speaker B: The tweet itself is also very enlightening, so probably useful.
00:46:18.796 - 00:46:20.930, Speaker A: Okay, so I'll show my profile. Sure.
00:46:23.060 - 00:46:50.404, Speaker B: And yeah, we definitely plan to release more educational materials. I'll just mention that while l one and l two communication is an additional 15 minutes. Talking about setting up approval and what exactly the proverb must do is probably a few hours session at least. There's a big gap between the hardness of those tasks.
00:46:50.532 - 00:47:12.656, Speaker A: You know, we were discussing with fear earlier and making a list of all the things we should cover if we do educational monitorial. And we came up with something like, okay, so we need about 30 hours of class, which makes sense. We really want to build that content, but it will take us a bit of time. Anyway, I think we're done for the 15 minutes, so if you want to move forward, that'd be great.
00:47:12.758 - 00:47:30.760, Speaker B: Let me just minimize this one as best I can. Or maybe I'll just close it. Yeah. Okay. Hopefully you all succeeded. And if you just want to enjoy the show, then let's quickly go over it. So this is the signature of the registered voter function.
00:47:30.760 - 00:48:33.340, Speaker B: Note that again we see the external decorator, the same implicit arguments as before that are used to access storage variables and the four explicit arguments, poll id, the public key of the voter, and an additional two values representing the signature of the poll owner. Okay, and in the end of the function, after all the verifications have passed, we're going to put something in the middle here in a second. But in the end you can see that we updated the registered voter storage variable. So we indicated that this public key is allowed to vote on this poll by calling right with three arguments where the left is one. Recall that we had a mapping registered voters between a pair of poll id and the public key of the voter to a flag which indicates whether or not he's allowed to vote. So here we're specifying the key and here we're specifying the value. So write takes three arguments as expected.
00:48:33.340 - 00:49:24.540, Speaker B: And initially we're simply reading the owner of the public key, whose rms is his supposed signature. So we're going to have to read the public key if we have any hope in checking whether or not these values make sense. Okay, so we're simply reading from the poll owner. Public key mapping and that's the solution of the exercise so far. So now we're going to complete this function together. Okay, so let's see what we added to register voter here. Okay, you'll note that we added another implicit argument, which is the ECDSA pointer, which is our way to interact with the ECDSA built in, which allows us to verify ECDSA signatures.
00:49:24.540 - 00:50:17.128, Speaker B: This is actually the same interface you're using as interacting with the hash built in. So you see here the Peterson pointer, and we're going to be using it to evaluate hashes, which you're also going to see it right here below. So first of all, we're verifying that the poll is initialized by verifying that the poll owner is not zero. If the poll owner is zero, then we're failing this line and we've no hope to complete the execution of registered voter correctly. And now we're verifying the signature. But first of all, signature over what? So what does the poll owner have to sign on? So he wants to allow a given voter into a given poll. So the message which is signing on consists of the poll id and the public key of the voter.
00:50:17.128 - 00:50:49.368, Speaker B: So in ECDSA, you first hash the message and then you're signing it. So here the first step is hashing the actual message. So now we call a library function, which we imported way before when we just started showing how to write contacts. Hash two, which is a hashing that takes two values and return two arguments and returns one value. This is why it's called hash two. And it takes one implicit argument. You see the curly brackets again.
00:50:49.368 - 00:51:44.532, Speaker B: And this implicit argument is the Peterson pointer, which we get as a parameter, as an implicit argument to register voter. So we're passing the Peterson pointer as a way to allow hash to execute, to actually evaluate hashes. And in the explicit arguments, we actually send the values that we want to be hashed. Okay, so hash two is a function that takes two explicit arguments and one implicit argument, which is called hash pointer. And we're simply substituting the Peterson pointer we got for register voter instead of the hash pointer. So now we have the hash of the message and then we're ready to verify the signature. So to verify the signature, we'll simply call calling the library function, verify eCDSA signature.
00:51:44.532 - 00:52:37.480, Speaker B: And what does this function expect? Sorry, it needs the message, the hashed message, the public key. Now which public key? Not that of the voter, but that of the public key owner. It's the public key owner who should have signed the public key of the voter. So the message, the public key of the owner and the supposed signature, the r and s that we got from here. So right now we basically implemented the rest of the function. If we managed to pass this line, this means that the signature was valid and the poll owner indeed allowed this voter to vote on his poll. So actually it was three additional lines from our side to support signatures, hashing and signatures.
00:52:37.480 - 00:53:05.824, Speaker B: And now that we have the register voter function, we'll show you something else. A view function. So now note the new decorator. The view decorator. This is an example of a function that is not allowed to change the state, but only to read from the contract. And you'll see again our favorite implicit arguments. And this function takes one explicit argument, the poll id.
00:53:05.824 - 00:53:50.160, Speaker B: And it returns two values, the number of no voters and the number of yes voters. So get voting state, as the name suggests, should show you the current state of the vote. And now we're leaving it to you guys to implement the rest of the function. Eventually, you're returning those two values. Note, I think it's the first time that we see a function that returns a more complicated object than just a single felt, a single field element. Here we're returning a tuple, a pair of elements in general. Now we have the ability to return structs and arrays, but here you just need to return a pair of the number of no voters and the number of yes voters.
00:53:50.160 - 00:54:24.430, Speaker B: So you have five minutes to fill in the body of getvoting state by reading the voting state storage variable, which we defined initially twice. So take five minutes for this exercise. Feel free to also ask questions about the implementation of registered voter. You'll have your chance to play with the signature verification logic in the next exercise, but feel free to ask about that as well. Okay, so please take five minutes and we'll be here.
00:55:01.710 - 00:55:06.654, Speaker A: So there are a few programming questions. Ariel, if you want to take a look and answer.
00:55:06.772 - 00:56:16.418, Speaker B: Yeah, maybe I'll take this one. How do we know which implicit arguments a function needs? Sorry, again, I'm giving you the answers way before I want to. There's no implicit arguments that a function needs. But let's say that the only thing you need to really know is that if you want to access storage variables, you need those three, the syscall pointer, the rancheck pointer, and the Peterson pointer, which allows to compute the hash. The reason behind it, and this is further explained in the tutorials, is that you need to compute the address of the storage variables, which is basically the hashing of the keys. So that's why you need the Peterson pointer, but I won't get into it more than that. And for example, if you want to know, how did I know to add the ECDSA pointer here? Well, if we look at the signature of the verify ECDSA library function, which we're not showing here, we're only showing how to apply it.
00:56:16.418 - 00:57:02.850, Speaker B: Then you'll see in its definition that it's expecting one implicit argument which is named ECDSA Pointer. So the reason it didn't complain here is because I had an argument which is named ECDSA Pointer. So behind the scenes it was automatically passed to verify ECDSA signature. But this mechanism is explained how Cairo works tutorial. We can link to it. I'm pretty sure there's a link in the notion document, but yeah, once you see the signature of this function, you know what implicit arguments it is expecting. Okay.
00:57:02.850 - 00:57:41.760, Speaker B: And we have access to this pointer because in the very beginning we declared this built in. So if I go way back, then you will see that I declared three built ins, the Peterson, the rain check, and the ECDSA. So this means that I have access to the ECDSA pointer. So that's why I'm allowed to have the ECDSA pointer here. Okay, I see. Compilation error. Maybe I leave it to Yoni because I can't really compile stuff now.
00:57:41.760 - 00:58:36.302, Speaker B: I'm not sure if it is on your code or on the code described in notion. The code in the notion should compile. I deployed those contracts just before the workshop, so unknown. Identify ECDSA pointer okay, it seems that you sent the pointer to the verify ECDSA signature. I'll let you only look over it more explicitly because I don't want to waste time live on compiling this, but something looks weird here. You need to specify which value you pass for ECDSA pointers. So when you're calling the verify ECDSA signature you need to do something like what was done here.
00:58:36.302 - 00:59:09.510, Speaker B: So you need to say what value you're giving ECDSA pointer. So if you would have written EcDSA pointer equals this ecDSA pointer, then things would have compiled, but right now it's kind of missing. You said you want to pass an ECDSA pointer but didn't give it a value. So I think that's the issue. And I didn't give it a value here. And it compiles because the name of the formal argument is exactly like the name of the variable that I have already defined. So since the names are equal, it is passed automatically.
00:59:09.510 - 01:00:07.200, Speaker B: So I could either not mention it at all or just say ecdSA pointer equals ecdSA pointer. Are there any more? Did you define the implicit argument ECDSA pointer? So no, it is an implicit argument for the register voter function, and I have access to it because I declared that I'm going to use the ECDSA pointer initially note that this is an external function, so nobody calls this function inside the code. This is the way to interact with the contract. So somebody is calling register voter from outside. And here I'm going to have access to the ECDSA pointer. I think that was it with the programming questions? Okay, did I miss something?
01:00:09.250 - 01:00:18.670, Speaker A: No, I think you did it. There was one question like why do we need Cairo? To generate a computation trace.
01:00:19.590 - 01:00:21.540, Speaker B: Why do we need Cairo for what?
01:00:22.150 - 01:00:28.500, Speaker A: Why do we need Cairo? To generate a computation trace. Why do we need Cairo? To prove a program.
01:00:28.870 - 01:02:07.166, Speaker B: Okay, you can prove the execution of a program in any language, but most languages were designed for the purpose of executing code in, for example x 86 architecture or whatever your favorite cpu architecture is. And when your purpose is entirely different, when you don't really care about optimizing execution, and what you really care about is optimizing making life easier for you. When you're proving that the program executed correctly, then your considerations are entirely different. And there is no reason to force yourself to use the in some sense wrong architecture for this, because x 86 was not designed for proving execution, it was designed for execution. So this is why we eventually settled on a completely new architecture to make proving to optimize the proving process in general. So both for efficiency, mostly for efficiency, and the entire architecture behind Cairo. If you're interested in how exactly it was designed and why certain design choices were made the way they did, then I definitely recommend in looking into the Cairo white paper, which is Marfiet parts.
01:02:07.166 - 01:03:10.574, Speaker B: But if that interests you, then it's definitely the way to go. And is there a tutorial for those who never coded but want to write contracts in Cairo? I mean, hello, the low stocknet tutorial should take you hand by hand in writing. Mean of course it is easier if you have some experience from other types of programming, not necessarily smart contracts even, but even if you don't, then you can do it step by step. I'm guessing it will probably take more time, but yeah, I don't think it's impossible. And if you feel like we're going too fast and you have some questions, then please ask. But you can always take the hello. Stocknet tutorial offline or watch the recording again and ask questions on our discord.
01:03:10.574 - 01:03:47.660, Speaker B: We'd love to help you with the process. Yes, a Cairo contract can call another Cairo contract. We'll look into that later. We actually have an example. So Henry, how are we on times?
01:03:48.670 - 01:03:50.300, Speaker A: I think you can move forward.
01:03:51.150 - 01:04:39.930, Speaker B: Okay, so let's move forward. So I'm reminding you guys you wanted to implement the get voting state, which tell us the current status of the votes. And basically we're just reading from the same storage variable twice. So we had the voting state storage variable, and we're reading under the key poll id and zero and poll id and one, we call that it's a mapping between a poll id and an option, a possible option to the number of voters. So we get the number of no voters, the number of yes voters, and we're simply returning it. Nothing too surprising in this regard. Okay, and you'll note that we're not updating any storage variable here, so we're consistent with the view decorator.
01:04:39.930 - 01:05:45.006, Speaker B: Okay, next, now to the next function, which is probably the primary logic of this contract, the verify vote function. So this is the declaration, and what this function is receiving is the poll id, the public key of the voter, the vote, the possibility that he wants to vote for, and the supposed signature, two values, rns, which now represent the signature of the voter, public key of the voter itself and not the poll owner. So now it's the voter signing on a vote and submitting his signed vote. So there are several verifications to do here. So the first verification we did for you here, we're verifying that he voted for a valid option, either zero or one. So the way to do it is simply asserting that this multiplication is zero. This multiplication will be zero only when vote equals either zero, in which case the left hand side would be zero, or one, in which case the right hand side would be zero.
01:05:45.006 - 01:06:14.138, Speaker B: Either case the multiplication would be zero. So once we verified that the vote itself is legitimate, we have to first of all verify that this voter is allowed in the poll. Second, that he hasn't voted yet. So we had a storage variable for that. And finally, we need to verify his signature. Now think. Try to take our previous exercise involved with signature and think.
01:06:14.138 - 01:07:26.570, Speaker B: What is exactly the message that the voter should have signed on in order to vote? And try to mimic what we did before using verify ECDSI signatures. So there are three things you need to verify here, and you now have 15 minutes to implement the rest of the function. So I'll leave the presentation on this thing, this screen, and over to you, Henry. It's getting way too cold. Okay, no problem. Feel free to ask. Afterwards.
01:07:26.570 - 01:07:39.158, Speaker B: I'm looking to see if there are any interesting questions that we missed, but I don't think there are.
01:07:39.184 - 01:07:45.520, Speaker A: Did we answer the one from Gilbert? Can a Cairo contract call other Cairo contracts? What would that look like?
01:07:46.630 - 01:07:50.082, Speaker B: We'll see it in a bit. That's actually after we'll finish.
01:07:50.216 - 01:08:04.470, Speaker A: Surprise. Somebody asked if we can manage negative numbers in Cairo.
01:08:04.890 - 01:08:05.960, Speaker B: I think we.
01:08:07.290 - 01:08:16.706, Speaker A: The question specifically was, can I verify competition involving negative numbers? Will there be an issue with field elements?
01:08:16.898 - 01:09:17.520, Speaker B: Okay, yes. So you need to define negatively, properly, because unlike Ethereum or EVM, the basic type in Kyo is a field element, and there are no notions of negative numbers in a field. There are only function between zero and a very large prime. But you can interpret those numbers as being positive from zero to the prime divided by two. So the first half of the numbers, you can call them positive, and the second half you can call them negative, and then you can be consistent with that choice. We're elaborating more on that in the how Cairo works tutorial under the section of Rangex. So I recommend that you go there to understand exact issues.
01:09:17.520 - 01:10:13.920, Speaker B: But I will also say that in addition to working with field elements, you can also work with UN 256, which is a library in Cairo, which you can import and walk with UN 256, where you can check whether one is bigger than another, et cetera, et cetera. It will be slightly less efficient because a unit is represented. A unit 256 is represented using two felts and not just one. So you shouldn't do it unless you need to. But it's an option. And I would recommend reading more about Range X to understand exactly how we handle negative answer negative numbers. But the short answer is yes, we can handle negative numbers.
01:10:17.990 - 01:11:27.494, Speaker A: So there's a question that I find interesting, actually. Are there ways for community members to contribute to Starknet, Cairo, Starkx code and repos? I'll let Ariel answer that. Also in a bit. From the point of view of Cairo code, there's an effort led by open zeppelin to develop standard contracts that are like, say, the ERC 20 in Cairo, ERC 721 in Cairo, and so contributing on that front, basically porting smart contracts that are very common on Ethereum, that have been forked a lot, and porting them to Cairo is very useful. I'd be very happy to see somebody port a liquidity mining contract such as the one used by synthetics. I'd be very happy to see people port governance frameworks such as Aragon's or the compound governance framework to Cairo. And if there are things like that that you'd be happy and willing to work on, do reach out.
01:11:27.494 - 01:11:35.100, Speaker A: We're always curious to hear who is able to do these kind of things. Ariel, do you want to add something here?
01:11:36.110 - 01:12:30.042, Speaker B: Yeah, I can add something. So in Starknet you can actually get involved without anyone's permission. So any idea for a cool smart contract or a project or a web3 project that you have in mind, you can just start implementing it and let your imagination go nuts because all the gas limitation from Ethereum no longer constrain you. Many more ideas are possible. We have a very nice project by one whose nickname is guilty Gioza, which does physics on chain, basically solving differential equations and motion equations where the computation is actually done on chain. So I think that's very cool. And he only got into it because that's something that interests him in general.
01:12:30.042 - 01:13:19.798, Speaker B: And now there's an option to actually do it and implement a prototype for full game or physics engine on Starknet. So any cool idea that you might have, then yeah, you should definitely contribute. We of course, welcome also any documentation effort and being active in the community, active on the discord. It could be answering questions, it could be participating and giving insights about research questions that we have, or any suggestions regarding revolving tooling, be it our block explorer or the new wallet, anything. Any input from the community is definitely valuable.
01:13:19.974 - 01:14:11.738, Speaker A: Valska is asking, can we also, with tutorials like suggesting simplifying language to explain things for newbie like Ariel, say, you don't need to ask our permission to do that, but it is very valuable if you do. So yeah, do write articles, publish blog posts, and vulgarize what it is we're building, because there are a lot of concepts that are a bit different than the way they work on bitcoin or ethereum. And I agree with you, we can do a lot of simplifying and a lot of explaining, and if you want to write content on that, do that. That's very valuable for us. And yeah, you partially answered the question. Would you recommend getting familiar with solidity before starting in Cairo and Starknet ecosystem? I don't know. It depends on what you want to do.
01:14:11.738 - 01:15:05.770, Speaker A: To be honest, I think it's worth it to have a notion about what solidity is and how it works and how you manipulate assets from the l one chain, because you'll need to manipulate them at some point. But the thing is, you probably should learn these high level concepts without spending too much time on them, because there's a lot to learn solidity too. And if you wait to be a solidity expert to move to Cairo, it's going to take you some time. So moving to Cairo right now is also a great opportunity. Actually, you were mentioning guilty gioza. I've met various other developers who mentioned recently. Yeah, I'm more confident and fluent in Cairo now than I am in solidity.
01:15:05.770 - 01:15:09.680, Speaker A: So there's a lot of precedent for that.
01:15:11.010 - 01:16:09.630, Speaker B: I'll say that the short answer is definitely Cairo. Who even cares about solidity now? But the long answer is it will probably be helpful if you have some notion, some basic principles of smart contract development before going into starknet, because this is actually something that is kept throughout all blockchains, this notion of smart contacts and interacting with. So I would probably take Henry's advice and get some very basic familiarity before jumping into the sparknet tutorials. But it definitely doesn't require to be a solidity expert to go into Cairo. I am much less fluent than Henry in solidity probably, and I feel comfortable around Cairo.
01:16:10.390 - 01:16:56.720, Speaker A: Yeah, and I agree 100% with you. I think the most important thing is writing smart contracts is a bit different than writing different kind of programs. And this logic, like how you have a shared state, people can access it, have functions that modify it, like this whole smart contract. The concept of a smart contract as a programming object, I think it's valuable to have it, but you can learn it from Cairo or from solidity. And this is very much the same. And I think it's good to have an understanding of how you store assets on solidity. But manipulating ERC 20 and ERC 721 is not that difficult, I'd say.
01:16:58.150 - 01:17:00.260, Speaker B: How are we on time, by the way?
01:17:01.030 - 01:17:04.946, Speaker A: I didn't measure it, but maybe we can move forward with the I think.
01:17:04.968 - 01:17:35.920, Speaker B: We'Ll move forward and then address other questions. Okay, so reminding you guys we're in the verify vote function and we need to do all the verifications to make sure the vote is legitimate. Okay, so the first thing that we want to verify is that the voter is registered to the poll. So to do that, we're simply reading from the registered voter storage variable under the key poll id.
01:17:37.730 - 01:17:38.542, Speaker A: And the public.
01:17:38.596 - 01:18:17.162, Speaker B: Key of our voter, of the voter who's currently trying to vote. And we're verifying that the value written there is nonzero. Recall that we're already maintaining this in the register voter function. So if register voter was called before voting, this assertion would pass, the value would be nonzero. And we'll move over to the next check. Okay, the second check is that the voter hasn't already voted. So now we're reading from the voter state under the key poll id and the public key of the voter, and we're verifying that the value is zero.
01:18:17.162 - 01:19:08.682, Speaker B: So first of all, we're verifying that the voter is allowed in this poll. And the second we're verifying that the voter is not attempting to vote twice. Now the third and last thing that we need to verify is that the signature is valid, that nobody is attempting to vote in my name. So what should the voter assign on? So unlike before, now what was assigning on is the poll id and the actual vote, the actual value of what I want to vote. So the message now that we're signing is the hash just like before, of the poll id and the vote value. So this could be zero or one, and this is just the poll id. And now we call verify ECDSA signature just like before, with the message now a hash of the poll id and the vote, the public key.
01:19:08.682 - 01:19:54.586, Speaker B: Which public key? Now the public key of the voter, not the owner, and the values that we get as arguments to this function, r and s, which represent the ECDSA signature. So this was all the things we needed to verify under the verify vote function. So now we know that if we pass verify vote, everything is legitimate and we can update the state. So now we're ready to implement the actual voting. Okay, so this is an external function, vote, and you will see that it calls the verify vote function, which wasn't an external overview function. I'm showing it to you again, sorry. Just verify that.
01:19:54.586 - 01:20:35.494, Speaker B: This is a helper function. You see that there is no decorator around it, so it's just used internally by our function. And now when we implement the voting logic, the first thing that we do is call verify vote with all the parameters that were sent to vote. And if we manage to pass this line, it means that the voter is indeed allowed to vote. And now we need to maintain the state. So what we need to do is first update the voting state, change it according to the value that the user voted. So now we read how many people voted for the option that I wanted to vote for.
01:20:35.494 - 01:21:25.894, Speaker B: So in this line we're reading from the voting state, which is a mapping between a poll id and the possible option to the number of voters. So I'm reading this storage variable from the key, which is the given poll id and the vote that I want to vote for. So if I wanted to vote one, I'm reading other poll id, and one, if I wanted to vote zero, then it would be zero. So this is the number of voters who voted for my option. And now I'm updating the voting state storage variable, and I'm setting the number of voters for this option to be the previous number of voters for this option plus one. So first of all I'm reading and then I'm increasing it by one. And then I'm updating voter state as well.
01:21:25.894 - 01:22:35.466, Speaker B: Note that this is very important to make sure that I won't be allowed to vote twice. So now I'm updating the voter state storage variable and I'm setting the flag to one. So now this voter public key, we have an indication that he already voted in this storage variable. So now if I try to call vote again with the same public key, verify vote will fail because one of our checks was to look in the voter state storage variable and verifying that what was written there was zero and not one. Okay, so we've actually managed to vote and now we're going into our last part, which is interacting with other Cairo contracts, other starknet contracts, which we call composability. So let's now skim to another Cairo contact, which is a dummy contact that is supposed to record the results of different polls. So again you will see declaration of built ins imports a storage variable and two functions, one external and one view.
01:22:35.466 - 01:23:22.266, Speaker B: We already know what that means. One is allowed to change its state, one isn't. And we have two functions, record, which takes a poll id and the result, and simply updates the single storage variable that we have, which is a mapping between a poll id to the result. So every poll id we remember whether the result was zero or one. And we support two functions, record and get poll result, which simply reads from the storage variable and returns the result. Okay, note that this is a dummy contact because there are no verifications here. Anybody can call record and specify whatever he wants, regardless of signatures and voters and anything like this.
01:23:22.266 - 01:24:21.326, Speaker B: So this contact is actually here to support, to demonstrate composability. And it's definitely a good exercise for you guys to take it further and think about how would you add the correct verifications in order that no unpermissioned entities would be able to call record that only the poll owner would be allowed to record a result for his own poll, for example. Okay, so how do we interact with this dummy contract? We're adding three things to our voter contract. So the first thing is we're adding another storage variable. This storage variable is a single value and not a mapping. How do I know this? We use the same syntax of a function, but now you can see that the function takes no arguments. This means that it's not a mapping from a key to a value, but just a single value.
01:24:21.326 - 01:25:01.078, Speaker B: And this value is the address of the result recorder contact. Okay, second part I'm adding a constructor. So this is an element we have not seen before. And you can see the constructor decorator above. And the constructor takes an argument, a single value, a single parameter, which is the address of the result recorder contact. So we're giving the voting contact constructor the address of the result recorder. And what the constructor does is simply storing this address in storage variable.
01:25:01.078 - 01:25:39.462, Speaker B: So now we have this address stored to be used whenever we want to actually record a result. And the last thing that we want to do is define the interface of the other contacts that we're going to use. So you see again a new decorator, the contact interface. And now you can see the definition of a new namespace which we call result recorder, which corresponds the functions that appear on the result recorder contract. And we see a declaration of one function. This namespace should contain the signatures of the functions that we're going to use. So we're going to use record.
01:25:39.462 - 01:26:19.640, Speaker B: And this was the signature of record. It accepted a poll id and a result to record. So that's the three elements that we're adding to the voting contract in order to be enabled to interact with the result recorder. Okay, so now let's see how exactly we can interact with the result recorder. We're doing it through a new function which is called finalize poll. So this is a function in our voting contract which takes a poll id, the poll id that we want to finalize. Okay, so what is basically being done here? Sorry.
01:26:19.640 - 01:27:08.670, Speaker B: First of all, we're getting the result recorder address. So we're reading from the storage variable that we kept for storing the address. You can see the tree takes no parameters because this isn't a mapping. Then we read the voting state. So now we know the number of no voters and the number of yes voters. And now we compute the result locally, so the result is zero if the number of no votes is greater than the number of yes votes and one otherwise. So we can call the is less equal function which does exactly that, returns one if the left argument is smaller or equal to the right hand argument, and zero if the opposite case holds.
01:27:08.670 - 01:27:55.140, Speaker B: So using this comparison we can know the result of the given poll and then we can actually record this result. Here you will see another feature, which is the short string syntax. So let's focus on this line for a bit. You can see that here result was zero or one, but here the result is the chiral representation of either the string yes or the string no. So if result was zero, this multiplication is zero. And here we have only the string no. And if the result was one, then this multiplication is zero and we have only the string yes.
01:27:55.140 - 01:28:51.966, Speaker B: So felts are basically numbers up to a very large prime, which is almost 32 bytes. So you can put strings up to 31 characters inside a single field. So since yes and no are both less than 31 characters, we can simply use this syntax and transform the result from zero one to the representation of yes or no. And the reason that it is important to do this because recall that the default value for all storage variables is zero. And we need to be able to differentiate between a poll which was finalized with a result no and a poll which was not yet finalized and holds the value zero because this is the default value. So this was kind of important. And once we have it, we can simply call the result recorder.
01:28:51.966 - 01:29:35.966, Speaker B: So the way we do it, we use the same word we defined for the namespace, the same name we defined for the namespace and calling the function that we declared in the interface. So we're simply calling record as if it was a function that we have locally. So we're calling it, but we're also adding the address of the contract. So while record here takes two arguments, here, when we call record, we're sending three arguments because the first argument is always the address of the called contract. So this is it. We read the contract state, the voting state. We checked what was bigger, the number of yes votes or the number of no votes.
01:29:35.966 - 01:30:23.950, Speaker B: We used a little trick to transform one and zero to some numbers that represent some different numbers that represents yes and no, and sent this result to be recorded to the result recorder contact. So this was composability. This was all you need to know in order to interact between two stacknet contracts. And now take five minutes to try it yourselves and add a verification that the poll wasn't already finalized. So this is the finalized poll function. So we don't want to allow finalization of a poll that was already finalized. So the way to do it, let me remind you that our result recorder contract had two functions.
01:30:23.950 - 01:30:56.730, Speaker B: One was record, which we already used, but we also had the get poll result, which returns the result of the poll. So think about how to use this function in order to verify whether the poll was finalized or not, and then interact with the result recorder contact by calling this function. So take five minutes and in the meantime we'll answer questions. Okay, so over to you, Henry. I'll leave the screen.
01:30:56.800 - 01:30:57.622, Speaker A: Thank you.
01:30:57.776 - 01:31:05.950, Speaker B: The finalized poll function. So I'm reminding you, the exercise is to add a verification that the poll wasn't already finalized.
01:31:10.230 - 01:31:12.338, Speaker A: So it's five minutes now, right?
01:31:12.504 - 01:31:13.220, Speaker B: Yes.
01:31:14.550 - 01:32:19.590, Speaker A: So there was a question. What is the difference between Starquare and immutable X? How difficult is it to build functions of immutable x if we chose to work on Cairo directly? So there are two questions there. I'll address the second one first, how difficult is it to build IMO tabledex directly on Cairo? I would say that we can't really give you an objective feedback on that. We wrote the software that runs imitabledex, so for us, of course it would be easy for you. I would say it's possible to write an NFT trading engine on Starknet now. It really depends on your level and proficiency with Cairo, but for sure this kind of marketplace will emerge on Starknet. Now what's the difference between Starkware and imitable x? So Starkware is a company that developed stark proving systems.
01:32:19.590 - 01:33:21.900, Speaker A: First we developed Cairo, and with Cairo we first developed one system which is StarkX, which is an execution, a trade execution engine, right. So it allows you to trade ERC twenty s or ERC 721. And it is a standalone application and it has various high profile users such as immutable X for ERC 721 or Sorre for ERC 721. And for ERC 20 we have Dydx diversify using it. Right. So emutable X is a company using a product by Starquare and the focus of today's presentation is Starknet, which is another project we're building on. I don't want to call it a product because it's not like something that is for sale and it's not something we will operate as a product, it's a tech we're building and that will eventually be operated outside our.
01:33:21.900 - 01:33:56.070, Speaker A: Yeah, I don't know if that answered the question that clears up something. And if you have questions, if you want to add something. How can we deploy Cairo smart contracts to Starknet? We'll cover it in a few seconds. Is it possible to extend Starkx application with Starknet smart contracts today? Not really. Starkx is a standalone application, but eventually you may be able to interact with Starkx on Starknet though I can't comment about this because. Still being researched.
01:33:56.970 - 01:35:07.580, Speaker B: So this is actually look forward for a post that will be released very soon and discuss these matters. But right now Starkx is a standalone Cairo program which is not written in a smart contract syntax and we're simply proving the execution of it. And this allows us to maintain the state of immutable X on Ethereum without doing the transactions on Ethereum. So it's a separate product than Stagnet, which is a layer two for Ethereum and has its own state, and the ability to deploy smart contracts which interact with each other, et cetera, et cetera. I think we missed some questions here. I saw why is it called Peterson Pointer? Because we're using the Peterson hash function and to understand what exactly it points to. I would read more into built ins in how Cairo works tutorial, but we're using the Peterson hash function, so it's why it's called Peterson Pointerioni already took, sorry.
01:35:07.580 - 01:36:09.662, Speaker B: And okay, I don't think we missed anything, right? No, I think, I also think it's an interesting number. There is actually reasons why this particular prime was picked. One day a post will be written about it, but it is not this day. And I think about x node zero. I'm not sure if the compiler supports this syntax, so it could be as simple as that. And regarding projects already deployed on Starknet, you can definitely come to our discord. I'll mention it a bit in the end, there's repos by openzeppelin which define the account contracts.
01:36:09.662 - 01:36:35.820, Speaker B: There are several projects building on Starknet. Zigzag is one of them, which is an exchange, essentially. There are many interesting starnet contracts which are open sourced, and you can look what they did. This code will probably is a good place to get references. Okay, I think we can go to the answer now.
01:36:36.510 - 01:36:37.260, Speaker A: Yes.
01:36:39.150 - 01:37:13.202, Speaker B: Okay, so, wanted to add a verification that the poll wasn't finalized. So we're simply adding two things in the finalized poll function. We're calling the get poll result, and we're verifying that it's zero. So here the trick that we did with the transforming zero one to yes and no is helpful because if the result was no, then it is different than zero. So here we had this assertion, but now we're calling a new function. Before we only called record, but now we're calling get poll result. So we also have to declare it under the namespace.
01:37:13.202 - 01:37:52.610, Speaker B: So we're just adding the signature here, we're adding get poll result. And these two additions allow us to interact with this second contract, second function of result recorder. So that's it. With those two additions, you simply verify that the poll wasn't already finalized. Okay, now I'll talk a bit about deploying contacts. Okay, this is Voyager, the block explorer for Starknet. And I already deployed a contact, so it will save us some time.
01:37:52.610 - 01:38:28.650, Speaker B: And this contact is actually our voting contract. You can convince yourselves here this contact is verified. So just like Etherscan, you can deploy a contract and then verify it by sending the source code. So this contract is verified. And you can see that this source code matches to exactly what we discussed so far. And you can see that this contract has three transactions in its history. The first one is deploy, and this one corresponds to the initialization of the poll.
01:38:28.650 - 01:39:08.300, Speaker B: And this one corresponds to registration of a voter. Okay, so you can see here that I initialized the poll with the id 2022. This is the public key of the poll owner. And you can see that this transaction was registration of voter to this poll. So this is again the poll id, this is the voter that I registered and this is the signature of the poll owner. So here we have two transactions that already passed. And if we go to read contact, we see our view functions, which view function which is get voting state.
01:39:08.300 - 01:39:46.070, Speaker B: So let's just see the current voting state. And in the meantime I've already prepared some values for my vote. Okay, so let me show you how to vote now. Okay, so in write contact we actually see all the functions which allow us to change the state. So to interact with a contact, I'm going to specify all our parameters. So I have my voter public key. I came prepared.
01:39:46.070 - 01:40:05.280, Speaker B: Okay, it completes me. Excellent. I don't remember which one is it, so I'm going to have to check. Okay, it's the one starting with eight. Okay, and this one is the one starting with seven, six, one.
01:40:06.130 - 01:40:07.070, Speaker A: Excellent.
01:40:07.490 - 01:40:49.302, Speaker B: So this is supposed to be the signature of this public key on, remember, what does the voters to sign on? So he's signing on the poll id and the value of the vote. So it's a signature for 2022 and one by this public key. So let's send the transaction. Okay, so now the block explorer is interacting with starknet and actually sending the transaction. Hopefully it will do so quickly. So in the meantime, there are two ways, basically you can interact with starknet. One is through the block explorer, which has this nice UI and you can verify contacts, et cetera, et cetera.
01:40:49.302 - 01:41:38.680, Speaker B: And you can also interact with starknet using Gower Cli, the command line interface which basically allows you without any fancy Gui to send transactions, read contract, write contract, whatever you want basically, and I refer you to the tutorials and documentations to see how exactly to use the CLI. We won't be able to get into it now at least. Okay, so you see my transaction was sent. Let's see the transaction. Oh my God, that makes me sad. Let's refresh, okay, for some reason I don't have the data yet. Let's copy the hash and maybe show you it in the Cli.
01:41:38.680 - 01:42:28.280, Speaker B: I need the hash of the transaction. Okay, you are not seeing my screen now, so let me share my entire screen. Okay, I hope you're able to see my screen now. So let me just demonstrate. So that's the way you use the CLI once you've installed the right package. So, for example, if I want to see the status of my transaction, transaction status, and I give it the hash as a parameter, and let's see the status of the transaction. Let's see who will win, the block explorer or the ClI.
01:42:28.280 - 01:43:03.652, Speaker B: So the Cli won. You saw that my transaction is now accepted on L two. This means that the next step in the lifecycle of this transaction is actually being proved on L one. So now I'm working against the go early testnet. So the proof is actually sent to go early and not to ethereum mainet, but it should be proved nonetheless. And now let's see the effect. So I voted on one.
01:43:03.652 - 01:43:32.252, Speaker B: So I'm now supposed to be able to see that the current voting state is one vote for one and zero votes for zero. So let's see, I had a view function. How did we call it? Get voting state. Okay, so let's use Starknet call. Okay, that's exactly what we want to do. So note that before the result was. So that's a call.
01:43:32.252 - 01:44:28.260, Speaker B: This is our contract address and here I'm giving it the compiled contract and the inputs to my function. So I want to know the status of the poll whose id is 2022, and I'm specifying which function I want to use. So get voting state. Okay, so let's copy paste it to see if the status was changed. So it was before. Let's see, what is it now? Okay, the transaction is now also visible on the explorer. Let's see the status of my contracting.
01:44:28.260 - 01:45:33.532, Speaker B: While we're waiting for the answer, let's talk about more things that you can do in the meantime. 1 second okay, so future steps to engage with starknet is definitely go to the Starknet hello starknet tutorial and see about setting up your environment. Installing the Kyolang package. Definitely join our discord and ask us anything about anything from starknet architecture and actually writing code and any ideas of projects you're interested in doing. Let your imagination go wild. There are also a few bonus exercises in the notion document, which I definitely encourage you to do. Okay, we now have our answer back, which is zero, 40, and one for one.
01:45:33.532 - 01:45:53.110, Speaker B: So it's very exciting. I was able to vote on the poll, which I initialized before our meeting. So yeah, now we're happy we managed to vote. We implemented a voting contract. We interacted with another contract. So you should be way happier than you were before this session started.
01:45:53.960 - 01:46:01.556, Speaker A: Congratulations, Ariel. We can still see your screen.
01:46:01.738 - 01:46:31.068, Speaker B: Yes, you see my screen, right? You see the presentation now we can. Okay, excellent. So I think that leaves me with this slide. So thank you very much for participating, and we should definitely engage with our system in any way possible. And whatever you want to ask, we're here to help you. I'm feed the fed on discord, so look for me there. Thank you very much for participating and good luck.
01:46:31.068 - 01:46:37.090, Speaker B: And if you want to stay for a bit more questions, then we're definitely here to answer them.
01:46:37.720 - 01:47:02.896, Speaker A: Wonderful. Thank you, Ariel. There were three last questions we can address. So one was, can I use metamask with Starknet? The answer is not yet. We're working on how to integrate metamask with Starknet. There are a few missing pieces. Specifically, starknet works better with different kinds of signatures than Ethereum signatures.
01:47:02.896 - 01:48:03.448, Speaker A: So we're working to see if metamask can provide that. But in the meanwhile, you can use also Argent X Starknet wallet, which is today the go to wallet to use on Starknet, which will allow you to send transaction and have a smart contract wallet. So it would be really cool to use. There's another question, which is will source code of all contracts deployed to starknet be readable by anyone? Yes and no. So in Starknet, people often confuse zero knowledge roll up with fully private roll up, which is just not the case. So don't confuse the fact that there's zero knowledge in the name with the fact that you can have privacy. You could implement private systems on Starknet, but as is, you shouldn't assume Starknet is private by default.
01:48:03.448 - 01:48:14.240, Speaker A: So the code of the contract you deploy will be visible via other people, by the sequencer, by the proverb, and things like that. And same goes for your transaction.
01:48:17.780 - 01:48:33.560, Speaker B: About sharp. So yes, Starknet does use the shared proverb and actually shares the proof with stock deployments. So the same proof actually handles both the state updates for Starknet and several Starkx applications.
01:48:34.620 - 01:48:55.150, Speaker A: Thank you. I was about to cover that one. And then the last question was, do you have any links to already deployed open source projects on Starknet? And I pointed to the open Zeppelin repo, you can go and check out their implementation of ERC 20 and their implementation of account contracts, which is used by Argent X.
01:48:56.660 - 01:49:11.008, Speaker B: We actually have a channel on Discord which is called introduce your project I think. And just by going to that channel and seeing anything that anyone's published, you'll be able to see a lot of cool smart contracts.
01:49:11.184 - 01:49:31.748, Speaker A: So Jonathan is asking, oh, maybe I can extend Starkx with Starknet contracts given that the sharp is the. No, I don't think it's linked. You're using the same prover. It doesn't mean that they share mean. Correct me if I'm wrong, Ariel, but I don't think this is linked.
01:49:31.924 - 01:49:52.530, Speaker B: Yeah, it's just a way to save costs on the proof, but it's not like the states are related in any way. It's just approving a bunch of different unrelated programs in the same proof, nothing else. So it's only for efficiency purposes, not composability or something of that sort.
01:49:56.100 - 01:50:37.570, Speaker A: All right, so I think we've covered most questions and I think we can close that workshop here off here. Our colleague just posted a link to form. If you can provide us feedback that would be very valuable for us so that we can know how to do things better next time and what kind of other contents you guys need for the future. So be sure to let us know what you think. We'll keep you updated if we have more workshops coming. And until then, happy building.
01:50:38.740 - 01:50:43.692, Speaker B: It was great you guys, good luck. Thank you for attending.
01:50:43.836 - 01:50:48.380, Speaker A: Thank you for your time. Thank you. Bye.
