00:00:02.410 - 00:00:45.882, Speaker A: Thank you all for being here. So just to get this started, by show of hands, who is a starknet developer, and also by show of hands, who is also a rust developer, raise your hands. Okay, we have a few people, so we can have a high context conversation, hopefully. My name is Giorgios, I work at paradigm. I do a lot of rust and a lot of open source. And here today we'll hopefully talk about some of the overlap, the intersections between the two. So the main takeaways that I want you guys to take here is that this is a useful tool, use it.
00:00:45.882 - 00:02:06.382, Speaker A: And there is a lot, a lot of opportunity for using it in the Startnet ecosystem, both for performance, for developer experience, and also for building things faster by having libraries that plug onto each other. Now I will start with a very clear timeline that says, hey, does this actually work? What is this guy selling you? So we've done that in the Ethereum ecosystem. We've already rewritten a big, big part of the Ethereum ecosystem in rust, starting with ethers rs. Before paradigm started working on Rust, which was the RPC integrations, how do you talk to the chain, the queuevalent of this in the Starknet ecosystem, it's the Starknet RS lib, starcly, all of that work. Then we built foundry, which was a testing framework for testing solidity, insolidity, which was very fast, and outperformed others by 310 hundred, 341 x, the highest benchmark was. So we got into testing and we thought, okay, this has a lot, a lot of room for more, getting even better at that. Then while we were iterating on foundry, we thought, okay, what if we have a fast and hookable runtime, the EVM, we want to make it faster such that we can test faster.
00:02:06.382 - 00:03:24.286, Speaker A: We also want a hookable vm, which means that as transactions operate, you can do things and you can customize the functionality. Then after we had the experience with all of this, we went and built a node. And why I'm telling you all of this is because there is a clear, clear mirror in Starknet. We've seen the movie before, and we can do it very well without repeating the mistakes of the past. Then once we got the node, the node involves a high performance database, peer to peer logic, stuff that starknet also needs. Then as we got some maturity and we went on to kind of productionizing our infrastructure, we said, okay, let's rewrite all our rewrites from first principles, trim our dependencies further, improve the performance, and now, most recently, who have also ventured into data indexing, how do you query, how do you get information out of the chain, and how do you then do things with it off chain very fast, all enabled by this guy who today looks like this, and we hope to make him look like this. So how are we going to do that? But before I get into this, maybe let me just further motivate a bit on why are we using this tool? And the first thing is that the rust tool chain gives you everything.
00:03:24.286 - 00:04:09.580, Speaker A: Basically, it gives you a compiler, a formatter, a testing framework, a linter, a lot of other extensions on the toolchain. It is really great. It also gives you a very big ecosystem of libraries that are well tested and well documented. And this is important for people doing things in production, because you cannot deal with zero point x ecosystems. They are all fundamentally unstable. There's also developer productivity, which comes at a cost that we'll talk about in a second, which means that devs really are very productive when they operate in rust, because the rust compiler is a very serious teacher, and it kind of forces you, it beats you into shape, but after a while it prevents you from making a lot of common mistakes. And this is enabled by the border tricker and other things.
00:04:09.580 - 00:04:38.866, Speaker A: The rust language has a culture of documentation inclusivity. What does this mean? It means that no thing is hard, and there's a lot of documentations to make it easy. We mentor people, we talk to people, we split things into smaller scope issues. We generally try to ensure that anybody can contribute and onboard the code bases, no matter how early in their career they might be. And that's important. Performance is a standard thing that you get. You also get efficiency and safety.
00:04:38.866 - 00:05:18.514, Speaker A: This means that rust is a compiled language. It compiles the machine code, it uses LLVM in the middle, so it optimizes a lot of things. It is efficient, which means that it can run on low powered devices, Starknet on Arm or whatever. And also safety means that you don't shoot yourself in the foot like you can shoot yourself in the foot in C or C Plus plus, while also not having a garbage collector let go. And this is a weird and interesting kind of feature set or value prop. Portability means that it compiles to any platform that you want. So in rust, I can compile to arm, I can compile to mips, can compile to risk five, I can compile to really whatever I want.
00:05:18.514 - 00:05:52.214, Speaker A: Like there's many, many targets, and that's very valuable when you want to target Windows, Linux, macOS, all of them together. How many times have people had issues with compiling to a different platform in other languages. In C, for example, people like reimplementing things. It's a weekend and you want to hack on something, let's rewrite it in Rust. But unfortunately, it comes with a steep learning curve, which turns many people off. And my view is that it's a very cheap cost to pay for all the benefits that you get. So now, why rust? In Ethereum, this was the slide a week ago.
00:05:52.214 - 00:06:23.126, Speaker A: Now we have the same slide, but for Starknet, because really the motivation is exactly the same. You get a high performance language for an ecosystem that demands high performance. You have smart contract developers. We have which these are Kaido devs. Here you have Mev use cases. MeV in Cairo or in Starknet is still very limited, but we hope to see that increase as activity picks up. We need indexing, query the data from the chain, Abi, decode the logs, create querable SQL interfaces to them.
00:06:23.126 - 00:07:05.560, Speaker A: All of these things do not exist in production so far, and the list goes on. RPCs like layer twos, layer threes on double starknet, more cryptography, for example. People are already implementing cryptography in Cairo for verification on chain and other things. So the yrust slide that I queued up earlier applies one to one. Here in Ethereum, we had to rewrite everything because there was a big stack of things that accumulated over the years. Starknet caught this early, which means that we have the Python tool chain, we had all the pre rust era, and we have the post rust era, and we didn't have to rewrite too many things because we're maybe like a year in. So the tech debt was not that much.
00:07:05.560 - 00:07:51.406, Speaker A: So how have we done in all of this so far? So there's a lot to add in this slide, and I don't have everything, and the timeline might be a bit out of order. But if you just do a quick historical review of how things were, we had, even before Kyrolang, we had like the first versions of Starkx that were all custom. Then we had Kyropy, which was the whole runtime that was used in Starknet and the sequencers and others. And then eventually, after a lot of discussion, we decided, all right, let's scrap it all. We need performance. We're not fast enough. We also need better, more safe infrastructure.
00:07:51.406 - 00:08:38.206, Speaker A: Python was not good enough at that. So we said, all right, let's rewrite everything. So the first thing that I had heard about was Pathfinder, which was this rust full node implementation by equilibrium labs, then another node also in rust called Papiros, and they all both roughly had the same similar scope, which was, okay, I have a node I want to sync over peer to peer. I want to provide RPC endpoints to people. All of these need to be high performance. They need to be able to service many requests on low resources. And then began the biggest undertaking of all, which was go from this old Cairo that we had, which I'll talk about in a second, a very rusty Cairo, starting with the intermediate representation called Sierra.
00:08:38.206 - 00:09:15.370, Speaker A: And for extra context, Sierra was very much needed because you could not prove failed transactions in Starknet before that. And that was very important for spam and other things. Then we got Cairo 1.0, and that was huge, because Cairo 1.0 got us out of a very bad devex into a devex that we can start to iterate on faster. And we'll see the examples in a second. Then Lambda class entered the chat room where they started building the Rust Cairo VM, which was one of the most exciting things personally, because it was also built to be fast, but also hookable.
00:09:15.370 - 00:10:03.514, Speaker A: And having a vm that's hookable is super important for all the tooling that gets built around it. Examples of tooling could be testing frameworks like the Starknet foundry, which we'll see in a second. It could also be mev infrastructure. It could be anything you want. Many people have hooked on the rusty vms so far in ways we did not expect, and we hope to see more of that here. Then, once you have a whole stack and you have an intermediate representation which is the Sierra, then you think, all right, why do I even need to execute bytecode? Why can I not execute native code? And the Kaido native project was exactly that, which was basically rust bindings on the intermediate representation. And because the entire stack is built in rust, it's very easy, you just consume the intermediate representation and you generate new code.
00:10:03.514 - 00:11:20.402, Speaker A: So what Kaido native does is that it takes some of the Kaido Sierra code and then transpiles it using MLIR, which is one way somebody could think of it is like an evolution of LLVM for machine learning, and it produces machine code, and that's many, many times faster than what you can get even on the rust implementations of Cairo, which is very exciting because you're running native code sequencer, go very fast. Then we had blockifier, which is effectively take a list of Kaido transactions, execute them. This was notably the biggest bottleneck in the Starknet sequencer. Before the transition to the rust stack, basically everything was running on Kaido PI and on Python interfaces, and then blockifier came along, it started using the Rust VM, then it started processing transactions on that. And that's how you saw, or part of how we've seen recently, how Starknet has been starting to do 5000 TPS peaks or more. A tool I'm particularly excited about is Caracal and Cairo Fuzzer, which are built by two security companies. I forget the Cairofuzzer one, Karakal is by trail of bits, which are effectively, again, plugging on rust components that are readily available and giving you very powerful tools.
00:11:20.402 - 00:11:50.350, Speaker A: Caracal is like a static analyzer. It converts, it parses your code, your Sierra code, and then it produces a report of known vulnerabilities. The fuzzer is a fuzzer. So this is what we had. Okay, I cannot bear to look at this. Then we got this, which I realize it might be hard to read, but you can see on the left side, you declare storage variables as functions. There's a res felt argument.
00:11:50.350 - 00:12:24.700, Speaker A: It is very verbose and very. It tries to be python, but it has a go function declaration, like for fun. It has felt fiscal pointer like what the hell is all of this? On the right, I still think it can get better, but on the right you see how every contract it has an interface that's defined as a trait that interface gets implemented. On the code you have things for backwards compatibility. The storage is nicely encapsulated in a struct. It starts to get better. We still have work to do, but it's starting to get somewhat better.
00:12:24.700 - 00:12:58.230, Speaker A: And this gets even worse, obviously. So this is like a simple getter setter contract. But this gets even worse the more you get into. So this is like an Arc 20 snippet. This is how it looks like in Cairo, zero point x. So you need to declare a bunch of functions with no body. Whereas now, and I think people should visit the visit repository to get more resources, now you have strut storage, put all your things there, market as storage, and then implement your thing on the right, it looks very rusty.
00:12:58.230 - 00:13:42.260, Speaker A: Again, it could get better, but I think we're already on the right path of using. Nice semantics that developers are happy with using. And also a big shout out to the Kaido one developers, because it has a border checker under the hood. It has a lot of clearly rust inspired features in it, although in some places it deviates. For example, the Ed contract state thing does not exist in rust, and people have opinions and the languages can evolve. So the main takeaway is that we use rust for performance and safety in a mission critical system. I would say that Starknet is, or should be thought of as one of them.
00:13:42.260 - 00:14:52.040, Speaker A: And we can also take inspiration from the Rustlang frontend design to build programming languages that are nice and easy to consume. If you look at the stack overflow developer reports, Rust is, if not the most loved, the highest growing language by programmers in terms of how much they enjoy writing it. Somebody I remember had said that I would rather rewrite the entire crypto stack in rust than do the C code or whatever, so there is some signal there. So what are we doing for that? As Faradigm, we're collaborating with the software mansion team to produce a tool called Darknet Foundry, part of the main foundry toolkit, which is spearheaded by the software mansion team with support from the core Foundry team, and it's what you would expect. Foundry is a testing framework for EVM contracts, so far with other tools in it. Starknet Foundry is that, but for Starknet, it supports a lot of things I don't need to talk about right now. There's a workshop happening right after this talk by the software mentioned team that if people are interested, you should attend it, and I would highly endorse it.
00:14:52.040 - 00:15:16.320, Speaker A: Performance wise, Starknet Forge is on par with Cairo test, obviously because they use the same vm. But now that we're in reducing parallel fuzzing, we should be even faster. Has 25 contributors. We want to grow this. If you're a rust developer or if you're not, learn rust and contribute. And yeah, I think I'm right on time, and I don't know if I have time for questions. Thank you.
