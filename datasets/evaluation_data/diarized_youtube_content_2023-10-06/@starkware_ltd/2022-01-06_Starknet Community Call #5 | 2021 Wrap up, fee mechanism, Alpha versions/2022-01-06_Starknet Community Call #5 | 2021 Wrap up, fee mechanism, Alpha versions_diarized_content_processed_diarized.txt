00:00:00.730 - 00:00:39.180, Speaker A: As usual, I just need to fix the ringing bell. All right. Okay. So now, Tom, I think. Yes, I can hear you. Are you also connected on the Discord channel?
00:00:41.090 - 00:00:41.840, Speaker B: No.
00:00:42.290 - 00:00:57.780, Speaker A: So it would be great if you can also connect on the Discord channel. That way people can hear you there too. And if you have a link to your slides that we can share in discord, that would be awesome too. Please. Okay.
00:00:58.310 - 00:01:05.300, Speaker B: Yeah, for that I need to bring my earphones, otherwise we'll have echo. So 1 minute, okay.
00:01:07.590 - 00:01:11.540, Speaker A: Sure. Okay.
00:01:16.070 - 00:01:16.820, Speaker B: You.
00:01:27.390 - 00:02:03.000, Speaker A: Okay? So for all of you on discord, Tom is connecting. He's on Zoom right now, but he'll be with us in a short while. In the meanwhile, I want to say a few things. So first of all, thank you all for being here. It's great to see that many people engage and curious about what Starknet is and involved in the discussions around it. I want to wish you all a happy year. 2022, may we all going to make it.
00:02:03.000 - 00:03:21.722, Speaker A: I think it would be also a good opportunity to maybe make a small retrospective of what happened in 2021 for starknet, because there's a lot of work ahead of us. But it's always nice to look back at what was accomplished on the year ago. And it turns out that the initial roadmap to Starknet was released about a year ago, where we initialized our spaces. So basically starknet planets, then constellations, universe. And it's really cool to see that in about a year. In about a year we've been able to move from concepts on paper, a medium post with strong technical backings, of course, to a decentralized. To a network that is not yet decentralized, but that allows you to write smart contracts that are arbitrary logic, that allows you to manipulate assets on l one in a trustless way.
00:03:21.722 - 00:03:55.862, Speaker A: So I think it's good to get a pat on the back before seeing what's coming next. So I think Tom is ready. Tom is asking to be a speaker. Let's see. I think, Tom, you can talk, we can hear you. Wonderful. So we've shared the slides on the community call channel on discord.
00:03:55.862 - 00:04:02.880, Speaker A: You guys can follow the slide there. And Tom, I'll let you take it from there.
00:04:05.250 - 00:04:35.000, Speaker B: Ok, great. Hi. Hello everybody. So, as Enri said, I will share a little bit our thought and our initial implementation of the fee mechanism on Starknet. And after that we can also discuss a little bit the upcoming alpha versions and what they will include. I think. I'm not sure where I will be able to see questions.
00:04:38.830 - 00:04:47.290, Speaker A: So I will monitor the questions. I will monitor the question both on Zoom, but also in the community call channel on discord.
00:04:48.110 - 00:05:07.790, Speaker B: Okay, perfect. So I will share my screen. Yes, let's do it. Yeah. So now you can see my screen.
00:05:11.010 - 00:05:12.080, Speaker A: We can.
00:05:12.450 - 00:06:14.498, Speaker B: Okay, great. So before we dive specifically into what first version of fees we will have on Starknet Alpha, let's discuss briefly what are, generally speaking are the transaction costs in a validity roll up. So I like to think about it as two components. One is the regular transaction cost, right. We have it on Ethereum and basically on every blockchain, which is the computation, the storage and the transmission over the network. In Ethereum, it translates to the computation is just the gas cost of various opcodes, the storage cost is the gas cost of s store or s load, and the transmission over the network is the cold data cost per byte that we have on Ethereum. This is also included in a transaction in a validity roll up.
00:06:14.498 - 00:06:54.590, Speaker B: The other component, which is somewhat unique to an l two solution, and those components are specific to validity roll up is the l one footprint, basically the call data that is sent to l one as a result of the transaction, alongside the proof. Right. And what this call data includes, includes, first of all, the messages that were sent from l two contracts to l one contracts. So for example, if I want to transfer my tokens from Starknet to Ethereum, a bit of spoiler bridges are coming soon. So if I want to do it.
00:06:54.660 - 00:07:04.450, Speaker A: Tom, if I may interrupt you just for a sec. Your screen is showing loading, so we can't see the slide. Actually can see your screen, but we can't see the slide.
00:07:08.710 - 00:07:45.950, Speaker B: Okay, let's see it again. And so now you can see it. Now we can, now you can't. Okay, so I will keep it like that. I won't move to present mode because for some reason it is not working. So I will just go over again what I said. So we have the regular transaction cost and we have the l one footprint transaction cost.
00:07:45.950 - 00:09:14.330, Speaker B: So a message is, for example, when I want to transfer a token from Starknet to Ethereum, it is done by the bridge contract on L two, sending a message to the bridge contract on L one, telling it that some user transfer some amount of tokens to it and then the user can consume this message on l one and get the tokens. So sending this message over has a call data cost and also storage updates. Since we are currently operating in a roll up mode, it means that all storage updates on each state update are being broadcasted on l one, which also has a cost. If we look at all the components that are the cost of a transaction in validator roll up, this is what you get, right? But if we're looking specifically on what is currently the fee that we will be taking on stagnat alpha, this is basically the formula, and it's not very nice looking. So let's try to simplify it. So in alpha we consider only two primary components out of the, I think four I mentioned above. The first one is the computation cost, and you can see it highlighted in yellow.
00:09:14.330 - 00:10:12.430, Speaker B: And what you see is basically we are counting the number of steps, where steps is the, when we imagine a proof, you can imagine a big table of the execution of the block, for example, and each transaction cost, number, amount of steps in the table, right? So we calculate the number of steps and we give it, and we multiply it by some constant, which is gas cost per step. I will elaborate in a minute how we calculate it. So this is the yellow part and the orange part, I think it's orange, is the l one data cost where you see the storage update and the messages, right? So we count the number of messages sent and we multiply them again by some constant. And we also count the number of state updates that were sent and we multiply them by some constant.
00:10:13.810 - 00:10:29.460, Speaker A: Tom? Yes, I would like to just say real quick, for the people following us on discord, on the community call, you can also join by zoom and then you can look at the screen.
00:10:30.890 - 00:11:43.738, Speaker B: Thank you. Now, before I dive specifically into what are those parameters are, the main thing to understand is that computation is much, much cheaper than an l one cost. So for example, if I do a storage update, for example, I write something into a storage variable on Starknet. It costs us something like, let's say 64 times 16 gas. And you will have to do a lot of computation in order to just be on par with this one, right? So we'll get to it in a second, but it has a meaning on the way you design and implement the contracts written on start. And one thing to note is that fees in the alpha will be measured in gas, right? So you can say that we measure the l one data cost, we multiply it by gas per byte, and we multiply the number of steps by gas per step, and we also, at the end, multiply it by gas price. So the fees are actually paid interest.
00:11:43.738 - 00:12:02.180, Speaker B: And this is how it will be in the upcoming versions. I will elaborate more on what are the upcoming versions at the end. So before we move to the next flow, are there any questions on that slide? We can also return to it in the end.
00:12:04.950 - 00:12:23.080, Speaker A: Actually, I have a question, Tom. So here in the bytes per message value, is it fixed regardless of the amount of data that is included in a message? And if so, why?
00:12:24.330 - 00:12:36.670, Speaker B: Yeah, okay, so, good point. It's not fixed and it is basically the bytes of the message. Maybe it's a misleading name, but you're right. So a message has three parameters.
00:12:38.770 - 00:12:54.420, Speaker A: It should be a sum rather than a fixed parameter. Okay, each message will have a specific cost depending on the amount of data it carries. Is that it?
00:12:55.030 - 00:13:38.790, Speaker B: Exactly. So a message has three parameters, which is the from parameter, the two parameter, and a payload. And the payload can be an arbitrary, is a list of an arbitrary length. So the longer the message, the more it costs. Okay, okay, great. So now that we understand what is the formula, how do we actually get what it is? Right, so this flow tried to explain it. So this is just sequence diagram with three entities.
00:13:38.790 - 00:14:45.682, Speaker B: One is the client or the user. Then we have some estimate gas service, and then we have the sequencer. But basically everything is encapsulated in API interaction with the gateway. So first of all, a user wants to generate a transaction and it wants to understand what is the amount of fee for this transaction. So then the API call is just, it sends this transaction to the estimate fee API, the fees being calculated by executing the transaction and applying the formula that I've just described. And then the fees returned to the user, and then the user signed the transaction with the fee and add the transaction to the sequencer. This is very similar to the way it is done today on Ethereum, where the only difference is that currently we still don't have full nodes that can be run locally by the users.
00:14:45.682 - 00:15:25.620, Speaker B: So there is no way for it to be actually calculated or estimated locally. Right, because there is no ability at the moment to execute a transaction against the current state. So this is currently the way to support it, even though there are no full nodes available on that front, I hope that we're aiming for the first version of full nodes to be ready by the end of January. But at the meantime, this is the flow that will allow users to get an estimation for a fee of a specific.
00:15:31.850 - 00:16:05.920, Speaker A: Tom, what you're saying is this is the way it will work today. Just the same way we provide an endpoint for people to broadcast their transaction, we'll provide an endpoint for people to estimate gas fee of their transaction. But once we'll have full nodes, eventually people will be able to run this locally by running their own full node, right? So this is very temporary, maybe it will not come in the first version of the full node software, but it will be included in the future, am I right?
00:16:06.690 - 00:16:16.020, Speaker B: Exactly. And okay, so let's move.
00:16:16.710 - 00:16:34.140, Speaker A: There are some questions, actually. So one is saying five times ten to the power three unit, is it gas or bytes? I think it's gas. Right. I think it's in the previous slide, in the formula in slide four.
00:16:35.630 - 00:16:57.760, Speaker B: Yes, you're right, this is a mistake. Yeah, good point. So this is a constant gas, and so the formula is incorrect. Very nice. This should not be multiplied by the gas per byte. Thank you. We will change it.
00:16:58.150 - 00:17:08.770, Speaker A: Okay, there's a second question by Yannick. Is the client a wallet contract instance or how do I pay the gas with my ether?
00:17:11.210 - 00:17:24.474, Speaker B: Okay, so this is actually something I didn't touch here, but I think I discussed it here. I think I will answer it now.
00:17:24.592 - 00:17:26.380, Speaker A: So let's move to slide six.
00:17:26.910 - 00:17:57.330, Speaker B: Yeah. The four points I would like you to understand and I don't know, remember. Right. So first of all, I repeat it. The computation is much, much cheaper than the l one cost. And this should have like an immediate impact on the way contracts are designed. The correct way is to opt for more computation than more, for example, storage rights.
00:17:57.330 - 00:19:06.418, Speaker B: Okay, this is the first point. The second point is that there will be upcoming changes to the account contracts. So this is in answer to you, Yannick. So the account contract will now as part of the execute function, after the validated transaction and the signature and the nons, there will be a fee payment part in which the fee will be paid in eth to the sequencer. And now the question is, how will one know the sequencer address? So there is a syscall which is called get sequencer address, that will be part of the code, and then the payment should be to this address. So this is the change to the account contract. And there will also be changes to the client and the libraries, which will, for example to starknet Js and Starknet Py that will allow sending a transaction after executing the fee estimation API call.
00:19:06.604 - 00:19:51.254, Speaker A: So if I may ask, does that mean. So for example, I'm doing a transaction on Ethereum. I estimate the gas call from my transaction, and then I craft my transaction and I sign the values in the data. That is the transaction envelope, basically. So that means that for Starknet I will have to send a transaction to a smart contract wallet and have somehow this smart contract wallet, which is a contract, pay the fee. So either I can pass the fee as an argument or I can have it calculated automatically. Is that correct? Yes.
00:19:51.372 - 00:20:19.460, Speaker B: What I mean by a change to the account contract. So currently when you send a transaction to the account contract, you specify basically the nons, and the nons I think is the less. But you specify the address to which you actually want to call, and you specify the selector and the payload and the nons. So to that input, there will be another field, which will be the amount of fee, and then as part of the execution of the transaction in the account contract, the fee will be paid.
00:20:20.070 - 00:20:59.950, Speaker A: Okay. And then I have another question. So this account contract, how will the clients, I mean, how will the network know the difference between this is a regular smart contract and this is an account contract, right. How will it make it the difference between, I'm calling a contract that is not a smart contract wallet, but has the same function selector as you would have on a smart contract wallet. And I'm calling a smart contract wallet. Will there be a canonical account contract? Can anyone write their own implementation of an account contract?
00:21:01.170 - 00:22:03.314, Speaker B: Yeah, so account contracts are, I suspect will be the topic of our next community call, because there are lots of updates to share on this front. But at the moment there is nothing that, there is nothing unique on account contract. So the system does not distinguish between irregular account and account contract, but an account contract will be an account which will implement a way to pay the fee. Right. And the sequencer will not accept transactions that are not paying fee. So any transaction will be valid if the fee is paid. But I think we shouldn't dive into it because there will be some changes to the way account contracts are going to operate in Starknet, and we should dedicate a full explanation to it.
00:22:03.432 - 00:22:43.920, Speaker A: Okay, thank you. So there are questions Martin is asking why the distinction between estimate and calculate in slide five? Is the estimate going to be reliable? I think, Martin, that the difference is that estimate fee is probably the name of the API call, whereas the calculate fee is just the words we put to describe the internal process of the software. But basically what will come out of calculate fee will be sent back in the fee step, right? It's just different name, same thing, right?
00:22:44.530 - 00:23:22.220, Speaker B: Yeah, there's no distinction. The reason we're calling it estimate fee is because the estimation is done on a specific state, and the transaction will actually operate maybe on a different state. Right. So it might be the case that on a specific state I did two storage updates, and on a different state the transaction did four storage updates. So maybe the fee estimation was not correct, which is also something that happens on Ethereum today. So this is why it is called fee estimation. There is no need to.
00:23:22.220 - 00:23:29.786, Speaker B: There's nothing deeper than that and why we called it calculate fee.
00:23:29.978 - 00:23:49.300, Speaker A: Okay, and then Matthia is asking, can you please repeat what the difference between calculating fees on ETH and on Starknet is? Matthia, I'm not sure I understand fully your question. If you want to raise your hand and talk to explain a bit better, that would help.
00:23:49.670 - 00:23:50.980, Speaker B: Yeah, I think I understand.
00:23:51.350 - 00:23:52.100, Speaker A: Okay.
00:23:53.030 - 00:24:46.680, Speaker B: Yeah. What I said is that currently on Ethereum, when you want to estimate the fee, there is an API for the full node that allows you to get the fee estimation right. What actually happens in the full node once you want to call this API is that the full node execute the transaction locally and estimate the gas it will consume. Now, since we currently don't yet have full nodes that are at all, and also the first version won't be able to execute transaction locally, we can't have this API available in your local node or in some API service. So currently the way to do it is that we expose this API on our gateway and this will be changed once full nodes will be available. I hope that answered the question.
00:24:47.210 - 00:25:34.120, Speaker A: Okay, don't hesitate and tell us if it doesn't. Matthia, there's a new question. So what about costs for deploying a contract on Starknet? Will the contract code be included in the state difference? These are two different questions. So what about costs for deploying a contract in Starknet? So the way you pay for a contract deployment on Ethereum is that you sign a transaction from an EOA and the fee to deploy the contract is taken from your EOA balance. Well, in order to deploy contract on Starknet, you will have to send a transaction through an account contract, and so the fee will be deducted from that account contract. Is that correct?
00:25:35.770 - 00:26:29.270, Speaker B: No, sorry. So there are two open questions that I didn't cover here, and very nice. One of them is actually the contract deployment. And I think someone also asked it on the shamans discussion. And another flow that is not covered by what I described here is how do someone pay for a message that is sent from l one to l two? So those two topics are not covered in this release, and we will need to address them on future versions. For the contract deployment. We have a few options on how to do it.
00:26:29.270 - 00:26:38.380, Speaker B: For the l one to l two message, I will be happy to hear opinions on what is the best way to do it.
00:26:40.590 - 00:26:58.110, Speaker A: Yeah, all right, so there was a second question in his question, which was, will the contract code be included in the state difference? So this, correct me if I'm wrong, but I think the contract code itself won't be included in the state div. But the hash of the code will be included.
00:26:58.630 - 00:26:59.620, Speaker B: Yes, exactly.
00:27:00.550 - 00:27:02.020, Speaker A: Got that one right.
00:27:05.750 - 00:27:23.320, Speaker B: Makiak is asking if east pay for transactions will need to be bridged from l one. Yeah, I don't know one way to mint right now. So unfortunately it will have to be bridged from l one.
00:27:25.550 - 00:27:43.200, Speaker A: This is an interesting onboarding question. Right. Imagine you want to create your user account on Starknet. Yeah, on Starknet. How do you fund this first transaction if you don't have an address to send the eth to?
00:27:47.810 - 00:28:31.662, Speaker B: Yes. First of all, note that as I've said, contract deployments are still not part of the fee mechanism. So you will be able to deploy your contract first and then send it to it. Secondly, the way contract addresses are computed on Starknet is very similar to create two. So you can know it in advance what the address will be, and you can know that only your contract can be deployed on this address. And so even if you send funds to a specific address before the contract is deployed, you will still be able to reclaim them.
00:28:31.796 - 00:28:40.960, Speaker A: Is it the case now? I thought that when we create a new address, we added some random salt that was decided by the sequencer. Did that change?
00:28:42.530 - 00:28:55.720, Speaker B: Yes. So the contract address is computed deterministically from the code, the constructor arguments, and salt that the user can choose.
00:28:56.490 - 00:29:07.580, Speaker A: Okay, because, I mean, a while back, the salt was decided by the sequencer. So by startware. Right, but now the user can choose it, is that correct?
00:29:09.470 - 00:29:17.694, Speaker B: Exactly. On the first versions of Startnet Alpha, you could basically deploy to any others that you want. So it was not enforced in any way.
00:29:17.812 - 00:29:18.480, Speaker A: Okay.
00:29:20.210 - 00:29:52.280, Speaker B: Yes, I think I answered once things will mature a little bit. We'll probably also have some ways to allow users to start using Starknet, even maybe for a little bit before they have funds. But I don't have anything concrete to share, so I won't elaborate more. Okay. Are there any more questions?
00:29:57.630 - 00:30:31.410, Speaker A: I don't see more questions. Yeah, I guess that was clear enough. Okay, so then let's move on. If you have further questions, please don't hesitate and ask them. We'll be more than happy to answer them. And in the meanwhile, thank you, Tom, for this intervention. This is really interesting.
00:30:31.410 - 00:31:26.502, Speaker A: So there's a question, we'll take it. And then maybe if you want to share new features after that, aside from fee mechanism, that will come in the coming weeks. So the question is, you said bridge is coming to Starknet, but already in sorare and IMX bridge exists. What does that mean? Well, Sorare and IMX run on Starkx, which is different software than Starknet. So here we're focusing on Starknet, and we'll actually come back to that a bit later on once we're done with the roadmap. There are a few questions that our community moderators raise that are often asked on discord, and we'll answer them, and this is one of them. So we'll come back to that.
00:31:26.502 - 00:31:41.500, Speaker A: Just stick around. Okay, so Tom, if you can present to us all the nice things that are coming in the next alpha version, that would be super cool, especially because I think the next version is packed with cool stuff.
00:31:42.510 - 00:32:24.054, Speaker B: Yeah, this is true. Okay, great. So first of all, I will start by saying that we worked pretty hard in the last two weeks on the service performance. We got a lot of feedback on what should be improved and on problems that people are having, and I think the situation should be better now. So if there are any more problems with it, we did few improvements and a few more are coming. So I think the response time and the consistency of the service should be much better now. We're still aiming to improve it.
00:32:24.054 - 00:33:34.494, Speaker B: But first of all, if it is indeed better, I would be very happy to hear. And also if you still have, I don't know, more problems or feedback, so please continue to share it with us. This was part of what we did in the last two weeks, and hopefully if things go according to plan, we plan to release next week, either on Monday or Tuesday, the next update to Alpha, which will be alpha five, and a few weeks afterwards we plan to release a minor update to it, which will be Cairo 0.7.1. So let me list what will be included in those versions. I think that the roadmap that is usually linked to it on the announcement is up to date. So you can also take a look there. But yeah, let's go over it.
00:33:34.494 - 00:34:32.046, Speaker B: So the next Alpha five version will first of all include the next missing feature, which will allow contract upgradability through proxy pattern. Right. So proxy pattern is a pattern that was originally, I think, invented by Openzeppen on Ethereum, which allows contracts to be upgraded while still maintaining their address. And we also wanted to support it on stagnet because it makes a lot of sense for account contracts. And generally it's a very useful pattern. So last version included the delegate call, and now we added what is called default entry point. And those two combined will allow us Openzeppelin to write the standard for proxy pattern on Stacknet and basically allow contracts to use it for upgradability mechanisms, which is very important in the alpha version because new features are constantly being released.
00:34:32.046 - 00:35:17.258, Speaker B: And for example, let's say I deployed a contract and two weeks later the events feature was published. I want to upgrade my contract to use this feature as well. So this will allow it. We also had two very important features, which is the block timestamp and block number. So you will be able to use this calls that gives you a block timestamp and block number. And there are also three features that were, I mean for me it was very nice because they came as requests from community discussions. So one of them is the ability to support multicoling account contracts.
00:35:17.258 - 00:36:19.758, Speaker B: So for example, if I want to send one transactions which actually include both the approval to DRC 20 and then the transfer form or something like that. So this will be supported in the account contracts on startnet. And there was a missing feature on the contract interface that was requested by both Openwind and Argent, so it will be added in this version. Another thing which will be added is an improvement to the way contract extensibility pattern can be supported by removing the built ins directive on the contract. And there are also many improvements to the and some more functions in the math library like square, and also improvements to Starknet CLI. So now the Starknet CLI will be, will support querying for the pending blocks which were released in the latest minor version. And it will also have support for accounts.
00:36:19.758 - 00:36:34.680, Speaker B: So we will be able to interact directly through the open Zeppelin account contract instead of having to manually construct transactions in such a way that will be compatible with it. So this is the upcoming version, hopefully next week.
00:36:35.530 - 00:36:38.680, Speaker A: So this is next week on Testnet, right?
00:36:38.990 - 00:37:59.470, Speaker B: Yes, exactly. So everything is first being published to Testnet, and once we see it stable and you don't find any bugs or something like that, we also upgrade mainly, and hopefully something like two weeks later we will release 0.7.1, which will have two very important features. One of them is the initial support for fee mechanism. So the flow that I've just described, it will be fully supported in this version. So you will be able to query the system for estimate fee and to include it, but it won't be enforced, right? So since it is in some way a breaking change which requires many changes to the accounts and to the clients and to the applications, it will only be supported so people will be able to pay fee, but it won't be enforced by the sequencer. So this is the first feature and the second feature is support for events, which is very important and will open the way for many, first of all, much better interaction with Sargnet and many external infrastructure to be built like indexers and et cetera, et cetera.
00:37:59.630 - 00:39:10.730, Speaker A: Actually, if I can ask a question. Yeah, so this is a good way to bounce on a question that Kadian asked on discord. So you say, I'm interested in hearing about the benefits and the requirements to run a full node. So the reason I'm saying this is a good opportunity is that it seems like running a node on Startnet will be a bit different than running a node on Ethereum, in the sense that you'll have different kinds of nodes that you have on Ethereum. On Ethereum you have full nodes, light nodes, archive nodes, which are very different, but in a way sort of perform the same actions. Right? An archive node and a full node, for example, will recompute everything that happened on Ethereum and reexecute everything that happened on Ethereum. It doesn't work quite that way on Sarknet, right? You don't need to re execute the full payload in order to know what is the latest state of the system, because you can just use the proof.
00:39:10.730 - 00:39:34.480, Speaker A: But how do you compute and how do you list all the events if you don't recompute all the execution that was done on Startnet? Will the events be part of the proof? Will they be shared over a network of nodes? Does my question make sense?
00:39:34.930 - 00:40:25.582, Speaker B: Yeah, this is a great. So to answer your first question, yes. The difference between full node on Ethereum and Starknet is the main reason for the scalability of the validity roll up support. Right? If I want a full node means that I basically want to verify the state and to be able to answer queries on it, right? So if I want to verify the state on Ethereum, I have to re execute the transactions. There's no other way for me to know what is the state and that it is correct. And on Starknet you don't need to verify to execute the transactions, you only need to verify the proofs. It's a huge difference, because verifying proofs are exponentially less computation and less computation.
00:40:25.582 - 00:40:43.830, Speaker B: So it means that even if the throughput of the system grows, the requirement from a full node does not grow, they remain almost constant. So this is the first difference. And to answer your questions about events. So, events are the output.
00:40:46.010 - 00:40:46.486, Speaker A: Of the.
00:40:46.508 - 00:41:26.354, Speaker B: Execution, but they are not sent on l one as called data, because they are not necessary to reconstruct the state. But what is sent on l one, or what is part of the proof output is a commitment to both the transactions that were executed in the state update and to the events. So even though it is not something I can get from l one, as a full node, I'm always able to verify that a set of events are indeed part of a state update. So the events will be just propagated over the peer to peel network between the nodes, and each node will be able to verify that indeed the events.
00:41:26.402 - 00:41:30.470, Speaker A: Are all the events that are required.
00:41:31.130 - 00:41:35.906, Speaker B: Exactly. And that those events are really the output of this block execution.
00:41:36.018 - 00:42:25.990, Speaker A: Cool. So that's one advantage of running your own node, it will be reconstructing, it will be basically the same advantage as running your node on Ethereum. You verify that everything happened correctly and the network is behaving correctly, so that you can check that decentralization is working correctly and nobody manipulates this chain. And you'll be able to have access to historical data through events, and you'll be able to see what happened in the past. And then there's another kind of full nodes, which are, I mean, the frontier between approver, a sequencer, and a full node that will still receive transaction, process them and broadcast them is still a bit blurry to me. Can you speak a bit about that and the requirements to running this kind of machines?
00:42:30.650 - 00:42:48.750, Speaker B: I think what you're referring to are basically execution nodes or sequencer nodes, right? So when Starknet will move to the permissionless stage of the system, anyone will be able to be a sequencer. And being a sequencer means running a sequencer node.
00:42:51.670 - 00:42:54.226, Speaker A: Yes, that's what I'm referring to, yeah.
00:42:54.248 - 00:43:21.420, Speaker B: And a sequencer node is basically a node that execute all the transactions, because otherwise you can generate a proof to it, at least initially. Those will be the two types of nodes. Maybe at some point we will also have light nodes, but we haven't yet specified it or started working on it.
00:43:22.110 - 00:44:04.310, Speaker A: Okay, so running this kind of nodes though will require more hardware because you will have to process the transaction. So instead of just taking the proof to verify it, you'll have to basically take the transaction, execute them and append them. So it will be an endeavor a bit closer to what running your miner on Ethereum would be. It's something that you would do in order to run the chain, take part for sequencing and producing proof. And so it's something that takes more resources, but that you can also potentially monetize. Because if you're a sequencer, then probably you can get part of the fees of the network.
00:44:04.890 - 00:44:33.860, Speaker B: Exactly. I expect those sequencers to be some sort of business, or like the miners we have today, or stakers we have on other chains. You should be very well aware of what you're doing, because otherwise you will waste a lot of money. It won't be cheap to participate, and I think it will also be very profitable to do it.
00:44:36.470 - 00:45:19.066, Speaker A: Okay. Actually, you were saying earlier that the way the fee mechanism is designed and will be designed does affect the way you will design your smart contract. Because execution is cheap, storage is not. And so it is useful for you to design your contract so that it does a lot of computation but not a lot of storage. I think it's Ted Suzmann who published a post a few weeks ago and he touched on that topic and he had really interesting point regarding that. But another thing you should take into account when designing your contracts that I think is really important. Following events.
00:45:19.066 - 00:45:51.900, Speaker A: And what we're saying is that events are important on Ethereum. If you want a fast way to know what happened at a given point in time, given that you're not in the default mode, going to re execute everything that happened on Starknet in order to synchronize your node, events are even more so important if you want to trace what happened during execution. Right? Does that make sense?
00:45:52.510 - 00:45:53.980, Speaker B: Yeah, I completely agree.
00:45:55.550 - 00:46:18.210, Speaker A: Yeah. I think once this feature is out, it's also very important to be mindful of how you use them, because it will be a very important tool for you to be able to reconstruct the history of what happened with an account, what happened with your smart contract, and in order to display a nice UI historized to your users.
00:46:20.070 - 00:46:29.800, Speaker B: Yeah, I agree. Okay. I finished everything I had to.
00:46:32.650 - 00:47:09.380, Speaker A: Think. There are, I don't see more questions, so we'll keep them coming, we'll keep answering them. We still have a few minutes. And so thank you, Tom, a lot for this intervention. I think it was really interesting. I'm really excited to see how the fee is going to be introduced in Starknet. I think it's really a testament to how early it is that we are able to introduce such fundamental builds, even blocks, little by little, and to get people to start building from day one.
00:47:09.380 - 00:47:40.320, Speaker A: And it's really interesting to see all these key features being introduced, like little by little, and I hope the community likes it. Don't hesitate if you have questions, suggestions, and if you want to get involved in these discussions and learn more and give your opinion. Don't forget to join our discourse community on shamans, because there's a lot of very interesting discussion that is following there.
00:47:40.850 - 00:48:12.646, Speaker B: Yeah. And I also want to highlight that really, a lot of the upcoming version is based on discussions that were done in the community. So being part of the discussion is actually affecting the roadmap and what is coming out. In my opinion, it is really good and I hope it will continue that way.
00:48:12.828 - 00:49:07.340, Speaker A: Yeah, me too. So Katyam has extract questions. He's asking, will execution and sequencer node be edited on Testnet at the end of the month when full nodes are launched? I think aside from the specific question to which the answer I think is, no, not really. Full nodes will be launched first in a capacity where you'll be able to reconstruct, I mean, to validate the proofs from L one and then maybe query the state and reconstruct the state. But execution and sequential node will come later. I think the broader question here is, what is our path to decentralization? And if you still have a few minutes, can you tell us a bit more about that? How do you see this evolving in 2022? This is a broad question.
00:49:08.590 - 00:49:42.770, Speaker B: Yeah, it is a broad question. Our goal is to have at least some initial version of the decentralization protocol in 2022. Right. So this means that you have a leader election mechanism, a consensus mechanism, where anybody can participate and be a sequencer and approval, and also that there is a software that is available for anyone to run for a sequencer and for approval. So this is the goal.
00:49:43.670 - 00:50:10.090, Speaker A: So these are actually two very big parts. Right. First, software that is stable enough that allows you to be or a sequencer or approver, and have people run it and test it, and then also have a consensus layer that is more theoretical, but that basically attributes and decides who gets to be the sequencer and approver at a given time. It's different challenges, but these are very too big and heavy bricks.
00:50:10.170 - 00:50:53.290, Speaker B: Right, exactly. And we are now heavily researching the second topic that you mentioned, what will be the protocol? And I hope that pretty soon we will be able to share at least between two to three options of what we have in mind, and we will be very happy to get feedback from anyone on. Are there any other things we're missing? Does those proposals make sense? How can they be improved? Et cetera, et cetera.
00:50:54.030 - 00:51:41.100, Speaker A: Fantastic. Thank you. So it's actually close to one of the questions that is raised quite often on the discord. One is when decentralization of Starknet, when can we run node, or what is basically that? So, to fully answer this question, because we didn't start from the beginning, but Starknet today is being developed, and it's not decentralized, but our goal is 100% to be fully decentralized, independent from starkware. And we want it to be a standalone network that is decentralized, where anyone can participate, full stop. That's what we have to do. Tom has to go.
00:51:41.100 - 00:51:56.814, Speaker A: Well, thank you, Tom, for this great information. I'll be here for a few minutes if you guys have more questions and to answer some questions that were raised on discord. Yeah, so thank you, Tom.
00:51:57.012 - 00:52:02.670, Speaker B: Yeah, thanks, everybody. Have a good day and goodbye.
00:52:05.350 - 00:53:04.962, Speaker A: So, going back to the question, when decentralization on Starknet, when can we run a node? So, as Tom said, this is something that will be the main target of our focus in 2022, in 2021. A good part of what we were focusing on was basically building an execution engine that allows you to write smart contracts and get them to be proofed and get this proof to be validated and created by Ethereum layer one, and then have these smart contracts interact with each other. But this doesn't require decentralization. Right. You can just write your smart contract, send it to us, and then we prove it, and then l one validates it. It's nice, but it's just one piece of the puzzle. Second big piece of the puzzle is how do we decentralize this? How do we write software that anyone can use? And this is very much a big focus for us on 2022.
00:53:04.962 - 00:54:17.542, Speaker A: So this is why we started with full nodes, so that you guys can run your piece of infrastructure at home, and then we hope to have sequencer improver sometime this year. We don't want to commit to deadlines today because it's a little bit blurry. But knowing Tom, if you say 2022, I'm confident it will happen in 2022, and then leader election, which we'll share more concepts about in the next few weeks. Related to that is a question that comes quite often, which is, what is the difference between Starknet, Starkx and Starkware, the company? So let's start from the beginning. Starkware is company that was founded by mathematicians and cryptographers, basically, and that researched zero knowledge proof systems. Right. And Starquare, the company came up with language called Cairo that allows you to write provable programs.
00:54:17.542 - 00:55:16.750, Speaker A: These provable programs can generate a trace of execution. And so if I have a program and I execute it, I can give you the result and the proof of execution, and you can be sure that the result I gave you corresponds to the initial program and that it was executed correctly without you having to execute a program yourself. And verifying this is much, much cheaper than writing the program yourself. So this is a basic building blocks that came out of Starkware, which turned into Starkx, which is an execution engine, which is basically a way to say, okay, so maybe we can write a program that will allow people to trade a lot of nfts, and then the proof that all those trades were done correctly will be sent to l one. And so we can verify that this. And so l one can verify that nobody stole nfts while they were in their custody. So this is basically in a nutshell what Starkx is.
00:55:16.750 - 00:56:18.626, Speaker A: It's the first version of our stark system that allows you trade ERC 20, ERC 721. Big names are using Starkx. This is probably why you've heard about Sorare, IMX, diversify and things like that, right? While this is nice, these are standalone applications. So you have to move your funds to Dydx and then you can use them in DyDX, but you can't use your funds in diversify directly from DyDx. So we then moved the objective to building a network of smart contracts that can interact with each other. And the trace of execution that this network behaves correctly should be interpreted by Ethereum layer one to make sure that the l two did not produce invalid plots. And this is what we're working on currently.
00:56:18.626 - 00:57:19.000, Speaker A: This is Starknet. So to step back again, Starkware is a company, Starkx is one product, a first product, Starknet is a second product. However, a network of decentralized application doesn't really make sense if it's the product of one company. So the goal for Starknet is to be fully decentralized, operated by its users, and fully accessible to anyone. So just to clear these questions, don't hesitate if you have questions regarding that. So I can see here that Matia is asking, is there a decentralization roadmap? There's a post which is called the road to Starknet, which I'll share later, which basically gives an overview of where we want to go with that. But we don't have a specific roadmap on that yet.
00:57:19.000 - 00:58:58.770, Speaker A: It's something we know we should communicate more about and we should specify a bit more. So we'll get back to you on that and we'll try to document it a bit more because it's a key point. Right, okay, so this were the question about the difference between Starkx and Sarkware and decentralization. Then there's a question which is can we move real funds to Starknet? Actually, this is another question which I'll take before that, which is is Starknet open source? So right now Starknet is using the same kind of licenses that uniswap or Ave V three are using, which are, it's not the exact same, but it's a similar spirit, which is business license, meaning that the code is readable and accessible, but you can't just copy paste it and deploy it under a different name and make off with all the hard work this community has done to build something interesting. So right now the position we have with licensing is that it's very easy to go in one direction and very hard to go in another one. It's very easy to go from restricted to open source. It's much harder to go from open source to restricted.
00:58:58.770 - 01:00:02.486, Speaker A: And we think these discussions and these decisions should be made by the community. If we decide today to open source everything, then the community will have a much harder time to go in the opposite direction should they decide to do so. If we leave things a bit more restricted or safe, depending on how you say it, then the community will have no problem with moving in a more open source direction. So right now, nothing prevents you from reading the code that runs Starknet, nothing prevents you from building on Starknet. And eventually these decisions, just like the operation of the network, will be in the hand of the community. All right, so that was about licensing then. Okay, can we move real funds to Starknet? We are testing token bridge right now that will allow you to bridge funds to starknet.
01:00:02.486 - 01:00:45.234, Speaker A: So stay tuned. It should come in the next few weeks. It should come very soon actually. It will be deployed first on Testnet and then you'll be able to use that bridge on mainnet to move real funds to startnet. And then there were two other questions which were where to get test tokens and what to do, what to test for users. So regarding the test tokens, you can install Argent X and they have a small interface that allows you to mint test tokens and then send them to people. So if you need test tokens, just do mean you can ask them on discord.
01:00:45.234 - 01:01:49.134, Speaker A: But honestly the easiest way is just to mint them yourself. And regarding what can we do, what can we test for users? There are a few apps that are live on startnet now. You can mint an NFT with Mint square, you can mint the test tokens with argent X you can build NFT sets and Minecraft sets with bricks. You can use I bet you by shardlabs to bet on the outcome of, I think on Twitter profiles and I don't want to forget anything, but I probably forgot some things. So do check these things out and check out our SAQ because we list resources here where people get to test new systems. And that were the questions I have. I see.
01:01:49.134 - 01:02:19.720, Speaker A: There's one more question. Is there a place where we can find info on how to become a sequencer in the we? Let me check. I think Louis wrote Twitter thread about it, but it's not the perfect source of information. I don't think we have a specified blog post or article about that, though. If we have, I'll make sure to share it. I'll make sure to share it. And yeah, that's about it.
01:02:19.720 - 01:03:05.478, Speaker A: I've covered all the topics I wanted to cover today, so if you don't have other questions, I think we can log off. So once again, thank you for being here. It's nice to see that many people show up on such a short notice because we just advertised this community call yesterday. So I think we will do the next community call in two weeks. So on Tuesday 18 January. We'll be happy to see you there. And yeah, that's about it.
01:03:05.478 - 01:03:31.694, Speaker A: Looking forward to it. And I see somebody raising their hands. Let me check. So, Krsna, I think you can talk now if you want, if you have a question. And. Okay, I think you're away from keyboard. Okay, so let's close it here.
01:03:31.694 - 01:03:41.930, Speaker A: Thanks again for being here and looking forward to next title. Have a great day, everyone. Bye.
