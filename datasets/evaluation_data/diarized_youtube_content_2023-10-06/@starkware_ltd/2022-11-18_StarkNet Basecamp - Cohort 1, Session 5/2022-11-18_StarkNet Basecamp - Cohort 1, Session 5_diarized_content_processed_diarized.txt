00:00:00.570 - 00:00:01.870, Speaker A: It's private tour.
00:00:04.130 - 00:00:28.750, Speaker B: We're going to wait for the rest of the dev advocates to come on to the stream. And we have about ten people right now. We usually have about 30. So we'll give everybody a little bit of time to join. Maybe while we're waiting.
00:00:31.650 - 00:00:38.164, Speaker A: I actually, can.
00:00:38.202 - 00:00:39.556, Speaker B: Someone raise their hand if they can.
00:00:39.578 - 00:00:43.028, Speaker A: Help us figure out allowing one of.
00:00:43.034 - 00:00:55.380, Speaker B: You guys to talk. If anyone on the stream now can just raise their hand. Who has a microphone?
00:01:01.170 - 00:01:01.822, Speaker A: Anybody?
00:01:01.956 - 00:01:02.830, Speaker C: Luis?
00:01:06.060 - 00:01:07.450, Speaker A: No? Yes.
00:01:09.260 - 00:01:13.420, Speaker B: All right, so can you, do you mind just trying to talk right now.
00:01:13.490 - 00:01:21.824, Speaker A: And make sure we can hear you? Hey, guys. Hey, do you hear me? Yes.
00:01:22.022 - 00:01:26.370, Speaker B: And do you mind doing one more thing? Can you try to share your screen.
00:01:29.560 - 00:01:50.850, Speaker A: Or does it give you a permission? Error. I believe he needs to be promoted to panelists, but, yeah, let's see what happens.
00:02:02.270 - 00:02:09.370, Speaker B: Okay, so, yeah, we did move Henry to panelists last time and he was able to share, I believe. All right, we'll figure it out on the fly.
00:02:13.100 - 00:02:13.850, Speaker A: Cool.
00:02:14.220 - 00:02:22.244, Speaker B: Welcome, everybody. We got 14 people. Maybe just give it another couple. Another couple of seconds.
00:02:22.292 - 00:02:26.460, Speaker A: So Henry is on promote to panelists?
00:02:26.880 - 00:02:27.532, Speaker C: Yeah, exactly.
00:02:27.586 - 00:02:29.550, Speaker A: Try with Henry. Okay.
00:02:30.720 - 00:02:33.576, Speaker B: Yeah. While we're just waiting for people, we'll.
00:02:33.608 - 00:02:42.930, Speaker A: Just do this elevated music. We'll do the actual information.
00:02:45.940 - 00:02:47.248, Speaker B: We're going to need a remix of.
00:02:47.254 - 00:02:50.530, Speaker A: That for next time. That's a sick tune, man. Where is this from?
00:02:51.000 - 00:02:52.630, Speaker B: That's ringtone, man.
00:02:54.120 - 00:02:55.780, Speaker C: Coming. French artist.
00:02:57.320 - 00:02:59.440, Speaker A: Love it. Hey, Arturo.
00:02:59.600 - 00:03:16.990, Speaker B: Welcome, everybody. Okay, we got about 17 people, so we can kick it off here. Yeah. So today, last session, we sent out the form in discord. We're going to send out the form here as well. Just in case you didn't see it. This is the graduation form.
00:03:16.990 - 00:03:59.032, Speaker B: Let me ping it out to you guys. So, yeah, it's going to have a little bit of feedback. Feedback opportunity. I know we've been collecting feedback as well throughout each session, but this is kind of just aggregate. What did you think about it? What could have done better? I know a lot of the feedback right now is that the math at the front end was a little confusing. So I think we're planning on tightening that up a little bit. If you guys have any prs, if you've come out the other side of base camp, if you have prs in that regard, that would be awesome to make things a little more concise and understandable, everything, even down to the timing of sessions once per week, every week.
00:03:59.032 - 00:05:02.460, Speaker B: Did that work well? Did you guys still feel engaged in the class? It's there for you. And then also repo and pr link for your graduation requirements. Your starknet wallet address for the wallet address that will have all the tutorial points except for exercise 14 of Starknet Cairo 101. We're going to extend the graduation time out one week. So by next Thursday, if you guys can have your PRS, your repos in your wallet address with all the points, and then if you guys have completed all the graduation requirements and do want swag, please fill out the rest of the optional requirements, which is phone number, address and a bunch of other invasive things. I know blockchain people don't necessarily love having their phone number, full name and address be pinged out, but unfortunately we need it for ship and swag.
00:05:03.840 - 00:05:04.300, Speaker D: Cool.
00:05:04.370 - 00:05:33.672, Speaker B: And again, ping me if you guys have any questions on that. So we do have three presenters today with their graduation requirements and prs ready. It looks like Olivier, who had a really good pr on recursion is actually out due to a medical issue. So we'll hope he's okay, but I'm going to send out his pull request to base camp in the chat and in discord. And feel free to check that out.
00:05:33.806 - 00:05:34.952, Speaker A: It's pretty cool.
00:05:35.086 - 00:05:40.570, Speaker B: Along with some Cairo code examples. So we'll start with.
00:05:43.020 - 00:05:45.880, Speaker A: Javier. Javier.
00:05:49.600 - 00:05:52.588, Speaker B: I don't see Javier on. Can you raise your hand if you.
00:05:52.594 - 00:05:53.310, Speaker C: Have an.
00:06:05.540 - 00:06:15.760, Speaker B: Okay, so maybe Javier will join later. Let's start with Shebin. Let me promote you to panelists.
00:06:18.120 - 00:06:37.630, Speaker A: You able to talk, Shebin? Hello, can you hear me? Yes. Awesome.
00:06:38.080 - 00:06:47.870, Speaker E: I will share my screen. Can you see my screen?
00:06:49.920 - 00:06:50.380, Speaker A: Awesome.
00:06:50.450 - 00:06:51.070, Speaker C: Yeah.
00:06:52.820 - 00:07:29.448, Speaker E: This is a pr regarding the proof of work example. This one has actually been discussed by Ben in cam two, I believe. So I'm just going through the code and we'll show you how this thing works. So first, let me just run the command. This is in the directory primer, bitcoin, proof of work, Python. And to run it, we just have Python, three main py, and it will start getting the Genesis block and all that thing. So, in terms of the code, this is a class for the block.
00:07:29.448 - 00:08:26.376, Speaker E: So block is basically, I believe everyone knows in this class if we are learning Cairo. So still, if anyone is not familiar with the block concept, it's the basic block where all the transaction is mined or all the transaction is encapsulated in a blockchain. In here we have the index, that is the block number, the transactions which can be included in the block, the timestamp of the block when it is mined. This is the hash of a previous one. So in blockchain it is basically linked with every block is linked to each other in a serial manner. So this has to be the previous hash of it. And in the case of a Genesis block where this is the first block which is going to be mined, this will be a Nil statement or nil sentence.
00:08:26.376 - 00:09:17.640, Speaker E: And this is the nuns of the block where the nuns is actually a random value. It is generated from starting from zero to n number where the hash of this block has to be of a certain difficulty, which I will mention later. The hash is being created like this. So it gets an encoded block with all the parameters of that object which are index, transaction, timestamp, previous hash and none. And we get the shard 256 of it with the create hash function moving along with the blockchain. This contains the values like difficulty. When it is four, it shows like the hash has to have at least four zeros in front of the calculated chart of six hash.
00:09:17.640 - 00:10:00.330, Speaker E: This is the chain which contains all the blocks starting from zero to n number. Unconfirmed transaction contains it is an Array can be considered as a mempool for people who already knows about it. This contains all the transaction which has to be included in a block. And at the time of initialization it will create a genesis block which is the first block in the blockchain. So coming to the generate genesis block, it will create a block with these details like the nuns will be zero. The transaction is just a text mentioning Genesis block, the timestamp of it and the previous hash. For this the first block will be.
00:10:00.330 - 00:10:35.664, Speaker E: Then we get the hash of it. With the create hash function, we may print mining the block containing genesis block which we can see here. Mining the block containing genesis block and we check that the difficulty at least there should be four zeros in it. So that's what we check here. And then we print the hash which we receive and it is appended to the chain. So that is appended here. Self dot chain in terms of last block, this is just to read the last block details.
00:10:35.664 - 00:11:02.268, Speaker E: Self dot chain of minus one gets the last block details of it. This is just to print the block values. You can see here the block zero previous hash is nil. For the first block it is genesis block, the nun source 127529. And the hash is this block one and so on. So this just basically prints from zero to n blocks in the chain. And this is where the actual proof of work happens.
00:11:02.268 - 00:11:39.444, Speaker E: This is similar to what happened in the genesis. The only difference is that in here we will include the actual transaction which is being added in the blockchain instead of just sending a nil previous hash. So we start the nuns from zero. We create the hash, we check the difficulty that is in this case, 40 should be there. We increment the nuns each time until the created hash doesn't have at least four zeros. And then we print this hash in terms of adding a block. The previous hash is checked if there is any alteration being made in the blockchain.
00:11:39.444 - 00:12:06.560, Speaker E: There was some kind of 51 percentage attack or something like that. The previous hash won't match with this, and this will avoid adding this block to it. So basically mentioning that there was some kind of attack happening. And then we check if it is a valid proof. This valid proof is checked with two conditions. First one, making sure that the difficulty requirement is met. And the second one, that the hash is actually the hash of that block.
00:12:06.560 - 00:12:24.360, Speaker E: We actually save that hash before adding that. And we return. True to mention that, yeah, this block is actually done. And then add new transaction. This is just basically adding multiple transaction. And those transaction will be added to the self. Sorry, uncomfort transaction chain.
00:12:24.360 - 00:12:50.684, Speaker E: Sorry array. And then this is the function to mine it. We check this last block, we encode the content of the block, we create the proof, and we add that block to the chain. And this main is just basically adding a new transaction. Send one BTC to Nick Cage. That's here. Then send two more BTC and send five more BTC.
00:12:50.684 - 00:13:07.028, Speaker E: And this is showing all the block. So just running this. This is how actually mining happens. It checks for different nuns. And when we get a suitable random hash which satisfies this difficulty, it actually gets mined.
00:13:07.204 - 00:13:07.544, Speaker A: And.
00:13:07.582 - 00:13:10.330, Speaker E: Yeah, that's all from me. Any questions?
00:13:14.380 - 00:13:15.432, Speaker A: This is nice.
00:13:15.566 - 00:13:16.810, Speaker E: Was I too fast?
00:13:17.680 - 00:13:28.430, Speaker A: No, it makes sense. Yeah. So maybe I missed it at the beginning, but is this part of zero sync? What is the context of this?
00:13:29.680 - 00:13:42.204, Speaker E: There was a requirement for mentioning building out proof of work examples, block verification examples. So I built one of it as a pr and I did the stack account thing. Points.
00:13:42.342 - 00:13:45.216, Speaker A: Yeah, makes sense. Sorry. Thank you, Henry.
00:13:45.248 - 00:13:51.190, Speaker B: This is in the primer, so it goes a. What is a blockchain? What are we actually doing?
00:13:52.360 - 00:13:53.300, Speaker A: Makes sense.
00:13:53.450 - 00:13:55.930, Speaker B: Cool, man. That's awesome. Thank you for that pr.
00:13:57.660 - 00:13:58.244, Speaker A: Sweet.
00:13:58.292 - 00:14:18.210, Speaker B: So let's do one more call for Javier. Javier, will you raise your hand if you're on today's session? Okay, it looks like he's not. Arturo, if you want to go ahead and share your contract, I'll promote you.
00:14:21.060 - 00:14:21.810, Speaker A: Now.
00:14:24.680 - 00:14:27.940, Speaker B: And then. Shebin, it looks like I'll demote.
00:14:34.540 - 00:14:35.290, Speaker A: You.
00:14:36.460 - 00:14:39.576, Speaker D: Hi, everyone. Can you hear me?
00:14:39.758 - 00:14:41.864, Speaker A: Yes. Okay.
00:14:42.062 - 00:14:51.950, Speaker D: I share my screen. You can see now, right?
00:14:53.520 - 00:14:54.270, Speaker A: Great.
00:14:58.160 - 00:15:18.656, Speaker D: This is my contract. It's a smart contract for a DCA bot. It's Dora cost average bot. It's just experimental. I'm using different tools here. I document some of the tools. For example, I'm using ten k swap.
00:15:18.656 - 00:15:58.736, Speaker D: I change this contract for the myswap contract and oracles like Empiric Oracle, forget the price from Ethereum and Ethereum USD. I tried to use in nostern finance, but Nostrom finance did not public his contracts yet. So I advance with the things that I can do. So I'm using protostar for making this environment for development. I don't know.
00:15:58.918 - 00:16:03.010, Speaker A: Okay, here.
00:16:05.060 - 00:16:13.430, Speaker D: I'm using survivals balance, last token price variation. It's kind of the user wants to.
00:16:14.300 - 00:16:15.050, Speaker A: Choose.
00:16:17.180 - 00:17:34.960, Speaker D: When he can buy in a better price, for example, or make an average pricing, right? When the user buys ether and it's just for that, these variables, periodicity is like when you want check the price from the oracle to Ethereum USD down variation is when the price from theorem is down maybe 3%, 5% or something like that. You take some USD and buy Ethereum. I'm trying to do this automatically. It's not complete yet, but that I tried to do. The old variation is when the Ethereum price goes up, you can solve 10% or something like that. And this is the implementation for interface from the oracle, the empiric oracle. I'm using this address, this valve pair, this is the address for the tokens.
00:17:34.960 - 00:18:41.876, Speaker D: This is my swap address. That is the interface that the contracts that I connect for making a swap, they don't have any documentation yet, but I try to deboke some transactions that is kind of this thing. So I try to make some testing in hardcode and yeah, that's it. The token price, get the current price ether and depends on that response. The swap, it's sold or by eater. And I'm trying to ask Jagu finance, they have some automotive contracts for making this, taking the value from pericity viable and execute every time with this tool. And that's it.
00:18:41.876 - 00:18:57.950, Speaker D: It's not complete. I need to add a lot of things like Nostra MMA because I want to deposit some funds in that vault for making some Apy or something like that.
00:18:59.520 - 00:19:04.892, Speaker A: I think that's it. Cool.
00:19:05.026 - 00:19:10.720, Speaker B: One question, what do you think the dev experience was like with Empiric?
00:19:12.020 - 00:19:30.710, Speaker D: It's really easy. The documents are good for this part because they have another data sheet or feeds for the Price feed. It's really easy. I didn't check the other feeds, but I think it's really easy.
00:19:32.840 - 00:19:34.836, Speaker A: For the.
00:19:34.858 - 00:19:41.050, Speaker D: My swap and nostra and jaggy. It's a little bit complicated because.
00:19:42.940 - 00:19:43.304, Speaker A: The.
00:19:43.342 - 00:20:10.640, Speaker D: Documentation is not too clear in the ten k swap. In my swap for the team to my swap, they have some problems with execution. Sometimes I need to learn better how to use integers un 256 and. Yeah, for a big battle.
00:20:12.920 - 00:20:13.604, Speaker B: Awesome, man.
00:20:13.642 - 00:20:13.956, Speaker A: Thank you.
00:20:13.978 - 00:20:21.910, Speaker B: Anyone else have questions? Cool, appreciate it, man, that's awesome.
00:20:22.280 - 00:20:26.072, Speaker A: Thank you. Congratulations. Good job, man. Thank you.
00:20:26.206 - 00:20:53.690, Speaker B: Okay, so anyone else that hasn't finished or completed the graduation form that would like to talk today, you can just raise your hand if you would like to present. Looks like no takers. Okay, well, again, you have one more week if you want to get some swag shipped out to you for.
00:20:55.740 - 00:20:56.056, Speaker A: The.
00:20:56.078 - 00:21:12.850, Speaker B: Sweet t shirt, it's going to have bragging rights. Cohort one. So you can go to the conferences and brag to all your friends. Yeah. And thanks for everyone who presented today. From here, we're going to give it to Henry to talk about the future.
00:21:13.780 - 00:21:14.384, Speaker C: Hey.
00:21:14.502 - 00:21:20.528, Speaker A: Hello, everyone. Actually, I'm joined today. We're going to be presenting with Hilia, who joined us. Hey, Ilya.
00:21:20.624 - 00:21:21.590, Speaker C: Hi, guys.
00:21:21.960 - 00:21:25.652, Speaker A: Cool. Oh, wow, you hurt your arm. Yeah.
00:21:25.786 - 00:21:27.190, Speaker C: Not a smart person.
00:21:28.520 - 00:21:39.748, Speaker A: Well, it happens to everyone. So the people here are fairly familiar, I guess, with us. We're at the dev at vocacci team. Ilya, can you say a few words about what you do at stockware?
00:21:39.924 - 00:21:55.228, Speaker C: Sure. So I've been working in the company for about seven months now, and mostly I do research about consensus. Some of it is about fees, but most of it is really about the protocol. So the consensus and the proverbs state updates, so on.
00:21:55.394 - 00:22:03.232, Speaker A: Super cool. And so, yeah, I've asked to come with us today because. So we're going to be talking one thing real quick. Sorry.
00:22:03.366 - 00:22:13.380, Speaker B: So I actually sent out a post from Ilya earlier. If you read the shamans or the community forum post on decentralization, that was written by Ilya just for some context.
00:22:13.800 - 00:23:08.788, Speaker A: I mean, this is great context because this is actually part of the reason why Ilya is here today. Because essentially we're going to talk about today, about what is next for Starknet. So, as you've noticed by now, Starknet is still being developed. There's a lot of things to implement, to have a fully functional and fully healthy, decentralized network. And today we're going to talk about the various things that are on the horizon. So I'm going to talk about the immediate roadmap, what we're working on right now. And what is the topic of right now for Startner? And then we're going to go a bit more into fuzzy territory and we're going to talk about things that we're working on, but we don't have concrete milestones or deadline for.
00:23:08.788 - 00:23:45.836, Speaker A: We have a rough idea of when these things will emerge, but these will take time. But we hear that it's important for us to share this information and for you all to be aware of what's cooking. So I'm going to present quickly what we're working on today, and then we're going to move on what's cooking for tomorrow. And we're going to talk with Ilia about, well, the things you mentioned, actually, decentralization, fee, market and state growth. So actually, yeah, that's what we're going to talk about today. So what we're working on, on 23, you guessed it, performances. We want to make the network faster.
00:23:45.836 - 00:24:29.970, Speaker A: Then we're going to talk about the following subjects. So, decentralization, fee, market, state growth, I want to touch on data availability. I don't know how much you guys talked about it in base camp yet, but I'm going to talk a bit about what it means and what things you can imagine with that. And we're going to talk about recursion and how this thing may impact the network and the way you design applications, because I think it's important. And then we're going to talk about the ecosystem itself and how to grow the ecosystem, because at the end of the days, a blockchain network is a nice technical creation, but it's a network of individuals and it's a network of people who collaborate. So the more the merrier. And we need everyone's help to grow this.
00:24:29.970 - 00:24:57.400, Speaker A: So it is how we do it. Let's go. Cool. So let's talk about throughput. So this is the main theme of, and this is our main focus. So if some of you have started coding on Starknet and developing on Starknet, you may have noticed that Starknet is not super fast right now. It actually got 2.5
00:24:57.400 - 00:25:18.624, Speaker A: x upgrade today. So it went from about 0.6 transactions per second to 1.5. Is it enough? No, of course not. It's ten times less than Ethereum and we want to go much, much higher than this. Is it good? Well, 0.6 to 1.5
00:25:18.624 - 00:26:08.240, Speaker A: is still a 2.5 upgrade, and we have a few things coming in short order that we're going to implement and deploy. And I'm going to talk about them in a sec. The thing that I want to mention first is what do we talk about when we talk about throughput? Because throughput on a ZK roll up is fundamentally submitted to different constraints than what throughput means on blockchain network. In a blockchain network, traditional like bitcoin or ethereum, you're limited by the size of the smallest node on the network. Right. In a ZK roll up paradigm, you can have very beefy machine, which are smaller, that execute a way more transaction.
00:26:08.240 - 00:27:13.120, Speaker A: And this is actually kind of similar to the architecture of some of these new blockchains network that are coming up. And I'm thinking about Solana Apto Sui polygon to a certain extent, even though Polygon uses the same EVM machine and geth client than Ethereum. But there are some interesting things we can take from this network and apply it in a ZK roll up mode, because for the execution of transaction, you can reuse the same thing. Now you may think, yes, sure, but what about proving? Proving takes time, so you're going to lag with proving. The thing is, given recursion. Once you have the ability to recursively prove stuff, it becomes actually fairly easy to catch up to the chain in terms of proving, because let's say you want to prove every day of execution, you don't have to prove a full day linearly. You can slice it into smaller blocks and then parallelize proof generation.
00:27:13.120 - 00:27:56.096, Speaker A: So take that on another timescale. This means that for proving, you have an efficient way of parallelizing because you know what each block is doing. And also proofing isn't. I mean, it is time sensitive, but it's not as time sensitive as ordering transactions and emitting block. And so once you have the ability to make separate proofs and aggregate aggregate them in bigger proof, the bottleneck stops to be the prover and becomes to be the sequencer. The prover can be a bottleneck in term of cost, but we're not there yet. That's not the main issue here.
00:27:56.096 - 00:28:38.448, Speaker A: The issue here is about ordering the transaction and being able to possess as many transaction as you can. So even though we are proving, we're still back to the issue of I have a big machine and everybody is sending me transaction, how do I process as many of them as possible? So the first avenue we're looking at is parallelization. If you're familiar with Ethereum. In Ethereum, all the transactions in our block are sequential. They're executed one after another, they're not parallelized. If I heard correctly, I think there is a way to parallelize transaction in Ethereum, but nobody's really leveraging it right now, and so it's not really used. Right.
00:28:38.448 - 00:29:19.868, Speaker A: I think there's the concept of access list in guest, but I'm not sure about that. So parallelization, having the capacity to execute in parallel transactions that are context independent would enable us to speed up the network. Let me take an example. Imagine David and I are doing two transactions. I'm using Henry swap and he's using David swap, and we're both swapping two different pairs of currencies. Technically, both of our transactions, if we execute them on Ethereum, will need to be ordered and one will be executed after the other. But the states affected by these transactions are totally different.
00:29:19.868 - 00:30:39.030, Speaker A: We're not touching the same smart contract, we're not touching the same tokens, we're not touching the same wallet. So technically you could execute them in parallel and then group the state at the end and you would have a unified execution environment while having fres in parallel. What's complicated with that is that in order to be able to separate these transactions, you need to know beforehand which one is going to touch which area of state. So this is a difficult thing to implement, and we're looking at two things long term, but I'm going to talk first about the short term gain we're thinking about. So the first thing is that when you're operating the sequencer, you start to realize that a lot of these transactions are independent. And you start thinking, well, maybe I could just randomly create some threads, isolate which state is touched by each thread, and if there's a collision, I fall back on a centralized thread for the transactions that touch this specific state. This gives you the possibility to process some kind of workload in parallel while still having a fallback in a unified state.
00:30:39.030 - 00:31:15.424, Speaker A: I don't know if that makes a lot of sense, but essentially it's about saying I have a bunch of transaction, I'm going to split them randomly to threads, and I have a fallback mechanism if they touch each other, and that works actually pretty well. The two point x optimization I just mentioned is due to that. It's something that we rolled out on testnet this week, and that will be rolled out on main net next week or so. I mean soon enough. I think the delay to go from Testnet to Mainnet is about a week. So this is going to be rolled out in mainnet soon. Now, is this enough? No.
00:31:15.424 - 00:32:01.360, Speaker A: So we are exploring various topics, and I can't comment enough on this. I'm going to give you pointers and then you can go read about them. The first one is called access list. And we thought a lot about this, and this is not necessarily where we're going, but it's an interesting direction. Access list is essentially you, when you're sending a transaction, specifying which areas of the state you're going to be touching, which smart contract, which sales. This basically gives the sequencer, when you receive the transaction, the ability to triage where each transaction should go. And this allows him to create, efficiently, threads to separate execution.
00:32:01.360 - 00:32:48.076, Speaker A: Now you may be thinking, okay, that's fine, but let's take an example where there's a big surge of usage on Ethereum. Let's say there's a nice NFT mint, and then everybody is trying to get to the same NFT mint at the same time. What would happen in that context? You wouldn't necessarily be able to process more transactions than you would be on a single thread, because if every transaction is touching the same area of state, you are still blocked by the capacity of one thread. So you can't go beyond that. You're still limited by the size of the sequencer. But the problem when there's a big NFT mint is that it's not only the people who are minting this NFT who are affected, it's also all the other people who are doing other stuff. They are in the same queue.
00:32:48.076 - 00:33:53.590, Speaker A: On Ethereum, having this kind of parallelization would allow everybody on the NFT mint to be on a single thread and all the others being on unrelated thread that would be less congested. And so it would not necessarily make the experience of the people and minting the NFT better, but it would make the experience of everybody else much better, which is already something good, and it avoids part of a backlog creating. Now, there's another avenue we're exploring, and I don't know enough about it to commence meaningfully on it. So I'm just going to say that using like there is something about typing and using types in the language in Cairo specifically that could help us parallelize better. And for that we're looking specifically at what move is doing and what the Sui team is doing. So a good insight is to take a look at how they process transaction, because this is something we're looking after and we might implement in Cairo. I don't know if somebody here, Ilya or Ben, you're familiar with this, and you can explain how this works.
00:33:54.840 - 00:34:32.560, Speaker C: I think in a sentence, it's basically a generalization of Utxos some objects, everything is an object. So the state is like a soup of objects. There is no distinguished accounts. It's a bunch of stuff. Every bit of stuff has an owner, and some stuff has a bunch of owners. And if something is owned by one entity, then it's basically independent, its location in the ledger, and the consensus is independent of the other transactions. So that kind of stuff can be parallelized like qtxos, because it acts like a literal piece of a literal tangible object.
00:34:32.560 - 00:34:39.270, Speaker C: It doesn't matter when it's given because no one else can dispute the action. I don't know if that makes sense.
00:34:39.880 - 00:34:47.990, Speaker A: Sort of. So wait, does that mean. It means that when you're sending a transaction, you'll still have to designate I'm touching this object, this object, and this object.
00:34:49.000 - 00:35:02.868, Speaker C: It depends, I think, on the implementation. But really, if all objects are owned and everyone knows that you are sending on objects that only you own, you don't have to say so because it's a part of the object's description.
00:35:02.964 - 00:35:07.100, Speaker A: But then what happens if you have something that is shared, like, I don't know, uniswap pool?
00:35:07.760 - 00:35:31.456, Speaker C: Yeah. The shared stuff can't be parallelized at all. What happens in sway is that they have for transactions, one is if you move shared objects, then there needs to be the usual consensus, but if you only move things that are owned by you, then there's a different flow. It's called fast pay, and basically you don't have to go through the entire consensus because it doesn't depend on other transactions.
00:35:31.648 - 00:35:41.764, Speaker A: Understood. So for a lot of stuff, like, I don't know, me sending a message money to Ben, if it's owned by both of us and nobody else touches it, it can be processed faster. Yeah.
00:35:41.802 - 00:35:55.550, Speaker C: And the idea is that basically this is you giving a tangible object to another person, and it doesn't matter when the rest of the system learns about it because it stays true, it's still true that you, at some point in time, went and gave someone a tangible object.
00:35:55.920 - 00:35:57.692, Speaker A: Nice. Okay, I understand.
00:35:57.826 - 00:36:04.930, Speaker B: I think if you treat objects like they do as first class citizens, the entire call graph becomes really easy to parse as well.
00:36:06.900 - 00:36:23.700, Speaker A: Nice. Cool. So, yeah, parallelization. This is something we're looking at what others are doing, and we don't have any concrete timelines or implementation for that, but this is something we're seriously looking at and is one vector of acceleration.
00:36:25.080 - 00:36:27.910, Speaker B: Henry Omar has a question. In the chat by the.
00:36:30.680 - 00:36:33.560, Speaker A: Omar. Yes.
00:36:33.710 - 00:36:42.620, Speaker E: Why is not being implemented in the layer one? For example, is there like a technical reason or, I don't know, maybe it wasn't plots at the beginning.
00:36:43.760 - 00:37:31.210, Speaker A: I think it's like a lot of stuff. We're standing on the shoulders of giants and there are some things that seem way more evident and self evident in hindsight. And when you're looking at Ethereum, you may think, oh, this needs to be made better. But when it was designed, it wasn't necessarily the case. And once things are deployed and everybody's using it, it becomes much harder to change. Yeah, right, the story of the AVM, right? Yeah, well, and to be fair, it's also the story of bitcoin, and one day it will be the story of Starknet. I'm sure we're making decisions where in five years we're going to think like, oh, obviously we should have made it differently, but that's fine, you have to start building at some point, otherwise you're just thinking and never deploying anything.
00:37:31.210 - 00:38:19.140, Speaker A: Sure. The second thing that is going to be a big speed up in the short term, it's going to take some time to roll out, is resting Starknet. So currently, Cairo and Starknet are both written in Python. And when I say both Starknet and Cairo, I mean like the Cairo VM executing code happens in a Python machine and the Starknet sequencer is written in Python. Python is great for prototyping. Obviously it's fast to implement stuff and it allows you to have quick results quickly and to test things. So that's why we showed that in order to release the first versions of Starknet.
00:38:19.140 - 00:38:54.420, Speaker A: Now, the thing is that Python is a bit slow. Like, there are languages that are way faster, and one of them is rust. So we're working to migrate slowly Starknet and the whole stack to rust. So the first major step, why would they use Rust and not C? That's a good question, and I'm not sure about that. I think. I'm guessing there are a lot of arguments for and against. I think ultimately Rust is more recent and it has the same kind of performances as C, from what I understand.
00:38:54.420 - 00:38:57.092, Speaker A: But. Good question.
00:38:57.226 - 00:39:03.610, Speaker C: I'm not sure it's also related to the typing. I think Rust has a better notion of types, but I'm really not.
00:39:06.860 - 00:39:09.370, Speaker B: Better memory safety guarantees as well.
00:39:10.560 - 00:39:47.892, Speaker A: So we do have some opinionated rust ins here. So the first major step will be to rewrite a Cairo VM in Rust. And so actually, so when you're compiling and when you're executing Cairo code, the VM will not be anymore in Python, it will be in Rust. And this is actually done. And believe it or not, the most radical thing about this is not that it was written in Rust, it is that it was written by somebody else than Starkware. And this is a really concrete step also towards decentralization. It's less tangible than conceptual algorithm, but I think it's an extremely important thing to mention.
00:39:47.892 - 00:40:53.224, Speaker A: This was not written by us, it was done by Lambda class. And so right now we have a Cairo VM in Rust, and the first thing we're going to do to make it fast is to wrap it in python so that we can use it in the Python sequencer to speed Cairo execution. And the benchmark I've seen are like ten to 15 times better. So I'm hoping that once this is deployed, we get to speed parity with Ethereum. Then the second thing would be to rewrite the sequencer in Rust. And for this, I'm not sure how public this is, but there's an effort to write a sequencer in Rust, which you should hear about in the next few, let's say months, low months, large weeks. Okay, so there's going to be a sequencer in Rust leveraging this, but the first impact you're going to see about the rusting of Starknet is going to be the sequencer will get faster, Proto star will get faster, and all the tools wrapping the VM will be faster.
00:40:53.224 - 00:41:22.550, Speaker A: Now, very good question by Omar. Would ints continue to be in Python? Hilly, I answered in the chat, hopefully not for too long. This is actually a question like, should you keep it in python? Something else? If I recall correctly, there's a discussion to have int been wasm so that people can write it in any language or not. Am I mistaken here? Or maybe not. Okay, I don't have many. Yeah, I'm not sure.
00:41:23.720 - 00:41:36.692, Speaker B: I think right now the rust implementation basically handwrites the whitelisted hints in rust. But eventually the plan, I think, is to go to wasm.
00:41:36.836 - 00:42:12.464, Speaker A: Yeah, and I'll be straight. For this presentation, I'm going to be saying I don't know, a lot, which I think is an important thing. These are things we're sharing with you, like what we're seeing under our horizon, but there's a lot of unknown and knowns. If you want to get involved, you can please ask more questions and write stuff. Then Arturo is saying, when the Cairo Rust VM is launched, do I need to redeploy my contract? No. So think about it this way. When imagine you run a guest node on your machine, on your windows machine, and now you move to a Linux machine and you run a guest node.
00:42:12.464 - 00:42:55.438, Speaker A: Do you need to redeploy your contracts? No, what happens is that the VM stays the same. It's just executed on another substrate. Well, the Cairo VM, the starknet VM, instead of being executed in Python, will be executed in rust, right? You can think of it as the underlying machine running Starknet. Does that make sense? I hope it does. Cool. Okay, so that's like these two things, parallelization and rusting the stack are the two immediate thing we're working on for performances. There are a large number of stuff we could do in the future.
00:42:55.438 - 00:43:34.718, Speaker A: I don't have them very clear for now. And to be honest, this is already going to take some time. This is going to be the focus of our team for the next few months, and this should bring very significant performance improvements. So this is the immediate we're working on. And then there are more broader stuff like decentralization. So before we move to decentralization, anyone want to add something on throughput and other avenues to speed up starknet? All right, so let's talk about decentralization. So as I mentioned in the beginning, we're lucky we got Ilya with us.
00:43:34.718 - 00:44:02.920, Speaker A: Ilya, you released recently a huge post about decentralization, which is very detailed and it is great. And I was wondering if you could talk to us a bit about first of all, where are we? If you had to designate the whole decentralization process, where are we? Are we at the very beginning? How far along have we made progress and what is left for us?
00:44:03.930 - 00:44:09.238, Speaker C: Just a second, someone asked something about. I can't really see, I don't have my glasses.
00:44:09.334 - 00:44:52.860, Speaker A: So is the core of the EVM developed by you or is it carried out by a partner that supports you? So I'm guessing you mean the Cairo VM. So we created and we coded the first Cairo VM. The Cairo VM, though is specified in a white paper that anyone can build on. And for the Cairo VM, here it is being developed by Lamita class, which is a company based out of Argentina, and they built it in rust. I hope that answers the question of Louis and then Darlington. Nam, sorry, is asking a link to the decentralization post, and Ben just posted it.
00:44:54.430 - 00:45:23.362, Speaker C: Right. So I think we're at the beginning of the decentralization because we're still thinking about what Starknet would look like. So we don't even have a concrete vision of what it would look like. Exactly. It's not the very beginning. We know sort of how we want provers and sequencers to behave, but nobody is working on implementing anything. No hard decisions have been reached, no particular protocol has been chosen over another.
00:45:23.362 - 00:45:25.470, Speaker C: So in that sense, I think we're in the beginning.
00:45:25.630 - 00:45:51.500, Speaker A: Very nice. So the post you outlined is essentially, I'm guessing it's an architectural post, right? It outlines a few constraints that we need to reach to have a nice consensus. It also separates between prover consensus, I'm sorry, sequencing consensus and proving consensus, though, as you mentioned in the post, is there a sense to have some kind of consensus improving? Right.
00:45:54.030 - 00:46:31.206, Speaker C: I think our viewpoint is basically this. We think about the sequencers as the consensus Layer, and the provers, they don't have to participate in a consensus protocol. They can work differently. For example, it's conceivable that sequencers reach consensus about certain stuff, post it to the l one, let's say periodically, and then provers can only choose stuff from what the sequencers have decided on to prove. So in this flow, the provers, they don't get to determine reality. They can only opt in or opt out.
00:46:31.308 - 00:46:33.430, Speaker A: So they're like service providers in a way.
00:46:33.500 - 00:46:43.740, Speaker C: Exactly. On the other hand, it could be like you described, it could be that provers are also an active part of the consensus protocol and they choose between different branches of reality, like sequencers do.
00:46:44.750 - 00:47:00.180, Speaker A: Question, can you detail a bit how it will work? So sequencers would be posting data to l one. How would that look like? And if they do. Sorry, no, please.
00:47:00.870 - 00:47:09.254, Speaker C: I thought of giving a rundown of the protocol. We currently have in mind an overview of it. So I'm going to share my screen.
00:47:09.372 - 00:47:10.258, Speaker A: Wonderful.
00:47:10.434 - 00:47:14.934, Speaker C: Show some pictures and I hope the story makes sure.
00:47:14.972 - 00:47:18.674, Speaker A: By the way, if there are questions, I'll read them, though, so don't worry.
00:47:18.802 - 00:47:45.274, Speaker C: Okay, cool. So here's the outline, let's say. Okay, let me make this clear first. This is one suggestion out of many possible suggestions, and this is not finalized. There is a lot of stuff in it that we haven't thought through, but we think this is a fairly simple one, which is easy to follow. So here's the entire protocol consists of four big steps. The first is a consensus layer, which is completely off chain.
00:47:45.274 - 00:48:01.170, Speaker C: And what it does is it constructs the ledger that we're trying to finalize. This is something that the sequencers. It's a protocol that the sequencers participated. The second step, and again, the consensus is completely off chain. There is no evidence of it on l one at all.
00:48:01.240 - 00:48:05.990, Speaker A: Okay, so when you say off chain, you mean off l one, not necessarily off l two.
00:48:06.140 - 00:48:37.506, Speaker C: Exactly. I mean, off l one. I mean, Ethereum doesn't know anything about this consent in itself. The second stage is called the checkpoint protocol, and it's also something that the sequencers do. And basically what it does is it periodically posts the consensus to l one. For example, a simple protocol would be every 100 starknet block. The sequencers gather some signatures and they post a commitment to the state, along with their signatures to l one.
00:48:37.506 - 00:48:45.010, Speaker C: So this is basically notifying l one of parts of the consensus. Does that make sense?
00:48:45.160 - 00:48:53.320, Speaker A: I think it does. My question is, what prevents sequencer from colluding and providing an invalid state transition here?
00:48:53.770 - 00:49:29.726, Speaker C: So it depends what you mean by invalid. I think there's two notions of invalid. The first one is that they construct a ledger which has, let's say a double spend. And the second one is that they provide a state commitment, a checkpoint to a state commitment, which is gibberish that nobody in the world knows how to prove. Okay, so these are two interesting, very different attacks. So in the first attack, this is something that will be resolved by Cairo, one by Sierra. If there is a double spend in the ledger, then the proverb can still prove the block and one of the transactions will be reverted.
00:49:29.726 - 00:49:38.722, Speaker C: But there is no risk in the sense of freezing or somehow crippling starknet. And there is also no security risk. It's a completely deterministic process, by the way.
00:49:38.776 - 00:49:56.730, Speaker A: So this means that when they post data to l one, they're committing to what happened on the networks, not what was the result of it. Right, because if they commit to, sorry. Because if they commit to the result, how can you prove that this result is invalid?
00:49:57.310 - 00:50:10.398, Speaker C: Okay, so let me see if I understand you correctly. So you're saying it's possible that the ledger includes some transactions, and when you execute them at one time you obtain a certain result, and when you execute them at another time you obtain a different result.
00:50:10.484 - 00:50:36.520, Speaker A: No, it's not exactly what I mean. What I mean is like, from what I understand, you're saying that if they make an invalid checkpoint that includes a double spend, when I'm proving it, I'm going to find that this transaction reverted. So this means to me that the sequencers post transaction data. So in a way like input data and not state updates, which is what we currently post.
00:50:37.210 - 00:50:59.150, Speaker C: I see. Okay, so this is not answered by the checkpoint protocol. This problem is resolved by the commitment and state update protocol. But basically what will happen is if none of the provers think that the state you committed to is provable, then none of them will commit to a proof and basically there will be some timeout period and this checkpoint will die. It will be deleted.
00:50:59.890 - 00:51:06.926, Speaker A: Okay. And so this means that all other checkpoints that were built on top of it will die also? Yes. Okay. Yes.
00:51:07.028 - 00:51:37.740, Speaker C: So let's get back to the checkpoint. So first of all, what are the goals of checkpoints? The goals, there are three goals. To increase abusers, to have accountability for misbehavior of sequencers, and to provide approvers with proving tasks. So it's not like a checkpoint is meant to provide eternal finality. It's only supposed to increase confidence. And indeed, it is the case that if someone posts a malicious checkpoint and other people continue to build on top of it, then all of that history can be erased from l one.
00:51:38.830 - 00:51:52.126, Speaker A: Okay, interesting. So just like now, you have something that is accepted on l two. You would have a new status which is accepted on l two checkpointed on l one. And then eventually it would be proven on l one. And then that's when it's rock solid. Yeah.
00:51:52.148 - 00:52:05.758, Speaker C: So here there are even four stages, right? There is first the consensus, then there's the checkpoint. And then there's another stage where some prover, he commits to proving it. So that's also another even higher intermediate finality.
00:52:05.854 - 00:52:09.394, Speaker A: So he's going to say, okay, I'm taking this one and proving it. Yes.
00:52:09.432 - 00:52:15.314, Speaker C: And that will give other people confidence that someone has actually decided to invest resources and begin to compute the proof.
00:52:15.442 - 00:52:16.310, Speaker A: Understood.
00:52:16.970 - 00:52:34.410, Speaker C: Okay, so I want to go through this flow again. So there is consensus off chain. The ultra sequencers, they talk between themselves in their peer to peer network. They do whatever they do. The consensus Protocol is black box. We don't know, maybe it's longest chain, maybe it's something else. I'll comment in the end what we're thinking of.
00:52:34.410 - 00:53:16.394, Speaker C: Then after some time, or every so often, these sequencers, they will produce a checkpoint and post it to l one. And that's the end of the role of the sequencers in the flow of these transactions. And now provers, they can look at l one and they see a bunch of checkpoints. Each of them has a turn, and in their turn they can post a commitment to proving certain checkpoints. And then they have a time window where they can post the actual proof. If they succeed, there is a state update and it goes on again. So I only describe the happy flow and we can dive into the more subtle details, but I want to ask whether the high level is sort of clear.
00:53:16.394 - 00:53:19.260, Speaker C: Is the happy flow clear? Does it make sense?
00:53:20.750 - 00:53:40.000, Speaker A: I'm guessing it does. I like the fact that proving, since it's not time sensitive, can be delegated in a non. It doesn't have to be a consensus. It can just be like, yeah, whoever can come and prove stuff.
00:53:40.690 - 00:53:41.198, Speaker C: Yeah.
00:53:41.284 - 00:53:43.742, Speaker B: I feel like you mentioned. Sorry, yeah.
00:53:43.796 - 00:53:44.778, Speaker C: What were we saying?
00:53:44.964 - 00:53:56.470, Speaker B: I feel like you mentioned at the second step there that if there's some commitment or checkpoint that the sequencer makes, that eventually is invalid, that it's erased.
00:53:56.970 - 00:53:57.382, Speaker C: Yeah.
00:53:57.436 - 00:54:08.794, Speaker B: Now, what's the actual interplay there with the l one? Is the actual data erased or is it just forgotten and never used?
00:54:08.992 - 00:54:35.234, Speaker C: So the idea here is that l one until the proofs actually come alongside the state diffs, which allow people to reconstruct the state from l one until the proof comes. The only thing that exists on l one is just evidence of consensus and maybe a state commitment. There is nothing that details the state beyond that.
00:54:35.432 - 00:54:35.986, Speaker A: Okay.
00:54:36.088 - 00:54:38.340, Speaker C: I'm not sure. Did this answer your question?
00:54:39.670 - 00:54:39.986, Speaker A: Yeah.
00:54:40.008 - 00:54:43.720, Speaker B: And I think you'll probably answer my question in the unhappy path as well.
00:54:45.130 - 00:54:49.014, Speaker C: Okay, cool. So, anything else here, or should we go on?
00:54:49.052 - 00:55:05.802, Speaker A: I'm guessing we'll get there also later on. But I'm curious how you pay for everyone here. Like, who gets paid how? I'm guessing sequencers get paid by users in their transaction. How do you pay for provers when you don't know when you're producing the block, who's going to be paid? And stuff like that?
00:55:05.936 - 00:55:46.490, Speaker C: I think this is a very difficult question, and I want to make it clear that we don't have a complete solution to all the incentives. It's a very interesting problem we have. Some of it. Some of it makes sense, some of it is intuitive, and other parts are very mysterious. For example, one of the most mysterious questions is how do you build incentives, which on one hand, they allow provers to be decentralized, and on the other hand, they incentivize provers to be as powerful as possible and to constantly improve their machines, because it turns out that these things basically have a trade off. So there's a bunch of interesting stuff, but I think it's a bit orthogonal to the flow of the protocol.
00:55:46.990 - 00:55:49.482, Speaker A: Understood. So let's proceed. Cool.
00:55:49.536 - 00:56:35.206, Speaker C: Okay, so there's two key design choices that I want to make right now for the suggestion. So the first is this, let's call it checkpoint forking. So one option would be that on l one, there is only one chain of checkpoints. That means that each checkpoint must be a successor of the previous latest checkpoint. And you can't fork checkpoints so in this flow, provers, they can only veto. By refusing to prove a certain checkpoint, they cannot choose between different branches of reality. The alternative would be to have a checkpoint tree on l one, like you have a block tree, like in longest chain, and then provers, they can choose between branches.
00:56:35.206 - 00:57:01.554, Speaker C: So we will focus on the first suggestion of a single checkpoint chain. And the motivation for this is Twofold. First of all, it's much simpler. And the second, it's much more obvious that checkpoints, they add confidence this way, because if you can't fork between checkpoints, then you know that a checkpoint must really mean something. Otherwise anyone can post it. Maybe any prover can choose whatever they want.
00:57:01.672 - 00:57:09.554, Speaker A: Yeah, in a way, checkpoints are designed for happy flows where we want to give an extra guarantee to users. So might as well optimize them for the happy flow.
00:57:09.682 - 00:57:50.862, Speaker C: Exactly. The second design choice, it pertains to how much stake do you require for producing a checkpoint? And the simple suggestion would be to use a supermajority of all of the stake. Okay, so let's say you use two thirds of the entire stake. The other option would be to have some more subtle local versions of the stake. For example, in longest chain, finality is determined by how many blocks build on top of you. So you could say that the finale is just the sum of the stake of the 50 blocks that follow you. This is very different from taking some supermajority of the global stake.
00:57:50.862 - 00:58:01.350, Speaker C: And again, for simplicity, let's just say we're talking about a supermajority of the total stake when we're talking about a checkpoint. So imagine two thirds of the entire stake is signed.
00:58:03.530 - 00:58:17.100, Speaker A: Yeah, it sounds like the second thing. Sounds like the second point here. Aggregating stakes with longest chain fits better when you have a checkpoint tree. So if we don't have a checkpoint tree, maybe it doesn't make sense.
00:58:18.110 - 00:58:38.080, Speaker C: I think there is still an interesting trade off, but I think, let's even say for simplicity, we'll focus only on the purple. Decision on the purple. Okay, so the next thing I want to do is go over this table, this table, what it's supposed to do or what it's trying to do. I don't want that. What do I want?
00:58:39.330 - 00:58:40.080, Speaker A: That?
00:58:41.510 - 00:59:18.510, Speaker C: What it's supposed to do is it's supposed to partition the entire protocol into four separate protocols, and we can try to understand some properties of them one by one. And this will simplify, let's say, the global view. So there's four protocols overall. There's the consensus protocol. There is a checkpoint protocol. There is a state update protocol and there is also on the side a slashing protocol which is supposed to disincentivize people from being naughty. So the state update protocol, you may be wondering why are there only three protocols here? If here there were four things.
00:59:18.510 - 00:59:47.490, Speaker C: And the reason is that the state update protocol includes also the commitments and also the state updates themselves. These two things are coupled in the state update protocol. Okay, so let's talk about these. First of all, we'll do it column by column. So the consensus, who participates? The sequencers participate. They have a proof of stake, civil resistance, that's managed on l one. All the stake is managed on l one, and I'll talk about that in a minute.
00:59:47.490 - 01:00:16.282, Speaker C: There is a very good reason for that. Even too, the protocol is leader based, but let's not decide what it is. Maybe it's longest chain, maybe it's some sort of fancy dag based Pft, I don't know. Let's keep that abstracted for now. Why should you participate? You want to get a block reward and you want to get transaction fees. And what are the weaknesses? It's the same for all the consensus protocols. You can have inactivity, you could have network problems and you could have equivocation.
01:00:16.282 - 01:00:36.200, Speaker C: Equivocation. It means that you tell different things to different people at the same time. For example, let's say I'm a block proposer. Now, I give Henry one block and I give Ben a different block and I pretend that both of them are the blocks for the same slot. This is very bad behavior. It can really fuck up a protocol. We don't want it.
01:00:36.200 - 01:00:57.534, Speaker C: Okay, what else do the sequencers do? They run a checkpoint protocol. So it's also proof of stake managed on l one. It is also leader based. What does it do? What is it supposed to do? It's supposed to certify a certain state commitment with some amount of stake and then upload it to l one. That's what it's supposed to do.
01:00:57.652 - 01:01:05.280, Speaker A: So it's a fully different consensus algorithm with different stake. Different.
01:01:06.210 - 01:01:17.250, Speaker C: First of all, it's the same stake and the same sequencers. There is one pool of stake that's called the sequencer stake, and the sequencers use it for the consensus and the checkpoint protocol.
01:01:17.990 - 01:01:24.710, Speaker A: Okay, so you can't just be a checkpointer or just be a sequencer. No, you're doing both. Okay.
01:01:24.780 - 01:01:28.370, Speaker C: A sequencer runs two protocols, the consensus and the checkpoints.
01:01:28.450 - 01:01:29.270, Speaker A: Understood.
01:01:30.890 - 01:02:07.282, Speaker C: And the third thing, which we decided in the design choices above, is that there is no forking. So there are no conflicting checkpoints on l one simultaneously. Every checkpoint must continue the most recent checkpoint. Okay, why do you want to participate? So this is a bit more subtle. First of all, there is a very primitive reason. We probably will reward people, even if it's sequencers, even if it's provers. We will reward them only after there is a state update on l one, which means that someone has to prove it.
01:02:07.282 - 01:02:38.574, Speaker C: And since only checkpoints can be proved, if you want to get money, you want to participate in creating checkpoints. This sounds convincing, but it is a bit subtle, because basically, it's not really clear why you shouldn't sign anything that someone offers you. So, suppose Enri is one of the people that are one of the sequencers, and I give him a checkpoint. I say, henry, just sign it. Don't look at it, just sign it. What do you care? And maybe Henry signs it.
01:02:38.612 - 01:02:40.046, Speaker A: I can get slashed. No.
01:02:40.228 - 01:02:43.850, Speaker C: So the problem is this. Suppose the checkpoint is gibberish.
01:02:43.930 - 01:02:44.222, Speaker A: Okay?
01:02:44.276 - 01:02:50.354, Speaker C: Suppose there is a state commitment which is complete gibberish. No prover will be able to prove it.
01:02:50.392 - 01:02:50.930, Speaker A: Right?
01:02:51.080 - 01:03:27.646, Speaker C: But the l one cannot distinguish between the state. Where provers can't prove it because they don't know it, or provers can't prove it because their machine is having problems. And because we can't distinguish between these, this creates a bit of a problem. We can't slash people if it's just a network partition. We can't ruin their life. It's a bit subtle. And in general, incentivizing people to create other people certificates is a bit subtle with incentives, but I think I don't really want to dive into that.
01:03:27.646 - 01:03:31.098, Speaker C: Now, the rough idea is that you need checkpoints to get rewards.
01:03:31.274 - 01:03:35.790, Speaker A: Makes sense. There's a question, but we'll cover it once you're done with the table.
01:03:36.770 - 01:03:39.620, Speaker C: Should we wait for the whole table? I think it's a lot of words.
01:03:39.990 - 01:03:49.140, Speaker A: Okay, the question is, is there a bottleneck here? I'm not sure that I understand the question fully, to be honest.
01:03:49.750 - 01:03:57.510, Speaker C: Let's think. I mean, what bottlenecks do we have? We can have a bottleneck for execution, which is the usual bottleneck. We can have a bottleneck for proving.
01:03:58.170 - 01:04:10.410, Speaker A: Or the time between block. I know that depending on the consensus you're choosing, it impacts. And the size of the network, it impacts how many blocks you're able to emit at every given period of time, right? Yes.
01:04:10.480 - 01:04:47.670, Speaker C: But I think this question of bottlenecks is a much more sneaky question than it appears, because there are a lot of bottlenecks in every, what's called a monolithic consensus protocol. So I think if the standard example of a BFT consensus is tendermint, then tendermint has a bunch of bottlenecks that are hidden into it. And one way to resolve them is to use DAC based protocols. And I think this carries us off on a real tangent. So I think my answer is yes, there are probably bottlenecks here, but I think they can be resolved, and I'm not sure that I want to dive into all of them.
01:04:47.820 - 01:04:48.520, Speaker A: Fine.
01:04:49.530 - 01:05:05.606, Speaker B: I have one more question, which might be better after this table as well. But what's the signature like for these commitments that the sequences are making? Is there any interesting thing with signatures? Is there BLS aggregation? Are we doing anything fancy under the hood?
01:05:05.718 - 01:05:20.110, Speaker C: I think we'll want to do BLS aggregation. But first of all, I'm out of my depth here because I don't know anything about BLS aggregation. And second of all, I think I don't really care yet because I don't care about the implementation yet. I just want to see if it makes sense with incentives.
01:05:20.270 - 01:05:24.114, Speaker A: Got you. Right.
01:05:24.152 - 01:06:02.666, Speaker C: So we're at the weaknesses of the checkpoint protocol. So there is one additional very important weakness, which is a one time data availability hijack. So all this means is, it means the following. Suppose I'm a very rich person and I just bribe all of the starknet sequencers for, let's say, a couple of hours, and I produce a checkpoint which just has a gibberish state commitment. This is a big problem because nobody will be able to prove it. So this can cause problems for the protocol and it must be treated. This is something which we really have to take into consideration.
01:06:02.778 - 01:06:11.346, Speaker A: Wait, in this case, if the checkpoint is gibberish, it just won't be proven and it would just eventually fall off if there's inactivity. Right, so that's the remedy, right?
01:06:11.448 - 01:06:23.938, Speaker C: Yes, exactly. Of course, this is a bit suboptimal because the fantasy is that there would be no added latency. But we don't see a way around having some sort of timeout.
01:06:24.114 - 01:06:31.522, Speaker A: Yeah, because as you mentioned, there's no way to distinguish between something that's gibberish or something that is. Yes, exactly. Okay.
01:06:31.596 - 01:06:40.038, Speaker C: Exactly. Not only one possible solution would be to require the checkpoint itself to contain state diffs.
01:06:40.214 - 01:06:42.742, Speaker A: Yeah, but then it would be much more costly.
01:06:42.886 - 01:06:55.834, Speaker C: Exactly. And we don't want the sequencers to incur l one costs. We want them to mostly have very little interaction with l one because that's not their job. Their job is not to deal with l one gas prices and their fluctuations.
01:06:55.962 - 01:07:04.820, Speaker A: Okay. And to be clear, checkpoints won't have any kind of impact on when you can withdraw on the frequency of withdrawal, right?
01:07:06.310 - 01:07:10.534, Speaker C: No, I mean, withdrawals are finalized by proofs only anyway.
01:07:10.732 - 01:07:15.320, Speaker A: Okay, so I'm guessing. Okay, sorry, I'm a bit ahead of myself. Please go on.
01:07:16.170 - 01:08:21.862, Speaker C: Okay, so before I go to these two columns, I want to elaborate on having stake on l one and why we want to do it. So first of all, how are people slashed on ethereum? Why is ethereum not very good at slashing a lot of people? So slashing on ethereum means that suppose I caught and redoing some horrible double voting, right? So what do I want to do? I want to submit an ethereum transaction that tells people, hey, Henry is a bad person, let's slash him. And what needs to happen now? There has to be consensus on this transaction for it to be included in the ledger, and only after it's included, everyone executes it and Enria is slashed. Okay, now suppose 50% of the people don't think Enria is a bad person. Then 50% of the people will not allow me to get the finalization that I need. So Enri will never be slashed. Basically, the problem here is that there is no way for an honest minority to slash a malicious majority.
01:08:21.862 - 01:09:09.114, Speaker C: It's not possible on Ethereum because the majority will censor them. But there is an even worse problem. It's not even possible for an honest majority sometimes to slash a malicious minority. For example, if 55% of ethereum, which is a majority, thinks that Enria is doing something bad, it's still not enough because you need 67% to finalize something in ethereum and 45% can censor it. So an ethereum slashing can only happen when you have a real supermajority of people that agree with the slashing. And this is definitely suboptimal. I mean, it would be really nice if one person, one honest person could hold 99% of the protocol by the balls if they do something bad.
01:09:09.114 - 01:09:15.734, Speaker C: That would be amazing if one honest person could trigger 99% of people to be slashed if they do some double.
01:09:15.782 - 01:09:22.366, Speaker A: Voting, as you're mentioning it, they can just decide to ignore him and not include his, not listen to it.
01:09:22.388 - 01:09:48.440, Speaker C: Exactly. And this is the beauty of being a roll up that we can enforce slashing using Ethereum. So we don't care if 99% of the starknet sequencers are evil if their stake is on l one because then someone can submit the evidence to l one, and then l one will enforce the slashing. Even if the sequencers don't agree, we can still slash them.
01:09:48.970 - 01:09:54.026, Speaker A: Nice. We can always go cry to daddy. That's nice. Exactly.
01:09:54.128 - 01:09:57.994, Speaker C: So we have big daddy Ethereum to protect us. That's one thing.
01:09:58.112 - 01:10:00.860, Speaker B: Henry's a bad man. Henry hit me.
01:10:02.750 - 01:10:24.990, Speaker C: Yeah, so that's a big advantage. And another thing is it gives also a very strong permissionless property for the same reason. Suppose I want to become a validator on Ethereum. I need consensus. I need everyone, or I need a supermajority to finalize this transaction. And if they don't, I can't become a validator. So let's say that some cartel has taken over ethereum.
01:10:24.990 - 01:10:45.740, Speaker C: They can censor anyone else from ever producing blocks. This is not a good thing. And again, we don't have that problem because we have big daddy Ethereum. So if I want to become a starknet sequencer, I just need to put some stake on l one and that's it. L1 takes care of me becoming a starknet sequencer. I don't need the consensus of l two.
01:10:46.350 - 01:10:49.580, Speaker B: Hey, alia, is this internal or is this public?
01:10:50.190 - 01:10:57.006, Speaker C: This is internal for now. I'm working on the last post of the series, which will be a readable version of this.
01:10:57.188 - 01:11:04.862, Speaker A: Nami is asking if he can get this table later on to go over it. If you plan on amazing. Cool.
01:11:04.916 - 01:11:07.154, Speaker C: It will give you a heartburn, but sure.
01:11:07.352 - 01:11:26.070, Speaker A: Nice. This is really interesting. I'm guessing we often say there is often this thing like, oh, we're not a monolithic blockchain and we have security execution. I feel like we're really leveraging that. It's really cool to be able to delegate security somewhere else.
01:11:26.220 - 01:12:11.480, Speaker C: It's amazing having l one. It does two things that are, I think, important to understand conceptually. First of all, it means that we can have our own enforcer, right? The l one can enforce smart contract logic, which we can't enforce if we have a malicious consensus. And also because l one is so centralized, we don't need to be as centralized because as long as we have correct proofs, sorry, I maybe misspoke. We don't have to be as decentralized as ethereum because we have proofs. So as soon as those happen, ethereum takes care of the rest. The decentralization there is much stronger than ours, and it's really good.
01:12:13.770 - 01:12:33.626, Speaker B: That question has actually come up in base camp and the question is kind of, can we write proofs and state diffs to another l one and we go over kind of why that's not why, that's suboptimal. Things like this are pretty demonstrative of we're going to be more tightly coupled to the l one in the future. Would you agree?
01:12:33.728 - 01:12:37.760, Speaker C: Yeah, maybe. I don't. What was the question?
01:12:38.130 - 01:12:57.090, Speaker B: We're going to be more tightly coupled to Ethereum specifically in the future, as opposed to, hey, why can't we just write proofs and prove on another l one and then write the state diffs to another l one? And why can't we just basically prove and write state diffs to every l one? Why is that suboptimal?
01:12:58.710 - 01:13:08.120, Speaker C: Are you saying we write the state diffs on chain one and then post approves on chain two? Or are you saying that Ethereum is distinguished and special?
01:13:09.050 - 01:13:27.518, Speaker B: Well, so as a roll up that we are a validity roll up on top of Ethereum? Well, why can't we be a validity roll up that operates on top of Ethereum and Solana and Avalanche? Well, we're kind of limited ourselves by.
01:13:27.524 - 01:13:50.334, Speaker A: The least secure chain because we need one jurisdiction, we need one unified vision of the world. And these chains don't agree with each other. They all exist in a vacuum. So you need to decide where matters are settled and you need every player to accept that. And you can't force avalanche to accept Ethereum's consensus.
01:13:50.462 - 01:13:59.094, Speaker C: You can't have too many daddies. Basically you need one. And if two daddies don't agree, then they fight. And the strongest daddy wins and Big Daddy is.
01:13:59.292 - 01:14:00.806, Speaker A: Yeah, and the thing is that could.
01:14:00.828 - 01:14:02.040, Speaker B: Be your dad up.
01:14:03.530 - 01:14:10.474, Speaker A: They won't even fight. You will have to choose, which is kind of horrible. And some people will be heartbroken. Yeah.
01:14:10.512 - 01:14:20.750, Speaker B: But as far as that question goes, I think it was in camp three that we got it. Not only do we exist as a validity to roll up on Ethereum, but we're going to get more tightly coupled to Ethereum.
01:14:25.490 - 01:14:34.180, Speaker C: Right. So I feel I'm talking a lot and progressing slowly. So do we want to finish the stable? Do we want to see a nice picture? What do you think?
01:14:34.950 - 01:15:16.910, Speaker A: I'm thinking that first let's direct this question to people listening. Do you have question, do you want to talk more about other subjects? Do you want to dive deeper in this? Let us know. My instinct would be let's move forward a little bit. And I think these topics are extremely interesting and having more public calls and more public discussions around that would be amazing. But that's a topic for another day. Maybe let's see if other people think the same thing. But, yeah, I don't know, maybe let's not dive too deep into subtopics.
01:15:17.890 - 01:15:38.594, Speaker C: Okay, cool. So I think the last thing I'll try to say about the protocol in that case is look at this pretty picture. We can all agree it's a pretty picture, and I'm just going to really run through it without explaining almost anything. And you're going to be convinced because it's a nice picture and it has colors.
01:15:38.722 - 01:15:39.062, Speaker A: Yes.
01:15:39.116 - 01:15:57.302, Speaker C: And it's a nice, colorful picture. Which is even stronger. Exactly. So what is this? This is a flow of the protocol. But the consensus and the checkpoint protocol are black boxed. The only thing that's unpacked here is the state update protocol. Okay, so this is the flow.
01:15:57.302 - 01:16:25.510, Speaker C: When the consensus and the checkpoints are abstracted away, what we're going to do is we're going to go through a transaction lifecycle. We're going to see what happens to it and how it can reach a state update. Henry submitted a transaction on Starknet and the first stage is consensus. He saw his transaction included in some l two block. Great. What's he waiting for now? Now he's waiting for this block to be included in some l one checkpoint.
01:16:25.930 - 01:16:41.100, Speaker A: Right. So being included in a checkpoint is just you being a little more sure that your transaction is going to be finalized, but it doesn't make you be able to check out more stuff earlier and things like that. Right.
01:16:41.950 - 01:17:00.066, Speaker C: The answer to the second question is right. And to the first question, the confidence you gain really depends on how much stake is backing the checkpoint. And one of our design choices was that it's a supermajority of the entire stake. So because of this, when you see a checkpoint, it's a big deal.
01:17:00.248 - 01:17:00.834, Speaker A: Okay.
01:17:00.952 - 01:17:11.640, Speaker C: There is a lot of money backing up your shit. So it's not finality. Definitely not, because the provers have to do something, but it's definitely a good sign.
01:17:14.920 - 01:17:15.670, Speaker A: Cool.
01:17:16.600 - 01:17:54.172, Speaker C: Now you're waiting to be included in a checkpoint. As long as you don't have a checkpoint to your block, you're invisible to l one, you're basically side chain security, or l two security. Okay, suppose you are now included in a checkpoint. Now what's supposed to happen? Some prover is supposed to commit to prove your checkpoint. That's what you're waiting for. You're waiting for one of the provers to actually commit that he is beginning to calculate a proof that includes your transaction. Okay, let's suppose there is 1 hour without any commitment.
01:17:54.172 - 01:18:16.552, Speaker C: Let's ignore the second line here. Let's suppose there is 1 hour without any prover committing to your checkpoint. This is a bad sign. It could potentially. What it probably means is that either the provers are malicious or there is a problem with your checkpoint. For example, we discussed the data availability problem of a gibberish checkpoint. If the checkpoint is gibberish, then this would happen.
01:18:16.552 - 01:18:51.196, Speaker C: No prover would commit to proving it. Okay, what happens now? An hour passes and the checkpoint and its successors are invalid. The checkpoint and all the checkpoints that come after it are invalid and we go back to the consensus. Okay, so think of this as the checkpoints are deleted from l one and we go again. Okay. Let's suppose that some prover did post a commitment to your checkpoint. If the prover posted a commitment and he fulfilled the commitment in time, he had some time window to compute the proof and he succeeded.
01:18:51.196 - 01:18:58.244, Speaker C: We perform a state update. That's it, you win. Okay, makes sense so far.
01:18:58.362 - 01:19:22.860, Speaker A: It makes sense. What I like about this is that the fact that anyone can pick a proof means that, well, you can wait for a big enough amount of checkpoints to be available for you to pick it up for it to make sense financially to you. Or it can make sense for you to be in hurry and say, no, I'll pick it up as early as I can so that I can withdraw my money as fast as I can.
01:19:23.010 - 01:19:50.192, Speaker C: Exactly. And one more important option is you don't have to do anything. You can choose to be idle and nothing happens. Which is also very important, because if the l one gas has fluctuated and it's very expensive and there is very few checkpoints, then maybe you don't want to prove anything and that's fine. There is no reason to impose the costs of this on you. It's not your fault that l one gas is expensive. So being idle is also a very important option for approver.
01:19:50.192 - 01:19:52.070, Speaker C: You don't have to always do stuff.
01:19:53.080 - 01:20:02.280, Speaker A: Yeah, but in that case, if price is very expensive, and I'm a sequencer, I posted a checkpoint and nobody will pick it up, I'm kind of fucked just because of gas prices.
01:20:03.420 - 01:20:49.240, Speaker C: I mean, that's one of the reasons that we think the checkpoint will maybe be expensive, but the prover will be able to prove how much it cost and then the sequencer will be repaid. But I think what you're pointing to is a very important problem which is not addressed here, is that the sequencers, they have some risk taking that is related to l one. Right? Because posting the checkpoint requires some speculation on future gas prices. And maybe the protocol will abstract this away into some l one futures market. There will be some futures market for l one gas. But again, I think this is a bit orthogonal, so let's leave it out. So we finished this leftmost fork.
01:20:49.240 - 01:21:04.350, Speaker C: This is the happiest flow. There's consensus. There's a checkpoint. Someone commits and someone proves it. You have a state update. Let's say that someone committed to posting a proof, but he didn't. The commitment is unfulfilled in this case.
01:21:04.350 - 01:21:34.170, Speaker C: I have a fancy name, exponential opening, which basically means that if one prover fails, two can try. If both of them fail, four can try, so on and so forth for, let's say, 10 hours. So gradually, the commitment opens up to more and more provers with every stage funded by the previous stage. So the first fails, he slashed enough to fund two more. Two fail, both of them are slashed to fund four more, and so on.
01:21:35.260 - 01:21:56.204, Speaker A: So this means that this funds more and more people to get involved. But the first one is. I don't know, he has to post a stake of, like, n. Then it means the following one will get n divided by two plus the initial, plus the block reward. Okay, cool. I mean, the proof reward. Yes.
01:21:56.402 - 01:22:12.484, Speaker C: Okay, great. So if this exponential opening. If the commitment is proving, during this opening, you have a state update again. And if there's 10 hours of exponential opening without anything happening. And notice a lot of people have been slashed here.
01:22:12.522 - 01:22:12.676, Speaker A: Right.
01:22:12.698 - 01:22:24.680, Speaker C: Because there's 10 hours where people decided to join and didn't succeed. That's a lot of slashing. And then again, you revert, you delete the checkpoint, and you go back to the consensus.
01:22:26.940 - 01:22:36.652, Speaker A: The time described here, 1 hour. 10 hours are kind of like how they're impacted by how big the proof is.
01:22:36.706 - 01:22:58.000, Speaker C: No, very much. The numbers here shouldn't be. I've just taken them for convenience. And of course, these are super sensitive parameters. Maybe proofs will be 8 hours, maybe they'll be half an hour. Recursion is very important here. A lot of stuff is very sensitive to changing the parameters.
01:22:58.820 - 01:22:59.570, Speaker A: Okay.
01:23:00.680 - 01:23:02.820, Speaker C: Yeah, but that's the flow.
01:23:03.480 - 01:23:07.540, Speaker A: That is really interesting. Thanks a lot. There is a question. I think it was you, Ben.
01:23:10.520 - 01:23:24.376, Speaker B: You answered it. My gut heard exponential slashing and then saw 10 hours. And I was thinking that could get to a ridiculous amount of stake slashed. But if the proof takes 8 hours, that makes more sense.
01:23:24.558 - 01:23:36.140, Speaker C: Yes. All of this is opt in, right? This is 10 hours of slashing, assuming 10 hours worth of people is trying to prove something and failing.
01:23:36.480 - 01:23:37.228, Speaker A: Right?
01:23:37.394 - 01:23:42.088, Speaker C: If nobody commits to proving it, then it's going to be deleted earlier.
01:23:42.264 - 01:24:06.356, Speaker A: Okay. Depending on the frequency of people dropping commitments, it might actually make sense for you to start proving earlier so that you can pick up one commitment. Okay, cool, thanks. This makes a lot of sense. I mean, this is really interesting. I don't know if there are questions in the audience. Are you guys following? Is everything clear? And I hope you find it interesting.
01:24:06.356 - 01:24:12.016, Speaker A: As iya mentioned, this is very much work in will.
01:24:12.058 - 01:24:25.116, Speaker B: I want to say one thing real quick. I feel like the base camp got some alpha here. I think this is the most public conversation of this decentralization post. It's happening in base camp. You guys get it first.
01:24:25.298 - 01:24:53.764, Speaker A: Well, I think this is a great avenue to do it. It's not like we have a lot of avenue to have in depth research calls about these things and maybe we should have more. But I think that for this kind of audience who has followed through basecamp, has studied in depth how Cairo and starknet works, I think it's the perfect audience to have that they're a little bit quiet, so I hope people are following. But I think it's a great idea.
01:24:53.802 - 01:25:14.904, Speaker C: To have it that we really care. Like I don't interact that much with the community, but I would be super interested to get any sort of feedback and suggestions because we could really use anyone's opinion. So I think feedback, it would be amazing for me to receive a lot of feedback.
01:25:14.952 - 01:25:50.010, Speaker A: I'm just saying. Very cool. Okay, so this is what you were able to present on decentralization. I know it's a bit late on your end, so I don't want to hold you up too long and I don't think we'll be able to cover if we ask a lot of questions, both topics. But you mentioned the fee market, that there's an interesting discussion to be had over that and then an interesting discussion about state growth. Do you want to pick one? And then we can just talk a bit about it and let's target for 15 minutes.
01:25:51.020 - 01:26:06.860, Speaker C: I think fees are too big a topic and I don't have much to say about state growth, so I think it's a better option. And also I think my ideas about it are not popular at all, so it's even better and with a bit of controversy.
01:26:07.360 - 01:26:10.956, Speaker A: Very nice. Okay, so let's go state growth. We're listening.
01:26:11.068 - 01:26:26.390, Speaker C: Okay, so what's the problem? The problem is this is the common problem as it's usually presented is state is growing constantly and it's harder for full nodes and sequencers to keep track of the entire state. This is bad. What can we do?
01:26:27.480 - 01:26:27.892, Speaker A: Nothing.
01:26:27.946 - 01:26:42.436, Speaker C: We can't do nothing. We can do some stuff. We can have a separate storage fee, we can charge rent. Who cares? You're a Nazi for talking about this. There is a bunch of opinions right at its core.
01:26:42.628 - 01:26:56.296, Speaker A: If we summarize what the state growth problem is, is that you're doing a transaction once and then it lives for eternity on the resource of everyone who has to maintain it. So in other words, you pay once for a cost that is forever.
01:26:56.488 - 01:27:56.320, Speaker C: Yes, exactly. And I think this is the point which should be sharpened. So in reality, there is nothing wrong with purchasing one object from another person forever, like for ownership to completely shift from one person to another. But I think the difference in blockchain is that the state, and the consensus more generally, is collectively owned by a changing set of sequencers over time. So it's not true that there is a one time multi sig of a specific set of sequencers and it stays the same set forever. So when I'm buying a storage cell from Henry, who is the sequencer at time a maybe ten years after Henry is doing something else, maybe he's a dancer, and a bunch of other people are running the system and they have to keep track of Henry's bizarre decision to sell me a storage cell. So I think this is a bit strange.
01:27:56.320 - 01:28:00.972, Speaker C: I don't think it's immoral or anything, but I do think it's a strange phenomenon.
01:28:01.116 - 01:28:56.660, Speaker A: I agree. I agree that it's an interesting. It goes against a lot of things we say in the blockchain, that when you write stuff in the blockchain, it's forever. But at the same time, what is forever in the absolute? Is there anything forever? It's a weird way to say it, but what you're saying basically reminds me of how things are dealt with in cemeteries, at least in France, when you want to have a place to bury your body, your body, you pay for it and you pay for it to the municipality it is in because it has maintenance. You have to pay people to make sure nobody comes in at night, to make sure that it stays clean. And this has an expiration date. And if you stop paying for it, eventually this concession is put back on the market for sale.
01:28:56.660 - 01:29:14.250, Speaker A: It feels sad because it's somebody else's remain. But then again, if nobody has manifested for thousands of years and the person has been dead for a very long time, does it really matter?
01:29:16.060 - 01:29:51.110, Speaker C: I agree, and this is the case I'm going to try and give. So I'm thinking from the perspective of the protocol designer. So I think a very good property a system to have is for users to only pay for the stuff that's actually being used actively. Right. So I don't want my system to incur user fees for stuff for, like, a storage cell that hasn't been touched in a year. That doesn't make sense to me because I'm basically making users pay for something that nobody is using. Right.
01:29:51.110 - 01:29:53.376, Speaker C: It's literally strange.
01:29:53.488 - 01:30:08.392, Speaker A: And there's also divergence. Like, if you make people pay for things that are not used, well, you have no incentive to use it. And so you will focus on the things that are very much used. And the one that are not used, it will just never be used anymore. But they'll still be here. And costly.
01:30:08.536 - 01:30:22.450, Speaker C: Yes. So I think the root of the problem is the fact that we need the protocol to somehow encourage the participants in the protocol to divert resources from inactive things to active things.
01:30:26.260 - 01:30:31.520, Speaker B: Do you kill inactive things? Do you make it just hard to retrieve?
01:30:33.540 - 01:31:04.350, Speaker C: I think we want to shift the cost. First of all, we don't kill it, but I think we want to shift the usage cost or the activation cost from the participants of the protocol to the users. This is, I think, the natural thing. So let's say you wrote a storage cell, right? And you haven't used it for ten years and you want to reactivate it, then the burden is on you. You can't just come to the sequencer and say, hey, please climb this mountain and retrieve this strange bucket that I have there. You should go and do it yourself.
01:31:06.480 - 01:31:46.424, Speaker A: So, wait, isn't there a possibility also for people? I'm guessing that's kind of what you're pointing at, but isn't there a way to, I don't know, segment states so that after a while, some part of states are still valid, but they're dropped by sequencers. And if you're sending a transaction to sequencer, we'll say, well, I need more data. Retrieve the data, give it to me, I'll execute it. But if you don't, I can't. And then the burden is on you to say, yeah, here's the data, and then there's a cost, but it's not on chain cost, right. There's no notion of state rent. The states stay valid, but you yourself have to retrieve it.
01:31:46.622 - 01:32:17.620, Speaker C: Yes, I think this is very natural, but again, this is a very unpopular opinion, and I think it's unpopular in part because people are used to having a one time event where they get ownership of something forever. And obviously it's not easy to tell people you can't have that anymore because it's not natural. But I think from the perspective of the protocol designer, it makes much more sense to prevent users from imposing costs on all the other users for some one time event, which is useless.
01:32:18.280 - 01:33:31.404, Speaker A: And also I think having this possibility of saying, hey, you can revive a storage cell if you provide the data. Having the tooling for that actually can be useful in other areas and specifically for data availability and volition, in the sense that if you maintain different states that you can use in your smart contract, but one of it is on chain, the other one is off chain, and you give the possibility to somebody in a transaction to say, hey, here's the state, execute the transaction and it's valid. You basically leave it to people to choose where distorted their data, whether it's on chain. And this is thing where we assume sequences, we keep it for like a year or two, or it's off chain. And then you either provide the data because you decided that your data availability solution is to have it on a USB drive, or it can be on Celestia. But Celestia is one state tree, and some sequencers can decide to operate this data availability layer on the site as a plugin on top of their sequencer, and they can provide this service to service more transaction, but it makes it modular. And sequencers can basically decide which data availability consortium they're part of.
01:33:31.404 - 01:33:32.588, Speaker A: I don't know.
01:33:32.754 - 01:33:51.916, Speaker C: Yeah, I think so too. I think all of this stuff is, I guess people are just afraid, or maybe they're worried about delegating this responsibility to users, which I think is understandable, but I think it's going to be inevitable eventually.
01:33:52.028 - 01:34:29.456, Speaker B: But I was going to play devil's advocate there. I mean, like, FTX just came through and everyone delegated their trust to FTX, and FTX just hurt a bunch of people. And the solution is self custody. So if we then say, okay, there's some storage slot know, you understand, at least in the paradigm of blockchains today, that you get, and it's maintained by the blockchain in perpetuity. And now we've abstracted that away to you go into a coma for seven years, and you have to come back and give me like a mercalization for seven years to prove that you own this. A lot of the selling point of.
01:34:29.478 - 01:34:30.370, Speaker C: What this is.
01:34:32.740 - 01:35:05.290, Speaker A: I think it depends, because maybe you come back after seven years, but maybe you never come back. And if nobody cared about storing your data. Why should anyone keep it in perpetuity? And here we have in a way the same problem as when you can't distinguish between a malicious state update and a gibberish state update is that you can keep it, but you never know if the person just ghosted and will come back later, or if he just decided to give you a shit ton of data and you're going to store it forever for nothing and it's just to incur a cost on you.
01:35:05.820 - 01:35:31.010, Speaker C: Yeah, I think the distinction also, first of all, the difference, I think, between this and FTX is that there is no delegation of trust here at all. The only thing happening here is that there is a burden of additional liveness on the users. The users have to periodically maintain something and make sure it's active, which is, in my opinion, very different from having someone else be able to just freeze your funds or to.
01:35:31.640 - 01:35:50.840, Speaker B: No, I totally agree with that. I'm just saying that shifting that burden from being, hey, keep this hexadecimal address somewhere safe, easiest thing in the world. To what, maintain some node, some light client that runs, or at least checkpoints itself.
01:35:50.990 - 01:36:02.110, Speaker A: Yeah, but the thing is saying keep this exadcimal address and be safe forever is not really an option, because if you do that, you're still relying on somebody else to run nodes for you, right?
01:36:02.960 - 01:36:04.348, Speaker B: That's kind of the point, right?
01:36:04.434 - 01:36:11.810, Speaker A: Yeah, but that's the thing. If you're running your node, then having an additional layer where you store the data that you care about kind of makes sense.
01:36:13.780 - 01:36:46.280, Speaker C: I think, from my perspective. It's just that participation in the network should be active participation to some extent. And sure, maybe we can control the frequency of what active means, but in general, it seems to me very strange that you purchase a storage cell and now for all eternity, all you need to do is keep a piece of paper with some letters safe, and everything else is taken care of by society. This seems to me like a strange thing, but again, this is not a popular opinion.
01:36:47.260 - 01:37:00.896, Speaker A: I kind of agree with you, and it doesn't seem to me like a safe thing, assuming somebody will pick up the scrap. To me, you need to participate in the network, and you need nodes to collaborate in some kind of state in some kind of place.
01:37:00.998 - 01:37:21.830, Speaker C: I think it increases user fees much beyond what they need to be. Right? If people only pay for what's being used, then that's much better than if people pay for everything that was ever used, which is what's going on right now. Right now for storage, you pay for all the storage that was ever used, even if no one has used it for a long time.
01:37:22.680 - 01:37:34.136, Speaker A: I guess part of this is it makes me think maybe it's a tangent, I don't think it is that much about EIP 48 44, something like that. The dang sharding EIP, which is, oh.
01:37:34.158 - 01:37:36.344, Speaker C: I lost your audio for a second there.
01:37:36.542 - 01:38:54.188, Speaker A: So the dang sharding EIP. So, providing cheaper data for roll ups on Ethereum, it's kind of linked with a team I wanted to talk about also later, which is the data availability problem, which is essentially, once you operate Starknet, how do you make sure that people are able to retrieve data to reconstruct the full state of Starknet? And right now we're very much adopting the same strategy you just described, Ilya. We're just saying, okay, let's send the data to Ethereum, and Ethereum will take care of the data, and we assume this paradigm will work forever. The question is, will it? And I think that you're not the only one asking this question. I think the rationale between then sharding is essentially to distinguish between data, like data availability is a weird term, because there's data public being public and data being available, which are two different things, right? Data availability in the way. So there's the fact that some data was public and accessible at a given point in time, which is what Densk sharding is about, which is what Celestia is about. And then there's making sure the data is available at any given time, which is what we tend to do with Ethereum.
01:38:54.188 - 01:39:47.030, Speaker A: But the whole point of denk sharding is saying, hey, you know what? We're just going to prove that at a given point in time on the network, the data was available and people were able to check it and then deal with it as they see fit. But we're not going to store it forever. So essentially it means that data that will go through this system will not be maintained by guest, and you'll have to rely on another network than Ethereum to reconstruct the state. So with that perspective, should we use dink sharding? Should starknet use it or not? Because at the same time, there are very concrete benefits. It will be like 15 times cheaper or something like that. It will be much, much cheaper. Are we still a roll up? Is Starknet still a ZK roll up if the data is published using a mechanism that has expiry on data?
01:39:47.560 - 01:40:11.740, Speaker C: Well, really, to be honest, I'm not a huge fan of distinguishing between the name roll. I don't think the name roll up should imply on chain data availability. I think there should be just an on chain data availability roll up and an off chain data availability roll up. Because in my opinion, the world roll up. The part of the architecture it signifies is the coupling of proofs with state updates.
01:40:12.080 - 01:40:16.110, Speaker A: Fair enough. So would ding sharding be on chain data or off chain data?
01:40:16.800 - 01:40:57.640, Speaker C: So I think it would really require a different class, because I think it breaks the dichotomy in a very obvious way, and I think it's exactly analogous. Like you said, it's a storage problem. It's an intermediate solution. You have some time to convince yourself, and basically you have security, assuming that the period of availability is longer than the period than the duration of some malicious cartel that is hiding data from everyone. And if data is available for longer than the cartel can hide it, then everything is fine. But again, this basically makes it into a spectrum. Before there was just two points and now there's like a spectrum.
01:40:57.640 - 01:41:03.150, Speaker C: And I think the spectrum is a good place to be. I think both of the extremes are bad.
01:41:04.560 - 01:41:12.110, Speaker A: Makes sense. Ben, any thoughts on that? You're hosting nodes, so are you fine with the state ever?
01:41:14.180 - 01:41:38.970, Speaker B: No. I think there needs to be some solution, but I think it's delicate. I think the promise of what blockchain is, and there's this tightrope walk of having an expressive blockchain with a Turing complete language built in, you know, it just is going to lead to state bloat. I don't know how you fix it.
01:41:39.660 - 01:41:41.850, Speaker A: I think it's the same for bitcoin, though.
01:41:42.780 - 01:42:10.560, Speaker B: It's just slower. From personal experience, I think I ended up growing like 500 gigs over six months or something like that. I mean, it's obviously untenable. So I don't know what the answer is, but I'm wary to step on like this is some public good that it should be very easy for a user to pick up in ten years from now if they're in a coma and basically use the chain.
01:42:11.640 - 01:42:12.390, Speaker A: Yeah.
01:42:15.080 - 01:42:17.110, Speaker C: I have to go play tennis now.
01:42:17.560 - 01:42:31.736, Speaker A: Thank you a lot for your time. Helia, again, I basically pinged Ilya yesterday to ask him if he would come, and this was an amazing discussion, a lot of insights. So thank you a lot for sharing your time and your research, and I.
01:42:31.758 - 01:42:44.232, Speaker C: Hope everyone knows how welcome their feedback is. We really want to hear back from the community and from anyone who's interested. This stuff is complicated and we don't think we know better than you. Thanks, Elia.
01:42:44.296 - 01:42:45.310, Speaker A: Enjoy the night.
01:42:46.960 - 01:43:11.620, Speaker B: To expand on that. The Starknet foundation is live now. This is a community effort. A lot of these things are community efforts. Even though they might have been incubated and started internally, these things are basically going to be delegated to the community. So not only do we want your feedback, we want you guys to know decision makers and code writers.
01:43:12.600 - 01:43:20.776, Speaker A: The best question we asked for half an hour if anyone had question and then Philip is just commenting, ilya is a liar. He's not going to play tennis because.
01:43:20.798 - 01:43:22.040, Speaker C: His arm is broken.
01:43:23.580 - 01:43:55.956, Speaker A: So fun fact, actually. And you can categorize this into the funny stuff Starquare employees do. I don't know it from Ilya directly and I should have asked him, but Ilya is a trainer for professional tennis players. He's like the trainer, the tennis player of one of the top israeli tennis player. So I'm guessing that maybe he's going to exercise or train somebody else. Anyway, we'll ask him next time. You're right.
01:43:55.956 - 01:43:59.680, Speaker A: We shall hold him accountable. Now I'm lying.
01:43:59.760 - 01:44:00.390, Speaker C: No.
01:44:01.720 - 01:44:26.030, Speaker A: Anyway, okay, so we still have 15 minutes. I'm going to cover a few topics real quick and then we'll move forward, actually extensively about data availability, but I want to put it back in context real quick and go through these slides. So what is the data? Did you cover the data availability problem, Ben, during base camp?
01:44:26.880 - 01:44:32.352, Speaker B: Not the problem, but just how Starknet writes its state to l one. But not really the problem now.
01:44:32.406 - 01:44:57.236, Speaker A: Okay, cool. So the problem with the data availability problem is the following. I can prove that I went from block zero to 100. I can prove that the transition was correct without giving you either block zero or block 100. The proof is valid. And when you think about, it's not really a problem, it's a super cool feature. You can prove that you did something correctly without providing the output.
01:44:57.236 - 01:45:39.284, Speaker A: You can just prove that you did something correctly, right? So I don't know, but it becomes a problem in the context of blockchain. Because imagine I'm giving you a proof that I went from block zero to block 100. And, okay, so now the state is block 100. You have the root, the block hash, the hash of the block header, and now you want to move from block 100 to block 200. But I ghost you and I'd never give you the state of block 100. Now what's happening? You have no way to generate a proof that moves the chain forward. You have no way to reconstruct the state of block 100.
01:45:39.284 - 01:46:23.044, Speaker A: And so you have no way to generate a proof that moves from block 100 to block 200 for example. And we don't want that. We don't want people to rely on this. So how do we do this with validity roll ups? So we assume that the underlying l one is always ups. We assume that l one is never going to go away and that the data that is on it will never go away. So in order to be super sure that the state of block 100 will always be accessible, so that people can pick up the chain and move it forward, we just store the data on l one. This is obviously very expensive, right? And when I say we store the data on l one, we don't store it in the state.
01:46:23.044 - 01:47:10.432, Speaker A: The data is received and emitted as events, but still, it's part of the transaction. And since transaction are kept, you can assume that they're saved, right? So in a validity roll up, we basically do this. Now, this is where the difference between a validium and a validity roll up appears. Because some people, you know, I agree that there's a risk here, but I've duplicated the data. I hold it, Ben has it, Omar has it, David has it. And there's no way every one of us will disappear at one given point in time. So you will have a way to reconstruct that data.
01:47:10.432 - 01:47:41.592, Speaker A: And in a way, data persistence is something that we know pretty well how to do. The blockchain is not necessarily about data persistence. It kind of is. But it's not exclusively about data persistence. It's about maintaining a common state, not necessarily about storing it. And so some people think, I'm fine with just having my network secured by proof, but not providing the data. And in that case, what they do is they just publish the proof on l one and they store the delta elsewhere.
01:47:41.592 - 01:48:18.116, Speaker A: And this is what validium is. This is what immutable is doing. This is what Soraya is doing. So they're able to mint shit tons of nfts without ever writing storage sales on Ethereum. So that's why they're able to generate nfts at a very low cost. And when we say a very low cost, Sorre has been able to divide its operating cost by 20,000 by adopting this strategy. So it's not like it's a cheaper way to do it that sacrifices guarantee.
01:48:18.116 - 01:48:41.600, Speaker A: It's a real trade off. There is a big impact on how much it costs. And with that, there is a big impact on what you can offer your users, but it's a design trade off. Now, the thing, right, this was my next slide. So you can store it wherever you want. Validiums. Right? And you don't rely on l one.
01:48:41.600 - 01:49:40.508, Speaker A: Now some people are saying, yeah, but now there are some data availability blockchains like Celestia and their mess to keep the data. I want to underline that there are different constraint, like there are different design choices for all of this solution. But you should be mindful that there are two concepts here. There's the concept of data publication, so proving that some data was available at a given point in time, and data storage, so proving that the data is available at any given point in time. And these are two very different things. And to the best of my knowledge, what things like Celestia are doing, or what Denk sharding is doing on Ethereum, is basically giving a proof that a set of people at one given point in time held some amount of data. And if you want this data to be available forever, you need to do this proof over and over again to prove that the data is still here.
01:49:40.508 - 01:50:31.300, Speaker A: But once if you don't, then the data can just be discarded and thrown away. And so it's different from data storage, making sure that the data is persistent. So when using a validium, it's really important to think about who will store the data for how long and was there incentive to do so. Everything clear so far? So we have validity roll ups and validiums on chain data, off chain data. Now, what about something that is a bit in the middle, like volition? Volition is the name we use for a concept where you have the best of both worlds. In your smart contract, you get to decide where specific amounts of data are stored. So for example, let's imagine you're doing an NFT.
01:50:31.300 - 01:51:04.232, Speaker A: The owner of that NFT is probably a very critical part of your application. Might as well put it on chain. The metadata or the attributes or the Uri, maybe you can store it elsewhere. Right? It doesn't matter. Like if it's lost, it's not as bad as if the owner of the token is lost. So maybe you put this off chain, and so in the context of evolution, you're able to decide where the data is stored. So this is not something that is canonically implemented in stack.
01:51:04.232 - 01:51:41.636, Speaker A: This is not something you can use and leverage in your smart contract. It's something we want you to be able to leverage in your smart contract. But right now it's not possible. Now, this is something that would be nice for users, it would lower costs, it would be nice for developers. We can design their application around this constraint. It is important to note that there are some issues around security around that, I mean, if you're an on chain smart contract and you're touching a smart contract that has data off chain, you're becoming dependent of the data that is off chain. So it's important to be mindful of that risk.
01:51:41.636 - 01:52:21.924, Speaker A: It's essentially a new risk. So yeah, that's the data availability problem. And then this is a nice and very big design space, I personally think. But that's just my opinion. The question we have right now at Starknet is like, should we implement a data availability solution? Should starknet enshrine that this particular set of data is off chain and maintained by sequencers and the rest is on chain? Because that basically means making this specific data layer canonical and part of Starknet. And I don't think we have a good solution to that. I am not sure there is one.
01:52:21.924 - 01:52:57.788, Speaker A: So I would tend to defer to people experimenting stuff. And that's why I think that a mechanism such as the one I described earlier, having various routes for off chain data and letting different solutions implement their own data availability solution on top of it, would make sense. But that's just my opinion. Right. So I'm curious to see what you think. Can't see if there are questions or remark, but I'm really curious to hear your opinion on that. Anyway, so that's what I wanted to say on data availability.
01:52:57.788 - 01:53:35.364, Speaker A: Are there any questions or observations? So I was super clear. Again, amazing. Okay, so let's talk about recursion real quick. Real quick, right. So recursion is essentially. Did you talk about recursion yet? No. Okay, so recursion is essentially the capability for you to verify a proof and then generate a proof that you verified this proof, right.
01:53:35.364 - 01:54:04.840, Speaker A: And when you're doing this with storing data. So it's kind of the same thing as taking a file, zipping it, and then zipping this again. The thing is, when you're doing this with a file, well, it doesn't work the second time, right? You can compress it the first time, but when you recompress it, it doesn't shrink in size anymore. Right. The thing is, with execution it does. So you can shrink it and shrink it and shrink it and shrink it. And as you go, the proof gets smaller.
01:54:04.840 - 01:54:42.872, Speaker A: And the really cool stuff with that is also that you can shrink two of them and then aggregate them and shrink that. So this is why we mean that we can have parallelization thanks to recursion, because it allows you to prove different stuff and then aggregate them in a single proof. So take an example. You want to prove that you went from block zero to block 100. Generating the proof will take you a lot of time, and you want to accelerate this. While you can divide this in ten threads where you're going from block zero to block ten, block ten to block 20, block 20 to block 30. And remember, you want to grow from block zero to block 100.
01:54:42.872 - 01:55:12.596, Speaker A: And you already know the path to go from one to another. So you can slice this right, and you generate a proof for each. So now instead of generating one big proof for 100 block, you're generating in parallel proofs for ten blocks, so that's shorter. And you just aggregate them in another proof. And this allows you to, it allows you a bunch of stuff. And I'm going to let you check aviate's full presentation, which was for iffprog. It's really extensive and I'm not going to give you much more elements if I cover it now.
01:55:12.596 - 01:55:37.308, Speaker A: So I'll let you click on the link and make sure that it makes sense because it can be used for performances and it can be used for a lot of stuff. Something I want to mention though, that is not in Avio's presentation. Oh, I see. There are questions. And that's the link. Nice. Yes, mind blowing, of course.
01:55:37.308 - 01:56:29.420, Speaker A: And then that's Avia's presentation. Yes, it's a good one. And the thing he didn't mention, and it's something I'm thinking about and I want to mention, is what I call client side proving. So in a nutshell, what is client side proving? It's the capacity that eventually, eventually the prover software will be open source, so anyone will be able to run a Cairo program and generate a proof for it. Now the thing with this capability is that it opens up the door to a lot of stuff. You can reduce recursion at the architecture level, at the network level, right? You can decide to have l freeze and to have them talk with each other. But having the capacity to have client side proving allows you to have very different properties in your smart contract.
01:56:29.420 - 01:57:32.832, Speaker A: The first one, which is kind of obvious, is that it's a really great tool for privacy apps, right? If you've ever used tornado cache, tornado cache makes you generate a proof on your machine and then send it to the chain. Well, you could do the same thing here. You could generate a proof in your cell phone, and the fact that you're verifying it on Starknet and that verifying the proof on Starknet is pretty cheap because it's computation, and computation is cheap on starknet makes it possible for you to design better privacy algorithm and more detailed ones. So I think that's a really nice avenue. But when you think beyond that, you can start thinking about an architecture where the user or the app server start to provide not just an interface to the blockchain, but maybe some computation also. And I'll give you an example. Let's imagine that I have written an algorithm that does generative art.
01:57:32.832 - 01:57:53.924, Speaker A: Oh, by the way, I found that when I was cleaning my backyard the other day. It's the thing I was talking to you about, the thing I distributed. It's not my backyard, my Garage. So this is the thing I distributed. I have NFT at CC. I have a shit ton of. So imagine that I have a generative art and my NFT.
01:57:53.924 - 01:58:49.144, Speaker A: When you call a function, it meets an NFT that looks for a path. And this algorithm is very expensive, so you can ask the starknet network to execute it. And it's going to be cheap, but still it's going to cost you because eventually nothing is free and you'll have to pay for it. Now what if instead of saying, hey, sequencer, compute this for me and give me the result and mark this as an NFT? What if you could say, hey look, I solved the path, here's the answer and here's the proof. Mint my NFT. Well, all of a sudden you get the same result, you get the same NFT in a provable manner that has the same generative art, but the computation was delegated away from the sequencer. When you think about it, it's really a change of paradigm because it changes the way you design your app, it changes the way computation is done.
01:58:49.144 - 01:59:33.332, Speaker A: And you can do it at the client level, you can do it at the app level. You could decide, hey, you know what, everybody can use my protocol directly on chain, but if you go through my app and my front end, I'm batching all your transactions into one big state update that I send to the sequencer automatically. And instead of you paying the sequencer, I do this for you. And it takes some computing power away from the sequencer. What this means is that conceptually it could allow you to really distribute compute outside of the sequencer. It would really allow the network to expand an extension of this cell free. But there's an in between.
01:59:33.332 - 02:00:10.436, Speaker A: There's the moment where everything is done by the sequencer, there's the moment where you operate a separate app chain, but then there's everything that is in the middle. And I think this is likely to come before because you can do a lot of stuff with that. Another idea is provable INTs. You see what Ints are for in Cairo, right? It's a way for you to give a shortcut to sequencer, to execute some piece of code. What if you could use an int? That is a proof. So you could give him a shortcut by giving you proof that you executed something on your machine. That would be pretty cool, I guess, right? I don't know.
02:00:10.436 - 02:00:19.794, Speaker A: Does that make sense? Ben is like, yes. Not sure, maybe makes sense.
02:00:19.912 - 02:00:29.110, Speaker B: It makes sense because you're just proving the output of it, basically. So you're just proving that. It's almost like recursion as well.
02:00:29.260 - 02:01:12.966, Speaker A: I mean, it is recursion. It's just one usage of recursion. But what I mean is, I used to think of recursion as if you have, oh, it allows l three kind of like two different things, but it's actually like it's a spectrum. There's a lot of things you can do in between. And I wanted to cover l three, of course, because what I find really fascinating about l three s is that it's not just that. The fact that mathematically this is kind of mind blowing is that when you think about it, proofs are the only way so far for blockchains to talk with each other natively. When starknet sends a proof, and I say sends a proof, somebody else sends it for it.
02:01:12.966 - 02:01:55.810, Speaker A: But when a proof of starknet is sent to ethereum, ethereum actually understands what happened on Starknet. It doesn't know how it happened, but ethereum knows what happened is valid. And this is the only context where a blockchain can take the output of another blockchain and know for sure that this blockchain was computed correctly. And to me this is beautiful. It's the first time where you have these things that are tightly coupled and not without humans in the middle. So these are slides I did for a presentation about how you could use this for cbdcs. But this basically would allow to have two things.
02:01:55.810 - 02:02:54.326, Speaker A: First of all, a public starknet and then specific special purpose networks. So you could have a starknet for a CBDC, you could have Starkx for a CBDC, and on top of that you could have authorized applications, authorized payment processors and stuff like that. The really cool stuff with that also is that these things don't necessarily need to be validity rollups, they can be validiums. One of the main advantages of validium is not just cost, it's the fact that since you're not disclosing data, you're not disclosing data, which is pretty cool. I mean, you could operate a payment network where you prove that everything's happening correctly on your payment network without disclosing who's paying what to who, which is valuable for customers, right? Having privacy. So it's something that would make a lot of sense. You could also have this kind of stuff where you have a CBDC network using Starknet and then having banks connect on top of it.
02:02:54.326 - 02:04:04.074, Speaker A: They could provide infrastructure at the Starknet layer and then have Starkx instances playing on top of it. So you could really have a layered network with different levels of access. I'm going a bit fast through it because I think CBDCs are not the most interesting stuff, but still, I think it's an interesting thought, right? I think that l freeze and fractal scaling basically give a legitimate possibility to have a multi consortium or private chain world which hasn't played out so far. It's really hard to have guest chains talking with each other. And the reason for that is that when you're doing your consortium chain, you can't really use what is done by another consortium chain because it would imply basically trusting what the other validators are doing. If you're trusting them, why not be on the same chain? So if you're in different chains in the first place, it means you can't really interact with each other with Starknet. I mean, with proof now you can.
02:04:04.074 - 02:05:07.760, Speaker A: Now, will this thing happen? Will CBDCs happen on starknet? I would say yes and no in the sense that I think this is a legitimate possibility. I think this is something that will happen. Having chains that are dedicated to payments, having chains that are dedicated to some kind of function that will have the data that is private but that will operate as a validium. But I don't think this will come from cbdcs. I don't think this will come from, from big entities. I think this is going to be done by it operators, small apps, maybe you building a payment system for your country where people can exchange value super fast without having the possibility for you to seize the fund. I think that the past events with FTX in the past few days have been a proof that indeed you need to be mindful of who you're delegating your money to and that indeed legal frameworks don't protect us as much as we wish they would.
02:05:07.760 - 02:05:37.686, Speaker A: Up until a month ago, we would look back at Mount Gox and think like, oh, that was another time. Now exchanges are really safe and secure. Well, this is a reminder that maybe not. And now we all feel this way. I think it will be much more difficult to remember that in ten years because you always feel like this is far away. But the good news is we have a solution for that now. Operating these networks so that the operators can't seize them is valuable.
02:05:37.686 - 02:06:16.440, Speaker A: And then there's the other point of view, which I think also really, which is really interesting, which is that operators don't want the liability. Right. I mean, having, being in, a lot of people don't. A lot of operators don't want to touch customer funds. They don't want to be in charge of this because it's too much responsibility, it's too expensive, it's regulatory oversight, yada, yada, yada. So if you can delegate this to a smart contract and say, hey, you know, I'm just providing a service, but I don't have any access to customer funds, it's a much easier way for you to set up a business. So I think there's also a vector for acceleration here.
02:06:16.440 - 02:06:44.990, Speaker A: Anyway, we've been together for 2 hours. That's why I'm going a bit faster. Wanted to ask if there are roadmap questions and if all is clear in the things we covered. And then I'm going to finish in like five to ten minutes. Talking about community stuff. Roshant is saying proving and recursion is covered in the Cairo white paper and pills and Ben calls it l three. Yes, it's a cool concept.
02:06:44.990 - 02:07:22.602, Speaker A: All right, so I'm going to assume that everyone has no questions. That's cool. Now let's talk about ecosystem expansion. I'm going to go real quick on this. I mentioned it in the beginning, but it's a blockchain network at the end of the day, as technical side, but it has an adoption side. If your blockchain network is super performant, super safe, but nobody uses it, is it really useful? My opinion is that not that much. So you, as builders of Starknet, you need to be mindful of that.
02:07:22.602 - 02:08:09.802, Speaker A: You need to be mindful of, we need people using the network. We need more people building. We need more people having fun building cool shit on top of Starknet. So our objective, your objective is to try to make this thing happen, have relationship, talk about it with friends, explain to people what it is getting engaged in your local community and try to raise awareness about it. And I'm not saying this in the sense that, oh, we need to bring as many people as we can, but in the sense that, I don't know, it sounds kind of culty to say this kind of stuff. What I mean to say is that if you're building here the long term, it's in your interest to have more people build here. So I'm not asking you to go evangelize to everyone.
02:08:09.802 - 02:08:45.318, Speaker A: I'm saying it is positive. If when people ask you a question, you take time to answer and you're nice. Just being nice goes a long way. Another really nice way of moving the ecosystem forward is organizing in real life meetups, in real life events. We support people who are doing this, and I know that Arturo is here. We did a meetup not too long ago together. So organizing a meetup is easier than you think it is.
02:08:45.318 - 02:09:25.620, Speaker A: It's not that easy, but it's not that hard either. So how would it happen? Basically, you need to figure out a date and people might come. And then we'll send you swag, we'll send you a bit of money to pay for. We send 1000 usd to cover for the venue cost to cover for food. We'll help you get people to the meetup, we'll advertise it, and we'll basically support you to make it happen. And having meetups regularly is a great way to make friends and to grow the community locally. So I strongly encourage you to consider it because it's a great experience, it's great fun.
02:09:25.620 - 02:09:49.654, Speaker A: I would stress the following thing. Don't stress too much about numbers. It's not that much about number as much as it is about quality. Having engaged people is more important than having thousands of people. Be nice. I know you guys are all very nice, but be nice, it's always worth it. And as soon as you can involve the community, tell people I organized this meetup.
02:09:49.654 - 02:10:21.158, Speaker A: It's a lot of work. Anyone want to step in? And you don't have to be a professional Cairo developer to step in. Like organizing an event is orthogonal to being a good Cairo developer. So can anyone help me? Anyone want to present their project next time? When is a good frequency? Ask questions and involve them in making this thing happen. That's basically the objective about this and mentoring. Just wanted to mention there's only a.
02:10:21.164 - 02:10:24.040, Speaker C: Question that has also been asked before.
02:10:24.490 - 02:10:28.310, Speaker E: If we can have something like explanation of Kakarot.
02:10:29.770 - 02:11:06.338, Speaker A: So I can't give an explanation of Kakarot right now. I'm not sure when they plan on doing something. Kakarot was initiated by us, but now it's in the end of the community. So I think you should join the Kakarot telegram group because that's where you're going to get most. And, okay, one last thing I wanted to mention is mentoring. I haven't been able to set that up for that session yet, but I'll come back to you one day. That day may never come, but I'll come back to you and ask you for a service.
02:11:06.338 - 02:11:53.700, Speaker A: And that service will basically take care of helping somebody on board. Stucknet. My objective is to make it as easy as possible. So basically the idea I have is I want to match people, newcomers, with old timers like you now, who are willing to give three times alpha an hour of their time. Then they can ask for and then they can ask for you to answer their questions and stuff like that. Each one teach one, and I hope my joke works. I added the Patagonia cap on top of the Godfather because Ben always has a Patagonia cap, but turns out he doesn't have one.
02:11:53.700 - 02:12:30.874, Speaker A: Anyway, kind of blew my question anyway, so that's what I wanted to say about community building. Think about running meetups. They're fun and they're a good way to meet friends. And I'll come back to you with stuff about mentoring in the future. Any questions around that, I'm going to assume everything is fine and I'm going to conclude base camp. So just want to mention again, Starknet is just getting started. As you saw, things are being built right now.
02:12:30.874 - 02:13:12.406, Speaker A: We are building on strong foundations and you've explored them with Ben Starks, Cairo. Starknet is still being developed. We talked a lot about the upcoming challenges, the one that are on the immediate frontier, throughput performances and then the one that are a bit later on that availability, decentralization, all of this stuff. Now you have tools and knowledge. You can go out, build stuff and have more people join the ecosystem because ultimately that's how we all win, is if we use this tool, not just talk about it. Just want to mention that I don't like the meme. Oh, you're Hurley.
02:13:12.406 - 02:13:40.638, Speaker A: But you are. You really are. And I have no idea financially how Hurley, we are in the blockchain space. I do know that technology wise, I don't think anything we're building will be solved in five years. I think that this is your career. You're going to be here for like 10, 20, 30 years. There is so much to be built that even if we were done in five years, it would mean that it is not something that is as interesting.
02:13:40.638 - 02:14:11.790, Speaker A: So get comfortable, invest your time in learning, and enjoy the time, enjoy the adventure, because you're going to have the best stories at the end of this. So thank you for your time with basecamp. We're really grateful for you dedicating so much time, learning what it is we're working on. We really hope this was useful. We're looking forward to having your feedback. We're looking forward to having you in the community and having you help us make better and, yeah, thank you. Thank you a lot for your time.
02:14:11.790 - 02:14:31.010, Speaker A: And I want to give a special thanks to Ben, who spent a lot of time and effort on this program. He's been a really cool teacher from the beginning to the end on topics that are really hairy and really difficult. So congrats on that, Ben. And, yeah, thanks, everyone for attending.
02:14:31.750 - 02:14:54.422, Speaker B: Thanks, guys. We need that thing where we all jump and it freezes. Freeze frame. Thank you, guys. Appreciate all your hard work. And again, until, if you want the swag, if you want to graduate, fill out that graduation form. And, yeah, thanks for your time.
02:14:54.422 - 02:14:56.220, Speaker B: Thanks for your effort. Appreciate you guys.
