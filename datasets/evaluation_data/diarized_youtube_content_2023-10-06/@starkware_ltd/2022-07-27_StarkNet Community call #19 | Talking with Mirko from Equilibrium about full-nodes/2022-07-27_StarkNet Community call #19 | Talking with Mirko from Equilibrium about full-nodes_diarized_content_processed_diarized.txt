00:00:00.590 - 00:00:01.140, Speaker A: You.
00:00:03.110 - 00:00:20.050, Speaker B: Boom. We're going live. All right, there's a small delay between Discord and Discord. Zoom and YouTube. YouTube is about 20 seconds late.
00:00:22.790 - 00:00:23.540, Speaker A: Cool.
00:00:24.710 - 00:00:52.340, Speaker B: So again, to everyone on Discord, everyone on YouTube, welcome. This is our 19th community call. Starknet community call. Today we will be talking with merco from equilibrium. And today is the day we talk about full nodes. What they are, how they work, how they are different in Starknet and in Ethereum, for example. And we're going to have a nice guest with us to answer all of our questions.
00:00:52.340 - 00:01:23.510, Speaker B: If you have questions, you are much welcome to ask them. So you can ask them either in Discord, in the committee call channel, or in the comments on YouTube. All right, Mirko, have you raised your hand in discord so they can let you talk?
00:01:23.960 - 00:01:38.480, Speaker A: Okay, let me do. That's it.
00:01:52.890 - 00:01:54.200, Speaker B: There you go.
00:01:54.890 - 00:01:55.686, Speaker A: Perfect.
00:01:55.868 - 00:01:57.880, Speaker B: All right, I think you're in.
00:02:00.010 - 00:02:38.340, Speaker A: Can people hear correct? Yeah, I'm Mika from Pathfinder and I'm part of equilibrium. Yeah, Pathfinder is Stocknet's first full state node. And we had an initial release earlier in March this year. And, yeah, since then we've just been adding features and remaining stable as we can be. We have a sibling node implementation called Juno, created by Nethermind. I think they got started a couple of months ago. So there's also another node implementation to check.
00:02:38.340 - 00:02:52.860, Speaker A: Yeah, and then we're also available from some well known services like Infuria and Chainstack, who've recently released Stocknet support with Pathfinder behind the scenes. And, yeah, there's some more to come.
00:02:53.470 - 00:03:12.670, Speaker B: Wonderful. Okay. Thank you for this introduction. Actually, let's start. So before we dive right into full note, I wanted to mention something real. You know, this community call takes place about every two weeks. Sometimes it's not possible.
00:03:12.670 - 00:03:55.030, Speaker B: Like for example, last week was ECC, so it was not possible to have a community call. I apologize because it's taken me some time to actually schedule the calls. I did it a while back and then I planned ten of them and we ran out of all of these and now they were not very planned. So I've just planned a bunch of these. In discord. I'm not sure what's the best place to communicate about these, but on discord at least you'll have a reminder for all the upcoming community calls. The next one will be on August 9, then August 23, and after that it will be in September.
00:03:55.030 - 00:04:31.186, Speaker B: I want to remind you also that these community calls are very much open. If you want to participate, come present your stuff. You're most welcome to do it. The next one will have the winners of the encode hackathon presenting their burner wallet on 23 August we'll have Lori presenting multisigs so multi signature wallet on Starknet. Then we'll have a game presenting called Friends lens on 6 September. So there are a bunch of upcoming committee calls. Make sure to bookmark them.
00:04:31.186 - 00:05:07.234, Speaker B: And as always we have presentation. But this is the place to ask questions. So if you have questions, feel free to ask them. And now let's dive right into the discussion about full nodes. I see there are some questions, I'll get around to them. My first question to start with would be the following. What is a full node? Let me roll back a bit.
00:05:07.234 - 00:06:05.640, Speaker B: In the blockchain world, usually we tend to separate custodial nodes or light nodes and full nodes. It's basically this small dichotomy. Light nodes let you query the data, but you don't hold it and you don't maintain the chain yourself and full nodes where you hold all the chain on your computer and your sovereign. It seems to me as though these definitions don't apply exactly the same in validity roll up context, because validating the chain doesn't mean the same thing. You could validate that everything that happened on Starknet happened correctly without having the transaction list or the transaction data, or without having all the events that are included in a state transition. So my question is the following. Does it still make sense to talk about full nodes? Is there a broader categorization that may emerge, and how do you see this playing out?
00:06:06.410 - 00:07:12.762, Speaker A: So I think it still makes sense to talk about full nodes just because most people are familiar with the term. So when you say, listen, we have a full node, that kind of implies the data that you have available to serve via RPC or however. But in stocknet we try to make a bit of a distinction between sort of how ethereum handles full nodes and how we're doing it by calling it a full state node. And sort of the implied difference is that, well, we don't have to do consensus or partake in it at all in order to validate things, because we can validate things based on what's on l one. And in addition, as you say, we don't need to check the receipts or so on because we can verify that the state is correct, because the state route is present on l one again, so we can combine l one's information and verify it against the l two information and use it to make sure that we are correct without really communicating on l two much at all if that makes sense.
00:07:12.896 - 00:07:46.118, Speaker B: It does. What you call a full state node is basically a node that will keep track of the state of starknet and validate. Not necessarily, it doesn't even need to validate the proofs, right, because the proofs are validated by Ethereum. So it's just keeping track of the state so that you can query it. So I mean there's the dimension of keeping the data so you don't need to keep track of transactions of events and stuff like that. But for some applications it may make sense to do so, right?
00:07:46.204 - 00:07:53.900, Speaker A: Yes. So currently the way Pathfinder itself works is it's more like an archive node in that it stores pretty much everything.
00:07:55.550 - 00:07:57.110, Speaker B: Transactions, events.
00:07:57.190 - 00:08:32.006, Speaker A: Yeah, everything. But it's mostly because it's the first node available, which means that people will want to use it for a wide range of different applications. And some of those applications do want the transactions and not just the state. So we're currently storing everything. But it's not a stretch of the imagination to say, listen, I'm only interested in the state, so toss everything else away, don't even bother with it. So there's a lot more fine grained options available I think. But currently we aren't really exploring those.
00:08:32.006 - 00:08:41.670, Speaker A: Things are changing so fast still in Starknetland that it would be a bit of a difficulty in maintaining that whilst we're moving forward.
00:08:41.820 - 00:09:23.974, Speaker B: Yeah, for sure. Even just having a full state node and a full archive node would be good. And a full archive node that you can synchronize with Testnet because that's also one of the big issue. I'll come back to that a bit later on, but. Okay, so so far you've mentioned full state node, full archive node question would it make sense to separate between in the granularity that you may have in the future, would it make sense to separate if you can select some events and not others? Like for example you're running a DaP. Maybe you want to store the events related to your Dap but not to a bunch of others. And same for transaction history.
00:09:24.172 - 00:10:00.254, Speaker A: Yeah, I think definitely. I mean if you want that kind of granularity and you know that this is all that you want, then sure, that makes a lot of sense to me right now. You could do something like that sort of by filtering, but that's of course you wouldn't really want to run your own Pathfinder node in that sense. You would be querying maybe, I don't know, infuria or chainstack or be running your own Pathfinder node somewhere off, like somewhere else, and then just querying it directly. But you could also. What I mean is that does just that little bit which, what I mean.
00:10:00.292 - 00:10:42.750, Speaker B: Is that to me, the fact that you don't need to store all the transactions is a big advantage because it saves you a lot of data and a lot of space, but you still need to have access to some historical data, and so it makes sense to store some, like the events. But it also means that the more starknet will grow, the more not an event state, but the more the event database will grow. And so the more, the higher the weary requirement on running a node. And so if you have a big machine, it doesn't matter if you store all the events. If you have a small machine, you want to run it on a raspberry PI. Maybe it makes sense to start filtering which one you request and which one you don't.
00:10:44.130 - 00:10:56.114, Speaker A: Yeah, it sounds like a small vertical slice node almost. It's not a light node because you are actually storing data, but you're only storing this thin, very specific slice of it.
00:10:56.232 - 00:11:53.960, Speaker B: What I think is interesting is that you cannot do that on Ethereum because you intrinsically need to download everything and validate everything. So you might as well keep it in order to validate the full node. So it's either you have a full node or a light node and you trust somebody else here. In that context, you could just validate the full state. You don't need this, but this is like an extra that you can make the request to and then to have it to serve in your application. But then it raises off a question like what about data availability in that context, because the fact that we have full nodes on Ethereum pretty much guarantees that any transaction that you, a single user made to an obscure dap that disappeared a while ago will still be stored by everyone. If you get to choose which events and which transaction you store are not, then what are the guarantees you have that this data will be available for later use?
00:11:56.330 - 00:12:00.280, Speaker A: So long as there's archive nodes and l one available, it's going to be there, right?
00:12:01.290 - 00:12:05.206, Speaker B: L one, why? Because are events stored in the state disk?
00:12:05.238 - 00:12:26.094, Speaker A: No, but you would need the l one to verify that they are actually somewhere. Someone has to validate it against l one to make sure that it's still correct, right? Or you could just say, listen, the store data is definitely correct, in which case it's fine, but if you wanted to be sure that it was accepted by l one, you need somewhere in l one.
00:12:26.292 - 00:12:34.558, Speaker B: I'm talking about events on l two, not l one events. L two events. I'm not sure l two events are part of the state update.
00:12:34.654 - 00:12:41.222, Speaker A: No, they're not. But you would need somehow to verify that what lands on l one is somehow matching the events that happen. Right.
00:12:41.356 - 00:12:48.950, Speaker B: All right, so you mean that somewhere someone will need to say, oh, these events were emitted. Let me find them.
00:12:49.100 - 00:13:04.810, Speaker A: It depends. Depends on what your need is. But yeah, if you wanted to be super safe, then yes, technically. So someone would have to execute transactions, make sure that the transactions led to that state update and limited these events. If you wanted to do.
00:13:04.960 - 00:13:29.886, Speaker B: Wait, no, but you don't need to do that. Like, if the proof is valid and is validated by the verifier on l one, you don't really need to re execute these and verify that the events work. Right. And if the events probably are not, they're committed to on the l one state update. Right. So there's a hash that is sent and probably the proof verifies that the commitment fits all the events that were emitted in the block.
00:13:29.918 - 00:13:37.030, Speaker A: Right? Yeah, but there's no link between the events that someone gives you and l one, so you have to somehow.
00:13:37.450 - 00:13:49.590, Speaker B: Oh, I see what you mean. Yes. So you mean when you want to require the events, you still need to make sure through query to l ones that these events are valid?
00:13:49.670 - 00:13:50.394, Speaker A: Yes.
00:13:50.592 - 00:14:14.980, Speaker B: I'm not worried about people giving me fake events, though I should be. I'm worried about events disappearing. I'm worried about a. We see there were some events, here's the bash, but we have no clue what they are. I think it's an interesting area of. I guess all blockchains, to a certain extent, face this issue on how you maintain the data availability problem. It's much wider than the usual thing.
00:14:14.980 - 00:14:54.382, Speaker B: We tend to narrow it down to. What I find fascinating is that for a lot of these networks, implicitly the choices of, yeah, okay. Everyone will take on the burden of keeping this and this and this, and then we assume it's going to be available. It's the same for a full node on ethereum. Technically, you wouldn't necessarily need to store the code of each smart contract that is deployed on l one. When there's a transaction associated to it, you could just say, hey, I'll validate it if you rebroadcast the code so that I can check against it. I'm not sure the code is actually part of the state.
00:14:54.382 - 00:14:56.494, Speaker B: It's just the hash of the code, right?
00:14:56.612 - 00:15:12.760, Speaker A: Yes, just the hash of the code. It's the same in stocknet. So we also store all the contracts and classes and so on. But yeah, we could just get the code, verify the hash, and then throw the code away and then it's gone forever again. Right?
00:15:14.170 - 00:15:48.510, Speaker B: There's a paradigm where this makes sense. If you're the developer of an app or the community of an app, it may make sense to say, hey, you know what? Take ownership of your code, you store it and you're able to send it later on. Or the community, it should be accessible to the community. And if nobody is willing to store it, maybe it's not that valuable of a program. Look, no, it's fair, right? I mean, if the community or the company or whoever operates that smart contract doesn't bother storing that contract data, why should it fall on the shoulders of the nodes who are not paid for that work?
00:15:48.660 - 00:16:08.040, Speaker A: Yeah, it's definitely a thing, and that's part of our concern with Pathfinder and that's why we're starting with the archive node and basically just storing everything for now. Because it's unclear what happens to the parts that aren't encoded somewhere. Do they have to be available? The answer is probably yes.
00:16:09.450 - 00:16:11.282, Speaker B: Probably somebody will need it eventually.
00:16:11.346 - 00:16:20.714, Speaker A: Yeah. So it doesn't help if we start a peer to peer network and the only thing running on it are light nodes and they're all just going, I don't know. What's the answer? I don't know.
00:16:20.912 - 00:16:38.500, Speaker B: Yeah, I don't know. To me, the difference is that there's a fundamental different trust absumption between what we call light nodes on Ethereum and light nodes in starknet. And I think that's why you were using the same terminology. Might make sense because it doesn't confuse users, but at the same time.
00:16:41.030 - 00:16:43.742, Speaker A: You'Re hiding the distinction as well. The differences.
00:16:43.806 - 00:16:57.394, Speaker B: Exactly. You're downplaying what we call a light node on Starknet actually does, which is like actually validating the chain. You could make the argument that if you're running an l one node, you're running a starknet node because you're validating all the proofs.
00:16:57.442 - 00:17:01.320, Speaker A: Right, fair enough.
00:17:02.430 - 00:17:38.082, Speaker B: So there's this mention of data that I find fascinating. And again, I think that all of these questions, there's no good answer to them. Right. We're going to figure out along as the years go by, what is valuable, what is not, and who doesn't want to, who attributes value to what. I'm curious, so you mentioned that Nezamind is running their own also full node effort. Are you in touch with each other? How do you synchronize on working on these.
00:17:38.216 - 00:18:04.170, Speaker A: So far we haven't had much direct contact except for on our. So we have a spec for the JSON RPC API and we communicate there and we communicate around peer to peer, which hasn't happened yet, but it's an upcoming sort of major feature, I guess. But yeah, otherwise not much direct communication.
00:18:04.750 - 00:18:06.010, Speaker B: When you're mentioning.
00:18:08.350 - 00:18:20.820, Speaker A: As far as understanding Juno still, I think they had a first release a cup like a month ago or so. So I think they're still hard at work catching up in terms of features just because, well, they obviously started a lot later than we did.
00:18:22.870 - 00:18:31.430, Speaker B: You mentioned peer to peer for this kind of library. Will you rewrite everything or will you reuse existing libraries?
00:18:33.530 - 00:19:32.940, Speaker A: We're currently probably going to be using lip PTP as the sort of foundation for all the peer to peer stuff. And yeah, so we've got a rough draft of the peer to peer spec that's up and going, but it's now onto us and other node developers and other people to start actually implementing it and sort of seeing and feeling how things are going. It's still very early days, so as you say, we kind of have to build it and see how it feels, change it a bit, and then slowly start rolling it out. So the nice thing is it doesn't matter if we really. Okay, I was about to say it doesn't matter so much if we screw it up, but it kind of does. But the nice thing is that there's always l one. There's inherent security in the fact we don't have to trust other things in general anyway, faulty network, we can always throw it away and start again until we've got a better one.
00:19:34.350 - 00:19:47.938, Speaker B: In a way, running a full node right now is more like running an indexer rather than running an actual node, right? Yes, you're more watching the network rather than contributing to running the network.
00:19:47.974 - 00:19:55.822, Speaker A: It's going to be like that for quite a while still, right? Like the stocknet is still centralized, is the sequencer and the gateway, and that's pretty much it.
00:19:55.876 - 00:20:02.114, Speaker B: So currently, once we have full nodes, we need full nodes to go to sequencers, right?
00:20:02.232 - 00:20:06.450, Speaker A: Yeah, no, sure. It's a process.
00:20:06.600 - 00:21:07.474, Speaker B: It is for sure. And it will take some time. Good things are not built overnight. While we're talking about sequencing and things like that, we mentioned the data storing difference between having a node on Starknet and having a node on Ethereum. I'm curious if we can talk a bit about the time difference, like the time difference between different nodes, because there's this different cinematics in terms of when you're on l one, you send a transaction, it goes to a node, then to a mining node, it stays in the mem pool, then it's included in a block and it's validated. And then you wait for a while and you can consider that it's impossible to roll back the dynamics around that are different on Sarknet in the sense that you will first send your transaction. It will be received by some node, which kind, we're not sure if there's a lot of traffic.
00:21:07.474 - 00:21:47.762, Speaker B: Maybe all the raspberry PI nodes won't handle the transaction. They will just delegate it to our nodes. There will be the validators, the sequencers, who will have a mempool and include these transactions in a block. And then this block will be published to the network and it will have the stamps of the validators saying, yes, this block is valid with no proofs attached, right? Which is already the case today in a way. And from what I understand, from what you're saying, these blocks are not picked up currently by Pathfinder. You're not really interacting at the l two level. You're taking what happens at the next step.
00:21:47.762 - 00:22:28.110, Speaker B: So when a bunch of l two blocks are collected, they're proven and sent to l one. Here there's technically two steps. Like once you have the proof, you could verify the proof without it being on l one. And then once the proof is sent to l one, you're sure that the block cannot be a rollback and you have an extra layer of finality. Just like there is a difference in terms of what kind of data each node will store. There will be also a difference in terms of. I'm not sure if the proper parameter is time, but there is time associated to it.
00:22:28.110 - 00:22:51.080, Speaker B: But each node will have, each block will have a different level of security, and there might be different type of nodes that will give you different blocks. It may make sense to just run a node that has only proven blocks or just blocks that are being built. Some will maintain the main pool, others won't. I'm curious, what are your thoughts on that and what kind of nodes you see arising there?
00:22:51.470 - 00:23:33.698, Speaker A: Okay, maybe just a short, quick correction. So Pathfinder does look at the sequences. So it does communicate with l two to get those blocks, but it just marks them as only l two accepted. And then once they've reached l one, then it marks them as l one accepted. And even currently on main net, the feature is almost ready. But we're going to be pulling the pending block on main net as well, because of the long block times. Otherwise some users, well, they want really fast transaction notification and so on, right? So they need that kind of latency.
00:23:33.698 - 00:23:41.206, Speaker A: But they trade off, like you say the trade off is now your finality isn't quite as strong, and also it.
00:23:41.228 - 00:23:55.200, Speaker B: Will take you more resources, right, if you have to validate consensus. And if you take a block, when l two gives you a block, what will it give you? Will it give you a list of transaction or will it give you a new state?
00:23:56.610 - 00:24:00.240, Speaker A: You can probably both, depending on what you ask for.
00:24:00.770 - 00:24:02.286, Speaker B: Yeah, sure, it makes sense.
00:24:02.468 - 00:25:10.114, Speaker A: And like you say, when you're creating a new node or wanting to build one, you have a trade off of at least three things, right? You have latency, finality or security, and then you also have computation like a raspberry PI or like a super light node. Probably doesn't have much computing power. So if you want to do full blocks, maybe you skip some steps and are just less secure. It's a trade off you make, or you go, listen, just mark this as question mark, wait for it to appear on l one, and then you go okay, cool, tick. Now we're very sure, or like you mentioned even earlier, you have less computing power, but you're only interested in this one contract and its events, so you just only verify that slice and then you need a lot less computing power and storage and so on. So there's a very large space to play in in terms of node design here. However, which ones will actually be useful? That depends on what people build.
00:25:10.312 - 00:25:16.166, Speaker B: Are you talking with other teams who are using a full node or who are saying, hey, we need this and that.
00:25:16.268 - 00:25:20.600, Speaker A: So as far as node implementations go, there aren't any others that I'm aware of.
00:25:23.070 - 00:25:23.606, Speaker B: Projects?
00:25:23.638 - 00:26:02.040, Speaker A: Users. Users, yeah, currently it's mainly indexes, I think, and then other services like Infuria or Chainstack that are just essentially rehosting Pathfinder and exposing the endpoints for it. Yeah. Otherwise other teams we're communicating with also like the sdks, like the Javascript and the Python, the Rust SDK people, but to get them to support the RPC, but otherwise, so far it's been mainly indexes and then users who, I'm not quite sure what they're building.
00:26:04.170 - 00:26:07.634, Speaker B: The people who are running the node and posting screenshots in discord?
00:26:07.682 - 00:26:27.758, Speaker A: No, some of those guys too. But there are some actual people building on top of Pathfinder, but I'm not entirely sure what product it is that they're actually building. The questions that they ask have been very interesting. At this point, it's still very early days.
00:26:27.924 - 00:26:59.240, Speaker B: Sure. So extra question regarding performances. So currently Pyfinder works, right, at least in April. I remember a few people saying, yeah, Pathfinder works, but it's too slow to use on testnet. You can use it on mainnet because there's not a lot of volume. But as soon as you want to use it on Testnet, it's really hard to catch up with the tip of the chain. Where are we on that front?
00:27:00.730 - 00:27:19.470, Speaker A: Yeah, essentially the problem was that the sync process was extremely slow and that problem was sort of twofold. One testnet block time is just extremely fast. So by the time Pathfinder, like you start a new Pathfinder node today and you want to sync on Testnet, you have almost 300,000 blocks that you need to sync.
00:27:20.850 - 00:27:24.158, Speaker B: So these, you sync them from L two or from L one?
00:27:24.244 - 00:27:53.846, Speaker A: From L two. And then in parallel we're also querying l one. So you can almost imagine it as two parallel streams where you're querying from l two and building up your getting your blocks and so on. And then in parallel you're getting the, well, information from L one and marking blocks as correct as you're going along. But the l one part is a lot less data. It's just a log, an ethereum log per block. And you can get them in large chunks.
00:27:53.846 - 00:28:28.500, Speaker A: So the l one sync portion takes well maybe a minute for all of Testnet. Whereas getting the actual block data is a very sequential process. Right. You download block one from the sequencer, you verify it, you download block two and so on. So that takes an extremely long time. And especially back in April, the gateway's performance wasn't quite up to the number of Pathfinder nodes that suddenly started. Effectively, the community buy in was just way too quick.
00:28:28.500 - 00:28:39.814, Speaker A: So suddenly overnight there were 300 pathfinder nodes that jumped up and started spamming the sequencer gateway and that just caused the gateway to go, oh, that sounds.
00:28:39.852 - 00:28:44.074, Speaker B: Like something where a p two p layer, even a dom one, would help a lot, right?
00:28:44.112 - 00:28:45.100, Speaker A: Yeah, it would.
00:28:47.390 - 00:28:51.500, Speaker B: It would alleviate the sequencer, made the performance better for everyone.
00:28:52.110 - 00:29:33.030, Speaker A: No, that's definitely true and PTP will fix this permanently. But as it stands currently, what's happened in the meantime is basically that for Testnet we release a snapshot. So for example, I think right now you can download a snapshot at 250,000 blocks and then catch up yourself. And what's also changed is that the gateway's performance has improved dramatically since then. So back at the start. I think it was taking 30 seconds to download a block, which, if you want to do quick math, 300,000 blocks at 30 seconds to download because applying the block and verifying it locally takes milliseconds. But downloading it just took forever.
00:29:33.030 - 00:30:03.300, Speaker A: But now it's down to like half a second to a second, depending on your Internet and where you are located in the world. So now it's a little bit more manageable. But as you say, p to P would just dramatically change the game here. But for us, it's just been a question of priorities. The snapshot basically alleviated this problem greatly. And there have been enough other features that we have needed. Before PTP was really high on the list.
00:30:03.300 - 00:30:21.240, Speaker A: It's kind of felt like this eternally just out of reach that we don't quite get around to building. But that's. Yeah, apart from keeping up with stocknet updates and so on, that PTP is our proper, real big next focus.
00:30:22.190 - 00:31:08.134, Speaker B: Very cool. Okay, thanks for this clarification. It's really interesting. I think there's a certain beauty to see engineers struggle with something and then solve it and then just it being immediately be floated by something else and there's always a new fire to put out and it's really impressive to see. So another big upgrade that will come will be the moment where you'll be able to test your transaction against your local state to see the outcome of your transaction. And maybe an extension of that will be to verify, to estimate the gas your transaction would cost. How far along are we on that front before I'm able to.
00:31:08.252 - 00:31:10.294, Speaker A: The gas estimation is already there.
00:31:10.492 - 00:31:11.400, Speaker B: Very nice.
00:31:11.930 - 00:31:22.266, Speaker A: And then call is as well. I don't think we're ever going to be doing transaction execution, but we have call execution, if that's what you mean. Where you.
00:31:22.368 - 00:31:23.322, Speaker B: Yeah, it is.
00:31:23.456 - 00:31:25.740, Speaker A: Yeah, we spot those.
00:31:28.110 - 00:31:30.350, Speaker B: So you can really do it. Very nice.
00:31:30.420 - 00:31:36.980, Speaker A: Yeah, I think we got that feature a month or two ago.
00:31:38.390 - 00:32:02.658, Speaker B: I need to test it more thoroughly. Sorry. Cool. So moving on to my next question. So when you run a starknet node and when you run a Pathfinder node, you need to have an l one node associated to it, attached to it. Can you talk to us about the specs of this node specifically? I think it's an archive node.
00:32:02.754 - 00:32:03.062, Speaker A: Right.
00:32:03.116 - 00:32:07.286, Speaker B: And I'm curious as to why we've.
00:32:07.318 - 00:32:31.714, Speaker A: Since changed that requirement. It was a bit of a misunderstanding on our behalf. But effectively what you need is an l one node that can serve, that can all events, all logs. Yeah. And initially we wrote down archive node because we were using an infuria endpoint to test with. And their full node doesn't give you historical events, only the archive node does.
00:32:31.832 - 00:32:36.034, Speaker B: So they are something like what I'm describing, which is a full node, but not really.
00:32:36.072 - 00:33:03.642, Speaker A: Yeah, exactly. However, it turns out if you run a normal ethereum geth full node, it does serve you all events. And that makes sense. However, the way we tested this was to go well, listen, let's spin up a normal node, a full node, or take a full node endpoint and try it out. And it didn't work. So we were like, well, okay, archive node works. So we put down archive node, but we've since been informed that we are wrong and we changed it.
00:33:03.642 - 00:33:07.070, Speaker A: Just say full node asterisks for infuria.
00:33:08.370 - 00:33:16.830, Speaker B: How did you solve it? Did you just say, okay, so no, inferior full node, it doesn't work. Or did you say, or did you talk with infuriate, say, hey, we need all events?
00:33:18.130 - 00:33:41.320, Speaker A: Yeah. So we asked infuria just to make sure that we were understanding this correctly. And yeah, they basically just said, well, we just put in our readme. Now, listen, if you're using infura, make sure it's the archive node option and everything else is a full node. And if there are other services or nodes that change the definition, then I guess we'll put another asterisk there and say, okay, and if you're using this one, be sure.
00:33:42.730 - 00:33:52.106, Speaker B: If we look forward, would it make sense to have an l two p two p layer where you exchange l one events so that people can say.
00:33:52.128 - 00:33:52.970, Speaker A: Hey, these are the.
00:33:53.040 - 00:34:04.510, Speaker B: I mean, why not, right? You could have a light node as long as you're able to say, hey, these events are genuine. I don't need to keep all the state of ethereum, I just need to make sure that it's included in a block correctly. Why not?
00:34:04.660 - 00:34:34.294, Speaker A: I mean, there have also been discussions about creating a sort of Stocknet l one hybrid node. Instead of pointing to an l one node, you actually build a minimal l one capable node that only does sort of the maybe takes part in consensus, like on l one l one consensus or whatnot. But at the very least, the only thing you need to store though, instead of storing all the history, is you only need to store the stocknet relevant history.
00:34:34.492 - 00:34:35.106, Speaker B: Right.
00:34:35.228 - 00:34:45.070, Speaker A: So you can start building hybrids like that, for example. But once again, early days, way too many things to build.
00:34:45.220 - 00:34:48.702, Speaker B: Yeah, for sure. How many people are working on Pathfinder currently?
00:34:48.756 - 00:34:50.574, Speaker A: Pathfinder is four people.
00:34:50.772 - 00:35:19.720, Speaker B: Wow, very cool. Yeah. I'm curious also to hear I've asked a lot of questions, but I'm curious if you have a broader question, if you can share some stuff that were challenging, some stuff that were surprisingly easy, can you tell us the story of developing Pathfinder? What were struggle? When did you shift gears? How did it happen.
00:35:23.210 - 00:36:27.790, Speaker A: Initially for us, I guess right at the start it was just a lot of learning that had to happen because we were essentially coming and going. Okay, Stocknet, yes, we've read through the docs, we understand a little bit about how contracts work and so on, but then getting into the actual, how do you build something that can to a certain degree, replicate a lot of what the sequencer is doing when it calculates proofs and so on? That was a real big challenge. So I think, for example, the first big thing I worked on was the Merkel Patricia tree implementation. That just was extremely difficult to get right. And the problem is, because it's a bunch of hashes, as soon as you have one mistake, all the hashes are wrong, and you can't really figure out where it's wrong because the answer is just random. But apart from that, things have been kind of pretty straightforward. The big challenge so far has really been just how fast stocknet has been evolving.
00:36:27.790 - 00:37:36.100, Speaker A: And because we are being run by so many different things and including infuria, and they expect the uptime of the node to be up. So every time the stocknet releases a new version, we have to make sure that ahead of time, we've already got an update ready to make sure that keeps running while starknet updates. And similarly, because we are the first node, we often run into problems that nobody else has hit yet in starknet, because we're building on things that not many people have built on yet or have replicated yet. So often where we go there is no documentation, or the documentation is old or hasn't been touched or updated in a while. A lot of the time we've built something and then tested it and it just doesn't work and we can't understand why. Then it turns out, oh, there's a slight change in how this was implemented before the documentation was updated, and it's just the way it is.
00:37:36.710 - 00:38:15.962, Speaker B: In my experience, this kind of stuff really slows down development. Not necessarily because you're fumbling in the dark, but because you do it a couple of times, you waste some time and then you just switch to asking, hey, this doesn't work. Is there an error on your side? And there's not necessarily an error on your side. And so the lack of documentation can really create friction between teams because you tend to think like, oh, this is probably on the other, I don't want to waste time if it's on the other party side. And so you kind of just try to. I'm not in this work group, so I'm not sure if this happens, but it sounds like something that could be frustrating.
00:38:16.106 - 00:39:04.186, Speaker A: Yeah, it's been difficult, but I mean, that's just the nature of it. I think. Like you say, we don't know what we don't know, so we're never quite sure. Is it our mistake or is the information just incomplete? And it's been both equally often. So you kind of try something and then eventually like, fuck it, I'm just going to ask. And then often there was a simple mistake I made or there was a slight change in direction on their end and that's how it works. And yeah, some other interesting technical challenges have been to support call and estimate fee, and that was mainly because in order to support those, we actually have to run a Cairo VM to execute the functions.
00:39:04.186 - 00:39:22.520, Speaker A: And what that basically means is we've got a little Python Cairo Vm embedded in Pathfinder, but Pathfinder is written in rust, so we've had to build a sort of communication between this VM and our main program and that took a bit of doing.
00:39:24.250 - 00:39:27.010, Speaker B: Are you excited about the Cairo Rust VM?
00:39:27.090 - 00:39:51.198, Speaker A: Oh, so much. I'm watching the development with eagle eyes and just going, oh, come on, it looks great. Looks like it's going to be a lot faster and it's going to be. Well, even once they're done with their. I think it's called Cleopatra. Right. Even when it's done, I think there's still going to be a gap between what we need and what they've built.
00:39:51.198 - 00:40:10.214, Speaker A: But I mean, that's fine. Maybe we can figure out how to make it do everything we need, because it's not just vm that we need, we need the whole stock. Like a little bit of stocknet wrapped around it, I think. I haven't quite looked into the details yet, but yeah, I'm very excited for one day when I can rip out this python and replace it.
00:40:10.412 - 00:40:10.934, Speaker B: Very nice.
00:40:10.972 - 00:40:14.310, Speaker A: Also made our install instructions a bit of a nightmare.
00:40:16.330 - 00:40:20.306, Speaker B: Yeah, because now you're dependent on dependencies from Rust and from Python.
00:40:20.418 - 00:40:28.220, Speaker A: Yeah. Then users forget to hit Python update button and then it crashes everything. Yeah.
00:40:29.070 - 00:41:00.310, Speaker B: Linked to that or not linked to the call functionality. I'm curious if you're talking with people developing tooling for Starknet and specifically people developing a bunch of people are asking, when do we get main net forking? So that you want to run a test and some tools on Ethereum let you do that. Basically they run a simulation of you sending a transaction by forking the state of mainnet. But it sounds like something you need a full node to implement.
00:41:03.130 - 00:41:27.440, Speaker A: I mean, like, I know there's Devnet, which sort of fakes a sequencer gateway, right? And we've had questions about if we can support that. And I think while technically possible, it's just difficult to effectively, once PTP occurs, all of this goes out the window. Right?
00:41:28.370 - 00:41:29.520, Speaker B: What do you mean?
00:41:31.810 - 00:42:29.890, Speaker A: So currently Pathfinder communicates with the sequencer gateway to get its information about new blocks. But once P to P is there, we're no longer going to be talking to the gateway directly. Somewhere there'll be a node that emits a new block and then we only communicate to it. So at that point, because Devnet is, as far as I understand it, I'm not that familiar. It simulates the gateway a bit like you can tell it what block, when to emit a new block and what kind of block and transactions to emit. And I think once we're at a peer to peer stage, you can very easily have a Pathfinder node that runs and then listens to sort of a smaller node that just emits the blocks that basically takes the place of Devnet. In that sense, then you would have the same setup that people want now with Pathfinder plus Devnet.
00:42:29.890 - 00:42:42.070, Speaker A: Okay, I think. But it's been asked, it's just not been high enough of priority, unfortunately.
00:42:42.650 - 00:42:44.630, Speaker B: There's only so many hours in the day.
00:42:44.700 - 00:42:45.880, Speaker A: Yeah, that's the thing.
00:42:47.130 - 00:43:17.360, Speaker B: Okay, so I'm looking at the questions online. In the community call channel. There's one I saw in the beginning and I can't find anymore, but that's fine. I see some question about community provision mechanism, stuff like that. I see Odin is answering, so I'm not going to touch on these. I see Masik is asking, do nodes track the state after it is finalized on l two or on l one? And your answer was both, right?
00:43:17.890 - 00:43:25.700, Speaker A: Yeah. So it tracks it from l two and then once it lands on l one, we mark it as accepted by l one. And that's pretty much the only difference.
00:43:26.150 - 00:43:46.730, Speaker B: Very cool. Yeah. And I don't see more questions here. If you have questions, feel free to ask them in the community call channel on discord or in the chat on YouTube. Happy to answer these. And it can be questions about full notes. It can be questions like more general questions.
00:43:46.730 - 00:44:33.238, Speaker B: I'm also curious, by the way, if you have opportunities to say, hey, I want the next community call to be about this, so don't hesitate and send suggestions there. Yeah, let me go back to my list of questions and see. Yeah, so we mentioned a lot of things possible, we mentioned a lot of technical challenges, a lot of potential things you could be working on. And as you mentioned, there's only so much brain power you can use to do that. So I'm curious, what's next? What's in your roadmap, what's the timeline, what are the next big things for Pathfinder?
00:44:33.414 - 00:45:42.670, Speaker A: So in the very short term we're going to be releasing pending support. So for those that pending blocks. So I mentioned this earlier, but Mainnet, because the block times are so slow, you can query it to ask for the pending block, which basically gives you the block information as it's been currently built and probably will be released soon, or what's it called, created soon. And to date Pathfinder has been sort of. You can query Pathfinder for the pending block, but up until, well, currently it still basically forwards that query to the sequencer and just returns what it returns. Whereas, well, with the downside being that you aren't getting any of the local Pathfinder verification or validation happening. So what we're busy with now is to pull the pending block on the sequencer and verify that information locally, so that when you query Pathfinder for the pending block, you instead get the local cached version of it that has been verified and validated in as far as we can, which is good in two ways.
00:45:42.670 - 00:46:17.260, Speaker A: First off, it's going to be. Your query will be a lot faster because the latency is less, like it's not going to Pathfinder and then to the gateway and then back again, it's just going to Pathfinder. And then you get a little bit more trust in the data because Pathfinder is also applying some verification to it. And then slightly longer term is like the major thing is p to p, peer to peer still. Otherwise it's really just keeping up with stocknet changes. Like the zero point ten is coming up soon and that's got quite a few breaking changes in it.
00:46:20.270 - 00:46:22.060, Speaker B: How does this affect you?
00:46:25.710 - 00:47:27.250, Speaker A: Stocknet's release cycle is a little difficult to deal with for us because first Testnet gets released and then a week plus later mainnet gets released. So there's this week or two period, two week period where we have to effectively support both the old version and the new version at the same time. So we end up with a lot of extra dead code in our code that we then delete two weeks later because we no longer need it. But for that period we need this sort of if else kind of statement the whole time. So that's frustrating, but that's part of the deal. The other difficulty is sometimes breaking changes aren't as backwards compatible as one would hope. For example, I think there's nonsense that are getting added now to contracts and then the nonces from the older historical blocks get some default value of zero or whatever.
00:47:27.250 - 00:47:59.446, Speaker A: But that now means either we say, okay, contracts have an optional nonce value and only supported going forwards. But that kind of leaves you in a like it's easy to make mistakes you kind of want to enforce. Ideally we would enforce that there must be a nonce. So what we then do is we go back and change all the historical blocks that we have already stored and add a zero. But that takes time physically for your database to update and have all that happen to it, especially on testnet we're updating.
00:47:59.638 - 00:48:01.702, Speaker B: You fucked up your whole database.
00:48:01.766 - 00:48:36.710, Speaker A: Yeah. So we take a lot of care with the database just to make sure that we don't do anything like that. But of course mistakes happen. So it's very nerve wracking. Every time an update like this comes around it always feels very small and insignificant. But for us it's usually okay, can we do this and can we do this migration carefully or are we going to screw something up? And then you just need to be quite careful. So it's not always difficult, but it's always stressful.
00:48:37.690 - 00:49:29.298, Speaker B: Understood. Look, I think I've asked most of the questions I wanted to ask. I don't see more questions on Discord and on YouTube. So I see a question by Christian saying it's unrelated to full node, but it's will Starkx combine with Starknet on an l free level in the future? Christian. So the question is, will Starkx be an l free to Starknet? I think the answer to that is that I don't think we have a strong opinion on that. If some project want to use Tarkax as an l two, why not Sharp will still be so sharp. The shared prover is the system that allows you to send proofs to generate and send to ethereum proofs for Cairo programs.
00:49:29.298 - 00:50:01.170, Speaker B: It is what is used to send the proofs of Starknet to L one. It will most likely be possible, I mean it will be possible for Starkx projects to be an l two. Now if they want to use sharp over Starknet it will also be possible and it will reduce costs further and give them more composability. This will just depend on who wants to do what in which projects. So both will be possible. That's a small apartheid.
00:50:03.270 - 00:50:03.634, Speaker A: Yeah.
00:50:03.672 - 00:50:40.240, Speaker B: I don't see more questions so I think we can wrap it up. Mirko, thank you a lot for your time and your explanation. You're doing phenomenal work that is like on the cutting edge of the cutting edge. I think that's really interesting and sounds stressful. Also, I hope the team has as much fun writing this software as we all collectively have using it. I don't know if there's anything you want to mention before we close.
00:50:42.690 - 00:50:56.180, Speaker A: No, I guess not. Thanks for having me on. Been nice chatting. Yeah. And I guess maybe just shout out to the community those that are using Pathfind and those that haven't. You can always test it for us. It's always great.
00:50:56.180 - 00:51:01.240, Speaker A: Yeah. The community so far has been really great. The uptake has been huge.
00:51:03.530 - 00:51:19.960, Speaker B: Wonderful. All right, well, thank you everyone for joining us on this community call today and we'll see you in two weeks. And in two weeks it will be Leron hosting the community call. Have a good day.
