00:00:09.280 - 00:01:38.980, Speaker A: Hi everyone, can you hear me? Magnificent. Okay, so as the title says, today we're going to work a bit on Kakarot, the ZKVM written in Cairo that Abdel started a few weeks ago. And we implemented quite a few opcodes and we're going to walk through it. So this is the one. Okay, so first we're going to go here on Kakarat, the GitHub repo. I'll send the link, tell me if it's big enough or if it's too small, but okay, let's check the readme. So there are a bunch of stuff on how to set up the environment.
00:01:38.980 - 00:02:09.592, Speaker A: This is a GiF done by Abdel. He really likes them. This is the number of supported opcodes. So you can see we have 87% of the opcodes that are supported. Now it remains probably the 13% hardest percent. There's a bit of explanation on how it works, but we don't really care. And here are the contributors.
00:02:09.592 - 00:02:59.448, Speaker A: Okay, so let's open the repo somewhere. Okay. Using TMax, because Ben loves it. Okay, so let's go into the repo, let's check what happened. Okay, and today we're gonna walk on poll upward. But first a little walkthrough on how everything works. Oh, Danilo, never doing anything else than Kagarot.
00:02:59.448 - 00:03:29.426, Speaker A: I see. Okay, so how it works precisely. So here is kakarot, like the external file, because right now Kakarot is a smart contract that we can deploy on Startnet. And here comes Abdel. Hello Abdel.
00:03:29.618 - 00:03:32.760, Speaker B: Hey Lucas, how are. Good, good.
00:03:33.850 - 00:03:40.842, Speaker A: I was walking people through Kakarot, but if you want to speak about it, feel free to do.
00:03:40.896 - 00:04:06.260, Speaker B: Yes, yeah, I can say a few words about the project. So basically Kakarot is a ZKVM written in Cairo. So there are multiple types of ZKVM. For people that are interested in those types. I suggest to read the article from Vitalik. Maybe you can share the link. Lucas, let me send it to you.
00:04:06.260 - 00:05:13.030, Speaker B: It's a very interesting article and it presents different decayvm types. Basically there are four main types, type one, two, three and four. And basically the TLDR is that the lower the number, the closer to ethereum compatibility it is. But the less performance and the higher the numbers, the less compatible with Ethereum, but the more efficient in terms of ZK proving and this kind of stuff. So this seems interesting because depending on the needs, you may want to have more compatibility with Ethereum. Why? Because you can use existing tooling, for example, I don't know, debugging tools or any static analysis tooling or stuff like that. And you can leverage from all the existing tooling from Ethereum and also reuse aziz existing bytecodes.
00:05:13.030 - 00:06:17.066, Speaker B: But if you want to focus on maximum efficiency of the probing system, then you may want to have higher type ckVm, or you may even want to not have EVM compatibility. And this is basically what we proposed with native Cairo. The promise is to have the maximal efficiency of the underlying probing system. But for people that do want EVM compatibility, it might make sense to have this kind of EVM compatibility. So that Kakarot is, we aim to have a type three VkVM. So basically this means strict EVM equivalents minus some changes like no support for the precompiles, for example. What are precompiles? So in the EVM world there are some opcodes, basically for example add is an opcode to do an addition notification.
00:06:17.066 - 00:07:20.210, Speaker B: So there are a bunch of arithmetic opcodes, there are some system opcodes, et cetera, to do call to other contracts. And aside from those opcodes, basically there are 142 opcodes in the AVM. And aside from those upcodes, there are also some special system contracts that are called precompy that are not run in the AVM world. And they aim to provide a specific function like for example signature verification, elliptic curve pairing, stuff like that, or other hashing algorithm. And they are run actually in native code. So for example, if you run get for example, so the Ethereum execution client written in Go, then the precompile will be written in go. If you run a client written in rust, the precompile will be run in the native code of the client.
00:07:20.210 - 00:08:18.638, Speaker B: Those precompiles are very hard to implement in Cairo and generally in a proof system world. So this is why when you implement a type three, you don't have to implement those precompiles, but other than that you have a full AVN equivalent. So this is what we aim to do with Kakarot. And Kakarot has a very special and unique architecture because it actually runs as a smart contract on Starknet, and the smart contract contains logic to run an EVM interpreter. So this is very powerful. This is a kind of inception where you have a smart contract that runs a VM that is interpreted by the K or virtual machine and generate proofs for the execution of the EVM bytecode. That means that you get Zkvm.
00:08:18.638 - 00:09:13.142, Speaker B: So it was more a showcase to showcase the power of Cairo actually, because if we can do such powerful and such complex stuff like an EVM with Cairo. That means that truly this is showing complete and you can build anything you want. With Cairo we will never get the performance of native Cairo for sure, and not even close. And this is not the purpose, but plus it is a very powerful showcase of that. So to put stuff in perspective, if you want to build a ZKVM from scratch and you don't have Cairo, basically you have to build manually all the circuits or the algebraic intermediate representation for each opcode, et cetera. And this is very painful. And like all projects that are building a ZKVM, it takes a very long time.
00:09:13.142 - 00:09:53.220, Speaker B: Basically they started more than a year ago or even two years ago. And some are not even at the point where we are at with Kakarot. So this is the perfect showcase of the power of Cairo because we can do that only because of the power of Cairo. This is truly the message we want to pass with Kakarot. And other than that it's exciting and we want it to become a community driven effort. And actually it starts to really be mainly driven by external contributors. I guess we can talk a bit more about that later, but this is huge to see the traction around the project and the engagement from the community.
00:09:54.390 - 00:10:27.360, Speaker A: Well, thank you Abdel. I think you have a great overview of what Kakarot is. And now we can walk through technically how it works. So basically what we need is that we need the bytecode because it's an evm interpreter. So we need the bytecode and every byte will be a felt. So the full code, the full bytecode would be like a felt array with all the opcodes. Then we have the call data for the function call.
00:10:27.360 - 00:11:03.910, Speaker A: And that we don't care is for the test. And so we'll execute this bytecode. So we go into this function and we will generate all the instructions because basically what we need is to have all the opcodes in Cairo. So what we're doing here is that we have all the functions for that, which are somewhere, somewhere around here.
00:11:04.060 - 00:11:06.570, Speaker B: Instructions ko yeah, exactly.
00:11:06.640 - 00:11:45.510, Speaker A: And here we save all the functions cut offsets and we map them to the opcode. So for example, the opcode one corresponds to the opcode add and we save the code offset in a mapping. So when we call the opcode one, it will go in the mapping check. Oh, upcode one. Let's get the code offset. It will get the code offset of exec add and then it will call add. This will be done here in the run function.
00:11:45.510 - 00:12:27.986, Speaker A: So this basically just creates an execution context because we need it the execution context will contain everything we need to run the smart contract. So the nested call depth. Actually, we need this for the call opcode, which we will finish to implement here. Here the parent is the same thing. It's a pointer to the parent context. So when we have nested calls, for example, contract a equals contract b, there will be a nested call, and we'll need to fetch the old execution context once the call is finished. So we need this pointer, then the code.
00:12:27.986 - 00:13:01.502, Speaker A: So as I said, it's a felt array. So we need the bytecode, call data, same, it's a felt array program counter. We need it to keep track of where we are and if the execution context is stopped. Basically every run finishes with the zero opcode, which is the stop instruction. Return data is also an array, and it's the data that the function will return. Are you raising your head, your hand up there? Yeah. Okay.
00:13:01.502 - 00:13:02.174, Speaker A: Please.
00:13:02.292 - 00:13:48.978, Speaker B: Yes, I didn't want to interrupt you. Yeah, basically. Also, while you explain, sometimes I may jump and say about the challenges we got and what we learned and also some useful contributions that people that are listening could jump into. And I'm thinking about how we handle bytes actually, because for the moment we have a naive way of dealing with bytes. So in the EVM world, we deal with bytes. A byte is an integral value between zero and 255, and that's grid. You can manipulate byte array, et cetera, on stocknets.
00:13:48.978 - 00:15:04.630, Speaker B: And in Cairo you have only felt, and felt is an integral, which is a maximum true power of 251. That means that in theory we could store up to 31 bytes into one face. So we don't do that for the moment. And it's an issue because actually we waste a lot of memory. And memory is an important resource when you want to prove, because a number of variables affect drastically the performance of the probing system. So if someone want to experiment and implement some more smart mechanism to represent bytes, like for example, felt packing, like for example, we could in one felt store 31 bytes, and then we will need some useful functions to manipulate that easily because we don't want to introduce a lot of overhead in terms of code complexity. But yes, that would be a great thing to do and to experiment if you want to contribute.
00:15:06.730 - 00:15:21.834, Speaker A: Yes, we're looking for the community to work on it. So if you want to work on this, please do. Yes, we're from France, but yes, if you want to work on it and if you have some ideas, you can talk with us.
00:15:22.032 - 00:15:26.540, Speaker B: Does this question mean that we have a dirty accent or something like that?
00:15:29.250 - 00:15:47.986, Speaker A: No, I think it's because of the view behind me. He saw like the. Yeah. If you want to contribute, please do. We need you for this. We want to step out of Kagarot. We want it to be a community effort or.
00:15:47.986 - 00:16:16.538, Speaker A: Well, we want to outsource it. Rosie. Mia. If you want to make it efficient, please do you have the link to the repo? You can check the issues. You can work on some issues, just need to coordinate with the others not to work on the same thing. But it would be really cool if you guys work on it also. Yeah.
00:16:16.538 - 00:16:54.614, Speaker A: And so, coming back to the execution context. So the stack, because the EVM is stack based. So you got your stack, you just push some stuff on the stack and pop it, and blah, blah, blah. Regular stack. And the memory, which works weirdly, but it's just a memory. And then specific to the EVM, gas used, gas limits, interesting gas cost. And then the starknet address and the EVM address, because the architecture is that we want to deploy every EVM contract as a starknet contract.
00:16:54.614 - 00:17:40.200, Speaker A: So for example, you have an ERC 20 written in solidity. Then you will deploy a contract on Starknet that has a view that is called get code, and that will just return all the bytecode of the contract. As Abdel said, it's not optimized, and we're looking to optimize it. But for now, we're just moving quickly to have a real PoC. But this will be improved. Yeah, that's how it works. So we need to map the starnet address to the EVM address, because we need to interact with starknet and we need to have the EVM address to know what contract we're calling.
00:17:40.200 - 00:18:37.788, Speaker A: Okay, so now we have the execution context, and now we will run the bytecode. So the run function is recursive and will run all the bytecode until it sees a stop popcode. So it will decode and execute the instruction. And basically what decode and execute does is just call the function using this function, which is really hard to use. And actually, Abdel had lots of trouble making this work, but now it works perfectly. So thanks, Abdel. And basically what invoke does is that it gets a code offset, and it calls the function at the code offset.
00:18:37.788 - 00:19:31.130, Speaker A: But you need to prepare the arguments and you need to parse back the arguments that you receive. So this is why it's quite hard to use. Basically, that's the high level scope and what a no code looks like. Let's check ad. So ad is here. And so what ad does is written here on this wonderful website, EVM code. And you can see that it pops two elements a and b, adds them together, and then it pushes the result on the stack.
00:19:31.130 - 00:19:58.100, Speaker A: So that's exactly what we're going to do. So we're popping two elements a and b, we're adding them together and then we're pushing the result on the stack. So we're using un 256 because one word in the stack is 32 bytes, and in Cairo we're limited to 31 bytes. So we have to use un.
00:19:58.950 - 00:20:19.914, Speaker B: Yeah. Maybe you can explain why we implemented the pop end function, because it is an optimization trick. And this is very interesting and it shows also the difficulties when you work with Cairo and the fact that memory is immutable. So you have to do some tricks like that to optimize. So I think it's interesting if you can explain that.
00:20:19.952 - 00:20:44.480, Speaker A: Yeah, sure. So basically in Cairo the memory is immutable and a stack is not immutable. You can push things and pop things. So if we push something, no, if we pop something, we are. No, I need to check. I think it's when we pop something.
00:20:46.870 - 00:20:49.540, Speaker B: Yeah, it is when we pop that we need to.
00:20:50.790 - 00:21:16.762, Speaker A: Yeah. Okay. So when we push something, we don't copy the full stack, we create another one, but with the new element number, because the memory is immutable. So we can't just rewrite only this property. So we need to create a new one. This is fine because it's not a lot of steps, but when we pop something, we remove something from the stack. We can't actually remove it.
00:21:16.762 - 00:22:20.110, Speaker A: Like memory is immutable, so we can't just delete. So what we have to do is to copy the full stack without the popped elements. So if we have to pop like three things, we would need to copy like twice the stack, which takes a lot of steps and a lot of memory, and we want to mitigate it. So we just added the pop n function to avoid replicating the stack millions of times. Okay, so here we popped in and we didn't bother reversing what's popped because it would have costed a few steps and we want to optimize. So we're using this, and yes, we're using un 256 because the stack uses 32 bytes. So, okay, we got the result and then we push it.
00:22:20.110 - 00:22:49.666, Speaker A: And then we have to create a new context because we modified the stack. And as I said, memory is immutable, so we need to create a new context. And also we modified the gas. Okay, so basically that's a simple opcode. And then we have. Test tests are the funniest part. And I have conflicts.
00:22:49.666 - 00:23:24.286, Speaker A: Yay. So this is like the result memory, the result stack and the bytecode. So the bytecode is just like opcodes that are chained. You see here you have 60. So 60 is push one. So it will push the first, like the next value in the bytecode. So here it will push 42 in hex.
00:23:24.286 - 00:23:50.230, Speaker A: Here it will push something else. Here it's 52. So it's a node code. 52 is m store, I think. Yeah, m store. So it will store a word at a precise offset. So this is the offset, this is the word that we want to store.
00:23:50.230 - 00:24:06.690, Speaker A: And it goes on. So what I would want to do today is to finish the call opcode that we started with Abdel.
00:24:07.190 - 00:24:09.890, Speaker B: I like the message at line 18.
00:24:11.590 - 00:24:17.430, Speaker A: Line 18, yeah, he fucked up the CI.
00:24:19.450 - 00:24:23.510, Speaker B: We were in hackathon mode to give you some excuse.
00:24:24.250 - 00:25:00.060, Speaker A: Yeah, we wanted to go faster. There were some trade offs that we took. So let's go back to the call upcode, which is not here. Where is it? We had to put it here because we had some circular imports, which is not fun to deal with. So we went hackathon mode and just put it there.
00:25:00.430 - 00:26:00.750, Speaker B: Yeah, because the problem is that we wanted to leverage, because basically to implement the call opcred, what you have to do is to invoke the code of another contract. And typically what you want to do is you get the bytecode of the cold contract and then you run the exact same logic that you did to run the bytecode of the caller contract. This is why we wanted to leverage, we were thinking like, okay, it's just the same thing as executing the color contract. Just you take another bytecode and you have another execution context. And because we wanted that, we wanted to be able to run the main rent function. But because of our architecture, we have the main function, which is in the interpreter that has dependencies to the specific opcat function. But you cannot have dependency in the other way because it creates a circular dependency.
00:26:02.610 - 00:26:44.650, Speaker A: Yeah, and it's really not fun. And here you'll see a really unfin rebase. Also because we removed all the hints to be able to deploy on Testnet and to be able to use the rust VM, which does not handle dynamic hints for now. So we want to switch to that. So that's why there is no hint. And that's why we'll need to rebase now and not have fun, because there will be conflicts every step. Are you all on telegram? Yes, we are on Telegram.
00:26:46.270 - 00:26:47.760, Speaker B: Maybe you can share.
00:26:49.730 - 00:26:54.574, Speaker A: I don't have the right, but if you send me the link.
00:26:54.772 - 00:27:04.290, Speaker B: Yeah, I can send you the link would be awesome. Okay. I put it in the chat.
00:27:05.110 - 00:27:19.522, Speaker A: Cool. Feel free to join. Yeah.
00:27:19.656 - 00:27:25.138, Speaker B: Okay. And I will send you the Twitter as well.
00:27:25.324 - 00:27:28.714, Speaker A: Yeah, feel free to join and check the read.
00:27:28.752 - 00:27:31.900, Speaker B: You can post a lot of Goku memes as well.
00:27:35.870 - 00:27:38.800, Speaker A: We don't have moderators for now in this group.
00:27:39.330 - 00:28:11.186, Speaker B: Yeah. Okay. Yeah. By the way, we also want to do some cool stuff for contributors like lightkey. We will do some kind of SBT styleborn token to reward contributors. And basically there will be some rules. Like for example, the number of pr you submitted into kakarot.
00:28:11.186 - 00:28:42.994, Speaker B: And then maybe we will have multiple levels. And for example, if you want to do something funny, we can have the different level of Goku, the different transformation. For example, you submit one pr, you have the normal Goku NFT, and then you submit five pr, you have the Super Saiya jin Goku NFT and so on. And also we maybe will. Sorry, I'm losing my word. Okay. Yeah.
00:28:42.994 - 00:29:11.770, Speaker B: We have booked the Kakarot stock domain name using stocknet id. And with stocknet id you can have free subdomains. That means that for example, for contributor we can do something like for example, Lucas Kakarot stock and it will be linked to Lucasnet accounts. And yes, this is cool. And we want to experiment that for people that contribute on kakarot.
00:29:12.990 - 00:29:45.300, Speaker A: Yeah, you can win some great stuff here. We actually won some nice figures. So you should have participated earlier. I mean, Daniel has won, but others you should have participated before. Here we have a problem, obviously, joy of repeating. Okay.
00:29:48.310 - 00:29:58.870, Speaker B: Maybe I can try. I can. I can try to. How do you say mobly in English? To fill the blanks. Basically, while you are revising.
00:30:01.550 - 00:30:07.020, Speaker A: We have a question. What's required for the airdrop? Do you have an answer for that?
00:30:08.350 - 00:31:06.480, Speaker B: The airdrop? What is the airdrop? Yeah, no, I mean, we want to reward builders. So if you want to get something cool, like, the best way to do this is to submit a pull request on mean. You can also participate in different ways. We have a discussion link in the GitHub repository and you can basically introduce yourself and say what you want to do. And if you are not a dev, it can be like design ux, it can be also creating some memes, stuff like that. But really it is more like if you want to be part of an exciting journey, to feel the vibes of the builders of the ecosystem and be part of the library and community. This is a very cool project to be involved in.
00:31:09.570 - 00:31:20.370, Speaker A: And it's basically not really an airdrop. You get SBT because you contributed to something. I don't know, it's worthless.
00:31:21.830 - 00:31:31.480, Speaker B: It's just to show an achievement of something like that. You have been part of something crazy, something exciting. And. Yeah.
00:31:33.690 - 00:31:38.474, Speaker A: I also nag your friends because you had something better than them.
00:31:38.672 - 00:32:06.962, Speaker B: Yeah. And also we say that. But for example, if at some point some community members want to take the lead, really, on the project, they can decide to make the real product out of it. And we don't know what it can mean. We just take that. But there is no strict guidelines or rules on the project. The community will decide on the future.
00:32:07.016 - 00:32:48.990, Speaker A: Of Kakarot, how to get SBT. You need to contribute to Kakarot. You just go on the repo, then you check if there is an issue that you might be able to resolve. Then you just ask if the issue is available. It should be if it's not assigned to everyone, to anyone. Because we created some strict guidelines about issue resolving. But it's better to ask before so that you don't work on the same thing.
00:32:49.060 - 00:33:32.220, Speaker B: Yeah. And basically you can just jump into the telegram group, you introduce yourself and you say you want to contribute. Then we have alias, which is a very active community member that can also guide you through an onboarding call. And maybe we can do some, maybe regular cacao community call, bi weekly calls to onboard multiple people in one call instead of doing only one on one onboarding call. But yeah, the real treasury is the people you will meet during this journey and what you will also learn.
00:33:36.530 - 00:33:51.874, Speaker A: It's not every day that you can work on ZKVM. And honestly, with Cairo, it's really not easy, but it's way easier than doing it in circum. I don't know.
00:33:52.072 - 00:33:52.820, Speaker B: Exactly.
00:33:53.510 - 00:34:00.680, Speaker A: So this is opportunity to learn some Cairo, to learn about the EVM, to learn about how blockchain works.
00:34:01.610 - 00:34:36.740, Speaker B: Yeah. And it will become even easier with Cairo 10. And we were joking about it because we said that we wanted to start with this version of Cairo because otherwise we would have done it too fast and we would have been in production before the Ksync. So, yeah, it was a joke. But with Cairo 10, the possibilities will be even higher and we will be able to build even crazier stuff.
00:34:37.110 - 00:34:49.490, Speaker A: Yeah, Cairo 1.0 will like, the repo will soon be public, I think, and it's going to be beautiful. I can show you some snippets.
00:34:49.570 - 00:34:53.170, Speaker B: This is the real Alpha, actually. If you show a snippet.
00:34:53.250 - 00:34:56.040, Speaker A: Yeah, I'll show it fast.
00:34:57.870 - 00:34:59.610, Speaker B: They will take screenshots.
00:35:00.430 - 00:35:36.500, Speaker A: Yeah, that's fine. This is what Cairo looks like for now. I mean it's fine, but still see a lot of things. It lacks a lot of functionalities and with carrier one you'll have. No, that's not the best example. This one, I like it with elastic. Oh, it's there.
00:35:42.980 - 00:35:55.300, Speaker B: Yeah. Basically for people familiar with rest, it definitely looks like rest. You have pattern matching for full stop like option. So it really becomes higher level language.
00:35:58.360 - 00:36:31.436, Speaker A: Yeah. You will have error endling, which is really cool, because for now you don't. And it's a bit painful to work with that. There will be also array management, but I don't think we have an example. Yeah, anyway, it's not the subject of the thing. You saw Cairo one. What programming language are we coding on Cairo for now? Well, forever.
00:36:31.436 - 00:36:32.800, Speaker A: Cairo forever.
00:36:33.860 - 00:37:12.990, Speaker B: But if you want specifically on Cacairo, you can contribute in Cairo, but not only in Cairo. We have multiple components, like Lucas is presenting the core component, which is the Cairo program that runs the EVM. But we also have other components. First we have a front end application to interact with Kakarot smart contracts. That means like for example deploy a smart contract on Kakarot and then being able to interact with it. So this is front end technology. So basically react JS stuff like that.
00:37:12.990 - 00:38:01.516, Speaker B: And then we also need, and actually it has not been started yet, so there is definitely room for contribution on that part. We also need the back end. Why? Because ultimately what we want is something very simple and very transparent for the user. So the end goal is something like that. You add just an RPC endpoint on your metamask and you can think it's regular ethereum, which is an RPC endpoint, but actually it's not. But it will give you the same experience. And what this backend will do, it will take the Ethereum transaction, the exact same transaction, and then it will do some stuff like adaptation, stuff like that.
00:38:01.516 - 00:38:44.680, Speaker B: Then it will forward the call to Kakarot. And then you can imagine a very transparent experience. And you can imagine to play exactly as you would play with an Ethereum smart contract. And for this backend, we want it to be in rust and it has not been restarted. So there is definitely room for rust developers to play with it and to kick start it. And there are many possibilities. Either it can be done from scratch, so you reimplement the logic of an Ethereum design RPC, or maybe you can think of fork in an actual Ethereum client, in rust, for example, Akula.
00:38:44.680 - 00:39:47.132, Speaker B: And for example, Akula actually might be a good option. Why? Because it adopts a modular architecture. So when Ethereum clients started, initially they were like a big monolithic application with everything like the EVM, JSON, RPC, the peer to peer, the logic to handle blocks, the consensus, et cetera. And then the more recent clients like Erigon and Akula, for example, they adopted a more modular architecture. Actually Erigon initiated that and they created a specification for modular architecture for an Ethereum client. And what does that mean? It means that you can have different components that are isolated somehow. And it's easier because you can run only pc if you want, you can only take the peer to peer part only evM, stuff like that.
00:39:47.132 - 00:40:07.140, Speaker B: So maybe forking such clients will be a good way to leverage existing code. And then we could just add our adaptation logic for kakarot. So yeah, for rest developers that are listening, feel free to jump in to take up this backend.
00:40:08.440 - 00:40:50.610, Speaker A: Also, someone is asking how to learn. There are multiple ways of learning Cairo. There are some tutorials that since darknet.edu we have made for you that will teach you how to read and write Cairo code. So this is the link of the organization here. The startnet Cairo 101 is just to teach you how to read Cairo. So you will have a set of exercises you'll need to read the code and to reach some instructions to get some points.
00:40:50.610 - 00:41:29.570, Speaker A: Then there are these tutorials that will teach you how to write an ERC 20 and ERC 721. This one will teach you about the messaging system in Starknet. Basically you can send a message to Ethereum and Ethereum can send message to Starknet. This one will teach you how to debug a smart contract. And this will teach you a lot about account abstraction that is native in starknet. There are also other tutorials made by only dust and other people that you can also do.
00:41:30.020 - 00:41:51.270, Speaker B: Yeah, I have a suggestion for you guys that are listening. If you want to learn and relax at the same time, I suggest you to listen to Henry podcast. He has such a relaxing voice. That's crazy. So you can learn and relax at the same.
00:41:53.980 - 00:42:15.230, Speaker A: I mean, he said it. Yeah, there are some podcasts, there are also some workshops. You can listen to Henry your whole life. I think. Yes, you all have enough content. Also Cairo is like solidity. No, not really.
00:42:15.230 - 00:43:16.840, Speaker A: Kairo is a general purpose programming language which means that you can use it everywhere else than blockchain. So let's say that you have an AI and you want to train it on Google Cloud, but you don't trust Google. Then you write your AI in Cairo and they send the trace and you can generate a proof that everything went smoothly and that they didn't cheat in your AI. For now it's mostly used for Starknet, but theoretically you can use it everywhere. What's the problem? Hi Elias, how are you?
00:43:17.930 - 00:43:23.030, Speaker B: Elias is here. Tell him to join. Tell him to join.
00:43:26.570 - 00:43:28.680, Speaker A: I'll send you the zoom link.
00:43:29.290 - 00:44:10.518, Speaker B: Yeah, so Elias is one of the main contributors of Kakarot. So he's not working at StarCraft, he's one of the community member. And he started recently his journey with Cairo actually, and I will let him explain, but I think it was a great experience for him and a great way to learn Cairo. It was very cool because we were all in the same building at Lisbon for Stacknet City. There was the hacker house building. This was another event that was organized by only dust and brick. It was very amazing.
00:44:10.518 - 00:44:36.462, Speaker B: Like it was four apartments that there were something like 50 builders in the same building. Coding and we were all together with Danilo, Elias and other community members hacking on Kakarot and it was like crazy. And yeah, hopefully Elias can join and share his experience as a community member working on Kakarot. Did you send him the link?
00:44:36.596 - 00:44:56.430, Speaker A: Yes, he should. Okay, I can. Yeah, no worries, no worries. It's ending in 15 minutes anyway, so please join. All right.
00:45:01.140 - 00:45:05.568, Speaker B: You are still trying to rebase sort of.
00:45:05.654 - 00:45:17.380, Speaker A: I mean the rebase created conflict because we had modified a bunch of stuff and here I'm having a weird error.
00:45:20.920 - 00:45:55.170, Speaker B: And really the best way to learn, once you have done the tutorial, once you have done starting and stuff like that, the best way to learn is to jump on an open source repo and to contribute. I invite you also to check Omnidusk platform. They provide basically a platform for contribution. Like when you are ready to contribute on Starknet ecosystem, you can just go on only deskt and try to find the contribution. Elias, welcome. We are happy to have you there. Very cool.
00:45:55.170 - 00:46:14.824, Speaker B: I don't know if you listened what we were saying, but basically I think it could be very cool if you could share your experience as someone that recently jumped into Starknet ecosystem and also share the vibes during the event and what you have learned so far and your plan for the future, if that makes sense.
00:46:14.942 - 00:46:45.730, Speaker C: Sure. So hey everyone, I kind of joined by accident. I wasn't supposed to come. My name is Elias, I'm a software engineer based in Paris. I'm 25 and recently I joined the Starknet ecosystem as part of Starknet CC at the same time as Starknet CC and met these two wonderful guys. During a week we hacked at Kakarot. So they introduced me to the project.
00:46:45.730 - 00:47:11.770, Speaker C: I had not coded Kro, I had not used Kro a month ago. So I am very new to this. So I can imagine if any of you are feeling overwhelmed by this amount of code and this syntax and. Yeah, basically I had to get acquainted with Kakarot, help organize the team effort, contribute a bit.
00:47:13.840 - 00:47:14.590, Speaker A: Yeah.
00:47:15.680 - 00:47:16.540, Speaker C: Forgot.
00:47:21.280 - 00:47:30.160, Speaker B: For example, during the hacker house, how was it going? Like, what was the vibes and what was the typical journey in the hacker house?
00:47:30.310 - 00:47:40.524, Speaker C: It was pretty fun. The vibe was pretty cool. The hacker house, we were like 50 people and six of us, approximately seven were hacking on Kakarot. And yeah, the typical day was waking.
00:47:40.572 - 00:47:41.170, Speaker A: Up.
00:47:43.060 - 00:47:56.276, Speaker C: Taking an opcode. We have 140 to code to have a complete EVM and a bunch of other things. But mainly we need 140 opcodes. We got 123 if I'm not mistaken.
00:47:56.308 - 00:47:57.416, Speaker A: Something like this.
00:47:57.598 - 00:48:15.072, Speaker C: So yeah, the basic things were which upcodes are next to destroy. We would destroy an opcode. I'm kidding. Lucas would and we would look at. Yeah, we. During the hackathon, I think we did five upcodes. It was pretty nice.
00:48:15.072 - 00:48:35.232, Speaker C: And big ones s store s load. We implemented storage, we implemented deployment. It's pretty nice. We even got a playground going where we could compare Kakarot and a normal EVM. And we had really cool results. So everyone was really happy. And we even impressed some people at stockware.
00:48:35.232 - 00:48:41.850, Speaker C: So it was very fun and everyone was pretty hyped about it. Honestly, it was fun.
00:48:42.780 - 00:48:46.520, Speaker B: Do you have a link ready to demo the playground?
00:48:46.860 - 00:48:47.720, Speaker C: I think not.
00:48:47.790 - 00:48:48.264, Speaker A: Because.
00:48:48.382 - 00:48:55.832, Speaker C: I'm not sure, actually we should ask. Yeah. Do you remember we had a Devnet and then we stopped using it?
00:48:55.966 - 00:49:05.004, Speaker B: Yeah, the famous devnet of Gregory. Yeah, Gregory is a cool guy. You want to say a few words about Gregory, maybe?
00:49:05.202 - 00:49:17.280, Speaker C: Yeah, I think he's contributing to Kego, the SDK. The Golang SDK for kero. He's a really fun guy, I think. You've been working with him, Lucas.
00:49:17.620 - 00:49:31.960, Speaker A: Yes. Actually it was supposed to be about Kygo. So I'm just going to say this. If you want to contribute to Kaigo, please do. It's really needed. It's a community project, so we need a lot of contribution.
00:49:33.260 - 00:49:36.004, Speaker B: The workshop was supposed to be on Kaido.
00:49:36.132 - 00:49:47.500, Speaker A: Yeah, but I'm not really a goaling developer, so I feel more comfortable working. Yeah, it end up in rebasing for an hour. But that's.
00:49:55.120 - 00:50:13.796, Speaker B: Bego. Yeah, very cool guy, but very opinionated on many topics. It was very crazy. And what were the main challenges? Because I guess you had at the same time to learn about Cairo, but also the EVM. I guess it was new also for.
00:50:13.818 - 00:50:45.676, Speaker C: You, EVM was new. Mean. A lot of people start solidity and they learn it, but they never really dig deep into the EVM. So that was my case. I had done solidity for six months, one year, and luckily I knew how a stack machine worked and like a cpu, because I did some classes, so it helped. But honestly, a lot of the times I would just go on the EVM codes. It's a list of all the upcodes.
00:50:45.676 - 00:50:57.440, Speaker C: Or I would go to Internet and be like, what the frick does that do? What is return data copy or whatever. I mean, so many weird upcodes.
00:50:57.940 - 00:51:02.950, Speaker B: And actually, there is a fun story around how you learned about stack machine, right?
00:51:03.320 - 00:51:04.070, Speaker A: Yeah.
00:51:05.000 - 00:51:07.060, Speaker B: You want to share? Yeah, sure.
00:51:07.210 - 00:51:48.644, Speaker C: I don't know if you guys know Uri and Eli, the CEO and president of Starquare, so they're very fun, and I think they did their studies in Jerusalem, and basically by random, by the providence, I don't know. I used to do late night classes to learn hardware, and it was a free course that I advise everyone to do on coursera. It's free, and it's called from Nan to Tetris. And it's very cool. And yeah, it's taught by Noam Nissan. And I did it like six months ago, and then I learned that Noam works at. So I guess it was fate that brought me here.
00:51:48.682 - 00:52:07.210, Speaker B: Guys, you should check on Wikipedia or something like that. You will learn a lot about Noan. Very smart guy, very cool teacher. Very cool. Yeah. And you were familiar with Python, right?
00:52:08.380 - 00:52:12.600, Speaker C: Not really. I was not familiar with Python. I was not familiar with Kroll.
00:52:13.120 - 00:52:14.732, Speaker B: Yeah, not really.
00:52:14.866 - 00:52:17.356, Speaker A: But you watched some videos for Python? No.
00:52:17.458 - 00:52:18.110, Speaker C: What?
00:52:18.800 - 00:52:21.790, Speaker A: You watched some videos to learn Python? No.
00:52:22.480 - 00:52:28.530, Speaker C: Yes, I did. I was in tutorial hell, and then I got out.
00:52:29.700 - 00:52:33.200, Speaker A: And now here's teacher paradise.
00:52:33.620 - 00:52:41.350, Speaker B: Yeah, let's not talk too much about Python, because otherwise I will start to be not kind.
00:52:44.360 - 00:53:03.610, Speaker A: Anyway, Python will disappear slowly in the starknet ecosystem, because right now everything is being re implemented in rust. So we have good performances. The VM first, then the sequencer will follow really soon and probably a bunch of other stuff.
00:53:04.300 - 00:53:25.970, Speaker B: Okay, let's do some kind of peer programming with Elias and Lucas. Lucas, you wanted to implement the call, so I know you are not prepared for that, Elias. But it will be fun how you actually implement the call upcode. Is that okay for you, Elias? If you.
00:53:26.340 - 00:53:29.692, Speaker C: I have to leave in five minutes though. We have five minutes to change the world.
00:53:29.766 - 00:53:31.156, Speaker B: Five minutes to. Okay, let's go.
00:53:31.178 - 00:53:32.790, Speaker C: Five minutes to write history.
00:53:33.720 - 00:53:38.804, Speaker B: Okay. Can you explain what you have so far, Lucas? And then adias can catch up.
00:53:38.922 - 00:54:10.956, Speaker A: If I can remember. Okay, so for call, let's go on AVN code to know what we need. Basically it's here. And call is somewhere. Okay, so call is here. What we need, we need to pop the amount of gas sent to the subcontext, the address of the contract we're calling the value of east that we're willing to send in this call. The argument offset in the memory, blah, blah.
00:54:10.956 - 00:54:47.688, Speaker A: Well, we need some stuff. And we're popping it from the stack. So we're using the pop in function. We're popping the gas, the address of the contract that we want to call. The value, the argument offsets in the memory, the argument size, the return offsets that we'll write in the memory and the return size. Then we create a blank return data because we need it in the context. The guys remaining child stack.
00:54:47.688 - 00:55:25.720, Speaker A: So new empty stack, new memory. Then we compute the memory expansion for the arguments that we're popping. Because if you're trying to access an unallocated memory cell, you'll need to create it to zero. So we're doing that here. The call data. We're getting the call data and then we're mapping the EVM address to the starknet address to be able to call for the code. And we're creating the child execution context.
00:55:25.720 - 00:56:07.270, Speaker A: So we have the nested call depth so we know in how many calls we're in. So for example, if contract a calls contract b calls contract c, we know that we're like in a third level. And it will be useful when we finish the call. And that we get to the previous execution context. So what we will do is basically run the execution context recursively with the run function. And once it finished, we get back to the parent execution context. And again and again.
00:56:07.270 - 00:56:12.822, Speaker A: Does it look fine for you?
00:56:12.956 - 00:56:14.120, Speaker C: Yeah, got you.
00:56:15.690 - 00:56:16.600, Speaker A: All right.
00:56:17.210 - 00:56:42.160, Speaker B: I think we don't even need to call anything recursively there. It will be handled by subsequent call of codes. In the cold contract, what we need to do is to handle the return. This is when we do some return that we need to update the call depths and handle the return data. I think that's fine. We don't even need to call recursively. Anything there?
00:56:42.610 - 00:56:50.446, Speaker A: Well, the run function will be called recursively. And if we have another subcontext, then we'll run into this function.
00:56:50.548 - 00:56:51.520, Speaker B: Yeah, exactly.
00:56:52.550 - 00:57:03.190, Speaker A: I see what you're saying. Yeah. So that's your key character we chose. Do you think it's the right one, Elias?
00:57:07.930 - 00:57:18.220, Speaker C: Yeah, because I had five in my mind, so that's my number one. Of course. No, I think it's pretty cool.
00:57:22.270 - 00:57:28.510, Speaker A: So the implementation is not yet finished. Because we need to handle the return data everywhere.
00:57:28.850 - 00:57:29.598, Speaker C: Okay.
00:57:29.764 - 00:57:42.020, Speaker A: But right now we would need to test it. But I think we're running out of time.
00:57:45.190 - 00:57:49.730, Speaker C: How can you test it right now? Because you declared child context. But you return context.
00:57:50.630 - 00:58:03.110, Speaker A: Yes. No. So this is not finished. Okay, so we need to finish it and then test it. And it's easier to see if our implementation is good if we test it.
00:58:03.260 - 00:58:04.354, Speaker C: Yeah, definitely.
00:58:04.492 - 00:58:18.990, Speaker A: But this could be an issue. If someone here wants to do it, you can say it and we'll open an issue. Otherwise we'll do it ourselves. Your choosing.
00:58:19.810 - 00:58:28.030, Speaker B: Yeah. Might not be the best one to jump in as a first issue. Because it is quite complex.
00:58:29.250 - 00:58:43.540, Speaker C: But it could be fun if we open up pair programming sessions. By the way, we should. Maybe, because it'd be very fun. And we could even stream it or something where Lucas would take on someone for an hour. And maybe that person can.
00:58:44.790 - 00:58:46.786, Speaker B: Yeah, we can try with Danilo.
00:58:46.898 - 00:58:48.310, Speaker C: Yeah, Danilo.
00:58:51.530 - 00:58:55.820, Speaker B: I couldn't even do it. That would be super cool, actually.
00:58:56.190 - 00:58:59.260, Speaker C: Then that way we have to explain out loud the code.
00:58:59.950 - 00:59:26.450, Speaker B: And would you be willing to. We were thinking about doing some packer specific community call. Maybe biweekly. Would you be willing to animate some of them? And maybe to onboard contributors instead of doing only one on one? For example, if you have ten people on the same live stream, it's easier for you to explain them how to jumping, stuff like that. I don't know, just random idea.
00:59:26.520 - 00:59:38.150, Speaker C: But it could be fun. Yeah, sure. Could be fun. The live coding would be fun. And definitely streaming. It would be even funnier.
00:59:40.090 - 00:59:46.230, Speaker B: Awesome. Very cool. Can we take some questions from the audience?
00:59:46.390 - 00:59:47.100, Speaker A: Yes.
00:59:48.750 - 00:59:49.850, Speaker B: Okay, bye.
00:59:50.430 - 00:59:51.660, Speaker A: Thanks for coming.
00:59:52.350 - 00:59:59.980, Speaker C: Thanks for having me. That was very random. That was fun. Hope to be back soon. Later.
01:00:02.990 - 01:00:05.020, Speaker B: When do you finish the.
01:00:05.890 - 01:00:42.006, Speaker A: We finished now, but we can take some questions. Okay, so the question is, where is the output condition for the recursive function when we match? Basically the recursive function is run. Which is somewhere. Which is somewhere. Library should be there. Where is it? Here. And you see, if stopped equals equal.
01:00:42.006 - 01:00:56.298, Speaker A: True. Then we return like we stop. That's the end condition. Daniel, I have many questions. Ask them, we'll be glad.
01:00:56.314 - 01:00:57.422, Speaker B: Daniel is here.
01:00:57.556 - 01:01:00.174, Speaker A: Yeah, Daniel is here. Do you want to come tell him to join?
01:01:00.222 - 01:01:26.330, Speaker B: Yeah, actually I was just pinging him on telegram to say him to jumping. Okay, jump, my friend. Let me know in English. He's going can have another mean. Sorry. He's jumping.
01:01:28.190 - 01:01:32.730, Speaker A: You're a kid. Now that it's recorded, it's not just live stream.
01:01:33.550 - 01:01:44.720, Speaker B: Yeah, I forgot. Okay. Yeah. You don't do any cut or any editing before publishing it.
01:01:45.330 - 01:01:46.990, Speaker A: I personally don't.
01:01:47.330 - 01:01:49.322, Speaker B: Okay, you put it as is okay?
01:01:49.396 - 01:01:53.954, Speaker A: Yeah, I think just like the replay of the stream so that everyone can see.
01:01:54.152 - 01:02:03.000, Speaker B: Nice. I will be flagged as a kid. What was the question about recursive function?
01:02:03.770 - 01:02:08.200, Speaker A: Where is the output condition for the recursive function?
01:02:08.810 - 01:02:12.246, Speaker B: Okay, so you explained that it is not a direct recursive function.
01:02:12.348 - 01:02:35.838, Speaker A: Yeah, it's the run function that's recursive and that checks if we reached. If we reached. Actually this one does not. Yeah, if we reach this upcode, which is stopped. Which is stopped. Also we didn't mention it, but we have an ERC 20 that works.
01:02:36.004 - 01:02:41.874, Speaker B: Oh, Abba, Danilo is the best person to explain that. Hey, Danilo, glad to see you.
01:02:41.912 - 01:02:44.340, Speaker D: Hello, good to see you.
01:02:47.830 - 01:03:06.200, Speaker B: Yeah. So Danilo is one of the main active contributors from the community. But Lucas was mentioning that we achieved the grid to milestone. And you are the best to explain it, because you actually did it during it San Francisco. So maybe you can explain what you did during.
01:03:11.370 - 01:03:47.862, Speaker D: So on it list bond. We worked on deploying a simple contract, which we wrote ourselves and then for it San Francisco. We thought about why not now try to deploy a solidity compiled contract with all the init code and the runtime code being separate. And that's what we tried. And basically our approach was put it to test whenever it breaks, try to fix until it runs all the way. And it worked. And yeah, overall it was an amazing experience.
01:03:47.862 - 01:04:29.140, Speaker D: So we were able to deploy a fully functional ERC 20. There are some improvements, a lot of improvements to be made. But I just wanted to thank Lucas and Abdel, as basically we are building on top of what was structured by then. So just by looking at it, I got to learn a lot. And definitely this wouldn't be possible without last week's like everyone coding together, sharing knowledge. We asking a lot of questions to you guys. Thanks so much.
01:04:29.590 - 01:04:54.726, Speaker B: No, it's definitely amazing to see the vibes of the community and how I was saying that before, but during the hacker house in Lisbon, it was like crazy. We were all hacking together. It was like 04:00 a.m. At some point we were all exhausted and it was so fun. And I enjoyed a lot this time with you guys. It was crazy. And this is something very special that we see on Starknet.
01:04:54.726 - 01:05:28.150, Speaker B: There is a strong community and the south that is emerging and this is very cool. I always say that, but it reminds me of a quote from Vitalik which is saying that a billion dollar capital project cannot compete with a project with a Sao. And I think we have a Sao on Starknet. And this is amazing. So glad to see that. Did you enjoy the hacker house, Lisbon? How was it basically? How was the vibe?
01:05:28.970 - 01:06:08.866, Speaker D: Yes, it was an amazing opportunity to be around so many amazing developers. Like you mentioned, I think the Starquare community, all of them are big brains. So everyone you talk about, they're doing something like, oh, that's amazing. And basically staying a whole week with all these amazing people. I think you cannot find it anywhere else. And I think it's not that, it's just a lot of smart people. It's also like a very united community, maybe because we don't have more than 1000 people.
01:06:08.866 - 01:06:27.260, Speaker D: And because of that I think the interaction and the connection level is a lot deeper than many of the other events. So I was very inspired and very excited after the durian and now after the it Lisbon hacker House. Looking forward for more.
01:06:27.790 - 01:07:39.280, Speaker B: Yeah, very cool. And I think like Phil from Rick said it well during the TC event he was basically talking about the history of Starknet and he was insisting on the fact that this is the history of people on Starknet and the fact that Starknet is strange and we should keep it strange. And I like it actually, this keep starknet strange meme is very cool and very powerful because I think it was part of the success of this community and the fact that they are all united because it was so painful at the beginning to do some cairo, they were united under the same pain and it was crazy. And also the fact that they had some new primitives that don't exist anywhere else and they just had new weapons to play with. That means to me that they were used to think out of the box. And this is cool because in terms of innovation, we don't have just random copy pasta of what we have on Ethereum or other project. And I love that.
01:07:39.280 - 01:07:57.240, Speaker B: In terms of the next step for kakarot, when do you think we can have a full work in type three EVM with all upcodes rosly, if you had to guess?
01:07:59.850 - 01:08:40.180, Speaker D: My guess, yeah, the fully working ones, I think you guys are taking the challenge on the remaining harder ones, which I think is the color. And then there would be the create and create two, which I think we have the similar issue of having to recursive on the loop. Once we have that, I think it's possible to start testing out more complex contracts. And I think in a timeline, I would say maybe in.
01:08:42.010 - 01:08:42.886, Speaker B: Two weeks to.
01:08:42.908 - 01:09:51.420, Speaker D: Four, we would definitely be able to, I think, run and test a lot of more complex contracts. So having a fully version one optimized and user ready, if I think things keeps going on, the vibe and the path that we're going, I would guess like in two months, it would be a good time to maybe even earlier, I don't know. But I think it will depend on the optimization. I think the optimization will be the most challenging part to make it very user ready. The parts of the opcodes and running contracts. I think you guys already have done so much that most of basic contracts should be able to run normally on top of the Kakara deviant in two weeks.
01:09:52.270 - 01:09:54.220, Speaker B: Okay, very cool.
01:09:55.390 - 01:10:04.990, Speaker A: More pessimistic than that, because there are always problems that we can't. That might lead to some big delay.
01:10:05.410 - 01:10:38.250, Speaker B: No, but I was talking about naive implementation, so not optimized. And also for nominal cases, not edge cases like handling proxy contract or whatnot, like just nominal cases. But for example, we are close to that. I mean, with ERC 20 we start to like for example, the next step can be NFT. And then the kind of the ultimate step for me is uniswap v two. If you can deploy two ERC 20 and kkarot, and then do a swap. That's crazy.
01:10:38.250 - 01:11:12.760, Speaker B: And then we can start to think about optimization, all this kind of stuff. But yeah, it will be a long way to go for the optimization around. I guess we will have some surprises in terms of efficiency. Obviously we will have to imagine a lot of optimization tricks, but it will be funny and exciting, I think, and challenging. But yeah, we were talking about the packing, maybe Danilo, you want to explain the problem with.
01:11:14.810 - 01:12:06.790, Speaker D: So I think Prashan is here also. And Prashan, I think he definitely could give us a hand as he's a chip designer. So the issue today is that we have an array of felts, and each element of the array is one byte. So it's two hexadecimal values. And basically we are underutilizing the whole felt. The whole felt can have up to 31 bytes, but we are just storing one byte. And because of this, we are having to store or initiate 31 times more memory compared to the steps that we would be able to if we could have 31 bytes in one felt.
01:12:06.790 - 01:12:49.540, Speaker D: And the trade off, I think, would be how efficient, because there is a lot of calculations and paddings and filtering out specific bytes and how these functions that Abdel mentioned, that if it's developed, how efficient they are compared to having more bytes or having to have more memory slots. My guess is that 31 times less memory slots will outwork some inefficiency in processing. But that's just a guess.
01:12:51.510 - 01:13:05.960, Speaker B: Okay, Lucas, what do you think about that? What is your guess in terms of the trade off between saving a lot of memory space? We are still adding some computation. What is your gut feeling about that?
01:13:06.810 - 01:13:39.826, Speaker A: It would definitely reduce the code of the cost of storing the bytecode on chain, but for the number of steps, I'm not sure it would improve that many, because we would need to use the bitwise built in. And I'm not sure how more efficient it is than just copying everything, like using just a felt. I don't know. I think that. Yeah, I don't know. Okay.
01:13:39.928 - 01:14:27.170, Speaker B: It will be interesting too. This is definitely something like to experiment, and it can be done separately. You don't have to have this EVM logic to benchmark this. So if anyone wants to test this from the community, feel free to jump in, and I guess this will be useful. Luca, also, regarding the problem we had with the constructor contract, there is no way to do some kind of mutual directly from the smart contract, because the problem Danilo had was to be able to deploy the starknet contract with the EDM bytecode and then directly being able to run the constructor function to init.
01:14:28.150 - 01:14:29.860, Speaker A: Well, you can do that.
01:14:30.950 - 01:14:32.282, Speaker B: You can or you can't.
01:14:32.366 - 01:14:35.126, Speaker A: You can how you deploy it and.
01:14:35.148 - 01:14:39.714, Speaker B: Then you call the constructor in the same transaction.
01:14:39.842 - 01:14:40.520, Speaker A: Yeah.
01:14:41.610 - 01:14:42.360, Speaker B: Okay.
01:14:45.930 - 01:15:10.786, Speaker D: So the issue I had was when I try to deploy and change the state of that contract on the same transaction, it was basically saying that contract was not found because it wasn't deployed yet. So my guess would be that if we could run the EVM bytecode on.
01:15:10.808 - 01:15:11.380, Speaker B: The.
01:15:13.430 - 01:15:43.654, Speaker D: Starknet constructor, then that could be a solution. But yeah, I did have this problem of when trying to at least how we implemented s store today, which is a call on the storage of that contract. It would just give this error that the contract doesn't exist yet when trying to call in the same transaction. But I could be wrong. And there could be more other solutions.
01:15:43.702 - 01:15:51.450, Speaker B: Do you think it should be possible, Luca? Like for example, KCRo deploy a contract and then it works?
01:15:51.600 - 01:15:52.938, Speaker A: Yeah, it should be.
01:15:53.104 - 01:15:54.006, Speaker B: It should be.
01:15:54.128 - 01:15:57.680, Speaker A: I would need to investigate if you're saying that it does not work.
01:15:58.290 - 01:16:17.190, Speaker B: Yeah, I think it's worth exploring because it has some impact on the architecture of the moment. And we need to do some tricky stuff that if we can remove those, it will be better. Yeah. Okay. Amazing. Are there some questions in the chat?
01:16:18.170 - 01:16:21.640, Speaker A: No, I think we can wrap this up.
01:16:22.490 - 01:16:30.250, Speaker B: Okay. Thanks, Danilo, for joining us. Yes, thanks again for your contribution. Yeah, see you soon.
01:16:30.400 - 01:16:30.874, Speaker D: Thank you.
01:16:30.912 - 01:16:32.522, Speaker A: Bye, guys.
01:16:32.576 - 01:16:35.930, Speaker B: Bye. Yeah, thanks. Bye bye.
01:16:37.790 - 01:17:04.700, Speaker A: Yeah, so we're going to wrap this up. Thanks for coming. Don't hesitate to reach out if you have some problems. If you want to learn Cairo, you can reach us in the discord or in telegram. Yeah, basically you feel free and keep learning and supporting. Bye bye. Yeah.
