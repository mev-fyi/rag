00:00:03.770 - 00:00:09.470, Speaker A: I share the link on discord as well, just in case there's confusion about how to join the session.
00:00:10.530 - 00:00:14.558, Speaker B: Perfect. Okay.
00:00:14.644 - 00:00:20.560, Speaker A: We are now live on YouTube, but it's an unlisted video. I will turn it into a public after we finish.
00:00:28.270 - 00:00:29.020, Speaker B: It.
00:00:30.830 - 00:00:39.210, Speaker A: Can someone just type on the chat just to make sure that it's working? Say the chat is disabled. I forgot what I did last time to enable it.
00:00:39.360 - 00:01:13.300, Speaker B: What did I do? It.
00:01:17.190 - 00:01:23.534, Speaker A: I also enabled a live transcript, as last time people suggested we should live transcript.
00:01:23.582 - 00:01:24.900, Speaker C: So what does that do?
00:01:26.470 - 00:01:31.462, Speaker A: It just automatically pulls a caption of whatever you're saying on the screen.
00:01:31.596 - 00:01:32.520, Speaker B: Oh, cool.
00:01:33.130 - 00:01:35.880, Speaker C: It's like accessibility features kind of. Yeah.
00:01:44.560 - 00:01:44.924, Speaker B: Cool.
00:01:44.962 - 00:01:47.790, Speaker C: So, hey, everybody, welcome back.
00:01:48.640 - 00:01:54.152, Speaker B: We're just going to let people kind of join.
00:01:54.216 - 00:01:57.250, Speaker C: We're going to give it about minute or two.
00:01:59.860 - 00:02:10.192, Speaker A: Sorry, I just mentioned that the chat now should be enabled, so give it a try to see if you can use the chat on the zoom call. All right, yeah, I can see the first comments.
00:02:10.256 - 00:02:10.628, Speaker D: Cool.
00:02:10.714 - 00:02:12.150, Speaker A: Chat is enabled now.
00:02:16.900 - 00:02:17.264, Speaker B: Cool.
00:02:17.302 - 00:02:30.230, Speaker C: Thanks for joining, everybody. Good to have you guys back. Like David mentioned, we got accessibility features turned on, so you should be able to see the transcript today. Q and a looks good.
00:02:30.600 - 00:02:31.904, Speaker B: Chat is disabled.
00:02:31.952 - 00:02:36.010, Speaker C: Okay. Chat is now.
00:02:36.620 - 00:02:37.816, Speaker A: It's enabled now.
00:02:37.918 - 00:02:38.570, Speaker B: Okay.
00:02:42.770 - 00:03:22.310, Speaker C: All right, awesome. We're going to wait for just a couple of minutes here for people to filter in. I hope everyone enjoyed Stark 101 on the off week. We're going to start with some questions on Stark 101, if you guys have them. So we can just kind of go over them and then jump into Cairo today. So let's give it about minute or two and then we can get started. One thing I'm kind of bummed, I think we're starting right during the Twitter spaces for the cockarat Zke evM.
00:03:22.310 - 00:03:46.450, Speaker C: That was written by some of the starware team members, but it's recorded, so I'll send that out in the chat here. Twitter space field trip. Yeah, it's like when the teacher wheels out the tv right at the start of the session.
00:03:47.430 - 00:03:49.700, Speaker B: You're like, yes, today is going to be easy.
00:03:58.720 - 00:04:10.240, Speaker C: Okay, I'll just get everything set up on my end. Can you guys just verify that you can see this presentation?
00:04:10.740 - 00:04:11.730, Speaker B: 1 second.
00:04:16.680 - 00:04:20.324, Speaker C: Are you able to see that or is that a black screen? It's coming through as a black screen for me.
00:04:20.522 - 00:04:22.196, Speaker A: It's black as well for me.
00:04:22.298 - 00:04:22.950, Speaker B: Okay.
00:04:34.070 - 00:05:52.920, Speaker C: Jay, good to have you. All right, so while I'm getting this set up, really, I just want to open by asking if anyone has any questions on Stark 101. If anyone has any kind of lingering things they want to go over in the session here today, so feel free to ping questions out in chat. We got a bunch of stark whizzes, stark masters. All right, for some reason my slideshow is not showing up. David, for the slideshow section, do you just want to show camp two and I'll tell you when to advance because for some reason it's not letting me do it.
00:05:53.610 - 00:05:59.110, Speaker A: I changed some settings to allow you to, let's see, try again.
00:05:59.180 - 00:06:00.200, Speaker D: So you can.
00:06:07.710 - 00:06:09.420, Speaker A: You'Re not able to share the screen?
00:06:10.350 - 00:06:16.460, Speaker C: No, it actually looks like it's a problem with my desktop. Every time I go full screen.
00:06:18.210 - 00:06:18.698, Speaker B: It'S.
00:06:18.714 - 00:06:20.910, Speaker C: Going to a black screen on the slideshow.
00:06:21.890 - 00:06:26.394, Speaker A: Oh, you know that happened to me. I had to disable some of the wallets on my browser.
00:06:26.522 - 00:06:28.254, Speaker C: Oh really? Yeah.
00:06:28.372 - 00:06:38.226, Speaker A: Using Google Slide, right? Yeah, it happened to me. Especially with Argent X. I don't know what's the reason but I disabled the extension and now Google Slide worked.
00:06:38.408 - 00:06:53.240, Speaker C: Okay, well I think what we're going to do is not debug that right now. So it's going to be a little less aesthetically pleasing. But I'm just going to do not full screen. So you guys can just see the slideshow, not full screen.
00:07:00.750 - 00:07:11.290, Speaker B: Sorry guys, it's still weirding out on me. One section.
00:07:19.550 - 00:07:23.370, Speaker C: All right, can you at least see this presentation deck?
00:07:23.710 - 00:07:33.854, Speaker B: Yeah, let me pop up the chat as well. Okay, cool.
00:07:33.892 - 00:08:09.574, Speaker C: So yeah, chat is open. If I am kind of continuing to roll, make sure to keep stopping me if you have questions. Again, I think the flow is a little bit better if we can kind of halt in the middle of these sessions to go over questions so that we don't have a lot of them pile up at the end. So yeah, feel free to reach out and then discord. Just a reminder for discord for everybody. David will ping out the discord link if anyone missed it last time, I think we had a couple stragglers. Our channel is base camp, cohort one and then contacts for today is going to be me, David, and Omar.
00:08:09.574 - 00:08:18.030, Speaker C: Omar will be, I think he's on right now and he's going to join back on to start talking a little bit about Cairo and Cairo fundamentals.
00:08:19.250 - 00:08:23.760, Speaker B: Setup. One sec.
00:08:36.550 - 00:08:57.900, Speaker C: You'll just need the basic setup. Everyone should have it. It's in the original readme for Basecamp repo and also we talked about it in last time session. It's just chiroling.org quick start here. We did just release an upgraded version of the platform, the 00:10 one, a couple release notes there if you want to check them out. Nothing too major.
00:08:57.900 - 00:09:34.998, Speaker C: So you should be able to get through all of today's examples with the basic setup, as long as you've upgraded your code syntax for Cairo to v 00:100 ultimate setup so this is a blog post. I'll ping it out in the chat. We will need this for next week's session. So man meet said the invite to the discord doesn't seem to work. David, if you wouldn't mind adding him to the discord. Thanks for joining man Meet Ultimate I.
00:09:35.004 - 00:09:59.006, Speaker A: Think the invitations were, invitations were paused for a while. We had a spike in people trying to join, I think because of the Aptos airdrop, and I think for security that's been like a slowdown. Now, if you're in the discord server and don't have access to the channel, that's a different thing. You can just drop your discord handle on the chat and I'll just add you to the channel that we have.
00:09:59.028 - 00:10:03.874, Speaker B: For the base camp. Cool.
00:10:03.912 - 00:10:13.350, Speaker C: And then he added his discord at the end there, just so you know. And then it looks like Prashant needs to be added as well. Prashant, can you add your discord handle to the chat?
00:10:14.570 - 00:10:15.320, Speaker B: Cool.
00:10:16.330 - 00:10:51.380, Speaker C: So ultimate setup ultimate setup just has the next camp. Next Thursday we're going to be going over Starknet as a platform, has a bunch of different postman collections and some kind of more in depth dev tooling. So once we kind of get into what a gateway is, what the API gateway is, what a full node looks like, and how to interact with them, it's a little bit easier for everyone. So if you can get those Postman collections up by next Thursday, that'd be great. And then if you have any questions, reach out to me over Discord or telegram and we can get you help set up.
00:10:53.910 - 00:10:54.274, Speaker B: Yes.
00:10:54.312 - 00:11:14.300, Speaker C: So can I rewrite the links here? Yep, I sent the medium article out for ultimate starknet dev environment, and let me just. That's kind of a lengthy blog post. I'll also just send out the Postman collection. If you are familiar with Postman, you'll just add it and fork the collections. If you're not familiar with Postman, you might want to go through.
00:11:16.670 - 00:11:17.146, Speaker B: And read.
00:11:17.168 - 00:11:45.870, Speaker C: That blog post just to get familiarized. It just is basically a boilerplate and a pre populated template for all of the API requests, whether they're going over JSON RPC or over HTTP, and we'll get into that next week. So once just got it open, here is the Postman collection. And you can also just search for Starknet.edu in Postman.
00:11:45.950 - 00:11:46.580, Speaker B: Cool.
00:11:47.750 - 00:12:18.686, Speaker C: Graduate. Just a reminder on how to graduate. So none of the hard requirements have been handed out yet for we just had Starknet 101, which doesn't include any ERC 20 tokens or any wallets today. The tutorial that I'm going to assign after today is the first one that does include that. So that's going to be Starknet Cairo 101. Getting familiar with the syntax of Cairo and then some more of the Starknet tutorials. So messaging, bridge and accounts here.
00:12:18.686 - 00:12:50.322, Speaker C: We'll go into those a little bit more next Thursday. And then just a reminder, everyone's going to need to either have a pr to base camp to make base camp better. There's a lot of portions of basecamp that say under construction. Omar from our team actually just had a really good pr. If you guys want to check the most recent pr that's been merged into base camp, expanding on basically all of camp two's readme. So check out his pr and if you guys can do something like that, that would be awesome. And then a presentation.
00:12:50.322 - 00:12:52.550, Speaker C: So the last two sessions.
00:12:54.330 - 00:12:54.806, Speaker B: If we.
00:12:54.828 - 00:13:29.300, Speaker C: Have enough time, we do have quite a bit of people in this session, but yeah, we would like to see kind of quick presentations of what you guys have come up with. The whole point is to expand on your developer creativity and see what you guys come up with. So we'd love to see what that is. We're going to recap the last session on Starks. This curriculum is all meant to build on itself. So we'll recap last session on Starks and stark math as a high level analogy. This is Ellie Benzeson's analogy, and it works well for me.
00:13:29.300 - 00:15:12.280, Speaker C: It's that if there's a drill sergeant that walks into a room, and that drill sergeant needs to check if that room is either clean or dirty, he can either go through and wipe his finger on every single surface in the room, or he can kind of do a smarter thing, which is to take a leaf blower and blow all the air in the room together and then take small samples of each part of the room and get with it with a high degree of certainty an answer to whether or not that barracks that he's investigating is clean or dirty. And then if you think back on our last stark math session and including Stark 101, this should make a little bit more sense to you because as we're going through passing this computation, this statement of computational integrity, through these arithmetic constraints, this arithmetic constraint system. We're starting to talk about this computation in the world of polynomials. We take that polynomial, and we add a blow up factor. We add a larger resolution size to it, and we evaluate that polynomial against the blow up factor, this polynomial, with a large resolution. And then if we take these measurements, if that drill instructor tests the air at certain points and he notices that it is indeed polluted, we feel like that's analogous to saying that we don't agree, the verifier and the prover don't agree that certain parts in that trace agree with the polynomial that we've created. And we can say with a very high degree of certainty, something that's bordering on, like, a hash collision in Shaw 256.
00:15:12.280 - 00:16:16.766, Speaker C: That, yes, indeed, the trace that was provided from the prover to the verifier does not look correct, or that it does look correct. And in that way, even an untrustworthy or a dishonest prover cannot trick a verifier. And so that analogy of the leaf blower in the room should make a little more sense. We're not checking every surface. The verifier is actually checking on some set of randomized parts of that polynomial that we've created through this polynomial I op and arithmetic constraint system. And then how do we get succinctness? How do we get this non interactive part that we need to have for this architecture of a sharp proving to a verifier that's on a solidity contract on l one? We get it through this cryptographic compilation. We have the fry protocol and the deep fry protocol, which you guys should have some understanding with from Stark 101.
00:16:16.766 - 00:16:33.600, Speaker C: And it all culminates in these commitments. And we don't have to open backup any of this Zk math. And this polynomial backup for a multi round operation between the verifier and.
00:16:36.290 - 00:16:36.606, Speaker B: The.
00:16:36.628 - 00:16:52.870, Speaker C: Prover can basically just say, with some degree of certainty and a fiat Shamir transform that I commit to this, and I could not have cheated on this. And now we have this non interactive relationship between the prover and the verifier.
00:16:53.370 - 00:16:54.118, Speaker B: Cool.
00:16:54.284 - 00:17:17.870, Speaker C: So that's high level, super high level starks. But, yeah, from the homework, you guys should be a little more familiar with Starks. Feel free to ask questions. So today, we're going to be tying that Stark math, that moon math. We're going to be tying that to Cairo. You guys have probably heard of Cairo. I hope some of you guys have written Cairo.
00:17:17.870 - 00:17:45.474, Speaker C: We'll get into how Cairo ties the Starks, and then we'll kind of get into the meat and potatoes of. What does the syntax of Cairo look like? Why does it look that way? What makes Cairo special? Okay, so looking back at this blowout, we have this arithmetization, or air, stands for algebraic intermediate representation.
00:17:45.522 - 00:17:46.120, Speaker B: Sorry.
00:17:48.890 - 00:18:42.054, Speaker C: And that's the meat of the Stark math prior to kind of like the fry commitments and fry queries. And if you think back to those examples, and I think I will talk a bit about it, but what we tried to prove in those examples was this sequence. I believe it was the Fibonacci squared sequence. So in those examples, we're making an algebraic intermediate representation and error to prove a single computation, a single computation. And that looks like if you were to build a circuit. So if you were to build a circuit with circum, let's say it looks similar to. It's not necessarily the exact same thing, but you're proving a specific computation.
00:18:42.054 - 00:19:37.290, Speaker C: And that specific computation is this next number in the sequence squared plus or. No, this sequence, the Fibonacci squared sequence. But what if we want to prove anything? What if we want to prove arbitrary logic? What if we want to prove the execution of a Turing machine? A Turing machine, just meaning that we can express arbitrary logic. Well, that's one of the things that gave Ethereum layer one this mass adoption is that people can write these smart contracts can write these smart contracts and be expressive with their business logic on a blockchain. On a verifiable blockchain. So that's the goal. The goal is to basically have some set of algebraic intermediate representations that can prove a Turing machine.
00:19:37.290 - 00:20:06.290, Speaker C: So, let me see if I missed anything. So, stark proof based system is based on errors. Errors is a list of polynomial constraints operating on a trace of finite field elements. So you guys should have a pretty good understanding of what that means. Now, stark proof verifies there exists a trace that satisfies the constraints, and that's at its base level, at its empiric level. That's what a stark proof does. That's what a verifier verifies, and that's what approver proves.
00:20:06.290 - 00:20:20.614, Speaker C: Prashant says that it's actually an almost saw that just recently. What does rap stand for?
00:20:20.652 - 00:20:21.430, Speaker B: Prashant.
00:20:29.110 - 00:20:59.062, Speaker C: Let me open back up the Cairo white paper. We won't dive too into this. If you are looking for the Cairo white paper, head over to basecamp repository. And again, we work pretty exclusively on the base camp repository. So if you're trying to navigate around and you see randomized error. Okay, camp two. Camp two is going to be all about Cairo again here, if you want to see a roadmap.
00:20:59.062 - 00:21:34.200, Speaker C: Starks, Cairo. Cairo. At the bottom, we have links to all of the sources. So the first one in the sources is the Cairo white paper. So, algebraic intermediate representation and randomized error with preprocessing. I'm not going to get too. This is, I think, a little slightly out of scope, and I don't want to go too down this road.
00:21:34.200 - 00:22:04.530, Speaker C: If we have some time at the end of today, we'll talk about the differences here. So we might come back to. Oh yeah, that's a good point. So, Prashant, just put out a really good blog post about demystifying Cairo white paper, part one. Definitely, go check that out. It even defines a lot of the terms in there. So he just put it in the discord.
00:22:04.530 - 00:22:05.662, Speaker C: Definitely check that out.
00:22:05.716 - 00:22:06.320, Speaker B: Cool.
00:22:09.170 - 00:22:42.014, Speaker C: All right, so that's a recap. We got some administration stuff out of the way. That's a recap of what we did last session. And now we'll start with our map, our handy dandy map. So, the goal of base camp is to get you guys really familiar from ground principles up to what most people see, what 90% of the devs see in the ecosystem, and to have you guys be really competent with everything. So this is a map of where we're going, a map of where we came from. We have clients that interact with the sequencer.
00:22:42.014 - 00:23:19.566, Speaker C: The sequencer right now is just run by Starkware, but eventually there will hopefully be multiple different implementations of the sequencer that sequences transactions submitted by clients. Everything in pink here is infrastructure, everything in blue here is execution. So once we have the sequencers sequenced into a block, we have the execution of the Starknet Os. So Starknet Os is written in Cairo. Cairo is what we'll be digging through today. Smart contracts also written in Cairo, which we'll be digging through today. And then we have the prover.
00:23:19.566 - 00:23:37.450, Speaker C: So what is the prover proving? It's proving starks. Yes, that is true. It is proving starks, but it's proving the execution of the Cairo Vm. So what is the Cairo Vm? How does the Cairo Vm work? What is the syntax we need to do, and how do we interact with the sharp.
00:23:39.230 - 00:23:39.980, Speaker B: Cool.
00:23:40.510 - 00:24:25.130, Speaker C: So, magnifying glass. Magnifying glass. And then, yes, here we have everything written in Cairo on Starknet L, two and sharps. And this is the transaction flow through Starknet. So a lot of the meat and potatoes here on these two parts of the map will really be camp three, where we go into starknet execution and how it interops with ethereum l one. Great, so Cairo, we're going to start the same way. Trung said, can I have the verifier contract address if someone wouldn't mind pinging that out to Trung.
00:24:25.130 - 00:25:06.486, Speaker C: Did you want the girly or the main net trong? I'm sure we can send both. So let's, let's define some terms, same way we did with starks. Cairo. Cairo actually stands for something. So Cairo is cpu air, as in algebraic intermediate representation. Oh, just, it's tacked on there at the end. It's a practically efficient, Turing complete, stark friendly cpu architecture.
00:25:06.486 - 00:26:05.370, Speaker C: That's a mouthful, but we will define some of that. So the problem before Cairo exists, know we are solving for a specified, know whether we're writing some type of stark to prove a Fibonacci squared or a Fibonacci sequence. Now we want to write a single set of polynomials, a single set of polynomial constraints and equations for a statement that executes the program of this architecture and is valid. And when I say this architecture, I mean an architecture that defines a Turing machine. Practical. What is practical? Cairo supports conditional branching, memory function calls and recursion. So we have some elements, including some syntactic sugar of a programming language, something that you can operate at a high level and expresses your logic.
00:26:05.370 - 00:26:49.642, Speaker C: I know we do have a lot of people that kind of have written Cairo. Cairo is an evolving constant. It keeps progressing, it keeps getting slightly easier to write, and it will. All of us right now in this ecosystem are in kind of an early time. So even though sometimes it might feel like the ground is shifting a little bit, I think the long arm of Cairo is basically that it's getting easier to write, more practical, so efficient. The Cairo instruction set was chosen so that the corresponding algebraic intermediate representation will be as efficient as possible. We have concept of built ins, which we'll get into a little bit.
00:26:49.642 - 00:27:24.040, Speaker C: And I think even that medium post that Prashant sent out is basically what that medium post is about, I believe. So we have a concept of built ins. We'll get into it today. So even though the goal of Cairo is that you don't need to write every single instruction for something that you're proving by hand, you don't have to write it out as an error in every single case. We can express all this stuff and it becomes easier. We need it to be efficient. We need the proof sizes to be somewhat small.
00:27:24.040 - 00:28:05.810, Speaker C: And then for operations that are used often, we can even interpret those in raw algebraic intermediate representation. We can improve the performance even more by adding something called a built in turn complete. I think out of the surveys here, most everyone is a software engineer, so turing completeness should be pretty obvious. But it's obvious if you know it and then it's really meta if you don't. But a Turing machine can simulate a Turing machine. It means a lot if you know it. It means a little if you don't, but basically you can implement arbitrary logic.
00:28:08.690 - 00:28:09.440, Speaker B: Cool.
00:28:10.290 - 00:28:48.570, Speaker C: So let's just rephrase it. We defined each term of Cairo. Let's rephrase what the goal of it is. Cairo is a language for writing provable programs. Running a Cairo program produces a trace that can then be sent to a trustless prover, which generates a stark proof for the validity of the statement of computation or computation represented by the Cairo program. The proof can then be verified using a verifier, which may or may not be on chain. In context of this class, in context of basecamp, we're going to be talking about starknet even though we are building from first principles.
00:28:48.570 - 00:28:57.200, Speaker C: So that verifier that we specifically are talking about is on chain. It's written in solidity, and it runs on ethereum layer one.
00:28:58.770 - 00:28:59.518, Speaker B: Cool.
00:28:59.684 - 00:29:15.378, Speaker C: So yeah, we write Cairo so that we can utilize a lot of the benefits that we talked about in last session. We write Cairo so that we can prove computation, so we can prove business logic, and we use starks under the.
00:29:15.384 - 00:29:16.500, Speaker B: Hood to do that.
00:29:18.730 - 00:30:15.350, Speaker C: Okay, so another way to say it, and this is directly from the white paper, but I do think that it's descriptive and it's illustrative of what Cairo's purpose is. It's an algebraic intermediate representation for the Cairo machine. In such a system for which the constraints are satisfiable, if and only if the Cairo machine outputs accept, such an algebraic intermediate representation allows the prover to convince the verifier that the machine accepts. So this should be where your intuition goes in my mind when we talk about Cairo. The prover is basically proving that the state transition of the Cairo machine, or Cairo virtual machine is correct. And it does that via starks in the way that we've defined.
00:30:17.550 - 00:30:18.300, Speaker B: Cool.
00:30:20.430 - 00:30:44.210, Speaker C: So to remind you guys of what a statement of computational integrity is, what a stark is proving, we're proving the initial state of a system. We have a defined program that changes that state, and we have a number of steps and a final state. So the Cairo framework enables one to prove the integrity of arbitrary computation, whereas this was a specific computation.
00:30:48.870 - 00:30:49.620, Speaker B: Okay.
00:30:52.470 - 00:31:40.530, Speaker C: This is going to be a little bit of a summary of the Cairo white paper. I would recommend digging into the Cairo white paper today. I'll give you guys some tools to read the Cairo white paper a little better, or at least a little more developer friendly as opposed to mathematician friendly, but here's kind of some of the high level takeaways. So, cpu error. The stark proof system is based on errors improve a list of polynomial constraints that operate on a trace. An error of a Cairo CPU consists of 30 or 40 constraints. So we're saying that the goal of Cairo is to come up with some subset of constraints.
00:31:40.530 - 00:31:43.570, Speaker C: I just got a scary noise.
00:31:45.370 - 00:31:49.254, Speaker B: Okay, looks like everything's good. Yeah.
00:31:49.292 - 00:32:36.520, Speaker C: So the goal of Cairo is to come up with some subset of constraints that enable this CPU architecture or Turing machine that actually exists in about 30 or 40 constraints. Again, read the white paper if you want to dig into that a little bit more. But you should have some idea of what that means now. So that single set of constraints can run any program, even though the verifier is deployed once. So in the starks that we've talked about before, you might want a specific verifier to verify them. This verifier can verify any subset of programs that have been run and operated, run and execute, through the sharp bootloader architecture. I put this here because it's interesting.
00:32:36.520 - 00:33:08.270, Speaker C: Prashant even talks about it. There's a version of Cairo outside the context of the verifier living on Ethereum, layer one and starknet. That is really cool. Cairo by itself is just built to write provable programs. So you can kind of take that and spin it out however you want. But you can basically prove the proper execution of a boot flow. You can prove the proper execution of like an IoT device.
00:33:08.270 - 00:33:47.130, Speaker C: Your brain can kind of spin out on some of the cool use cases of Cairo. So if you do go through and read the Cairo white paper, which I would suggest you do, check out the bootloader architecture. It's really interesting. Incrementally verifiable computation, aka recursive proofs. We're not going to get into that today. It's something that enables layer three. Recursive proofs enable layer three, and it's this concept that I think we basically are the first ones to come through and suggest, which is fractal scaling.
00:33:47.130 - 00:34:50.366, Speaker C: But if you do have some subset of stark math that can prove arbitrary computation, the theory goes, well, why can't that arbitrary computation be a stark proof? And now you start operating on these higher levels that you kind of drop down the rabbit hole, and you can even kind of mix and match these ideas and make your architecture run a little more efficient. So instead of creating one proof that verifies the execution of Starknet ecosystem and various different Starkx ecosystems, we can actually separate those and verify them within each other. And now we can move Starkx as a system that operates on top of maybe even Starknet L two. That kind of requires you guys to have a little more understanding of Starknet architecture. So that's why it's a little out.
00:34:50.388 - 00:34:51.198, Speaker B: Of scope for today.
00:34:51.284 - 00:34:56.274, Speaker C: But needless to say, as Prashant said, l three is really cool.
00:34:56.312 - 00:35:00.020, Speaker B: Recursive proofs. Really cool. Cool.
00:35:00.390 - 00:35:52.814, Speaker C: Another mental model to help you kind of get through what Cairo is, especially if you're coming from a web two world. We have the concept of just a CPU, just silicone, basically. A cpu like, you know and love. Since Cairo is CPU air, how do they differ from each other? So, when you're looking at a modern cpu architecture, you're probably looking at a 62 bit integer depth. For us, we're talking about finite fields. You guys should be really aware about finite fields now. And instead of the traditional arithmetic operations that you run on top of a CPU, we're now talking about the arithmetic operations that we talked about in last session.
00:35:52.814 - 00:36:27.646, Speaker C: So, all modulo the prime and all over the finite field. The instruction set on a regular cpu is run against physical transistors, whereas we're running the instruction set in an algebraic intermediate representation. Real transistors can handle new inputs over time. Airs can handle only one instruction in the same virtual transistor. We'll get into that today. This plays into why the memory model of Cairo looks the way it does. Prashant said.
00:36:27.646 - 00:37:00.554, Speaker C: Hi, Ben. Will it be possible for you to give some insights into who is our building asics for Starknet ecosystem? It is a good question. It's one that I don't know the answer to. Since our. Since the prover. There's a couple implementations of the prover out there. There's Eth stark, which Ellie Ben Sassan got a grant from the Ethereum foundation to work on.
00:37:00.554 - 00:37:32.980, Speaker C: Completely open source. It's written in c, it's out there. And then we are internally going back and forth as far as what the licensing will look like, our. Some of our tooling, like the prover that we use in production. I think that questions like that will become more clear once it's kind of like a chicken and egg situation. Once the prover licensing gets all ironed out, we'll start to see who's going to build asics for starknet and where that goes. I hope that answers that question.
00:37:32.980 - 00:38:41.302, Speaker C: Okay, so they both have, talking about a silicon cpu and a Cairo CPU. They both have built in optimization. So there's literal hardware accelerations in a cpu, in a board for Shaw, or various different operations that are used. Quite a a similar, we have a similar concept for built in optimizations that instead of running on top of this generalized instruction set that is Cairo, they just run on top of raw errors that have been written specifically to do that task and that task alone. And again, this is why we structure basecamp like this, because you guys should now understand why that is faster. You'll understand a little bit more once we get into Cairo. But as you can imagine, when we're implementing a generalized execution environment, it's going to have overhead that doesn't necessarily apply to each operation.
00:38:41.302 - 00:39:27.034, Speaker C: Whereas if we wrote that error, if instead of having the Fibonacci squared sequence, we say we want this error to be specifically for range checking parameters, or for. I use hashing a lot, or I guess Peterson for us, but I use hashing a lot just because it's a computationally heavy task. So we can write out the error specifically for that and implement specifically. Okay, so, Cairo defines a deterministic Cairo machine or CPU. It operates on three registers, which we'll get into today and we'll see in code. Again, I like to look at it in code. It just makes a little more sense.
00:39:27.034 - 00:40:11.542, Speaker C: In my brain, those registers are PCaP and FP. That's program counter allocation pointer and frame pointer. We have non deterministic continuous read only memory. Nondeterministic, continuous read only memory. So if you think about the way that a memory model you're probably familiar with, it's usually a read write model. Because we're operating in this kind of polynomial and mathematic domain, it operates slightly differently. We're proving each trace cell, so we need something that looks more like a read only memory model.
00:40:11.542 - 00:40:39.230, Speaker C: So there's these subsets here, A, B, and C. This is ways you could implement a memory model. A would be the read write you're used to. So write value seven to address 20, and then read it in a normal cpu. And a transistor can pick up and put down values over its lifetime. So no problem. Read write seven to 20, write, then write nine to 20, so on and so forth.
00:40:39.230 - 00:41:32.910, Speaker C: Write once would be the same thing, except you can only read it, you can't then write to it again, and then you have this version of a nondeterministic, read only memory, which is what we have. And the reason we need it is because we need to know where the memory layout looks like so that we can prove it. So it looks more like this does on c. So y is actually being assigned in the read. So we're asserting that y equals seven and that for all intents and purposes it looks like a write. You can think about it like a write. The way I think about it is write once, but the way you actually kind of write it out and formalize it, it's actually saying it's only read only in that we asserted that y equals seven, so that we know that that memory layout looks that way as you're writing Cairo code.
00:41:32.910 - 00:42:03.130, Speaker C: I think that this is a little non useful. You can think about it more like a write once memory model validity of the execution trace between two states. So that's getting into the statement of computational integrity. We have an instruction. So an instruction is one operation that the Cairo machine is doing. It's going to touch four trace cells. Those are the trace cells of the stark.
00:42:03.130 - 00:43:21.816, Speaker C: We have memory access. So the memory access is going to touch five trace cells of the stark and then an instruction decode. So this is the overhead that we talk about when we talk about operating the Cairo machine as opposed to writing a built in or a customized air. You don't incur these penalties. What do we mean when we say sell? So cell refers to a trace cell, and the trace cell is it goes back a little bit to the starks that we talked about last session, where what we're proving is, if you think about it, in those frames, the next cell was the next sequence in the Fibonacci squared sequence that was from one trace cell to the next trace cell, the entire thing being the trace. So from, we have some deterministic ending of that sequence, which was the 1022nd element of the Fibonacci squared sequence, so we don't go to infinity. And so that gives us the trace.
00:43:21.816 - 00:43:55.850, Speaker C: And so here we're saying instead of proving the Fibonacci squared sequence, we're proving the movement of these pointers within the Cairo machine. Okay, cool. Those are the trace cells in the proof. So what is a memory segment? We'll look at that later today. Memory is where CPU reads to or write from, for example, ram in our computers. Yeah, exactly.
00:43:59.740 - 00:44:00.584, Speaker B: Okay.
00:44:00.782 - 00:44:28.960, Speaker C: A little bit more in depth onto registers. These are the only values that change over time. And they are the allocation pointer, which points to a yet unused memory cell frame pointer. Frame pointer points to a frame of the current function. So this is how we implement things like scope. We'll look at it today. Addresses of function arguments and local variables are relative to the frame pointer.
00:44:28.960 - 00:44:34.100, Speaker C: And then program counter, program counter points to the current instruction.
00:44:37.160 - 00:44:37.910, Speaker B: Okay.
00:44:39.880 - 00:45:14.716, Speaker C: So we have a Cairo machine. We have a Cairo virtual machine. So with that comes some assembly. The very origins of Cairo really was this assembly language with some syntactical sugar on top of it. It's becoming a more complex language, it's becoming a more dynamic language. But this assembly syntax sits under the hood of all of. So yeah, that's a good question, prasant.
00:45:14.716 - 00:45:57.488, Speaker C: I'll answer it in 1 second. With Cairo assembly, we have direct access to these pointers that we mentioned, this AP, FP and PC, and we can manipulate them as well. So if we're wanting to access some memory in the memory layout, we access it like this, increasing AP, so advancing the allocation pointer so that we can allocate more to memory and memory segments. AP plus plus assert equals. This is an important one because it kind of goes back to our different ways to implement a memory layout. You'll see that here.
00:45:57.574 - 00:46:06.390, Speaker B: And this actually should be like this.
00:46:07.560 - 00:47:06.680, Speaker C: This is one of the reasons that assert needs to be in the assembly language is because what we're doing here in the nondeterminist agreed only memory is that we're actually asserting that y equals seven. So we need some assertation of equality at the assembly level, ensures that the left hand and the right hand are equal or rejects the execution. That's one thing that looks slightly different from other languages. You can write something that looks like assert this equals that. If the left hand is not assigned to that will assign to this. Whereas in other languages you might have assignment and assertions split out from each other. If you don't have a complete execution halt, then it will assign.
00:47:06.680 - 00:47:49.376, Speaker C: Probably shouldn't have mentioned that. I'll show you where that exists if you want to dig deeper into that. But it might be mudding the waters right now. Jumps call and returns and advancing AP. So Prashant asked a good question. How relevant are APC for Cairo programmers who are writing smart contracts in high level Cairo? The answer is they're not necessarily that relevant until they are. So the way that a lot of Cairo developers kind of come into the ecosystem is they want to write smart contracts.
00:47:49.376 - 00:48:35.024, Speaker C: They want to write composable smart contracts on top of Starknet, and they come in and they start writing these programs. And then they'll see something like a revoked reference, and when you get something like a revoked reference, you almost kind of start to stall out. As far as what that is, maybe there's not a ton of documentation on it. And if you don't have any idea of what's happening under the hood, almost everything that we're talking about right here, especially starks, is way under the hood. As a smart contract developer in Cairo, you're never really going to have to touch starks. The closest you'll probably get is defining a felt or a field element. And that's kind of the same thing with Cairo assembly.
00:48:35.024 - 00:49:11.460, Speaker C: So you're not really going to be manipulating APFP and PC as a smart contract engineer, but it's good to know what they are. And when you see something like a revoked reference, it's good to know why that might have happened. All right, we will jump into the code. Where are we at time wise? Before we do that, any questions on that kind of high level layout of what Cairo is, what the goals of Cairo are, how Cairo relates to starks?
00:49:18.160 - 00:49:18.910, Speaker B: Okay.
00:49:21.600 - 00:50:10.610, Speaker C: Then we will jump into the code. I believe I sent it out, but I'll ping it out in the chat one more time. So base camp is here. If you already have basecamp locally, do me a favor and pull it. There were some changes, like I mentioned, from Omar. And again, just to reiterate that if you want to go check out Omar's pr and see what we're looking for when we're looking for contributions to basecamp, check that out. Because we really want basecamp to be kind of a cohesive place to look at code examples, concept overviews.
00:50:12.310 - 00:50:16.274, Speaker B: Base camp. Let's see.
00:50:16.312 - 00:51:02.082, Speaker C: Would it be important to know the concepts of APFPNPC in case the programmer wants to optimize the developed. Yes. Yeah, so that's another. Like, you see a lot of these solidity developers running through gas optimizations with their solidity assembly. And yeah, you're going to see the same things. If you understand exactly where your program is accessing memory segments, you're going to be able to optimize it to the end of the earth, probably for worse rather than better, because I know programmers can kind of sit with those things for a long time. All right, let me just make sure I don't have anything too crazy in here.
00:51:02.082 - 00:51:23.660, Speaker C: Okay. You can follow along with me if you want. I'm going to blow away my base camp. All right, we are stepping into camp two.
00:51:34.810 - 00:51:49.640, Speaker B: And we will go over it. Sorry, the zoom thing is screwing up all my screens.
00:51:52.080 - 00:52:12.290, Speaker C: Okay, let's start with felts. We'll look at. There's a slight difference in the way felts are treated in Cairo than they are than I've taught you about starks so far. So we'll start there. Let's look at a quick slide about it.
00:52:14.900 - 00:52:15.650, Speaker B: No?
00:52:18.440 - 00:53:30.344, Speaker C: All right, so felts are the base integer type, they're the native type, they're the scalar type, really, at the base of everything, you're going to see a felt. So in other languages you're probably going to see a lot of interpretations of different integer depths. So you might see like a Un eight, UN 32, UN 64, an unsigned integer assigned integer at the base of the Cairo VM is just going to be the integer the felt. And that felt is, whereas in a stark it is just defined as anything greater than zero and less than know. We talked about why that's important. In the Cairo VM we have the concept of a signed integer. So instead of going from that definition of a felt like we have in something like the stark, we have negative, so negative p divided by two, x is above that and less than prime divided by two.
00:53:30.344 - 00:54:13.624, Speaker C: And so you have any integer in that entire range can operate as the native scalar type of integer. And the register size is the stark prime. So our prime is two to the 251st plus 17 times two to the 192nd plus one. That's one of the primes that has been found in that range that has some multiplicative subgroup that offers these benefits that make the proofs scalable. So that's our prime. That's what P is here. All operations are mod p.
00:54:13.624 - 00:54:25.100, Speaker C: So that includes addition, subtraction, multiplication and division. Yeah, and some of the gotchas here we'll look at in code, but even checks and division.
00:54:30.320 - 00:54:34.990, Speaker B: All right. Actually going to do it like this?
00:54:39.680 - 00:54:56.980, Speaker C: I'm not sure if I sent this out last time. Might be useful to some people. I have just a bash alias for stepping into a Cairo development environment. I'll just send it out in the chat in case it's useful.
00:54:58.840 - 00:55:02.840, Speaker A: Are you showing a terminal, Ben? Because I keep seeing your slides.
00:55:04.540 - 00:55:06.056, Speaker C: I'm trying to.
00:55:06.158 - 00:55:07.130, Speaker B: Let's see.
00:55:09.420 - 00:55:12.430, Speaker C: Can you see this?
00:55:13.120 - 00:55:14.748, Speaker A: Yeah, I can see the terminal now.
00:55:14.834 - 00:55:16.060, Speaker B: Okay, score.
00:55:25.410 - 00:55:43.720, Speaker C: Okay. If this is useful to people, it's useful to me. So there's just a little alias here for stepping into your Cairo development environment. David actually has a really good blog post about setting up your development environment as well, David, if you want to post that out.
00:55:45.050 - 00:55:46.040, Speaker A: Yeah, sure.
00:55:49.690 - 00:56:27.090, Speaker C: But what we need to do when we're developing. So we need to have the Python virtual environment source, the python virtual environment set up a couple environment variables. So I have an alias for Cairo dev environment, and that points to Gurley, the testnet. You can also point to Alpha Gurley, which is, sorry, Alpha Mainnet, which is the main net starknet wallet. We'll get into that in session two. We have account abstraction on Starknet, so you need to define some wallet. If you're operating the CLI locally.
00:56:28.790 - 00:56:29.106, Speaker B: To.
00:56:29.128 - 00:57:12.740, Speaker C: Point to a certain wallet provider, that's most of what you'll need to operate the Clis. We have a couple of different clis that come when you do pip install chiroling, which everyone should have. So once you're in your development environment, you should see a bunch of clis. For Cairo, compile, Cairo format, Cairo hash program, Cairo migrate, Cairo, run Cairo, reconstruct, traceback and Cairo Sharp. And then you have a couple as well for Starknet, Starknet compile and Starknet Devnet. That's not something that comes in the starkware provided toolchain, but we'll get into that. It's very useful to have.
00:57:13.430 - 00:57:19.730, Speaker A: I don't know if you answered Arturo's question in the chat about overflows in Cairo.
00:57:20.090 - 00:57:21.240, Speaker B: Let me check.
00:57:21.850 - 00:57:55.742, Speaker C: In Cairo exist the overflow and underflow in numbers greater than two to the 252 bits as insulinity. That's a great question. And let me go through felts and then tell me if that answers the question. Okay, so here is camp two, and we are in felts. We have the Cairo implementation and a Python implementation. Let's start with the Cairo implementation, because I think that might solve your question. Here's the max felt size.
00:57:55.742 - 00:58:24.530, Speaker C: So this is the max felt size that we have. This is the prime that we mentioned. This is also how you define a constant in Cairo. So we have that serialized word is a built in that we will get into what built ins, or sorry, serialized word uses a built in, which is the output pointer. We'll get into built ins in a little bit. Don't worry about that for now. But it's basically similar to a print or console log that you might have seen or a print statement.
00:58:24.530 - 00:58:52.100, Speaker C: So what we're going to do here is we're going to print the max field size. We're going to print the max field size divided by two plus one, which gets into the signed version of a felt. And we'll also do the same thing right around the overflow and underflow. As Arturo mentioned. We're going to do division when division is clean, we see that it's going to be two. And when division is not clean.
00:58:53.910 - 00:58:54.274, Speaker B: It.
00:58:54.312 - 00:59:31.322, Speaker C: Provides an answer that solves for the equation that we talked about last time. And I am now realizing I didn't provide a solid answer and I said I would. I hope that you guys did some research on division in finite fields. But basically we land in an answer in the finite field that solves for the greatest common denominator and solves an equation of two coefficients, which we talked about last time. If you guys are still curious about that, let's take it offline. I realize I owe you an answer for that. And then multiplication.
00:59:31.322 - 00:59:39.170, Speaker C: So we'll run all of this. Here are your commands. Cairo compile.
00:59:42.710 - 00:59:44.338, Speaker B: We'll CD. Where are we?
00:59:44.424 - 00:59:57.670, Speaker C: We'll CD into Feltz. Cairo. This is slightly interesting. So this is the development flow. What we're doing is we're compiling.
01:00:00.170 - 01:00:00.534, Speaker B: This.
01:00:00.572 - 01:00:26.762, Speaker C: Cairo program down to a felt compiled jSon. So let's check out what that is. It defines the built ins that we've used. Built ins are those raw, um, raw algebraic intermediate representations. Define some other metadata about the tool chain. So we're using 00:10 one. We'll get into this a little bit more.
01:00:26.762 - 01:00:45.122, Speaker C: This is going to be your bytecode, your Cairo bytecode for the execution of the VM debug info hints we'll get into today. Identifiers. Prime is the prime that we've already referenced and reference manager.
01:00:45.186 - 01:00:45.800, Speaker B: Okay.
01:00:47.530 - 01:01:12.480, Speaker C: All right, so once we've compiled that, and keep in mind, this is the compilation and the trace that we do send to the sharp. So this is what the sharp then re executes and proves. And this is where we get into the interplay of the prover and verifier. So we do need to compile and then we run.
01:01:17.110 - 01:01:17.762, Speaker B: It.
01:01:17.896 - 01:01:57.870, Speaker C: All right, so let's see if this answers your question. We have the constant which is the max of the prime of the finite field. We have just printed it and it's zero because we wrap. What is the max modulo? The max, it's nothing. It's zero. Similar with overflow and underflow. So what is the max in the finite field? Plus one and minus one? It's just plus one and minus one because we have this finite field arithmetic that deals in modulos.
01:01:57.870 - 01:02:19.510, Speaker C: When we overflow, we might get some unexpected behavior in the code that you've written, but it's not going to pop us in any type of weird execution environment. You're just going to wrap these field elements. Does that answer your question? I think Arturo.
01:02:23.600 - 01:02:24.750, Speaker B: Okay, cool.
01:02:26.800 - 01:03:01.610, Speaker C: And then now we have down here, let's go three up from the bottom. Six divided by three gives us a clean division within that finite field arithmetic. So we have two, but then seven divided by three does not give us a clean division. So we have this large field element somewhere within our field element description. And then what have I done here? Okay, so this is, this is to describe on 22 and 23 that.
01:03:04.220 - 01:03:04.536, Speaker B: Even.
01:03:04.558 - 01:03:41.990, Speaker C: Though this is funky division, it is still solving for division. It's just that it might not look like what you expect. So then when we do the results of seven divided by three, and we multiply it back by three and it's all in the finite field, we do still get seven. It just kind of looks wonky. And you need to be careful when you don't have a clean division like that. Let's step into the Python code here. Similar concepts in the Python code.
01:03:41.990 - 01:04:39.620, Speaker C: It's just outside of the Cairo execution. So like we mentioned last time, Cairo and a lot of the tool chain was written in Python. A lot of the toolchain is now being rewritten in rust. But if you want to see how might these concepts look in the python that implements them, here is the field size, the prime as a python constant. Here's the max signed felt size. And then you might be thinking like, okay, if we are running on my silicone and the bitwidth is 64 bits, how much bigger is our field size? So this just kind of gives you a little visual representation of how much bigger field size is over our finite field. And then just some of these arithmetic operations.
01:04:39.620 - 01:04:44.090, Speaker C: Modular prime. So.
01:04:46.300 - 01:04:51.530, Speaker B: Python three felt cool.
01:04:54.000 - 01:05:03.470, Speaker C: Here is the field size. This should say signed field size. And then you can see how much bigger it is than these standard.
01:05:05.460 - 01:05:05.872, Speaker B: Local.
01:05:05.926 - 01:05:40.552, Speaker C: Machine architectures, which I don't know what your intuition says about it. Mine says, oh, cairo must run very slow. And it's just that it's not the goal, right? The goal of Cairo is not to run super, super fast. The goal is to output provable programs. Okay, overflow one, because we had the modulo. And here is where we get this. The very edge of the prime ends in one, so it's not even.
01:05:40.552 - 01:09:25.470, Speaker C: But then the very edge of the felt plus one is also not even. So we have two kind of odd entities back to back, which might defy your intuition there as well. Okay, I think we've been going for about an hour. Does anyone have any questions on felts or how they're represented in Cairo or python? Okay, we're going to take a five minute break real quick and then let's meet back up in five. Hey, Omar, we're going to meet back up in just really a minute here.
01:09:26.000 - 01:09:26.604, Speaker B: Perfect.
01:09:26.722 - 01:09:29.676, Speaker D: Okay, can you hear me? Well, everything clear?
01:09:29.858 - 01:09:32.270, Speaker B: Yes, perfect.
01:10:17.840 - 01:10:22.800, Speaker C: Omar, don't do anything crazy. You're on camera and being streamed live to YouTube.
01:10:24.740 - 01:10:32.980, Speaker D: Okay. Nothing of going underwater to coats under the sea of Panama.
01:10:40.990 - 01:11:18.520, Speaker C: All right, Manolo has a good question, one that I'm actually trying to get an answer to. I think I have the answer to it. So he says, hello, why in felts Cairo the value of felt size is zero, but in felts PI, it's the max. Oh, I see, never mind, I see what you're saying. Yeah. So the description of the felt size is going to be modulo the prime. So let me go back.
01:11:18.520 - 01:11:25.400, Speaker C: Can you guys see that?
01:11:28.190 - 01:11:28.986, Speaker D: Yes.
01:11:29.168 - 01:11:29.900, Speaker B: Okay.
01:11:33.440 - 01:11:34.910, Speaker C: So that would be.
01:11:40.900 - 01:11:41.424, Speaker B: I think.
01:11:41.462 - 01:12:24.750, Speaker C: What you're saying is basically this field size modulo felt size, modulo felt size in python. So when we do felt size modulo felt size in Python, we see zero. But Cairo, that's what Cairo is doing under the hood. Cairo operates on those field elements that we've talked about. So everything is on a finite field, so everything is by nature modulo the prime there. So that's why you see zero and you don't have to actually explicitly do that modulo operator and we just see zero.
01:12:28.140 - 01:12:28.890, Speaker B: Cool.
01:12:29.500 - 01:13:24.684, Speaker C: Okay, I am going to briefly talk about custom types. So we've seen felt, that's the native scalar type, but just to provide the developers some flexibility, some fidelity, we have these other types and references, so consts, which we've already seen, short strings. So short strings is really a string as it's represented in an integer format from a hex encoding. That might look strange. I think if we don't go over it in today's session, we'll go over it in next Thursday's session. You should have an intuition of what that means, though. One of the things it means is that a short string can only be represented the number of bits that a felt has.
01:13:24.684 - 01:14:12.830, Speaker C: So that ends up being, I believe, 31 characters. And you could probably understand why that is now. References, references, strings, local variables, temp variables, tuples and arrays. And so this gives us a little bit more fidelity with how we express our business logic, which we will look at today. Gotchas, revoked references and rebindings and locals. From here, I'm actually going to pass it to Omar. So Omar is going to talk about algebraic risk and the memory model.
01:14:15.200 - 01:14:15.804, Speaker B: Perfect.
01:14:15.922 - 01:14:24.780, Speaker D: Thank you, Ben. Let me share screen here. Can you see my browser?
01:14:28.170 - 01:14:29.830, Speaker C: Yep, I can see the slides.
01:14:30.250 - 01:14:30.758, Speaker B: Perfect.
01:14:30.844 - 01:15:14.150, Speaker D: Ok, so we already talked a little bit about what error is and now we're going to talk about the structural sets that we send to the CPU, to the carrier CPU. So what we use is an algebraic risk. Risk is a common term in computer science. It means reduce instruction set computer. That's what the Cairo CPU is implementing. And the algebraic part is because we are using the fails part field operations. As we have seen before here, we're implementing an algebraic risk, a Cairo instruction set that is optimized for performance, for fast and effective performance.
01:15:14.150 - 01:16:11.370, Speaker D: So the goals we have with the risk with this instruction set that Cairo uses is to minimize the number of trace cells used so the error can be as efficient as possible. This is what we are trying to do here, and that way we support only two operations, the addition and multiplication, and checking whether two values are equal. So as you can see, this is a very simplified instruction set, but this is what we have found to be the most efficient to create all these operations. And even though we have like a very reduced set of operations, the Alibaba risk can simulate any Turing machine and thus it is turing complete. However, by itself it is not Turing complete. We need the buildings that we're going to be talking about in a little bit. So if you from these supported native operations below the buildings we have a Turing machine.
01:16:11.950 - 01:16:15.270, Speaker B: Okay, so now going to the memory.
01:16:15.350 - 01:16:40.002, Speaker D: Which is key here for us to understand better what built ins and registers are, that are our main topic here in the memory, I believe we have four different four key characteristics. Number one, the memory should be continuous. If you have something on, for example the memory cell number seven, and on the memory cell number nine, you also have to have something on the number.
01:16:40.056 - 01:16:40.660, Speaker B: Eight.
01:16:42.470 - 01:17:09.270, Speaker D: You cannot provide this value yourself, but the program will automatically fill this empty space. And that is actually not very efficient since we have memory cells that are being used even though they are not relevant for a program. So it's better to have everything in place. But if you don't have everything in order then the program will add something there. So we have a continuous memory. We will see that in a moment. Also we have a write once read only memory.
01:17:09.270 - 01:17:45.202, Speaker D: So you can write something once to the memory and then you can read from it, but you cannot write it twice. Also the relative addresses we are working not with absolute address. So I cannot tell something like I want in memory cell number 37 to have this value and or memory cell number 39 to have this value. No, we only have relative addresses. That's what we're going to be using the registers for. So, for example, you can say, in the next empty cell, I want to write this, or in the next three different memory cells, I want to add this other thing. But everything is related.
01:17:45.202 - 01:18:22.706, Speaker D: And we will be using an offset for that. Offset is this number that you can add to a specific memory address. For example, to this address, add four cells. And then we will write something or read something from there. So I know this can be a little bit weird and we are going a little bit fast over this, but everything that I'm telling you, you can find it in more details inside the base camp. Number two, in this part, for example, of the care instruction, set the algebraic risk. And then you can go to the memory part where we also go deep into this part of how the memory works.
01:18:22.808 - 01:18:25.558, Speaker B: In kyro perfect.
01:18:25.724 - 01:18:57.242, Speaker D: Okay, so we have relative addresses. And finally we have segments. These segments are memory areas. These are key for the memory of Cairo because we will be using builtins. In a moment, I will explain what built ins are, but what we have is these memory segments that have certain properties each. So we have segment one, sorry, we have segment zero, segment one, segment two, segment three, and so on. And each building will have its own memory area called a segment.
01:18:57.242 - 01:19:18.642, Speaker D: So we have a list of segments. And if you concatenate them altogether, then we have our memory. So we will see an example in a couple of minutes. Please let me know if there are any questions. I see. We don't have questions right now, but yes. Okay, so this is how, more or less how Cairo works relating to memory.
01:19:18.642 - 01:19:43.106, Speaker D: And now we can go to builtins. So built ins are key for archival program to be turing complete. What we are doing here is that we are having a segment of the memory. So we have, for example, certain numbers of cells of memory, cells that have certain properties. For example, we can have a range check pointer. So I will go quickly to the next slide. We have several different builtins.
01:19:43.106 - 01:20:46.686, Speaker D: In this case we have output pedal send range check, ECDSA and bitwise. Each one of these built ins will be assigned a segment in case you will use them because it's optional. So if you use them, you will be assigned a segment for each of these built ins. And that part of the memory will have certain properties. For example, if we go to the pedder saying segment, you will see that if you have three different memory cells, then if you put one number in memory cell one and then another number in memory cell two, then you will compute this memory segment will compute the hash of these two different numbers and then output the result into the third memory cell. And then you go to the fourth at a number, into the fifth, another number, and in the 6th space you will have the result automatically output by these memory segments. So output, for example, if you already code with Cairo, you have seen a lot output.
01:20:46.686 - 01:21:10.258, Speaker D: You have that if you write something into a cell of the output segment, then this will be output by your program. So it will be for example, printed into your terminal if you are using this output building. So each of these different buildings have certain properties that allow the algebraic risk, the instruction set of the chiro machine.
01:21:10.354 - 01:21:13.338, Speaker B: To be touring complete for us.
01:21:13.504 - 01:22:03.546, Speaker D: And of course we have to get a way to access this memory segment that is assigned to each of these different buildings. So for example, for the output building, we have a pointer called output pointer that points precisely to this memory segment. You want to access the Person memory segment, then you have to use the person pointer, and so on. We have the range pointer, the EcBSA pointer, the bitwise pointer, and this pointer can be of different types. For example, in the case of output, we have a felt, sorry, a pointer to a felt. In the case of person, we have a pointer to the hash built in the range check. Because of conventions, it's not a pointer, it's actually a felt, not a pointer to fail, and so on.
01:22:03.546 - 01:23:05.886, Speaker D: Again, everything that I'm telling you right now, you can find it in the built in section inside the repo of the camp number two. And also we have certain details additional. For example, here we can find how is the structure of a hash built in, which is actually the type that we have for a pointer, for a pairs and pointer, as you can see, we have three different members of this structure, x, y and result. And you remember that I mentioned before that if you access this payer send segment, if you add something to cell number one, for example, as an x, I can add a number one, for example, and to y I can add a second number and automatically we will have a result output by the program. And actually, if we go to the actual implementation of the hash two function, this is the one. Let me see if we should use this one. Let's see this example.
01:23:05.886 - 01:23:35.978, Speaker D: So if we go directly to the implementation of the hash two function, that's where you input two different numbers and you get back a result. We can see that what we are doing here is invoke, and that is the term we're using, invoke the hash function. What we're doing here is invoking that memory segment with certain properties that we have. So for example here I'm telling this function that we want to store a.
01:23:35.984 - 01:23:43.354, Speaker B: Next value into this hash, which is.
01:23:43.392 - 01:24:21.954, Speaker D: Simply the hash built in we have before this one. So I'm storing something next, then storing something in y here, and then I am returning the value in result, and that is the hash value of x and y. As you can see, this is done automatically. I'm not implementing a function or something like that. This is done automatically by this memory segment of our Cairo machine. And also something relevant here is that we have always either implicitly or explicitly add the updated value of the pointer. So in here, for example, I am doing it explicitly.
01:24:21.954 - 01:24:51.358, Speaker D: If you have already called with Cairo, you know that we use implicit arguments here. We're using an explicit value to return the new hash pointer, which is three values to the right. So if we input something in x, we are using memory cell one, in y, memory cell two, and then c will print its result in memory cell three, and then we can use the memory cell number four. So we are returning the updated value. If not, we will have an error, a mistake here. I don't know if there's any questions. Yes?
01:24:51.444 - 01:24:57.550, Speaker A: Yeah, there's a question about the cave in asking that those built in pointer names are reserved names.
01:24:57.630 - 01:25:00.734, Speaker D: There's a question, yes, those are reserved names.
01:25:00.782 - 01:25:01.380, Speaker B: Yes.
01:25:01.750 - 01:25:32.350, Speaker D: So there's a convention, actually, as you can see here, there's a convention. It's simply the name of the building plus the underscore pointer. Underscore pointer, underscore pointer and so on. So you want to manage. This is basically low level Cairo. This is what goes underneath of what you're building, and this is how the memory works. And the segments are key for this, for you to better understand how Cairo is working and build very cool applications.
01:25:32.350 - 01:26:25.066, Speaker D: So this is the same implementation as before, but with an implicit argument instead of an explicit argument. As you can see, we are only returning the result that was output by the Pearson memory statement, but we're not returning the updated hash pointer, but we are updating it here and it's returned automatically because it's an implicit argument. Okay. If you want to go through another example here, you can see that also in the CLI's word implementation. As I told you before, we are using here the output pointer, which points to the memory segment for the outputs built in, which is a specific segment, commonly is the number two. Is the segment number two. We have number segments.
01:26:25.066 - 01:26:42.690, Speaker D: We will see that in a moment. But basically what we're doing here is that we want to output our program to output these words. So basically we're storing in this memory address the value that is in word. And then we are simply updating the output pointer because this is necessary.
01:26:43.530 - 01:26:44.038, Speaker B: Okay.
01:26:44.124 - 01:27:05.082, Speaker D: So if we go to the code here, and also you will find that in your code in basecap. Let me share screen again. Just a second. Let me see. Okay. Can you see my visual field codes? Yes.
01:27:05.136 - 01:27:06.714, Speaker B: Okay, thank you.
01:27:06.832 - 01:27:43.266, Speaker D: So here you can find the code to compile and run this program. It's basically I'm using here three different built ins, output built in, person built in, and the range check built in. It's nothing useful, but just for the sake of an example. So we're using a function, hash two, that, as we saw before, is using the hash pointer, which points to the memory segment of Pedersen. Then we have the output pointer, which points to the output built in, and then the range check pointer, which points to the memory segment of range check. And then I'm using them all here in a main function. Nothing relevant.
01:27:43.266 - 01:27:55.020, Speaker D: Simply using them. So we can compile this and we can run this. And let me use this coding here, going back to my terminal. Can you see my terminal now?
01:27:56.030 - 01:27:58.490, Speaker A: Yeah, but there's a question, Omar.
01:27:59.490 - 01:28:27.810, Speaker D: Yes. Let me look at it just a second. In the chat, how is dict access work and why we can write multiple times at the same key? Let me see. Go back here to the code we have here. Dict access.
01:28:29.700 - 01:28:30.976, Speaker B: What is the dict access?
01:28:31.078 - 01:28:38.290, Speaker D: I think this is not a question related to what we're talking about right now. No.
01:28:41.240 - 01:28:48.470, Speaker C: It'S a good question. Do you mind just pulling this up? I'm going to post it in the chat real quick.
01:28:49.160 - 01:28:49.910, Speaker D: Sure.
01:28:50.760 - 01:28:52.724, Speaker B: Perfect. Yeah.
01:28:52.762 - 01:29:22.604, Speaker C: So how does dict access work? And why can we write multiple times at the same key? It's actually a little bit of a trick under the hood. And it's a really good question. You, in essence, are not writing to the same key. Can you pull that link up, Omar, on your screen share, and then scroll down to that table? Yeah.
01:29:22.642 - 01:29:23.230, Speaker D: Right.
01:29:24.160 - 01:29:58.060, Speaker C: So instead of writing to the same key, you're actually writing the entire access of the dictionary. And then what you do is you do this squashed function, which is not on the same key. And then you get basically the diff from everything that happened for the dict accesses. And in that way, even though you see where his cursor is from, seven, the previous is three, the newest two. And then there's another entry in the row, which is a new entry for seven. Seven. Previous is two.
01:29:58.060 - 01:30:10.290, Speaker C: Next is ten. You actually are never touching the same memory cell. It's just a data structure that appends the rows that you can then squash. But it's a super good question.
01:30:12.980 - 01:30:14.944, Speaker D: Yes. And you end up with this one.
01:30:15.062 - 01:30:19.200, Speaker B: Yes. Cool. Perfect.
01:30:19.350 - 01:30:52.376, Speaker D: Okay, going back to our code, what I did is run this compile and then run this hash program. And what we are outputting here is basically the hash of two different numbers. And it's basically that. So you, for example, want to see what is happening beneath in the memory. I will explain a little bit further that part. But you can simply add the print memory and here the print memory flag.
01:30:52.488 - 01:30:58.976, Speaker B: To your code and run it with it.
01:30:59.078 - 01:31:13.250, Speaker D: And what we have here are the different segments actually in action. So for example, we have the segment number zero, which again, if you go, and everything is very plain here.
01:31:16.420 - 01:31:16.688, Speaker B: In.
01:31:16.694 - 01:31:49.996, Speaker D: The base camps, number two, you can see more details on everything. And particularly we can see more about what each segment means. So, segment number zero here is the program segment. So, the program segment is accessed by the program counter register that we will see in a minute, but basically is what is happening in our program. Then in segment one, we have the execution segment. And this is where the AP and FP registers work. We will see that in a minute.
01:31:50.188 - 01:31:53.904, Speaker B: And if we go back to our.
01:31:54.022 - 01:32:23.608, Speaker D: Memory here, that we printed from our previous function, the hash function, you can see here that we are accessing this segment zero. So now you can see the address value is kind of weird. Again, this is because we're using related address values. So the value number one here is the number of the segment. So this is segment zero, zero. And here is segment one, one. And here is segment two.
01:32:23.608 - 01:32:55.248, Speaker D: The second number is called the offset that I mentioned before. That is the number that we add to the segment. So this is the memory cell address number zero from the segment zero. This one is the one, this one, the two, the three, the four. So, as you can see, this is relative to the segment that we have. These are called relocatable address values because they will be located after we run all of this. And we will see that in a minute.
01:32:55.248 - 01:33:19.724, Speaker D: All this then will form a continuous memory. And we will see that in a minute. So this is relocatable address values. So remember, we have in the first value the number of the segment. And in the second value, we have the memory cell related to that segment. As you can see, they always start again. So we have segment zero here that starts at this moment.
01:33:19.724 - 01:34:05.336, Speaker D: And then segment one, which is the execution segment starts here and so on. So we have here the program segments is the number zero, and then the execution segment, which is number one. And then in the segment number two we are outputting. This is the segment that was assigned automatically by Cairo to the output built in. So all the segment two will have the properties of the output built in. Then in the number three we have, and we are storing the values for the pedals built in. And in the number four we are storing the values for the range check built in.
01:34:05.336 - 01:34:42.980, Speaker D: So this segment number two has the properties of output, this segment number three has the properties of person, and this segment memory four has all the properties of the range built in. I don't know if you have any question until that. Until now. Let me see, Ben will talk a little bit more about that syntax thing that you're talking. Olivier, those are for hints. So Ben will approach that in a moment. So I know this is kind of weird, this is strange, but this is very useful to understand what is happening underneath Cairo.
01:34:42.980 - 01:35:20.944, Speaker D: And lastly, let's talk a little bit. And again you can go through the camp two text to understand better what we are talking about. And finally we have the registers. So I mentioned them before, these registers, particularly AP and FP. The AP is the location pointer, and the FP, the frame pointer, will allow us to go and to manage all the memory that is happening in archive. So the AP pointer or allocation pointer, simply points to a yet unused memory cell. It's pointing to the next unused memory cell.
01:35:20.944 - 01:36:03.200, Speaker D: And the frame pointer is pointing to the start of a scope of a function. So for example, if we have one function, then it points to the start of the scope of that function. If we go through another function, then it will go to the start of the scope of that function and stayed constant until we change to another function or go back to a previous function. So let's see this in an example. And basically the program counter, you won't have to deal with it a lot, but basically it's the program counter. It works on the program segment, which is the number serial that we saw before. Right now let's just focus on the AP and FP.
01:36:03.200 - 01:36:34.110, Speaker D: So again, if you go to this AP FP example here in the base camp, and you compile and run, let me copy this. Compile clean here. Okay, so we compile, and now let's run it. And also let's add some flex to print our output here. Sorry.
01:36:36.980 - 01:36:38.144, Speaker B: What happened there?
01:36:38.262 - 01:37:17.752, Speaker D: Just a second. We're compiling here. Let's now run it and we will use the print info and print segments flags to get more useful information. So basically, this is a simple exercise to see where AP is, then where FP is, and see what is on the previous value of AP. So what we are doing here, going through it very simply, what we're doing here is that we are storing something. Let's go to the main function first. So we are printing first the AP address and the FP address using a hint.
01:37:17.752 - 01:37:55.184, Speaker D: Ben is going to go over that in a minute. Basically, it's python code that you can use inside a KO program. And you can see that here I am asserting I am adding the value, I am storing the value 100, which is a felt inside the AP address. Okay, remember, the AP address is the next empty memory cell that we have. And then with this we are adding a number to AP. So AP is increasing in value. Remember I said that before, it's very important for you to update the value of a pointer so it points to the next value.
01:37:55.184 - 01:38:43.568, Speaker D: If not, you're going to have a mistake that is useful for both the built ins, but also for these AP values. So here I am storing the value 100 and then going to the next value of AP. Then I am simply asserting that the values that was stored in AP minus one is equal to 100. It's very simple here. And as you can see, and we go back to what we printed before, we're using the AP address number one three. So segment one, which is the execution segment, and then using the value three, the memory cell three of the segment one, okay, and FP address is the same as AP. Did you remember that I had said before that AP and Fp will be the same when the function starts.
01:38:43.568 - 01:38:54.424, Speaker D: But then, as you can see, I start moving the AP value. So now it's the number four memory cell four memory cell five, and so on. But the FP keeps its value.
01:38:54.542 - 01:38:54.968, Speaker B: Why?
01:38:55.054 - 01:39:26.160, Speaker D: Because we are inside the same scope of the function. Then here specifically we change a function. So what I do here is simply call a full function and do it exactly the same as with the main function, but using full. So here is full function, I'm simply calling it. And when I call full function, then you can see that the FP value changes. And now is one eight. And that is ws where the scope of this full function starts.
01:39:26.160 - 01:39:30.116, Speaker D: And it was the same at the moment that AP was one eight.
01:39:30.298 - 01:39:30.692, Speaker B: Okay?
01:39:30.746 - 01:40:10.524, Speaker D: And it will keep its value one eight until we get out of this function. And as you can see, after foo, I go back to my main function and also update the value of AP. And as you can see, we go back to one three that we have before because we go back to the scope of the main function. So FP moves that way. Fp and AP moves. It's more for us to add our values there and manipulate what is on AP, which, as you can see, is a dynamic pointer that we can use for our own sake. I know this is weird.
01:40:10.524 - 01:40:16.948, Speaker D: It's a little bit. I'm going a little bit fast over it, but feel free to go to the code and the text in the camp.
01:40:17.034 - 01:40:19.616, Speaker B: Number two, I don't know if there's.
01:40:19.648 - 01:40:24.760, Speaker D: Any question till now. We're about to end this section, so I will finish it real quick.
01:40:24.910 - 01:40:27.672, Speaker B: So as you can see here, I.
01:40:27.726 - 01:40:53.170, Speaker D: Printed the memory again. We have here the program segment, which is number zero. Don't mind it a lot. It's a little bit weird. Then we have the execution segment, which is the number one. And here is where the AP value starts to move. So we are storing values 100, then we're storing value 200, then we're storing the value, which is a relocatable address, that is 20.
01:40:53.170 - 01:41:25.800, Speaker D: I don't mind it a lot. What is important here is that you can store felt values, but also you can store relocatable addresses here. Yes. So this is the values that AP, that we are saving. And at a certain moment, what I do to show how the continuous memory works is that I store here inside the full function. We're storing here a value on AP plus 300. And also something that I forgot to mention is that this number is the offset.
01:41:25.800 - 01:41:30.844, Speaker D: Okay? Basically, the offset is the related value to a certain memory address. Right.
01:41:30.882 - 01:41:31.132, Speaker B: Okay.
01:41:31.186 - 01:42:25.100, Speaker D: So I am using here the AP and I'm storing something, 300 memory cells after that one. Okay? So I am leaving a huge gap of memory cells on you by me. Okay? So this will help us to understand better how the continuous memory works. But simply, if we go down here, you can see that I'm storing something in one, there's something in one, one, then in one, two, so on. And suddenly we have a jump here of the memory. So these three points mean there's a jump in the memory, okay? When we are passing from segment to segment, there's a jump. And here, if we have this big jump between the current value that we have at AP, and then we added 300 numbers and we are storing this value, 50,000 arbitrary value.
01:42:25.100 - 01:42:32.448, Speaker D: Don't care about it. As you can see, we have a lot of empty cell space here. We can do that.
01:42:32.534 - 01:42:33.170, Speaker B: Yes.
01:42:33.860 - 01:42:36.610, Speaker D: Also they're going to stop. I don't know what happened.
01:42:37.620 - 01:42:45.684, Speaker A: Sorry, that was me. It's just my laptop. It's like dying. Because I realized I streaming two things, one to zoom cloud and one to YouTube. So we don't need both.
01:42:45.722 - 01:42:46.468, Speaker D: I just stop.
01:42:46.554 - 01:42:48.020, Speaker C: Otherwise you're going to crash.
01:42:48.520 - 01:42:49.316, Speaker B: Okay. What?
01:42:49.338 - 01:42:50.740, Speaker D: I can continue normally?
01:42:54.700 - 01:42:56.920, Speaker A: Yes, you can continue normally. Don't worry.
01:42:57.900 - 01:43:25.808, Speaker D: Perfect. Okay, so basically we have unused memory cell here. And now you will ask yourself, hey, Omar, you told me that this was continuous memory, but we have empty cells. Yes, yes, but no. So underneath here we have the segment relocation table. What this means is how the memory finally end up being. So we execute that program and the memory end up being this.
01:43:25.808 - 01:44:02.380, Speaker D: Basically it turned all these relocatable value addresses located themselves in a continuous way. Okay, that is what they are called, relocatable. They relocate in a continuous way, so it's no longer related. But now it's continuous. So we have the segment number zero occupies the cells between the memory cell one up to the memory cell 28. Then the segment number one starts at cell number 29 and then ops at 338 and so on. So this is a continued memory.
01:44:02.380 - 01:44:29.412, Speaker D: Don't mind about the segments three and four. These are empty segments that are used for the return values of PC and FP. Don't mind them about them. Right now you can see it in the text. As you can see, this is the memory that we end up having after running our program. Okay, as you can see, it is continuous, but we cannot access these memory spaces. We have to do it in a relocatable way.
01:44:29.412 - 01:44:54.716, Speaker D: We are using the relocatable values. These are all relative addresses. And what Kyo did inside this empty space that we have here is add arbitrary values. This is not efficient because we have memory space that we are not using. That is useful for us. It's not useful for us, but Cairo is filling these spaces. So this is what we are having.
01:44:54.716 - 01:45:26.980, Speaker D: I don't know if there is any question. Again, you can go through more details with the documentation and our text. There's a question by Carlos Colorado. What does frame of the function means in the AP definition? Let's go back. You mean to the frame pointer definition? So the frame is the start of the scope of a function. It's basically that. And also there's a question, Oliver Bulland.
01:45:26.980 - 01:45:36.908, Speaker D: Does it mean that memory cells for function foo starts exactly. He's asking that the memory sales for function foo starts at AP one nine.
01:45:37.074 - 01:45:37.548, Speaker B: Exactly.
01:45:37.634 - 01:46:04.576, Speaker D: If we go here to one nine. No, it actually starts before at one seven. Let me go back here. So the first thing that we have with Foo is that we are assigning AP, the value 301. Eight has 300. However, it's first AP. What is doing here inside the.
01:46:04.576 - 01:46:43.408, Speaker D: What AP is doing inside the execution segment is defined that we are preparing to enter another function. And this is done through the memory cell six and memory cell number seven. And then we can use the memory cell eight. Okay, so we cannot access number c and seven, but we access eight, nine, and then in ten we go back to the scope, to the frame of the previous function that was the main function. And here we are storing this valid. Sorry, let me see. No, sorry.
01:46:43.408 - 01:47:11.880, Speaker D: We're storing here. This one is still in the function foo, because in function foo is where we are doing this big jump and storing the value, the arbitrary value of 50,000. So we are still here in this segment. Yes. So it's basically that. I don't know if there's any additional question. We're having here the segment number two, because we have an output value.
01:47:11.880 - 01:47:35.296, Speaker D: So we are using the built in outputs. So that's why we're using the segment number two. And we're also using segments three and four. But this is automatically assigned by carrier to store the value of Pc and FP. The final values of Pc and FP. Don't care about them, they are not relevant here. So I think those are all the questions.
01:47:35.296 - 01:47:40.630, Speaker D: Ben, back to you. Sorry for the long.
01:47:41.160 - 01:47:47.540, Speaker C: No, no, that was awesome. One thing I wanted to add to that from Omar.
01:47:48.920 - 01:47:50.388, Speaker D: Do you want me to share screen?
01:47:50.554 - 01:48:50.068, Speaker C: No. So Omar showed a lot of the good CLI tooling that we have and a lot of the flags now, like with any CLI tooling, there's a lot of. In the usage, you can kind of read through it all and there's a lot there. And it kind of takes some getting used to another way that's good to kind of visualize some of these concepts, especially with registers like Carlo Omar has been going over is the. In the. I'll put it in the chat here you can start to go through a debug process. So I'm going to take the example that Omar wrote and I'm just going to plop it into that playground and then press debug.
01:48:50.068 - 01:49:17.456, Speaker C: So a lot of the concepts that he was talking about, it just adds a little bit of a visualization to it. The register segments that he was talking about, it doesn't quite show. So I think you do want to look at his example for that. But as you step through the execution of this program, you can see where the program counter is, where the frame pointer is, where the application pointer is, and step through the entire execution of.
01:49:17.478 - 01:49:27.188, Speaker B: This code just kind of helps to visualize. Okay, cool.
01:49:27.354 - 01:49:29.060, Speaker C: Do you have something else, Omar?
01:49:30.520 - 01:49:40.250, Speaker D: No, just to remind you folks that we are coding with very low level Cairo. So enjoy it.
01:49:41.420 - 01:50:13.072, Speaker C: Yeah, it's a good point. On your day to day smart contract development, you're not really going to see a lot of syntax like this in advancing a pointer manually. Okay, so we had a question about hints. So I want to get into hints real quick. And this gets into a little bit of the difference between. Can you send the link in here about the online debugger? Yeah, it's just above that, Olivia. It's the slash playground.
01:50:13.072 - 01:50:55.872, Speaker C: And you can drop any Cairo code in there. So hints get into the difference between the entire subset of Cairo versus the entire breadth of Cairo versus the subset that we write on Starknet. So we have a directive here for languages built in for contracts and code written for Starknet. And we specifically involved this to tell the compiler that we're writing a smart contract for Starknet. Now there's a subset of Cairo that we can use. One of the subset is that it cannot involve hints. And there's a caveat to that.
01:50:55.872 - 01:51:54.512, Speaker C: It can have hints that have been previously whitelisted. So there are a certain amount of whitelisted hints. But before we get into that, what is a hints? The goal of Cairo is to write provable programs, but like we saw with the integer depth of a felt versus 64 bit integer, it's not necessarily going to be the most performant language on earth. So we have these hints that let us step out of the execution flow or the execution trace of our Cairo program and run logic in another programming language. So right now that programming language is only Python. In the future I think that we'll see different subsets of languages being able to write inside of hints. But right now you can think about it like Omar said, which is it allows us to write python code in our Cairo execution flow.
01:51:54.512 - 01:52:26.990, Speaker C: So the question of what is this syntax on 18 and 21? This puts us into a hint. And then this gets us out of a hint. So we can actually access memory segments from the Cairo execution like you see here, memory AP. So we're accessing the AP of the Cairo execution flow. And then this also allows us to prove the result of a hint. We can inject values from our hint back into the execution state. So you might ask like, well, why would I want to do that.
01:52:26.990 - 01:53:15.448, Speaker C: From the point of view, from the verifier, it looks like the prover guessed the correct answer. But let's say for all intents and purposes, this part of the execution flow is actually not the part that we needed to be provable. We just needed to know that we got an answer. There's plenty of different reasons why you need this. It's the reason why a lot of the Starkx instances run on Starkx instead of Starknet. They don't necessarily need a composable environment in which they can play with all of the different DeFi applications that exist in the composable execution environment of Starknet. They just need to basically prove things on chain.
01:53:15.448 - 01:54:08.210, Speaker C: And so they have this entire subset of Kyro that they can use and prove the state of their order book or how many nfts were minted and to whom. And they're still able to prove that on chain in a really performant way because they can step out of the execution flow. Cairo write some business logic in Python and then prove that business logic back in Cairo. Prashant says hints allow us to execute programs in a non deterministic way, which is exactly are Cairo is proving this deterministic machine state execution. And then once we step out on 18 and into 21, we actually aren't proving any of this. Anything in here is basically nondeterministic. It's anything we define in here, but we're not including it in our trace, we're not proving it.
01:54:08.210 - 01:54:31.812, Speaker C: So we can do things like Omar showed, we can print, we can print hello world. This example specifically is getting input. And so you might be asking, okay, well, how do we inject input in? And that's this input JSON. And we see program input with a key access of value. Well, in our input JSON we have.
01:54:31.866 - 01:54:32.970, Speaker B: A key of value.
01:54:33.660 - 01:55:00.070, Speaker C: So the other piece of the tooling that needs to know about this for Cairo is going to be, nothing's going to change in the compilation because the hint basically just steps out of the execution of Cairo. So we will CD into.
01:55:02.760 - 01:55:08.710, Speaker B: Hints. Cairo compile that.
01:55:10.120 - 01:56:12.730, Speaker C: Yeah, so the Cairo run utility here needs to be pointed to the input JSON here with program input. And now not necessarily the most compute heavy operation, a square root, but somewhat compute intensive. We do that in this python execution and simply have the proof of the output in our Cairo code here. So we'll run that. And the program output is 31 because we pointed the output pointer built in to the end of that hint. So let me just go to hints yeah, a block of code that will be executed by the prover right before the next instruction. So it's tied to the instruction prior, and that's how this output pointer has access to the output value of the hint here.
01:56:12.730 - 01:56:35.708, Speaker C: So why it's still able to prove a statement without having to execute a long polynomial trace for. Yeah, and that's where you get a lot of the speed ups of Starkx. So when we talk about Starknet, there's only whitelisted hints available, and omar sent out the list of those whitelisted hints.
01:56:35.724 - 01:56:36.800, Speaker B: If you are curious.
01:56:39.920 - 01:57:14.420, Speaker C: Where are we at time wise? We're 5 minutes. So timing is pretty good. I'm going to briefly just show you how to manually interact with the sharp. Since this is a Starknet class, you're not going to be doing a lot of this, but there are some pretty interesting use cases with just writing raw Cairo. If you're writing raw Cairo, you can just submit it to the sharp because that is what the Starknet OS is. It's just Cairo code that's being executed and proved by the sharp. So we're writing can simply, we can simply prove it with the sharp.
01:57:14.420 - 01:57:29.210, Speaker C: We will just take something we've written, we'll just take the hint that we've written. Cairo compile. We've already compiled it, so we'll say cairo, sharp submit program.
01:57:31.280 - 01:57:46.290, Speaker B: What do we name it? We named it hints compiled. Okay, no program.
01:57:49.300 - 01:57:52.930, Speaker C: All right, so this is going to run that code. Make sure that it.
01:57:53.780 - 01:57:54.530, Speaker B: No.
01:58:01.770 - 01:58:03.960, Speaker C: Everything breaks on demo day.
01:58:05.850 - 01:58:35.770, Speaker B: Let me make sure input. All right, sorry about that.
01:58:37.200 - 01:58:47.384, Speaker C: I'll get you guys a better code example that works, but I'll show you what it should have done. So if you look at our architecture.
01:58:47.432 - 01:58:48.030, Speaker B: Here.
01:58:49.760 - 01:59:57.776, Speaker C: All the things that we're talking about is this execution flow. Now, sharp is a stark prover, so it also proves Cairo codes submitted by starkx, instances like Dydx and so rare and immutable. And now if that code would have worked, it would have just been me simply providing the trace to my trace for my simple little Cairo program on my local host to this sharp prover, and it then executing and proving it to the stark verifier on l one. Again, the goal of this is to interact in some not circuit ZK system where approver is proving execution to a verifier. Okay, so that's the sharp. And then I briefly want to touch on this. So for anyone that like Prashant is going to go in and do a real deep dive of the white paper, I find it also helpful to kind of decompile the bytecode of just simple programs.
01:59:57.776 - 02:00:20.030, Speaker C: So there's a couple simple programs in basecamp, like in registers, we just have an AP that basically does nothing. You can comment out these lines. And that's basically one of the simplest programs you can have in Cairo. And when we compile that, we're going to get.
02:00:21.840 - 02:00:23.470, Speaker B: Actually we'll run it.
02:00:26.400 - 02:01:03.770, Speaker C: We're going to look at the trace. Oh boy. All right, we got to compile it. We will run this trace and we'll see. This is basically as simple as it gets. We have an instruction, an allocation of memory and then a return. So you can run this through the debug environment, and that's fine.
02:01:03.770 - 02:01:55.290, Speaker C: But this in hex is going to show you the bytecode, the bytecode of Cairo, which is also in our compiled code here. So our compiled code has three things in this data trace. This is the Cairo bytecode. And so you might be asking, what is that? What does that mean? Well, to really understand the Cairo bytecode, you're going to have to run through. Are we still on? Okay, you're going to have to run through the Cairo white paper, but as you do that, there's this little python script that decompiles this word, this Cairo word. So here's some Cairo bytecode, and this will show you what the flags are within that Cairo bytecode and what each one of them is doing. So we have these offsets that Omar talked about.
02:01:55.290 - 02:02:28.164, Speaker C: Is it a pc update, is it an AP update, which opcode it's using so you can plug and play with which Cairo bytecode word you're looking at within your execution trace, and it will give you a real under the hood nerdy look at what's going on. So I found that useful when running through the white paper just to really get an idea that along with some of these other ClI flags, to understand what's going on.
02:02:28.202 - 02:02:31.750, Speaker B: So let's just output this.
02:02:32.760 - 02:02:43.320, Speaker C: Okay, so that's going to show you which bits are flipped, what it means, and what it means to the Cairo VM.
02:02:46.060 - 02:02:49.390, Speaker B: One last thing before we run out of time.
02:02:54.800 - 02:02:57.900, Speaker C: So in here there's a memory.
02:02:59.920 - 02:03:00.236, Speaker B: Not.
02:03:00.258 - 02:03:29.290, Speaker C: Going to be able to find it. Right now it looks like this though. So that byte code word is this instruction map, and that's where they sit, and that's why the VM does what it does. And you can get a real good explanation of it. Okay, so I think we will close out the section there. If you have any questions, feel free to put them in the discord. One of the three instructors will reach out to you, try to help you out.
02:03:29.290 - 02:04:21.524, Speaker C: As far as today, this is the playground that we talked about. Here is how Cairo works, the documentation and then obviously the white paper. And again, I would recommend Prashant's medium article as well workshop so what to do in the off are and I do want to mention the same way that kind of Cairo today got a little easier. Moon math Starks next session will get even easier because we're dealing with a subset of Cairo code that is just written for smart contracts on Starknet. So that is what this tutorial goes over. It goes over Cairo syntax as it pertains to Starknet. And we'll start really building out some fun stuff and working with Starknet the way the reason that a lot of people come to the environment, but you guys have a real low level understanding of what's going on.
02:04:21.524 - 02:04:43.084, Speaker C: So make sure to do not just the basic setup, but the ultimate setup in the slides here. If you don't have an argent wallet, please install one in your browser. And that's it for today. So thank you all for joining. Thanks Omar for the awesome presentation. And yeah, feel free to reach out to any of us. And thanks again.
02:04:43.084 - 02:04:44.810, Speaker C: We'll see you next Thursday, same time.
