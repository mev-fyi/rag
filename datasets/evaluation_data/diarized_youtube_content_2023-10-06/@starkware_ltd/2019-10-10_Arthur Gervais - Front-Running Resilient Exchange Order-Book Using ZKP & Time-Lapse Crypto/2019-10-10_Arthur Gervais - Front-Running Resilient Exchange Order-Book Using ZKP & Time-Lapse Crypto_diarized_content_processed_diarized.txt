00:00:05.740 - 00:00:30.250, Speaker A: I want to invite Arthur Gervais to the stage from liquidity network. He is? Yeah, let's give him a hand. He's going to be talking about. He's actually going to be talking about a solution, kind of, to the problem that Martin had already outlined, focusing on how you can prevent front running using zero knowledge proofs and time lapse. Time lapse cryptography. Cool.
00:00:31.980 - 00:01:26.452, Speaker B: Thank you very much for the kind introduction. That's like rather a broad intro because the prior two talks, I think, summarized the topics very well. But financial exchanges are really at the heart of our economy and speed matters. And what we see in the traditional world is we have these very centralized operators here that have custody of their funds. So over the last centuries, there was no alternative actually to use to trade significant volumes, but to go over these centralized custodians on a very high level. Financial exchanges 101 is an exchange is built out of two components. So we have a trade matching system and we have a trade settlement system, and this really is the exchange in a very simplified manner.
00:01:26.452 - 00:02:06.900, Speaker B: So if you look at Ed Martin's talk previously, he explains how to do this without a central entity, which is really amazing. But here we're looking in this talk, we're going to focus still on an operator model where we have an order book. So this is an exchange architecture. Let's assume here we have two traders. So there's Michaela, she has some black coin. There's Jackson, he has some white coin, and they would like to trade these coins. So Michaela puts in an order, I would like to sell this black coin and get a white coin and the same done by Jackson.
00:02:06.900 - 00:02:36.812, Speaker B: And then the matching system can say, great, I have two matching orders. I can forward them now to the trade settlement layer. So the trade settlement here just switched the trades. You see, the trade was executed on the settlement layer. So what could possibly go wrong? Martin thankfully already mentioned very well front running resilience or front running issues. So there are actually many different things that can go wrong in exchanges. And it's really fun.
00:02:36.812 - 00:03:20.030, Speaker B: You can go to the New York Stock Exchange website. They have a compilation of all the kinds of issues. So it seems traders in the last decades have become very creative on different malficiencies. Within this talk, we will focus on front running primarily, and it's defined as when you enter into an equity trade on option or futures contract with advanced knowledge of a block transaction. So like a large transaction, and you're aware that basically you're entering into this trade will influence the price of the underlying security. And your only intention here is to capitalize on the trade. So you're aware your order will or your trade will change the price and you're trying to capitalize on that change.
00:03:20.030 - 00:03:53.960, Speaker B: That's actually forbidden by the SEC. So according to yes, your law. And traders are not allowed to act on non public information in general, which spans across insider trading, to trade ahead of customers lacking that knowledge. So it should be public knowledge. So now some might argue, well, if you do front running in a blockchain, these transactions, they are broadcasted everyone knows about, right? So it's like transparent. So another malficience is wash trading. This is where you can create beautiful gardens.
00:03:53.960 - 00:04:45.972, Speaker B: And here you can see we have analyzed some blockchain exchanges on chain exchanges. And you can see some addresses are trading with themselves, creating beautiful flowers. So the talk will be mostly about front running. Just to give you some example that there are many other different security issues in exchanges. In particular, if you're looking at blockchain based exchanges, the question we should ask ourselves is, so who is actually the adversary? Who is the malicious entity that we're dealing with? There is a blockchain miner, there's an adversary trader like your other traders. Some financial traders say, well, trading is like a war, right? You're going to war, and it's always like a jungle, like Radalia says, and you really have to fight. So your opposing traders are kind of your opponents here or the operator.
00:04:45.972 - 00:05:39.850, Speaker B: So if you're not having a dutch auction model like Martin presented, then you're probably dealing with some centralized operator here who might or might not front run your trades. Why is that a problem? In reality, nowadays, most crypto exchanges are not regulated, so the regulators haven't yet caught up with regulating what is good and what is bad behavior. Moreover, it's really hard to detect bad behavior, and you can almost never prove it. So it could be that you have an exchange that offers you zero trading fees, but maybe they just capitalize on your trades by front running them constantly. So there are potentially millions of us dollars in damages every year. And one recent study by Diane that I'll try to quantify for on chain exchanges how much front running practices there are. So it's an excellent paper I recommend you have a look at.
00:05:39.850 - 00:06:35.208, Speaker B: So let's look at the trade matching engine first. So, trade matching engine is really just an older book where you collect bit and asks, and Michaela here, for example, wants to buy a certain asset, and Jackson wants to sell a certain asset at a certain price. So there's a certain spread here because they haven't yet matched to agree on a trade. In this talk, we will be looking at two order book models. So you can either put the order book on the server side or on chain on the blockchain. So the advantage of putting the order book on the server side is that you have a fast matching, right. There's no fees for canceled orders, there's no censorship resistance, however, so the exchange can choose to not accept your orders.
00:06:35.208 - 00:07:04.064, Speaker B: And there's exchange fund running. So here the adversary is the exchange operator, who can designate a certain order to your income and trades. If you go with the onchain model, well, you do have great censorship resistance is fairly robust, right? I mean, your broadcasting is to the world. Everybody has your traits. However, you have slow matching. You need to pay blockchain fees for every order, even if they're not fulfilled. And now you're having a different set of adversaries.
00:07:04.064 - 00:07:48.832, Speaker B: You're having the miners and the adversary traders. So miners can just reorder within a block or sensor, as was discussed earlier. Or the traders can pay a higher gas price or high transaction fees in general to prioritize their transactions and try to front run you. We will discuss the trade settlement layer, but we will focus on noncustodial trade settlement layers. And there are two models that we could think of. So there's an off chain model and there's an onchain model again. So by off chain, I'm referring here to the broad set of off chain techniques that are out there whereby you can perform a transaction off the blockchain, but it's secured by the blockchain.
00:07:48.832 - 00:08:31.548, Speaker B: We published a paper recently of trying to summarize the state of the art and off chain solutions. And I mean, the field is progressing so fast, so there might be a few that have basically come up since then. So if the trade settlement is on chain, again, we have censorship resistance. It's fairly robust, but it doesn't scale and it's quite slow, which is bad in financial exchanges. As was discussed earlier, you don't want to be the slow exchange because otherwise the fast exchanges are profiting off you. There are blockchain fees for each order and minor trader fund running. If you do the settlement off chain, it's fast and scalable.
00:08:31.548 - 00:09:18.864, Speaker B: There are typically no blockchain fees, no minor trader front running, but you don't have censorship resistance, and the exchange operator could front run. So, as a summary, this is kind of the design space that we are looking at within this talk. There might be further options, like the dutch auctions that we saw earlier. So for the purpose of our exchange tax, the trustless exchange, we settled with this architecture. So a server that maintains an order book and an off chain protocol trade settlement protocol that I will go into details later. So what about the server exchange trade matching system? So here we can see, well, it's good because we're quite immune to front running from miners and traders. So those bad guys are gone.
00:09:18.864 - 00:09:53.128, Speaker B: Right. However, now, well, the server can front run our orders. So we will talk about this now in the front running resilient order book. So by resilient I mean almost immune. It can probabilistically detect front running if you're willing to take certain assumptions. It's actually robust. So the underlying idea that we had to build such a front running resilient order book is to have a commit and reveal protocol for limit orders.
00:09:53.128 - 00:10:42.920, Speaker B: Our goals was that it's difficult to dos the exchange. We want to hide the order content before the exchange commits to an order so that the exchange actually doesn't know anything about the trade information like what coin I'm buying or what asset I'm buying, what volume or selling. But the exchange still needs to know that an order is valid before committing to an order. Sounds like a perfect use for zkps. The faster the exchange commits to a particular order, the better, because then we know that likely there was no front running. And this is where we came in with a moonwalk order. So in order to prevent front running, we're using moonwalk orders, which are composed of a zero knowledge proof, the encrypted order, and a timelock puzzle.
00:10:42.920 - 00:11:35.340, Speaker B: So why do we need the zero knowledge proof? The zero knowledge proof proves that the order is a valid order and that I'm allowed to spend this amount of assets or buy this amount of assets. The encrypted order is basically just the order contents in an encrypted form that the exchange can decrypt with its timelock puzzle. So the timelock puzzle allows the exchange to decrypt an order after time t in case that the trader doesn't reveal the appropriate key. So let's go into the protocol and see step by step how this would work. So we have here Michaela, the trader. We have a trade matching off chain settlement system on the server that by default would not resist front running from the operator. We have here parent chain, a blockchain, and a smart contract.
00:11:35.340 - 00:12:11.770, Speaker B: So Michaela creates this moonwalk order with the ZKP encrypted order and a timelock puzzle. She then sends this order to the exchange. So that's an encrypted order. The exchange doesn't see the contents of the order, and the exchange has a Merkel mountain range of existing orders. So it will append this new order to the Merkel mountain range and send the commitment of this MMR back to Michaela. So now what Michaela can do. She can measure the round trip time it took for the exchange to send this order back.
00:12:11.770 - 00:12:52.116, Speaker B: The faster the exchange came back, the less likely the exchange was actually attempting to solve the timelock puzzle. That would allow the exchange to look into the encrypted order. If MickEyrea is nice, she will reveal the key. And once this happens, the exchange basically allows Michaela to resubmit a new order. So that's one DOS protection mechanism here for the exchange, whereby the exchange only allows the trader to submit a new order if the trader revealed the prior key. So what's interesting here is Michaela can repeat this. She can actually test the exchange multiple times.
00:12:52.116 - 00:13:41.780, Speaker B: And you can just do this for very small orders and always measure this delta t the time that the exchange takes to respond. And if you know how much time it would take with the best computational hardware that you're aware, to decrypt a timelock puzzle, if you're aware of the round trip time, the network latency to the exchange, you can roughly approximate whether or you can guess whether the exchange attempted to front run your order or not. So, front running here would require the exchange to change the Merkel Martin range commitment. And this Merkel Martin range commitment is checkpointed at regular intervals to the on chain smart contract, where Michaela can prove malficians later on. So it's almost about building trust. So you have an operator. He can decrypt the order in t seconds.
00:13:41.780 - 00:14:21.730, Speaker B: If it takes Michaela t seconds to receive back the receipt of the Mooch mountain range, then front running can happen. Doesn't have to, but can. So Michaela would basically issue k fake or small orders to build up trust here. If the exchange would do anything malicious, then we can always resort to the on chain smart contract and challenge the operator. And, for example, there can be a slashing of a certain deposit or some other actions are possible. So we don't specify this. What about the trade settlement layer? So, now we looked at the order book, but once we have found two matching trades, we want to settle them.
00:14:21.730 - 00:14:51.572, Speaker B: So which off chain solutions do we want to look at? There are many solutions out there. I think the broad categories would be channel networks and commit chains. So commit chains, for example, they are fraud proof based, validity proof based. There are a lot of solutions out there. We settled with nocast because we develop nocast. And Nocast also has a zero knowledge version. So if you're looking also at real world systems in production.
00:14:51.572 - 00:15:22.452, Speaker B: So on the one side there's lightning, but we couldn't really see how to do atomic trades or to build a decks on the lightning network here. And there's the liquidity network, who implements and runs the nocast protocol in production since March this year. And you can see real traffic on this network. So roughly on a high level. I just want to give you a glimpse of what a commit chain is. And there are many variations of this, so it is quite cool. The design space is really large.
00:15:22.452 - 00:15:55.648, Speaker B: You basically have a blockchain, you have a central operator. The central operator commits an off chain state in typically a constant sized checkpoint or via snark, stark, et cetera. And there are a certain set of off chain transactions or swaps or tummy swaps that happen off chain. And basically here the operator would commit at regular intervals. These can be small or larger. It's really just a parameter like the block size or the block time interval in a layer. One blockchain, depending on the design you specify here, round or eon size.
00:15:55.648 - 00:16:24.260, Speaker B: And your users might be required to come online to verify the integrity of those checkpoints. It really depends on the specific design that you're looking at. In Nokia specifically, we have. This is the key innovation. It's a Merkel interval tree, where each account is represented as a balance. Where we have an active and passive tree whereby a user can be offline to receive a payment or even a swap. So in the case of tax, two traders.
00:16:24.260 - 00:16:57.528, Speaker B: So two traders that want to match a trade, they don't have to be online at the same time to match the trade. That's a very important requirement. You don't want users to be required to traders to be online at the same time for their trades to match nocas. ZKP is an extension to nocus, which adds your knowledge proofs to this checkpoint. What we're using is a recursively composed. Recursively composed proofs. So the idea here is that we could potentially enable a distributed ZK miner.
00:16:57.528 - 00:18:07.752, Speaker B: So instead of having one central operator who does this big giant proof, which is computationally very expensive, we could outsource this to a set of miners. And this would actually add to decentralization, because then the central operator would depend on the collaboration of those individual miners xeno lodge proofs reduce a few attack vectors that would be otherwise possible. We currently evaluated the gas cost is about 500k pre EIP one one eight, and by a factor of five smaller post EIP. So because we have fraud proof based, the commit chain can be halted. So what could happen if the exchange does something malicious or is being dossed for a continuous amount of time? So in any case, if it doesn't render its service properly, a nocus commit chain can be halted. So this means some trades would be reverted. In the trading world, this is a bit less tricky than in the payment world, because in the trading world you would get basically your prior assets in the payment system.
00:18:07.752 - 00:19:02.600, Speaker B: This should be mostly insured, but this can be fixed by providing collateral for instant finality. Still, the proofs are quite computationally expensive to be performed. So on the right side you can see the wallet of liquidity network that already is on the play store and App Store on mainnet. And on the left side you can see a mock up of text, but you can already try the Rinkbee version. It's online text liquidity network. Basically, you can send funds from the mobile wallet to the exchange near instantly and then trade on the rinkby network on the exchange. So we really see this as being a layer where you can build up your decks or your particular wallet and enable it to be more scalable.
00:19:02.600 - 00:19:28.310, Speaker B: The full details are published in those two papers, so if you have any questions, we try to be as precise as possible. And we know there are so many subtleties that it's really hard to explain them very well. But I think it's very important to have this open research and details such that anyone can build such systems or extend them and build better ones. So thank you very much. I'm happy to take questions.
00:19:37.180 - 00:19:41.160, Speaker A: Yeah, just make your way over to the race.
00:19:44.000 - 00:20:03.040, Speaker C: It's working. Thank you very much. Arthur. One question regarding the moonwalk orders. So when the user wants to prove that he has the right amount of balance and he can actually execute the trade, he proves it according to what mean? How does he prove that he has enough balance?
00:20:03.380 - 00:20:48.690, Speaker B: Yeah, that's an excellent question. So the front rowing resilient order book and the trade settlement layer are not that decoupled as I presented them in the slides. So in our case, we actually mix the information of the trade settlement layer with information of the exchange order book. Ideally, it would be great if even some centralized custodial exchanges could use the front running resilient order book design, but then they wouldn't be able to include probably, I mean, probably would be trickier to include a proof that a trader has a certain balance to be executed. In our case, we mix the information of the trade settlement layer and therefore have access to this data.
00:20:50.260 - 00:20:51.010, Speaker C: Thanks.
00:20:52.820 - 00:21:09.850, Speaker D: Thank you. I was wondering if, when a trader realizes that they might be being front run because of the responses being too slow, is that limited to just subjective knowledge or is there some way that they could prove this? Or have you thought about that kind of a thing?
00:21:11.020 - 00:21:43.010, Speaker B: Right. So here we are really trying to detect, in the first instance, to detect front exchange, the trader receives a receipt. The head of the Merkel Martin range from the exchange. And that's a commitment, that's a non reputable signature that the trader gets. If the exchange would then commit on chain non compatible checkpoint, then there's actually cryptographic proof that there was front running.
00:21:44.100 - 00:21:48.310, Speaker D: Yeah, sorry, my question was about the, because my understanding is that.
00:21:51.480 - 00:21:51.956, Speaker B: The front.
00:21:51.978 - 00:22:06.650, Speaker D: Running detection is coming from the delay. Right. So let's say I'm always getting slow responses. That just means that I'm going to avoid trading there. But have you thought about how to prove it to other people that they should also avoid trading there?
00:22:07.500 - 00:22:21.070, Speaker B: I mean, if you have a signature from the exchange on a certain Merkel Martin range, and the exchange does not commit to the same one later on, then you do have a proof that you can show to others that the exchange actually performed front running.
00:22:21.920 - 00:22:22.670, Speaker D: Okay.
00:22:27.440 - 00:22:30.270, Speaker B: Hi, I think there's another question over here.
00:22:31.780 - 00:22:45.860, Speaker E: Just one question. Why is it important to prove that the order is valid? I mean, what would be the issue if someone just submits an order and then it's kind of encrypted and it turns out that they don't have enough balance, but it's just ignored.
00:22:46.360 - 00:23:25.616, Speaker B: Right. This exchange is not directly, I believe at least the further measurements and studies should show this. I don't believe it's suitable for high frequency trading, because if a trader does not reveal a key, then the exchange is forced to open up the time lock. Right. So this might take at most time t. The good thing is if many traders are kind of trying to dos the exchange at the same time, then the exchange can parallelize the decryption of these time lock orders. So your question was why would we prove or why would we try to.
00:23:25.638 - 00:23:31.910, Speaker E: Yeah, basically why it's necessary to prove that this order is valid. I mean, would it hurt to.
00:23:32.280 - 00:23:52.910, Speaker B: It basically reduces the number of attack vectors for the exchange. Okay. Yeah, that's the main reason. Right. So there might be other ways to reduce those vectors. Yeah, but zoonological proof verification is very quick, so doesn't hurt. I mean, it's more work on the client side to prove that it's actually a valid order.
00:23:53.440 - 00:24:34.410, Speaker F: Hi. Do you see any other things that are required from the regulator, such as front planning, as market conduct, for example, spoofing, watch trading, publishing of Libor. All of this exists already in the trading right. And currently, by the way, from the regulator, the responsibility is from the action, not from the exchange to mitigate that, but from the one that is, for example, big banks, to take action upon that. Do you see any action that is currently being taken by the regulator or it's still in?
00:24:35.340 - 00:25:04.830, Speaker B: I have not seen any action so far. I really see this kind of solution. I see it as a competitive advantage for exchanges today, for just being honest before the regulators even come in. But I haven't seen any actions. And I can only speak for Switzerland for swiss regulations. For example, if you're a non custodial exchange, then you're not even subject to AML KYC laws. Okay, thanks.
00:25:06.120 - 00:25:18.770, Speaker A: It all right. There's actually a little bit more time if anyone has any more questions. No. All right, so then I guess we'll move it up. We're going to start catching up on time. Thank you.
