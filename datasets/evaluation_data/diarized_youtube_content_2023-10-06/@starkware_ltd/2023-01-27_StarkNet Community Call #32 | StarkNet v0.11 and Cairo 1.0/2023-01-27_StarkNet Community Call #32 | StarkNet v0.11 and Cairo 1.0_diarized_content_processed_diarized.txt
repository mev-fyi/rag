00:00:00.170 - 00:00:00.574, Speaker A: Actually.
00:00:00.692 - 00:00:46.714, Speaker B: All right, and one, two, three. And we're live. Hi everyone, and welcome to this Orceeri community call. It's not the usual one we do, but it's a special one, actually, a really special one. I'm joined today by a bunch of people, which I'm going to present a bit later on. But amongst them I want to say that we have Tom and Ariel from Starkware's product team, and we will talk about version zero point eleven. And we have Gal, who has been the organizer of this call, actually, and we are joined also with a bunch of builders from the space.
00:00:46.714 - 00:01:54.334, Speaker B: The goal of this special community call is to present the upcoming version zero point eleven of Starknet to the world, so that we can detail what is in it, what is not in it, how people should prepare for it and answer any remaining question. The goal also is to basically make sure that everybody understand what zero point eleven entails, because it's going to be the first version on which the first version upgrade of Starknet, on which token holders will get the opportunity to vote, which is an amazing milestone when you think about it. We've been talking about decentralization for a while. This is one of the first. I mean, this is one more concrete step in that direction. So I think, gal, you will explain the process exactly how this vote will mean. Do you want to explain it now? In a few seconds.
00:01:54.334 - 00:01:55.838, Speaker B: Gal, how will this vote?
00:01:56.014 - 00:02:00.450, Speaker C: I think this question is probably for Manor or Devin or Sylves.
00:02:00.790 - 00:02:01.250, Speaker D: Yes.
00:02:01.320 - 00:02:05.060, Speaker B: All right. So, Sylvie, do you want to explain Manor? Are you here?
00:02:05.910 - 00:02:07.214, Speaker D: But he doesn't have a voice.
00:02:07.262 - 00:02:13.670, Speaker A: I'm here. Sure, but my voice. You can go on. And if I will join?
00:02:14.170 - 00:02:16.994, Speaker E: Yeah, I can quickly just explain a bit about the below council.
00:02:17.042 - 00:02:19.482, Speaker A: Right? Yeah.
00:02:19.536 - 00:02:40.880, Speaker B: Okay, so because you're right when I say token Holder seems vague, who will actually vote on this upgrade will have delegates. Right? People who submitted their profile as delegate will have the ability to vote with the votes that were delegated to them, as well as the builders console. And we have a large number of people from the builders council present today.
00:02:41.250 - 00:02:41.950, Speaker D: Yes.
00:02:42.100 - 00:03:02.120, Speaker E: So folks, happy to see you all in the first call together. Feel free to ask any question that you have. I know a lot of you have already reviewed the documentation or were in the previous community call, so feel free to shoot if you have any question or anything else. Don't be shy and get ready for a vote in the coming month.
00:03:05.130 - 00:03:12.220, Speaker B: How do you get ready for voting, Silva? Like, where will this proposal be published? How will the vote actually happen?
00:03:12.830 - 00:03:24.090, Speaker E: Vote will be held most likely inside a call like this. I set up another safe right now. Currently I'm just a one of one. I'll probably add a couple more people from the villa council just for availability.
00:03:24.170 - 00:03:25.678, Speaker D: Purposes, just to make sure that everything.
00:03:25.764 - 00:03:28.670, Speaker E: Runs smoothly when we actually have to vote.
00:03:30.130 - 00:03:34.174, Speaker B: But it's a nosis safe, a multisig.
00:03:34.302 - 00:03:58.486, Speaker E: Multisig on l one. Currently there's only my address in there. So once we do get the proposal for voting out, we'll reconvene again. In a call like this, everyone will have to do a bit of homework. Review the review, exactly what's the content of the release? Then we do a single vote like this, yay or nay. And then we just vote on the vault. I sig on snapshot to say yay.
00:03:58.518 - 00:04:00.410, Speaker D: Or nay as the builder council.
00:04:00.990 - 00:04:09.530, Speaker B: Fantastic. So let's start with the homework. Tell us everything, Tom, what is in zero point eleven?
00:04:10.770 - 00:04:58.970, Speaker D: Okay, thank you very much. As you said to me. Actually, I was very excited toward this call because everything else we do in general, the governance process is like processing slowly and in steps. But this is like a real first step, even though it's small towards not only decentralizing the protocol, but also the decision making and how we do stuff on Starknet. So yeah, I'm very happy. Having said that, I'm not here to be happy. So let me tell you a bit about what we have in store.
00:04:58.970 - 00:05:02.510, Speaker D: So I will share my screen. It's disabled.
00:05:03.570 - 00:05:08.880, Speaker B: I always need to say, yes, you can go ahead. Yes, you can go ahead now.
00:05:09.250 - 00:05:14.420, Speaker D: Yes. Okay, great. So I'm sharing my screen. Can you see it?
00:05:16.070 - 00:05:17.154, Speaker A: Yes, we can.
00:05:17.272 - 00:05:53.418, Speaker D: Okay, great. So I will give a bit of a context to where zero point eleven lives, like in the broader roadmap or timeline of Starknet. And then Ariel, go deep into the details and once we understand where we are, we'll explain how zero point eleven try to achieve its purpose. Okay, soundcrew okay, so this is basically the context. Today we are somewhere here. At the beginning of the month, we released like the first usable version of Cairo, Zero of Cairo one. Apologies.
00:05:53.418 - 00:06:53.490, Speaker D: And actually today it was not yet tweeted, but it is out. We have another version of Cairo, one released. And if you want to be amazed, just go to the release notes and see what has been done in the last three weeks. It's really mind blowing. But the nice thing about the released version today is that you can write, compile and test the ERC 20 contract. So go check it out. But we are today, and hopefully by the end it was supposed to be a bit earlier, but as it seems right now, by the end of the month of next month we'll have a Starknet alpha zero point eleven where the goal of this version is basically to add Kyle one compatibility into Starknet and in the wider context of our roadmap, why we want that, we want that in order to start as soon as possible what we call the transition period.
00:06:53.490 - 00:07:49.486, Speaker D: The transition period is basically the ability of builders and application developers to start migrating their code from Cairo Zero to Cairo one, and during this period to port it, to audit it and then to actually deploy it. And then after we finish, or the ecosystem as a whole finish with this process, somewhere in the future we'll have the regenerates. So this is the context. Now I want to dive a bit deeper into the roadmap and the priorities and then go back to it and hopefully it will give a bit more context. Okay. Was not supposed to be an animation, but if you remember I discussed it I think almost three months ago in this bone. What are the current priorities for Starknet as we see them at least? So the first and foremost is the performance.
00:07:49.486 - 00:08:27.966, Speaker D: And actually the latest version, zero point 10.2 added the optimistic parallelization which gave a good enough improvement to the dire needs of Gerley and Mainet. And even though we're not in a place where we think is good for Starknet, it is good enough for the time being. And indeed in the next version, not zero point eleven, but zero point twelve, there are plans for much bigger improvements. Right. So I don't know if you've seen but earlier this week, maybe it was yesterday, times flies by but we released or we open sourced the sequencer. Right.
00:08:27.966 - 00:09:24.370, Speaker D: So in zero point twelve basically the module that we've open sourced yesterday will be integrated into Starknet. This is for a different community call for builders and delegators. But basically this integration will combine together three very important components which I hope will give a major improvement to the performance. So one is the actual transaction execution that was released yesterday, two is basically the underlying state manager or the full node that stagnate sequencer will use will be replaced with a much more performant one. And this is papyrus which we released earlier this month. Also the Cairo execution will be replaced with the Cairo RS project by Lambda class that is already live and working in few of the development tools for a couple of weeks now. Okay, so this is performance.
00:09:26.550 - 00:09:33.700, Speaker B: Can I interrupt you a second? There is a question in the chat from Nicola about timeline. Nicola, do you want to open your mic?
00:09:34.710 - 00:09:52.060, Speaker A: Yeah sure. It was just too much. I mean what we are being said here with a bit more detail than what we had on the other call. So on the other call I heard, I think, 00:11 and Testnet for mid February and regenerates three or four months later. So that was just too well to see if you have the same perspective on that.
00:09:53.310 - 00:09:53.770, Speaker C: Yes.
00:09:53.840 - 00:10:02.814, Speaker D: So I'll get to a genesis in two bullet points and then I will answer that. So just 1 second.
00:10:02.852 - 00:10:06.970, Speaker B: Okay, perfect. Sorry, I thought it was about timelines, which we addressed just before, but let's.
00:10:07.050 - 00:10:07.822, Speaker D: Go back to them.
00:10:07.876 - 00:10:08.480, Speaker A: Thanks.
00:10:09.730 - 00:10:44.730, Speaker D: It's all about timelines anyway. So the second is to get as soon as possible a stable version of Cairo Zero that is feature compatible with Cairo. Apologies, Cairo one that is feature compatible with Cairo Zero. So as I've said, we released another version today which gets us one step closer to it. And the existing milestone is to reach the feature parity with old Cairo. And now we get to do a regenerative nicola to what you've asked. So as I've said, the transition period begins with stagnet zero point eleven.
00:10:44.730 - 00:11:36.266, Speaker D: Yes, we hoped it to be on testnet by mid February. I think we'll only manage to have it by mid February on integration and then one or two weeks after that on Garly. So it's around that time and the transition period will end basically, and this is what we call the Regenesis, when the ecosystem will finish with the migration, which I really hope it to be three to four months. But I don't want to give hard timeline where we haven't actually started with this process. So if in three months we'll see that no progress were made, or in three months we'll see that everyone already did a migration, then we can get the decision there. But yes, I suspect it will be between three to four, five months. Or this is what I hope.
00:11:36.448 - 00:11:52.366, Speaker B: I have a question regarding Regenesis. Is Regenesis, what is Regenesis? Is it when Cairo zero code becomes deprecated, or are there any other actions like, I don't know, block numbers going back to zero? Something like that?
00:11:52.548 - 00:11:56.290, Speaker D: Okay, so you're asking what will happen here at the Regenesis? Right?
00:11:56.360 - 00:11:57.650, Speaker B: Exactly, yes.
00:11:57.720 - 00:12:58.982, Speaker D: So the first thing that will for sure happen is that Cairo zero contract will no longer be executable, right? So if a transaction will try to call a function in a Cairo zero class contract, right, so the OS will fail the transaction and basically the sequencer will still be able to get paid for it, but we won't do execution on Kyle zero contracts. So this is one thing. What we also want to do is to remove the old blocks of starknet for many good reasons. And there is a subtle question on how we not break backward compatibility with events or transactions that are stuff like that. So we still need to find or to come up together with the best solution here. But those are the two motivations or.
00:12:59.036 - 00:13:03.302, Speaker A: Things we want to do in the regenerative thank you.
00:13:03.356 - 00:13:20.250, Speaker B: And then in the chat, Julian asked, will zero point twelve come before Regenesis or after? So I'm guessing you mean before the end of Regenesis? And Ariel answered before. So yeah, there will be various darknet versions before the end of Regenesis. Is that accurate?
00:13:20.910 - 00:14:17.550, Speaker D: Yes. So 0.2 is already in the works in parallel, and it's actually making very good progress. So I hope it won't be long time after zero point eleven that we'll see zero point twelve, because it's actually working on the rust sequencer and working on the integration with Python, but it's almost completely orthogonal to what we're trying to achieve with zero point eleven. Okay, so this is the context. If you have more questions around that, I'll be happy to answer. If not, I will hand it to Ariel to do a deep dive into zero point eleven to understand how it will achieve starknet compatibility with Cairo one, or what needs to change or adapted in starknet in order to be able to declare, deploy and run Cairo one contract.
00:14:17.550 - 00:14:21.040, Speaker D: Okay, great.
00:14:21.410 - 00:14:42.470, Speaker C: I have one question about the planned repo structure, if you can go back to the previous slide. So right now Cairo is both the name of. It's like one repo where both Cairo the language and starknet the system live. So can you talk a little bit about what's planned for the repo structure throughout the transition period?
00:14:43.210 - 00:16:01.082, Speaker D: Yes, I wouldn't couple it directly to the transition period, but generally until I think the Cairo Rs, the Cairo VM in rust was the first external repo to Cairo length that had a component of Starknet that was part of the main infrastructure that the developers used. But in general, the aim for us is to at some point deprecate the existing Kyolang repository and to have each of the, I think, five components that currently lives under the same repo being independent repo that is developed in a public open source repo, right? So the sequencer, which parts of it are now lives in Cairolang, is already starting to live in its own repo. Same for the Cairo VM. The compiler is already now in a different repo. Right. The Cairo one lives in a different repo. We have the Starknet OS and Starknet L one contract, so they need to be moved also to an open public repo.
00:16:01.082 - 00:16:07.474, Speaker D: And the last one, maybe Ariel, I remember we said five, but maybe we.
00:16:07.512 - 00:16:12.610, Speaker A: Had contacts, we had the sequencer, we had the VM compiler.
00:16:13.190 - 00:16:23.960, Speaker D: Yes, and the CLI. Right. Currently the CLI also lives in the same repo and there's no reason for it to be there. Does that answer the question?
00:16:24.330 - 00:16:25.080, Speaker A: Yes.
00:16:25.450 - 00:16:42.080, Speaker C: And another question. You kind of touched on it before, but I think that it's important to make it very straightforward. So when is going to be the date where people are going to be able to start reimplementing their apps in cryo one? And how much time would they have to do it?
00:16:43.410 - 00:17:59.454, Speaker D: Okay, so being able to deploy and run contracts on startnet is together with zero point eleven. The features that you specifically need for your specific contract depends on what exists there. So, for example, yesterday I talked with Marto from open zeppelin, and hopefully with the release today, they will already be able to start looking into their ERC 20 contracts and start migrating them. Right. But once we reach here, and again, I hope that we'll reach here actually quite close to zero point eleven because zero point eleven has been a bit delayed. So once we reach here, there will not be a contract that you can't migrate to Cairo one. So I encourage basically every developer to once we have zero point, even today, but specifically once we have zero point eleven to start looking at, I think most of the code that exists today will already be migratable and then how much time we have.
00:17:59.454 - 00:18:36.220, Speaker D: So this relates to what Nicola asked. So basically the transition period is we have a goal, but we won't do it when we see that parts of the ecosystem haven't migrated. So I think we should aim to something like four months, but I think we should also let the builders and the developers start doing it and seeing if our estimations are correct or not. Okay, any more questions?
00:18:39.680 - 00:18:44.990, Speaker B: Where can we find a list of things that are missing? The feature parity list for Cairo one.
00:18:46.880 - 00:18:55.280, Speaker D: In the Cairo one repo. But I actually need to update it, so do it only in the evening.
00:18:55.700 - 00:18:57.330, Speaker B: Okay, thank you.
00:18:59.940 - 00:19:03.830, Speaker D: Okay, Ariel, go ahead.
00:19:04.520 - 00:19:07.990, Speaker A: Okay, so let me just share my screen as well.
00:19:10.680 - 00:19:17.464, Speaker C: And actually, sorry. In the meantime, another question. Where is a good place for people to discuss Cairo one?
00:19:17.502 - 00:19:18.090, Speaker A: Issues?
00:19:21.180 - 00:20:22.830, Speaker D: Great question. So I think that for small questions or beginner questions or stuff like that, we open the Cairo one discord channel. And I think this will be the best place if there are some either bugs or major feedback or requested feature, then the GitHub either issues or discussion is the good place for that kind of discussion, but for immediate support then the Discord channel is the best place. Both Enri and his team will, as the time goes by, will be there more and more. And currently the compiler team also monitors it and answer questions. So this is a good place to start and hopefully soon builders will be able to answer one another. Okay.
00:20:24.560 - 00:20:25.310, Speaker A: Just.
00:20:27.600 - 00:20:36.576, Speaker D: I missed the last part is the latest carol is out today. Is there you in 256 support? Yes and yes, you can see it.
00:20:36.598 - 00:21:49.560, Speaker A: With your own eyes. Okay, thank you. Okay, so I'll start going over the details of the changes expected in eleven and the exact motivation for those changes. This page is part of the startnet docs, so all you need to do dive into this list in more details is go to the Startnet versions section and check out the upcoming startnet versions page. And feel free to stop me with questions anytime. Okay, so like Tom said, the big addition with Starnet Eleven is the introduction of Cairo one into Starknet. So far it's existed separately, but in eleven you will be able to start declaring classes that were written in chiro one and deploying contracts, having those classes, and actually running Chiro one code as part of parknet.
00:21:49.560 - 00:22:53.768, Speaker A: Okay, so there's actually a lot going on behind the scenes in regards to Chiro 1.0. It is more than a more convenient syntax and richer language for writing smart contracts, but it is actually a crucial element for having DOS protection in starknet. Okay, so essentially the issue is that now not all transactions can be proven. If you have, for example, an assert instruction in your contract and a specific transaction hits an assert one equals two instruction, this transaction cannot be added to a proof. We cannot say that this transaction failed provably, which means we cannot provably charge fee. We cannot say, okay, we executed this transaction for 100 steps. We're eligible to take fees.
00:22:53.768 - 00:23:51.996, Speaker A: Sequencer is eligible to take fees 100 step off of fees. So this is not something that can be done today. And this is why we introduced the error, which is an intermediate representation between Cairo 1.0 and Cairo assembly. So right now, whenever a user writes in chiro zero, this compiles to Cairo assembly, and this is what is sent to the startnet sequencer from Startnet eleven. While this Cairo zero still continues to operate as before, and you can continue to work with them until the Regenesis. But for Cairo one, once a user writes Cairo one, he will then compile it to this intermediate representation, which we call Sierra safe intermediate representation.
00:23:51.996 - 00:24:50.640, Speaker A: This is what is going to send to the starnet sequencer. So the actual class structure is going to change. It will now consist of Sierra instruction, and the sequencer will compile the Sierra to Cairo assembly. And the very important property that we want to achieve here is that Cairo assembly generated from Sierra can always be proven. The compiler from Sierra to Cairo assembly does not generate not nice Cairo assembly that sometimes cannot be proven. So the canonical example that I like to hold in my mind in this respect is instead of asserts do ifs. So the Sierra 2000 compiler won't put asserts for you, but he will use if else instead.
00:24:50.640 - 00:26:12.552, Speaker A: This is a vast oversimplification, but I think it's a very useful example into understanding how this compiler will behave. Okay, so that's a first significant change that now instead of sending Cairo assembly to the stagnet sequencer, Tierra will be sent. And by changing this structure, this means that we're going to need a new declare transaction, which is what the declare v two transaction is all about, sending a different type of contact classes who consist of Sierra instructions rather than Cairo send. There is much more to say about this and we'll dive into what declare v two means. But any high level questions about the purpose of Sierra in this effort. Okay, then I'll continue to discuss declare v two. You see all the regular fields from the standard declare transaction version max three signature non sender address, which is the address of the account contract.
00:26:12.552 - 00:26:19.260, Speaker A: Sending the transaction. I haven't detailed here the specifics of the new class structure.
00:26:20.580 - 00:26:27.680, Speaker D: Yes, maybe before diving into the declare, go over all the changes that entails.
00:26:28.740 - 00:27:09.208, Speaker A: Okay, so I'll briefly list them. In addition to this new declare transaction, we have a change in the way the state commitment is computed. We'll get to that later. There are some changes in the on chain data sent to l one. So right now the state diffs between each block are sent to l one to guarantee data availability. So the specific format of those state will slightly change. We will introduce a new system call called replace class.
00:27:09.208 - 00:28:00.380, Speaker A: This system call will allow taking your Cairo zero contract, which already has a rich state in it, and allow you to replace its underlying cluster while keeping the address and storage. So this is how you'll be able to maintain significant state, especially on Mainnet. When we move towards regenerative. The replace club is crucial for that purpose. And there are a bunch of API changes both on the stagnet side, on the feeder gateway and on the full node JSON RPC. That are related to mostly to the introduction of the new class structure and the Sierra object, but those are detailed under the API changes section.
00:28:01.680 - 00:28:09.760, Speaker B: Ariel, we have a question for the replace class. Ash, do you mind if we answer it now? Yes you mind or no you don't mind?
00:28:09.910 - 00:29:09.584, Speaker A: No, I don't mind and I just saw the question, so I'll repeat it. Can I use replace class multiple times? So the answer is yes, we don't limit it. And in fact this can be the de facto new way to implement the proxy pattern. Obviously this isn't mandatory, but while we thought of this mechanism for the purpose of maintaining your address and storage towards regenesis, we realized internally that it can also be used for regular upgrade and it can be a nicer mechanism than what were used with the proxy pattern. And it's all a result of the separation between contracts and classes that we have on Starknet.
00:29:09.712 - 00:29:56.372, Speaker B: It's actually quite interesting because I think initially when we talked about this Cisco, we said, oh, it's going to be available just for Regenesis. But now we're thinking, wait, maybe this is useful. It's kind of native proxy. It's one more example of things where we figure out things are useful. After seeing how things goes on Ethereum, Darlington in the chat is saying, wait, but for upgradable contracts you only need it for the proxy. And it is true you can update your proxy with it, but with this Cisco you can have a new kind of proxy, you can implement proxies differently. And I'm sure Martin here will have a lot of ideas on how you can implement this.
00:29:56.372 - 00:30:16.376, Speaker B: Martin is saying rootstock had an idea of having a native upgrade at Cisco. I'd be interested in seeing how this panned out. But you can basically instead of having deploying a proxy and having your implementation separately, you could basically inherit proxy functions or import proxy functions inside your smart contracts, for example.
00:30:16.558 - 00:30:42.516, Speaker D: Yes. So actually we will have to decide as a community if we want to keep originally we thought about it as syscall only for the regenesis and to remove it from the os afterwards. But we might want to consider to keep it and this is clearly open for discussion. Interesting.
00:30:42.618 - 00:30:57.832, Speaker B: Martin is saying, I think there wouldn't be a proxy at okay, oh, so this will be an interesting discussion for a future community call. Maybe, but okay, I think we answered the question. Thanks, Ariel, please go ahead.
00:30:57.966 - 00:31:42.900, Speaker A: I agree, definitely whether or not we want to keep replace class is an interesting discussion. And how exactly will proxy pattern which utilizes replace class we look like? Because we need to have concrete design for properly discussing this. Okay, so these are the high level changes. I think the biggest change is the new declare transaction. So I'll try to go over it briefly. The important parts at least. So we already discussed the new class structure, which is now the error instruction.
00:31:42.900 - 00:33:08.396, Speaker A: But you will notice here another field that doesn't exist in the current v one declare transaction, which is the compiled class hash. So what is it? This compiled class hash is the hash of the Cairo assembly, which results from compilation of the contact class. Now the Sierra object to Cairo assembly. So the user wrote Cairo one, compiled it to Sierra, sent this to the sequencer, but he will also compile this result again to generate Cairo assembly, add the resulting hash to the transaction, and sign on this data as part of the declare transaction hash. Why this is important and why did we add this field to the transaction? So the long term plan for Sierra is to have the compilation from Sierra to Cairo assembly as part of the pool. So the way to guarantee that all contracts in the system are nice, that no one somehow managed to inject a malicious contract to startnet that allows dosing the sequencer. The way to prevent this is to have every declared class provably compiled from Sierra to Cairo assembly.
00:33:08.396 - 00:33:55.650, Speaker A: So because you know that the compiler is audited and satisfies the desirable properties, and the proof will tell you that the deployed contract, its class, is indeed generated from this nice compiler. But this is not yet the case today. Today this compilation happens on the sequencer side and is not proven. So the user needs a way to couple the code that will actually be proven to what he's sending. So if I'm sending this, and this is hopefully what's defining the semantics that I wanted. For example ERC 20. Here I have my transfer logic, my allowance logic, and everything I wanted.
00:33:55.650 - 00:34:50.908, Speaker A: But what gets proven on every block is actually Cairo assembly execution, because that's what we know how to prove whenever a proof is involved. We're talking about Cairo assembly execution. So the sequencer will actually prove stuff about this. But if the user doesn't ratify and says okay, that's actually the Cairo assembly that I mean for you to execute, then there's effectively trust on the sequencer. So in order to have this very important coupling. In the meantime, while compilation is not part of the OS and is not proven, we needed this extra new field. And that's maybe the biggest change in the declare v two transaction.
00:34:50.908 - 00:34:54.368, Speaker A: I saw a bunch of questions on chat.
00:34:54.544 - 00:35:16.490, Speaker B: Yeah, basically people answered it, they were answered, but let's do it. Also for people on YouTube is declare v two for Cairo one declaration only, and Thompson yes, it's only for Cairo, one contract. I got an extra question from what you explained, ariel, can we expect one day that the ABI will be proven also?
00:35:18.880 - 00:36:21.356, Speaker A: That's a good question. Since we don't have a nice encoding in mind for Abis, and it is effectively JSON, we don't think that we'll be able in the proven compiler which will be written in Cairo. The plan is to actually write the Sierra to Cairo assembly compiler in Cairo, and that's how we're going to prove it. So we don't imagine this compiler to deal with the JSON serialization and that sort of stuff. So the way to overcome this is to do something similar to what we do today, that the contact class will contain inside it the ABi, and the ABI will be part of the class hash. So you can say nonsense in this ABi, but it will be coupled to the class hash. It will be a way for the person declaring to couple an ABI to this class hash.
00:36:21.356 - 00:36:31.520, Speaker A: And if he hopes others to use it, you will probably want to put an API that makes sense there, one that is consistent with the actual compilation.
00:36:32.260 - 00:36:33.570, Speaker B: All right, thank you.
00:36:38.840 - 00:37:36.490, Speaker A: Okay, so that's declare v two. A few words on the transaction flow. So the sequencer gets this transaction. What he does is compiling first running validate declare, just like today, to make sure this declaration is valid, this signature is valid. If the transaction turned out to be valid, properly signed, then he will compile this class and make sure the resulting compiled class hash matches the one given by the user. If this is not the case, then the sequencer is eligible to charge fee for this transaction. Because this is effectively treated as a DOS attempt, you tried to cause the sequencer to basically run a bunch of compilation which don't match what you said they are supposed to match.
00:37:36.490 - 00:38:49.128, Speaker A: So putting nonsense in this compiled class hash, in addition to not providing guarantees that the actual proven code corresponds to what you sent, it, will also mean that fee can be charged for this compilation attempt. Okay, so the high level flow is the sequencer. Get it? Run, validates declare, compiles the class and make sure that it matches the one provided by the user. Okay, so with that we'll pass declare v two and maybe last a final word on Sierra. Is that the way to think about it is that now the startnet class semantics is reflected in the Sierra code. So when you're calling a contract or deploying a new contract, which means when you're using the library call system call or the deploy system call, you're specifying the class hash. You're referring to this object, and you're never talking about the compiled class hash.
00:38:49.128 - 00:39:08.150, Speaker A: The compiled class hash only exists for proving purposes, but the semantics is encoded in this object. So if I want to deploy a new instance of this class you just declared, I'm specifying the class hash, not the compiled class hash. Okay.
00:39:10.120 - 00:39:25.690, Speaker D: Because it's a bit different from what we have today. So it's good to make sure that it's clear. I can give another example on how this can be used. Maybe it will clear stuff, maybe it will make it more complicated. So what do you want me to give it?
00:39:27.420 - 00:39:28.232, Speaker A: Go for it.
00:39:28.286 - 00:39:29.880, Speaker B: Rodinger's explanation.
00:39:30.220 - 00:39:30.970, Speaker D: What?
00:39:32.880 - 00:39:34.428, Speaker B: No, please do.
00:39:34.594 - 00:39:54.160, Speaker D: So can you go back to the declared transaction? Yes. SRVL said the contract class, which is basically a Sierra code, actually defines exactly the semantics of the class, and then how we can use it. This notion of this separation notion.
00:39:56.280 - 00:39:56.596, Speaker A: We.
00:39:56.618 - 00:40:37.280, Speaker D: Can have it be compiled to Cairo if we want to prove it, but we can have it be compiled to something which is more efficient to run on x 86 if we want to only execute it in the sequencer, for example. Right? So you can imagine a compiler from Sierra to LLVM, which is something that few teams in the ecosystem have started exploring to allow more efficient sequencing. And this we can do it because we have the separation or this decoupling between what we actually need for proving and what actually defines the semantics of the class. So I hope it helps.
00:40:39.620 - 00:41:20.044, Speaker A: Yeah, I'll say maybe a few more words, because this is a delicate point. So Cairo is only needed for proving. If we didn't want to prove things, we could have just executed rust. So Cairo was invented and developed for the sole purpose of being able to prove computation. The sequencer who's producing blocks and actually all the developer tools who are running startnet contracts don't really care about proving. Or the sequencer can be decoupled from proving. It can be someone else's responsibility setting.
00:41:20.044 - 00:41:53.880, Speaker A: So if the semantics are encoded in this object, you can treat it directly. However, in the coming months at least there is no Sierra two LLVM execution. So the way to execute your contract would be to compile it to Cairo assembly and use Cairo VM implementations to execute it. But in the future you may not need this extra compilation step. Maybe I also added more confusion.
00:41:55.340 - 00:41:56.890, Speaker D: Let's ignore it and continue.
00:41:59.360 - 00:43:15.136, Speaker A: Okay. State commitment currently, the way the state commitment works is we have one global tree, similarly to Ethereum, where the leaves are essentially storage routes for each contract, for each contract which encode the storage of the contract itself. After eleven, the starknet state commitment will consist of two trees, one the state one corresponding to the contact states, exactly the same as the tree today, and the other corresponds to the classes which exist in the system. So we're going to construct a tree from the key value pairs where the key is the class hash and the value is the compiled class hash. And this will be part of the state commitment. So every time you declare a cairo one class with the declare v two transaction, you're changing the state commitment by adding this pair to the classes tree and changing the eventual state commitment. Who's now the hash of two different routes.
00:43:15.136 - 00:44:13.940, Speaker A: So we have the global state tree, same as today, but we also have the classes root. So every declare affects this classes route. Okay, that's the state commitment. Why are classes needed in the state root? Why weren't they needed before? Very good question. Okay, were they needed before? The answer is that the code itself was present before, because the leaf of this tree also contained the class hash. And every time we executed a contract as part of the proof, we made sure that the class we're using corresponds to the class hash that appears inside this tree. That we're not inventing arbitrary code and running this instead of what you intended.
00:44:13.940 - 00:45:02.950, Speaker A: But you are correct in that there was no coupling between declarations and the state previously. For example, up until now, if I only declared a class and didn't deploy a new instance of it, this information was not reflected in the state commitment. And this is effectively a mistake. You do not want this behavior. This can cause a bunch of confusions around the sequencer. Being familiar with a bunch of classes while a full node isn't having the classes well defined in the commitment solves every ambiguity. Everyone know exactly what classes are part of the starknet state.
00:45:02.950 - 00:45:51.876, Speaker A: And with Chiro one classes, we're starting afresh. So old classes that are eventually not going to be accessible after the Regenesis, they are still not going to be part of the commitments. But new classes, new Cairo one classes that are added by declare v two from day one, they are going to be part of the commitments. Does this answer the question? Okay, good. Okay, replace class. So maybe the other heavy change in this version, the system call that allows you to replace your class. So I think the easiest way to see it is by an example.
00:45:51.876 - 00:46:53.140, Speaker A: So this is the Chiro zero contract. I have two external function swap and get price. I have no idea what this does, but get price is called inside swap three times, twice in an inline manner, and once via the call contract system call, and as you can see, between the first and second get price call, I'm using the replace class system call. So the way this will work when I call swap is that here get price from the existing class will be used. No surprises here. I'm calling get replace class and assuming this class was previously declared, I'm transitioning my class. If this class was not previously declared, then I'm failing.
00:46:53.140 - 00:47:51.900, Speaker A: At this point, let's assume it was. This get price call will still use the old class implementation because we are concluding the context that we were executing. So far, calling replace class doesn't magically take you away from what you're currently executing. We thought this would be a more reasonable behavior for the execution flow. But if you will call your contract via the system call and not in an inline manner, then the new implementation will be called. So in this example here and here we're using the old class, but here we're using the new class. And this will work assuming the new class also has a get price method.
00:47:51.900 - 00:48:05.490, Speaker A: So that's the flow of replace class. I saw there's a bunch of questions there. I'm not sure if they're about replacement, or about.
00:48:09.140 - 00:48:24.630, Speaker D: Questions about the need for the state commitment for adding the class to the state. And what change with Cairo one that made us do this change and not do it before.
00:48:26.380 - 00:48:28.810, Speaker A: Okay, did we answer it?
00:48:30.300 - 00:48:35.290, Speaker D: I think I don't know. I wrote some sentences. I hope they answer.
00:48:36.800 - 00:49:02.152, Speaker A: Okay. If they didn't, then let us know. Okay, so I'm continuing with replace class. So this is how it's going to work. And the proposed mechanism by which you're going to replace your class is the following. And note this only works for upgradable contracts. So suppose your contract is upgradable.
00:49:02.152 - 00:49:55.316, Speaker A: Then on the implementation side you have no problems. Once you re implemented your logic in Cairo one, you declared the class and you sent a regular declare transaction. This is not a problem, but how you are replacing the class of the proxy itself, which is a Cairo zero class, and it is the one with the interesting address and the interesting storage. So the proposed flow consists of the following steps. First step, you work on your Cairo one implementation and proxy. Okay, so now you have the Cairo one proxy class ready. Now you can upgrade the implementation to a one which has the replaced class system call in it.
00:49:55.316 - 00:50:44.692, Speaker A: Okay, so now you've upgraded the implementation. The proxy is still a chiro zero class, but the implementation has replace class logic inside it. Now you're calling this logic that you recently added, which makes use of the replace class system call. So this is a transaction to the proxy and that's it. Now your class is replaced and you're ready for the regenessis. And I see a question on get price does not use the new class hash yet. Okay, so the reason we're not really.
00:50:44.746 - 00:50:46.150, Speaker D: Repeat the question please.
00:50:46.680 - 00:51:47.252, Speaker A: Yes, sorry. So the question is why exactly this uses the old implementation while this uses the new implementation. Okay, so there are two parts to this answer. One, the trivial one, is that the current way system calls work, it's much more natural to have other system calls use the new class. So if I called this system call before this one, then the later system call will know about the changes from the previous system call. But the other reason, which I think, at least to me makes more sense, is that I don't want to break the current flow eventually. This call is effectively a jump.
00:51:47.252 - 00:52:39.880, Speaker A: I'm doing stuff inside my currently running code and I don't want to overload this. I don't want to hurt the current execution stack. While system calls, they live on a different flow. So here I'm allowing you to conclude the current execution, but later system calls will know about the changes from older system calls. I hope this helps. Yes. Okay, so there was a question about the replacement mechanism.
00:52:39.880 - 00:53:59.330, Speaker A: After I follow these steps, does the upgrade to the proxy class happen with the replace class call that lies on the implementation class? Then yes, that's exactly how it happens. The implementation class has the replace class logic and this affects the class of the proxy contract who calls it. And yes, you can also later remove this upgradability feature by replacing to a class that doesn't have it. Actually, I need to think a bit more about it. If you want that, make sure that your current proxy contact no longer has upgradability mechanisms. I think this requires taking this offline and actually writing down the contract. But thinking about it for very briefly, I think that the answer is yes, that it can be done.
00:53:59.330 - 00:54:15.370, Speaker A: And I see there are a bunch of more questions, but we're also running out of time. So Henry, how should we approach this?
00:54:17.340 - 00:54:19.290, Speaker B: I'm sorry, can you repeat the question?
00:54:19.740 - 00:54:23.130, Speaker A: We have a bunch of more questions, but we're running out of time.
00:54:24.220 - 00:54:27.436, Speaker B: I have time. I don't mind taking a bit more.
00:54:27.458 - 00:54:35.468, Speaker A: Time, so I may have to drop and Tom will because you have someplace to go.
00:54:35.634 - 00:54:36.590, Speaker B: I see.
00:54:38.160 - 00:55:20.418, Speaker A: But let's try to cover the question so far. Automatically proxy one. It's not clear that replace class upgradability cannot use proxies. You'll be upgrading the proxy and never the implementation. So it doesn't make any sense to have a separate implementation. I'm not sure I understand. Do you maybe want to ask this via mic? Can you hear me? Yes, yes.
00:55:20.418 - 00:55:22.246, Speaker A: It wasn't a question, actually, Cory, it.
00:55:22.268 - 00:55:25.042, Speaker D: Was a comment that since the replace.
00:55:25.106 - 00:55:29.986, Speaker A: Class being called from the proxy will be replacing the proxies class, then that's.
00:55:30.018 - 00:55:36.026, Speaker D: A new appraisability mechanism that it doesn't require any implementation. If you had an implementation contract, you.
00:55:36.048 - 00:55:38.710, Speaker A: Would be always upgrading the proxy implementation.
00:55:38.790 - 00:55:47.370, Speaker D: So you don't actually need an implementation contract. So what I'm saying is that this is really pattern without a proxy scheme.
00:55:47.450 - 00:56:29.580, Speaker A: It's a single contract that upgrades itself. No proxies. It was just. I'm using the term proxy contract loosely because even today the mechanism in stocknet uses one contract and two classes, the class of the proxy and the class of the implementation. There are no two contracts involved ever since we moved to the direction of separation between contacts and classes. So I don't think it's different in that sense. But yeah, if I made it sound like there are two contacts going on, then yes, that's not how it's going to look like.
00:56:32.350 - 00:56:54.580, Speaker B: It sounds like it's going to be one of those things in crypto where we designate something by a name that isn't accurate. We're going to be calling this proxy pattern when what you're saying, martin, is that this is not a proxy, it's native replaceability or something. It's something else. It's not a proxy, but it achieves the same functionality, meaning being able to upgrade your code. Is that correct?
00:56:55.990 - 00:57:17.260, Speaker A: I agree, it is, yes. Maybe proxy now becomes not an ideal name, but I think that in the near future what people will be looking for is how do I implement proxy in. So ZK proxy is a nice name.
00:57:18.830 - 00:57:21.450, Speaker B: Maybe it's not a proxy.
00:57:25.250 - 00:57:27.040, Speaker A: But it's a fancy name.
00:57:28.050 - 00:57:29.680, Speaker B: It has decay in it.
00:57:30.450 - 00:57:50.260, Speaker A: Okay, I have to move to a different corner, so I will let Tom take over. We basically covered, I think, the heavy lifting of o eleven. What's remaining is the IPI changes that accompany what we've discussed so far.
00:57:53.050 - 00:57:54.710, Speaker D: Okay, thank you, Ariel.
00:57:55.290 - 00:57:56.280, Speaker A: Thank you.
00:58:01.130 - 00:58:24.960, Speaker D: Can you stop the screen share? So I'll take a look? Thank you. Let me see where it is. And. Yes. Okay. Can you see my screen? Okay, great. Yes, sir.
00:58:24.960 - 00:58:54.120, Speaker D: I'm really excited, so just please take a look at the release notes of the last three weeks on the Cara one repo. It's really nice thing to see. Okay, now back to our version. Okay, great. So we finished with the replace class. Cisco, do you see or do I need to increase it? Is this okay?
00:58:55.070 - 00:58:57.290, Speaker B: No more please, bigger.
00:58:57.870 - 00:59:04.634, Speaker D: Okay, how is that now?
00:59:04.672 - 00:59:05.500, Speaker A: It's good.
00:59:05.870 - 00:59:49.900, Speaker D: Okay, so we finished with the replace class, it's called. If there are more questions about it, then let's get back to it at the end. And as I realize the on chain data changes and the API changes and the JSON RPC changes are all basically to reflect those changes to how we treat class and compiled class and this duality. Okay. And also the on chain data will now have specific treatment to a replaced contract. Right. So I can go into the details, but basically everything is written here.
00:59:49.900 - 01:00:40.410, Speaker D: I don't think it's that important to go specifically into those details. Okay, the API changes. So again we added the get compiled class, basically returns the value under the class in the class estate and the get class by hash now return two different objects depending if it's a car one contract, car one class or not. Same for full contract. And in get state update there are a few changes. So one, there is an explicit new field that mentions classes that have been replaced, right. So it's basically an address and a new class hash.
01:00:40.410 - 01:01:21.190, Speaker D: And also to make it easier to populate the class estate, the declared contract is now split into all declared contracts, which basically contracts that use declare v one. Hopefully there won't be a lot, but there will be at least few in order to utilize the replace classes call. Yes, and small changes. Any other questions on those changes? I see there's a lot of discussion.
01:01:22.330 - 01:02:00.020, Speaker B: People saying they have to move, but aside from that there were a few questions on YouTube, but I answered most of them. Some people asked to go over the upgradability flow for Cairo one with the replace class ash, but everything is declared in the docs so I highly encourage you to go check it out. I've added the link in the video description and then one interesting question. Maybe people are asking if we're starting to develop an application today, should we do it in Cairo one or Cairo zero and upgrade later?
01:02:02.870 - 01:02:44.070, Speaker D: I know it's like the worst time to ask it, but yeah, I would tell you to start learning Cairo one and to start developing, I don't know, other parts of the applications which are not the smart contracts per se, because really like months from now hopefully it will be just possible to write everything in Cairo one. So maybe come to start with sessions, you have a week there, then spend the time to learn Kyro one, write the back end, the front end, and then at the beginning of March just finish with the smart contract and you can immediately deploy.
01:02:44.170 - 01:03:26.510, Speaker B: It's actually a good thing. I would encourage people to start working on the architecture of their application, like the business logic and maybe the front end, which won't change that much in the future, and then work on the smart contracts starting like if you start in two or three weeks you can get onto it directly with Cara one and if there are features missing by the time you'll need it, we'll have front run you and they'll be available. And we have Nicole asking maybe this is a question for another community call, but he heard there was a migration from Pedersen ashes to Poseidon in progress. Can we get an update on that? Is there any timeline? Because that might be an important change for constrained.
01:03:29.170 - 01:03:37.330, Speaker D: Yes Nicola, thanks for the question. So actually it is not written here and we'll update it as soon as possible.
01:03:37.400 - 01:03:38.020, Speaker A: But.
01:03:41.590 - 01:05:24.290, Speaker D: The new state with the classes and the new classes hash computation will transition to use Poseidon. So Poseidon is basically a stark friendly hash function that was developed a few years ago in an effort to find specifically hash functions that are efficient for stark proving or in general for validity proofs. And it's something like ten x more efficient on the proving side and also ten x more efficient on the x 86 side. So it is on both parameters better than the existing function Peterson so we in general want to transition starknet to use Poseidon now what we do now is that everything which is new, we edit with Poseidon, right? So as I said, new classes hash will be computed with Poseidon and implementations to Poseidon will be supplied both in Karolang and in the crypto CPP. And there's also Pathfinder are already working on rust implementation and also we already have an implemented Javascript implementation, an efficient Javascript implementation by Paul Miller. So it does exist. Apologies with regards to for example the transaction hash and the old state.
01:05:24.290 - 01:06:08.398, Speaker D: So this will, I think we want to have it as part of the regenesis. Again, it's a discussion that needs to be made. How do we do this transition? Do we do it in some trusted way that can be verified off chain? For example, just transition to use a new hash function and give the data and the script off chain to be able to verify it? Or do we do it via a validity proof? Right. Having a proof that says take this state, compute the commitment with Peterson, compute the commitment with Poseidon and see that you can do the transition. It's a very big proof. So we need to decide. I think this is mainly a community or ecosystem decision.
01:06:08.398 - 01:06:24.150, Speaker D: What is good enough with respect to trust. So I hope this answered the question by Julian Nicola, if not, let me mean you can also discuss it in great details next week in Starbucks sessions.
01:06:26.830 - 01:06:33.850, Speaker B: All right, so I think we covered most of what we wanted to cover today. Is that accurate?
01:06:37.080 - 01:06:38.404, Speaker C: I think it is.
01:06:38.602 - 01:06:42.248, Speaker B: Very nice. Okay, let's wrap it up.
01:06:42.334 - 01:07:12.800, Speaker D: Are not here, but maybe if they will hear it afterwards or for people who are here. So the purpose of this meeting was to go deep into zero point eleven, to allow the decision on the version to be made with more knowledge. So I would love to hear if this format helps, if it's good, if there are other ways you think we should do. It was the first time and I'm sure there are many ways we can improve.
01:07:15.220 - 01:07:44.664, Speaker C: And I also wanted to say that we encourage people to continue asking those questions, especially overflow. Maybe it's better for Henry to say it, but yeah, we have stack overflow, the community forum discord. We'd love to have people ask technical questions and questions about the architecture starting going forward. We have those discussions not just in those community calls.
01:07:44.792 - 01:08:07.668, Speaker B: Absolutely. Get involved, ask questions whenever you need. And as Tom said, do let us know if this process makes you feel more comfortable with the upgrades coming in Starknet and you feel like you're informed enough to vote on them, because ultimately that's the goal. It's for you to decide. So get informed. All right, let's wrap it up. One final word.
01:08:07.668 - 01:08:25.240, Speaker B: Gal, you have a nice background stating that next week is starkware session in Tel Aviv. Everything is on the program. It's going to be a nice conference, Gal. Tom, can we get a recommendation? What is the one thing people need to eat during their week in Star wars sessions?
01:08:27.260 - 01:08:31.944, Speaker D: It's called Sabilabane. Sabilabane? Yes. Okay.
01:08:31.982 - 01:08:34.760, Speaker B: I have a colleague in Tel Aviv. I'll ask him where to get some.
01:08:34.910 - 01:08:35.380, Speaker A: Exactly.
01:08:35.470 - 01:08:39.580, Speaker D: I think Gal does not agree with me. He has maybe a more fine taste.
01:08:39.920 - 01:08:41.960, Speaker B: What would it be? Gal, what's your recommendation?
01:08:42.040 - 01:08:43.884, Speaker C: I honestly have no idea what Tom.
01:08:43.922 - 01:08:44.690, Speaker A: Just said.
01:08:48.260 - 01:09:12.192, Speaker C: But you should know that literally two of the top five restaurants in Israel are 50 meters from the conference venue. I'm not going to say their names, so that you'd have to work a little bit before all the spots are taking over there. But yeah, some really good food around the conference venue in Tel Aviv.
01:09:12.336 - 01:09:18.950, Speaker B: Amazing. All right, so I hope we'll see a lot of people there. And thank you for attending our call today.
01:09:19.640 - 01:09:21.848, Speaker D: Until next time, bye.
