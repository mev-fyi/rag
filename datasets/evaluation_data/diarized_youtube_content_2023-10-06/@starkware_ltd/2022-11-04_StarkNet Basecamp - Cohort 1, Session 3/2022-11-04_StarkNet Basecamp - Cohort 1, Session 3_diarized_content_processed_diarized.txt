00:00:00.570 - 00:00:01.120, Speaker A: It.
00:00:03.810 - 00:00:09.440, Speaker B: By the way, your video seems to be frozen, at least on my side.
00:00:10.370 - 00:00:13.402, Speaker C: Okay, I'm going to rejoin.
00:00:13.546 - 00:00:14.480, Speaker A: One sec.
00:00:19.460 - 00:00:26.076, Speaker B: Okay, so we're streaming to YouTube. We have 14 participants waiting for Ben.
00:00:26.108 - 00:00:44.308, Speaker A: To come back and we have a.
00:00:44.314 - 00:01:34.018, Speaker B: Question in the chat. This might not be included related to today's event, but if you can answer, great. How's your knowledge ensure in? Okay, we have to wait for Ben to answer those questions and I'm going to enable subtitles before I forget as well. Lives transcript okay, that should be on now. Just a few minutes. We get Ben back and we can start the third session of basecamp. By the way, stagnatc happened over the weekend, actually now happened over Monday and Tuesday.
00:01:34.194 - 00:01:35.458, Speaker A: And I think you can watch the.
00:01:35.484 - 00:02:16.926, Speaker B: Recording of the session as well on YouTube if you want to learn a little bit more about some of the talks that were given there. All right, Ben's back.
00:02:16.948 - 00:02:20.026, Speaker A: I can see your camera now, Ben.
00:02:20.058 - 00:02:31.240, Speaker B: I think we are set. So I'm just going to switch to send an email to remind people of the zoom link. And we have a question in the chat if you want to take a look before you start.
00:02:35.610 - 00:02:49.580, Speaker A: For some reason I can't see chat. Can you just ping chat maybe since I wasn't here. Oh, here we go. Okay.
00:02:52.350 - 00:03:17.694, Speaker C: So this may not be completely related to today's event, but if you can answer it, that would be great. How zero knowledge is insured in one when there is an if else condition with the if having heavy computation and the else having only else only having a small computation, wouldn't that show which path the program took based on the input?
00:03:17.742 - 00:03:20.850, Speaker A: I read somewhere that it builds traces.
00:03:20.930 - 00:04:00.180, Speaker C: For both the conditions, but now couldn't find where I read that. And two, what happens for a loop? Okay, so we'll start with one, it sounds like the question is in regards to an attacker deriving the path of execution based on how many steps the conditional branches take. And it sounds like what you're saying is, aren't we throwing away privacy if we know that, if we know the steps that one branch took, and we know that those steps are longer.
00:04:02.790 - 00:04:03.106, Speaker A: And.
00:04:03.128 - 00:04:47.618, Speaker C: The answer is it doesn't matter the way that our validity roll up and the way that the conditional works in Cairo has nothing to do with privacy, it just enables the scalability that we get from the stark proof. So yes, it will have a longer step count if one of those if else branches has longer computation to run, but it doesn't matter because we don't care if we're divulging that to an attacker or someone looking from the outside, because we're not enabling any privacy. Does that answer that question? The answer to it is yes. Someone could tell by the amount of.
00:04:47.624 - 00:04:53.586, Speaker A: Computation one branch took that another branch wouldn't have.
00:04:53.688 - 00:04:56.100, Speaker C: You can tell which branch it took.
00:04:57.670 - 00:04:58.514, Speaker A: Okay.
00:04:58.712 - 00:05:26.080, Speaker C: And then for loops, the way that we enable loops is with recursion. There's going to be a nice syntactic sugar version of loops in Cairo 10, but right now you need to do all your looping mechanisms with recursion just because we're proving each iteration of the function call. And that's how we have loops for now.
00:05:28.720 - 00:05:30.636, Speaker A: Is there a branch repo where we.
00:05:30.658 - 00:05:33.420, Speaker C: Can see the Cairo 10 development?
00:05:36.640 - 00:05:38.024, Speaker A: That's a good question.
00:05:38.162 - 00:06:07.836, Speaker C: I don't believe that it's open right now. I think it's just being developed internally. There's some good blog posts on it. Shibin, have you seen the blog post on Cairo 10? Okay, I think that's all that's available for now. And then it's just being developed in house. Yeah, Cairo 10 is going to be really exciting. The syntax is going to look a lot more rust.
00:06:07.836 - 00:06:34.960, Speaker C: Like everything's going to be a little more rust based. The whole two tool chain is going to be a little more rust based. Yeah, Cairo 10 should be pretty awesome. Prashant says, is it only me who doesn't see questions? Yeah, Prashant, I wasn't able to see questions until I jumped back on and they were reposted. Maybe if you leave and hop back on, it'll come back up and populate.
00:06:35.460 - 00:06:35.824, Speaker A: Cool.
00:06:35.862 - 00:06:36.960, Speaker C: Thanks for joining.
00:06:37.540 - 00:06:48.996, Speaker B: Also, the issue is that when you post a message on the chat, make sure to use the option everyone, and not just host and panelists, because otherwise only Ben will be able to see the question, not the rest of the people in be.
00:06:49.098 - 00:06:54.404, Speaker A: That could be it. Cool.
00:06:54.442 - 00:06:59.930, Speaker C: David, thank you for getting this set up. You can drop if you need to.
00:07:01.180 - 00:07:02.184, Speaker A: I'll leave this running.
00:07:02.222 - 00:07:10.780, Speaker B: I'm just going to step out, but just because I'm streaming, I'm just worried if I leave the stream will cut out. But I will not be here. Just, I will leave it running.
00:07:10.930 - 00:07:12.430, Speaker A: Okay, sounds good.
00:07:17.330 - 00:07:24.450, Speaker C: I'll repost Shivan's question. Are you able to see that prashant?
00:07:37.660 - 00:07:50.190, Speaker A: Can someone also just ping and make sure that they can see my screen? Okay, great. Cool.
00:07:50.500 - 00:08:01.810, Speaker C: Thanks for joining for camp three. Session three. Today we're going to go over Starknet. That's kind of what we're all here for.
00:08:02.340 - 00:08:13.590, Speaker A: So we are going to go over Starknet. Let me just make sure I'm all up to date here.
00:08:18.940 - 00:08:21.160, Speaker C: Can you guys see that slideshow?
00:08:24.900 - 00:08:28.850, Speaker A: Okay, cool.
00:08:29.380 - 00:08:40.870, Speaker C: So yeah, just some administration stuff out of the way. How to graduate. We've already gone over this, but in case you're joining for the first time, a wallet, an argent wallet, or.
00:08:42.760 - 00:08:43.088, Speaker A: I'm.
00:08:43.104 - 00:09:15.840, Speaker C: Blanking a Bravos wallet with all of the Cairo 101 points, all of the messaging bridge points, and all of the starknet account points. You can actually disregard this for now. This account tutorial just recently was deprecated with the most recent upgrade of the network from zero ten zero to zero ten one. So don't worry about this one. And then Starknet educational related smart contract or pr to base camp or tutorial. One thing I wanted to highlight.
00:09:19.460 - 00:09:25.620, Speaker A: Make sure I'm sharing my whole desktop.
00:09:28.600 - 00:09:32.970, Speaker C: One thing that I wanted to highlight is we had just recently a pr.
00:09:33.820 - 00:09:39.050, Speaker A: That got merged in and I wanted to show it to you guys.
00:09:55.840 - 00:10:00.750, Speaker C: If you haven't pulled base camp recently, please pull it again.
00:10:03.200 - 00:10:06.988, Speaker A: Do I have anything actually?
00:10:07.074 - 00:10:09.310, Speaker C: Sorry guys, don't pull it yet.
00:10:09.720 - 00:11:16.910, Speaker A: It all right, looks like I already pushed those. Let me just double check it. Sorry guys, one secret.
00:12:03.890 - 00:12:10.000, Speaker C: Okay, sorry about that. Okay, so we're going to look at some code that was pushed just recently from.
00:12:12.290 - 00:12:20.970, Speaker A: Let me get this right, Remy.
00:12:21.630 - 00:13:01.320, Speaker C: No, Shebin, Shebin, who just asked that question, he just pushed this proof of work example. Proof of work example in Python. So he added to the primer directory, we got the CD proof bitcoin proof of work in Python. So he's added to the readme, added to the documentation for proof of work example. And then here's the python for that. And he followed the subdirectory structure, so coding language underneath the concept. So proof of workpython main py and then we can come in here and see.
00:13:17.270 - 00:13:24.394, Speaker A: Primer bitcoin proof of work Python his.
00:13:24.432 - 00:13:44.560, Speaker C: Python script documented with what each function does, each function definition does. And so he gets the nonce and gives us an idea of what proof of work looks like in Python. If you want to run it, follow his code.
00:13:46.870 - 00:13:48.980, Speaker A: Sorry guys, I'm all over the place today.
00:13:52.550 - 00:13:55.458, Speaker C: CD proof of work Python Python main.
00:13:55.544 - 00:14:06.390, Speaker A: Py Primer bitcoin Python three main py cool.
00:14:06.460 - 00:14:54.822, Speaker C: So we see on my local laptop, on my local machine, I'm mining, I'm trying to get the nonce at some seed value that's been decided on by the protocol that's obviously stubbed out at this point. But we're just basically given a good idea of what proof of work looks like, and how that actually looks like in code. Yeah, hopefully that kind of solidifies the concept to anybody. That's a Python developer. There's also one from me for go. But again, if you're a rust developer, c plus plus, really anything. We'd love to see all these subdirectories populated with all of the programming languages that people are familiar with.
00:14:54.822 - 00:15:05.660, Speaker C: And so this also applies to the camps, camp one, camp two, camp three. It'll also be broken out by its programming language. But yeah, thank you for that.
00:15:06.110 - 00:15:08.620, Speaker A: That's a great addition to the code base.
00:15:11.950 - 00:15:33.460, Speaker C: Yeah. He says I should have reduced the mining difficulty. That's okay. That's another cool part of those scripts, is that it gives you an idea of what can be changed, what the config values are. You can put print statements in all of these, see exactly where things are happening.
00:15:34.150 - 00:15:52.060, Speaker A: Let's see where the difficulty is. Difficulty $5. Um.
00:15:58.360 - 00:16:00.150, Speaker C: Oh, sorry, I went the wrong way.
00:16:00.680 - 00:16:01.092, Speaker A: Yeah.
00:16:01.146 - 00:16:25.164, Speaker C: So we can take it down to difficulty two. And yes, you can see that if we lower that difficulty, if the protocol agrees on some difficulty that's really low. Obviously not as low as the beginning of bitcoin. It's fairly not compute. Heavy to compute that. Proof of work.
00:16:25.282 - 00:16:26.350, Speaker A: Okay, cool.
00:16:26.720 - 00:17:01.824, Speaker C: We will jump into our session today. So we will do a quick recap of camp two, session two, where we went over Cairo. And again, feel free to kind of jump into the chat with questions. I think you can also raise your hand. We can try that today. If you do want to jump on and ask a question verbally, we can go ahead and do that. So Cairo is a practically efficient turn complete stark friendly cpu architecture.
00:17:01.824 - 00:17:45.120, Speaker C: Again, quite a mouthful. When we said practical, we meant Cairo supports conditional branching, memory function calls and recursion. Efficient is a construction of the airs such that we are building a Turing machine that doesn't take to the ends of the earth to operate it and to execute it. So we have some efficient instructions set that we can run our business logic on. Our arbitrary business logic on Leor, a member of Starkware just had a tweet the other day that he said one set of polynomials to rule them all. And so I think that's a pretty good analogy. One set of polynomials to rule them all, one set to find them, one set to bring them all and in the darkness bind them.
00:17:45.120 - 00:17:55.620, Speaker C: It's kind of a cool way to think of Cairo. One thing we didn't touch on last time is a fact registry pattern.
00:17:57.480 - 00:17:57.892, Speaker A: Under.
00:17:57.946 - 00:18:55.880, Speaker C: The hood of what the sharp is actually writing is that it's writing facts. And so what do we mean by facts and how do we use them? So, once we have a verified proof of the program execution, we have this fact registry. If you are writing raw Cairo, again, we're not writing outside of a paradigm that we're not proving. So we need this prover and verifier concepts, and then we want the verification of that program execution to be available somewhere. That's really the whole point of Cairo code is for the verification of this logic to be available somewhere. So we have this fact registry pattern, and it's the same way that our core contracts work, which we'll get into today. But just to see kind of at an empirical level how this works, we're going to check it out.
00:18:55.880 - 00:19:13.660, Speaker C: So from this diagram we have Cairo code execution, and then we send the trace to the sharp, the shared prover. The prover proves to the verifier written in solidity on Ethereum layer one, that that execution was done correctly, and it writes a fact.
00:19:13.730 - 00:19:16.690, Speaker A: So what is a fact?
00:19:18.660 - 00:19:42.200, Speaker C: Yeah, and then anything can check that that fact exists. I believe we did this last time. We went through the sharp, the shared proverb, how to communicate with it, how to interact with it. We have Cairo compile builtins Cairo, and we compiled our Cairo program and then we submitted to the sharp. When we submit to the sharp.
00:19:44.860 - 00:19:45.128, Speaker A: The.
00:19:45.134 - 00:20:19.396, Speaker C: Shared proverb batches a lot of different program traces and executions together so that we can get an efficient proof to l one. If we were proving every single execution that the sharp got, that would be pretty expensive as we have to write some of those values to l one in call data. So it batches up a lot of those proofs, which makes it much more efficient to run the sharp and to run the prover. So that's when we get this job key. The job key signifying that, hey, we.
00:20:19.418 - 00:20:35.800, Speaker A: Might not have written this specific fact. I know I promised you to tell you what a fact was. Proof of work, Python.
00:20:37.340 - 00:20:40.970, Speaker C: So we'll head back to camp two for this.
00:20:48.620 - 00:21:03.344, Speaker A: Camp two sharp py fact check. Camp two sharp fact check.
00:21:03.542 - 00:21:31.384, Speaker C: Okay, so like we talked about last time, we have everything we need to have a deterministic hash of the Cairo program. We have the compilation output, which is the bytecode for it, along with any dependencies and then some debug info so we can get a deterministic hash of what that Cairo program is. And then we also have the CLI tool Cairo hash program, which will tell.
00:21:31.422 - 00:21:57.510, Speaker A: Us what that hash is. So Cairo hash program, I'm just going to come up here so we can work in two different spots, camp to built in Cairo. All right, we will.
00:21:59.640 - 00:22:01.350, Speaker C: Compile it one more time.
00:22:12.390 - 00:22:13.806, Speaker A: I got to be in my Cairo.
00:22:13.838 - 00:22:36.540, Speaker C: Dev environment, which includes the Python virtual environment. All right, so we have the compilation, which you should remember from last session.
00:22:37.120 - 00:22:39.090, Speaker A: So now we will grab the.
00:22:41.380 - 00:23:54.970, Speaker C: Hash of that program. Okay, so that's the deterministic hash of this compiled program, builtinscopiled JSON. So if we have the deterministic hash of that program. I know you guys all know what a hash is and what that means, but that's going to change if we change anything to the program. So this program will have a different hash, obviously. Okay, so what are we proving in this architecture of fact registry? We know we have the determinist hash or the program, but also what are we hashing it with? We're hashing it with another element which is the output of the program. So we have this hash which we got from hash program, and we have the program output 100, 203 hundred.
00:23:54.970 - 00:24:15.230, Speaker C: So we use the ketchack, the same ketchack hash that ethereum uses. And we can get this ultimate fact. We just do the program output and the hash of the program, and we can get this.
00:24:17.680 - 00:24:18.430, Speaker A: Fact.
00:24:23.300 - 00:24:30.130, Speaker C: Okay, so here's a hash. And what are we proving? We're proving that this exact program.
00:24:32.120 - 00:24:32.484, Speaker A: Take.
00:24:32.522 - 00:24:50.330, Speaker C: It back to where it was, this exact program output. This exact output. And the whole point of Cairo is that we can go and check it. So here is a verify on l one. This is the fact registry for the.
00:24:53.660 - 00:24:54.810, Speaker A: For the.
00:24:58.640 - 00:25:33.444, Speaker C: For the verifier. I'm just going to put this ether scan link in chat. So is valid. We have, this is valid fact and we're going to check the fact. So if we've submitted this, which we have in that example, we should understand that this fact is valid. And this goes into kind of the architectures we were talking about with grading a program. True, this exact program outputted exactly 100, 203 hundred.
00:25:33.444 - 00:26:14.084, Speaker C: And with hints in raw Cairo, we can inject hints so you can have things like a hidden input to this program, but then verify the output of the program. And that's how you would get an architecture that looks like, I think I mentioned it last time, where you could basically grade someone. You could have a test with a rubric and you could prove that someone either passed or failed that test without divulging the answers. And we can get that proof on chain and I can have an application on layer one that interacts with that fact, that piece of information and basically says the way I saw it would.
00:26:14.122 - 00:26:14.710, Speaker A: Be.
00:26:17.800 - 00:26:39.916, Speaker C: Proving competency on. Any questions, any questions on Cairo on fact registry patterns, Cairo in general, we're going to jump the rest of the day through starknet. So a bunch of starknet specific stuff. So kind of last call for Cairo. Questions.
00:26:40.018 - 00:26:42.270, Speaker A: Let me pop the chat back open.
00:26:43.040 - 00:26:49.360, Speaker D: There's a question from Carlos Colorado. Does the program state has any effect on the program hash?
00:26:52.020 - 00:26:54.320, Speaker C: Is it in Q A, Omar?
00:26:54.660 - 00:26:56.864, Speaker D: Yes, in open Q A.
00:26:56.982 - 00:26:57.648, Speaker A: Okay.
00:26:57.814 - 00:27:43.116, Speaker C: Yeah. Does the program state hash has any effect on the program hash? It will if you're thinking about what output you're proving. No. Okay, let me rephrase that. That's a good question. So does the program state have any effect on the program hash? Okay, so the program hash is not going to affect the program hash, but that's why we have the concept of the fact which uses the program hash. So not only can we prove that that exact bytecode ran, but we can prove that the program state ended with this as the output.
00:27:43.116 - 00:27:50.690, Speaker C: So it's not going to affect the program hash, it will affect the program fact or not the program fact. The fact.
00:27:53.880 - 00:27:55.430, Speaker A: Does that answer the question?
00:28:02.660 - 00:28:04.960, Speaker C: Assuming this is the fact registry.
00:28:06.740 - 00:28:07.104, Speaker A: Why.
00:28:07.142 - 00:28:08.628, Speaker C: Is it required to see that at.
00:28:08.634 - 00:28:20.740, Speaker A: Least one fact is registered in a registry? Assuming this is the fact registry, why is it required?
00:28:21.580 - 00:28:23.530, Speaker C: Okay, I'm going to go to that link.
00:28:24.300 - 00:28:37.246, Speaker A: Shiman, any fact registered? That looks like it's just almost like.
00:28:37.268 - 00:28:44.580, Speaker C: A validity check, like a sanity check just by just looking at it? That's what it looks like.
00:28:45.110 - 00:28:46.722, Speaker A: I don't think there's any better reason.
00:28:46.776 - 00:28:47.726, Speaker C: Off the top of my head that.
00:28:47.768 - 00:28:48.760, Speaker A: That would be there.
00:28:49.130 - 00:28:50.790, Speaker C: Any fact registered?
00:28:53.620 - 00:28:55.970, Speaker A: Yeah, looks like a sanity check to me.
00:28:58.500 - 00:29:00.608, Speaker C: I'll double check internally and let you.
00:29:00.614 - 00:29:12.856, Speaker A: Know if it's anything different than just a sanity check. Okay, great. All right.
00:29:12.878 - 00:29:18.076, Speaker C: If you have any other questions as far as Cairo internals go, you can.
00:29:18.098 - 00:29:23.390, Speaker A: Always just ping them out. Okay.
00:29:26.640 - 00:30:47.370, Speaker C: We'Ll head to our map. So we have clients, clients interact with sequencers by sending transactions well formatted to the sequencers right now, just operate in a FIFo, first in, first out, and they don't do any special sequencing, so there's no opportunity for extractable value there. That will be a topic of discussion once sequencers are open source and ran by the community and not just internally. One thing that you do have from us running the sequencers, just because it's a validity roll up, is that you can trust the validity just because you can trust the Cairo state machine execution like we've talked about yesterday, Starknet. So Starknet has Starknet Os written in Cairo, which we'll go over today, smart contracts written in Cairo, which is I'm sure what you guys are all here know we all love smart contracts. The ability to kind of compose and deploy all of these awesome, you know, anything that your heart can imagine. The cool thing about Starknet is that computation is cheap, so it enables this kind of cambrian explosion of different ideas that can be done at this layer two that were kind of cost prohibitive to be done at layer one.
00:30:47.370 - 00:31:20.800, Speaker C: A lot of the ideas I have are educational related. So people aren't going to, aren't going to. If gas is like 120 gwe, people aren't going to do like educational related resources on chain. That's something you could now do up at this higher layer, stark proverbs sharp. So we talked about that in the first session and then the stark core contract written in solidity and the stark verifier written in solidity. We actually are not going to touch on the verifier today much besides just that overview of the sharp.
00:31:23.080 - 00:31:23.588, Speaker A: Okay.
00:31:23.674 - 00:32:17.670, Speaker C: To give you guys a reworking of the transaction flow. So clients submit a transaction, sequencers include the transactions into a block, that transaction execution is proved to be valid and that proof is written to l one. And then we also need the state update written to l one so that we can rebuild the state of Starknet layer two from the data that's available on Ethereum layer one. And we'll look at that today. Okay, so Starknet, cool definition level setting. What is Starknet? Starknet is a permissionless, decentralized validity roll up, also known as the ZK rollup. We're trying to kind of deprecate our use of the word zk roll up.
00:32:17.670 - 00:32:54.720, Speaker C: Validity roll up is a much more succinct way of saying this layer two world has no concept of privacy. We're not hiding Waldo and his surroundings and proving Waldo. We're saying that all information is available on this layer two roll up. And all we're doing is proving the validity of the roll up. And the only thing we're doing is helping scale Ethereum at this layer two. We don't have anything to do with privacy. It operates as a layer two network over Ethereum, enabling decentralized applications to achieve unlimited scale for its computations.
00:32:54.720 - 00:33:05.248, Speaker C: Starknet contracts and the Starknet OS are written in Cairo, supporting the development and scaling of any use case and whatever business logic.
00:33:05.344 - 00:33:05.990, Speaker A: Cool.
00:33:07.080 - 00:33:15.450, Speaker D: Ben, just one quick question that is always on the mind of the community. But will we have privacy in Starnet in any way in the future?
00:33:18.060 - 00:33:21.720, Speaker C: We touched just briefly on layer threes.
00:33:23.420 - 00:33:25.930, Speaker A: We touched just briefly on layer three.
00:33:26.240 - 00:33:29.950, Speaker C: I'll show you where in the ecosystem they're going to sit.
00:33:31.200 - 00:33:32.910, Speaker A: All right, so if you look at this.
00:33:35.520 - 00:34:15.944, Speaker C: If you look at what enables us to prove the validity of layer two, we're never going to enable it. At the base layer of layer two here, you can have a smart contract. Since Cairo is a Turing complete language, you can have a smart contract that does anything. You could have an encryption library that does it in your smart contract. Go for it. The whole point is that none of the inputs and outputs are going to be available on the base layer. Now, the reason that Starknet and validity roll ups work is because we have a stark verifier here on layer one and approver here on layer two.
00:34:15.944 - 00:35:20.080, Speaker C: So if you just take this concept and you shift it up one and you say, okay, let's just have a stark verifier written in Cairo on layer two and something proving the execution of this higher layer at layer three onto Starknet layer two, you start to get a lot more flexible with the operating parameters of that layer three, you can start enabling things like privacy. You can start enabling things like hyperscalability. You can kind of mix and match all of these configs. At layer three, the Starkx instances which we've talked about kind of in passing, we haven't really talked about in depth, but these Stark X instances that sit out here and use the sharp, those are also going to be moved up to layer three. So those are going to write stark proofs that get proved on layer two, which then propagate down to layer one. That's when you'll start seeing things like privacy roll ups at layer three, but not at layer two.
00:35:20.150 - 00:35:20.770, Speaker A: Yeah.
00:35:21.860 - 00:35:28.290, Speaker D: Do you think this is something like, will be made by Star wars, or do you think this going to come from the community?
00:35:29.700 - 00:35:30.930, Speaker C: It's a good question.
00:35:32.260 - 00:35:33.200, Speaker A: It's a good question.
00:35:33.270 - 00:35:38.850, Speaker C: I don't know the answer, honestly. My gut instinct is that it'll come from the community.
00:35:41.620 - 00:35:42.816, Speaker A: But my guess is.
00:35:42.838 - 00:36:25.110, Speaker C: That we'll offer reference implementation. The design space up at layer three is still a little esoteric. It's still a little green. We do have an audited stark verifier written in Cairo, so that piece is done. But all of these concepts for recursive proving and layer three, they're all so new that we're kind of talking about ideas rather than pragmatic implementations. My guess is that we would offer some sort of reference implementation about how to do it, but we'll see.
00:36:26.120 - 00:36:28.980, Speaker D: Thank you. There's also a question in the chat, if you want to.
00:36:29.130 - 00:36:54.190, Speaker C: If we duplicate the verifier, the fact and the core contract in other blockchains, could we run Cairo contracts from Starknet and validate in the other blockchains, different to l one? Arturo, that's a super good question. The problem lies in.
00:36:56.960 - 00:36:57.944, Speaker A: The problem lies.
00:36:57.992 - 00:37:44.110, Speaker C: In where your source of truth is. So if we say that we are a validity roll up operating on top of Ethereum layer one, then you know that the ultimate finality, the ultimate data availability guarantees the ultimate source of truth is the Ethereum layer one blockchain. And that also is how we can say that we inherit the security properties of Ethereum layer one. Now, if we say that we also write that to avalanche. Sure, we could. We totally could. We could write all the same information in any blockchain that we can write a stark verifier on.
00:37:44.110 - 00:38:37.900, Speaker C: At the end of the day, that's what gives us the availability to do it, is that we can write it in solidity. But now we are as good as our weakest chain. So let's say that there's a reorgan Ethereum that's ten blocks deep and there's a reorgan avalanche that's ten blocks deep. There's this time where we are out of sync with everything in our ecosystem and we don't have a source of truth anywhere. So right now, we're focusing all our efforts on Ethereum layer one. If there might be some interesting data availability guarantees and modular blockchains like Celestia that come around that make things an architecture look a little more interesting. But right now, the question is, we want to inherit the security properties of the strongest chain.
00:38:39.300 - 00:38:46.862, Speaker A: Does that make sense? Okay, cool.
00:38:46.916 - 00:38:50.400, Speaker C: I just realized that question wasn't sent out. Let me just ping it out to everybody.
00:38:51.570 - 00:38:56.306, Speaker A: For some reason, Zoom defaults to the.
00:38:56.328 - 00:39:00.980, Speaker C: Most restrictive chat options every time. So yeah, there's the question.
00:39:02.950 - 00:39:07.800, Speaker A: Okay, cool. Okay.
00:39:10.810 - 00:39:46.450, Speaker C: So at the end of the day, we are a blockchain. It's a validity roll up. But what are we rolling up? We're rolling up a blockchain. We're rolling up an accounts based blockchain. If you guys did the primer, you guys saw how a Merkel, Patricia try an MPT stores the state of Ethereum. We also have that. We have a state that is maintained through the propagation of blocks.
00:39:48.550 - 00:39:49.106, Speaker A: And the.
00:39:49.128 - 00:40:37.198, Speaker C: Prover batches those blocks into a proof and then proves a whole bunch of blocks at the same time. So at layer two, we are just simply a blockchain. And what is the blockchain? I guess I'm not going to, no pun intended, rehash everything about a blockchain. But if you do want to start from base principles, go read the primer to find out what a blockchain is. But it's some concept of a hash structure that propagates in perpetuity. So what does ours look like? Our header is the parent block hash, the block number, the global state route. So this is our state commitment that we make in a merkel.
00:40:37.198 - 00:41:28.594, Speaker C: Patricia, try the sequencer, address, block, timestamp, transaction count, transaction commitment. Again, this is another anytime you see the word commitment, you're looking at a Merkel tree event commitment protocol version and extra data. Okay, so that all looks good written out in a table, but let's look at what it actually looks like. And we're going to start digging into the tooling of Starknet. So you guys should have set up ultimate environment, and that includes the postman collection. I saw some comments in the Discord channel that a couple of the items of that ultimate environment blog post were slightly out of date. I'll go through and fix those.
00:41:28.594 - 00:41:46.710, Speaker C: The one things that you should have is this postman collection, which should be up to date, at least for what we're going to go through today. So here's a postman collection. You guys should have it. If you don't.
00:41:48.650 - 00:41:49.606, Speaker A: I will just ping.
00:41:49.638 - 00:41:50.700, Speaker C: It out as well.
00:41:54.190 - 00:41:54.940, Speaker A: Okay.
00:41:56.030 - 00:42:31.346, Speaker C: The blog post goes through forking each of these collections. So that's the only way you're going to be able to run these is if you fork them. I'm an owner, so I'm going to be able to run them just in here. But yeah, go through and fork them and then you can run them locally. What's the actual reason why Starknet felt the need to establish a new test net? Things were getting congested. It looks like there was some bot activity on the original grilley. So we opened up a test net because first off, we wanted developers not to have to deal with the slowdown in the bottleneck.
00:42:31.346 - 00:43:27.794, Speaker C: And second off, we were running a capture the flag competition in Lisbon that we needed a testnet up and operating for those people to operate on. Okay, so here's the Postman collection. If you haven't used postman before, it stubs out network requests and it gives us a really nice visual representation of what we get back from these network requests. If you're ever confused about what we're actually doing and what we're operating in here, you can kind of refer back to this mental model of what's going on here. We're really asking the sequencer, it's really this interaction here. We are a client and we're asking the sequencer for information. The postman collections are separated into a couple different items.
00:43:27.794 - 00:44:20.230, Speaker C: So before we had a node built out by a team called Pathfinder, sorry, a team called equilibrium Labs, they wrote a node implementation called Pathfinder. And that's what you'll see used almost everywhere nowadays, including the infura. We have infira support. So that's a JSON RPC node, the same way that JSON RPC nodes operate on Ethereum layer one. But before we had that, we just had an HTTP API, and we still have this HTTP API, and it will allow you to enable this sequence. So clients to sequencers, there's two different endpoints here. So we have the feeder gateway, this is for all read operations, and gateway, which is for all write operations.
00:44:20.230 - 00:44:53.006, Speaker C: This is what we're going to be looking at today. So fork these and you'll be able to run the same query. You'll be able to basically just follow along with me and do what I do. The other thing you'll need to fork is the environments. So we have different environments. And this goes into Luis's question, and I actually don't have the second testnet up here, so you'll have to populate that yourself if you want to use it. So we'll use Devnet, which is the local devnet.
00:44:53.006 - 00:45:19.494, Speaker C: The default is to run on localhost 50 50, and that's an HTTP interface to that. We have the girly testnet that's at alpha four, Starknet IO. If you do want to set up, before I add it to this collection for you guys to use, if you do want to set up the testnet.
00:45:19.542 - 00:45:50.100, Speaker A: Two, let me go find that for you real quick. I'll point you to that once I get it. Sorry. Okay.
00:45:52.390 - 00:45:55.540, Speaker C: Yeah, I believe it's alpha four.
00:45:57.830 - 00:45:58.482, Speaker A: Two.
00:45:58.616 - 00:46:31.626, Speaker C: Don't worry about it today, but I'll get it out to you in the discord after this. Mainnet can be found at Alphamainet, Stark Ao and then node. So node will be whatever your operators. Actually, I don't know if I shared that. If I did, I probably should take it off. That's my own infura setup. Starknet ultimate dev environment had you go through and run Pathfinder and start to sync Pathfinder so you should have Pathfinder locally.
00:46:31.626 - 00:47:10.934, Speaker C: And if you don't have Pathfinder locally, you can go through infura and go through and set it up through infura. It's probably the easiest route, but like, we all know we're not being great stewards of decentralization. If everyone is going through infura, I'll get off my high horse and get into some code. So let's look at interacting with the feeder gateway. Like I said, feeder gateway is going to be all read operations. So in reference to this block header.
00:47:10.982 - 00:47:11.690, Speaker A: Chart.
00:47:13.630 - 00:47:16.346, Speaker C: Let'S get a nice example of.
00:47:16.368 - 00:47:19.450, Speaker A: A block through get block.
00:47:21.390 - 00:47:41.090, Speaker C: If you just want the latest block, you can write latest. You can also write pending here. So we have an idea of a mem pool, which is that the sequencer is going to build up this memory pool of transactions before it solidifies it into a block. So we can get the pending block as well if we write pending. Let's just start with latest.
00:47:47.370 - 00:47:48.214, Speaker A: Cool.
00:47:48.412 - 00:47:50.950, Speaker C: No transactions in the latest block.
00:47:52.250 - 00:47:58.624, Speaker A: Interesting. Block number zero. Oh, sorry.
00:47:58.662 - 00:48:29.476, Speaker C: Okay, I was on Devnet, so top right of postman is where you select your environment. So we'll select Gurley. Gurley is the testnet that's currently running a little bit slow. So this is the latest block in Gurley testnet. There's been 392,000 blocks on this testnet. And we can see all of the block header information that we looked at in the chart. So we have block hash, which is the block hash of the current block.
00:48:29.476 - 00:48:42.910, Speaker C: I'm looking at parent block hash, block number, state route, state route status. We'll go through what the available statuses are. Gas price. Gas price is the gas price.
00:48:45.120 - 00:48:45.484, Speaker D: When.
00:48:45.522 - 00:49:23.096, Speaker C: We write our proof and state transition. So we write our state transition through call data to our court contracts in Ethereum layer one. We'll look at it today. But that costs money as well as the sharp proof, writing the proof to the verifier. That's the reason why you pay fees when you pay fees for your transactions. It's to cover the l one footprint of your transaction, both in the sharp proof and the data availability. And again, don't worry about it too much.
00:49:23.096 - 00:49:51.430, Speaker C: We'll look at it in code. But that is what you're paying for. And that is that gas price that we're looking at. I have a tool that I wrote. You can also do this in the terminal if you're a little more comfortable in the terminal. But I like having a UI for it as well. When we're digging through all of this block information.
00:49:51.430 - 00:50:30.048, Speaker C: Everything is either formatted in felts, which you guys are now familiar with felts, or hex encoding. So if I see this and I say this is the gas price, that might not mean a lot. You can put it into util turbofish and it'll decode based on its prefix, which is zero x. And so this makes a lot more sense than this for what is the gas price that was paid and that's in Guay. Another thing about this tool is that if you need a selector, we'll go through what a selector is. Today. A selector is a function name.
00:50:30.048 - 00:51:18.956, Speaker C: So let's say that we have a function name that is balance of that you'll see on ERC 20 contracts. This will give you the selector for it, which comes in handy quite often. And if you need a UN 256, which is split up into the low and high bits, this will split it up for you. So once we hit that 128 bits, it splits it into two felts, because felts are in the order of 252 bits. So we need to split it up in order to make a unit 256. Menmeat says is there any instant finality solution on Starknet? In case nodes on l one went to get confirmation faster than the sequencer.
00:51:18.988 - 00:51:22.896, Speaker A: Can get verified on l one? Let me just reread that.
00:51:22.918 - 00:52:16.844, Speaker C: Is there any instant finality solution on Starknet? In case nodes on l one went to get confirmation fast, the sequencer can get verified on l one? Not right now. There's no instant finality solution right now. It's going to be up to you as the DAP developer to say what your finality guarantees are. Once your transaction has gone from pending, from a pending block and has been accepted into a block, you can say that you have some finality there because that l two block is a valid block and you will have finality as far as that Starknet layer two block.
00:52:16.972 - 00:52:21.556, Speaker A: Now let's say that something shit the.
00:52:21.578 - 00:52:26.390, Speaker C: Bed here, here or here before it could write three or four.
00:52:29.400 - 00:52:30.048, Speaker A: Then you're.
00:52:30.064 - 00:52:37.690, Speaker C: Not exactly going to be able to rebuild the state with that layer two transaction included. So it's just a matter of.
00:52:39.900 - 00:52:40.264, Speaker A: What.
00:52:40.302 - 00:53:15.636, Speaker C: Finality guarantees you need for your application and what finality guarantees you can offer your users. You could just say, we'll wait until it's accepted on layer one, until we say that this transaction is final. Once there are multiple sequencers and we have some consensus protocol on layer two, you probably are going to be able to say with more certainty that you have finality at layer two. I wouldn't fault you for saying you don't have finality at layer two until it's accepted on layer one. Right now it'll just be up to.
00:53:15.658 - 00:53:17.060, Speaker A: You and your users.
00:53:25.370 - 00:53:31.482, Speaker C: Where else is the concept of a selector is used other than l one, l two bridges, yes, I'll get into that today.
00:53:31.536 - 00:53:32.410, Speaker A: Prashant.
00:53:37.470 - 00:53:50.854, Speaker C: Okay, so we are looking at blocks. So for this latest block, this is the list of transactions. And this actually gets into it a little bit. Prashant.
00:53:50.922 - 00:53:57.326, Speaker A: So this is a single transaction that's.
00:53:57.358 - 00:54:09.320, Speaker C: Included in this block. Its signature is populated, which means that it was sent by an account contract. So an account contract signed this.
00:54:11.130 - 00:54:11.974, Speaker A: It.
00:54:12.172 - 00:54:18.440, Speaker C: Interacted with this contract and it sent this call data. Wow, quite a bit of call data.
00:54:22.170 - 00:54:22.920, Speaker A: Ah.
00:54:24.910 - 00:54:27.850, Speaker C: Okay, so this one is going to be transaction version.
00:54:33.330 - 00:54:34.734, Speaker A: Transaction version one.
00:54:34.772 - 00:55:08.220, Speaker C: So in transaction version one, which was released as far as Starknet 00:100 you'll see that there's no entry point selector in this transaction. Now what that probably means is that the entry point selector is in this call data. So this is most likely passing a call on to this contract at this selector. So it's calling the external function that's available at this contract here.
00:55:08.830 - 00:55:13.434, Speaker A: You guys should know, so everyone should.
00:55:13.472 - 00:55:33.620, Speaker C: Have done Starknet Cairo 101 at this point. So you guys should know what an external function on a Starknet contract is. So that is this selector. So if you named your function on your smart contract and you named it.
00:55:36.390 - 00:55:41.890, Speaker A: Let'S get into a Cairo file.
00:55:42.630 - 00:55:44.360, Speaker C: So let's say you named it.
00:55:46.650 - 00:55:52.280, Speaker A: External function name is balance of.
00:55:53.130 - 00:56:13.406, Speaker C: We have our syscall pointer, Peterson pointer, range check pointer. You guys should be familiar with that. Now, arguments that we'll take for now, don't worry about any of that. Just know that I named this external function. External is a decorator, meaning anyone on Starknet can call it. And I named it balance of that.
00:56:13.428 - 00:56:17.502, Speaker A: Means that the selector for that function.
00:56:17.556 - 00:57:01.310, Speaker C: That anyone else can call is this, and then this is the felt representation of it. So one way that we become composable is that we expose these externally decorated functions to anybody else for them to call. And that's how we would get. This would actually be a view because we're just getting the balance of, but let's say this is instead of balance of, we'll say it's transfer. So transfer would be our external function because it's a state changing function, which means it's a write and the corresponding.
00:57:02.850 - 00:57:05.040, Speaker A: Selector would be this.
00:57:06.210 - 00:57:36.940, Speaker C: Unfortunately there's no way to go back, otherwise I would show you what actually I think Starkscan does it. Okay, yeah, let's look at Starkscan real quick. So I'm operating on the HTTP API. A nicer way to go. Look at the information that's propagating across Starknet is through a block explorer. One of the really good ones is Starkscan. So we'll look at what this transaction did.
00:57:36.940 - 00:57:42.650, Speaker C: So it called publish spot entries.
00:57:44.750 - 00:57:46.730, Speaker A: Publish spot entries.
00:57:51.680 - 00:58:08.400, Speaker C: Ox. Here we go. So ox 4468. Okay, so the nice stark scan gives it to us all nice. And says that it did. Publish spot entries.
00:58:10.740 - 00:58:23.110, Speaker A: Published spot entries should be ox 29840. No. All right, so I'm probably looking at.
00:58:23.560 - 00:58:25.270, Speaker C: A higher level call.
00:58:35.430 - 00:58:35.938, Speaker A: Okay.
00:58:36.024 - 00:58:44.180, Speaker C: I'm not going to dig through this entire execution flow, but I hope that helps at least with some of the.
00:58:47.290 - 00:59:05.790, Speaker A: What a selector is actually publish spot entries. It says that it is that.
00:59:07.040 - 00:59:11.180, Speaker C: Anyway, sorry, sometimes I get kind of lost in the weeds.
00:59:11.920 - 00:59:13.852, Speaker A: I don't want to kind of cause.
00:59:13.906 - 00:59:45.796, Speaker C: Us to come crash into a halt here. Okay, so that's the transaction. Transactions in a block is an array of transactions. We also have the timestamp, the sequencer that sequenced this. This is going to be the same now just because it's being operated by us. Again, once sequencer is open source, multiple clients, multiple operators, you'll see sequencer address change, transaction receipts. So this is going to tell us what events were emitted from the transaction.
00:59:45.796 - 01:00:01.020, Speaker C: These are the events that were emitted from this transaction with the keys and data. Again, this is just the raw block, the bare bones block. If you want to really dig in with a much nicer view of what's going on in this block, I would use starkscan.
01:00:01.840 - 01:00:12.624, Speaker A: Starkscan shows you the signature here and events. Cool. Okay.
01:00:12.662 - 01:00:22.950, Speaker C: The whole reason I'm showing you this is so you guys can get an idea of how the block is hashed. So we have camp three here.
01:00:24.680 - 01:00:25.792, Speaker A: Block verification.
01:00:25.936 - 01:00:35.530, Speaker C: So this is a python script for hashing this block. And this hashes everything you see.
01:00:37.820 - 01:00:41.844, Speaker A: In this data header table so that we.
01:00:41.982 - 01:00:51.980, Speaker C: Are not missing any piece of information, including events that are emitted from these smart contracts, into this block. So we'll take a block.
01:00:54.020 - 01:01:02.050, Speaker A: We'll just take blocks. Take this one.
01:01:04.580 - 01:01:30.664, Speaker C: You know what? I think my script goes against main net. So we'll go to mainnet and we'll take this one. The height of the main net blockchain is 7690 blocks. Just keep this in mind. 00:24 D 31. And again, feel free to kind of play with this. Put print statements in where you're curious about it.
01:01:30.664 - 01:01:38.750, Speaker C: But we're hashing all of the commitment trees and making sure that we have a, you know, a valley block here.
01:01:39.680 - 01:02:10.840, Speaker A: So we'll say 7690 block verification. Python. Python three, verify. I am not in my Cairo environment.
01:02:14.380 - 01:02:50.550, Speaker C: Okay, so it's going to take a second to pull that. And in the block, you should notice that we do get the block hash. So this is the block hash for the latest block. So this script is just saying, hey, did we hash the correct block hash that we get from the actual block? Again, a lot of these concepts are in the primer, but if your question is, why don't we just use the block hash that was given to us, it's because it defeats the purpose of the blockchain. In order to really understand.
01:02:53.320 - 01:02:53.844, Speaker A: To really.
01:02:53.882 - 01:03:01.864, Speaker C: Understand the state of bitcoin, we need to have hashed every single piece of information that went into that block and the blockchain from Genesis to now.
01:03:02.062 - 01:03:02.520, Speaker A: Cool.
01:03:02.590 - 01:03:24.270, Speaker C: So, yeah, feel free to put print statements in there wherever you feel like it. That's how we hash block. Where are we at time wise? Okay, we're at about an hour. Let's take a five minute break and meet back up at 940.
01:08:05.870 - 01:08:10.540, Speaker A: All right. Hey, thanks for coming back.
01:08:13.250 - 01:08:14.480, Speaker C: No more questions.
01:08:14.930 - 01:08:16.110, Speaker A: Okay, cool.
01:08:16.260 - 01:08:50.810, Speaker C: We will cruise. Okay, so, yes, hopefully block verification is good for everybody. Let's go over the transaction lifecycle. And we looked at what a transaction looked like as well. So we should know what goes into a transaction. I'm going to ping out the docs. So a lot of what I'm talking about as far as the specification goes, you're going to be able to find here docs starknet IO.
01:08:53.150 - 01:08:54.620, Speaker A: Bring it down here.
01:08:59.800 - 01:09:32.224, Speaker C: Docs starknet IO. So like this information on blocks and transactions block structure, that's all here. It just doesn't come with a script for playing with the block structure and understanding exactly how to hash an event commitment transaction lifecycle. Same thing here. It'll give you an understanding of what the transaction lifecycle is and transaction structure. So we can obviously look at what goes into a transaction structure. But here's the specification for digging into it.
01:09:32.224 - 01:09:39.330, Speaker C: Here's version zero and version one. Me personally, I like looking at.
01:09:42.260 - 01:09:42.576, Speaker A: My.
01:09:42.598 - 01:10:26.400, Speaker C: Brain kind of blanks out when I see something like this, but when I see it in code, it just makes so much more sense to me. So if you're like me, head over to basecamp code examples, and if you are kind of more of a formal verification, I can read this and it makes sense to me. Head to docs starknet IO. Okay, so we're going to go through transaction lifecycle. So transaction lifecycle goes from not received to receive to pending to rejected, and then we have accepted on layer two. Accepted on layer one. These are going to be the transaction statuses as they're returned to us by either the sequencer or the full node.
01:10:26.400 - 01:10:33.190, Speaker C: So status accepted on l two. We've already had the conversation about.
01:10:35.400 - 01:10:35.716, Speaker A: What.
01:10:35.738 - 01:11:03.390, Speaker C: Kind of security guarantees we're telling our users as far as finality goes. So you can say that there is some version of finality that you get for accepted on l two. It is in a layer two block. That block is propagated, but until it's accepted on layer one and proved on layer one, you don't inherit the security guarantees that ethereum gives us, which is the full concept of a roll up.
01:11:04.240 - 01:11:04.604, Speaker A: Cool.
01:11:04.642 - 01:11:41.880, Speaker C: Yes, we'll just make sure we didn't miss anything. TX received received by the sequencer. It will either execute successfully or be rejected. So if the execution of your Cairo code is not executed correctly, or there's some assertion that didn't match, that will be rejected if everything went through. The other thing here is if the fee was extracted and the fee paying account had the correct more than the amount that needs to be charged for the l one footprint of the transaction. All of that is good. Then we say that it's pending.
01:11:41.880 - 01:12:03.740, Speaker C: This is when it's in that mem pool. Right now it's just a fifo. First in, first out. So the Tx is executed successfully, entered a pending block, rejected. So rejected is the TX executed unsuccessfully and was skipped. Like we have a bad assertion. Okay, so I actually misspoke earlier when I said received.
01:12:03.740 - 01:12:32.970, Speaker C: So everything I said about received in terms of like a bad assertion or a bad fee payment, that's actually going to be down here at rejected, accepted on l two. So accepted on l two. It's in a layer two block, but it has not been proved. Or if a state update, it was required, it was not written to layer one. And then finally, we have accepted on layer one. We've gone full circle with our lifecycle here. One, two.
01:12:32.970 - 01:12:37.210, Speaker C: This is both two, three, and four.
01:12:38.380 - 01:12:39.130, Speaker A: Cool.
01:12:39.580 - 01:13:36.152, Speaker C: There's zero X Iceman put together this really cool visualization of the contract. So this is a really high level kind of mind map of what's going on. If you want a really low level idea of what's actually happening on chain, this is what this zero x iceman put together, and it will show you the actual, let me boost my text, my font size. It'll show you the actual process of everything that we talked about. So, verifying the merkel tree, part of the stark proving, verifying the fry protocol. It'll highlight the components, the actual on chain components that are used in each one of these. So verifying the Merkel tree, verifying the fry protocol registering continuous memory pages these continuous memory pages are facts.
01:13:36.152 - 01:14:26.076, Speaker C: So going back to the fact registry pattern, the starknet core contracts actually use the fact registry pattern under the hood to make it so we can query the memory pages that are written from the sharp to the verifier, verify the proof and register, and then update state. So whereas this is kind of just a component overview, to get it into your head at a conceptual level, here are the actual contracts and here are the contract addresses. If you are digging in fully, you can also find contract addresses at that docs. Stark IO operational info will give you.
01:14:26.258 - 01:14:29.650, Speaker A: All of the Starknet addresses. Cool.
01:14:32.420 - 01:15:19.148, Speaker C: Okay, contracts. What is a contract? So it's a starknet implementation of a smart contract written in Cairo. And again, so it's not the full breadth of Cairo. We don't have things like hints that let us do non deterministic code jumps. And if you think about it intuitively, we are an expressive, composable blockchain. We only work because we're proving the validity of the execution of layer two to layer one. So if anyone's able to hop out of the execution and the validity trace of that execution and run arbitrary logic in Python, the proof isn't going to mean much on layer one.
01:15:19.148 - 01:15:33.300, Speaker C: So that's why you don't have access to the full suite of hints in your starknet smart contracts. But yeah, for the same reason that there are smart contracts in solidity, just to enable you guys to build crazy.
01:15:33.370 - 01:15:36.870, Speaker A: Cool shit stuff we can guess.
01:15:38.600 - 01:15:51.290, Speaker C: Subset of kara. We talked about classes we'll talk about today. And accounts. I'm going to hand it to Omar to talk about accounts. Omar, feel free to skip that slide if you.
01:15:52.380 - 01:16:32.740, Speaker D: Thank you. Thank you, Ben. So I wanted to talk a little bit about something that is key in the start, or better, it is key to the Ethereum ecosystem, to the general blockchain ecosystem, and it's something that we have and only have the opportunity to use natively using starmap. So we heard a lot about account obstruction. Actually, I counted the number of talks about account obstruction during Defcon. There were six different talks about account obstruction, including one panel where Vitalik was on. So this is a key topic that the training committee has been pushing, but that has not been implemented at the protocol level in layer.
01:16:32.740 - 01:17:20.848, Speaker D: So getting deeper into this, we can already call it using actually Ben's tutorial on standard. I will share it in the chat, but conceptually, what are we talking about? So accounts fraction is so important that we could say that Ethereum is at stake. So Ethereum depends, and will depend a lot on account abstraction. So danger number one is that most Ethereum users are actually using centralized exchanges. That is maybe I will ask in the chat, how many of you have a Coinbase account, a binance account, an FTX account? I'm guessing most of you, even though that you are hardcore developers, getting deep into starknet, getting deep into Ethereum ecosystem. Most of you, including myself, I have a Coinbase account. Most of you have centralized accounts.
01:17:20.848 - 01:17:39.064, Speaker D: Why? Because self costly is very hard. It's very hard. We have a private key. We have, sorry, I'm just bringing a timer here. So we have a private keys. We have to write twelve different words in order to recover access to our accounts. So this is really weird, really weird.
01:17:39.064 - 01:18:09.392, Speaker D: And even me, I have lost my words at a certain moment and I have stress about my funds there. So we are securing asset in a very complicated way. And this is not going to scale. There is no way that this will scale to reach the next billion users of Ethereum. So there is no discussion on that. Everybody, Vitalik, everybody every now knows that account searching is required in order to reach the next billion of users. We have to stop using centralized exchanges.
01:18:09.392 - 01:18:44.832, Speaker D: This is the idea of all of this and more people. The next way of users will be using, we will using centralized exchanges. And this is something that we do not want to have. So danger number two is the imminent arrival of quantum computers. So it will force the entire ecosystem, of course here, including Ethereum, to move to quantum proof signatures. So maybe we can use star corps, which are actually quantum proof and also, as Vitalik said it before, future proof. So we have two dangers that are imminent that they will be coming.
01:18:44.832 - 01:19:26.236, Speaker D: And a kernel structure tries to solve boats and actually it stops them. And only account structure can be done in a starnet at a native, at a protocol level. So this is something very interesting. So now what account structure is, there's different kind of definitions. For example, Martin Traffom Opensepalin says that account obstruction is when a smart contract can pay for its own transactions. So you can deploy this account obstruction, this account contract, and then it can pay for its own deployment and also pay for other actions that it takes. Definition number two, this was given by light client he's working at get.
01:19:26.236 - 01:20:07.400, Speaker D: He gave this definition at Defcon, account is actually a validation abstraction. That means that we are obstructing the validation process. We can use different type of signal tunes, such as we were telling before. We can use cryptographic primitives, we can use different execution processes. So we are actually abstracting how we are dealing with the validation process. This definition, the number two, I never heard before, and it seems very logical to me, it makes sense to me, and it's something that we can keep in mind. So these two definitions can let us see more or less how account structure has a lot of power on what is coming in the following years.
01:20:07.400 - 01:20:33.404, Speaker D: So, okay, excel construction sounds nice. We already saw the problems that Ethereum is at stake, and this is a reality. This is something that people know. Ethereum is in danger if we don't solve this kind of stuff. Account. So what construction. Okay, so Martin tray, for example, says that a construction means huge improvements in onboarding.
01:20:33.404 - 01:21:04.056, Speaker D: We were telling before that we will onboard the next million users, and this will come with better user experience, but also security. And this is something that we'll talk about in a minute. But security will be improved also with account abstraction. So basically, a can of structure is the future of crypto user experience and security. And this is not exaggerating, this is really the future of it. Also, Julian is set builder and co founder of Ariant. Ariant, you know your Starnet builders, you know that you can use StarnetX already with the Starnet ecosystem.
01:21:04.056 - 01:21:56.060, Speaker D: And actually, I don't know if you are aware of this, but Arian is one of the companies, or the most involved company in accounts fraction. They have been pushing for this in layer two since the beginning. Since 2018, they haven't achieved almost anything. So they went into the layer two ecosystem specifically using Starnet and CK sync. In the case of CKC, this has not yet been implemented both in starnet, we already have it. So we have been building how the power structure looks in the starnet ecosystem, something that you can already use, thanks to the work of Julian sand from Argent, also of course, Star wars team, but also the people from open sepulin, and also looking at what were the good practices in the layer one. So in the layer one, we had the EIP, I don't remember the name exactly.
01:21:56.060 - 01:22:40.372, Speaker D: I think it's four, three, seven. It was written by Joab here and Vitalik, and it contains some good practices, and we're implementing them in the Starnet ecosystem. So as you can see, what we have right now, and that you can build already with Starnet is only the best practices and we're innovating on what is the next step on account structure. And this is only possible in starnet again. So also Vitalik says that smart wallets, smart wallets is also a name that you can use for this type of contracts, account contracts, smart wallets should be the default and account obstruction is the key step for this. So we should have this as a default. And also Joab, who is very focused on security.
01:22:40.372 - 01:23:39.916, Speaker D: Actually, if I get it wrong, maybe Ben can correct me. But Joab audited the Cairo contracts, so he's another hardcore Israeli. But well, Joab said that a Cairo structure is key for security and also we'll be talking about that in a moment. What can we do with this? And this is something again that you can already implement the ecosystem and the jobs ecosystem and the opportunities ecosystem that you can find in account structure is getting bigger and bigger. Again in vitaliworlds this should be the default. So what we observe in the future is not only ariant being a provider of wallets that use account abstraction, but we will also see metamask and other wallet providers, I don't know, rainbow, something like that, trying to provide this kind of functionality, also different kind of companies trying to implement in different ways. So there's a big opportunity in being first here in learning how to do it and what can we do with it.
01:23:39.916 - 01:24:39.004, Speaker D: So some of the things that we can do, and again, this goes back to what Ben was saying, that Starnet provides us with an opportunity to create something that has never been done before, something that is discovering explosion of opportunities, of ideas, something that is out of scope completely in the layer one. And a construction is one of these things. So we're not talking here about the cost of fees, which are and should be low in starnet or we're not talking about the velocity of the transactions, the speed of transactions. We are talking here about something very specific that is a canoe structure, another thing that provides developers with something that is out of the scope of layer one. So a kind of abstraction can do stuff such as social recovery. Please let me know if you have any questions in the chat or question and answers. I know this is not that much related to code, but it's something that I found very interesting and very relevant for us to understand starnet, but we can have social recovery.
01:24:39.004 - 01:25:21.084, Speaker D: Basically all this before going into these specific opportunities. Basically this is all already been implemented in web two account is taking us from the difficulty of managing private keys, seed phrases and bring it into web two experience. Again, this is key for the next billion users, I cannot imagine my grandma or my grandpa using their metamask and writing their seed phrases in a paper and storing it. There's no way that will happen. No way. There is no way that the next users will go into metamask or something like that. So something that we have in web two is social recovery.
01:25:21.084 - 01:26:04.232, Speaker D: That is, for example, I can say, hey, I forgot my password, I forgot my access keys. Can you company, maybe argent, something like that. Can you help me recover them? And yes, you can implement this using a can of fraction. For example, you can have two access keys that can. You can define a key that does not have access to, for example, signing transactions. It has only one single power that is changing the public keys. So in case that you, for example, lost access to your account, then you can ask for this other key that could be in the hands of a provider such as argent.
01:26:04.232 - 01:26:41.448, Speaker D: I don't know, maybe in the future metamask and they can use their power with this key in order to change the public keys. So we can recover access to our phones, we can recover access to our assets. So social recovery is very important. You also can have key rotation. For example, you want to change the keys every month for security reasons, maybe so this could also be helpful. You can have different security policies for different type of users. Again, what job was focusing a lot? It was in the sense of security.
01:26:41.448 - 01:27:12.064, Speaker D: Security is important for us. And for example, what happened if you have, I don't know, like an enterprise account. So in this enterprise account, of course you will be moving bigger amounts of money. Or maybe you can have different persons that can access these funds and make transactions, employees from the company. So you want to give them different access to these different persons. So you will have different security policies for these accounts. It will be different from one that is like an individual account, like a normal account that we can have already.
01:27:12.064 - 01:27:20.516, Speaker D: Of course, in layer one, this makes no sense. In layer one, if you have the keys, you can do anything. If you don't have the keys, you cannot do anything.
01:27:20.618 - 01:27:20.932, Speaker A: Okay.
01:27:20.986 - 01:28:07.972, Speaker D: It's like here, we can implement these different kind of web two experiences. Also you can have session keys, meaning that, for example, and this is something that has already been implemented in Starnet. It was a very interesting project from cartridge. Session keys means that, for example, when you get into your iPhone or in your Android cell phone, and then you sign in with your thumb, and then you can get access to your phone. So you only, for example, have to input your password once, and then the next time you can access with your thumb or with your face. And then maybe in a month it will ask you again for your password, just to make sure that it is you. And then you can access again with your thumb and so on.
01:28:07.972 - 01:28:39.260, Speaker D: We can do this. This is something that has been implemented in web two everywhere. So you can have session keys for your computer, you can have them for your cell phone and so on. So this can also help get more people on board. And of course another thing that is very important for security, we can have custom transaction validation schemes. And this is related to the second definition I gave. It was not my definition, it was from light client from the get team.
01:28:39.260 - 01:29:25.900, Speaker D: So we are abstracting the validation process. We can have different signature schemes. You can have multi signature, for example, you can have that I lost access to my account, I forgot my password, whatever. So you can have for example a multi signature where you can give powers to three of your friends, three different friends, and you can give them access to unblock your account, so you lose your password. So these persons that you can call them, and if two out of three sign that you can have access back to your account, then they will, I don't know, sign sponsoring and then you can have back the access to your account. This is only an example. This was an example actually given by Vitalik.
01:29:25.900 - 01:29:58.628, Speaker D: One of the important use cases that we can have with account. And also you can have different signature schemes. Again, we'll require this when quantity computers will come. I don't know, maybe people say that 2028, something like that. And of course you can use the star curve to sign your transactions. So again, this providers with a lot of flexibility and is key for the future of Ethereum. If you have any questions, let me know.
01:29:58.628 - 01:30:24.144, Speaker D: But just to make you, to show you more or less what we are losing, what we are losing in the layer one. Again, this is something that you cannot do. In the layer one you have an ERC. Four, three, seven. If I don't get it wrong, let me search for it. Yes, 4237. It was actually based on the IP 4237 proposed by Vitalik, by UAP and others.
01:30:24.144 - 01:31:15.532, Speaker D: And it's very good. And again, standard has base its account process on this ERC in this EIP and previous eips. Because we have like three or four eips already trying to implement a kind of structure on the layer one. But this has not been possible. So why not layer one? We have seen that even Vitalik and the main stakeholders of stern are interested in this. So why not layer is, and this is a perfect example of the limitations of the EVM and why you can use different virtual machines such as Cairo or others to implement new things that again are not possible in the layer one. So this is something that Vitalik himself has advocated for since 2016.
01:31:15.532 - 01:32:24.128, Speaker D: Since the beginning he has been talking about this and it has not yet been implemented. Now the question is why? There's always something more important at the moment. So for example, we always have some priorities, I don't know, maybe the merge and now the following upgrades of Ethereum and so on. So there's always something more urgent for Ethereum to work, for Ethereum to work properly. And this is my personal opinion, but account search has been pushed back because it's something like, it's not that key to the function, the actual function of the theorem. If you don't have a construction, Ethereum will work well, it won't have any problem, the AVM will work well, but we are losing the scope of what can it provide because again, Ethereum is at stake and this is not my words, this is something that was talked a lot during Devcon. Please look at the panel with Vitalik, Joab, Julian and light client and it's very interesting.
01:32:24.128 - 01:33:01.456, Speaker D: But this is something that Ethereum is at stake. And I don't know, maybe the Ethereum community, the core developers have not looked this into. They haven't given the priority that this deserves. And this is something that again, Vitalik knows that Julian has said that a lot of times and well, it's a problem. It's a problem. We have had eips that are trying to implement like an abstraction, like the 4237, but not at the protocol level, but at the application layer. So like a layer on top of what actually needs to change.
01:33:01.456 - 01:33:50.060, Speaker D: And Julian says that what actually needs to change is the externally owned accounts. The eoas are the problem here. And this is something that, as you know, we don't have at starnet, we don't have externally owned accounts, everything is a smart contract. So this is something that needs to change in layer one. Now the question is, is this going to be implemented at a moment in layer one? There's not a lot of hope, to be honest. From what we have seen in the panels in the discussions, it doesn't seem like it's not going to come near in the closed term. It seems like it's something that is going to continue to be pushed away and this is a problem and this is a problem and because terminate is getting bigger and bigger and bigger.
01:33:50.060 - 01:34:55.960, Speaker D: So making changes to the EVM to the protocol, it's very hard. It's getting more and more difficult to implement these kind of changes. And again, this is something that is at the core of the EVM. These are an example of a limitation of the EVM that another virtual machine can improve on. Now also, is this going to come to other layer tools, not only to starnet or to CK sync? Again, in Ck sync you cannot use it already in starnet you can. But is this going to come to other layer tools, specifically talking about the zero knowledge evms that are being built? Julian from Arian says that this is very difficult, again, because these other layer tools are focusing on implementing the EVM, most likely as it is, without changes. Again, a construction seems to not be present in these layer tools unless they commit to make changes to the virtual machine, to the AVM that they are implementing.
01:34:55.960 - 01:35:45.832, Speaker D: We're talking about, I don't know, one to two years from now, and you can already have it with the starnet. This is something that you can already use and something that all the community, again, including the guys from this panel, agree, is that Starnet is leading the implementation of a cannonstration at a protocol level. It is like the testing ground for how a cannonstration could look in the future with possible improvements to the AVM. If it comes, it will be based on the experience that we have at starnet. Again, we're working with leaders in the industry, such as Joab from the term foundation. We're working with argents. We're also working with Opensepelline inside the Star wars team to get the best implementation of account structure as possible.
01:35:45.832 - 01:36:07.128, Speaker D: So you go to all these talks in Devcon, just look into YouTube and write Devcon talks, account obstruction, something like that. And all of those talks, they always are talking about Starnet. Some of them are only dedicated to Starnet, and they are not even from the Star wars team. They are people from the community talking about Starnet and account abstraction.
01:36:07.224 - 01:36:07.532, Speaker A: Why?
01:36:07.586 - 01:36:27.110, Speaker D: Because again, Starnet is the place for account structure currently in Ethereum. So I don't know if you have any questions, but now, if you want to implement a construction again, this is a great opportunity. In the future, we'll see that a lot of people, some protocol, are trying to implement it.
01:36:27.720 - 01:36:28.470, Speaker A: So.
01:36:30.760 - 01:37:28.596, Speaker D: Where can you learn how to use it? You can go into starddu and you will be able to see the accounts tutorial, which is led by Ben, which is actually very good. And also, please let us know if you want to go deeper into this and maybe have it as part of the base camp account obstruction and how to build account obstruction. So you can go to these tutorials, starting accounts, and you will have different kind of exercise. For example, here you can implement different kind of signatures using accounts fraction you have, as Ben showed before, we have different, of course, smart accounts. We have to let node starnet that these kind of contracts are a little bit different from a typical smart contract. Even though we're talking about smart contracts. These are all smart contracts.
01:37:28.596 - 01:38:00.560, Speaker D: But there are certain types of that we have to implement. For example, validate. Here you can decide what will be like the validation process for this. Again, as was one of the definitions, this is a validation of structure too. So we can make our own way of validating these kind of contracts. And the most important call is execute. And here you can implement something else that is out of our current scope in layer one.
01:38:00.560 - 01:38:09.620, Speaker D: For example here, Ben, what he's doing is he's catching using the Star Corp. If I don't get it wrong, Ben.
01:38:09.960 - 01:38:16.760, Speaker C: Yeah, I'm basically trying to confuse the user there. But yeah, just hashing a couple of values.
01:38:18.380 - 01:38:50.016, Speaker D: Okay, so just go into this storage account repo in the storage repo available to the chat and start exploring it. And if you get any idea, if you want to do something as basecamp with this, please let us know. Just remember that after these couple of slides, you can go with something. Is that account searching is much more important than most people. Think about it. It's the way to onboard the next billion users to Ethereum. And Starnet is leading the way on this.
01:38:50.016 - 01:38:52.044, Speaker D: Thank you, Ben, back to you.
01:38:52.182 - 01:39:30.544, Speaker C: Yeah, thanks, Omar. A good point. I mean, account abstraction really is super important. The reason I'm trying to confuse people in that specific example is to kind of show that you can do anything. Since account abstraction is just a smart contract, you can insert the signature in the call data and you can verify the signature in call data. There is actually a signature slot that we looked at in a transaction that you guys have already seen in the transactions today. But yeah, account abstraction being that account abstraction is just a smart contract on the blockchain, you can do anything.
01:39:30.544 - 01:40:12.140, Speaker C: It really opens everything up. One thing Prashant said, with account abstraction on Starknet, layer two, does Ethereum really need account abstraction? I was trying to find the two googly eyes, the two emoji eyes. That's kind of how I feel. I won't go into my conspiracy theories. I think a lot of the important execution code will be run on layer twos. So I think that you might be onto something there. Okay, we are kind of running low on time with the content we have, so I'm going to try not to run too fast through the rest of this, but get through the important stuff nonetheless.
01:40:12.140 - 01:40:58.484, Speaker C: And if we need to bleed over into the next session, we will. But again, just feel free to reach out with any questions if we are moving fast or not covering something that you have a question on. Okay, cool. So, storage. So one of the really important things with smart contract blockchains and composable expressive blockchains is contract storage. One of the things that these smart contracts propagate into the future and one of the things that they compose together. And the reason that we have write operations in an expressive smart contract blockchain is because we have storage.
01:40:58.484 - 01:42:09.472, Speaker C: We have someplace for these smart contracts to keep information from one selector execution to the next selector execution, from one block to the next block. So what does storage look like for a smart contract on Starknet? So smart contract storage is two to the 251 slots that are all initialized to zero. So that's how many slots you have available for reading and writing to your smart contract storage. They're all initialized to zero and then why? Yeah, kind of like we already talked about, smart contracts need to maintain a state so that they can be interacted with. When you have an external selector which you guys have seen in Starknet Cairo 101, we want that to be a write operation, and we typically want that write operation to be to smart contract storage. If you guys would do me a favor and pull base camp, the version you guys have, I believe has the deprecated syntax. So head into camp three.
01:42:09.472 - 01:42:45.150, Speaker C: After you pull camp three contracts, CD contracts and CD Cairo. Okay, so you should have storage Cairo, and storage Cairo should look like this with open curly brackets and close curly brackets. This is the new syntax as opposed to something that used to look like colon and the word end. We now need to have the open curly bracket. Close curly bracket. Okay.
01:42:46.960 - 01:42:47.660, Speaker A: Yeah.
01:42:47.810 - 01:43:38.344, Speaker C: Cairo syntax and Cairo smart contract syntax specifically should not look new to you guys. You should be fairly familiar with decorators. So we've already talked about them a little bit in this class. The decorators that we're going to use here is storage VAR storage VAR view, and external. So external being a write operation, something that alters the state or storage of your contract view, something that's a getter, it's getting a value of your smart contract storage. And then storage bar. This is how we tell storage bar is how we tell the tool chain that we do in fact want to store something at this slot we saw that there's two to 2510 initialized slots.
01:43:38.344 - 01:44:09.352, Speaker C: So we are saying that we want to store something here. Now we can store things in different ways. If you guys are coming from solidity, you're probably familiar with a mapping. These are the various different ways that we're going to be able to solidify different types of data types. So we just briefly talked about data types in Cairo. I believe Cairo 101 gets into data types, but we have felts as the native structure. And then we also have things like this.
01:44:09.352 - 01:44:50.150, Speaker C: We have a struct, which is a custom defined structure that is made up of felts or further custom defined structures. This is an example on 38 of a tuple res is a tuple left and right, which is two felts. And then the storage variable here for struct store is storing a custom struct type. And then we have just the single store, which is storing a felt. So we'll go through and look at what each one of those are when array in storage VAR. That is a good question that I do not know the answer to. Omar, do you know the answer to?
01:44:52.520 - 01:44:53.380, Speaker D: Don't.
01:44:54.140 - 01:45:29.584, Speaker C: Okay, we'll try to get your response to that. Okay, so one of the things we get when we do have the decorator for storage variable or storage VAR is we get an inherent read and write function utility. So you'll notice that I haven't defined another function in this smart contract storage Cairo that is read I should probably search for is my font size. Okay here for you guys, maybe one.
01:45:29.622 - 01:45:33.760, Speaker D: Up, maybe a little bit of sum, a little bit more if possible.
01:45:33.910 - 01:45:37.670, Speaker A: Yes. Okay, thanks.
01:45:39.000 - 01:45:57.160, Speaker C: Okay, so you'll notice that I've defined this storage variable here called single store. Single store is a single storage access to a variable that's just a felt, that's the definition from 29 to 31 here. Now funk read in this entire smart contract.
01:45:58.380 - 01:46:00.236, Speaker A: I should talk about this real quick.
01:46:00.258 - 01:46:56.892, Speaker C: We know that it's a starknet smart contract because we have this language directive here. If you're ever curious if I'm working on a raw Cairo execution or a Starknet smart contract, we know that on line four here. So on 29 to 31 in the rest of the contract here, function read and function write are never defined because the tool chain gives them to us with the storage decorator. So when I do want to access single store, I then can do it with write operations off of that storage variable. So write. And we also have a read syntax here. You can kind of read through it if you want, but so since I've defined the storage variable as just a storage variable to a felt, we're just going to write a felt to it.
01:46:56.892 - 01:47:07.004, Speaker C: And a felt can be a short string. So if you need a short string here, you can write it like that. And again, anything less than 31 characters.
01:47:07.132 - 01:47:09.040, Speaker A: Which fits into a felt.
01:47:10.420 - 01:47:38.536, Speaker C: Okay, mapping store. So mapping store gives us some version of a hash map. We have an index to a felt. This is going to give us some lookup table that I can have one to something. We'll look at it in code and then multistore. Instead of storing a single felt, I'm storing a tuple, which is of left and right, and then struct store, I'm storing a custom structure which I've defined.
01:47:38.568 - 01:47:40.540, Speaker A: Here in the smart contract.
01:47:40.880 - 01:48:11.664, Speaker C: Okay, writes, reads, all hanging off of the storage variables views. So views are just getters. You're going to want to have some getters for the storage variables in your smart contracts. These are also free. So these are just read operations. So anything with a view decorator is free. You can go in and call these view decorators to get the current state of your smart contract externals.
01:48:11.664 - 01:48:41.550, Speaker C: You guys have seen externals. These are writes we're going to write to the smart contract storage, and these are state changing operations. So let's look at what this all means. So we said that we have two to the 251 storage slots, zero initialized. So when I say single store is going to store a res, let's look at the python code here.
01:48:44.000 - 01:48:44.750, Speaker A: Do.
01:48:48.720 - 01:49:17.488, Speaker C: This is the key for that storage value. These storage lookups are key value pairs, and that value can be any of the data types that we've talked about. So tuple felt struct. But the key is going to be, if it's a single store, it's going to be defined like this. Starknet ketchak. That's a version of Ketchack. That's the hashing algorithm used on Ethereum.
01:49:17.488 - 01:49:27.530, Speaker C: It's just truncated. If you want the full definition of Starknet ketchack, it's in docs Starknet IO. But that's going to give us the key for the lookup here.
01:49:28.300 - 01:49:29.690, Speaker A: So I'll show.
01:49:32.940 - 01:50:11.350, Speaker C: You single store for count and mapping store for array elements and use the count as a key. Voila, you have an array with the current setup. That is a great idea. There's a bunch of interesting workarounds like the one that Shebin just offered up, and you can kind of do things where you can unpack and repack data structures in multiple different data structures. It's slightly out of scope for what we're looking at today, but you can typically kind of rework the data structures in a way that it works for you. So let's look at.
01:50:13.960 - 01:50:17.850, Speaker A: The. Where are we?
01:50:19.740 - 01:50:21.820, Speaker C: Okay, we'll go up to Python.
01:50:24.080 - 01:50:24.396, Speaker A: And.
01:50:24.418 - 01:50:27.820, Speaker C: We'Ll run Python storage.
01:50:28.320 - 01:50:29.070, Speaker A: Okay.
01:50:31.040 - 01:51:06.520, Speaker C: So the storage for the single key is located here. This is a hex encoding. One of the frustrating things is sometimes we need felt when we have hex, and sometimes we have the other way around, vice versa. So in the gateway we have a lookup for get storage at. So this is going to be able to give us the storage value at these certain keys of our smart contract. So, contract address, I've already deployed this to testnet. The contract details are at the top of storage.
01:51:08.620 - 01:51:09.272, Speaker A: Right here.
01:51:09.326 - 01:52:19.410, Speaker C: So contract address is this hex encoding right here. And then for key we have this output which is the Starknet ketchack, which is the truncated regular ketchack. And the only problem is that that's in hex. So I'm going to pop that into turbofish and that gives us felt. Okay, so as of the latest block at this contract, at this storage key, what's the value? The value is three. Now that's just, obviously I wrote one in here originally, and then throughout the lifespan of the contract it's been rewritten to three. And how do we do that? We send an invocation Transaction to update single store, an external function that writes a value that's passed to that storage slot.
01:52:19.410 - 01:53:12.382, Speaker C: Okay, so for some of the more complex data structures, how do we get the key? So you would think it was just a hash of a hash. It's slightly different. So we have the starknet ketchak encoding of the mapping store, and then we take the Peterson hash of the key with the first element to get us to the second value. Now we can go down this list and kind of get more and more complicated into the storage values and the key value pairs for our contract storage. And feel free to do that, by the way. This code will give you the answers to all those. But the more sensical way to do it is just provide view functions.
01:53:12.382 - 01:53:40.140, Speaker C: So this will get storage struct read. We'll just read the value there. And a view function is free. This will show you a little bit about selectors. So getstruck store is the name of the view function. The selector for it is here. So let's call that.
01:53:40.140 - 01:53:44.880, Speaker C: There's a post for call contract here.
01:53:45.410 - 01:53:50.240, Speaker A: We will grab the contract address.
01:53:56.900 - 01:54:09.030, Speaker C: Entry point selector is our entry point selector. And let's just make sure that the view function doesn't require us to pass any information.
01:54:11.080 - 01:54:13.190, Speaker A: I forget which one we looked up.
01:54:14.920 - 01:54:54.766, Speaker C: It does not. So it does not take an argument, but it does return a tuple. And so in our postman collection here, we can call it this might be the issue with why we spun up our second test net. We'll let that spin for a second. So what I'm showing you here though is the. Okay, cool. So these are the map values, I believe.
01:54:54.948 - 01:54:58.622, Speaker A: Which one did I do? Struct store.
01:54:58.676 - 01:55:42.800, Speaker C: Okay, so struct is defined like this, left, center, right. And the values that we get back are left, center, right. So what I'm showing you here, as far as smart contract storage, is really the entire stack of smart contract storage, the same way we kind of did with aps, FPS and pcs. You're almost never going to use the raw syscall, which is right here, storage read. You're almost never going to use this endpoint for get storage at by the key lookup. You're almost always going to use the storage VAR decorators that have been offered, which are write and read. But now you guys have some idea of what's going on under the hood with how the storage is laid out.
01:55:43.890 - 01:55:48.720, Speaker A: 1028 shoot, we are really running low on time.
01:55:49.570 - 01:55:51.726, Speaker C: Omar, the contracts that you generate for.
01:55:51.748 - 01:55:56.660, Speaker A: Workshop series start five, I'll let you answer that.
01:55:57.910 - 01:56:19.840, Speaker C: Any questions on smart contract storage here? Okay, if you do want to write some funky infrastructure that looks up smart contract storage by its key value hashes.
01:56:20.740 - 01:56:32.948, Speaker A: You can do it like that. All right, let's look at our slides. Okay.
01:56:33.034 - 01:57:03.196, Speaker C: Layer one to layer two, messaging. So we only have two minutes left. I'm going to save this for the next session. The next session is going to go over smart contract development. It's probably why most of you guys are here. It's why I'm here to build cool stuff. So you guys have gone the really hard route of learning the moon math, how the moon math applies to Cairo, how Cairo applies to Starknet.
01:57:03.196 - 01:57:25.744, Speaker C: And now you have learned the entire architecture of Starknet, or at least most of the architecture of Starknet. From here, we're going to get way more practical. We're going to start writing smart contracts. We're going to do a little more fun things. But I am going to save this for the next session. So we're going to split the next session up in two. Smart contract development.
01:57:25.744 - 01:57:43.740, Speaker C: Some of the good tooling that's around the ecosystem like protostar Nile, we'll get into test driven development and we will go over a little more of the high level concepts of Starknet like l one to l two, message passing. L one to l two, message passing.
01:57:44.400 - 01:57:46.830, Speaker A: Let's see if we missed anything else today.
01:57:48.400 - 01:58:33.070, Speaker C: Yeah, so we'll get into state transition and fees. So when you do pay an invocation transaction fee, what are you paying for? Why does a transaction cost money? And why does it cost the specific amount of money that it cost you? So in order to prep for next session, the workshop is l one to l two, message passing. Okay, that's good. The tutorial is really good so you won't need to know any of the stuff that I'm going to teach you next session and you'll have a bit of a primer going into that session which will be nice. And we could probably get some more pointed questions as far as the content we go over.
01:58:35.760 - 01:58:37.020, Speaker A: Was there. Yes.
01:58:37.090 - 01:59:14.970, Speaker C: So graduation Shebin, I think you've already completed your graduation requirements with that. You know, if you guys are looking for requirements for graduation, it'll be some pr to either one of the tutorials or basecamp or a education related smart contract on know it can be about base camp specifically. So if you wanted to do some NFT soul bound certificate on Starknet that gives everyone that a soul bound token, that'd be cool.
01:59:16.060 - 01:59:16.472, Speaker A: Yeah.
01:59:16.526 - 01:59:26.152, Speaker C: Thank you guys for joining. We're going to meet same time next Thursday and yeah, I hope you guys enjoy the week and we'll see you then.
01:59:26.286 - 01:59:26.970, Speaker A: Thanks.
01:59:28.140 - 01:59:29.190, Speaker D: Thank you. See you.
