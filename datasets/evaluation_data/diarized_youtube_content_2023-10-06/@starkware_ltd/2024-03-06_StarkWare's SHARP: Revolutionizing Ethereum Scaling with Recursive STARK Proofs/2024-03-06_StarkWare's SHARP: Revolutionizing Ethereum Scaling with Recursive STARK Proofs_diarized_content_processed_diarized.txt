00:00:00.600 - 00:00:44.862, Speaker A: Hey there, my name is Sirkines and welcome to the fifth episode of the scalability series. Today well explore Sharp, the proving system developed by Starkware and well see how its scaling Ethereum sharp, which stands for shared prover, is a proving system used by Starknet and Starkx that takes as an input a program execution and outputs a stark proof that attests to the validity of the program. This proof is then sent to the l one verifier contract on Ethereum. Once verified, the updated states of Starknet and Starchx are accepted and settled on Ethereum. This means that L2 transactions inherit the security of Ethereum. But why are we talking about a shared prover who shares what? Lets say that we have a perpetuals, a spot trading app and an NFT platform all running on the same network. As apps are being used and transactions are being made, their execution is sent to one common system which is sharp.
00:00:44.862 - 00:01:25.638, Speaker A: The transactions cause a change in the state of the network, and Sharp is responsible for telling Ethereum that this change is correct. As all transactions go through the same proving system, the apps share the same stark proof at one point in time. This method saves costs in the proof generation and increases efficiency. So how does sharp scale ethereum? Sharp scales Ethereum because it aggregates multiple transactions into a single proof that is later validated on the mainnet. So we're splitting one ethereum transaction among multiple L2 transactions. Costs are lower because verifying a stock proof on Ethereum is much less computationally intensive than naively redoing the transaction to check its validity. So how does sharp work? The sharp system takes as input the Cairo jobs, which are the executed Cairo programs.
00:01:25.638 - 00:02:05.068, Speaker A: This is also the execution trace of the program. That description of every step that took place during the programs execution ultimately were proving to ethereum how the execution of a L2 smart contract changed the state of the network through the steps of its execution. So how does Sharp deal with these Cairo jobs? Initially, Sharp worked on a linear schedule, meaning that as Cairo jobs would enter the system, it would wait for enough jobs to fill a batch. Sharp would then create a stark proof of the filled batch. This method of creating proofs allowed for roughly 128 million karo steps to fit into a single stark proof. But waiting for the batch to fill up and proving all the transactions at once would cause blocks to take several hours to settle on Ethereum. So sharp now operates on the recursive scheduling.
00:02:05.068 - 00:02:25.716, Speaker A: Instead of waiting for the Cairo jobs to fill up a batch, we send the Cairo jobs directly to the approver. The moment they get into the system. Suppose that we have four Cairo jobs. We create a proof for each individual chiro logic. We then verify using the l two chiro verifier the proofs in pairs. This verification is then proven. In other words, were proving the validation of the proof of the two chiro jobs.
00:02:25.716 - 00:02:51.708, Speaker A: You might have guessed it. But next we verify the proof of the verifications and so on and so forth. This is what we call a recursive tree. Once enough chiro jobs have entered a tree and we created our recursive proof. Then we send this proof over to the on chain solidity verifier. Even though were generating a lot more proofs, there are significant benefits to using recursive proofing. Sending a star proof to Ethereum is now four times faster because instead of waiting for a batch to fill up, we prove Cairo jobs as they enter the system.
00:02:51.708 - 00:03:24.204, Speaker A: We can also create larger proofs because were compressing a proof multiple times. Since were verifying recursively, we can now fit 16 times more Cairo steps in a single stark proof. In other words, more transactions are sent to the mainnet. Also the recursive verification leads to lower cloud costs because the decrease in the time we take to create a stark proof consumes a lot less memory compared to linear scheduling. And thats it. Sharp is a proving system that scales Ethereum because it aggregates multiple transactions into a single recursive stark proof that is later on verified on Ethereum. I hope you enjoyed this episode on sharp and ill see you in the next one.
