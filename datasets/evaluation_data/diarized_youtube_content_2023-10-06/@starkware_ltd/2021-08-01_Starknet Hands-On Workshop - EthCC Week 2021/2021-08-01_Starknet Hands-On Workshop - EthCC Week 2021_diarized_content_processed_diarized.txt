00:00:01.850 - 00:00:51.934, Speaker A: Okay, so thank you for coming. My name is Tom. Here is Shakau. We're both from Starkware and I mean, this is a bit fancy, but the intention of this workshop is to be not formal one. So I mean, we will present Starknet, we will go through a demo of how to write and deploy Starknet contract, and then you would also try and succeed to write Starknet contract. But feel free to ask anything that you want on Starknet, on Cairo, which is the underlying language that we won't get much into. But basically between Shakar and myself and Louis, everything about Starknet and Cairo and Starkwell in general is here.
00:00:51.934 - 00:01:47.950, Speaker A: So just feel free. Okay. Okay, great. So yeah, as I've said, our purpose today is to write Starknet contracts and to deploy them to Starknet Alpha, which is a work in progress version of Starknet that we published on Robsten. And we're constantly updating it with the latest state of our development. So I'll start with saying on hive level, what is Targnet, what we're aiming for, then a little bit deep dive into Stargnet and specifically what are the changes from the perspective of developer with regards to Ethereum. Then we'll do an intro to intro to Cairo, which will be a very brief overview of Cairo, which is the language in which the contracts are written.
00:01:47.950 - 00:02:25.210, Speaker A: And then Shah will show a demo of writing a contract and then you will be able, I think it will take between one and a half hour to maybe more. And feel free to stay afterwards and keep talking, but let's start. Any questions before I start? Okay, great. What I wanted to say, maybe you should write it before I continue. We tried to put all the resources which are relevant to this workshop in this resource page. And we tried it to be a simple URL. So write it down and let me know when you're finished.
00:02:25.210 - 00:02:30.540, Speaker A: Someone still writing it?
00:02:31.870 - 00:02:32.766, Speaker B: Okay, perfect.
00:02:32.868 - 00:02:52.820, Speaker A: So let's start. Okay, so what is Starknet or what is the vision? What are we aiming for? So basically it's a layer two network on top of Ethereum, which will be permissionless, secure roll up, and it will offer both Scalability, right? This is why we're doing it.
00:02:53.990 - 00:02:54.740, Speaker B: Yes.
00:03:02.350 - 00:03:20.010, Speaker A: So both scalability and the security of Ethereum. Right. So just trying to break it up. So basically it's a ZK roll up. I crossed it because it's not really ZK. Right. ZK stands for zero knowledge and it is not used here in anywhere.
00:03:20.010 - 00:03:49.762, Speaker A: Zero knowledge. What we actually use are validity proofs and the fact that verifying a validity proof is exponentially less computational heavy than the computation itself. So we actually prefer to call it validity roll up. But the actual term is ek roll up. But now you know it, it will be permissionless. Both of course for the developers and users, but also for the sequencer level. So sequencer levels are the equivalent to minor in Ethereum.
00:03:49.762 - 00:04:22.580, Speaker A: And this layer will be permissionless. The contract will offer basically implementing any computation that you want and you will be able to see it today. And we will also have composability, meaning contracts will be able to interact with each other and also with layer one contracts. Okay, great. So this is the vision, what we have today. So today, the stagnat Alpha one. Last month on the mid of June, we released Stagnet Alpha Zero.
00:04:22.580 - 00:05:08.142, Speaker A: On Monday we upgraded it. So basically, what's Starnet Alpha? As I've said, it's a work in progress. So currently it's not a network, it's a hosted service that we are running. But it allows to see what is the state functionality of starknet today. So it has smart contracts, meaning you can write and deploy smart contracts to it users and anyone can send transactions to those contracts. There's also layer one, layer two interaction, meaning layer one contracts can send messages to layer two contracts, and layer two contracts can send messages to layer one. And the next update will include the composability, the layer two to layer two interaction.
00:05:08.142 - 00:06:13.110, Speaker A: Right. I think it's the first system, and maybe I'm wrong, but as far as I know, it's the first system. It actually lets you do all those stuff. And the state updates to this network are proven off chain and verified on chain, meaning each transaction deployed, transactions interaction transactions are batched together, approved. And when you do a state update on l one, which I will get into it in a second, it is backed by a validity proof. Is this clear? Okay. And as I've said, we keep updating the alpha and the next thing that we will update will be the intercontract interaction which will open up what experimentation can be done with this system to a much wider variety of use cases.
00:06:13.110 - 00:07:14.070, Speaker A: And I'm not going into a full overview of Starknet, but Aviu, which is, I think you saw him in the entrance, gave a talk today at ECC, which I don't yet have the link, but it will be available and you can have a wider overview on what is now let's. What's your name? Christoph. Hi. From timeline perspective. Yeah. So Christoph asked what exactly is the timeline? I mean, when does layer two interaction is supposed to come and when we actually. I guess when we aim to launch on Mainet, I just repeat it.
00:07:14.070 - 00:07:53.520, Speaker A: Thanks. Okay, so we're already working on it. I think it will be in the order of between months to two months, this specific. And we're aiming to launch with the beta network on testnet somewhere around q four. Right. And hopefully to take it a step further to Mainet by the end of the year or maybe at the beginning of next year. What I'm describing here is we call it the stagnet core because it's the actual functionality of the state.
00:07:53.520 - 00:08:36.350, Speaker A: Right. So there's a whole ecosystem around it, which there's also either internal work or external work that works on it. But here I'm just describing what a developer can do with contracts. Okay, thank you. Any more question? Okay, we tried to list the properties of Stargnet that are relevant from the developer perspective. Maybe we missed something. And if you have questions along the way through the demo or when you're writing, then feel free to ask.
00:08:36.350 - 00:09:42.064, Speaker A: But basically, when you look at the consensus mechanism of a layer two, specifically ZK roll up or roll up in any roll up. So what defines the consensus is the state which is committed on the l one contract of the system. Right. So when I do a state update on l one and it is accepted, because a valid proof was also verified on l one, and another list of properties was also verified, then we say that the system has updated to a new state. And this is relevant because it means that we have two types of finality. So one, we have the off chain confirmation, which means that at this point, it means that the sequencer, our service said, okay, this will be included in a block, and this is the state after this block was executed. But it still hasn't made the state update on l one.
00:09:42.064 - 00:10:30.048, Speaker A: And the second step of finality is the l one finality, after which this state update has actually occurred. Specifically now on Robston, since the upgrade of the network to EIP 1559. So there are very, very deep reorgs because of one rogue minor. And we are in the transition to moving out of Robson to goalie. But the actual confirmations on l one that we are waiting is very large. So it is not the best experience right now. Hopefully next week we'll move to Gurley and we'll be back to, I don't know, on the order of minutes.
00:10:30.048 - 00:11:11.476, Speaker A: But now it's 120 blocks confirmation. So there's a big latency. Okay, this is the finality aspect. The other aspect is a contract. So as I've said they're written in Cairo and Shakar will in a minute give us a brief overview of what is Cairo. But the actual contract structure is the same as EVM contracts, meaning basically you have storage variables which can be either just a variable or mappings, or mappings of mappings. And you have functions, internal and external and view functions which operate on those storage variables.
00:11:11.476 - 00:11:57.292, Speaker A: They can also send messages to l one. And in the next update they will be able to also call other contracts. And one thing which is different from Ethereum is account abstraction. So an ethereum, an address in the state, has few properties. One of them is a balance and nons, and I guess you know that. But if it doesn't have a contract deployed into this address, then it operates as an externally owned account, meaning it can send transactions. So basically every transaction in Ethereum origin from one EOA address, right? So in starknet this is not the case.
00:11:57.292 - 00:12:48.110, Speaker A: All addresses are contracts and account functionality is implemented as a contract. So we will have account contracts. And what does this mean is that transactions has no signature and the signature is actually verified on the application level. So when you will want to send a transaction in stocknet, you will see that you don't need to sign on it in advance. And if you want it to be somehow verified, it needs to be part of the inputs to the transaction. Was that clear? Okay, I see faces, but I will try to go at it from a different angle. So when you send a transaction to Ethereum, it must be accompanied with a signature, and the signature is verified on the protocol level.
00:12:48.110 - 00:13:40.590, Speaker A: What? The protocol actually verifies that who signed on this signature. And then it verifies that this address has enough funds to pay for this transaction. And then it calls either e transfer or whatever function this transaction wants to call in a specific contract. And in starknet there's no verification. Before actually calling the contract, you immediately call the contract, and if the transaction can be executed, it will be executed. And if we want to mimic some account functionality in Starknet, we actually do it through an account abstraction. I don't think it will have any meaning right now, but you will see that when you want to send that transaction, it doesn't ask you to sign on it or stuff like that.
00:13:40.590 - 00:13:59.620, Speaker A: Okay, we'll see how we handle signatures in the demo. Okay, so this is, I think, the relevant properties currently from Stagnet Shaho, you want to explain a little bit about Cairo?
00:14:06.190 - 00:14:56.918, Speaker B: Hi, so this will be a very brief introduction to the introduction of Cairo, because there's a lot to talk about. Cairo. If you are interested in learning more about Cairo, you can see in our resources URL that you saw in the beginning, there's a link to the Starknet documentation. From there you can reach the Cairo documentation, learn more. Okay, so a few things about Cairo. Cairo, it's very efficient in the sense that we want to compile sort of SDK proof from program. And that is why there are some decisions that are not standard in programming languages.
00:14:56.918 - 00:15:38.314, Speaker B: One of them is that memory is immutable. So if you assign some value to a variable, you can't reassign anything. Also it means that it's hard to do loops because you don't have an iterator that can change values. Instead you have recursion. So it's sort of like a functional language. Also in the resources section you can see a cheat sheet which I want to go over now. So let me just maybe just say.
00:15:38.352 - 00:15:39.820, Speaker A: A sentence about what?
00:15:41.870 - 00:17:06.520, Speaker B: Oh yeah, okay. Cairo is a programming language designed to create ZK stark proofs. Essentially you can write programming Cairo and then run it locally and then give it to a prover that will generate a succinct proof. You can verify very efficiently that this program ran with these inputs and gave this output. So for example, if you want to implement an exchange, for example, the program would be something like it reads transactions from the input, it executes them, applies on the state, has some mapping of balances, it applies the balances, it verifies signatures on the transaction from users and then it outputs what is the hash of the final state. And from this run of like let's say we have 1000 transactions, then you can generate a small proof, you can put it then in l one in Ethereum where we already deployed a Cairo verifier contract for you. Anyone can use it.
00:17:06.520 - 00:17:32.398, Speaker B: And if the fact is written on chain, you can be sure that if you start with a state with this hush and apply some signed transactions, then you'll get this hush at the end. So Cairo is meant to make efficient proofs of computation. Anything else? Yeah, maybe.
00:17:32.484 - 00:17:33.680, Speaker A: I would just add.
00:17:37.570 - 00:17:38.254, Speaker B: There'S a very.
00:17:38.292 - 00:18:23.360, Speaker A: Nice presentation of Shakar on how we created Cairo, but for the sake of Starknet. Starknet is basically abstract. Most of those things from the Developer and allow him to or her to write contracts the same way that you are used mean starkware products. For example, Starkx is written in Cairo and it's a specific Zikirola application. But what Starknet does, it brings a blockchain framework that allows to prove state updates of this blockchain because of Cairo. I hope it was.
00:18:23.890 - 00:19:06.240, Speaker B: Any questions about Cairo? No. Okay, so I think we can start with the, we need to onboard them, right quick start on setting up your environment. Yeah, I think we get them starting and then we'll do the cheat sheet. Okay, so let's start with setting up your environment. You need to download things which.
00:19:08.770 - 00:19:14.800, Speaker A: You have this link on the left of the page. Setting up your environment. Basically.
00:19:21.180 - 00:19:52.010, Speaker B: Yeah. So I take a few minutes to go to that link from the resources section and set up your environment. If you have any questions you can ask. Basically just good practice is creating a virtual environment for python. Then you should download the package and pip install it. There are some prerequisites and then you're all done.
00:19:53.020 - 00:19:55.290, Speaker A: After this maybe you can go back to the.
00:19:58.780 - 00:20:20.160, Speaker B: Okay, yeah. And then do these things. If you manage to manage to run this line, then you're good. Yeah.
00:20:20.850 - 00:20:25.680, Speaker A: What if I have an apple MacBook like.
00:20:28.310 - 00:20:29.540, Speaker B: 3.7?
00:20:31.510 - 00:20:41.800, Speaker A: You have m one. Have you tried? Yeah, I'm trying but.
00:20:50.280 - 00:21:20.840, Speaker B: First of all. Okay, I got a question. What if basically this doesn't work? First of all, you can go to the playground at the Carolang site. It's just a web version. You can deploy your contracts from there so you can play around with it there. It's always an easy solution. Otherwise virtual machine cairolang.org
00:21:20.840 - 00:21:34.340, Speaker B: there's a playground there though. I do recommend you try to set up your local environment if possible.
00:22:29.850 - 00:22:31.720, Speaker A: For following this entire.
00:22:34.250 - 00:24:32.794, Speaker B: Okay, there was a question if the pelleground is it will be okay for most things, but not 100% of the things. So if you can set up your local environment, it's better. If you have apple and you have problems installing, installing it, then it's really your fault because you're using Apple. So stop. Does anyone need more time to set up his environment? Don't be ashamed. Okay, remember to do these steps as well. Just this.
00:24:32.794 - 00:25:38.016, Speaker B: And make sure starknet works. You can also see it on your resources link from the beginning. Okay, let's continue. So this is the cheat sheet that you also have the link to in the resources page. It's just like a very brief overview of things you can do in Cairo. And the syntax, of course you can define structs, user defined structs like this. With a struct, define members felt is the basic type in caro.
00:25:38.016 - 00:26:00.190, Speaker B: It's a field element. Basically mathematical operations on it are in the field. If you add it in the field. If you multiply, divide, it's in the field. This can also give rise to weird results. If you multiply two numbers, you can suddenly get small number. You can get one because it's in the field.
00:26:00.190 - 00:26:31.188, Speaker B: We'll see later how to do safe arithmetic operations. The asterisk is pointer. We can have pointers functions this is the syntax for function. Inside this is the arguments. For example, these are three arguments. These are the return types. Have multiple return types.
00:26:31.188 - 00:27:26.168, Speaker B: These are your return. You can return either without argument names or with argument names. Also, when calling functions, when you call a function, you can either call it discarding the return values, or bind them like this. Okay, basic function calling import. You can use this import syntax to import things, mostly from our standard library, which has a lot of things we'll see in the next few bullets, but also from your code if you want to spade it over files. Obviously there is the main function in Cairo. When programming in starconnect, you won't ever use the main function.
00:27:26.168 - 00:28:10.470, Speaker B: It's written for you, it's already generated. But in regular Cairo you have the main function. Other than that, this is how you can allocate an instance of t. Use the alloc function. Instance will be pointed to a t type, and then you can start filling its members using the assert keyword. Assert basically makes sure that the left side of the equation equals the right side of the equation. This is where chiro is different from a regular language, because it's a language for verifying things.
00:28:10.470 - 00:28:56.870, Speaker B: It is non deterministic, and writing values is the same as verifying that they're equal. Something and the COVID runner automatically knows to deduce that this memory cell needs to be equal. This and I don't know this one, so I'll make it equal if you want to dive more than the documentations. But practically this is how you write values to the members variables. At the top of the function, you should write locals if you want locals, it will change in the future. I'm sorry. This is how you define a local type t.
00:28:56.870 - 00:29:33.260, Speaker B: You can also assign where you define the local. When you bind the return value from function, you can add the local to make it local we should use if the compiler yells at you. You can also rebind. For example, I had a local b before. Here I rebind it. So b right now is actually this second variable, not the first one. And note that I can't write again because it's immutable.
00:29:33.260 - 00:30:24.624, Speaker B: The memory is immutable, so rebind is not the same as writing a new value to b. For example, if you had a pointer to the old b then the old b would still point to four even after this repaint. Okay, implicit arguments, you will mostly see them in the code. You won't need to use them yourself, although you could. But if you use this syntax, this means it's an implicit argument to the function, so you don't have to explicitly pass it. But it's also an implicit return type. So this function, basically under the hood gets a inside I can do things to a, we bind it, and then it returns a to the color.
00:30:24.624 - 00:31:06.704, Speaker B: It's good if you have pointers that are advancing and want to create something mutable, then we pass it and get the new value. Yeah. For example, this is how I called foo, and I don't need to explicitly pass a, but it's passed and returned. And I can also use this syntax to pass a, and it changes the value of a. Okay, conditionals, this is very useful. Just you do. If something equals something or something different than something, you can add the else.
00:31:06.704 - 00:31:35.640, Speaker B: This syntax looks a bit like python. Try to avoid defining locals inside. See the cheat sheet for extra details. Okay. Now built ins built ins is also very important because we want Cairo to be very efficient. We don't implement everything in Cairo. For example, the hashes and the signatures.
00:31:35.640 - 00:32:25.816, Speaker B: If we would have implemented them in Cairo, they would be very expensive. So instead there are some built in with a very efficient implementation in polynomial equations. And the way you use them is basically pass this implicit argument and use the library function. So for example, this is the built in that does hash, and you can use the library function hash two to hash two values. You also have the same thing with the verify ECDSA signature. This is the two basic built ins you will need to use for the signatures. This is not chirocode, this is Python code.
00:32:25.816 - 00:33:21.400, Speaker B: In order to sign using r curve, this is like a sample python code you can run in the environment you installed. This is basically signs things. We will use it some arithmetics. Like I said, these are all field operations, adding, multiplying, dividing. We have library function for asserting not zero, asserting non negative, which actually means that the number is between zero and this big number. So if we want to do safe math, then we need to use numbers that are always in the bound range, like zero to two, to the 128. Basically, assert that all your inputs are there after you add things, assert it there after you multiply.
00:33:21.400 - 00:34:04.090, Speaker B: Maybe you need to assert it. Maybe even use the assert NLE to make it a lower range. For example, if you want to only support amounts with 64 bits, then assert everything is between zero and 64 bit. And you also have this nice function that does integer division as opposed to field division, which are different things. And there are also diversions that instead of asserting, they just return if it's true or not. Like one or zero. Dictionary is also very useful and important.
00:34:04.090 - 00:34:40.686, Speaker B: Like I said, cairo is a mutable language, so it's hard to use dictionaries, which are mutable by nature. But we have some magic that does it. If we look at it like this, we have the function that creates a new dictionary. We have the dict read and dict write. And at the end you must call it finalized, otherwise it's not safe. Basically. Okay, this was a bit about Cairo.
00:34:40.686 - 00:35:37.650, Speaker B: Starknet has like a version of Cairo which you don't need to write main, and you have extra things which are syntactic sugars for your contract. For example, we have this storage VAR, which is how you have storage in your contract. Yeah, it's not immutable. For example, these three lines define a single variable in the storage of type a field element. You can read and write it using this read and write. You can also have a lot more complex storage variables, which is like a mapping from two field elements, and the result is a pair of field elements, and you rewrite like this. So it's like a map of a map with a value that is complex.
00:35:37.650 - 00:36:24.322, Speaker B: Other than storage vars, you have the external decorator, which means this is a function that can be called from outside, from other contracts, directly from user, from transactions. This is the external. So instead of having a main, you have external functions. And the external functions can have either just field element arguments or arrays, which must look like this. One defines the length and the other is the array, the pointer to the data. Okay. Yeah.
00:36:24.322 - 00:36:50.410, Speaker B: We also have a view function, which is like external, but you can also use it with the call CLI, which basically doesn't make a transaction, just does it locally and doesn't change your state. Okay, so this was a very long, brief introduction to Cairo.
00:36:51.310 - 00:36:53.210, Speaker A: Are the built ins open sources?
00:36:56.110 - 00:38:05.890, Speaker B: Okay, will it be open source? Okay, essentially they are built ins have a few parts. Okay. The question was if the builtins are open source. So the built ins have a part in the car runner, which is how we run the vm, unrelated to the proof itself, just running it in virtual machine in our computer, that is open source. You can see today. Other than that, there are the equations which you can also see in our contract, there is a solid contract that is deployed and everyone can see the polynomial equations that verify the buildings are there the things that currently isn't open source? Is just the proverbs side of them, but that is maybe under the Polaris license in the future. But most of the interesting things about built ins are open source.
00:38:05.890 - 00:39:07.780, Speaker B: Yeah, specifically the things that are needed for trust are open source. Okay, any other questions? Okay, you have this cheat sheet. You can use it when you will write things on your own. Okay, so I want to start with showing you how a contract looks like. Also if you're using this code in the setting up your environment part in our site, you can see it in the resources part. There is also a link to a vs code extension that makes your life easier when writing Kyro. Okay, let me just do a duplication.
00:39:07.780 - 00:39:46.110, Speaker B: See the same thing. Okay, so this is a sample contract, just a really simple one. Stocknet. Let's see how it looks like. Let's break it down. Stocknet contracts always start with the Langstocknet, which specifies it's the variant of language that is used in stocknet. We then give the built ins we will use in this contract.
00:39:46.110 - 00:40:17.290, Speaker B: Then all the imports we have the hash built in and the storage which is relevant to your storage. The first bit we can see here is what we saw in one of the last cheat sheet elements. It's a storage VAR. It's basically a balance. We have one variable of balance in this entire contract. It's not a mapping, just one field element. We have one external function that increases this balance.
00:40:17.290 - 00:40:53.510, Speaker B: It gets one argument amount, the other implicit and they are built in, so it's not very important. It gets the amount. What it does is read the balance and adds the amount. Not very complicated. The other function is a view function which you can use in the call, which you will see soon. It gets no argument and returns one value, which is what we get from reading the balance. So pretty simple.
00:40:53.510 - 00:42:04.150, Speaker B: Basically one variable with a setter and a getter. Any questions about what happens here? No? Okay, so let's see what we can do here. First of all, okay, you should all have this darknet compile ClI command. I tell it to compile this file and output both the compiled bytecode and the API which I can use to make call invokes later. Okay, that's compiled. I just want to say if you want to do this thing with me, you can download this contract in the docs like the resources we gave at the beginning. There's a link to the stark and docs.
00:42:04.150 - 00:42:28.030, Speaker B: Yeah, in there, there is the first contract. So you can go there and copy this and do these commands on your own. Okay. So now that I compiled it, I can deploy it using stocknet deploy. It's pretty easy. Stock deploy. And the contract.
00:42:28.030 - 00:43:05.380, Speaker B: Okay, so I initiated the deploy. There's a transaction id and the contract address. What I can do now is, let's say, starknet. Let's see the commands I have in Starknet. I have the get transaction, which you can see. I can give the transaction id and see what's up with my transaction. Okay, it's received.
00:43:05.380 - 00:43:57.240, Speaker B: What I want to do is wait a bit until the status is changed to pending. Pending is the second form of finalization we have, like Tom, discussed before. After a transaction is received, we need to wait for it to be batched in some batch, which is the consensus mechanism, but it's still not in l one. And after a longer period, when a proof is generated, then it will also be in l one. And that is the final confirmation right now to work with it. It's enough to have it pending. We also have a web Ui for it, the Voyager.
00:43:57.240 - 00:44:42.910, Speaker B: Voyager online. We can check the transaction over there. You can see it's still not inside a block. By the way, you can look at all this transaction, what they did. Look at the contracts and read and write from the contracts. Okay, so transaction is inside. So you can see here, this is a transaction 37 seconds ago sent to this contract.
00:44:42.910 - 00:45:12.434, Speaker B: We can see the functions we have. We have get balance. If we just query the get balance, we get zero because we haven't did anything inside. And also notice that it's a getter for a single variable. It's not anything amazing. We can increase the balance, but I want to do this from the ClI. So let's do it in the ClI.
00:45:12.434 - 00:45:44.120, Speaker B: First of all, just notice now the status is pending. This is second confirmation. Okay, so let's do a call just to make sure our call will be reasonable. Call the function, increase balance. Let's see what else I'm missing. Address and Abi. This is the address.
00:45:44.120 - 00:46:21.740, Speaker B: And the ABI is one of the artifacts of the compilation had. And, oh, I need to add an argument at input. So I'm adding balance. How much I want to add, let's say 1234. Okay, so the call passed successfully. So I'll just do the invoke. Invoke actually makes a transaction and sends it to starknet.
00:46:21.740 - 00:47:04.920, Speaker B: Okay, now I have a transaction id, and I can wait for it to be accepted. And once it will be accepted, I will be able to do the call on get balance, and I will see my balance do it in a minute. So this is the basic interaction with starknet. Are there any questions on this interaction? No. Okay. So right now I want to add some functionality like having balance for one user is kind of silly. So let's add a user.
00:47:04.920 - 00:47:47.730, Speaker B: I want the balance to be a mapping right now. So I'm adding an argument here a user, and now it's a mapping. Now it tells it me that hey, don't have enough arguments here. So let's read user equals user and edit as an argument. Yeah, user is undefined. So edit as an argument is a function. And when we write I can't mix like this.
00:47:47.730 - 00:48:08.104, Speaker B: Okay. So increase balance is okay. And now get balance. I need to do user equals user. Okay. What, give it the user. Yeah.
00:48:08.104 - 00:48:45.618, Speaker B: Also need to add the user as an argument. Thanks. Okay. This wasn't very hard, I think. By the way, let's look at a previous thing we added to the balance right now. The transaction we invoked before adding one, two, three to the one to three, four to the account balance. We can see it's here.
00:48:45.618 - 00:49:03.770, Speaker B: This is the balance. Okay. Go back here. Okay, this is nice. But I also want to add some authentication mechanism. Don't want to let everyone increase balance of everyone. I want to add some signature for the user.
00:49:03.770 - 00:50:01.440, Speaker B: So what I'll do is add as an argument the signature here. Let's say the signatures in a cover or two field elements are in this. And I'll need to use a signature. I have my cheat sheet here. Yeah. These are the procrastinate imports. And just let's see, where's the cheat sheet? No, do not look at that.
00:50:01.440 - 00:50:33.490, Speaker B: Okay, my cheat sheet. Where's my cheat sheet here. Okay. This is cheat sheet. Okay. This is how I use the verify CDC signature. And here I'll also verify, doesn't really matter where, but I'll verify.
00:50:33.490 - 00:51:15.280, Speaker B: And let's say the message I want to just the amount means basic enough. User should just sign the amount. The public key should be user and here. Okay. So right now it yells at me that I don't have the ECD say built in passed. Indeed, we can see we only pass it the hush built in. So just add the ECD say built in.
00:51:15.280 - 00:52:07.290, Speaker B: Doing it in one hand is not helping. Okay. And now it says that it doesn't know it's an entry function, it's an external function. It doesn't know what to give ECDSA because I didn't add it in the built ins. So I'm adding ECDSA in the built ins. Okay. And now everything should work.
00:52:07.290 - 00:52:50.780, Speaker B: So again, let's compile compiled. It's good. And I'll deploy it. And now we just need to make a valid signature, call it with the right arguments. So for this we have, as I showed you, as you can see in the cheat sheet, how to create valid signatures. So this is an example. This is like creating a private key.
00:52:50.780 - 00:53:31.640, Speaker B: Let's say this is my private key, very safe, and I'm making a public key. And I'm also signing the message for three, two, one, with this private key. So this thing will be our user, the public key. And this will be r and this will be s, the signature we will give it. So let's do the invoke. Starknet invoke function. I want to do increased balance again.
00:53:31.640 - 00:54:12.280, Speaker B: Now what are the arguments? Okay, probably also missing address and things. No, this was the address. Yeah, no, this is the address. Are you saying I forgot to. Oh yeah, this is a contract. Thank you. This is the address and the contract.
00:54:12.280 - 00:55:06.950, Speaker B: Abi. It's a function and inputs are, let's see, user, this is our user public key amount, we sign four, three to one. So that's what we need to give it rns signature. Before we do an invoke, let's do a call. Okay, so the call passed. If I would have passed it, a wrong signature, for example like this, then it would yell at me because it's the wrong transaction filled wrong signature. So signature mechanism works, which is good.
00:55:06.950 - 00:56:06.330, Speaker B: And instead of a call, do an invoke to actually do a transaction. Okay, so basically what we did here is added this complex mapping instead of just a single variable. And we also verified signatures. As you remember from Tom's talk, users don't sign transactions when they send them. So basically anyone can send anything unless at least currently you enforce it in your contract. In the future we'll have probably account contract so you can rely on the sender of transactions. But currently we need to verify the signatures inside the contract itself.
00:56:06.330 - 00:57:10.918, Speaker B: Okay, are there any questions what we did here? You guys are good. Okay, so next thing I want to show is l one communication. Did I forget anything for that? Okay, l one communication works both ways. You can send messages to l one and get messages from l one. So let's see my cheat sheet here, how it works. Yeah, I have it, I have it here. Okay.
00:57:10.918 - 00:57:46.286, Speaker B: This is an example of, this is basically what we did before. And now there are additional functions which let's go through what they do. Okay, it's a withdraw and deposit. Withdraw is basically something I invoke at l two, it reduces some balance from l two and then sends a message to l one. Let's see how it looks. First of all, we verify that amount is indeed in the right range. It's non negative because we don't want to reduce the amount, not edit.
00:57:46.286 - 00:58:17.998, Speaker B: So make sure it's non negative. Note that to use this thing we must pass the range checkpointer. This is what allows us to do all these arithmetic operations. Okay, so now that amount is good, we read the current balance and deduce and verify that the new balance is not negative. That user has enough balance. And then we write the new balance. At this point, we deduce the amount and we need to send a message to l one.
00:58:17.998 - 00:59:19.700, Speaker B: So we create a field element array. Basically, just using the alloc, we write three words. The first is some identifier, some selector that mentions, hey, this message is of type withdraw, and the next is which user did and with what amount back at l one, we should have a corresponding solidity contract that can parse this thing and we'll see it shortly. This contract, how it looks like. Okay, so now that we have this payload, we just use the send message to l one library function. We import to l one address, which we defined here. L one contract address just number the size of the payload, which is three, and the payload itself just sending a message to l one now.
00:59:19.700 - 01:00:11.046, Speaker B: Yeah, exactly. In the same way that for using cert nn, we need to pass the range pointer. And to send message to l one, we need to pass the Cisco pointer, which lets you do some stock and system calls. Okay, so how does this l one content look like? I had it here somewhere here. Let's just have a brief look at it. Okay. First of all, this is so you know how to write the counterpart ethereum contract that talks with your contract.
01:00:11.046 - 01:00:43.900, Speaker B: There is an interface you probably get from somewhere else, the starknet core, which has send message to l two and consume message from l two. So basically when you send a message to l one in your contract, it still doesn't automatically apply it to l one. Someone needs to issue an ethereum transaction to do it. In the future we have something automatic that does it, but right now you need to issue it yourself. Yeah.
01:00:46.430 - 01:01:12.740, Speaker A: When a contract sends a message to an l two contract sends a message to an l one contract, then when we do the state update on l one, then part of the output of the state update are those sent messages to l one. And then it gets stored on the starknet core l one contract. And as Shah has shown here the interface l one contracts can consume these messages. So for example.
01:01:15.610 - 01:01:55.170, Speaker B: Yeah, okay, for example, if you see the withdraw, the withdraw function, and then it creates the same payload that we saw before. And then it basically says, hey, make sure you got this specific message and consume it like mark that it is consumed. And once we get here, we indeed got this message and we add this balance to l one, basically. So using consume message, is it clear.
01:01:55.240 - 01:01:55.860, Speaker A: That.
01:01:58.390 - 01:02:09.100, Speaker B: Consume message does? No, it marks this flag of consume. Basically.
01:02:11.230 - 01:02:27.200, Speaker A: We use counter because there's a multiple. I don't know why we draw three times one is so the message will be the same message. I don't want it to be true or false if I continue.
01:02:30.870 - 01:02:33.780, Speaker B: Okay, everything is fine.
01:02:40.240 - 01:02:41.470, Speaker A: Okay, thank you.
01:02:42.480 - 01:03:15.800, Speaker B: Okay. Yeah, I just want to repeat the question. The question was, what does consume message actually do? Does it only read? The answer is no, it also marks that the message is consumed. The implementation is there is a mapping at l one from the message hash to an integer. It starts with zero. Every time a message is sent to l one, we increase one to this number. And when we call consume message on l one, we deduce one and say passed.
01:03:15.800 - 01:04:08.474, Speaker B: No, the question was, if it must be consumed in same order, then no, the messages are unordered. There is no order on the messages. You consume it in arbitrary order. Okay, so this was sending a message to l one. And this is the opposite direction. If we get a message from l one contract has this decorator which says l one handler. Basically if you see the solidity part, then the deposit creates a payload which will be passed and when it calls we use send message to l two.
01:04:08.474 - 01:05:15.600, Speaker B: We give the l two contract address this selector of the function which will be generated from this function name. Basically it's sort of a hush, which there is a tool to deduce this vector and the payload. And then after you do it in l one, then automatically a transaction will be added to l two that calls this deposit with the correct from address, which is an ethereum address, and the payload as arguments the user and the amount. Okay, so what we need to do is here is first of all, assert that the from address is the correct l one address that we deployed. Not everybody will be able to send us the deposit messages and add balance, basically. Okay, so this was the other direction. I repeat, here we have the send message to l two.
01:05:15.600 - 01:06:04.350, Speaker B: And here we have the l one handler, basically. So, yeah, any questions about that's. There is also a mapping. So basically here you add the number. Yeah, it is called the starting core contract. Indeed, and the operator is by protocol obligated to consume this. And there are safety mechanisms, not right now, but will be that you must consume it within x time or the system will freeze.
01:06:04.350 - 01:06:05.600, Speaker B: So.
01:06:09.270 - 01:06:10.370, Speaker A: The operator.
01:06:18.070 - 01:06:32.790, Speaker B: Yeah, and when the proof is in the update state, it checks this proof, it also as part of the output of the proof, he sees I consume these and these messages and he knows reduced.
01:06:37.450 - 01:06:51.360, Speaker A: The state update won't happen if those messages do not exist. So I can just send a deposit message, a deposit transaction on L two, if a corresponding message was not sent on L one, because then the state update will fail. Okay.
01:06:57.650 - 01:07:27.800, Speaker B: Finish the part I want to show you. I think the next thing is for you to try to work on your own on this code, try and do something nice, something crazy, I know, so this will be, you have time for questions about general things, not necessarily what I talked about by Carl, by Stargraph about how to do things. And afterwards you can go hack. Yes.
01:07:35.260 - 01:07:38.730, Speaker A: Is there a reason you decided not to compile that?
01:07:42.860 - 01:08:22.170, Speaker B: Okay, the question was why? We decided to go with immutable memory instead of compiling to SSA so it will be transparent to the user in a sense. Okay, this works for variables and there is the rebinding mechanism, which basically allows you to do just that as you saw before, but it won't help you with data structures like arrays and dictionaries and things like this. Okay, any other questions?
01:08:24.380 - 01:08:27.050, Speaker A: The end code to the page.
01:08:27.740 - 01:08:29.050, Speaker B: The end code.
01:08:31.680 - 01:08:31.996, Speaker A: Yeah.
01:08:32.018 - 01:08:44.800, Speaker B: Okay, I'll add this code in a few minutes. Okay, ground working, good luck.
01:08:46.900 - 01:09:00.590, Speaker A: There's like 40 minutes, something like that, and then hopefully someone will want to present what we did then we'll be very happy to share it. If you have any questions, we are here now.
