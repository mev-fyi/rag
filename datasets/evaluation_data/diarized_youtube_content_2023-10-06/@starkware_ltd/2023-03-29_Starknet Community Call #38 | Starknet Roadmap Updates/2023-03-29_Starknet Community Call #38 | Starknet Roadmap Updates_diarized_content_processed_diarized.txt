00:00:00.570 - 00:00:25.280, Speaker A: It nice. Okay, I pressed go live on YouTube and we should be live now. Very cool. Okay, so let's start for real this time. So hey everyone, again, welcome to Starknet 38. Community call. We're at the end of March and finally we have Cairo one on Star.
00:00:25.280 - 00:00:33.638, Speaker A: Huge victory. Yeah, it's very exciting today I'm with Ariel. Hello Ariel, thank you for being here with us.
00:00:33.804 - 00:00:34.520, Speaker B: Hello.
00:00:35.850 - 00:01:22.520, Speaker A: And Ariel, you're at stockware and you're very much in tune with what's in upcoming releases and the development process of Stocknet. So I figured we'd do a small recap. We already did a community call last week to talk a little bit about zero point eleven. I think there are a few things I want to dive a little more into. And then I'd like to talk a little bit about zero point 120 Twitter people on YouTube, you can ask us question either directly on Twitter or on YouTube. We'll read them and we'll make sure to answer them. So first of all, let's see.
00:01:22.520 - 00:02:10.230, Speaker A: So can you talk a little bit? Let's roll back. Last week zero point eleven was deployed on Starknet's testnet. So it's now usable on Testnet and people can write and deploy Cairo one contract on Testnet. I think with this new release we're about to when we have alf introduced a new way for people to compile, contract and deploy them. So it used to be you downloaded Cairo Lang and then you could compile with the CLI your set of contracts. Now it's going to change a little bit. People will have to clone Cairo one and build it locally or at least download an executable.
00:02:10.230 - 00:02:35.200, Speaker A: But an important point here is that the Starknet version of Cairo one is not necessarily going to be the exact same one as the latest Cairo one commit. For example, the team for the compiler of Cairo one keeps on chugging and shipping updates. It doesn't mean you can use these automatically in your Starknet contract, is that correct?
00:02:36.610 - 00:02:46.862, Speaker B: Yes. So unless you know what you're doing, what I would do is check out on Alpha six of the compiler, which is the version of the compiler throughout eleven.
00:02:47.006 - 00:02:48.740, Speaker A: How do we check it out?
00:02:49.910 - 00:03:11.660, Speaker B: How do you check it out which is named Alpha six some Cairo one, alpha six, something like that. And you can just check out it and build locally and then you have the compiler, the same compiler that is used on Startnet available?
00:03:12.590 - 00:03:41.700, Speaker A: Yes, actually I didn't know that. I'm going to share this immediately so that people can see it. Wait, I'm going to clean a little bit. There you go. So you're here, I'm here in the Cairo one or Cairo repo. Right. And if I want to build my contract I'm going to go click here.
00:03:41.700 - 00:04:01.914, Speaker A: This is where I got the Alpha six version of the compiler. Now if I want to get the proper branch, I'm going to click on the commit number here, right. And I can clone the repo and then do git checkout with this particular commit hash and I will get the.
00:04:01.952 - 00:04:12.320, Speaker B: Repo at that height you can also do git checkouts and this exact name. V one Alpha six.
00:04:13.090 - 00:04:46.680, Speaker A: Super cool. All right, so that's how you get the proper compiler version. Very nice. And so how will the development process be in that regard? Will there be, I'm guessing, will the Cairo one compiled and released version be always in sync with Starknet? Will the next version release, the next release of Cairo one be with the next version of Starknet or will there be some before?
00:04:47.470 - 00:06:00.494, Speaker B: So at the moment we're thinking that compiler releases will be in line with starknet releases. In theory there are compiler changes that can take effect on Starknet and are not breaking, but the current focus of the compiler team is adding more lib funks to Sierra, which is exactly the type of changes that will be breaking. And you will need to upgrade the compiler on the sequencer for them to take effect. So for now we're thinking about compiler releases being very coupled to start net releases. I was just going to say that once the compiler team shifts the focus towards more higher level language features, then we'll probably reconsider this. Nothing is set in stone and we'll see how we go about distinguishing between changes that can take effect immediately in startnet and changes that require a startnet upgrade. Nice.
00:06:00.532 - 00:06:21.160, Speaker A: So we're learning how to walk. Pretty interesting. And can we expect this thing to happen on every minor release of Starknet, or minor or major one? Like we've just had zero point eleven. If there's zero point 11.1, can we expect a Cairo one update or no?
00:06:22.090 - 00:07:05.594, Speaker B: I think this will depend on what will we have in the compiler if we'll have features that can justify a release and be beneficial to the community. Like more stuff on Cairo one there won't be release of the compiler just for the purpose of releasing. I think for eleven one we will have it. I'm not completely sure, but I expect that we will. Small patches like fixes like eleven one and the eleven two that we're expecting will not be coupled to the compiler in any way. The compiler will stay fixed.
00:07:05.742 - 00:07:12.646, Speaker A: Can you talk a little bit about eleven, 111 two and 11.1 please?
00:07:12.828 - 00:08:49.400, Speaker B: Yes. So we had a lot of feedback around issues in the CLI, making some inconsistencies in usage of Cairo zero and Cairo one, and declare V two not being straightforward throughout the CLI, which is partly related to how do you use Cairo one from Cairo Land? And the first minor release I think fixed some bug in the CLI, which I'm not sure what exactly this was, but the upcoming one is supposed to improve the current experience a bit and allow you to specify a path to a locally built compiler, which should solve the problem of certain architectures not being able to use the CLI because the existing compiler binary inside Kyoland is only fitted for Linux architectures. Cool. So that's 0.1, that's eleven two. The upcoming one, the first one. I don't remember exactly what the bug was, but it should be in the release notes, but also a CLI related bug that was fixed think hours after the release itself.
00:08:49.400 - 00:08:50.678, Speaker B: Cool.
00:08:50.844 - 00:08:53.622, Speaker A: And what about 11.1?
00:08:53.756 - 00:09:19.790, Speaker B: Yeah, 11.1. So for 11.1 we have some small expected features which didn't make it to eleven. I think the most important one is reducing the sensitivity of gas sampling. So today there are a nontrivial amount of transactions that are being rejected due to insufficient fees.
00:09:20.850 - 00:09:22.634, Speaker A: Heard of all transactions, right?
00:09:22.772 - 00:10:37.794, Speaker B: Yes, a very high, unexpectedly high percentage. Something like this. And that's why when we're counting internal failed transactions we see something like four point xtps, while if we're only counting successful ones, it's around 1.81.9. And what sucks about transactions that fail on fee estimation is that the sequencer actually has to run them all the way to figure out the fee is insufficient for inclusion. So you've basically already wasted as much sequencer resource as you can. So the idea is to reduce the sensitivity there, and instead of the sequencer resampling the l one gas price on every block, which I'm reminding if you're looking at the current fee mechanism of Starknet, everything is measured in l one gas units because we're only charging for the marginal cost of proving the transaction. Sorry for verifying the proof on l one, not for proving.
00:10:37.794 - 00:11:12.020, Speaker B: And this is measured in gas. We are sending a transaction with a proof. It used to cost around 5 million, now it can be even closer. I think around 8 million gas sometimes depends on the size of the exact proof. And this proof probably involves a whole bunch of other programs. It involves Starkx instances, it's recursive proofs with many starknet blocks. And your small transaction has a small part in the verification and the current fees are attempting to reflect this.
00:11:12.020 - 00:12:02.078, Speaker B: And this is why they are measured in l one gas. And this is why the sequencer, whenever it starts walking on a block, it samples the current gas price and we just want to make it less sensitive. And instead of completely changing the sample every block, make it a moving average. I don't have the technical details, but let's imagine an average, a moving average over the less 100 blocks. So if you estimated the fee currently, and your transaction gets included five blocks later, the price estimates that the sequencer will use will be very close to what you use during estimation, making it much less likely for your transaction to be rejected due to insufficient fees.
00:12:02.254 - 00:12:25.946, Speaker A: Interesting. But sometimes when I use the CLI, I send a transaction and I get a fee estimation error. Basically like the actual fee exceeds the max fee. In this case, I think the CLI pulls the sequencer to get the estimate fee and then sends the transaction. So will that solve this when you.
00:12:26.048 - 00:12:28.154, Speaker B: Query estimate fee or getting.
00:12:28.272 - 00:12:30.810, Speaker A: No, when I send a transaction through the CLI.
00:12:31.310 - 00:13:02.070, Speaker B: When you send a transaction through the CLI, yes, that's exactly the issue we're talking about. I don't remember how much extra is the CLI adding on top of, I think wallets are adding 10% or something in this area to make sure the transaction to be more resilient to fluctuation in prices. I'm not sure what is the number in the CLI, but yeah, that's exactly the issue that this change will tackle.
00:13:02.570 - 00:13:17.260, Speaker A: Nice. It's interesting. So basically, since we don't have failed transactions, transactions that would fail due to lack of gas are just not counted in some explorers and are counted in others.
00:13:17.630 - 00:14:06.170, Speaker B: Exactly. And related, there are also non failures, which are probably caused by fee estimation failures. Because let's say you had five transactions going in with nonsense, one after five, and if your first transaction ends up not being included, and you're only waited for the received status for sending the next transaction. So the sequencer hasn't looked at anything yet, but you know it received one. So you're sending two and then you're sending three, four, five, and unfortunately one is failing due to sufficient fee, then two to five will fail on invalid nons.
00:14:06.750 - 00:14:07.834, Speaker A: Not fun.
00:14:08.032 - 00:14:15.934, Speaker B: Yes. Okay, so eleven, one should treat this issue nice.
00:14:16.132 - 00:14:34.100, Speaker A: While we're on the topic of eleven, I think there are two points I want to three points, actually. I'm going to take note so that we don't forget one is about wallet needing to upgrade. And I see that we just retweeted something about that. Can you explain here what is the issue please?
00:14:35.770 - 00:15:42.570, Speaker B: Yes, so ever since version zero point ten, which was, I don't remember to be honest, version zero, transactions have become deprecated and some very old accounts have not yet updated. The change in account contracts was the separation of the execute function into two functions, one execute and one validate. So there are still some old accounts which have the validation logic inside this single execute function. So both major wallets, argent and Bavo, said a bunch of versions sent them. So if you upgraded through the app, then your account now separates this process into validate and execute. But all the accounts who did not upgrade will not be able to send VZO transactions because they will no longer be supported as of eleven.
00:15:42.990 - 00:15:46.700, Speaker A: As of eleven. So when is eleven on main net?
00:15:47.870 - 00:15:48.730, Speaker B: Tomorrow.
00:15:49.070 - 00:16:11.970, Speaker A: Tomorrow. So if you have an account on Mainnet, you should log in very fast and check. Actually, I'm going to do it right now. No, I'm kidding, I already did it a while ago, but okay, so message to everyone hearing us. If you have a wallet on Starknet, you should connect to it today and check whether it upgrade your wallet because it may be useful.
00:16:13.110 - 00:16:26.934, Speaker B: Yes you should. But just to calm people who are alarmed, if you logged into your wallet anytime in the last, I don't know, three months, probably more, then you're fine.
00:16:27.132 - 00:17:21.354, Speaker A: Yeah, likely most people will be fine. All right, second question I wanted to talk about is one of the thing I'm mostly interested about for Cairo one was the fact that you can prove that the transaction failed. And this introduces the capacity to have DoS protection for the sequencer because now taking the example you just mentioned, right, we get failed transaction and we can't charge for these. Cairo one introduces the building blocks to address that. But this is not live yet. I realized it not so long ago and actually makes sense, right? Because just because we have the capacity in Carawan to prove that an execution failed doesn't mean that this has been implemented. So just wanted to go back on that.
00:17:21.354 - 00:18:11.894, Speaker A: Correct me if I'm saying anything stupid. Currently, while your transaction can, when you send a transaction and your program fails, technically the Cairo program completes and you could generate a proof for that. But the OS of Starknet is not equipped for that yet. We haven't written what is this failed transaction, what does it mean to be a failed transaction for the OS? And we haven't programmed the part where we basically have a transaction that is executed but doesn't do anything to the state. So this is a feature that will come in the coming months. It's not the highest priority. Or is it? What's the expected timeline? But yeah, I guess timeline, not in terms of months, but in terms of version.
00:18:11.894 - 00:18:15.130, Speaker A: When can we start seeing failed transactions on Starknet?
00:18:15.470 - 00:18:51.682, Speaker B: Yes. So it's not part, or at least not planned to be a part of the next two major versions. So we can talk about what's planned for those later. It is planned to happen before regenerasis, but that's the best resolution I can give now. But yeah, like you said, there are things to be implemented in order to have failed transactions in the block. We need to add the notion of reverts. We need to have the Startnetos know how to basically revert updates from a transaction up to the point of failure.
00:18:51.682 - 00:19:35.594, Speaker B: Part of this code already exists, for example, checking whether a call is out of guess or not. The remaining guess is being passed around throughout all the calls. It is simply ignored and everything is handled externally at this point. So we have the foundations, but this needs to be implemented. Like you said, I think there are two things to distinguish here. So Sierra gives two things. We usually think about it only in terms of proving failed transactions, and we treat out of gas as an example of a failure.
00:19:35.594 - 00:19:40.280, Speaker B: But gas metering in general is something that we don't currently.
00:19:40.970 - 00:19:43.670, Speaker A: Yeah, it wasn't here before and now we have it.
00:19:43.820 - 00:20:27.122, Speaker B: Yeah. So Sierra gives you the ability to basically dynamically count how many steps were executed. And if you think about it, when your transaction reverts on Ethereum and it costs such and such amount of guests, then it isn't part of the EVM opcodes. You just know that every validator participating knows to separately count after each EVM opcode. It should update the gas counter separately. So basically for every instruction you have some overhead for updating the gas counter. But this doesn't happen in the EVM itself.
00:20:27.122 - 00:21:09.090, Speaker B: There's no reason for it to happen. It is part of the consensus of what we're agreeing on. But when you're talking about ZK roll up or you need to prove everything that happens, I can't just say, yes, this transaction was successful and it costs one k guess. I need to prove that one k guess was consumed. And if I have an overhead for every instruction where I need to upgrade some value in the memory, then I'm basically blowing up my poof by a factor of two just for gas metering. And Sierra has a lot of interesting machinery to make it less than a factor of two and basically have only a small overhead.
00:21:10.470 - 00:21:48.570, Speaker A: This is really interesting. It's true when you think about it. The purpose of the EVM is to give developers a programmable environment that is deterministic. But a lot of stuff we agree on consensus wise are not written in the EVM, right? Because it's the same code for everyone. So we have other ways to write deterministic code. But if you want to do this with a ZK roll up and not have everyone agree on stuff, you have to do everything in the same language, everything with the same primitive, so that it's provable. This is the same issue we're having with lib funks.
00:21:48.570 - 00:22:12.310, Speaker A: I mean the same issue. This is the same challenge we're having with lib funks that Ethereum can get away with. Pre compiles, right? Pre compiles are not written in the EVM, they're executed outside the EVM. But we need everything to be provable, so we can't really take this step out. It's really interesting in a way. Pre compiles are like hints for the EVM.
00:22:14.730 - 00:22:26.090, Speaker B: I think it's a good description. You're basically saying what operation you want to do. We agree on how much gas it costs, but we don't implement it with EVM. Opcode.
00:22:26.910 - 00:23:13.322, Speaker A: Interesting. All right, thank you for this clarification. So fed transactions before Genesis, but not too soon. Yes, another question, and I think it was a surprise to some people. I don't think we were super clear on that, but so technically what Cairo one on Starknet means is in its very concrete version is you now have a new version of transactions which are v two declared transaction that allow you to declare a Cairo one program. And the Starknet sequencer treats these as a Cairo one program, and it knows that it's a Cairo one program. So this is what it means.
00:23:13.322 - 00:23:48.440, Speaker A: Cairo one is now available on Tarknet and this is available on Testnet. But V two transactions are not going to be straight away available on Mainnet. You mentioned that Mainnet is going to be updated tomorrow. V two transactions are still not going to be part of this. So in other words, what will be on main net tomorrow is a feature limited version of eleven, just to get a little time to have more insight on how Chiro one work. Is that correct?
00:23:49.450 - 00:24:50.482, Speaker B: Yes. Want to have people playing around with Cairo one contacts on Mainet if they are on Testnet, if there are some weird bugs that weren't found doing whatever internal or external audits, then we want those found. By the time we'll remove this limitation on Mainet, hopefully we'll be able to get an external audit in as well. So essentially yes, we wanted the development to move forward and apps to start accumulating experience. And the voices that we heard so far weren't like, I want to deploy my ready app on Mainnet, but okay, I started writing Chiron, but I have nothing to do with it. So hopefully this is answered and the next challenge is to feel more comfortable and then we can remove the limitation on Mainet.
00:24:50.626 - 00:25:22.500, Speaker A: Okay, so zero point eleven is not just about car one. There are other cool features like replace class hash, the thing that gives you the ability to deploy a contract, and then later on move it to Chiro one. And so this gives the ability for people to start deploying their app now on main net and then later update to Cairo one. But if I'm an app and should I start working on my Cairo one code right now, if I can't deploy it to Mainnet, are we talking about a few days, a few weeks, a few years?
00:25:23.750 - 00:25:54.160, Speaker B: I think a few weeks to a small number of months, but don't quote me. Definitely not a few years. And yes. And to answer your question, then definitely yes. You want to be ready with your app for when this feature is enabled and not just start developing once it can hit mainet, because then you'll be much behind.
00:25:56.690 - 00:26:15.640, Speaker A: But yeah, very nice. Okay, cool. So I hope this clarifies it. This is great. I think we've talked a bunch about version 00:11 I'd like to hear you. What's next? What's in zero point twelve?
00:26:16.570 - 00:27:13.046, Speaker B: Sure. So twelve is back to performance, and I think it will not, feature wise, it will not affect anything. It will be completely focused on increasing the TPS. And the way to do it is to transition to the rust 3.0. So there's this public repo inside, I think Star warlives, which is called the blockifier, and was essentially taking the pythonic sequencer and taking out chunks, making them, implementing them in rust and replacing them. So the blockifier is the big chunk, probably the biggest chunk that is responsible for the transaction execution. We're taking that out.
00:27:13.046 - 00:27:58.854, Speaker B: We're also going to use for the first time our internal full node implementation, which is propyrus. There's a certain caveat which we're not using it as is out of the box, but we're taking basically its internal logic to implement the sequencers storage layer. So basically the database layer is going to completely change the execution logic. Is going to completely change everything in rust. And the only thing that will remain pythonic are the external services, the gateways, and the, let's say, main process that's responsible for initiating the block creation, which.
00:27:58.892 - 00:28:16.906, Speaker A: Is still pretty big, right? Zero point twelve will be hopefully a massive enhancement on Starknet, but after that, we can still expect some further enhancements once we change those external services.
00:28:17.008 - 00:29:02.006, Speaker B: No, the external services will not affect those because these are essentially mempool management. Maybe they can improve user experience, but not TPS. Regarding the other parts. The other parts will probably have a much smaller effect, but they will save on those Python rust contexts, which is that will happen. But I think the bulk of the improvement will be with the twelve. I think after twelve, the next major step, TPS wise, is doing what we did for the pythonic sequencer.
00:29:02.118 - 00:29:11.658, Speaker A: Yeah, that's also something I wanted to ask. Right now, the sequencer processes transactions in parallel, and it's not going to be the case anymore.
00:29:11.834 - 00:29:48.630, Speaker B: Yes. So we worked hard on getting parallelization into the pythonic sequencer. It did help, but by a factor of, I think, two to four, something like this. Pretty cool. And it turns out, maybe not unexpectedly, that transitioning to rust gives you a much higher improvement without working on parallelization. So we figured out we'll roll that out first and then use our experience from the pythonic sequencer to reintroduce parallelization.
00:29:48.970 - 00:29:55.786, Speaker A: In rust, we got parallelization, then we're taking it out, and then we'll put the feedback again. Nice.
00:29:55.888 - 00:29:56.540, Speaker B: Exactly.
00:29:58.910 - 00:30:03.230, Speaker A: Well, it's good that we're optimizing for performances.
00:30:04.850 - 00:30:05.840, Speaker B: I agree.
00:30:07.410 - 00:30:21.970, Speaker A: All right, so that's for zero point twelve. So zero point twelve should be about speed. What about zero point 14? First of all, did we consider not doing a zero point 14 and going straight to zero point 14?
00:30:24.150 - 00:30:24.754, Speaker B: Why not?
00:30:24.792 - 00:30:31.414, Speaker A: Straight to zero point 1513 is a particular number.
00:30:31.532 - 00:31:15.630, Speaker B: I see. No, but maybe we should. Maybe you should consult it. Maybe you should reconsider. No, it's not too late now. So we've been talking about different data availability options for a while, and currently data availability is about 95% of transaction fees on Starknet. So just for context, you send a transaction, you pay for two things, you pay for the marginal cost of proving on l one, but this has two components.
00:31:15.630 - 00:32:10.514, Speaker B: One, the computation. Each chiropractor step you're doing is another chiropractor step we're going to prove, and it has some small cost. That's computation. And then you have on chain data, which means each storage cell you're changing is going to reach ethereum as call data, because we want to make sure that even if the sequence cell goes down, then the state of starknet can be reconstructed just from l one. That's the whole point of working in roll up mode. And this means that a single storage update costs 512 guests, or actually one k guests, because we need to submit two words to Ethereum, one for the key and one for the new value. And each word is 32 bytes.
00:32:10.514 - 00:32:40.526, Speaker B: Each byte is 16 guests, so you end up with one k guests for each storage update. So if your transaction is, let's say, let's call it storage intensive, then it can get pretty expensive, even if the computation is negligible. Obviously it will be much cheaper than Ethereum, but it won't be, I don't know, orders of magnitude cheaper, which is.
00:32:40.548 - 00:32:45.026, Speaker A: What we want with an s. Oh no, actually you're right. Even.
00:32:45.128 - 00:34:19.920, Speaker B: Yeah, okay, I'm not sure if you take transfer transaction, and I don't remember the latest estimates for like transfers or swap, how much are them? I think we may reach one order of magnitude there, but with the existing situation. But in any case, the big potential for improvement is not with improving computation costs, but with improving data availability costs. And by the way, we're not talking about it, but in eleven we did decrease the cost of computation by five x. Each chiropractor step becomes five x cheaper. And it's not like arbitrary okay, computation is cheaper now, but we've been using recursive proofs for a while and we can now better estimate the marginal costs of proving when your transaction is actually part of recursive proof. And sorry, I keep saying the marginal cost of proving, I should say the marginal cost of verifying the proof on l one, which is the bulk of the cost, and we ended up with newer estimates and the number is now five x smaller. Yes, but in any way, when we're talking about 13 and the focus on reducing the other 95% of the transaction cost.
00:34:19.920 - 00:35:25.106, Speaker B: And in 13 we plan to introduce volition, which means to be able to choose whether specific storage values go to l one, which means they use the standard on chain data availability solutions solution. Or are you essentially trusting the l two consensus, which means you're trusting the sequencer and full nodes operating on top of Starknet to hold that data and make it recoverable. In that case, the price will obviously be negligible compared to the one k guest per storage update. And this entails many components, because there's a question of how does it look inside the smart contract? Okay, I want to pay less. I want my storage updates to not reach l one. So there will be a special syntax where you mark a storage variable in a way as off chain storage variable. There will be ways to change it.
00:35:25.106 - 00:36:27.750, Speaker B: There are questions of how an ERC 20 contract will then look, if I want my balance to be off chain, I don't want any transfer transaction to cost much more because I need to publish my new balance on chain. So there are many questions like low level design questions there, which will affect smart contract developers as they will be the ones making the maybe not making the decisions, but writing using this syntax to allow variables to not go on chain. The way I'm imagining it, as a user, when you're using an ERC 20, you'll be able to decide whether your balance is held off chain or on chain. And the way I'm imagining in it is you will hold 99 million out of your 100 million usdcs in an on chain balance, and the remaining million you'll hold off chain.
00:36:29.710 - 00:36:39.500, Speaker A: You'll have your savings account on chain and your checking account like your main account on chain. That's actually a smart way of doing that in terms of security.
00:36:40.510 - 00:37:02.942, Speaker B: I fear that when we're using off chain here, people think of it like as those 1 million, that 1 million is somehow not on stocknet, but no, it's part of the stocknet state. It's just like the other part, except that the new values, the storage updates, aren't being posted on Ethereum, they are just being posted elsewhere.
00:37:03.086 - 00:37:21.180, Speaker A: You can use them exactly the same in your smart contract, just that it lives on a Pathfinder node instead of living on an ethereum node. So we have a question here. Elias is asking which team is in charge of the volition project. I'm thinking this is Starkware, right?
00:37:22.110 - 00:37:45.300, Speaker B: Which team? I mean, it will be in starkware. I don't know. If you're asking inside Starkware, then I will tell you that, I don't know, probably the same team that is working on the startnet backend, but there is a lot of compiler work because we're going to have to add this syntax to storage variables, so there will be a lot of compiler work alongside it.
00:37:45.910 - 00:37:58.294, Speaker A: Interesting. All right, cool. So we've covered 1112 13 and I don't think we have 14 yet. I mean, we don't know yet what will be there, right?
00:37:58.332 - 00:38:05.026, Speaker B: Maybe reverted transaction and using CRS gas metering. That would be cool, but who knows?
00:38:05.138 - 00:38:28.720, Speaker A: Yes, very nice. All right, I'm checking if there are questions. If there are questions, on YouTube. Don't hesitate and write them in the comments. You can also ask your questions on Twitter but I don't see many. I think I've asked most of my questions. Rayel, is there anything you think would be interesting for people to know?
00:38:33.410 - 00:38:54.886, Speaker B: I don't think we've missed anything. Obviously there are a lot of interesting discussions to be had actually on everything we've talked about. But since we've just talked about volition, interesting discussions to be had on the different security guarantees between posting data on l one and posting it on l.
00:38:54.908 - 00:39:04.566, Speaker A: Two s, we'll make a call out of volition. I want to dive in this topic a little more so we'll get into it more in depth later on.
00:39:04.748 - 00:39:05.800, Speaker B: Sounds good.
00:39:06.250 - 00:39:16.880, Speaker A: Wonderful. All right, so there's no more questions. Let's wrap it up here. So to everybody who was here, thank you for joining and we'll see you soon.
00:39:17.890 - 00:39:19.370, Speaker B: Bye everyone. Bye.
