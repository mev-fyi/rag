00:00:03.190 - 00:00:48.946, Speaker A: So hi everyone. For everyone not familiar, my name is Mitch and I'm CTO of Switchboard. And today I'll be talking about the switchboard Oracle protocol and us entering the Starknet space to help grow DeFi platforms and any other platform that might need an oracle in this space. And really excited to be helping out with Starknet, the Starknet ecosystem. So anyways, to start off, has anyone built an app that's needed to integrate an oracle of any kind before show of hands quickly? Few developers? Four or five? Okay, great. Well, for those who aren't familiar, there's plenty of types of apps, especially defi apps, that do need different types of data. For some of those you might need price feeds, sports data, NFT floor prices.
00:00:48.946 - 00:01:31.490, Speaker A: If you want to make dynamic nfts, maybe you want to take real world data about weather, about a location of a person, any types of information. It's really infinite. So what Switch protocol actually offers is a permissionless oracle protocol that is developer first, customizable and multichain. So what do we mean by this? Well really when we talk about permissionless DeFi, we really need permissionless data too. So if you want to spin up, let's say a feed for, let's say a long tail data set, let's say current meme. Point is bonk the liquidity of a long tail data feed. You might need some liquidity sources that are off chain.
00:01:31.490 - 00:02:15.010, Speaker A: So you can get that by actually designing and creating your own data feed through switchboard, which we let anybody do and configure themselves in a no code fashion. And on top of that, we actually offer a VRF on some of the chains we support too. If you actually need true support on a deterministic world like the blockchain, you need a system like a VRF where you can actually decentralize the sourcing of randomness and not actually have that revealed until all the party seeds are committed and no one can predict before that final results entered. So yeah, just some use cases that I went over before. A lot of people use oracles for price information. Let's say you're making a perpetuals market. You need to know the funding and the quotation rates.
00:02:15.010 - 00:02:49.726, Speaker A: Let's say you're doing cross collateralized lending. You need to know the lending rates for different assets and any type of prediction market. You need a sports data for some game, a lot more ephemeral things. Sometimes you need to spin up a data feed for things, events that are just happening for a day, for even a few hours. And that's what switchboard is really good at actually. So to go into a little bit of the architecture of how switchboard works, there's a few different data types. Inside of our actual program we have what we call Oracle jobs which actually direct what the oracle should be doing.
00:02:49.726 - 00:03:27.980, Speaker A: Data feeds which report, let's say a price on chain. It actually holds the data that oracles bring back the oracles, which is the off chain machine. Oracle queues which manage allocation of doing this work through the entire switchboard network and cranks which are responsible for asynchronous task scheduling. Yeah, so you see the oracle jobs can actually utilize the schema that the developer creates and do any type of job fetching on chain or off chain of all the data that it was told to propagate. The data feed. It's essentially what you configure. You can actually fund an escrow associated with the data feed and that's used to pay out all the oracles as they do the work for you.
00:03:27.980 - 00:04:00.578, Speaker A: The oracles are the actual containers off chain that are fetching all the resources. Oracle queues are made for allocating different machines in the network and the cranes for scheduling. As I said before, this is a higher level architecture of how switchport actually works. In the top left you could see a person actually making a data feed. What they do is they configure this tree like structure of different jobs for how oracle should fetch the soft chain data. Those are then sent to a data feed which are all processed in the tree like order. If they can be processed in parallel, we do try to optimize for that.
00:04:00.578 - 00:05:08.518, Speaker A: Then they can set off to the oracle queue which where they are allocated around robin matter, or they're switched in order essentially to make sure that we don't have a consistent grouping of oracles always assigned to a certain data feed. Those oracles watch for all the responses and then report that back on chain. And if there is a failed response, we actually have a mechanism for a fast retry to make sure we can get the information to on chain as fast as possible. So how oracles currently work, or in the classical sense, is that you have many machines performing the same actions, at least for switchboard. We can have, let's say different APIs, like a binance API, a kraken API, Bitfinex API, all fetching the price data for a certain asset and maybe even weighted by liquidity if you want to make sure the price effect of any movement is accurately portrayed on chain relative to what exchange you're looking at. And those are all dolled out to oracles that are then assigned in a queue to a data feed, and then those are published on chain for reflecting all the jobs that are inside the data feed, as you see on the right here. So we have a few different products that we actually have here we have the explorer where you can see all the data on chain and how it's being fetched.
00:05:08.518 - 00:05:48.402, Speaker A: The schema is being fetched. We have the publisher, which makes it really easy for anyone to go and put their own data on chain. The feed builder, which is the no code drag and drop solution for anyone to build a feed and a catalog to actually look at pre mapped APIs of people who actually were incentivizing to go map out the Internet. So it makes it much easier for anyone else to go build this data off of any APIs that might have already been looked at by other parties. So here you can see one of our chains. We have multiple chains on the main right here and Starknet and Sui on Devnet right now. And you can see a large list of data feeds that people have created using Switchport.
00:05:48.402 - 00:06:37.606, Speaker A: And you can see that these can actually have update time of down to 5 seconds intervals just to deal with the two times confirmation time of a full trip for this task scheduler. And actually let's go look quickly into one of these data feeds so we get an idea of some of these configurations. Since everyone actually owns a data feed in switchboard, you can actually see that each feed has an edit authority and they can actually control what data is being pulled on chain by the oracles. So if you look here, you have all these different types of schemas that tells the oracle how to fetch data. We have different types of jobs we denote as task types. So this will fetch some rest API and then this will parse out certain fields and take the median of it. You can do a pretty expensive stuff using switchboard here.
00:06:37.606 - 00:07:20.200, Speaker A: It pulls in websock information to the data feed. You can pull in on chain sources too. I don't think there isn't that many in this one. We keep the history of data feeds on chain, so you can easily make a twap on top of this feed and you can say, specify how many oracles you want to resolve a feed, how many of these jobs need to succeed in order to actually report a new result and the update interval that this feed should be opening new rounds and requesting new data in. So right now this is configured for every 6 seconds. But I really want to show you some of the stuff we're doing with Starknet here, which is more relevant to the crowd here. So this is a quick view of our publisher here.
00:07:20.200 - 00:07:56.900, Speaker A: You can go and connect either Argent X or Bravis wallets. Once that's connected you can go look at the data that we have on chain. Got a few more clicks here. So over here we can go to the feed builder and we can go to our drag and drop tool and say hey, we want to actually make an HTTP request and then parse out a certain field here. So we'll go make an HTTP request to, I think binance.com here, binance us and we'll be making a call to get the ETH USD spot price. We'll wait for that to finish up there.
00:07:56.900 - 00:08:42.448, Speaker A: Great. And then beyond that we can do more logical operations on the information that was pulled. This will parse out the response and get the price field. And you can just make sure that this is working properly to get all the data before you go and actually publish this feed on chain. So now we're going to go name the feed eth USD and then from there we can go and add this to our cart. From there we can modify some of the consensus settings, say how many oracles we actually want to be assigned to this data feed every time that it's updated. And of course having more oracles means there's a higher integrity level because more oracles would need to be malicious in order to actually affect the response of the data feed.
00:08:42.448 - 00:09:19.520, Speaker A: And then this is actually filling an escrow with some eth. So these can be paid out to the oracle so they're incentivized to respond properly and in an orderly fashion based off their update time. So once a transaction is pending, it'll just take a second here and then. Okay, now we can look on chain at the data feed. Fantastic. Yeah, so you see we have a few data feeds that are pending updates right now and they're all updating now. So they'll update in the update interval that you specified when you were actually publishing the feed.
00:09:19.520 - 00:09:59.962, Speaker A: So now it's very easy to make an ETh USD price feed. You don't have to go through any biz dev teams to go and make an e feed. This is a really free form oracle for you and your team to build. All right, great. Now that is the general gist of how the V two mechanism works. Now where does the trust and where does the incentives actually lie for the oracles? In V two, oracles are incentivized for honest reporting based on getting some type of reward and some type of stashing mechanism that's configured in what we called the queue before. So each queue has its own reward mechanism for the oracles when they're actually updating.
00:09:59.962 - 00:11:03.540, Speaker A: But what price is a good price? Let's say you're supporting a multi million dollar market. How can you know that a single update would actually, from an oracle, be properly incentivized to not manipulate this market for its entire worth? I'm sure that there was actually a recent event where there is a stake weighted oracle protocol where somebody submitted $200 to affect one single update and drain the pool for $120,000,000. And I think the stake weighted or set reward mechanism for oracles are not perfect. They don't perfectly align the mechanisms for what oracles are incentivized to do and any downstream applications. So in the essence, you're really relying on a heavy trust assumption, the way that oracles are working today. And since oracles are responsible for all these millions and millions of dollars, can we do better? So that's what we'd like to announce right now. We are actually launching our switchboard V three, which we believe solves this issue.
00:11:03.540 - 00:12:13.030, Speaker A: We are actually moving to a full secure enclave type of model where we can offer completely verifiable compute services off chain. And we're actually making a custom implementation of Intel's SGX quote out of station to be verifiable for any machine on chain. And this opens up a lot of new opportunities and a lot of new use cases for oracles. And this is one of the first oracles to actually be taking this route and doing these types of things for verifying the entire machines at a station on chain. So now you can have ultimate reliability on what the oracle is actually doing because you can see what image was actually verified for all machines that you're onboarding, and you can actually give much more reasonable rewards for every single oracle update and know that they are honestly responding. So a few cool things that you can actually do with that are you can make consensus using Levenstein consensus. So if you want to submit random buffers rather than just quantitative data, we can do that now using SGX secured oracles.
00:12:13.030 - 00:12:35.610, Speaker A: You have two more reasons. I'll go think of them in a second after I go through some questions. But it opens up a whole new world of possibilities. And we're really excited about this new model where we are minimizing trust for oracles completely. And we hope to help you guys build in starknet. So if you have any questions here, please scan the code and get some more information from our team. And, yeah, I'll open the floor.
