00:04:50.700 - 00:05:15.928, Speaker A: Entrances. Entrances. All right. Sorry for these technical problems. We're figuring out how to connect. Omar, sound. Technical problems.
00:05:15.928 - 00:05:42.130, Speaker A: We're figuring out how to connect. There is a small echo because I'm monitoring sound. Please wait for a sec while Omar reconnects. Omar, can you try and speak, please? Can you hear me? Can you hear me? Ah, now I can hear you. Let me check if we can hear you on. On twitch. Perfect.
00:05:42.130 - 00:07:12.100, Speaker A: Yes. All right, people can hear you now on twitch. So let's go. Obar, can you hear us? Can you hear me? We can't hear you anymore now. Hey, can you hear me? Drawing here. Can you hear me now? Drawing. Audio.
00:07:12.100 - 00:07:39.224, Speaker A: Can you hear me? Yes. Okay, thanks. Now, second trial. Can you hear me now? Can you hear me now? Okay, I don't know what's happening. Sorry again. So what we're going to be doing today is calling an ERC 721. This one will be based on the standard workshop automated workshop.
00:07:39.224 - 00:08:09.392, Speaker A: It's a very good workshop where you can learn a lot about how to deploy your own RC 721. I will send you a link a little bit later. Then we're going to unit test it using Protostar. Protostar is a very nice tool for you to be able to test your contracts, also deploy them. But in this case, we're going to be focused on the testing part. So we'll be able to test it using Cairo itself. So we don't have to depend that much in python.
00:08:09.392 - 00:08:39.568, Speaker A: We will have to depend a little bit, but not that much as with only python test, which I think is a good practice, and it's also inspiring foundry. So we'll be exploring that and then we're going to be giving a couple cheat codes and testing tips that will be useful for you. So I believe this is a very important workshop because we often talk about these sanit steps. I don't know if people call it that way. That's the way I call them. But also I want to poll. Yes, because my camera is not working right now.
00:08:39.568 - 00:09:25.650, Speaker A: Sorry for that. In a next workshop, you will be able to look at me. So the sanity steps are unit test first, then definite or local, then testnet and finally mainets. So we always try to start with unit test and in Protestar we'll be able to do them and also deploy them locally. So we'll be doing the first and second step using Protostar locally in a local protestar network and a local protestar cheat network. That's how we're going to be calling it today, a cheat network of starnet and also we'll be able to deploy them to the testnet. And of course the main net bots will be staying at the local level and also deploying the testnet, just as an example.
00:09:25.650 - 00:10:12.396, Speaker A: So this is a small mem. I also clarify that this is a mem. It's very important for you to test your contracts. And the nice part is that using Cairo, you will be able to use them with the same Cairo code that you're already using for your smart contracts. So Protostar is, sorry for the starting part there, but Protostar is like, you can think about it as a combination between truffle and foundry, for ethereum. So it had best practices from truffle and from foundry. And we'll be looking at them from foundry, we will be taking the testing parts, something that foundry is very famous for.
00:10:12.396 - 00:10:52.844, Speaker A: And from truffle we'll be taking the migrations parts, which are very relevant too. So today we're going to be focusing on unit testing because the migrations are not yet fully developed. They are in the workings by the Protestar team. But soon you will be able to use them and they will be very useful when that time comes. So first, calling an ArC 721. So today the focus is not on this part, it's more on the testing part. But for that I recommend you that you get the first QR code here in order for you to access the ERC 721.
00:10:52.844 - 00:11:34.410, Speaker A: Automated workshop is the first QR code. There you will be able to follow some steps and enjoy making an ERC 721 where you will be able to breed animals. It is very nice and very well done workshop. And also if you need help, you can check David's Barrett's tutorial, started developer advocate. This is the second QR code. This guide by David is very useful, very good. So I don't think that there's a necessity today to go deep into how to code this ERC 721 or how to finish these workshops, but focus more on the testing part.
00:11:34.410 - 00:12:14.656, Speaker A: Okay, so if we go right now to the code, let me stop sharing a little bit and share again my screen and go to the code so we can review what we'll be doing today. Okay, let's go and share it. Screen. Sorry for that. And we have this code. I will send you. Also I will add the QR code here for the repo where you will find this exercise.
00:12:14.656 - 00:12:57.060, Speaker A: But for now, let's go. Don't care for the red part. I don't know what is happening right now to the visual studio code. Widget that is not identifying that there's not an error, but it's okay, don't care about that part. So if we go to the, let me share first my terminal, just to confirm with you guys, are you able to look at the terminal right now? Because I don't know if you're able right now to see only terminal. I think so. I think you're able to see the terminal.
00:12:57.060 - 00:14:13.380, Speaker A: Okay, so here we are on our code, and if we create a new protestar repository using Protostar init, it will automatically build you a nice couple of directories that you will be able to use. These are good practices. For example here, if we can explore how our code is built, how our directory is built, we'll be able to see that protostar automatically created for us a build directory. There will be our jsons with the qualify files. In this case, we have two different contracts that were compiled and ERC 721 custom and ERC 721 original. Then in leap, in the leap directory we'll be able to see everything that we install. So for example, we're installing here the Cairo contracts from opensepling, and this is all the code inside it.
00:14:13.380 - 00:14:35.542, Speaker A: Also it will create you a CRC folder automatically. You can change the name of it. Maybe you prefer to call it contracts, I don't know. But inside CRC I create two traditional directories. These are mine. One is called contracts, one called interfaces, and one called Python. And finally it will create you a test directory.
00:14:35.542 - 00:15:30.326, Speaker A: There we'll be able to see all the tests that we are coding. Also, of course we will have a configuration file called Protostar to ML. Instead of it. We'll be able to see the configuration of our protostar. Right now we have a very simple configuration and the two most important part are these ones. In protostar contracts we are telling protostar where are the contracts, what are the paths for the contracts that we're going to be compiling and then deploying? In this case, we're telling him a search for live carrier contracts. So enter the open seplin directory that we just installed, and then we'll be using this ERC 721 mintableburnable Cairo.
00:15:30.326 - 00:16:26.730, Speaker A: We will call this contract ERC 721 original. Also we will have a second contract called ERC 721 custom. And this is the path for it. Okay? So when we compile our contract automatically, will gather these files from these paths and then create our JSON files that we'll be able to deploy. Second, we have this protostar share command configs in here. We're specifying there's another path, a Cairo path where it will be able to find the Cairo contracts will be able to find the Cairo contracts imported from open settlement. Okay, having said that, let's go back to the command line and here we can start by typing protostar deploy.
00:16:26.730 - 00:17:15.150, Speaker A: Sorry protostar builds and right now we are compiling our contracts. We are compiling the two contracts that we indicated Protostar that we'll be using today. Okay, so it compiled them and it stored them inside the build directory. Here we have our two ERC 721 custom and ERC 721 original compile. Okay, the next step for us will be to deploy it. It's also very easy to deploy using either the Devnets shardlabs, testnet, sorry Devnet or the testnet or the main net. So in this case we'll be deploying straight to the testnets, very easy.
00:17:15.150 - 00:18:07.710, Speaker A: Again we can use Protostar deploy. Then we can indicate that the contract in order to deploy will be, sorry, this is not required right now. It was a protostore deploy and let's go and deploy the ERC 71 custom dots. Let me get out of the build right now I'm on the build directory, let me get out of it and we can go and deploy protostar deploy. And then we indicate what is the contract that we want to deploy. Here is the custom one. Let's go directly to the custom one and also we can indicate the network.
00:18:07.710 - 00:19:10.734, Speaker A: Here we indicate testnets and here we're going to be adding our inputs. Now if we go before deploying this, let's go to the constructor and see where the inputs that the constructor is asking for us. So this code is inside CRC. And then if we go to contracts we'll find this one. This is the contract that will be deploying today. If we go to the constructor to see the inputs that the contract is asking for us, we'll see that it's asking for three different arguments, name, symbol and owner. Now I don't call it a problem, but the limitation here is that name should be in failed format, symbol should be in health format, and the owner which is originally a hex, it also have to be in a felt format.
00:19:10.734 - 00:19:58.210, Speaker A: So we have to convert strings to felt and also a hex to felt. Okay, so for this there's always a small script that everybody uses. It's on almost every relevant repository using Cairo and it's called YouTube Py. And I don't know who created it, I have seen it in a lot of repos but I don't know what they are in it. But in here we have several very useful functions that we can use to get to convert into different values. For example, we can convert right now the hex to felt. So for example, I can have my address of my starnet account in a hex format and then convert it to a felt.
00:19:58.210 - 00:20:55.222, Speaker A: Also we can convert the string to a felt, which is what we need for the name and the symbol of the token. So we can use them really easily using the terminal. Let's go to, let's create another new terminal account here. Let's go here and let me get out here. Let's go back to our previous repo start workshop in here. Let's go to perfect. And if we go using Python three I and then go into CRC Python, you will be able to access the Python code.
00:20:55.222 - 00:22:22.114, Speaker A: Very simple. So right now we can use, for example, let's think that we want to convert a string to a felt, for example, new token, and it will provide us with, sorry, I clicked on felt array and it will provide us with the felt that we need to input, as in this case, for example, the name of the token. We can do the same with, I don't know, like this, the symbol could be Tata, and that will be the field value for it. Also for the hex we can use this one and we can add a value in this case, this is not an actual, sorry, it's hex to felt here, I got it wrong, but of course this is not a felt that I'm adding. But suppose it's a felt, sorry, suppose it's a hex, and right now it's an error because it's not an actual hex. But if we have for example, an address, we can convert it into a felt and that's what we need right now. So I will be providing here my address, my starting address, and convert it into a can so we can tell the contract that I am the owner of this contract and I can interact with it.
00:22:22.114 - 00:23:14.366, Speaker A: Now we can exit Python, we exit and we are again back into our testing framework. So coming back to the deployment part, we are telling him, let's deploy this contract, ERc 721 custom. We will do it to the testnet network, testnet. And the inputs will be, and if we go back to the code, we see that the code is asking for the name, symbol and owner in that order. So I have them already converted and stored here locally. The name will be sorry for this because it's going to be looking really awful, but that is the name then we have the symbol. And finally, we are going to be having the owner, which was originally hex.
00:23:14.366 - 00:23:45.232, Speaker A: Right now it's an address. Okay, so we wait a little bit, and this should be able to deploy it to testnet and we'll be able to interact with it. So right now, as you can see, it was successful. It provide us with a contract address and also a Voyager address. We click into the Voyager address, we'll be able to access directly to. Course, of course. And this is why we are focusing today on the testing part.
00:23:45.232 - 00:24:28.228, Speaker A: But of course, it's not currently working on the test. We have to wait, I don't know, maybe three to five minutes for it to be live here and we can interact with it. And, well, as you can see right now, this is precisely the problem that we have with the testnet, that it takes a little bit of time for us to interact with it. So we have that small problem. So now let's go back and see what can we do about it because we don't want to stuff like this. This is not the ideal way to interact with this. We want to be able to quickly test and quickly iterate in our code.
00:24:28.228 - 00:25:19.628, Speaker A: Okay, so while we wait for this to be able to be available for us, let's go back into our slides and go into the testing part. This QR code that you see here will take you to the repository with the code that I'm showing right now. So you can access it, you can edit it, you can use it, whatever you want. But it will be very useful because, at least for me, it's very useful to see a new repost that shows best practices and a nice code. It will allow me to apply it to my own smart contract. So feel free to look at it and give it a start if you want and clone it and use it however you want. Okay, so let's go to the cheat codes parts by protestor.
00:25:19.628 - 00:26:08.824, Speaker A: They are, of course, inspired by foundry. I don't know. I haven't found a single place where they explain the cheat code's name, why it's called cheat code, and at the beginning it's not that intuitive because, I don't know. It remembers to me when I was playing write the photo four, for example. And you have these cheats list cheat codes where you add certain code and you have extra life or, I don't know, more powerful weapons. But it sounded a little bit weird to me. But after looking at it and exploring it inside foundry and then with Protostar, you discover that it's actually meaning that you are fooling, you are cheating the state of the blockchain.
00:26:08.824 - 00:26:47.360, Speaker A: So you are like cheating in the sense that I will simulate or cheat that I am deploying a contract and that I am the owner, I am cheating that I'm making this call. So it's a mock call, but I'm actually not doing it. So you are constantly cheating. And for this you have codes, particular codes that in this case protostar did, the protostar team did. By the way, protostar is open source, so you can also contribute to it. But yes, that is the name of the cheat code. I don't know if this is the best name, but you are cheating the state of the blockchain.
00:26:47.360 - 00:27:28.940, Speaker A: So where are some of the most important cheat codes? And we will look at them directly at the code, but I want to explain them before this way. So first we will simulate cheat deployment. For that we'll be using declare, prepare and deploy codes. And it's important to tell you that all this code is inside hints. So the codes of the cheap codes are practically hints always. And you will have to code them easily using Python. But don't worry that if you don't know Python, it's a very simple, they are very simple to use.
00:27:28.940 - 00:28:10.868, Speaker A: No problem. You don't have to be an expert in Python. Definitely you don't have to have a high level of python, as for example, when you need to test only using Python. This is much more easier in terms of the Python part. Mainly we'll be using caro codes. So when you want to cheat the deployment, you can use these two functions previously, and actually currently you have another that is called deploy contract, deploy underscore contract call, but be not working more in the next deployment or protestar or something like that. So we'll be focusing on what is the future and what stays current inside protestar.
00:28:10.868 - 00:28:46.832, Speaker A: So with the declare function we will be able, as you can see in the green part of the code. We'll be able to say that this is the path to the contract that we want to deploy. Then we'll use this declare contract to impute as an input for the prepare function. And the prepare function has the particular part that will be able to add what are our inputs. So these are the inputs, name, symbol, owner. You can see it because we just read it in the testnet. So we have name, symbol and owner.
00:28:46.832 - 00:29:22.688, Speaker A: And there we'll be imputing these arguments that will go into the constructor. Okay, so these are the constructor arguments. And finally using deploy, we'll be able to deploy the prepared contract. And particularly of relevance is for us to get the contract address and we'll be storing it using the context. I will explain it a little bit later that we'll be using context ER 721. ERC 721 underscore custom underscore address and there will be storing the address. Okay, so we'll be looking at that directly into the code.
00:29:22.688 - 00:30:08.336, Speaker A: But before let us see another important part of the cheat codes. This is a cheat to deploy at the beginning of our contract. So we don't have to be deploying at each different test. So we can deploy at the beginning and then we can interact with this deploy contract with the following test without the need to be deploying for each test. Okay, so this will make our test faster and a little bit cleaner for us to read. So at the beginning we can deploy using the underscore setup underscore. And inside that code I am adding the previous declare prepared deploy code.
00:30:08.336 - 00:30:59.250, Speaker A: As you can see, the code that I showed you before here, the declare prepare deploy goes actually inside this setup. So this means that we are setting up, we're using a hook, the setup hook, in order for us to deploy at the beginning of the contract and not requiring it to be deploying each time. Okay, so let's go to the codes and see this life. So here we have our test of the custom Chiron. Now a small disclaimer. This code is optimized for learning purposes and could have a couple of not best practices regarding the format of the smart contract. It's mainly focused on showing the best practices regarding the test.
00:30:59.250 - 00:31:46.156, Speaker A: So in here, if we go to the setup, you can see what I was telling you before. Here we are declaring, preparing and deploying our contracts inside the external part, and then we will have a couple of tests. I will explain them in a moment. But this test no longer require for us to deploy the contract, and this is the most important part. We're storing the contract address. As you can see, this is Cairo code and we're using hints for the test, hints inside of course our Cairo contract. So in here, as you can see, we're storing the contract address inside this context.
00:31:46.156 - 00:32:28.024, Speaker A: ERC 721 underscore custom underscore address. This context part will allow us to use this variable. Anything that we store inside the context, then we'll be able to use it in other parts of our contract. So in the setup hook, we can do anything that is required to initialize the test, and then we can pass all this information throughout our different tests. Inside this one, inside this test suite. So for example, let's go to the first test. We are simply testing the deployment of our contract and inside here, and I will spy it a little bit deeper.
00:32:28.024 - 00:32:59.636, Speaker A: But right now I want you to see these parts where we're using a hint. In this hint, we're retrieving the address of our contract from the context variable. Okay. And we are storing it inside a local variable called attempt variable called ERC 721. Underscore cost of underscore address. This will be helpful for us to later use this address when we are deploying and we are using other, sorry. When we are using functions from the deploy contract.
00:32:59.636 - 00:33:38.964, Speaker A: Okay, so before going into that, let's go again to our browser. Let's go to our presentation. Oh, I cannot go right now. No problem. Okay, so if we go right now and explore the, let me try to go to the brave parts. This sharing screen stuff is a little bit confusing. Okay, let us go back to.
00:33:38.964 - 00:34:19.500, Speaker A: I will stop sharing for a moment. I can see it right now. Share again. So if we go again to our contract, we will see that it's already deployed, should be working right now. So you are looking right now at my testnets and as you can see, the contract that we deploy using Protostar is now working and we can explore it. Of course this is maybe what you are most used to. And in here you can of course read the contract and write to the contract.
00:34:19.500 - 00:34:53.144, Speaker A: And of particular interest right now for the test we're looking at is the name part. So if I go to the name and then we can retrieve it in text formats query for it and we'll be getting that. This token is called new cute token. And if you go to the symbol, we'll be able to see that the symbol is MCT. This is just a small example. And of course if we go to the owner part, we'll be able to see who the owner of this contract is. Using the hex format, we can retrieve that.
00:34:53.144 - 00:35:13.772, Speaker A: The owner is this address. It's ending with a 510. I can go right now to my starting account. Right now I'm using Ariant and we can see it also ends in 8510. So I am the owner of this contract. It was well deployed. So no problem in here we can interact with it, we can write to the storage.
00:35:13.772 - 00:35:36.890, Speaker A: No problem. We can read from storage. Okay, looks very nice. So explain a little bit more about what this custom ERC 721 is doing. In case you haven't done before. The workshop, the automatic workshop. This is simply a contract that allows you to mint an ERC 721.
00:35:36.890 - 00:36:06.732, Speaker A: That's an NFT, informally called an NFT. And this, you can mint it, and you can provide it with some interesting properties. In this case, animal characteristics. These animal characteristics are legs, legs, wings and sex. So, for example, let's go and mint one of these animals. For this, we'll not be using the traditional minting function. We'll be using the declared animal.
00:36:06.732 - 00:36:31.648, Speaker A: So, for example, I will provide with a sex one, legs one and wings one. Then we click on transact. I will approve the transaction using my standard account. Okay, so now we have to wait for it to pass. You can see above, Arden is telling me that there is a current transaction in place. So we will have to wait for it, pending transactions. Declare animal.
00:36:31.648 - 00:37:03.204, Speaker A: Again, this is not ideal, and that's why we're using the unit testing part and deploying locally. Okay, so if we wait for this, we'll be able to have an animal. This animal will have one sex one, Lex one, and wings one. And we'll be able to retrieve this information using the getter function called get animal characteristics. That's practically all, that's what we're doing with these contracts. It's a very simple contract. Again, we are not waiting for it.
00:37:03.204 - 00:37:30.120, Speaker A: So if we go back to our test now, we'll be able to test these custom parts of our contracts here. First, we are starting with the constants. So we have an owner. This should be an address. Think of it like a hex address, but it doesn't matter because it's a false address. We have a name, and we have a symbol. Sex, legs, and wings.
00:37:30.120 - 00:37:52.324, Speaker A: Okay, just a couple examples how we can test our contract. As we show before here, we had setup. We're deploying there. And also we have a small interface that we'll be using a little bit down here. But this is a small interface. Just as an example. Sorry.
00:37:52.324 - 00:38:24.190, Speaker A: So in this first part, we'll be testing the ERC 71 deployment part. Okay, so we already know that we deploy it when we use the setup hook. Right. Now let's see if the name and the symbol and the owner are actually the ones that we declare to be. Okay, so again, we're returning from here the custom address and storing in this temporal variable called ERC 721. Underscore. Custom underscore address.
00:38:24.190 - 00:38:58.948, Speaker A: Then we're calling the IER 721 custom interface. For that, I have to import it above here. I import from the interface part. This is an interface that I created. This is the interface you're looking at right now. And in this interface I declare some of the functions that we want to test right now. For example, we want to test the function called name, the one that we use right now that we used previously in the testnet.
00:38:58.948 - 00:39:24.944, Speaker A: You remember it name, and it provide us with the name of the animal. Also the symbol function that we use above or the owner function that we also use in the testnet. And then we will also test in this declare animal function that we also use. Let's go back to our browser and see if the function has already passed. No, it hasn't passed yet. No problem. So we have the declare animal function and we'll be testing it.
00:39:24.944 - 00:40:14.688, Speaker A: Also we'll be testing the get animal characteristics part and the getlast token id. I will explain a little bit more about them in a moment. The important part here is that we have an interface that will allow us to interact with the actual code of the contract. That in this case is the ERC 721 underscore custom underscorecustom Cairo. Sorry, ERC 721 custom Cairo. This is the actual contract and we'll be using the interface as a way to interact with it in a more simple way. So again, let's go back here and we're calling the interface and then using the name function from the interface you saw before that we have this as a function we want to test.
00:40:14.688 - 00:41:07.552, Speaker A: Okay, so then we are adding a single argument that is called contract address. This contract address argument is the address that we put before from the deploy contract. Okay, so we are using the deploy contract and using the function name. And then we will be storing this name inside name. Okay, we will do in the same with symbol using the symbol function and with owner using the owner function. Again, the important part here is that you're using the interface with a single argument that is automatically created. When you say that this is an interface, you automatically create an argument that is called contract address, where you have to input the address of the deploy contract that contains the functionality.
00:41:07.552 - 00:41:36.280, Speaker A: Okay, so the interface doesn't contain what the functions are doing. It is just declaring the functions that we'll be using, but not the functionality, not the actual workings. Inner workings of the functions. These inner workings, you will find them in the actual contract. Okay, so we are getting here the name, the symbol and the owner. And then we are doing a couple of cells, and here comes the first testing. Best practice that I want to tell you.
00:41:36.280 - 00:42:36.416, Speaker A: Actually the second, the first one is to deploy at the beginning of your contract. The second one is here that we are making some assertions but as you can see, they look different from the ones that we're used to. So you remember that assert actually can do two things. For example, in this case, if we don't have a variable called name, if the variable called name is empty, it will create it and store inside it what name has. So for example, in this case, if we have one, then if name, if the variable name is actually not created, then it will create it automatically and it will store the value one inside it. Okay, in case this name variable is created, this name expression is created, then it will assert, it will assert in the python way. See if this variable is storing a one or not.
00:42:36.416 - 00:43:15.804, Speaker A: In case it doesn't have a one, for example it has a two, then it will give you an error. Okay, if it has a one indeed, then it will pass. No problem, the session will pass. So this particularity that we have in Cairo allow us to test not on a proper way. For example, we have the name variable here. And what happens if this call to the name function didn't work and it didn't store anything inside name? So name is still empty and we have here Ola. Okay.
00:43:15.804 - 00:43:48.948, Speaker A: Of course this will be a mistake because we don't have strengths in Cairo, but this ola will be assigned to name, okay? Because name is empty. So that's not what we want, because then it will be able to pass the test. Okay, so that's not a good practice. So what we're doing here is that we are creating first the constant. For example, again, using the Ola example, we have Ola before name. You can see that. So that means that a assert me please.
00:43:48.948 - 00:44:46.820, Speaker A: That name, the value inside name, has actually the same value of these constants. So it's the reverse order, but it works and it's a better practice in case actually name is empty. Okay, so again, we're using name here, and the name was declared above here as a constant. Okay, so name is already a constant, and we are reviewing that what comes inside the variable name is actually what the constant is telling us. Okay, so this is like a reverse way of asserting, and I find it very useful. So in this case, we're asserting that the name, symbol and owner are the actual ones that we deployed, with which we deployed the contract when we deployed a bob using the setup hook. As you can see here, in the arguments to a constructor, I include the name, symbol and owner.
00:44:46.820 - 00:45:35.928, Speaker A: So we are just reviewing that these indeed are okay, perfect. Now this is the first test, and let's go back to our contracts in the testnet, as we can see, Arian is telling us that we were able to declare this animal. So that's great, amazing. And now let's go and read the characteristics of this animal. So this animal has the token id one because it was the first one that we minted. And let's go and retrieve the characteristics in the format of text of this animal. Let's see, something happened here.
00:45:35.928 - 00:46:03.280, Speaker A: Let's see what happened. It wasn't text, it was decimal. Of course, because they were numbers. Okay, so we have sex one, lex one and weeks one, just as we said before. Perfect, no problem. So animal characteristics, when you impute a token id, you are able to retrieve the characteristics of this animal. Excellent.
00:46:03.280 - 00:46:48.512, Speaker A: Also we have this getlast token id. I'm showing this because we'll be testing them next. Okay, so getlast token id simply tell us the token id of the last minted animal. So in this case let's go and query for it. It's telling us the last token id that was minted is the number one because we only have one. For example, if you were asking for the characteristics of the token of the animal in token two, we won't be receiving anything only because this haven't been minted yet. But we have minted the one, sorry, the number one which has six one, legs one and wings one.
00:46:48.512 - 00:47:19.530, Speaker A: Excellent. Just for the sake of another example, we'll be declaring a second animal instead of being one one one, it will have two sex two legs, two wings. Okay, sex two. Okay, and let's go with transact. And again we'll be writing something on the state of the blockchain. So it will take us a little bit time, a couple minutes, again, three to five minutes for it to work. So let's wait for it.
00:47:19.530 - 00:47:55.590, Speaker A: But now we can see that we have other relevant functions such as get animal characteristics and get last token id. We'll be testing them right now. So let's go to the next test. This test is testing the declare part of the animals. So the minting part of the animals. This one is a little bit stronger, a little bit harder, and it's also very interesting, a very interesting test. So what we're doing here is creating a couple temporal variables again in order to store that address.
00:47:55.590 - 00:48:31.996, Speaker A: Don't mind this one, we won't be using it. And yes, we have first the variable, the temporal variable. Will we be storing the address of our contract, of our deployed contract, the one we deploy above at the beginning of our contract. And then we'll be using this interesting cheat code. It's called mock call. Let's explore it a little bit. But this mock call, let's go a little bit to the slides.
00:48:31.996 - 00:49:17.036, Speaker A: And this mock call will allow us to simulate a call. Inside the mock call we will add the first as the first argument is the contract address. Then the contract address of the contract from which we want to simulate a call. For example, in this case, in the example below, you can see that we are adding the external contract address, which is just again an example. It's not a real address. The address is one, two, three. This is the beauty of not having to interact with an actual network like a testnet, but we're actually using and deploying locally using protostar.
00:49:17.036 - 00:49:40.612, Speaker A: So we can use mock address. In this case, one, two, three. And we are mocking the call. We are mocking the function. So let's go. Okay, as a second argument, we're using a function name. This is the name of the function from this address that we are mocking.
00:49:40.612 - 00:50:27.190, Speaker A: And finally we will have as a final and third argument, the return data inside here is in the format of a list, most likely, or a dictionary from Python. You will have the actual return value that you are mocking. Okay, so if we go to the example below, we can see that we are actually, let's go back to our code, and this is the actual sample that I was showing before in the slides. And as you can see I'm creating a mock contract address as you saw before. And from this we are using the function called assign legs number. And we are telling it that the return valuable. The mock return valuable because we are actually not making a call.
00:50:27.190 - 00:51:16.308, Speaker A: It's ten. Okay, so what contract are we using? What is this address regarding to? It is actually mentioning the interface of the evaluator that I created before. So if we go above in our code, we can see that we create an interface inside our code here, and it's called interface evaluator. I evaluator as a sake of an example, it only has a function. It's called assign legs number. This receives a player address and returns the legs. So if you tell him I am player number three, tell me the number of legs that corresponds to me.
00:51:16.308 - 00:51:46.284, Speaker A: But as you can see, we don't have the actual code for this evaluator contract. We don't have it and I don't care. I'm just smoking a call to it. I'm just smoking what will happen. I know that this function works, that this contract evaluator works. I'm just moking a return value from when I'm calling this function called assign lex number. Okay, again, I repeat that I don't have the actual code of the evaluator contract.
00:51:46.284 - 00:52:22.472, Speaker A: Okay, I just know that there's a function called assign legs number that when you impute it with the player address, it will return the number of legs. Okay, so again, coming back to our test, we're making a call to this address. Actually, I don't even deploy this address, as you can see. I didn't even deploy it. I'm just mocking this call. I didn't deploy it because I don't have the actual code, the contract. Okay, so this mock call is again calling the assign lex number function from this address.
00:52:22.472 - 00:52:57.552, Speaker A: And it will be returning me with a ten, it could be a nine, it could be an eleven, whatever, doesn't matter. It's just a mock code. And then using the interface evaluator and the function assign line numbers as we say before. Then we will be provided with the contract address. That again is a mock contract address. We're deploying everything locally so we don't have a problem with that. And we are telling it that the player address, that's the argument that this function assign lex number was asking for us, is called owner.
00:52:57.552 - 00:53:38.468, Speaker A: This will have, imagine that it has a hex value with an address. So again, we are mocking, we're mocking, we're mocking and this is not real. We are just deploying locally. Okay, then the value that we retrieve is going to be stored inside a nolex and we're telling a stop the mock. Okay, then we will be asserting that indeed ten, the constant is equal to the number of legs. As you saw before, we said that it should return ten. Okay? So it should pass this small test.
00:53:38.468 - 00:54:14.450, Speaker A: So right now we are using this very common cheat code that is called mock code. Excellent. Now let's go to the next part. Here we're retrieving again, we're retrieving from context. You remember that context is where we are storing everything that we deploy or declare at the beginning of the contract using the setup hook. So here we store the address of the ERC 721. And now we're storing it here and bringing it to our contract, to our test.
00:54:14.450 - 00:55:04.232, Speaker A: Now let's go to what I think is the most usable and the most beautiful cheat code that we have. The star prank cheat code coming back to our slides. Simply what we have with the star prank is that we are simulating, we are cheating, we are pranking a certain contract, telling them, hey, I am the owner or somebody is the owner. Not precisely. In this case we'll be using it with I am the owner even though as you can see we don't use a wallet here. And actually Protostar currently doesn't support for you to be able to sign transactions. Nobody will be soon able to do that.
00:55:04.232 - 00:55:28.676, Speaker A: Don't worry. Protostar is being created right now. The team is working very hard and actually they are very responsible discord. So I recommend you that if you have any question go to the commentation. If you don't find there what you need then you can go to the discord of Protostar, the starnet discord. Inside you have a Protostar channel. They are very responsive and very nice guys.
00:55:28.676 - 00:56:13.700, Speaker A: So no problem with that. But they are currently working on that and they are working on a lot of very nice and very interesting features. But for the moment being we can cheat a contract telling them hey, I am the owner even though I am not the owner because this was actually not deployed and signed. Okay, so there's no accurate owner but I will prank it telling them that it's me the owner. So the star prank cheat code has two arguments. The first one is the color address. Again in this case I will be using it as a I am the owner and yes I am the owner and then we'll be telling it.
00:56:13.700 - 00:56:58.676, Speaker A: But you can use other address. Okay, you can maybe add that the caller is maybe a third account and that third account is interacting in certain weight with this contract. So I don't use it. Whenever you need to tell it that the color is somebody else. In this case I want to tell it the color is actually the owner. Okay, so why the owner? Because I am minting something and if you remember the year 721 code I will show it in a moment. But you need for the owner or in a you need for the owner to call this function to mint and then we will have the target contract address.
00:56:58.676 - 00:57:35.152, Speaker A: So what is the address that we want to prank? What is the address that we want to cheat? So coming back to our code we have this not that beautiful maybe code. Let me just erase this for the sake of simplicity right now. And as you can see we're starting our prank and here we're finishing our prank. So this code inside the two hints is the one that's going to be affected by the star pranked cheat code. This is beautiful. To be honest. This is beautiful, very nice.
00:57:35.152 - 00:58:19.656, Speaker A: And I love it. I love it because yes, it's very easy to use. So in here we'll be able to what we are testing right now is the declare animal function from the interface, as you remember before, and we have already called it twice in the testnet, when we call the declare animal, we are telling it that certain animal has certain sex, certain number of legs and certain number of wings. We go back to our blocksplorer boyeger. We can see that our transaction already passed. So we declare an animal. So the arguments are sex, legs and wigs.
00:58:19.656 - 00:59:16.012, Speaker A: You remember that we already did this twice. And also we, and this is the most important part, we are telling it that the address of the deployed contract that has this function, the declare animal function, is the ERC 721 custom address. Okay? And then we are going to be storing because you didn't see that before, but whenever we declare an animal, it will return us with a token id for this animal. So this is the animal number one. Okay, so coming back to our code, we'll be storing this animal token inside this first animal token variables. Okay, so let's see, let's review what we did here with the star prank. And this is very relevant call.
00:59:16.012 - 01:00:13.260, Speaker A: This is a very relevant cheat code and very interesting one. So we are telling this contract called ERC 721 custom with to the function declare animal that we are the owner and we want to do this. Okay. If we go to our code inside the declare animal function, and of course you will be able to see all this code inside the GitHub repo that I showed before the QR, it's commented, this function, particularly commented, is the most important one. And you can see that it will only allow us to use this function if we are the actual owners of this contract. Okay, so it's checking if we are the owners. If we didn't use here the star prank cheat code, it won't be able to see that we are the owner, so we won't be able to test the declared animal parts.
01:00:13.260 - 01:01:13.504, Speaker A: Okay, this is very interesting. So for example, in the next part of this automated workshop, the ERC 721, you actually have to create a list of persons, of accounts that are able to mint and declare animals. Okay, so for example, in this case, we could create a stark prank where the contract address is actually one of these different addresses that are able to mint animals. So we can test that with each of these different address. They are able to test. In this case, we don't have this already implemented, so only the owner can declare animals. This is very interesting, right? Actually, without having to sign the deployment of the contract, as me, the owner, you can interact with it also in a testnet we can interact with it because it knows that I am the owner.
01:01:13.504 - 01:01:49.836, Speaker A: Because when I was making the deployment, I tell the contract that I am actually the owner. It is one of the arguments of the constructor. Okay, so right now we have this part, the star prank owner. This is to me the most beautiful test that we have. And then we will be simply testing this deployment. Okay, so before I erased this part, but what I was doing here is just the same as before, I'm declaring a second animal. So first animal and then a second animal.
01:01:49.836 - 01:02:27.288, Speaker A: The second animal has different number of legs, different number of sex, and different number of wings. Okay, so now I will test it. I won't go into too much detail, but here you can see we have a couple of assertions. These assertions are allowing us to review that indeed our functions are working. For example, we are using the getlast token id. We use it before and tested. You remember that it gives us what is the last token id from the last minted animal.
01:02:27.288 - 01:03:05.080, Speaker A: And then we'll be reviewing that it actually works with. It is the same token id as the second minted animal, because we minted two animals. So we want to see that the second animal also corresponds to the last token id function. Okay, that's all. And then we'll be simply asserting that the animal characteristics work. So we are right now testing the get animal characteristics function. As you remember, I can go here into get animal characteristics function.
01:03:05.080 - 01:03:59.050, Speaker A: This one, as you can see, it is giving us the sex, the legs and the wings. And we have actually used it a couple of times already in the testnet. So we are testing it by assigning to this variable, this local variable, sex, leg and wings. We are getting the animal characteristics and we are adding as imputes the contract address, of course of this deploy contract and also the token id. So I am asking here, give me the characteristics of the token id number of the animal with the token id number one. And also give me an ask for this to this address of this deployed contract, the ERC 721 custom. And then we are simply asserting that the numbers are what we expect.
01:03:59.050 - 01:04:40.760, Speaker A: And we're doing also that with the second minted animal, that we had the second declar animal. And that's all, that's practically all. Again, you can go and see the test inside the repo. Now let's see if the actual test work. And whenever you are testing, remember that the tests are stored inside the test folder here. So here I have two tests. I didn't show you the original one, but the original one is simply testing the original ERC 721 contract if we deploy it properly.
01:04:40.760 - 01:05:20.392, Speaker A: The important part here is the custom end to end deployment testing of the year 71. So whenever we want to test, we can simply go and go into test build. And I want to only ask, this is not what I was looking for. I can tell it what test suits we want to test. So in this case. So right now what we're doing is testing this suit. So it says collected one suit and two test cases.
01:05:20.392 - 01:05:56.156, Speaker A: Now, you will always have a lot of errors in this part. It doesn't matter if you are an expert in Cairo or not, you will have a lot of errors in here. But actually Cairo and protostar have very nice, it tells you very nicely when you have a mistake. And it's very easy to debug whenever you have an error. It's very easy. So I always have a lot of errors. And I can always go back to my code, either in the part of the test, because you might find an error in the main contract thanks to the test, or maybe you have errors in the test, no problem.
01:05:56.156 - 01:06:29.416, Speaker A: So in this case, what you can see is that the test passed. And it tells you that there were two tests, the two different functions that we declared before. There's only a single test suit and it passed. It only took it 15 seconds for finish the test part. And yes, that is practically all. If, for example, we want to test everything, I can only say that I want to test everything. And now it will be testing two suits, the original one and the custom one.
01:06:29.416 - 01:06:54.384, Speaker A: But it will take it, I don't know, like 20 seconds. But in the meantime, let's go back. Let's go back to already passed. As you can see, it's telling us that it was a success. Again, it is very likely that you will have mistakes. And it's okay, it's very easy to Deboke, thanks to Cairo and thanks to Protestar. So no problem with that.
01:06:54.384 - 01:07:29.764, Speaker A: So just to finish, let's talk a little bit more about what is next in the ecosystem. So I will stop sharing screen for a moment and go back and share again. Let me just a second. Share screen. This sharing screen part is kind of annoying. Okay, so we review some of the most important cheat codes. And finally, let's go to what is next in the pot store ecosystem.
01:07:29.764 - 01:08:17.624, Speaker A: This is the migrations part. Now, the migrations part is inspired by truffle. Truffle, to the best of my knowledge, was the first one to create this part of the migrations. And here you can actually not only prank, actually not pranking, but you can deploy and manage contracts in a network. This could be the devnet, this could be the testnet or the main. However, there's a warning in the documentation that this is actively being developed and I talk a little bit with the propstore team and they are indeed developing this part of the migration. So it's not actively right now, but we'll be having it very soon.
01:08:17.624 - 01:09:05.976, Speaker A: But this is the next part of it. We'll be able to make some interesting calls to the actual network. Currently, whenever we want to deploy, for example in a testnet or in the Devnet, and we want to interact with these contracts, we have to actually use the command line interface of the testnet or the Devnet. In the case of the Testnet we can use the starnet original command line interface which is also very simple to use. And in the case of the Devnet we can use the Shardlabs command line interface for the Devnet, which is very similar again to the starnet interface command line interface. But will we be able to do this in the future using only Protestar? So this is a nice feature, I'm eager to try it. So thank you very much.
01:09:05.976 - 01:09:49.988, Speaker A: If you have any questions, please add it to your pegs wherever you are. No problem and we can solve them. And thank you very much for it. I want to apologize for the problems at the beginning. Streamyard has its own framework and you have to learn how to use it properly. So again, an apology for that won't happen again. So coming back while you input your questions, while you write your questions, remember here you can have the link to the GitHub account, to the GitHub repo where all this is made.
01:09:49.988 - 01:10:20.370, Speaker A: You can find test and it's also very useful to see the stark prank and all these cheat codes in action. So you can see them inside here. And also feel free to review the ERC 721 automated workshop and also David tutorials in case you need help to solve this workshop, which is very nice. And again, thank you very much. And let me see if there's any questions. Seems like we don't have any questions. I will stop sharing, sorry for that.
01:10:20.370 - 01:10:55.490, Speaker A: Okay, seems like we are okay and there's no questions right now. Looking for them. Going into YouTube to see if we have any questions, but it doesn't seem so excellent. So thank you, thank you very much and have a nice day wherever you are, and see you soon. Go ahead and test your contracts because it's very relevant and it's very simple to use, thanks to Protestar. So thank you very much, and we'll be seeing us soon.
