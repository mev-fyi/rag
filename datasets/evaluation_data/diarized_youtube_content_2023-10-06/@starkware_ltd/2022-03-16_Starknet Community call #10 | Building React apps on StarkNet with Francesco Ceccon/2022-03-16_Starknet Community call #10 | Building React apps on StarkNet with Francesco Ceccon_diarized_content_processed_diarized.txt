00:00:03.610 - 00:00:08.240, Speaker A: Actually, there was a button saying, go live. I found it. Now we should be live.
00:00:08.930 - 00:00:09.806, Speaker B: That's it.
00:00:09.908 - 00:00:13.726, Speaker A: Oh, my God. That's embarrassing. Okay, so we're live. Is that good?
00:00:13.828 - 00:00:15.374, Speaker B: Yeah, I can see myself.
00:00:15.572 - 00:00:23.520, Speaker A: Very cool. There's a 20 seconds delay, by the way. Okay, I'm going to post it now on discord. Okay, perfect.
00:00:38.970 - 00:00:39.720, Speaker B: It.
00:00:43.290 - 00:01:11.742, Speaker A: And now I'm going to join the community call also. Right. So now, let's see. Um. Okay, 1212. So I'm on the committee call on Discord. Can you please, on discord, confirm that you can hear me, please.
00:01:11.742 - 00:01:57.310, Speaker A: And Francesco, if you can join on Discord also, that would be wonderful. And that way people can hear you on Discord and people can also get. And people can also see you on YouTube. All right, so for everyone, welcome to our community call. I've managed to make YouTube live work, which is great. So you can follow today's community call on Discord and on YouTube Live. And.
00:01:57.310 - 00:02:23.510, Speaker A: Yeah, so you get sound on Discord and you can get sound and vision on YouTube. So I think with everything, we're all set. So let's go. Thank you for joining me today. Francesco, are you connected? Is your voice connected on Discord?
00:02:24.010 - 00:02:25.910, Speaker B: I request to speak on discord.
00:02:26.570 - 00:02:43.020, Speaker A: I can see the little end risen now. Invite to speak. You should be able to come up on stage. Awesome. So you'll see there's a small echo. The setup is not perfect, but that's what we have, and it works for now.
00:02:43.650 - 00:02:45.680, Speaker B: Can people on discord hear me?
00:02:48.290 - 00:02:59.026, Speaker A: I'm not sure. On people on discord. Can you hear. Francisco, can you please tell us in the community call channel, please?
00:02:59.128 - 00:03:02.100, Speaker B: Yeah, probably. She also tried to speak and say something.
00:03:03.350 - 00:03:04.770, Speaker A: Can you sing a song?
00:03:05.270 - 00:03:07.650, Speaker B: No, probably if I don't.
00:03:10.090 - 00:03:19.080, Speaker A: Okay, so they can't hear you. Apparently so can you try to check your discord configuration, please?
00:03:19.450 - 00:03:21.798, Speaker B: Just have a strong echo.
00:03:21.974 - 00:03:34.480, Speaker A: There is a strong echo. It's not enjoyable, but you should be able to switch off just your. You should be able to switch off one of these.
00:03:35.730 - 00:03:39.600, Speaker B: Let me try. So now they can hear me, right?
00:03:41.170 - 00:03:49.938, Speaker A: I can't tell you. I'm with you on Zoom. Okay, so bzh, buck is saying that he can hear you.
00:03:50.024 - 00:03:53.490, Speaker B: Okay, so now everything is working. And I think I fit the hacker.
00:03:54.070 - 00:04:16.026, Speaker A: Wonderful. Okay. Wonderful. All right, so let's start. Thank you all for attending our 10th community call. Ten is a nice number. I don't know if we should celebrate these or power of twos or what would be the equivalent, because traditional computer cpus are base two.
00:04:16.026 - 00:04:51.430, Speaker A: I don't know, what's the base we should use for Cairo? Because we're not based on. It's up to a certain felt. So should we celebrate prime numbers for community calls or something like that? I don't know. Anyway, welcome for our 10th community show. Community show, not community call. Today we have Francesco Chicon with us who is going to talk to us about building react apps on Starknet. And then we'll have a short discussion ama about the roadmap for Starknet and what's coming in version 0.8,
00:04:51.430 - 00:04:59.590, Speaker A: which was released this week. All right, Francesco, welcome. Can you introduce yourself in a few?
00:04:59.740 - 00:05:22.510, Speaker B: Yeah, sure. So I'm Francisco Tetron. I am like a startner developer, I guess. And basically now I'm focusing on everything from smart contracts. So I'm working on modular contracts and how to basically make it easier to develop. You know, I'm working on front end libraries, for example, this startnet pre art. So a really full startnet developer.
00:05:22.510 - 00:05:26.426, Speaker B: Okay, let me start. I share my screen.
00:05:26.548 - 00:05:28.340, Speaker A: Perfect. You should be able to.
00:05:28.710 - 00:06:05.658, Speaker B: Yeah, desktop. Okay, perfect. So today I'm going to talk about the Startnet react library that I wrote. And it is that it is make it easy to use Startnet from a react application. So a little bit more about myself. So I'm Francesco, as I mentioned, you might know me for Bismarbots, which is a small 2d block building game on Startnet. And it's live.
00:06:05.658 - 00:06:40.418, Speaker B: And also now I'm working full time on Atlantis where I'm a founder. And the idea is that we want to build a no code platform for people to deploy their own NFT marketplace. And so if you want to work together, we are hiring across the board. So we are hiring frontend developers, Starnet developers. And also if you're a functional programmer, you would like to work on our backend. And if you want to follow for news and things about Starnet, you can find my Twitter account there, you can get in touch with me at any time. And so also, before we start presenting, I want to say a big thank you to the author of Starnet JS.
00:06:40.418 - 00:07:20.646, Speaker B: Because widely library approach basically allows you to interact with Starnet from reart very easily. Everything goes through Starnet js first. So what they do is they encode data so they can be sent to the starnet blockchain and also they get data from the Starnet gateway and test of decoded data so that developers can use it very easily. So again, Starnet React will not be possible without Starnet JS and the work from the team. So thank you. Okay, so if I had to describe Starnet react in one sentence, I would say it's a collection of hoops for Startnet. That's the way.
00:07:20.646 - 00:08:00.926, Speaker B: And so how do you get started? With starting a react, I provide a nice template that uses netjs to basically set up the project. And basically with one command you create a project. You can name your app with whatever name you want to use and then it's ready to start development. Notice that if you instead want to use create react app, there's a bug in start next JS, so it doesn't work with that. So I recommend to use next js for now until we fix the bar. Actually figure out why there's a bar there, that we fix it. Okay, so basically the entire presentation is going to be about this more thing here.
00:08:00.926 - 00:08:48.850, Speaker B: So this hook use Startnet, right? And I assume that the audience today is not super familiar with react or react hooks and they want to learn more. And so I will go a bit into the details and the basics, because I think it's important. We can really guess that what this hoops is doing is that it keeps track of the state and somehow it provides functions to change state. So we can see somehow, we will see later how we track what is the current and connected account, if any. And we also provide a function to connect the account. And we can see that now with the version of Startner VR data released yesterday or the day before. We also have this injected connector, which is basically the web browser wallet, which in this case on Starnet is Argentax.
00:08:48.850 - 00:09:42.420, Speaker B: And so we are really future proof in that if there will be new wallets or new connectors, for example wallets to connect, we can support them easily. So now what are oops, right? I already mentioned them and say, oh, starnet react is a collection of hoops, but if you're not familiar to react, it doesn't mean anything, it would actually be confusing. And so hoops are basically a way to reuse and compose stateful logic in your components. So before functional components and hoots, developers had to use class components, but the issue was that it was very difficult to compose them. So if I had some behavior, then I would write some code, and then there was no easy way to share this behavior between different components. And so hoots solved that issue. And the idea is that on the left I define a hook, and on the right I'm using.
00:09:42.420 - 00:10:12.854, Speaker B: And usually by convention, hoots have a name that starts with use. And so in this case we call this hook. As an example, we call it use counter. And from the name we guess is basically a basic counter that can be incremented or decremented. And so we compose hooks together. And so we have a use state hook, which is a built in provided by react to keep track of the counter value. And this hook basically returns a function that returns two values.
00:10:12.854 - 00:10:48.374, Speaker B: One is the current value of the counter and one is a function to update the value of the counter. And the nice thing is that after I update the value of the counter, react automatically updates the value of the counter, right? So this sort of is like reactive programming. I guess that's where the name from. And then after that we define two functions. One is used to increment the counter and one is used to decrement the counter. And we can see that this set counter function. So the function that is used to update the value of the state, we can invoke it.
00:10:48.374 - 00:11:26.334, Speaker B: We pass in a function that will take the previous value of the state and returns the new value of the state. So in this case we have the counter and we update the counter. And in decrement function we determine the counter. And the second argument to the function is between square brackets is basically what is called as the dependency list. And so every time that the value inside the dependency list changes the value, the hook is reevaluated. So for example, in this case, we don't want to put counter as a dependency of our increment and determine function. Otherwise react will enter in an infinite loop.
00:11:26.334 - 00:11:57.126, Speaker B: And that's bad. At the end we set up everything for our hook and we return the value of the counter and then the two functions, one to increment and one to decrement the counter. And finally we can use it there. And so we can see, we use it by calling use counter and basically splicing the result to get the counter and the two functions. And we can show the value of the counter. And also we have basically as a callback to the buttons on click event. We add these two functions.
00:11:57.126 - 00:12:48.350, Speaker B: And what I find is very exciting is that we have to automatically update our component every time the value of the counter changes. And so we don't need to really think too much about it, sort of like the data flows through our program. And so that's the basic foods. And finally, before we can really start looking to the library, there's one more thing, is that we have this idea of provider that if you develop reactor application, you probably encountered before. And basically there are special type of components that are used to track global state. So in this trial, we will wrap our entire application in this startnet provider. So then all the children component will be able to sort of like track the startnet global state without having to explicitly pass it down the component IRT.
00:12:48.350 - 00:13:23.346, Speaker B: Okay, so what does basically starnet react provide? It provides these six hoops that we are going to see in more details. I'm not going to go over them now. And so the first hook and the most important one, the one you will use every single time, is this usetarnet hook. And all it does is it returns basically some values and it returns the currently connected account and a function to connect an account. Right. And this function takes a connector and at the moment the only type of supported connector is the web browser connector. So the injector connector.
00:13:23.346 - 00:14:12.790, Speaker B: So when you call this function with a connector, Argentex with us, they use to connect to the wallet and then they confirm and then the value of account will be updated and so it will display the user account. Here we can see how to use this hook. So again at the top we call the use startnet hook. We are interested in basically only the account and the connect function. And then if the user connected their account, then we want to display that account to the user. Otherwise we can basically show a button that when it's pressed the user will use to connect to connect to arsenal. And basically with a few lines of code, we basically have the structure to be the button you usually find in top right corners of dapps where they show your account number.
00:14:12.790 - 00:15:01.650, Speaker B: If you're not connected, they ask you to connect to Argentax. And then the second hook, which is used a lot but not in the way that you would think, is that basically the hook that returns the current startner block behind the scene. This hook basically keeps pulling the startner gateway to see what block is the current block. Right. And I think the interval at which the block is fetched can be configured. I think now is around three to 5 seconds. And the idea is that you use this hook not because you are really interested in the data, in what block number is, but mostly because you can drive updates on other components.
00:15:01.650 - 00:16:04.300, Speaker B: So for example, in this example I use the block number and not really, again interested in the value of the block number, just interested that every time the block number changes, so there is a new block, I want to fetch some external data. So I always show fresh data to my users. I think that this pattern is used a lot in the next components we are going to see. So another component, and that's not very interesting to be honest. Is this use contract hook that just used to construct a contract and you need to pass the ABI and the address of the contract. I think it's important for this use case to have a hook, because when you deploy a production application, you always have two networks, one for the test network, and then you have a version for the production network, right? And so as the user changes the network they're connected to, we also need to refresh basically the contracts because the address changes. And so this hook is very convenient to do that.
00:16:04.300 - 00:17:03.854, Speaker B: And so finally we get to the juicy hooks, the one that are actually exciting and useful. And so the first one is use startner code. And the idea that, as the name implies, is that we are fetching data from the smart contract and we are calling like a view function. So a read only function, this hook as arguments basically accept the contract that we constructed previously with a Hughes contract hook, then a method name and the arguments to this method, and we return some values. One is it will return basically the result of the call to the contract if it has a flag that basically saying, are we calling the contract? Or we already called the contract, which is the loading flag, or basically a flood that has the error value. And Tefani, we have a method that if we want to refresh the data, because maybe the user disconnected from the network, now they want to refresh the data, we should provide them a button to do that. And so there's a callback to do date, and here that's how you use it.
00:17:03.854 - 00:18:03.518, Speaker B: So here we create our contract using a hook. And it's good practice, at least in my experience, to create hooks to instantiate your contracts specific to your application. So in this case I have a hook that just to instantiate this counter contract, which is an example, and then I call my hook with a contract as parameter. The method is basically to get the current value of the counter. And then I pass empty arguments, right, because this function doesn't take any argument and we see I'm interested only in the result for this example, I don't care about showing like a load or anything. And then I add an extra hook at the bottom where I extract the value from this result and convert it to a string value in base ten, because that's what the users want to see and see. I think the exciting thing about this use startner call is that it will make a call to your contract only if the contract, the method name and the arguments are not undefined.
00:18:03.518 - 00:18:33.734, Speaker B: And why I say it's exciting because most of the times what we are doing when building application is that we need to fetch data from somewhere. Maybe it's our back end application, maybe it's another code to another smart contract. Or maybe we are just waiting for the user to tornad their wallet to display their balance. And so we don't always have the value to make that call. And without hoots, it's quite tricky to do that. We will need to have a lot of logic and keep track of state. It's basically very complex with these hoots.
00:18:33.734 - 00:19:15.340, Speaker B: They make it very easy. So in that case, if you don't have arguments, we just pass undefined to the arguments. And then when for example, user connects their wallet, we finally get the value of the user account and we can make the call. Also, another cool thing is that you start on a call supports type parameters. So if I know the type and the number of parameters my function requires, I can pass it to use start on a call. And that way if I pass the wrong number of arguments to the core, basically the typescript code will not compile, so there's no risk of deploying code that has actually a bug. So it's good practice to do that.
00:19:15.340 - 00:20:16.110, Speaker B: And now, similar to startnet call, there is startnet invoke, which basically does call external functions on our smart contract. Notice that unlike starnet core, this hook only requires to pass the contract and the method name, and we return a lot of values. We return basically the data which contains the transaction hash that basically becomes known undefined only after the user invokes the function. Then we have basically a flag to know if the user is actually invoking the function. And finally we have this invoke function which is used to invoke the external method on the contract, and that's how we use it. In this case, we can do the same thing we did for the code, and we can pass as type parameter the number and type of arguments that our function takes. So in this case we force the compiler to only accept calls where I only pass one argument and it's a string.
00:20:16.110 - 00:21:10.634, Speaker B: And then here I show that basically if you have some data, so if the value of data is not undefined, it means that users submit a transaction and we have a hash for it. Then other cases we want to show, for example, some type of spinner where the user is waiting to accept the transaction from arsenics. And then if there's any error when submitting a transaction, we want to show that to the user. Again, I think it's very important to have these mode things to make user experience good and I think these suits can really make it very fast to develop nice applications. And finally, we see basically the action we can do, and we can see how our code can easily invoke an external method on the smart contract. And again, here we see that I pass one argument and it's a string, so the code will compile. If I pass something else, then the code is not going to compile.
00:21:10.634 - 00:22:06.174, Speaker B: And again, I think it's very important to make sure we don't deploy application that have parts. And now, if you develop any type of decentralized apps, you know that, again, to improve user experiences, the root part is to show a list of transactions and their status, right? So the users always know all the interaction with the chain, because there's some latency between when they submit the transaction and when they get the value back. And so it's important to make them understand what they're doing. And so we provide this transaction manager that we use using a hook, and it returns a list of transactions. And we also return some function that can be used to other transaction, which is a bit a low level operation that is not important for now. Then we have a hook that basically remove, remove. We have a function that removes the transaction from the list of transactions, so the transaction manager will forget about it.
00:22:06.174 - 00:22:54.654, Speaker B: And then we have another function that helps basically refresh the transaction state immediately. And the good thing about this transaction manager is that behind the scene, it will keep updating the transaction status without you having to write any code. And so after user submitted a transaction, it will refresh the transaction status quite often, I think every two, three, 5 seconds, because we expect it to change very quickly after the transaction has been received by the gateway to the startner node. We know that it will take probably five to 10 seconds to accept. So we pour for the transaction status less often. And after it's been accepted on l two, we don't really care about that much. And we also know it will take a long time before it is accepted by l one.
00:22:54.654 - 00:23:36.750, Speaker B: And so we refresh the transaction status every 30 seconds to 1 minute. And so that way you don't have to worry about keeping track of all these transactions and when to refresh them. The library does it for you. And so it becomes very easy, actually trivial, to just have a pop up menu, for example, where we show the transactions that the user submitted with their status. And even we can provide a link to Voyager. And so that was all. And you can find the source code online on, you know, contributors are welcome, and you can contact me on Twitter or on discord if you want to contribute, and I can help you get started.
00:23:36.750 - 00:23:39.040, Speaker B: And I think that's all.
00:23:42.450 - 00:24:00.422, Speaker A: Fantastic. Thank you. Fantastic. Thank you for your presentation. I have a question for you, actually, before we take questions from people. So if you have questions, you can ask them on discord in the community channel section. I have a question for you.
00:24:00.422 - 00:24:49.454, Speaker A: So your components are making very regular calls to refresh data from Starknet. What's funny to me is that right now, Starknet is fully centralized around us, and we operate the prover, the sequencer, and the node. Like, there's just a bunch of nodes that we operate. And this is a big stress on the architecture. So I find it really funny, too, that at the same time, a few committee calls back, we were saying, yeah, so we have performance issue, we're trying to solve this. And right now we're saying like, yeah, so just pull it every second and eventually the value will update. I think this is really funny, but it's interesting to see practices around that.
00:24:49.454 - 00:24:59.160, Speaker A: I was wondering if you had, I don't know, feedback or is it something you take in account currently when you're developing a new X on Starknet or. Not really.
00:25:00.090 - 00:25:24.254, Speaker B: Yes, that's a good point. Also, for example, my experience building apps on DVM, so using Altium for API, right, my experience, actually, yes, we are polling every often, but in Vit, most users will use your app for maybe five minutes to one, from ten minutes if it's really an engaging app. And so it's not actually that many calls. Right. They make two or three transactions and they get accepted. So they make maybe 50 calls. Right.
00:25:24.254 - 00:25:28.030, Speaker B: And even the basic plan on Archim is 10,000 calls.
00:25:30.550 - 00:25:54.570, Speaker A: I think it makes sense. I also think that it makes sense for you not to structure your app around temporary limitations that we have on our side, because if you don't stress the architecture, then we're in no rush to improve it. And if you stress it, we make something better. And full nodes will come eventually.
00:25:56.270 - 00:26:23.060, Speaker B: I think actually related to that, I'm not worried about the node because again, eventually there will be more service provided for it. It's also a matter of user experience. Right. If you make too many calls too frequently, then it's annoying for the user. Right. You use their bandwidth and also the browser can be slowed down. So I think it's important to set a group value so the users have data that is fresh enough, but it doesn't stress their browser too much.
00:26:23.830 - 00:26:35.330, Speaker A: Interesting. Thank you. So it's both in order not to let stocknet engineers sleep at night, but also to have a better ux.
00:26:35.410 - 00:26:36.040, Speaker B: Interesting.
00:26:36.890 - 00:26:53.820, Speaker A: So we have two questions, one related to node, which we'll cover a bit later. So Yan M has a question for you. Is there a good example of an application that is open source built on this? Would love to check it out. Thanks. So I think you pointed to your GitHub repo, but.
00:26:55.710 - 00:27:33.900, Speaker B: The good thing is that in the repo in the readMe, I have like a list of applications that are using starnet React and the one Bitma box is not open source yet. But there's another game that I think it is open source and hope so. And anyway, I think the examples are in reality are good enough. I try to make them as close as possible to what I'm using in a real application. And also this would come from my experience in building Bitma bots and previously building on the EVM. And so I don't think that's answered the question, but what I say is that the example is realistic enough.
00:27:37.470 - 00:28:08.750, Speaker A: Okay, thank you. Perfect. People in the audience, I don't know if you have other questions, please don't hesitate and ask them. And yeah, I think we're good. Thank you again for your presentation. It's really cool because we had a bunch of people presenting back end stuff for smart contracts and things like that. And it's really good to have people working on the front end too.
00:28:08.750 - 00:29:09.000, Speaker A: And I agree with you, we should ship apps without bugs. We don't often think of front end bugs as a vector for malfunction for smart contract, but they actually kind of is. Especially for more solidified networks like Ethereum, where for applications like Aave Uniswap, I think most of the interaction with the apps are actually from other contracts. So front end are important, but not as important as for nascent networks such as darknet or games where most of the user interaction will come from front end. Cool. So, okay, if there are no other questions, thank you again, and we can give the floor to Ariel who joined us on the call. Ariel, can you hear us?
00:29:09.690 - 00:29:19.430, Speaker C: Hey, yes, I can hear you. I'm sorry, should I unmute myself on discord?
00:29:19.590 - 00:29:23.210, Speaker A: Yes. Also, please, you should request to speak on discord.
00:29:23.970 - 00:29:26.510, Speaker C: Okay, let's figure out how to do that.
00:29:26.580 - 00:29:27.870, Speaker A: Feed the fed.
00:29:31.250 - 00:30:03.930, Speaker C: Okay, this should be working now. Okay, it is working. Okay, great. So I'll talk a little bit about what's new in 0.8 and then feel free to ask questions. Okay, so let me start by the minor smaller news. There are a lot of small Cairo improvements.
00:30:03.930 - 00:31:09.418, Speaker C: So there's now the new operator, there's another hash function is added to the implementations. My recommendation here is for you to check out the discord announcements and check out all the bunch of little coyote weeks. The best way to get familiar with the changes is to actually play with them. I'll focus now on the big things and discuss fees and a bunch of stuff we added to the capabilities of the CLI. So obviously the big thing in 0.8 is transaction fees, which are now not yet enforced, but payable, and will be enforced in the next version, 0.9. So right now the big change is that you can now attach a new field to your transaction max fee, which is signed by the user, and this fee can be charging according to the resources required by the transaction.
00:31:09.418 - 00:31:12.046, Speaker C: So if I share my screen for.
00:31:12.068 - 00:31:14.160, Speaker A: A minute here, can I ask you.
00:31:16.550 - 00:31:26.130, Speaker C: Sorry, what should I close to avoid this echo discord?
00:31:28.490 - 00:31:30.600, Speaker A: You can probably.
00:31:33.610 - 00:31:35.190, Speaker C: Now I'm muted.
00:31:35.850 - 00:32:19.950, Speaker A: Yeah, so you can basically unmute when you want to speak. So my question is the following. First, just want to make it clear for everyone so the fees are activated but not enforced means, and stop me if I'm wrong, that it's technically possible to pay fees if you want to, but you don't have to pay fees. And then in version 0.9 you'll be forced to pay fees. Now the question is, why would you want to pay fees if you don't have to? And the answer is, well, you'll have to pay fees eventually. So you want to be able to integrate this in your app right now to make sure that it's working correctly.
00:32:19.950 - 00:32:42.650, Speaker A: So that's why we're phasing it in this way. So I just wanted to clear that thing. And when you're saying you can add a fee field to your transaction, what do you mean by that? Is it when you're calling your account contract or is it to the transaction object? Where do you specify that exactly? Okay, you need to reactivate on discord.
00:32:43.150 - 00:32:48.334, Speaker C: I activated it tight. Do I need to do anything else?
00:32:48.372 - 00:32:49.520, Speaker A: No, it's okay.
00:32:52.690 - 00:33:51.790, Speaker C: Sorry about that. Okay, so as a user or developer, what I need to do is to wait for the sdks to update their versions to be compatible with 0.8. For example, if I'm just a user and I want to interact with the Argent X wallet, so I need Argent X wallet to be able to support me signing a fee. So I'm pretty sure that they released already. If not, they'll release it in the very near future, a new version for the wallet, which, in addition to the transaction parameters, allows me to sign a max fee for the transaction. And this max fee, or something lower than it will be charged in fake eth tokens in testnet. By fake eth, I mean just testnet Eth.
00:33:53.250 - 00:34:02.310, Speaker A: I think Argentina released a new wallet. I'm not sure if the UX. I haven't tried the Ux yet, but the new wallets are out, so they should be usable.
00:34:03.290 - 00:34:10.040, Speaker C: Yeah, sorry, not really sure about this echo thing.
00:34:11.150 - 00:34:16.620, Speaker A: Yeah, the flow between Zoom and YouTube is not optimal, but that's what we have for now.
00:34:19.390 - 00:35:09.610, Speaker C: Okay, so enough terms. The fee is documented in our technical documentation on the website. So currently, the only thing that is charged is the computation. So, a transaction, the source of the cost of a transaction is basically twofold. You have the computational element, and you have the l one footprint, because every storage update or messages sent to l one are eventually sent as data on chain, which bears some cost. So in this version, we're ignoring the l one footprint, which will be actually incorporated in the next version. But right now, we're focusing on computation.
00:35:09.610 - 00:36:10.478, Speaker C: And inside computation, there are a few things we can focus. So, basically, the reason I'm sharing my screen here is for you guys to see this particular part. So, when you're executing a Starknet transaction, if you look at the API, for example, this is a new endpoint of the API, which I want to talk about. But if you look at the answer you're getting back from Starknet, you'll see the resources required by the transaction. So, you have the number of steps and the number of applications of each building. Now, without going too deeply into each element, I'll just say that each of them has a different computational cost. So, for example, every chiropractor step has a cost, which is 0.5
00:36:10.478 - 00:37:14.100, Speaker C: gas per step. So, this is the cost, the gas cost of a single chiro step, and the actual fee associated with the transaction follows from the current gas price. So, in order to know what fee is associated with your transaction, we have a new capability in the CLI for estimating the fee, which we'll document in the next minor version, hopefully in a week or so. But when you call this fee estimator, which I assume, if not already, then it will be integrated with the wallet. But once you get the fee estimate, you know what fee should be associated with your transaction. And right now, this fee estimate only takes into account built in applications with those particular costs. So each built in has an associated gas per application with it, and some gas that is charged per co step.
00:37:14.100 - 00:38:12.658, Speaker C: You can read this documentation more carefully in order to get a sense of why those numbers. Why is this not double? Why is this not halved? I don't want to get into it right now because it will take too much of our time, but if you want an intuition of where are those numbers coming from, I invite you to read the rest of this documentation and follow up on discord. But this should allow you to compute for yourself the fee estimate. And obviously the flow from the user perspective is just to call a certain endpoint in order to estimate the fee. And this will be documented in the next minor release. So the flow from the user's endpoint is estimate my fee either manually by calling the endpoint myself, or to the wallet, and then signing a certain fee on my transaction. So that's what I have to say about fees.
00:38:12.658 - 00:38:14.440, Speaker C: In 0.8.
00:38:16.250 - 00:39:03.880, Speaker A: We have a question. Marcelo is saying, okay, now that we have a limit, how far can we go with each transaction? And specifically says, does the introduction of fees also increase the max amount of steps? So can you talk a bit about how you forecast? Basically, one of the reason we had to have a relatively low limit in the number of steps is that since everything was freed and it was easy to abuse, now that it's less easy to abuse, what's the plan with regard to that limit? When do we want to raise it? Why, according to which criteria? And I'm guessing we were not going to erase that limit until fees are enforced. But yeah, can you talk a bit about this please?
00:39:04.490 - 00:40:09.722, Speaker C: Yes, like you said, we did not yet change this limit, but as fees will be enforced, we can gradually increase this limit, because now it will no longer be the case that the entire burden of the proof is basically subsidized by stackware. As everything will come from the user paying their own fees, there will still obviously be a limitation per block, which depends on what latency we want to achieve. How long do we want to wait for the proof to be included in l one? That sort of considerations. But you are right in the sense that right now, a limiting factor for this block steps cap is that it's completely funded by us, which will no longer be the case. But as of this moment, we still haven't listed, as far as I know, at least.
00:40:09.856 - 00:40:17.660, Speaker A: Thank you. I have another question. How do you stop?
00:40:20.670 - 00:40:24.220, Speaker C: Okay, I managed to do it only on the perfect.
00:40:24.830 - 00:41:23.170, Speaker A: So my question is, right now the price of gas is fixed. How is it fixed? What are the components that will influence the price of gas? And specifically, my question is on ethereum. Instinctively there is more transactions, so the price of gas rises in order to sort transactions in between. How does that work in Starknet, where in a way the more transaction, the lower the cost per transaction for a proof, and also the price of the gas should take to some extent in consideration the price of gas on l one, which may change very rapidly when you want to put the proof on l one. And I was wondering if we have ideas around how gas price will evolve according to which criteria.
00:41:25.590 - 00:42:38.730, Speaker C: Okay, so let me start by making myself clear that the units in every fee component which I've shown previously is Ethereum gas. So a chiro step is 500 of a single unit of Ethereum gas, and the fee associated with the transaction will be of course dependent on the current Ethereum gas price. The reason behind this coupling to the Ethereum gas prices is that eventually we're considering the costs of verifying a proof on Ethereum. So imagine very roughly that if I can include in Ethereum approve of 200 million Cairo steps, and the cost of verifying this proof on Ethereum is 5 million, then this is exactly where the 500 number is coming from. So I can think of a single car step as costing me this much gas. Roughly. So that's how we're pricing each computational component in terms of Ethereum gas.
00:42:38.730 - 00:43:20.760, Speaker C: An important comment for this version is that the gas prices associated with the fees will be fixed until the next minor release, where we will actually use web three gas price estimates. But for now it's fixed at I think 100 guay. This will change in 81, but this is the situation at the moment. And then we'll move to use dynamic gas prices. I hope that answers the question. Feel free to direct me more.
00:43:21.550 - 00:43:22.682, Speaker A: It does. Thank you.
00:43:22.736 - 00:43:23.500, Speaker B: Thank you.
00:43:23.870 - 00:43:42.654, Speaker A: We have another question from Francesco. Actually, in a post by Leor, he mentions that state differences will be accounted for in the fees. Is it something we implemented or will, and do you have an update or.
00:43:42.692 - 00:43:56.500, Speaker C: Some thoughts on that will in the next major release in 0.9? Right now we neglected the l one footprint. We neglected everything that is on chain data, including storage updates. Now it is only computation cost.
00:43:58.790 - 00:44:53.654, Speaker A: Thank you. Marcelo is asking, taking in consideration that accounts are abstract, is it possible for an app to subsidize fees for its users? I think I can answer this one. I'd say yes, absolutely. So correct me if I'm wrong, right? But when you send a transaction, the entry point will be an account contract and the fees will be paid by that account. So if your user wants to do a transaction, what you can do as DAP developer or somebody doing exactly what you want to do. The user can sign his transaction exactly the same way, the same payload that he will send directly to Starknet. But instead of doing that, you send it as the payload of your transaction to your account contract, and you pay fees at that point.
00:44:53.654 - 00:45:39.010, Speaker A: So that's one possibility to do it, I'd say. And then account contracts are a fairly open stack. You can write your own smart contract and your own account contract. So you can probably also write account contracts where the transaction goes directly to the user wallet and fees are paid differently somehow there. But maybe you can talk a bit about that. Ariel. So when the fees are taken from the account, how does that happen? Exactly? Where does that happen? How is it enforced? And can the account contract make a call to another contract to pay for fees? Or what's the limit to what you can do in an account contract?
00:45:40.010 - 00:46:17.310, Speaker C: Okay, so this is shortly referenced in the technical documentation for the fees I've shown before. The idea is as follows. Right now, every account contact has to have a certain structure. It is not completely arbitrary. It does have to contain an execute method. All interactions with your account contract has to go through this particular entry point. And the Starknet OS, which is the Kyo program behind Starknet.
00:46:17.310 - 00:47:38.090, Speaker C: You can think of it as Starknet's engine will inject another call at the end of this execute function from the account contract, which will transfer the fee that you signed on, or at most this fee, to the sequencer's balance on l two. So basically what happens is you signed a certain max fee. You called the execute method, which also verified the signature. And then if all the execution was valid, let's say the sequencer estimated your transaction fee to be half of the max fee you actually signed. Then what it will be able to do is inject a call to a sort of a transfer method in the end of this function that will give half of the max fee you signed on to himself to his own address. There are no limitations here. He can transfer to himself any amount between zero and the max fee that the user signed, which obviously serves as an upper bound on the fee.
00:47:38.090 - 00:47:42.700, Speaker C: So that's the way it roughly works.
00:47:43.390 - 00:48:19.160, Speaker A: Thank you, understood. It also does mean that currently one can still send garbage transactions that are invalid and they will be executed by the sequencer. So it's still a DoS vector, right? Having the fee and having red grain fee are two different. The word in French is chantier, but I would say like are two different things. We're working on. Right. I was wondering if you have an update or if you could talk a bit about red fee, grand fee, or.
00:48:20.010 - 00:49:24.070, Speaker C: The yes, so I don't have any news regarding to the long term DOS prevention plan, but this is unrelated to the current change. Right now the sequencer is only able to charge fees for successful executions. There is no fee associated with an unsuccessful execution. Maybe just in two words. As the account obstruction evolves and you can see the full plan on the starnet shamans discourse platform, it will have even slightly more structure. Right now we have the execute function, which is a mandatory entry point for an account contract. In the future, there will also be a validate method where the flow of every transaction would be to first pass through validate, which can do whatever the account contract wants.
00:49:24.070 - 00:50:17.258, Speaker C: It can verify a single signature, it can verify a multi sig, it can do some weird logic. And only then if the verification was successful, then the running is transferred to the execute entry point. So what will be possible is to charge fees for transactions where validate was successful but execute wasn't. Because this means that this is indeed a transaction that was signed in a generalized sense, or approved, I should say, by the user, but was unsuccessful for every reason. So this means that the sequencer did try to do some effort. He at least verified that this transaction was indeed approved. So in this case, we might want to allow him to charge some fee.
00:50:17.258 - 00:50:35.490, Speaker C: Probably not all the fee, but maybe a small portion of it. But that's the future, let's say, of a possible future of account contracts. Right now charge any number between zero and the max fee, and only upon successful execution.
00:50:36.550 - 00:50:37.154, Speaker A: Thank you.
00:50:37.192 - 00:50:38.020, Speaker B: Thank you.
00:50:41.750 - 00:51:06.380, Speaker A: What about limiting functions tend to starknet to account contract? Is this enforced yet? Or is it still possible to send transaction to any smart contract? And the second question is, how does starknet OS differentiates between account contracts and regular contracts that are valid entry point?
00:51:09.390 - 00:51:53.558, Speaker C: Okay, so today you can still interact directly with contacts with the smart contracts which are not accounts. This will no longer be possible. In 0.9, your transaction will have to go to an account contract and pay a fee. And how will stocknet differentiate? Actually, it's pretty easy. Any contract with a few given entry points, in this case only execute can be considered an account contract. So if your contract has an execute function and enough eth in his balance, enough l two eth on l two, then it can serve as an account contract and the transaction may go through it.
00:51:53.558 - 00:52:02.090, Speaker C: Because after running execute, the sequencer will be able to transfer funds from the executor to himself.
00:52:04.430 - 00:52:04.954, Speaker A: Thank you.
00:52:04.992 - 00:52:05.866, Speaker B: Thank you.
00:52:06.048 - 00:52:21.620, Speaker A: Marcelo is asking if at some point the sequencer will be elected, is it possible for such a sequencer to accept other tokens as fees? In other words, can we pay in other tokens than just EtH, or do we plan to allow this?
00:52:24.900 - 00:53:06.220, Speaker C: So yeah, it's complicated with the whole discord zoom thing. So yes, we do plan to allow it. This is actually our post on account obstruction is divided into two parts. So look for account obstruction part two. That's where we talk about fee obstruction and introducing paymasters and the ability to pay in different tokens. In the near future, it won't be possible. In the near future, the fee token will be fixed at ETH, but we do plan to have a fee abstraction in startnet.
00:53:08.480 - 00:53:14.172, Speaker A: Perfect. Thank you. Account abstraction, fee abstraction. And now with warp we have Cairo abstraction.
00:53:14.316 - 00:53:15.010, Speaker B: Interesting.
00:53:16.260 - 00:53:46.490, Speaker A: So Marcelo is also asking, so we were talking know, basically validate and execute and the evolution of account abstraction. The question here is, does that mean that users will pay for reverted transactions? Yeah, I think that here the question is specifically around how do we charge for users when their transactions are not executable, and what we see as something that may arise here.
00:53:49.960 - 00:54:51.952, Speaker C: So one possible solution is the red green fee that you mentioned, which means roughly the idea is for user to sign two different types of fees. One is the red fee and the other is the green fee, which is higher. And upon successful validation but unsuccessful execution, the sequencer would be allowed to charge the red fee, because successfully running validate can be taken as indication that the sequencer indeed honestly attempted to execute your transaction and failed. This solution can obviously be improved because there are a certain way to attack this. Let's say that a sequencer is malicious and only ever takes the red fees. He never attempts execution. Then perhaps the user might want to blacklist certain sequencers.
00:54:51.952 - 00:55:04.120, Speaker C: There are ways to work around it, but the highlight of the idea is to have two type of fees, one for successful execution and the other for successful validation.
00:55:07.520 - 00:55:52.120, Speaker A: Thank you. It's not directly related with what we were discussing, and it's a question I don't have an answer to, but a user was asking, hey, how do I know if my starknet node is syncing correctly? How do I monitor that? I haven't used Pyfinder yet. I was wondering if you had, or if you have any insights into that. But I guess if I had to guess, probably there's a command to tell you what is the last block number on your node? Probably you can check. What's the latest block number and check on Voyager or something else, and you can see if the node is synced. But. Yeah, I don't know, Ariel, if you have other insights on how do I know that my node is running correctly?
00:55:55.100 - 00:56:34.936, Speaker C: Okay, so I haven't run the node myself, but we do have a Discord channel with the Pathfinder folk who can definitely answer this more expertly than I can. But the node does serve JSON RPC in particular. You can get the current block number. You can get. The less block that was seen on l one, the less block that was seen on l two. Basically, when you're running the node, you basically know that you're doing the right things to verify. To verify the current state of Starknet because you're running the actual code.
00:56:34.936 - 00:56:38.890, Speaker C: So I'm not sure that answers your question, but.
00:56:42.060 - 00:56:55.596, Speaker A: Thank you. Okay, so I know you have to run. So thank you. One last question. Your name is feed the fed on discord. Can you talk a bit about inflation and how you see this coming from. No, I'm kidding you.
00:56:55.596 - 00:57:00.128, Speaker A: I know you're in a hurry and you can't stay for too much. This will be a discussion for another time.
00:57:00.294 - 00:57:02.770, Speaker C: For this discussion, I can always stay.
00:57:05.620 - 00:57:24.596, Speaker A: Okay. Thank you, Ariel, for taking time with us today. I'll be here for a few more minutes if you have a follow up question. Thank you, Ariel. Bye. So, Nico is asking. I hope that's not a stupid question.
00:57:24.596 - 00:58:09.332, Speaker A: It never is. Don't worry about it. When it comes to fee abstraction, how does it work in the background? Does for example, if you pay with die, the DAi just gets converted into eth instantly. And if yes, how will this be swapped? Will a custom amm be built for this? Or how will an amm be chosen and everything? So I posted in discord right above your question, two topics that were created by starkware. Member about Starknet, like the count abstraction model we're imagining for Starknet. So I invite you to take a look there because this is where we share our ids. All of this is still being worked out.
00:58:09.332 - 00:58:39.330, Speaker A: It's not fixed. We don't have a fixed design for everything. We're very much building this as we go and as you guys give us your feedback. Your feedback is read and used, and we very much take it into account. So don't hesitate and engage in these posts. In shamans. There is no stupid question and no stupid answers to these questions specifically for your question.
00:58:39.330 - 00:59:27.904, Speaker A: I don't know if it makes sense necessarily to convert the DAi to ETH. Maybe it makes sense for each sequencer to specify which token they accept to pay for the fees. So maybe they will want to receive it directly, maybe they'll want to convert it. So I think there's a lot of way you can design around. You know, Marcelo was saying, hey, does that mean that as a company I can pay for the fees for my user? You can also probably implement wallet where fees abstraction is abstracted. So basically, even if the sequencer accepts only ETH, you can change his die on the fly with another kind of account contract to pay in ETh. You can imagine a lot of things with that.
00:59:27.904 - 01:00:08.044, Speaker A: So I'm not sure if it makes sense to implement this at the core or just let the sequencer choose what they want to receive, but that's just what I think. Right? Your opinion? I'd be curious to have your opinions to do. Share it on shamans, by the way, talking about shamans. So I wanted to talk about this very briefly. Currently, our community seems to synchronize around two tools, which is discord and shamans. So discourse, and to a large extent also Twitter. But that doesn't count.
01:00:08.044 - 01:00:52.760, Speaker A: It's different because discord and discourse are really like starknet focused tools. I think one of the things we need to figure out as a community is how do we fix knowledge somewhere that is indexable and where Google can be used to index the content and search for it later on. If you're in the Starknet channel, you probably have seen the same questions come over and over again. And then we have have. I say we as a community, because most of the time it's not us answering, it's you guys like answering the same questions. There's no easy solution to that. Setting up stock overflow is not accessible right now.
01:00:52.760 - 01:01:51.390, Speaker A: We don't have a big enough community for that. And so we deployed this discourse instance shamans to both have high level discussions, and right now we have them there. We have really high quality discussions there, and that's really cool. I think it's also a platform we could use for support. I know open Zeppelin uses it a know people post questions and then they get answers and everything. So I think my question for you, or my remark is like, I think we can use this tool better as a community to answer the questions of people there, and to redirect newcomers to ask their question there so that we can point them there with a link, rather than just answering the same thing over and over again. So anyway, if you have an insight in that, or if that's a question you think is worth digging, I'm happy to talk and to discuss.
01:01:51.390 - 01:02:32.730, Speaker A: Yeah, so I'm going to check if there are other questions. I don't seem to see these in YouTube and I don't see other questions in Discord. So I think if we're done, that's a wrap. So Francisco is saying here's a list of projects using the library. Yeah, so Francesco just posted some links towards the library with Tokenom. So don't hesitate and click there. Okay, so if there are no other questions.
01:02:32.730 - 01:03:13.560, Speaker A: Thank you for attending. Always happy to see people turn out here. It's really interesting because we've done some calls that were just on YouTube and they never have as much attendees as there is on discord. But a lot of time people share their screen in YouTube and you can't see them on discord. So I'm really curious why that is the case. But yeah, I think for now, even though it's not very convenient, we'll still stick to discord and YouTube. So yeah, that's for the community organization.
01:03:13.560 - 01:04:10.952, Speaker A: And also if you want to present your project or come show something cool around what you're building on Starknet, there's a post on shamans with the upcoming date for the calls. So don't hesitate and say, hey, can I present that date? Always welcome and we're happy to showcase your project. And also I wanted to mention that we are currently trying to extend our education for it on Starknet and to get more people on boarded and to explain to more devs how starknet works and how they can deploy smart contract. If it's something you'd like to be involved in, do reach out. Happy to brainstorm on how we can make things better. And I also wanted to mention that we are currently running a program for meetups. So if you want to organize a meetup in your city, there's a lot of different ways it can happen.
01:04:10.952 - 01:04:58.624, Speaker A: The best configuration is if you can organize it. We're happy to help pay for the venue, for drinks, for pizza, whatever. And the ideal way for this to happen is you present Starknet, you may present what you're building on. I mean, you organize the meetup as you want and we can make time to be available for an AMA and to discuss, to answer questions remotely. Yeah, and if your event is somewhere close to where we are, which is Europe or Colorado or Israel, who knows, we may show up and do the IMA in person. I for sure if it's in Europe would be happy to come. So don't hesitate and organize these events.
01:04:58.624 - 01:05:26.360, Speaker A: Do let us know how we can help you. All right, so I think that's a wrap. Thank you again for your attention, and I'll see you next time. Next call is in two weeks on Tuesday, 29 April. All right, so I hope everyone has a good day. Until next time. Bye.
