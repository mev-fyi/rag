00:00:02.450 - 00:00:36.000, Speaker A: You. Hello, everyone. My usual first question. Can you hear us and see us? If you can just use the chat, it's okay. Thank you, Anton Marwan. Thank you. Okay, so it's a pleasure to have another stark at home.
00:00:36.000 - 00:01:29.038, Speaker A: And this time the focus is going to be on magnificent project called Warp. And we have the creators of the Warp project with us. And let's focus the screen on them. I'll just introduce, first of all, with me to lead the interview is going to be Shahal Papini, who's on, if you have the same screen on the left, Cairo, co creator from Starquare. And now I'm going to focus on our main people in the event. So we have Greg Vardy, CTO of Nethermind as of two days ago, I think, and Yorick Schiliken of the warp project and at Nethermind and many other things. And the essence is going to be about warp, and we'll hear all about it.
00:01:29.038 - 00:02:02.042, Speaker A: Just before that, I just want to mention that if you have a question, the chat isn't so good, so you better use the ask a question button. There's already seven questions. Slava wrote a question. I think it's in Russian. So if someone can translate it as a comment, and there's another one. Anton wrote two questions. Unfortunately, we don't have russian speakers among us here, so please limit the questions to English so we can all address them.
00:02:02.042 - 00:02:15.758, Speaker A: If you have a question, put it there and we'll answer it there. So maybe let's start off just with Greg and Yorick. Do you want to just give a brief introduction and tell us what is warp all about? Cool.
00:02:15.844 - 00:02:47.926, Speaker B: Yeah. So warp is obviously a solidity to Cairo transpiler. It didn't start out that way, though. I'll just give a bit of a history about warp. So our first approach was to try take EVM bycode, like the opcodes, and transpile them to Cairo. It turned out this was extremely inefficient, and there's a bunch of reasons, mostly because even the really simple solidity contract can generate a ton of bycode. And so we're generating very large Cairo contracts.
00:02:47.926 - 00:03:23.682, Speaker B: And then we took the next best approach after that approach that led us to result quickest, which was going with Yule. So Yule is solidity's intermediate representation, and an intermediate representation is just sort of like a lower level representation of solidity. And the efficiency gains are pretty good from that. And we managed to get it finished, like, fairly quickly after doing the first approach. And now walk 2.0 which has just been made public but still isn't production ready. That works by transpiling solidity directly to Cairo.
00:03:23.682 - 00:03:26.550, Speaker B: And it's a lot better in pretty much every dimension.
00:03:27.610 - 00:03:56.720, Speaker A: I now realize that maybe I jumped a bit too fast. So all four of us know what Cairo, Starknet and this and that are, but I think I jumped too fast in. So maybe I'm going to ask Shah, do you want to just give maybe just an introduction into what Stark and Cairo and Starknet is? And why would anyone want even a transpiler or something like that? And then lead the discussion from there please?
00:03:57.970 - 00:04:45.786, Speaker C: Sure. Well, Stark is a proof system that we use at starkware to help scale the blockchain. This is the main use we have for it and currently we use it in Starknet. Starknet is a L2 blockchain that we have. It runs Cairo. Cairo is programming language which is meant for Starknet. And it basically produces very efficient, very short proofs of a lot of transactions of Starknet.
00:04:45.786 - 00:06:08.380, Speaker C: And it posts them on Ethereum. So basically it's supposed to get the security of Ethereum while getting a scaling and efficiency of a regular computer, my home computer or big computers, and not be bound by Ethereum. So a bit more on how Starknet works. It runs Cairo virtual machine bytecode, unlike Ethereum which runs EVM bytecode. So it's a different architecture. And that is that a lot of developers today are very used solidity which compiles learning a new language might sometimes be a barrier. Now I do want to point that programming in Cairo sometimes might be beneficial, but if these programmers that are very used to solidity will have a better way to take their current solidity contracts and compile them to Cairo and just run them on Starknet and get the scaling benefits.
00:06:08.380 - 00:06:22.566, Speaker C: This would be very nice. And this is what we are going to talk about with this. Enough, Ellie. Ellie is on.
00:06:22.688 - 00:06:31.690, Speaker A: Yeah, so why don't you start peppering Greg and Yorick with some questions about warp.
00:06:31.770 - 00:06:57.450, Speaker C: Yeah, sure. Okay, so can you describe, the task is to take this solidity code that everybody's used to and produce carrot code. Now can you describe what your initial approach for this was? And maybe was it? And properties?
00:06:58.590 - 00:07:39.480, Speaker B: Yeah, so the initial approach was probably the easiest way to get this done and that was to take the solicit and use the solipsy compiler to turn it into EVM bytecode. And then basically. So EVM bytecode is just a set of instructions, there's a bunch of different opcodes. And so basically we would implement each opcode as a function in Cairo. And then we'd also have to maintain the EVM stack because the EVM is stack based. And EVM memory, this approach is pretty easy because there aren't that many opcodes for the EVM. And the EVM is a very simple architecture so it meant we could sort of get something out the door as quickly as possible.
00:07:39.480 - 00:08:44.250, Speaker B: And it turned out that it was very inefficient because you have to maintain a stack in Cairo, you have to simulate EVM memory. Everything is like call data encoded, which basically means, for those who don't know, is when you send a transaction on the ethereum network, use ABI, encode the inputs to the function or the smart contract you want to call. And then on the other side in the contract it has to decode this input and it has to do a lot of bitwise operations which are quite expensive. And probably the main thing was that like an ERC 20 solidity contract, which is a token standard, it can produce like 10,000 opcodes, 11,000 opcodes depending on how it's implemented. And so you end up getting like a lot, a lot of Cairo and the contracts become pretty large pretty quickly. So that approach didn't really work. We had a working prototype, but they were very efficient, like pretty massive overhead, like 1000 x versus 100 kara.
00:08:46.110 - 00:08:55.840, Speaker C: Okay. And you mentioned that this approach might be inefficient. Just said. But it was quick to write. How quick was it?
00:08:57.170 - 00:09:06.018, Speaker B: I think we got it done in the bartcode approach. Two months, two and a half months I think. Okay. Yeah.
00:09:06.184 - 00:09:19.654, Speaker C: So in two months you had like a working version that you could take politic contracts and compile them to very inefficient contracts, but working contracts, yeah.
00:09:19.772 - 00:09:53.860, Speaker B: So the reason that we weren't able to figure it out, we'll definitively say earlier, is because if you want to do this method on any sort of nontrivial solidity contract you basically need to support all the opcodes, right? And once you support all the opcodes you just can support any solidity contract. Otherwise we would have figured out earlier. Because when you hit the point where you can run like a contract that actually does something because of those, how simple the EVM is, it means you pretty much have all the opcodes implemented. So you can handle almost anything, basically.
00:09:55.110 - 00:10:06.280, Speaker C: Okay, you guys realized that this approach was inefficient. So what was the next step?
00:10:06.650 - 00:10:10.200, Speaker B: Yeah, so the next thing was we had.
00:10:12.730 - 00:10:59.666, Speaker D: The next thing we attempted was going through an intermediate language which is being developed by solidity it's called Yule. And the idea is that that could be used by various implementations to run solidity code, but it's slightly easier to work with than the EVM code. You can still put your own optimizations on it and so on. The reason it's useful for us is because it already did a lot of things. That solidity has its semantics, so it handled imports and it did a bunch of optimizations on basic arithmetic operations and branching. And then the final language is quite simple. So it's easy to encode in Cairo, and it's actually quite close to Cairo.
00:10:59.666 - 00:11:24.270, Speaker D: In a lot of ways it's easy to work with. So we then built the transpiler for Yule. So it basically goes solidity. And you point the source C compiler at that point at Yule. And then we just wrote from Yule to Cairo. And this was actually quite good. It also went quite fast, that implementation, and it was also quite handy that we had the implementations for the opcodes, I think.
00:11:24.340 - 00:11:43.122, Speaker B: Yeah, because there's only one type apart from string literals, and that's the U into 56. And the evm, it's the same. There's only one type U into 56. And a lot of the UL built in functions, they're just EVM opcode functions. And we had all of those implemented already.
00:11:43.176 - 00:11:43.346, Speaker A: Yes.
00:11:43.368 - 00:12:24.926, Speaker D: So we could just call out to those whenever needed. So we'd already gotten a bunch of work done in the first place. But this actually also turned out to be quite inefficient, even though it did work and was compiling quite large contracts, but not as large as we would have liked. And most of those inefficiencies come from two areas. One is that the UN 56 operations are quite slow because Cairo's data type is a felt, and Un 56 is larger than a felt. And bitwise operations multiplication require more steps than your normal architecture would take. And then the other major inefficiency is that we still rely on the call data semantics, which is this encoding and transcoding that's required for the function calls.
00:12:24.926 - 00:12:40.678, Speaker D: And it turns out that if you get rid of that, you can get a lot of optimizations out of it. So we were still wrestling with this, and it's just a fundamental part of this approach that makes it inefficient, which led us on to what we're currently working on.
00:12:40.844 - 00:12:53.126, Speaker C: Yeah, okay, just a few questions about this approach. Okay, so yeah, like you said, it probably still has efficiency problems, but was it better than the previous approach?
00:12:53.238 - 00:12:59.950, Speaker B: Yeah, much much better, because we didn't have to maintain an EVM stack anymore because Yol doesn't expose that directly.
00:13:00.690 - 00:13:12.030, Speaker C: Okay. And by the way, can you tell me, think about how the warp team developed throughout these stages? Same. Did more people work on it?
00:13:12.180 - 00:13:34.390, Speaker B: Yeah, so we've gradually had more and more people joining since we first started, I think in June. I think it was three of us in the beginning, and now there's about nine, including interns. So yeah, it's gotten a lot bigger. But also because the current approach with warp 2.0 is a lot more complex than the Yule and bytecode approaches.
00:13:36.750 - 00:13:59.280, Speaker A: I'm going to be the one in charge of asking the dumb questions. So you mentioned something about EVM being UN 256, and then you need to move it to something that you said, a felt or something. So I'm guessing it's not the cloth, but can you maybe explain what do you mean? And what's the issue here?
00:14:00.610 - 00:14:10.254, Speaker D: The felt is the fundamental data type. With Cairo, it is a large prime over which we have a set of operations that we can construct our proofs.
00:14:10.302 - 00:14:13.970, Speaker B: Well, the felt is an integer over a large prime theft, right?
00:14:14.120 - 00:14:26.230, Speaker D: Yes, technically a restriction of that range. Un 256 is too big. I think the felt, I'm really bad at remember numbers off top of my head. But it's 128, right?
00:14:26.300 - 00:14:26.786, Speaker B: Yeah.
00:14:26.908 - 00:14:27.580, Speaker A: Cool.
00:14:28.110 - 00:14:37.658, Speaker D: So to represent 256 bit integer. Oh no, it's larger, right? No, we split the 128 ranges fit with the boat. But it's 240.
00:14:37.824 - 00:15:09.830, Speaker B: Yeah, basically because the felt, if you're talking about like positive and integers, which is positive and negative numbers, we can't do 256 bits in the felt because you'll get an overflow. So what you need to do is you need to create a structure that holds like two felts that represents the high and low bits of the UN 256. And so now every operation on that UN 256, that structure, because it's got two elements, everything is at least twice as slow.
00:15:10.810 - 00:15:29.194, Speaker A: So now I realize I have another dumb question, but this time I think it's to the Cairo co creator. Why did you pick this weird data type of felt and not work like everyone else with 256 bit integers or something like that? Why is that?
00:15:29.392 - 00:16:14.940, Speaker C: Yeah, that is a good question. This is a corollary of a main decision we made when developing Cairo. We could have made Cairo very compatible, maybe even EVM compatible, like SDKE EVM. The problem is, it wouldn't be as efficient for the proof system. Proof systems like starks are based on polynomials over finite fields. Using a basic type of field element gives a much more efficient polynomial equations. And this make also the proving time better and the verification time.
00:16:14.940 - 00:16:33.200, Speaker C: So a lot of the choices of chiral, including using field elements were done for efficiency sake, like the immutable memory, no followups included, and a lot of other.
00:16:35.730 - 00:16:36.480, Speaker A: Sounds.
00:16:37.350 - 00:17:31.540, Speaker C: I have a question for Greg. It sounds to me like there is an underlying issue here, that there is a difference between the basic data type in Cairo and basic data type in EVM. EVM. In Cairo we use field elements, and like you mentioned before, you started at the beginning was simulating this UN 256 operations inside Cairo as field elements, as you break it into few field elements and do something that is a bit more expensive than native computations of field elements. This sounds to me like something that is inherent, like a fundamental part of the problem here. How can you get over this problem?
00:17:32.070 - 00:18:38.300, Speaker B: Yeah, so the way you really get over it is to have, so we go up a level from the EVM into Yule, and that doesn't get rid of the U N 256 problem. But what it does allow us to do is because Yule is higher level, we can have more semantic context about where we are, let's say in a yule function, or are we in a for loop or something. So it's a bit easier to write more efficient code in that case. But then when we go up a level again to solidity, we have the full range of integers from like un to eight all the way up and into eight all the way up to 256 in steps of eight. So now there's like a whole bunch of types that people can use for their integer types. And yeah, sure, if someone does use a U into 56 in solidity, it's going to be just as slow as in the Yule approach. But because in the yule approach everything gets serialized down into a U into 56, so they end up being like an order or two of magnitude more of these u into fifty six s.
00:18:40.030 - 00:19:04.610, Speaker A: I realized that I have another dumb question. I hope it's not detracting. So let me know if it does. Everyone's talking about this zk evM. And first of all, I want to understand, is Cairo a zk evm is warp a zk evm? What is a zke evm? And is this it? Or where does it map?
00:19:05.830 - 00:19:41.840, Speaker B: Yes, so obviously Kyra isn't Zke EVM, but Zke EVM is just like an implementation of the EVM that is amenable to zero knowledge proofs. So I think they're right. Well, no one, there's no open source implementation yet I think there isn't. So like a lot of the ZKVM rollouts, the implementations aren't open source, so it's sort of really difficult to know how they're actually doing it. But yeah, that is different, because Cairo has its own virtual machine, which I think obviously Shahara can talk about.
00:19:44.290 - 00:20:12.662, Speaker A: But then I'm confused, because if warp takes code that is designed for the EVM and somehow magically makes proofs for it, well, not zk proofs, but people call them zk proofs, but they're validity proofs. Mean, is this a competing approach? Is it the same thing? Why isn't this not Zke EVM? Or where does that fall? Where does war?
00:20:12.716 - 00:20:45.294, Speaker B: Yeah, I think if you look at it at like a really high level, you could say that it's making starknet EVM compatible if people are only writing solidity, I guess, which 99% of people do only anyway. So in that sense, yeah, if you don't want to be too pedantic about the definition of it, then you could call it that, I guess. But yeah, the main difference is that the ZKEBM is running the solidity. We're not running the solidity, we're taking the solidity and turning it into Cairo and then running the Cairo.
00:20:45.342 - 00:20:45.650, Speaker A: Right.
00:20:45.720 - 00:20:52.340, Speaker B: But to a high level user they would still just be writing solidity in both cases. So to them there's virtually no difference.
00:20:52.970 - 00:21:57.100, Speaker C: Yeah, I want to add a few words here as well. I'd say there are two approaches here. One that might be called ZKEVM, is taking the EVM semantics and implementing them as the polynomial equations of the proof system, whether it's stark or stark or something else. So really doing it as the virtual machine of the underlying l two or blockchain or whatever. So another approach is not to take the EVM semantics and make polynomials of them. The approach that we took is compiling it to Cairo and having polynomial equations just for Cairo. Now there is questions of what is better, why one or the other.
00:21:57.100 - 00:23:36.870, Speaker C: If you know everything you need to do is EVM, then maybe a ZKVM would be better, but not always. I'll give an example. Assume you have solidity contract, and it doesn't really use a lot of the EVM native things, a lot of ketchup, a lot of un 256 maybe has some simple logic that can be translated very nicely to Cairo. In this case, using warp might create a Cairo contract, which is a lot more efficient to run on Starknet than if it was in ZKEVM, because for example, if you only use uint eight, uint 32s, something like that, then it could be the case that just more efficient, because car was efficient and you use simple logic. Now, the downside of this approach, however, is that everything is not fully EVM compatible in the sense that taking the state of Ethereum right now, and with all the EVM bytecode that is in every contract, all the data there, and you can just plug it into Starknet, there needs to be some translation. So it's not fully compatible with EVM Ethereum as it is today. It requires some translation.
00:23:38.170 - 00:24:25.510, Speaker B: Yeah, yeah, I think those are some really good points. And further to that point is the EVM wasn't designed originally with this in mind, right, to be zero knowledge compatible runtime. And so when you're trying to take that and push it into a different shape, it can be much, much more difficult. Whereas if you have Cairo, you can think, start from scratch, and say, if, let's build the best possible validity runtime, validity proof runtime. And so you're not necessarily constrained by a bunch of historical semantics that were defined without taking this into consideration. So it opens up a lot of doors, like built ins or some of the really cool things in Kyra.
00:24:25.950 - 00:24:45.280, Speaker A: Yeah, sorry for detracting it to this question, but I mean, Shahal, Yurik, if you want to continue on the line of questioning, also at some point, Shahal, when you feel comfortable, maybe we should go to the ask a question, or when Greg and Yurik think it's a good time, I'll leave it to you. Sorry.
00:24:48.770 - 00:25:08.360, Speaker C: Yeah, I think we can go on to the next questions, if you're okay with it. Can you describe what were the main challenges you encountered while in development, in programming, also in efficiency and how you overcame them?
00:25:10.250 - 00:25:13.334, Speaker D: Are you interested in the old approaches or the current one that we're there?
00:25:13.372 - 00:25:14.662, Speaker B: Let's talk about work 2.0.
00:25:14.716 - 00:25:29.946, Speaker D: Yeah, so Orc 2.0 is a new approach which is intended to be more efficient and basically produces Cairo code that's much closer to the original solidity. This works really well because it reads very much like the original solidity contracts.
00:25:30.058 - 00:25:31.578, Speaker B: What would like the challenges?
00:25:31.754 - 00:26:48.642, Speaker D: Yeah, so the challenges to this are there's a bit of a mismatch between solidity semantics and between Cairo semantics that's mostly inherent in the immutable data that's in Cairo, while solidity is mutable. So we can pass around references to arrays, update values, but in Cairo we can't do that. And our only way to approach this is to try and build a memory model in immutable memory, which we can update piecewise with the updates that are expected on the solidity side, and then collapse them all together at the end. And for that we've had to write basically an entire abstraction for all of the data types of solidity, and also write an abstraction for how they represented storage in layer one storage, and come up with this framework that was general enough to handle all the cases not so specific that it was annoying to work with. So that was one of the biggest challenges that is being finished more or less this week or next week. Don Henderson has done a lot of the work on that, and it's coming together very nicely, which is great. The other thing is representing types in Cairo.
00:26:48.642 - 00:27:00.554, Speaker D: Questions, how do you encode each of the basic facility types? And that needed some planning at the start, but after that this project has actually been quite screen saving and warp 2.0 is coming together quite quickly.
00:27:00.752 - 00:27:37.218, Speaker B: Yeah. So just to take you through like a basic flow of how Warp 2.0 works. So what happens is we use a library to get the ast obsolete, and I'll explain what that is. It's an abstract syntax tree, and it's like a structured representation of the solidity program, right. That makes it easy to traverse this tree structure that it's nice to traverse and do transformations on, et cetera, et cetera. So we take this solidity ast and then we do like a bunch of transformations on it that make it easier to generate Cairo.
00:27:37.218 - 00:27:58.326, Speaker B: So one example is we'll turn for loops into functions. We'll also turn some if statements into functions to prevent reference evoking in Cairo. What are some of the other ones we do? Like constant folding, like some small optimizations. So it's just a bunch of these steps.
00:27:58.358 - 00:27:58.746, Speaker A: Right.
00:27:58.848 - 00:28:05.646, Speaker D: Need to replace all the arithmetic with the correct faults to Cairo functions because they're not likely to Cairo over there.
00:28:05.828 - 00:28:17.940, Speaker B: And then at the end of this we have a solidity ast that's much easier now to generate Cairo from. And so we go through each ast node and we generate the corresponding Cairo basically.
00:28:18.390 - 00:28:26.760, Speaker D: And luckily it's so close to Cairo that that rating was very simple, which allowed us to have a working prototype within a couple of days when we started.
00:28:27.850 - 00:28:34.200, Speaker C: Nice. And this new approach, how efficient is it?
00:28:35.150 - 00:28:43.354, Speaker B: Yeah, we actually have some slides on that which we can share with you now. Wrong one.
00:28:43.552 - 00:28:44.540, Speaker D: It was.
00:28:46.750 - 00:28:47.660, Speaker A: There. Yeah.
00:28:51.570 - 00:28:52.640, Speaker B: There you go.
00:28:56.290 - 00:28:59.354, Speaker D: So, yeah, it's also on the screen.
00:28:59.492 - 00:29:18.658, Speaker B: Yeah. So this is warp 2.0, verse 1.0. There we go. And as you can see. Well, this is the Yule version of warp and it's pretty much not even on the graph. So the blue lines are the number of steps in Cairo.
00:29:18.658 - 00:29:51.314, Speaker B: So this is generally how we think about efficiency in Cairo is through step count. And so as you can see, the blue line is before, which is the old version of warp. And the new one, the orange, is the warp 2.0. And it's pretty much orders of magnitude more efficient in every single way you can measure it. There we go. Oh wait, no, you skipped one. Yes.
00:29:51.314 - 00:30:32.830, Speaker B: And so this is an example of makerdao. So Makerdao has written a Dai implementation in Cairo. Someone said they lost audio and video. Can you guys hear? Yeah, no, he's saying it works for him. Yeah. So as you can see, it's pretty much, the blue line is we took the makerdive solidity implementation of DaI and we transferred to Cairo and then we compared it with their handwritten version of the die Cairo contract. And it's pretty much the same, like no major differences for the standard ERC 20 functions.
00:30:32.830 - 00:30:51.218, Speaker B: And so the next slide is an example of what warp. So this is how ugly the Cara used to look for the Yule approach of warp. It's pretty unreadable. There's a lot of weird function names that get injected from Yule that gets.
00:30:51.304 - 00:30:56.166, Speaker A: Maybe you should increase the font size because I think at this size it's purposely done.
00:30:56.348 - 00:30:58.230, Speaker B: It's kind of on purpose to show you how.
00:30:58.300 - 00:30:58.920, Speaker C: Okay.
00:30:59.530 - 00:31:05.234, Speaker B: Because you'll see the next one now. Yeah, that's cheating.
00:31:05.282 - 00:31:11.674, Speaker A: Because now this is the unreadable one because the font now is bigger or this is the new one.
00:31:11.792 - 00:31:42.410, Speaker B: This is the one that's much more so. Those two are the same functions. The other function was like ten X is longer and was that one relative to warp 2.0, which is much easier to read. We'll have some documentation about how to read it. But one of the great parts about this is it makes your Cairo code a lot easier to audit and reason about. And obviously the warp fuel version is pretty much unreadable.
00:31:42.410 - 00:31:46.310, Speaker B: So that's one of the major pluses apart from the massive efficiency gains.
00:31:46.890 - 00:31:53.430, Speaker C: I just want to mention that we have a Cairo vs. Code extension that does syntax.
00:31:56.510 - 00:31:59.660, Speaker B: Yeah, my bad. Cool.
00:32:01.310 - 00:32:12.800, Speaker A: By the way, reminding you, maybe when you feel comfortable, maybe we should go into a few of the, there's quite a few questions. So when do you think would be a good point to jump over and see a few?
00:32:13.650 - 00:32:16.926, Speaker B: We can have a peek at some of them now. I guess yeah.
00:32:17.108 - 00:32:31.780, Speaker A: Okay, let me just make myself small. I want to make you guys bigger and then. Okay, Shakal, do you want to lead through the questions or do you want me to read them?
00:32:33.590 - 00:32:34.898, Speaker C: You can read the questions.
00:32:34.984 - 00:33:01.310, Speaker A: Yeah, I will read the questions. So question number one, it's a pretty long one. Is it? Or will it be possible for us to opt in to tell the compiler to just consider all our UN 256s as UN 252 instead, which is what would fit inside a felt? I believe in order to avoid these performance issues you were mentioning, I imagine a lot of scenarios, token contracts where those extra bits can be easily discarded.
00:33:02.530 - 00:33:33.960, Speaker B: Yeah. So you'd probably just use a UN 248 in solidity, which would then fit into a felt. So you would just write the solidity type to be whatever type you wanted it to be and then the warp would handle the rest. So, yeah, adding a whole nother type to solidity would mean that we would have to change the compiler. Solidity compiler a bit more. And it's like a bit of a maintenance cost, but if lots of people want it, we might consider it.
00:33:34.810 - 00:33:56.160, Speaker C: Also, I want to mention that UN 248 won't be good enough. Neither will 128. You actually need to go down to something like 124, I believe. Otherwise things would still be inefficient because you need to be able to multiply to the numbers and not get an overflow. So maybe down to 124.
00:33:58.450 - 00:34:05.860, Speaker A: Okay, next question is, how did the idea for the project come about? Anton is asking.
00:34:06.710 - 00:34:44.640, Speaker B: Yeah, so it was, I think Tomas, the CEO of Nethermind, was in contact with Yuri about this and they asked Nethermind if it was something that we could do. And Tomasch said, yeah, sure. And so we got an initial sort of prototype and sketch by the Starquare guys, you guys, of what the bytecode transpiler might look like. And I saw Yuri do a tweet saying something like, hey, we're looking for people to work on a transpire. And so I dm'd him and that's sort of how I got involved in the project, which was pretty early on.
00:34:46.370 - 00:35:00.370, Speaker A: Okay, next question. In what levels do you expect developers will use the warp? I'm not sure I understood the question, but I'm asking, I guess, in what levels do you expect developers will use warp?
00:35:01.910 - 00:35:38.160, Speaker D: I can take a stab at trying to interpret what it means, but we had basically two use cases in mind, especially with warp 1.0. The idea was to demonstrate the capabilities of Starknet by allowing you to just translate your basic contracts and see how they work. Like just show that they would work on Starknet, and Warp 2.0 is going to become a lot closer to an actual usable language. In that sense, you could write code for Starknet starting from solidity and having that work for.
00:35:42.130 - 00:36:19.900, Speaker B: If you have, let's say you're a protocol, right, and you have a big complicated solidity code base and you've invested a lot of resources and get people learning solidity. Everyone knows how it works really well. It's easy to extend and you don't really have the resources for some reason for your developers to learn. Cara. And so you could just go to your command line, type warp transpile with the name of your contracts and then walk deploy, and then your contracts are in Starknet. And so walk 2.0 should pretty much be able to handle almost anything apart from a few things that aren't implemented on Starknet yet.
00:36:20.930 - 00:36:59.530, Speaker A: Let's take the last question for now, and then we'll get back to more questions. So this question says it's two questions. One, what extent does transpiling solidity to Cairo expose new security loopholes? And two, how succinct is the transpiled Cairo code? Are people expected to start working with the transpile code at some point, or are they expected to continue editing in solidity? So one is a question about security loopholes, and the other is, do you transpile and then go and work in Cairo, or do you keep working in solidity?
00:37:00.910 - 00:37:02.886, Speaker B: Do you want to mention the semantic tests?
00:37:02.998 - 00:38:08.222, Speaker D: Yeah. So in terms of security loopholes, one of the big things when it comes to transpilers is that your understanding of the semantics of the original language and how it's encoded in the target language don't actually line up with the reality of the situation. This can show up anywhere across the stack from implementation CVM all the way up to transpilers and so on. To try and fend this off, you can formally write a definition of the language, which we have started partially. I don't know if the project is going to continue, but it's a specification of you and a specification of solidity in lean, and then in a more sort of direct engineering style solution, there are a whole set of semantic tests, about 1200 of them, that solidity has implemented for their implementation of the solidity compiler. And we've been able to take these tests, translate their inputs, the correct inputs for the Yule approach that's Warp 1.0, and for the current approach in warp 2.0,
00:38:08.222 - 00:38:18.420, Speaker D: and run all of their tests against our transpiled versions so we can try and guarantee that the semantics of the first, I'll tell you the second.
00:38:18.870 - 00:39:13.540, Speaker B: Yeah, so the solidity compiler, as you said, it has these over 1000 semantic tests and it's just code written in solidity. And then you have some function calls that test like almost all of the semantics of solidity and some expected output and results of those function calls or executing certain solidity code. And so we take all those contracts and all those tests and we transpile them to Cairo and then we execute them on the Cairo VM and check that the outputs and the expected results are the same as the ones that were defined in the original test. So those tests cover almost all, pretty much all of the solidity semantics. Well, as reasonably possible. Right. And so when we have all of those passing, we're pretty confident that it's semantics preserving on the security front.
00:39:13.540 - 00:39:16.120, Speaker B: And what was the second question again?
00:39:17.130 - 00:39:37.340, Speaker A: Okay, our developers, what's going to be the mode of operation? I just keep on writing only in solidity and I don't need to know anything about Cairo. Or is it like this one? Or I first write it, get it in Cairo and then I move over and continue in Cairo. How is it going to work?
00:39:38.030 - 00:40:04.594, Speaker B: Yeah, so with walk 2.0 you have either choice. You can use walk to transpire some of your contracts to Cairo and then you can write Cairo native Cairo for the rest. Or you can just write solidity and transpire your solidity contracts. And if you want to make a change, you just go change the solidity contract. But that's the nice thing about walk 2.0 is it will be readable the generated Cairo.
00:40:04.594 - 00:40:12.630, Speaker B: So you will be able to just generate some Cairo from some of your solicitor contracts. And then you may want to handwrite the rest of the Cairo.
00:40:13.930 - 00:40:14.680, Speaker A: Okay.
00:40:20.110 - 00:40:52.130, Speaker C: As long as you are doing simple things. And if you're very familiar with solidity, then using solidity is okay. But I think the end goal should be maybe to use Cairo, maybe for the efficient part if parts don't translate well, and maybe for better interaction with other starknet contracts which are written in Cairo to be easier integrating.
00:40:52.650 - 00:41:00.760, Speaker B: Yeah, if you're a new project starting from scratch, it's better to go with Cairo. Straight? Yeah.
00:41:02.090 - 00:41:05.100, Speaker A: Shah, do you want to continue asking questions?
00:41:10.190 - 00:41:40.900, Speaker C: Let's see. Yeah. Okay, so there was the initial version that used bytecode compiled straight from EVM bytecode. The second version compiled from Yule. The third version is compiling from solidity. Is there anywhere to improve? Do you have any thoughts? But in the future what can be more efficient? What you want to do things like that.
00:41:44.310 - 00:42:30.142, Speaker D: With warp two. It's a fundamentally different approach to the previous ones, and I don't think there's much more space to do that big fundamental jump. So most of warp two will just be optimized. We realize that we can drop certain operations or change a pass in such a way that we produce less code and that work will continue as the project is maintained. In my opinion, the biggest jumps that you can make is to try and either restrict solidity in certain ways, or create your own higher level language to work with. And I know that there are certain projects that are looking into that, so I think that would be a huge thing. But I think we have cut out as much as possible to cut out of solidity while preserving the semantics.
00:42:30.142 - 00:42:30.820, Speaker D: Exactly.
00:42:32.950 - 00:42:46.782, Speaker B: Yeah. So it's quite difficult to do better than warp 2.0. There may be like small incremental improvements, but yeah, it's pretty good as it is. It's really difficult to do better for transpiler.
00:42:46.946 - 00:43:19.810, Speaker C: Yeah, I saw that the numbers are very similar to native Cairo as you showed in your graphs. But what about doing better than native Cairo? Theoretically, there are optimizations that are possible that native Cairo does not know how to do. Inlining things like that you already do constant unfolding as a herder, maybe more optimization this direction you do better than the native. Did you think about things in this direction?
00:43:20.470 - 00:44:03.250, Speaker D: Right now the push has been towards implementing the solution, but we have considered a few optimizations in the previous version, in UL1, in warp one, in order to get it faster. And I think there are a few avenues to go down there. I'm not actually versed on the specifics right now. The constant folding was an idea. Cairo's efficiency does depend on just how much code there is to execute. So anything like dead branch removals, or like dead code removal, or any branching optimizations that we can make, those would definitely be very useful, but those things need to wait until we have a full implementation.
00:44:05.350 - 00:44:10.290, Speaker B: Do you want to get your charger quickly? Yeah, sorry, Yari's just going to get his charger for his laptop.
00:44:11.190 - 00:44:19.190, Speaker C: Sure. These were my questions. Maybe you can take more questions from the audience.
00:44:19.850 - 00:44:34.090, Speaker A: Yeah, and we'll take more questions from the audience. And at some point I think it would be, were you planning maybe to show us how something transpiles? Or like what are the steps? Did you think of, do you have something like this up here?
00:44:34.240 - 00:44:58.930, Speaker B: We don't have a live demo, but there will be some examples on the repo, on the warp repo, which has the warp 2.0 as a branch on it. So the branch on the public warp repo of warp 2.0 is called warp Ts. TS is just for typescript, because it's written in typescript. And so we'll put up like a bunch of examples there, like transpiling die erc twenty s, et cetera, et cetera.
00:44:59.430 - 00:45:12.310, Speaker A: Okay, let's take a few more questions. Miguel asking do you support code that relies on things such as Gaz left and other EVM specific features?
00:45:13.290 - 00:45:27.870, Speaker B: Yeah, so there's things that don't yet make sense on Starknet, like gas left block, difficulty base, know those sorts of specific operations.
00:45:30.770 - 00:45:52.530, Speaker A: Okay, another question Yoav is asking. What are the limitations? What kind of solidity programs can't be transpiled to Cairo, or maybe can't be transpiled? I mean, there are like two questions hiding here cannot period. I don't know what that means. Something explodes, but there's also transpiles. But this is just completely horrendous.
00:45:54.890 - 00:46:45.070, Speaker D: Yeah, there are two main things that will not be supported by this. One is try catch. Basically the reverting semantics on Cairo would be a real pain to encode them in Cairo, basically, and it's almost impossible without actual support from Cairo. This is not to be supportive for the time being. The other thing that struggled a bit with is it works perfectly fine on warp 1.0, and if you need this absolutely desperately you can go towards that. But that's inline assembly, which is a big thing for fallback functions and proxy patterns and so on, which allows you to write Yule in the solidity code in order to use lower level operations.
00:46:45.070 - 00:47:03.850, Speaker D: But we do have a solution to this, which is that we're going to support inline Cairo in the long term, which allow you to call low level Cairo operations, which will do very similar things. The translations are usually quite simple between the two, so it's actually not that big an overhead to just go through your contract, find reusing, in line assembly and replace.
00:47:04.430 - 00:47:47.020, Speaker B: Yeah, because we've already got all the Yule functions implemented as Cairo library functions, so it'll be pretty simple to translate between the two. And there's quite an important reason as to why we don't want your written in solidity contracts. And because the second we allow that, we're again exposing EVM semantics and we have to AVI encode call data and AVI decode call data. And that's pretty inefficient to just add some inefficiencies, and then you have to maintain EVM memory again, because you all can have m store M load those operations, and so it just adds a whole bunch of overhead and it's not really worth it.
00:47:51.150 - 00:48:12.370, Speaker A: Okay, next question. Just 1 second. Where is it? Okay, commenting on the recommendation of using un 124. There's no UN 124 in solidity. I assume UN 120 should be the one to use and guarantee no overflow.
00:48:14.470 - 00:48:19.380, Speaker D: Yes, you divide by eight.
00:48:22.970 - 00:48:37.740, Speaker A: Okay, another question by Walid. Solidity uses a different elliptic curve than the one in Cairo. Does the transpiler convert the logic in any way to Cairo's native curve or not?
00:48:38.910 - 00:48:46.726, Speaker B: No. Is he talking about like the EC recover opcode, the pre compiles in solidity?
00:48:46.918 - 00:48:48.540, Speaker C: Yes, they certainly did.
00:48:49.150 - 00:49:09.140, Speaker B: Yeah, so we don't support precompiles either. And so basically if you're transpiling existing code in our readMe, we'll list all of this stuff. It'll all be there. So you can just have like a little checklist and you can just do a quick skim of your existing code to see if there's anything there that you'll need to change.
00:49:10.870 - 00:49:32.810, Speaker C: I assume that from a correctness point of view, these calls for precompiled contracts could be just replaced with calls to regular contracts that will implement those things. And we do have some Cairo implementations for elliptic curve operations in other curves and fields, so it should be not hard to implement.
00:49:36.930 - 00:49:45.230, Speaker A: Okay, another question. Is there similar work being done on transpiling wasm to Cairo?
00:49:46.130 - 00:49:47.520, Speaker C: Not that I know.
00:49:51.730 - 00:49:52.334, Speaker A: Okay.
00:49:52.452 - 00:49:55.460, Speaker C: But I'm accepting pull requests if you want.
00:49:59.110 - 00:50:26.250, Speaker A: I will say this now, speaking on behalf of Starker, just as we were very happy to support the warp project, if there is a serious contender for writing a wasm to a Cairo compiler, that would also be great. Which contracts are written in WAsm? I think it's some other blockchains. Right. But still, that would be also terrific.
00:50:26.670 - 00:50:29.626, Speaker B: Yeah, I think they're all Solana or something.
00:50:29.808 - 00:51:04.358, Speaker A: Yeah, that would be great. And then you can take Solana contracts and the logic there and make them. Yeah. So if someone out there wants to work on a wasm or let's make it more general. If you want to work on an X to Cairo transpiler, you fill in X for anything of interest and you're serious about it. We'd love to support that for sure, as long as it's not, let's say Cairo to Cairo or something like easy. Okay, another question.
00:51:04.358 - 00:51:16.266, Speaker A: I just want to pause and ask Greg and to is there other stuff that you want to present and discuss, or should we continue with the questions. There are a lot of good questions.
00:51:16.448 - 00:51:18.460, Speaker B: Yeah, we can just continue with the questions.
00:51:19.170 - 00:51:30.320, Speaker A: Okay, so how do you guarantee that the generated Cairo is a true representation of the original solidity? I like this question. It's a good one.
00:51:31.010 - 00:52:29.538, Speaker B: Well, that's. You could ask the same question as how do you guarantee that the generated EVM barcode is a true representation of the original solidity? And the word guarantee is like a strong word, so you would need to formally verify this whole process. So not even the solidity compiler has this. When I say a guarantee, I mean like some sort of proof, like formal proof, using a proof assistance or something like that. So even for the search compiler itself, there's no guarantee guarantee, but you can do a whole bunch of tests and test all the lowest level operations and all the different kind of semantics, thousands of them, and you can be pretty safe in assuming that it is the correct representation. What do you think?
00:52:29.624 - 00:52:31.346, Speaker D: As close as salsa is getting?
00:52:31.448 - 00:52:43.080, Speaker B: Yeah, as close as the solidity compiler is getting to taking the original solidity and the backcode representation representing it correctly, that's as close as we aim to get. Or we'll get to.
00:52:44.410 - 00:53:29.320, Speaker A: Yeah, I was just thinking philosophically or mathematically, the question of what the true representation true meaning is in these two models, you probably want to formally define what that means, and it sounds to me quite tricky. Next question. Do you introduce additional risks when transpiling from solidity to the Cairo vm instead of using a Zkevm? I see. So like in terms of risk. Well, I just want to say there is no zk Evm right now, so it's hard to compare, but. Okay. Assuming under some interpretation of what a Zkevm is, is it inherently, is one approach inherently more risky than the other?
00:53:30.730 - 00:53:49.370, Speaker B: Honestly, I think it's almost impossible to answer correctly without almost making something up when you're talking. You know what I mean? If someone gave an answer to that, they'd probably be making it up, I think, or just taking a wild guess. So yeah, I can't really say for sure.
00:53:49.520 - 00:53:52.814, Speaker A: Why? Because you're saying it's not. Oh, sorry, shafar, go ahead.
00:53:52.852 - 00:54:02.420, Speaker C: Yeah, I just want to say that one process I think is writing the warp compiler, which is written in Python. And what is it?
00:54:02.950 - 00:54:07.118, Speaker D: Version one is in python, version two is in typescript.
00:54:07.294 - 00:54:23.320, Speaker C: In typescript. So you need either to trust this typescript code or trust the polynomials for the keeping, whichever you can read better.
00:54:24.170 - 00:54:29.466, Speaker B: Yeah, true, very true. The typescript is a lot easier to read.
00:54:29.648 - 00:54:34.746, Speaker D: These questions get grizzly and grizzlier if you read anything like untrusting trust and then you realize you have to trust.
00:54:34.768 - 00:54:36.458, Speaker B: The entire system from top to bottom.
00:54:36.544 - 00:55:16.230, Speaker D: Then it gets a very complicated question to answer. But I guess the hand wave view one is both of them come with their own set of risks. We trust that Cairo is correctly implemented, you trust that we've written our compilers correctly, you trust someone else with their EVM is correctly implemented. But there's a lot of work in auditing and in testing that is going on, and we are testing in ways that are a lot better than most, in my humble opinion, quite thoroughly. And it will be fully audited by the time it's released.
00:55:18.110 - 00:55:46.978, Speaker A: So there's another question here I guess I want to throw. I just thought, I want to throw a question that just occurred to me. If I'm enthusiastic about this, is there any way I can help? First of all, if you can maybe post a link in the chat, I want to use this or help out or build something. Maybe I know how to work with compilers or programming languages. What could I do?
00:55:47.144 - 00:56:19.920, Speaker B: Yeah, Yarik is about to post a link now in the chat to the branch of Walk 2.0. And if you go to the readme of that GitHub page all the way at the bottom, there's a link to our notion that has like a bunch of tasks that we're currently working on and tasks that need to be worked on. So if you're interested in contributing, you can even dm me on Twitter if you have some questions about how to contribute or where we might need help, or have a look at the notion we are open to anyone contributing, really.
00:56:21.730 - 00:56:47.638, Speaker A: Okay, so the. Sorry, I just made it into a call to action button. The next question, I'm not sure I understand what it is, but if you can answer it anyways. Okay, what projects are priority project password? I don't understand.
00:56:47.804 - 00:56:49.160, Speaker B: Yeah, we don't understand.
00:56:50.730 - 00:57:09.600, Speaker A: Okay, this is a really nice question. I like this. Where do you see yourself in one year? And I guess I interpret it as in one year if all the stars align themselves, what's happening with warp in terms of usage, what's the development and so on.
00:57:11.570 - 00:57:34.406, Speaker B: We just hope that it's helped a lot of protocols that would have not otherwise deployed on Starknet deploy on Starknet. I think that's the reason we exist, right? Is that to lower the barrier to entry? Because I think we're all big believers in Starknet. We think it's amazing technology and we want to do everything we can to reduce the friction of allowing protocols to get onto us, basically.
00:57:34.588 - 00:58:02.320, Speaker A: And the typical, let's say one year from now, this is like the bridge that will help me bring over my smart contracts from Ethereum that were written in solidity. Or this is for a new developer for big established projects who's going to be using Warp one year forward? Well, if you get to choose, right?
00:58:02.690 - 00:58:05.418, Speaker B: If you get to choose, yeah, all the biggest protocols in Ethereum.
00:58:05.514 - 00:58:48.220, Speaker D: Yeah, every protocol. I really am hoping that warp will get close, so close to efficient that you could write, because you have to engage with a lot of the problems that warp solves, even if you're writing chiropode, like how do you handle mutable memory or store references to things? And if you just want to avoid that, you can definitely write in solidity and just go through warp and use all the semantics that you're familiar with. And I'm hoping that in one year's time, we're so close to handwritten Cairo, that there's a no brainer to choose that if you're doing something pretty small and you don't care that much about the efficiency, or you just want to see what your project would look like.
00:58:49.150 - 00:59:02.042, Speaker B: We want it to be completely seamless. You feeling like you don't really need to know what the Cairo virtual machine is. You can just click walk, transpal walk, deploy simple stuff, and then if you're.
00:59:02.106 - 00:59:04.800, Speaker D: Really counting the pennies, you can go to the Cairo site.
00:59:05.910 - 00:59:19.000, Speaker A: So here's another question, I'm not sure. It may be more for Shah, but let's see, because it could be interpreted about warp or about maybe Chiron Starknet, what do you intend to do to speed up application?
00:59:20.410 - 00:59:22.498, Speaker B: Yeah, I think that's a question for Shahan.
00:59:22.674 - 01:00:14.210, Speaker C: Yeah, that's a question for Shahan. I assume you mean speed up things on Starknet. Well, there are a lot of aspects to what speed up can mean. As for scaling on Ethereum, the more people use darknet, the more efficient it will become. Regarding l one costs. But another aspect in the current version of Starknet is not that fast, is basically just the sequencers. Remember that Starknet is only in alpha phase, still, it's not decentralized.
01:00:14.210 - 01:01:08.380, Speaker C: And we have a sequencer which is used mainly for getting used to the system, seeing how things work together, developing on it. But once it reaches a more mature phase and decentralized, then everything could be a lot faster. People have large machines and run their things. We could have l three s on top of it and make it even faster. Once the full node implementations and sequencers from developers which are working on it right now come to life. Everything should be a lot faster in this sense. But it's not that.
01:01:08.380 - 01:01:40.898, Speaker C: But it's not a theoretical challenge to run things fast on your local machine or in any one machine, which is what is required right now. Once we go past the alpha phase and when this gets done, then we would be able to scale a lot. L eleven will be the ball neck. I hope I answered the question.
01:01:41.064 - 01:02:44.462, Speaker A: Next question, which I think is also to Shah, but I'll also venture to say something about it. How does stark see app scaling at such a slow rate as it is today? So I think this is about probably the rate know transactions or something on the testnet. I want to say that doing what we're attempting to do, which is to validity prove general computations in a very efficient way is a pretty challenging. I mean folks like Shah and everyone on our team are working very hard, but it's a grand challenge. We focused so far was on usability. The next phase that we're just about to start is related to throughput and performance on Starknet. I remind you that we're very optimistic.
01:02:44.462 - 01:03:27.382, Speaker A: And one of the reasons is that we already have systems, basically the Starkx systems on DyDx and immutable that are running at TPS of basically any demand that was thrown at them so far, they sort of gobbled up very nicely. So there the scale and the throughput and everything is really good. And part of what happened with Starknet. Shah, you'll explain more about this. But we basically took that sort of engine and we brought it over as quickly as possible. And then there are many things there that are not as performant for a general purpose starknet system as they are for those systems. So we're aware of that.
01:03:27.382 - 01:03:40.330, Speaker A: And that's going to be the next phase that's going to last till roughly the summer. I hope people will bear with us and be willing to tolerate this. Shaka, what do you want to say about the rate and speed on startnet?
01:03:40.830 - 01:04:23.350, Speaker C: Yeah, I mean there are even things doing right now to make faster, whether it's the response time of our API and whether it's just executing all the transactions which currently run sequentially on a single sequencer, because that is just the minimal viable product for testability, for usability we had. So there are efforts right now to parallelize these executions and they should see even now a lot of benefit before the next phase.
01:04:24.970 - 01:04:54.100, Speaker A: Okay, I think we're going to take three more questions. And these questions I think are all of them to the warp team? The first one, I think it means, it says that in 2022 there will be transitions from solidity to warp. I guess I interpret that as asking, do you think that in 2022 you'll see, and I'm going to combine it with the next question. I think it's roughly the same thing. When do you expect Warp 2.0 to be production ready? I think they're sort of asking the same thing, right?
01:04:57.190 - 01:05:03.460, Speaker B: Yeah, I think warp 2.0, about a month and a half. Two months? Yeah.
01:05:03.990 - 01:05:09.830, Speaker D: To usable then production is still auditing.
01:05:10.250 - 01:05:18.860, Speaker B: Yeah. We need to go through an audit first before we can say, hey guys, it's production ready, but when it will be ready to be audited in about a month and a half, two months.
01:05:20.270 - 01:05:36.750, Speaker A: Okay, next question. And then one more. And then basically I'll let you just wrap it up. Will there be, sorry, not ever. Will there be a formally verified transpiraler eventually, or at least a formally proved one similar to the lean proof for Cairo Vm?
01:05:37.410 - 01:06:27.600, Speaker B: Yeah, so we formally specified Yule with the goal of eventually verifying warp, but we changed to solidity. And the problem with trying to do it with something like solidity is that these formal specifications and proofs are very sensitive to changes somewhere else. So if solidity changes the semantics of a certain language feature or changes the language feature, it could break the entire specification and verification. And just specifying something like solidity is like an eight month to a year probably effort in and of itself. So at the moment we're not thinking about formally verifying walk 2.8.
01:06:28.850 - 01:06:34.500, Speaker A: Okay, so last question. Why should new developers partner with you?
01:06:35.190 - 01:06:37.890, Speaker B: Partner with? I think that's just darkware.
01:06:40.070 - 01:06:47.460, Speaker A: Yeah, you're muted by the.
01:06:51.610 - 01:07:00.010, Speaker C: Yeah. If you want to scale your app, then you should work with us. If you don't, then don't.
01:07:02.910 - 01:07:15.470, Speaker A: I like that. If you want to reach scale. Yes, I agree. Okay, so I mean, Sean, since you're on the screen, maybe final words and then final words by Yorick and Greg.
01:07:16.850 - 01:07:46.620, Speaker C: Yeah, I think the world project is really leap forward and stepping the maturity of Starknet. A lot of contracts are written in solidity and a lot of programmers know solidity, a lot of projects that can be very big core base for other stuff. So I think it's very exciting that this is finally complete.
01:07:47.710 - 01:08:08.800, Speaker B: Thanks, appreciate it. And I'll just do a bit of a shameless plug for our pitch. So nevermind is hiring like crazy across all our teams. So warp formal verification, auditing, we've got a bunch of roles open, and so have a look at our job board and maybe you'll find something interesting there.
01:08:10.630 - 01:08:47.950, Speaker A: Okay, so basically, I want to thank Yorick and Greg from Nethermind. Sorry for squeezing you in. And Shaka from Starquare. It's been a terrific start at home episode. All these episodes are recorded. We hope to see a lot of you on future things. And more importantly, go press the button which will bring you to the GitHub, get yourself warped into Starknet, and start scaling.
01:08:47.950 - 01:08:50.000, Speaker A: Thank you very much.
01:08:50.530 - 01:08:52.494, Speaker B: Thank you. Thanks for having us.
01:08:52.692 - 01:08:54.410, Speaker D: Thank you. Bye.
