00:00:03.320 - 00:00:47.908, Speaker A: All right, cool. Thanks all for sticking around. I'm Ethan, co founder of Cosmos and CEO of the cortical systems and cycles, and I'm going to talk a little bit about one of the pieces we're building four cycles. That's called quartz, a privacy driven side pe, side card for cosmosm. Cosmosm is the main smart contract environment Cosmos. This talk was initially designed to just motivate these tes in the first place for Cosmos devs and to convince them to arm them with the conceptual arguments for why we need tes and why they're useful, even if all the other cryptography stuff turns out well. And then Kevin's willing, I will give a little demo.
00:00:47.908 - 00:01:03.162, Speaker A: So if I could just quickly shill informal, because we do a lot of stuff that might be interesting. I mean, we run security audit business. We do staking on ETH and across Cosmos networks. We also do a lot of open source work. So we're built. We're the lead there for the Cosmos hub. Best place to launch a change.
00:01:03.162 - 00:01:26.794, Speaker A: We were leading development of Comet DFT. You might be familiar with tendermint. The main line of tendermint is now called Comet DFT. We've had it for about a year and a half ago. There's a lot of very powerful stuff in comet that allows you to do decentralized oracles, mvv, prevention. It basically gives application developers a lot of control over block production and how the consensus is operating. So there's a lot of interesting things to look at there.
00:01:26.794 - 00:01:59.660, Speaker A: We also build a lot of the IBC infrastructure, Hermes, three layer, and IBCrs. And we are building. We've done a lot of work in formal methods and through auditing, we found that there's a serious lack of good tooling for writing specifications. And so we've addressed that problem by building a spec language called Quiz. It's designed to delight you. So if you try it and you're not delighted, you are required to let me know, because, you know, heads are in a roll. Our goal is for this to do for spec languages what ros did for type safe systems programming.
00:01:59.660 - 00:02:09.856, Speaker A: Oops. How'd that get there? This is Quint. This talk has nothing to do with Quint, but we just put this website together. I've been distributing stickers. It's awesome. Try it. It's designed to delay Quint.
00:02:09.856 - 00:02:33.508, Speaker A: Dash clang.org dot okay. The other big thing and form I was working on is a new project recommending is called cycles. Cycles money. Cycles is an open clearance protocol designed to clear the most debt for the most people with the least money from the most preferred sources, which is a mouthful. But the essential pitch here is that crypto seems to think that power banking comes from assets. And if only we build counterparty free assets, permissionless transfer, whatever, then we could take over the banks.
00:02:33.508 - 00:03:11.382, Speaker A: This is wrong. The banks love that you believe this, because it's simply incorrect. The power banking comes from the liability side of the balance sheet, which people, because they have been infected by a brainworm called austrian economics, refused to really think about. But banks have been gathering and clearing houses for hundreds of years, clear massive amounts of debts between themselves with almost no money at all, and the rest of us are just shut out from these clubs. The only experience you have with clearing is when you do split wise with your friends. Otherwise you're just like systematically excluded and the cyclists are going to solve that problem. Building an open clearing protocol allows anyone to participate in clearing debts using arbitrary currencies and units of account.
00:03:11.382 - 00:03:54.984, Speaker A: And so to do this, we basically need to run a graph flow algorithm over a large graph of private data. Right? And so that is why we've ended up building with tes. Okay, I should quickly acknowledge a few people. Andrew here, who's done a lot of the protocol design work with us. He joined us last, late last summer, who's not here, but he's our lead developer, so he did a lot of work building and stuff. And the rest of the informal system, cycles team and formal team, who is, who's been helping us, obviously build everything with cycles. So what are we talking about, private compute keys or these magical things? As we've sort of seen, private compute is like a fundamental human right.
00:03:54.984 - 00:04:22.926, Speaker A: Ultimately, it's important that blockchains are fundamental human rights for you to transact, but they're all fully transparent, and that's a problem. And so we need to address that. There's a lot of great developments happening. We've seen, like Penumbra actually just launched last week, if you're not familiar, there's shielded transactions, shielded decks built using the cosmos stack. Very cool. But we might want more general compute than just specific things you can build with CK, let's say, today. So I'm going to try to motivate that a little bit.
00:04:22.926 - 00:05:04.282, Speaker A: Right? So zero knowledge proofs, we all know them, we all love them, but the main problem is that the prover has to see all the inputs, right? So it's private for the verifier, not so private for the prover. So this works great when the data that you're proving over is an individual's own data, right? So it's something like Zcash or penumbra. It's the user that's producing the proof. And so that's awesome because they already have access to the data. So they have everything but for privacy on global computations, like so called ZK roll ups or like what we're trying to do with cycles. The prover is not like an individual user in some other kind of solver. And so suddenly they have access to all the data.
00:05:04.282 - 00:05:38.956, Speaker A: We don't really like that. So ZK has kind of unfortunately come to really need like succinctness or integrity or validity more than really privacy per se, which is in a sense, going back to like the original goals of these construction were succinctness. They actually kind of got privacy like by accident, almost like trivially in the construction, which is interesting, but we're not really good, so. So DK doesn't, doesn't solve our problems. We can't do, you know, it doesn't give us privacy on from, from the actual. Right. What about FPC? This does solve our problems.
00:05:38.956 - 00:05:56.916, Speaker A: Technically. This is, you know, true encrypted computation. No single agent can see the inputs or the values or the outputs. That's great. But you have to trust KMN agents, to be honest. And as you increase those numbers, things, you know, start to slow down quite substantially. So, you know, this is expensive, a lot of network communication overhead.
00:05:56.916 - 00:06:17.070, Speaker A: And you also have this problem of collusion. Right? So if the, if the size of the set is too small, you're trusting them not to collude. And if they do collude, you can't detect it. Right. Which is important to remember. So what about fhe? Well, this actually isn't helpful on its own because you still need MVC to actually do decryption. Right.
00:06:17.070 - 00:07:05.372, Speaker A: The way we've been thinking about what fhe achieves, it allows you to swap the I O overhead of MVC for the compute overhead of FHG. So if the compute overhead actually gets low enough, or we build the hardware for it, or whatever is everyone claims it's going to happen, then fag might make MVC faster. But you can't use fag without NPC. Otherwise it's kind of useless. It's fine if you're just a single user and you're just trying to outsource some compute, but if you want to use blockchains, global state and all that, it doesn't really help you with that MPC. So Miquera is in Toronto represent Toronto background bitch on Twitter has been chilling all these amazing memes about, you know, these problems with fhe. And so, you know, I just included a few of them here just to really hammer the point home.
00:07:05.372 - 00:07:32.210, Speaker A: But you all get it. I mean, you're all, you're all sold on tvs already. So where does that leave us? So ZK doesn't give us private compute. MPC is expensive, doesn't give us collusion resistance. FHG is expensive, but can in principle make MVC cheaper. And so this is what it looks like to be waiting for NPC and FHG to be fast enough while we want to do, you know, a lot of interesting things. So what's a practical solution that we can use today that gives us sufficient guarantees and that we can combine with other techniques as necessary? Pick, tee dummies.
00:07:32.210 - 00:08:00.220, Speaker A: I'm a big fan, but that's besides the point. Okay, so what are we talking about? Tee is product compute practical, fast. You know, no one can access the data. You can get proof of correct execution. Very valuable, relatively straightforward signature verification. But of course, our downside, vulnerable to potentially devastating side channel attacks. And you have to trust the central issuer, right? So when we're using these things, we want to, a, try to mitigate the side channel attacks and b, trust the issuer as little as possible.
00:08:00.220 - 00:08:54.932, Speaker A: And so that's, you know, the design goals in front of us. So, you know, most of the discussions are around Intel SGx, basically, you know, the Intel CPU plus some extra opcodes, plus encrypted memory, assumes the operating system is untrusted. And then you could remote a test, which you could see quite a bit about that today. So how do we mitigate these issues? Right side, general tax and reducing our reliance on intel. Well, blockchains are actually great for this because you can stick a like client inside the enclave so that the binary in the enclave will only run when the blockchain gives it permission. And suddenly that removes the ability for an attacker, for someone who's compromised the host, to try to run things many times on the enclave and trigger some kind of leak. Many of these live channel attacks depend on being able to run sort of what Andrew was talking about before.
00:08:54.932 - 00:09:30.100, Speaker A: You trigger these page faults, and then you can sort of see where it is, what it's accessing in the memory and so on. So you can't run the enclave binary many times because it will only run based on when the blockchain gives it permission. Because it's running. Running a light client that verifies the state of the blockchain, then you can actually mitigate quite substantially. So we can use blockchains to constrain who can run the enclave, how often and on what data. And that prevents these kinds of grinding and replay attacks, which are the source of many of these side channel exploits. And then of course we can use zero knowledge proofs to reduce the dependency on intel for the actual integrity and correctness.
00:09:30.100 - 00:09:55.022, Speaker A: Zero knowledge proofs actually are getting quite a bit faster. There are techniques to parallelize them. The generalized zkvms are accelerating at a surprising rate. And so we can combine these kinds of techniques and really do some amazing stuff. So this is really what it looks like. The tes are leaking, but we can slap lifelines on them and that's a solution. Now I wanted to make sure that I looked up this flex tape stuff.
00:09:55.022 - 00:10:43.720, Speaker A: So does the mean mean like the problem is solved or is this just like a temporary hack? Okay, and to prove that the problem is solved. I don't know if you guys have seen the video. This guy here, he like cuts a boat in half and then tapes it back together with his flex tape and then goes out on the water, right? So like that seems, seems to me like it solves the problem. Okay, so meme validated. So summary, ultimately complete design is going to combine everything, even fhe MVC ZkP benefits from using the te because you prevent collusion. Right. In the meantime, the TES give us very practical private compute and rapid prototyping reduced side channel attacks with blockchain protocol design, which I'll, you know, give sort of demo heaven.
00:10:43.720 - 00:11:23.436, Speaker A: We can reduce the dependence on the te for correctness with zero knowledge proof. And we can use many, you know, we can use multiple zero knowledge proof systems, multiple tes to get for defense. And, and so ultimately what we're doing is running a max flow graph solver in the enclave, but producing a 0 mile proof that the results correct. So with that kind of design, all you're depending on the enclave for is privacy, which means it's strictly better than what we have on most blockchains today, right? So often, you know, really I'm just trying to arm people with like arguments for why we should be using this stuff. And often, you know, some people are still stuck in like these old mental models. Oh, risky. What do I want to trust intel? No, this is like, if you do this, you're just strictly better than what they currently have.
00:11:23.436 - 00:12:00.060, Speaker A: Because the blockchains today, most of them don't have any privacy, and here you're only relying on intel for privacy. And so if it fails, you just, like, defaulting back to the base case. Right. And that this has been very convincing. So hopefully, you will be successful in also battling the loadouts. Okay, so, you know, something like this, these guys at one of the summits, and there are a few te people gathered to Tara. These are the people robbing everyone in Brussels.
00:12:00.060 - 00:12:24.330, Speaker A: Okay, so let's talk about cosmosm. So, you know, I'm in cosmos. Cosmosm is like a native virtual machine. Not every chain has it, but a lot of them do. Secret network has been pushing tes for a long time. They've been really chewing glass to get people to understand. But in the secret network, so they have Cosmos and SGX.
00:12:24.330 - 00:12:59.808, Speaker A: But all the nodes run the SGX. If you join the network, you're running it, the keys will not get shared. And there are some challenges with this that have been vulnerabilities in the past, but you have this problem that all the nodes are basically running. And so what we want to do is be able to add privacy to existing cosmological chains. A lot of the cosmos chains have cosmos activated, you know, DyDX, osmosis, the hub's going to have it soon, and so on. And neutron is another big one. And we want to allow them to reduce the surface area by basically limiting who runs the enclave plant and on what data.
00:12:59.808 - 00:13:31.948, Speaker A: Right. We can do that using, like, client groups and so on. So we're building this framework called ports SDXI fire for cosmological, add private contracts, contract any existing cosmos chain. So why sidecar is a little bit, just a rehash, but you can add to any existing chain, limit who the operators are mitigating SGX bombs. With life client control, we can run arbitrary code in the enclave. So a lot of existing te sidecar solutions are sort of designing the environment to be the same as the environment on chain. So it's like solidity on chain, solidity in the enclave, or cosmos on chain, cosmos on the enclave.
00:13:31.948 - 00:14:14.262, Speaker A: And we're like, well, why not just generalize it, right? Why not just run arbitrary code? Give the applications very complex approach, give the application developers, like, full control to run arbitrary code in the enclave. Why not? Great power, great responsibility, and so on, but might as well go big. And then it's nice you can do rapid prototyping. Start with the enclave, trust them however much you want, and then add zkps. And if you like, eventually move to NPC if you don't become a skeleton. So ultimately, these are just sort of a summary of the properties we're going for, right? Replay protection, which we can get with these lifeline proofs, plus Merkel proof, plus remote attestation. Forward secrecy can be a little bit tricky, but if you do key rotation, then you can achieve that too.
00:14:14.262 - 00:15:20.180, Speaker A: Censorship resistance encryption, plus light client groups can actually everything is encrypted so no one can see other than inside the tee. The light client groups can also guarantee that the TE is processing all of the available data, so it's not leaving anything out of and then strong and weak kind of integrity using Zernal's roots and or remote address. So this is just a very rough kind of overview. I mean, it's pretty simple, right? You have users, they submit intents encrypted to the enclave, to the chain or some DA layer. The enclave pulls everything down, retrieves the intent, encrypts, runs computation, encrypts the results either back to itself, back to the users, up to the application developers on chain, verify the attestation, verify zero proofs, make any state transitions that are necessary, and then the user can fetch the results. Okay, so let's talk about this, like mine thing. This is the thing that enables us to like, really lock down the on flip, right? So what we want is that all communication with the enclave happens through a lifeline based round trip, right? So what we do is when we set up the.
00:15:20.180 - 00:16:28.308, Speaker A: Set up the enclave, we do a handshake with the blockchain, right? So the enclave will create a nonce and a key, and then it will register those in the contract on chain, and then it will verify a proof that the nonce and the key are registered in the contract. Right? And that allows both the enclave and the contract to be aware of each other and to have this like, session that's been created. And if you turn off the enclave to the host, you remember the host is untrusted. Right? So you have to assume that someone who you don't like adversary controls the actual physical machine that the enclave is on. And so, you know, one attack they can obviously do is just turn the machine off and turn it back on, right? But if you require this kind of like client group each time, then they have to do a new handshake with a new nonce, right? And so that forces them to check back in with the chain. And then when processing is actually happening again, using a life client, check to actually fetch the data, and you can use a counter on chain. I mentioned it here so that every time the offlake runs, there's an incrementing nonce an incremented counter, just sort of like a sequence number, like ethereum transactions that also prevents replay.
00:16:28.308 - 00:17:45.172, Speaker A: And so this basically prevents the enclave from being able to execute on arbitrary data and allows the change completely control when and how it runs and on what data. It was very powerful and can pretty much limit the vast majority of possible unknown future side channel attacks that depend on being able to make arbitrary commands, arbitrary runs on the enclave. So just quickly, the challenges of what we had to go through to build this. So it's split into two, you have to prove the blockchain to the enclave and you have to prove the enclave to the blockchain. And so there were a number of things we had to build that might be more interesting to kind of cosmos dev and just give you a bit of a flavor. But one thing, you can make system calls from enclaves, right? It's normal cpu, but generally you don't want to because then you're giving the host control and just might be, it's just best practice to try to not write more pure functions in there. And so we needed to build a like mind verification system that doesn't make the network calls, right? So the host is going to make a bunch of network calls, fetch the data that we're going to need, and then feed it into the enclave so that you can actually do the light client verification, right? So that's a useful utility, getting Merkel proof.
00:17:45.172 - 00:18:30.342, Speaker A: So it turns out everyone has designed their blockchain to be able to produce Merkel proofs of state. And then like, no one actually goes and checks Merkel proofs of state. Right? Now in cosmos, we're a little bit unique because we have this IBC thing which depends on merkle proofs of state in the cosmos. SDK and so every IBC transaction is verifying, literally verifying electronic proof and a Merkel proof. So we're doing this in production every day, you know, thousands, billions of times a day. But apparently nobody was verifying Merkel proofs of the state of cosmonauts and contracts because we tried to generate a Merkel proof and it was difficult. And you want this Merkel proof because you want to be able to prove, you want the enclave to be able to verify, like all the data that it needs to run on, and you want to prevent it from leaving anything out or anything like that, right? Because the host is going to fetch data from the chain and feed it to the enclave.
00:18:30.342 - 00:19:16.238, Speaker A: So the host could easily just like not include something, you know, it's like, oh, I saw this was sent by this address. I'm going to censor that. So you want the enclave to be able to check that it got all the data that it's supposed to get, right? And so Merkel proofs sort of allow you to do that. And so this is how we basically had to get a markle proof from cosmology. You compose this thing, query, raw contract, state request, and then tenurement has like four different encoding, or it's common now, four different encoding standards. So what you then have to do is sacrifice a goat to the gods of encoding, and if they accept your sacrifice, then your encoding will be correct and then you'll be able to actually run the query, get the correct data you need, and process your. So we're still working on making all this work for more advanced mermal proofs, baskets, bash proofs and so on.
00:19:16.238 - 00:19:42.390, Speaker A: One of the challenges with the Ethereum state tree is that all the keys have to be hash because it's a. It's a prefix tree, right? So in order for the tree to be balanced, I think in the original report, I don't know if Andrew found this, but initially, or at least authority, you know, one of the. The original audit of Ethereum was like, oh, your tree is unbalanced. And so there's dots, tax. So you have to hash all the keys, which makes it basically impossible to iterate over the tree, right? Because you can't iterate in key space. You've got hash keys in the tree, right. It's very painful.
00:19:42.390 - 00:20:20.708, Speaker A: So in cosmos we're actually using a balanced binary tree, which is much nicer because the tree is always balanced. We have to do balancing operation, but we don't have to have our keys, which means we can iterate. The keys are sorted in key space in the merkle tree, which means we can do like back proofs about, you know, collections of items in the. In the merkle tree, which is very nice. Maybe people care less about this now because they're all doing, you know, going up verkle trees and everyone's just like, oh, we'll just produce a polynomial commitment of a thing, but you know, it's still useful. Okay, what about proving the enclave to the blockchain? So we have to do remote attestation. Currently we're using epid just because it was easy to get started.
00:20:20.708 - 00:20:46.486, Speaker A: There was code we are now working on. Almost done. Maybe a decap pure rust so that it'll just run in. There's a bunch of stuff using fmis. We're trying to avoid all that so pure rust, that'll run directly in cosmosm, which is what we're trying to get to. Our goal is to be able to deploy this on existing production systems without them having to make any changes they might end up having to. We'll see exactly how much everything costs, gas and so on.
00:20:46.486 - 00:21:19.252, Speaker A: But that's what we're, that's what we're working towards. And then finally, ZK verifiers, right? So like I was saying, the VMS rich, zero, sd one, are they kind of work out of box? You can run those verifiers we've been experimenting with Mar, but they actually don't have a rust verifier yet, which is very frustrating because they make a big deal about, like, writing this stack in rust. But then you look at their, like, ZK prover, and it's all in Cuba. So if you see Zach or anyone from the aztec team, make sure to troll them about this. They're very sensitive to it. Okay, future work. There's a lot to do.
00:21:19.252 - 00:21:50.862, Speaker A: I mean, really just have a prototype publisher code, forward secrecy, managing stake. As you can see right now, we're doing some really silly things, but it works. Adding support for multiple solvers of multiple enclaves, federating them, key management, solver decentralization. So you multiple enclaves and recover from faults and all that sort of stuff. So actually making a production is sort of still ahead of us, but we have sort of the basics working. So that's the buckmaster cycles money. Feel free to get connected.
00:21:50.862 - 00:23:11.778, Speaker A: And now, if my sacrifice is accepted, I will do a demo. But maybe we can pray for any questions first. What do you mean that the proof would convince others that the te included all the data? The te, the binary that's running in the enclave should be written in such a way that the data that's fed into the enclave is complete, right? So that. So the te is going to verify a merkle proof that it has all the data, right? So the way you would write the contract is to say, okay, people are submitting some encrypted intents into the contract. They're being stored in the tree, in the contract, there's a set of them, right? And now the host who's going to fetch that data and feed it into the enclave, might only pick a subset, right? And so the enclave's got to go look and verify a merkle proof that it actually has all the data and that none of it got left out. And the fact that it's remote attesting to running a binary that does that verification is what would convince others. So other people aren't necessarily going to verify that proof, but they'll see that the binary checks that proof and you're remote testing and running that binary.
00:23:11.778 - 00:24:29.540, Speaker A: That makes sense. Yeah. Okay, other questions? Yes, I do not mind. Does anyone else? Okay, so firstly, thanks so much. Very refreshing. My first question to you, and it's like executed in plain text, but because everything's very sharded, like it's not worth acumen, these kinds of enhancements or is this like further down the line? It's all further down the line. We have thought about these things like adding support from multiple kinds of tpes and being able to abstract that away.
00:24:29.540 - 00:25:11.946, Speaker A: You know, this stuff we sort of talk about at a high level, we haven't made meaningful progress towards like actually designing it or trying to. It would be great to do that, especially if there's demand for this, for that. In this kind of framework there's tons to build over the next few years. And then ultimately using either using FEC to share keys between enclaves or to some extent to get rid of enclaves altogether would be great. And that's also kind of further down the line we're looking. I mean right now we just want to make this like very practical for practical use cases. And depending on really the main priority is making work for cycles.
00:25:11.946 - 00:25:54.080, Speaker A: We're building cycles and so we needed this recycling. Oh, this is probably useful for a lot of people. So let's, you know, rip it out, make it a framework, put it in a repo and release it, which we haven't released it yet, but hopefully soon and iterate on it. And so, you know, people open issues like, you know, we'd love to have more community input on how to, what things we want out design. Yeah, I can also have several questions. Like, first of all, I was, I was kind of surprised I didn't hear about TPM. And like it kind of does order the same thing that he does.
00:25:54.080 - 00:26:36.410, Speaker A: And as I can see is like Avengers said in wine, it is so tied to frozen water. Like wine, wine make more general purpose. You said about executing arbitrary gold in the enclave. Maybe you can tell more about it. Yeah, so TBM, I don't know much about. We're just getting started with like tools that are easy to use and that, you know, black boss folks were using, Andrew was familiar with because we just want to get the prototype of the cycles thing built. We do want to generalize, be able to use other platforms down the road again if we think possible to people.
00:26:36.410 - 00:27:24.922, Speaker A: But I'm still early in my trusted compute journey, so I'm still learning about the platforms and how they all work and the trade offs and stuff, but I am a believer. And then, as for the cosmonausm thing, I mean, we have thought about that as well, but I mean, you have to write a framework basically for each. So the thing is, with the enclave, we can write like the base framework in rust, and then you can write arbitrary rust code. And so we only have to write it for each language. Right. For the on chain piece, we would have to write some framework for each on chain execution environment, which I guess the same is like kind of for languages, but it's like languages specific to the environment. So we've done it for Cosmos.
00:27:24.922 - 00:28:10.890, Speaker A: Been thinking about doing it and go for the Cosmos SDK. We can do it for solidity, but probably there's a lot of flash process work that we could adapt for that kind of purpose. And so we're really just focused on right now building what we need to build cycles that we're building within the cause ecosystem using Cosmos, it's easy for us to get started. Part of the goal, cycles is to build a platform, a risk reduced environment for people to build lending protocols and stable coins. Right. Because you have access to this whole graph, you can do a lot of very interesting things, lending protocol design and stable coin design, where you're not just like lending to an individual, you're lending into this graph of obligations, which can ultimately just reduce risk in all kinds of interesting ways and open up new forms of yield. And you're working in the real world, so you can create opportunities for real world businesses and stuff like that.
00:28:10.890 - 00:29:02.692, Speaker A: So that's really where our focus is and what's driving our priorities. We didn't start by being like, oh, let's build a general purpose framework for enclave and privacy, but we needed it to build the cycles. The cycles is driving our priorities. But as we open this up and if there's interest for people to work at other platforms, we'd love for there to be contributions and so on. I just wanted to add that we kind of did a very similar thing with key rotation, but with solidity and like we see is so, yeah, having the same kind of thoughts and the same problems. But yeah, I was kind of surprised because, like, to me, I think crossing was great, but why not make it for everyone? Well, you just need to build more stuff. Yeah, just take more time.
00:29:02.692 - 00:29:42.210, Speaker A: So we're getting into work Cosmos, and then we'll try to make it work for us. But you know why? Nothing. Anything else? Okay, you want to see the demo? Yeah. Good, because I've spent like more than half of the last 12 hours, like, debugging it. So the gods have not been in this in my favor. All right, so what do we have here? We have a few terminal windows, and I'm kind of doing everything with scrap. So this window here, I'm going to be sshing into Andrew's machine called.
00:29:42.210 - 00:30:07.574, Speaker A: This is our SGX environment. Can you increase the. Yes, yes, yes, yes, of course. Wait, lines. Okay, so there's three machines involved. I'm sort of trying to simulate somewhat realistic environment. So, t box, what's up? Nothing.
00:30:07.574 - 00:30:48.574, Speaker A: No, I did it in three different windows just so that I can be clear about where I am. And anyway, you know, unfortunately for me, I kind of used to be like pretty hardcore dev, and then I got like, thrust into management roles for like a number of years. Finally I'm back into dev, but I haven't caught up with like, I des and all this stuff. So please excuse my retro retro setup or whatever, but I'm still an elite hacks. Okay, so this is, so this is our digital ocean mode, and I am just running a stock wasMD blockchain on it. It has, you know, states been initialized and all that. So here is my cosmos blockchain running in the cloud.
00:30:48.574 - 00:31:22.004, Speaker A: Okay. And here I am on Andrew's machine. Oh, that's a. Okay. And so what I'm going to do on Andrew's machine is, well, I'm going to tell it about the node it needs to talk to and I'm going to start the enclave. I've already built my binary, so to do this, I had to build a cosmosm binary and an enclave binary. Right.
00:31:22.004 - 00:31:45.470, Speaker A: So I'm not going to bore you with, with building rust code. And I just have a series of scripts right now. We're still polishing a lot of this stuff. Very, you know, plumbing versus porcelain, very in the plumbing stage. But I'll sort of show you it a little bit, just so we can see what's happening. So I'm going to run this start script, which is basically going to do, you know, we're in a proof of stake world, so. And we're talking about like, clients, we have to do like subjective initialization.
00:31:45.470 - 00:32:01.806, Speaker A: This is the whole weak subjectivity thing. You know, that's. That's old stuff. We've all like, stopped thinking about it now, taking it for granted. But you need to initialize your, like, client with like a trusted hash. Okay? And so that, that's in here. And then, you know, there's the enclave's private key region granting.
00:32:01.806 - 00:32:36.296, Speaker A: So there's a manifest file. You sign it, you start it. So that's, that's pretty simple. So we're gonna, we're gonna say a short prayer and then we're gonna run the start script and quiet signing takes an hour for some reason, but if we're lucky, Gram equals tar. Looks good. All right, everyone, there's lots more with that camera. Okay, so now Grammy is running.
00:32:36.296 - 00:33:22.358, Speaker A: Now what we're going to do is deploy a smart contract and it's this script. Deploy sh. And so what this thing is going to do is it's going to go, we have this three layer script for talking to the enclave and we're going to call this instantiate function on our enclave, which is basically just going to give us a report of the measurements. This is the hash of the code that's running on the enclave and our client parameters. So we're going to get the hash of the binary from the enclave and then we're going to deploy a smart contract on the chain that has that hash baked into it. So the contract is tied to that binary. Ok? So anyone who's going to use this thing is then going to go.
00:33:22.358 - 00:33:47.904, Speaker A: Yes. Is the live client also inside the enclave? The lite client is inside the enclave, yes. The verifier, the host is going to go fetch the data and pass it in. It's going to produce the proof and pass it in to be verified. Right. Okay. So it's gonna, you know, there's a lot of JQ Bash magic, like I said, elite hacks, and then we're actually gonna deploy, deploy the contract.
00:33:47.904 - 00:34:09.618, Speaker A: The deploy isn't. So, you know, here's our relay script, gets attested messages. Just talking to the enclave with GRPC, not so exciting. It's gross. It's just, you messy bash and JQ, but it works. Okay. And the deploy script, also pretty simple.
00:34:09.618 - 00:34:46.804, Speaker A: It's just some like cosmos commands to push the code on chain, deploy it, wait for blocks and all that kind of stuff. So let's go here, let's go into our thing transfers. So the app, I should tell you what app we're deploying. It's a simple transfer app. So maybe I'll just run it and then what is this script called? Boy, it's. Okay, so it's deploying. It's telling me about what it's doing.
00:34:46.804 - 00:35:04.108, Speaker A: It's waiting for blocks, contracts deployed. So what is this app the way this app is going to work? Well, I'll show you when I get to it. Let's just get through the ports part. This is going to be standard for any app you're going to deploy. You have to go through these steps, yeah? Yes, please. Can you verify the contract? I'll check. Verify it.
00:35:04.108 - 00:35:28.200, Speaker A: What do you want? So you deployed something to this address, right? How do we know it's actually this code? You can go fetch the code for this address. So there's some WASMD command. Oh, you're asking me to improv, eh? Let's see what we can do here. So I'll show you. Our things are quite self verifying. So query probably query wasm. Query wasm.
00:35:28.200 - 00:35:50.516, Speaker A: And that's code id of a contract given its address. So wasm contract. And I probably need. Actually, I think I can just do this. Notes URL. Yes. So here is the code.
00:35:50.516 - 00:36:15.698, Speaker A: It's got codeid four in wasm. The code is stored separately under a code id and then the contract address points to that id. So you know where the code is. Right. So then I could also query wasm code. You want the bytecode or do you want the metadata? I mean, I like the search. Can I also, if I build it myself, do I get the same bytecode? Yeah, you should.
00:36:15.698 - 00:36:35.350, Speaker A: Yeah. Yeah, exactly. I mean, this is where reproducible builds come in and all that. So you know, there's the hash of it and I can give you the. I mean this is just going to dump. Oh, what does it want to our output? File name. What's your name? I'm going to spell that wrong.
00:36:35.350 - 00:37:31.736, Speaker A: Looks good, right? It looks great. Turn into hands and everyone. Are you satisfied? Where was I? All right, I have a. I have a contract address that is that out? It's this thing. I'm just gonna export that for safe use. So now what? So now the contract's deployed, it knows about the hash of the binary running in the enclave, but it doesn't know about a running instance of the enclave yet. It just knows about the static hash of the binary, but it hasn't actually connected with the running thing.
00:37:31.736 - 00:38:04.518, Speaker A: Now we're going to do the proper handshake between God and Mandev. And so this handshake, this handshake is kind of interesting. Again, it's going to use the light client proof, it's going to use remote attestation. And we do it in two steps. First we run this session, create command, where the enclave is going to generate a nonce. Right. And so the session create is going to create this nonce and it's going to remotely test to the nonce, and then we're going to send that to the chain and the chain is going to store the nonce.
00:38:04.518 - 00:38:51.456, Speaker A: And then we're going to fetch a proof that the nonce is stored in the chain and we're going to run a second command called Session Setpubkey, where we're going to prove, we're going to prove to the enclave that the nonce is stored on chain. And then the enclave is going to generate a key sec p, it's going to spit out the pub key and then we're going to publish that pub key in the contract. And once that's done, we will have a nonce and a pub key stored in the contract. And the enclave will have verified that the nonce was stored in the contract. And the contract will have verified remote attestations from the enclave that these were all produced from the hash of the bind, from the binary with that hash. Right? So already knows that. So that's our script here it all looks good.
00:38:51.456 - 00:39:14.936, Speaker A: Script, handshake, properly named functions, say a short prayer. Now we have to wait for blocks to reproduce that. We can get merkel proofs and all this stuff. A bunch of logs. Look, there's the. We built the proof, we passed it in and everything went swimmingly. Well, this is very exciting for me.
00:39:14.936 - 00:39:57.116, Speaker A: And so here's our nonce, and here is our enclaves pub key. Okay, so that's awesome. So now we're going to do, the last thing we have to do is run a, is run a listen straight. And so this is like our server that's now going to run on the enclaves host that's going to like wait for events from the contract. Whenever some event comes, it's going to go pull down the data, make the like client proof pass through the enclave, trigger all the processing, and actually have execution happen. Right? So it's just a silly websocket, you know, just subscribe again. It's all in, it's all in bash, and then it's going to go do bad stuff, get stuff out of the car, contract, and then ultimately pass it to the enclave and resubmit the results.
00:39:57.116 - 00:40:18.920, Speaker A: Okay, so let's run it, let's run it. It's running. Okay, so, so we have our blockchain running in digitalocean. We have our enclave stuff running on Zed. And now we have the most important machine of all, is my machine because it's mine. And so here I am. I'm going to run some front end code.
00:40:18.920 - 00:40:49.742, Speaker A: We have a file here where we specify. Now, this thing is going to be talking to the blockchain. And so we need that contract address, which is this guy. So we're going to tell it. This is the contract address to talk to. It knows where the node is located and we need to give it the pub key of the enclave because it's going to encrypt everything. Everything the user does is going to be encrypted to the pub key of the enclosure.
00:40:49.742 - 00:41:23.176, Speaker A: Okay? So this is just, you know, some JavaScript config file. I'm going to run NPM, run dev. And so now I have. Now I have a application that might or might not be super secure with my Kepler. How many of you have used Kepler? Come on. Just gonna briefly disconnect so I can handle this for a second. No one.
00:41:23.176 - 00:41:50.280, Speaker A: Listen carefully. Yeah, no one. Turn off your microphone. Password managers and all that junk, you know, blah, blah, blah, blah, blah, blah. Sorry, guys. I thought I had done this in advance, but. All right, Kepler is unlocked.
00:41:50.280 - 00:42:06.530, Speaker A: We're back in business. I will allow it. Okay, so here's Kepler. How many of you have used Kepler? Nice. That's great. Go, team. All right, so here I am in Kepler.
00:42:06.530 - 00:42:25.138, Speaker A: I have. I have a bunch of keys that I've set up. Maybe you're familiar with these characters, maybe you're not, but they're members of my community. And so here I am with. This is Brita's account. And there's a few other accounts, obviously, normally be like, you know, machines or whatever. And some of these accounts are pre funded so that they can pay gas.
00:42:25.138 - 00:42:42.728, Speaker A: And so here I am with Britta, and she has some of these cosm tokens. Everything is like ten to the. So this is actually like 9 million tokens. 9.9 million tokens. And here's our app. And so what does our app do? It's basically a private transaction app where, for privacy, it uses envelopes.
00:42:42.728 - 00:43:04.836, Speaker A: Right. You might call it a mixer, but I wouldn't. And so it's definitely not for use in production. And so what you do is you deposit funds into the contract, and that's obviously in the clear. And then the state of the contract is literally just an encrypted block. It's literally just an encrypted block. Okay.
00:43:04.836 - 00:43:34.100, Speaker A: And then you publish encrypted to the enclave, right. This is. The enclave is the only one who has access to the state, but it stores the state on chain, and then users submit these encrypted requests. Requests encrypted to the enclave to make transfers. And that's it. That's the extent of the state here. And so you'll deposit into the enclave, you'll deposit into the contract, real funds or real funds, and then the enclave will detect that it'll run, oh, there's deposit.
00:43:34.100 - 00:43:55.086, Speaker A: Let me update the state. And the state it's managing is just a map of addresses and balances encrypted to itself. So fully agency state. And then you can run a transfer, transfer command and the transfer is actually encrypted. So once you've deposited funds, you can transfer it to someone else and that transfer is encrypted. So no one will see who you're transferring to or how much. Okay.
00:43:55.086 - 00:44:13.650, Speaker A: For the sake of this application, they will see who the sender is because it's a clear tax cosmos transaction. We're not using serenade proofs or anything fancy like that. But the point is just to demo a very simple ports application. Okay, so let's. Oh, the other thing. Well, I'll tell you in a second. So let's do a deposit here.
00:44:13.650 - 00:44:48.248, Speaker A: I'm Brita, I am depositing, signing my Kepler transaction. And you'll see that. So on the proxy, it detected the event, it fetched requests. There was one deposit request and then it produced the state. And so this is our encrypted state that the enclave encrypted to itself and then submitted back to the blockchain. Okay? And so, you know, because this app was like, built to be super secure and all the state is encrypted to the enclave, it's so secure that you can't even query it. You can't even get data out of it.
00:44:48.248 - 00:45:18.330, Speaker A: So because we don't have o ram and like a secure way to query, we built a very simple thing, which is you just query by sending a transaction to the blockchain and then the enclave will, if you're the owner of the funds, it will you give it your own public key and it will encrypt the result of the query back to you. Okay. Very expensive approach, but it works. Okay, so let's. Well, we'll see if it works. Let's try to get a balance. So getting a balance requires that we submit a transaction.
00:45:18.330 - 00:45:39.932, Speaker A: We make a short prayer. Something's happening. Hey, look at that. God is smiling upon me today. And you can see, you know, same kind of thing happening. This is the address, this is the encrypted balance. Why is there so much stuff? I'm not sure padding.
00:45:39.932 - 00:45:58.604, Speaker A: One of our devs implemented this, and so that works great. So now let's make a transfer. Okay, so now let me just copy Abed's address here. Abed has some funds to pay gas. I will just copy his address and I'll go back to Britta. And Britta and Abed are tight. Britta wants to buy him a.
00:45:58.604 - 00:46:29.728, Speaker A: See, the thing is, Abed really wants to, like, go to film school, but his dad wants him to run the falafel stand. And Britta is, like, intervening in his life, and his dad's, like, not happy about this. And Britta's like, Ovid, I'm going to give you the money to buy a camera so that you can, like, be, you know, a director. But she doesn't want his dad to see that, right? So she's going to use courts and our transfer app. She's deposited her funds and now she's going to transfer them. So she's transferring to Abed's address. She's going to send him, I don't know, 5000.
00:46:29.728 - 00:46:46.062, Speaker A: That should be enough by a thing. And so here we go. We're going to approve it. And now it's running and looks great. Some more stuff is happening. It's all encrypted. That all looks fun.
00:46:46.062 - 00:47:02.300, Speaker A: And so now if we query. If we query for balance again. Oops. It should be error. Error. Okay, there we go. We query her balance again.
00:47:02.300 - 00:47:22.504, Speaker A: It should be 5000, naturally. 5000. Okay. And now if we go to Abed and we query his balance, we should also see 5000. Very nice. Okay. And now Abed is like, well, fuck Britta.
00:47:22.504 - 00:47:59.714, Speaker A: I'm gonna go send some funds to my homie, Troy, because we're going to do some stuff together and so he can make another transfer. And now Britta will have no idea who he sent the funds to. He'll be mad at him, but he'll be like, no, I bought the camera and it only costed me 2500. And so these are all private transfers and they're all just, like, working. I could sit here making private transfers all day. You can't stop me. And then I can go to Troy, and I can see what Troy's got.
00:47:59.714 - 00:48:19.196, Speaker A: Actually, Troy doesn't have money to pay gas, so I will not go to Troy. I will stay with Abed and I will check his balance one more time, and then we'll be done. And then we'll run the withdrawing. And the way we withdraw is it just withdraws all the funds you have and deposits them back into your account. So 2500 left. You know, we have 0.08 here.
00:48:19.196 - 00:48:39.600, Speaker A: We're going to have to pay some gas and withdraw. It will grab everything. Approve. And so, yeah, and so now it will be, you know, the balance will be zero, but they'll be. The funds will be in my account. Of course, I might spend it all on gas by now. But you get it, it works.
00:48:39.600 - 00:48:52.040, Speaker A: You can see it all happening here. We can't actually see what's happening because it's in the enclave and we're not. We're very secure developers, so we're not printing logs from the enclave. You just don't know what's happening and that's it. And it works.
