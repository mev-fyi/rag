00:00:00.170 - 00:00:02.320, Speaker A: Excited about today's program.
00:00:04.930 - 00:00:14.880, Speaker B: Yeah. Well, shall we start? Sonny all right.
00:00:17.250 - 00:00:37.000, Speaker C: Alex maybe let's wait, like, two, three minutes just for late. Comers you I don't know what I mean. Maybe I have the wrong time on my computer. It's 31. Oh, no, it's 33 on my phone. Maybe at 35. We start in, like, two minutes.
00:00:37.000 - 00:00:39.560, Speaker C: Yeah, sounds good.
00:00:40.410 - 00:00:40.834, Speaker A: Cool.
00:00:40.892 - 00:01:14.550, Speaker B: Awesome. Well, while we wait, we're going to go over some housekeeping. So for today's session, the roastmaster is sunny. The reason we call it a roast is to make it rowdy and controversial. Doesn't mean you have to be loud. Just means that please feel free to ask your questions or raise your challenges anytime. And you could do it in the site chat.
00:01:14.550 - 00:02:23.470, Speaker B: Also, everything presented in the roast today will be public. It is public, in fact. So if you need the link to the slide deck, Alex, if you don't mind, we can share it with the folks here. So, just a bit of a background. Mev Roast is a tradition from Flashbots, and we are a research and development organization formed to mitigate negative externalities and no longer just existential risks posed by mev to smart contract blockchains. And you can find out more by reading our Medium post, where we does introduction to mev and articulate value of our organization. And in first half of this and in the roast today, our roastmaster has proposed three key questions for us to cover.
00:02:23.470 - 00:03:16.958, Speaker B: One, how is privacy relevant in reducing mev? Two, what are the trade offs between privacy solutions at the mempool layer? And three, what is the optimal privacy solution to create a seal bit mev option for L1 and L two? Architecture. And so I guess we're at time. So we shall start. The portion today will be split into two parts. First, it will focus on privacy to minimize mev. And we'll start with a presentation from Sunny that surveys the existing privacy solutions and where privacy meets MEB. And then followed by three presentations by potentially two.
00:03:16.958 - 00:03:59.100, Speaker B: Depends on, I guess, whether Sonny wants to share the bit about threshold description upfront right after your first presentation. And the second part of the project of the Mev Roast will be very dynamic and interactive. Our navigator Field Ian, will share a brainstorming deck and kind of walk through our discussion in how to achieve full privacy in creating a Seal bid mev auction. So let's start. Sunny, do you want to present your screen?
00:03:59.710 - 00:04:33.610, Speaker C: Yep. Give me a second. All right. Can people see my screen? Yes. Sweet. All right. So I'm just going to go ahead and talk a bit about the focus of the conversation today is on how we can use privacy techniques to help reduce mev.
00:04:33.610 - 00:05:29.214, Speaker C: That's an old thing. One of the things this talk is going to be mostly focused on mev minimization. And then I think later in the discussions, we'll talk about how we can use some of these techniques for the mev auctions. But why is mev minimization a desirable goal? Well, mev has a number of side effects to it and I think mev auctions help mitigate some of the externalities. But if we really want to attack all the problems at once, we really have to figure out how to reduce the total. Addressable mev altogether. What is mev? I'm sure a lot of the people on this call are already pretty familiar with it.
00:05:29.214 - 00:06:17.754, Speaker C: But just as a quick recap, basically what we mean is any sort of edge that an individual miner or block proposer can get that does not need coordination with other proposers to think about this. You can think about it in terms of what are the sort of powers that a block proposer can single handedly do. These include things like reading transactions from the mempool. They can choose which transactions get included. They can choose how to reorder transactions. You can do like consensus vote censorship in the proof of work. This takes the form of things like selfish mining in proof of stake or BFT things.
00:06:17.754 - 00:07:16.798, Speaker C: It takes the form of vote censorship and you could do time tracking style attacks. And so because today we're focusing primarily on the privacy focus, we're going to talk specifically about what are the mev attacks that can be done with the ability to read transactions from the mempool and how we can. And then three solutions for how to mitigate them. So the two large main classes of attacks that can be done using the power of reading transactions from the mempool, I'd call them censorship attacks and ordering attacks. Censorship has asterisks not all censorship attacks would fall under this. Same with ordering attacks, not all ordering attacks as well. But by censorship attack we mean things like the ability to censor someone from making payments, but also the ability to censor someone from doing a challenge on a payment channel close for example.
00:07:16.798 - 00:08:23.518, Speaker C: And so this has monetary value because you could steal value from someone if you can prevent them from being able to challenge certain things, then ordering attacks. We have the front thing like front running. I'm going to skip this section because I think most people here are probably familiar with what front running is. Basically a proposer can go ahead and add their own transactions into a block before Alice's transaction in order to somehow profit off of it. Then on top of that, we have things like dark forest attacks, which is something Dan Robinson and Giorgios coined. But essentially the idea is you can think of it as basically an on chain puzzle, which it will give $5 to whoever's the first person to show the solution to this puzzle. And Alice can go ahead and she's clever and has figured out the solution to the problem and goes ahead and sends a transaction with her solution to the block proposer.
00:08:23.518 - 00:09:24.406, Speaker C: The thing is, the block proposer can always just look at that, copy it and then put her solution in their own transaction. And because they have the ability to choose ordering, they can also make sure that they're always going to be the first one in the block and they're going to win the money. And here it's kind of like a simplistic thing where I just said a puzzle, but you could think about this as, like any sort of arbitrage opportunity. And this is sort of where the whole mev state space searching comes in, which is, I think, the topic for the next roast. But simplifying it and just calling these all puzzles. Basically, if we can mitigate both of these attacks, basically rely on the ability to read the user's transaction data in the mem pool and if we can stop this, then we solve this problem. We were able to mitigate both these ordering attacks as well as the censorship attacks we mentioned before.
00:09:24.406 - 00:10:36.830, Speaker C: And the best solution that I know of is encrypted transactions, some way of encrypting transactions in the mempool. So essentially you want a way for Alice to go ahead and submit a encrypted transaction that's unreadable to the block proposer. The block proposer. Ideally all the transactions in the mempool are encrypted. The block proposer would have to put together a block with the encrypted transactions, have the system come to consensus on the encrypted transactions and then only once the order and inclusion of transactions are committed to, we do some sort of magic in order to decrypt the transactions so then they can be executed. Now the question is, what is this magic? What are the options for doing this magic? So there's basically three main methods that I'm familiar with which I would broadly categorize as trusted hardware, time lock encryption and threshold encryption. And we want to kind of lay out some of the trade offs between each of these solutions.
00:10:36.830 - 00:11:42.402, Speaker C: And these are sort of the categories that we're going to use to compare and contrast this different solutions. So what is the security of the model, what kind of delays it causes on execution, what kind of delays it causes on consensus? And then just this catch all other thing to catch other things. So trusted hardware. Well, trusted hardware, the simplest way to put it is what happens is you have all these encrypted transactions. We go ahead and come to consensus on them, and then the CEO of intel comes in and does some sort of, like, black magic that no one knows how it works, but you just trust them because it's intel. And then it gets decrypted and it all magically works. So the idea would be that every miner or validator would have an SGX and they have a protocol for sharing an encryption key that's only accessible in the SGX and then all users will encrypt their transactions to that shared key.
00:11:42.402 - 00:12:32.260, Speaker C: The SGX can then verify certain properties about the transaction. They can make sure that the fees are correct, they can make sure the signatures are correct, they can make sure that the nice thing about the SGX is you can do all sorts of more stateful checks that might not be possible with some of the other solutions. And then you can output the block hash for Validators to come to consensus on. So in this one, I kind of was focused more on BFP consensus. But in the proof of work situation, actually I have it right here. In the proof of work situation, what would happen is they would basically submit all the Encrypted transactions to a Miner's. Then and the SGX will just spit out a block hash for the miners to start doing their proof of work on.
00:12:32.260 - 00:13:46.730, Speaker C: And then once the Miner has found a valid proof of work, they can submit it to the SGX and the SGX will give the Miner the Unencrypted block data so that they can broadcast it. Now, yes, the Miner, if they wanted to, they could go ahead and once they get the unencrypted data from the SGX, they could choose to ignore to start rehashing it and insert their own transactions. But they'd basically be having to do twice the amount of work because they had already won the previous block. And they're basically foregoing that block reward in order to try to get the mev. And so if the mev starts to exceed the block reward, this could turn into a bit of a problem. So pros here, one of the nice things is it can be easily done as an opt in feature. It doesn't need any sort of protocol changes like individual miners or individual Validators can basically offer this as a feature to people who send transactions to their Vempool.
00:13:46.730 - 00:14:41.120, Speaker C: The cons though, is it's not a great security trade off breaking the SGX. We need to think of it in terms of economic costs and the rate at which SGX bugs are being found and SGX security models are being broken. You can probably throw a million to $10 million at it and probably be able to find some vulnerability and be able to break the privacy. And if the value of the profit to be made off of breaking the privacy model of the SGX is worth it, we can expect that people will start doing it. And so this is something we'll get into the discussion afterwards about how we can start to think about this security model. So the trade off summary here.
00:14:42.850 - 00:14:43.262, Speaker B: Cost.
00:14:43.316 - 00:15:44.018, Speaker C: To break the SGX not that great, but what's nice is it has no execution delay. You can go ahead and start executing in the same block because you can actually do execution within the SGX, which is nice. And then consensus time, it slightly delays the Miner, which could lead to a little bit more forking and stuff, but it's not that big of a deal. And finally, the nice thing is that there's no protocol changes required next up, we have timelock encryption. Time lock encryption basically is constructing a cryptographic primitive that basically says, okay, we have some encrypted piece of data. Anyone can spend enough time doing some operation on this data. And once you do enough of that operation, then it kind of breaks open the encryption, unlocks the encryption, and now you have the decrypted data.
00:15:44.018 - 00:16:44.100, Speaker C: And how you can use this is to minimize mev, is basically what would happen is people submit transactions encrypted to miners mempools. The miners would include the transactions in blocks, and then on the side, they take the transactions and start running the process to decrypt them. Now time will go past and a couple of blocks will go by. And then finally, after a certain period of time, the transaction will be decrypted. And then you can take that decrypted data and submit it in a transaction and then it gets executed. So the key is what's happening here is there's quite a high noticeable delay for transaction execution. So whatever the time lock period is, you can't actually execute the transaction until that is over.
00:16:44.100 - 00:17:52.650, Speaker C: And this delay actually has to be quite significant because the delay has to be quite significant because you want to avoid the situation where it's impossible basically to guarantee that this time lock thing takes a certain amount of time because you don't know what kind of hardware or asics that individual miners may have developed. And so you need to make it have a sufficiently long time so there's enough buffer to give you the security guarantees. On top of this, all transactions have to use the time lock encryption, so it's not an opt in feature. So like with the SCX, for example, some transactions can say, I want to go through privacy and payments. For example. Some transactions might not care about the front running resistance, but in the time lock encryption, you kind of don't have that choice. Everyone has to use it and has to bear that execution delay, which can make for some pretty poor UX.
00:17:52.650 - 00:18:52.958, Speaker C: And then finally, if you can prevent the transaction from being included in the encrypted transaction from being included in a block for long enough, you can start decrypting the transaction while it's in the mempool. And so there's nothing to say that, hey, the time lock can only start once it makes it into the block. And so if group of miners are able to keep the transaction out of a block for a while, they can actually start the time lock process and perhaps even decrypt it before it gets included into a block. Mev security, it's kind of like a yellow because it basically is a trade off against the time delay. So if you want to say that there's only a minute of time lock delay, you're going to lose a lot of security. But if you're saying, hey, the time lock delay, we're putting it at scale a couple of hours then maybe it's a higher security. And so it's really this sliding trade off.
00:18:52.958 - 00:19:50.510, Speaker C: The execution delay is quite high. As we talked about, it has very little impact on consensus time itself. But then once again, the con is that it's not opt in. Finally, the third solution that we want to talk about is threshold encryption. How it works is let's take a normal BFT consensus system. So what's happening here is the block proposer has created a block proposal, sent it to all the validators, and then all the validators would normally do some sort of vote, send it back, and then you use all these votes in order to lock the block and commit the block. Well, how Threshold decryption would work is you'd basically say here's all these encrypted transactions, each validator would have a decryption share.
00:19:50.510 - 00:20:59.190, Speaker C: And what would happen is use threshold cryptography to basically say any two thirds or whatever fraction you want of the validators can come together to decrypt all the transactions. And so what would happen is along with their vote, you would also include a decryption share and their vote would be invalid if they don't also include a valid decryption share. So what's nice is then you could do this and you can use the votes to come to commit the block. But because the votes are only valid with a decryption share, you must by definition have the decryption shares that you can then use to decrypt the transactions. And so what's nice here is with special decryption, it guarantees that the decryption of transactions happens atomically with the committing of a block and with the executability of the transactions. And so the mev security is actually, the security is quite high. It basically gives you close to equivalent security as consensus.
00:20:59.190 - 00:22:06.490, Speaker C: There's a little bit of a shade of yellow there just because there are some asterisks there. You need to add in additional things to make sure that validators don't share the decryption shares out of band without sharing the vote. But there's ways of mitigating that. Finally, the execution delay, you basically get a one block delay because you can't execute the transactions until the very next block they have to be. But it's not that big of an execution delay compared to something like time lock encryption, you get quite a bit of increased bandwidth because these decryption shares could potentially grow to be pretty large and so it'll have some impact on the consensus speed. And the biggest con here, though, is it really only makes a lot of sense in my opinion, with classical BFT consensus. For threshold decryption, you need some committee that basically is the one who decides whether a transaction gets decrypted or not.
00:22:06.490 - 00:22:58.060, Speaker C: And the most logical place committee to use is the validator set because you can use that if you design your Threshold decryption system well, you can make it so it's atomic such that decryption happens atomically with transaction execution, which is something you can't do with time lock encryption, but you can do with SCX, which is nice. So yeah, that's basically a nice sort of overview summary of the trade offs of the three main schemes for how to get privacy at the mempool layer. So I'd like to open it up for questions and whatnot and just general discussion. Are there any additional trade offs that maybe I didn't talk about or anything like that?
00:23:09.830 - 00:23:14.840, Speaker B: Do you want to ask a question or make a comment as you commented on the side?
00:23:18.350 - 00:24:23.162, Speaker C: So just I think Sonny actually mentioned this. So I just feel like the comparison between time lock and threshold encryption feels like in the BFP when you have synchronous protocol versus partial or asynchronous protocol, whether you wait for some time versus whether you wait for a quorum. But I just think that the latter, the strategic aspect of the latter seems to still be an open question. That's just my comment. Can you explain a little bit about what you mean, what the analogy is here with synchronous versus asynchronous BFP? Because in asynchronous BFP, right, so you wait for some time, for example, because I wait for ten minutes. After ten minutes, if I don't receive a message that means that you didn't send it, then I can do my consensus based on that. But then those partial synchronous protocols, right, so you wait for two thirds of the vote.
00:24:23.162 - 00:24:37.220, Speaker C: It's like, I feel like it is like the Threshold encryption. So that's the analogy I'm thinking about. So it might be maybe more like synchronous versus partial synchronous. Yeah, exactly.
00:24:38.790 - 00:24:49.240, Speaker D: Still can't be sure how many agreed on the Threshold signature. So there is some asynchrony in that as well.
00:24:55.380 - 00:25:42.896, Speaker C: So I guess maybe I can start looking at some of the questions in the chat box. Meanwhile, I have one question. On the time delay that you would have with time lock encryption, what would be implications of that in terms of looking at some of the applications we have today on Ethereum, for example, and how would that interact with for example, I'm thinking of price delay and how that would interact with centralized exchanges, price as well. Right. Because their notion of time would be different than this new notion of time. So what would be some of the implications there? Yeah, that's something I didn't think about. I was thinking about it mostly in terms of UX, where it's like all transactions are delayed by, let's say, ten minutes.
00:25:42.896 - 00:27:20.476, Speaker C: And this would be a poor UX, because one of the nice things about using Ethereum is you have the potential to have much faster execution as opposed to something like bitcoin. But yeah, this could actually be a big problem where if the time delay is on the scale of hours, then a lot of DeFi things that depend on price oracles and the like would basically always be lagging somewhat from the real prices. One thing with the time know, maybe some caveat I didn't mention was or maybe I should clarify, is if your system, if your protocol has a little bit smarter knowledge of different types of transactions, you can make it so some types of transactions are opt in or don't have to use time lock encryption. Basically, you could say that maybe price Oracle updates don't have to be time lock encrypted, but meanwhile, all trades or something have to be time lock encrypted. And so if you do have some smarter way of segmenting transaction types, then you could do that. And so it really depends on the transaction types that don't have to follow time lock encryption. It depends on if they suffer from any sort of if they're vulnerable to any of the attacks.
00:27:20.476 - 00:27:54.536, Speaker C: That I meant at the beginning. If price Oracle updates aren't really subject to being front run well, it's not that. It's basically anything that can be used to front run has to be subject to the time lock delays. So if the Price Oracle update itself can't be used to subject something to front running, then you can make that instant. But I don't know if that's true. There's probably a lot of cases where you can use price Oracle updates to front run things.
00:27:54.718 - 00:28:19.996, Speaker E: It's also not clear, like, what's the impact on DeFi if you have the Price Oracle updates come in later so you get the live price Oracle at the given block, but all the transactions were executing there came from an hour ago. How does this impact the finance system if all transactions are executing an hour in the future, but with the price an hour in the future, it feels.
00:28:20.028 - 00:28:51.550, Speaker C: Like if there was one unique notion of time, then it would be okay, right? It would just be like everything is delayed and the price just works that way. It's just that because you have centralized exchanges as well and price is there, that's where it gets more messy because it's like being on different time zones. Kind of, yeah. That's cool. Thank you. I see Stefan asked about what does Threshold without BFT look like? Can it happen on L two plus Ethereum? So, Dave, do you want to maybe answer that one?
00:28:52.400 - 00:29:27.320, Speaker E: Yeah, sure. So, yeah, you can totally do Threshold encryption on L two plus Ethereum. It's just highly unclear what's your so the security function threshold encryption is that a given threshold of them does not collude. So it's like, why do you believe this given threshold for this L two committee in proof of stake? You kind of have this easy answer. I already assumed this for security. So you're always making additional assumptions if you are using a different committee. And you just have to have a compelling reason for why a Threshold security assumption makes sense in that setting.
00:29:33.590 - 00:29:53.880, Speaker C: Yeah. And a lot of the slashing conditions that we built to prevent sharing of Threshold shares out of protocol in order to slash people. They could also be done in the L2 system as well.
00:29:54.490 - 00:29:55.240, Speaker A: Really?
00:29:55.690 - 00:30:08.140, Speaker C: As long as you can use some sort of BFT system with your L2, then it should be fine. And most L two systems should be able to work on some sort of BFT way.
00:30:09.230 - 00:31:16.610, Speaker E: Sorry. One thing that's kind of annoying about threshold encryption is that you actually can't have such conditions against a sufficiently advanced adversary or adversarial set because they could always like conditions. Basically, you want this way of preventing a football by saying that if you suppose you give me a threshold decryption share when you shouldn't have, I can report this and then get you slashed. But we can do all of our threshold decryption sharing in an SGX, so this prevents me from ever sharing it publicly. And so you could have this validator set basically adversarily decrypt early in an SGX and front run together. So if you assume this highly advanced start model of, I don't know, ask us how advanced it is, if you see the start model of the threshold that's colluding with using SGXs, then we actually can't slash threshold decryption, which could be a problem. It depends on how sensible is the threshold assumption in the setting.
00:31:24.290 - 00:31:42.470, Speaker A: I guess one question I have is how do you view these techniques interacting with mev as a metric? Like, is the goal to reduce mev to zero or is there still going to be some with each of these techniques and how does it compare in its effect on the empirical mev quantity?
00:31:43.850 - 00:33:03.200, Speaker C: Yeah, so like I mentioned, I think mev comes from all sorts of powers that the miners or block proposers have. And these privacy techniques are really meant to just solve that first power, which is the ability to read transactions from mempools. And so I don't know any numbers off top of my head, but I think that will actually probably solve a large percentage of the mev, but definitely not going to push it to zero. And you do need to solve all these other powers as well as any other powers I may not have listed here, and I think the ones that are probably most related are probably the ability to stop the ability to control inclusion of transaction in the block proposal and the ordering of transaction in the block proposal. So you can use randomness techniques to prevent the reordering of transactions and you could choose there's other techniques we have for how to make it so one block proposal can't have full control over which transactions make it into a block or not. These solutions alone don't put MEB to zero, but they're part of a larger toolkit of solutions that can bring it probably not to zero ever, but as low as possible.
00:33:04.610 - 00:33:39.926, Speaker A: Yeah, I guess. Two other very quick meta comments on the properties you chose since you asked for feedback on those. I think two I would also think about is like the cost to generate the proof. So if that's super expensive for the user or not might make a difference in some apps. And also the backwards compatibility with Or Universality, I guess. Can you use it on existing L1s? Existing l two S. Does it work on both? Will it need to be tweaked as it's applied? Or is like I don't know what the cleanest way to express this, but basically how flexible is the actual deployment?
00:33:40.118 - 00:34:30.860, Speaker C: Yeah, I was trying to kind of get at that with the other category, at least with the SGX and the Threshold. I think one of the nicest things is the SGX is probably the most universal, it's like the most backwards compatible, while the Threshold is sort of maybe one of the less backwards compatible, where it does make pretty strong assumptions about your consensus protocol, for example. That's one. And then, yeah, definitely the impact of users. Oftentimes there's things that we don't consider, like Zhash, it has great privacy, but then sometimes we forget to think about, oh, what impact does it have to like, clients, for example. So, yeah, I think that's definitely a good additional category to think about as well.
00:34:31.710 - 00:34:57.220, Speaker A: I think one question I really have for Flashbots and for L, one mev is like, is SGX the only universal solution? And that's kind of what I'm going to, I guess, cover in my part of things. But I think it's a cool thing brainstorm. Like, can we have other solutions that have some of the nicer properties of like, time lock or Threshold and don't need SGX, but also have the same backwards compatibility? I think it's an open research question, I guess.
00:34:57.670 - 00:34:58.322, Speaker C: Yeah.
00:34:58.456 - 00:35:08.520, Speaker E: On the question of how long does it take to actually Threshold encrypt as a user? That's pretty comparable to signing time. I don't know about time lock encryption, though.
00:35:11.930 - 00:36:20.990, Speaker C: Another thing that an interesting thing to think about on impacts to users is the slide has it incorrectly, but earlier I said there's a zero block delay for SGX execution, but there's a one block delay for Threshold encryption and like a longer delay for time block encryption. The fact that there's a zero block delay until execution. Currently in Ethereum, you get charged for gas used, not gas requested. But if you have a one block delay on execution now, it does complicate your gas model because you need to sort of start charging for gas asked for. So, like, whatever the gas limit you put into, not just on gas executed, you can potentially combine this with things like EIP 1559 and then give partial gas refund. So you can basically say, like, okay, we're willing to refund up to 25% of your gas asked for. But that is definitely something that will have, like, a user facing impact.
00:36:28.370 - 00:37:02.620, Speaker B: Well, I think shall we move on to the next part? We have two more presentations and then we have an interactive workshop led by. Phil that dives deeper. But feel free if you have more questions. Leave them on the side chat and we will have discussions in between the presentations. So Dale, would you like to hi Eli.
00:37:05.450 - 00:37:06.006, Speaker A: Hello.
00:37:06.108 - 00:37:06.760, Speaker D: Hi.
00:37:22.570 - 00:37:35.820, Speaker F: Hello everyone. Can you see my presentation? Yes. Now? Yes.
00:37:37.310 - 00:37:38.060, Speaker B: Great.
00:37:38.590 - 00:38:10.520, Speaker F: Okay, great. So hi everyone. I'm Yael. I'm a product manager and researcher at Starquare. And today I'm going to present timelock which will hopefully rescue us from all this mev unfairness. Okay, so first of all, why timelock can be a measure to eliminate mev. So actually, Sunny summarized it very good.
00:38:10.520 - 00:39:20.790, Speaker F: In the Mempool, transactions are public and there are some entities, like miners, that are in powerful position and they can decide if to include transactions in the block and how to order them. So the fact that the transactions are public lets them do that and exploit some revenue opportunities. But once the transactions will be locked, time locked and at the moment of the ordering of the block, these entities won't know what to do. In order to profit from mev, the Mev will be unextractable. So what is vido? Vido timelock is based on a delay function F which is very long to compute. It is sequential computation and its inverse is fast to compute. Besides that, Vidu is also a VDF for randomness.
00:39:20.790 - 00:40:23.314, Speaker F: But in this talk, I will only talk about timelock. How can we generate a time lock commitment using Vido? So, if I want to commit to a value v, I need to apply the inverse of the delay function F on the value v and generate my commitment. To reveal the value, one has to compute the delay function F and he will get the value v that I committed to. Anyone can verify the computation of this delay function of the reveal. One option is to compute the inverse function just to see that you get back from C to v, from V to C. And the other option is to generate a stark proof that attests to the validity of this computation. The Star proof, anyone can verify it very fast in logarithmic time.
00:40:23.314 - 00:41:42.380, Speaker F: And a smart contract on Ethereum can also verify it and register it for future queries. So how can video rescue us and improve the Mev problems? I will now present two approaches for possible design using Vido. The first approach is timelocks as part of the protocol layer, which means that it requires some changes to the protocol. And the second approach is based on smart contracts on Ethereum and is fully supported today. So I will describe the first approach and then probably I will cover some of the second approach. Okay, so the first step is a user that wants to commit to a value sends her time locked commitment to the Mempool. Okay, so here you can see a few users, alice, Bocaron and Bob that committed to a time locked value.
00:41:42.380 - 00:42:57.250, Speaker F: Obviously the commitment has an expiration time because we wanted to appear on blockchain before the Time Locked expired. And then a Miner comes and includes these Time Locked values on the blockchain. Notice that these transactions are now time locked. So the miner cannot use any mevo opportunity because he doesn't have any way to compute the value that he can extract. Okay, now comes an operator that for each of the Time Locked values he performs the computation, the delay function and reveals the value. And next the operator submits a computation proof that he did the computation correctly. And these values X-Y-Z were computed as they should have been computed.
00:42:57.250 - 00:44:10.650, Speaker F: The operator also submits again these transactions, but now they are revealed. And they are also conditioned on the fact that the Verifier on chain approved them, that they were computed correctly. Now a Miner can query the Verifier and see that the condition is valid for each one of them. And then he can include them on the blockchain. Note that the reveal transactions must be in the same order as they were in the previous block or a few blocks ago when they were time locked. Otherwise the miner could have performed some front running or to extract mev by adding his own transactions or change the order. So in this case, the miner has to store the order of these Time Locked transactions.
00:44:10.650 - 00:45:45.080, Speaker F: Okay, if we think about the second approach, this responsibility that the Miner had to store the order of the Time Locked transactions can move to an onchain smart contract. Okay, so here we have a sequencer that submits the Time Locked transactions to a sequencer smart contract. To be economic, he submits only the hash of this list and not the entire list. An operator, again, like in the previous approach, computes the time locks and then submits the proof on chain to the Verifier. The Verifier can now check another condition that the list of commitments were revealed at the same order that they were committed to. So the sequencer smart contract has this list commitment, the hash, and it can be compared to the list of revealed values. Okay, I want to add that the Time Locked values can be for one specific application.
00:45:45.080 - 00:46:46.570, Speaker F: It doesn't have to be a transaction, it can be input for a specific application like uniswap or some game. And the operator can submit these revealed values to some logic smart contract that operates with some logic. And this logic smart contract can query the Verifier to see that these are valid. Okay, so to summarize, privacy can reduce mev vido. timelock offers a solution for privacy in this very critical phase of sequencing of the transactions. And there are multiple schemes to use vido to minimize mev, which some of them I presented here. Okay, that's it.
00:46:46.570 - 00:46:48.860, Speaker F: Now you can ask any question.
00:46:51.410 - 00:47:02.110, Speaker B: Yeah, thanks for presenting. I think out of consideration of time, let's take two or three questions and then we'll move on to the next presentation.
00:47:05.910 - 00:47:22.520, Speaker C: So how do you guys think about what sort of time delay to do, given that we mentioned in the last talk, like there's this trade off sort of between UX with security when you're choosing the time delay parameter. So how do you guys think about choosing that?
00:47:23.530 - 00:48:05.300, Speaker F: Okay, so, yeah, it should be a time lock, which is long enough for the transaction to get in the blockchain, but not to hurt the UX, of course. But in the second solution, where the full list of commitments is submitted at once to the sequencer smart contract, in that case, the delay can be shorter because it's only one submission to the blockchain per list of transactions. So this can improve the delay. Actually.
00:48:10.640 - 00:48:15.100, Speaker C: That list can be submitted before the time lock actually finishes. Executed?
00:48:16.560 - 00:48:39.460, Speaker F: Yes. First, the commitment for the list only the hash of the list is submitted on chain. And then this is a commitment for the order of the transactions. That would be and then later, after the time locks are revealed, the entire content is on chain.
00:48:42.360 - 00:48:45.560, Speaker C: My question is, how do you choose that time lock length?
00:48:49.900 - 00:49:43.800, Speaker D: I can try to answer, if that's okay. There are two ways to think about it. One is to sort of take the economic cost of a reorg and use that as a metric versus how much extractable value you want measure by that. So just to throw some numbers, which may be completely off, suppose reorg is $10,000 for whatever for five blocks, and the value is more than $10,000. Then it's not good. Okay, so you want more or less, depending on that. A different way to think about it is that if you have this is to rely on, let's call it macroeconomic considerations, which means that attackers I mean, there's sort of the normal reorg rate that you see, which I don't know what it is.
00:49:43.800 - 00:50:11.810, Speaker D: Let's suppose it's two or three blocks, whatever. That's the natural thing. So as long as you go over that, it means that if someone's going to do a reorg based on extracting value, everyone's going to notice it, and maybe the value of the underlying blockchain goes down. So maybe you're safe just above that, even if your total economic value is more than that. I mean, those are two ways of thinking about it, and it's a parameter that you need to set.
00:50:15.720 - 00:50:39.528, Speaker E: Second question I have is how concerned are you about alternate BDF hardware that computes it faster than the honest operators are? How do you price or account for that risk? Is this something that's generally worrisome or I just don't know much about it.
00:50:39.694 - 00:50:41.610, Speaker F: Ellie, maybe you can answer that.
00:50:42.000 - 00:50:46.172, Speaker D: Okay, I see that also a viewer is your view do you want to answer it or should I?
00:50:46.306 - 00:50:50.716, Speaker G: Yeah, I think the question was about accelerating the speed of computing the VDF.
00:50:50.828 - 00:50:51.536, Speaker D: Yes.
00:50:51.718 - 00:51:42.576, Speaker G: We spend a lot of time in conversation about that and measures, and I think the main advantage that we have right now is that our VDF function is pretty simple and it's already something that is pretty close to optimized even if you run it on a CPU. So it's not to say, well, I can't improve it if I build a specific ASIC for that, but it's also not crazy off from that. So if you do it for I would say it's also some kind of economical reasoning you have to think about. But for any practical or not very high mev, I think running it on a CPU and assuming a small multiplicative factor would be probably fine and we can provide more accurate numbers there just.
00:51:42.598 - 00:51:50.240, Speaker E: As the small mean like, I don't know, two or three or does it mean like, I don't know, tens?
00:51:51.300 - 00:51:55.488, Speaker G: I think that two or three will be probably very safe or pretty safe.
00:51:55.584 - 00:51:56.180, Speaker A: Okay.
00:51:56.330 - 00:51:59.460, Speaker G: But even if you do like eight, that's fine.
00:51:59.610 - 00:52:00.550, Speaker E: Oh, cool.
00:52:02.040 - 00:52:21.480, Speaker D: Is there an issue with data availability? If you only submit the hashes and order the hashes, then is there some reasoning that needs to be done about actually providing the data? Once there is, the commitment has been achieved?
00:52:25.820 - 00:52:27.160, Speaker C: Yeah, you should answer.
00:52:27.310 - 00:53:09.320, Speaker F: Yeah, okay. And the smart contract should enforce that the transactions are revealed in the right order according to this hash. So if the operator tries to submit something that was not included there, it will be very easy to see that it doesn't correspond to this hash.
00:53:10.300 - 00:53:29.810, Speaker D: Yes. Besides this mechanism, there should be an entire application layer of incentives. How do you enforce the proper execution besides the existence of the smart contract and the video?
00:53:30.340 - 00:53:44.020, Speaker C: Basically, I think that instead of including just the hash originally, you should be including all the encrypted data in the proposal. So that way anyone can start the decryption process, not just the original operator.
00:53:44.600 - 00:53:49.850, Speaker F: Yes. You can include it as a call data which would be cost less.
00:53:51.580 - 00:53:58.940, Speaker C: Yeah, I mean, it has to be done. Otherwise then that proposer could just never show anyone else that data.
00:53:59.010 - 00:53:59.292, Speaker E: Exactly.
00:53:59.346 - 00:54:12.700, Speaker D: They can just censor it unless kind of similar to zero knowledge and optimistic roll ups either punish them or have the data on chain.
00:54:13.220 - 00:54:22.796, Speaker G: Except that there is not really a state here. So censoring here will lead to not executing all transactions, but maybe not executing.
00:54:22.828 - 00:54:24.470, Speaker D: It is exactly what you want.
00:54:25.000 - 00:54:26.436, Speaker C: That could be the attack.
00:54:26.618 - 00:54:37.210, Speaker G: I'm not saying that it's a solution, I think that's what it implies and it's a little bit different than roll ups on this specific point.
00:54:42.560 - 00:54:52.450, Speaker C: Maybe it's worth just as a last question to pick up pintail's question in the chat can the operator be anyone and how easy are the Stark proofs to.
00:54:57.630 - 00:55:57.982, Speaker D: Yeah, the operator can be anyone and how easy the Stark proofs are to produce it's code and in the mean it's very close to the ETH Stark code base that we open sourced. So it's actually much simpler than it because the Ethstark code base does something a little bit more complicated than VDU. So it's quite simple. Right now we have a service that we're operating, but definitely over time, part of StarkNet will be opening provers for a whole bunch of things, including for VDS, if there is a need for them, if programs are going to be written around them. By the way, it's a terrific project. If someone wants to modify the Eftstark open source Prover to do VDO proving, that's a terrific project.
00:55:58.116 - 00:56:16.340, Speaker G: It's not very yeah, I wanted to say it's already very efficient and the air that is implemented there is very close, like said. So it's actually someone wants to play with Stark's constraints, then I think it's a very nice project to do.
00:56:18.230 - 00:56:18.738, Speaker C: Cool.
00:56:18.824 - 00:56:25.590, Speaker B: Well, thanks for the presentation and the discussion. Let's move on to secret network.
00:56:28.880 - 00:57:41.140, Speaker H: Hey, everyone, let me share my screen real quick. Can you see my yep, yep, perfect. Hi there. This is John Kisagun, I'm one of the co founders at Enigma, and we're building Secret Network, which is a privacy preserving smart contracting platform based on the use of SGX. And today I'm going to talk about secret contracts and how that can be used to mitigate mev some high level information about the network. It is a Cosmos SDK based chain. So even though I think Sani, you gave a good overview, but even though computations are run privately inside the SGX of each validator, the hashes are compared on chain and correctness is guaranteed by consensus.
00:57:41.140 - 00:59:07.948, Speaker H: There is a native token like Adam used for staking delegation, governance and fees. This is not private, but everything about the contracts are private. I think it's important because people get to see what gas is being paid for different transactions even though the inputs are not available. Yeah, as I mentioned, it's a Rust based contracting language compiling the WebAssembly, and the contracts have encrypted inputs, encrypted state and encrypted outputs. And the way we do that is through a use of enclaves, some key management and encryption protocols, very high level. The way it works is there is a single network private key that's generated inside the trusted execution environment and it's shared between the validators and if interesting, we can get into more details there. When a user is submitting inputs to the network, they do a Semitic encryption where they encrypt the inputs using so Alice use her private key and the network public key to encrypt the inputs, send them to the state, then each node can take that inputs and decrypt it inside the enclave where the network private key remains.
00:59:07.948 - 00:59:56.284, Speaker H: Do the computation, compare hashes and update state in an encrypted way on chain, and each user can access the encrypted outputs of the contract that they're interacting with if they choose to. Or these outputs can be made public depending on the application. I'm going to pass these ones for now, but would be happy to go over them if you guys have questions. We have two contracts that have been on the network live for four or five months now. One is this concept of Snip 20. It's similar to ERC 20. It's a smart contract based token issuance.
00:59:56.284 - 01:00:36.684, Speaker H: But since the contracts are encrypted, every token you mint is a privacy token. Basically, we have around $40 million worth of ETH assets on our platform right now used as privacy tokens. But what I want to show you here primarily is this is what you see when someone interacts with this contract. Also, this is like what a miner would more or less see. You see Alice's address, you see the contract that Alice is interacting with. In this transaction. Alice is sending these secret tokens a certain amount to someone.
01:00:36.684 - 01:01:52.710, Speaker H: We don't know what the amount is, we don't know who the recipient is. We just know that Alice is interacting with this. While you probably don't really have too much to gain from front running a simple transaction, any contract that's built on secret network is designed and encouraged to be working with these Snip 20s. So if this was like a uniswap kind of swap where there actually is value in reordering a transaction, that would not be possible or similarly like a dark forest attack thing. One thing to note though, there is a way to kind of see what's going on because of the metadata that's being submitted to the network. If you have a contract that has two different functions and one function takes very large inputs or it's very expensive to compute compared to the other one, someone can estimate which function is being called based on just the gas fees that somebody on chain. But again, the inputs to the transaction will not be known by anyone.
01:01:52.710 - 01:02:52.360, Speaker H: We also have an auction contract that's live right now. The goal is to build a dark pool like product around it. But I think this is interesting, and this could be interesting for also the auction implementations that you guys are looking into. The auction contract accepts all tokens to it. So if Alice is creating an auction and she wants to sell 100 eat, she needs to send her secret eat to the contract. And if Bob is bidding, like however much Die, Bob, Charlie, all them have to submit their tokens to the contract because these privacy tokens cannot be observed on chain. We have privacy on what assets are flowing into the contract and when the contract executes, there's guaranteed settlements while keeping privacy.
01:02:52.360 - 01:04:16.550, Speaker H: And our goal is to have any application that's built on our network to be depending on this Snip 20 standards. So kind of like, where does this put us with relationship? To mev, as I mentioned, inputs are encrypted so values can't see the transactions. They can't really reorder or insert transactions, solving two of the problems that Sunny touched upon, one like the dark forest and the other ordering for front running indexes. As I said though, it is possible to observe encrypted inputs, outputs, the functions that are being called to infer what's going on and that would potentially create some vulnerabilities around censorship. So if someone's trying to close a position CDP kind of situation, someone can see that this specific function is being called if the function is leaking some data. So one thing that we do is we encourage secret contract developers to kind of think through these side channel attack and do their own due diligence around it. So that's kind of it in terms of the way potentially with the mev auctions that you do.
01:04:16.550 - 01:05:20.250, Speaker H: One interesting option can be to have a smart contract, have the code to calculate this profitability calculation for the transaction bundles. The transaction bundle itself can be an encrypted input and we could just have the secret contract give the miner the ordered pair. At that point the miner would still need to submit it on chain. So there is a potential surface of attack. But that's something that we could do very easily. And if a couple of miners want to implement this, we could spin up a version of what we do or just implement this fairly quickly for other networks which do not run with private smart contracts. So that's me for now.
01:05:20.250 - 01:05:27.210, Speaker H: My colleague Asaf is also on the call, so if you have any questions, I'd be happy to go through things in more detail.
01:05:29.660 - 01:05:33.070, Speaker D: Yeah, dev, can you explain your last question?
01:05:33.440 - 01:05:48.960, Speaker E: Oh, sure. I guess the question is you mentioned earlier that some metadata is leaked because of the fact that anyone can execute the transaction in SGX and the metadata is, I guess database accesses.
01:05:50.100 - 01:06:16.744, Speaker D: Yeah, database accesses, the size of inputs and outputs, stuff like that. For example, if you know that a contract has two functions and one of them receives large inputs, usually then by looking at the encrypted input, you may guess that if the input is large, that what function will be called.
01:06:16.942 - 01:06:23.820, Speaker E: Right. So I should be able to get the order of all database reads and writes and the size of the data communicated?
01:06:24.240 - 01:06:24.988, Speaker C: Yes.
01:06:25.154 - 01:06:38.876, Speaker E: The question I have then is in order to get mev security optimal, do I need that all contracts in network are essentially equivalent or are data oblivious to one another. Is that the right primitive?
01:06:38.988 - 01:06:50.470, Speaker D: Yeah, for personal security, yes, you need it. But I think you can only know this in hindsight, what you're referring to.
01:06:51.160 - 01:07:02.600, Speaker E: Well, I mean, without that your anonymity set is just set of contracts of data oblivious with. So I guess for ideal security, maybe you could fix a data oblivious communication pattern.
01:07:04.220 - 01:07:11.084, Speaker D: Yeah, that is one area of improvement we can do.
01:07:11.122 - 01:07:21.980, Speaker E: Yeah, I guess I kind of worry if developers are the ones, if it's permissionless, what's the probability that two given contracts are data oblivious equivalent.
01:07:24.740 - 01:07:25.216, Speaker C: But you.
01:07:25.238 - 01:07:29.792, Speaker D: Know which contract is being executed? You just don't know what's going on inside.
01:07:29.926 - 01:07:41.220, Speaker E: Oh, right. Because it's not being hidden. Okay, right. Okay, that makes sense. You'd only need data obliviousness within a contract, which then a single developer could do.
01:07:41.370 - 01:07:41.972, Speaker C: Yeah.
01:07:42.106 - 01:07:45.110, Speaker E: Okay, thanks. That makes sense.
01:07:48.860 - 01:07:55.560, Speaker C: There's a question from Stefan as well above. What challenges did you encounter with running Cosmos SDK in SGX?
01:07:59.820 - 01:08:22.800, Speaker D: I don't know how to answer this. We don't run the SDK itself within SGX. We only run the smart contracting module inside SGX. And it wasn't very hard. You just call an external library.
01:08:31.090 - 01:08:31.598, Speaker A: Cool.
01:08:31.684 - 01:08:49.680, Speaker B: Well, I hope that answers Stefan's question. We can also continue the chat on the site. Let's move on to the last and fun part about the brainstorming session. Phil, do you want to present?
01:08:51.490 - 01:08:51.962, Speaker C: Cool.
01:08:52.036 - 01:09:16.060, Speaker A: Yeah. Thank you guys so much for that presentation. That's super interesting. And I think everyone who's presented so far will also probably have some good inputs into this next part. If you want to stay on, I would encourage that. So I will share my screen now. Oh, my browser can't apparently one SEC.
01:09:16.060 - 01:09:25.200, Speaker A: Let me rejoin in firefox. Sorry about that.
01:09:42.940 - 01:09:55.870, Speaker B: I think this is the most exciting roast so far. We've said that every single roast, but this one has been the best. But go ahead, Phil. Can you share the screen now.
01:10:10.440 - 01:10:15.210, Speaker C: Phil? We can, I think, see your screen, but can't hear you. At least we see something black.
01:10:15.740 - 01:10:17.368, Speaker D: Yeah, I just see a black screen.
01:10:17.534 - 01:10:19.450, Speaker A: You just see a black screen only?
01:10:20.380 - 01:10:23.560, Speaker C: Yeah, with a mouse.
01:10:23.900 - 01:10:48.852, Speaker A: Okay, great. One secret I want to present. All right, we'll just have to do it this way. Can you guys see this? Yeah. All right. I might have to. Okay.
01:10:48.852 - 01:10:52.116, Speaker A: Do you see the slides or do you see something different?
01:10:52.298 - 01:10:53.700, Speaker C: I can see slides.
01:10:54.360 - 01:11:36.156, Speaker A: Great. All right, so let's get started. I'm going to rant for just a few minutes, and then I would like to open up to some open discussion for the amount of time we have left in the roast. So hopefully, I'm just going to really summarize all the content we've seen. Now, we've seen several strategies for using secrets to reduce mev. Maybe we can contextualize this and talk about how we think about this in the engineering side of the Flashbots organization and where there's space for, I think, R D improvement across projects, collaborations. But the first thing I want to say is that I will also accept just talking about GameStop for the entire discussion session.
01:11:36.156 - 01:12:12.800, Speaker A: And if you're really disappointed by my slides and you're like, Phil, these slides don't look as good as your usual slides. It's because I was on Twitter all day yesterday, so I'm sorry about that. The other disclaimer I have is that these are not necessarily binding plans in any way or necessarily a roadmap for our organization. These are just my kind of shower thoughts on different architecture trade offs for L1 mev. So I would encourage people to be very vocal and interrupt me. I can't see the chat right now, so you'll have to do it audibly. But yeah, don't take these things too seriously or think they're in a final form.
01:12:12.800 - 01:13:14.080, Speaker A: I would love to kind of discuss and hear some reactions. Okay, so real quick, what is privacy? So the type of privacy we're talking about here is privacy of transactions as they're being mined from the miners. So normally when you have a miner that's creating some sort of block either in or a validator, either in a proof of work or proof of stake or a L2 system, they can see the full contents of the block they're mining. And as we covered here, we want to be able to enable, at least for some transactions, them to be able to mine this block while being blinded to this kind of set of transactions that's inside the block. So that's the goal. Why do we want this at Flashbots specifically for layer one mev? Well, actually, I think the miners are the ones who should really want this. And you might be asking like, why would miners want to blind themselves? Well, the reason is because by blinding themselves, they enable a more efficient marketplace between themselves and the people who are specialized in writing these trading strategies and these bot strategies that we've seen on the network.
01:13:14.080 - 01:14:42.030, Speaker A: So by allowing new types of orders, because there's a clearer trust relationship between validators and bots that increases the overall revenue that a validator would see versus having to spend engineering effort kind of running all the bots themselves. And it also enables specialization between kind of validation and mev extraction, which I think is a very important ecosystem property for fairness. So that kind of goes to the next bullet point, which is that it maintains incentives for permissionless, innovation, and an efficient bot ecosystem. So if we don't end up having minor transaction privacy, what's going to happen is that in order to extract large amounts of mev, especially with opportunities like exploits or new arbitrage types that haven't been imagined or flash loan, kind of arbitrage. It's going to be very hard for bots in the end game to extract these things without having either a very specialized infrastructure to deal with the dark forest kind of Meme or the PGA meme or to partner with miners directly. So we think that requiring that kind of partnership makes that ecosystem less efficient and causes all sorts of systemic stability problems, et cetera. I also think that miners have like trust or regulatory based issues where they don't necessarily want to be discriminating based on transaction contents and having this system where they provably can't, while they're still extracting mev, solves a lot of those concerns for them.
01:14:42.030 - 01:15:30.530, Speaker A: So overall, I think we increase system efficiency and fairness for miners as well as bots. Why the bot operators would kind of want this is obvious they get clearer guarantees on execution and efficiency. They don't need to specialize on gas auctions the way they currently do, which removes a barrier to entry and should democratize that marketplace. Specifically, they'll be kind of using a more advantageous and efficient auction mechanism that will be easier to both set up and reason about the economic properties of. And what that'll do is that'll let them specialize on strategies. So what we've heard in a lot of our previous roasts and brainstorming calls from people who are running these bots is that right now the bot specializations are really on the PGA Games and on mempool dynamics. And that's like a significant kind of monopolistic force in the industry right now.
01:15:30.530 - 01:16:11.260, Speaker A: And it's my hypothesis that all this PGA effort is kind of being wasted and is not making the system more efficient. So let me just check my time real quick. Okay, great. Whoops. This is the downside of this Janky Linux screen sharing. All right, so what are the properties we want for this system? So I guess it's basically the same as the three properties we laid out in the Flashbots initial blog post, which is permissionless. So we don't want to require any setup for either miners or bots to join the system and no trust overhead over the current ETH model.
01:16:11.260 - 01:16:55.076, Speaker A: So no need to trust certain miners to behave better or certain network tools to work or anything like that. So that's the ideal no trust overhead to today's network. We want it to be fair. So we wanted to align incentives between these different parties we've seen emerge in the ecosystem. And I think part of that is having as little barrier to entry and competition as possible. So right now, PGAs and back running, bots and spam, these are all significant barriers to entry and competition that we want to remove. And we want transparency for whatever privacy solution so that the custody guarantees for the data, like where the data goes and who processes it and how it's released, is very clear to everyone and also minimal impact on current networks.
01:16:55.076 - 01:17:58.532, Speaker A: So one of the differences, I think in Flashbots and the presentations we've seen is that a lot of the presentations we've seen are able to kind of reinvent the whole system and say, like, this is the ideal clean slate solution. So while I think there's a place for all of that in this ecosystem and we need that too, we also need things that work with current networks to prevent those networks from devolving into these trust based kind of systems. So I want to propose this informal primitive, and this is what I want people to kind of go away from this roast and brainstorm and maybe follow up with eventually. And this kind of unifies a lot of the things people have been talking about in previous presentations here stated very informally. So this is a proof of a private transaction, basically, or a private bundle, if you want to think. About the Flashbots context and in this proof basically approver proves to a verifier that it has a valid set of transactions for some ETH block hash H. So this is the new block hash and some transactions are in a public input list and others are kept private as input to this proof.
01:17:58.532 - 01:18:49.032, Speaker A: So that's stated very informally, but the definition can kind of follow from other interactive proof definitions, so you can have soundness and completeness and zero knowledge kind of standard properties layered on top of this. Properties we specifically want for a Flashbot's capable network would be that they're not withholdable. So this is the data availability that we were talking about earlier. State rich would also be nice. So in addition to having this proof that the private transactions will still cause valid state transitions, having proofs on the final state that results. So proofs about things like the coinbase of the Miner would also be useful. And I'll get to why in a second, cheap to compute locally, to create and to verify, and portable and non interactive.
01:18:49.032 - 01:19:31.224, Speaker A: Again, we'll get to why that's useful on the next slide, because we have this peer to peer network. So we want to kind of reuse these proofs as things travel through the peer to peer network. And again, this one's very Flashbot specific and kind of will impact a lot of how these solutions work. And that's backwards compatibility with existing ETH and existing L2 solutions. So let's say we have this magical primitive, this magical proof of private transaction. How would we use this to build minor privacy and accomplish the goals we set out? Well, it would be simple. So basically the trader, the bot operator, when they are submitting a bid to a minor to include their bundle or their private transaction, they would generate such a proof that the transaction is valid and they would kind of forward that to the relay network.
01:19:31.224 - 01:20:33.776, Speaker A: And that proof of the valid transaction and the valid fee payment, essentially because you have the state proof, would be used for spam control in this relay network in the same way E fee payments are, and would also be checked by the miner so that the miner knows that even though they have these blinders on, they won't lose revenue by including the private data because both data can't be withheld from them and that the data is all valid in the first place. And another layer here could be possibly combining these multiple transactions and these multiple bundles. So that's what I think was mentioned in the secret network presentation as one possible great application of SGX is that you can efficiently run, combiners and keep data private while you do that. And so if you have that, you can enter the situation where you have the Miner mine these bundles in a blinded way and you remove the blinders only after this block is produced. So we've seen many techniques for achieving secrecy and this use case is no different. So one solution is SGX. I think it's pretty clear at this point what that would look like.
01:20:33.776 - 01:21:35.860, Speaker A: You'd basically have some subset of an Ethereum client inside your enclave. It would attest that you have a valid block state transition on some public input hash and a correct encryption of the secret contents that you're withholding. You can also add to the output another binary, which is like a time lock encryption, or a committee encryption, or an encryption to SGX keys to ensure data withholding doesn't occur. Using these as defense strategies for the committee based solution, it would be nice if we could remove SGX here. That's kind of the open question that I want people to brainstorm when they leave here. Is it possible to have all the properties we have with SGX but without SGX? And I imagine many of the kind of Enigma folks and the Starquare folks and other people who are working on these solutions already have got answers and have tried many things in terms of removing SGX and these kinds of protocols. My guess is that the validity proofs are going to be somewhat prohibitive, especially with our requirement of them being cheap.
01:21:35.860 - 01:23:00.136, Speaker A: But let's say we have a magical committee MPC protocol that could also generate these proofs if it was efficient and could run kind of a whole ETH client in this MPC. Can we approximate that with threshold encryption and crypto economic kind of properties? Maybe using a bond or something like that? Would that erode our properties of fairness that we're trying to achieve? And even if we don't use this for the full system, can we layer these committees and these time lock encryptions on top of an SGX solution to achieve defense in depth if SGX breaks? The other thing I didn't mention here is that the burden of who generates the proof, right? Like you could have the trader just encrypt the transactions to the Miner's SGX and the proof is really just the encrypted transaction data. There's a question here of how the system behaves when SGX breaks. And by putting that kind of onus on the trader, it gives the miners the roles of kind of falsifying the SGX guarantees and noticing when SGX breaks, because the Miner will see that they get kind of invalid proofs that later no longer hold up when they're unblinded. So for the Miner in this system, these guarantees are kind of falsifiable and they can notice when they break and kind of stop running flashbots. If we instead put the onus on the Miner to run SGX, there are issues with miners reselling order flow and having advantages to kind of try to cut the line, like we've mentioned earlier. So those are all just things to think about here's.
01:23:00.136 - 01:24:24.840, Speaker A: Some open questions to discuss. I'm happy to discuss GameStop instead. We really only have five minutes, so maybe if anyone wants to hang out for a few extra minutes. That would also be fun. But is this kind of proof of transaction the right way of thinking about what we need to build? Is SGX a palatable solution for this, for the community? Does our straw man system that we've posited here using SGX and using the POTX in the relay network actually achieve the goals that we have? What qualities do these things share on layer one and L2? So, for example, can we use all these solutions we've just seen for reducing mev with consensus changes or on L2 on ETH today? My guess is there will be some difference here, but it's not clear how much infrastructure can be reused, especially in terms of Mitigating mev and in terms of the best auction mechanism. Is the best auction mechanism on L2 and layer one the same or not? And what other cryptographic primitives are useful for creating proofs of transactions that we haven't thought about? And what are the limitations of, for example, new MPC techniques or new proof types? So if these are questions you're interested in and we don't get to answers on this, call, also welcome to reach out to Info at Flashbots to talk about these things. I'm going to split my screen a little bit here so I can see the chat.
01:24:24.840 - 01:24:45.900, Speaker A: So yeah, that's all I really had. It's really just open questions and challenges. I don't know the answers to these, I wish I did, but that's kind of how we're thinking about it here at Flashbots and where we see current solutions, lagging questions, comments.
01:24:53.200 - 01:24:53.688, Speaker C: That would be.
01:24:53.714 - 01:25:34.380, Speaker E: Kind of interesting is can we get the miners to be a Threshold Encryption committee? And then they do Threshold Encryption sort of on their own. And then you have this protocol where essentially or you have standard built between them, where if one of them doesn't follow protocol correctly, e g they take threshold decrypted transactions and include their own transactions, like some transactions that weren't threshold encrypted, like weren't from this process. Then everyone else soft forks them out, like they basically reject that block. So essentially many soft forks in order to simulate Threshold Decryption.
01:25:34.800 - 01:26:11.640, Speaker A: Like an interesting meta economic question, which is that if the goal of Flashbots is to build an Mev extraction, I guess I don't want to use the word cartel extraction incentivized system of cooperation, then should the system punish defection or not? And I think that's an interesting open question, especially once kind of a higher hash power threshold is reached.
01:26:18.710 - 01:26:26.440, Speaker E: I don't say I can get around punishing defection with Threshold Encryption. Maybe SGX. There's no committee, so it's okay.
01:26:28.490 - 01:27:31.620, Speaker A: I guess that's fair. Well, I guess the way to get around it is just to assume your committee always works. And if it doesn't, then you just stop using the system. But yeah, that doesn't seem quite as satisfying. I think that's one of the other dimensions maybe it's worth adding to Sonny's and your other kind of section on the presentation which is like falsifiability of if trust guarantees fail, what is the recovery path and can people tell? So I think there's obvious differences even in just the SGX designs that I've thought about of who runs the SGX will affect whose job it is to monitor this and whether they can falsify or whether they can deterministically and accurately detect falsifications. I guess I think it's another dimension to think.
01:27:33.690 - 01:28:20.230, Speaker E: I guess in that dimension you have a lot of different design choices. I guess also for threshold decryption in Ethike environment you can have a committee where they accept some pipeline delay and block inclusion. Like this committee is going to decide on a run consensus out of Band essentially decide what block they want to propose next, what encrypted transactions and then if the hash of those encrypted transactions is included in block N, then they'll decrypt it in parallel. And then mine on that for block N plus one or N plus two depending on how pipeline delays work here. That's another alternative, which I guess gets rid of some of the fears of invalid or malicious committees but has other costs, namely pipeline delays.
01:28:20.810 - 01:28:48.080, Speaker A: Yeah, I think there's also probably like a falsifiability backwards compatibility trade off. I don't know, maybe not, but it seems like the current, let's say ETH protocol for example, because it's not designed to have such a system layered on it. There may be less false viability in some parts of the stack. That's just a hypothesis, but maybe that's the case.
01:28:55.890 - 01:30:24.330, Speaker D: If these are questions or remarks or maybe some obvious things. But as I see it, the main point or the main differentiator is to prevent the miners from playing unfairly and taking all the mev for themselves. You mentioned that as it stands now, frontrunners are optimizing on the wrong thing, they're optimizing on gaff war games and back running, et cetera. But I guess the end result is that either if they optimize on that or extracting possibilities eventually in both cases they can choose to give the miner everything besides the last dollar of profit minus their margin of operation. So the secrecy or the way you hide this transaction mainly achieves fairness that yes, you can optimize on whatever you want, but you can be sure that your optimization will not be front run eventually by the miners who have the ultimate power. Unless there is some other edge that you think is also important in this privacy scheme.
01:30:25.630 - 01:32:10.606, Speaker A: Yeah, I think ideally that would be I guess my hypothesis is that things would be more there's like an infinitely deep rabbit hole in the state based search of finding the best and most profitable strategy. So I do expect that for very simple strategies like uniswap sandwiching or something like that, probably you're right that it will be somewhat of a race to the bottom and the miners will extract the bulk of that because that's just how the auction will play out. And there will be some specialization there also in the auction at the frontiers of more obscure or complicated ARBs, I expect there will be more lag. So like market leaders who can kind of do a little bit better because their algorithms are a little bit more sophisticated and they have an edge for a little while and they use that edge to kind of profit until the edge disappears. So I think for everyone that's almost the best case scenario because for miners, they don't have to infinitely specialize to constantly keep up with this frontier. They can be comfortable that they'll extract kind of the bulk of the stuff that's been around for a while and they'll basically pay some R and D out to kind of more sophisticated actors who are exploring these things that there aren't mainstream tools for yet. So personally, my hypothesis is that that world is better for everyone also, because right now these searchers are somewhat searching, spending less time thinking about ARBs because they're specializing on PGA so much.
01:32:10.606 - 01:32:42.920, Speaker A: And I think a lot of these PGA dynamic details that people are spending a lot of time on are very arbitrary and kind of silly consequences of ethereum design that nobody ever intended to form the basis of this massive economy that wastes tens of thousands of hours optimizing around how guest simulation code works or whatever. But that actually is what we've seen. So yeah, I think that my hypothesis is that that world is better for everyone. But I think that's a good open question too.
01:32:51.720 - 01:33:16.190, Speaker D: Definitely in the short run it will be better for everyone. I guess maybe the way I see it, in the long term it converges to kind of the same thing. But on the other hand, yeah, I guess as more projects pop up, the pool of possibilities also rises exponentially. So there's that.
01:33:16.500 - 01:33:39.270, Speaker A: Yeah, I also expect there's going to be some pushback in people who have substantial code bases, but I also think they're the most flexible in terms of being happy they've had their edge for as long as they've had it and moving on to something else. So, yeah, I hope that that's how things would play out, but I don't know.
01:33:41.950 - 01:33:50.090, Speaker D: Yeah, I guess you'll be optimizing on whatever your dev salary instead of your gas cost.
01:33:50.240 - 01:34:16.500, Speaker A: Yeah, exactly. I see Syria also had a question about whether this is just making things more efficient because it removes PGAs or it removes PGAs just because it removes visibility, which I think is part of it. But I also think part of it is that it allows us to clean slate design and auction mechanism, which I guess is what you're working on. So I think it's a little bit of both.
01:34:19.290 - 01:34:20.280, Speaker D: Got you.
01:34:28.150 - 01:35:12.330, Speaker A: Cool. Any other questions? Comments, thoughts? I guess if not, we are a little bit overtime. So thank you guys for staying late and I think it's going to be a really interesting kind of thing to keep thinking about and try to think about, I guess, whether we can achieve these goals without SGX or whether it's worth compromising on these goals or whether SGX kind of really is the obvious answer here. So yeah, I look forward to hearing what people think. Async on that too.
01:35:24.880 - 01:36:20.990, Speaker D: I just can't see any other way, any non SGX way of doing it efficiently. Like every other option just seems to be just seems to require a lot more work that I think especially miners would rather just take SGX and be okay with. I don't, I don't think they care as much know, SGX being sort of know, a very clean security solution in the sense that it's not very pretty looking in terms know, maybe Threshold encryption. I think their priority is something they can plug in right now, start working with and it's super fast. Right. So there's a point here, I guess that worst case is whatever we have right now. So how bad would it be?
01:36:22.980 - 01:36:26.960, Speaker A: Would it be detectable if SJX is used and broken?
01:36:27.860 - 01:36:36.500, Speaker E: No, that would be non detectable fault as far as I'm aware. Because you can just front run and claim whatever order you got was from SGX.
01:36:43.560 - 01:36:48.384, Speaker A: Then it creates a false illusion of safety, which is actually worse than what we have.
01:36:48.522 - 01:37:06.088, Speaker E: Yeah, I also think that the point about it's miners may not care. Well, the security property isn't for miners, MEB is a security property for users. I guess it does matter what the miners think, but it should be the users who demand high security ideas.
01:37:06.104 - 01:38:18.112, Speaker A: I think that's all. So I think it is possible to make it in a way that if SGX breaks, the worst thing that happens is that you can spam the Flashbots network and dos it and dos temporarily any miners that are using flashbots until they turn it off. And the reason is that if you have the trader kind of generate this proof with private transactions here, let's say the trader never sends these private transactions and the output of this is also a committee encrypted kind of blob of these private transactions. Then as this proof gets passed along, if any of these guys break SGX, they don't learn anything because the proof has no data about these private transactions. So these guys can break SGX all day long and they have no advantage. If this guy breaks SGX who made the proof, he can send fake crap across the network and get miners to mine invalid blocks, basically. But if you're a miner you can also monitor for that and you can know when someone has broken SGX because they've promised to, let's say, pay you to eat for this block and then when you mine it, it's not valid.
01:38:18.112 - 01:39:23.240, Speaker A: So that kind of becomes obvious. I think it is possible, if you're somewhat careful around your failure modes to design something that degrades somewhat gracefully, still not fully graceful, still having SGX as a solution for not having the miners crash is not completely optimal. But I think if you had, let's say the miner run the SGX, then the consequences of them breaking it is much worse because there's no one that can check that they did that and they can front run you at will. So yeah, I think there's a kind of security continuum here and a lot of subtleties in designs. I think my hypothesis is that in this way SGX is a little more acceptable because it's not relying network is not relying on it for anything but security of POS, security of the miners that are using Flashbots. And you can also probably as a normal client watch for massive hash rate drops to have like a more decentralized metric on did the flashbots network get Dos also. So, just some thoughts.
01:39:36.330 - 01:41:17.910, Speaker B: Well, one interesting thought from our current learning with Flashbots Alpha is whether how miners, whether existing incumbent miners perceive true seal bit auction and also how the incumbent traders or bot operators perceive the seal bit auction. It's a bit scope creeping beyond the current discussion, but originally we thought the adoption hurdle would come at running SGX, but it seems to be that both sites are fishing for more information for an edge and that is something that at the current stage is something that we're curious to see whether there are creative ways to get around that per se. Because if the current version of MEB guests become the dominant way essentially for this kind of inclusion, the miners still have more control. So whether they would like to give up that control in exchange for the additional order flow potentially because of a system that could be more essentially that the traders the searchers will feel more comfortable with, I think that's going to be another site question that's there. We've experienced a lot of challenges around why seal bid, is seal bid really better? And UX with seal bid how do I even price without knowing where everyone else is pricing?
01:41:20.410 - 01:42:09.080, Speaker A: Yeah, that's a great point. I think it'd be super interesting to gather all their thoughts on sealed bids just as a way to see how people react to that proposal. I think we can also do not sealed bid stuff. I think our advantage is that we can really design the flashbots auction, however is best from first principles because we have a very good infrastructure to do that on with ETH plus SGX and also a clean slate possibility. So we could potentially have multiple auctions and have some be partially open where you leak some bid information on purpose. I don't know. I know sealed bid has some substantial limitations also around collusion that Syria is kind of formalizing now.
01:42:09.080 - 01:42:13.820, Speaker A: So yeah, I think that is very much an open economic question.
01:42:23.750 - 01:43:06.110, Speaker B: Well, cool. Anyone has any closing thoughts? If not, I am really impressed that we still have half of our folks still on beyond essentially, like, 100 minutes into our roast. So not to set the precedent for roast to become a day long event, which I don't mind, I think we should lead more to async as well as. So Sunny has proposed that we should have a couple more, essentially one privacy focused and another one is transaction ordering focused sessions. Right, Sunny? Our roastmaster. Any thoughts for future sessions?
01:43:07.190 - 01:43:37.180, Speaker C: Yeah, I think, like I said, we were focused mostly on that first proposer power, but I think it'll be good to talk about mev reduction techniques to start dealing with some of the other proposal powers, and choosing transaction ordering and inclusion is one of those as well. So, yeah, I think we think that would make for a good discussion. There's a number of different solutions of how you can do it.
01:43:42.020 - 01:44:23.504, Speaker B: Yeah, definitely. I think that sets the stage for more of these fun jamming sessions. That's it for today's content, and we will post recordings on the GitHub and our next session, either next Thursday or the Thursday after, we will have a session specifically focusing on state space search. So really, how large is the mev space and how much has been really capturing and can be captured through what means. Thanks for joining, everyone.
01:44:23.622 - 01:44:24.530, Speaker A: Thanks, everyone.
01:44:26.180 - 01:44:26.930, Speaker H: Thanks.
01:44:27.780 - 01:44:28.640, Speaker C: One last question.
01:44:28.710 - 01:44:30.290, Speaker A: Will this be recorded?
01:44:32.100 - 01:44:44.070, Speaker B: Everything is recorded. You can go on Flashbots, GitHub, PM, and where all of the row sessions are recorded.
01:44:45.000 - 01:44:47.300, Speaker H: Could you post a link in the chat?
01:44:47.720 - 01:44:49.270, Speaker B: Yes, I will do that.
01:44:54.550 - 01:44:56.280, Speaker C: Thank you. Want me to do it?
01:44:59.210 - 01:45:00.006, Speaker F: Yeah.
01:45:00.188 - 01:45:39.140, Speaker B: I'm also trying to find it also, if anyone is not on our discord, that's probably the best way to continue Async discussion, because we're all there and it's 24/7. So if you would like to be part of any of these open question research or propose essentially questions or want to present on the future roast, just shoot us a note in the discord channel, which, if you're not in it, I will also post here. One moment.
01:45:41.030 - 01:45:43.618, Speaker A: Awesome. Thanks so much, everyone.
01:45:43.704 - 01:45:44.386, Speaker C: Thanks.
01:45:44.568 - 01:45:45.520, Speaker A: Great to see you all.
