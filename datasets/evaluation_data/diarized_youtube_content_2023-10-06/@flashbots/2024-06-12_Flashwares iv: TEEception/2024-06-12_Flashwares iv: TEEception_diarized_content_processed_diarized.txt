00:00:06.320 - 00:00:26.484, Speaker A: All right, perfect. We are live. Welcome, everyone. This is the fourth flashbots flashware session. This session will be hosted by Mateusz. Information about the session, as well as previous and upcoming sessions can be found on the forum collective dot, flashbots.net dot.
00:00:26.484 - 00:00:29.444, Speaker A: And with that, I will hand it over to Mateusz.
00:00:33.344 - 00:01:27.264, Speaker B: All right, so, hello, everyone. I've prepared a very short presentation. Three slides, and then I would like us to go and try to make something actually work on a bare metal TDX. And hopefully I can follow Vlas at home. But also just feel free to comment with what you would want to do next within the context of TTX and virtualization. All right, so I'll go ahead and talk for like ten minutes. All right, so, yeah, the topic today is t ception.
00:01:27.264 - 00:02:06.144, Speaker B: So it's the idea of using TDX to run a tested hypervisor. So we are putting, you know, we are putting containers into our vms, and that's running in TDX. So, you know, why would that ever be a good idea? Right? So that's the risk. That's the idea of today's, you know, of today's fast first session, and it's more like a jam and like a hack session. Rather than me explaining anything or me teaching you something, I would be wrong a lot of the times in this presentation, so feel free to correct. And hopefully, hopefully I can also learn something new.
00:02:07.644 - 00:02:13.124, Speaker A: Sorry, sorry. One quick comment. Only half the screen is shared right now.
00:02:13.624 - 00:02:21.044, Speaker B: All right, let's fix that. This should work.
00:02:22.304 - 00:02:28.084, Speaker C: No, still, I think you should turn off the share screen and turn it on again. Probably.
00:02:28.904 - 00:02:52.388, Speaker B: Yeah, it's worked. Okay, stop. Share. Hopefully you can beat the share screen issues before we dive into solving all of crypto. Perfect. All right, does this work?
00:02:52.436 - 00:02:53.864, Speaker C: Much, much better.
00:02:54.924 - 00:02:56.504, Speaker B: Much better. Or like, perfect.
00:02:57.164 - 00:02:58.884, Speaker C: Perfect, perfect.
00:02:58.964 - 00:03:40.686, Speaker B: That's good. Perfect. Okay, so first, like, very quickly, visualization and containerization was the difference. I'm sure most people have at least heard of those terms, and at least some of us are, I'm sure, experts in the domain. So there's a couple of ways you can do virtualization. So why virtualization is nice is you're not running your applications with access to your hardware, so you can run something that you don't trust, don't fully trust, or just as a security precaution, think, for example, Firefox Windows. You don't want your firefox windows to have access at your ram and your disk.
00:03:40.686 - 00:04:25.682, Speaker B: Of course, that's one example where you do trust somewhat the application. But as a precaution, you don't want to be running. That's software containerization. And what we'll be doing here is harder virtualization, at least in part. So hardware virtualization is where the whole thing is running in a sandbox, the whole os that's running rather than just a window. The whole thing is running without access to hardware, or at least direct access to hardware. One example would be just full visualization where your os, there's a green box and your applications, they know they're in a sandbox, but they just can't do anything about it.
00:04:25.682 - 00:05:29.644, Speaker B: And the only way for them to access hardware is through the hypervisor and through the host OS, where the host is whatever is running your application in your virtualized OS. That's virtualization. Some of the technologies that can do this, you see now xen, it's like an old thing nowadays, mostly like camo and KVM can use those to emulate basically the whole machine. There's no access to the hardware directly. Then we have something in the middle where you have this green box, this guest OS, but it actually does have access directly to the hardware for some instructions, which makes it, for example, much faster because you don't actually have this emulation layer. This is called para virtualization sometimes. And there's things in the middle, like if you're using camo and KVM, it's not true that it's in either of those.
00:05:29.644 - 00:06:19.702, Speaker B: You're using basic KVM. The KVM is like a kernel module for visualization. Kernel visualization module probably. And although I'm not sure that's the right abbreviation, and you're using that as a way to accelerate your application. So some of this actually is translated much faster and some of your workloads actually run on the hardware. So there's like not a very even speed, but just like things in the middle. And then on the far left we have continualization, or sometimes also called os server virtualization, where you don't even run an os, it's just your application running somewhere with a bunch of libraries, and then you have some kind of engine underneath that's going to serve your application basically OS calls.
00:06:19.702 - 00:07:09.466, Speaker B: So here on the stripe side, whenever you want to go access hardware, you're going to exit out of your vm and go ask the hypervisor or the hostess or whatever to, you know, to give you access to hardware or to do something with hardware for you with containers. That's not so much right. First you just request the OS, like with an OS call, and that goes into the container engine and gets translated into whatever instructions. So it's a bit high level. And if you think about security, full visualization is kind of the most secure because nothing ever really runs on the hardware. It could be the strongest sandbox. I'm not sure if it is, because there are still things that can go wrong.
00:07:09.466 - 00:07:46.084, Speaker B: And you can probably escape this green box of your sandbox. This green is the sandbox. And you can try to escape to your hostess by leveraging some kind of attacks against this virtualization that you're under with a container. The problem is that you have access basically to the host kernel. If you think about it, your app goes and requests something from the OS. What happens there is it goes into the kernel. So if there is a bug in the kernel, or if there's a bug in the host OS, or there's a bug in the container engine, you basically immediately grant, get permission and get access to the hardware.
00:07:46.084 - 00:08:33.294, Speaker B: So if you run, for example, if this blue box is, for example, previous docker container, it's kind of triggered to escape it because you have access to all the devices of the machine. So this usually kind of easy to escape, and there's some options of some container engines that just simply insecure visualization. It's kind of a bit more interesting because there's, you know, there's, the attacks are maybe less obvious because there's no hostess to escape to. It's just the hardware. All right, but I'll stop now. Are there any questions? Did I get something wrong? By the way, please do correct me.
00:08:36.434 - 00:09:39.252, Speaker D: I do have a comment here. So I think when you mentioned the full virtualization with QEMU and KVM is probably the most secure. There are people who say differently. I don't know if you've heard about the Cubes project, the Cubes OS project, and I can't remember the details right now, but they basically, they tried to ditch KVM and QEMU for Xen. And the idea basically is they view hardware based isolation as the most secure of all. And then comes software based virtualization, which is what QMU does. It's an emulator, right? And yeah, obviously, like hardware based isolation is most likely more secure rather than any kind of software written code that might contain any kind of bugs or something like that.
00:09:39.252 - 00:09:48.504, Speaker D: Of course we have hardware bugs as well, but they seem to be less common than software bugs. That's just my comment here.
00:09:50.084 - 00:10:40.874, Speaker B: Yeah, I think that's right. So this approach with parasite virtualization where you don't even have this hostess to escape to write, there's no emulation that you want to try to find bugs in. Yeah, it could be more secure. I could definitely see that being a case, but I didn't do as much. This is kind of intuitive where full visualization is for sure safer than containerization. Although again, with very good containerization, maybe it's secure enough. And yes, part of virtualization where you kind of have direct access to hardware so you can do some things, you can do something if you're under parabolization, you can, for example, try to abuse the resources and things like that where it's not an escape, but you can still mess things up.
00:10:42.854 - 00:11:18.680, Speaker C: But yeah, I have also here. That's all true, but it's also very use case specific because paravetralization, if I recall correctly, for scenarios where you are trying to virtualize a process for a different architecture, then it will not be your target. And then there you only have the option of full virtualization in this case. Or maybe containerization where you can maybe specify a different target. But I don't think part of it realization will help you here.
00:11:18.872 - 00:11:47.092, Speaker B: Yeah, absolutely. Because you're running on top of hardware, you must, the target must be the right hardware. You can do a trick here. You can actually run this. You can run emulation here. So rather than treating the emulator, which is camo is an emulator, rather than treating camo as an officialization for sandboxing, you can treat it for just emulation. Run camo here and then whatever else you want on top of that.
00:11:47.288 - 00:11:54.864, Speaker C: Yes, that's true. But then you have to, you have to provide this manually because.
00:11:55.244 - 00:12:20.564, Speaker B: And then it's very slow. Right? Because camo with KVM is kind of fast here. If you are like. Especially if you match the hardware, if the hardware is the same as the cam target, as the chem. Guest is very fast with acceleration here is going to be. Yeah, it's going to be slow by definition, because the guest os is a different target than the hardware. So I have to emulate.
00:12:21.144 - 00:12:21.924, Speaker C: Correct.
00:12:22.464 - 00:12:51.704, Speaker B: Okay, let's get into. Let's get into the myth, which is TDX. So why am I going on about this, about this visualization? Because TDX is, you know, is a virtualization thing, right? It basically looks like this. They're trusted domains. I think of it as vm. That's probably correct. But that's roughly the idea.
00:12:51.704 - 00:13:33.924, Speaker B: So I think that this is how it looks like. This is like an artist. This on the right is my rendition, artist rendition of the thing that Latino provides in their docs, where we basically have this addition of this TGX module, right? That's, yeah, that's doing something that's living basically on top of the hardware. Right? So how. And this I think is true, because the TDX model does access the hardware directly for some instructions at least. Right? So Friedr, actually, feel free to correct me if you know, because I think that this TDX module goes and talks with the hardware directly. Right? Rather the hardware TXT keeps track on behalf of the TDX module.
00:13:33.924 - 00:13:56.604, Speaker B: All right. Yeah. So there is going to be some trusted domains running basically against OS. So this is a full Vm. It's not a container. It's actually running in OS. It's like some asterisks.
00:13:56.604 - 00:14:28.834, Speaker B: What kind of OS is that? But it's going to be the os on top of that. You have whatever you put on top of your os, whatever drivers you have, whatever applications you have. Then that goes and talks to either the hypervisor or the TDX module, or the hardware for the TDX module. That's cool. We have this box. I think that's roughly how you can interpret it when it comes to context of virtualization. And I'll stop here for a bit.
00:14:28.834 - 00:14:34.954, Speaker B: I would love Friedrich's opinion about my rendition of this diagram.
00:14:38.974 - 00:16:01.204, Speaker D: I mean, I think the interesting thing about TDX here is that it's, and you can see this here in the picture very clearly. It's trying to not only wall off different vms being able to extract information from each other, but the actual host and platform itself. And it does so via the TDX module. And if we want to interpret this picture, of course, I'm not a TDX module expert, but it does provide some interface to the VMM and does take a lot of responsibilities that a normal VMM actually has. Like example, if you could look at the nested page tables or extended page tables, it's taking care of that. Although we've learned that it's not like if you look at, for example, migrating the vm to a different host, and there's some exceptions, and we're still not sure whether these are secure or not. But in essence, the idea is that the TDX module has access to the extended page tables, and they host VM and not.
00:16:01.204 - 00:16:29.014, Speaker D: And so yeah, there's quite a lot of isolation happening. And this is good. And also good is that this TDX module is software, and it can easily be upgraded, even though you don't, you don't have to reboot your system. You can do it on a fly. And then that will be part of the attestation as well. So far so good. What we've seen from intel, this makes sense.
00:16:29.014 - 00:17:37.554, Speaker D: Unfortunately, if you go into the details about memory access and stuff like that, either things haven't been figured out yet by us, or there needs to be some additional work here. But it looks like that the TDX module is as it is software. We can change it, and we can provide suggestions how to change that and make it more secure to provide our needs. Where we want a TD VM running without ever getting interrupted. And like making this wall perfect that you see here, that's basically just running like it's running on a different cpu and the host really doesn't have any kind of access. And if it tries to access any kind of htable information, then, yeah, whatever, like our application gets slashed or will stop, something like that.
00:17:41.174 - 00:18:22.214, Speaker B: All right. All right. There you have it. Yeah, this does look good. And this does look like an improvement from the user perspective, if you want to go and run this in a cloud, if you're a user and this is your os, you want to go and run your application. This does give you separation from the cloud, basically right, from the cloud hypervisor, and shields you from them accessing anything here, which is very nice. All right, cool.
00:18:22.214 - 00:19:25.204, Speaker B: I can see. Okay, so KVM stands for kernel based visual machine. Of course it does. And then can I talk about preferences about LXC and Docker? So, to me, the level at which I'm kind of thinking about this is what kind of virtualization we want. So to me, Docker and Alexei and polymer divisor, whatever else, see, it's kind of in one buckets, and it kind of depends on which one fits your needs better for you. Specifically, what do you want of this? Do you want to be running untrusted code in that container, like on behalf of people? Probably don't use Docker, probably not use select C either. Actually, if you don't care, if you just prefer exceed and then go with that, right? Yeah, at that point, it's like whichever tool fits you best.
00:19:25.204 - 00:19:53.484, Speaker B: But as far as the virtualization goes, as far as Tex goes to, it's actually kind of the same. Hopefully that answers. All right, so this is what TDX looks like. If you think about it as like a part of the visualization stack. Basically, it's a module that's translating to the host VMM. I'm going to continue calling that the hypervisor, though. It's not the hypervisor, but whatever.
00:19:53.484 - 00:20:38.856, Speaker B: And some of this too hardware referred has the extended pages table so there's something residing here. Some things are delegated to the hypervisor. All right, sweet. So why I'm excited about this, so why I'm excited about this is that we can also run containerization here. We can nest because this runs just in regular Os. We can do another level of visualization. And with a proper sandbox you can probably run untrusted code in those trust domains where whoever gave you the code can be convinced that they are not going to do anything to the code.
00:20:38.856 - 00:21:40.016, Speaker B: And there's not much you can do with the hardware to trig them. As long as you control the sandbox and set up properly, it could be safe as well, depending on what type of virtualization you are doing. But I'm even more excited is that you can run containerization here inside this green box. So you have this TDX module that's acting as everything in this blue box can be attested. You can go and test everything here. And in particular, if you're doing, for example, on OS level visualization like Docker or something, as the guest, you can actually attest that you're doing this correctly or according to some rules, which I find an interesting topic and hence the deception. We're going to run some sort of continualization solution or visualization as I guess, all the TDX module, and we'll see where that gets us.
00:21:40.016 - 00:22:17.214, Speaker B: For example, can you attest anything that runs as the guess? Let's try to find out. So, yes, that's roughly what I'm talking about. So I think that TDX nested virtualization is something worth exploring, and it's definitely something that's worth hacking on. This is kind of simple to set up. You'll see that it takes maybe an hour to get up to speed on this and start using a stack like this. And. Yeah, so with a, with like an OS visualization.
00:22:17.214 - 00:23:12.160, Speaker B: So like Docker, this would look like the string on the left where we have the TX module and the guest and the container engine all attested. Right. So this blue box, this blue box is tested. The green box is not necessarily, let's think, let's talk about it later. Yeah, but you cannot test all the rules that are going on in this blue box. In particular, how you run the applications with the container engine, what kind of version of the containers are using? What's the firmware? What commands exactly are you using? How are you sandboxing? Are you running this privileged container? Or are you running user space containers or whatever on the right, this would be full visualization. Where probably not full visualization with an asterisk, probably harder.
00:23:12.160 - 00:23:36.434, Speaker B: Accelerated so that it's fast, where instead of a container engine, we're running another hypervisor. We are running our own hypervisor. This hypervisor, I'm not sure if you can attest. I don't think so. I think this is trusted. But we can attest this other hypervisor, which I think could be pretty neat. I would like us to explore if this gets anywhere and this useful at all.
00:23:36.434 - 00:24:02.994, Speaker B: Questions. That's it for the presentation. Let's take any questions that people may have. All right, no questions. Everything is clear. Let's go. Right, so that's it for my presentation, as promised.
00:24:02.994 - 00:24:55.080, Speaker B: Very short. And yeah, let's try to figure out like what's what we want to do as next steps. So I have some proposals, I have some agenda. What I thought would be nice to do is just go and look at how this looks like. How do you actually run Docker inside kennel inside the TDX VM? I don't think that's, it's kind of straightforward, but it's maybe counterintuitive. So it's good to see that actually works and that you can still access data stations, in particular from this nested container. I can show you where I'm stuck with nested full visualization because I'm actually stuck with running camo in camo.
00:24:55.080 - 00:25:33.124, Speaker B: For whatever reason, the KVM module is just not available. We have some very cool things from mobile who has recently built a yogto image with Podman. With Podman inside. So this would be like a reproducible image where you have a containerization solution inside the image that you can run as a part of the TDX VM. I think it's pretty cool. Yeah, I think that's it. So Leo is asking, is Docker itself reproducibility built? I should have no idea.
00:25:33.124 - 00:26:01.494, Speaker B: I'd be surprised if you couldn't get it to build reproducibility. But I didn't check. And I think that if it's not built reproducibility, we could probably always use something else. It's a good question. I actually don't know if anyone cares to check. I also be very curious about the answer. All right.
00:26:01.494 - 00:26:59.804, Speaker B: In the meanwhile, I'm going to set up my console and let's see if I can run it. Let's see if I can run the current cam again because I did try live demos. Right. All right. I have to make it big, right? So I have access to a better method for instance. So this is very nice. So this is not a TDX Vm as you'd get from let's say azure, right? So this is a bare metal server that is TDX enabled and that we've configured to work with attestations.
00:26:59.804 - 00:27:45.980, Speaker B: So we'll be using like we have access to all the hardware and we have access to all of the, we have like TDX guest device, right. And things like that. Okay, so I have found the guide from canonical to be an extremely useful resource. It's linked on the forum under it's just canonical TDX. I'm also going to paste it in the zoom if anyone wants to follow. So let's just make sure that I've set that correctly. So they're asking first to go and let's just look at what the script does.
00:27:45.980 - 00:28:32.604, Speaker B: Right. Like how does setting up itd experimental host look like? So 1st, 1st thing they ask you to do is to go here and run this setup ttxl script. Okay, let's, let's go and see what this does. Okay. I have no idea what this does as some kind of boot options later on we have this Kabul team which is building TDX libraries and it's going to be actually very important. We have a bunch of other dependencies. In particular, we are going to install camo.
00:28:32.604 - 00:29:13.824, Speaker B: Camo system. X 86 is, there's various flavors of camo. This is the target that you want to emulate basically. In this case it's just going to be native, right? Because we are on a X 86 server as well. And this TDX tools host, this is from the Cobop team and this is where most of the goodies come from. So if you're interested in seeing the actual libraries and the actual tools, this is where you actually want to go. All right, so we're switching the kernel here and that's it.
00:29:13.824 - 00:30:09.314, Speaker B: Okay, so in grub, so this is like the boot options. The thing that we are doing is we're allowing the KVM Intel TDX, right? So this is like enabling the, I think this enables the TDX device inside the KVM module so that we can have access to TDX inside cam o vms. And this is actually very important. So this means that we'll be able to go and request quotes from inside the vm. So here it's just a bunch of dependencies. As you saw, this is not, it's not very complex. The most complex change is probably enabling the KVM module and then configuring it with TDX support.
00:30:09.314 - 00:30:44.962, Speaker B: All right, so a couple next steps. The guide asks us to go and enable TDX in the hosts bios, which we have done already. I'm not going to show you that. And yeah, let's see if our host has TDX enabled. And you can see that indities. So if you're, if you're following account of your own machine, this is kind of what you want, what you're interested in once you put up after setting up the host. Right.
00:30:44.962 - 00:31:17.924, Speaker B: This TDX module should be, should be enabled. So both in versus. And then you should see the. Yeah, and you should see this KVM intel being enabled here with TDX as well. All right, next up is the guide is asking us to go and generate the VM image that you're supposed to run. So let's go see what this does. And this is rather simple.
00:31:17.924 - 00:31:49.404, Speaker B: So we're going to use a official Ubuntu image, something like, just like Ubuntu 23. Right. And we are going to do a bunch of things to the image, making it like a TDX guest image ready to be run with camo on our machine. So I'm not actually going to run this because this will take forever. This takes like an hour. I've run this area. So I already have the image.
00:31:49.404 - 00:32:18.574, Speaker B: What does this basically goes and downloads the image. It's not very interesting. And yeah, then it's going to go and install. So this kind of interesting. It's going to install the driving data. It's going to install all of this, you know, as like metadata. It's just setting up a bunch of stuff.
00:32:18.574 - 00:32:54.074, Speaker B: And here's how we define how, you know, the image defines the dependencies that it was installed. And again, you're seeing that, you see that the packages are kind of fine. It's the same. There is this. So this is the important bit where we will mount the, the TDX device in this inner vm. Once it boots, it's going to go and mount this mode. If you need to, you can modify this could actually be found later on.
00:32:54.074 - 00:33:36.084, Speaker B: You could make it a part of some group so that it mounts with an Android group. Could be useful. This important is going to mount the TDX devices, in particular the devices you're using to, to get TDX quotes inside your vm. Again, thanks to the co op team, as you see all the tools. And the last thing is it just sets the root password one to 3456. I don't think there's anything more here. So let's go back and.
00:33:36.084 - 00:33:56.144, Speaker B: Yeah, the next thing is gonna do is just going to increase the size of the image. So when you download the image is very small, but you want like the disk of this, of this VM to be bigger. And how you do that in camo is just add space to the file. Right. That you downloaded. Yeah. So this is how they do it.
00:33:56.144 - 00:34:30.327, Speaker B: Yeah. Here they are copying the user data and they're doing some image magic because what you download is an ISO and. Okay, whatever this is, I don't think anything. I think the rest is kind of simple. Okay. So one thing that's important that's left is this setup, TDX guest. They're going to copy it into TMP of the VM and they're going to, and then they're going to run it.
00:34:30.327 - 00:34:52.923, Speaker B: So this is kind of important. We should probably go take a look. And that's it. That's going to be the image. All right, let's go look at stat guest. This is, so this is basically what makes the image TD extra. And it's very simple.
00:34:52.923 - 00:35:40.964, Speaker B: All it does installs a bunch of dependencies, again from the cobweb theme. Right. So they're adding the repository and installing the robotics guest package, which contains a bunch of stuff in particular contains like tools to get the quotes, to get the TDX quotes. All right. So once you run the image, what you'll get out is this TX guest 123, this Qcal two format, which is the cam format. And let's see. And the next step is just to bullet.
00:35:40.964 - 00:36:30.054, Speaker B: So let's try, let me see if I actually have the image showing anywhere. So the run command is like a var script, and then I'm exporting the path to the nav created image. And let's take a look quickly at the command, at the script. So this certainly modified. I'm trying to make it in a run with. This is visualization on with very success. Yes, the success is partial.
00:36:30.054 - 00:37:09.388, Speaker B: Okay, let's see what it does. So first the script checks that your user is in the KVM group because otherwise you cannot use the acceleration or in general the KVM module. So it's important that you do. Then that's basically nothing. It's just running the chemo system. This is the native one, and you can see that it's native because we are passing in CPU host. In kernel terms, this means that the guest and the host is the same target.
00:37:09.388 - 00:37:41.546, Speaker B: And we are asking Camo to not emulate anything. There's a bunch of things here. I didn't quite work out how the memory encryption is handled here. Yeah, so if anyone knows, that would be nice to learn about. Yep. It's basically saying, please encrypt my memory with TDX. And I have no idea how that sounds inside camo.
00:37:41.546 - 00:38:00.444, Speaker B: I'd be very curious to learn. All right. And then there's not much else really. Yeah. And just tells you that this is running. So let's go ahead and run it. All right.
00:38:00.444 - 00:38:23.964, Speaker B: Usually needs a second to put up, but. All right. And we are in. Okay. And I'm looking at the guides what. What else they're asking to. Asking us to do.
00:38:23.964 - 00:38:34.680, Speaker B: And. Yeah. So now comes the verification part. So first they're asking us to run this comment. Right. Mask, type into grep, look for TDX. Right.
00:38:34.680 - 00:39:05.214, Speaker B: So we are going to look through fruit mask. So this is like the kernel log or something like that. Right. So first thing it does is it says that it's detected that it's a guest, which is very nice because it's also correct. And yeah. Saying that, you know, it has like memory encryption within, which is nice. So this looks so good.
00:39:05.214 - 00:39:37.894, Speaker B: Of course, this is not something that you can trust because it's just a log. So we actually need a better way to confirm that we are indeed in TDX. So next thing that they ask us to do is check if the TDX device is mounted. And yet it is. This is where. Where we go and request our quotes and. All right, I think that's.
00:39:37.894 - 00:40:20.774, Speaker B: I think that's it. So the guide goes into setting up attestations, which I'm not going to show because it's either very simple and you just follow the script or very complex. We have followed the guide with hopefully successful and. Okay, next thing that they ask us to do is to go and set up the guests at the stations. So here again, Kabuk team, the sleep TDX dev. I think this is from the Kabuk team has a bunch of nice things in particular. I think this is the thing that they provide.
00:40:20.774 - 00:40:57.044, Speaker B: Second example quote, which we're going to go and run. So let's run this. And what's this going to do is it's going to build this example that goes and requests a TDX quote, so generates like a TD report and request a quad. I never forget. I never remember the path. So. Okay, and then we can go and run it and.
00:40:57.044 - 00:41:35.826, Speaker B: All right, so we have some bytes, right? We have, we have some. Some hacks and yeah, it's going to generate the report data. Here we have the full report. This includes all the fields that we are looking for, probably like what image was run and such? And yeah, we got the quote. So if we go and parse this, this should kind of convince us that we're indeed running integration and everything is set up correctly. This should be signpainted or whatever. And yeah, so we got like a camo VM running.
00:41:35.826 - 00:42:10.724, Speaker B: So that's the first step. Right. And I'll probably stop now for like a minute and see if there's any questions. The next part will be, I was going to run Docker inside and see if we can get the code to still work. Is cowork a canonical or an intel team? I have no idea. Yeah. Does anyone know the.
00:42:10.724 - 00:42:46.484, Speaker B: I don't think they're part of canonical because they have a separate PPA. Right. This is not. It's not the usual canonical things. So I'd be surprised if they were. Yeah, I'm trying to look hard to say. I don't know.
00:42:46.484 - 00:43:14.304, Speaker B: I wouldn't be surprised either way. All right, I actually have a question here to mount because Mo has actually went and parsed this, this quote. And Mo, could you maybe paste me or paste in the chat, the parse data for this, for this quote?
00:43:15.164 - 00:43:22.144, Speaker C: Yes, I can. 1 second. I need to parse it again but once. Give me 1 second.
00:43:30.784 - 00:43:31.724, Speaker B: Okay.
00:43:32.664 - 00:43:39.844, Speaker D: Andrew has written a cool script that does exactly that. I think it would be nice to show here.
00:43:42.584 - 00:43:51.656, Speaker B: Yeah. Moto, do you want to show the script or. We probably cut you off guard, so I don't want to make you all good.
00:43:51.720 - 00:43:54.334, Speaker C: Where should I post the. The quote?
00:43:57.554 - 00:43:59.854, Speaker B: You can dm me. Maybe I can just show it here.
00:44:00.434 - 00:44:03.534, Speaker C: All right, I'll send it to you. 1 second.
00:44:03.994 - 00:44:09.974, Speaker B: Yeah. But we have a very nice parsing tool from Andrew. We should definitely go on the kit at least.
00:44:10.554 - 00:44:40.224, Speaker C: Yeah. The one from Andrew is parser for the version four of the TD quote. So basically TDX 1.00. I think I've written two parsers in rust. Which one also v four and one for the v five in case we. Yeah, we utilize the newest quote so we have two. I can share with you the two repos.
00:44:40.224 - 00:44:52.064, Speaker C: So this is the code pauser and rust. And I'll fetch you the one from Andrew shortly.
00:44:54.164 - 00:45:08.884, Speaker B: All right. Okay, so this is the parsed. The parsed quote. And. Yeah, it looks like, you know, looks like everything is here. Yeah. No.
00:45:08.884 - 00:45:17.542, Speaker B: Anymore it's kind of, yeah. Intel, I think, dropped down there. Right.
00:45:17.718 - 00:45:18.086, Speaker C: Okay.
00:45:18.110 - 00:45:20.814, Speaker B: And we have the three most important measurements.
00:45:20.854 - 00:45:21.434, Speaker D: Right.
00:45:22.574 - 00:45:29.534, Speaker B: This is kind of what we care about. And user data is just zeros. Right. We didn't actually post anything.
00:45:29.574 - 00:45:30.154, Speaker D: Actually.
00:45:30.454 - 00:45:45.156, Speaker C: Sorry, I think I misled you here. The RTMR three is not necessary user data. It's like an empty field that can be extended with whatever later on. Because if you go up you will see user data. There is a field for user data.
00:45:45.340 - 00:45:46.104, Speaker B: Yeah.
00:45:47.884 - 00:45:56.764, Speaker D: It was my rtmr three could be used for the bob private ssh key for example.
00:45:56.924 - 00:45:57.332, Speaker B: Yes.
00:45:57.388 - 00:46:02.144, Speaker C: You can use it for anything you can think of. Like it's a 64 byte I think.
00:46:04.494 - 00:46:11.822, Speaker B: What do you, what do you mean by private? Private. Private key. So the public parts of the key or something like that?
00:46:11.958 - 00:46:12.674, Speaker C: Yes.
00:46:14.054 - 00:46:55.654, Speaker B: So if I want someone to, you know, if I want to convince someone that I'm running in sgX and you know, and give them a way to give me data in a way that only I can get it, I should propose I should just put my public key, or like a hash of my public key inside this rtmr three. Right. And they can encrypt to that. And they can be reasonably sure that if they check that I'm actually generating the private key inside the enclave right inside TDX, and they check the other three. So the image and the command line, whatever they would configure, they can just be sure that they can encrypt to that key and only I can decrypt it inside TDX.
00:47:00.214 - 00:47:25.534, Speaker C: If I. Yeah, it's like you can think of it as a field where you can export some data to the outside attestably. Like basically you can make sure that this is really by this image and you can attest it like it's secure, like it's not being manipulated or. Yeah. Maliciously changed.
00:47:25.834 - 00:47:41.254, Speaker B: That's pretty cool. That's pretty cool actually, because that's the next step. Right. How do I get data in? How do I get convinced that I can get data in? And that would be one way. So that's interesting.
00:47:42.634 - 00:48:06.584, Speaker C: If you notice when you generated the TD quote, you got three failures at the end which says like could not extend those. RTmR two and three fail to extend. Yeah. Maybe we could look into this later on how we can extend these and add some data to it. But yeah, this is the main idea of the station here. You can add stuff.
00:48:08.324 - 00:48:20.194, Speaker B: I see. And we thought would we extend this? Because as far as the guide goes, they're saying that this is fine. Yes. I'm not sure I trust. So what would happen here?
00:48:21.494 - 00:49:35.320, Speaker C: What would happen here if I understood correctly from the documentation that the TD module will inject those values plus their hashes and science them and put them part of the session report. So this is mainly, as Frieder said, you can use it to, for example, exposing your public key, and you can attest it then through the TD quote, and it will be part of the general hash value. And a very important part, if you show the parsing again, is the MRTD actually, which is how I interpreted it, is basically comparable to the GX enclave. Mister enclave. So the measurement enclave, that's how I understood it, actually. So this here is basically measurement TD instead, instead of a measurement enclave. But I also noticed that your image that you created on this machine and the one that we created on Andrew's machine, on two different machines, they were generating the same measurement, which is actually correct, because if you think of it, you are both of them.
00:49:35.320 - 00:49:47.404, Speaker C: Like, you're, like you and Andrew generate the same image. So like from the same base image and you didn't do any changes. So I would expect also to have identical value.
00:49:47.824 - 00:49:55.688, Speaker B: But I did use different options for my Camo CMD, though I don't, I.
00:49:55.696 - 00:50:50.384, Speaker D: Don'T think this is the case. And if we can get a yocto at the station, we will likely see the same MRTD. And the reason for that is the MRTD only has like, it's the initial measurement. Like if you look at a TPM measurement, PCR zero, the first volume that's being measured, that's only like the firmware and the boot UEFI, stuff like that. This is what's being measured. And then you have RTMR zero, which is probably the kernel. RTMR one might be the round disk, and RTmR two, kernel command line, but don't, like, I don't know which one of these, but that's basically what they're measuring afterwards, which you will find in PCR three.
00:50:50.384 - 00:51:17.824, Speaker D: Well, in the PCR values, so. But MRTD, PCR zero. So that's basically, that's why it's called MRTD, the measurement of the TD itself. So before any VM has happened, it's only the initial trusted domain that's being measured here with a firmware that's eventually going to boot. The boot at the end.
00:51:19.024 - 00:51:26.480, Speaker C: Yeah, makes sense as well. But at the same time, I don't see then. I don't see any usage for it, like at the moment, for security wise.
00:51:26.512 - 00:51:41.724, Speaker D: So basically the most important, I mean, it's a firmware, it's a boot, it's the UFI. You need to know what's being booted here. If you don't know what you're booting. You could easily sneak in a backdoor. So this is, of course, this is part of security.
00:51:42.144 - 00:51:50.598, Speaker C: Yes, but we don't have the access on this firmware. It's proprietary. So basically, you kind of like, just. Yeah. Trusting this hash to be.
00:51:50.646 - 00:51:51.382, Speaker B: No, I think.
00:51:51.518 - 00:52:13.434, Speaker D: I think in this case here, we do have access. This is what actually what we give by the QEMU command is we provide an open source UEFI implementation. And I don't know what else has been passed as permanent, but we do have access and we can actually try to distribute this MRTD measurement.
00:52:13.924 - 00:52:34.540, Speaker C: This would be an interesting. To verify this, actually. This is nice, but. Yeah, back to the RTMR zero, one and two. Yeah, you are correct about the. This is the unified kernel image hash. And I think the one was the CMD line and the second is the trend disk.
00:52:34.540 - 00:52:54.274, Speaker C: But why do they say then that those three values cannot be generated without, like, booting the image? So these three values are runtime measurements that can be only generated during runtime and cannot be done at compile time, like at building time of the image.
00:52:54.774 - 00:53:26.876, Speaker D: So there's a misunderstanding here. RTMR zero, one and two. These are different depending on the VM image that you're booting. Um, so, uh, it might as well be that you're going to boot an image that's not going to, um, send this event of, I want to have a measurement right now. And then you don't have any rtmr zero. You don't even have an RtmR zero. Uh, not even like a one and two.
00:53:26.876 - 00:53:57.664, Speaker D: Out of question. So it depends on whatever you're going to boot. Um, which is then going to give you a measurement or not. It depends on the code that you like. This is a chain. You put in measure something, you execute that, and then this something is going to execute something else, which is then being measured and so on. So depending on what you're going to start in the next phase, it's going to give you a measurement or not.
00:53:59.204 - 00:54:00.104, Speaker C: I see.
00:54:02.004 - 00:54:17.864, Speaker B: Yeah, I think that we actually can get this at build time is just complex, and they didn't do it yet. But if you just captured all those events, I think that you can get this without access to TDX at least, right?
00:54:18.024 - 00:54:33.780, Speaker D: Definitely. If the MRTD is PCR zero, which is what they're saying, then we just need to look at the TPM documentation and look how they're measuring the firmware, and then we can reproduce the MRTD with MRTD.
00:54:33.812 - 00:54:38.344, Speaker B: Yes, but how about. Yeah.
00:54:38.804 - 00:54:40.784, Speaker C: How do you do them? That's a question.
00:54:41.364 - 00:54:53.824, Speaker B: But I think, I think it's the same for those. Right. I just have to emulate it. But there is no, like, those are not signed or anything like that. Right? This doesn't require access to the hardware? TDX hardware? No.
00:54:54.324 - 00:54:59.924, Speaker D: For these measurements, we already have a code that can measure these parts of the disk.
00:55:00.384 - 00:55:12.844, Speaker C: But are they comparable with, are they comparable with the same values? This is the question. Like, are they generating the same values as these? You didn't verify this. We have to verify this, in my opinion.
00:55:13.664 - 00:55:19.284, Speaker D: Yeah, sure. We can verify that. You can just run the script on the image that we have here and check.
00:55:19.904 - 00:55:26.484, Speaker C: I tried this. It doesn't work out of the box. You have to do some kind of changes because the script does not accept this format.
00:55:29.414 - 00:55:30.030, Speaker B: What is it?
00:55:30.062 - 00:55:33.862, Speaker D: Is it the Kikao two format? Something like that?
00:55:33.998 - 00:55:35.470, Speaker C: Yes, it's Kiko two.
00:55:35.622 - 00:55:37.674, Speaker D: Okay. And that's the reason why it's failing.
00:55:38.534 - 00:55:47.394, Speaker C: It's failing. Yeah, it's failing. Not necessarily because of the format, but I assume it's because of the format. So I will try to change it to raw format and try again.
00:55:47.854 - 00:55:48.502, Speaker B: Okay.
00:55:48.598 - 00:55:52.158, Speaker D: I don't think this is like we can fix this. Should be easy.
00:55:52.326 - 00:55:54.474, Speaker C: Yeah, yeah, definitely.
00:55:56.664 - 00:56:35.826, Speaker B: All right. Amazing. So last thing, I'll show you. I'll show you how you can, I don't know, access the DX codes inside Docker, which I think is pretty cool. So I'm going to run a previous container because I have not yet figured out how to run this in user mode. The usual tricks with cgroups don't actually work. I'm sure this can be done.
00:56:35.826 - 00:57:11.344, Speaker B: Just didn't have the time yet. And also not sure if we want to use Docker. So not investing too much. Yeah. Let's see if I can get this work. And what we'll use is we'll use the, one of the tools from the people. Let me remember, actually, this.
00:57:11.344 - 00:57:44.634, Speaker B: Oh, wait. Yeah. So installing the tools to then add. We are not cleaning. I think that this actually. Okay. Is this.
00:57:44.634 - 00:58:05.714, Speaker B: Yeah. Trust. Okay. And then quot just like that. This is just zero, I think. All right. And we did, you know, get a call.
00:58:05.714 - 00:58:30.920, Speaker B: So this is from inside Docker. Driving is pretty cool. It is running previous, which is not cool. It's completely broken. But yeah, you can see that we do have access to the device and it's generating quotes just fine. I'm actually not sure what this code has, what this code contains. I think it would be pretty cool to go find out.
00:58:30.920 - 00:58:48.524, Speaker B: We should definitely go try and parse this. Probably not right now. So if you want answers, you have to reproduce and then check the code. But in the meanwhile, we'll for sure try and parse this and see what this code has inside.
00:58:50.184 - 00:58:50.632, Speaker D: All right.
00:58:50.688 - 00:59:50.684, Speaker B: So, yeah, we are running Docker in a way that is attestable. So if this initial VM was generated reproducibility, and you could have tested and it didn't include SSH access, you could actually be reasonably certain that the way that the containers are run is as you expect, which I think is interesting. Yeah, there is not really anything severely broken, I think, about this approach, although I'm pretty sure that the code that you're getting inside Docker doesn't actually give you any guarantees about the container running, rather about the initial VM, which could be actually useful in some way. So, yeah, I think that's it for me for today. Do we have any last questions? Any questions from YouTube? If anyone is there, it's looking at the comments, I'll go check.
00:59:56.644 - 01:00:16.624, Speaker A: No questions from YouTube, but if you're watching this afterwards on YouTube, please go to the forum, ask your questions in the thread, it's linked in the description, and then any upcoming sessions will also be posted on the forum collective dot flashbots.net. thank you so much.
01:00:18.124 - 01:00:24.084, Speaker B: All right, thanks, everyone. And yeah, see you next time. Awesome.
