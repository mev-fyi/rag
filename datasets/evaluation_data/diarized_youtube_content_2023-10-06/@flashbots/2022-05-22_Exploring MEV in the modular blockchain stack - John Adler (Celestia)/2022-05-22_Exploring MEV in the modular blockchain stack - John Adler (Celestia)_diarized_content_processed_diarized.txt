00:00:09.450 - 00:00:32.642, Speaker A: Good afternoon, everyone. I guess it's time to I guess it's time to start. So I'm here to talk about exploring mev in the modular blockchain stack. A little bit about me. My name is John. Unfortunately, IRL, I am not a cute anime girl. I am one of the co founders of Celestia Labs, which is building Celestia, the first modular blockchain network.
00:00:32.642 - 00:01:20.360, Speaker A: And I'm also one of the co founders of Fuel Labs, which is building Fuel, the fastest modular execution layer. And today I'm going to talk a bit about modular blockchains and how mev in a modular blockchain stack context might look like. And why would we even want this? What's the motivation for this? For those of you who have been following the Celestia project, this notion of modular blockchains has been increasing in popularity, not just on Celestia, but also with alternatives such as polygons avail and ETH Two's. Thanks, Sharding. And so on. There's a big push in the industry to move towards this modular architecture, which is fundamentally different than the monolithic architecture. And we would like to know how mev might look in this new world.
00:01:20.360 - 00:02:07.618, Speaker A: Okay, so first, a quick recap of the difference between monolithic and modular blockchain architectures. For those of you who may not be familiar with this, this is kind of how a monolithic blockchain looks. It's a single monolithic, for lack of a better word, atomic layer that does consensus. So ordering of zeros and ones availability. So this means making sure that data has been published to the world settlement optionally and also execution. So a blockchain like ethereum or Bitcoin or Solana or literally every blockchain prior to Celestia was a monolithic blockchain. And it does all four of these components, all in a single atomic layer.
00:02:07.618 - 00:02:57.154, Speaker A: Why is this not particularly the best model? Well, because to resolve the double spending problem, if you read Satoshi's design paper carefully, you don't actually need to exclude conflicting transactions to resolve double spending. You only need to provide a total ordering on transactions. In other words, on zeros and ones, ultimately. And as long as you have a total ordering, anyone can exclude themselves later on invalid transactions that attempt to double spend that come later. So timestamping, in other words, consensus and data availability is sufficient. You don't actually need to do execution of the transactions at the basis layer in order to solve the double spending problem. And this is good because what is the current bottleneck for ethereum? Well, it's execution, right? It's not consensus.
00:02:57.154 - 00:03:49.974, Speaker A: Just changing the consensus protocol does not make the EVM faster. The bottleneck is ultimately the EVM and state growth and disk I O and such that result from the particular virtual machine choice. In other words, execution. Okay, so the start of moving in the direction of modularism is when roll ups kind of started getting steam, where you would have execution happening at a higher layer, the roll up layer, and you would have your base layer still performing things like ordering of transactions, data availability, settlement, but also execution. So this looks like roll ups on Ethereum today. This isn't exactly modular because the base layer is still performing all the four tasks and therefore it's still bottlenecked fundamentally by this execution. Can we go further? And the answer is yes.
00:03:49.974 - 00:04:28.894, Speaker A: So an actual proper modular blockchain architecture would look something like this. You have the basis consensus layer at the bottom that orders transactions, makes them available. And then on top of that, you can have completely separate layers that perform settlement and then execution on top of this. And this is not the only configuration of a modular blockchain stack. It's only one possible one. And this is the nice thing about modular blockchain stacks is they can be configured in many different ways. For example, you could have multiple settlement layers connecting sorry, multiple execution layers connecting to a single settlement layer, which then posts its data to the data layer.
00:04:28.894 - 00:05:10.798, Speaker A: You could also have execution layers that directly post their data to a consensus layer. And you could have one or two or thousands or a million of them all running on top of a single consensus layer that provides shared security to every single one of these layers on top of it. Okay, so now we're going to talk about now that we know what the modular architecture looks like, we can start exploring a little bit about how mev would look in there. So we're going to keep two things in mind. The first is the law of conservation of mev. This is kind of a tongue in cheek observation that isn't like any hard law or anything. That simply moving things from one layer to another.
00:05:10.798 - 00:06:07.474, Speaker A: Like, say, moving execution from the base layer up to an execution layer. Does not, on its own, with no further changes, it does not change the total amount of mev in the system. Now, the nice thing about separating things in layers, it allows exploration and it allows you to kind of tailor each individual layer with different ways blocks are produced and so on, so that the total mev of the system can be reduced in ways that might be very difficult to do if everything was on single layer. The second thing to keep in mind is that minor extractable value is approximately leader extractable value in the sense that in order to extract value, the person who is best positioned to do so is the person who is the leader. In other words, the person who produces blocks. As a small side note, there are certain protocols like Avalanche which claim to be leaderless and therefore have no mev. Maybe this is true, maybe it's not.
00:06:07.474 - 00:06:48.830, Speaker A: That being said, Avalanche is actually not leaderless. Their C chain does in fact have a leader after a recent upgrade due to the fact that leaderless C chain doesn't actually work. So the fact that if someone comes to you and says, well, you have to think about things differently in a leaderless protocol. No such protocol actually exists today. Every single blockchain that does Turing complete smart contract execution all has a leader. So we're going to approximate it to leader extractable value. Before we start kind of diving into how leaders are selected and stuff, we'll take a little blast from the past here.
00:06:48.830 - 00:07:42.750, Speaker A: I was talking to Giorgios back in August 2019 about some work that I was doing on this design paradigm that was later called Optimistic Roll Ups. And this back and forth here is essentially a discussion on how blocks are produced in this roll up, right? Because a lot of the classical thinking around plasma researchers at the time were around things like exits. You have a single permissioned leader or sequencer, if you want to call it that and so on. One of the primary innovations of this design technique that is now known as Optimistic Roll Ups is that producing a block must be permissionless. And it's not sufficient to simply say, okay, I can force an exit through something, I don't know, an inbox or something because there are certain things on the roll up that cannot be exited. Something like a uniswap liquidity pool, right, that's not owned by anyone. You can't exactly exit it.
00:07:42.750 - 00:08:28.574, Speaker A: Or if you want to unwind your position, you're in some DeFi protocol, you want to unwind your position, you can't exit that. You actually have to force a state transition into the chain. And not only that, users, if their only recourse is forcing a single transaction into the chain, that's not exactly very good. Because it means if the operator goes down or the sequencer or whatever you want to call it goes down, then that means every single user now has to make a main chain transaction to get their transactions in. The property you really want is it must be permissionless for users to post an entire batch of transactions to update the roll up state. And there's a word for that. Well, it's called producing a block, right? So if your scheme isomorphic to producing a block, then you're good.
00:08:28.574 - 00:09:30.178, Speaker A: If it's not, then there's issues somewhere. Those issues could be good, there could be bad, but there are issues. Okay? So at the end here, in my last tweet over here, I get asked how exactly would you make this block production permissionless, right this way of selecting a leader who can produce a block. And I kind of say, well, it'll be an implantation detail and Q people getting triggered because as the researchers and the designers and stuff, we leave the implantation details, all the hard stuff to the implementers. It turns out there's a lot of nuances in the implantation details that get skipped over, that have ramifications in that maybe space. Even though from a design perspective of the security of the optimistic roll up, as long as it's permissionless, then you have your security guarantees. Okay, so now we're going to explore different layered architectures and we're going to point out where is the leader and we're going to see because, again, minor extractable value is analogous or it's very close to leader extractable value.
00:09:30.178 - 00:10:16.510, Speaker A: So we want to see where is the leader to know if this mev is on the L2, if it's on the layer one, if it's on the data layer, if it's on the execution layer, and see if there's nice things we can do to move mev into one place or a different place. Okay, so mev in the monolithic stack, you're doing everything all on a single layer. There aren't exactly many places that mev could where the leader could be because there's only one layer here. But the mev mostly comes from this execution part, this execution module of this layer right there's. Arbitrage. There's reorganizing transactions in a block and reordering rather transactions in a block. So the leader is going to be on the base layer.
00:10:16.510 - 00:10:58.782, Speaker A: Okay, good. We give you a crown here. Now, another model. Let's imagine we have a roll up with a single sequencer. So this is what a lot of roll ups look like on Ethereum today, where you have your roll up execution layer and it settles to the base layer, which in our example, I guess it could be Ethereum. Right? Now, if you have a single sequencer, that's a Proof of Authority sequencer, let's say, right? Where would the leader be? Would it be on the base layer or would it be entirely self contained within the L2 and not leak down into the layer one? Who here thinks it'll be on the execution layer? Please raise your hand. Okay, I see like two hands.
00:10:58.782 - 00:11:31.878, Speaker A: Good. I see three hands. Good. The three hands are correct. Okay, so if you have a proof of Authority leader selection protocol, then the layer one, the base consensus layer, can't actually do anything to stop that person from being the leader. Right? So all of the bad things around leader extractable bad or good things around leader extractable value are in this model, entirely pushed to the execution layer. Potentially this is good because now it means that this mev is not leaking down and it's not bleeding down into the base layer.
00:11:31.878 - 00:12:56.626, Speaker A: And this is very similar in some ways to this notion of proposer builder separation, where the proposers essentially are in a network outside the base layer and all this mev and stuff is contained into that layer. Okay, so let's examine a different leader selection protocol. Rather than something like a single sequencer, let's do something more chaotic like first come, first serve, where literally the first person who submits a block, a rollout block that is valid and that builds upon another valid block and stuff, that they are the ones who are implicitly the leader after the fact. So there's no slots where people are decided to be the leader, just like thrust come for a surf. This case is different because the miners or the block producers at the base layer can actually choose which order people go in, right? So in this case, a lot of the mev will actually leak down into the base consensus layer because those miners can actually decide who goes first. And not only that, they can actually insert their own transactions, so they themselves can go first. Right? So this is an example where this implementation detail, which doesn't really change the fundamental security of the roll up, actually changes something, which is it changes where is Demi B extractable? In this case, it would be the consensus layer.
00:12:56.626 - 00:13:42.578, Speaker A: Obviously, this isn't particularly desirable. Okay, let's do something else. We can think of a tendermint style leader selection protocol. So this is something like imagine you have some tokens, you have some stake weighted thing enough that you just kind of rotate around the leaders on different slots, right? In this case, the actual deciding on who is a leader runs in a smart contract. But beyond that, the base layer doesn't have the ability to, for instance, reorder transactions, to insert themselves to be the leader. It's more like they need to have stake which is completely independent of their ability to reorder transactions. So in this case, the mev would essentially be extractable in the execution layer and it'd be done through this leader selection process.
00:13:42.578 - 00:14:20.634, Speaker A: Tendermint style leader selection process. Okay, so that was kind of like modular monolithic, semi monolithic, if you want to call it that, designs. Let's think about how it would look like in a modular world. So imagine you have what's known as a sovereign execution layer or a sovereign roll up. So this one here is one that posts its data directly to a data layer and essentially self settles. It doesn't have to post its data and post its fraud or validity proofs to something like an EVM. It essentially will execute those fraud or validity proofs entirely client side, entirely locally.
00:14:20.634 - 00:14:55.082, Speaker A: So it self settles. You can think of this largely like a layer one in terms of the fact that it can hard fork or soft fork to upgrade its consensus rules, which is good because off chain governance and all that, but it also shares security with the base layer because to reorg the execution layer, you must reorg the base layer. So it's essentially the best of both worlds. And this is one of the reasons why these modular systems are essentially the future. So we have this sovereign execution layer. Imagine you have a single sequencer. So again, some POA style thing or a tendermint style leader selection process.
00:14:55.082 - 00:15:49.340, Speaker A: Well, this will look a lot like what we saw previously, where essentially the leader selection process is not dictated by the underlying consensus layer, but rather is done entirely within the execution layer's consensus rules. So there's nothing the base layer can really gain by reordering transactions right now, the base consensus layer, if it could completely reorg the chain and do a time band that attack, then yes, the MEB might bleed down into the base layer. This is, of course, why most proof of stake systems, which everyone's moving towards, provide some notion of finality. Tendermint is very good in this. It provides immediate finality as soon as you have a block, 10 seconds, 30 seconds, whatever your number is, immediate finality gasper is a little bit worse at this, right? It has something like six minutes to finality in the best case. In the happy case, it could be forever. But that's another story.
00:15:49.340 - 00:17:10.002, Speaker A: Okay, let's consider a different example where you have a sovereign execution layer, and again, you have a first come, first serve, where literally the first person to post a block to the data layer is implicitly the leader. In this case, just like before, the data layer can in fact change the outcome of what is the canonical roll up chain by reordering transactions on the base layer. Purely so, the mev essentially has leaked down into the base layer if you choose this mechanism for leader selection. Okay, now we can consider non sovereign execution layer. So this one is one that I don't want to call these like L2s or layer threes, because this notion doesn't really exist in a modular blockchain world. But imagine you have an execution layer that posts its proofs, fraud or validity to a settlement layer, and the settlement layer then posts all the data to the data layer, right? This is a pretty good architecture because it allows things like roll ups that exist on ethereum today to very easily just kind of plug in and become execution layers in this model. So where would the leader selection be? Well, it could be over here if you make your settlement layer do first come, first serve block production, right? Or it could also be here if you make the leader selection process be first come, first serve within the settlement layer.
00:17:10.002 - 00:17:52.100, Speaker A: But the settlement layer then had a tendermint style leader selection process to post blocks to the data layer. Or it could be anywhere here, depending on the implementation details. TM. So this is an example where even though the security guarantees of the protocol itself don't change fundamentally depending on which leader selection protocol you use, it does have very significant effects on where across the stack mev is actually extractable from. And I think we would hope that we want to push mev up the stack as much as possible. Although that's not exactly my place to tell. That's probably more of a question for the mev researchers here.
00:17:52.100 - 00:18:07.000, Speaker A: Okay, so if you want to find out more about what we're doing, our website is Celestia.org, our GitHub is celestia.org, and our Twitter is also@celestia.org or you can also follow me on Twitter at jadler zero. And with that, I guess it's time for questions.
00:18:19.600 - 00:18:37.228, Speaker B: So I have two questions. One is very basic about just how to understand what modular blockchains are and then one that's more specific to mev. The mev one is why do you say we should push it up? What's your intuitive thinking around moving it upwards rather than downwards?
00:18:37.404 - 00:19:19.650, Speaker A: The intuitive thinking is that well, it's the same reason that people want to have proposer builder separation in e. Two is that if you move it upwards into the stack, then failures are contained to there, while if it's lower in the stack, failures or increases in cost and so on. And disruptions from the mev actually affect everything above, which if you just have like a single if you have a single layer of okay, data layer, then settlement layer, then execution layers. It's not exactly very important, but we expect in the future to have many, many execution layers and many settlement layers. You don't want the mev of one settlement layer to bleed down to the data layer and then affect everything else.
00:19:20.580 - 00:19:39.624, Speaker B: Got you. And then probably a really basic question, but could you explain again why the roll up model doesn't actually solve for what the truly modular structure does? You had mentioned that when it's a roll up it doesn't solve very much from what a monolithic blockchain would do.
00:19:39.822 - 00:20:29.312, Speaker A: Yeah. So the issue with a roll up on top of a monolithic chain is that in order to use the monolithic chain, which does data availability, consensus, execution and settlement altogether, to use it, you actually have to make sure that it's valid, which means you have to do a whole bunch of work. Like if you try to run an ethereum full node, it takes somewhere like 650GB just to run an ethereum full node today. And that if you keep it running it's going to quickly grow to 1 TB. Then you have to turn it off and prune it and stuff. And it requires a fairly powerful computer to run an ethereum full node. So this is where yes, it's partially modular in the sense that you're offloading some execution, but if you don't remove execution from the base layer, then every single roll up must also, for instance, run a ethereum.
00:20:29.312 - 00:20:48.310, Speaker A: Like if you're doing this in Ethereum, every single roll up must run an ethereum full node to have any security guarantees, which is obviously not great. You would want that base layer to be as minimal as possible and to be usable as a shared security layer. Thank you. I think we have the discussion now. Thank you.
