00:00:01.050 - 00:00:59.920, Speaker A: All right, thanks everybody for joining. Really excited for you all to be here today. We're going to be talking about Share Flashbots protocol for users and searchers to collaborate and for users to get paid the mev that they generate. We're going to be starting off with a high level overview of Mevshare, what it is, how it it's designed and how it works. And then we're going to walk through an open source code base called Simple Blind Arbitrage that the Flashbots team created in open source as an example of how you might write a searcher that interacts with Mev Share and uses some of its unique qualities. We're going to be walking through this open source code base, but keep in mind, you should really understand this thing. You should understand its smart contract, how to interact with it, what it is doing if you want to run this thing yourself or put any money to it, into it.
00:00:59.920 - 00:01:11.278, Speaker A: So without further ado, I'm going to turn it over to the legendary Scott FF to give us an intro to Mev Share. Scott.
00:01:11.374 - 00:01:48.842, Speaker B: Cool. Awesome. Thanks, Bert. So we're going to do a really quick overview of basically why Flashbots made MAV Share by kind of outlining some of the problems that Mev Share is solving. To talk about those, we're going to first discuss what Ethereum was like. Kind of since the beginning, we've always had this Mem pool of transactions, right? We've had transactions that before they land in blocks, they're shared with absolutely everybody. And very shortly after this, we had searchers that came along and realized that they could see transactions in the Mempool before they were confirmed and they can take actions on these transactions.
00:01:48.842 - 00:02:50.206, Speaker B: One of the things you can do when you see a transaction before it lands in a block is that you can take this transaction and put your transaction right after it in order to take advantage of whatever this transaction was doing. As an example, this transaction could be making a very large swap order on, say, uniswap. And that large order has created an arbitrage opportunity. And if you come right after them, you are going to be the first one that is able to collect the Mev that was created by this first transaction. With the advent of Flashbots, we were able to take these transactions and put them into a bundle which get delivered to a relay that can bring these two transactions together at the same time. The problem comes along when searchers see these transactions and are able to, instead of putting their transaction after the user transaction, they put their transactions before. And when they do this, they can influence the behavior of the user transaction.
00:02:50.206 - 00:03:32.142, Speaker B: They can say, let's say that this user was trying to buy an NFT. They could have seen this transaction in the Mempool where somebody else wanted to buy the NFT and they buy it first. And in that example, we don't even require any sort of bundling, right? So all that the searcher needed to do was to see this user transaction in the mempool and say like, oh, you know what, I'm going to do this first. And they don't even care how this transaction lands. So we don't even need a bundle for this, right? This doesn't require flashbots or bundling or anything. This just requires seeing a transaction and taking an action before they do. So the problem with the mempool is that searchers and everybody in the entire world sees it.
00:03:32.142 - 00:04:06.314, Speaker B: It provides full details of all the transaction. You can see everything that transaction is trying to do and simulate it on a node and see what it's going to do on the chain when it lands there. And it means that searchers can front run these transactions either by doing this action first or by including it in a bundle and influencing the behavior of that transaction because that transaction is going to come second. And so it's led to users using private mem pools. You've probably heard about some of these. We have like Flashbots protect, we have a number. I remember one inch, ran one for a while.
00:04:06.314 - 00:05:01.510, Speaker B: There's a large number of these where users, instead of putting their transaction in the mempool that everyone can see, there is this other pool where no details are leaked to anybody, only to the miners originally and now to the builders and validators such that nobody else can see these transactions before they land in a block. And so users have started to give their flow here. They've given their transactions to these private mem pools because no details go here. But it's kind of been a regression because now we have what we call top of block gas wars. What that means is that this user transaction lands in one block. There is now a race in the very next block for all of these other searchers, all trying to take advantage of that mev and fighting with each other. This usually involves a large number of competitive transactions that are trying to outcompete each other and to use higher fees.
00:05:01.510 - 00:06:01.422, Speaker B: And it creates a worse experience for ethereum all around. There's a lot of wasted block space, there's high gas prices. And so the question is coming back here, how do we create a system that enables this, right? Because in this circumstance where the searcher transaction comes after the user transaction, this user transaction is not affected in any way and the user doesn't really know or care that somebody did something after. So how do we enable this while at the same time avoiding this scenario or this scenario, right, where the searcher can influence the transaction or just do whatever they wanted to do first, preventing them from doing it? And the answer to this question is that there's something in between a mem pool and a private mem pool. We're calling this service. Mev share. And the idea behind mev share is that users will give transactions to the mev share pool, just like you might give it to a private pool, but it's going to share some of the data.
00:06:01.422 - 00:06:28.774, Speaker B: Not all of the data, but a very small subset of the data with a searcher and enable the searcher to look at this subset of data. In this case, as an example, the subset of data is uniswap B two ETH, Pepe. They're saying that this transaction the user has provided has interacted with this uniswap liquidity pool in some way. We're not saying what they're doing. They could be adding liquidity. They could be buying Pepe, or they could be selling Pepe. We don't know.
00:06:28.774 - 00:07:07.710, Speaker B: But the searcher can take that limited amount of information and say, okay, well, maybe if you're interacting with this uniswap pool, maybe we can arbitrage and buy on sushi and sell on uni for Pepe specifically. And then you can give this back to the mev share pool in order to see if that is a reasonable bundle to provide. But we also don't know if they were buying or selling. So maybe we need to try this transaction the other way. For that exact same transaction, we'll send another mev share bundle back to the mev share pool. We also might try other liquidity pools. Hey, maybe they're doing this on uniswap b two, and there's uniswap b three liquidity.
00:07:07.710 - 00:07:54.014, Speaker B: And this transaction has bought so much Pepe that there is now a price discrepancy between b two and b three. And we can use that price discrepancy in this transaction. But the searcher does not have enough information to either prevent them doing what they're trying to do. They don't even know if they're trying to buy or sell, so they can't get in front of them in line, and this system will not allow them to give a bundle of transactions back. That puts the user transaction second. The user transaction always has to come first in the bundle that comes back to the MEB share pool. And so this is great for the searcher, right? The searcher now has an ability to be the next transaction after a potentially interesting transaction is about to land on chain.
00:07:54.014 - 00:09:05.846, Speaker B: But the question is, why would the user do this? Why would the user use an mev share pool instead of a private MEMP pool? What's in it for them? Right? Their transaction lands first, and it's unaffected in the same way. And the reason is because this mev share system, when it lands this bundle here, let's say that this is the one that ended up being profitable because they were, say, buying Pepe here. And so we were able to sell Pepe and buy it and kind of create an arbitrage loop with this particular route that we just guessed might be available. The fees that are generated from this transaction here, which are often very, very high, are split inside the Mev share system and a large portion of the fees that went into this transaction become a new transaction that is injected by Mev Share that lands on chain and rewards the user by just sending them ETH on chain directly after this bundle landing. As an example of this, the system is live right now. It's been live for a little while and we've seen some adoption of searchers doing this and also order flow. And here's an example on chain.
00:09:05.846 - 00:09:37.962, Speaker B: We can go look at it in a second. But what we're seeing here, remember, these things are it's ether scan. So things are kind of ordered backwards. This is the first transaction. This user interacted with a swap router and performed a swap. This transaction here is the Mev extraction transaction where they took advantage of the new price that was created based on this swap happening. This created an arbitrage opportunity that paid the builder a pretty decent amount of ETH.
00:09:37.962 - 00:10:25.186, Speaker B: And in this transaction here, this is the last transaction in the bundle. You can see that the builder paid this user back, in this case, zero point 38 ETH for providing that bundle flow in the first place, right? That's the reward for giving the system the transaction as opposed to just privately relying it. So their transaction landed without being copied by someone else, without having its execution changed by another transaction coming through it. And they also got a kickback on chain that is theirs to keep. If we look at these transactions really quick, I'm opening this up in a new tab here. Go down to builder. Here are those three transactions here.
00:10:25.186 - 00:10:55.854, Speaker B: I think it's worth looking at each one of them real quick. This first transaction we see, this is them interacting with this swap router. They are interacting on this refund token. It looks like they are selling this token for ETH. So I'm going to close this. I'm going to open up the next one. This is the searcher, right? This is somebody who could have been running simple blind arbitrage or maybe a version of it they modified or just something that operates in the same way that simple blind arbitrage does.
00:10:55.854 - 00:12:08.600, Speaker B: But we can see that they were able to get zero point 88 ETH in Mev out of that Arbitrage opportunity of which they gave zero point 44 to the builder as a reward for including this bundle. And zero point 44 they kept for themselves, right? This? Is this BA 20? BA 20. So they paid themselves zero point 44 ETH as a reward for landing and they only had to pay 0.1 in order to in transaction fees. And so, keep this number in mind, zero point 44 go back to that final transaction that pays out the user. I'm opening this up in a new tab. So of that zero point 44, the builder kept a small portion for themselves and paid zero point 38 ETH to the originator of that transaction that created the Mev I think that's a good time to stop and maybe ask for questions or see if Bert or Brock want to chime in here on anything.
00:12:12.250 - 00:12:16.962, Speaker A: We had somebody asking for slides in the chat. You don't mind sharing?
00:12:17.106 - 00:12:27.786, Speaker B: Course, of course. How should I share you? I'll give them to you. I'll put them right there, right? Yeah.
00:12:27.968 - 00:12:29.260, Speaker A: And then I got it.
00:12:30.270 - 00:12:30.970, Speaker B: Cool.
00:12:31.120 - 00:12:32.780, Speaker A: Let me see if I can get that.
00:12:35.790 - 00:12:36.214, Speaker B: Okay.
00:12:36.272 - 00:12:37.600, Speaker A: Looks like they're free.
00:12:38.210 - 00:12:45.360, Speaker B: Yeah. So the question about the average rebate so this is a very new system that doesn't work.
00:12:46.290 - 00:12:47.646, Speaker A: No, it worked for me.
00:12:47.828 - 00:12:52.260, Speaker B: Yeah, well, you might be I think that's because you're Flash bots. Oh, that should work.
00:12:53.190 - 00:12:55.060, Speaker A: No, I opened it on.
00:12:56.310 - 00:12:57.060, Speaker B: Okay.
00:12:58.790 - 00:12:59.154, Speaker C: Yeah.
00:12:59.192 - 00:13:36.382, Speaker B: The question is, it's a good question. What is the average rebate? The average rebate is still kind of being determined right now. This is a brand new system, and it's been live for some number of weeks. We've had several, I think probably on the order of, what, 40 or 50 kickbacks so far? Land on chain somewhere in that neighborhood. So it's a very, very new system. We're still attracting order flow. We're still attracting searchers and building this marketplace of people providing order flow and searchers that know how to operate on that order flow to extract mev.
00:13:36.382 - 00:14:09.146, Speaker B: That has a majority of it going back to the user, I will say that there's recently been a 1.2 E kickback that occurred. Several days ago, there was an Oracle update. In one of the transactions that Oracle update went through our order flow system. And the person who updated the Oracle got 1.2 ETH back as a reward for one searcher who wanted to put a transaction immediately after it. If everyone is using the service, the service becomes a semi public.
00:14:09.146 - 00:14:35.506, Speaker B: I mean, yeah, it is semi public, right? Actually, that's a really good question. Semi public. Let's talk about what semi public means. And to do that, we talked about this component here, right? This stream of transaction hashes with hints about what is happening in those transaction hashes. We can actually pull that up in our browser very, very easily. It's one of the kind of the cool things about mebshare. So I'll pull that up right now.
00:14:35.506 - 00:15:20.882, Speaker B: If you just go to Mebshare flashbots net. This is an endpoint that will stream the transaction flow to anybody who asks for it. So if we just sit here and wait for a second. There we go. We have the transaction hash, and then we have logs here. So the MV share system actually, let me get the font size here a lot. We have the Amoeb system simulated the transaction that was sent to it, grabbed the address, grabbed one of the log topics and sent that along in this endpoint that others could look at that, decide if they wanted to try to backrog it with several transactions that could extract mev and feed it back to the system.
00:15:20.882 - 00:16:08.850, Speaker B: So here we can see another transaction that all that it shares is the hash. So when we say programmable privacy, we mean that whoever submits the transaction is the one that is allowed to determine how much of the transaction is leaked. In this case right here, they said nothing like, the only thing you can leak is my transaction hash. And from that searchers would have a really hard time landing opportunities. But if a searcher knows the time frame of an Oracle update, which was the case a couple of days ago, just by knowing the time frame, is that, hey, in this ten minute window, just knowing the hash, I will try to backrun everything in this ten minute window in order to distract mev. And it ended up being successful for them. So they were able to backrun something without knowing anything about it except for the general time frame of it being released.
00:16:08.850 - 00:16:32.266, Speaker B: Yeah. So here we see all of this data that is being streamed that is partially anonymized. Here we have let's see, is there anything more? Do we have anything that does selectors? Yeah, we haven't seen there's other things that can get shared besides logs. There's the contract address you interact with. There's the function selectors of the call data.
00:16:32.448 - 00:16:33.180, Speaker C: And.
00:16:35.230 - 00:16:47.950, Speaker B: I think that's it. Right, I should have the actually, can you post a link brock or Bert to the maybe share documentation? Pretty sure there's one more that I'm forgetting.
00:16:49.250 - 00:16:50.190, Speaker A: Yeah, I got it.
00:16:50.260 - 00:16:50.638, Speaker C: Cool.
00:16:50.724 - 00:17:15.954, Speaker B: Yeah. Here we go. So here's somebody who sent a transaction that was willing to share oh, yeah, here we go. Full call data. So they were willing to share what they were sending it to, what the function selector was, but not what contract address it was entering for. Yeah, that's pretty interesting. Right? So they get to choose what gets shared, and it can be up to the wallet that might be making these determinations.
00:17:15.954 - 00:17:34.010, Speaker B: It could be up to the user. But the idea is that the user gets to control instead of being stuck with this kind of dilemma that we had before of are you going to go to the mempool or are you going to go to the private mempool? The users now have more control over what gets shared ahead of their transaction, landing completely on chain.
00:17:34.170 - 00:17:46.574, Speaker A: Reese says, so I can expose my transaction hash and potentially get a kickback if someone extracts my mev. Someone extracts mev post my TX. But since it will be harder for them to do so, I also have higher chance claiming any post mine.
00:17:46.622 - 00:18:44.258, Speaker B: Well, yeah, mev extraction, it's kind of a bit of a specialty, right? It's fairly difficult to do. But mev is created, by the way, by let's say that you are making a large order for ETH Pepe and you go straight to one uniswap market to do so. Let's say you only do uniswap b two, even though there's like three other very good markets out there to choose from. Mev is really created because that transaction really should have gone to all the sources and bought enough that it kind of kept the price you got the best price for the user. So a lot of times the reason this mev is created is because the user didn't create the right transaction in the first place that could have kept all of these pools more in price parity. And so, yeah, if you can extract your own mev, you probably just create a different transaction in the first place. It is more difficult.
00:18:44.258 - 00:20:01.790, Speaker B: The less you share it, the more difficult it is for searchers. And so the less kickback you get. And you might not get any kickback, right, because eventually, because Mev shares will also just bring your transaction to the chain on its own without any sort of a kickback if nobody has bid on your transaction, which is probably the normal operation of the system, right? Because if you're just saying, hey, I want to send my friend three E, you're not creating any mev. There's nothing that anybody can do right after that that they couldn't have done before. And so there's a set of transactions that can extract mev, and if one of them users don't generally extract their own mev, they would have created a new transaction in the first place, I think is really the answer there. Okay, so now that we understand kind of this component here, right? So basically this component that reads this stream of transactions, looks at them and then dreams up bundles and their own transactions that could go after the target transaction that may or may not make money based on the limited information they have. I wanted to introduce you to a simple repo.
00:20:01.790 - 00:20:58.774, Speaker B: Actually, let me show you to it in GitHub first, we're calling this. So the first thing we created a long time ago is called simple Arbitrage. There was one of the first before the Mev Share, like when Flashbots first launched. So this is simple blind Arbitrage, because this uses Mev Share, and using limited information such as what address did this interact with without even knowing if it bought or sold, is able to make Arbitrages by just sending a large number of them back to the Mev share system, right? Just like here, right? So this is basically what the system does. Simplebind Arbitrage reads, creates two bundles looking for like, hey, do I sell this way? Or hey, do I sell this way? And provides them back to MAB share. Okay, so I already have cloned this and pulled this up in an IDE. And Brock or Bert, if you want to chime in here, I'd be more than happy to have some backup here.
00:20:58.774 - 00:21:09.100, Speaker B: But the whole system, let me just kind of just walk through the code really quick just to show you how little of it there really is. So there's this index. What was that?
00:21:10.110 - 00:21:12.694, Speaker A: Yeah. Here to chime in wherever.
00:21:12.742 - 00:21:13.002, Speaker B: Awesome.
00:21:13.056 - 00:21:13.322, Speaker C: Yeah.
00:21:13.376 - 00:22:03.818, Speaker B: If you am, please feel free to interrupt me. But the first thing that I really wanted to draw your attention to is just like how little there really is to this code. So there's this index which just sort of like looks at some options, sets up a few network connections, and then has this little loop here where it kind of does some evaluation. There's a little bit of code over here kind of for how to look at uniswap pools and the bundle executor, which formulates the request. Those little, like two, but, you know, two transaction bundles and sends them off to the off to the matchmaker as a potentially profitable bundle to include. You can see like, this thing's like half, you know, half comments. There's really not a lot to it.
00:22:03.818 - 00:23:03.642, Speaker B: This isn't an overly complex system. I do want to take a moment here before we get started to say that running this in its current form is almost certainly not profitable because there are many people who do this and there's only a limited amount of mev out there. The real reason that I wanted to go through this isn't to convince you to just clone this and run it. This is a really good place to build from and apply other ideas that you have for Alpha about, hey, maybe if I look at this way, hey, maybe if I instrument this pool over here, or maybe I buy the tokens and take on some liquidity risk and sell them in the next block. This is really a framework to build off of, and that's why it's so simple, is because it really wanted to be easy to understand and extend without being profitable in its current state because it's too easy for everyone to run it and just use the same logic. And all the mev kind of competes with each other and everything gets bid down to no profit whatsoever. So this is definitely not a get rich quick presentation.
00:23:03.642 - 00:23:14.930, Speaker B: This is something I wanted to show to help you build your version of what this might be or to adapt this to some other strategy.
00:23:15.750 - 00:23:41.546, Speaker A: I did add a branch, if you're interested, that uses a Flash loan for liquidity. It needs a little bit of changes to the index JS file in order to make this work. But if you're watching this and you don't want to get started with your own capital, you may be able to use the Flash loan with this as well. So you're not putting any air funds at risk. You can just deploy a contract, get.
00:23:41.568 - 00:24:11.026, Speaker B: Started, yes, but still, getting started is not a decision to be taken lightly because, well, for instance, one of the first things you need to do when you are interacting with the system is you need to come over to this environment file. Right, so we are in. This is the zoom in there. I don't know if I can zoom in. So this is the file structure of the system and under Execute, which is where all of these scripts live. There are a bunch of files here. One of them is the env.
00:24:11.026 - 00:24:39.786, Speaker B: So in this case, we need to have an RPC connected to you. You might use in fiora. Most people who are searching have their own high performance servers that they use, that they operate. This private key is not valid. There's just some bunch of data that I found. But you need to literally go get a private key that has money in it and copy and paste it and put it in here. And so that is a very kind of dangerous thing to do, right? This is a hotkey that you're running in here.
00:24:39.786 - 00:25:12.360, Speaker B: You could be accidentally committing things. You could go to get push something to GitHub on accidents and all of a sudden your private key is compromised. So be very careful with that. And we also need to deploy a contract that is included in this repository that I think we should probably go through first and then put that contract address here. So these are some fairly technical steps that are needed in order to set this up. I think it's worth talking about the contract first, actually. Bert, did you want to kind of go over the contract or did you want me to do that?
00:25:12.970 - 00:25:15.226, Speaker A: Go over the contract? Yeah, you want to pull it up?
00:25:15.248 - 00:25:16.300, Speaker B: Yes, we're there.
00:25:16.990 - 00:26:21.162, Speaker A: Yeah. So I was a bit lazy in my Forge deployments and there are a couple of different contracts here. But in the simple blind arbitrage root repo, you go to source and then blindback run sol in order to find the relevant code. And there's another one for debugging and testing, which is useful if you want to run the Forge scripts or do any sort of debugging of this and pinion around. And if you look through the code, the main path that matters here is this one function, execute arbitrage. It takes in two pair addresses and a percentage to pay coinbase, which comes up later. And remember, the context in which you're calling this function is that you have partial information that has been leaked by the matchmaker about a user's transaction.
00:26:21.162 - 00:27:21.460, Speaker A: So the matchmaker will tell you, hey, a user is swapping on the ETH USDC pool on unisoft v two or unisop v three, but it won't tell you how much they are swapping. And just with this information of the pair that a user is swapping, you can go and find another pair of the same type ETH USDC on sushi swap if the user is trading on uniswap v two and look for an arbitrage between these two different pairs all on chain. So that's what we're trying to do here. We take in two pair addresses and we're looking for an arbitrage between them doing all those calculations on chain. We start by setting up some structures. So you got to tell Solidity that these things are pairs and we get some data from them. If you go to the get pair data function, Scott, we can see what data we're returning here.
00:27:21.460 - 00:28:31.718, Speaker A: So we give it a pair and what we get back from it are the reserves of that pair. So the amount of tokens of ETH or USDC to keep on using this example, we log whether a token is WETH or not. So you want to know which token either the first or the second in the pool or the pair is WETH because this is helpful in calculating the arbitrage and knowing which direction to trade. And we calculate a price which is just we calculate a price which is the reserves divided by each other and then doing some stuff to handle decimals in the token. So we have this information, we return it back and we start calculating our arbitrage. Further in where a lot of the magic happens in calculating the arbitrage is this function called Get amount in. Long story short, uniswap v two.
00:28:31.718 - 00:29:43.118, Speaker A: Since it is a relatively simple mathematical formula for X on chain, you can actually calculate an optimal trade given the state of two uniswap v two pools and down to the single way with the optimal amount. I won't run you through the exact code here, but know that this Get amount in function uses that optimal trade calculation and calculates it all within Solidity. It's like fairly complicated math. There's a numerator part and a denominator part. One of the complicated parts of it is handling tokens because your tokens may have different decimals and you need to make sure that they don't overflow or underflow at some point. But this get amount in again takes the state of the pairs that we had just gotten a moment ago and it calculates what the optimal trade is on chain using this somewhat simple mathematical formula which is complicated to look at written in Solidity. Okay, so we have the optimal amount in.
00:29:43.118 - 00:30:51.378, Speaker A: Of course, we need to know more than that. We need to figure out how much am I going to get out for this, given what we sent in, and then how much am I going to get out on the other side. But first, in order to make swaps on uniswap v two pairs, you actually have this interesting thing where you need to optimistically send the tokens before you call the swap function. So this line that Scott has highlighted is us sending the amount into the first pair address that we are trading on before we call swap on it. Okay. So we have our amount in, we transfer it. We calculate below, depending on then depending on whether the first token in the pair is WETH or the second token is WETH, we change sort of which token we are trading and buying on first.
00:30:51.378 - 00:31:44.754, Speaker A: That's the if statement there. We sent. In our WETH to the first pair, we calculate how much we're going to get out from the first pair given that amount in, weft that's first pair amount out, given how much of the token and first pair amount out that we're getting. We then calculate the final amount out, which is the weft that we get on the other side, completing the arbitrage. And then first pair swap and second pair swap are us actually executing these trades on chain, if that makes sense. Again, note that there is this interesting thing about how uniswap pairs work in their swaps where you need to send tokens to them first and then call the swap function. So we first send WETH to the first pair on the first pair.
00:31:44.754 - 00:32:48.390, Speaker A: When we make that swap, we set the recipient address of the tokens we're swapping out of the first pair to equal the second pair, and then we call swap on the second pair, setting the recipient address to be our contract for execution. All right, so to recap here we have this smart contract. It takes in two uniswap V, two pairs as inputs. It gets some data from both of them and then uses fancy calculus, fancy math to get the optimal amounts in. We then handle execution of that depending on whether the first token in a pool or a pair rather is WETH or whether the second one that's the if statement. And we handle kind of all of the trading amounts based off of what the optimal amount in is. So the first para amount is equivalent to how much of whatever token you're swapping to you're getting in return for your ETH.
00:32:48.390 - 00:33:22.580, Speaker A: And final amount is the amount of ETH that you're getting in return for the token that you're swapping to. In theory, final amount out should be larger than amount in. And you check that with these require balance after. It's greater than balance before requirement. Here. Then the last bit you can read over. Everybody is just making sure that we made some or if we made profit, paying some amount of it to block coinbase transfer, which is the fee recipient, the block builder in this case.
00:33:22.580 - 00:34:18.662, Speaker A: One thing that I will note here is that this contract just enforces the narrow condition that your balance after is greater than your balance before. But it is possible that you made a super small WETH ARB. You made like one WETH at the limit worth of profit and the gas fee that you're paying for the overall transaction is larger than your WETH profit. So a smarter way to do this would be to require that your balance afterwards is larger than the amount of profit that you made plus the transaction fee that you're paying for your overall transaction. A very simple way to do this is that you're making like the profit that you have is greater than 0.1 E or something like that. Yeah.
00:34:18.662 - 00:34:26.578, Speaker A: So that's the smart contract fairly simple. We just calculate an optimal arbon chain. Anything to add scalat or Brock?
00:34:26.674 - 00:35:14.406, Speaker B: No, I think that the most important part here is this when you require that the balance after is greater than balance before, this is a very important line just because the matchmaker is constantly evaluating whether your transaction is profitable and succeeds and it's really important that you fail. Right. Your failure here is how you tell the matchmaker that you don't want to do this because this is still a valid transaction, but you're indicating that it's not going to make you money and therefore please don't include it. Yeah. And just the amount of math we have to do on chain is because of the mev share system, not sharing the direction of the trade with you ahead of time. Normally this is something that you would do off chain and pass into your contract. Right.
00:35:14.406 - 00:35:25.770, Speaker B: So you wouldn't have to do all this math on chain, but because you don't know anything about the size or direction you need to calculate on chain so there is a little bit of difference in how your contracts operate.
00:35:27.970 - 00:36:01.974, Speaker C: Yeah. I think this is a good time to mention too the differences between off chain and on chain, which calculations you can or should do on or off. So one thing that stuck out to me when I was reviewing this code was can you go back up to, I think it's line 76? It's the line that checks the wrapped ether balance. So one way to make this more efficient would be if you're on univ two, you can deterministically calculate how many tokens you're getting out.
00:36:02.012 - 00:36:02.166, Speaker B: Right.
00:36:02.188 - 00:36:55.130, Speaker C: So you don't actually have to check your balance and that would be an optimization for gas. But if you have, say, like a poison token where it could lie about your balance, then you're kind of stuck with the same problem. So like here, checking the balance works because we have wrapped ether hard coded and so we know that the contract isn't going to lie to us. But there are still vectors on chain where checking the balance might not be the only assertion that you need to make to know that you actually made a profit. It's important to consider the data that you have access to in the context.
00:36:56.110 - 00:37:34.120, Speaker B: Yeah, right. There could be malicious things that come through in here. It could be somebody like made up a token that looks like there's an arbitrage opportunity, but when you try to take it, it lies about it. I believe that simple blind arbitrage has good protections in there based on that wealth balance. But yeah, like you're saying, if you think, oh, I'm going to grab some pepe four token and as long as I have more of it at the end, I feel like I made money. And you don't know anything about whether that token is valuable, about whether the balance can't just be taken from you later. So be careful, like what you accrue your searcher balances into.
00:37:38.330 - 00:37:57.290, Speaker C: Another thing is, I think it would probably be wise to have a cache of valid tokens, maybe do some off chain investigation and make sure that you're not just aping into scam coins.
00:37:57.710 - 00:38:17.586, Speaker B: Yeah. Okay. So now do you want to hop over to the actual executor? Now this is like the client side version that's going to create the transactions and bundles that go to the matchmaker after subscribing. Is that a good time? Actually? Should we check on the does the troll box?
00:38:17.688 - 00:38:21.282, Speaker A: Yeah, I'm in the troll box. You can trust me on that.
00:38:21.336 - 00:38:39.746, Speaker B: All right. Okay. So this code here really just looks at arguments you pass in. This is kind of boilerplate stuff. We need to have a connection to Ethereum. You're going to need an RPC URL in order to look up things to look up, like the pairs.
00:38:39.778 - 00:38:39.926, Speaker C: Right.
00:38:39.948 - 00:39:13.746, Speaker B: We saw a lot of the we're going to be passing in pair information, uniswap pair information, like which tokens on one side or the other. Is this is it WETH? So that's going to be important here. Signers are what we use for reputation in Flashbots. Well, actually, this is like the real one, isn't it? Right. So this is going to be the wallet that signs your transactions that pay for the gas. Right. So in this scenario over here, these are real signed transactions and you need to sign them with an account that actually has some ETH to pay for gas.
00:39:13.746 - 00:39:26.794, Speaker B: And so we need to provide that to the simpleblind arbitrage. Yeah, the bundle provider. Actually, I don't think this is actually used in this repository. I think we just ripped that.
00:39:26.832 - 00:39:31.420, Speaker A: Yeah, I think I added it there and I actually couldn't ever use it.
00:39:33.470 - 00:40:11.606, Speaker B: And the pool manager is just a bit of code to look up various bits of information about the uniswap pool. So, like I said, like, figuring out, is this a weth based pair? Because if it's not a web based pair, we can just move on. We don't need to do any further evaluation. Connect to whether you want to connect to Mainnet or Gorely. Both of them are supported by the matchmaker. These are all configured in this config JSON, where you can find all their URLs and the factory addresses for uniswap in order to perform some of these verifications of these pairs. But this all comes standard.
00:40:11.606 - 00:40:18.442, Speaker B: You don't need to type this in. This is in the repository. Yeah, if you wanted to.
00:40:18.496 - 00:40:39.646, Speaker A: Also, it's probably just a little bit of profit extra to make. You might find a few more ARBs if you added the other uniswap V. Two forks. There are a few more that's in the OG simple arbitrage repo that are not in the simple blind arbitrage. I forget what they are, but there's like Zeus or something like that.
00:40:39.668 - 00:41:07.466, Speaker B: I remember that one. Yeah, there's a bunch of ones. Usually they get a little some liquidity at first, but every so often there's one of these uniswap clones that becomes like the place that you exchange one type of token. Anybody? A lot of liquidity just for a small number. So yeah, really that's where you can take this and turn it into your own and say you could add a bunch more. You could add uniswap B three, which is going to be very complicated with the way that uniswap b three is different from b two. But again, the harder it is, the more likely it is that somebody else didn't do it.
00:41:07.466 - 00:41:56.198, Speaker B: And the more likely you are to be finding like novel mev that you're not sitting there and having to bid 100% to get included on chain because you're competing with others who are doing the same thing. So, yeah, we create an event source. This is really just connecting to that endpoint that I pulled up in the browser that was streaming that data to us. And again, this just comes right out of that config, knowing where the URL is and when you attach an on message callback to it, this just gets called every time a new message comes down the pipe from that endpoint that we were looking at. One thing that I think is I like to do when I'm evaluating this kind of code is I'm going to delete all this code. Literally just delete. Okay, in this case, all we're going to do is really log the data that's coming in.
00:41:56.198 - 00:42:22.900, Speaker B: So we look at the data in there, we make sure that logs are present because without logs, we can't really know whether something is a uniswap transaction or not. So we're just going to skip everything. It doesn't even have any logs. We're in debug mode. And so we've paused execution here and now we can evaluate this data structure that got parsed from everything that came here. And so let's pull that up. Sorry, I don't think I can increase the font size in this window or down here.
00:42:22.900 - 00:43:05.822, Speaker B: So sorry. This is a little bit on the small side, but here you can see this is really just a structured representation of the data message that we were getting from that stream. And from here we can look at the logs, right? This is the log. This is the first log in it. And we can see that this log topic is zero X D 78 Ad. So we actually got kind of lucky here because remember that. So I'm actually going to copy this value because when I undelete this code, just going back to the way it was before, the first thing we do is we say, hey, is that first log this? And if you look at it, it's that.
00:43:05.822 - 00:43:52.334, Speaker B: Right? So we got lucky in that we actually the first message we processed was one that we would be interested in. It is a log message that gets emitted when a swap occurs on a uniswap, on a uniswap pair. So this is the way that we use that partial data to conditionally move forward or not move forward with processing. So just like before. So we're going to look at data logs. I address, we can see this address here. Again, you probably can't see that very well, but that is a uniswap pair address, right, saying, oh, this address emitted a log, right? So let me see if I can actually copy that and go look it up.
00:43:52.334 - 00:44:15.030, Speaker B: Right? So this is how you would kind of create your own custom searcher logic. So I'm going to copy that value. I'm going to come over to my browser, look at it. Yeah. So here we have a uniswap V, two pair. And remember that D seven, eight. Remember I said that zero x, D 78 topic that maps to this swap function.
00:44:15.030 - 00:44:40.302, Speaker B: So it's like, this is what we are targeting. We're targeting a swap having occurred inside of that transaction. But if we go back here and look at the rest of it's like, oh, well, we don't even know how much see, it zeroed, all these values. So you don't know how much is being swapped here. You just know that swap is being called. These have been anonymized. So we have the address of the pair we're interested in.
00:44:40.436 - 00:44:42.106, Speaker A: We use what's the token?
00:44:42.298 - 00:45:08.134, Speaker B: The token, good question. It has a decent amount of bonito. Just kidding, I have no idea what that is. But yeah, so it's like we know this is the bonito token. And so as we check the pool, we can now query it for what its tokens are. Is one of the tokens WETH? Well, come over here. We know that's true.
00:45:08.134 - 00:46:01.302, Speaker B: One of them is WETH. It maps to these contract, like these contract addresses over here, these contract values over here, token, zero token, one that's WEF right. So we're going to fall to the next part where we return the tokens that we extracted and we say, hey, you know what, this was uniswap, right? If we see that uniswap is what this token is, in case it will be right, because the factory that created it, again, which is a function call over here, this function call, that maps to the uniswap factory. Then you know what, here's the tokens you're interested in, by the way, go check Sushi. Go find the Sushi address for this so we can pass it in. So but we're back in index now. We're actually paused in execution right here.
00:46:01.302 - 00:46:58.090, Speaker B: So, yeah, we know the tokens, we know the other side of the arbitrage that we should check. We go and find the pair address for in this case, it will be sushi for these two tokens. Once we have that first pair and second pair, all that's left is taking these and bundling them up into two different bundles that go to the that go to the matchmaker. And the reason it's two is the way that we structured this is when we saw one transaction like, hey, let's try to go sushi to uni and let's try to go uni to sushi. We made those two different bundles. You could make them the same transaction, but you kind of have an advantage here where you can kind of save gas. You only need to check one thing or the other because the entire transaction will be excluded and you'll have used less gas in the one that succeeds.
00:47:01.680 - 00:48:07.650, Speaker C: Yeah, I think this is another good time to point out the logic behind gas optimization and separation of information here to get the most gas efficient execution, ideally you just want to be doing the least amount of computation. So I think the best way to design your contract in this case is you want to have one function for each sort of logical path. So you would have like one optimization I can think of is if, you know, on the pair wrapped Ether is token zero, then you can have in your smart contract, like one function for when the token is zero and one for when wheat is token one. And that way you're cutting out an if statement in your execute function because you can get that data off chain. So like, in any case where you can get that data off chain, you want to do that.
00:48:09.460 - 00:48:48.460, Speaker B: Yeah, exactly. Right, so there's extra gas that a system like Mev Share Incurs. Because you need to do more calculations on chain, but you can combat that with the gas savings that systems like Mev Share can give you because you can just give a whole bunch of bad transactions to it and one good one. And you don't need to have all this if logic in the transaction that actually lands on chain. Right. You don't pay gas for anything that doesn't land on chain. And so you can do all your checks and fail and then not pay for any of that gas and only have the one that landed on chain that didn't even check anything because it knew it was going to succeed, because it ended up succeeding.
00:48:48.460 - 00:49:50.704, Speaker B: So at this point, we have the pair addresses, right? So this is going to be like the uniswap pair and the sushi swap pair and then the transaction hash that is the user target transaction, right? So this is like it's passing in this transaction hash here. Not the actual transaction details because we don't have it, but the hash that we use as an Identifier when we feed this data back into MEV Share. And if we look at this, there's really not much to it, right? It just creates these using the standard Ethers library. It's just this contract populate transaction is just a way that you create the call data for a call without sending it to the Mempool. So this is how you kind of just create your transactions and keep them in memory. And all that it does is it creates one transaction where it tries to ARB first pair to second pair and a second where it does second pair to first pair creates these two bundles. Right.
00:49:50.704 - 00:50:15.352, Speaker B: Remember hash and then an actual signed transactions. That's what this looks like over here, right? We have the hash and the signed transaction. It formulates those in the format that the Mev Share Matchmaker expects. Yeah. And then it just puts them into the format. This is just the protocol format that the matchmaker wants. The mev share matchmaker wants.
00:50:15.352 - 00:51:03.208, Speaker B: So we'd say like, hey, I want you to include this up until this block. You eventually want to stop, right? You don't want to sit there and try to have this included for 1000 blocks. There's some limits there anyway. And this body bundle is that set of transactions that we wanted to pass in, right? The hash and then the real signed transaction. And so, really, this is all just kind of like under the hood stuff for how you get your bundles to the matchmaker in a way that it understands. I'm kind of going back here, right? So we're back at the index, right? So all that this really is, is saying, hey, create those two bundles and send them to the matchmaker to see if one of them is profitable. Targeting the transaction that I discovered that had that log in it and that's all dust.
00:51:03.208 - 00:51:34.220, Speaker B: That's the end of the loop, right? That's the end of what you do when you find a message coming from this message source that has a D 78. Yeah. That has this on there. You sit there, you take that and another pair that has the same tokens on it, and you see if there's an arbitrage opportunity afterwards. If there is, you land, you pay the builder. The builder pays most of it to the user. But the amount that you pay the builder doesn't have to be 100% of the profits.
00:51:34.220 - 00:52:00.916, Speaker B: In the example we had over here, where this user landed a transaction, this is just like we're talking about here. This is one of the transactions that was signed using a system like simple blind arbitrage. They sent this to the builder. They kept this for themselves. When you take out the transaction fee, they made 00:34 in this bundle and the user made 00:38. So everybody wins. Great Scott.
00:52:00.948 - 00:52:08.104, Speaker A: You have somebody asking if we can show the code that read TX from MapShare again.
00:52:08.222 - 00:52:27.296, Speaker B: Yeah, of course. Yeah. I mean, the thing is, there's so little code. It's like here, right? So this event here, let me pause this. Let me put a breakpoint here. So the code that reads it is just creating an event source. This just knows how to read an HTP stream like we have over here.
00:52:27.296 - 00:52:58.424, Speaker B: That's all it is. Like, remember the stream over here? New event source on that, right? We're on main net this. See, this value is just that URL that I'm looking at. And then you just say, hey, event source. Whenever you get a message, this is kind of a built in like node function. Whenever you get a message through that endpoint, call this function and then it's going to end up here. So in this case, all that we're doing is we've got a debug point here.
00:52:58.424 - 00:53:20.256, Speaker B: So the event that came in is this. Yeah, right here. See that? This is what came in. This is one of the ones that doesn't actually share anything, but it still came in as a JSON message. We parse that. Step over that. Look at now you just parse it into a message and now we can evaluate it.
00:53:20.256 - 00:53:49.850, Speaker B: So, I mean, the whole thing is just really set it up, get a callback, parse the data that comes back. Now you can do whatever you want. See if this one has more. Right, so I'm hitting play again. Nothing. Yeah, it's a pretty common path that people just don't share anything, but from the when they do, they share. Here's one that shared a ton of stuff.
00:53:49.850 - 00:53:55.180, Speaker B: Yeah. So this one shared a whole bunch of logs.
00:53:55.840 - 00:53:57.656, Speaker A: It's probably a big swap.
00:53:57.848 - 00:54:05.410, Speaker B: Yeah, that's Dai right there. I don't know. Oh, that's dai. That's USDC pushing stuff. Yeah.
00:54:10.500 - 00:54:11.760, Speaker A: I think this tether.
00:54:14.980 - 00:54:16.160, Speaker B: Tether is DAC.
00:54:19.620 - 00:54:20.370, Speaker C: Correct.
00:54:23.060 - 00:54:53.310, Speaker B: Me. But anyway, yeah, so that's how you parse it. You just parse it with really these three lines and then how you react to it and the data you extract out of the logs, or the function signature or the call data, whatever it is that's present, and the ideas you have for what to pass in afterwards back to the matchmaker, is really what these searchers are all about. And kind of like where if you have new ideas for how to do this or better ways for how to do these, that's where your edge comes from.
00:54:56.480 - 00:55:06.560, Speaker A: Somebody asks in the chat, breeze asks in the chat, what are some special cases of mev that you guys have imagined would occur from the system that have not occurred?
00:55:09.700 - 00:55:51.296, Speaker B: Mean, I think the Oracle update that happened a couple days ago, that's one we've been talking about a lot because Oracle updates historically have generated like a ton of Nmev that people fight for for blocks. Right? This used to be like liquidations on Maker where, hey, guess what? The new price of ETH is now 1000. All of these Maker positions are now underwater and now there's just a race to liquidate them because there's like a large mev there. But the thing that happened two days ago was it was an Oracle update for I think it was like a token kind of becoming available for transfer. And so, yeah, that was a cool one to see. And especially since it did just like we expected, it was a large one. I don't know.
00:55:51.296 - 00:55:54.690, Speaker B: Do you have any ideas for other mev that we expect to see from the system.
00:55:56.820 - 00:57:03.092, Speaker A: This is a good one. I think an interesting thing is there's lots of meme coins that are launching right now and oftentimes they get sniped by token snipers that are willing to pay huge bribes in order to be the first person to snipe a token that's launched. And you could have a team that launches their token through mepshare instead. And searchers are bidding for the right to backrun it. But the profit of backRunning that token launch goes to the user actually launching the thing instead of just the builder or a searcher. So you can actually internalize the value of the back running more if your things are going to background anyway and it can help you more fairly price what your token launch should be since you can take those ETH profits from the auction and kick it back to your LP. I think that is very interesting and that's not really something you can do in the usual mempool or the usual way that MEP works.
00:57:03.092 - 00:57:10.488, Speaker A: Like totally novel. Yeah. What else is really interesting?
00:57:10.574 - 00:57:11.710, Speaker C: I'm trying to think.
00:57:14.400 - 00:58:20.924, Speaker B: I think one of the largest there's a lot of mev in NFTs but NFTs are kind of difficult to operate in systems where you're kind of blind because it's like hey, somebody is buying or selling a board ape but which one? Is there a way that you can operate on that information? I think that it'll be interesting to see what people do with partial information for NFTs or whether NFT wallets want to make sure their users get more kickback for their transactions. Maybe the wallets when they interact with NFTs was like oh we're doing an NFT, I'll leak a little bit more. I'll tell the matchmaker that hey yeah, why don't you leak my function signature so you at least know that I'm buying or selling. I think that the ecosystem that kind of evolves around how the decisions are made for what to share. I think that's going to be interesting and kind of as users get these kickbacks right, like that user got 1.2 kickback or this 00:38. I think that's going to start to get users thinking about I used to give these away for free and I don't have to anymore.
00:58:20.924 - 00:58:28.900, Speaker B: And then services that can figure out should you be leaking this data or not and how that gets automated. I think it's going to be a cool development.
00:58:32.190 - 00:58:50.800, Speaker C: Yeah. We also haven't talked about bundle nesting searcher searcher collabs but as far as I know we haven't seen that actually happen yet. But I think that one is going to be probably the most interesting.
00:58:52.450 - 00:58:54.880, Speaker A: Is it live about our yeah.
00:58:55.330 - 00:58:58.930, Speaker B: And bundle nesting works? Yeah. Do you want to talk about it, Brock?
00:59:00.150 - 01:00:07.320, Speaker C: Sure, yeah. Essentially I'd say it pretty much looks just like a transaction when you see it from the SSE stream. It'll just have hash and whatever else you decide to include. What's interesting is, say you leak logs. The logs will come from your entire bundle, but they also inherit the privacy settings from whatever transactions are in the bundle. So if you pick up somebody else's transaction and back run it and their transaction was fully private, then you won't be able to leak their data out of the system. You could see like an attack vector on this, right? If we didn't inherit the privacy settings, then you could just take every transaction and leak all data and logs and then just leak that as a bundle, then read it yourself again and then operate with full information.
01:00:07.320 - 01:00:50.382, Speaker C: So we need to take the intersection of the privacies. But given that searchers, say you don't have the most efficient bot, maybe you're doing a univ three V, two ARB, and you're just using some crude estimation. So you might be leaving a little money on the table. You could decide to share that bundle with mev, share or the matchmaker, and somebody else could come in and see that and maybe they have a more efficient bot or maybe they're taking a bunch of orders and aggregating them into larger bundles.
01:00:50.526 - 01:01:18.350, Speaker B: Well, or if I can chime in here, I think that one of the things we're saying a lot is that there are some people who are willing to buy a token and then sell it on a centralized exchange. Then other people don't want to do that. Right. Other people can't get an account on the exchange. They don't want to deal with a centralized exchange. And so sometimes the back run of, like, that searcher operated perfectly. It left this one pool out of sync and that somebody else loved to buy those tokens to go sell them on a centralized exchange that isn't available to the person who created that first bundle.
01:01:19.010 - 01:01:39.160, Speaker C: On top of that, we talk about decentralized block building and this is kind of like bundle nesting is sort of like a first step in that direction. I mean, if you have somebody who's really good at aggregating orders and they can do it at scale, that's essentially block building.
01:01:40.090 - 01:01:40.840, Speaker B: Yeah.
01:01:41.690 - 01:01:46.838, Speaker C: The question is, how do you do that with imperfect information? There's kind of a balancing act.
01:01:47.004 - 01:02:35.746, Speaker B: So I think we forgot to cover from the user standpoint how you would end up sending to the matchmaker in a way that leaks more or less information. And the way you do it is just to use Flashboss Protect, but with hints on your URL. Right. When you add a URL for Flashboss Protect to MetaMask, you'll include no one looks like this, but you can include these arguments here that say, like, yeah, I want to leak my call data, I want to leak my logs. And this is how those systems end up getting in here with this data that is partially shared. I think in the future, Wallets will start making this call that's going. To be one of the benefits of wallets or IPCs.
01:02:35.746 - 01:02:52.730, Speaker B: They can kind of look at a transaction, be like, I know what kind this is. I kind of figure out what they're going to want. I don't think users are going to want to make that determination every time, but I think that there's going to be part of the service related to sending transactions is going to be figuring out automatically what the right privacy level is for these transactions.
01:02:53.150 - 01:03:18.242, Speaker A: We got time. Maybe we'll do five or ten more minutes of questions. If anybody has any anything they want to say or talk about in the chat. Juan Sunogo, I think you pronounce your name says, any plans for a Golang library? For Matchmaker? Rock. Any plans for Golang library?
01:03:18.306 - 01:03:20.440, Speaker B: We didn't even talk about Matchmaker, by the way.
01:03:21.930 - 01:03:48.990, Speaker C: Oh, matchmaker? Yeah. Golang library. Yeah, why not? We don't have any plans, like set in stone, but we have this TypeScript library. I know a couple of people are writing one for Rust already. I imagine it will probably come out of the community before we have time to do it ourselves.
01:03:50.850 - 01:04:30.934, Speaker B: Yeah, that's what we saw before with the original Flashbots Ethers provider. Yeah. There's a little bit of code that goes into this. I think it's worth one thing to mention is that this thing we just looked at here, this is the simple blind Arbitrage, strangely doesn't actually use this Matchmaker library. If you look at this, even though it's called Matchmaker yeah, even though it's called Matchmaker as a variable, all it is is a raw event source. And then, remember, and I was like, oh, yeah, look at all this magic happening over here in Bundle Executor. If you use that Matchmaker TS, you don't need to write any of this stuff, right? All this, like, oh, this thing needs to do a JSON RPC request.
01:04:30.934 - 01:05:02.600, Speaker B: That's the kind of stuff that gets handled by I mean, yeah, I think Go library would be awesome. And yeah, we saw people from the community make those for the thing. But it's not that hard to do without a library either, right. If you're just using Go and there's no library, I mean, it's probably about, I don't know, 20 extra minutes of work. And most of that is just, I think, reading the format that goes into kind of just like reading how the matchmaker accepts JSON RPC, but there's not much to it.
01:05:03.050 - 01:05:20.750, Speaker A: I honestly did not want to handle integrating a TypeScript library into a JavaScript file or writing my shit in TypeScript. I don't know TypeScript as well as I know JavaScript, so I'm sorry you did not use your library, Brock. That's why it handled me. That's good.
01:05:20.820 - 01:05:43.970, Speaker C: I think it's valuable to see just how simple this SSE stream is just by implementing it yourself. It's really not complicated. The RPC formatter, you could just copy that out of any one of the libraries. It's just our standard signature scheme.
01:05:46.070 - 01:06:59.178, Speaker A: So we got a couple of questions. In Chat, Simda says, is payment to user prioritized or payment to builder for Metshare? Yes. So at the builder, in theory, they choose the bundle that pays the user the most. And the incentives are aligned here because when we send methshare bundles to builders, there's a field that says refund 90% of the value or x percent of the value to this address, and the rest of it goes to the builder. So in theory, if you have a more valuable bundle, both the user and the builder get more value if their refund is set to be the same thing. Ran Away asks, can you leak fake information and pollute the stream? You cannot ran away. So you set your hints at your RPC or directly if you're directly interacting with the matchmaker and the matchmaker derives the information to leak itself.
01:06:59.178 - 01:07:09.454, Speaker A: So unless the matchmaker was behaving maliciously, you are trusting the matchmaker to say what the hints are. Right?
01:07:09.492 - 01:07:18.820, Speaker B: Exactly. Yeah. You don't say what the call data is. You just say like, hey, tell people what the call data is, and then when those transactions come in, it looks at the call data and sends that out.
01:07:19.590 - 01:07:39.258, Speaker C: Yeah. So I responded to this in chat. I guess it depends on what you mean by fake information. If you expose some logs well, I don't know. How would you really fake that? If you can check the contract address and you can check the logs, you.
01:07:39.264 - 01:07:42.650, Speaker B: Have to do some stuff. Okay, we're getting to some nitty gritty.
01:07:44.190 - 01:07:49.180, Speaker A: We want to give people information on how to fix stuff.
01:07:53.070 - 01:07:55.230, Speaker C: It's in the interest of transparency.
01:07:57.090 - 01:08:03.902, Speaker A: Yeah. You should probably check on chain to make sure that your transaction is actually profitable, is what I would say.
01:08:03.956 - 01:08:04.594, Speaker B: Yeah, exactly.
01:08:04.712 - 01:08:13.220, Speaker A: The matchmaker will not lie about logs that it sees, but someone's smart contract that they're interacting with might.
01:08:14.230 - 01:08:45.286, Speaker B: Yeah, but if you're checking profitability on chain and you revert your transaction, even if the matchmaker tried to bring it to the chain, it wouldn't execute the good. Right. Your revert rolls everything back. So because your transaction comes afterward, you have final say in whether your transaction executes or not. And so I think that the worst thing that's going to happen is you send these bundles to the MV share pool, like the matchmaker. That's what we're calling the matchmaker. You send these there and they just don't execute.
01:08:45.286 - 01:08:57.060, Speaker B: But that's like what's probably going to happen most of the time, right. So it's not even that much of a trolling vector. You're used to sending transactions that don't land because you're just kind of like guessing what might work. That's very common.
01:09:00.390 - 01:09:01.140, Speaker C: Yeah.
01:09:05.400 - 01:09:14.890, Speaker A: Let's see what else we got here. What are the possibilities to reduce searcher spam on the matchmaker sidestep? Thanks for your question. What do you guys think?
01:09:16.460 - 01:09:17.640, Speaker C: Use spam?
01:09:20.080 - 01:09:52.550, Speaker B: Probably the best way to reduce spam is to find a way to charge for simulation time to make it like, hey, if you're incurring a millionth of a cent of CPU cost to simulate it, if you can just find a way to, I think, push that out to the users, then it's like, oh yeah, go ahead and spam. Right. There's a way to do that. We've seen that with other pools as well. I'm not sure if that's being considered for our product, but that was not something that's on the roadmap, though.
01:09:53.320 - 01:10:21.164, Speaker A: I think one thing that's interesting is if you send us a transaction and this isn't a feature that we have right now, but we could have a feature where you send us a transaction and you tell us, hey, put this behind Oracle updates for the compound, whatever Oracle that compound uses or something. Or put this only behind Curve, USDT, USDC trades, something like that.
01:10:21.282 - 01:10:25.890, Speaker B: It's more like a standing order as opposed to just getting it all the time.
01:10:26.900 - 01:10:27.696, Speaker A: Yeah, exactly.
01:10:27.798 - 01:10:52.056, Speaker B: Well, actually there is we deal with spam. Hold on. We do have a spam mechanism, and that is reputation. Right. We do reputation, which is you sign all the payloads you send with another private key, and as you land bundles, you end up going into different priority queues. And if you are landing lots of bundles, you are going to get evaluated potentially sooner. Right.
01:10:52.056 - 01:10:58.730, Speaker B: Or faster, just based on how your prior history has been.
01:11:03.530 - 01:11:07.190, Speaker A: It only matters in periods of high load, I think.
01:11:07.260 - 01:11:07.880, Speaker C: Yeah.
01:11:11.290 - 01:11:23.450, Speaker A: All right, other questions. Let's see. Breeze says, how do you plan on mainstreaming the system? What do you mean, breeze? For users, for searchers.
01:11:25.550 - 01:11:55.446, Speaker B: It's like a marketplace, right? The marketplace kind of becomes like self promoting. It's our job to make sure it gets self promoted. Right. The more order flow you have, the more searches you have, the more profit, I think that becomes kind of this recursive thing and so for everyone. Yeah. I just think all we need to do is make sure that it has enough volume on everything on the searching side and on the order flow side to make it profitable for all the parties. Right.
01:11:55.446 - 01:12:04.566, Speaker B: Because all the interests are aligned. Yeah. There is an API endpoint to check your reputation that's get user stats.
01:12:04.598 - 01:12:18.106, Speaker C: Right. Have we finished integrating reputation from MapShare or matchmaker into that? I think that might still be in progress.
01:12:18.218 - 01:12:25.440, Speaker A: Aiden Khan asks, can you please shed some lights on how to protect the private keys? No, Aiden, I'm sorry.
01:12:29.410 - 01:13:12.374, Speaker B: I have some light. I'd like to know. It should really just be gas. You only need to sign transactions that can operate on gas. And because of the protections on the contract, you could have the owner be a much more secure account, the one that might actually own funds that are on that contract. And you should only need to keep enough on there for a very small amount of gas, which normally is a pretty small amount of ETH. And yeah, I think that just finding, like, a tiered system like that means that even in the worst case, you could be out, like, a very small amount if you were constantly refilling it, make it so that anybody who calls it calls your contract can't drain any money unless they have the more secure account.
01:13:12.374 - 01:13:38.434, Speaker B: Right. It's like calling it with, like, first pair, second pair. If it's not profitable, it reverts. So you're not going to do anything except for potentially waste all the gas. Excuse me? Yeah, environment variables. But it's hot, right? It's hot in memory somewhere. So that should be a separate account that is only used for gas, not for withdrawals.
01:13:38.482 - 01:13:53.338, Speaker A: What else we got here? Maybe we'll take two more questions. How do you know if you get outbidded on your bundle? You don't. Right now we're working on some APIs to help.
01:13:53.504 - 01:14:20.226, Speaker B: Yeah, we do have a little bit here, but we could talk about this. This is probably one of the cooler. This is a cool function. Where is it? Matchmaker. So in the matchmaker TS, we have this simulate bundle. And the funny thing about simulate bundle is that you can't do it. So simulate bundle basically kind of takes these two transactions and says, hey, run this transaction, then run this transaction and tell me what would have happened.
01:14:20.226 - 01:15:26.760, Speaker B: The problem is you don't have this transaction, you have this transaction hash. And so this is a function that we wrote that will actually wait for that transaction to potentially land on chain. It'll just sit there and pull for it every block. And once it finds out what that transaction is, then you can run the simulate function for that promise will return, and you'll be able to say, oh, no, the transaction is let me grab it, and then simulate these two transactions in a row. And then you could see what happened. And if you discover that that transaction that you were targeting landed in somebody else's bundle instead, and yours succeeded with it and would have paid a certain amount, you could figure out like, oh, well, they paid a certain amount, I paid a certain amount, and was I paying more and something went wrong? Or was I paying less or not enough, or it gives you a chance to evaluate the actual on chain landing behaviors if you just wait for this transaction to eventually become public, which is very likely, right? These things normally become public eventually, right? Because even if they don't land with a searcher, they also go to the more conventional, just like landing without. So you can eventually simulate.
01:15:30.060 - 01:16:22.312, Speaker C: And then he's asking, how do I know if I got outbid? In mev boost, we have function called get conflicting bundle. It's in the ethers provider bundle library. And it'll look for the target transaction sort of in the same way. Waits till it's included on chain and then it'll look up all the bundles in the blocks API, which are also on chain now. And it will just run through and simulate against each bundle until there's a conflict found. So we want something similar for this, but some upgrades I think need to happen on the back end.
01:16:22.366 - 01:17:01.920, Speaker B: The APIs, aren't there? Actually, we have a pull request that we're looking at right now that's going to expose bundles. We have blocks API that you use to yes, we have this blocks API that you can query for bundle information from our builder. That will be enough, right? So you can get bundle information from our builder. This currently does not include the matchmaker bundles, but it will very shortly. We have the code written for it. We just need to check it and deploy it. But pretty soon what you can do is bundle that the transaction that I wanted to land landed in this block.
01:17:01.920 - 01:17:19.820, Speaker B: You can go and check the blocks API for was it a part of a bundle or did it just land naturally? Because those are kind of two different paths you would need to evaluate separately to see why that happened. But there is information that gets exposed about how these things actually landed on chain and it'll be added to that shortly.
01:17:26.080 - 01:17:39.440, Speaker A: You all can feel free to stay on. I unfortunately got to drop. So thanks everybody, for tuning in at least to listen to me talk. Thanks Brock and Scott, for joining us today. Feel free to stay on if you want. Cheers.
01:17:39.940 - 01:17:43.810, Speaker C: Cheers. You want to do a couple more?
01:17:44.340 - 01:17:45.190, Speaker B: Sure, sure.
01:17:48.680 - 01:17:54.550, Speaker C: We can wrap it up. Yeah, let's see.
01:17:57.580 - 01:18:27.010, Speaker B: Okay, I like this question here. Transactions that hint only TX hash are essentially private since you can't act upon them. Right. So in that case, I think I mentioned this at the top of the talk, but there was a large the largest payout we had actually was from a transaction that only shared TX hash, and it was from an Oracle update. But the searcher knew the approximate time frame that it was coming out and so it just took its bundle. Let's come over here. Right.
01:18:27.010 - 01:19:16.450, Speaker B: Every time it got something, regardless of having nothing here, it said this do the thing I want. Right. New transaction, do the thing I want. And so it just kept every time it got something for that small period of time, which I think it was probably just about, maybe ten minutes, it tried the bundle and it eventually landed. And eventually it got to back run the transaction that it wanted and it paid a good fee to the builder and a good fee to the originator of that transaction. So with current volumes, it's somewhat feasible to do every transaction. But pretty soon, I mean, this kind of comes back to the other questions we had about denial of service and reputation and how we deal with those going forward in a scalable way.
01:19:16.450 - 01:19:59.916, Speaker B: Currently there are rate limits based on a bunch of sources right, for any searcher doing normal things. I mean you can see that right now the volume of this, let's go back to our MVB share, right? I mean the volume of this isn't crazy, right? This isn't that bad. This is only brand new transactions that are coming in through and these are only ones that are coming in through the matchmaker. This is order flow that we are working to improve. But there are probably tens of thousands a day, something along those lines, but not such a large amount that I think we need to be crazy worried. Unless you're doing like 10,000 transactions. If this list of three is 10,000, then yes, I think we have a problem but we haven't seen that yet.
01:19:59.938 - 01:21:07.120, Speaker C: And we'll address that when we get there's. We pick the builder fee at Runtime in the smart contract or do we need to specify the fee when we send the transaction? Yeah, great question. Yeah. So you could do it in your smart contract. This is just block coinbase transfer or whatever method you prefer. So yeah, in the bot right now in the smart contract you'll see that there's a calculation for we find how much profit we have by checking the before and after balance and then we do some math to calculate how much the validator or the builder gets as a coinbase payment. So yeah, if you want to specify off chain, you can but you have no way of knowing exactly how much profit you're getting out outside of that context.
01:21:07.120 - 01:21:11.910, Speaker C: Depending on your strategy, you may or may not want to do.
01:21:12.360 - 01:22:12.650, Speaker B: Yeah but right know you can execute EVM code and you kind of decide based on how much comes in is how much the coinbase gets. And normally when you do this you submit your transactions with a zero priority fee. So you're not paying the miner anything, you're going to pay your base fee but you don't pay the miner anything except for this and that is still a valid transaction and that's kind of a common way to do it, especially when you don't know how much profit there's going to be until you're at Runtime. And I know I mentioned this before, but it's important to compare this profit against how much gas you've spent and how much gas you've spent is available inside of inside the EVM and that code's not here right now. Again, that's an exercise for the reader but there should be a line here that says, hey, make sure that the profit is more than I spent on the base fee to get this transaction included. Otherwise you have lost money, you have gained WETH, but lost more than that amount of WETH in ETH on the executor account on the signer, right?
01:22:14.220 - 01:23:08.700, Speaker C: Yeah. And then if you wrote the contract you have a pretty good idea of how much gas it's going to consume for one ARB. Can have sort of pretty accurate estimation there. So you could pass this in as a function argument. If, you know, say if it's like really long tail and you know that you're only you're the only one searching on that, then it might be better to pass your gas or your tip as an argument, save some gas. But if it's that rare, I guess in this case, it doesn't really matter if you're going to save a couple of bucks or not, but yeah, depending on the strategy. We had one question about an aggregator for relaying bundles to multiple relays.
01:23:08.700 - 01:23:23.600, Speaker C: We don't have an endpoint that does that right now, but we're doing something like that with the Dao. We didn't talk about the Dao at all. The Dao?
01:23:25.060 - 01:23:31.410, Speaker B: Yeah. I don't know a whole lot about the dog. I know it's the order working group, but is there any more to talk about?
01:23:32.600 - 01:23:54.550, Speaker C: It's the decentralized order flow working group. So, yeah, the idea is in this group, order flow is shared between parties and that'll increase inclusion rates. But this is still very fledgling idea and something that we're building currently.
01:23:55.400 - 01:24:04.440, Speaker B: By the way, I've been saying the wrong number this whole time. I forgot it's not 1.2, it's 10.8. That was the refund that the user got. 1.2 was the builders.
