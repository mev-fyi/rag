00:00:02.520 - 00:01:08.514, Speaker A: So we have, I think, a closing panel on application specific sequencing. And basically, one way to categorize sequences in my mind, is that you have the general purpose sequencers that will cater for general purpose roll ups as well as some more specialized virtual machines. And then you have a completely different type of beast, which is the application specific sequencer, which for some reason or another, they've decided to not opt in to the largest or the de facto shared sequencer. They have very, very good reasons for doing something else. And I guess one type of example here could be gaming. I might want super low latency or super high uptime, or I want to very precisely control the fees that I have to pay for sequencing. I don't want to be subject to activity from other applications and suffer mev spikes and things like that.
00:01:08.514 - 00:02:12.714, Speaker A: I think another potential use case is DeXs. So, right now we have this problem where DEXs, like Uniswap leak mev, specifically the sextex arbitrage opportunity to the proposer. But there's these ideas like Sorella, where when you introduce an application specific sequencer, and then now you have the opportunity to auction off the mev opportunity and rebate it back to the LP's so that it no longer leaks to the sequencer. And that's actually not beneficial to the users in some sense, it's returning mev to users. And we have a very similar idea with, with Oracles and with liquidations. And so I guess, like, my first question is, do you agree with this dichotomy of shared sequencer versus application specific sequencer? And what other applications do you think could make sense to basically use an application specific sequencer?
00:02:13.974 - 00:02:22.444, Speaker B: I got ideas. Okay, so this term, application specific sequencer, is kind of new to me. I kind of like it.
00:02:22.784 - 00:02:23.816, Speaker A: It was coined yesterday.
00:02:23.880 - 00:02:27.288, Speaker B: Yes, coined yesterday. Okay. It's interesting.
00:02:27.376 - 00:02:28.488, Speaker C: We're done with this stuff.
00:02:28.536 - 00:02:31.200, Speaker A: Come on, it's a good meme.
00:02:31.232 - 00:02:34.320, Speaker C: I thought I was the only one that didn't know what it was. I was like, what's like code?
00:02:34.432 - 00:02:35.296, Speaker A: What's going on here?
00:02:35.360 - 00:02:58.170, Speaker B: Okay, it's gonna be on a panel. Gonna be on a panel on applications. But here'd be my argument, okay? Because, Justin, we've talked about this before. You're a futurist. You're thinking five years out and generalized things seem great. Five years out today, the killer app, or the modest use case of a lot of these blockchains. And where most of them comes from, is from trading.
00:02:58.170 - 00:04:16.824, Speaker B: So in a multi chain world, it's going to be swapping assets from chain a to chain b, or bridging the same asset from chain a to chain b. And I have two points here. So, first of all, it seems logical that you may want to today design a specific solution to capture Mev and make this killer use case the most efficient and offer users the best execution. Today, that seems logical, given that it's a big part of the market. And part two with trading in particular, there's another feature that allows you actually opens up the design space, which is the fact that these assets are fungible. So if you're going to fill a user on a different chain, you can literally just fill, it doesn't have to be the asset on the origin chain, you can just, whatever the same asset is, you can fill them. And so the bridge which can do swapping that I work on called across, takes advantage of this in this quote, unquote intent based architecture, to use other buzzwords, where we're using the fungibility aspect to fill users on the destination chain in a sort of application specific sequencing, if you will, where the market makers are purely taking on the risk of best execution, or competing for best execution for the user.
00:04:16.824 - 00:04:27.184, Speaker B: And we are laser focused on trying to make that be as efficient as possible, even if five years from now there might be more generalized ways to do it.
00:04:27.844 - 00:04:28.276, Speaker A: Gotcha.
00:04:28.300 - 00:05:21.364, Speaker D: I think I would push back against the dichotomy that you drew too. When I saw applications specific sequencing, when I thought we were talking about today, actually. So that was new to me, was the notion that applications could program generalized sequences to have sequencing rules that are specific to them. So you have your generic EVM chain today, but you're an application on that, that wants some sequencing rules for your application. So I think on Ethereum one, you can see this with solvers as an example, where you're trying to give a user the best trade possible, and the right optimal way to do that may be to place it in a certain place in the block back running another trade as an example. So you want to program the sequencer to have some special logic of how to handle your transaction. So I think there's a third way actually, which is what I thought we were talking about.
00:05:22.984 - 00:05:50.888, Speaker A: I mean, in some sense you want to try and marry the two, because there is a need to have separate rules for specific applications. And sometimes that means creating a totally new sequencer. And that comes with composability trade offs. So, for example, Sorella or Cal swap is not as composable as an l one contract. But if you could take a shared sequencer and kind of customize it to your application and retain the composability that would be the best of both worlds.
00:05:51.016 - 00:06:35.464, Speaker B: Yeah, maybe. And again, I want other people to talk, but there's kind of two paths here. Like do you start with the specific use case of optimizing, let's call it swapping, and then figure out how to generalize that through chain abstraction. Through maybe what you're swapping actually is all you're doing to move from chain a to chain b is you're moving enough gas to execute the user op from account abstraction to do the thing on the other chain. I can paint a path for chain abstraction flowing from an intent based bridge, or. So you start specific and generalize, or do you start generalize to build the generalized thing over here too? And I think we're just going to see the different approaches play out.
00:06:37.044 - 00:06:49.228, Speaker C: I'm just confused. Who's the sequencer in the application specific sequencer world? Is it still the market builder super node, or is it someone else?
00:06:49.396 - 00:07:05.124, Speaker A: It's someone else. So in the case of Sorella, they have their own external consensus who's custom designed for maintaining an order book and matching, matching orders. And they use that in order to auction off the LVR.
00:07:05.544 - 00:07:11.400, Speaker C: Okay, so then they what, they produce like a set of transactions, like a block, and then they post it somewhere. What do they do with that?
00:07:11.432 - 00:07:12.204, Speaker B: Ordering?
00:07:12.584 - 00:07:37.980, Speaker A: Yeah, so they produce a block which has this finality certificate. So basically two thirds of the validators have signed off on it for their own roll up. Yeah, for their own roll up. And then that gets settled on l one. Yeah, I think Cal swap, they have basically a centralized sequencer, which is application specific. And you can think of binance as being its own application specific sequencer.
00:07:38.012 - 00:07:46.304, Speaker C: I guess I do agree with Robert here. Why isn't the sequencing just a program that runs within the block builder at whatever merge time that they're doing?
00:07:47.204 - 00:07:55.774, Speaker A: Well, if you could do that, it would be amazing. But neither Carlswap nor Sorella did that. Well, suave, suave.
00:07:57.514 - 00:08:32.288, Speaker B: Well, hold on though. Okay, so my mental model for Sorella is you've got a block and you want to do a bunch of trades on a dex and you want to capture LVR or whatever. So you're going to sequence all the trades in that block. There's like a unit here, and that's what you're sequencing. And then for cowswap you have a batch auction over some period of time with a group of trades, and you're going to solve that and sequence that. But then there's the other way, which is just you have a trade, aka user intent. And what's up is Cal swap a roll up now? No, but this is where I'm trying to use the application specific sequencer idea here.
00:08:32.288 - 00:08:33.544, Speaker B: This is the new idea.
00:08:33.664 - 00:08:35.104, Speaker C: Okay, okay, okay, sorry.
00:08:35.264 - 00:09:06.234, Speaker B: But let's kill it. So let's delete that and just talk about best execution for a user on a swap specific. I have a trade, I have a swap. I want to auction it off. There is no sequencing. Exactly, because it's just one single trade, but because I'm not specifying how that trade gets executed, in a sense, the market maker is abstracting away how they're going to end up doing it. And so I don't know if this fits in your framework, but I look at that as a single action.
00:09:06.234 - 00:09:22.128, Speaker B: I'm capturing all the meV. I'm not leaking any information about how I'm going to execute that trade. I'm principling the risk as a market maker. And there is no mev leakage, and it works pretty well. And you can do it today, but.
00:09:22.136 - 00:09:23.872, Speaker C: You don't have the composability aspect.
00:09:23.928 - 00:09:25.564, Speaker A: You don't have the composability as Justin.
00:09:26.024 - 00:09:28.248, Speaker C: Really wants for the ethereum ecosystem.
00:09:28.416 - 00:09:40.626, Speaker B: Well, so then you layer on top of that, right? So it's like, okay, what is the composability I want? So if it's just swap asset a to asset b from chain one to chain two and then deposit in a lending protocol.
00:09:40.760 - 00:09:56.678, Speaker C: Well, I think it's more like everyone has their liquidity on l one, and you don't need a Dex on any l two s because you can just borrow that liquidity at runtime when you do the sequencing within the suave node that's running on the blockbuilders, or you.
00:09:56.686 - 00:10:01.582, Speaker B: Have the market maker do that with their own sophistication. And so they're the ones providing liquidity.
00:10:01.678 - 00:10:05.182, Speaker C: But then they require inventory on the like, whatever is right.
00:10:05.238 - 00:10:05.550, Speaker B: Sure.
00:10:05.622 - 00:10:09.366, Speaker C: That's less efficient than just having a single pool of aggregated liquidity on one.
00:10:09.390 - 00:10:14.350, Speaker B: Place, maybe, but like, we do it pretty well and with, like the across bridge has.
00:10:14.462 - 00:10:18.286, Speaker C: Yeah, but really we're talking about the future here. What are we talking about today?
00:10:18.470 - 00:10:50.868, Speaker D: One of the things that is challenging about this is that, you know, everyone has their own application. That's sequencing. Everyone has their own set of information, everyone has their own liquidity. And you want composability between these things because of the idea that we have in crypto that the sum of parts is greater than the individual parts in and of itself. So the couch pop example is a great example for that. Or a solver that's sending a transaction. You want to be able to backrun someone else's transaction, but you may not trust the market maker to have access to your private information.
00:10:50.868 - 00:11:07.774, Speaker D: And so that's why we're bullish about the notion of having privacy for these things, trusted execution environments where you can get this composability and collaboration between people, because we do think it gives users better execution in the limit, because it enables collaboration where you wouldn't have it otherwise.
00:11:10.074 - 00:11:23.774, Speaker C: I have a question about SUAV and sequencing. So if we have a program which is an application specific sequencer that we deploy onto SwaV that is run by a block builder, how does that interface with programs that are not deployed to swap?
00:11:27.234 - 00:11:44.754, Speaker D: That's an interesting question. Presumably your program has some set of APIs, and you'd be able to feed it inputs at some point in the block building process. I think we'd have to sit down and really look at the details. But anything that is external to suave won't have access to its internal state, at least between blocks that it has produced.
00:11:44.914 - 00:11:52.730, Speaker C: So maybe it can produce a blob for the swab stuff, and then a different blob for the non swab stuff.
00:11:52.842 - 00:12:26.934, Speaker D: Yeah, and I think it's really up to your application to define those rules of what you are sharing, when and how the external world interacts with it. Imagine a batch auction. That's a program on suave that you want to settle at block building time. Of course it's going to take a bunch of inputs throughout the blockbuilding process, and it's up to that application to define what that looks like. So batch auction wants to have people trading until the very, very last minute. And probably it defines some sort of API through we use solidity for how people interact with it. So it is application specific about it.
00:12:27.474 - 00:13:11.996, Speaker E: The way that I took application specific was more. So an application that's built on some type of execution layer that's off chain, that posts some types of commitments on chain, which the chain that you're posting the commitments to is somehow aware of. So I think it depends on the perspective of the operator or the user of that particular protocol. So what we're building with anoma is a generalized architecture for intents. So from the perspective of a user who wants to settle natively on anoma, it would not be application specific, it could be a generalized application, but from a user that wants to settle to Ethereum. It could be an application specific sequencer. Just back to your first question, Justin.
00:13:11.996 - 00:14:01.908, Speaker E: In terms of the types of applications, I think there's actually a lot of low hanging fruit. For instance, if you think about proof of personhood or digital identity, there have been teams like circles, Ubi, who have done various things to try to bootstrap their network. They've had issues building out the infrastructure, and they need something a little bit more generalized. And in particular, they need something that provides some sort of information flow control, or as others might say, privacy. So this would be the type of application that you could build on anoma and still reason about it. On Ethereum, in addition to that, there's things like, I wrote a blog post about a potential application, intent centric kickstarter with dominant insurance contracts. This would allow you to aggregate demand side preferences.
00:14:01.908 - 00:14:40.094, Speaker E: So, for instance, if you wanted to do something like contact a hardware manufacturer and get them to agree to a spec to build a phone for you, we all in this room could express our intents. We could do multiple rounds of consensus, and then we could settle potentially on the spec with the hardware manufacturer. And this is something that you can't do today on Kickstarter. Another example of an application could be like a multi chat application. So you think about like encrypted slack or discord. These are the type of applications that you could build with an application specific sequencer, but still have some awareness on the base layer in some type of construction, perhaps like a plasma.
00:14:42.694 - 00:14:43.634, Speaker A: Gotcha.
00:14:44.734 - 00:15:13.714, Speaker B: Well, I was just going to. So, Patrick, one of the things you said, right, is back to the beginning, what you're saying, this idea of a protocol that you define rules, which we could call the sequencing rules on chain, and then you can have off chain actors that do things that then get settled on chain and verify that those rules were followed. And so I'm being pretty abstract here, but this is like sequencing rules defined on chain. Off chain actors do things.
00:15:16.534 - 00:15:17.874, Speaker C: Yeah, I think I follow.
00:15:18.574 - 00:15:41.620, Speaker B: Yeah, ok, too abstract. But my point here, the thing that I just kind of want to shake and be like, guys, we're missing it. It's like if 95% of what users want to do here is swap asset a to b, or swap asset a to b and then execute code on destination chain. If that's like 95% of what users want to do, that set of rules we can define on chain pretty clearly.
00:15:41.692 - 00:15:48.028, Speaker E: But what is on chain though, right? Like on chain Ethereum, or on chain Celestia, or on chain the cosmos hub. Right?
00:15:48.156 - 00:16:08.984, Speaker B: So, okay, let's go back to what I've actually been talking to Stefan about a little bit here. And we want a standard for a cross chain intent. Okay, so this is an order ticket of what a user wants to do. And they sign it and it says input asset on chain a, output asset on chain B. That's what I want to do. Okay, so there's my order ticket.
00:16:10.004 - 00:16:13.092, Speaker C: You call it a pre conformation messaging standard.
00:16:13.188 - 00:16:15.764, Speaker B: Yeah, pre conf messaging standard.
00:16:15.884 - 00:16:17.944, Speaker C: A base pre conf messaging standard.
00:16:18.284 - 00:16:54.432, Speaker B: But it is a cross chain limit, order based pre conf message standard. It's a cross chain limit order that maybe also has some extra stuff on the destination. Do this other thing, execute this arbitrary code and the user signs this. Ok, so what do we want to do now? And we're talking this multi chain world. We want user assets to get escrowed somewhere. We want searchers to compete to fill this order. We want the best searcher, solver, market maker, whatever we want to call them, to fill the order with their own capital.
00:16:54.432 - 00:17:28.044, Speaker B: And the advantage we have here is fungibility. So we don't need to do anything on chain, they can just fund it. And then after we verify that that order is fulfilled, we release the user assets back to the solver. And then it gets complicated. Like, ok, are the user assets on the origin chain, they get paid back on the origin chain. Does the solver have crushed inventory? I got a lot to talk about all that stuff, but as a basic concept, this works really well. And it isn't composability, but it approximates composability from the UX perspective.
00:17:28.044 - 00:17:41.594, Speaker B: And you can do it today. Like across is doing it today. Uniswap X is doing it in a single chain context today. One inch fusion is doing it today. It works today. Solves a pain point. It's cheap, good execution.
00:17:43.654 - 00:17:54.634, Speaker A: My pitch, I guess what you're saying is that you have this one application swapping which doesn't require composability, and so you might as well have a custom design solution which is very efficient, specifically.
00:17:54.674 - 00:18:01.694, Speaker B: Because of the fungibility of assets. And if you don't have that, this falls apart. And that's where I go back to where you are.
00:18:02.714 - 00:18:03.774, Speaker C: Piece of cake.
00:18:04.394 - 00:18:13.522, Speaker A: One of the downsides here is that let's say optimism, or let's say Ave wanted to like liquidate the position and like access the liquidity.
00:18:13.658 - 00:18:14.466, Speaker B: This doesn't work.
00:18:14.530 - 00:18:33.366, Speaker A: Doesn't work. And so this is where the application specific sequencing comes in and you break the network effects. And so I guess the question is, I guess one way to phrase the question is, what are the applications that are silos that don't need composability? And I think one of them could be gaming and another one could be swapping.
00:18:33.470 - 00:19:01.682, Speaker B: So I think this also goes to the market structure of those roll ups here, too. So I'm not a big gamer. I don't know a lot. But to me, a game like an on chain game, is going to run on its own l two, and it doesn't really need to talk to other l two s. Very often, at most, you just need to bring assets to pay gas on chain or something like that, too. Another interesting example is all these perp dexs, they're kind of like casinos. Your money goes in, and then they don't really want to come out.
00:19:01.682 - 00:19:09.818, Speaker B: They're not really composable. Most of these perp dexes, well, it's true. And their whole business model is get deposited.
00:19:09.866 - 00:19:10.974, Speaker C: Well, it's in the name.
00:19:11.542 - 00:19:27.902, Speaker B: There you go. Of get perpetual deposits. The applications that actually require composability today, I think, are relatively few and far between. The Aave cross chain lending, I think, is the best one.
00:19:28.078 - 00:19:49.010, Speaker A: Okay, here's a question for you guys. Is it that we have these application specific small applications because we haven't reached enough maturity to build complex applications, and once we have multiple building blocks that we can compose, like money legos, then finally we'll have this rich and compelling application?
00:19:49.202 - 00:20:27.592, Speaker C: Yes. Now you're speaking my language. I mean, that's the vision that we've all been working towards, right? Like, the fact that everyone's just speculating on top of crypto today, and that's like, 95% of the usage is not the dream world that I think everyone in this room sort of, you know, dreamed about when they joined in today. It wasn't what I joined in for. When I started in 2017. It was like, wow, everyone's thinking about Daos and putting Uber on the blockchain and whatever else. ICO days were fun, but now the dream of web3 is kind of like, what's happening? People aren't actually developing these applications and having them reach meaningful scale.
00:20:27.592 - 00:20:48.804, Speaker C: I think I have a question for the panelists, which is actually, I wonder, how many application specific do you think there will be? My thesis is that there will be as many as there are smart contracts on Ethereum today. And we'll see people build all kinds of new applications using this magic infinite block space that l two s have created. But I wonder if you guys disagree with that.
00:20:50.224 - 00:21:02.596, Speaker A: I disagree. I agree with you. That there's going to be lots of chains. But where I disagree is that a lot of them will share sequencer. And so in some sense they will act like one chain. So a chain, will that mean that.
00:21:02.620 - 00:21:10.224, Speaker C: They are constrained in block space by that one sequencer that they share? Or how does sharing constrain them?
00:21:10.524 - 00:21:39.074, Speaker A: Sharing gives them composability. It doesn't constrain them in terms of scalability because you have PBS. So I think there needs to be a very good reason for an application to opt out of a shared sequencer. And even if there is some opting out at the game level, for example the swapping level, I think there will be shared sequencing there. So it's possible that there will be a gaming sequencer for all the games and then a Defi sequencer for all the swapping and whatnot.
00:21:39.374 - 00:21:55.476, Speaker B: But Justin, do you think there is some cost to shared sequencing? Right, what is it? But I mean, today there's some cost. We don't have the tech to do it. And I'm saying maybe that cost gets less and less and less, but there is some marginal cost to shared sequencing. Right?
00:21:55.630 - 00:22:17.656, Speaker A: Okay, so one of them is that you can't do MEP protection easily because centralized sequencing does it. Another one is pre conformations are trivial with shared sequencing. And then another one is the whole security training wheels. But once we've solved these problems, which are all solvable, then I don't think there's any downside to opting into a shared sequencer.
00:22:17.720 - 00:22:53.124, Speaker B: So I guess this is the question though, because there's a path dependency here, where if there's a cost today that is not insignificant, and I believe you, that that cost is going to go down and probably become insignificant at a future state. But if there's a cost today and there isn't a lot of benefit, like again, if you have different gaming l two s that don't really need to talk to each other, like why they want to offer the cheapest user experience today, so they're going to develop their own things and then other band aid y solutions emerge. And then you have a migration problem in the future if and when shared sequencing becomes cheap enough.
00:22:53.504 - 00:23:57.284, Speaker D: One observation I have is that I feel like in the beginning of the last cycle everyone was really excited about composability and we had a lot of really interesting and novel applications. I remember people used to wrap die with a bunch of stuff and we thought we would pay with wrap to die instead of die itself would be the token. And it seems like a lot the trend has actually been in the opposite direction, where there used to be more applications that were built on the notion of composability, and now there are fewer. And actually every one of the big defi protocols is increasingly trying to own more and more pieces of the stack themselves and internalize it themselves, as opposed to this vision of a bunch of different composable protocols. And so I think if you take the last four years empirically, we've seen the composability thesis play out in the opposite direction, where we're having more silos as opposed to more composable protocols. I think this would lead us to think that it's not as big of a deal with sequencing as we think. Maybe you can pitch me the opposite side of the argument, Justin.
00:23:59.264 - 00:24:08.584, Speaker A: I mean, empirically, just looking at market caps, there are network effects. Just bitcoin, for example. It's all composable within itself and it has half the market.
00:24:08.624 - 00:24:11.248, Speaker D: What does it mean for bitcoin to be composable within itself?
00:24:11.296 - 00:24:36.014, Speaker A: Well, it's kind of, abstractly speaking, composability at different layers, not just at the sequencing layer. You share the l one, you share the l zero, you share the asset, you share the culture. And I think my personal thesis that we're going to see these strong network effects that are going to lead to winner take most in various aspects, and I think we are seeing that with bitcoin as a great example.
00:24:36.634 - 00:25:26.330, Speaker E: I want to go back to Steph's point about application lock in. I mean, it's hard to explain in this context, but in our architecture, applications are unbundled from particular chains. So the native units of state are called resources, and the resources are controlled by resource logics, which you can think about as predicates or smart contract code. Those resources internally can live on different instances of anoma. And so as a user, you can specify you want to use a particular application, and it doesn't necessarily matter which partition of state the application lives on. So this flips the concept of on its head, where typically you think about security domain first and application second. But in our architecture, you think about application first and security domain second, which.
00:25:26.362 - 00:25:28.454, Speaker C: Actually ends up being more decentralized.
00:25:34.494 - 00:25:38.774, Speaker A: I think we're almost up on time. Tina, let me know how we're going.
00:25:38.934 - 00:25:42.278, Speaker C: The dinners? Yes, these two has a dinner to go to.
00:25:42.366 - 00:25:43.034, Speaker B: Yeah.
00:25:44.014 - 00:25:46.366, Speaker A: Okay, perfect. Shall we wrap it up here?
00:25:46.470 - 00:25:47.206, Speaker D: Yeah, sure.
00:25:47.270 - 00:25:48.182, Speaker A: Okay, perfect.
00:25:48.318 - 00:25:49.374, Speaker B: That's a hard cut.
