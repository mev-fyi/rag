00:00:03.780 - 00:00:18.808, Speaker A: All right. Amazing. So perfect segue. We're going to be talking about some open challenges and indeed trade offs in mev privacy. Hello, everyone. I am Phil. So all of this is let me minimize my little zoom here.
00:00:18.808 - 00:00:56.420, Speaker A: So all of this is kind of going to be in the backdrop of something you all may have heard of, which is something we announced recently at the last debcon, which is the system we're building called Suave. And this is kind of the next step for Flashbots. So I'm going to talk for two minutes about Suave just to give you some background in case you weren't present for that announcement, and then kind of dive into privacy specifically. So Suave is the next step for Flashbots. It stands for the single unifying auction for value expression. It's an Mevaware encrypted, aka Private, with programmable privacy shout out quintus mempool for users and wallets. It features progressive decentralization.
00:00:56.420 - 00:01:40.788, Speaker A: So one of the goals here I'm going to be talking about is iterating towards decentralizing the current MEB boost market, as well as the Flashbots relay and other components kind of more than they are today. It can also provide a turnkey decentralized block builder for roll ups. So the aim is to kind of build the best mev ecosystem we can on ETH so that other domains and other chains can both interact with that, as well as kind of take some of the lessons for their own systems. So to do this, we are creating kind of this fully decentralized block builder. This is the mission. We want to develop this in the open. So this is part of why the Roast series are kind of being restarted and pushed again, but not the only reason.
00:01:40.788 - 00:02:23.748, Speaker A: And we want to be kind of 100% open and transparent about our R and D, where we're at today, where we're going, and have people come and comment and participate in the design because there's a lot of questions we haven't answered yet. So this talk is going to be kind of about one of these big questions that I hope you all, as our community privacy aficionados and experts, can help us answer. The system is going to be ETH native. It's going to have EVM kind of scripting that's going to be relevant in the rest of the talk. We're going to aim for optimal user execution, harnessing mev to give users kind of the cheapest possible price or the best outcome for any trades or other transactions they're doing. And this is again going to be one of the key goals. We're going to talk about privacy serving today.
00:02:23.748 - 00:03:24.010, Speaker A: We're looking for kind of full compatibility with Flashbot's infra today so that searchers can continue searching and validators can continue validating with kind of a generalization, of course, to cross and MultiChain if needed. And this is really the key point of the design goal for this system, which is to maximize both the competition within the system and also the geographic diversity of the nodes in the system by creating a protocol that doesn't, let's say, overly advantage latency in mev extraction or anything like that. And the last two things are we want to enable open order flow. So this will be kind of a key part of privacy is how do you ensure open access to users transactions and kind of step away from the need to permission execution to certain searchers or protocols to get ideal mev outcomes. We want truly permissionless execution where people can send to any number of protocols and any number of actors can kind of optimize against these transactions in real time. And we want programmable privacy. So that's what I'm going to be talking about next.
00:03:24.010 - 00:04:28.184, Speaker A: So these are some trillion dollar questions that I introduced at a talk I gave at Columbia kind of event a few weeks ago. And we're going to be talking about here this first question, which is what is the privacy efficiency frontier in mev extraction? Basically, if you allow users to select much more rich decryption conditions and predicates at mev search time, which is as I'll describe what we mean when we say programmable privacy, how much info should they reveal, when should they reveal it? And what are the trade offs of their ability to internalize the value of this private information against the execution quality, kind of of any options they participate in or anything like that. Other topics that may be relevant here include geographic diversity, censorship, resistance, how to escape SGX. So we're going to be talking about one possible SGX solution, but of course we know the problems with SGX. Stay tuned for the spicy panel later, the feasibility of things like MPC and Fhe in these contexts, how this relates to the limits of minimizing mev and actually the act of minimizing mev itself. That's going to be kind of later in this talk. And also meta mev on Swab.
00:04:28.184 - 00:05:13.320, Speaker A: So how to use Swab mev to kind of drive the system itself. Okay, so that's all for Swab. Let's talk about privacy now, finally. So we're going to be talking about privacy in service of two concrete goals here separately. The first concrete goal, as kind of Quintus talked about in the last presentation, is to continue to reduce the requirements for trust in the Flashbot system as it is today, to decentralize the role of Flashbots today and to remove kind of centralized choke points in the system and maintain the decentralized mev market we've built, prevent further centralization vertical integration, et cetera. The second thing we really want to use privacy for is to allow the user to internalize the value of their mev. So this is what Flashbots means when it says democratize.
00:05:13.320 - 00:05:44.950, Speaker A: Sorry, distribute. I chose the wrong keyword, my bad. I was making these slides very early this morning. So this should be distribute, but we want users to be able to internalize the value of their mev and of course, there are other reasons you might want privacy alluding to some here. But I think we're going to kind of not talk about those in this specific presentation. Maybe we should have a separate roast on censorship, resistance, inclusion, robustness and things like that, if that's kind of of interest. All right, cool.
00:05:44.950 - 00:06:39.232, Speaker A: We want privacy. We want programmable privacy. What do we mean? What would be a useful abstraction for privacy? So this is a presentation I gave two years ago now about kind of the best privacy abstraction that we could use in decentralized building and what we want to build towards. So I'm going to give you kind of a thousand foot view, and then we'll zoom into the details of how this actually works in swap. So wouldn't it be great if we could create this thing I'm calling a proof of private transaction, which was basically an execution proof inside the ETH consensus rules that a certain mix of public and private transactions executed in a way that was consistent with a certain witness. Or here I'm calling it a hatch of the proof. So what this would allow you to do is basically prove that executing some private and public transactions in a given state resulted in a certain outcome and kind of prove certain properties of this outcome without leaking what's in these private transactions.
00:06:39.232 - 00:07:55.720, Speaker A: This is kind of a standard notion of basically programmable encryption. So then if we had this magical abstraction, what could we do? Well, instead of having a relay or a builder like we do today at Flashbots, we could have a whole network of nodes in between the validator here and the searcher trader user or whatever on the other end over here. And the Flashbots relay, which currently kind of validates transactions for spam control and protects the privacy of bids and things like that in flight, as well as the rest of mev boost, would kind of almost cease to need to exist. The trust guarantees would be much more distributed, and we could build something more peer to peer than the Federated mev boost system. You could imagine also multiple kind of private transaction proofs floating around this peer to peer network, as well as an ability to take two of these private transaction proofs and combine them into a new private transaction proof, which eventually kind of crystallizes into an ethereum block. So this would be the ideal way to use privacy to decentralize Flashbots today. Instead of sending the relay, your bundle, you just create this proof about your bundle, send it to this peer to peer network where it can be trustlessly permissionlessly without losing privacy combined with other bundles into eventually what becomes a block.
00:07:55.720 - 00:08:10.100, Speaker A: And this all kind of magically works. Hand wavy. Hand wavy, fully decentralized. And we don't need the relay or builder today. And we sidestep kind of a lot of the issues we're seeing in the Mev Boost market. So this is really what we want to build towards. This is the ideal abstraction.
00:08:10.100 - 00:08:57.424, Speaker A: But how do we get there? So to get into that, we kind of need to lay some technical groundwork to talk about Swab a little bit. And this may be interesting to some people also who have kind of asked and been curious about suave this stuff is all going to kind of be part of a Swab spec that we're very actively developing and looking to roll out very soon. People were very angry at me for saying a timeline last time, so I won't say one, but soon. TM so Swab is a stateful system, stateful distributed system. Essentially. You can consider basically Swab states as sequence of states through time s one, S two, S three. And we can denote the current state by lowercase S and the set of all past valid Swab states as capital S.
00:08:57.424 - 00:09:38.204, Speaker A: These are basically states that are confirmed by the Swab consensus algorithm. And transactions on this system are called bids. And bids basically represent preferences. And preferences map future states of the world to utility functions to the bidder represented in basically computation. So what do these bids preferences transactions actually look like? Well, you basically have a program or smart contract on swap the same way kind of each transaction executes some code. This is the same idea. And it is also EVM, as I said before, EVM compatible such that when you execute the bid in some future state S, this should probably stay S prime.
00:09:38.204 - 00:10:26.648, Speaker A: To not be confusing. But this is a different S. When you execute the bid in some future state or in any state really, you get this output where the bid or the program outputs kind of the value of that state in its model. So this B is kind of the value of reaching this state S or the amount that's going to be paid to the executor. And the bid also outputs an address where basically that address is the executor that executed the Swab transaction kind of computed dynamically gets a little tricky. So not expecting kind of this to be fully grasped right now all that really matters stateful system bids, EVM transactions, they're also Oracle contracts. So the way these bids are actually executed in the future if they do kind of come to fruition.
00:10:26.648 - 00:11:01.572, Speaker A: So let's say I want to bid for an empty block in 1000 blocks. I can submit this bid and then by basically creating the transaction, but then the transaction will actually output a payment if the Oracle essentially tells it that the state of other domains has transitioned such that the payment should be made. So here's some example. The Oracle can kind of be any flexible, smart contract Oracle. We've certainly seen a number of these on ETH and other systems. Any can be used here. But you'd have something like essentially okay, block one on the chain.
00:11:01.572 - 00:11:35.316, Speaker A: This is the block hash. Here's a log hash. And here are the transaction hashes that are confirmed in this block body. And this actually having this Oracle plus this distributed system is already enough to decentralize flashbots bundling. So here are some example preferences you can state in this system. You can say, okay, if a transaction comes at position zero, so the top of a block pay the sender of position one some amount. So this assumes that if you have someone that can reliably kind of place transactions in blocks, they can kind of steganographically tag their doing so.
00:11:35.316 - 00:12:11.730, Speaker A: And as long as your transaction here that you want xerox Cafe ends up being mined at position zero, that person gets to kind of trustlessly claim this three e bid against the Oracles. Another example is you can have kind of a list of transactions to come in a specific order. So this is what's known as a bundle. Now you can say Xerox Cafe must come before transaction zero x dead beef that must come before transaction zero X. And let's say that represents a sandwich and that's where three eat to you. So that would be the B. You would pay essentially the following sender steganographically tagged again some amount for landing this sandwich for you.
00:12:11.730 - 00:13:18.724, Speaker A: You can also use this to bid for empty blocks. You can use this to bid for certain execution logs. So you can just say, look, this is the state I want, create a log transition to the state I want, I'll pay you for it, and kind of fully generalize this to more bridge style transactions as well. So how do we decentralize flashbots using this? Well, we basically create this relay, which sorry, not create this relay, we create a swab, this system where searchers can submit these bids to, and we allow other actors just on the network mev bots, other validators, whatever it might be that we call executors, which may or may not be l one validators. Certainly it's a more efficient optimization if l one validators natively plug in here, but also you could have PGO actors or other such actors kind of competing to fulfill this execution end of the MEB market. So this allows us again to kind of bypass the relay. I'm going to skip over some details here, essentially what this slide is saying.
00:13:18.724 - 00:14:14.996, Speaker A: There's two cases you can have native plugins for this where validators directly listen to bids and kind of automatically switch over bids that they're able to parse and understand and control. And other actors kind of translate these bids into bids that validators can control, or you can have validators that totally don't use swab and the actual execution happens over PGAs or some other kind of third party channel. We've seen both in the MVV market in practice. Great. So now let's switch gears a little bit and talk about really the meat of the privacy problem, which is not just to provide this proof of private transaction that allows us to decentralize the relay, that allows us to decentralize the builder into a peer to peer network, that there's more value to privacy that still hasn't been unlocked in the world yet. And that comes in in when you really kind of dissect the mev marketplace and the trends in the mev marketplace and where they're going in the future. So where is mev going? So mev market has two sides.
00:14:14.996 - 00:14:34.670, Speaker A: There's the user and the validator. The user or a trader, whatever else. Searchers even can fall in the middle or can fall on either side. Here wants to make transactions. They want to purchase block space. They're a consumer of blockspace. Validators want to get paid as much as possible for providing this block space and engage in kind of a business doing so.
00:14:34.670 - 00:15:06.292, Speaker A: And the crux of the mev market is essentially interfacing these two parties using mev as the utility optimization function. So users want to minimize the amount of mev they release. They want to minimize their payments. Validators want to maximize the amount of mev they extract. They want to maximize their kind of received bids. So how do we allow the user to internalize the value of their mev or private information? And again, this should say distribute, not democratize. Well, there's two possibilities.
00:15:06.292 - 00:15:36.352, Speaker A: The first one is we can use what we've seen before in various order flow auctions that have been proposed, that are executing various other kind of domains other than ETH are experimenting with these. You can use what's called basically permissioned execution. So you can auction off the right to execute your transaction to a specific protocol, to a specific searcher, to a specific set of parties. You can sell futures on your protocol. That's essentially the same thing. I also call this an information auction. The advantage here is you kind of get a clear payment and a clear rebate up front.
00:15:36.352 - 00:16:50.056, Speaker A: The disadvantage here is you're actually disincentivizing competition on executing your transaction, right? So, like, you have to decide one party in advance, that party can't efficiently price your transaction. And in the real time mev optimization, you're losing the ability for other actors to economically provide input into what is your best execution, what is the best optimization of preferences. Here, on the other hand, you have programmable privacy, which basically lets users fine tune how and when they release their information to various parties and leverage that in negotiations for MEB. So we strongly believe this is the better route of these two for scalability reasons, because it allows for more permissionless extraction, and because it doesn't lead to a PFOP style market, closed permissioned order flow or the need to kind of trust certain searchers or the need to kind of forfeit additional rent between when kind of the auction happens and the transaction is executed. So for many reasons, we believe this is the best option. Maybe we'll have a separate roast where we go deep into programmable privacy and why this is the best option here we have basically a more formal description of a bid in Suave which is going to come from our documentation. So stay tuned for this.
00:16:50.056 - 00:17:32.448, Speaker A: Please don't read this whole thing. Now you'll just get a little bit confused because we're kind of limited on time. But what matters here is basically in this bid there's two things that users can provide an execution predicate this P of S, or three things, sorry, an encryption predicate Q of S and a set of peakers signal. So this is kind of the control knobs on our programmable privacy inside Swab itself. It allows a user to provide a set of transactions and say, okay, this is when this transaction will be decrypted. When this condition on the world state against all these oracles are met, this transaction can be decrypted and this is when this transaction can be executed only if these conditions on state are met. So you maybe can say, okay, I only want my transaction to execute if it's first in a block, otherwise it should fail.
00:17:32.448 - 00:18:37.384, Speaker A: You can say, okay, I want to reveal certain data, but only under certain world state transitions. So what does this allow you to do? It allows you to partially decrypt transactions, to allow searchers to execute them, but also keep private various aspects of your economic preferences. Now this gets really powerful when you combine it with this concept that we call a fee escalator internally, which is basically signing transactions that increase mev subsidies over time. So you can think of this as like, let's say users increasing a gas price over time, having a VDF based mev release function or anything like that. So in this world you can actually start with a negative mev subsidy where your transaction basically requires some searcher to fund your account in order to be executed. And you can slowly increase this mev subsidy over time to try to find kind of the optimal supply demand point where your transaction becomes profitable to mine. Now, if you do this and you keep this curve private, and you keep information about your transaction private, but you allow searchers to kind of brute force optimize this against other bundles.
00:18:37.384 - 00:19:33.212, Speaker A: Using the type of merging we talked about in the proofs of private transactions earlier, you can actually back out the guarantee that a user gets optimal mev execution while having permissionless real time access to their order flow. So without the need to permission, who is going to execute their transaction? And this is super powerful. It only relies on kind of a competitiveness assumption around the searchers and validators participating in this market. So this is what we consider the core of kind of programmable privacy and why we care about it. Okay, now the last thing I'm going to talk about is kind of the trade off here and this is the kind of trillion dollar mev question, how much information to leak when you make a transaction as a user. So there's the most extreme case of privacy, which is that searchers, validators, et cetera, learn nothing until a block is signed and confirmed. You can only possibly reorder merge Encrypted Blobs, but maybe even not do that, and that you learn no information theoretic output on this data.
00:19:33.212 - 00:20:08.360, Speaker A: Of course, in this most extreme world, it's very hard to mev optimize these transactions and get optimal execution for the user against mev. Kind of find the right point on this curve. The least extreme is you send it to the menpool, you have no privacy. But there are lots of middle grounds here. So if you have a uniswap transaction, maybe you can reveal that this transaction uses the uniswap contract. You can reveal what pools are being traded. You can reveal the direction of a trade or something like that, which will help searchers, find, and computationally optimize your mev without leaking the valuable trade data that's allowing you to find this optimal trade off point in our kind of analysis.
00:20:08.360 - 00:20:35.536, Speaker A: So this is the trillion dollar question here. We're between a rock and a hard place between inefficient mev with full privacy and mempool, which provides no leverage for users. So we really need to optimize this better and find a same middle ground in the context of these programmable abstracts we've created. We look forward to your help here. Come join us on our forum and help us build this. I'm out of time, so sorry I had to rush through that a little, but hopefully it was interesting and illuminating. Please reach out if you have any other questions.
00:20:35.536 - 00:20:37.010, Speaker A: All right, thanks, everyone.
00:20:38.580 - 00:21:16.744, Speaker B: Thank you, Phil. In the next talk, which is my talk, I guess I'm going to push back a little bit on this trade off space. I think we can have our cake and eat it, too. I guess the one kind of spicy question that I have, I'm happy to open it up is on the S in SUAV, the single. Is it necessary for Flashbots to want to take over the Encrypted mempool space? Can there be multiple competing mempools, or does it have to be like a single unified Encrypted mempool?
00:21:16.872 - 00:21:43.620, Speaker A: So I think there should be multiple mempools. I think the interesting question is, like, where to optimize the boundary. The S is a little bit of a troll, so appreciate you for picking up on it. I think what it means more is the intent to kind of provide and maximally decentralize all possible features of an Encrypted mempool in the long term. Not necessarily that there won't be computing systems. There definitely will be. In fact, it will be competing with the centralized systems that exist in the mev boost marketplace today on day one.
00:21:43.620 - 00:22:43.656, Speaker A: So already on day one, it won't be the single auction, and it'll need to kind of reason about how to interface with these systems. So, yes, I believe there's space for many Encrypted mem pools but we would like to try to hit the optimum trade off point in our opinion on what is the best option if you had to choose one. That being said, there are also some network effects and advantages of having one option, specifically when it comes to privacy. So the more you can get within privacy zones that can be optimized against each other for mev. So again, stepping down from this full privacy and having this mev optimizable privacy, I believe the better execution the user gets. So like if I can also optimize my transaction without revealing its information against many other trades and liquidity provisions and arbitrages on uniswap, I should be able to get a better price than if that transaction is not optimized with an awareness of the semantics of mev in mind. So there's like a network effect of privacy that having more people in a single zone is better for those people.
00:22:43.656 - 00:23:10.850, Speaker A: And also same with crosschain mev for validators crosschain you get super linear rewards in the cross chain kind of buy in you have to any single auction. So for those reasons there is kind of some pressure there. It we also truly don't want to be the single system for obvious reasons because then if things break, everyone's like all salty and stuff like that. Certainly we've seen that before. So it's a little bit more of a troll than like a serious product goal. But hopefully that answers the question.
