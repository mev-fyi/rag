00:00:01.370 - 00:01:19.858, Speaker A: I will try to make it short. And I'm Yan Singh probably, I know most of you here and I have been passionate about the direction of credible commitment for a long time as I think it is one of the major value propositions of crypto. Whereas compared with this major value proposition, the research of crypto formalizing the blockchain as a commitment device. And how does different designs of the blockchain community device impact the commitment games, coordination games played on top of it? This research has not been largely explored and this talk would be a simple exploration about the ideas. We basically goes through a series of theory and practice examples to arrive at the central question that we want to answer, which is what is mediator extractable value? How do we better formalize blockchain commitment devices and better study mev both mentioned in Barnaby and David's talk this phenomena, peculiar phenomena that arises from the specific design of blockchain as a commitment device. Okay, so let's start. So the expectations of this session is that it's going to be free, inform, it's not going to be a lot of slides and whiteboard mostly feel free to interrupt.
00:01:19.858 - 00:02:42.622, Speaker A: And the motivation of this session is to as soon as we want to make an impact and actually implement any coordination technology with commitments, whether for AIS or for humans, I know that's something a lot of the corporate AI folks here are working on as lions, we want to actually implement those systems. We will run into problems that involve the design choices of what substrate those commitment games that are played on. And as we have seen in blockchain, we have witnessed through blockchain history, the design choices of the substrate of the commitment device actually impact greatly the commitment games that are played on top. And it is nontrivial for us to navigate the trade offs between different designs of commitment devices. So I will first start with some theory to talk about the overview of some existing work on formulating blockchains as commitment devices. So I believe all of those work on communication blockchains started mostly with the old Virgil Griffiths thesis. So Virgil was a person working, I believe on special projects at the Ethereum Foundation a few years ago and he had this thesis which relates to the game mining paper.
00:02:42.622 - 00:03:43.218, Speaker A: And game mining is essentially saying I'm credibly committing to a commitment that maps the set of outcomes in a game to a set of payments. So this is very much like the principal Asian problem, how to design optimal contracts. Also mentioning David's talk and so from there people have started to devise games that we can play with this with. The most easy example is of course the example of Darkdouce. So Darkdouce basically states that you can use a blockchain or usually a privacy enhanced blockchain to deploy a bidding ring for second price auctions. Or the example of bitcoin. So Bitcoin is basically allowing users to achieve public goods funding by committing to say that, by committing to a smart contract to say that oh, if 100 other person agrees to fund this project, this public goods, then I also commit to fund this public good.
00:03:43.218 - 00:04:46.402, Speaker A: So that is a classic interdependent commitment. And those interdependent commitments can be formulated in a way that, oh, I'm committing to a smart contract that reads the source code of your smart contract, which might be familiar with to the open source game theory or programming clear by Moshe tenderhouse and widely studied in corporate Aisi, as far as I know. So going forward with this, knowing this theory of blockchains as commitment devices, what have people built? We know that people have built the Dark Dowser bidding rings. People have built the public goods fundings. People have also built, let's say, I don't know, like the global payment system, for example. All of the Bitcoin ethereum example are all like, oh, two people are playing this game where they can't trust each other, that if I give you the money, you might not give me the good. But through the use of Smart Contracts, we make this atomic.
00:04:46.402 - 00:05:39.690, Speaker A: So that's like, I commit to only giving you the money after you give me the good. And so the other person commits to the symmetric commitment. So that increases efficiency. So of course we know that there are various folk theorem results about this. Which is to say that if in your commitment you can only commit to a specific strategy in the normal form game, then you can achieve better equilibrium. But there will always exist some game in which the optimal outcome is not achievable if you can only commit to a specific strategy. And the only way to robustly achieve the optimal outcome given any game is if you have this ability to commit to interdependent commitments aka the program equilibrium whatever notion.
00:05:39.690 - 00:07:18.670, Speaker A: So we saw those practices being made but then let's focus on specifically what we are studying here so theory, what are some unique properties of blockchains that makes it different from other commitment devices that we traditionally study? What are some unique things about it? So one unique thing that we have seen is that let me use the whiteboard, okay? So the first one is of course the block type. So block time is the notion that we, let's see okay, so we know commitment devices implement coordination via enforcement and the common knowledge of enforcement. We know that blockchains implement enforcement via delegate gameplay to the ethereum virtual machine which is like the consensus protocols or whatever value the code that people run secured by disinterested parties holding the commitment device. It also implements a common knowledge of this enforcement via consensus protocols to make public announcement broadcasts. However, we know that the common knowledge of enforcement means that the computation of delegation and the implementation of common knowledge takes time, which is a block time and the block time is evidently by that, say you are in a distributed network. You need network latency to propagate messages, to send messages to each other. You also need to some computation time to process the messages.
00:07:18.670 - 00:07:27.186, Speaker A: So let's just call the block time key and then we know that you.
00:07:27.208 - 00:07:28.260, Speaker B: Have to lock the service.
00:07:28.950 - 00:07:31.780, Speaker A: Okay. Yeah. Okay, that's good.
00:07:34.550 - 00:07:44.278, Speaker C: The implication is okay, computation delegation and foundation takes time, hence the block time. But there's a property block that is discrete, right?
00:07:44.364 - 00:07:45.000, Speaker A: Yes.
00:07:46.970 - 00:07:50.150, Speaker C: You put in principle public blockchain.
00:07:51.470 - 00:07:53.260, Speaker A: Yeah, you could have that.
00:07:56.670 - 00:08:07.790, Speaker C: Is that a property we care about or not? Should we think of blockchains more as part of things that involve time or should we take block times as a primitive?
00:08:09.170 - 00:08:52.074, Speaker A: Yeah, I think at this stage we should take them as a property of the blockchain community wise. Because in most of the designs of blockchains we have this discrete time element. The continuous time element is more like say you have a roll up, for example, the popular roll up arbitron. You take transactions, you take people's commitments and then you make those commitments common knowledge by somehow broadcasting to other people. But even in reality roll ups don't really implement this continuous time thing. They more often just batch transactions and then settle them onto the layer one at once. So that's really like a discrete time thing.
00:08:52.272 - 00:09:07.540, Speaker C: That's definitely the normative approach. And more like okay, you observe blockchains in the wild and block time. So then you model them, but you are living designs out of the table, right. That could be potentially continuous time.
00:09:11.990 - 00:09:17.098, Speaker A: Yeah, I agree. The study of there is a logic.
00:09:17.134 - 00:09:24.470, Speaker D: Car synchronous where there is no need to keep track of an expert.
00:09:29.770 - 00:09:31.960, Speaker C: So beach warning longer than this.
00:09:34.350 - 00:09:50.590, Speaker D: Yeah, I mean Ethereum is partially synchronous by number correctly. So maybe this is a specific context, but it's possible, definitely possible abstractions not to have collection but not dependent upon.
00:09:53.510 - 00:10:27.980, Speaker A: Yes. For here I'm more like emphasizing that the blockchain is not zero. So say you are in proof of work. There is no definite block time. It takes some time to implement the common knowledge. And that part is like the property that is needed for that is different from traditionally how people presume the properties of a commitment device in which they presume that the implementation of common knowledge takes zero time. Okay.
00:10:36.850 - 00:10:38.320, Speaker C: First thought about this?
00:10:40.210 - 00:11:16.810, Speaker A: Oh yeah, this is same as the first one. So it's just saying like the implementation, the common knowledge that there is this predicated strategy space takes some time. Like where the first one is this you can predicate other people's strategies. Yeah. Okay. Yeah. So another unique property I think is that on past Ethereum we have this public mempo.
00:11:16.810 - 00:12:24.766, Speaker A: So public mempos basically means that whenever you send a commitment, the other parties is able to view your commitment before your commitment is finalized. What does it mean for a commitment to be finalized on blockchain? It means that the commitment is made permanently credible and is made common knowledge that other people also knows that you have credibly committed to this action. However, on ethereum in the old days we still have this now but it's much less prevalent, this public manpowers, which is that whenever you first send a commitment before this commitment is made credible, other people can see, you know, as talk both in Barnaby and David's talk people can do various bad things about it. So for example, I see you have tried to commit to this thing and then I front from right, I buy the asset that you want to buy before you buy them. Or I can do things like sandwiches and then the third property is that.
00:12:24.948 - 00:12:39.170, Speaker C: In most second property why finalized or on the ledger because if it's a digital signature, it's still gray.
00:12:42.490 - 00:12:52.490, Speaker A: Yeah, it's like you cannot back out if you assume the other person would include your commitment on the blockchain.
00:12:53.710 - 00:13:01.420, Speaker C: That's a really assumption once the signature is out on the public mempool that is braille in a way, right?
00:13:03.810 - 00:13:19.360, Speaker A: Well, I mean, there are nouns. You can cancel the previous commitment by sending the same transaction with a higher nouns. But that's really technical detail, right? Is that.
00:13:21.250 - 00:13:22.558, Speaker D: You'Re ready to give a.
00:13:22.564 - 00:13:23.470, Speaker A: Transaction.
00:13:26.230 - 00:13:48.220, Speaker D: But you could think of signing some arbitrary thing that meets you with a different where you really could out of it. Unless you sign something that you decide that you could date it. I think you've read the once it's out itself ready to appear yes.
00:13:50.350 - 00:14:23.052, Speaker A: I agree. Yes. Okay. Yeah. So that's really for the second point. And then the third point is more like the mediators on blockchain control the settlement function. So the mediator is more in classical mechanism design, the mediator is often called like the auctioneer and in game theory, commitment devices, the mediator is more talked about in the context of mediator equilibrium.
00:14:23.052 - 00:15:55.820, Speaker A: Right. So everybody instead of committing to something and have the natural coordination mechanism arises from the composition of all those individual commitments. You have a central mediator where everybody the mediator says that here are the messages that you can send and here is my guarantee or my commitment to say that oh, when you send this message here is what will happen. Basically the mediator implements a correlated equilibrium in this way and on blockchains, the mediator, as I mentioned blockchains have this block time component. So during the block time, everybody sends a commitment to the blockchain and then the mediator basically takes all of those, say n commitments and only settles maybe m of all of those commitments and it is the mediator's choice of what m out of commitments to settle and that gives the mediator some power on blockchains. And euro is a mediator is called the miner or the validator from those three properties we can already see some bad things can happen right? So for example with the existence of block time. We know that blockchains implement coordination via the use of commitments and common knowledge of commitments.
00:15:55.820 - 00:17:07.136, Speaker A: So that means that any game that is played within the block time I. E. The game starts and finishes before the block time, before the block is published. Then the blockchain as a community device cannot coordinate that game. And in practice we see that there is an abundance of such games. For example financial applications like people trading against each other, the price is constantly moving and therefore the game of arbitraging some automated market maker on blockchain is almost by definition in practice a game that is played within the block time and therefore the blockchain cannot coordinate this game. So this is evidently by say two users want to trade against some, want to trade some assets and then in practice we see that those users can only commit to I want to trade asset A to asset B using this route.
00:17:07.136 - 00:18:20.510, Speaker A: However, the optimal routing can only be decided if agent A and agent B coordinate. Which route does it take? Right? So for example, agent A and agent B wants to settle against each other, their asset first before batching their orders and then settle against Aam. So then this game is not able to be coordinated. Another game that cannot be coordinated is the game of determining the ordering of transactions inside a block. So this is a game that by definition cannot be coordinated within the block time because it is a game about the ordering that is happening within that block. Okay? So then in practice we see a great welfare loss due to such fast games that have played within the block time. Right? As I mentioned, when people cannot coordinate on determining the ordering of a block they tend to spam others or collocate with the validator, spend up large amounts of resources just to get a lower latency or things like that.
00:18:20.510 - 00:19:27.448, Speaker A: And those things and variants of such mechanisms are usually called like one specific instance is called priority gas auctions. So in that case it's more like people determine the ordering of transactions inside a block by entering an all pay auction. And that as we all know, all pay auction of deciding the ordering of a block is really not efficient. And what happened was that people deploy off chain systems, as we see in Barnabas talk, people establish additional institutions that deploy additional mechanisms, make additional credible commitments where the credibility is only assured by some reputation of the institution to shift the equilibrium. And those new institutions act as mediators to coordinate this game where the blockchain cannot self coordinate this game. Yeah.
00:19:27.554 - 00:19:33.410, Speaker B: You say a game is not coordinated or we are unable to coordinate it. What does it mean?
00:19:33.880 - 00:20:13.728, Speaker A: Unable to be coordinated? Yeah. So that means that a more optimal outcome is not able to be achieved because users say for example, cannot express their preferences or fail to. So for example, in the priority gas auction, people, all of the bidders would want to say that if I fail to end up in the first of the block, then I don't want to pay anything and they want to coordinate with other people to express such preferences. Basically they need an optioneer. Right.
00:20:13.894 - 00:20:21.520, Speaker B: So is the idea that a game is we fail to coordinate a game that players don't have access to credible commitments?
00:20:25.560 - 00:20:57.020, Speaker A: Yeah. They don't have access to credible commitment devices that are fast enough yeah. To coordinate the games that they are playing. Yeah. So another more, maybe easier example is a case of two users trading against trading some assets. Right. Users want to settle against each other, but they can't because they don't know what the other user is doing or they cannot express the preference that the other user that they want to settle against another user.
00:20:57.020 - 00:21:51.204, Speaker A: Yeah. And therefore people implement things like coincidence of once, which is to say that one user commits to that. If there exists another user committing to trade the same amount of assets but in the opposite direction, then I commit to trade against that user. And currently on blockchains, you cannot do this inside one block. Yeah. Okay, so then in practice we see that as we mentioned, those unique properties impact the coordination games played on top in the way that it introduces mev, it introduces welfare losses to mitigate them. The design choices that people make to the blockchain commitment device to change this is essentially or mostly to establish more institutions.
00:21:51.204 - 00:23:38.976, Speaker A: Right. They established more institutions to mitigate this problem that they cannot coordinate games happening within the block time. They establish institutions to provide, say, private, but programmable mempos to solve this second property problem established by the second property. Some people try to establish institutions that provide better decentralization and encourage competition between the mediators to weaken the mediators bargaining power in this grand scheme of the games. Okay, so then after seeing that the blockchain industry has been trying empirically to patch its protocol to go from a very bad commitment device design to increasingly better, then can we systematically study what is the drive underlying all of those patches that we make to the protocol? Why do we keep on establishing those institutions? Is there some way that we can systematically study this and then based on our systematic study, derive some results that we can finally implement and practically implement? So I don't really have a systematic way to study, but I have some attempts. Okay. Yeah.
00:23:38.976 - 00:24:38.848, Speaker A: So then let's jump onto some formalisms to present a simple study of those. Okay, so suppose we start at time T with block time small T. Suppose all of those are on ethereum. Therefore we have this synchronous commitment device. And suppose further that this blockchain command device exhibits all of those three properties described by a financial language. And then within each block, we receive transactions which are essentially commitments by the users, denoted by and they are sent to the commitment device. And at the end of the block time at the end of the block, the commitment device implements common knowledge of the commitments and their settlement denominator by functionally mapping the list of all commitments to a commitment device state by making a public broadcast of the results.
00:24:38.848 - 00:26:12.000, Speaker A: So basically, at the start of each slot people send their respect to commitments come one, come two, come three to come n and then the mediator basically has all of those commitments and then it controls this settlement function f to process those commitments. Okay, so then we can formally define crypto as this permission as credible commitment device that consists of, say, a state s that include all of the set of commitments the commitment constructors that people can use to produce commitments. So one example of a commitment constructor is to say that I can only commit to single strategies in a normal phone game. And as we discussed before, this infrusive clear bracket cannot always achieve the optimal outcome state and other commitment. Constructors on Ethereum we know that Ethereum is Turing complete so it essentially influenced the good old program Equilibria type of commitments and then the commitment semantics or the settlement function which is controlled by the mediator as we discussed. Function f takes into the list of commitments and returns a state and then the block time key, of course, that this commitment device need to collect, compute, settle, and then finally broadcast all of the commitments. So then, let's start with our favorite example.
00:26:12.070 - 00:26:12.256, Speaker D: Right.
00:26:12.278 - 00:27:13.744, Speaker A: The simplest prisoners dilemma. We know that for the prisoner's dilemma the state s is essentially the strategies that agents play is an actual prisoner's dilemma game, not the prisoner's dilemma game aided with the commitment. So then state assets essentially a mapping from each player's ID to the strategy that they play in the prisoner, denoted here the two by two matrix. So basically we have the commitment constructor CCOM. Basically it's a function that takes in either a function from the prisoner's Dilemma game strategy to the prisoner's dilemma game strategy. Like it's a function from the other person's strategy to your strategy or a Prison dilemma game strategy. So what this means is that I can commit to that if you play sorry I wrote silent.
00:27:13.744 - 00:28:03.952, Speaker A: It should really be corporate. If you commit to corporate then I will also commit to corporate. So that's like a mapping from corporate to corporate and defect to defect and the other person then you can check the other person should commit to defect. So then there should be two types of commitment constructors. One allows you to commit to a mapping from strategy to strategy and the other is to commit to a strategy and then the commitment semantics is basically check the list of all of the commitments as an apply commitment. Of type strategy to commitment of the type of a mapping from strategy to strategy as puts all of the results, the resolved results into the mapping of the state. Right? So then you can check if you have such kind of commitment device.
00:28:03.952 - 00:28:40.690, Speaker A: Then here's a sample smart contract or the mapping that you can implement construct using CCOM. So you can check over here, you can achieve the optimal state. But then over here what about block time T? Actually so about block time T, we see that Pctd are permissionless credible commitment devices. They implement coordination via common knowledge. And this is what we talked before. For any game played within block time it cannot coordinate and the auctioneer strategy is not certain. This is again the third property.
00:28:40.690 - 00:28:57.176, Speaker A: Then often the mediator is upset of process seeking or even malicious agents that could collude. So then in this case the commitment device cannot coordinate the game. So one example of this is yeah.
00:28:57.358 - 00:29:42.580, Speaker D: Maybe possible in the contract that validators that way. For example, this device that keeps track of all the links in the network also includes entering status, for example providing adaptation or proposing five Blobs and so forth. And that way also that was an important part of the kind of system is also representative.
00:29:47.080 - 00:29:51.476, Speaker A: You mean can you take in smart contract sent by the validators?
00:29:51.508 - 00:29:57.880, Speaker D: No, I mean for example, say you so validators fundamentally enter in contract.
00:29:58.960 - 00:30:01.564, Speaker A: Yeah, it runs a validator code yet.
00:30:01.682 - 00:31:02.450, Speaker D: And the commitments are enforced two ways. For example, buddy blocks are punishment in the future. And so these commitments, my question is no, I personally see them as fundamentally just having a deeper language. Commitments are only representing smart context. I guess my question is is there perhaps common abstraction or device that can accommodate for both things in loss? So for example, you can include induction, but you also include for example, all the operations, all the bin chain in different commitments. I don't know, maybe it's a weird way in explaining what I was trying to say.
00:31:04.180 - 00:31:29.780, Speaker A: Okay, here's a rephrase of your question. I don't know if that captures the scene. So you're saying there are two kinds of commitments. One type is the commitment games. So one type is the actual ethereum commitment that you make. This is like the commitment is made as a level of validator toad. The other is the commitment that the commitment that you use to play the actual commitment games on top of the blockchain.
00:31:29.780 - 00:32:05.260, Speaker A: This is like commitment made on the level of smart contracts. And those two commitments, even though they are theoretically of the same whatever of the same expressivity in that you can add any the validator code is written in Go, you can add any arbitrary commitment and the smart contract is also turing complete. But then they are kind of different and how do they interface? Can we put some part of the writer code level commitment onto this Smart contract level commitment or vice versa?
00:32:05.340 - 00:32:35.016, Speaker D: Well, that's one way to say. For example, lobster include transactions and operations such as slashings and changes to the state involving I guess my question is basically you can think of Ethereum. Also self importing institution made out of commitments. And the question is, why not create a space in the commitment by structure.
00:32:35.048 - 00:32:36.876, Speaker C: To correlate with these commitments in a.
00:32:36.898 - 00:33:00.900, Speaker D: Specific way that also allows validators to enter into new commitments that perhaps may not necessarily be specified? So this builds on something that this builds the idea of proposer commitments. Or you can have the proposal new commitment. So maybe both have the same factor.
00:33:02.840 - 00:33:39.884, Speaker A: Yeah, you could have that because the validator code level commitment is like slow commitments. Right? Because to change that commitment you need social coordination of the ethereum foundation and then the smart contract level commitment is permissionless anybody can deploy. So then you are using the fast commitment to encode some commitments that should have been encoded in the slow commitment. So you can always do this because the fast community device can accommodate for the slow commitments the vice versa cannot be achieved. Yeah, and what you talked about is like kind of restaking or Pepsi by, apparently.
00:33:39.932 - 00:33:40.096, Speaker D: Right?
00:33:40.118 - 00:33:40.690, Speaker A: Yeah.
00:33:42.820 - 00:34:27.790, Speaker C: Okay, I have a separate question so in your formalism you enjoy these two different types, right? The commitment on a strategy or the commitment that there is a commitment. I wonder why we need to do that. Like comparing to say, the formalism in the paper of commitment theory by Aka and our people. So there they explicitly only condition their commitments on other people's commitments. They ban this committing on strategies and then they have these neutral devices that accommodate this commitment to your strategies. I wonder, is it an ordinary difference? Why do you need to deal with structures? Why does that formality not directly apply?
00:34:28.580 - 00:36:06.610, Speaker A: Yeah, that's a great question because the reason I chose to explicitly have the commitment constructor is that I want a way to compare how would the expressivity of a commitment device impact the efficiency that it can achieve when we move from a less expressive commitment device to a more expressive commitment device? If by expressivity we mean that you can add more conditioning onto your commitment language then how does the welfare change? Right? For example, even in the simplest Prisoners Dilemma example, we see that this change, this graph, if you plot it out, the efficiency versus expressivity, it is not monotonic. It starts at a very not efficient outcome. If you have a not expressive language, then it rises and then it could decrease once you increase the expressivity. So the reason is this the reason of this is like you can imagining can I draw on this? Yeah it's like you have this very complex space that you are trying to carve out this is all of the outcome space and over here is like the good outcome space right over here here is what you want and enlarging the expressivity, you basically draw a circle inside of this. Okay, so this is all of the outcome that you can capture. Why a circle is because drawing a circle is easy. Yeah.
00:36:06.610 - 00:36:47.388, Speaker A: This is an analogy to saying that in reality, you cannot devise a super complicated expressive language. You can only devise a sensible language. And like doing in practice, a practical sensible language is the equivalence of you can only draw a circle. You cannot draw some complicated shape. Yeah. So then increasing the expressivity is like you are like drawing a larger circle, also have the same center. But then drawing a larger circle actually does not necessarily allow you to exactly carve out the desired state that you want.
00:36:47.388 - 00:38:08.520, Speaker A: It could enlarge too much and then your welfare decreases. So if this is like expressivity and this is efficiency, then it could be something like this. Overall, it's like because I think this thing is at least not intuitive to me, and I think it would be interesting to study that such a formalism. And also in most of the game theory paper that I have read, it's like they kind of directly especially programming crypto, they don't mention this semantics or settlement function at all because they were proving folk theorems. They just assumed that there exists such function that maps the two programs onto the set of strategies that those agents actually play. But in practice, if you want to actually implement anything that solves those, you need to consider, oh, there might not actually exist such function because even if it exists, it does not terminate. So to capture the idea of termination, you need to additionally define define this semantics or settlement function, which in turn dictates that you must have some notion of constructors because non termination is a property of the expressivity.
00:38:12.220 - 00:38:18.596, Speaker C: Okay. Because of your definition, then you have.
00:38:18.638 - 00:38:23.180, Speaker D: Like, enforce that you can set in Japan.
00:38:26.240 - 00:38:27.980, Speaker C: How does your model enforce?
00:38:32.980 - 00:39:28.320, Speaker A: Yeah, I think in practice we can only do stack overflows the gas on ethereum. Of course, there are many more theoretical results. So the most generalized one, I think, is like, you use a total language, which is like, you still have this Turing complete language, but whenever you pass on the commitment, you accompany your commitment with a proof saying that if my commitment encounters whatever other people's commitment, then here is the proof that those programs will terminate. And then basically the settlement function takes the termination proof and then checks. It actually terminates. And in that way you can enforce. So basically the settlement function rejects any commitment that is not accompanied by the proof of termination.
00:39:28.320 - 00:39:37.190, Speaker A: And in the literature, there's several the law theorem classic whatever thing. Yeah.
00:39:41.720 - 00:39:52.010, Speaker B: When you say that expressive language or commitment of practice, not achievable, can you talk about why that is the case.
00:39:54.460 - 00:40:38.360, Speaker A: Database? Yeah, it's more like if you want to actually, in practice, draw this super complicated shape to actually just. Precisely capture this outcome region that you want. You probably need something like the total language that I described. Like you still use the Turing complete language, but you require the other person to submit you a proof about the termination of your settlement function. So that thing is obviously not doable because as we know, doing some formal proofs, especially machine checkable proofs about commitments is extremely hard. So in practice you can probably only draw like circles.
00:40:40.380 - 00:40:45.156, Speaker B: I understand your plan to be different. Now, I thought your first plan was that there's a limitation on how expressive.
00:40:45.188 - 00:41:01.196, Speaker A: You can make the language there's no, the most expressive language is probably like drawing super large circle that encompasses all of those outcome states. So that's like equivalent of not doing.
00:41:01.378 - 00:41:05.816, Speaker B: Why would the total language not be a large circle outlining?
00:41:05.848 - 00:41:07.180, Speaker D: Exactly outcome?
00:41:08.720 - 00:41:20.468, Speaker A: Oh, because you're requiring other people to submit a proof that your settlement function terminates. So it has to be there's two.
00:41:20.554 - 00:41:34.410, Speaker C: Independent dimensions here that's enlarging the circle and changing the shape and you're equating now changing the shape to termination, which I don't think that's where you're going.
00:41:36.460 - 00:42:20.600, Speaker A: You are saying more expressivity oh yeah, sorry. Yes, I fucked up. Yes, they are not the same. Yes, crypt. Changing the shape is that it requires you as the mechanism designer, the designer of this commitment device. You know, what exactly are the games that people are going to play on top of your community device? And then knowing the game structure, you can carve out almost exactly the space that you want. But this is not possible, say, on Ethereum because Ethereum is Turing company.
00:42:20.600 - 00:43:03.780, Speaker A: People can use it to play whatever commitment games that they desire to play and you can't really carve out the cases that you want to. So a simple example is reorgs or 51% attack encouraging contracts. Right? So for real or contract is something that you don't want to get played. So they're kind of over here it is like the region that you want to evade. So then the way to actually carve out is like in your Ethereum validator code. You say that, oh, if somebody deploys a commitment that seems like a real contract, then I just censor it or don't settle it and then you can carve out this region.
00:43:04.680 - 00:43:22.650, Speaker C: An argument for different patchwork of different languages, local strategy group like Mindset where is as opposed to finding one general language that covers it all, a patchwork of more restricted languages that cover.
00:43:25.440 - 00:43:33.520, Speaker A: Yeah, that's the Kudo app specific chain versus generalized chain argument.
00:43:34.820 - 00:43:46.370, Speaker D: What's the guarantee that every possible game corresponds to can be expressed in terms of whatever language, whatever set of languages you're into or if that exists as well.
00:43:48.180 - 00:43:50.880, Speaker C: Your web token code, shrub, your language.
00:43:52.740 - 00:43:54.580, Speaker B: But it's also just like social media.
00:43:54.730 - 00:43:57.560, Speaker D: If you provide like a general language.
00:44:01.340 - 00:44:03.610, Speaker B: Usually one application or whatever.
00:44:06.540 - 00:44:07.450, Speaker D: We say.
00:44:08.480 - 00:44:11.230, Speaker B: You don't have to condition what other people are doing.
00:44:14.320 - 00:44:15.180, Speaker D: Abstract.
00:44:18.560 - 00:44:22.556, Speaker B: This could also reach a little bit up like social norms.
00:44:22.588 - 00:44:25.584, Speaker A: So hey, we probably should end this.
00:44:25.782 - 00:44:47.050, Speaker D: I agree with that. I mean obviously it would make reaching consensus a little more tricky because perhaps it may be easier for people to reach different encryptions using the same set of evidence or group form interpretation via social sciences like criteria. Right, that up.
00:44:47.820 - 00:44:49.688, Speaker B: Yeah, I'm not talking about enforcement just.
00:44:49.694 - 00:44:51.224, Speaker D: Sort of like it kind of works.
00:44:51.262 - 00:44:52.936, Speaker B: Out because I anticipate that everyone else.
00:44:52.958 - 00:44:54.250, Speaker A: Will do something similar.
00:44:56.620 - 00:44:57.530, Speaker D: But maybe.
00:44:59.420 - 00:45:06.630, Speaker A: Yeah, I would like to talk more and I have comment about that as well but I think we are over time I should hand.
