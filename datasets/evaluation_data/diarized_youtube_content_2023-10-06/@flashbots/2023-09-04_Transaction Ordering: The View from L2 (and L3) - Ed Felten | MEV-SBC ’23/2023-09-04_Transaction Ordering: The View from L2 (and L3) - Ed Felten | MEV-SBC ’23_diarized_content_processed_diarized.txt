00:00:00.330 - 00:00:26.066, Speaker A: You. Hey everybody. Good afternoon. Thanks for your time. I'm going to talk about the other side of that distinction that David drew between macro and micro. I have many interesting thoughts, I hope, about macro, but this talk is about micro. And I'm going to talk about what it looks like, what this problem looks like from the side of an L2 or L3s designer.
00:00:26.066 - 00:01:37.414, Speaker A: And in particular, this is based on both our experience running the Arbitrum sequencer which is the most used so far roll up sequencer and also the research that we've done on this particular topic. So let me start just reviewing and this is pretty close to a diagram that David showed talking about how L2 systems work and just reviewing what is the role of the sequencer because there is some misconception out there about it. So the sequencer is this function up here on the upper left. And its job, and its only job is to receive transactions from users and to publish a canonical sequence of transactions. These are the transactions that have been seen and this is the order in which they've been seen. The execution phase of the protocol then is in charge of figuring out whether those transactions are valid and if so, how they change the state and which blocks they make. So the sequencer you can almost think about a modern state of the art roll up as almost being two chains.
00:01:37.414 - 00:02:20.360, Speaker A: First, a chain that is built by the sequencer, which is the chain of transactions that have arrived and then second, a logically different chain that consumes those transactions and then updates state and looks like in our case, an Ethereum chain. So that's the role of the sequencer only trusted to vouch for transaction arrivals and some transaction order. All right, so how does l two differ from l one ethereum? There's a bunch of different ways, all of them probably important. First, sequencing is separate from execution and settlement. As I just described, the block time is much faster on L2. On Arbitrum, it's 250 milliseconds 48 x faster than Ethereum. That makes a big difference.
00:02:20.360 - 00:03:12.860, Speaker A: There's a private mem pool by default, unlike the public mem pool and the kind of peer to peer gossip that goes on of the mem pool. Maybe you have some private order flow on Ethereum but kind of the default is public mem pool. And in L two, typically the default is private mempool. There's a very low cost structure on L2 S and that means costs that might be negligible for an L one might be really appreciably add to the cost on L two. And so we need to optimize cost in ways that L ones don't necessarily have to. But then finally, L2 S have a degree of design flexibility that L One doesn't have simply because L One is a much more mature, much more widely used system. And so it's a lot harder and a lot slower, and rightly so, to change how ethereum works compared to changing how or evolving how an L two works.
00:03:12.860 - 00:03:34.666, Speaker A: Okay, so we think of this problem not as MEB, but as transaction ordering. And here are our goals for transaction ordering. First, we want low latency. We want to preserve that maybe not 250 millisecond, but pretty close to it block time. We need low cost of operation. We want something that resists front running. We think we owe that to our users.
00:03:34.666 - 00:04:12.586, Speaker A: Our users ask for it and want it. And that's the sentiment of the Arbitrum Dao. But at the same time, we'd like to be able to capture revenue of mev other than front running. We'd like to be able to ethically monetize that. We want to not build in centralization. And what I mean by that is that we don't want an architecture that is inherently centralized. And by central or centralizing and I mean by that not only sort of a count of how many participants there are, but are we creating an economic structure that tends toward monopoly or oligopoly or concentration of economic power? We want to avoid that to the extent we can.
00:04:12.586 - 00:04:37.902, Speaker A: And we also want a property that we call independence of your relevant transactions. And I'll give an example later that helps to motivate why this is a good thing. But let me explain briefly now what it is. Here's what we mean. Suppose that Alice wants to backrun some transaction A and Bob wants to backrun some transaction B. And those transactions are unrelated. They're trading in different quantities.
00:04:37.902 - 00:05:17.694, Speaker A: So Alice's strategy in how she goes about this, what she submits, how she bids, et cetera, should be independent of what Bob does. Ellis's strategy space should be independent. Or in other words, if two opportunities for mev are non interfering, then they should be strategy independent. So the strategy of one is independent of what people in the other one do or even of the existence of the second one. Many mechanisms don't have this property, but it turns out to be valuable, as we'll see later. One of the reasons to understand one of the reasons it's valuable, consider the alternative. Consider a world where everything is entangled.
00:05:17.694 - 00:05:54.046, Speaker A: Every single opportunity is entangled with every other opportunity. So you can't form a strategy for extracting even simple, a simple mev opportunity without understanding everything that's available and what everyone's else's strategy space is. So then, to complete Pete effectively for anything, you need to analyze everything in the most sophisticated way. And that creates a barrier to entry in the space. Also, in a world where everything is entangled, private information becomes more valuable. If you have some private order flow. Now, you know something about the strategy space that none of your competitors do.
00:05:54.046 - 00:06:29.510, Speaker A: And because that strategy space is entangled, that's an advantage for you. So that creates an economy of scale. Those who can get more private order flow have a natural advantage. And for both of these reasons, barriers to entry and economies of scale, any market that has those properties is going to tend toward monopoly or oligopoly. And this is what you would see in a world with max entanglement, consistent with what we see, for example, on ethereum, with the increasing concentration of power in block building. So these factors push toward monopoly. We'd like to avoid them, and one way to do that is to strive for this strategy independence.
00:06:29.510 - 00:06:54.346, Speaker A: All right, so those are our goals. I want to propose a policy for doing this, which we call a frequent ordering auction. And what it is is basically three attributes. First, it's fast, meaning we want to go as fast as we can. A fraction of a second, do this over and over and over. It's a sealed bid auction, and it's a priority gas auction. Priority gas auction means like ethereum.
00:06:54.346 - 00:07:44.450, Speaker A: That what your bid is is it's an offer to pay a bit extra for every unit of gas your transaction uses. And the fact that it's a priority gas auction rather than just a single bid actually turns out to be important, as you'll see later in one of my examples. So this is the approach that we are suggesting, frequent ordering auction. Okay? Now, this actually is related to something in the economics literature of frequent batch auction, and we don't call it by the same name because there is a difference. And the main difference is in the nature and structure of the specific auction that this famous paper by Buddhist and colleagues would do. So to avoid that confusion, we use frequent ordering auction. But we definitely shout out this team because this is one of the inspirations for what we're proposing.
00:07:44.450 - 00:08:29.310, Speaker A: Okay, a fast sealed bid, priority gas auction. All right, so let me talk about a straw man centralized implementation of this. This is actually pretty easy to build. So you have a centralized, trusted sequencer in this world which is chosen who that is is chosen by governance based on trust considerations, and it maintains a private mempool. Now, to make a sequencer block to make a sort of subsequence of the transactions that are deemed to have arrived. First, the sequencer will collect incoming transactions, all of the incoming transactions, over a period of, let's say, half a second. At the end of that half a second, a bell rings and the sequencer moves on to the next stage.
00:08:29.310 - 00:09:26.690, Speaker A: Next, it sorts the collected transactions into decreasing order by priority fee breaking ties according to some kind of deterministic rule. Doesn't matter for now what it is. Then after that, a very important step in practice, which is super annoying and in whiteboard designs, people omit it, but your system will fail without it. That is, you need to filter and discard unfunded transactions, that is, transactions that may look perfectly valid and be perfectly validly signed, but the party who submitted them doesn't have the funds to pay for the data availability for that transaction. If you don't do this, you are operating an unpaid data availability service for the whole internet and you will be sad. So we need to do this as a phase. After we decide what the block would otherwise be, then the sequencer signs and publishes the block and starts the process again for the next block.
00:09:26.690 - 00:10:10.240, Speaker A: That's a straw man centralized implementation. A straw man decentralized implementation might work something like this. Where the sequencer is a BFT committee that is threshold trusted in the way you might expect it's, chosen by Governance. Submitted transactions that are submitted to this can optionally be threshold encrypted. That gives you the private mempool property so that members of this committee don't get to see don't get to see what the contents would be until the transaction's position in the sequence has already been decided. Of course, a malicious quorum of the committee could always decrypt early. But if you don't have a malicious quorum, early decryption doesn't help anybody.
00:10:10.240 - 00:10:59.914, Speaker A: All right, now, to make a sequencer block, first the committee needs to agree on which incoming transactions have arrived before the arrival deadline of the current sequencer block. Having reached consensus on that, they then jointly decrypt any encrypted transactions that are in that set. They then sort the collected and decrypted transactions according to the same rule as before, decreasing order by priority fee with deterministic tiebreaking. They then individually filter and discard unfunded transactions because they have the same sequence. They will do that identically, the honest ones will do that identically. They then jointly sign and publish the block and you move on to the next one. So this actually works pretty nicely.
00:10:59.914 - 00:11:59.090, Speaker A: The only drawback of this is that it has multiple rounds of BFT consensus built in, which is in tension with that goal of a fast block time. And in fact, at the end of the day, users or Governance will have to decide whether they like the trust assumption of centralization with really fast blocks, which means really fast transaction latency, or whether they like better the slower operation and happier trust assumption of having a committee based scheme. I'm not going to predict what a particular governance will want, but that will be ultimately the choice. And of course, one of the big questions here is how fast can you make this decentralized implementation? Interesting research problems there. All right, let me talk a little bit about the economics of this by giving some simple examples. And I'll start with first a single arbitrage opportunity. Imagine the simplest possible situation.
00:11:59.090 - 00:13:12.860, Speaker A: There's one arbitrage opportunity and you have some value on that opportunity. So the first transaction, the transaction that will be earliest within the next block according to the sorting order, will win the reward. And so this is effectively a sealed bid all pay auction. Right, well understood mechanism that is revenue efficient, where the strategy space is well understood all right, but why an all pay auction? And the answer is, if we consider two independent arbitrage opportunities that are separate, and the first transaction that aims at opportunity A will get that one, and the first transaction that aims at opportunity B will get that one, right? Now, this will effectively operate as two separate sealed bid all pay auctions that the transactions aiming for A and the transactions aiming for B will be interleaved somehow in the final sorted transaction sequence. But if you're aiming at A, you don't care about the B transactions because they don't affect your ordering relative to the other A transactions. So you get that strategy independence. It just falls out from the fact that we're doing this sealed bid all pay auction with a sort.
00:13:12.860 - 00:14:23.786, Speaker A: Another thing to note is, because the auction is for priority fee, the amount you pay is your bid multiplied by the gas you use. So if you get the bright idea of combined making one transaction that first grabs arbitrage opportunity A and then grabs opportunity B, that will use roughly twice as much gas or roughly the sum of the gas that you would spend by going after A and going after B. So that is roughly equivalent to submitting two separate transactions that happen to have the same bid and are aiming at the two opportunities. So the bundling of transactions in order to somehow piggyback on top of some other bid doesn't quite really exist here. Now, that's not exactly true because there's a little bit of startup cost for a transaction. But to first approximation, this is pretty close to independence. And unless in practice, unless you would already want to bid fairly, almost equal amounts in the two auctions, you would probably want to submit separately, right? So you can see how the strategy space is simpler.
00:14:23.786 - 00:15:28.614, Speaker A: You don't need to think about whether there are any independent opportunities from the one that you're going after. Okay? Now let's compare this I'd like to take a minute and compare this to a property. That a policy that we've written about before. We had a paper at FC about this called Timeboost, which I'll call now Classic Time boost. So the idea here is that you have a centralized sequencer, just to make it simple, that is timestamping incoming transactions and time boost essentially logically adjusts the timestamp of an incoming transaction according to the formula here, that the final adjusted timestamp is the actual arrival timestamp minus a correction. And in this correction, B is your bid, c is a normalization constant, and G is the maximum amount of time advantage you can buy. Because even if B goes to infinity in this formula, the second term just goes to G, right? Always less than G for a finite bit.
00:15:28.614 - 00:16:25.270, Speaker A: So this is classic time boost and that you would receive transactions, timestamp them, apply this correction, and then issue each timestamp as soon as you were sure that it was definitely going to be next in the sequence. Now, discrete time boost is a variant of this in which you round each transaction's timestamp to the nearest multiple of G and then apply this same time boost algorithm. And it turns out that discrete time boost is equivalent to this frequent ordering auction. So one way of looking at frequent ordering auction is as a kind of frequent batch auction applied to blockchain. Another way is as a discrete version of the time boost policy. And you can look at it either way you want because they're really equivalent. I kind of having gotten there by both paths, kind of like the frequent ordering auction version of understanding a little bit better, but your mileage may vary.
00:16:25.270 - 00:17:22.540, Speaker A: Okay, let's talk about this with bundles. It makes sense to allow people to anyone to submit a transaction bundle, and the sequencer ought to accept submission of bundles. Where a bundle contains multiple transactions, each transaction validly signed by some sender. And the guarantees that we can provide are first that the transactions in a bundle will definitely be in the same sequencer block. I should note that in our model, there is effectively no limit to the size of a sequencer block, and so nobody's going to get crowded out because there's not space. So we'll guarantee that the transactions in a bundle will be in the same sequencer block, and transactions that are in the same bundle, that have the same bid will be consecutive in the sequence and will be in the same order as in the bundle. To make this true, we need to tweak the deterministic tiebreaking rule a little bit, but if you think about it at all, it should be obvious how to do that.
00:17:22.540 - 00:18:04.440, Speaker A: Okay, a few implementation notes based on experience about how this might work. First, the priority fee can be in fact, naturally would be collected by the chain. That's not only convenient, because EVM execution engines already know how to collect priority fees from transactions, so we don't need to build any additional fee collection mechanism. And importantly, the sequencer never has to collect or handle fees. That not only is convenient, so you don't have to have an off chain payment mechanism, but also sort of morally, this revenue belongs to the chain and it makes sense for it to be collected by the chain. And if the chain wants to distribute some of it to the sequencer, that's great. I expect that's what will happen.
00:18:04.440 - 00:19:15.194, Speaker A: Okay, the second note, in terms of implementation in Arbitrum, this is an annoying fact, but again, we're building a real product, so we have to deal with annoying facts. Arbitrum currently doesn't collect priority fees. The reason is it treats every transaction as if its priority fee is zero. The reason is that wallets insert default priority fees of, say, one Guay, which is negligible if you're on L one, but on L two it's like ten x. The base fee and so because so many people inadvertently submit transactions with enormous for L two priority fees and because currently priority fee doesn't get you anything, we have, ever since the launch of Arbitrum, ignored priority fees, not collected them and treated every transaction as if it had priority fee zero. So therefore, for backward compatibility we don't want to just turn on collection of priority fees one day. The slightly messy but pragmatic solution to this is to create a new transaction type which is identical to the existing 1559 transaction type but actually does collect the transaction fee.
00:19:15.194 - 00:19:56.940, Speaker A: Now, the people who are going after mev or who care about placement very much in a world with half second block times are not end users who are using a mouse clicky interface. They're people who are generating their transactions programmatically. And so it's not a big problem for them to create a new transaction type which is identical except for one type byte. So that's a thing that we would have to do. And finally, of course, supporting bundles is important to do and we expect to do it. All right? That's the view from at least one L two chain on what we think makes sense and a proposal for a policy. And I'm happy to take questions.
00:20:04.770 - 00:20:20.254, Speaker B: Thanks for the talk, Ed. So if I understood correctly, the fees, priority fees or any kind of fees paid by transactions don't go to the infrastructure operator but rather go to the sort of Arbitrage token or some treasury?
00:20:20.302 - 00:20:42.810, Speaker A: Well, right. What the implementation is, is they get deposited to some smart contract which is designated by governance and that smart contract sends it wherever it's programmed to send it. So presumably there's some split. Realistically, the Dao will want most of it to go to the treasury, some will probably go to infrastructure provider.
00:20:43.310 - 00:21:09.042, Speaker B: That makes sense. My question is if that split, let's say, for example, in the extreme only goes to the treasury, to governance, it doesn't go to the infrastructure provider at all. There's a clear sort of incentive for the infrastructure provider to take off chain payments, basically and to use that to influence ordering. And so, of course, the limitations on what you can do without being detected. But I wonder if you've sort of put thought into that.
00:21:09.096 - 00:21:43.370, Speaker A: Yeah, let me talk about that issue. One thing to note is that within a block the sort order is trivial to verify and so the sequencer cannot reorder transactions. Within a sequencer block, the transactions are signed by the people who submitted them. Right? And so there are two things the sequencer can do that it has the power to do. One thing is to censor a transaction so that it doesn't appear until later. That is a very important problem. But it is a separate problem and also will be, over time, detectable by users.
00:21:43.370 - 00:22:41.786, Speaker A: The other thing the sequencer could do is inject transactions. That is the hardest problem to prevent and ultimately, I think you have to rely on in a centralized setting, you have to rely on some degree of trust and that if governance suspects that this is happening, if it happens at a large scale, governance will probably suspect, but can't prove that it's happening. And I think then you see a sequencer fired and a new one chosen in a distributed setting, then you have sort of the Threshold trust version of that argument. So as far as this goes, right. The concerns are censorship of transactions so that something doesn't get in, and front running is really the hardcore of this problem. Right. I believe that we should try to prevent front running, but in a centralized setting, trust is really your only option that I can see for preventing front running in a distributed setting.
00:22:41.786 - 00:22:44.640, Speaker A: There's more you can do and there's research going on around that.
00:22:45.110 - 00:22:45.474, Speaker C: Yeah.
00:22:45.512 - 00:22:46.050, Speaker B: Thank you.
00:22:46.120 - 00:22:46.786, Speaker A: Sure.
00:22:46.968 - 00:22:51.326, Speaker B: So this only resembles a sealed bid auction because of the timestamping of the sequencer.
00:22:51.358 - 00:22:51.506, Speaker A: Right.
00:22:51.528 - 00:22:56.354, Speaker B: It doesn't require a private mempool for the sequencer. You can still kind of gossip transactions.
00:22:56.402 - 00:23:12.774, Speaker A: Around or no, let's see. So with the centralized sequencer, there's not really a need for gossip. Right. The users who want their transactions in fast will send them directly to the sequencer. With the decentralized sequencer. Yes. You can have gossip.
00:23:12.774 - 00:24:11.630, Speaker A: It makes sense to have gossip as part of this. Again, someone who wants their transaction in fast will send it directly to a quorum of the committee. But because of a concern about front running with the committee, if the transaction becomes known early on to some dishonest member, then you might worry that they'll inject a front running transaction. And there's things you can do about that within the consensus protocol, because other members of the committee will see that front running transaction arriving relatively late or else being known only to a small number of possibly colluding parties. So it's an interesting problem, what you can do to detect or prevent that. One thing that we know works is threshold encryption of the transactions where there's consensus among the committee on the order which they commit to publicly before they decrypt. Right.
00:24:11.630 - 00:24:19.630, Speaker A: And that way they at least don't know what is the content of the encrypted transactions until it's too late to front run them.
00:24:19.780 - 00:24:20.382, Speaker B: Thank you.
00:24:20.436 - 00:24:21.040, Speaker A: Thanks.
00:24:21.810 - 00:24:38.842, Speaker C: Hey, Ed, thank you for the talk. Maybe I'm not understanding something correctly, but okay. I think there's a few moving parts here. So are you saying that first the sequencer commits to some order and someone decrypts it and then the debug gets committed?
00:24:38.926 - 00:25:21.662, Speaker A: Is that sort of the that's basically the idea, yes. In a world of threshold encryption, you want the sequencer or the committee to commit to a set of transactions that have arrived within the time window, and some of those might still be encrypted. Right. Then you decrypt having committed to that, you're now committed and everything will follow deterministically from there, right? First the decryption, the threshold decryption by the committee, then the sorting and then the filtering of unfunded transactions. As long as the committee is threshold honest, those things are all deterministic and can't be changed once they've committed to this set of arrived transactions.
00:25:21.726 - 00:25:22.642, Speaker C: Got it. Thank you.
00:25:22.696 - 00:25:23.620, Speaker A: Yeah, thanks.
00:25:25.370 - 00:25:25.846, Speaker C: Go ahead.
00:25:25.868 - 00:25:51.870, Speaker D: Sorry, I think I must be misunderstanding something. Because in order to verify that what the committee committed to is correct, that they committed and it's encrypted, then it seems like you're reintroducing the problem of a free data storage layer for the Internet because you have to have that set of transactions available to verify the commitment, and you haven't verified that those are funded.
00:25:53.890 - 00:26:00.238, Speaker A: Right. You can commit to the set without.
00:26:00.324 - 00:26:06.498, Speaker D: Publishing them, but some of them might be encrypted. So have you also verified that they're funded on an encrypted state or?
00:26:06.504 - 00:26:07.154, Speaker A: No, not yet.
00:26:07.192 - 00:26:08.162, Speaker D: No, exactly.
00:26:08.296 - 00:26:52.458, Speaker A: Right. So the committee members know the transactions, they know the set of transactions, they reach consensus among themselves on the set of transactions, including the encrypted ones. They commit cryptographically to that without publishing any plain text. Right. Then they collectively just among themselves decrypt everything and then so they decrypt everything and then they sort and filter and then they jointly sign the result of that. Right. And so, as I've described the scheme here, no one outside the committee is going to see what the contents of those transactions are.
00:26:52.458 - 00:27:42.606, Speaker A: You are trusting the committee you're threshold trusting the committee to do the filtering correctly on transactions that were encrypted. If you make them publish the decryptions permanently, you obviously have the problem you described. Now, there are other schemes where they can prove that something about the for example, they can prove what some commitment to the transaction was so that a person can make a claim, hey, I submitted this transaction, they say they discarded it. Here's the pre image of that commitment that they say they discarded and you can see it's valid. So there's schemes like that you can use. Yes, Dan, I think yeah.
00:27:42.788 - 00:27:51.330, Speaker C: So did I understand correctly that you're building both a centralized and a decentralized sequencer and then users can choose which one they submit transactions to.
00:27:51.480 - 00:28:00.406, Speaker A: As a practical matter, building a central, enhancing the centralized sequencer to do this can happen much more quickly than building the decentralized one.
00:28:00.428 - 00:28:01.638, Speaker C: But eventually there'll be two.
00:28:01.724 - 00:28:06.774, Speaker A: Eventually, yeah, eventually we expect there'll be centralized and decentralized users can choose which.
00:28:06.812 - 00:28:08.310, Speaker C: One to submit to.
00:28:08.460 - 00:28:24.990, Speaker A: No. So the chain as a whole needs to choose. The chain needs a sequencer so each chain can decide for themselves the sort of flagship Arbitrum chain would for that chain, it would be decided by governance, but for an app chain, it's up to whoever governs that app chain. Okay, yeah, perfect.
00:28:25.060 - 00:28:45.050, Speaker C: Makes sense. Thanks. Quick question. Related, what does the process look like for the safe transitioning of the centralized to decentralized sequencer? How do you mitigate for some unintended consequences, like maybe no fees to infrastructure might lead to liveness issues or yeah, how do you mitigate for some unintended consequences?
00:28:45.150 - 00:29:45.000, Speaker A: So whoever is the sequencer, whether it's centralized or a committee, there needs to be what amounts to an agreement with the chain in which that party is going to get paid to do the work, right? Otherwise they're not going to do the work. And so the and so the answer is essentially that when you switch from centralized to decentralized, the chain will pay the participants in the decentralized committee to do this role and fire them. If they don't, presumably they'd be chosen based on trust, so they're not likely to be anonymous parties. It's hard to imagine that if you're electing a trusted committee, that an anonymous party who's not like sort of a non identity, who's known, could be elected. So there'll be known entities and they can expect to get fired if they don't perform, but they would expect to get paid for their work. Yes.
00:29:47.630 - 00:29:57.770, Speaker C: I'm curious if you have an app specific roll up, what are your thoughts on the application expressing rules on which bundles are allowed and not allowed?
00:29:58.430 - 00:31:05.966, Speaker A: So you could do that, right? If you have an app chain, you could say things, you could say you can submit bundles, but we have this predicate and we'll discard bundles that aren't like that. One thing to note is that bundling does help some in this setting, but a bundle is not as powerful a notion as it is in some other models, compared to just separately submitting what would otherwise be the components of the bundle. What you get for a bundle are just the two things guarantee of being in the same sequencer block and guarantee of being consecutive in that block in the order you wanted, if the bid is the same, and that is valuable. But let me generalize your question a little bit. If you have an app chain that has a special kind of application and want to have a different ordering policy, you could do that. You could have a different sort order. For example, you'd give up the economics that I was talking about early, earlier, because you're creating a different kind of structure, but certainly you could do that.
00:31:05.966 - 00:31:11.422, Speaker A: You can have whatever rules you want for even which transactions are valid. Thanks, everybody.
00:31:11.556 - 00:31:15.390, Speaker D: All right, let's think it's.
