00:00:08.730 - 00:00:39.126, Speaker A: Hi, everyone. My name's Theo. I'm one of Guillermo and Jarris's many alts. I'm a PhD student optimization at MIT and do research for Baincap's Crypto Fund. And I'm going to talk about how to optimally route through decentralized exchanges. So this is executing trades like swaps, et cetera, over networks of decentralized exchanges. And the main point to take away from this is that the routing problem, so that includes things like arbitrage, swaps and so on, is a convex optimization problem.
00:00:39.126 - 00:01:10.020, Speaker A: And the reason we care about that is it can be efficiently solved to global optimality. You'll note that it's convex when we ignore gas. I'm happy to talk about this at the end, it's actually pretty minor as a detail. So with this we'll get into the math. So first I want to review constant function market makers. This is going to be similar to Tarun's talk if you were there. Next we're going to kind of formalize what this routing problem is, so how we can actually write it down in a very nice way, then talk how we use this to look at things like swaps, arbitrage and so on.
00:01:10.020 - 00:02:02.222, Speaker A: I promised an efficient algorithm because it's convex. We'll talk about a sketch of that algorithm and then wrap up. So first, most decentralized exchanges, or at least a lot of the big ones, are implemented as constant function market makers. And so these are defined by their trading function which we'll call phi, which map the reserves to some real number. And phi in all cases that we really see is concave and increasing and it accepts a trade where we input some basket of tokens delta and receive some basket of tokens lambda. If essentially when we look at the new reserves discounted by some fee, which is gamma here, the trading function evaluated on the new reserves is greater than or equal to the trading function evaluated in the old reserves. And so we can look at a lot of the current decentralized exchanges through this lens.
00:02:02.222 - 00:02:55.202, Speaker A: So for example, balancer and uniswap fall into this general class of things called geometric mean market makers, where the trading function is just a weighted geometric mean. For example, uniswap is r is a two vector and the weights are going to be equal. Even some of the more complicated trading functions like curve, again, can be looked at through this CfMM paradigm. So with that we're going to actually use this to formalize what the routing problem is. And when we look at networks of Cfmms, a lot of times these are represented by a graph. So one common thing that I've seen a lot is using the tokens as the nodes and then putting the edges as basically the exchange rates between these two. One issue with this is it's hard to handle things like three pools and also a lot of times we have multiple Cfmms where I can exchange one token for another.
00:02:55.202 - 00:03:41.010, Speaker A: So for example, for dye to ETH. I can go to uniswap for that, go to balancer and so on. So I think a more natural representation of this is a hypergraph and this is just a generalization of a graph where edges can connect more than two vertices. So here for example, you see that the curve pool has dieath and USDT in it, or sorry, dieth and USDC in it. Another way to look at a hypergraph is essentially you have this bipartite graph where your Cfmms are on one side, your tokens are on another side and each CfMM is associated with some number of tokens. Similarly, you can trade each token in some number of Cfmms. Essentially this just increases the complexity a lot from the first case we saw and Good bookkeeping is essential.
00:03:41.010 - 00:04:11.526, Speaker A: So to do that, we are going to kind of take a global view and label all the tokens in the universe that we care about as one through N. Label all the Cfmms as one through M. One thing. To note here is usually M is going to be way larger. And this was alluded to by some of the other speakers, where even if we have a modest number of tokens, if we have a ton of swap pools between all these tokens, m might be on the order of N squared. So it can blow up quite fast. Each CfMM which we're going to call I is going to have Ni tokens.
00:04:11.526 - 00:04:57.370, Speaker A: So for example, a swap pool, the local indices would be one to Ni. So it'd be one and two in a swap pool. And we're going to trade this local basket delta I, lambda I with Cfmmi. And again, this trade is only accepted if when we evaluate the trading function on the basket of or on the new reserves discounted by some fee, it's greater than equal to the trading function evaluated on the old reserves. To bookkeep the network component of this, we are going to introduce this matrix AI, which maps from the local index of a CfMM to the global index. So for example, we might have a dieath swap pool where the local indices are one and two. But perhaps the global index of die is three and the global index of ETH is one.
00:04:57.370 - 00:05:39.794, Speaker A: So all that would do is when we multiply AI by our local vector, we would take the first entry, put it in the third position, take the second entry, put it in the first position, everything else would be zero and that would be a vector of size N, which is our global universe of tokens. So using all this formalism we can actually write out what this overall net trade with the network is. So for each CfMM I gain lambda, the vector lambda of tokens I input the vector delta. So our net trade is lambda minus delta. And then we map that from the local index to the global index and we sum all these up. So I promise all this formalism is going somewhere. And before I introduce the model, I'm going to talk about a few simplifying assumptions.
00:05:39.794 - 00:06:04.000, Speaker A: Again, we ignore gas fees. I'm happy to talk about this at the end, but just for the purpose of showing this as a convex problem, we are going to ignore that for now. In addition, we're not going to worry about transaction execution ordering. There are a lot of people in this room that are way more qualified to talk about this than I am. I'm not a searcher, I'm only a researcher. So just want to throw that out there as a disclaimer. And like I said, we can kind of return to these at the end if people are interested.
00:06:04.000 - 00:06:44.160, Speaker A: So the routing problem, the final piece of it that we need is we need some utility of the net trade. So we need some way to say like when a net trade is good and when a net trade is bad. And with that we can actually write down exactly what the optimal routing problem is. And so it's to maximize that utility function of the net trade, the net trade being this thing that we just constructed kind of with the notation I introduced. And then of course we have the trading constraints introduced by each individual CfMM. So we can use this routing problem here to talk about things like swap, arbitrage, et cetera, by encoding those in that utility function. U.
00:06:44.160 - 00:07:33.630, Speaker A: And this is again what gives our satisfaction for the net trade that we make. So for example, for Arbitrage we have some external prices, say from an infinitely liquid reference market, or our own internal prices, or maybe we just want only ETH out of the arbitrage. So we set everything to zero except for the price of ETH, which we set to one. But essentially optimal arbitrage is finding kind of the best net trade subject to that net trade being entirely positive. So we don't actually put any money into that net trade, it's only extracted. And so you can see here we can write that out as essentially just the dot product of our price vector with our net trade minus this indicator function. And so all that indicator function is doing is it's making it so our utility is negative infinity if our net trade isn't non negative and otherwise it's just zero.
00:07:33.630 - 00:08:21.260, Speaker A: So this just encodes that constraint. In addition, we can use this to talk about things like swaps. So this is not a swap with an individual CfMM, instead it's a swap with the entire network. So essentially, if we have some fixed input of token I, how much of token j can we take out of the entire network of all the Cfmms that we have available to us. And so a lot of routers or like Dex aggregators do something like this. And so again, we're going to maximize the amount we get out subject to putting a certain amount in and then just that the net trade for everything else should be zero. So if we route from, let's say, like Dai to ETH to USDC, and we want kind of just the route from Dai to USDC, we don't want the net amount of ETH to be positive or negative, we want it to be zero.
00:08:21.260 - 00:09:20.234, Speaker A: And more generally, this can be used to optimally purchase or liquidate a basket of tokens or trade one basket of tokens for another. And you can almost think of this as capturing arbitrage opportunities as part of the swap. Because like I said earlier, if it makes sense to trade instead of trading from token I, token J, trading from token I to token K to token J, and then maybe trading some directly from I to J that will be captured in this formulation. So now that we've kind of introduced why one should care about this type of problem and how it can be used to encode a lot of the things that we're actually interested in, I'm going to talk about an efficient algorithm for actually doing so. And this is really where we are going to rely on using convex optimization and convex duality. So what I introduced earlier is the primal problem. And so that's given all the constraints we have and given what we want to do, how do we find the optimal trades? There's actually a dual problem here and that can be think of as finding the optimal prices.
00:09:20.234 - 00:10:05.566, Speaker A: And it's not really prices in the traditional sense. The idea is if you give me a utility function, you say, this is how I value the net trade, I could essentially give you a vector of, let's call them shadow prices at which you value each token. And that means if you have this vector of shadow prices, you can go to all the individual decentralized exchanges and arbitrage them independently from each other. And additionally, this can be executed in parallel. So you can see how this kind of has the underpinnings of what we would need for an efficient algorithm because all we do is we iteratively update these prices. Where convexity comes in is, because we have strong duality, we can instead of solving the primal problem, we can solve the dual problem. And that gives us the solution to the primal problem.
00:10:05.566 - 00:10:31.080, Speaker A: I'll very briefly go over what this actually looks like. So the dual problem is this expression here. So it's minimizing essentially the conjugate function of our utility plus the individual arbitrage with each CfMM. The conjugate function is something that you don't really need to worry about. It's typically easy to evaluate. Actually it's for swaps and for arbitrage. It's essentially a closed form thing, so it's not that bad.
00:10:31.080 - 00:11:17.718, Speaker A: And in addition, the arbi is just the optimal arbitrage on Cfmmi with some known global token prices. So these can be done completely in parallel from each other. And that optimal ARB problem is just this thing down here where we're maximizing the amount that we get out of this CfMM subject to our token prices and the trading constraints, because this is an unconstrained convex problem. And in addition, this variable is only a vector of size N. It's quite fast to solve. We're handling all the CfMM parts, which is on order N squared in parallel, and we're only looking at kind of this variable that's size N to actually iterate this. And more importantly, to add a decentralized exchange to this formulation, all you need to do is define the arbitrage function.
00:11:17.718 - 00:11:56.740, Speaker A: So if you know how to arbitrage, given some external, infinitely liquid reference market, so God gives you the prices and you have to arbitrage. If you can do that, you can add the decentralized exchange to this formulation. And of course, there are a lot of details that I didn't kind of glossed over for this algorithm. And so I'd encourage you. We actually have an open source implementation of this. So to check out this package and the associated documentation which go through basically what this algorithm looks like in a little bit more detail. All right, so to wrap up routing with no gas fees is a convex optimization problem.
00:11:56.740 - 00:12:28.566, Speaker A: This means the reason we care about this is it can be quickly solved to global optimality. Using convexity, we can construct an efficient algorithm. So it's another reason that we care about this. And this is implemented in Cfmmrouter JL, which also has the documentation, has a little bit more of a detailed explanation of what this algorithm looks like. And like I said, there is a lot of future work to be done here. So right now we did not include gas fees in the formulation nor in the implementation. And for that you need some good heuristics.
00:12:28.566 - 00:12:58.186, Speaker A: Luckily, this is a problem that's very similar to things that people have studied in other fields, like sparse regression. So there are very good techniques that people know right now to how to do this. In addition, you could include things like liquidations in this framework. So, like gas, this is kind of a discrete thing and this is something that we're thinking about extending the framework to. Finally, probabilistic constraints are important when you have transactions that might fail. And we'd like to add some of these additional features. In addition, in the open source package, I will give a warning.
00:12:58.186 - 00:13:40.640, Speaker A: It's not super optimized, it's more intended to be used as a reference implementation. But we do hope it's quite fast regardless. So thank you very much. If you want to check more things out, the associated paper is optimal routing for constant function market makers package, like I already said, is CfMM JL. And feel free to contact me on Twitter. Thank you. It any questions? Yes.
00:13:40.640 - 00:14:36.640, Speaker A: Will the gas fees make the objective non complex or the solar? So I guess with gas fees, there's several ways to formulate it. So if I formulate as like a cardinality actually I wasn't sure how much time I would have, but I do have actually some slides for gas fees. So we can go over that real quick. But essentially you're introducing you can model this in the constraints with some constraint that basically says do I use this decentralized exchange in the trade or not? And if I do use that in the trade, then this a to I is one and my gas fee is Qi. So I just add this to the objective that might not be the best way of going about it. So this is a mixed integer convex program. There are some efficient solvers, especially if you're dealing with pretty small sizes of this problem.
00:14:36.640 - 00:15:20.102, Speaker A: However, there's also good heuristics for this type of thing. So one thing that kind of you can pull from, I mean this has been invented by like seven different fields who all claim to invent it, but essentially so I won't name any fields. But the L1 norm tends to be a really good heuristic for cardinality. And so you can basically think of gas as like the cardinality of the trade vectors. So if your trade vector has cardinality zero, you're not using that CfMM, and if it has cardinality one, you are using it. And so we can write essentially what the approximate gas would be, which would be for each of these. It would be whatever the gas cost is times the cardinality or something that kind of looks like the cardinality.
00:15:20.102 - 00:15:58.262, Speaker A: And then we're going to normalize it by the size of whatever this is. So like Ni would be two for a swap pool. And then this is like what I would do at least is I would solve something like this. So this problem is actually convex if you kind of use the same type of machinery that we did to come up with the efficient algorithm, you can also write a very, very fast algorithm for this. And then of course, there's fancier things that you can do with like reweighting the L1 norm iteratively and solving a few convex problems. But so gaspies do fit into this. It's just a little bit more complicated because then you have, I guess some freedom of expression in terms of how you formulate that problem heuristically.
00:15:58.262 - 00:16:38.610, Speaker A: So it's a little bit of room for creative expression. There are the Fry eyes, usually these no, they're usually so concave and increasing essentially. So for example, like uniswap is going to be so for uniswap, if you have reserves like R one and R two, it's a two vector. It'd be like square root of R one, R two. So the geometric mean of those two. And then most of these things are going to be concave, increasing functions. Any other questions? And sorry, that would be uniswap V two.
00:16:38.610 - 00:17:19.170, Speaker A: Just to clarify. Well as a follow up question, like you mentioned, it's just fee two what do you do for fee three? Well, yeah, actually, this formulation is like a tiny bit of a lie. I'm glad you asked. I swear he wasn't a plant. So there's like two things here, I think. One is that you actually only need to define so in the algorithm I presented, you only need to define the Arbitrage function. And this can be done pretty efficiently for uniswap V three as well.
00:17:19.170 - 00:17:54.424, Speaker A: Like I said, the formulation is a tiny bit of a lie. You actually basically only need a convex reachable set. So you just need that your updated reserves with kind of the basket discounted for fees is in some convex reachable set. Actually, this is also a little bit of a lie. You only in fact need that Delta Lambda is in a convex trading set. Just the ability to write this down in the form with phi actually makes this quite a bit easier to kind of talk about. And so that's why that was the presentation that I used.
00:17:54.424 - 00:18:44.864, Speaker A: And of course, if you want to implement this in practice, if I give you some arbitrary convex set, that can be very hard to actually implement. Oh, yes. Just a quick question. So how do you define the Arbitrage function for an LP position that's being lent out for some sort of context, basically, as the Arbitrage? Let me find it. I guess you don't care what the LPs are doing, right? You can see what the state of kind of the exchange is, so you can see kind of what the prices are quoted or the reserves, whatever. So all you care about is you have some prices, you have to make some trade. You know how this is going to affect the reserves.
00:18:44.864 - 00:19:40.520, Speaker A: So basically, you know, kind of what trade you can make. And so all this is saying is, given my external prices, make the best trade out of the trades that I can make. So you don't really care what the LPs are doing in this case as somebody just executing a trade across a bunch of markets? Yes. So I can talk about our performance. So we implemented this, and I think with 10,000 swap pools, it was 100 milliseconds or so to do it, and I think it was around a second. It scaled linearly, essentially, which is the other nice thing about something like this, is kind of when you add you're only adding kind of some, in a very rough sense, linear complexity as you add additional pools. And then it was about a second when we did this with 100,000.
00:19:40.520 - 00:20:17.780, Speaker A: That said, I think you probably could get like two to five x speed up pretty easily on our implementation. Super optimized code is always harder to read, so we wanted to make sure that it was performant, but still pretty easy to read and good to use as a reference implementation. Thank you. Anything else? Great. Thank you very much. You think.
