00:00:15.080 - 00:00:53.970, Speaker A: Hey, am I live now? Oh, my God, dude, YouTube? You got to be kidding me. Hey, everyone. Okay, I thought I was streaming for the last 30 minutes and, okay, maybe do a tweet to say you had some trouble starting it. Yeah, thanks, guys. All right. Hey, everyone. So, yeah, I thought I was streaming for the last 30 minutes and, yeah, I thought.
00:00:53.970 - 00:01:39.630, Speaker A: I thought, yeah, apparently YouTube, you have to click go live in addition to streaming from, you know, your obs or whatever. Oh, boy. I guess we got to restart. Okay, let's restart. Okay. All right. Okay.
00:01:39.630 - 00:02:13.058, Speaker A: Damn. Sorry, everyone. Yeah, this is the first stream on YouTube, so, yeah, forgive the technical difficulties. Alright, so starting again. So, okay, we. We're gonna build just a dead simple swap, like the most basic possible example. We're just gonna start from scratch.
00:02:13.058 - 00:03:15.590, Speaker A: Oops. All right. Okay, so if you want to follow along, check out the link in the banner. Zero Xbroc GitHub IO livestreams. I've got like a content outline here that sort of covers what we're going to do and has links for the stuff that you need. Okay, so, okay, let's start off by running swap gethenness. So go here, GitHub flashbots, swap geth.
00:03:15.590 - 00:04:15.528, Speaker A: Clone that baby. Once you've cloned it here, make suave. If you want to run, if you want to run it locally or, because I've already done this, I got to turn it off and turn it back on again. If you want to run the stack in docker compose, just run make devnetup. It will build everything in Docker and it will run suave geth, which is like your core suave mavm, and then it will run suave execution geth, which is a modified ethereum l one, like geth node. And it just has some custom endpoints for suave to communicate with the mevm. Yeah.
00:04:15.528 - 00:04:36.886, Speaker A: So l one and l two can communicate. It doesn't really. Doesn't matter a whole lot if you're just starting out. Like, you don't have to get into that. But yeah, just so you're aware, that's, that's what we're spinning up here. So, yeah, here's mevm. And then there's suave enabled chain.
00:04:36.886 - 00:05:06.540, Speaker A: That's suave ethereum. Suave execution Geth is the other thing we're running, so don't really need to worry about that, but. Okay, so when you're running swabgeth, you should see something like that if you're running it with Docker. I'm just going to stick with that. For the demo. Okay. And then in this live streams.
00:05:06.540 - 00:05:52.950, Speaker A: So if you go to GitHub zero Xbrox live streams. So I'm going to push all the code here, and then I'll just put it in a swap directory here. So you'll be able to pull this code as I write it and run it yourself. Okay, so let's start. Let's just build the, let's build the swap. So a swap starts with some smart contracts. So we shouldn't have this here yet.
00:05:52.950 - 00:06:32.420, Speaker A: Okay. Oh, man. I did this on the main branch. Okay, sorry. So, yeah, this all shouldn't be here. But you would run forge init and then you would get this. If we open that up, an editor.
00:06:32.420 - 00:07:19.030, Speaker A: Yeah, we just have the basic forge project. And what we'll do is we'll just take this counter project and turn it into a swap. So start doing that. We need to import swab STD. So just forge, install flashbot suave STD. And we've already installed it here, so that's going to give me an error. Let's just make sure we have the most up to date dependencies.
00:07:19.030 - 00:07:57.310, Speaker A: And now, yeah, this looks good. So now we can use suave in our smart contract. So we'll just call import suave from suave std slash suave suave soul. Okay. Autocomplete is iffy here. The plugin doesn't do too well, but here it is. So this is like everything that we have access to.
00:07:57.310 - 00:08:45.620, Speaker A: Yeah, check it out if you want to get a sense for what we can do with suave. But there's some pretty cool stuff in here, but. All right, what we're going to be using is the confidential inputs. So in this function setnumber, you see, it takes this argument in the traditional call data, and we want this argument to be confidential. So call data is public to the mempool. If you see pending transactions, you'll see this, you'll be able to read it before, before the transaction is executed. And that's what we want to make confidential in this example.
00:08:45.620 - 00:10:53.696, Speaker A: So we'll delete that parameter from there and we'll read it from confidential inputs. So to do that, first make a bytes memory, something and need to call suave confidentialinputs it. Oh, did I hit the mic? Is it back on now? Dude, streaming is hard. Hold on. Yes. Is it back? Oh, my God. Sorry, y'all.
00:10:53.696 - 00:11:45.120, Speaker A: Once again, streaming is hard. I have a, I have a mic mute hotkey that I must have accidentally pressed. Okay, so let me make sure I've explained everything. What we're doing is replacing this call data parameter with a confidential inputs parameter. And so when you're, when you're calling a function with a confidential request, everything that happens in that function has to be an off chain operation. It can't modify any on chain state. So yeah, we have to comment out this state assignment here and move it somewhere else.
00:11:45.120 - 00:12:33.220, Speaker A: And we'll set that up in just a second. Real quick, we can delete that. We're not using it in this function. We want to make sure that we're calling this function from a confidential compute request because we're going to be doing off chain operations. We want to make sure this is being called via a confidential request. So the way we do that is we can just make an assertion or require, do require suave isconfidential. And so that's just like a helper method that makes sure that this is being called from a CCR confidential compute request.
00:12:33.220 - 00:13:23.956, Speaker A: And for convenience we can even move that to a modifier. This is what I usually do. So then you can just say confidential here and now if you call this function and you don't call it from CCR, it'll throw an error, it'll revert. Alright, so now how do we set this number we can't modify on chain state here. So we have to, we have to do it somewhere else. And the place we do that is in a callback. So, I'm sorry, one sec, let me close the chat.
00:13:23.956 - 00:14:07.958, Speaker A: I want to open up the chat again. Sweet. Okay, so we got to set this in a callback. And this is how swab separates on chain off chain operations. So we can just write a new function like onset number confidential, not confidential. Let's see why later onset number will actually take the number as a parameter here. And that's where we can set it.
00:14:07.958 - 00:14:48.132, Speaker A: So number is being set here. And then to actually trigger this the way we do this in suave smart contracts, you have to abi encode the call data in the return value of set number to call onsetnumber. So let me just write this out and I'll explain it. Modify the return signature of this function, returns bytes memory. And then we need to avi encode. You can use with selector or with signature. With signature is convenient.
00:14:48.132 - 00:15:43.040, Speaker A: If you know, if you just know like onset number, you meant 256 and that's never going to change. But if it does change, which it often does when you're developing, you have to remember to adjust this magic string. And so for that reason I prefer encode with selector, which lets you, so you can actually just reference the selector from a function definition. So if we replace this with this dot onsetnumber dot selector. Kind of annoying that the versus code solidity plugin doesn't pick this up, but it's here and that will just automatically target this function. So if you ever change the signature then it won't, you know, it won't break your code. This will still be a good reference.
00:15:43.040 - 00:16:33.540, Speaker A: Okay, so then our ARG is new number. All right, so now when we call this function with a CCR, it's going to take the confidential inputs that we gave it, decode them into a UN 256, and then return the call data to call onset number, which will take care of the on chain state updates that we want to do. Okay. Onset number is also events are state updates as well. So if you wanted to emit events, that's where you would do it. So we could make one, for example, number set and emit it here. Emit number set, new number.
00:16:33.540 - 00:17:19.440, Speaker A: Cool. So now that's good to go. All right, so let's just build everything, make sure it works. Okay, so the counter test is failing, which makes sense because now it's testing the wrong thing. I'm just gonna disable those for now. We'll come back to Tess in a minute. Okay, so the build was successful.
00:17:19.440 - 00:18:05.780, Speaker A: So now we've got a swap that we can deploy to swap gethennesse. Let me get the logs out of here. So yeah, just doing normal get things. But yeah, we want to deploy this to our local suave devnet node. So I like to use forge create for this. And we'll need a private key to send this transaction with. So I've got a pr here for the docs.
00:18:05.780 - 00:18:40.580, Speaker A: It's not merged yet, but we'll just use this pre funded account. So this is just like included with suave geth Devnet. This private key has like 10 billion ether. So we can test with that and do whatever we want. But yeah, we'll forge create private key and then we just need the, need the path. So source contract or. Yeah, source counter Sol and the name counter.
00:18:40.580 - 00:19:21.594, Speaker A: Okay, so that's deployed to this address. We can just save that. But we need something to call this. We need something to actually interact with this swap. So there's a handful of clients that you can use. The one I'm going to be using here is in typescript because it lets you make web apps as well as server side apps. So that's what we'll be doing here.
00:19:21.594 - 00:20:01.550, Speaker A: But if you want to use a different programming language. There are a couple other options. There's suave alloy from this guy Miha, so you can use that if you want rust. I'll post this in the chat and then there's some examples in Geth here as well. And I'll post those. So yeah, if you want to use rust or go check those out. Yeah, this one's typescript.
00:20:01.550 - 00:21:13.110, Speaker A: Okay, so yeah, we could see from the suave geth logs that our contract creation worked. So okay, let's build some code to actually interact with the swap. All right. Okay, so if you go to the live streams repository, I already have it open, don't I? Yeah, this branch is live. Ignore this. Here it is, swap livestream. So if you want the code to just run yourself, you can just get it here and I'll just be pushing it to this branch.
00:21:13.110 - 00:22:14.812, Speaker A: Okay, so we need a new, we need a new project within this project to do some typescript stuff. So just make a directory and let's just roll everything into one. And we'll make a web app because that'll kind of show you everything that swapvm can do. Swap VM is the, is the library that we're using in typescript. But yeah, if you want to make a web app, I like Vita, I think is how it's pronounced. You can just run bun create Vitae. If you give it directory, it won't double nest your project.
00:22:14.812 - 00:23:04.990, Speaker A: If you already made a directory, you run that and I'm just going to choose react. Yeah, you can use any one of those, it doesn't matter. Then in here I'll just install everything to start. And this should give us a starter web app. Yeah, so this is what we're going to be modifying, making a swap out of. I need a new one. All right, so we need to get suave VM in this project so I can just do bun add at flashbots slash suaven.
00:23:04.990 - 00:24:27.940, Speaker A: All right, now let's get out of the solidity code into this here source app. TSX. This is where the magic happens. I'm gonna delete all this boilerplate stuff. I like this little thing here. I'm gonna keep that. Don't need those, man.
00:24:27.940 - 00:25:10.640, Speaker A: Thanks. Hold on, I'm going to fix this. Okay. Is it back now? Sorry, one sec. Hey. Okay, yeah, I definitely gotta move that hotkey. That sucks.
00:25:10.640 - 00:25:46.960, Speaker A: Alright, thanks, chat. Okay, so yeah, all I was doing here was setting up this state hook. This is just like a variable that persists across page renders in the web app. So we'll use this to hold the value that's represented in the smart contract. All right. Then we need use effect from react. Useeffect is just something that runs when we load the page.
00:25:46.960 - 00:26:39.270, Speaker A: We don't actually want that, but we could use that to test. All right, check that out. Yeah. The number is 42. So we'll use set the number when we, when we read it from, we'll query the chain to get the actual value and use this function a bit later. But we need to, we need to set up a wallet and a provider to actually connect to swab to do any of this stuff. So I need to import some swab vm stuff here.
00:26:39.270 - 00:27:31.200, Speaker A: Import git suave provider, git swab wallet. And we need to type transaction request swab. Yeah, that should get us going. Okay, so then when the window loads, it's going to call useeffect and we need to look for the Ethereum provider. So like if you have metamask, which maybe this account doesn't, this is a fresh chrome account, but we'll see if you have metamask window. Ethereum will be populated in the app. So we just need to pick that up and see.
00:27:31.200 - 00:28:00.544, Speaker A: We'll do that like this. So we need this async function. Gotta do some async stuff. And then we'll just call it and then. Okay, so window in Ethereum, this is like the. Oh, whoops, no, backwards. If ethereum in window.
00:28:00.544 - 00:28:36.340, Speaker A: There we go. This is just like the JavaScript way of checking to see if an object has a property, because it's possible that it's undefined, that Ethereum doesn't exist. So we need to make sure here before we try to reference it. But if it is, then we want to say we want to get that window. Ethereum. Ethereum, it's like an unknown type, I don't want to give it a type. See if we can find something.
00:28:36.340 - 00:29:58.700, Speaker A: You can just define its core properties, it's got a request method and it returns whatever. It doesn't like that I'm using any hit. So we've got window Ethereum and this will give us the metamask provider. But if you use the metamask provider, you're locked into whichever RPC that wallet's connected to. So for the suave provider, so it's just basically a swab wallet is just a swap provider with an account attached to it. Swap provider we're just going to be using to read stuff from the chain. And for that we can actually just connect directly to the node and not use window Ethereum, but we're going to set up the swab wallet first, since we're already doing it.
00:29:58.700 - 00:31:04.570, Speaker A: So I'm going to put the wallet in a hook. That's a swab wallethead. Make sure we're importing the types correctly. And suave wallet wants a transport type and our wallet is a, it's called a custom transport. This is just basically letting us know that it's using EIP 1193, which is, which is how wallets take requests from web browsers. So like in metamask, if you want, if you want a metamask wallet or whatever, you initialize this with a custom transport. Okay, so we can just do getswa wallet and then the params it wants are transport.
00:31:04.570 - 00:31:47.268, Speaker A: And this isn't exactly the same as this. I mean it's the same thing, but it's got a different way of doing it. You just need to call it a custom function. So that's there in flashbot swap VM. And this is just a helper function to create this custom transport. Alright? So we can, when creating the custom transport we just pass it this eth window, ethereum, and that should connect us to Metamask. And then after that we just need a JSON RPC account.
00:31:47.268 - 00:32:54.320, Speaker A: So you see there's two optional parameters here, JSON RPC account and private key. So if you have a wallet where you have the private key in memory, then you can just, you can provide it here and you won't have to, you won't have to use a custom transport, you can just use like an HTTP transport. If you're using a custom transport, it's going to expect JSON RPC account because it's basically sending a request with an unsigned transaction to the wallet. And then the wallet is responsible for taking that and signing it. So the JSON RPC account is just going to be the address that you want to sign with in metamask. And then private key is if you have the private key. So we'll use JSON RPC account here and we need the, well, we need metamask to give us the account to use.
00:32:54.320 - 00:34:27.899, Speaker A: So we actually can't do that yet. We need to do, first we need to get the need to call the what is it? Request accounts method. I want copilot to do it, I know it can. Yeah. Oh, whoops. I might be, I'm doing this wrong. Whoops, I, I've got something.
00:34:27.899 - 00:35:52.590, Speaker A: Ah, there it is. That's it. Hmm. Something wrong here. One sec, I've got some reference code I can look up to get this right. There we go. Yeah, so typescript is kind of annoying in that it wants this ethereum provider definition for window Ethereum.
00:35:52.590 - 00:37:15.482, Speaker A: It kind of complains if you don't have it, but we can just define it and then get rid of all this nonsense and that'll make it a little easier for us to reason about what ETH is. It's like screwed up my brackets here. What did I do? Oh God. Okay, there we go. Okay, I'm just going to move this up. Let's see if that worked. Oh, all right.
00:37:15.482 - 00:38:29.724, Speaker A: I. Oh yeah. And yeah, we're seeing here that we actually don't have window ethereum because on this fresh profile I haven't installed it. So let's install it. Where did it go? Extensions. Yeah. Here's what the hotkey is for.
00:38:29.724 - 00:39:12.970, Speaker A: Enter my password. Okay, come on, give me a wallet. Okay, now I got metamask. Now this should work. And yeah, it's going to request my account. And there we go. So eight, nine, b, f, one.
00:39:12.970 - 00:40:09.670, Speaker A: That's us. So let's hold on to that value. Say connected account is. Whatever this returns, it'll just, we'll say it's the first account. So that connected account to account, zero, make sure it's greater than zero. And this should be array of strings or array of hex. Hex is another helper from swap vm.
00:40:09.670 - 00:40:36.220, Speaker A: It just makes sure that there's a zero x in front of the string. Nice and convenient. Unknown is not assignable, but we know what it is. We can force it using as. Yeah, so it counts as an array of hex strings. Looks good. Now we've got the connected account.
00:40:36.220 - 00:41:08.234, Speaker A: Oops. Yeah, so now it's rendering. Cool. Can I move this? Yeah, that's better. Okay, so we're almost. Yeah, we're almost there. We need, we got the account.
00:41:08.234 - 00:42:30.710, Speaker A: Now we need to set up the wallet and we need to set up the provider to connect to suave. So let's see, how should we do this? When we load it, we're going to check to see if Ethereum is available. And if it is, let's also do this. Let's say if connected account isn't defined, because we don't want to be calling this every single time we load the page. We only want to call it if we don't have a connected account. All right. And then also in here, if wallet is not defined, then we want to get the wallet set up, getswab Wallethorne, and it accepts the transport which we're using custom for this because we want to use the metamask provider and this is just custom eth, right.
00:42:30.710 - 00:44:06.500, Speaker A: And then the wallet JSON RPC account and that's going to be connected account and need to make sure connected account exists. Make sure that we cast it to hex. It always will be, but typescript needs to be sure. And then we need to just put that in here so that we have access to it outside of this function. Cool. So now we're nearly there, we got a wallet hooked up and now we just, let's get a provider so that we can do some chain queries, make a use state provider and it takes a transport type generic parameter as well. And this is going to be, I want HTTP transport here because I'm just going to hook it up to my, to my local host to make it easy.
00:44:06.500 - 00:44:54.390, Speaker A: And in this, we don't even have to do it like in this function, we just want to make sure it happens. So we can just say setswap provider to get swap provider. And this just takes a transport. So make one with the HTTP function. So this is just like the custom function but for HTTP. And we can give this a URL localhost 8545. That's where swab geth runs by default.
00:44:54.390 - 00:46:22.720, Speaker A: And now swav provider should be set. So now anywhere else in the app we can say if swab provider set, let's check for the number. When we load the page, how do we check for the number? We also need to import the AVI from the contracts that we built. So here in the swap directory out there's our build artifacts and we need to import that so that we know how to encode the function column. So we can just, we can just import the JSON directly, which is a nice feature of typescript. Let's say import counter from need to be conscientious of the path here. So this is, yeah, up to directories into the out directory, into the counter sol directory and then counter JSON.
00:46:22.720 - 00:47:35.920, Speaker A: Okay, now we should be able to use something like counter Abi. Yeah, see there's all the stuff you need. If you wanted to deploy contracts from swab VM, you could do it here with the bytecode. Yeah, so we just need the ABI and we need a function to call that, you know, that number function. So this, any public variable like this is also going to be represented as a getter function. So we can just call like number and that will act like a function call and give us the number. So okay, let's write a new function to get the number async because we got to wait for the result and swag provider just make sure and just want to be swab provider call.
00:47:35.920 - 00:48:32.640, Speaker A: Let's say that async call. So the arguments for this, let's see, it's like a transaction request. So we'll have two. All right, where do we save the counter address? Did we save it at all? Is our connected account? Yeah, when we created it, it just deployed again here. So there's our contract address. We'll just hard code that for now. So then that's what we're going to send the call to.
00:48:32.640 - 00:48:55.320, Speaker A: Counter address and then the data. This is how we'll encode the function. Call counter Avi. Does that work? Yeah, I didn't think so. That's looks like a geth thing. That's not how that works. Copilot wrong.
00:48:55.320 - 00:49:28.392, Speaker A: Now VM has a function to do this. We can call, just type encode function data, autocomplete should find it. It's in swap VM top level. Yeah. Encode function data, which takes an ABI, which is that counter Avi takes ArG's. Don't know why it's autocompleting to arguments instead of ArG's. I.
00:49:28.392 - 00:50:00.830, Speaker A: But these are just the function arguments. In our case, we actually don't have any. We're calling it with an empty argument. So we can actually just omit that and then function name number. Yep. So yeah, that will call the number function using tall. We'll just do, you know, a non executing transaction, simulate it and give us the result.
00:50:00.830 - 00:50:41.740, Speaker A: Is there anything else we need with this request? Two and data. We don't need gas, so I think that's probably fine. Let's try it out. We need to call this function somewhere, get a number. Let's just try it out and see what happens. Oh yeah, I can see why this isn't working. Now.
00:50:41.740 - 00:51:43.886, Speaker A: We need to set these, these are like dependencies for this useeffect function. So this array down here, if you don't give it anything, this function only ever runs once. But what we're doing is we're actually going through like multiple steps where we initialize the page, we connect it, then we reinitialize the page and render, you know, we got the account or whatever. And then we go through another iteration of this. And so if we don't call this multiple times or we don't allow it to be called multiple times, which is what we're doing here with this empty brackets, then this will never, the swap provider will never be initialized, or this won't ever be called because it'll get initialized and then load won't run again. So we just need to specify these to trigger reloads for different variables. So if we set wallet, we want to reload.
00:51:43.886 - 00:52:09.330, Speaker A: If we set swath provider, we want to reload. We set connected account, we want to reload. React will actually suggest other stuff too, that it thinks you need. So we'll set that. And now, yeah, it's infinitely looping, so. Okay, let's stop that for a second. Oh, boy.
00:52:09.330 - 00:53:08.320, Speaker A: Hold on, I gotta stop this. We did something wrong. We can leave all this stuff, but we just need to conditionally trigger load. So if the ultimate goal for this load function is to load, I mean, aside from initializing the stuff that we need to use, I think this function is considered done when we fetch the number from on chain. So we can just say, like, if the number is undefined and we need a strict check for that because zero could be a number, but is also falsy. So save numbers undefined, then load. Now that's, let me set the number.
00:53:08.320 - 00:53:54.810, Speaker A: Oh, yeah, we still, oh, my God. We still haven't set the number yet. Okay, so run it once, and then in get number. So this res, we're logging res and we see it's got a data field. So you make sure that we're picking that up. Res data. And make sure res data exists.
00:53:54.810 - 00:55:50.730, Speaker A: Okay, I think that should work. No, why is it doing that? Oh, yeah. Okay, so the condition is that the number is defined, but the way we're calling it, I stopped the infinite loop. The way we're calling it, when we get the number back, we're calling parseint, and parseint will be zero. Hmm. Why doesn't that work? I don't know. Let's see.
00:55:50.730 - 00:57:59.720, Speaker A: Just ignore this mod provider here. I'm gonna brain fart. I'm doing something wrong. Oh, setswap provider is always called. Yeah, I think that works. This doesn't need to be there. There we go.
00:57:59.720 - 00:58:23.120, Speaker A: I think that's it. Yeah. Just needed to prevent. Yeah, infinite loops, a little bit tricky, but there we go. It's good. So now when it loads, it's going to look for Ethereum. It's going to make sure we have a swap provider, and if not, it's going to make one.
00:58:23.120 - 00:58:57.560, Speaker A: This will, you know, this will loop through and fix its own conditions until everything is good. And then as we go through, it will render more and more of what's available. So now we can see here number zero. We're getting that from on chain. So it's pretty good so far. Now we want to actually change the number like this. Move it inside the use effect callback.
00:58:57.560 - 00:59:26.530, Speaker A: Nah. Okay. I don't like these lines, so fine. All right, that looks good. So yeah, let's get to sending it. So we need a transaction request swab, that's what this thing was for. And make a function for that.
00:59:26.530 - 00:59:54.760, Speaker A: Send CCR. All right. Make sure the wallet exists and it's already, okay. It's starting us off pretty well. Well, counter address is correct. We're going to set function data in the data field. So this is how we're going to call the function.
00:59:54.760 - 01:00:47.748, Speaker A: So we'll call set number here, set number. And again, we can remove, or we can omit the aRg's parameter because we're not sending, yeah, we're not sending arguments here. We only need the function name in the data and that should be enough. Everything else goes into confidential inputs. So yeah, this is where we specify here what is going to be read here. So confidential input. We just need to abi encode this event 256 style integer.
01:00:47.748 - 01:01:28.046, Speaker A: So you can use this vm helper function, encode Abi parameters, two arguments. The first one is a list of types, type definitions you can, like, you can see copilot is value. You can use the name of the argument. You don't need to, I'm just going to use types. And this is just like a string representation of the type name. Here we have one argument. It's a unit 256.
01:01:28.046 - 01:02:02.186, Speaker A: And then we'll actually pass the argument. And the argument, yeah, it's TDD because we have not set up the input to change the number reaction. So yeah, let's just do that real quick down here. Input number type on change, set the number. Yeah, looks pretty good. Target value. Yeah.
01:02:02.186 - 01:03:28.620, Speaker A: So it's taking this string, parsing it into the integer and set the number. Oh, this is actually not quite right. Set the number is our terminal foot. What we want is everything from, yeah, we need to pass whatever this is, whatever the input is giving argument. We're always going to be getting a string in this case and send CCl is like an app specific function. So I don't feel like I need to go down to like big into a number. I can just assume that it's all as a string and I'll just decode it at least into a big one.
01:03:28.620 - 01:04:49.690, Speaker A: Okay, so we got our confidential input. We need the pedal address in CTR. This is basically, it's like an account in swab that this response, it actually sends a callback. So like when you call this setnumber function from CCR, so you're calling this function and returning this, and then the kettle account is going to take this call data and it is actually calling this concept limit function. Anyways, for our purposes, we just need to know the address of it. So once again, I've got my handy dandy pr here. Take the kettle address and pop it in.
01:04:49.690 - 01:05:48.550, Speaker A: This is probably something we could also. This address is specific to the devnet if you're doing this on the live. Oh, is that better? Yeah, I see, I see the white noise you were talking about on the visualizer. Sorry about that. Ping in chat if it keeps happening. Yeah. Okay, so kettle addresses, if you're on like testnet, this address will be different.
01:05:48.550 - 01:06:56.196, Speaker A: But yeah, just keep in mind, you know, keep your kettle addresses close. Okay, so the last params we need are gas and gas price. Standard stuff. I'm just going to estimate like for this one, no more than 100,000 most likely. I'll just try that. The reason I'm just setting these manually, I haven't been able to get the estimate gas to work implicitly. But you can do, you can get the gas price from your swab provider, get gas price, you can use that.
01:06:56.196 - 01:07:54.000, Speaker A: But for the actual amount of gas used, I've been, yeah, I've had some trouble getting it to work in swap VM. So for now what I've been doing is just setting this high and then you can run it and check the transaction receipt and that'll give you how much was actually used and then you can adjust from there. Okay, so that looks like everything data, confidential inputs, kettle address, gas. We could do type as well, but it's optional. It should be, you know, if you specify confidential inputs or kettle address, then this type will automatically be filled in for you. But we can just specify it anyways just to be verbose, but. Okay, so this is, this transaction request is ready to go.
01:07:54.000 - 01:09:03.520, Speaker A: We just need to sign it and send it. So just go wallet dot send transaction tx and we'll get a TX hash back from that. So yeah, we'll grab that. We'll just log it for now and then all we got to do is link it here. So NcCr e target value. Oh, and this actually, well, let me just make sure that I'm not doing this incorrectly. This value is a string, but it's a decimal string.
01:09:03.520 - 01:10:23.130, Speaker A: So this is expecting a hex string. I don't know how about that, that's kind of goofy. This is my right thing, but that'll work. Parsing an integer to string base 16 and string is not assignable to parameter of type. Okay, so we just need to make sure we're explicitly declaring that's a hex and that should work. Okay. Right.
01:10:23.130 - 01:10:53.600, Speaker A: And then we were going to, well, we need to set, oh yeah, that's, oh, whoops. So I'm, this is the input. I was thinking about the button. This is what we want to put in the button. My mistake. Um, this is actually, this needs to update our, the number. No, no, we need a new one.
01:10:53.600 - 01:11:42.820, Speaker A: Input num. Yeah, there we go. So make sure I don't get confused again from on chain. Use input number. Okay. Input anonymous function to call this with an argument of our choosing. And this is, oh no, this is a, yeah, one of those e target value.
01:11:42.820 - 01:12:23.772, Speaker A: Yeah. So whenever this, you know, whenever we're typing, every keypress is going to trigger this set. Input num. And then we need a button. Yeah, that's what we were looking for. And then we just got to do this thing again. And this is not that anymore.
01:12:23.772 - 01:13:18.940, Speaker A: This is input num. We got to make sure input num exists in this context. So make sure input num here. So I just wrap this in some curly brackets and then I, that allows me to put JavaScript sort of intermixed with the HTML here or JSx or whatever it is. So this is just asserting that if input num exists, then we'll render all this stuff, but if not, then we'll just do nothing and you won't see the button. So, okay, we should be able to check that out. Now.
01:13:18.940 - 01:13:38.220, Speaker A: Input none is undefined. So no button. Nice. And it's broken. Okay, you take like a two minute break. Yeah. I'll be right back.
01:13:38.220 - 01:16:13.620, Speaker A: Okay, so we got an error. Cannot convert one e zero f three to a bigint. We probably parse the string incorrectly somehow. Input num. Bigintumen, or rather what's, well, yeah, what's inputting them? Let's expand this, get the brackets right. Okay. One click.
01:16:13.620 - 01:16:56.570, Speaker A: Okay. Input num. Type of input num. Yes. Decimal string. Well, see, that makes sense. Oh, I know.
01:16:56.570 - 01:17:29.500, Speaker A: It just needs a zero x in front of it. Yeah. Okay, that's good. So now we got a new error. ETh sign has been disabled. You must enable it in the advanced settings. So yeah, this is a good time to explain the sort of structure of CCR's confidential request.
01:17:29.500 - 01:18:33.972, Speaker A: So the confidential request type the structure of the thing. It's basically got an inner type and everything else that's in the wrapper. And the input type is what we sign over. And crucially, we don't sign over confidential inputs because if we did, then you would have to reveal confidential inputs to verify the signature. So instead we sign over confidentialinputshash. We put that in the inner object, that's what we sign over, and then the whole thing is sent like a normal transaction. But yeah, what I'm getting at is the structure of the transaction itself is not compatible with like normal wallets.
01:18:33.972 - 01:19:49.700, Speaker A: That's why we have swab vm to handle that custom encoding and signing of the transaction request or the CCR. So to make this work for metamask, what we had to do with the way we have it now we have to use ETh sign and we just have to give it that inner object to sign directly rather than using those convenient, you know, send raw transaction or sign transaction or whatever. But yeah, because of that, we need to enable ETh sign danger mode in metamask with, with the EIP 712 pr and swap Geth. That all goes away, which is super nice. Essentially what we did there is we just replace the inner object with an EIP 712 message. And because it's an EIP 712 message, it plays really nice with metamask. So when you want to sign an EIP 712 message, metamask will give you that whole JSON outline of what you're actually signing, rather than just some opaque hash.
01:19:49.700 - 01:20:36.590, Speaker A: And you don't need to specify the RPC endpoint. So one thing I haven't done yet here that I need to do is I need to add my swab geth devnet to my metamask networks. So I'm sending the request to the right place. So just do that real quick. Suave localhost five. The chain id for suave geth. It's hard to remember, it's like 161-3185 or something.
01:20:36.590 - 01:21:16.730, Speaker A: But yeah, I can't remember exactly, but it's in the docs. Let me look it up. Ridge testnet Jan ID. There we go. Is that right? 1681-3125 ah, I was close. Okay, where did we need that here? Chain ids, that currency symbol, and we can add the block explorer to Rigel has. Well, actually, no, let's not, because this is localhost, not rigid testnet.
01:21:16.730 - 01:21:47.120, Speaker A: So we'll leave that. Alright, got it. Oh my God. Okay, so we got our account, we're connected to suave localhost. We still need to send ourselves some, some suave eth or some rigile ethnic. And we can just do that from cast. We have our private key here with 10 billion, we can just do a cast send.
01:21:47.120 - 01:22:26.130, Speaker A: And this will be on 8545. That is like an anvil key. And it needs to be this one. Oh boy. Yeah, 91 ab. And then our address that we're sending it to is your metamask. That one.
01:22:26.130 - 01:22:50.900, Speaker A: All right, so we'll send ourselves one ethere. There we go. Let's check metamask. Ah, works great. Okay, so we got that. We're connected. Okay, so everything should be set.
01:22:50.900 - 01:23:28.230, Speaker A: Now we just need to enable Eth sign. So that's in settings advanced. Yeah, Eth sign requests. I only sign yeah. And yeah, we don't like really want to use this Eth sign. It sucks, but that's what we got for now. It's going away pretty soon, but just not 100% there yet.
01:23:28.230 - 01:23:43.714, Speaker A: So. Okay, I'm going to refresh this clean slate. No error messages. Let's try and set the number. All right, we got a sign request. Sign it. And.
01:23:43.714 - 01:24:28.430, Speaker A: All right, we got an error RLP input string. Too long for Boolean decoding in the compute request. Oh. Oh, whoops. Okay, so yeah, underlying error with this new suave geth release. It's not compatible with the original transaction wrapper. So I think we actually, we're going to have to either switch to EIP 712 right now or downgrade swavgath.
01:24:28.430 - 01:25:47.150, Speaker A: I just want to get this working to see it. So I'm going to downgrade swab gethenne. All right, let's just go to this previous commit. All right. Rebuild. Okay. Oops.
01:25:47.150 - 01:26:36.890, Speaker A: Okay, so downgraded suave geth. Now we've got to create the transfer, the, we got to deploy the smart contract again and we got to send ourselves some more ether because we just reset the, we just reset the swap geth state. So just got to redo this stuff. This is a different address here. And then test send, give ourselves another eth. Alright, now we should be back on track. Run this again.
01:26:36.890 - 01:27:22.990, Speaker A: It hasn't detected our new address. We might need to restart the app. Oh, wait, no, that's the account. Whoops, I'm reading that wrong. I want to show the address here too. Okay, so yeah, that looks good. That's the right address now.
01:27:22.990 - 01:27:54.148, Speaker A: New number. Nice transaction hash. Ok, that's good. This succeeded. So let me look at the suave geth logs. Docker logs f to follow and yeah, submitted transaction. Everything looks good.
01:27:54.148 - 01:28:21.450, Speaker A: This is, this error is normal, you can ignore that. But yeah, it looks like it's working. So if I refresh. Yeah, we've got one, two, three. Sweet. So yeah, there's like a couple more things we could do to make the UI a little better. You know, we could, whenever we hit the button, we could wait for the transaction receipt.
01:28:21.450 - 01:29:17.480, Speaker A: So like here, we want to see if the transaction was actually successful because we, we landed it on chain successfully or we got it to the, to the RPC correctly, but we didn't actually, you know, we don't know if it reverted or not. So that's the next thing I want to check. We can do that by getting the receipt. So swap provider dot, get transaction receipt. This takes a hash inside an object like that. So get transaction receipt given the transaction hash. And if we can check receipt, well, receipts not going to be undefined, so we just need to check the status.
01:29:17.480 - 01:30:20.050, Speaker A: So the receipt status is either going to be, well, in the raw form it's one or zero, but in swab VM it's reverted or successive as a string. So let's say if it's reverted, let's just throw an error. Actually, no, I like, I like the affirmative success for successful. If we're successful, maybe we should actually just do a little. Hmm. I'd like to update the number, but I have to break this getnumber thing out. It does seem like a good use of time.
01:30:20.050 - 01:31:29.950, Speaker A: Let's just say, let's make it just a status string. We can render it down here, like right here, conditionally render it and then stem us. Yeah, so we'll just set status with the actual receipt status. Then we don't have to do that. Check here. So then, yeah. Three, two, one, send a new one.
01:31:29.950 - 01:31:56.198, Speaker A: Oh, error. Oh, whoops. Nons. Too low. Hmm. Yeah, so that was another, that's another thing that I need to figure out in swap VM. But it metamask for some reason is not getting the nonce properly from, from suave geth.
01:31:56.198 - 01:32:58.480, Speaker A: So when we send it, we just need to get the nonce ourselves, get transaction count from suave provider, pass it the wallet address. It'd be wallet dot account dot address. And wrap this up in like, what is the. Yeah, just address, get transaction count of address, and then, yeah, we'll just pass the nonce here. This is already the right type, so we're good to go. Transaction successful. Sweet.
01:32:58.480 - 01:33:35.150, Speaker A: I think I maybe put it inside of strong. Yeah, cool. Okay, so that's, that's like a, that's a successful swap. That's just like the basic rudimentary bare bones, as simple as it can possibly get. Swep. Let's see how much time we got left. We got an hour.
01:33:35.150 - 01:34:31.500, Speaker A: Thanks, Ryan. Yes, very confusing indeed. But you get used to it, I think especially, you know, this set number onset, number callback sort of paradigm. It's very, you know, unusual. It's like, yeah, not something that I would expect, you know, solidity developers, ethereum developers to like be familiar with, but yeah, that's how it works. Real quick, I guess we could try out the EIP 712 thing. I can't guarantee it's going to work, but we can see what the state of it is.
01:34:31.500 - 01:36:17.650, Speaker A: The actual migration is pretty simple. So let's see if we can do it. All right, we need to upgrade, swap geth again. Yep. Shut down the old Devnet, spin up the new Devnet rebuild and oh yeah, we also need to update the swab VM. I need to get the right branch here. This is a, is a change that hasn't been merged yet, so I will need to explicitly check out this branch here, let me get that.
01:36:17.650 - 01:37:03.900, Speaker A: Commit hash. Can I use that? I don't remember exactly. If I can do this from GitHub, it might be easier to just build this locally and. Yeah, just link it from my local build. Okay, so, okay, Docker compose is running again. Just before I forget, I'm going to create, whoops, the contract again, same address, because it only depends on the nonce of the account that sends it. So we can leave that and then send myself some ether again for testing.
01:37:03.900 - 01:37:54.808, Speaker A: Okay. And then an RTS swap. Well, actually, before I screw this whole thing up, I'll commit these changes so that we have, you know, so everyone can use it in its working state. Yep. Alright, now we can screw it up. So I'm just gonna. I'm paranoid about how bun updates dependencies, whether it caches them.
01:37:54.808 - 01:38:54.540, Speaker A: I don't know exactly how it works. So I'm just gonna be erring on the side of caution and I'm just gonna remove swap VM directly. Wait, swap? Oh, we're in the wrong directory here. Okay, so remove that and then we need a new terminal. Swab VM, check out that 712 branch. Nah, I want, I just want the branch name. 712 CCR.
01:38:54.540 - 01:39:41.600, Speaker A: Yeah. Alright then, here I need to build, it's going to compile all of my typescript into a library that I can use. Make sure it worked. Yeah. So this is, these are what, these are the like, outputs of the build types. ESM and cjs, and those are different ways of importing JavaScript, but okay, it worked. So we've got that built and now we can run bun link.
01:39:41.600 - 01:40:38.650, Speaker A: Whoops, we gotta get a source for that. So bun link here, and then that will link on my computer this flashbotswap VM to this local build. So then to import it, I can just run that. So then in my swap, where I've just uninstalled the official version, I can run flashbots VM. Now we should have the EIP 712 compatible version. And I believe I don't need to change anything here, because the way this is set up, this method sends transactions. Where is it? Yeah, wallet, dot send transaction.
01:40:38.650 - 01:41:22.390, Speaker A: Well, in this case, I don't want to find it, but yeah, it does the EIP 712 signature instead of esignitive. So I think we should be able to just work straight away. How is this? Oh, it's already running here. All right. Um, right, number zero again. Sets. One, two, three.
01:41:22.390 - 01:41:48.380, Speaker A: Nice. Yeah, it totally worked. So, yeah, this is what the EIP 712 version looks like. You know, it's all the same. You can see we're signing over confidential inputs hash, like I was talking about before, you've got all your transaction values. But yeah, it's not that scary eth sign dialogue. It's this nice looking EFP 712 thing.
01:41:48.380 - 01:42:21.480, Speaker A: And hell yeah, it works. So, yeah, that's, I don't know how much I can say yet, but that's probably what we're going to be doing in suave is this EIP 712 style. So get excited for that. But yeah, I think that's all I have. Let's run back through this checklist and see if we could check everything off. So, made counter soul into a swap. Oh, we didn't write a forge test.
01:42:21.480 - 01:43:04.580, Speaker A: Okay, let me write a forge test real fast to show you what that looks like, because that's important. It's super helpful. So back here, counter t sol, we commented all this stuff out. If you want to write forge tests that use suave precompiles, you can go see if I remember it. I want to look at the source code again. So suave STD source and test. Yeah, so that's what we want import suave enabled from.
01:43:04.580 - 01:44:13.500, Speaker A: So STD test. Um, yeah, this, uh, the plugin is wrong again. This is fine. Yeah, if you want to test precompiles, so say make a counter, what does that do? Ooh, that'll work. Oh, setup. We got to get rid of setup. That's not redo that.
01:44:13.500 - 01:45:23.840, Speaker A: All right. Yeah, so it's in the fallback. This is happening because I believe, because we didn't set, this might be too deep. This is like a, I could go like a whole hour explaining this. How to, how to call confidential, confidential compute requests in a test. There's like a few steps to do, but like, I'll just do the basic version here. So you're just aware of forge tests and how you can use them with suave.
01:45:23.840 - 01:46:04.620, Speaker A: So if you use this suave enabled component. Let's also get suave in here. Swab from suave lib. Yeah, so with this you can test precompiles directly. So if we had something like suave do HTTP request. I need to build an HTTP request memory equals. Hmm, interesting.
01:46:04.620 - 01:46:42.650, Speaker A: I don't know if it needs that. I don't know. Let's try that. I don't know if that's even valid. Code reexpected five. What's in the HTTP request string? URL? String method. So we got URL, we got method headers.
01:46:42.650 - 01:47:14.540, Speaker A: Oh, it's just zero. So that's fine. Body. It could probably autocast and with flashbot signature bool for this one. Hmm. What is it supposed to be? String headers. Oh, the string.
01:47:14.540 - 01:47:43.722, Speaker A: All right. Okay, so yeah, this worked sort of. Um, so we got this error. Precompilereverted domain API dot coingecko.com is not allowed. So this is happening because suave geth, or rather suave execution geth. Well, no, no, sorry.
01:47:43.722 - 01:48:36.640, Speaker A: It is suave geth. Swab geth. It has a whitelist that you have to specify. So I have this little script here that I just, I just use to hold on to my, you know, initialization, you know, just a script to run it for when I'm developing because I change these every once in a while. But if you pass this, this argument here, suave eth external whitelist, you can add in domains here that aren't included by default because by default it's like super locked down. So if you wanted to do this, let's just go all the way. We're going to shut down this Devnet that we have, then we're going to run this local Devnet here with my custom parameters.
01:48:36.640 - 01:49:25.040, Speaker A: Just by running that script, I've set the external whitelist equal to the wildcard. So anything when I do that now, because I'm running this swab geth locally, I've also got to go and run swab execution geth. And I've got another one of these same scripts here. It's a little bit older with old params, but it works. This is just gonna basically do the same thing that I was doing with the Docker compose Devnet. But I'm just running these directly on my machine now. So yeah, now we just need to.
01:49:25.040 - 01:49:57.740, Speaker A: I need to deploy the contracts again and give myself some eth again here. So forge create same address again. That's good. Cast, send. Got my ether. Alright, now our chain is set up again to test with this app and. Oh shoot, man, I missed one more thing I forgot to make.
01:49:57.740 - 01:50:36.960, Speaker A: Oh, I did. Okay. Yeah, it's built. Okay, sorry, one more time. All right, it's initialized. Okay, so yeah, we're running suave geth with now a wildcard for the whitelist. So if we run our forge test, that's calling Coingecko domain not allowed.
01:50:36.960 - 01:52:26.044, Speaker A: What did I do wrong? Huh? Yeah, there might be a new change that I haven't looked at yet, so sorry for the bummer conclusion. But yeah, if you're looking to write, you know, if you're looking to test your precompiles or your functions that use precompiles, this is the way you would do it. Obviously you got to figure out this little error. But yeah, forged tests are really helpful for. They're not really super helpful for testing full integrations, although we have done it. But yeah, it can be kind of difficult. But if you want to test little snippets to make sure that you're calling the precompile right and you're getting the right data back, these forge tests are super helpful.
01:52:26.044 - 01:52:49.940, Speaker A: You can also do console logs here if you get. You have console or console two. And console two just has more helper methods for different types or whatever. But you can do console logs to get. To get your. Yeah, like to print. To print values from your pre compiles, what they return, stuff like that.
01:52:49.940 - 01:53:17.446, Speaker A: So yeah, definitely make use of forge tests when you're developing swaps. Okay, that's all that I have for today. Yeah. Once again, going back to the little checklist we failed here. But we did that. We did that. Sent the CCR with metamask, did all the shit, the metamask once.
01:53:17.446 - 01:53:39.044, Speaker A: And we even got to vip 712. This is a note for myself to disable it for my own personal metamask use. But yeah, that's for you. So. Okay, I think that's all I got. Thanks everyone for tuning in. Appreciate y'all hanging out and.
01:53:39.044 - 01:54:22.972, Speaker A: Yeah, we'll catch you in the next one. The next one is going to be more advanced. We're going to be getting deeper into, you know, a really complicated kind of swap that uses lots of different precompiles. We have, you know, heavy usage of this HTTP request specifically so we can do things like talk to chat, GPT, and make swaps that rely on API values from web two APIs, and you can take web two things and improve them in a web3 way. So it should be pretty exciting. Yeah, we'll get to that. In the next one.
01:54:22.972 - 01:54:34.910, Speaker A: I'll release the outline the same as this one before I announce it, so you'll have all that ready to go when we start that one. So that's all for now and see you at the next.
