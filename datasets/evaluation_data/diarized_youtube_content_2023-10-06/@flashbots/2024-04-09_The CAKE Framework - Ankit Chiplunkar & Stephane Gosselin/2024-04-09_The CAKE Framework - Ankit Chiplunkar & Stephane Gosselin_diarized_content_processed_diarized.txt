00:00:02.240 - 00:00:28.098, Speaker A: Hey, everyone. How's everyone doing? Long day? Great, yeah. Anyone still tracking prices, or are we, like, fully tapped into the infrastructure now? Bad prices. Everyone's below the seats, checking their portfolio. Okay, I'm going to talk about cake. So I spent a lot of time looking at the MEV stuff. I was previously a founder of Flashbots, and then I left, and then I'm actually more interested now at the application layer.
00:00:28.098 - 00:01:06.044, Speaker A: So I want to talk a little bit about that. I want to talk about how MEV is actually critical for the application layer. I think we heard in many of the previous presentation, oh, MeV will be solved at the application layer. The application layer is going to take away the MEV, so we don't need to worry about it. So I guess my role now is to say, how does that actually happen? And sort of provide a framework for people to think about it. So enkid and I, ankit over here, we work at Frontier Research, and we put together this thing called the cake framework. So what is cake? If anyone was here in 2019, it was amazing.
00:01:06.044 - 00:02:11.274, Speaker A: The community was tiny. There was maybe, I don't know, 100 developers in the space, and we all knew each other, we all hang out together, and then we built these really cool applications that no one used. And it was kind of fun, but also sad, because as soon as a user tried to use a web3 app, they had to pay $200 to be able to post a message. And so it was very clear that there was a fundamental problem with the way that development on Ethereum happened at that time. We had the usability. We had applications that had account abstraction, that had gas fee abstraction that was fully based on stable coins, and so the user could go directly from credit card to onboarding, but we didn't have the scalability, so it kind of didn't matter. The users didn't come fast forward a little bit of time, and we find ourselves in a situation where we have a really damn complicated network of middleware that all try to solve some specific niche, edge case solution, and need for application developers that are higher up the stack.
00:02:11.274 - 00:02:58.088, Speaker A: And this complete mess also has resulted in all the l two landscape that we have, all the different roll ups that we have. I wonder if anyone has tried to use cross chain application. Has anyone put a hand up if you interacted on multiple chains? Ok, put your hand up if you would classify that experience as easy and user friendly. All right, so this is kind of the scenario that we have, right? Like a v wallet has multiple different chains. You have to pick your RPC you have your favorites brand of roll up that you want to use. Either your red, blue, green, who knows? And then you also have to bridge your assets. You have to build your bridge.
00:02:58.088 - 00:03:38.232, Speaker A: You don't know if the multisig behind the bridge is going to rug you or not. It's a bit of a mess. My take is if we are to make the most of all the middleware that we've built, all the stuff that we've built, and actually build applications that are going to deliver on the dream of web3, we need to do better from a ux perspective than the status quo that is today. And so that's what cake is all about. It's about providing a framework for thinking about all these legos, all these chain abstraction legos to build better applications. And hopefully in 2024 we can have applications that are actually usable. That's the dream.
00:03:38.232 - 00:04:12.968, Speaker A: We have a new set of users that are coming into the space. We have block space, scalability. Now, I think this is probably the most exciting time to be building web3 applications. And I just hope that we make the most out of it because I've been through three cycles already and I'm ready for actual applications and users. And we're close, actually, I want to do a show of hands. Who has used telegram bot? Okay, so we have a decent chunk of people. So telegram bots are actually probably one of the coolest applications in my mind that exists on web3 today.
00:04:12.968 - 00:04:17.168, Speaker A: It serves one of the core use cases which some people look down on, which is speculation.
00:04:17.336 - 00:04:17.580, Speaker B: But.
00:04:17.592 - 00:05:05.328, Speaker A: But that's where a lot of the demand for blockchains is today. And it does so by abstracting away a lot of the complexity of interacting with blockchains. So I would propose that telegram bots are actually a great example of the cake. They take care of the application layer and offer that in a way that's most optimized for user experience. And they hide away all the complexity of what sits beneath it. So we present a framework that has multiple different layers and trade offs in the design of the components beneath those layers. And we think that it would be good for application developers to have a simple, unified interface to be able to tap into all of this instead of having to navigate a bunch of different wording and, I don't know, branding and terminology across the different things.
00:05:05.328 - 00:05:30.120, Speaker A: Does that sound like a good idea to do? I think so. Right? Yeah. Okay. I want to have a quick show of hands because I want to read the room a little bit. We've segmented the cake into the application layer, the permission layer, the solver layer, and the settlement layer. By show of hand, who here is working on the application layer? Wow. We have three, four application layer people.
00:05:30.120 - 00:06:08.948, Speaker A: Okay, we're an infrastructure heavy team here. Who is on the permissioning layer? So, like, Wallace signatures, permissioning intents, maybe a couple people. Who's on the solver layer? Who's building solvers? Okay, what about mempool routing, auctions, all this kind of stuff? Yeah. Okay. The silver crews over here, and then the settlement layer bridges, layer ones, anything related to execution oracles. What are all you guys building? There's no one else putting your hand up. Okay.
00:06:08.948 - 00:06:38.474, Speaker A: All right, so we have a mix across the cake here. So I'm super excited about this. Like I said, I think it's the most exciting part time so far to build web3 applications because we have the block space scalability. But please, please, please, let's build it in a way that actually makes user experience great. I'll pass the mic over to. Oh, yeah, this is my meme. I'm basically saying a lot of this is possible because of MeV.
00:06:38.474 - 00:07:25.274, Speaker A: I want to clarify this. So to me, Mevboost represented one particular shift in mindset for the development of the Ethereum ecosystem, which was breaking away from the Ethereum transaction format. So when you shift over from a pre PBS to a post PBS world, you introduce, yes, this specialized world as a block builder that we spent the entire day today talking about. But what this blockbuilder can do is actually introduce new transaction types, and those are often referred to as intense. And we're talking about pre conformations and all kinds of cool stuff. I think these are all critical components that lead towards what is cake and actually enables better user experience for users. So this means everything is cake, and cake is inevitable.
00:07:25.274 - 00:07:49.584, Speaker A: So, yeah, we'll see more about this later. We have a working group, actually, we're doing a session on Friday with working group members. So if you're building something that's relevant and you'd want to participate, we'd welcome your participation. It'll be in the same space? I think so, yeah. All right, I'll pass the mic over to Ankit, and he'll talk about why chain abstraction and the different trade offs in them.
00:07:50.444 - 00:08:24.790, Speaker B: Hello. Hello. So thanks a lot, Stefan, for introducing the cake. Let's talk about why chain abstraction? So I'll talk about three things. Why chain abstraction? What are the tradeoffs with chain abstraction? What do we even mean by chain abstraction? And what are the six designs or six pieces of cake that emerge from if you want to build something like a chain abstraction experience for the end user. So let's go back 20 years. Let's go back 20 years.
00:08:24.790 - 00:09:11.828, Speaker B: Suppose SMTP, TCIP, HTTP, all these standards had not emerged and you have this PDF of your wedding and you want to invite people and you want to send this PDF to all your friends. What do you do? You basically google an email aggregator. You basically type your to and from address. You paste a PDF and you get this list of three options on how are you actually able to send this PDF to your friends. So there's a fast option where you pay $20, but it's very quick. There's a medium option and then there's a cheap option where you have to wait like 20 minutes, but it's very cheap. And then you go through this and then you somehow send this PDF to your friends and you get a wrapped version of the PDF.
00:09:11.828 - 00:09:58.864, Speaker B: After spending tens of dollars and spending tens of minutes, you get this wrapped version of PDF. It does not even have the date. And so you have this experience of you spend so much money, you spend so much time and you do not even get the actual PDF that you are trying to send. Thankfully that did not happen. Thankfully we had HTTP, TCIP, SMTP, all these standard that emerged where instead of going through this loop of or hoops of spending a lot of money, a lot of time, you have this experience, seamless experience of dragon drop and send. And these delightful applications could have been built just because you have these all of set of standards where the users do not care how they're interacting with these underlying layers of the cake of the web. Two cake.
00:09:58.864 - 00:10:37.892, Speaker B: You have just this delightful experience that is available to be built for the application developers. Unfortunately, this is what we have today in crypto. So you have these different roll ups, you need to have money to spend for fees and all these different roll ups. Every time you switch a roll up, you need to somehow do this, which is very irritating for me personally. And then when you are trying to move assets from one chain to another, you have these list of options and it takes a lot of time, it takes a lot of money and it just causes a lot of friction. It just causes a lot of user drop off. This is not what application developers want.
00:10:37.892 - 00:11:22.716, Speaker B: We still have a lot of activity on all these roll ups. It just shows you how powerful economic incentives are. But if you want to build delightful experiences, this is not what you should give to the users. So what is chain abstraction? So block spaces are abundant right now you can literally one click deploy a new roll up. What is the bottleneck? Is the Ux? How do you move these assets from one chain to another? And so the chain abstraction is an ideology where the users should not know what network they're on. The user just connects their wallet to the app, clicks on what they want to do, and then in the back end, in the infrastructure layer, everything that happens, needs to happen. What network needs to be deployed is a DAP decision.
00:11:22.716 - 00:12:32.374, Speaker B: The users should maybe not care that much about it. And in our opinion, chain abstraction will lay the groundwork to build the next set of applications. And will they the groundwork to bring in the next magnitude of the users, where most of the users might not care about some of these constraints and they just want delightful application and delightful user experience. So that's chain abstraction. Let's look at what are the key trade offs that if you are building a chain abstraction framework, if you are trying to build something like this for application developers, what are the key trade offs that you would want to take into account to somehow answer some of the questions that emerge during different layers of the cake? Uh, so the first question that you want to answer is what type of message or what type of thing that you're trying to transfer between two different chains. Are you trying to transfer a message or any type of information, or are you trying to transfer value? So if you're trying to transfer message, then messages are all type of information, any type of information, but it needs to be lossless. So if you are trying to participate in a governance vote, you do not want your yes vote to be converted into a maybe.
00:12:32.374 - 00:13:02.210, Speaker B: And because it has to be lossless, it has to use the most secure pathways. So it covers all types of transactions. And some examples are governance votes, approvals, stuff like that. The second type is value transfer. This is what blockchains are made for. It has to be, you need to conserve this scarcity and atomicity properties when you are trying to transfer value. And so you need to do this in a lockstep fashion where you deduct funds from the sender and you credit funds into the receiver.
00:13:02.210 - 00:13:58.398, Speaker B: And it can be lossy, because it can be like if you are transferring hundred dollars, you are happy maybe by just receiving $99 and you pay $1 to whoever is the third party or a counterparty that is trying to facilitate that transaction. And so you can leverage third parties to basically facilitate that transactions. 95% to 99% of the transactions today in blockchains are value transfer transactions. This is measured by the gas bid and some types of value transfers are transfers, swaps, gas, stuff like that. The next set of trade offs come based on how you are trying to leverage the solvers into different layers of the cake. And so if you decide to actually leverage solvers, how you bring in solvers into these different layers of cric, bring in their own set of trade offs. And so if you are on the permissioning layer, there's this trade off between UX and agency.
00:13:58.398 - 00:14:49.710, Speaker B: And so different users have lie on a different set of spectrum on how much control they want over the transactions versus how much they want to, are willing to let go to different sets of applications. And so like EOA accounts are accounts which where users have almost all the control. And then account abstraction wallets are where users are willing to, to find a counterparty to pay for gas. And then policy based wallet, like telegram wallets or near wallets are where the user just signs one thing, and then maybe there are 30 different things that happen in between, all in the back end. The user just does not care about it, it just happens for them. So there's a spectrum between UX and agency, which these different types of wallets or permissioning systems basically give to the users. The second thing that you need to figure out is how do you find the optimal path.
00:14:49.710 - 00:15:36.740, Speaker B: So suppose you want to do something cross chain between chain a and chain b. There might be 30 different things that the solver needs to do, or the user needs to do. You, as a chain abstraction layer or chain abstraction framework, what you would want to do is you would want to bring in multiple set of solvers who can look at what the user wants to do and find the optimal path. And they have their own competition in between, and they find the optimal path and give it to the users. But because there are multiple solvers who are looking at what the user wants to do, the state of these chains might deviate and you might lose on some execution guarantees. And so this is the trade off that you would want, that you want to resolve on the solver layer and on the settlement layer. What you would want to do is solve this trade off between low fees and execution speed.
00:15:36.740 - 00:16:20.004, Speaker B: And so if you want to transfer information, if you want to use the most secure pathways, you would want to wait for finality guarantees. And so if you want to exchange information between two chains, you would wait for finality, you would wait for economic finality, or any type of finality that you want for. And that introduces some time delta. Whereas if you take on some solvers and they're willing to take some risk. They would charge for their services, but they're willing to take some timing or finality risk and give you that service in exchange. And so, but all these different trade offs bring us to the six different designs that we think emerge from these different sets of trade offs. To just recap like there are five trade offs.
00:16:20.004 - 00:16:58.554, Speaker B: One is between information and value transfer. The second is between the user agency. The third is between fees, execution guarantee and speed. And so, based on these three trade offs and how you can bring in solvers, there is this trilemma that emerges between execution guarantee, fees and execution speed. And if you want to take only execution guarantee and low fees, what you would want to do is just use the in protocol paths. Just use paths that are determined by the protocol. So this might look something like a based sequencing, or this might look something like an IBC on Cosmos.
00:16:58.554 - 00:18:10.854, Speaker B: If you want to improve your speed, what you would want to do is bring in solvers into the system, bring in solvers into into your chain abstraction framework. And so if low fees and execution speed is to be optimized, then you would want a solver competition, where multiple solvers look at your order flow and compete with each other to find the optimal route. And if execution guarantee and execution speed is preferred, then you would want the solvers to come not on price to compete, not on price, but on speed. So based on the trade offs that emerge, these are the six pieces of cake that emerge. All of these different designs of how to transfer value or how to transfer information between different chains are in opinion, their own set of product market fit. They're also a little bit composable with each other. And so if you want to transfer value and you want to use the in protocol parts, then a good example is USDCCTP, where the token team comes in and says, on all of these chains, this is our canonical token address, and this is the bridge that has the right to burn and mint the tokens on all the chains.
00:18:10.854 - 00:19:10.532, Speaker B: If you want to do message transfer, but still use this in protocol path, still let go of speed, but have good high execution guarantees and low fees, you would want to go with an ecosystem aligned bridge route. So this looks very close to like a shelling point of an ecosystem. When an ecosystem says, okay, this is, this is what we are providing for you, and then all the application developers can gravitate towards that. And so this, things like IBC, Agular polygon are examples of ecosystem aligned bridges. There is one issue with the roll up roadmap, which is in IBC, because Cosmos has very fast finality, you can very quickly basically pass messages in an in protocol path. But because roll ups or optimistic roll ups are seven day finality, that is a very slow path for all the users. And so what ends up happening is applications tend to start bringing in solvers to basically give that speed to the users.
00:19:10.532 - 00:19:44.514, Speaker B: And so if you want to transfer value and have a solver competition, then you would want to bring in multiple solvers. And whoever has the best price, you will give that order flow to them. So examples are jumper bungee, which are competitions of these bridge protocols. OPX is a competition of solvers. And then if you want to do multiple types of messages, then you would go the wallet route where things like near avocado, Alfred, are examples. These look like super apps, aggregators or aggregators. So this looks like an aggregator, but this looks like an aggregator of an aggregator.
00:19:44.514 - 00:20:44.224, Speaker B: And so if you want to go for speed, then what you would do is you would bring in all the solvers, but say, hey, whoever is the first will get the mev or will get the execution rights. And examples of this are across. And then finally, if you want high execution guarantee and high speed, then basically you would go the exclusive backdrop route, which is very similar to execution tickets. And that's what Robin Hood uses as well. So these are, in our opinion, the six pieces of cake, six different products that emerge if you are trying to give that cross chain or chain abstracted experience to application developers. And so to conclude, we think that the users, a lot of the users that might come in the next cycle do not care about what network they are on. They just want delightful application, delightful experiences.
00:20:44.224 - 00:21:10.144, Speaker B: And that's what chain abstraction is all about. We introduced the cake framework, which is a way to think about how these different layers interact with each other. What are the trade offs in each layer? And I think if we want to give this delightful experience, then we need to define, or we need to adopt a common standard to basically move these messages across. So that's all on my side. Thanks a lot.
