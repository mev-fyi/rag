00:00:08.890 - 00:01:09.922, Speaker A: And I want to talk about mev and l two So here's the TLDR from my talk. L Two S work differently from Ethereum in some important respects. And unless you're careful, your assumptions from ethereum may steer you wrong in thinking about mev on L Two S. So what I want to do to sort of flesh this out is I'm going to talk a little bit about how Arbitrum works and the things I talk about will be common across the deployed L Two S, as far as I know. Then I will talk some about how this affects, how these differences affect the mev landscape. And then finally I'll talk some about what we at Arbitrum, how we approach it, what our principles are about this and what we're actually doing. Okay, let me start by talking about how Arbitram as at this level a typical L Two works.
00:01:09.922 - 00:01:50.762, Speaker A: And if you've seen one of my other talks this week, you may have seen this diagram before. I'll go through the parts that are relevant for this talk. The key component here is the sequencer in the upper left. So under normal conditions, users send to the sequencer all of their transactions directly by RPC. The sequencer gets those transactions and what it is supposed to do is put those transactions into a sequence that the Sequencer decides, but it is supposed to put them into an Arbitram first come, first served order. So the sequencer is responsible for putting transactions into sequence order and for nothing else. It's not trusted for any other purpose.
00:01:50.762 - 00:02:16.982, Speaker A: Anything else it does that it might do wrong is checked for and corrected for by the rest of the system. So that's all it does is sequencing. And I'll talk a little bit about how this works and so on. The sequencer might be a centralized element or it might be a distributed system. More on that later. Okay, the sequencer then does two things with the Sequence thing. One is publishes a sequencer feed very quickly.
00:02:16.982 - 00:03:07.160, Speaker A: In a second or less, after your transaction has arrived at the sequencer, your transaction will have been put into the sequence and the sequencer will have published it as part of the sequencer feed. That's a feed, a real time feed that anyone can subscribe to. And if the Sequencer is honest, then that will be the order in which transactions occur in the L Two chain. Now over here on the right we have the state transition function. This is basically a function that eats one transaction at a time, processes that transaction, possibly updates the state and then possibly emits an L Two block. This state transition function is fully deterministic. So the outcome at any time will depend only on the Genesis state and on the sequence of transactions that it is processed up to now and on nothing else.
00:03:07.160 - 00:03:14.262, Speaker A: What that means is that the sequencer's sequence output fully determines the eventual state of the chain.
00:03:14.406 - 00:03:14.714, Speaker B: Okay?
00:03:14.752 - 00:04:09.014, Speaker A: So the sequencer publishes its sequencer feed very quickly. This allows users who decide to trust the sequencer on its sequence to get a very low latency response to their transactions. Users love this. This is a huge user experience advantage, and that's the reason why the Sequencer feed exists and indeed, why the sequencer exists at all. But then the other thing the sequencer does is once it has built up a large enough batch of unrecorded transactions, it makes a big batch of transactions, compresses it using a general purpose compression algorithm, and then writes it onto the L One chain. And this is the final and permanent record of what the transaction sequence is. And because of the determinism of the state transition function, it determines completely what the history of the chain will be up through that part of the transaction sequence.
00:04:09.014 - 00:04:55.610, Speaker A: So from that point on, the wheels inevitably grind to cause those transactions to eventually be settled back to L One. Okay, so there are two interactions that this process has with the L One chain. One to store the compressed batches, and the other to settle the transactions to L One. Now, what's interesting about this is these transactions to L One don't really care about ordering. If the sequencer is honest, then the batch and compress and record transaction is only recording information that's already known. It's simply recording and notarizing information that everyone already knows. And so if it gets delayed a little bit or advanced a little bit, that doesn't affect anything.
00:04:55.610 - 00:05:23.630, Speaker A: It doesn't affect the history of the L Two chain. It only affects when the L One chain learns of that history. Similarly, over on the right, when you settle the transactions to L One, the result of that is inevitable, fully determined by what already happened. And so again, it doesn't matter that much whether it happens earlier or later. Everyone knows it's going to happen. The only question is when. And so there's not much opportunity or these things are not very sensitive to mev considerations.
00:05:23.630 - 00:05:39.190, Speaker A: I put an Asterisk on the one on the left, because if the sequencer is lying, which could happen occasionally, it might lie for a little while before it gets fired and replaced by another sequencer. If the sequencer lies, then you might care how quickly it gets caught in the lie.
00:05:39.770 - 00:05:40.242, Speaker C: Okay?
00:05:40.316 - 00:05:51.180, Speaker A: But for the most part, there's not a lot of mev sensitivity in these transactions. But of course, what you may be really interested in is what happens regarding mev on layer two.
00:05:52.110 - 00:05:52.860, Speaker C: Okay.
00:05:54.990 - 00:06:49.518, Speaker A: Let me stop and talk about who runs the sequencer because I think this is important in thinking about how all of this works. Because the sequencer is really the only party who has opportunity to extract it's, the only party who is definitely sitting on the path that a transaction must go through and potentially has power to extract mev. So currently, the sequencer is centralized. It's run by us, the Arbitrum team, and so if you trust us to run the sequencer honestly, and if you believe we're running the code that we published, then you're good to go. Over time though, we will move to a distributed sequencer. The sequencer will become a distributed system. Now importantly, we are not following the paradigm that some decentralized sequencing systems use, where you have a rotating sequencer, which is basically a rotating centralization system, where each step or round or block is centralized and you rotate who gets to do those things instead.
00:06:49.518 - 00:07:35.150, Speaker A: This is a fully distributed system. I'll talk in a minute about how it works. But the guarantee we give is that as long as K out of N of those participants are honest for suitable values, think more than two thirds honest, then the result will be honest. It will meet the specification. I'll talk in a minute about what that is. It's also worth noting that in this scheme, dishonest behavior by individual sequencer nodes will usually be detectable, not provable to a third party, but because it's detectable, that means if a sequencer consistently cheats, then that will become common knowledge that that's a cheating sequencer. And so a social mechanism or a governance mechanism can kick in to replace that lying sequencer.
00:07:35.890 - 00:07:36.542, Speaker C: Okay?
00:07:36.676 - 00:08:36.690, Speaker A: So in a distributed sequencer world, you provide a distributed first come, first served type of policy. And here's what that means. In particular, the story of a transaction basically is that the user multicast their transaction to all of the sequencer instances. Think 15 to 20 of them user multicast their transaction to all of them, or almost all of them. Each sequencer then publishes its own ordering of the order in which it received the transactions, or so it claims. And then there's a fair sequence merging algorithm that takes those individual claimed sequences from all of the sequencers and merges them to produce a consensus sequence. And the guarantee is something that you might informally call majority first come, first served, which is roughly that if a supermajority of the sequencers are honest, then if your transaction arrived before mine at a supermajority of the sequencers, yours will be before mine in the order.
00:08:36.690 - 00:09:10.570, Speaker A: There's some technical nuances here and a big shout out to the research team at Cornell Tech, mahin Mckalkar and Ari Jewels and other collaborators who produced the work that makes this possible. Basically, they showed exactly what properties could and could not be achieved and good algorithms for achieving them. But in any case, this is the guarantee that if a supermajority are honest, that the result will be first come, first served in sort of the natural sense that you can define that in a distributed system with asynchronous clocks.
00:09:11.230 - 00:09:11.738, Speaker C: Okay?
00:09:11.824 - 00:10:00.410, Speaker A: Now, you can also combine with this the use of public key encryption of the transaction and threshold decryption by the sequencer committee members that sort of knits together in a really cool way so that people in the middle, including the sequencers themselves, don't know the contents of the transactions until it's too late for them to modify the order. Okay, so that's sort of the technical background. Let me now turn to how we on the Arbitram team think about mev. I'm going to give you two principles an observation and then tell you what our policy is. Principle number one is to reduce users costs. Reduce users total costs, right? That's one of the big reasons people come to an L. Two, they want lower cost and we want to reduce total cost.
00:10:00.410 - 00:10:37.538, Speaker A: So that includes the cost of any slippage or other loss that a user suffers because someone reordered on them. So to the extent that someone is a victim of mev extraction, then that implies that we should reduce mev extraction where we can there can be some pro social mev extraction. We're fine if users can opt into it. I'll talk about that later. But we don't want to force people into a world where someone can extract mev from them because that is a cost. And our goal is to minimize cost. But also the second principle regarding cost and fees is we try to make users cost incentive compatible.
00:10:37.538 - 00:11:58.590, Speaker A: And in particular, that means we want to incent behavior on users behalf, which reduces the use of scarce resources in the system and which preferentially reduces the use of the scarcest resources. So to the extent that a user's costs are perfectly aligned with their usage of scarce resources, then users have the incentives we want them to have, and our chain and our users will use those resources efficiently. To the extent that there's some other element of cost which doesn't correlate with that use of scarce resources and users are optimizing some combination of those things, say some combination of resource usage and mev resistance, then you're going to get a worse result for resource use and our chain will be less efficient. So that user may be saving their cost by making themselves mev resistant but using more resource. But by doing so, they're transferring cost onto other users because those resources become marginally more expensive. All right, so this is why we would prefer to keep mev considerations mostly out of the cost equation of our users unless the users have some reason that they think mev will benefit them. All right, observation number three users really love the 1 second transaction latency.
00:11:58.590 - 00:13:04.098, Speaker A: You can't really appreciate this until you ship a system that does it and you hear from your users and they love it for two reasons. One is its basic doctrine in the user experience world that there's kind of a boundary around 1 second that things that take more than 1 second feel like they take a long time and you're tempted to go get a cup of coffee. Things that take 1 second, you notice the lag, but that's pretty good. People want to have not only a low mean latency but also a low variance in the latency. And that is important and it's something we want to preserve. Notice the consequences of this for mev extraction, which is that if we were to build up a big mem pool and let an mev extractor choose from that big mem pool, that would necessarily increase the mean and variance of the latency that users experience and that would be bad for users. Okay, so what is our policy? Our policy is the sequencer provides a first come, first served ordering of transactions that's best from the standpoint of latency mean and variance.
00:13:04.098 - 00:13:56.918, Speaker A: It's simple to implement, it's simple to explain to users. Okay, let me talk about the implications of these things for mev more generally across L two S. The first one is that the mean invariance of latency on these systems is much lower than on ethereum and that the mean is important because it's sort of a measure of how much of a mem pool you can build up and reorder before you're starting to increase the time. Very much. And the variance is also really important that Ethereum already has a high variance in the latency to get your transaction recorded. And so if you add some more variance because of mev extraction, users don't notice it that much. But on a system with both very low mean and very low variance, users notice a lot and it degrades the user experience.
00:13:56.918 - 00:15:03.680, Speaker A: That means that there's only probably a fraction of a second of mempool that you can build up and reorder in an mev extractor before you start to degrade the overall user experience of the system. Right? So here an mev extracting sequencer would either significantly increase latency for many transactions or be able to only manipulate sort of the timing of individual transactions by a fraction of a second, so much less opportunity for mev extraction without paying a price in other areas that are really important to us. Okay, some other topics to discuss. One of the things that has been proposed is the idea of putting an mev extractor in front of the sequencer on a kind of opt in basis. Anybody could do this. Of course, our sequencer or distributed sequencer is a set of nodes that are trusted or collectively k of n trusted by our community. And of course our community isn't going to be involved in the deliberations about how to select them.
00:15:03.680 - 00:16:25.640, Speaker A: But anyone who wants to, whether users or we, like it or not, can put an external mev extractor in front of the sequencer and users can choose to use that as a proxy for submitting their transactions. So that is the thing that can happen if you're a user, for example, who's doing a DeFi transaction and you recognize that you're creating an arbitrage opportunity behind your transaction and you'd like to be able to sell that opportunity. You could choose to route through an intermediary and of course there can be multiple of those and they will compete with each other on user value. That's a thing that A, we can't stop and b is probably a good thing as long as it's not mandatory for users, which it won't be. Users can go directly to our sequencer or sequencers or they can go through this intermediary. Go through an intermediary, you'll get slightly slower response because of the intermediary but maybe you can extract some value. The other thing, of course, the other piece here is because our sequencer is currently sitting geographically somewhere and because the members of the distributed sequencer set will be sitting geographically in a bunch of places, probably around the world, people may compete to get geographically close or network latency close to those sequencers in order to get faster response time.
00:16:25.640 - 00:17:48.146, Speaker A: And that will probably exist. We don't have hard evidence but we strongly suspect people are already doing this. That could exist for private use or it could be sold as a service and in general anything that has value for private use probably could be sold as a service, as a business. We expect that as things mature and develop that that might well happen. The consequences of the geographically distributed sequencer committee here are interesting because if you have a point of presence if there are 20 sequencers scattered around the world and you have a point of presence at each one and what you need is to get your transaction to a supermajority of them before somebody else. That means you may not have time to coordinate between your different points of presence in order to coordinate on what you're going to do. So there is some limit on your ability to actually use geographic proximity in this distributed system sense simply because if Alice is sitting in one place and multicasts her transaction out across the world to everywhere, then if you see it over here and then try to inform your friend over there of what to do, that Alice's transaction will probably beat you.
00:17:48.146 - 00:18:37.566, Speaker A: Right? Because you have to pay the triangle penalty for your path. And so there is some resistance to the geographic proximity methods. Essentially someone would need to have a deterministic method of reacting to the transactions they see, which is a little tricky because if you have only local information about the order in which your sequencer saw the information, that's not a guarantee about what the majority will see. So there's some complexity here and arguably it's a bit more difficult to try to get geographically near. So that's basically where we stand. I've given you a little flavor. I think the biggest difference you see in just to summarize between L One ethereum and L Two is in the response time of the sequencer.
00:18:37.566 - 00:19:06.850, Speaker A: It's in the fact that ordering is done by transactions. Blocks are not built in the normal sense, it's a per transaction ordering process and that has implications as well. So I'd be happy to answer any questions or engage in any discussion or civilized debate. And I think we have about ten minutes for that. I'll repeat the question if not okay.
00:19:08.100 - 00:19:10.000, Speaker B: Yeah, I'm a huge fan.
00:19:10.420 - 00:19:11.330, Speaker C: Thank you.
00:19:12.180 - 00:19:23.540, Speaker B: Just to church while you're talking, is there a possibility, perhaps might it be a good idea might it be a good idea to continue to run your.
00:19:23.610 - 00:20:01.184, Speaker C: Centralized sequencer in parallel to a distributed version? Thank you. Would it be a good idea to run a centralized sequencer in parallel to a distributed sequencer? Almost like a kind of first of all, to give an alternative to users and secondly, almost like a kind of economic incentive to the distributed actors to behave. You've got this kind of threat that if they start messing with a sequencer, people get to see it and they've got this alternative they can quickly go to of the sort of reputation based centralized. Is that something that's occurred to you? Do you think that might be a good idea?
00:20:01.382 - 00:20:40.592, Speaker A: So I think there are some difficulties with this. I think it may be the case that when we roll out a distributed sequencer, our centralized sequencer will become one of the parties in that system. That seems pretty likely. You can have different sequencers who publish their opinions about event ordering. Right. There is a core problem, though, that different sequencers. If every user is multicasting their transactions and every sequencer is honestly reporting its order of receiving them, they will report different orders, right.
00:20:40.592 - 00:21:50.468, Speaker A: Just because of how network latency and delivery works. So there's a sense in which there is only a sequencer who sits in one place is really the only party who knows what truth it should have reported, right. At least sort of in detail. It's difficult in a single instance to figure out who's telling the truth or who's lying. The other thing is that people could of course, if we had a parallel reporting system that got the transaction separately and reported what it saw, a user could manipulate that by multicasting to the sequencer committee now and then waiting a while and sending to us or the other way around. So the fact of differences between arrival time at different places is not necessarily evidence that could be shown to a third party about what went wrong. Now, if you and you wearing a different hat at a different IP address, send transactions to the same sequencer and you in fact can know that A arrived before B, but it puts B before A.
00:21:50.468 - 00:22:21.680, Speaker A: Or if you detect that your transactions consistently see longer latency than that other person's than your friends, that's some indication that that sequencer may be manipulating order. So in a kind of collective and cumulative way, a dishonest sequencer's dishonesty is likely to become evident, but you can't detect it with an automated mechanism, at least not that I can see. And so you have to rely on social response.
00:22:24.980 - 00:22:26.128, Speaker B: One thing I was just going to.
00:22:26.134 - 00:23:07.384, Speaker C: Add there is I just come clean. I'm founding an organization called Zero Mev that attempts to quantify on chain mev in different layers and specifically kind of tempts to differentiate between toxic and neutral. So one way you can do that is you can try and quantify the amount of toxic mev that's happening. So, for example, sandwich attacks a great way of seeing very quickly and very clearly whether users are being exploited on a certain chain. So if you have some reporting of the kind of relatively how many sandwich attacks you're getting on a distributed chain versus the centralized, that could be quite a powerful incentive for that not to happen on the distributed chain.
00:23:07.432 - 00:24:02.770, Speaker A: I mean, on a centralized chain, of course, the centralized sequencer has the power to do a sandwich attack to people in a distributed sequencer. It would require a suitable supermajority to all coordinate their sandwich attacks right. Which you can't rule out technically, but which the trust requirement would rule out. And if an organization were to report that that was happening, then we and our community would take notice and you could expect the sequencer committee members to be changed. And of course, it's really important in the distributed sequencer model that each sequencer publishes their claimed sequence. And so you have the evidence of if one sequencer seems to be sandwiching a lot, you actually have the evidence that you can point to and say, look, these sequencers are sandwiching and the other ones are not. Something must be happening.
00:24:07.850 - 00:24:15.530, Speaker D: You've spoken briefly now about how it's possible to detect dishonest sequencing, but what actual incentive is there to be an honest sequencer?
00:24:16.270 - 00:24:19.530, Speaker A: Well, you won't be fired, you won't lose your job as a sequencer.
00:24:21.150 - 00:24:29.500, Speaker D: That seems like a small incentive there because if I can just spin up another sequencer, I'll just keep creating more and more.
00:24:30.130 - 00:24:44.740, Speaker A: Right, so the set of sequencers is permissioned and is chosen through a process that involves deliberation by our community. And so you don't automatically get to be a sequencer just because you want to.
00:24:48.710 - 00:24:49.460, Speaker B: Sure.
00:24:54.610 - 00:25:39.626, Speaker E: Coming back to the roadmap towards distributed sequencer. If you think of things like cross domain mev and the risk of some of those sequencer colluding with other sequencers from other L two S to extract mev, there's a trade off that becomes quite complicated between a centralized sequencer that is operated by a company that people can trust is honest or operating honestly versus a distributed set of sequencers that might collude in a way that is quite unpredictable. So how do you think about the timeline and the moment when the trade off towards distributed sequencer becomes a positive outcome for the user?
00:25:39.738 - 00:26:33.374, Speaker A: Sure yeah, let me say a couple of things about that. The first is that if a small minority of the sequencers in this scheme are colluding with outsiders, that has no effect, because the honest supermajority will still provide the distributed first come first serve guarantee, regardless of what a small minority does. The second piece of that is yes. It's really important how these sequencers are chosen. They're likely to be parties who are trusted by our community to be reputable and have reason to be honest. And if they misbehave and parties who would suffer a reputational hit for misbehaving. I think if you think about the process for how you would choose those parties, you would want ones who have a reputation as trustworthy in the community, who have reputation to lose, who have a stake in the success of the community and so on.
00:26:33.374 - 00:26:43.920, Speaker A: And so I think the considerations that you suggest would play a big role in choosing the sequencers. And should.
00:26:46.450 - 00:26:46.974, Speaker B: We out?
00:26:47.012 - 00:26:47.566, Speaker D: That's enough time.
00:26:47.588 - 00:26:48.480, Speaker A: Thank you, everyone.
00:26:49.650 - 00:27:05.090, Speaker B: Thank it's.
