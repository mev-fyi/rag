00:00:27.160 - 00:01:24.880, Speaker A: Process and the TX is having some much bigger CD because we now have not only the application mode and the So's. Yeah. So many other processes that we're running inside trusted. And to tackle this problem, basically it's not a problem, but we want to have a small tcp. In that case we are using correctly, which basically lets you to build your virtual machine layer by layer just to minimize the extrusion base and not having any. As you can see here, Shane already presented what we are doing now. For example, this is one of the use cases, we are putting the R builder inside TVX and you have to just see what the benefits of doing.
00:01:24.880 - 00:02:17.860, Speaker A: So we will show the chain of trust. So now we have the DXM. And currently if you are three approaches to do it, either you basically deploy on the cloud providers such as Azure or GCP, and in this measure you get some cross which is execution assurance running on your service. Also like join distribution where they are provided. And yeah, it's difficult to talk about. However, you have some cons which is you are adding an extra layer of trust because there is the HCL which basically running your vm and so on. So it's part of the decision because now that decision is using the BTPM and then of course that's the end of chain process where you are doing the provisioning.
00:02:17.860 - 00:03:24.890, Speaker A: Second approach would be the bare metal, like you can rent TDX machine and do it on your own. And this way basically you get the process of having full control. So no extra weber, currently not CEA. So this is the execution assurance, where is it from? However, this can be worked on, of course, and the geo solution is actually difficult. And the third approach already, and we already talked about this, the option, we'll talk about it probably later. Much more in detail. Yeah, let's skip it for now because we don't talk too much about this.
00:03:24.890 - 00:04:14.054, Speaker A: This is a snippet of the TD one that we generated on the bare metal. And then we have here very important, which are the MiTD, the measurement module that is running for the firmware. And you have the RTMR zero one and 203. Those are representing the hash of the kernel, which is running the Ramf. And the Rmar two is basically the CMD line. When you put your image inside the memory. Yeah, for now we will see some kind of station on address or demo.
00:04:14.054 - 00:06:12.482, Speaker A: So how it works, they are using the HPM measure boot. We were able to repeat, this is for constellation. So we are using the which basically, and without further ado, let's do. Could you increase the fun? Yes. So for now let's do the. But here when it starts out, it's actually running. Exactly.
00:06:12.482 - 00:07:35.360, Speaker A: Only the applications that we started with. So basically it's only an armloader and all. So basically this is very bold because now you have literally an operating system running only your binaries and we are building it in a useful way that's such that wherever you build this image, it's generating the same measurement. So you can use those measurements. You can make sure that on that log that's being running is actually the one that you built or basically you can literally verify this. So here I can show you for example the output of red, which is so yeah, we already have it synced since we found and so we also ran to but we didn't open up here. This is here just like that environment.
00:07:35.360 - 00:08:03.350, Speaker A: We are not really sending bundles or anything to it just to show blocks and be confident. But yeah, this is just like how it's been working. So we have the working mvp with the. And let's do some attestation. So we just measurements. Let's see. Hopefully it will work.
00:08:03.350 - 00:09:22.590, Speaker A: Let's start to first. Yes. So show me a anyway, so let me show you the measurements, how they are generated and it goes something like this. So as I mentioned earlier in the slides, you can see here the PCR eleven measurement and PCR four measurement and CR nine. These are every time you rebuild the image with the new stock, for example, they changed. But if you are building the same image they are always exactly identical which just makes it more incredible in order to. So now let's run the.
00:09:22.590 - 00:10:26.012, Speaker A: This is BPM. Yeah, this is approach of Azure and I showed you the TD quotes of that bare metal how it looks like. And we are also working on a way inside the October when you deploy it on bare metal the way it. This is working proper slowly, right? Yeah. So now we can curl it. So we can curl this reverse proxy with this measurement that we are expecting. I just showed you for the image and as you can see here on the left side, basically it's received request to do that.
00:10:26.012 - 00:11:01.078, Speaker A: The station, it's sent a torture and Azure looked into the measurement and sent it back to styling. So in this way it's basically Azure. In this case it's seeing the measurement and then compares them and see if they are identical with the one that's being deployed. And it gives you like it's valid like the sign validation function. And this is also like you do. So basically you know that it's been deployed on Azure Francis. So I think this is one of the examples with our builders running on the chair.
00:11:01.078 - 00:11:51.376, Speaker A: I can show you a snippet of the experimental. Please bear in mind it's still worth the progress. So this is a bare metal machine and we can show you here we are running also rest inside a TD machine. And in this case here one part is we have access actually to the TD guest module which basically would allow you to japanese. So I can show you. So this is there and we can also see similarly to the one deploy manager, but on bare metal. It's also a very minimal virtual machine running on the application caliber.
00:11:51.376 - 00:13:35.814, Speaker A: And we can see here also you can see how the rest is probably still currently syncing. So yeah, this is the rest currently with JSON. What exactly does the Azure module check when you set the Azure. So to my understanding how Azure is doing, it is basically when you do the attestation you are trusting the stage which basically is run on top. You can somehow think of it like the level s which runs before your vm and then it boots up your vm. And so this makes it like you're trusting here the VTVM, in this case it's loading the right measurements of your image and into this exact PCR. So everything then is defined by the signature of measure.
00:13:35.814 - 00:16:58.824, Speaker A: The space become very firmware. We have everything help us if they want. But yeah, everything is built in Yocto and we are providing Docker ways to do the building inside docker because there are some artifacts, example the arbour, some dependencies where they have some access to specific output methods. But once you solve all these minimal issues, you are specifying each one of you. One more question. And then we have our like kind of, they are actually not used around this and we all know that the x this side is not part of the measurement. So when you put your image, putting your binary in the initial ram, this initial ram has been measured and this measurement will be considered like all the applications are measured.
00:16:58.824 - 00:17:14.990, Speaker A: So if you change your application and the growth process without changing any other thing, you will notice that the PCR nine will be changing subsequently because the energy changes. Great, thank you.
