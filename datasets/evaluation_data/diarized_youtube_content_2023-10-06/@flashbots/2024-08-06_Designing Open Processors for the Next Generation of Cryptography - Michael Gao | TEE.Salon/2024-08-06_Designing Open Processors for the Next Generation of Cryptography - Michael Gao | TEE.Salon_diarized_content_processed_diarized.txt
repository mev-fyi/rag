00:00:02.920 - 00:00:37.500, Speaker A: Yeah, this is a topic which is, let's say that there's some mechanism for establishing some sort of fund for this, right? What is the ideal chip for web3? So today we have a slide deck, right? Tina is my co founder. There's a slight hack on there. And yes, every crypto company needs a chinese woman called Tina.
00:00:41.920 - 00:00:42.860, Speaker B: Posted.
00:00:44.320 - 00:01:17.876, Speaker A: But yeah, what is the ideal chip for? Book three is kind of the motivating question for ever. Our first chip has CK. It has fhe. We're about to show you what we already did, but this is a question about the second chat. We chose ZK as an entry point into confidential computing and, you know, trustworthy, let's say computer trustless computing, depending on what kind of brand you want to do. And really like that. Washington.
00:01:17.876 - 00:02:14.920, Speaker A: The intent of that, wasn't that necessarily? This thing and this thing alone is going to be the end game here at fabric, we believe that all the cryptography, all of the confidential computing is ultimately going to be the end game. And these are just tools in your toolbox, and you're going to use a combination of them. And so our next chip is probably going to have Ck, fhe, and tes of some sort. And so how these interact, how these combine, how new functionality can come from combinations of these things, maybe layered on top of each other, maybe used together in some creative way. What other physical features? I think there was an interesting term that Solvanna used, which was crypto physics. We want to go into the crypto physical realm, and so all of those ideas are really the motivating topic for this discussion. This is less of a and more of a discussion.
00:02:14.920 - 00:03:09.652, Speaker A: So we'll talk about like, what we've done so far for a few brief moments, but then I want to open the floor to, you know, most of the time, just talk about questions and really ask you guys, what would the ideal chip be? So, yeah, we're gonna, we're gonna start from the VPU B one. The VBU is the verifiable processing unit. So the intent for the VBU is basically to be a high performance processor for things that were too slow before to manage. So our first application is real time ZK proving, and you can run the end to end prover on chip. So we actually already have Risc V on the chip. We can do everything from witness generation to prove the it's general purpose. So we did not hard code NTT, we didn't hard code hashes msms.
00:03:09.652 - 00:03:40.470, Speaker A: We didn't hard code any of that. It's basically architected like a GPU. And it's super easy to program and it's scalable. So we're going to produce thousands of these next year. They're going to be shipping starting at the beginning of the year in Molly to data centers all across the. So Fabrica is basically a team of 60 founded last year. We're going in hyperspeed and we're building up one with the intent that is basically after GPU's have come out for photography, FPGA's, AsICs.
00:03:40.470 - 00:04:11.460, Speaker A: I think we all have this notion from the last ten years in crypto, that there's an apparent trade off between programmability and performance. The vpus intended to break that trade up. So we believe that you can create a chip that's both basic level performance, but also programmable energy. And so there are dozens of supported primitives in this first chip. They all have to do with number theory and big integers. I think Tina came up with a fun catchphrase. I like this big n s and I cannot lie.
00:04:11.460 - 00:04:44.644, Speaker A: That's how we feel about. So it has about ten times the big n hops as the GPU. And there's an onboard risk five cpu that in the next edition may have a te in it. And there's a cpu to make you interconnect on chip. So there are a lot of applications for tes in these cases. And inside the tile is basically a massive number theory vector processor. So thank ABX 512 for those of you who know vector extensions.
00:04:44.644 - 00:05:34.156, Speaker A: It's basically like AVx 512 except 1536 y and a lot of number theory. So that's what the VP trial is. And so you got a bunch of them in each chip, they can do a bunch of stuff, you know, and the same things that are done for ZK can be reused for FNG. And what we do is basically we focus all of the diarrhea on cryptography function. So instead of doing all these AI things, floating point things, we focus the entire thing. And so this is a overall diet floor plan almost, right? So you have like this Ris five core complex, you have 40 tile custom compute instruction set implementation. And then you have these five channels of Gmer.
00:05:34.156 - 00:06:13.116, Speaker A: And I basically things like this limit of assembly to very, very short modular vector arrays. And so, you know, as one example, I was presenting this yesterday at the FHG summit, you know, you get an order of magnitude or more on VPU versus FPGA. So that's a pretty massive improvement based on PFHD or multiplication, obviously. Still a little bit expensive but you can start to use this kind of stuff if you have a bunch of phones for things like auctions and.
00:06:13.268 - 00:06:16.920, Speaker B: Yeah, also this is just our faq.
00:06:17.500 - 00:06:57.010, Speaker A: Yeah, this is a reuse of fhe. So ZK, we get similar kind of cost performance improvements on things like snarks. Starks know, quantity two, quantity three, all sorts of amazing things. The cost is just electricity. This cost is measured as capex plus opex. So there's like a whole thing about the methodology for measuring that. And then, you know, the flexibility that you have for switching between all these different ZK algorithms basically cross applies to.
00:06:57.010 - 00:08:04.700, Speaker A: I think you guys kind of get the idea, right? Like, but yeah, basically optimizations are measured in percentages, right? So if you're like a typical ZK, fhe software engineer, you're happy if you get like 30%, 50% at a time. And the VPU is designed for a quantum leap, so to speak, ten x 20 x kind of leap. So some of you might be thinking, okay, so to use this for fhe, you probably need a next gen, you know, to get the truly like several levels of performance. That next gen is what we're here to talk about today. Yeah, but this is the first one and it's shipping. This is an actual picture of the BCIe. So any questions before we.
00:08:16.720 - 00:08:32.552, Speaker B: As you're manufacturing these, since all of these are going for fhe security, that kind of thing, is there anything in the manufacturing process that is like unique that you're doing, such as like what a government would do to make sure that there's something along the way, random sampling, stuff like that?
00:08:32.736 - 00:09:21.080, Speaker A: I think that's a next gen thing. The current, because the current generation is meant for a lot of like the CK succinct applications that don't really require zero knowledge, but are just like basically centralized or decentralized massive roll up processing, which is how we got off the ground, basically all these roll ups. And we think that that's a really, really big deal, that real time ZK is going to actually make these roll ups very, very practical. And so that's kind of the first gen. And the next gen, you know, will continue to have that value prop for crypto. But also we're looking at like a lot of different applications. Maybe in the sequencer space, block building space.
00:09:21.080 - 00:10:21.060, Speaker A: So that's like an active area. Yeah. Can I answer that? Yeah, yeah. General purpose PE and GPU. I guess you can at that point you have everything, I guess. Let's hone in on this question a little bit, which is what makes for a crypto native te. This is really, you know, a huge question that I came in with is like what kind of technical implementation level details are required for a te that truly meets the needs of the blockchain does a lot better than something like SGX, TPS and those things.
00:10:21.060 - 00:11:38.750, Speaker A: So I guess like anyone with a thought on that, I want to hear your thoughts on tamper resources, first of all. I mean, so a puff that has still been presented, it's like the necessary but not sufficient for what we need, because that just does its thing of having a secure key and it would generate images of signing. We want full execution that's unfoldable, untamped. So the question is, can you build tamper resistance into the logic itself? Yeah, yeah, I think that. So there's a question of like what kind of tamper resistance are you looking for? Are you looking for like you literally can't rewire it because it's almost impossible to rewire these chips in order to break open the chip to the point where you could rewire it. You're already destroying the chip to the point where you can't rewire it. Like if you redeposit in the semiconductor world above like a sanded down chip, like most likely you've destroyed it to the point, I mean you could potentially do it, but it would be a very obvious effort.
00:11:38.750 - 00:12:32.240, Speaker A: Like you would have to build an entire semiconductor. I mean the goal is to get all of the parameters, private keys, for example, as it runs, as it runs. Make it harder on us because you want your ideal time in the world and. Yeah, so there's kind of two ways to use drought on a chip, right? The first is let's say like keep the chip intact, but basically have wires in to some hidden pads on a chip or something like that. But then the patch would have been inserted at cat time. So like I don't think that this will happen if like you have people randomly sampling chips and stuff like that, like cache. So let's say random sampling, quick catch.
00:12:32.240 - 00:13:32.320, Speaker A: But then this one is just an em side channel, right? And I think like this one is probably most preventable with software level sweeps combined with a lot of white hat em attempts. I think this one you can only really article, I mean you can try to make it a Faraday cage and stuff like that too. You can definitely do that. Maybe that's also random sampling things and then temper resistance on the package level. So you have the silicon, but usually you have a package on top and you can put a little like vial here such that the moment that you open the package, this acid will corrode the chip. This is another thing that you can do on the manufacturing level. This is like what government people do to protect ships against hostile jurisdiction.
00:13:32.320 - 00:13:44.532, Speaker A: This one is actually a relatively simple one. I think it's a specialty package manufacturer. These things are just random, so you.
00:13:44.556 - 00:13:56.140, Speaker B: Can probably use the other way. I've seen it because rip trust, like a hardware wallet company. Does this work there? A hardware wallet, there's like a secure mesh that has like an electronic current running through it that's active.
00:13:56.180 - 00:13:58.348, Speaker A: Oh, you can totally do that too. You can do that too.
00:13:58.404 - 00:14:00.236, Speaker B: Is it cheaper than the whatever you just said?
00:14:00.268 - 00:14:00.628, Speaker A: Poison?
00:14:00.684 - 00:14:01.520, Speaker B: What did you say?
00:14:03.980 - 00:14:05.000, Speaker A: Cyanide?
00:14:07.420 - 00:14:12.800, Speaker B: Yeah. Which one is like, has anyone done the chip one with secure mesh?
00:14:13.140 - 00:14:18.440, Speaker A: I think people have done this one for sure that I'm familiar with. This is a great idea.
00:14:19.060 - 00:14:21.156, Speaker B: I think you certainly shaking your head.
00:14:21.188 - 00:14:24.108, Speaker A: So secure meshes are like totally in.
00:14:24.124 - 00:14:25.240, Speaker B: The same standard.
00:14:27.170 - 00:14:46.122, Speaker A: But I would start like way lower with temporary distance. I mean, this is already like super invasive attacks, which are very hard to do with equipment. But currently we don't even have like security against like the simplest kind of side channel attacks that a physical attacker can perform. If I plug my oscilloscope to make.
00:14:46.146 - 00:14:49.386, Speaker B: An internship, I can get you the key and I can tell you what.
00:14:49.418 - 00:15:01.072, Speaker A: The, what the enclave is computing. These are like the basic things you have to do. And fault resistance is also a thing that you need to consider at the design level.
00:15:01.176 - 00:15:03.576, Speaker B: And we have provably secure design techniques.
00:15:03.608 - 00:15:47.020, Speaker A: Against this kind of attacks. So like, temper resistance, I would start with like the attacks, which are cheap to perform, and then move to like the ultra invasive things with like scanning electron microscopes and focus beams and changing wires on the ship somewhere. This is like the first thing. But to go into another direction, I think we need temper resistance, and we need open source for trust and decentralization. I know it's kind of an unfair question to ask commercial companies because you need to run money. Open sourceness to me is like, that's what we need to have in the root of trust. Otherwise, I'm not willing to trust.
00:15:47.020 - 00:16:29.910, Speaker A: So then there's a question of like, basically how do you make open source incentive one? And I think that's a great question. I think there are some interesting approaches being tried in the AI space, for example, and in the chip world, there might be some sort of equivalent of that where, you know, maybe part of the chip has some logic, right? And this logic could be obfuscated in some way. And then maybe you have a Risc V, you know, processor, and this part is open source, so your actual acceleration, you know, which is like the zkar, like, that could be more closed source. And then maybe this thing.
00:16:30.890 - 00:17:13.592, Speaker B: So the ways I've seen it done for. I'm not a hardware person, but how I looked into this before. So, basically, for, like, you can make it completely open source of, like, Trezor hardware wallets so that everyone copies it. But at the end of the day, people generally will go back to Trezor as the more trusted one if they build a local approach. There's actually three ways. The second way is, how would world coin seem? So, world Coin has open source all their chips, but they kind of waited until they could get the leg up on production for the most part. And the last way is what Apple does, I believe, with their chips, where you have parts of open source and the rest, you get independent people that are very, very, very high trust to say, we've looked at this, let's say.
00:17:13.592 - 00:17:26.350, Speaker B: And then you basically have these certifications that they're starting to come out with. So you would just have someone from the crypto community be like, yeah, like, as close as we can get to the open source. We've had 30 people look at this stressfully.
00:17:27.090 - 00:17:43.682, Speaker A: Yeah, that's true. Although there's also a question of, okay, let's say I have some verilog, and I've shown you this verilog, and it's open source, and everyone can build on it, etcetera. And then I built this verilog into a chip. But how do you know that the verilog corresponds to it?
00:17:43.746 - 00:17:48.710, Speaker B: I borrow the oscilloscope from units. Nightmare fuel for, like, the alien.
00:17:49.370 - 00:17:50.984, Speaker A: But there are billions of.
00:17:51.162 - 00:18:21.434, Speaker B: Oh, yeah. So, like, you just have it checked often and maybe randomized. So basically, like, you have, like, from the supply line, like, we have someone walk up and actually take it and be like, I am checking this. And then, like, letting you get into it open source code levels to kind of get, like, a git script or something where it's, like, at some random point, whatever the next commit is that we decide is wrapped in the. Take it away or sent to somewhere else that you can't stop the process.
00:18:21.562 - 00:18:48.700, Speaker A: Actually, this one has a solution from the fabric, which is if you trust the ate manufacturer, then you could potentially have the ate cooked and throw all the JTAG ports that you left for DFP. And then you would basically do some sort of interactive group of logical equipments, which is already like kind of what you do, but this would be more costly because you could like have more coverage of various things.
00:18:48.780 - 00:18:50.120, Speaker B: You should have like 20 issues.
00:18:54.900 - 00:19:49.576, Speaker A: I don't think you have to wait 20 years necessarily true. I think with like maybe two generations from now or one generation from now, you'll have like pretty, I mean you won't have with in order of magnitude to plain text, but like somewhere close. Yeah. What potential impacts do you see if embed those changes in the next gen of your current chips? What are the potential side effects regarding, let's say, performance or don't think that it should create that much more performance impact like this one. You know, DFT designed for test is already something that you do for chips. Like it blows up area and like slows down certain things, but it's something you already do. So it's not like you're creating that much more overhead.
00:19:49.576 - 00:20:20.044, Speaker A: The random sampling is more of a cost overhead for chips. But again, the chip is like a portion of your overall supply chain. And so the chip may only be a certain amount of. So if you even double the cost of the chip, it'll create less than a doubling of the cost of the entire unit. So this may not actually be a big deal and open source. I think that's mainly a business question and business implication. The puffs are pretty small.
00:20:20.044 - 00:21:14.590, Speaker A: So like all of these, I mean, the biggest thing that I can think of is if you're actually making a modification to the, for example, you're creating some sort of workable commitment to memory or something like that. That would be where like maybe an application would come in, but like this part can actually do super high speed caching. So, like, we have like 40 Merkle per card for a second. And so, like, you could just, you know, transfer some stuff over to here and then. So actually, like, the main expense here is not on the actual, like marginal cost. It's on the initial effort to like embrace all this stuff. Like this is, this is all like difficult to set up but then easy to.
00:21:14.590 - 00:22:10.656, Speaker A: I want to talk about why chain effect. Like, yeah, you're saying, let's say I include your SDK. How do I know that? I would say, like, do you provide an SDK? Yes, we do. How do we protect against the software supply chain? That's a great question. I mean, that is like an active conversation that all of us should have. I think that there are plenty of unsolved problems in that first stage. Like, we're not going to be able to seal off the entire security novel with like one sweep.
00:22:10.656 - 00:22:17.568, Speaker A: I think it's more a question of, like, how many additional layers of security can we put in? How many things can we mitigate with the next one?
00:22:17.624 - 00:22:18.384, Speaker B: Next one.
00:22:18.512 - 00:22:47.594, Speaker A: So it's going to be an iterative process. I think the problem that you just posed as a problem across the industry kind of don't know exactly what we're doing. Yeah. So not related to this. How do you think about, like, in t's who basically have accurate memory, right. And, like, there is a 20 of the memory flight so that none of the secrets fall out. Right.
00:22:47.594 - 00:23:18.888, Speaker A: And not because we don't have fh. Yeah. So do you think fhe will be a million times faster and really just always cheap, or do you want to consider providing something like. Well, I think on the same process node, fhe is always going to be more expensive than the Francis. That's like, there's no way around it, right. It's always going to be more expensive. The question is how much? I think that something like 10,000 x is very, very doable, given enough time, money, etcetera.
00:23:18.888 - 00:23:57.446, Speaker A: The money could be quite astronomical for that. But you can do it. Like, you can do some back of the envelope calculations, and you can certainly put that many gates into animator. And then it's just a question of willingness. You have to build a team of hundreds and actually go do it over a period of years and higher on the pieces. But the question is a million. A million is like a harder problem.
00:23:57.446 - 00:24:54.270, Speaker A: I think the other thing that you can do is you can parallelize it more, and then you can have the cost come within maybe like several orders of magnitude of plaintext, but then the latency could be even better, and then you just parallelize it from machines. That's another way that you could kind of compensate, because you're just willing to pay more, maybe through some sort of blockchain subsidy of this thing. Like, you could easily get rid of this problem, because if you look at the bitcoin network, bitcoin has incentivized SHA 256 to such an extent. We're almost at a z per second. So this overhead, we can figure out ways for everyone to be able to create something that's positive sum that actually captures when fheelabs. Sorry, I think that's more a question for the roll ups.
00:24:56.370 - 00:25:09.350, Speaker B: How does polygon labs? I don't know. It's not about what I want, it's about what's gonna start a little bit.
00:25:11.100 - 00:25:13.460, Speaker A: I do think the fhe big problem.
00:25:13.540 - 00:25:22.540, Speaker B: Is the MPC on top of fhe because we need MPC to distribute the master key. But under the hood there are like.
00:25:22.580 - 00:25:24.996, Speaker A: Just the ten nodes hosting the key.
00:25:25.108 - 00:25:29.300, Speaker B: In a threshold network. Compared with like even Tor, it has.
00:25:29.340 - 00:25:32.948, Speaker A: Less nodes, but it's better than blendos, right? Of course.
00:25:33.004 - 00:25:50.410, Speaker B: But you said we needed a syntization mechanism for those nodes to create more nodes, right? Why is there only ten? Because the latency and bandwidth requirement grow like unscrewed so far, like leaked network, they only have ten nodes.
00:25:51.870 - 00:25:55.190, Speaker A: Okay, can you get Tes instead of.
00:25:55.350 - 00:26:01.730, Speaker B: Oh, they are already using tes, they are using amds. Interesting.
00:26:12.280 - 00:26:56.876, Speaker A: Oh, that's a good question. Why do Soc? So the question was like, why do everything on one chip? Answer is because there's really high bandwidth between different parts of the same chip. So like there are kind of, I think that someone was pointing out that like, oh, if you have like two bidders in a negotiation, like on a single chip, like that's a really good situation. Like that kind of co location is the same reason that you want to like put things on some chip. So it makes a lot of sense to create like a unified web3 chip because otherwise you run into a lot of I o problems. Like for example, a lot of people do like fixed functions ek six. But then the Xeon sending witness data to this CK ASIC is like super slow.
00:26:56.876 - 00:27:46.736, Speaker A: So no matter how fast your ASIC gets, like this is super slow. I was wondering for more for the t. Is there like all kinds of use cases in a way that, where you have like specialized secret hardware, you need to do signatures, right? Or you need to do proof of division or I one time. Yeah, this is a really good question. So I think that like, you know, potentially you have like a secure te with like a risk five. And then you have some other blocks that have different trust assumptions. And basically the goal would be to give people as wide and diverse a range of trust assumptions as possible.
00:27:46.736 - 00:28:33.382, Speaker A: So for example, like I saw a paper somewhere that was talking about like only having a secure multiplier. And I thought, wow, what a great idea. Because like all you have to do is just this one tiny thing that you can test there easily. Like in a random sampling context, you can easily test that all multiplier, know that nothing is wrong, right? So like maybe malt and then maybe like a simple, like em, like you can have all of these, right? You can have all of the above. And then like they all have their separate, literally physically isolated sections with like a very secure boundary between them. Like if you can do something like this, then you could potentially leave it up to the user. Okay, this was Torb Williams here at this group.
00:28:33.382 - 00:29:30.810, Speaker A: They basically know how to build an open source signing. Horrible. Just assign it so where the private key is secure, even if the device is in the hands of an attacker. But the problem with this is that we don't have a t yet. It will be a first step. But a question that can be interesting here is that if that can be a product on its own, or if you can have other kind of somewhat similar, specialized minimal for minimalistic devices you can sell that people buy, then it can help us with ongoing funding effort towards. Yeah, well the great thing is we're already going to come up with the next chip, right? So the marginal effort to like include these things is still quite high, right? Like doable.
00:29:30.810 - 00:29:48.998, Speaker A: It's within the realm of reason. So then like you can fit it into the next chip and then you get all this other functionality put in boat for free. Right. You still have to pay for the hardware and stuff like that. Right. But like all of it coming in like a one stop shop. Yep.
00:29:48.998 - 00:30:17.880, Speaker A: Have you thought about chips outside of server racks? Like maybe in a consumer device or. Oh yeah, I. Yes, I think the end game is that this stuff is going to be everywhere. So some subset of what we call the VPU today is going to be hopefully in every cell phone, et cetera. Now, not all of it will have the same functionality, right? Like cell phone. I heard someone say, like someone proposed putting fhe on the cell phone. This is not a good idea.
00:30:17.880 - 00:31:18.340, Speaker A: But you know, there are all sorts of good ideas that maybe a subset of the instructions that or maybe the entire instruction set, but like a few tiles, as long as you can get the thing off the ground initially, then you can actually write your entire chip paralog in a modular way and be able to make all these different product lines for different contexts. So that's certainly something that we would be interested in. Did you launch a token? We are a hardware company. Sometimes I look around, sometimes I look around and I regret it. Physical tokens? Yeah, maybe, maybe every chip has its own NFT or something. Attestation to the. Yeah, yeah, yeah.
00:31:18.340 - 00:31:40.140, Speaker A: Like attestation. So if anyone wants to contribute, collaborate has an idea of like how to make this real. Like certainly talk to us or even mention it here if we have more time. All right.
