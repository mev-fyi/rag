00:00:02.280 - 00:00:40.698, Speaker A: Hi everyone. So today I'm going to talk about this idea I call the united chains of Ethereum. This vision whereby the different l two s and roll ups can share a sequencer and be much closer together than they are today relative to the silos that we currently have with Ethereum rollups. And so in some sense, this is all about fixing ethereum fragmentation. So the talk will be in three parts. One, synchronous composability, and all the advantages that come with that. Two decentralized preconfirmations.
00:00:40.698 - 00:01:50.088, Speaker A: We're going to have decentralized sequences. How do we do preconfirmations in that context? And then three, this slightly more opinionated idea that maybe the l one proposes themselves can be doing the sequencing, and that's called base sequencing. So one of the key ingredients to get synchronous composability is this idea of shared sequencing. So different execution environment, different so called domains can share a sequencer, and then that one entity has monopoly power, at least within their slot, to simultaneously sequence multiple roll ups, or l two s. And just so that we're clear on definitions, there's different types of synchronicity. So one thing that you could ask, for example, this shared sequencer is synchronous inclusion to make sure that two transactions, one on roll up a and one on roll up b, both get included on chain at the same time. You could ask for something stronger, which is synchronous execution, where basically you have guarantees on state routes, not just on inclusion.
00:01:50.088 - 00:03:25.264, Speaker A: And then you have the strongest form of synchronicity, which I call synchronous composability, where you also have assets that can clear immediately in and out. And so basically these are guarantees that the shared sequencer can give on different data structures, either on the transaction route, which merkelizes the transactions, the state route, or the withdrawals route, which captures assets that go out of rollups, and l two s. Now let's imagine that rollups a, B and C have opted into a shared sequencer and imagine that the passage of time is from the top to the bottom. Now, the simplest thing you could do is you could have each roll up in some sense be its own silo and be executed perfectly in parallel and have maximum efficiency. But another thing you can do with shared sequencing is you can have the shared sequencer do some magic across the roll ups. So for example, at the top of the block here, the shared sequencer could choose to do some sort of fancy arbitrage, for example, which synchronously happens, but you can also, throughout the block, have opportunities for synchronicity. And in some sense, what shared sequencing is all about is exposing to the market this additional value that synchronicity can provide, synchronous composability, and then ultimately providing more value to users and to roll ups.
00:03:25.264 - 00:04:27.602, Speaker A: So if we zoom in to this little portion here between the yellow and green rollups, what is really happening? So you have this synchronous, so called supertransaction, which has multiple constituents sub transactions. So here we'll have three sub transactions, a yellow one, a green one, and then another yellow one. And really one of the important things here is that there's asset transfers that are happening in real time. And so you have this idea of real time settlement where the roll ups are immediately clearing their assets and are capable of sending them to other roll ups. And you can have these sub transactions kind of depend on what's happening in the other sub transactions. So, for example, you could have this final yellow call depend on the results of the green call, and that might introduce some amount of locking. So this is why basically, the way I depicted it is that only one sub transaction is executing at any given point in time.
00:04:27.602 - 00:05:31.714, Speaker A: And so that kind of has a cost, right? This virtual locking that the shared sequencer can provide means that the user is going to have to pay for gas simultaneously on roll up a and roll up b, even though at any given point in time, maybe only one single roll up is active and executing. Now, one of the things that's kind of important here is this idea of proving latency, because ultimately, settlement latency depends on how fast you can prove things. And so imagine that we have synchronous composition at the top of the block here. Well, that's actually pretty good, because we have a whole 11 seconds, if the slot time is 12 seconds, to do the proving and to include that proof towards the end of the block. But things can become really tricky. If you want to provide synchronous composability at the very end of the slot, you might only have a few milliseconds. And this is why the really fast real time proving is a requirement to unlock full synchronous composability across the full block.
00:05:31.714 - 00:06:09.822, Speaker A: Now, I'm very optimistic about low latency proving. There's all these really cool ideas around folding, which are basically very fancy, very efficient recursive proofs. This idea called nova, that pioneered a whole amount of literature. And we're also starting to see snark proving asics. So we have the very first, proving ASIC from axial. I'm going to be talking about it at the ZK summit. It's live, it's real, they're building test boards, and it provides a huge amount of cost reduction, of opportunity for parallelism and power reduction.
00:06:09.822 - 00:07:07.692, Speaker A: We're talking orders of magnitude improvements with these chips. Now, I guess an alternative to real time proving, because real time proving will still take a few months, is liquidity providing. So you can kind of simulate this idea of synchronous composability with liquidity providers. And so here in this example, even though these yellow dashed arrows and the green dashed arrows might take time, it might take, let's say seven days for settlement and asset clearing to happen. You can have these liquidity providers basically provide immediate liquidity on both sides. But that comes with downsides, it comes with fees, there's like capital inefficiencies, it comes with intermediation and complexity. And it also comes with liquidity constraints, because if you want to do NFTs, for example, if it's a one of one NFT, then that's very difficult to provide liquidity for.
00:07:07.692 - 00:08:18.574, Speaker A: And if you want to operate in size, for example, if you want $100 million of liquidity, then liquidity provided might not have that kind of liquidity to provide in the first place. So that was part one. Any burning questions so far? I mean, the idea here is that, again, with this very basic and simple idea, which is shared sequencing, we can have these currently siloed execution environments go back to what we have at layer one. At layer one you can have two contracts which synchronously composed of each other. You can have, for example, Aave synchronously composed of uniswap and executes a liquidation, which is something that we don't have the roller play today, so we don't have the equivalent of one inch or matcha. Like, you can't go to a website and say, give me the best liquidity across all the roll ups just because you're dealing with all these separate sequencers. And it becomes extremely, extremely massive.
00:08:18.574 - 00:09:10.058, Speaker A: Okay, part two, which in some sense is orthogonal to shared sequencing, is the very simple question of, ok, we have pre conformations with centralized sequences. That's super easy. They work really well. Like how do we do preconfirmations in a decentralized setting? And it turns out the answer is also surprisingly easy. So basically what you can do is you can have the user determine who is going to be the sequencer in the next slot. So here there's this notion of a look ahead, you can see who the next proposers will be, who the next sequences will be, and the user very simply makes a request to the next preconfirmer, and then gets a promise from that pre confirmer. And again, this is a promise on execution, not just inclusion.
00:09:10.058 - 00:09:56.600, Speaker A: It could be even a promise on asset clearing, the strongest kind of promise. And really the only thing that changes is that at every slot, there's a different sequencer. So what is a decentralized sequencer is just a fancy centralized sequencer, where the centralized sequencer changes at every single slot. And one, I guess, difference is that is how we do slashing. So with a centralized sequencer, you're leveraging reputational collateral. There's arbitrum's or optimism's reputation, which is worth probably billions of dollars, and they're not going to go ahead and screw users and renege on their pre conformations. But in a decentralized setting, where anyone could be the next sequencer, you need a different type of collateral.
00:09:56.600 - 00:10:39.294, Speaker A: And here you just use financial collateral. And there's two types of faults that are slashable. There's safety faults and liveness faults. Safety faults is when I gave you a preconfirmation that such and such transaction will execute in such and such way, and it turns out to not execute in that way. So there's a very clear safety fault, which would never happen if the sequencer is honest. And then you also have liveness faults, which are a bit of an edge case, a bit more subtle, where, you know, the sequencers really trying to be honest, but they were just offline at that point in time. And that's something you also need to penalize for, because they were not able to honor their pre conformation, just because they went offline and they were not able to produce a block.
00:10:39.294 - 00:11:40.024, Speaker A: Okay, now, I guess one question is, how do we do incentivized block building, and how do we modify Bev boost to take into account these preconfirmations? So right now, the pipeline for Mavboost is, like, unidirectional. You have the builders that push blocks to relays, that push block to proposers. And really the main thing that you need to do is basically provide information in the other direction. So you have the users, which are now this new entity in the block production pipeline, that have preconfirmations with the proposal or pre conferral sequencer, however you want to call it. And then these preconfirmations can flow upstream to the relays and ultimately to the builders. And now the builders are tasked to build blocks that respect the preconfirmations. So really, what is this? It's like a fancy inclusion list in some sense, or preconfirmation list that constrains the block builders in what they can do.
00:11:40.024 - 00:12:31.996, Speaker A: And like one, one important detail here, I guess, is that the relays could enforce that. These constraints are respected. But nowadays a lot of the relays, at least the competitive ones, are optimistic relays, where they don't check in real time, these constraints. And so what you'd need is the builder to be collateralized to the same extent that the proposer is, in case the builder doesn't honor the pre conformations that the proposer did, so that the proposal can be compensated by the builder if a bad block was built. Okay, so just as a quick summary slide here. In some sense, centralized preconfirmations and decentralized preconfirmations are the same thing, but there's just a few things that change. One is that the sequencer, instead of being fixed, is now rotating.
00:12:31.996 - 00:13:02.316, Speaker A: So at every single slot you have a different sequencer. That's easy. The slashing is also a little different. You're now using financial collateral as opposed to reputational collateral. Fine. And then like, another final thing which is interesting is how Mev is done. So today, with decentralized sequences, you can kind of think as decentralized sequencer, providing a makeshift, super cheap, encrypted mempool.
00:13:02.316 - 00:13:26.000, Speaker A: As a user, I send my transaction, end to end, encrypted to the sequencer. No one can see it. I can't get sandwiched. For example, I get this MEV protection. And oftentimes there's a policy which is that we're not going to screw our users, we're not going to sandwich them. Another policy might be some sort of first come, first serve. But these policy based sequencing, I think, is going to be much harder in a decentralized setting.
00:13:26.000 - 00:14:34.626, Speaker A: And so you have to move to something which is a bit more market based, something like PBS, for example. So we've gone through these two parts. Part one, there's potentially a lot of power to ethereum reuniting and fixing its fragmentation with shared sequencing. And if you're given a decentralized sequencer, actually providing preconfirmations is fairly easy. And now what if we take an existing shared sequencer, which we kind of all in our subconscious know exist? Can we kind of compile it in some sense to modify it, to give preconfirmations for that, and kind of make it a really great sequencer? And this is what base sequencing is all about. So in some sense you can think of Ethereum as being like this service that provides multiple modules. So there's the settlement module, which all the l two s will use.
00:14:34.626 - 00:15:28.884, Speaker A: There's the data availability model, which all the roll ups will use. And then there's this third module, which in some sense is new because people have only realized recently that they can go and leverage it, but it's been there all along, is the sequencing module. So you can use the l one proposers as sequencers for your l two. And just like Coredata was this somewhat hidden thing that people only realize could be reused as data availability for l two s. L1 sequencing was also this hidden thing that existed from Genesis. Now why would you want to use Ethereum sequencing? Well, it's for all the same reasons as to why you'd want to use Ethereum settlement or Ethereum data availability. You inherit the security of l one, you also inherit a lot of the credible neutrality that comes with it, and you also inherit composability.
00:15:28.884 - 00:16:40.684, Speaker A: Now how does it work exactly? Like who are the sequencers in the context of base sequencing? So in the specific design that I'm proposing here, we basically have a subset of the l one proposers who opt into becoming sequences. And the reason why it has to be a subset is because they have to come forward with collateral, right? They don't have reputation, so they come forward with this financial collateral. So the green ones have put forward collateral and they're a subset of the proposers in the look ahead. And we're going to call those sequences. And everyone else who's not a sequencer, who didn't put forward any collateral, we're going to call them includers. And basically the idea here is in order to provide preconfirmations as a service by the L1 proposers, we're just going to do exactly what we talked about in the previous section. We're going to have the user communicate with the next sequencer, which happens to be this green one, which is collateralized.
00:16:40.684 - 00:18:05.910, Speaker A: A request will be asked from the user, a promise will be given by the pre confirmer. And one of the things that we can also do is basically have the includers be given the right to include and settle pre confirmed transactions. So the includers don't have the right to order transactions, but if they have an ordering which is given to them from the next sequencer, well, they can go ahead and include that and settle it. And so basically you have best in class user experience on the one hand, you have the 100 millisecond latency of sending a request, getting a pre confirmation really, really fast. And you also have the next slot settlement because this includer can immediately settle in their slot whatever was sequenced by this pre confirmer. And again, there's a very simple diagram here where we modify mathboost so that the blocks take into account the preconfirmations that were given by the proposal. Now one of the questions you may ask is, if I want to provide preconfirmations, shouldn't I be very, very sophisticated? And the answer is yes.
00:18:05.910 - 00:18:52.336, Speaker A: You need to have at least enough bandwidth to support user requests from all the roll ups. So that's potentially tens of thousands, hundreds of thousands of transactions per second. You need to be running full nodes for all these roll ups. It could be hundreds of full nodes, and you need to do all sorts of fancy things like pricing the pre conformation tips. You need to have high uptime, low latency. And so really it's fair to ask, do we really want l one proposers that are running on a raspberry PI to be preconfirmers? And the answer is no. And the good news is that we have this idea called execution tickets, where as a validator that's running on raspberry PI, I don't have to do block proposing.
00:18:52.336 - 00:20:06.970, Speaker A: Instead my main task is attesting. I also have to build inclusion lists for sensory resistance, but I don't have to do the sophisticated sequencing. Now unfortunately, execution tickets are a hard fork in the future, potentially, and they would take several years to come out. And so what can we do in the short term? Well, in the short term what we can do is basically introduce a trusted entity here, semi trusted entity like the relays, which we could call the gateway. So this would be a pre conformation gateway, and the proposer would delegate their sequencing rights to the gateway. So now the gateway can provide these, these pre conformations on behalf of the proposer, and they would be collateralized in case, you know, they, they cause a safety fault. Now this whole idea of base sequencing is relatively recent, and a lot of the roll ups had their own plans to do different things, but in the last few weeks and months there's been more and more interest from the ecosystem.
00:20:06.970 - 00:21:02.284, Speaker A: So we've had Tico, that's been a base roll up for a very, very long time. A few days ago I learned about this new roll up which is also going to be based. And then also a few days ago, one of the founders of the very top roll up, some production today said that they're going to be pushing for them to become a base roll up. And then there's all sorts of infrastructure providers that are also starting to build infrastructure dedicated to base roll ups. There's espresso, Sorella, chain bound, and there's other entities, for example lime chain and nevermind, that are doing like research and consultancy. So really the ecosystem is very nascent. But there's more and more momentum behind this idea of using the l one proposers for maximum security, maximum credible neutrality, but also being able to leverage the TVL of the l one.
00:21:02.284 - 00:21:45.750, Speaker A: Because if you zoom out and you look ok, where's the TVL? Sure, there's like arbitrum has 10 billion or 15 billion, but then you have the l one, which has half a trillion or 600 billion. So it's orders of magnitude multi vl at layer one. And when you have this base sequencing, basically the roll apps can synchronously compose with the l one. And so you get access to all these pools of liquidity. You get best in class user experience because now you can have complex applications that live in multiple places, including some on DL1. Um, and yeah, that's basically the, the pitch for, for, for base sequencing. Um, okay, last slide.
00:21:45.750 - 00:22:32.660, Speaker A: Um, so right now we're in this place where we have centralized sequences and I think we all agree that we want to move to decentralized sequencing. And there's going to be quite a big lift in my opinion, to get from decentralized to centralized. Like we need to think of all sorts of things like MEV protection, PBS, intense ofas data compression and whatnot. So I think that's where 80% of the problems need to be solved. And then within decentralized sequencing there's a subset of problems that are specific to shared sequencing. And that's where maybe let's say 15% of the problems need to be solved. So we need to solve, for example, MeV sharing as a roll up, I opt into a shared sequencer, and doing so by default, I'm giving my MEV to that shared sequencer.
00:22:32.660 - 00:23:24.054, Speaker A: Like can we basically identify where the MEV came from and kick it back, rebate it to the roll ups that generated that MeV? There's also other problems that we can think about, like deposit sharing and execution sharing. But in general speaking, there's fewer problems to be solved than just decentralized sequencing alone. And then there's this kind of final subset of even more specialized sequences, which are the base sequences, where in some sense there's very little to solve. It's just being opinionated about saying, okay, the preconfirmers are going to be the l one proposers, but everything else, all the other technical problems around preconfirmations and shared sequencing that can be solved using off the shelf technology, and that's it. Thank you.
