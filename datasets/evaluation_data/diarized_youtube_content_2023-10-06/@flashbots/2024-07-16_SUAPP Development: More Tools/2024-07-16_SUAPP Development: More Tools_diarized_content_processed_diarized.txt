00:00:10.910 - 00:00:40.540, Speaker A: All right, I think it says we're live. All right, y'all, I'm trying to get my webcam set up here for whatever reason. It's just. Yeah, I don't know what's wrong with this thing, but as you can see, this is my webcam up here and it's stuck. So I think we're just going to have to go. No webcam. We'll just get on with it.
00:00:40.540 - 00:02:17.874, Speaker A: Okay, let me pull up the outline for this stream, see what we're going to be talking about it. Hey, the mic was muted again. Okay, now can we see that? Damn, why is this stuff so hard? Alright, so here we are, the first stream. We set up a super basic swap and I'll spin that up here in a minute. We'll dig back into the code if you missed the first stream, but in this one we're going to go into all the other tools that we didn't cover in the first stream. So some big ones are like suave geth spell. So this suave geth spell is kind of like suave's version of like cast or foundry, if you're familiar with foundry.
00:02:17.874 - 00:03:04.440, Speaker A: So it's like cast or forge, where you can create contracts or send confidential requests just from the command line. So that'll come in handy. Yeah, this is sort of, this is supposed to be a sub bullet point. Ignore that. We can also write some, we're going to write some forge tests with suave stuff inside the, inside the forge tests. So a couple sub bullets there and then we'll also talk about suave Geth ETH providers. So every node, every suave geth node has an attached Ethereum provider.
00:03:04.440 - 00:03:45.176, Speaker A: And when you're developing locally, I'll show you this in a minute. But when you're developing locally, you have sort of this default, it's suave execution geth. This is just like the default geth node for the suave Eth provider anyways. It just provides like Ethereum l one type data for suave. So I'll, yeah, I'll get more into it as we, as we cover it. You know, each topic individually. That's what we're going to do today.
00:03:45.176 - 00:04:37.590, Speaker A: So to start this off, I'm just going to, this is like a brand new environment here. So I have nothing running. So I'll just do everything from scratch, which means first I actually need to spin up swap gethenness. I have a script to run this. It's just for me, but you'd want to run something like this specifically for this stream this flag right here, suave remote endpoint. This is what's going to point to our custom alternative Eth provider. So pay attention to that.
00:04:37.590 - 00:05:46.190, Speaker A: And then this swabeath external whitelist, this just defines which URL's we can access via the HTTP precompiles. So if you've looked through suavestd, let's look at all the precompiles. So, okay so these, these are all the precompiles or, you know, the names of the precompilers and the addresses that we use to access them via solidity. Where is it? This one here. So do HTTP request. So this reads this whitelist and that is what tells it which URL's it's allowed to access and which ones it can't. So here we just have it set to the wildcard, which means it'll access anything we give it.
00:05:46.190 - 00:06:49.342, Speaker A: And that's good for a dev environment, but obviously in prod you would want to lock that down anyways. So going to run that, this is just going to run the swab geth Devnet should be familiar with that from the first stream. If not, check the notes here and then suave execution geth. We'll start there and then we'll look at the alternative. I guess we'll do that last. I have a script here for that as well. And this is the same thing except in the first, in suave geth here, this script, it's using suave dev, which it like includes all of these, but I'm not sure if that's insuave execution geth.
00:06:49.342 - 00:07:33.620, Speaker A: So I just have all these manually set, need a second. Take a screenshot of that. Or even better, I'll leave it there for a second while I just run this another window. Okay, so that's, that's a suave geth environment. All right, we don't need this anymore. All right then we need to run our app so real fast. I need one of these over here.
00:07:33.620 - 00:08:38.414, Speaker A: 1 second. Yeah. All right. Okay, we got too many windows. Stack these, not exactly what we wanted. Close enough. All right.
00:08:38.414 - 00:09:21.546, Speaker A: Okay, so let's start working on this thing. So first let's start off with suave geth spell. Let me close all these. All right, we got a handful of stuff that we can do to this. So the code that we wrote in the last stream, we're just going to work off of this. So there's a bunch of stuff that we could do here to make this better. But first I want to just deploy this contract.
00:09:21.546 - 00:10:42.110, Speaker A: So I want to show you all the different ways to deploy a contract using the suave tools that we have available to us. So first off, let's do this swab geth spell. So if you have swab installed like in your system path, you can do where is suave? Or where is suave geth def to find that mine is mapped to the actual location in which I build it. But you can also install it with swavup. Let me see if I can find the link. Yeah, so it's suaveup dot flashbots.net. so this is just a script that's going to install swab Geth, you know, like into your, I think it goes into local bin or something, but this will just install it.
00:10:42.110 - 00:11:34.162, Speaker A: So if you could, if you want to install it this way, you can do curl swapup dot slash dots.net, you could curl that into bash or something and that would, I didn't do that exactly right. I think you need a, yeah, dash lithe. That will do it. That will do it for you. And it looks like it just did it for me. So now if I went did where is suave Geth swath? Oh, I see it.
00:11:34.162 - 00:12:06.828, Speaker A: Put it in home dev swab bin. Oh, I need to load the new path. Okay. Yeah, so there's, now I have two versions installed. Suave Geth and this suave and suave geth and where I built it. Anyways, that was sort of a, sort of a long walk away from the point. But you'll install suave and you'll be able to run it like this in your terminal.
00:12:06.828 - 00:12:31.960, Speaker A: So if you run suave spell. So you've got some commands here. Just a couple. Deploy a contract and conf request. So we'll start with deploy and then we can, we can actually just send a request from the command line. Let's see how that works. So let's deploy the counter contract.
00:12:31.960 - 00:13:30.400, Speaker A: I think I'll make these just a little smaller. Okay. You probably don't need this anymore. Okay, so all the code is in the swap directory. And oh yeah, if you want to follow along, everything we're doing here is in the stream two branch, don't need that yet. But yeah, if you want to follow along, all the code we have that we're starting with is in the stream two branch and we're just going to be working off of the previous streams example. So yeah, what is it? Here's the link.
00:13:30.400 - 00:14:17.902, Speaker A: Zero xbroc GitHub IO livestreams or GitHub.com dot GitHub.com zero xbroc livestreams. Get the code there and follow along. All right, so suave spell deploy. All right, so how this works is pretty simple. I think this arguments thing, we should probably change that because it's not exactly clear what the arguments are, but thankfully I know them off the top of my head, or at least I'm convinced that I do.
00:14:17.902 - 00:15:05.728, Speaker A: So we'll try it out. So suave spell deploy. Um, I don't think we need a private key because this is just going to use the default funded account in the suave devnet. That's the nice thing about using swath spell. If we wanted to do this from something like forge, or if you wanted to do something like this from cast, you have to provide the private key because boundary doesn't come with that private key in its default key store. But with suave, we already have that key sort of ready to go. So we don't need to provide that private key.
00:15:05.728 - 00:15:46.090, Speaker A: Kettle address and RPc, we can also use the defaults there. So we actually don't need any options. We also don't need artifacts either, because the default value out is where our contracts are being. Contract artifacts are being sent. So that's good too. So we can just, I think we can just run suave spell deploy and then it's going to be the file path, I believe, source, counter, dot, sol. But it might actually ignore, I think it ignores source.
00:15:46.090 - 00:16:54.800, Speaker A: Like it assumes, it assumes source is the contracts directory. So assuming that we're in source, we'd want to put dot, slash, and then just like forge create, we'll do this colon, and then the contract name. So counter, dot, sol, colon, counter. And yeah, that worked. So one thing that's not super clear, if you look at the help menu, you know, the format of the, of the actual contract you pass as an argument is necessarily specified. And also it doesn't take constructor arguments. So for instance, if, if this contract had a constructor like this, that took a number, that would be like our base number when we deploy the contract.
00:16:54.800 - 00:18:12.420, Speaker A: And if we wanted to create this contract now, if we did the same command, oh, we got to build it first, right? So it's going to throw an error and we can't pass that. So if we have constructor Arg's, we have to do it slightly differently. One sec. So yeah, we want to pass constructor Arg's just for this example. So you know, we have forge create and this, you know, this is foundries fully featured contracts, you know, testing and deployment. Cli helper, you can see this first option we have, constructor Arg's, so we could do the same thing with Forge created as we did with swap spell deploy. It's just going to be.
00:18:12.420 - 00:19:17.300, Speaker A: We need a private key because remember, forge doesn't have that key. But what is that key? It's somewhere deep in suave geth and I just have it saved somewhere. So let me. Let me try and find it real fast. Oh, whoops. Oh, no. Let's check the docs.
00:19:17.300 - 00:20:09.090, Speaker A: Suave flashbots.net or suave alpha flashbots.net. see if you just find everything with a zero x in it. Local dev account. Here we go. Yeah, this is just the page I was looking for. Tolium and Testnet is where you'll find this.
00:20:09.090 - 00:20:34.464, Speaker A: So we need this one of these dev accounts. So here's the private key for that. That's what we want. And this, so this account here, this default dev account, this has like 10 million or 10 billion or something eth. So yeah, we can just use that. Okay. RPC URL, it's going to default to localhost 8545.
00:20:34.464 - 00:21:10.400, Speaker A: So that's fine. I think everything else, all the default options are okay for this. Yeah, we just need to pass the contract now and the constructor args. So with constructor args, it gets kind of funky because it accepts multiple arguments after the invocation of the option. I'll just show you what I mean. So we want source slash counter Sol. So forge is expecting the actual path, not a relative path.
00:21:10.400 - 00:21:35.492, Speaker A: Well, relative to this directory, but, you know, relative to the shell, not relative to whatever is going on inside the program. I digress. Source slash counter dot soul calling counter. All right. And then again, we need constructor Arg's. So constructor Arg's we can put afterwards. And then it's just one number.
00:21:35.492 - 00:21:59.560, Speaker A: So we can just pop that number in here. So let's say 42. Okay. And that worked. So, all right. Yeah, that's how that works. If you want to deploy a contract, it would be cool to add constructor Arg's to the, to the suave spell command.
00:21:59.560 - 00:22:24.610, Speaker A: You'd like to add that at some point, but just don't have it now. So that's how you deploy contracts. If you, if you have a constructor Arg's. But I'm going to actually just remove this because we don't need it. And let's get back to the swap spell stuff. So we've deployed the contract, let me deploy it again with. Whoops.
00:22:24.610 - 00:23:44.348, Speaker A: I need forge build to get this back to normal. And then, so I'll spell deploy. Let's hold on to this address. No, actually since we're going to deploy it, we're going to deploy the contract a lot and we're going to need to save this address, you know, constantly as we're developing. So what I'm going to do is just make a little script to deploy the contracts. Deploy contracts sh, oh, but actually, you know, I'm going to use Forge for this. Let me show you, why don't you constructor Arg's.
00:23:44.348 - 00:25:02.930, Speaker A: But let me take this. So one really cool thing about Forge is that you can make it output JSON. So now when we run this, well let's just run it, see what happens. All right. So yeah, you see, it spits out this JSON object instead of the sort of log style output that it did before. So if we capture this input and if we pipe this into JQ, then we can just parse the contract address right out of it. But even we don't actually even have to parse any of it with JQ because we could just write it to a file and read the JSON directly.
00:25:02.930 - 00:25:57.560, Speaker A: So we'll just run this and write the file to contract deployment JSON. Just a simple standard out redirect into a file here. So now when we run this contract cat contractdeployment, JSON now exists. There it is. So now in our app we'll be able to just import this file. Let's also ignore that. We don't want to commit that to source.
00:25:57.560 - 00:26:51.692, Speaker A: All right. Oops. All right. All right. So now we got a simple way to just keep deploying the contract as we test it out and modify it. Okay. All right.
00:26:51.692 - 00:27:39.806, Speaker A: So back to suave spell. So let's deploy or so we've already deployed, we've already deployed a contract and we want to send a confidential request to it in the command line. So suave spell conf request. Alright. So you can see from the help menu we've got mostly the same options from the deploy command. But these arguments are just slightly different. You see, we have confidential input here.
00:27:39.806 - 00:28:15.020, Speaker A: That's a new one. So in our contract example here, we read confidential inputs to set the number. So it's just going to be expecting a number here. If you're expecting more than a number, you'll have to abi encode that payload. But that's not too hard to figure out. You can also do that with cast. If you do cast Abi and code.
00:28:15.020 - 00:29:11.130, Speaker A: Yeah, check that out. That will basically pack up if you have a struct here, or if you have multiple primitive types, this is what you would use. But let's just send one with what we have now. So spell comp request and let's do the options first. Confidential input. And let's just say that's a number, zero x 42. And then the arguments again, they're not spelled out, so let me try and remember how how they go.
00:29:11.130 - 00:30:06.490, Speaker A: I believe it's just the contract address and then the signature of the function. Let's cache that contract deployment. We want the deployed to address. Copy that, the address and then the function signature set number. Okay, let's see. It looks like we entered it correctly or the contract anyways, but we got execution reverted, so I wonder why that is. Oh, here, right here in suave geth.
00:30:06.490 - 00:30:57.638, Speaker A: Insufficient funds. Oh no, that wasn't it. That was this one. Let's run it again. Why is that failing? Let's see if we can figure it out. So why is it failing? Well, first we need to be able to emit these error messages correctly. Well, not emit these error messages.
00:30:57.638 - 00:32:05.790, Speaker A: This is an error message. But if there's an error message, we won't be able to log it correctly unless we do this. We need to make it. Need to get the swap. Swap contract. Basically you make it a swap. Am I doing this right? Source swap? Yeah, this should be right, but yeah, so it allows you to add this emit off chain logs, and this logs contract does a bunch of stuff to decode logs, I think from swab they're in like base 64, so there's just some decoding that you have to do to see them.
00:32:05.790 - 00:34:11.350, Speaker A: Oh, here's what we did wrong. Counter isswap. Okay, I don't think that'll change anything right away, but yeah, so still just execution reverted. Maybe we're doing all right. What are we doing? Wrong method arguments. All right, so we can see, you know, if we remove the quotes from the setnumber function failed to parse method signature method, no match is found. So we're actually calling the function.
00:34:11.350 - 00:34:47.930, Speaker A: We know that because it's reverting when we put this back there. Just can't tell why it's reverting. Let's try this. And it's off chain logs. I'll talk more about what this does once we get this working, but this is super confusing. I don't understand why this isn't working. Let's try this.
00:34:47.930 - 00:35:38.140, Speaker A: Let's make a new account. All right, let's send it some money. So there's the private key that we were using before. I just have this command hot loaded. You know my shell history, but I'm going to send it. I'm going to send this new account, one ether, and then from that new account I'll send this just in case that's the problem. Nope, that's not the problem.
00:35:38.140 - 00:36:44.730, Speaker A: Hmm. What about this? Oh, oh, also, I just realized we didn't update the contract like we're. Yeah, we're building the new contract, but we're nothing deploying the new contract. We need to get the new address there. We need to make sure to add that in our new. Yeah, in our new command. Whoops.
00:36:44.730 - 00:37:34.860, Speaker A: Okay. Make sure that we do that. Okay. Hmm. All right, we'll figure this out. Let me think. Maybe we can try this.
00:37:34.860 - 00:38:19.070, Speaker A: Let's open up the. Let's open up the web app. Alright, it's time to. Oh my God. It's time to switch this up. Okay. All right.
00:38:19.070 - 00:39:17.140, Speaker A: Oh boy. Oh, that was wrong. Okay, we'll just do this. So let's see if we can just see if we can still call the contract from the actual web app. This one. All right, so we run bun, run Dev in this tss swap thing. Get a web browser, go to local host 5173.
00:39:17.140 - 00:40:33.340, Speaker A: Oops. There we go. Alright, so if you remember, this is the thing we built last time and it looks like it's also reverting. Oh, geez. We got to figure this out. Oh, this one's just insufficient funds. Right.
00:40:33.340 - 00:42:12.300, Speaker A: Connected account. Let's send it some ethereum. Okay, localhost should be. There we go. Transaction failed. Yeah, looks like that one worked, but it didn't. All right, what do we do wrong? Hmm.
00:42:12.300 - 00:44:15.080, Speaker A: Anyone got any ideas? I feel like this was working before and now it's not. I don't understand it. This all looks correct. Oh, yeah. Oh, well, I also know why the web app didn't work, because again, we have the wrong address here. There we go. Let's try that because it really feels like this should be working.
00:44:15.080 - 00:44:30.588, Speaker A: So there's the right address. Set the number. Okay, good. Transaction successful. Refresh. Sweet. There's the number.
00:44:30.588 - 00:45:19.460, Speaker A: Okay, so the contract is designed correctly. I'm. I must be using the. I must be using the spell command incorrectly because it's not liking that, but I don't know why. Maybe I'll follow up on that later because we spent a lot of time already trying to figure that out. But yeah, if you want to send confidential requests on the fly, that's usually a good solution. I just, I feel like I my brain scrambled and I can't remember the exact arguments.
00:45:19.460 - 00:46:44.356, Speaker A: So if you want to figure it out, let's see if we can find the. Where is it? All right. Yeah, I'll get back to it later. All right. What else are we doing? All right, so let's, let's go into some forge tests. All right, so, yeah, like the way we set this up from the very beginning was we just built the app and then we built the smart contract, the swab portion of the swap, and then we built a front end and just plugged it straight in. And that was like the only way we tested it, just straight up live integration test.
00:46:44.356 - 00:47:47.210, Speaker A: No, no, actual testing really. So we'll cover some forge tests so you don't have to build a whole app to see if your smart contract works. All right. So to write forge tests for suave, it's pretty simple. Here we've got our t sol file for counter, and all we have to do to make it work with suave is import, import suave enabled from suave STD. And that's from suavestd test sol. And then you say your counter test is test, test is from Forge stdin swab enabled here.
00:47:47.210 - 00:48:21.780, Speaker A: So it's test and swab enabled. We have everything commented out just because last time the tests were failing, because we hadn't written them correctly. We hadn't written them at all. They were the default tests and we changed the code. So we commented these out. But let's, you know, let's write new ones. I'm just going to delete this setup here and this contract state variable counter.
00:48:21.780 - 00:48:49.200, Speaker A: We'll also have to delete those. So in swab enabled, we've got this setup already that triggers ffi. This is how we launch suave. We launched suave Geth in the background to do this stuff, to run the tests. So this is how it works. But because that's there, it means that we can't write our own setup function here. But that's not a big deal.
00:48:49.200 - 00:49:40.880, Speaker A: We can get around that. We'll just make a new contract for every test directly. So test, counter, make a new counter. Let's not jump again here. But yeah, we made a new counter and it's going to call setnumber. Remember, setnumber is the right, so setnumber is the confidential function that reads the confidential inputs and decodes. Decodes them into a uint to trigger the callback, which sets the number in the smart contract.
00:49:40.880 - 00:50:30.452, Speaker A: But how do we get the confidential inputs for counter to actually read from? Because we can't pass them function arguments. So to do that, suave enabled, it also adds a contract variable called CTX. And that's like, you know, just your context. We only see gas and origin right here. But there's more. There's a function called setconfidential inputs that does exactly what you think it does. So yeah, see if we can find the definition.
00:50:30.452 - 00:51:16.744, Speaker A: There we go, some context connector which is inherited, but it, yeah, so it takes bytes memory and it'll set the confidential inputs. So we just need to give it Avi encoded bytes. So if we wanted the number to be 42, AVi code 42, pass it in and that's done. If we call counter dot setnumber, well it'll set the number but. Well, we should expect it to set the number but let's see what happens. So counter dot number, this public variable will also be accessible as a public function. We'll use that to read the value.
00:51:16.744 - 00:52:41.090, Speaker A: So we'll get the number here and let's make sure that it becomes 42 number 42. All right, and let's pull up a shell. All right. Then we can run forgetest and we need to pass the FfI flag. So yeah, it didn't set the number, but why? So when we call counter dot setnumber, I mean obviously, you know, the number isn't being set inside of here, it's being set when the callback is called, when onset number is being called. All this is doing is it's going to run this stuff and then it's going to return this call data to trigger this function. So we can actually look at that if we capture the bytes that are returned here.
00:52:41.090 - 00:53:30.870, Speaker A: Bytes memory counter, oh, I don't know. Set number result. Let's log those bytes. I'm going to get console two in here from forgestde. Okay, also two log bytes, set number result. Let's see what that looks like. I'll add vvv so we can see the logs when it errors.
00:53:30.870 - 00:54:34.930, Speaker A: All right, so what's it doing to here? We call set number, the setup thing happens, triggers ffi, blah, blah blah. Okay, I think something here. Log bytes. Okay yeah, that looks like call data. So we have zero x 8519 fffb. So that would be the function signature and we can verify this too. So if we do cast sig, the function that we're calling is called onset, onset number with uint 256 as the argument.
00:54:34.930 - 00:55:31.178, Speaker A: Sure enough, a 519 fffb. So yeah, the function signature is correct here. And then everything that follows, you know, a bunch of zeros in two a two a in hex is 42, so it's working. But in forge, you know, when we return the callback that calls this next function, forge isn't going to automatically execute that function. It's not going to read the call data and say, execute that. This is what the kettle does. This is what would happen in a live, suave environment, but in a forged test, it doesn't.
00:55:31.178 - 00:56:52.800, Speaker A: So if we want to test both, you know, this initial function that we call, which still runs, it does its thing, you know, it's going to interact with swab, it's going to call precompiles, it's going to do off chain stuff. But if we want to see the full behavior of what happens afterwards, we need to call this onset number function directly. So in our test, we could do some stuff here to verify. If you wanted your test to be really good, you could verify the call data and everything here. So we could say something like set number, result, I don't know, let's say zero, and that should be a five. You could also like strip all the call data. This is, it gets kind of involved because you have to strip the call data and then you have to decode the bytes into the type you're expecting.
00:56:52.800 - 00:59:23.740, Speaker A: And then let's see if we can get chat GPT to write something for us. Let's see if that works. I don't know if this will work, but it's worth a shot. Not call data. Okay, try that. Let's block that out and make sure. So let's see if this passes.
00:59:23.740 - 00:59:47.580, Speaker A: Cool. That passed. So, yeah, that's how you would like, that's how you would check the call data that's being returned. But I don't know, it's not super necessary. You could also just look at it because, I mean, you really, you're just testing, you know, Abi, dot encode a selector. Like, you don't really need to test it, but it's good to know. Anyways, back to the program.
00:59:47.580 - 01:00:31.030, Speaker A: We need to set the number directly if we want to test this callback. So we could just call that, we can just say counter dot onset number 42. I'll make it 43, just to show that this initial thing doesn't do anything to the state. This initial thing doesn't do anything to the state here. We should expect it now to be 43. Okay, sweet. It worked.
01:00:31.030 - 01:01:12.464, Speaker A: Look deep at the logs. Everything is working. On set number 43, it's emitting this log emit number set. So exactly what we expect from calling this. So, yeah, just to put a cap on it. If you want to test your functions, you know, your confidential enabled functions in forge you need swab enabled. And then you need to remember that confidential functions that return call data as bytes, they're not going to trigger the callback.
01:01:12.464 - 01:02:28.370, Speaker A: So you have to trigger the callback yourself. But you know, that's, that's how you can get a fully featured testing environment for your, for your swaps. It doesn't stop here at the boring counter stuff either. Let's make this example a little more interesting and use some actual suave stuff. So let's like, let's just use the random number generator from suave. So what we'll do is we'll write another function that sets the number to just, it'll read a random number from suave and call onsetnumber to update the number. Okay, set with random number returns bytes memory.
01:02:28.370 - 01:03:20.330, Speaker A: Remember, we're returning bytes memory because we're going to call this confidentially. So also confidential. And if you're not familiar with this little thing here, it's this modifier. So every function that you call with the CCR, you need to make sure you call this requireswap is confidential. This is just going to make sure that it's being called from like an EOA with confidential inputs as a confidential request and not publicly on chain. Okay, so how does this work? We don't need to read confidential inputs because we're not going to pass it any data we're, you know, we're going to get the number from. So it looks like copilot already figured this out for us.
01:03:20.330 - 01:04:00.180, Speaker A: Almost suave random. That's not a thing. We need import random from suave std random. Yep. And then we can call random random uint 256 to get our new number. And then we can just use the same callback onset number and we'll give it our new number. And that looks good.
01:04:00.180 - 01:04:40.498, Speaker A: All right, so then in the test, let's add another test. Test random counter. Need to make a new counter. Not going to set confidential inputs, but we are going to set with random number. That looks good. Sure, we can log the bytes. Don't really need to do that.
01:04:40.498 - 01:05:28.632, Speaker A: Again, I'm not going to do that. Oh yeah, actually we kind of want to do this, so. Yeah, because we're getting a random number. I mean, we've already tested that. We can set the number. So like this last step here isn't super important, but I want to see, you know, that this number is random. So maybe we could just say like we're reading the number here with this remove function selector, just good to have for this random test.
01:05:28.632 - 01:06:05.490, Speaker A: We could just say, you know, make sure it's not 42. It's not a perfect test, but the chances of this random number coming out exactly 42 is like slim to none. So I think that's pretty good. Whoops. Not equal. Oh, I guess not equal is not in here. Let's just do a regular assert.
01:06:05.490 - 01:07:07.800, Speaker A: That's fine. So we'll just run the random test, see if that works and it looks good. I'll turn down the logs by one. Why is it, oh yeah, okay, so it is random, but. Well, yeah. Okay, I was getting confused because this a five, this is the function signature, and the random number starts right here. So instead of logging bytes, let's just log the number.
01:07:07.800 - 01:07:36.090, Speaker A: Sweet. Looks like we're getting random numbers. Looks great. Cool. So yeah, we can test that. We can test that. The precompiles are actually executing and hitting suave.
01:07:36.090 - 01:08:16.650, Speaker A: That's kind of a simple example, but there's an even better example that we should do. Let's add another precompile. Let's add one that accesses. Let's do one that makes an HTTP request. Because for this one you need to do a couple extra things to make it work. But let's write the function first. Maybe not an HTTP request.
01:08:16.650 - 01:09:50.530, Speaker A: Let's do an eth call. So let's do this. Let's set the number to what the heck? Vitalix balance. Alright, so what I'm going to do here is I'm going to use the eth call precompile to read the wrapped ether contract on, on the l one eth provider that's connected via suave. I'm going to read the weth balance from the wrapped ether contract, Vitalik's address, and set that number to this contract number. Okay, so how do we do that? First off, we need Vitalux address, etherscan vitalik eth. There's the address, need the wrapped ether address.
01:09:50.530 - 01:11:05.540, Speaker A: All right. And then we need to actually call the precompile swab ethcall with and then input. So this is abi encoded bytes. So abi dot encode with actually gonna use encode with signature here. The signature string is balance of and then it's got an address that it takes. So just use standard Abi encoded function call here and the argument v for Vitalik's address. All right? And then that is going to return bytes.
01:11:05.540 - 01:12:07.150, Speaker A: So let's capture that and then we know the balance of contract. If we just run this example real quick, it returns the UN 256 and we should be getting something like 3644 when we're done. But yeah, we're getting bytes and we know it's a UN 256. So we're going to Abi decode that. There we go. Let's say raw balance. Alright.
01:12:07.150 - 01:13:15.710, Speaker A: And then yeah, once we have the actual balance number that we're looking for, Abi and code, we'll call this onset number with that balance and should trigger. Yeah, it should do all the same stuff. So then let's write a test for it. All right, I think that looks good. Let's run it. Oh, we're running the wrong test. Okay, so it reverted.
01:13:15.710 - 01:14:09.840, Speaker A: Let's figure out why. I was expecting it to revert, but I wanted to walk through what's going on. So basically what's going on here is let's lay out the shells so I can explain it. So here's suave geth, and here's suave execution geth. Suave execution geth is running on port a 555. And then, you know, this one's 8545, the standard port. But what's going on is when you send or when you call the, here it is, Eth call precompile, it's going to suave Geth.
01:14:09.840 - 01:15:39.220, Speaker A: And then the MevM in SwaV Geth will make a request to suave execution Geth or whatever, whatever is connected at this address, localhost 8555. Because remember, that's what if we look at the script I used to run suave Geth again, that is the address that we specified to use as the ETH provider. So swab execution Geth is getting this request and saying like, well, what is, what is this address? I've never seen this. I've never seen this. And it's because swab execution Geth isn't actually hooked up to main net and we're trying to get main net data. So if we wanted to use Mainnet data in our, in our test environment, we actually have to swap out swab execution Geth for an alternative solution, something that can fork Mainnet state and also offers the suavex endpoints that suave Geth relies on to interact with the execution node. So I have a project here that does this.
01:15:39.220 - 01:16:24.794, Speaker A: It's called Suavex Foundry. It's just a fork of anvil. It's a fork of foundry, the repository. But I've only changed Anvil. So the way we run this, I mean, I don't have a release process or anything for this yet. So you have to build it from source so you'll clone this repository, and if you're looking for that, it's in here, check that link and clone that repository. You want cargobuild bin Anvil, and I've already built it.
01:16:24.794 - 01:17:06.880, Speaker A: But then you run that, you probably don't even need to run build, you can just run, run. I digress. So you're running the anvil binary, and then we'll pass that dash. Dash to let it know that we're passing commands to Anvil and not cargo now. And then Anvil, it's going to need a port. So P 5555 or, whoops, sorry, 8555. It also be nice if we could replicate Haleski with this chain id.
01:17:06.880 - 01:17:53.200, Speaker A: This just makes it so that, you know, if you have, well, you know, the testnet itself right now is hooked up for Hleshki, so you probably, there's a good chance you're going to be writing your tests for Haleshki. So if you set the chain id like this, it just reduces the likelihood that you run into problems with, you know, eip 1559 transactions having chain id in them. You don't have to do this, but it can help sometimes. Okay, so port chain id and. Yeah, and then the fork URL. So RPC URL. I have this set in my shell already.
01:17:53.200 - 01:18:21.966, Speaker A: This is just like a alchemy node that's hooked up to Ethereum mainnet. Yeah, we'll run that. There's whatever, there's my URL. I'm going to have to cycle that, I guess, on stream, whatever. Go ahead and spam it. But yeah. So now Anvil Suavex, anvil is running and it's going to be our ETH provider.
01:18:21.966 - 01:18:57.626, Speaker A: So now if we run this test again, let's try it. Oh, still revert. Let's see. Oh, yeah. Okay, so let me stop Swavgeth here and show this. We stop suave geth and nothing changes. And that's because when we run a forged test, we're not relying on an already running Swavgeth instance, we're relying on the Swavgeth instance.
01:18:57.626 - 01:20:03.490, Speaker A: That foundry or that forge spins up, it's a separate instance. So if we want to, we basically have to pass the same, the same arguments that we do here, but to forge. So I have a good example that we can copy from. This is a project that Miha and I worked on, but it's got here, it's profile suave. This is what I want. So in our foundry, Toml, in our contracts environment, we'll add this profile suave. Section.
01:20:03.490 - 01:20:41.826, Speaker A: And we have the same sort of stuff here. Whitelist equals wildcard. I'm actually going to remove this service alias thing because it wasn't working for me last time. This just lets you like, define, I don't know, like basically like DNS style resolutions, but for whatever reason, it wasn't working for me last time I tried it. So I'm just gonna comment that out and just use this, use this value directly. So eth backend is equal to. And that's five.
01:20:41.826 - 01:21:18.880, Speaker A: Five. Okay, so now it knows to look to localhost 8555 for the eth back end when we run forge tests. So now let's run this again. Oh, there it goes. So now, just like we saw on Etherscan before, we're pulling this balance from ethel 13644. It should look exactly the same on Etherscan 3644. Yep, exactly the same.
01:21:18.880 - 01:22:01.080, Speaker A: So it is in fact going through suave hitting suavex anvil. And you can see that too. There's the suavex call which triggers EtH call internally. So, yeah, it's working. So, yeah, now, like, this is everything you need, essentially, to write fully featured smart contract tests in foundry forswave. I want to give a big shout out here to Firon because he wrote a lot of this stuff for forge. That.
01:22:01.080 - 01:22:50.100, Speaker A: Yeah, just makes it so much easier, this context swap suave, you know, he is responsible for mostly all that. So Varron, shout out to you, buddy. Okay, let me look back at the layout. I think we're almost out of content here. Alternative ETH providers. Yeah, so I hope that was clear how the ETH providers work. Maybe later on we could talk more about exactly why we need that and why we can't just use like, a default ETH provider.
01:22:50.100 - 01:23:48.670, Speaker A: The long and short of it is there's special endpoints specifically designed for suave. So ETH call and suavex call, they do the same thing, but they're just slightly different. And we have to implement those for a host of different things. So that's why we need this fork. But, yeah, we didn't talk a lot about context. Let me cover that real fast down here. Okay, so earlier on, right, earlier on, I switched this line here from suave confidentialinputs to context confidentialinputs.
01:23:48.670 - 01:24:31.104, Speaker A: So they provide the same data, but what's the difference? So, sanity check. Let me run my, I'm gonna run all the tests. Okay, so all the tests pass. Now let me switch this back to suave confidentialinputs and I'll run the test again. And they fail two passed, but one failed. Which one failed? Test counter. Right.
01:24:31.104 - 01:25:08.540, Speaker A: So the one where we actually pulled confidential inputs. That makes sense. So suave confidential inputs. Like if I, if I. Oh, I gotta spin up swab geth again. Alright, so if I deploy the contracts again and I get the address and I put it in the web app. Oh.
01:25:08.540 - 01:25:53.560, Speaker A: What? Oh, okay. Okay. Is this still running? Yeah. So new contract, D 59. So this will work, I think. Oh, gotta send myself some money. Yeah, so that works.
01:25:53.560 - 01:27:14.736, Speaker A: But in, let's just verify it worked. Yeah, but in forge, the suave context, like the suave, you know, wherever this data comes from, it doesn't exist in forge. But if we replace this with context, basically context replicates what suave does in the backend, but just in memory in the EVM testing environment. And if you use context here, it will still work just the same as suave. So if we deploy contracts, get the new address again. Oops, I did it again there. Add the web app contract address is CB something.
01:27:14.736 - 01:28:22.320, Speaker A: Yep. Success. Yeah, so it works the same, but context will also work in these forge tests. So, yeah, all context is doing, it's like proxying this context get so that, you know, if it's in solidity, it will. Or if it's in a forged test, it will pull from, you know, this the way that we set it here with. Oh, sorry, wrong file CTX setconfidential inputs. Context will read it from there or from the precompile, whereas suave will only read it from the precompile.
01:28:22.320 - 01:29:22.210, Speaker A: So yeah, context is what's going to unblock you for forged tests in a lot of cases. Well, in the case that you need confidential inputs. Oh, and there was one more thing. Emit off chain logs. So this one's pretty cool because like, say you have a function that has like a huge, I don't know, it needs to do a lot of stuff. Like say this is your callback and, well, let's just make up a function to demonstrate this, like, function. Do lots of stuff.
01:29:22.210 - 01:30:33.548, Speaker A: All right, let's say, I don't know. I'm not going to do any like fancy stuff. I'm just going to make stuff up. Oops. Okay, so we've got all these numbers that, you know, imagine they're important and like say we want to save them all to state or we want to emit them all as logs. Like we wouldn't want to have to, you know, add like five parameters or whatever this is. And like, what if this grows? Like, either have to add more parameters or, you know, we would have to add a struct with all this stuff.
01:30:33.548 - 01:32:17.350, Speaker A: But like, you know, even then, not ideal because then we got to build the struct and pass it into here. Like we don't want to do that. So instead of passing everything through the arguments to the callback, if we know that we just want to emit these as logs. Okay. If you want to use these values as arguments for state changes, you still have to pass them via parameters. But if you just want to emit them as events, then you can just emit them here. Like you could do that and then you don't have to do anything here basically because, well, you know, as long as we do this, as long as we call, like as long as we return the call data to undo stuff and undo stuff has emit off chain logs, then all these logs, they will be logged.
01:32:17.350 - 01:33:02.620, Speaker A: Before this off chain logs, you would have to pass all these as arguments. And then I, these logs, they would have been here now. Yeah. If you just want to log these, you can log them all here. And then if you have something like, you know, one thing has to change with the state then, then you could just pass that like that. And so you can just, yeah. Drastically reduce the complexity of this call data that you're returning, which is always good.
01:33:02.620 - 01:33:29.938, Speaker A: And it makes the code a little bit nicer to read too when you don't have to pass all these different things in. Yeah. So that's that. Now all that does is clean things up a bit. Um, yeah, that's done. That's done. That's done.
01:33:29.938 - 01:34:02.200, Speaker A: That's done. Yeah. We didn't, we didn't figure out how to send ccrs. So if you're not, if you're not bored, I'm gonna try that now. Yeah, I'll leave that there. Why not? Let's write a test for that too. Let's see if it works.
01:34:02.200 - 01:34:30.944, Speaker A: This copilot's pretty good at writing tests. Yep. Do lots of stuff. Fantastic. And yeah, also. Oh, that's strange. Oh no, it's fine.
01:34:30.944 - 01:35:17.464, Speaker A: They're all 42. Yep, it works. Okay. All right. Let me push all these changes. What do we do? New tests, new functions in the contract. Okay.
01:35:17.464 - 01:36:46.040, Speaker A: Now the code is pushed. All right. I'm going to figure out this suave geth spell thing. I just gotta find it. Oh, okay, one sec. Spell CMD. Here we go.
01:36:46.040 - 01:38:24.394, Speaker A: Conf. Request, contract, address, method signature, call data. Seems like I was doing it right. I don't get it. Alright, you know, I'll figure this out and I will write a tweet about it because this is going to bug me. But, yeah, that's all the content that I've got for y'all today. Thanks, everyone.
01:38:24.394 - 01:38:44.662, Speaker A: Who tuned in? I am just now seeing the chat messages, so sorry I didn't get to those, but thank you. Thank you for the code suggestion. I'll try that out. Yeah, that's all we got. Thanks, everyone. Bye.
