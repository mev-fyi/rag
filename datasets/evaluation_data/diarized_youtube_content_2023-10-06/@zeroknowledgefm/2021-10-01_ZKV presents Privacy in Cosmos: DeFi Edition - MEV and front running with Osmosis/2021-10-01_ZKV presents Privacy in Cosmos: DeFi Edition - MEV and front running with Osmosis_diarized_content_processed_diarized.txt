00:00:00.330 - 00:00:24.400, Speaker A: Thank you guys. Thank you guys for hosting this. Yeah. So this is part of a so this is like a talk I've given a couple of times before. And it's much longer, but I'm going to kind of keep this one a bit shorter. So we can get to the panel, because I think that's much more interesting. So also, I'm feeling a little bit under the weather, so my voice might be a little bit gone, but we'll work through this.
00:00:24.400 - 00:01:13.330, Speaker A: Okay, so what we're going to talk about today is minimizing mev through privacy in the mempool. And so in osmosis, we're focused on actually a lot of privacy stuff. Part of the original reason we started working on osmosis. Was to build a privacy focused dex. And when exploring different use cases of what do people actually care about privacy, the number one thing that we came across is the biggest problem that people are facing right now was this mev problem and front running. So what we'll do is basically talk a little bit about what mev is and then some of the solutions that osmosis is working on on solving it. So let's just get one thing out of the way before we start, which is we keep saying mev, and it means stands for minor extractable value.
00:01:13.330 - 00:02:02.606, Speaker A: But what we really mean is proposer extractable value. Because, of course, we are using proof of stake tendermint, and there's no miners, but still there's still someone proposing a block, and they have certain powers. And so that's really how you have to think about mev. Our proposal attract we're going to stick with the mev term. Because it's just the standardized term at this point. But what powers does a proposer uniquely have that gives them some sort of edge? And how can they extract value by using it? So what are things that proposers can single handedly do? So one thing they can do is mess with the timestamps of a block proposal, right? But we have solutions for this in tendermint. We have BFP time, which takes the median of every validator's timestamp.
00:02:02.606 - 00:02:45.330, Speaker A: So while this might be an issue in many chains, in tendermint, this isn't really an issue because we already kind of solved this. Another thing you could do is do consensus vote censorship in proof of stake in tendermint. This would come in the sense of me censoring other validators votes, only accepting the minimum two thirds I need in proof of work. It takes the form of something called selfish mining, but this is sort of something a proposer can single handedly do. You can read transactions from the mempool. So currently, today, everyone can usually read transactions in the mempool. Because the traditional way of broadcasting transactions, everything gets broadcast.
00:02:45.330 - 00:03:28.910, Speaker A: But we see the rise of private mem pools today. And things like ethereum, where transaction creators will go ahead and directly send their transactions to mining pools who add them into blocks. But at the end of the day, the proposer kind of has to be able to see the transactions in their Mempool before they can add them. The other thing they can do is control inclusion of transactions in the block proposal. They can choose from the Mempool what they want to include and they can choose the order of transactions in the block proposal. So what we're going to do is go ahead and focus in on the three that have to do with transactions. There's solutions.
00:03:28.910 - 00:04:01.100, Speaker A: Some of these things. Other Mev attacks have simple solutions, some of them have more complicated solutions. But we're going to focus in on the transaction based ones. We'll call this transaction based manipulations. So broadly you can classify these into two different categories, which is censorship, manipulations and ordering manipulations. And within ordering manipulations, we have what we call front running. So what is front running? You've probably heard this term before.
00:04:01.100 - 00:04:53.674, Speaker A: It's a term that exists in traditional finance as well. It's not like a crypto specific thing. In traditional finance, what would happen is imagine you wanted to buy a million shares of some company on the New York Stock Exchange. You send this order to your broker and what they could do is basically front run you by using knowledge of this information to purchase the shares themselves before you giving you worse pricing and then execute your trade afterwards and getting a profit. And this is how Robinhood makes all of its money. And then in the blockchain it's not very different. What will happen is Alice will go ahead and send the transaction to the block proposer and Bob will go ahead and send it.
00:04:53.674 - 00:05:52.522, Speaker A: And what will happen is the block proposer, in this case it'll be the sikka validator. They can see the transactions and the block proposer can choose to put their transaction in front of everyone else's so they can profit off of this. And it's the fact that they can read what's in the Mempool that gives them the ability to do this. You also have something called Dark Forest Attacks, which know the name comes from the blog post from Dan and Georgia who will be on in a couple of minutes in the panel. But basically it's not so much about reading someone else's transaction and front running it, but rather just making sure you're always the it's not about being relatively ordered to their transaction. So in normal front running you still need to make sure that the person who you're front running, they get their transaction on chain. So you could be in front of them in a Dark Force attack.
00:05:52.522 - 00:06:43.066, Speaker A: It doesn't really matter whether they get their transaction on chain or not. Really what it is, is that you're copying their transaction itself. So for example, if there's some sort of on chain puzzle, a puzzle could be more in depth. It could be like an arbitrage opportunity or something like that, but some sort of puzzle that can earn you money. What could happen is Alice could be really smart and have a lot of work in figuring out the solution to this puzzle, and she can go ahead and send her transaction to the mempool. But what will happen is the block proposer could be like, oh, wow, wait, that's a cool solution. They can just copy the solution into their own transaction and create a block and make sure their solution goes before Alice's.
00:06:43.066 - 00:07:37.040, Speaker A: So this is different where you're not sort of front running, but rather you're copying someone else's transaction. The distinction is useful just because it helps on different types of some solutions only work on dark force attacks or only on normal front running. But the solution that we're going to present here actually works on both of these at the same time because both of these rely on the same power, which is the ability to read transactions from the mempool. So how do we solve this problem? How do we make it so people can't the block bros can't read transactions from the Mempool. And this is where it all comes together, where why privacy is important here. What we have is the solution here is encrypted transactions. So we want to make sure everything in the mem, all the transactions in the mempool are encrypted in a way that the block proposer cannot read.
00:07:37.040 - 00:08:08.818, Speaker A: You know, at the high level. What is the ideal. We want a world where Alice sends her transaction to the block proposer. The block proposer has a mempool, and they know that there's a transaction there, but they just can't read what the transaction. So, you know, all the transactions should be encrypted. And then the block proposer will create a block with the encrypted transactions. The validators will come to consensus and commit lock on a block with an ordering of encrypted transactions.
00:08:08.818 - 00:09:04.410, Speaker A: And then there will be some sort of magic that happens that lets the transactions be decrypted, and then they can be executed. And the beauty is, because we're using a finality based consensus protocol like tendermint, we don't run into any situation where the block can't be reverted once the transactions are decrypted. Once the transactions are decrypted, the ordering is known, and they will be executed in that order. Cool. So this is really nice. But the question is there's many ways we can make this magic happen. What is the magic that's happening here? So, essentially from our research, we basically identified three main feasible methods of doing this decryption magic, which are trusted hardware, time lock encryption, and threshold encryption.
00:09:04.410 - 00:10:17.262, Speaker A: What we'll do here is I'll give a brief summary of all three of them and sort of some of the trade offs between all of them. So starting off with trusted hardware. So, trusted hardware, how it basically works is you have these encrypted transactions and you're committed. And then the CEO of intel comes in and performs some sort of dark magic that decrypts the transactions and executes them because no one actually knows how Intel SGXs work. I don't think intel actually knows how Intel SGXs work, but what it really means is that the Intel SGX is a piece of trusted hardware where basically intel basically has a private key inside of a trusted enclave in the CPU that claims to be tamper resistant in such a way that you can send messages. And here what we would do is we'd have it. So all Validators would have a private decryption key that is sent to their SGX enclave, so it's encrypted to the key in their enclave.
00:10:17.262 - 00:11:49.662, Speaker A: So now all the Validators will have the same private key decryption key in their SGX enclave that in theory they should not be able to access because of magic trusted hardware rules. And then what's nice then is so once the block is committed, then the block will be sent to the validator's trusted enclaves which will then use the key to decrypt the transactions and then execute them. I'll skip this because we're all using Henderman here, because this is a Cosmos event, so don't care about how it works in proof of work, but what are the pros here? There's a lot of pros on using this. One thing is it's nice is that can be used as an opt in feature where individual block proposers or individual in the proof of work case, individual mining pools can choose to offer this as an opt in feature. Which is sort of from my understanding this is the long term goal of the flashbox Project is provide this as an opt in feature. But however the cons of this are there's not a really great security trade off because as I mentioned, for one you have a built in trust assumption on intel that they're producing this trusted hardware in a proper way and they're not. Like if you compromise intel as a company, it's very easy to break this because intel gets to decide and claim what is a valid SGX or not.
00:11:49.662 - 00:12:57.782, Speaker A: And so they can just make a fake SGX and then say yes, this is a real SGX and then being able to sort of break all the security model here. But not only do you have to trust an intel, you also have to trust not only you have to trust that they're not malicious, we also have to trust their competency. And so the SGX doesn't have a super great economic security trade off. Right? So every couple of months at this point you basically see new papers that show you there's a new vulnerability in SGXs that are released every couple of months. And so if you wanted to break an SGX you could probably get a team of like ten of the top notch best researchers, pay them for six months and you'll probably find some exploit in the SGX that will allow you to break it. And how much will that cost? $10 million, $20 million, maybe. But if the value of breaking the SGX to extract mev, the mev market on Ethereum today is much bigger than $10 million.
00:12:57.782 - 00:13:55.574, Speaker A: Right? And so it's economically rational for someone to break the SGX in order to be able to extract the mev. So that's why this doesn't really act as a great solution for what we're trying to do here. So on the trade offs, okay, the pros, there's very little execution delay. It doesn't have a big impact. It's pretty good across the board, minus the actual security guarantees it gives you. Okay, the next solution we have is called timelock encryption. Time lock encryption is a cool encryption technique where what it does is you can have an encrypted thing and it's parameterizable, but you can basically say there's some fixed amount of we can call it, for simplicity of understanding, some amount of proof of work that needs to be done on this encrypted data.
00:13:55.574 - 00:14:58.182, Speaker A: And then once that amount of time has elapsed, a certain amount of work has been done on it, it then is able to open up the encrypted data and it is now readable. So how you would use this to create a mempool privacy solution is you'd go ahead and Alice would send her transaction to the mempool of the Validator. The validators will create the encrypted block with all the encrypted transactions in it. And what would happen here is on the side, once the block is created, the validators will begin decrypting Alice's transaction. In the meanwhile, they'll go ahead and keep making more blocks, and then once the time has lapsed for the decryption process, then they'll be able to realize Alice's decrypted data. They'll include that in the next block. And this is when Alice's transaction will actually be executed.
00:14:58.182 - 00:16:31.130, Speaker A: So there's a sort of a long delay, multi block delay between the time of a transaction being included and the time that it's actually able to be executed. And so this actually is one of the main cons of time locking crypto, where it has this notable delay on transaction execution, which isn't the greatest UX experience. The thing is, like I mentioned, the time lock length is parameterizable, but you can't make it be too short because let's say we had the time lock period be only in the order of a few seconds or even under a minute. What's important to happen is that the decryption process doesn't have to wait until the transaction is included in the block. The decryption can actually start as soon as the validator has the transaction in their mempool. And so if they can prevent a transaction from if they can decrypt the transaction fast enough outside themselves before that encrypted version is actually included in a block, they can actually then go ahead and put their own transaction in a block to front run it. So you need to make sure that the time lock is sufficiently long such that there's high guarantees that all transactions will make it into the blockchain before they can be decrypted out of band.
00:16:31.130 - 00:17:06.630, Speaker A: Sorry, 1 second. Sorry. My friend left his phone in the room and it went off. Okay, cool. Then another con, which I'm not going to go into due to time, but it's not an opt in feature. This has to be a built in protocol thing. And basically every single transaction needs to use this time lock feature.
00:17:06.630 - 00:18:00.806, Speaker A: You can't be like, oh, some transactions want to use it and some transactions don't. Because if you allowed some transactions to not use the time lock, then you could still effectively front run. So every transaction, all users have to be subject to this execution delay, and it provides some protection against the dark forest style transactions. So this is the same thing about like, if you can keep it out of the blockchain for long enough and decrypt it, then it doesn't work. Okay, here's the trade off summaries medium security. It's parameterizable. The longer you make the UX delay, the higher security guarantees you'll get high execution delay, very little impact on consensus, and it's not opt in.
00:18:00.806 - 00:18:45.890, Speaker A: So that's where we are on the trade offs there. And then finally we'll talk about Threshold Encryption. So Threshold Encryption, to understand it, one of the things that makes it a little bit special is unlike the other two solutions which do work on Nakamoto Consensus or Proof of Work style chains, threshold Encryption does sort of assume some sort of BFT Consensus protocol. And here's why. So what is normal BFT consensus like tendermint, so what will happen is you'll have a bunch of validators, they have a copy of the block of the block proposal, and then they all take their votes. They send them to the next block proposer. And that block proposer, once they have enough transactions, that turns it into a committed block.
00:18:45.890 - 00:19:37.010, Speaker A: What Threshold Decryption does is what we'll have is basically what Threshold Encryption is, is the validators come together to create a shared decryption key. And that decryption key will have some limit of how many decryption shares you need to be able to decrypt the data that's encrypted to that key. And so what you'd normally do is you'd parameterize it. So it's the same as the consensus threshold. So in Tendermint, we have a two thirds consensus threshold. What we do is we make it so that you need two thirds of decryption shares in order to decrypt the transactions in the block. And what this does is this allows us to basically every validator, along with their consensus vote, they'll package their decryption shares with their consensus vote.
00:19:37.010 - 00:20:33.510, Speaker A: And so when they send their consensus votes to the next block proposer, they'll also go ahead and send their decryption share. And this basically causes it. So using the votes, that allows them to lock on the block, and then there's also have enough decryption shares that then they can go ahead and decrypt and then execute. And what's nice is this means that Threshold encryption happens atomically with consensus itself. So you can't get into a situation where a block can be committed and not decryptable. And more importantly, unlike time lock, assuming the incentive mechanisms are working correctly. But you'll never have a situation where a transaction is decryptable without being in a block because validators will only share decryption shares.
00:20:33.510 - 00:21:19.698, Speaker A: The transaction will only be decryptable if they're in a valid block. And so this prevents the time lock crypto situation where transactions are decryptable as soon as they're in the mem pool. So the benefits here are they have a basically close to equivalent security as consensus. There's some slight things that you have to deal with, but for the most part you can treat it as essentially equivalent. There's very little execution delay. Basically what will happen is unlike Ethereum, which executes in the same block that transactions are included, execution will have to happen in the next block rather than in the same block. But that's okay because we actually already do this in Tendermint.
00:21:19.698 - 00:22:25.586, Speaker A: Tendermint already has execution off by one and so it actually has no change to what we already do in Tendermint. It does have a little bit higher impact on the bandwidth because these decryption shares are the amount of data that's being shared is linear with the number of transactions in a block. And so that's one con and it does require a classical BFP consensus. But once again, that shouldn't be an issue because I assume everyone here is using Tendermint already and there's some cool stuff that we have to stall with making it work. There's edge cases that you have to deal with around gas and we can talk about the solution if you're interested, you can talk to us offline about it. I'm going to skip. Obviously, given these trade offs Osmosis, what we've been working on for the last almost a year at this point is basically working on this Threshold encryption solution because we've come to the conclusion that this actually gives us the on the trade offs.
00:22:25.586 - 00:22:53.058, Speaker A: This is probably gives us the best bang for our buck. And so this is sort of what we're working on implementing as an extension to the Tenderman core software and it'll be available on the Osmosis chain and then all these other sorts of mev stuff that it's not really related to privacy. There's sort of other solutions for solving these which we're not going to go into today. And we'll go ahead and jump into the panel.
00:22:53.154 - 00:23:05.930, Speaker B: Cool. Yo, thanks so much. I'm so glad that we got a chance to hear this talk. I'm just going to ask Giorgio's to jump on so that we can actually do a short conversation.
00:23:06.590 - 00:23:09.962, Speaker A: I think he's slide. You like me to keep on the screen?
00:23:10.096 - 00:23:15.050, Speaker B: I don't know, maybe the where's Giorgio's? Hey, Giorgio's.
00:23:15.790 - 00:23:17.310, Speaker C: Hello. Is this thing on?
00:23:17.380 - 00:23:18.366, Speaker B: You're on.
00:23:18.548 - 00:23:21.502, Speaker C: All right. Great. How's it going?
00:23:21.636 - 00:23:58.140, Speaker B: Oh, good. I don't actually I think the trade off summary might be interesting. So, yeah, I want to basically kick off this little discussion after the fact. I know there's a lot of conversation happening in the chat. Dave Sunny's co founder, is in there. So hopefully helping to field some of these questions. I know with this chat, what we wanted to do is kind of like explore, after hearing Sunny's talk, explore a little bit more the larger context of mev and also in the context of cross chain stuff, in the context of Cosmos itself.
00:23:58.140 - 00:24:07.360, Speaker B: I had sort of a question. Well, actually, Giorgios, do you want to maybe just introduce who you are? Because I know that maybe the audience isn't entirely familiar with you.
00:24:08.530 - 00:24:08.942, Speaker A: Sure.
00:24:08.996 - 00:24:45.542, Speaker C: So. Hi, I'm Georgius. I work with paradigm. Paradigm is a venture capital firm. I'm a research partner, which means that I do engineering on stuff that involves companies that we invest in, research on open source stuff that I find interesting and I think is useful for the industry and on the investment process because we look at a lot of projects and it's important to have people that know their technical stuff when evaluating investment opportunities. Before that, I did engineering audits and other cool stuff on the Ethereum ecosystem. And before that, I studied electrical engineering.
00:24:45.686 - 00:24:46.282, Speaker B: Cool.
00:24:46.416 - 00:24:47.850, Speaker C: So thank you for having me.
00:24:47.920 - 00:25:12.580, Speaker B: Yeah, so I wanted to as a first sort of kickoff question that I had is, does this topic even matter in the context of proof of stake and on Tendermint? Because I always got the impression that this was very much like a proof of work problem. So I'd like to hear maybe from either of you, maybe, I don't know, Georgia, if you want to take this one.
00:25:13.990 - 00:26:22.470, Speaker C: So mev is not dependent on the work or on the stake. It's dependent on, as Sunny said, what are the powers of the proposer and on the finality conditions of the chain? So in tendermint, you have instant finality or in BFT algorithms where once a block has been mined or confirmed, it's final, and there's no way to do any chain reorganizations. But this comes at the trade off of liveness in tournament. When one third of the stake is dead, the chain is also dead. Whereas in proof of work or in like a motor consensus, you have this whole concept of reorgs, which means that when a block is confirmed, it's not final. And if more blocks arrive that have an alternative history and they have more work, maybe they can cause a reorg, which means that the current blocks that you're following, they get discarded and you change over to the other chain. Why this matters is that because, firstly, mev that gets exposed basically is the same in both proof of work and proof of stake.
00:26:22.470 - 00:27:05.800, Speaker C: But in the proof of stake context, typically you have more finality compared to proof of work, which means that these sort of mev attacks that depend on reorgs are more unlikely to happen. So in bitcoin or in ethereum, you can reorg any amount of blocks. If you have enough stake, if you have enough hash power. In Tendermint, you cannot do any reorgs to extract mev. In ethereum two, you can do reorgs up to twelve minutes or two epochs in the task. So there is some mev which can be exposed via reorgs, but it's more limited. And the mev exposed via reorgs, we typically call it the time bandit attack.
00:27:06.250 - 00:27:22.978, Speaker A: Yeah. So Tendermint, I guess, removes that as a proposer power. So in a proof of work, one of the powers of a proposer is choose what block to build on top of that's not a power that you have consensus.
00:27:23.174 - 00:28:03.702, Speaker C: Something to add though, is that while in tendermint you cannot extract mev as a block proposer during the reorgs. With reorgs, what you can do is that you can cause timeouts in other parts of the protocol. So in Tendermint, how the protocol works is that two thirds of the stake, they gossip around a bunch of messages, and when they have all signed on two thirds of the messages, a new block is produced. But if mev exists, potentially, and somebody other than you is proposing, you could maybe refuse to sign on the block, maybe taking on some liveness slashing. But that's plausibly.
00:28:03.766 - 00:28:04.042, Speaker A: Fine.
00:28:04.096 - 00:28:36.980, Speaker C: Because you prevent the other person from producing the block. And then maybe you get elected as the follow on block producer after that person, and you can propose a block that gives you more mev than what you paid in slashing. So in a know phil, Diane said this a few weeks ago, but I wonder there might be some sort of preservance of mev or you cannot just remove mev. Mev always exists and just moves around layers depending on the protocol that you're using.
00:28:37.450 - 00:28:38.200, Speaker B: Okay.
00:28:39.290 - 00:28:43.960, Speaker C: The theorem of conservation of mev, similarly to how we say conservation of energy.
00:28:46.410 - 00:29:17.600, Speaker B: Sonny, in your talk you were primarily looking at different kinds of privacy techniques to minimize and maybe it doesn't get rid of it completely, but minimize as much as possible mev. But I know that there's been strategies that are more to democratize mev. And I feel like I don't know if you both agree on which strategy is best here, but I thought that would be useful to talk about. Sonny, why don't you kind of brief the audience on what that conflict really.
00:29:18.610 - 00:30:16.798, Speaker A: I mean, I think this does have to do with the whole, like okay, let me just pull that up really quickly. Okay. So I have this taxonomy of mev manipulations. I avoid the word attack because I use the word manipulation on purpose, because I think there's a fair argument to be said, which is like, some of these, I think, are more malicious than others. And the ones that the area that I'm most focused on is just things that are based on other people's transactions. And when you're front running someone, it's basically you're taking knowledge of their transaction and using it to front run them. And I consider that an immoral breach of privacy that needs to be fixed.
00:30:16.798 - 00:31:03.010, Speaker A: Now, another source of mev could be like, on chain liquidations, right? Having someone doing on chain liquidations is good, and you want to make sure that whoever's doing them is properly incentivized to do them. And if that's a source of mev, that's not breaking anyone's privacy, because it's not based off of anyone else's transactions. Right. It's based off of on chain state that is freely accessible to everyone. In those cases, I think democratization makes sense, but when it comes to things that are based off of other people's transactions and private intentions, I think that's where you need to focus on minimization.
00:31:04.950 - 00:31:37.890, Speaker C: I agree with that. I also want to say that we start with minimizing wherever we can without gutting the protocol. So in Sanny's case, one block delay might be an acceptable UX trade off. If it was ten blocks delay to be secure, maybe the protocol is garbage and we cannot minimize the mev. So we need to figure out some other way. So minimize what you can, and then just make extraction as open as possible. Minimize, then demogradize.
00:31:37.990 - 00:31:59.060, Speaker B: Got it. I want to bring this to sort of the cross chain world. Mev. In a cross chain world, does it matter? And I'm obviously talking the Cosmos sense, so maybe over IBC, how do mev issues from various chains actually interact? Is this something you're thinking about?
00:31:59.590 - 00:33:09.734, Speaker A: Yeah, so this is something we've thought about briefly. It's not like super well fleshed out yet, but essentially what we'd want to be able to do is, okay, so the solution that we presented here is, how do we do mempool privacy on a single chain? But really what we'd want to do as well is actually have cross chain threshold encryption. And what that means is having wrapped threshold encryption, where imagine, essentially, I think, the big focus of the Cosmos ecosystem for the next year, what I tweeted a couple of weeks ago was, like, everyone else is thinking about cross chain communication now. We've been thinking about it for years. We've already built it and shipped it, and we're thinking about cross chain composability now. And I think what we're going to be focusing on a lot on is how do you make seamless user interactions that take place on multiple chains at the same time? I want to go do a swap on this chain, and then it'll automatically transfer. Pass my tokens on to another chain, and it'll do some other interaction on that chain.
00:33:09.734 - 00:33:55.674, Speaker A: Right. Well, the question is, once the entire transaction is decrypted on chain A, you can front run the part that's about to happen on chain B. Right. And so how do you prevent that? Well. One solution is this wrapped threshold encryption, where you have only the part that needs to be executed, the part of the data that needs to be available to execute the transaction on chain A that can be decrypted on chain A, and the rest of it can remain encrypted until it hits chain B. And once it's committed on chain B, the IBC transaction is relayed to chain B. Then the rest of the transaction is decrypted and executed on chain B.
00:33:55.674 - 00:35:02.734, Speaker A: Now, this works except for the fact that it works at a very pure level, but if there's situations where you can infer the action that's about to happen on chain B by looking at what's happening on chain A, then it's like we don't really have a great solution for that. And what I mean by that as an example is like, imagine I was going to okay, yeah. So imagine I was like, there's a leverage loop going on, right, where you have a borrowing protocol on one chain, and then you have a AMM protocol on another chain. And you know, that's a very common user action that they'll the first thing they do is go borrow some assets and then they take them to the AMM and trade them, right? So if you see that on chain A, a bunch of this asset was just borrowed, you can probably predict that it has something going to chain B. You don't know what that is yet because encrypted, but you can probably assume it's going to go sell that asset on chain B, right? And so you can still front run them there. And so how do you solve these? Like, I don't know. I don't know if there's a good term for them yet.
00:35:02.734 - 00:35:10.500, Speaker A: Maybe like side channel attacks, but I don't know if we have a really great solution for that yet.
00:35:11.830 - 00:35:42.230, Speaker C: Basically, you're leaking information by just doing some action. It doesn't matter what the action is. You're just leaking information about what will happen because all the possible actions that can happen contingent on the first action are limited. Right? So what you had on your previous slide, the blind front running part, it's a bit less blind. Effectively, you're guided by what gets opened on the remote chain. So, yeah, I agree with that. Also, it will be very important to find out who is running the relays.
00:35:42.230 - 00:36:40.446, Speaker C: So in Cosmos, very specifically, basically what happens is that there's the relayers that pass on hashes of the chain headers from one chain to another. And that is free because we're in Cosmos and that's part of the protocol. But there's also the relayer entity, which basically takes transactions from one place and proves that they happened on the other place. And basically the relayer could say, I forgot to relay a transaction because I wanted to insert my transaction first. So it will be important to figure out ways to mitigate or democratize or figure out how to combat relayer extractable value. And obviously in a cross chain world, Charlie Noyes, like my co worker from Paradem had know, mev suffers from the cares of dimensionality. Or rather it grows super linearly to how many chains you have.
00:36:40.446 - 00:37:02.840, Speaker C: So the more the chains, the mev grows even more than that. So in a multi chain world, this is even more important. And we've only talked about cross chain mev in instant finality days chains. Imagine what happens when you want to reorg like this chain because you want to cancel an action that happened on this other chain. Or.
00:37:07.210 - 00:37:27.870, Speaker B: Do you, do you think that there's going to be a standard solution for the proposal that you made, Sonny? Do you see that as potentially becoming a standard for different zones? Like they would all adopt this technique of MEB? Or do you think that we're going to see a lot of different techniques, maybe just start a lot of different techniques?
00:37:28.530 - 00:38:03.750, Speaker A: Yeah, I'm hoping that the Threshold Encryption solution will become the standard. I think realistically, with all the trade offs that were presented, I think the only reason you wouldn't use Threshold Encryption is if you didn't want to use a classical BFT consensus protocol. But given that everyone in Cosmos is already using Tendermint, I think Threshold Encryption is a no brainer. And then yeah, having this multi chain wrapped Threshold Encryption, I think that will have to become like an ICS standard, interchange standard that all these chains will adopt.
00:38:03.830 - 00:38:04.746, Speaker B: Got it.
00:38:04.928 - 00:38:06.202, Speaker A: So I agree with that.
00:38:06.256 - 00:39:06.622, Speaker C: Just to give an extra point to kind of push back on your slide from earlier on, SGX, basically, we cannot rely on SGX for safety related properties. So Avalanche for example, uses like ZATI just told me in the end. So thank you ZATI, for the info. Avalanche, for example, uses SGX for the bridge security. And that obviously can end up very badly if the SGX enslave is compromised. But in the case of for example, and maybe in a Dex, this is also tragic because trades just start getting front run uncontrollably. But for example, in the Democratization or the concept, flaskbots has been using SGX on top of the Miner software that they've been building, which effectively restricts the Miners power x compared to what they already have.
00:39:06.622 - 00:39:35.446, Speaker C: So instead of submitting a bunch of transactions which by default the Miner can unbundle or reorder in whatever order they want, and there's a social contract, you just use SGX to remove the need for the social contract, for the reputation. And the worst case fallback is reputation. And as Kobe writes in the chat, it's basically defense in depth. It's not a requirement in your system.
00:39:35.628 - 00:39:49.100, Speaker A: Is it not worse though, if people so, okay, imagine like a minor, it's worth it to break the SGX, they have the solution to break the SGX. Isn't it worse for people to assume that the SGX is providing security?
00:39:50.430 - 00:39:56.640, Speaker C: But there is reputation, so it is observable. The moment the miner tries to screw up with things, you just pick them off your system.
00:39:58.130 - 00:40:12.340, Speaker B: I'm sorry. To this right when there was a fight. So yeah. Sonny, do you have, like, one last point to say? Maybe, and then we'll move on?
00:40:13.190 - 00:40:43.302, Speaker A: My point was just know, I feel that when people start adding SGXs in, they become less aware of the reputation of their counterparties because they're like, oh, it's okay, they have an SGX. I don't have to worry about their trustworthiness. Then once that SGX breaks, I think then a lot of the social yeah. People stop relying on trustworthiness when they assume that there's SGX in play. And once the SGX breaks, things can get messy.
00:40:43.446 - 00:40:48.150, Speaker B: Cool. Thanks, everybody. That was a great panel.
