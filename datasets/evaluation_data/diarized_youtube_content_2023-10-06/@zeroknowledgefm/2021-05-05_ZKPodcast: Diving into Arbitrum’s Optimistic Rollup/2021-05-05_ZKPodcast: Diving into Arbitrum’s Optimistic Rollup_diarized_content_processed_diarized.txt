00:00:05.450 - 00:00:43.258, Speaker A: Welcome to Zero Knowledge. I'm your host, Anna Rose. In this podcast, we will be exploring the latest in zero knowledge research and the decentralized web, as well as new paradigms that promise to change the way we interact and transact online. Today, James and I chat with Stephen Goldseder and Ed Felton from Arbitrum. We dig deeper into the topic of optimistic roll ups. We learn about the history of the project and what makes it unique in the ecosystem. But before we start in, I want to tell you about the ZK Jobs board.
00:00:43.258 - 00:01:16.334, Speaker A: A few weeks ago I held something called a ZK Jobs fair, which was an awesome way for job seekers to connect with the best teams working on ZK topics. We did this on a gather town hangout. It was very social. It was very fun. Now, as part of the job fair, I also put together the ZK Jobs board, which is a list of all these available jobs in the zero knowledge space. There are jobs in software development, specifically in rust, as well as applied cryptography and research jobs. There are also a couple community and biz dev positions.
00:01:16.334 - 00:01:54.514, Speaker A: Now, I've added the link in the show notes. You should be sure to check it out if you're currently looking for a new opportunity. And also keep your eyes open for the next ZK Jobs fair, it would be super cool to see you there. I also want to take the time to thank this week's sponsor, Ave. Ave is an open source, decentralized, non custodial liquidity protocol on Ethereum. With Ave, users can participate as depositors, meaning they provide liquidity to earn a passive income. They can also act as borrowers to borrow in an overcollateralized way or an undercollateralized way.
00:01:54.514 - 00:02:41.050, Speaker A: Think one block liquidity flash loans given that we are currently doing a series of l two focused episodes, it makes sense to mention that Ave has also deployed a new market on polygon sidechain. This lets users pay much lower gas fees. Assets can be transferred from Ethereum with the Polygon Bridge and put to use on Ave's polygon markets. To learn about it, check out the blog post that I've added in the show notes and also visit the project@ave.com so thank you again, Ave, for supporting the podcast. Now here is our interview with Ed and Steven. So today James and I are chatting with Stephen Goldfeather and Ed Felton from Arbitrum.
00:02:41.050 - 00:02:42.286, Speaker A: Welcome to the show guys.
00:02:42.388 - 00:02:43.470, Speaker B: Thanks for having us.
00:02:43.540 - 00:02:45.106, Speaker C: Thanks for having us.
00:02:45.208 - 00:02:46.158, Speaker A: And hi James.
00:02:46.254 - 00:02:48.322, Speaker D: Hi Anna. It's good to be here again.
00:02:48.456 - 00:02:58.422, Speaker A: So this is like I think this is the fourth episode in a series of episodes that we seem to be doing on roll ups over the last little while.
00:02:58.556 - 00:03:00.690, Speaker D: Kind of an accidental series.
00:03:00.850 - 00:03:25.654, Speaker A: Totally. I mean, I think about a month ago, I did something called mapping the l two landscape as an event, as a ZK session. Since then, I feel like this topic has become extremely relevant for the show. So, yeah, I think with today's episode, we're going to be looking at Arbitrum, which is another roll up, I guess it falls into, and correct me if I'm wrong here, but, like, more in the optimistic roll up side of things.
00:03:25.792 - 00:03:26.478, Speaker C: That's correct.
00:03:26.564 - 00:03:36.882, Speaker A: But before we start in on all this, I actually am really excited to have the two of you on the show. It's the first time we meet, and I would love to hear kind of what your path to arbitrum is.
00:03:37.016 - 00:04:08.554, Speaker B: Sure. I guess I'll go first. Since I was there at the very beginning of Proto Arbitrum, it goes back to, actually, to 2014. At that time, I was teaching a course at Princeton, or I was helping teach a course at Princeton about blockchain cryptocurrency technology. And one of the topics we covered was smart contracts. So it seemed pretty clear to a bunch of us that scaling was going to be a big issue for smart contracts. And so we started thinking about what we could do about it.
00:04:08.554 - 00:04:30.114, Speaker B: And long story short, in the fall of 2014, a group of students in this Princeton course did a joint course project building a very early version of Arbitram. It was called Arbitrum. You can go on YouTube, actually, and watch their course presentation, and it's obviously student work, but you can see, really the germ of the ideas from the product there.
00:04:30.232 - 00:04:30.658, Speaker A: Wow.
00:04:30.744 - 00:05:05.966, Speaker B: So that happened. And a bit more research on the topic. And then in 2015, in spring of 2015, I got invited to go off and work on the White House staff. And so I worked for President Obama for almost two years, which was when, obviously, arbitram was not so much on my mind. During that time, we had other things to worry about. But in January of 2017, when the presidential transition happened, I came back to Princeton, and one day, these two graduate students, Stephen Goldfetter and Harry Kalodener, came into my office. And at this point, I think I'll pass the baton to Stephen to tell the rest of the story.
00:05:06.148 - 00:05:38.610, Speaker C: Yeah. So I guess I can back up a little bit. I was, like, eagerly waiting for Ed to come back from the White House, because in the interim, scaling, well, we thought scaling had become a problem. Of course, what we actually saw was a blip compared to what we see today. But it was very clear to me that scaling solutions were necessary and that Ed had early foresight here. So Harry and I basically ambushed ed at his office and said, hey, that arbitram thing that you were working on, I think it's time to pick that up. And for that, we worked on Arbitram for about two years or so, a year and a half to two years in an academic context.
00:05:38.610 - 00:06:04.674, Speaker C: We published a paper on arbitrum and it became clear to us basically then before the paper was even fully published, that there was commercial potential here, and we decided to spin out arbitram as a company. I don't think any of us realized that moving forward we'd all be in this full time and absolutely loving it three years later. But there was really nothing else that I'd rather be working on now, and that's sort of the beginning. But it's been a really long and really amazing journey in the company so far, and I think the best is yet to come.
00:06:04.792 - 00:06:05.410, Speaker A: Cool.
00:06:05.560 - 00:06:17.446, Speaker D: That is a really long time for a product to exist. How similar is arbitrum today to what you started on three years ago and to what the student work from 2014 was?
00:06:17.548 - 00:07:07.230, Speaker B: Yeah, let me compare it to the student work. The piece that really comes through from that very first version is the way that the system resolves disputes between parties about what is the correct execution of a chain. The basic idea of resolving disputes through this recursive bisection method that we use that goes back to the very first version of arbitrum. But I think almost everything else about how it works has been built since then. If you go back to 2014, this is before Ethereum had really launched. Yeah, and so we didn't think of it at that time as an Ethereum scaling project, because there wasn't really an Ethereum to scale. And so one of the ways in which it's changed is the way that we've adapted some of the basic ideas to work with Ethereum.
00:07:07.230 - 00:08:00.902, Speaker B: And I think we found partly that it's a really good fit to the problems and affordances that Ethereum has, and partly we've made it fit through the various research and engineering work we've done in between. So that's a big piece of it. Moving into what's today called the roll up model is, I think one of the changes over time, we've had different ideas of what the role of validators are and how all that works. We could go deep on that, if anyone is interested. And this is actually another part of our journey in the early days of our company, we would talk to people about what we were doing, and they said, okay, is it state channels or is it plasma? And we would have to say, no, it's something else. But there wasn't really a word at that time for the thing that arbitrum is. It was only later that this term roll up came along and we recognized, hey, this actually is a pretty good description of what we do, or at least a big part of what we do.
00:08:00.902 - 00:08:06.994, Speaker B: And so the category that we're in is a category we were in before. It was a category.
00:08:07.122 - 00:08:20.266, Speaker A: But do you. I mean, I said this just before that. You're sort of in the optimistic roll up category as well. Like, the idea of using. I'm assuming you're using fraud proofs. Was that already part of the idea back in 2015?
00:08:20.368 - 00:08:40.350, Speaker B: Yeah, the idea was optimistic in the sense that somebody would make a claim about what the correct execution of the chain was. And then there's a time period where people can dispute that if they want to dispute it. And if there is a dispute, then there's this dispute resolution protocol. So all of that existed in the 2014 version.
00:08:40.510 - 00:08:45.982, Speaker A: Okay, but was it all built with the concept of, like, bitcoin as the core?
00:08:46.126 - 00:09:17.774, Speaker C: I think our line back then was, we're chain agnostic. And that's what was in our academic paper was, you have some layer one chain that has some basic capabilities, and you can build a powerful layer two on top of that. Really, it solidified to us that we were building on Ethereum back when we start, when we initially formed the company. That's when, in an academic paper, you can say, oh, it's chain agnostic. And that's, like, a good thing when you're building a company and you have to actually know what you're building on. And it became clear to us that building on Ethereum was the right thing to do. This actually wasn't the most popular model for investors back in the day.
00:09:17.774 - 00:09:33.378, Speaker C: This was like 2017, 2018, people just wanted you to launch your own blockchain and your own coin. But it was clear to us back then that if this could be made to work on Ethereum, we should make it work on Ethereum. And that's sort of the approach that we took, and the rest is history from that point.
00:09:33.464 - 00:09:53.882, Speaker A: So you just mentioned the company that you formed, which is off chain labs. Correct? That's a company. So I actually kind of wanted to understand that. So going back to that story, you were saying it like, 2017. You're deciding okay, we're going to actually run with this. You found a company. Who was that company, and what was the kind of origin story there?
00:09:53.936 - 00:10:21.650, Speaker B: Yeah, so at first it was the three founders. It was myself and Harry Kalodner and Stephen. So we were the three main authors of the academic paper. We had written the vast majority, or I think maybe all of the code underlying the academic paper. And so it was just the three of us that spun out into a company. And at first it was just three people and a piece of paper saying that we're a corporation. And that was sort of the beginning of the journey.
00:10:21.650 - 00:10:40.362, Speaker B: We did a first fundraising round in early 2019. We started hiring employees and got an office and started actually producing, taking the academic code which we had licensed from Princeton, and then turning it into something that was going to work as a product.
00:10:40.496 - 00:10:46.940, Speaker A: Wow, you were raising in 2019. That was a tricky time. I remember, yes.
00:10:47.550 - 00:11:25.954, Speaker C: Back then, basically, people didn't really believe that scaling would be the issue that it is now. This quickly. I remember one of our investors says, what you're saying is, build it and they will come. Do we really need this? Is Ethereum really going to ever reach its capacity, or is it going to reach it anytime soon? Another pushback we got was, hey, there are so many other problems that will come first, like Ux, et cetera, finding good use cases, and scalability is more down the road. So I think that it was a particularly hard time for the market to raise then, but I think for scaling solutions also. People didn't really believe that it would become that important that quickly. But we didn't have too much trouble raising.
00:11:25.954 - 00:11:36.490, Speaker C: But we definitely did need to convince people of our story as opposed to today, where people are saying, hey, why is this not built yet? Why is it not on Mainnet yet? We need this leg yesterday.
00:11:37.310 - 00:11:57.570, Speaker A: Okay. So we've kind of determined that arbitram falls into the optimistic roll up category. But when you were doing this, there was no optimistic roll up category. Really? Like, you didn't call it that, did you? Or actually, sort of random question here, but who coined that phrase? I actually don't know that.
00:11:57.720 - 00:12:29.900, Speaker B: So it came in two pieces, I think, as I understand it. First, the idea of roll up, which today means something about recording data on the l one chain to allow people to replay the history of the chain if they want to, and then optimistic as a descriptor on that, came later. We didn't originate either of those terms, but we adopted them because it was clear that they were describing the thing that we were already doing.
00:12:30.690 - 00:12:52.398, Speaker D: If I remember correctly, roll ups came out of Barry Whitehat's work on ZK roll ups, or the early thing that eventually became the foundation of ZK roll ups. And optimistic was coined by, I want to say, Vitalik, and then popularized by Dean Eigenman's post on optimistic systems.
00:12:52.494 - 00:12:55.250, Speaker A: No way Dean made that famous.
00:12:56.070 - 00:13:11.210, Speaker D: He was the first one that I remember writing a big blog post about what is optimistic. And then after that, they came together to be optimistic roll up, which was a description of systems like arbitrum that were already in progress.
00:13:12.830 - 00:13:40.446, Speaker A: A few weeks ago. We did have optimism on the show, and there obviously you can see like they kind of took that name and now it's kind of part of their brand. I keep unfortunately messing that up and being like optimistic when I mean optimism, and optimism when I mean optimistic. But I want to understand how is it different from what they're building if you're both in this kind of subcategory of roll ups, which we're calling optimistic?
00:13:40.638 - 00:14:01.286, Speaker C: Yeah, it's a great question. The first thing I'll just say on the name. Yeah, I think they definitely were using the term optimistic roll up before we were. That's sort of now come to describe a category of scaling solutions. We also have some others, like fuel labs, also sort of recategorizing projects into this category. Yeah, I don't know. Ed, do you want to let me.
00:14:01.308 - 00:15:07.562, Speaker B: Talk about what the difference is? There's a bunch of ways to come at this. We can talk about a lot of the detailed differences, but one way that I think is useful to think about it is that we start with the idea of resolving disputes, that is dealing with claims of fraud by an interactive protocol. So you have two people, Alice and Bob, who disagree about what's the correct outcome of a particular set of inputs to the chain, and how do you resolve that dispute? We use an approach that's based on interactive proving. So that is, Alice and Bob sort of go back and forth. There's a kind of game between those two parties that's refereed by an l one ethereum contract. And our system is designed around the idea that that is the best and most efficient way to not only to resolve disputes, but actually it allows the most efficient execution, even in the case without a dispute. At bottom, one of the big differences between optimism's product and our product is the way that the disputes are resolved.
00:15:07.562 - 00:15:21.906, Speaker B: And many aspects of the overall design of arbitrum follow from that decision to use interactive proving. And we could dig into that a lot more. Why interactive proving is better, we think. And then what does that mean for the design?
00:15:22.088 - 00:15:22.530, Speaker C: Sure.
00:15:22.600 - 00:15:59.806, Speaker A: I want to take one step back into the kind of fraud proof concept because it was in that interview that I realized, okay, so when you're like this fraud proof, it's not that you're constantly sending fraud proofs, in fact, you should never, it will be very rare that such a proof is actually created. And I guess the reason I didn't get that right away is I'm always thinking from the ZK proof context and the ZK roll up where you're often sending proofs. Here, if there is a dispute, a fraud proof is submitted, and then that fraud proof must be kind of figured out.
00:15:59.908 - 00:16:26.198, Speaker B: Yes, if everyone agrees. If literally everyone agrees what the result is, there's no need for a proof. Yeah, right. And as you say in the common case, no proof is necessary, right? Because someone makes a claim which is correct and everyone else looks at it says that's correct, and on you go. So this is one of the ways that optimistic systems can be more efficient is you don't have to pay the cost of proving unless there's actually a.
00:16:26.204 - 00:16:28.600, Speaker D: Dispute, unless something goes wrong.
00:16:30.510 - 00:16:38.470, Speaker B: Unless something goes wrong one way or another. Yeah, but normally things don't go wrong, right? And people are disincented from trying to cheat.
00:16:38.550 - 00:17:13.202, Speaker C: There's a very interesting thing here to connect this question back to the other point of how we compare our core differences in the technology is really around fraud proofs. And it's a bit ironic. As you mentioned, fraud proofs don't really come up in practice. We expect them, the incentives of the system work that fraud proofs shouldn't come up and we really don't expect to see these. But ironically, the fraud proof technology impacts the happy case as well. So for example, our transaction costs are quite low. And it's because the way we do fraud proofs, other systems have issues with large transactions.
00:17:13.202 - 00:18:00.302, Speaker C: So consider a transaction that goes over the Ethereum gas limit or a contract deployment that's larger than allowed on Ethereum. We can do these, but systems that rely on fraud proofs that reexcute code have trouble with these, because again, even if fraud proofs don't come up, you always have to have the ability to do a fraud proof. So if your fraud proof mechanism requires you to re execute code and rerun your transactions on chain, then even in the happy case where there is no fraud proof, you still are bound by the limits of the ethereum chain. And that's something which we break out. Interesting. It's super interesting that our core technical differences from other optimistic roll ups are in the way we do fraud proofs, but it actually impacts the healthy system even when there are no fraud proofs, which is, I think, an interesting and not super appreciated point. Yeah.
00:18:00.376 - 00:18:06.520, Speaker B: So, I mean, one way to looking at this is you rarely have to do a fraud proof, but you always have to be ready to do one.
00:18:06.970 - 00:18:07.960, Speaker A: Got it.
00:18:08.330 - 00:18:19.370, Speaker D: So you've used the word interactive to describe your fraud proofs a few times. Should we say that optimism's fraud proofs are non interactive? And that's one of the core distinctions.
00:18:19.870 - 00:18:51.960, Speaker B: I think it's probably more accurate to say that they are one round interactive proofs. So someone posts a claim about a roll up block, which is like a claim about what correct execution is, and there's one round of interaction that someone says, assuming it's wrong, they make a claim that it's wrong, and then the system in sort of that one round game is able to resolve it, whereas we use a multi round interactive protocol. And on the other hand, a ZK roll up system would use a non interactive because you just post the proof every time right away.
00:18:52.490 - 00:19:05.126, Speaker D: So it's much more of a spectrum than a binary. Here is we have the ZK on one end as non interactive and then optimism as one round of interaction. And then arbitrum can do potentially many rounds.
00:19:05.318 - 00:19:13.254, Speaker B: Multiple rounds. Yeah, as many as necessary. It's a small factor times the log of the number of steps of computation.
00:19:13.382 - 00:19:18.254, Speaker D: Yeah. You said recursive earlier, which gave me a hint as to how it works.
00:19:18.372 - 00:19:18.654, Speaker C: Yeah.
00:19:18.692 - 00:19:48.354, Speaker B: So let me dig into that a little bit more. So imagine that Alice has made a claim about a billion steps of computation, and Bob disagrees with it. Right. So what will happen is Bob, first of all, says he disagrees with it. Bob will make a counterclaim. Here's what he thinks the result should be after a billion steps. And then Bob will divide his counterclaim into 100 smaller claims, each of them being 10 million steps that sort of in sequence line up to be equivalent to his whole billion step claim.
00:19:48.354 - 00:20:24.210, Speaker B: Right. And so now Bob has made 100 of these 10 million step claims, and Alice will pick one of those to disagree with. Alice has to pick one to disagree with. And so now what you've done is in one round of this game of Bob's move, you've reduced the scope of the dispute from a billion steps to a dispute, about 10 million steps of computation. So a factor of 100 at each round, you reduce it. So after whatever the log base 100 of a billion is, which is, I guess, four and a half rounds. You now have a dispute about one step of computation.
00:20:24.210 - 00:20:52.282, Speaker B: And now that finally gets decided on the l one chain on the merits, right? That is, whoever is making that one step claim has to offer a proof that, like, hey, this is an ad instruction. Here's a proof that it's an ad instruction. Here's a proof of what it is that we're adding, and therefore, here's what the result should be. So that one step proof is super simple, but you get there from a billion steps or whatever, 100 billion down to one through this recursive division.
00:20:52.426 - 00:21:20.802, Speaker D: Right. The idea is that you and I are running the same computation with the same inputs. We should agree exactly on what happened at every step, right? Yes. So where optimism, the solution would be to have the l one run all 1 billion steps in arbitrum, there's this negotiation between you and I where we narrow down to exactly where we disagree, and then the chain resolves just that one step where we disagree.
00:21:20.946 - 00:21:26.214, Speaker B: Exactly. Right. And the thing that you can prove is that the person who's right can.
00:21:26.252 - 00:21:33.606, Speaker D: Always win the game, as long as there's no censorship on the chain and the other kind of standard fraud proof assumptions.
00:21:33.718 - 00:21:34.042, Speaker C: Yes.
00:21:34.096 - 00:21:52.378, Speaker B: Right. You have to assume that people can get a transaction on the chain within a not outrageous length of time. So it's about a week in optimism, I think, is what they're thinking. And that's what we're thinking as well, that you have about a week of grace period to deal with denial of service attacks if there is a dispute.
00:21:52.554 - 00:22:04.302, Speaker D: So, in this example, with a billion steps of computation, and we need to do four or five rounds back and forth, is that one week per round or one week for all rounds?
00:22:04.446 - 00:22:28.106, Speaker B: It's one week total. We sometimes talk about it as a chess clock model. That is, each player gets a clock that starts with a week. And when it's your turn to move, your clock is ticking, and if your week runs out, then you lose the challenge. And so that means that you have a week. This is a week in addition to the time that it's expected to actually take you in the absence of denial of service. Right.
00:22:28.106 - 00:22:35.390, Speaker B: So you have a week of extra cushion to deal with denial of service or crashes or whatever might happen during the entire course of the game.
00:22:35.540 - 00:23:03.058, Speaker D: Gotcha. Interesting. And so this core difference is why you were talking earlier about arbitrum being able to handle much larger contracts and much larger computation is because where a one round fraud proof would have to run all billion steps at the same time, arbitrum can break it down into a bunch of discrete little sub rounds, or a bunch of discrete rounds, but only if necessary.
00:23:03.154 - 00:23:47.378, Speaker B: Right. So this is one of the key points. If you're operating with this re execution model, you have to post a state route on the l one chain, basically for every transaction or for every ethereum gas limit. Whereas with arbitrum, you don't need to do that so that you can checkpoint the state route to chain, say, only every five or ten minutes. And because if there's a dispute going, the difference between 13 seconds and five minutes is just a couple of rounds of dispute. And with this chess clock model, it doesn't slow down the resolution of the dispute by more than a trivial amount.
00:23:47.464 - 00:24:07.254, Speaker D: Right. And I guess the other part of that is, if I have committed fraud, and I am absolutely sure I'm going to lose this game after ten rounds, I probably won't even play the game at all. So we don't have to have the layer one spend money and gas running this ten round game that I know I'm going to lose.
00:24:07.382 - 00:24:45.042, Speaker B: That's true. But also, even if you do play the game out, the l one's job is really easy. It's a timekeeper, number one. And number two, it makes sure that the player's moves are sort of valid on their face. So Bob is supposed to issue 100 intermediate state routes. And did Bob issue 100 things that look like state routes or not? Whether the state routes are correct or bear any resemblance to reality, the referee doesn't need to know because that's all going to come out as they play this interactive game. And so the referee just needs to make sure that each player moves on time and that the move is syntactically valid.
00:24:45.042 - 00:25:00.102, Speaker B: Does it contain 100 state routes? Did the person really identify one of those 100 steps? Literally, is it an integer between zero and 99, the sort of segment identifier that gets passed? So it's very simple, checking at each round.
00:25:00.246 - 00:25:00.940, Speaker D: Interesting.
00:25:01.390 - 00:25:46.314, Speaker A: I'm left with like two questions from here that maybe you can help me understand. So we keep kind of mentioning this one week duration. So going back to that idea, fraud proofs, they exist in the case that somebody does something inappropriate. But you have this week long time frame, I guess that's been predetermined. When you think of a transaction actually kind of going from the l one to arbitram doing something, or like, things are basically happening over an arbitram, and then you're trying to kind of bring it back to l one. Does it then sit for a week on, en route back to l one. When you're trying to kind of show that this thing has happened, guarantee that it's happened, roll it up and write it.
00:25:46.314 - 00:25:48.922, Speaker A: Do you have to wait before you can access it?
00:25:49.056 - 00:26:15.762, Speaker B: So there's an important distinction here between finality and what we call confirmation. So finality is when do you know what the result of your transaction will be? At what point in time does every honest party who's watching know exactly what the result of your transaction has to be? And then there's confirmation, which is that, at what point in time does the ethereum chain record the fact that that happened? Does that make.
00:26:15.896 - 00:26:16.974, Speaker A: Yep, yep.
00:26:17.022 - 00:26:22.882, Speaker B: Okay, so, and it might be helpful to walk through kind of the transit of an arbitram transaction.
00:26:22.946 - 00:26:23.862, Speaker A: Sure, let's do that.
00:26:23.916 - 00:26:59.186, Speaker B: Some user wants to do an arbitrary transaction. What they're going to do first is arrange for that transaction to get put into the chain's inbox. So the chain has an inbox which is managed by an l one contract, and it's first in, first out. And basically that supplies the inputs to the chain's execution. And so what the chain does is it reads its inbox one transaction or message at a time, and it processes each one. And that processing is fully deterministic. So once your transaction is in the inbox, now you can figure out exactly what its result is going to be.
00:26:59.186 - 00:27:10.978, Speaker B: And everyone else who's paying attention can also figure that out, because the result of your transaction is a deterministic result of what's in your transaction and what's ahead of it in the inbox.
00:27:11.074 - 00:27:22.810, Speaker A: So when you talk about this execution, though, is that execution only on arbitrum, or is that execution still on this l one execution on arbitram? Okay, so we've already moved off of l one. We're in l two.
00:27:22.880 - 00:27:23.114, Speaker C: Yeah.
00:27:23.152 - 00:27:30.178, Speaker B: So as soon as you put your transaction into the arbitram chain's inbox, now its result is inevitable.
00:27:30.294 - 00:27:30.814, Speaker A: Okay.
00:27:30.932 - 00:28:01.542, Speaker B: And everyone can know what it is. So as soon as the arrival of your message in the inbox has finality on ethereum, then your transaction has finality on arbitrum, in that everyone knows what its result will be. The only entity that doesn't know what the result of that transaction will be is the Ethereum chain. Right? So the whole point of an l two chain is that you don't want to make Ethereum do all the work of executing or checking out all the transactions, right?
00:28:01.596 - 00:28:01.862, Speaker A: Yes.
00:28:01.916 - 00:28:23.642, Speaker B: And so we don't. Right. So all observers who are watching, they can execute along with what the chain is doing based on the contents of the inbox that are fully known to everybody. Figure out what the result of your transaction will be and go on from there. But it takes a week for the Ethereum chain to ratify or confirm that inevitable result.
00:28:23.776 - 00:28:46.290, Speaker A: When we talk about kind of going over to arbitrum, it's not that it's like a ledger owned by sitting on one person's computer where things are happening. That in itself has a decentralized block production kind of system. So it's like it moves from the l one to the l two, which has its own, I guess, security in it.
00:28:46.360 - 00:28:46.738, Speaker B: Yes.
00:28:46.824 - 00:29:00.326, Speaker A: And then the extra security is generated by getting that confirmation one week later, actually, is that how you'd think of security there? Because I always think of, like, the l one is supposed to provide the security, in a way, yeah.
00:29:00.348 - 00:29:22.110, Speaker B: We think of the l one as providing confirmation, as confirming or ratifying the result. Right. In the normal case, the history of your transaction will be you put it into the chain's inbox. And once that has finality, that putting into the inbox transaction has finality. On Ethereum now, your transaction has finality, right. Its result is known to you and knowable by everyone. Right.
00:29:22.110 - 00:30:06.654, Speaker B: Then at some point, some party will propose a roll up block that includes the execution of your transaction and whatever results it produces, whatever changes it makes to the state of the arbitram chain. There's a state route that's posted that summarizes all of that. And then any actions like withdrawals of funds back to l one are also part of that roll up block. So that roll up block gets posted. If it's correct, everyone knows that it will eventually be accepted. If it's incorrect, everyone knows it will eventually be rejected. So in the normal case, someone posts a correct roll up block that includes your transaction, and then a week later, in the normal case, no one has disputed that, and the Ethereum chain confirms it.
00:30:06.654 - 00:30:15.298, Speaker B: And then now Ethereum knows that that's the result of your transaction. Everyone else knew before that, but it takes a week for Ethereum to find out.
00:30:15.384 - 00:30:24.770, Speaker D: So say you're me, I'm running an Ethereum node, and then I want to participate in arbitrum. So I also run an arbitram full node alongside it, right?
00:30:24.840 - 00:30:28.760, Speaker B: If you want to, yes. So it's just like Ethereum. You can run a full node or not.
00:30:29.130 - 00:30:40.246, Speaker D: And so my arbitrum full node can learn very quickly whether an arbitrum block is valid, right, because it's running the whole arbitrum chain. It's syncing everything.
00:30:40.348 - 00:30:41.138, Speaker B: Sure. Yeah.
00:30:41.244 - 00:30:46.154, Speaker D: But then it takes Ethereum a week to catch up to what my node knew all along.
00:30:46.272 - 00:30:53.790, Speaker B: That's right. Okay, yeah, your node, everyone's node, it knows the score. It's just that Ethereum is slow to find out.
00:30:53.940 - 00:31:03.966, Speaker D: Okay. And so the idea of that week is that it gives a chance for Mynode to tell Ethereum that something's fishy here.
00:31:04.068 - 00:31:29.766, Speaker B: Yes. Right. If you think that that roll up block that was proposed is wrong, you can dispute it. You have to say what you think is correct, and then you have to stake, and then you and whoever proposed that block will be put into a challenge with your stakes at stake. And eventually one of you will lose and the wrong block will eventually get rejected and the correct one will eventually get confirmed.
00:31:29.878 - 00:31:37.638, Speaker D: Interesting. But the outcome of that challenge is known to everyone else. As soon as it happens, everyone knows.
00:31:37.654 - 00:31:39.574, Speaker B: Who'S in the right in that challenge.
00:31:39.702 - 00:31:40.234, Speaker A: Okay.
00:31:40.352 - 00:32:02.100, Speaker C: The security property of the rock is that you can ensure that whatever you see on your node, that any honest player themselves can ensure the correctness. So if you're running your node and you know the state, that's exactly the guarantee of the roll up, that you can guarantee that Ethereum will publish, that will confirm that, because either it's going to be published and accepted, or if someone tries to challenge, you know that you can successfully defend it.
00:32:02.870 - 00:32:16.598, Speaker D: And so the security guarantee is that Ethereum will catch up to what everybody else knows is correct, as long as there's no censorship and there's one honest person like me out there willing to submit the proof and everything.
00:32:16.684 - 00:32:31.070, Speaker B: So we do assume that there is one honest person who is, or just one greedy person who wants to take the stakes from liars. Right. Even just a person who is challenging wrong roll up blocks for profit will ensure correctness.
00:32:31.970 - 00:32:37.214, Speaker D: And I think to be clear, is that's an assumption of any optimistic system?
00:32:37.332 - 00:32:52.386, Speaker B: Yes. What's essentially the assumption of roll ups is that you get a guarantee of correctness on some assumption, an optimistic assumption. You have to assume that there is someone who's willing to stand up for the correctness of your transaction or the correctness of the chain at all.
00:32:52.488 - 00:32:56.854, Speaker D: And for ZK rollups, you have to assume that the cryptography works.
00:32:57.052 - 00:33:28.814, Speaker B: Yes. There's also questions about censorships. One of the things that I like about optimistic systems is anyone, literally anyone in the world, can play the role of the one party who forces correct execution. You don't have to rely on someone who has special equipment or special know how or secret software or anything. Right. All of the information you need is on the l one chain because it's a roll up. And the computational load of actually ensuring correctness is reasonable for an ordinary computer.
00:33:28.932 - 00:33:30.174, Speaker D: Oh, that's nice.
00:33:30.372 - 00:33:45.762, Speaker A: I want to understand this idea of one individual can submit a fraud proof, but what does that actually look like? It's not. Somebody sitting there sees something with their eyes and presses, right. This is all built into the rules already, essentially, yeah.
00:33:45.816 - 00:34:27.250, Speaker B: So in practice, people will run validator software, right? So a validator software is, if you want to get right down to it, it's a piece of software that watches the chain, and it creates disputes and engages in this interactive challenge protocol when needed. And we offchain Labs produce open source software that will do that. And so anybody can download that, build it yourself, or just download our docker image, or you can write your own according to the published protocol. Right? So anybody can do that. And there's open source software that lets you do it. So in practice, what you do is you start a validator on your computer or on an Amazon instance or something, and then you just go about your regular life, I guess.
00:34:27.320 - 00:34:43.938, Speaker A: Should we make a distinction here? When you use the term validator? I have a validator. It's called ZK validator. But on these proof of stake l one networks, I've heard a lot of different words for the actor that lives between l one and l two. And is that what you're referring to here when you say validator?
00:34:44.034 - 00:35:27.674, Speaker B: Yeah. So we think of the nodes, the arbitram nodes, as basically falling into two categories. They're the ones that are validators who are paying attention to the correctness of the protocol, making sure that roll up blocks are correct and so on. And most of the time, a validator is just watching and checking, right? Most of the time everything's okay. And so nobody even knows you're running a validator. If you don't tell them, then there are full nodes, which are more like Ethereum nodes, meaning that they're following along. And many of these nodes will accept rpcs from clients and can provide node services using the same API that Ethereum nodes export.
00:35:27.742 - 00:35:39.682, Speaker A: Got it. But these validators are not building. They're not creating the block. Actually, this is a question. Is there a block in our blockchain in there? Okay, so who makes the blocks?
00:35:39.746 - 00:36:00.682, Speaker B: So any validator can make a block. Okay, so anybody can make a block. You're essentially proposing a block. If you like, you can think of it like the Ethereum chain in the sense that anyone can make a block. We don't have a proof of work that you need to do. Instead, you're subject to fraud proof. Instead, you have to stake and you're subject to a fraud.
00:36:00.746 - 00:36:08.610, Speaker A: Okay, so it is proof of stake. In a way, it is proof of stake, but you don't call it that. This is where it becomes so intertwined.
00:36:09.830 - 00:36:51.630, Speaker B: The difference is, I think, that with sort of classic proof of stake, you have this scheme where people make blocks and there's a kind of consensus that develops among the people who have stakes down. Whereas in our protocol and in most other roll ups, it's not a consensus protocol, it's a correctness protocol. That is, if you are correct and everyone else in the world is lined up against you, you will still win. Because at the end of the day, this dispute resolution protocol is determining who is actually wrong about what the chain will do. And so if you're right, you can always win in this game. That's a difference between either proof of work or proof of stake type consensus algorithm.
00:36:52.770 - 00:37:11.910, Speaker C: Traditionally, proof of stake is like a voting model. And the idea is if you accumulate enough stake, you can overpower and make bad things happen in the system. There's no such attack vector here, right? All you need is one stake and you can guarantee honesty. And if someone else has way more stake than me and they still can't force a bad result into the system.
00:37:11.980 - 00:37:20.786, Speaker A: Is the validator actually the bad actor as well? If there was to be a bad actor, would it be a validator actually submitting something incorrect?
00:37:20.898 - 00:37:29.546, Speaker C: Yes, the validator who post the update would post a bad update and then another validator would challenge, and you'd get this interactive challenge between two validators that.
00:37:29.568 - 00:37:42.074, Speaker B: Would play out, and then at the end of the challenge, the bad validator is going to lose the challenge and they will lose their stake. And some of that stake goes to the good validator who challenged them, and some gets burned for incentive reasons.
00:37:42.202 - 00:38:04.950, Speaker D: We were talking earlier about this being a correctness protocol, not a consensus protocol, and that validators, unlike in proof of stake, cannot vote for incorrect things. Am I right in believing that you get that nice property because you're relying on the layer one host blockchain to provide you a consensus protocol and everything else you need?
00:38:05.020 - 00:38:18.118, Speaker C: That's exactly correct. There's no magic bullet here. We're using Ethereum's consensus. We need a consensus mechanism. But the property is if Ethereum's consensus works, then one honest validator can enforce correctness.
00:38:18.214 - 00:38:24.300, Speaker D: This is an extension to existing consensus protocols, it improves them, it makes them better and more.
00:38:24.770 - 00:38:57.862, Speaker C: Yeah, exactly. And that's why it's really a layer two. By definition, the layer two is the true layer two, because it doesn't have its own consensus. It relies on layer one consensus. And then the validator property is for ensuring the correctness of the layer two. And that's why it's so nice, because you can get the decentralization and the security of the layer one. And then you have these validators that are really, again, minimally trusted in a typical proof of stake or a different consensus system, you have to worry about who are the validators, how many are there? Again, can they overpower and over team and form a cartel here? You don't have that property.
00:38:57.862 - 00:39:06.582, Speaker C: All you need to know is that there is one honest validator that's going to do the right thing. And again, that, together with Ethereum's consensus, is the recipe for correctness.
00:39:06.726 - 00:39:12.794, Speaker D: So as long as ethereum is working and there's one honest validator out there, arbitrum is going to work, right?
00:39:12.832 - 00:39:16.810, Speaker B: Yeah. As long as that's the case, you will get correct execution of the arbitram chain.
00:39:16.890 - 00:39:29.410, Speaker A: Besides the fraud proof, there's something else being written to l one. What is that? Actually not the proof of fraud, but the transaction going back.
00:39:29.480 - 00:40:26.286, Speaker B: Yeah. So let me tell you sort of what's in a roll up block, which is probably the key thing, right? So a roll up block has first of all a reference to the previous roll up block saying, here's the last block before me that I say is correct, then. So starting at the endpoint of that block, the roll up block says we can execute a certain number of steps of computation, and that if we do that, we'll consume a certain number of messages from the inbox, that after doing that, the state root of the chain will have a certain hash, and that along the way, in the course of doing those things, a certain set of outputs will be produced, and there's a sort of hash that summarizes all of the outputs that are produced. So that is the claim. It's starting at a certain point, you can execute a certain amount of computation, that it takes the state root of the system to a certain value, and that it produces an outputs that have a certain hash. So that's relatively small.
00:40:26.408 - 00:40:41.370, Speaker D: So, phrasing that in kind of more layer one e terms, is the roll up block, is the previous state a bunch of transactions, and the assertion that if you execute all these transactions on the previous state, it'll produce a new state.
00:40:41.440 - 00:41:12.958, Speaker B: And these messages, logically it includes that information, but it doesn't actually physically include it. Like the individual transactions are not actually part of the roll up block. They don't need to be. They're in the inbox because they're in the inbox. Right. The inbox provides, and this is another thing that is, I think, non intuitive for people who are new to this, that you have this inbox contract which runs on l one, which does two things. First of all, it establishes an order on all of the transactions that are submitted to the chain.
00:41:12.958 - 00:41:35.722, Speaker B: And then it also records their call data. It records their data in the form of l one call data, so that it's accessible to everyone. And then separately, you have the roll up protocol, which, given the contents of the inbox, ensures the correct execution. That is the update of the state of the chain. And then whatever outputs it produces one higher level.
00:41:35.776 - 00:42:25.446, Speaker C: Point that again, I'm not sure, I'll just say it quickly, and I can speak to this if it's interesting for a question, but sometimes people think that we're sort of scaling Ethereum transactions directly, right? You have some contracts on Ethereum, and then the roll up comes in and gives you extra superpower. There. There actually was a scaling project that did this, and this was basically truebit back in the day when the idea there was you're running your Ethereum contract, you get to something that's super intensive, you call out to Truebit, it gives you a result, and everything stays on Ethereum. The way to think about arbitram and really all the modern rollups, these aren't like interacting with the transactions directly on Ethereum. They're basically present themselves as other chains, and they have their own ecosystem and their own sort of transaction history and state that's built on top and secured by Ethereum. And so it's not that there's no one to run. Relationship between every transaction is affecting something on Ethereum.
00:42:25.446 - 00:42:45.426, Speaker C: Rather, the roll up has an ecosystem. It's a chain that lives on Ethereum, that is secured by Ethereum, that has a trustless bridge back to and from Ethereum. But that's sort of the level of interaction, really is the bridge and information going back and forth. But it's not like every transaction on Ethereum can just call out into the roll up and get some extra superpower, super scaling energy or whatever.
00:42:45.608 - 00:42:58.738, Speaker D: Just as a quick aside, I am interested in how you guys would characterize the difference between your recursive fraud proof system and truebit. I know truebit is basically defunct these days, so it doesn't matter that much.
00:42:58.824 - 00:43:47.230, Speaker B: Sure, I'd say a few things. One is that in our basic model, the execution is stateful, whereas truebit is stateless, that they are proving the result of a computation that has an input and an output and no state. And so this is what Stephen was talking about before, where you have like a sub procedure inside of your Ethereum transaction, and you can execute that subprocessure on tribit. Whereas because our system is stateful and because it is capable of emulating Ethereum, you can do 15 minutes of Ethereum transactions in a sort of single roll up block if you want. Got it. The statefulness is an important thing. The other thing is, we've made some very significant improvements in the bisection protocol, so that you need many fewer rounds.
00:43:47.230 - 00:44:11.594, Speaker B: What we were talking about back in 2014 is similar to the kind of bisection that trubit uses. And we've since made a bunch of improvements that increase the sort of degree of division in the bisection from a factor of two for every two rounds to a factor of 100 for every one round. So a big difference. And especially when you compound that over all of the, over multiple rounds, I.
00:44:11.632 - 00:44:31.826, Speaker A: Want to ask the things that are kind of off the table for an optimistic roll up are probably a Zk roll up. Are things like flash loans, like what you said, it's not one transaction that could kind of go off and come back within one block. It's like it's going to go off, it's going to live off and then come back after a while.
00:44:32.008 - 00:44:54.554, Speaker C: I would say that flash loans are in play. Flash loans that go back and forth from Ethereum wouldn't be in play. But again, we expect there to be a fully flourishing ecosystem of defi protocols on the roll up itself on arbitrum. So I think everything you have in Ethereum, you'll see there. But, yeah, definitely we don't have synchronous composability. So you wouldn't have flash loans that go jump back and forth between the roll up.
00:44:54.592 - 00:45:07.790, Speaker A: Okay. And on the arbitrum chain, will you say there's an entire ecosystem? Is there like gas and all of those elements? Okay. Is that the case for all the roll ups? I actually never asked that question.
00:45:07.940 - 00:45:13.882, Speaker B: There kind of has to be. Right, because if resources are free, then they're going to get overused.
00:45:14.026 - 00:45:49.674, Speaker A: Now, I want to bring up something, Steven, you mentioned earlier, which was this idea of, actually, I think a while back, I said, I have two questions and one was the one week, and now this is actually the second mean, at least I feel like I understand what we've talked mostly about optimistic roll ups in general. But you mentioned that the reexecution aspect, that is actually used more for the fraud proof, actually has something, it differentiates you somehow, and I don't exactly understand where that fits into this.
00:45:49.792 - 00:46:13.614, Speaker C: Yeah. So I think we were discussing that was, we were asked about the comparison between us and optimism and how we do our fraud proof. So what is a fraud proof? Right. So the key idea of a roll up, of course, is you take the execution off chain and you prove to ethereum what happens. And the way the fraud proof works is optimistically, the validator posts what happens without proof. And then a challenge window opens whereby anyone can prove fraud. And that's what's called a fraud proof.
00:46:13.614 - 00:46:54.170, Speaker C: And so what are these fraud proofs these magical things look like? So the simplest way to do a fraud proof, and this is what optimism does, is re execution, where you point to a transaction and say, hey, that transaction is fraudulent. And you rerun that transaction on chain. So they have a before checkpoint and an end checkpoint, and you rerun and say, hey, does this transaction match up with the end checkpoint? And that's how you prove fraud. What we do is different. And this is what Ed was talking about, how we do this back and forth. And instead of re executing your, say, 5 million gas transaction, we actually just do an interactive process. And what you end up having to execute on chain is not the entire transaction, but much, much smaller, like one step of the transaction.
00:46:54.170 - 00:46:57.422, Speaker C: So that's all fraud proof. So you might say, okay, this is all irrelevant, doesn't matter.
00:46:57.476 - 00:47:10.450, Speaker A: Yeah, that's the thing is, to me, it was kind of in the context of the fraud proof. But does that have any impact on how the system is built without a fraud proof? Like that idea that we talked about, like the inbox and the fact that you're writing back to chain.
00:47:10.530 - 00:47:40.170, Speaker C: Yes. So it does have few things that come into play here. Number one, this is something Ed mentioned earlier as well. The idea is, if you're pointing to transactions, to re execute them, then you basically need to have frequent checkpoints. Every challengeable unit has to have a checkpoint before and a checkpoint after. And what this means is in systems like optimism, you have a checkpoint for every transaction, and a checkpoint is roughly a 32 byte state route, 32 byte hash. And they need these frequent checkpoints because you need to basically point to something that runs between two checkpoints.
00:47:40.170 - 00:48:09.606, Speaker C: We don't need these checkpoints. That's one point. And another is this idea of we can do transactions that use much more gas than is allowed in Ethereum block. We can do contract deployments that completely break out of ethereum's contract size limit. Now how can we do that? And the answer is because we don't need to ever run our transactions on chain. If your fraud proof model is re execution, then you can't have a transaction that uses more gas than is allowable in Ethereum block because it's not challengeable. Someone can't say, hey, that's wrong, and you say, okay, let's run it.
00:48:09.606 - 00:48:10.566, Speaker C: Oh, we can't run it.
00:48:10.588 - 00:48:14.006, Speaker A: You can't because there's too much gas on now one, right, or the contract.
00:48:14.038 - 00:48:43.940, Speaker C: Deployment is too large. We can't do that contract deployment because it's too much gas. But we can do those things because our model doesn't require us to re execute and rerun full transactions on chain. You can do a transaction in arbitrum that uses much, much more gas than an Ethereum block. And that's okay because the fraud proof will not say, hey, run that on chain and you'll be like, oh, sorry, I can't. It will get it down to the core unit of dispute and that's going to always be small and something that you can run on chain. So it's ironic the fraud proofs won't come up, but they really do.
00:48:44.710 - 00:49:00.358, Speaker A: Basically what you're saying here is like your fraud proof won't break Ethereum, you will be able to run more on your chain, and yet you've been able to make sure that if ever you need to run a fraud proof, it will still fit within the confines of the l ones.
00:49:00.444 - 00:49:18.158, Speaker C: Exactly. The mechanism won't come up, but in order for the system to work, the mechanism needs to be there and therefore you can't do something that it's not challengeable, even though no one's going to challenge it when it is challengeable. But it's a very weird thing where again, the fraud proofs won't come up. But if you don't have the ability to do fraud proofs, then that's a big problem.
00:49:18.244 - 00:49:41.160, Speaker B: Yeah, right. And the key thing is you have to be able to do the fraud proof and you have to have enough data recorded on the l one chain so that the scope of the fraud proof is defined. Right. So this is this thing that you always need to be ready to do a fraud proof, even if you very rarely have to do it. And the cost of being ready to do one kind of fraud proof versus a different kind of fraud proof can be fairly different.
00:49:41.530 - 00:49:58.762, Speaker A: Okay, so we've talked about kind of, we've mentioned a few of the other optimistic roll ups. We have mentioned the ZK roll ups. I want to talk a little bit about the costs of all of these systems and how you kind of fare. Like what does it cost to use an arbitrum style optimistic roll up versus others?
00:49:58.896 - 00:50:42.154, Speaker B: Sure. I mean, we've worked really hard to shave down the cost at this point in time, given the ethereum gas costs and the price. And the price. Right. Right. Now, given the situation with Ethereum fees for all of these systems, the biggest cost is from the l one footprint of your transaction, and that is the cost to record your call data on the l one chain, something that you have to do if it's going to be a roll up, and then whatever additional l one cost is necessary for bookkeeping and dealing with fraud and so on. And we've worked both in the architecture of our system and also in our specific engineering to minimize those things.
00:50:42.154 - 00:51:21.574, Speaker B: So to give you an idea on our testnet that's currently up, people can actually go and run their transactions and then look in our block explorer and see what the l one cost was. But we're running around something like 2000 l one gas per transaction for a transaction that has a small call data. And we think we can get that down further by adopting BLS signatures once that is fully supported. But that number is really competitive in terms of where other systems are. So we're really happy with that. And there's a bunch of things we've done to make that possible. Some of them are things anyone can do, like aggressively compressing the transaction header data.
00:51:21.574 - 00:51:36.262, Speaker B: Some of them are things that not everyone can do, like not posting a state route for every transaction, because our protocol allows us to not do that. So l one footprint is the biggest component of cost. That's really where we're focused in terms of cost reduction.
00:51:36.406 - 00:51:43.254, Speaker A: This is sort of more generic question, but optimistic versus Zk. Does Zk tend to be more expensive or optimistic?
00:51:43.382 - 00:52:00.338, Speaker B: The answer, I think is it depends. Call data needs to be recorded on the l one. That is pretty much a constant. And then the question is how much bookkeeping is required and how much cost is there per roll up block or per whatever the equivalent is in a Zk system.
00:52:00.504 - 00:52:17.442, Speaker C: And another thing to be said here is the overhead of ZK, I think is much, much larger than the overhead at a per batch level of the overhead of arbitram or other optimistic roll ups. So in order to amortize the overhead, you'd need significantly larger batches in a Zk system than you would in arbitrum.
00:52:17.586 - 00:52:52.450, Speaker B: And the way that that sort of batch size affects users is that you have some entity that is submitting batches of transactions to the system, and it's got to wait until it has a full batch before it can do that. And for the user that means latency. And so if you have a system that needs to accumulate a million transactions in a batch before it can submit a batch, because a batch is super expensive per batch, right, then you're going to have a longer latency than a system where you can have a batch of 30 to 50 transactions and still operate very efficiently. And that's kind of the neighborhood that we're in.
00:52:52.520 - 00:53:03.254, Speaker A: That's why I guess you said amortized over, because on a per transaction, optimistic might still be more expensive, but you can do more of them, I guess. But you win on time, and time.
00:53:03.292 - 00:53:22.790, Speaker B: Is really important for users, right. How quickly can they get to the point where you as a user know what the result of your transaction will be? Right. People are already unhappy with how long that takes on Ethereum, and you certainly don't want to make that worse. And there's a whole other conversation about how to make it better, but that's something that goes more to our roadmap than to our current testnet.
00:53:22.870 - 00:53:35.182, Speaker A: Cool. Speaking of, that's actually the next question and a question I want to touch on. I know we're getting close to the end of this episode, so let's hear about this roadmap. You mentioned a testnet. Where is this project at?
00:53:35.316 - 00:54:04.134, Speaker C: Yeah, so we've been on Testnet actually since October. That's a testnet that's fully open and permissionless. Anyone can launch deploy contracts. And we've seen a ton of usage on our testnet. We're actually currently on the fourth iteration of our testnet, but it's been running since October, and a few weeks ago we put out what we call the Mainnet release candidate version of our testnet. So this is more or less the code that will run on Mainnet and running on Testnet, getting some more mileage of testing there. But again, this is our full protocol.
00:54:04.134 - 00:54:21.902, Speaker C: The fraud proofs mechanisms are up and running on the testnet. We have real validators running. We have some other people running validators as well. We have permissionless deployment and lots of people playing with our testnet currently and the scaling Ethereum, Hackathon is going on and people are building on our testnet. We're seeing a nice amount of usage there.
00:54:21.956 - 00:54:22.270, Speaker B: Cool.
00:54:22.340 - 00:54:25.860, Speaker C: Yeah. So where do we go from here is. And the answer is Mainnet, of course.
00:54:27.350 - 00:54:29.140, Speaker A: Do you have a timeline in mind?
00:54:30.150 - 00:54:51.234, Speaker C: So we haven't announced a formal timeline yet, but what I'll say is I think it's going to be a lot sooner than people expect. We are basically, from a technical perspective, near just about there and we're coordinating some details and we'll have a lot more to say about this in the next one to two weeks. But I think we're probably a lot closer than people realize.
00:54:51.362 - 00:55:13.550, Speaker A: Cool. I know that a lot of the l two, there's sort of a race between the l two s to find new d five projects to work with or other kind of dapps more popular projects that are like working on top of the l one. How is that going for you? Do you feel that kind of race, that competition? And what are you seeing from your side?
00:55:13.700 - 00:55:41.798, Speaker C: So one thing to be said about the way we're approaching our launch, and this is actually something that's different from a lot of other players in the space, we don't have a whitelist model. We're not onboarding one project at a time. When we open the floodgates and let projects in, it's everyone, everyone's on the same footing. And we think that's really the values of the open and permissionless ecosystem. That's what we're doing here. It should be open to everyone and we're not going to be picking winners. So yeah, we have a really strong coalition of projects that are launching with us.
00:55:41.798 - 00:56:10.754, Speaker C: Some of them are announced like McDex and Dodo exchange, and some of them are not yet announced, but we'll be announcing in the next few weeks. And also we have a really strong coalition of infrastructure projects already announced, Chainlink. But a bunch of other node providers and different infrastructure projects are going to be coming along with us to Mainet as well. So I actually think I'm really, really comfortable with the coalition that we have now. Again, much of it is not yet public, but will be potentially by the time this is aired, will be public.
00:56:10.872 - 00:56:21.954, Speaker A: Cool. Is there anything missing before mainet release? Is there anything you still need to build or you feel like there's some projects that will make using the system even easier?
00:56:22.082 - 00:56:44.014, Speaker C: Okay. Yeah. So the way we're doing our main net launch, I should say, and this is not something we've spoken about publicly yet, but I'm happy to say here. We're initially going to launch on mainet, and it's going to be mainly open to developers, not in a whitelist or restricted model. But the idea is it'll be open to developers to set up shop first. So we'll have infrastructure providers setting up a bunch of the projects, for example, that are launching at us are going to be using Chainlink. So Chainlink needs to be up and running.
00:56:44.014 - 00:57:32.710, Speaker C: We don't want to be in a situation where we say, hey, everyone, we're on mainet five minutes after we deployed our contracts on Mainnet, and then there's nothing running. So there will be a time where, again, it's open to everyone, but it will really be focused at developers. There'll be a few week period, and important in these period projects coming on are again, the infrastructure projects that we're working with and also projects that really make the user experience better. So one category of projects here are fast bridges. We spoke earlier about that optimistic roll ups have a delay period that delay withdrawals for roughly one week. But that's really only on the protocol level. The protocol level bridge has this one week delay period, but there are some really great solutions coming on board, like connect hop protocol seller Seabridge, that are basically bridging this gap and providing fast liquidity exits to users.
00:57:32.710 - 00:57:38.558, Speaker C: So I don't have an exact date on when those will go live, but that's an important piece of infrastructure in the system as well.
00:57:38.644 - 00:57:51.458, Speaker A: Got it. That was actually a question was like, how would that week long thing be mitigated? And it sounds like you have a plan in place, and that will be kind of like happening somewhat in tandem with you going live.
00:57:51.544 - 00:58:31.738, Speaker B: Yeah. And the design of the system makes this possible because although it takes a week for the L one Ethereum chain to recognize your withdrawal is happening, your withdrawal has finality, which everyone else can verify right away. And that means that somebody who is thinking of loaning you that withdrawal money right away can have certainty that that withdrawal is going to happen. And so a liquidity provider can cover that one week delay for you at zero risk. And this also enables a competitive market for those liquidity providers. And so we think that there will be a robust market in people who are facilitating instant withdrawals from the network.
00:58:31.834 - 00:58:49.654, Speaker D: So if I'm a liquidity provider here, I have ether on Ethereum. You have ether on arbitrum. You're going to send me that ether from arbitrum to l one, and I'm going to send you ether on l one immediately. And I get your ether after a week, is that right?
00:58:49.772 - 00:59:14.682, Speaker B: More or less, yeah. There's a small fee involved, and there's different technologies for doing this. Some are more state channel like, some are cross chain atomic swaps. Some involve selling the sort of withdrawal ticket that gets created at l one. On l one. There's different ways of doing it, but that's the fundamental idea. You're trading an l one asset for an l two asset and paying a small fee to the provider.
00:59:14.746 - 00:59:21.502, Speaker D: I am an atomic swap minimalist, so I probably won't be using that one.
00:59:21.636 - 00:59:26.034, Speaker B: Yeah, you can use the technology of your choice. That's the beauty of this.
00:59:26.232 - 00:59:38.338, Speaker D: I understand you all are on Testnet right now. Is this something that I could go home after this call and download like a docker client or anything and participate in the testnet?
00:59:38.434 - 01:00:11.694, Speaker C: Yes, absolutely. So there are a few ways to participate in the testnet. The easiest way to participate in the Testnet actually doesn't require you to download anything. Just point your tooling at an arbitrary node, deploy contracts, and interact with apps. If you actually want to run a validator on the testnet, there is a docker image that's packaged up that will allow you to do that as well. So plenty of ways to participate in the testnet for developers that want to deploy, for users that want to use live apps, we have a fork of uniswap live in the testnet. Users can just play around with and also for sort of power users that want to run validators with.
01:00:11.694 - 01:00:14.000, Speaker C: James, I assume might be you.
01:00:15.730 - 01:00:19.140, Speaker D: I have been known to run full nodes once in a while.
01:00:19.990 - 01:00:28.978, Speaker A: On that note, I want to say a big thank you to Ed and Steven for coming on the show and sharing all of this info about arbitrum with all of us.
01:00:29.064 - 01:00:31.250, Speaker C: Thank you so much for having us. This is really a blast.
01:00:31.330 - 01:00:31.766, Speaker B: Thanks.
01:00:31.868 - 01:00:34.726, Speaker A: And thanks James, for co hosting this one.
01:00:34.908 - 01:00:36.022, Speaker D: Oh, it's great.
01:00:36.156 - 01:00:43.730, Speaker A: And I want to say a big thank you to the podcast producer, Andre, the podcast editor Henrik, and to our listeners. Thanks for listening.
