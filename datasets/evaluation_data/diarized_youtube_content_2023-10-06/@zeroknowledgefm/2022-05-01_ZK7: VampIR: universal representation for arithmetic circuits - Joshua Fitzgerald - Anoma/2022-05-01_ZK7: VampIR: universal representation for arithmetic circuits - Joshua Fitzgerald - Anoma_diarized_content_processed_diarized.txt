00:00:07.210 - 00:00:07.374, Speaker A: Now.
00:00:07.412 - 00:00:10.910, Speaker B: We will begin with Joshua's talk on Vampire.
00:00:12.450 - 00:01:32.330, Speaker A: Hello, I'm Joshua Fitzgerald, I'm with Anoma, and I don't know if David and Joseph are still here or not, but we should definitely talk because your your expression framework is hi very similar to what we're trying to do with Vampire. So, yeah, we should get in touch. Vampire is a universal intermediate representation for circuits. We we were at a noma, we were looking for some kind of intermediate representation that we can use to sit between our programming language. We have called juvix. Juvix is a dependently typed programming language can be used for many things, but we would like it to be able to create zero knowledge proofs. And so we wanted something to sit between Jubix and a proof system backend like our ZK Garage Plonk implementation.
00:01:32.330 - 00:02:35.210, Speaker A: But you immediately get a problem if you want to use something like plank, because it's so configurable that you write a circuit for one configuration of plank with three wires or three variables, or four wires or lookups or custom gates, or without lookups and without custom gates, and you have to change your circuits. So we really wanted something that was universal. So here's what we have. A Vampire is a proof system agnostic language for arithmetic circuits. Circuits written in Vampire can be compiled to any proof system using any constraint system or configuration, including those with custom gates and lookup tables. So my image didn't show up. That's too bad.
00:02:35.210 - 00:03:24.920, Speaker A: Arithmetic circuits, just some background. They are a representation of polynomial constraints. So in this beautiful empty box here, there is just see in your mind's eye a diagram of an arithmetic circuit where you have inputs at the top, and they're joined with wires going into gates like times and plus, and they feed together. If you've seen that diagram before, that's exactly what would be here. And on the right side, then we have the polynomial version. They both express the same thing. This is for a range gate.
00:03:24.920 - 00:04:48.160, Speaker A: This would check to see if the variable y is four bits. All right, so constraint systems, we have a few of these. There's like r one CS and Planckish. And the constraint systems are just another representation of a system of polynomials. But you only allow certain kinds of polynomials, polynomials of a certain format into the system, something that the proof system back end can process. With r one CS, you have this expression that's like A times B minus C, but A, B and C can be a linear combination of variables, right? So R one CS allows one product of a linear combination of variables, whereas Planckish constraints have a fixed number of variables. I almost put on here that a Planckish constraint has maximum degree two, which is like the original Planck, but it's not really true.
00:04:48.160 - 00:05:27.740, Speaker A: Once you start getting into custom gates and things, you can change that. You can expand that. So because Planck is so configurable, really. I couldn't think of anything else that really captures what it is other than it's got a fixed number of variables. You can change the relationships that those variables must have. So these two different constraint systems mean you have to write a circuit in two different ways. And with Plonkish, there's actually many more ways that you may need to write your circuit.
00:05:27.740 - 00:06:19.676, Speaker A: So yeah, there's some annoyances with constraint systems that are limited like this. Circuits written in different constraint systems can look very different. Constraints written in some constraint system may not resemble the source. If you're implementing something, it's got a canonical formula, but that formula doesn't fit into your constraint system. Then you have to rewrite and you have to break your polynomials into pieces, and suddenly it doesn't really resemble the original source. So you can make mistakes that way. Circuits have to be rewritten in order to use them in another proof system or configuration.
00:06:19.676 - 00:07:03.244, Speaker A: It's a big pain. It's also painful to benchmark a circuit in different proof systems or configurations. You might have a circuit that you suspect will perform better with Lookups enabled, for instance. But Lookup gates come with their own cost. They're not free. So you want to know, is this circuit, will it work better with Lookups or not? You'd want to use it in two different ways, one with Lookups and one without. But you have to rewrite the circuit in order to use it in two different ways.
00:07:03.244 - 00:07:50.750, Speaker A: And then you have to verify that circuits are actually the same. What if you made a mistake when you were rewriting the circuit? So that's a challenge. Some more annoyances. No canonical circuit format. So it's harder to take someone's circuit that they wrote specifically in a back end proof system like implementation, and then translate that into some other proof system. Implementation iterating on circuit designs is difficult. Make a change, might change the entire thing.
00:07:50.750 - 00:08:42.616, Speaker A: Front end languages or DSLs can become very tied to a particular constraint system or proof system implementation. So you're kind of stuck. It might be easy to write circuits using a particular DSL, but then what if that DSL only ends up using R one CS, but you want to try it out in Plunk, then you have to use some other DSL. So yeah, there's a couple of issues. Here's an example of some circuits that don't resemble each other because they're written in different constraint systems. They also don't resemble the source. This is the formula for a twisted Edwards addition on twisted Edwards elliptic curve.
00:08:42.616 - 00:09:27.150, Speaker A: So you've got three points here. They have X and Y coordinates, and those points add together according to that formula up there if these two constraints at the bottom are satisfied. So we've got six variables here, the capital A, capital D. These are just parameters that specify a particular curve. I didn't want to write the huge numbers out, so I just used those. So these two constraints here. Neither one will fit into r one CS or most plonkish configurations as is.
00:09:27.150 - 00:10:33.296, Speaker A: So here's those same constraints rewritten using r, one CS and three wire Planck. This is like the original Planck with three wires maximum of one term of degree. Two. And you can kind of see how this works. The o variables are auxiliary variables that have to be added into the system so that your constraints can fit in. So, like in this first line here, under R one CS, we are kind of saving X one times y two in a new variable called one, which then we can use later. If you remember high school math, you might have to take system of equations and eliminate variables, use substitution, that kind of thing.
00:10:33.296 - 00:11:22.290, Speaker A: We're kind of doing the reverse here. We're adding in variables so that we can actually use more constraints of lower degree or that fit the format. Similar things happening on the right side with three wire. Planck but because three wire Planck doesn't allow an arbitrary number of variables in the system, there we have to include more constraints. All right. And compare those to the originals. If you showed me either of these circuits at the top here, I wouldn't know unless I sat down and did the math that they actually correspond to what's at the bottom right.
00:11:22.290 - 00:12:05.850, Speaker A: They don't look anything like it. And it's some work to recover those original equations. So the cure for all these problems is we need a circuit language that allows for arbitrary polynomial constraints. Then we can write arithmetic circuits in, like, a canonical way. That's universal. So we just get rid of the references to any constraint system, format, whatever, and we just write polynomials. After all, arithmetic circuits are just an expression of a system of polynomials.
00:12:05.850 - 00:13:24.110, Speaker A: So if we really want to write arithmetic circuits in their native language, we should just use polynomials that are not constrained in any way. All right, so that's easy enough. You can then take these polynomials and convert them into r one CS or plonkish constraints. You can do some things like taking any multiplication of variables and saving them in a new one, just like on previous slide. But we still have a problem if you're just using polynomials. What do you do about proof? System back ends with custom gates and lookup gates. I had hoped, and my hopes were quickly dashed, but I had hoped that we would be able to search through a list of constraints for constraints that match certain pattern and then replace those with a lookup gate or a custom gate so that we didn't need anything but polynomials.
00:13:24.110 - 00:14:00.400, Speaker A: I just really wanted this pure polynomial language. It's not quite doable. Searching through thousands, tens of thousands of constraints for particular patterns. Not the most efficient. And there's a pretty simple thing we can do to avoid having to do that. Um, yeah, I Basically Just Said this the arbitrary polynomial constraints aren't enough. We need some extra information.
00:14:00.400 - 00:15:27.850, Speaker A: We need to indicate if certain subsurcucuits or sets of polynomials could be replaced with a common custom gate or lookup gate. So all these problems gave rise to vampire. Vampire stands for well, the V stands for vampire, vampire aliased, multivariable polynomial, intermediate representation. So the design principles for vampire are we should have a representation of a circuit that expresses the intention of the circuit, and hopefully we can do that without including a bunch of details from the particular proof system that you want to use, or constraint system or the implementation of that proof system. It should just express the circuit itself. The circuit is one thing and it should be kind of encapsulated there so we can separate our concerns. A representation of a circuit should be flexible enough to allow for custom gates and lookup tables.
00:15:27.850 - 00:17:11.600, Speaker A: All right, so how does vampire work? Vampire accepts multivariable polynomial constraints of any format. So this achieves our first principle, which is polynomials in any format don't have any reference to our particular proof system or constraint system. So if we were rewriting those twisted Edwards addition formulas in vampire, we would just use the original formulas at the bottom. These are slightly modified from the formulas in the book because they usually write them as a fraction. But all you have to do is multiply both sides and you can recover these polynomials in this format with no division at all. But it basically looks exactly like the formula you would read out of a book, so it's much easier to check. And it all right for indicating lookup tables and custom gates, we just attach a little bit of extra information, which also is very natural to do, which is you can take a subsurfit, which is just a list of constraints, and kind of group them together and give them a name that you can reuse later on.
00:17:11.600 - 00:18:12.430, Speaker A: You definitely want this just for ergonomic reasons, you would want this, right? So the vampire language allows collections of polynomials or subsurcucuits to be given a reusable name called an alias. The aliases maybe macros and a more appropriate name for these, but then you don't get the nice acronym right. So, yeah, we can call these an alias. Here is a definition of two aliases. And we have check on SW curve. This takes two coordinates and checks that those coordinates are the coordinates of a point on a particular short wire stress curve. And you can see like, if you know formulas for elliptic curves, the polynomial that's there, that is the formula.
00:18:12.430 - 00:19:10.330, Speaker A: So nothing complicated there. And then we also have range for x. This is checking that x is four bits and you saw those equations earlier. Okay. Aliases can have a signature, kind of like a function signature, which indicates which variables you should consider to be outputs. One of the awkward things about programming and circuits is that arithmetic circuits don't really have outputs. It's not a computation where you put something in and get something out, but a lot of the computations you want to check are function like with outputs.
00:19:10.330 - 00:20:41.674, Speaker A: And so what we do is we have these signatures along with the aliases s, which indicate which variables should be considered outputs, which then lets us compose aliases as if they were functions with actual outputs. So that's what the x one y one, x two, y two arrow x three y three indicates. Um, so the the x three and y three would be outputs of this alias, outputs and quotes. Okay? So yeah, once you have outputs, then you can compose these as well. So here's twisted Edwards ad done twice. So we're adding three points together and getting a fourth as a result. So in the parentheses we have our first one, twisted Edwards add x one, y one, x two, y two because of the definition, that will expand out into these polynomial constraints and it will save the results, so to speak, in x three, y three, and then those will become the two first coordinates down here.
00:20:41.674 - 00:22:05.240, Speaker A: And there's the namespace thing going on here to prevent the x three and y three from colliding there. So this gives you a really convenient way of expressing circuits. It's fairly ergonomic, fairly readable. And also this solves our problem with lookup gates and custom gates. If you're using standardized aliases that a back end proof system knows about, then it can decide to replace certain aliases or subsurfits with a Lookup gate or a custom gate, because the original polynomial formulas are there. A proof system that does not have Lookups or custom gates can still use the exact same circuit format. But whatever is compiling this circuit into format that the back end proof system implementation needs can make those decisions for itself.
00:22:05.240 - 00:23:44.176, Speaker A: All right, so a compiler targeting and proof system that has Lookups can replace this four bit range gate with a Lookup table, a Lookup gate. Okay, so a benefit of this I wonder if I'm missing another image here, but DSLs or front end languages can have a consistent target to compile to. And then also on the back end side, various proof system implementations can use Vampire as a consistent source for circuits, and they also may be able to make certain decisions about how to interpret that circuit in a way that makes sense for its particular features. A complicated circuit can become fairly readable. This is an example from the Zcash protocol spec document. This is the Sapling output circuit. Fairly complicated circuit, not as complicated as the spend, but the output circuit is here we've got basically four lines and yeah, I'm missing more images.
00:23:44.176 - 00:24:31.190, Speaker A: That's a shame. If you look up the Sapling spec, there is a part where they say exactly what needs to be checked in the circuit for the output. It looks very similar to the lines that we have here. So you can write these and just visually see that it matches what you expect it to look like. So you can check circuits against a spec pretty easily. Also, a circuit written in Vampire can serve as a spec. If it's universal and canonical and it expresses the intention of a circuit, you could be able to use it as a spec itself.
00:24:31.190 - 00:24:47.690, Speaker A: Okay, I think that's it. Yeah, there's the Zcash protocol specification that I used in part of this. So I think we've got just a little time left. Are there any questions?
00:24:50.720 - 00:24:53.230, Speaker B: Oh, here's one. Hold on.
00:24:54.000 - 00:25:10.770, Speaker C: Yeah. First of all, fantastic. Great talk and really cool work. I have a question. So do you perform sort of sub expression elimination and extracting the common variables out, all of those kinds of optimizations at this level, or is it like something at a lower level than that?
00:25:13.160 - 00:25:53.730, Speaker A: Yeah, I think at this level, these expressions can compile to, like an AST type of thing, and we can do some manipulations there and yeah, you can also write circuits in multiple ways. Since Vampire does allow general ones. You can write a circuit in R one CS, let's say, and then the general one, and eliminate the variables and just check that they are the same. It's easy enough to do by hand if your circuits are small, but you can also do it automatically that way.
00:25:55.700 - 00:26:03.190, Speaker C: Can I have a follow up question? Yeah. How do you handle nondeterminism in this? Where do witnesses come from?
00:26:05.720 - 00:27:02.950, Speaker A: How do we handle nondeterminism and where do witnesses come from? All right. Yes. So the witnesses will come from certain initial inputs that are independent of everything else, and the proof system back end implementation will receive a list of those initial inputs, and then it should be able to figure out how to calculate any intermediate values and assemble the witnesses that way. Because these aliases least, most of them are definitely going to be like common things that are in a standard library. It should be able to know how to compute witnesses for those that has the initials. Okay, cool.
00:27:06.120 - 00:27:19.080, Speaker D: Two questions. First is just a very minor point. I noticed on the range check there is a word bool. X is bool. In this case, just another alias that would represent the constraint of binaryness?
00:27:19.240 - 00:27:35.424, Speaker A: Yes, I had more examples in there and I deleted some of them to save some space. Bool was one of them. Sure. Yeah. So bool x is an alias that just takes X times X minus X equals zero.
00:27:35.542 - 00:27:46.550, Speaker D: And then the other question was just in terms of implementation, how far along is this? Is this something that people could use right now? What's the sort of status in that regard?
00:27:47.160 - 00:28:02.970, Speaker A: It's very preliminary. We have some prototypes. They don't do all the things we want Vampire to do yet, so, yeah, we're just starting. So not usable yet, but we're working hard on it.
00:28:03.980 - 00:28:05.210, Speaker B: Any other questions.
00:28:16.780 - 00:28:53.496, Speaker E: Would it help, for example, that the languages like DSL languages or the other languages export part of the structure so that you don't have to write, like, another polynomial? So another system, would it help that the languages, the current DSL languages export information? So it says you export these constraints, and these constraints are for this template or are for this specific function. So this could help also to optimize and to get the information on that side.
00:28:53.678 - 00:29:44.740, Speaker A: Yes. Front ends. Yeah, we're not sure exactly how much a front end language might need to know about the proof system back end on the other side of our intermediate representation. But we were thinking that some amount of that information, a configuration of something like that, might be very helpful in a DSL to know about. They may be able to export that information into, like, a separate file that sits alongside Vampire. Vampire expresses the circuit, and any other information could be separate. That way you can have a circuit which is portable under different configurations.
00:29:44.740 - 00:29:50.750, Speaker A: But, yeah, front end might want to include some helpful information.
00:29:51.680 - 00:29:56.910, Speaker B: Very cool. I think we're actually at time thank you so much for the talk.
