00:00:04.060 - 00:00:11.010, Speaker A: I want to introduce Alex from matterlabs who's going to be talking about Zinc. Take it away.
00:00:11.940 - 00:01:02.172, Speaker B: Hi everyone. Yeah, I'm going to talk about Zinc and actually about the whole ecosystem which zinc belongs to. And this is the Zinc EVM compiler and language or virtual machine. And it's a little unusual for what the other speakers are going to discuss, because Zinc is not a circuit language for programming specifically zero knowledge circuits, but it's designed for smart contracts. And the interesting thing about ZkVM is, as the name suggests, we're going to support EVM compatible languages such as Viper and Solidity. So it will be possible to compile solidity into the Zinc VM and also zinc into zinc VM. Zinc is a separate language.
00:01:02.172 - 00:02:32.800, Speaker B: It's based on something went wrong 1 second. So Zinc is based on rust, and it's essentially a subset of rust, which was supposed to be circuit language, but we repurposed it to be a smart contract programming language. And the way things work in ZkVM is we compile zinc to LLVM and we compile solidity to Yule, and we compile Yule through all LLVM backend into the zinc VM, which gives us a tiny ram circuit. So if you're not familiar with tiny ram, it's an architecture where we have a single universal circuit which executes multiple operations depending on what program you load there. So we don't generate a new zero knowledge circuit every time we compile a program, we reuse the same fixed circuit and it just does the execution. So we prove the execution trace of a single program. The way I recently gave a talk about this on it global here is a spreadsheet that illustrates how it works.
00:02:32.800 - 00:03:42.420, Speaker B: You can go and change the comments here, and you can change the inputs, and the outputs will change. And each of the steps of computations is actually a single formula which depends on the inputs, which depends on the comments here and the operands, but it remains unchanged and we can modify the program. So what this gives us is during completeness. So let's see, we can execute programs of arbitrary length, we can do efficient branching, we can do efficient recursion, we can have unbounded loops, so we can have arbitrary conditionals with comparisons and jumps. The disadvantage of this approach is that it's quite expensive. For each computational step we have roughly 1000 x overhead, so we cannot implement very efficient operations. We need to separate heavy operations and combine them recursively with different circuits.
00:03:42.420 - 00:04:30.148, Speaker B: And we do it in ZK sync 2.0, where all the smart contracts are going to be compiled. So although those languages are designed for smart contracts primarily, they can be repurposed to build some logic of zero knowledge proofs which can be then recursively combined also in the circuits and proven. And they can have also very long execution trace where we recursively combine multiple circuits. But I think that smart contracts usage will dominate mostly. So that's a very rough overview. It's really hard to pack these ideas into five minutes.
00:04:30.148 - 00:04:34.950, Speaker B: So I hope for more questions which we can discuss now.
00:04:35.480 - 00:04:43.960, Speaker A: Sounds good. So one question is how do you check memory consistency in zinc? Also, did you want to invite your colleague to the stage?
00:04:44.780 - 00:04:46.264, Speaker B: Yes, he should be here.
00:04:46.382 - 00:04:50.990, Speaker A: Just add just to is it, what's the person's name?
00:04:51.360 - 00:04:53.736, Speaker B: Alex Zarubin.
00:04:53.928 - 00:04:54.670, Speaker A: Perfect.
00:04:57.200 - 00:05:31.380, Speaker C: Okay. Hi everyone. Hi. The question was about how we are going to check the memory persistence in zinc. Well, we are going to have some technique like borrow checking in rust. So we will have references and we'll have the compiler checking the validity of references at compile time and the rest will be handled by the VM in runtime.
00:05:32.680 - 00:05:34.004, Speaker B: So that's it.
00:05:34.202 - 00:05:41.340, Speaker A: I think Isaac, I believe Isaac's question was also to you, which is do you guys basically use the Cairo technique for your vm?
00:05:42.160 - 00:05:44.748, Speaker C: So what exactly as far as you.
00:05:44.754 - 00:05:48.396, Speaker B: Can judge how Cairo works? Probably, yes. Like it's similar.
00:05:48.578 - 00:05:49.404, Speaker C: Yes.
00:05:49.602 - 00:06:00.930, Speaker A: I think Shahar is actually here in the chat, so maybe you guys can talk about that too. Matthias asked, is there a library that focuses os square span programs also? I don't know if I said that right.
00:06:04.680 - 00:06:35.180, Speaker B: Not really. Zinc is a programming language which feels like a normal programming language. You don't have specific concepts for circuits, you don't have non determinism like whatever you run and execute will be automatically constrained for you from start to the end. So you can't really do low level manipulation of constraints.
00:06:35.600 - 00:06:41.304, Speaker A: Dara asked, what proving systems are you using and what's the cost of recursion of the recursion?
00:06:41.432 - 00:06:58.656, Speaker B: We use plonk with optimizations for recursion based on lookup tables and custom gates. And the overhead is I think something like 1 million gates or 2 million gates. I don't have it out of top of my head, but roughly around this range.
00:06:58.848 - 00:07:03.990, Speaker A: Cool. Are there any other questions?
00:07:06.300 - 00:07:33.570, Speaker B: So Andre is asking, if the thousand x overhead, how does it manifest itself on building a DAP, for example? It doesn't really, it translates to the cost of the call, which remains negligible because the part of the logic in smart contracts is very low. It's a very small fraction of the entire execution trace, so your contract will just cost you something, which is going to be around one or two cent.
00:07:35.940 - 00:07:39.360, Speaker A: Leonardo asked, any unsupported EVM opcodes?
00:07:40.980 - 00:08:01.480, Speaker C: Well, we support the entire Yule language, so there are no unsupported cases. There are some changes, like we adjust some Yule opposed behavior to our vm, but in general it's entirely supportive.
00:08:02.060 - 00:08:14.952, Speaker B: Cool and directed. That hire for plonk. I'm curious to her estimates. If you can post what you think it should be curious to also discuss later.
00:08:15.006 - 00:08:21.130, Speaker A: After the call, Kev asked, can you explain why LLVM was in the diagram shown? How does it relate to.
00:08:26.100 - 00:08:40.510, Speaker C: We are translating each language into LVM so we can facilitate the LVM optimizer completely and receive the most optimal bytecourse in the end.
