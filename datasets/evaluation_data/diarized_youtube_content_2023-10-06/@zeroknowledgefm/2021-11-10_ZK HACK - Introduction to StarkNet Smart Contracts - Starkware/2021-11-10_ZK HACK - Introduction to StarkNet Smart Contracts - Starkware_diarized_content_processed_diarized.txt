00:00:00.170 - 00:00:02.560, Speaker A: Should be able to see my screen.
00:00:02.930 - 00:00:04.000, Speaker B: Very good.
00:00:04.450 - 00:00:04.862, Speaker A: Good.
00:00:04.916 - 00:00:12.910, Speaker B: And to the audience, maybe we'll just do a quick thing. Is audio and video coming in good for all of you? Maybe just let us know in the sessions chat.
00:00:13.810 - 00:00:14.560, Speaker A: Cool.
00:00:14.930 - 00:00:21.838, Speaker B: Okay, I'm going to jump off. We're here. Let us know if you want us to jump back on for anything and take it away.
00:00:22.004 - 00:01:07.438, Speaker A: Wonderful. Thank you. So I'm going to take my operator voice and present this Starknet voting workshop that we'll have tonight. I'm Henry Liotto. I'm a developer advocate for Starknet, and I'm joined with my wonderful colleagues Ariel, who is a product manager for Starknet, and Jonathan, who is working on engineering on Starknet. So today we're going to explain to you a bit, what is Starknet, what is Cairo, and a few things about writing smart contracts in Starknet that you can use and build your applications on. So the first question is obviously, what is Starknet? So Starknet is a layer two of Ethereum.
00:01:07.438 - 00:01:51.440, Speaker A: It's a general computation platform which is secured by Ethereum. Layer one. It allows you to write smart contracts that are general purpose. You can write any kind of logic in these stocknet smart contract, and they allow you to manipulate Ethereum assets. These can be ERC 20, ERC 721, or really any kind of asset that you want to have on mainet. It allows you to interact very smoothly with l one. Actually, you can have logic implemented on l two that has fx on l one in a very short amount of time, meaning in a very short amount of execution time.
00:01:51.440 - 00:03:12.038, Speaker A: The cool thing about Starknet is that, contrary to Ethereum, where the execution of your transaction happens on every node of the network, Starknet pushes execution of your smart contract to the edge of the network, meaning then that only one node of the network, which is called the prover, actually execute the payload of your transaction and generates what we call a proof of correctness. In turn, every node of the network actually verifies the proof of correctness and updates its state. So this means intuitively, if the computational work is done by only one computer instead of all the computers of the network, it lowers the cost of execution. Because you're not bounded by the smallest machine you want on your network, and you still give extremely strong guarantees that the execution was done correctly. You're not trusting the proverb to do the work correctly. You're trusting mathematics that the job was done correctly. So lowering the cost of execution of your smart contract has two really nice side effects.
00:03:12.038 - 00:04:17.962, Speaker A: The first one is that you can scale the number of transactions you can do in a given block on l one. So you might have heard of the crazy numbers that DyDx is doing with Starkx, which is a bit different than Starknet, but I won't get into that right now. But basically some applications like Sorair or DyDX or Immutablex are able to pack a very large number of transactions in a single execution proof and lower the cost of a single execution. That's something we see today, and everybody needs it, right. But there's the other side of that, which is also very interesting, which is that you can do more transaction or you can do more complex one, and that's really hard to define, I can't really tell you. Oh, you could do this, you could do that, because it's still very much uncharted territory. And it's something that I'm really curious to see you guys explore.
00:04:17.962 - 00:05:25.720, Speaker A: So definitely go look for that revolving around Starknet. So you might have heard about Starknet, but you also might have heard about Cairo. So what is Cairo exactly? So Cairo is a language that was designed by Starquare. It's a programming language that allows you to write provable programs. So compared to a classical programming language that compiles to CPU instruction, Cairo compiles to arithmetic instructions which have specific properties. And these properties allow a very neat trick, which is if I show you a program, I show you its inputs and its outputs, and a proof of validity. You're able to verify the proof and be certain that the output is valid without actually executing the program itself.
00:05:25.720 - 00:06:15.534, Speaker A: And this is a paradigm that you might be used to in the blockchain world. The parallel I like to use is with proof of work. If I show you a specific block hash, you're confident that some work has been done without having to actually do the work yourself. Well, in a way what we do is conceptually the same. I show you a proof and you're sure the work was done correctly, but you don't have to do it yourself. Now the really cool thing with Cairo is that Ethereum has codes that allow the EVM to verify such proof. This means that you can execute a Cairo program off chain, send the proof on chain, and have a smart contract actually verify this validity proof.
00:06:15.534 - 00:06:50.750, Speaker A: So now it's not just you, a user, that I tried to convince that a program was executed correctly. I can prove it to an Ethereum smart contract. I can automate the shit out of my app. I can do a lot of things very cool with l one, right? So basically that's it. You write a Cairo program outside of l one and you can prove to l one that something happened. How does that link exactly to Starknet? Right, because Starknet is a computation network. What is the link with Cairo? Well, that's a really cool thing.
00:06:50.750 - 00:07:44.114, Speaker A: Starknet is a Cairo program. Starknet is an operating system which has a vm which is called the Cairo VM. And this VM has storage and it allows the execution of Cairo smart contracts inside this vm. Right? And so this whole vm is written in Cairo, and you can prove that this VM was executed correctly and that it executed all the sub payloads correctly. So you can prove to Ethereum layer one that your layer two network executed all its smart contract correctly. And that's really all there is to it. Right? So there's Cairo, which you can write general purpose programs with.
00:07:44.114 - 00:08:33.438, Speaker A: And we have implemented one specific program which is Starknet, which allows you to execute subkiro programs which can be arbitrarily complex inside this vm and have it interact with layer one. Right. So that's a general high level overview of what we're building. And yeah, I don't know if I have it on my slide, but where is this exactly? Like how can you use it and when will it hit main net? Well, it's been in testnet since July, and the alpha will hit main net at the end of this month. So you can start using it on Main net at the end of this month. All right, so that's for the conceptual introduction. Now about what we're going to be working on today.
00:08:33.438 - 00:09:17.550, Speaker A: Today is a hands on workshop. We want to teach you how to use a starknet smart contract because everything I've presented is nice, but you may still be thinking well, but still Cairo is not solidity. And you're right, we do have a transpiler in the work that will allow you to port your solidity contract to Starknet. But that's not what we're covering today. Today we're covering writing an actual starknet smart contract which will give you more efficiency when running your smart contract. And you'll see that it's not that different from solidity concepts and the layout and the synetics of using your contract. So you're going to learn about the general syntax of stocknet smart contracts.
00:09:17.550 - 00:10:34.802, Speaker A: You're going to learn how to import modules, which we called built ins. You're going to learn how to declare, use variables, create functions, have them interact, and we're going to talk also about composability so how you can write a contract and have it interact with another contract in stocknet while we will be doing all of this, and this is nice, we won't have time to cover everything we would like you to learn. So we won't cover, for example, l one to l two, communication, meaning how do you send a message? And how do you manage assets on l one from l two and vice versa? We're not going to cover how to build a front end for your Starknet app. And we're not going to get into detail about the Starknet architecture, like for example, the network architecture, what kind of nodes there is, how do you send info to the approver and all of this stuff. But be sure to, if you're, if this topic interests you, this certainly interests me. Be sure to join our community. You can read more about what we're building on our documentation.
00:10:34.802 - 00:11:17.250, Speaker A: And mostly you can join the party on Discord. We have a lot of content there, community calls and things like that. So be sure to join and you'll learn more about what it is we're building. Okay, so for the actual topic of the contract you're writing today, you're going to be working on a voting system. So some of you might be familiar with the first tutorial that is offered by Remax. When you start working on solidity, it's somehow similar. You're going to learn how to create a contract that will allow users to create polls, to register user for them to vote on polls.
00:11:17.250 - 00:11:39.802, Speaker A: And then you'll have functions that allow users to vote on polls, all nice and dandy. You will learn how to do functions, variables, get comfortable with starknet contracts and things like that. All right? And with that, my mission is done. I'm going to stop sharing my screen and I'm going to ask if Ariel can join and take it from there.
00:11:39.936 - 00:11:59.970, Speaker B: Wait, just before you do that, I just want to point out that in the Q a there's actually two questions that were asked. Maybe we could actually say them out loud for the video viewers later and maybe you could just help answer those. So the first one I'll ask, if that's okay, could you briefly explain what would change for the end user? Can the end user still use metamask?
00:12:03.750 - 00:12:54.930, Speaker A: The first tension to this is that this is very much to be defined, right? I mean, the actual user experience of Ethereum was not defined by the people who developed Ethereum. It was defined by people who built on top of Ethereum. So if you want to have a say in that, start building on Stacknet that being said, it will probably look like other l two s where you move assets from one network to the other, and then you'll have different tools, be them wallet extension, browser extension that will allow you to interact with the network. And depending on technical choices, you might be able to use metamask or maybe other wallets in the first versions. I'm not sure it's going to be metamask, but we're currently working on an implementation for account abstraction with Arjon and Openzeppen.
00:12:55.430 - 00:12:56.274, Speaker B: Very cool.
00:12:56.392 - 00:12:58.706, Speaker A: Does that answer the question? Sure.
00:12:58.808 - 00:13:16.086, Speaker B: The person can answer, since can maybe ask more in the chat if there's anything else. The second one is about is anyone building tools to generate ZK snark validators in Cairo? So maybe you want to. Yeah, because you're not really doing snarks, you're doing starks.
00:13:16.198 - 00:13:49.126, Speaker A: Exactly. I see Ariel twitching. So yeah, we're using a bit of a different primitive. We're not using snarks, we're using something that's called Stark. Not going to get into what is different between the two. That's an interesting question and you should come ask it, but I don't think that's the topic for tonight and I don't think we can transpire thing from circum Socratist. I'm not sure about this specific question, so.
00:13:49.126 - 00:13:54.374, Speaker A: Yeah, I don't have much to say about that. Ariel, do you have insight on this?
00:13:54.572 - 00:14:28.770, Speaker C: Well, I can say that there is some interest in developing snark validators in Kyle, actually as a Starknet contract, so I think there's some people who are actively working on it, but outside of Stacker. So this is still open. If you want to be the first one to have ZK snark verifier written as a startner contact, then go ahead, we'll be happy to publicize it. Same goes for ZK stocks while they chose in Cairo, which is also something that interests us.
00:14:28.920 - 00:14:37.474, Speaker B: Very cool. Henry, if there's any more questions, I see one more in the chat. Maybe you just want to answer in chat so that Ariel can continue with this presentation.
00:14:37.522 - 00:14:41.686, Speaker A: Sure. So Ariel will present the workshop and I'll be here answering questions.
00:14:41.868 - 00:14:42.694, Speaker B: Very cool.
00:14:42.812 - 00:14:44.294, Speaker A: Okay, thank you.
00:14:44.332 - 00:14:45.830, Speaker B: Take it away, Ariel.
00:14:47.790 - 00:15:11.840, Speaker C: Hey, so let me just share my screen. Okay, so I'm guessing you see the presentation. Okay, good. So first of all, before I'll get into what we're going to do today, I'm Mariela. I'm product manager in Starquare. And right now we should be sharing a few links in the chat. So the first link is to this notion document that you see right here.
00:15:11.840 - 00:16:02.534, Speaker C: So as we go through the exercise and different parts of the contract, you will have the code in copy pastable format. And for those of you who can't really wait for the answers, you have the complete code in the end of the document. Other than that, the place you're actually going to write your code is the Starknet playground, which is also you should be seeing the link in chat right now. So you'll have the example contact here. So feel free to just remove it, write your contact, and attempt to compile it. Okay, so I think that we're all set. Let's start talking about the actual contact that we're writing.
00:16:02.534 - 00:16:41.690, Speaker C: So I'm going to basically walk you through writing voting contact in Starknet. Okay, so let's start with the very basics of a starnet contact. So every starnet contact starts with a specification of a contact which is as opposed to a native Cairo program. So Cairo programs don't have this line. The second line that you see right here is a declaration of what built ins we're going to use. So Henry talked about it briefly. I'll just say that you can think of built ins as pre compiles.
00:16:41.690 - 00:17:15.254, Speaker C: These are certain functions who are not implemented in native Cairo for optimization purposes. So for example, you see right here that we're using the Peterson built in, which is the hash used throughout Starknet. So you'll later see how exactly we're going to use it. For now we're just declaring that it will be used somewhere. You can see more built ins right here. We'll talk about the CDSA built in later. After that you have the modules that we're going to use.
00:17:15.254 - 00:18:02.354, Speaker C: So here we're just importing different structs and library functions. For example the hash two function, which we're also going to use a bit leister, the verify ECBSA signature and a few others. Okay, so let's continue with the basics. So, storage variables, just like you would have them in solidity. You can define variables which are part of the contact storage, although with a slightly different syntax than perhaps what you use to form solidity. Okay, so here you can see the definition of two storage variables. You can see that there are storage variables by the storage VAR decorator, and this is the name of the variable.
00:18:02.354 - 00:18:32.858, Speaker C: So you can see that the syntax for declaring a storage variable in starknet is actually defining a function. So you can see that this function takes one parameter and returns one value. So the way to interpret it. To interpret it is that this is in fact a mapping from a key to a value. So it takes the key and it returns the value corresponding to that key. And for example, the second storage variable that we see here takes two arguments. So you can think of it as a nested mapping, mapping of mappings.
00:18:32.858 - 00:19:08.790, Speaker C: So you need to specify two keys to get the value. So simple as that. Okay, something else that you might be seeing here is the type of all keys and values which is felt. This is the basic type in Cairo. It's short for a field element, and you can think of it as analogous to un 256 in solidity. For our purposes, it's just a number from zero to a very large point. Okay, so let me just say what those storage variables represent in our context.
00:19:08.790 - 00:20:07.930, Speaker C: So public owner public key poll owner public key is actually a mapping between a voting poll id and the public key of the poll owner. This owner will be the only one permissioned to allow voters into this specific poll. So you can't vote on a poll unless you have the owner's permission, and then you have the mapping of the registered voters. So it's a mapping between a poll id and a public key of now some voter, and a mapping to a flag which indicates whether or not this particular voter is indeed permissioned to this board. Okay, great. So we're already getting into our first exercise, so here we're just asking you to add two more storage variables. So the first is voting state, which is a mapping from a poll id, and answer, which is the possible answer to the poll.
00:20:07.930 - 00:20:51.630, Speaker C: In our case, simply yes or no represented as a felt, and the value is the number of votes for this particular answer. And another variable, voter state, which indicates whether or not a voter has voted on a given poll. So we're going to want to be able to track the voter state so he won't be able to vote twice. So here again, the parameters is our poll id. The key consists of poll id and the voter's public key. Okay? So please take five minutes and of course let us know if there are any questions. Feel free to ask in chat.
00:20:51.630 - 00:21:53.060, Speaker C: Good luck. We'll have a few more of those as we move along. A question in the Q A, what is the difference between built ins and modules functions? So the modules and functions you saw after the built ins are actually implemented in Cairo, they are actually written as Cairo instructions, whereas built ins are not. So the analogy is pre compiled code. So these are not Cairo instructions that are getting through the entire compilation process.
00:21:58.950 - 00:22:37.220, Speaker A: So Ariel, I took liberty of copy paste, pasting some questions that were in the chat. Maybe what we can do is while people work, we can answer a few of these questions and then we'll correct the exercises. So if you want to focus on your work, please feel free to mute me. So the second question, actually I'd be glad if you can answer it. How is it to embed Cairo into other blockchains? What is the critical requirement? I'm guessing you need your blockchain to be able to verify starks. I'm not sure if something else was done on that.
00:22:45.750 - 00:23:09.930, Speaker C: I'll just add that. Okay, the critical requirements is being able to verify in that specific blockchain language the execution of Cairo programs. So yeah, just like we were able to write this verification in solidity. I hope I understood your intention correctly.
00:23:11.790 - 00:24:00.282, Speaker A: Okay, the next question we saw, interesting is what is the status of the solidity to Cairo transpiler? So the team at Nevermind is working on it. I posted a link to a Twitter announcement that was a few days ago. Basically they have small smart contracts transpiding, and they're able to have different smart contracts talking with one another. How complete will that be? Well, unatten mentioned that you're not going to get the best performance out of the Cairo VM using transpile code, but you're still going to be able to do a lot of things. Then somebody asked also who's going to run starknet nodes? And my answer was, everyone. We're building decentralized permissionless network, so that's the end game for us. There's not really an interest to build something else.
00:24:00.282 - 00:24:42.300, Speaker A: That being said, the infrastructure today is fairly centralized because it's in the process of being built. So that's what we're doing. So look out for decentralization steps along the deployments that we'll have of starkness. The following question is, what is the web free equivalent to interact with Cairo smart contracts from a web app or an automation bot? We have a few tools that are being built by the community that allow you to connect your program to starknet contracts. Ariel, what are the most relevant to you, do you think?
00:24:43.630 - 00:25:24.950, Speaker C: I mean, there are some projects for interacting with. Probably the permanent and closest one is Argent's wallet. We also have our block explorer which allows you to interact with Starknet and send transactions. There's the Cairo land, which will refer to it in the end when we give you links to additional resources. So there's no like a complete web3 analog, which is already mature library that allows you to completely interact with stuffnet, but it's coming along and also working on an API for node, some web3 analog. So yeah, stay tuned.
00:25:27.610 - 00:25:36.010, Speaker A: And I think we've passed the five minute mark, so maybe we can keep the relevant questions for what next? While you correct the exercise.
00:25:38.830 - 00:26:20.578, Speaker C: Yes. Okay, so let's go for the solution of the first exercise. I'll refer to the data availability question in our next intermission. I like this one. Okay, you see here that now the number of storage variables grew a little bit. So we have our voting state, which is a mapping from poll id and then a possible answer to the number of votes for that answer. And we also have the voter state mapping, which takes a poll id and the public key of a specific voter and returns a flag that indicates whether or not this particular user has already voted.
00:26:20.578 - 00:26:52.274, Speaker C: Sorry about that. Let me move to present mode. Okay, good. Okay, so now we have the storage that's ready to support our voting logic, but now we need to actually implement that logic. Okay, so this is the polish initialization function. So you can already see the external decorator right here. This means that you can interact with this contract by accessing this function.
00:26:52.274 - 00:27:48.254, Speaker C: Okay, so this function in its poll, it takes under the curly brackets you see three arguments. So this syntax is actually called implicit arguments, and it takes two regular arguments, which are the poll id and the public key of the poll owner. So to initialize the poll you need to specify the poll id and your public key to say a word about those implicit arguments. We're actually using those under the hood to access storage variables. So if you wonder what are they doing here? While you don't see an explicit mention of this, so that's why they're there. Okay, obviously more information on how exactly implicit arguments work can be found in our chiro documentation. Okay, so what is the logic of polish initialization? So we need to verify that this poll is not already initialized.
00:27:48.254 - 00:28:49.286, Speaker C: So for this we have our poll owner public key mapping. So we're just going to read from this mapping under the key, which is poll id. Okay, you see this let syntax, which simply defines a reference whose name is poll id taken and whose value is the return value of the read call right here. Okay, so now at this point I should mention that the default values of all mappings in starnet is zero. So unless you've initialized the poll with a nonzero public key, then this value is going to be zero. So here we're asserting that is poll id taken equals zero, meaning that no user has substituted his public key under this poll id. And if we were able to pass this assertion, then we are able to get to the next line which simply writes to this mapping our public key which we've received as a parameter to this poll id.
00:28:49.286 - 00:30:01.502, Speaker C: So note that this variable, so reading take is a function that takes one argument, the key that you want to read from, and writing takes two arguments, which is the key one to read from, and the value. If this was a nested mapping, then the number of arguments for write would be larger. Okay, so now we're simply returning after we've successfully initialized the poll. Okay, this leads us to the second exercise, which you have slightly longer time for. Okay, so now we want you to write the declaration of a function which is called register voter, who takes as parameters poll id, the voter public key, and two additional values which we're calling r and s. These are going to be the signature of the poll owner of this particular poll, which signifies that the poll owner indeed allows this particular voter inside this poll. Okay, and start implementing this function body.
00:30:01.502 - 00:30:44.460, Speaker C: So you shouldn't actually do the signature verification at this point, but you should simply read the current poll owner. We already saw how to read from storage variable. Later we're going to do some verification on it and then update the registered voter storage variable. So recall that we had a registered voters variable which indicates which voters are allowed under which poll. So it makes sense that the register voter function will eventually update the registered voters storage variable. Okay, so good luck and we'll talk about it in 15 minutes.
00:30:45.250 - 00:31:25.210, Speaker A: Hello again for the break. Advertisement how can we call these questions? Okay, so you have 15 minutes. I put a timer and we can answer questions in the meanwhile. So there are some questions. There's an easy one, I mean an easy one. There's one I can answer and then there's one I leave up to you. So the first question is, how does data availability work in Starknet? Do we need to keep all data on l one, or is it supported on Starknet l two? So the data availability problem is very much an area of research in the l two space.
00:31:25.210 - 00:32:21.818, Speaker A: In general, the way it works in starknet is that the way people usually think it works is that you need to push all transactions to layer one for them to be exploitable later on. We don't need to do that. So for example, that's the way optimistic roll ups work, right? You push the transaction that's called data and if needed you open them. This doesn't work like this in Starknet, because once you have the proof of execution. You don't need the transaction to reexecute the payload because you know the execution was done correctly. What you need to have on l one is the state. So the way Starknet works today is that every time we push a new proof of execution, we put state diff so that you can recompute the state from the past state and be sure that the transition that led to this new state is correct.
00:32:21.818 - 00:33:07.660, Speaker A: This is the first construction of starknet and it's what is called a ZQ roll up, meaning that you have all the data to reconstruct everything. But we're exploring how we can make this more efficient or tailor made to the user's need by exploring other constructions. So one is the lidium, where you basically just post the proof of execution, but you don't push the state diff to Mainnet. So this is obviously cheaper, but it has decentralization issue and we're mostly exploring the space between both. Like how can you publish some data, not everything. It's very much an area of research, and if you have meaningful contributions you want to do on that topic, please join the discussion with us on discord, where your ideas are valuable. So come and talk with us.
00:33:07.660 - 00:33:41.990, Speaker A: And related to that, there was another question in the chat, which was basically how are transaction ordered in Starknet? So the actual question I think is how does Mev extraction work in Starknet? And for that I would say that this is very much an open question. We're still designing that. There are a few things we're thinking of, and if you have ideas on how we could tackle that, please join the discussion. And there's this question I want to give to you, Ariel. Do starks and snarks do the same thing, just differently?
00:33:44.090 - 00:34:50.602, Speaker C: So I wouldn't say they do the same thing eventually. If you call the same things proving arguments about the program execution, then the answer might be yes. But one major difference I can think of other than the properties of the construction, the cryptographic assumptions and technical details like this, a difference in the statements that we're proving is that snarks are usually built around arguments of a specific size. So for example, circuits of specific size, while the star construction that we're using actually allows you to prove the execution of arbitrary programs. So my program can take 10,000 steps or a million steps, and I can still use the same protocol for proving it. Obviously the proof will require more resources. I'm eventually limited by my hardware, but I'm not limited at the protocol level.
00:34:50.602 - 00:35:40.422, Speaker C: It's not that if I'm moving to a greater number of steps, then I need to change my setup somehow. I don't need to resend any parameters. There's actually nothing different going on. I just send the program and start executing the protocol. And regarding the I just want to emphasize a point that Henry mentioned in the data availability area, that it's an important distinction that for example, for optimistic rollups, the transactions have to be sent somewhere because otherwise you can't submit a fraud proof. You must see the transactions themselves. While in ZK rollup you have a guarantee that the execution happened correctly and you just need to keep track of the current state in order to be able to produce new blocks.
00:35:40.422 - 00:36:22.200, Speaker C: So what we do currently in Starknet is publish the state diffs, not the transactions as call data, not storage on l one. And we're exploring different possibilities, perhaps different l two s that will hold the current state. So this area is still under research, but yeah, we're definitely exploring a wide spectrum of data availability solutions and our intention is that in the final design you will be able to choose the data availability trade off that is suitable for your ownings between, for example, price and.
00:36:27.370 - 00:37:09.618, Speaker A: Joff has a question. Will Starknet allow deposits, exchange and withdraw of nfts, or is it just for fungible tokens? Joff, free your minds from the shackle of the FM and from all the other ZQ solutions you've seen so far. You can do anything in Starknet. You can manipulate ERC 20, you can manipulate ERC 721, you can create different kind of objects. You can create specific custom application connectors on your smart contract on l one and have it be manipulated by l two. Starknet is a general computation platform. You can do anything on it.
00:37:09.618 - 00:37:36.570, Speaker A: And as long as you define the way l two and l one communicates together, then you can exchange arbitrary messages. So you can do anything. And I know it's not a very precise answer, but the answer to your question is yes, you can manipulate nfts and you can do a lot of things with that. Not sure if you want to add something, Ariel?
00:37:37.070 - 00:37:40.666, Speaker C: No, I completely agree. If you like to move nfts, then.
00:37:40.688 - 00:38:40.398, Speaker A: Yeah, you can move nfts the way the bridge works between because. Right, we're still first seven minutes in, so I hope all of you guys are working well, we still have time, so maybe I can talk a bit about the l one to l two bridge. How does it works exactly? So the way it works is that the bridge of Starknet actually takes as input a proof of execution and a state diff. And it will also have an inbox and an outbox of messages. So your l one smart contract can go right into this bridge. A message which can be arbitrary data that once the block is picked up, will be picked up by l two and sent to l two in an inbox in L two. And you can have your smart contract on l two pick that message and execute it, right.
00:38:40.398 - 00:39:38.686, Speaker A: And it works the same way the other way around. You can have your l two smart contract send a message to l one. And once a new state is committed on l one, the fact or the message that you're sending will be pickable by your smart contract on l one. So you can implement any kind of logic, right? It can just be simple booleans, it can be arbitrary delta, you can RlP encode, it can be whatever you imagine. So the same question after that is, is it the same with ERC seven seven, ERC 1151? I'm not sure what these are to be honest, but since the bridge of communication between Starknet and l one is general purpose, if you designed a way to exchange things, you can do. So that being said, the bridge is general purpose. We published code for an ERC 20 bridge.
00:39:38.686 - 00:39:58.550, Speaker A: I'm not sure if it's ERC 721, but I know some people from the community are working on that. So you'll be able to use for standard bridges out of the box, but other than that you can design them. I was going to say fairly simply, maybe I'm not objective, but it's doable.
00:39:59.770 - 00:40:10.560, Speaker C: Just mentioned that Openzeppelin are working on developing standard contacts, and you can just view them on GitHub. You can see how ERC 20 is implemented by them.
00:40:15.010 - 00:41:05.050, Speaker A: Yoni is asking how complex can startnet program be? Is there Starknet gas? So these are two questions I'm going to tackle. One and then the other. So the first one is, how complex can a Starknet program be? Arbitrarily complex. You might have seen if you're following us on Twitter, we pushed some content from a guy called guilty Gioza, which is down doing like physics simulation. And you can see things move on your screen. It looks nice, there's a free body problem and it looks cool, but what is going on exactly. So when you have a game on the blockchain, usually what you have is that you will have the transfer of assets that will happen on chain, but the actual calculation for the game will happen off chain, or if they happen on chain, it will be fairly simple computation.
00:41:05.050 - 00:41:43.254, Speaker A: The cool thing about Starknet is that since you push execution to the edge of the network, you are able to have very complex calculation be executed and prove that the execution is correct. So I want to think about worms too. I'm sure I'm not the only one who played that game, right? You have small worms and you shoot at each other. Try to imagine writing a smart contract program. I mean, try to imagine writing a program that calculates the trajectory of a bazooka shoot and then it hitting a wall and all the shrapnels going around. Hard but doable. Now try to imagine writing this in solidity.
00:41:43.254 - 00:42:46.000, Speaker A: The first thing you're going to think is like gas wise, it's not doable, it's not going to work. Well, you can write these things in Starknet and only one node would execute it, and it will prove to you that the shooting of your bazooka had this actual trajectory and this exact kind of damage. So that's the kind of complex simulation computation we're talking about. And that's what guilty Gioza is actually working on, is working on a physics engine with which you'll be able to manipulate objects and have them have trajectory and interact with each other, which is a very interesting primitive for gaming, because now you have games that you're able to play on chain with the actual gameplay happening on chain with verifiable contracts. So that is for the complexity part. Now, the second question is, is there Starknet gas? The shortest answer is not yet. Of course, computing things has a cost, so there will be cost associated with your program, with executing your program.
00:42:46.000 - 00:43:30.430, Speaker A: But this is not fully defined as of today. In the beginning of the network, it's not going to be very expensive, but then it's still an area where we need to define exactly how we're going to charge users for that. One thing I want to mention regarding that is that in general, in starknet, computation is cheaper than storage. Since you're updating storage on l one, this has a higher cost than computation. That's why calculating a trajectory is cheaper than actually storing the results on chain. I don't know if you want to add something to that, Ariel.
00:43:33.730 - 00:43:36.590, Speaker C: That sounds accurate.
00:43:38.450 - 00:44:24.378, Speaker A: So the following question is, if one node can execute the transaction and others are verifying how race conditions are prevented. I mean, if Alice makes a swap on one node and Bob makes a swap on another, how the common state is built. Well, you'll have a prover which will basically compute the state and push the proof of execution. So proving will happen at one entity. How this entity is chosen and how the order of the transaction is chosen is still an area of research. And if you want to learn more, do join the discussion on discord to learn more. And then we still have a minute and a half, so I'm going to skip on Snark versus Stark.
00:44:24.378 - 00:45:12.586, Speaker A: Somebody asked the question earlier, I don't know if you heard the answer. If you have more questions regarding Snark versus Stark, please give more details about what you want to learn. And the following question is, how does the business model of darkware work? How do you guys plan on monetizing your work? It's not a technical question, but it's a good one. It's still an area of research. We figure that if we build something cool that people use and has usage, something will show up. Starkware is a company developing ZK roll ups, but Starknet will have a life on its own eventually. So the objective is not to have an enterprise platform permission, it's to have a decentralized network.
00:45:12.586 - 00:45:24.740, Speaker A: So we'll see what happens. And we still have 30 seconds to go before correcting. So I'm going to let Ariel correct the exercise thing.
00:45:26.790 - 00:46:38.026, Speaker C: Just before I start, let me answer can one hope to understand stocks without getting very deep into the math? So it depends, what is your motivation? If your motivation is to understand stocks and understand our protocol, then the short answer is no. You're going to have to get into the papers and understand all the definitions they're relying on and so forth. But if you want to develop for Starknet and write Starknet apps, then you don't care about it. It's just like saying that a solidity developer doesn't need to know exactly how transistors work. So from your point of view, it's just an elementary part in the system which works, and you can walk around it. So an experienced solidity dev knows the evm very good, but he doesn't really care about transistors and how stuff actually running. So in that it's sort of analogous to a stacknet developer which really knows Cairo and really understands the Cairo VM, but has no idea about starks and how exactly the proof of execution works.
00:46:38.026 - 00:47:43.066, Speaker C: I mean, those things are pretty much orthogonal. Okay, so I'll move on to the exercise solution. I hope you all got it right. Okay, so this is the declaration of the register voter function. So you see, our regular implicit parameters are still with us, and we take as parameters the poll id, the public key of the voter, and rms, two additional values which I remind you represent the signature of the poll owner on this particular voter public key and the poll id. So the signature should imply that the owner of the poll has given permission to this particular voter to vote. Okay, so you see that the last line in this function will eventually be to add this voter to the register voters storage variable.
00:47:43.066 - 00:48:23.222, Speaker C: So we're going to update and update this storage variable under the key poll id and the public key of the voter. And we're going to write one. So one implies that this voter is registered to this poll id. Okay, so now to the more advanced verification. Okay, so first of all, we're asserting that this poll is initialized. So how are we asserting that this poll is already initialized? So you can't register voter to an uninitialized poll, obviously. So we simply read the poll owner from the poll owner public key storage variable.
00:48:23.222 - 00:49:13.394, Speaker C: So we're reading the public key of the owner and we're asserting that it is different than the default value, reminding you all that the default value is always zero. Now, so I have the initial part, the less part. Now all that remains is to verify the signature. So first of all, we need to get the message that the owner supposedly signed on. So again he should sign the poll id and the public key of this particular voter. So how it works in ECDSA is that you first hash the message and sign on that hash. So this is why we're using the library function which we imported before hash two, which hashes two arguments to one and we feed it the poll id and the public key of the voter.
00:49:13.394 - 00:50:02.842, Speaker C: Again, you see the simplicity argument here. The left side is simply the formal name of the argument hash pointer, and we're substituting to it this Peterson pointer, which represents our hash built in again. So if you want to really understand how implicit arguments work, I refer you to the chiro docs. Okay, so now we have a reference to the result of hash two. This message is now a reference reference to the result of the hash on the poll id and the voter public key. And we're ready now to verify, to actually verify the signature. So we're just calling another library function verify ECDSA signature on what arguments? The message the public key and which public key? The public key of the owner because he's the one who's supposed to sign.
00:50:02.842 - 00:50:43.734, Speaker C: And finally, the signature values the r and the s. So two library, two important library functions here, hash two and verify ECDSA signature. And we verified everything at this point. So we verified, the poll is initialized, we verified the signature. Now we can update the storage variable and actually register the talked about. Okay, we didn't mention this. So this is another built in the ECDSA built in, which is used in this verify ECDSA signature function.
00:50:43.734 - 00:51:39.530, Speaker C: So again, these are things that happen behind the scenes. Okay, we're asserting that the value is not zero, and this we actually talked about. Okay, so now we're adding another function to the voting logic. You can see here a new decorator, the view decorator, which indicates that this particular function is not allowed to change the contact storage. So this is a read only function. Okay, and what does it take as an argument outside our standard implicit arguments that allow accessing storage variables? So it takes the poll id as an argument, as a key, and it returns now two values, the number of no votes and the number of yes votes. So as the name suggests, it simply returns the current voting state.
00:51:39.530 - 00:52:23.800, Speaker C: Okay, so right now it's your job to implement the body of this function and you have five minutes for it. If you don't want to know exactly, if you don't want to get in for this, then stop here. And if you do, then it simply requires you to read twice from the storage variable, which we defined previously. And we will keep track of it, we will maintain it later. So far we haven't really maintained it, but assume that this storage variable indeed maintains the current state of the vote. Okay, so please take five minutes and we'll continue with our regular habit of answering questions.
00:52:25.310 - 00:53:01.700, Speaker A: Launch the timer for five minutes. So I've seen some questions that were answered in the chat, so do look for answers in the chat too. So one question is, how big is the overhead for stocknet programs in comparison to native implementation? For the example of worms, is it ten x or 100 x or something else? I don't have an answer for this question. I don't know, Ariel, if it's clear to you and you want to answer it, otherwise, I'll just keep it and look for the answer and keep it later.
00:53:03.290 - 00:54:15.994, Speaker C: Talking about the actual size of the program, like bytecode, you do have some overhead because Cairo is, let's say, lower level than, for example, Python, and you don't have libraries that implement all sort of numerical logic yet, so there is going to be some overhead in the program size, but you don't really care about that in terms of execution. If we're talking about execution differences, I can't really give you a concrete number, but again, we want you to get the mindset that computation is cheap and storage is the more expensive part. Computation is cheap because eventually the only overhead here is submitting the proof of execution, which is much smaller, so you don't really care how long the computation took. So I'm guessing 100 x is exaggerated, but I can't really give you more concrete estimates at this point.
00:54:16.192 - 00:54:58.250, Speaker A: Cool. I answer one quickly. Does the tooling automatically create a Zk verifier in solidity for l one? No, what happens is that what you're doing in starknet is proved in the context of Starknet and the execution of Starknet. So the execution of your all layer two is proved to solidity. So there's one contract where you prove everything that happens on Starknet and this place where you verify that everything is correct as an inbox and outbox message. So that's from a solidity developer perspective. All you have to do is handle messages that go to and from l two.
00:54:58.250 - 00:55:41.826, Speaker A: You don't have to worry about building a verifier, having a circuits, having a setup, things like that. You just need to handle messages, which is nice. I'll answer another one, which is what tools are there for developing TDD? I'm not sure if that's a typo or something, but basically for developing Cairo contracts. Hard hat solidity. So there's a set of tools that is being developed by the community and other partners. You'll find plenty of information in the chat. We're going to publish a link with community tools and do join Discord because there are new people joining quite regularly actually, and sharing their tools.
00:55:41.826 - 00:56:06.030, Speaker A: And so everything is built. I'm not going to lie, it's a bit more nascent than, it's fairly more nascent than solidity, but there's a lot of tooling emerging. So there's a lot of things to simplify your life. And this one I'll let you. Ariel, are the costs of function arguments in Starknet meaningfully greater than, say, inputs to sharp? Is that explicit?
00:56:07.570 - 00:57:16.306, Speaker C: Not sure exactly what you mean, because sharp, it actually stands for shared proverb and it is a service that we run at Starquare which allows us to prove simultaneously the execution of different programs. So now sharp is in production with several applications. So we have immutable x and soil, I believe. So these are both two apps which both require different proofs of completely different programs, but using Sharp, they can share the burden of the proof. So this is unrelated to what we're doing here with writing a starnet contract. You could ask eventually the execution, the advancing of the state in starknet. Running the Starknet OS, which Henry mentioned briefly at the beginning of the workshop can be proven in sharp, but these are two different type of objects, like the contact function and sharp.
00:57:16.306 - 00:57:45.360, Speaker C: So I can't really answer that. And just about test driven development. So we have our testing framework, which is documented in our site, and some of the tools that Henry mentioned are building on top of our testing framework. So yes, we do have testing environment and it is pretty dynamic. We improve it as we add more features to start it.
00:57:46.050 - 00:58:27.914, Speaker A: Okay, I'll answer one last one very quickly before we move on. To answer the question by Rahul is how often does the mailman come from l one to l two? So how do you think about data availability and set submission in terms of frequency? And correct me if I'm wrong, Ariel, right now you have to think there's a state committed every. I think it's like in terms of hours, right, every 8 hours. But this is pretty much something that may evolve with time. If we have more volume or more necessity, this frequency can probably increase. Am I saying something stupid?
00:58:27.962 - 00:58:40.480, Speaker C: Is it accurate right now? It's in the order of ours. It can be improved with, for example, recursion if or when we will have it.
00:58:42.290 - 00:58:51.380, Speaker A: Wonderful. So in the order of ours for now, but work in progress and we want to drive it lower. Okay. With that, let's go to the answers. Thank you.
00:58:52.070 - 00:59:32.190, Speaker C: Okay, great. I'll just also have faster checkpoints than actually submitting the pool. So, poof. Accepted on ethereum will be the greatest degree of finality, but we'll have something before that for apps which need to be more live and don't really care about waiting for the proof and can settle for load the gear finality. Okay, so let's go to the answer. So, hope you were all able to do it. So we're just defining two references, simply reading from the voting state.
00:59:32.190 - 01:00:07.900, Speaker C: Again, notice the keys that we send. So, to get the number of no votes, we send the poll id and zero. And to get the number of yes votes, we send the poll id and one, and we simply return those two values. That's it. Okay, let's move on to now verifying the vote. So far we verified things that are related to the owner of the poll, but now we actually need to verify things that are related to the vote itself and the voter. Okay, so we have the verify vote function.
01:00:07.900 - 01:00:45.670, Speaker C: And note that this function has no particular decorator. This means that it is a helper function, which we will call in one of the either external or view functions. Okay, so again, the implicit arguments that we're used to and a few standard explicit arguments. The poll id, the public key of the voter. Now again, notice the difference between the owner and the voter. The vote, the value that he is intending to vote. And again, two values representing the signature now of the voter rather than the owner.
01:00:45.670 - 01:01:23.570, Speaker C: Okay, so the first verification is simply that the vote itself is binary. It's either zero or one. And we can verify this by asserting that this multiplication equals to zero. This will only be zero if vote is either zero or one. Okay, so now we're actually coming to the next exercise, and you now have to implement the rest of the verification. So first of all, you need to verify that this particular voter is allowed in this particular poll. This is why we're maintaining the registered voters storage variable.
01:01:23.570 - 01:02:04.420, Speaker C: The next thing you need to know is that this particular voter is not attempting to vote twice. This is why we're maintaining the voter state. And lastly, you need to verify the signature. So you already saw how to verify the signature, but right now it's the signature of the voter rather than the owner. And think about what he's signing on. So what he needs to sign on is the poll id and his vote value. Nobody else should be able to vote in the name of this public key.
01:02:04.420 - 01:02:17.990, Speaker C: Okay, so you have 15 minutes to implement the rest of the functions. You can see the previous code in the notion, document, notion, document. And good luck.
01:02:19.850 - 01:03:05.854, Speaker A: Thank you, Ariel. Putting the timer back. So I'll take some questions, and then there's another thing I want to talk quickly about. So the first one I'm going to take is, what are your thoughts on ZK sync and their implementation of a ZK roll up? Well, we believe l two s are the future and ZK roll ups are the future. So we're always happy to see more people interested in the same topic and building toward the same decentralized future we are. So we're excited to see what they will release once it's visible and usable. It's always interesting to have the perspective of other teams on the same topic we're trying to solve.
01:03:05.854 - 01:03:23.100, Speaker A: So very curious to see what they have once they release it. And the second question is, would writing a GPU shader like program to manipulate a large memory buffer be possible? Ariel, is it something?
01:03:23.870 - 01:03:28.586, Speaker C: I have no idea. What exactly is the meaning here?
01:03:28.768 - 01:04:05.810, Speaker A: Me neither. Okay, so let's put this in the back of our head, and if Yoni, you can give more insight as to what it is you want to build, please write it in chat and we'll try to answer it. Thank you. And the other thing I wanted to mention really quickly that I saw somebody in the chat saying like, whoa, this is interesting. You can do more stuff, more computation. And yes, it is the case. Computation in starknet is fairly cheap.
01:04:05.810 - 01:04:57.160, Speaker A: It's very cheap. So you can do a lot of stuff. And I'll give you one brain teaser about things that you could do. Right? So imagine you want to do a snapshot to have people vote depending on how much token they hold, right? In order to do that snapshot, you have to do it off chain and then write some tool that will analyze this block and then authorize people to vote or not and not. And then you'll have to collect these signatures off chain, and you'll be able to produce a reliable image of who was allowed to vote at a point in time and who actually voted. Right. But there's obvious limitations to that because you can do it off chain, but you can't really have a smart contract actually implement like verify this kind of thing.
01:04:57.160 - 01:05:47.194, Speaker A: You can't give to a smart contract the state of a block in the past, analyze who was allowed to vote or not and who voted what. This would be way too computation intensive. Well, you can do that in Starknet. You can give to starknet the content of block, an Ethereum block in the past. You can have Starknet verify the content of that block, verify the state of specific smart contract in that block, and then have different mechanism in place. You can verify an Ethereum signature. So you could collect data off chain and have Starknet smart contract produce a proof that somebody did something, depending on something that happened on l one, and produce a proof on L two that can eventually have actions on L one.
01:05:47.194 - 01:06:14.000, Speaker A: And that's the basic concept behind something we presented a few weeks ago, which is called Stark Vote, which is a partnership with Snapshot, which you guys might be familiar with. This specific example does give you an idea of how you can exploit l one data on l two. I don't know, Ariel, if I've said something you want to correct, or if you have something you want to add on this.
01:06:14.710 - 01:06:15.460, Speaker C: No.
01:06:16.950 - 01:07:03.890, Speaker A: Perfect. So who's going to be the first to write a bitcoin miner on Starknet? I'm not sure you could mine on Starknet, but you can definitely interpret the content of bitcoin block on Starknet. So that's exciting. And Yoni gave more information regarding GPU shaders. So think running a step of inference for a machine learning model or frame in a 3d game or Photoshop like drawing program. So I think what you're saying is, how complex can the execution be? And if we can run logic, that is akin to what you would run on a GPU in a computer. Yeah.
01:07:03.890 - 01:07:09.458, Speaker A: Do you want to comment on that, Ariel? I think the question basically is like how far can you go with the.
01:07:09.464 - 01:08:02.994, Speaker C: Complexity on if your program requires, I don't know, thousands of dollars to run on AWS, for example, then it's probably going to be harder to implement it in a provable way. So you don't have the overhead, the insane overhead of Ethereum, but you still do computation. So if you're doing a very heavy model training, then you're probably eventually going to get into the same barriers that you would if you were to use your own very strong computer. So there's no magic. There's magic in the proof aspect, but somebody out there will have to execute this computation, just not. It won't have to be everyone. Yeah, I'll just say something about privacy.
01:08:02.994 - 01:09:18.474, Speaker C: By the way, there are no syntactical questions, so I'm guessing that's because you're all writing it very easily and the code is compiling for all of you. So about the privacy question in our implementation right here in this voting example, then we don't do anything related to privacy. But I will say a word about using, for example, ZK snarks for private voting. So you could use ZK snarks or starks for privacy. The technology of the proof isn't really important here. What is important? That when we're talking in a layer one and layer two context information, having a zero knowledge proof is far from enough, because somebody sends the transaction to a mempool eventually. So what point does it have to publicly send my vote to some poll, but having the proof expose no information on it? I mean, it's a little silly because, okay, I won't try to read it from the proof, I will simply look at the mempool.
01:09:18.474 - 01:10:20.560, Speaker C: To implement a system which truly exposes no information, you need more than the proof to not leak any information. This is similar to Zkesh, which on top of using ZK proofs, they also had a complete design in showing privacy. So the ZK proofs were just one element in a much larger system, a crucial element, but just one element. So you could implement something like this on top of Starknet. Right now, our proofs are not technically ZK, although I believe it's not a very practical task to extract information from it. But if you care about privacy, you need to do stuff in the business logic of your particular application, because if you simply expect someone to send you the transaction, then obviously you'll get no privacy, regardless of what proof you're using.
01:10:21.590 - 01:11:12.254, Speaker A: There's another question in the usage workflow. Can I deploy my own Starknet or shall I use the one provided by Starkware? Well, should you use Ethereum or run your own chain? You can do both. It depends on your use case. But in most use cases for app developers, you want to be on Ethereum mainnet, right? So you probably will find more apps and more content and more infrastructure on the public Starknet. And when you say the one provided by Stark, once again, I want to stress that right now we're developing it and we're maintaining it, but this won't stay like this forever. Eventually it's going to have legs of its own and it's going to be outside of our control. So we still have some time.
01:11:12.254 - 01:11:24.790, Speaker A: Is there anything to say about accounts on Starknet opens up and uses? So can you talk a bit about account abstraction Ariel on Starknet?
01:11:26.890 - 01:12:18.742, Speaker C: Let me read the question again carefully. Okay, so we are still working on the specific implementation details of account obstructions. We're also working closely with open Zeppelin. You can see their initial account contact right now. You can just go to the repo and see how they implemented it. So yeah, they do use get caller address which returns the contact address calling you. How does this work with it accounts? So if you want to bind your account contact with your eth account one way for example to do it, but to just have a field in your contact account which represents your Ethereum address and somehow work your logic around that.
01:12:18.742 - 01:12:44.240, Speaker C: So if we're going down the account contact routes where your account is represented by a contract like any other, then you can contain information regarding your Ethereum address on it as well. And you might require ethereum signatures which correspond to the public key or saving there and this sort of stuff.
01:12:46.530 - 01:13:41.060, Speaker A: So there are a few programming questions that I will let Jonathan maybe answer. There's another question which is interesting, is ethereum gas helps preventing getting the smart contract in an infinite loop? What mechanism prevents that on Starknet if not using gas? So two aspects. The first one is this is still an area of discussion and experimentation. So there are very interesting discussions regarding this very topic. So do join the discussion if you're interested and you have good ideas on that. I'll just say that when you run a Cairo program, there's a number of steps that you need to execute, and you can put a cap on number of steps that you'll allow in your program, I think. Ariel, do you have something else to add on that topic? How do you prevent grieving attack?
01:13:43.830 - 01:13:45.780, Speaker C: Not right now.
01:13:48.550 - 01:14:13.242, Speaker A: Okay, cool, thank you. Then there are programming questions, which is I guess related to the exercise, and I think it's easier if we answer this in writing. So do check the answers, all questions.
01:14:13.376 - 01:15:06.778, Speaker C: So first of all, notice that Yoni is answering questions in the chat, so take a look there as well. So our compiler currently doesn't support, or I'm guessing that it's not conceptually hard to implement, it's just not a top priority. So yeah, this is why we're using this particular assertion here. Okay. And regarding the previous question, so we will have some DOS prevention mechanism that will allow you to charge somehow for computation. For example, if somebody infinite loop, we can limit the number of steps. There are some technical obstacles which we are currently dealing with, but you can expect some notion of guess.
01:15:06.778 - 01:15:23.370, Speaker C: Definitely in the alpha version we won't have it just yet, but you can expect something along those lines on time.
01:15:26.080 - 01:15:27.692, Speaker A: Still minutes to go.
01:15:27.826 - 01:16:14.232, Speaker C: Okay, no problem. So maybe I'll use those two minutes to refer to the last question about implicit arguments. So essentially we need to have access to them, and being able to update those are pointers. And every function needs to, every function that accesses the storage needs to be able to track the current location of those pointers. So under the hood, it's not particularly sophisticated. Under the hood, what's happening is that those variables, the updated value of those arguments, is actually returned. So this is a helper function, it receives implicit arguments, and here it looks like it doesn't return anything.
01:16:14.232 - 01:16:58.760, Speaker C: But under the hood those parameters actually changed and they're returned. It is just so the user won't have to always return explicitly those arguments which are not directly related to his business logic. So yes, they do appear here, but you can think of it as they only appear once in a sense, and from that on they're just implicitly passed to other functions that make use of them. So I hope that sheds some light on it. Again, for more complete explanation, see our docs.
01:17:12.760 - 01:17:20.760, Speaker A: And we are at about 15 minutes, so we can now with the correction of the exercise.
01:17:21.340 - 01:18:08.928, Speaker C: Okay, great. So again, I hope you all got it right. And for those who want to enjoy the show, this is the first verification that the voter is already registered to the poll. So we're maintaining the register voter storage variable. So we simply read from it and assert that it is nonzero. So it is a flag, recall that it is a mapping from a poll id and the voter public key to a flag which indicates if the user is registered or not, then we do almost the same thing to verify that the user hasn't already voted. So we're going to voter state and we're reading the flag which says whether or not the user has already voted.
01:18:08.928 - 01:18:59.372, Speaker C: And again we're asserting that this value is zero. Then we asserted that the value was not zero. Now we asserted that the user hasn't voted and now we have the verification of the voter signature. So exactly like the previous signature verification, only now the message that we're signing on is the hash of the poll id and the vote. Okay, because the user is signing on the pair poll id and vote and obviously the public key who's with respect to we're verifying the signature is the public key of the voter. In the previous verification it was the public key of the owner. And again we're passing those rn tests.
01:18:59.372 - 01:20:02.936, Speaker C: So we will only pass this verification if the signature is valid. Okay, now finally we're ready to implement the actual voting logic. So we have the vote function which takes as explicit arguments the poll id public key of the voter, his vote and r s representing the ECDSA signature. And we first of all call our helper function which does all the verification, checking that the user is registered to the poll, checking that he didn't already vote, checking that his signature is valid. And if we were able to pass this line, this means that everything works and we can simply update the voting state. So we're reading what is the current number of votes for the option that this user wants to vote to. So we're reading from voting state and the parameters we're sending is the vote of this particular user.
01:20:02.936 - 01:20:35.712, Speaker C: So recall it's a mapping from the option to the number of votes. So we're reading this mapping in this particular option and then we're writing to this same storage variable, the updated value. So the same key, the poll id and the vote of this particular user. But now the value is the current number of votes plus one. And one thing before we're done is update the voter state. So recall that the storage variable we need to maintain. So we need to remember that the user has already voted.
01:20:35.712 - 01:21:15.990, Speaker C: So we're setting this mapping to one and this is actually now we have our voting logic complete. Okay, great. So now we move on to the next part, which is composability. So here we're basically going to show you how to interact with other spark net contracts. Okay, so this is a dummy contract for vote recording. So think of it as a contact which holds the result of all polls. Okay, it has one storage variable, a mapping between a poll id and the result.
01:21:15.990 - 01:21:56.204, Speaker C: It has one external function and one view function. The external function record takes as arguments a poll id and the result, and simply writes records the result. And the get result does exactly what you would expect. It reads the current value from the mapping and returns it. So I know if you want to yell that there is no verification here and anybody can call record even if he's not the poll owner. So yes, this is just dummy contact to demonstrate composability. But you're essentially right to make this system meaningful.
01:21:56.204 - 01:23:06.784, Speaker C: If you want vote recording, then you probably need to verify the signature of the poll owner. Okay, so how can we interact with this new contract from our primary voting contract under which we implemented all that logic before? So we're going to add three elements to our contact, basically. So the first one is another storage variable, which is simply a single felt value, a single field element. You can see it from the fact that this function takes no arguments or there's no key required. It is not a mapping, it is just a single variable. And this storage variable represents the address of the recorder contract. Okay, we will also add a constructor to our voting contract, which will take as an argument the address of the recording contract and save it to the storage variable.
01:23:06.784 - 01:23:54.900, Speaker C: So now, as opposed to the previous situation, to deploy this contract, we're going to have to send an argument. This argument will be the address of the vote recorder contract. Okay? And the constructor simply takes this address and stores it in storage variable, very similar to how you would do this sort of things in solidity. And then we also have to define the interface of the contract that we're going to use. So here you see the contact interface, decorator and special syntax namespace, and the name that we're going to use to actually call the contract. And here we define the function that we're going to call. So we're going to call the record function, which we've seen before.
01:23:54.900 - 01:24:40.520, Speaker C: It takes a poll id and the result. Okay, so now having those three parts incorporated in our contract, we're ready to interact with this recording contract. Okay, so let's see how this is actually done. So now we're adding a new function to our voting contact. It is called finalize poll. Again, the implicit arguments which we're used to, it takes only the poll id as an argument, okay. And what it does is simply read it first accesses the address of the recorder contract.
01:24:40.520 - 01:25:36.544, Speaker C: They call it this storage variable keeps the address of the contact that we want to interact with. Then from the voting state we take the number of no votes and the number of yes votes. And then bear with me, I'm going to jump a few lines. We're checking which is bigger using the is less equal library function, the number of no votes or the number of yes votes. So this returns one if the number of yes votes is bigger or equal. And now we can compute the result of this particular vote and we're not representing it as a boolean value as to not create a mix up between a zero result for a poll and the zero default value for storage variables. So we're going to use the short string syntax in starknet.
01:25:36.544 - 01:26:28.650, Speaker C: So when you write the constant string yes under those buckets, what it does is represent the string as a felt. So this is the way it encodes it. It takes the ASCII encoding and presents it in a big indian encoding. So notice that the result is simply the multiplication of yes by result and no by one minus result. So if the result of the poll is one, okay, it means that the number of yes votes is bigger, then this is going to be zero, and result is going to be the field element representing yes. If, on the other hand, this is going to be zero, this means that the number of no votes is greater, this is going to be zero, and this is going to be one. So the result will be the field element which represents the string no.
01:26:28.650 - 01:27:15.140, Speaker C: And now once we have the string representation of the result we want to record, we're simply calling the record function. So recall we defined the namespace under the name result recorder. This is what we defined here. So we can simply write result recorder and access the function that we have here, record. And we're accessing it as if you would access a function inside the contract. So with a simple distinction that the first argument is always the address of the contract you want to interact with. So the record function takes two arguments, and here we send three arguments, the first being the address of the contract, which we take from storage.
01:27:15.140 - 01:28:11.144, Speaker C: So this is how we were able to interact with other contracts. And now we leave it to you to add another external call to verify that the poll wasn't already finalized. So in the finalized poll, before we actually record the result, we want to verify that this wasn't already finalized. And let me just show you again the code for the recorder contract. So we already used the record function in our voting contract. But note that we also have this view function, which we didn't use which takes the poll result. So think how you would use this function to verify that the vote is not already settled and call it from the voting contract we've implemented so far.
01:28:11.144 - 01:28:55.220, Speaker C: So again, what you need to incorporate is these new definitions and good luck. So you have five minutes for it and I leave it under this slide so you will see what you need to add in order to be able to access the new contract. Obviously, again, you have all the code in the notion document, so if you need to, you can also look there. Okay, so we're going to give you five minutes and I'll take a look at the questions in the meantime. Okay, I'll leave it to Henry who led our intermissions.
01:28:55.640 - 01:29:16.184, Speaker A: Hello again. So there are two questions. There are less questions in the beginning, so it's going to be easy. How does carry row handle longer strings? For example, strings cannot be in one felt. I don't think we have a native support for strings or for longer strings.
01:29:16.312 - 01:29:37.750, Speaker C: We still don't have any library supporting it. You feel free to implement it and post it on our discord. People will be very glad to hear it. But yeah, there needs to be some handling of this. But all the tools are out there just waiting for us or somebody else to implement it.
01:29:40.360 - 01:30:24.080, Speaker A: But he's asking, how can I improve myself on coding about starks. So to be honest, I think Starknet is more of an application running on top of starks. You don't really need to deeply understand starks to write starknet smart contracts. So I'm not sure Starknet would be the place for you to learn how to reason and write about starks. That being said, our documentation and our code, which is open source, is a good place to learn how we implemented stuff. How would you go about it? Ariel?
01:30:25.320 - 01:31:04.280, Speaker C: So there are our documentation. Definitely. Also join our discord to interact with other developers and see what kind of problems they're tackling and the advice they're giving. There's also the tooling around Starknet. Start with our documentation and just start writing dummy contracts until you slowly get better. So that's why, for example, we're doing this workshop. So this is the kind of thing you would want to improve it if you're going to develop dapps on Starknet.
01:31:04.280 - 01:31:15.444, Speaker C: This is completely unrelated to improving your understanding of stocks. Again, I can't stress this enough. You don't need to get into this.
01:31:15.482 - 01:31:16.070, Speaker A: Type.
01:31:17.800 - 01:31:19.540, Speaker C: To the matic papers.
01:31:22.040 - 01:31:22.516, Speaker A: To be.
01:31:22.538 - 01:31:58.930, Speaker C: An excellent top of the line stocknet developer. The analogy between a very sharp solidity dev to a very sharp stocknet dev would be understanding the ins and outs of Cairo. And this is unrelated to starks. I wouldn't say unrelated because Cairo was built to support Stark proving of execution. But you don't have to know anything about starks to understand very deeply how Cairo works and how net contracts utilizing Cairo work.
01:32:02.260 - 01:32:15.590, Speaker A: And I think that's most of the questions we had. If you have others, feel free to answer them. Other than that, we still have two minutes to go, so let's wait a bit.
01:32:22.360 - 01:32:45.352, Speaker C: So we're moving to the solution. I see. Just another question regarding the guy who's finishing his master. Then join our discord and see what projects are available. I mean, there are tons of projects going on. If you have any cool idea then be sure to let us know and go nuts. And again, feel free to ask our help on discord.
01:32:45.352 - 01:33:21.426, Speaker C: We're very interested in any startnet ideas. Oh, you were the one who asked about getting deep into stocks. So yeah, if it interests you, the papers are out there, go nuts with that as well. Okay, so I'm going to move on to the solution. So I'm reminding you, we want to verify that the poll wasn't already finalized. And to do that we simply want to call this view function on the contract. We want to see the poll result.
01:33:21.426 - 01:33:56.014, Speaker C: Recall that when recording we substituted the field representations of yes and no. So if the poll result is zero, this means it is still set to the default value. So the poll is still ongoing. So all we need to do is read the poll result from the recorder and verify that it is still zero. Okay, so these are the two parts that you need to add to the contract. You need to add to the namespace the other function that you're going to use. So this is the get poll result.
01:33:56.014 - 01:34:55.410, Speaker C: You wouldn't be able to call it inside the voting contract unless you explicitly defined its signature here. And now all the logic that you need to implement to verify that the poll was not already settled is calling get poll result and asserting that the value is zero, which means it is not yes or no yet. And if it was zero, then we're able to continue to the next line which was recording the result. Okay, so we're actually done with our voting contract. I hope you all enjoyed the exercises and the questions. So I'm going to briefly interact with it before going ahead with telling you what else you can do to improve your starting experience. Okay, so let me just share my browser.
01:34:55.410 - 01:35:51.184, Speaker C: 1 second, I need to reshare here. Okay, so you guys should be able to see my screen. Now, this is our block explorer, Voyager. So Starknet is currently deployed on the goy testnet, and it will be deployed on mainnet in its alpha version by the end of the month. So right now, you see this exact voting contact, which I pre deployed. So if you don't believe me, you can later check out that bytecode here corresponds to the voting contract. And as you can see, I presubmitted two transactions to it.
01:35:51.184 - 01:36:24.216, Speaker C: So I deployed it. This was a transaction deploying the contract, and I submitted two additional transactions. Those were initializing some poll and the next one was giving some voter permissions to that poll. So, stuff we implemented like an hour ago, in case you forgot. So you see, under write contract, you can see external functions. Under read contract, you can see view functions. So these were all our external functions that we implemented.
01:36:24.216 - 01:37:11.180, Speaker C: And this is the view functions that we implemented. So you can see that, trust me when I say I initialized a poll with Id 2022, and as you can see, nobody has voted on it yet. So the number of votes is zero for both no and yes. So what I'm going to do now is send a transaction through Voyager. It is not the only way to interact with Starknet. So to interact with Starknet using our Cairo length package and the cli view our documentation, but right now, I'll just, for the purposes of demonstration, will interact using Voyager. So what I'm going to do is I'm going to vote.
01:37:11.180 - 01:37:37.908, Speaker C: So I've prepared the signature that I want to put here. So this is the poll id that I want to use. And now let's see. Hopefully these are going to be the correct parameters, otherwise I won't be permitted. This is my public key. Now I'm going to attach my signature. Okay, so I'm going to vote yes.
01:37:37.908 - 01:38:28.488, Speaker C: Don't ask me to vote no, because I didn't prepare a signature for the no answer. So I'm going to vote yes, if you don't mind. Let's imagine this is a question where the answer is obviously yes. Okay, so hopefully these are all the valid arguments for voting. So I'm going to send this transaction. Okay, so this transaction is now sent, and we're waiting for it to be included in a Starknet block. So the lifecycle of a transaction is first being captured by our system or by any other sequencer, when Starknet will be decentralized and after it is accepted on l two.
01:38:28.488 - 01:39:04.816, Speaker C: This is the term we use, at least in Voyager. We're waiting for a final confirmation that a proof attesting to the validity of this transaction was also accepted on Ethereum. Right now obviously on the go early testnet because we're working with go early. Okay, so that's basically how you can use Voyager to interact with your contacts. So just see what other nice features you can extract from here. So let's see how our transaction is doing. It's still waiting to be included in a block.
01:39:04.816 - 01:40:12.200, Speaker C: So for now, let me just tell you what else you can do. Okay, so here we use the playground to write code, which is actually a less optimal way to go if you want to write Cairo or Starknet contracts more fluently. So we have the Cairo land package which comes with the compiler and the CLI for interacting with Starknet. Everything is explained in our documentation, so please feel free to read it. And obviously, if you find some explanation lacking or you're encountering some problems, join our discord and ask any questions in any range of difficulty and we'll definitely answer. And for those of you who just want to start from the ground up, there's the starting tutorial. So start from there and see where it takes you.
01:40:12.200 - 01:40:36.144, Speaker C: There are also additional exercises in the notion document. So yeah, you have different avenues you can pursue. So good luck. Let's just see what's our status there. Okay, so our transaction was accepted on l two. Let's just see that I'm getting the new value. Right.
01:40:36.144 - 01:41:04.088, Speaker C: So the poll id was 2022. Okay, great. Now the number of yes ports is one. This is very exciting. We were able to pass the verification. This means all the arguments I previously gave are indeed the correct ECDSA signature for my public key. So thank you very much for going along with writing the contact.
01:41:04.088 - 01:41:27.936, Speaker C: I hope you enjoyed it. I hope you also found it helpful. And again, feel free to visit us on discord. And if you have cool ideas for dapps on Starknet, let us know. I'm feed the fed, so feel free to ask me anything. Henry, did you want to add something?
01:41:28.118 - 01:41:50.472, Speaker A: No, I think. Yeah. Thank you to everyone. There are two questions we can answer quickly, maybe. So where to find a good technical description of how the stocknet network does works. Sorry, verifier approval or l one, l two connection on all of these parts. So we're building that documentation and we are documenting things as we develop them.
01:41:50.472 - 01:42:11.120, Speaker A: So not everything is documented. You will not find that much about verifier improver yet, but it will come. You'll be able to run a starknet full node by the end of year. You should be able to do it. So that's going to be a big step. L one l two connection. This is fairly well documented, so you can look up at the documentation.
01:42:11.120 - 01:43:15.776, Speaker A: So mostly I would encourage you to join our discord and we will publish a discourse platform soon where you'll be able to find more information and see the discussions in real time regarding the network architecture. Then there's another question about could you talk a bit about the concept of hints? Is it possible to fetch data from external Python code? Yes, but actually no. So the concept of hints is a concept of Cairo. It's something you can actually use in Cairo, but you can't use in Starknet. So Ariel may correct me if I'm wrong, but basically the program you are running when you want to prove something will basically require you at some point, for example, to prove that, you know the square root of 25. You could supply the value five and the program would be fine. Or you could just run some python code that calculate this value from the point of view of Cairo.
01:43:15.776 - 01:44:05.876, Speaker A: It doesn't change much. The important thing is that you have the actual value to verify that the program executed correctly. So this is why in Cairo, when you're writing a general purpose Cairo program, you can use INts. Now, in the context of Starknet, this is a bit more difficult because the proof will not be run on your computer, it will run by the prover, and it's hard to be sure how the hint will work in the proverbs environment. So that's why you can't have generalized hints in Starknet. Smart contract that being said, I think we have a whitelist of hints you can use. So you can use some hints, but not anything you would like to add.
01:44:05.876 - 01:44:08.150, Speaker A: And I hope that answers the question.
01:44:09.640 - 01:44:34.984, Speaker C: Just add that some library functions are actually using hints. So for example, if you want to search for an element in a list, then doing it nondeterministically would be getting the location of this element in the list and then verifying that this is indeed the element. You need a hint for that, but luckily we've implemented it for you. This hint is whitelisted and you can do it by simply calling the library.
01:44:35.032 - 01:45:01.296, Speaker A: Function, which is pretty cool actually. I don't know if you've ever written a solidity smart contract to look for a value in an array, and it's a pain in the ass because it's got so much money. There's nothing specific for that. And now in stagnant you can just say, yeah, do it in python and give me back the answer. Which is kind of cool. Anyway, so thank you for everything. I'll do join our discord, join the conversation.
01:45:01.296 - 01:45:06.644, Speaker A: And thank you to Zikiak for having us. It was fun.
01:45:06.762 - 01:45:07.430, Speaker C: Yeah.
01:45:08.040 - 01:45:16.748, Speaker B: Thank you so much for doing this. Ariel, we noticed that you were also hoarding. I don't know if you this off.
01:45:16.834 - 01:45:17.470, Speaker C: Definitely.
01:45:20.640 - 01:45:23.340, Speaker B: Yeah. We actually have a ton of t shirts.
01:45:24.000 - 01:45:26.750, Speaker A: I got one, but my brother stole it from.
01:45:27.440 - 01:45:37.400, Speaker B: Well, we have a lot of them. So actually, we're going to try to find a way to get it out to people if people want these very cool shirts. I want to say thank you so much for doing this workshop.
