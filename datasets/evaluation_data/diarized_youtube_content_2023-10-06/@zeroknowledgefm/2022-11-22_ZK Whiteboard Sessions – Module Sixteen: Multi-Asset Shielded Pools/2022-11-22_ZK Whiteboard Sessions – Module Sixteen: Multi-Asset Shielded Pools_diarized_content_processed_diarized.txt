00:00:10.930 - 00:00:27.840, Speaker A: Hello everyone. I'm Bobin from Polygon and today I'm here with Joe from Anoma and we're doing another recording of the ZK whiteboard series. And today our topic is multi asset shielded pools. So Joe, what are multi asset shielded pools and why do we them?
00:00:28.210 - 00:01:11.722, Speaker B: Thanks for having me. So a multi asset shielded pool is exactly as the name suggests. It's a shielded pool that can contain multiple assets. Now, what is a shielded pool? Well, shielded pool is popularized by Zcash or the original zero coin paper. And the idea of a shielded pool is that instead of having the sender receiver and value all publicly listed on the blockchain as this with most transparent blockchains, the idea is that a shielded pool is a privacy layer that allows transactions to be encrypted in a sense so that they're not broadcast to the entire world.
00:01:11.856 - 00:01:22.638, Speaker A: So if you and I are using a shielded pool, then nobody from the outside can figure out who sent money to whom or how big the amount was and all of that stuff, right?
00:01:22.724 - 00:02:47.442, Speaker B: At least you've broken the cryptographic link between each transaction. Okay? And so one of the things that is true of Zcash is that it supports only a single asset, only at least at this time, which is ZEC. And the idea of we have a shielded pool with a single asset, every transaction in the shielded pool is transferring the same exact asset. And so it's obvious, at least from the outside, even though the sender receiver and value may be encrypted, the asset type is not in question because everyone knows that this transaction within the shielded pool must be the single asset. And so our goal of the multi asset shielded pool is to allow many asset types within a single shielded pool so that for a given transaction is not possible to tell from the outside. At least there's no cryptographic evidence of what that asset in that transaction is.
00:02:47.596 - 00:02:55.274, Speaker A: I guess before we go into the multi asset, could you maybe explain at high level like how does a single asset shielded pool work?
00:02:55.392 - 00:05:32.990, Speaker B: Right? So the zero coin and Zcash model is essentially how most or all shielded pools today operate. And the idea is that we have a note set, which is a merkel tree of all transaction output ever recorded in the pool. So this is similar to how Bitcoin has a UTXO set, except that in this case, we make a slight difference where note set is actually every transaction output, whether they're spent or unspent. And so then from this note set, we can use zero knowledge proofs to show several things about the transaction. So if you start with this merkel tree and each note looks something like some value of the note and the owner the owner address, which is typically a public key, then what you can do is if you want to spend a note, use a VK Snark or similar, some kind of zero knowledge proof or argument or something like that, to show that one, the note is unspent as it hasn't been spent already. Two, the owner has authorized, which in the case, if the owner addresses a public key, there's a signature involved or something like a signature. And three, the transaction, the value of the notes spent is equal to the value of the notes created.
00:05:33.490 - 00:05:36.314, Speaker A: So sum of inputs is equal to sum of outputs.
00:05:36.442 - 00:05:57.298, Speaker B: Exactly, yes. So that therefore you cannot just create value out of nowhere magically, right? And in the single asset case, this is relatively straightforward, right? You just sum up all of the values of the notes that are spent in the transaction and you sum up all the value of the notes that are created and check that they're equal.
00:05:57.474 - 00:05:59.186, Speaker A: And that happens within the ZK snark.
00:05:59.218 - 00:06:43.690, Speaker B: And you check all this inside of the ZK snark and then you take the notes that are created and then you add them back into the merkel tree of the note set. And so the more transactions that there are, the larger this note set becomes. And because each note in the note set, although it contains the encrypted value and owner address, or more precisely the commitment, each note in the note set doesn't reveal any information about to the public what the value or the owner is. And so, as the note set grows, you get more and more and more privacy.
00:06:44.030 - 00:06:57.840, Speaker A: And I guess maybe this is part, but why can't we have multiple assets, we want to have some privacy guarantees, why can't we just create a single asset pool for each asset that we care about?
00:06:58.150 - 00:08:04.182, Speaker B: Right? So this is not such a major problem for if you have a couple different popular assets so like assets that have many transactions, tokens that have many transactions, then the privacy sets for each of those might be large enough already and you might get more privacy by merging them together into one shielded pool. But the real advantage is when you have assets that are wildly different, popularities. If you have a very common asset that is transferred a lot, and then you have some other assets that are very rarely transferred, or even something like an NFT, which there is only one of and is only transferred when that NFT is transferred, you know it's transferred. And so it doesn't put much use to put it in its own shielded pool. And so the real advantage of a multi asset shielded pool is putting them all in the same shielded pool and getting all of these different tokens to share the same privacy set.
00:08:04.316 - 00:08:16.090, Speaker A: So basically, even infrequently traded or transferred assets get the same kind of same guarantees of anonymity and privacy as the most frequently traded asset, basically, right?
00:08:16.160 - 00:08:29.166, Speaker B: Because even if some token is traded only once per day and it's in the same shielded pool as a token that's traded a million times per day they're still cryptographically indistinguishable from the outside.
00:08:29.268 - 00:08:40.500, Speaker A: Makes sense. Makes sense. All right, so I think the motivation is clear. But what are the challenges of creating this multi asset shielded pools, right?
00:08:41.430 - 00:09:36.812, Speaker B: So what are the challenges when we try and add multiple asset types into one shielded pool? Well, for one, we don't want to hard code assets. So no hard coded because for one, it's probably impossible to make a list of all the assets that you would want to be able to put in the shielded pool. But second, it's also not very practical if to hard code a long list into the ZK Snark circuit. We want to have some kind of protocol which is agnostic to how many assets might be in the shielded pool or even if some of those assets may not exist yet. We want to support assets to create.
00:09:36.866 - 00:09:39.004, Speaker A: Assets dynamically, almost, right?
00:09:39.042 - 00:11:17.630, Speaker B: There should be some way to create new assets and put them in or take them out of the shield pool in some standardized way. And so the second challenge is that oftentimes there's different standards. Um, for example, value, sometimes this is a U 64, sometimes this is a U 128. If you are putting different assets that follow different standards into the same shielded pool, sometimes you have to address how they technically look different. Another challenge is fee payment, which is when you have multiple asset types in the same shielded pool, if you have a transaction with one asset type, it might not be the native token of the chain or something like that. And so how do you negotiate the fee payment for this transaction? Because you either have to maybe have the native token of the chain or you have some kind of mechanism where you unshield some of the other assets to pay the fees, but then you're revealing what the asset was in the transaction. And so there's some challenges in terms of how you allow fee payment.
00:11:18.000 - 00:11:29.484, Speaker A: And then you mentioned native token. But I guess in the context of like a multi asset world, do we even need a native token? Or can we just say all assets are equal? Or because of the fee payment aspect, you do want to have a native.
00:11:29.532 - 00:12:49.736, Speaker B: Token, for example, right? It comes down often to the economics of the chain where the chain might have some native token which all fee payments must be in. Maybe the chain doesn't have any requirement for fee payments at all. Maybe the chain allows payment in different asset types and the miners or validators have some mechanism for valuing these tokens. Maybe there's some mechanism where inside of the shielded pool, the non native assets can be swapped for the native assets. There's lots of different ways you can approach this problem. But it's a unique problem because if you have fee payments of some kind that are required and you are unshielding some of the transferred asset, you might leak some of the privacy. Right? And the last challenge, which I'll mention is heterogeneous transactions, which is that you may have in a transaction, a single transaction, multiple asset types.
00:12:49.736 - 00:13:15.650, Speaker B: And this is something that cannot happen in a single asset shielded pool because, well, every transfer in a transaction is going to be the same asset. And so you don't have to keep track of this, but if you have multiple assets allowed, then you might have complex transactions where you're sending more than one asset type within a transaction. You might want to allow this.
00:13:16.120 - 00:13:22.256, Speaker A: What are the benefits of being able to have the same assets or different assets in the same transaction?
00:13:22.448 - 00:14:19.340, Speaker B: Well, for one, you don't have to split it across multiple transactions. So if you want to make sure that your transaction is atomic, for example, you definitely don't want to send one token first and then send the second token because one of those two transactions may not execute. You might want to have complex transactions with multiple signers, multiple parties. This is a situation that you maybe come across less commonly in a single asset shielded pool because it's less likely that someone would want to atomically send the same asset as someone else. But say, if you and I are swapping a token privately, we might want to construct a multiparty transaction where I send the token to you, you send the token to me, and they're different types. And we're doing this kind of swap. There's no exchange and a decentralized exchange involved.
00:14:19.340 - 00:14:26.856, Speaker B: We're just swapping the assets, and we want to do this atomically so neither of us can back out of the trade. Okay.
00:14:26.958 - 00:14:35.452, Speaker A: I think that's pretty cool, actually, that we can swap basically, we can exchange assets without involving an exchange and do it fully privately, right?
00:14:35.506 - 00:16:19.016, Speaker B: Yeah. And so you get these questions that don't come up so much in the single asset shielded pool of, like, how do you handle if you have multiple signers or this kind of thing, right? But we can start from the single asset shielded pool model, and we can start to address these challenges, all right? And the most simple thing we can do is just add another field to each note asset type. So maybe not describing exactly the form that this field takes, but we have some representation of each asset type. It can depend maybe, on where the assets are from. If there's some kind of ERC token or if they're a cosmos token or something like that, then they all have some kind of representation for what their asset type is, and you want to encode it somehow and put it in the node. Makes sense, right? And so if we do this, this is conceptually simple, but we do have to make some changes to the rest of the protocol, right? Because here where we said that the sum of all the values of the notes that are spent has to equal the sum of all the values of the notes that are created. And when we do this in the multiasset case, we don't just have to sum all the values of all the notes together, we have to sum for each asset type independently.
00:16:19.016 - 00:16:30.320, Speaker B: So for each asset type, we have to sum all of the value of those notes of that asset type and check that it's equal to the value the sum of the values of all the notes of that asset type.
00:16:30.390 - 00:16:33.890, Speaker A: I guess that complicates the circuit quite a bit. If you want to do that.
00:16:35.160 - 00:17:42.790, Speaker B: It could, yes. So there's several different ways that we can implement this step in the ZK snark of checking that the value balance is correct, that you're not creating any value. So let's consider some of the different ways that you could do it. I'll just call it the value balance check. So how do you check that the transactions has correct value balance? Well, one way of doing it is to check the sum in the circuit. So the circuit inputs many notes and then some spent. So say two spent notes and then two output notes.
00:17:42.790 - 00:18:05.766, Speaker B: Though again, in the multi asset case, you may need more. This is the way that Zerocoin worked the Zcash Sprout protocol, where you had a single circuit that checked all of the input nodes and all of the output nodes and all of the created notes and checked it inside of the circuit.
00:18:05.798 - 00:18:29.470, Speaker A: That the value guess in multi asset situation. Like if you have many assets, like, your circuit needs to be, I guess, generic enough to be able to determine I might have ten assets as part of one node and like twelve assets in another node or something like that. Well, hopefully not twelve. Hopefully there's still ten in each. But there could be varying number of assets. So like the circuit needs to be able to handle some kind of degree of variability.
00:18:29.550 - 00:19:11.840, Speaker B: Right? Right. And so this might make the circuit extra complicated because now you have to sort of keep track of how many different asset types you have to keep a running sum of each different asset type. And it's not the most efficient way to do it. And there was a reason why with the Zcash Sapling upgrade, they stopped doing this and they adopted a much more clever way, much more clever way of doing it, which I'll call homomorphic value commitments.
00:19:15.140 - 00:19:19.440, Speaker A: And could you explain a little bit more about what exactly are homomorphic value commitments?
00:19:19.960 - 00:20:31.370, Speaker B: Exactly. So the idea is that instead of, instead of having all of your input notes, so if you have value public key and then asset type, so suppose that you have four notes that are being spent and then you have four notes that are being created. So instead of having one circuit that takes in all of these notes and checks the sums independently, instead what we do is we associate with each of these nodes a value commitment. And what is a value commitment? Basically, we can think of it as an encrypted representation of the note's value.
00:20:38.770 - 00:20:47.074, Speaker A: So it's kind of an object that commits to a value, but it is done in such a way where you cannot tell what the actual value is.
00:20:47.192 - 00:21:43.846, Speaker B: Right? The important properties of it is that it's hiding meaning no one can tell what the value is, that it's binding, that represents exactly one value and cannot be feasibly changed and that it's homomorphic. Which means that if you take two value commitments and add them together that that is going to be equal to the commitment that is the sum of the values. Okay? And I won't say exactly how you add just yet, but if you take two value commitments and you add them together, this is going to be equal to the value commitment of the sum of its values inside.
00:21:44.028 - 00:21:45.030, Speaker A: Makes sense.
00:21:45.180 - 00:21:45.878, Speaker B: Okay?
00:21:46.044 - 00:21:58.266, Speaker A: So basically with this trick we had this number two or number three item where we would check the sum of inputs is equal to subpoenuts in the circuit. We no longer need to do this in the circuit, am I right?
00:21:58.368 - 00:22:49.014, Speaker B: Exactly. The reason that you want to do this is because instead of checking in the circuit that the sum of the value commitments is zero. You can instead just have one circuit for each note. So perhaps one for each spent. At least in the Sapling model. This was the way it worked. You have one circuit for each note and the circuit just needs to check that the value commitment is correct, that the value commitment matches the value of the note and the circuit doesn't actually know anything about all the other notes.
00:22:49.014 - 00:23:24.690, Speaker B: It's not checking the balance directly. But instead outside of the circuit we can add up all of the value commitments that are being spent and we can add up all of the value commitments that are created and we can check that that is the commitment of the value zero. And so from the outside we see that it balances because the sum is zero, but we don't actually know what is inside of each of these value commitments.
00:23:24.770 - 00:23:25.366, Speaker A: Makes sense.
00:23:25.468 - 00:23:38.250, Speaker B: And there's some advantages of this. Basically, each circuit is now much smaller. You're not constrained to say, having two notes in and two notes out and generally you just get a lot more efficiency.
00:23:38.590 - 00:23:48.430, Speaker A: And I think especially in the multi asset context, this bucketization by asset is much easier to do outside of the circuit than it is inside the circuit, I'm guessing, right?
00:23:48.500 - 00:23:59.620, Speaker B: Yeah. And the amazing thing now is that because each circuit only deals with one node at a time, this means that the circuit only needs to consider one asset at a time.
00:24:00.470 - 00:24:14.520, Speaker A: But I guess now you need to make this commitment somehow unique to each asset type, am I right? So like you can't add them two different value commitments from two different assets or it somehow shouldn't make sense.
00:24:14.970 - 00:25:42.440, Speaker B: Exactly. So let's look at how it works in the single asset case, and then I'll describe how it generalizes. So in the single asset case, we get two random. I'll put random in quotes, elliptic curve points. This is where it gets mathy, right? We'll call these points v and R. And so what we can do is we can say that a value commitment for some integer value and some randomness, the randomness is going to serve to make the value commitment private. The value commitment is going to be equal to the integer value times this elliptic curve point v plus the randomness times the elliptic curve point R.
00:25:42.440 - 00:26:05.920, Speaker B: And the nice thing about using this form of value commitment, which is essentially pederson commitment is that it meets the requirements that we have, hiding, binding and homomorphic at least to the extent that we need it to be.
00:26:08.130 - 00:26:21.330, Speaker A: If you had two different v's, well, I guess if you had another asset, you would add them together and they just add up in terms of the v. And let's say you had a U or something like that the same.
00:26:21.400 - 00:27:57.986, Speaker B: Okay? Because if you have v one plus the value commitment v two and some randomness, this is going to be equal to v one plus v two times v plus some randomness plus some other randomness times R, which is just the value commitment of v one plus v two and some randomness. Yes. So we get the properties that we want, and in the single asset case, we just check that the sum of all the value commitments is zero and have guaranteed that the transaction is balanced. So what do we do in the multi asset case? Well, there's a very clever approach that the Zcash team at Electric Coin Company figured out, which is that instead of using two points, we actually have many random elliptic curve points, okay? One for each asset type. That is to say that each separate asset type is going to have its own random elliptic curve point. Got it?
00:27:58.008 - 00:28:00.258, Speaker A: But R is the same for all, right?
00:28:00.424 - 00:29:56.050, Speaker B: R can be the same for all. Okay? And this way when you now change your value commitment to take in the asset type and the randomness instead of using the single asset value base, the particular value base for that asset type. And then the claim is that because if we now add value commitments from two different assets together so, for example so value commitment of V one and then let's say asset type one and then the randomness is not important. Plus the value commitment that has value v two and asset type a two and some randomness. Then this is going to look like v one and then the elliptic curve point for the asset type one plus v two times the elliptic curve point for asset type two and then randomness. And the claim is that because VA one and VA two are random, that it's not actually feasible to determine what the relationship between VA one and VA two is.
00:29:56.140 - 00:30:01.450, Speaker A: So they will never collide in such a way where they can cancel each other out or something like that.
00:30:01.520 - 00:30:27.026, Speaker B: Right. Because even though they're on the same elliptic curve and more formally in the same subgroup, same cyclic subgroup on the elliptic curve. So even though we know that there's some potential relationship between them because they were selected at random, it's not feasible to find this relationship. And this is a very standard cryptographic assumption. Yes.
00:30:27.128 - 00:30:27.778, Speaker A: Makes sense.
00:30:27.864 - 00:30:53.470, Speaker B: Now the only thing that we have to do is that we should say that, well, randomness is kind of hard to verify. So we're going to actually just use pseudorandom points which are generated using a hash to curve.
00:30:54.290 - 00:30:56.160, Speaker A: What do you hash in this case?
00:30:56.530 - 00:31:46.110, Speaker B: Right, exactly. So in order to find the value base for a particular asset, we want to make sure that it's pseudo randomly chosen, there's no structure to it, no obvious structure to it, and that it's unique to that asset type, that no other assets type has this particular value base. And so we're going to use this hash to curve. There's many possible ways to do it of the asset type representation.
00:31:47.170 - 00:31:52.480, Speaker A: An asset type representation? Is it like a string that has an asset name, or is it something else?
00:31:53.970 - 00:32:41.370, Speaker B: It could be a token address, for example. It could be some kind of other representative string. The important thing is that it just has to be unique to that asset's type. And two distinct assets never share the same representation. And so by using this hash to curve, we can get these value bases for each asset type. And in fact, we can generate new value bases whenever the protocol needs it. And so this starts to meet our requirement of not hard coding into the protocol the assets that are allowed to go in the pool.
00:32:41.370 - 00:32:48.418, Speaker B: And if new assets come along, we just hash whatever their representation is and we can get the new value base.
00:32:48.584 - 00:33:18.726, Speaker A: Makes sense. Okay, so I think I understand how kind of assets work, but how do you create new assets? I mean, usually for native assets, frequently you would have some kind of like either cap or schedule of how they appear and things like that. So when we want to create in the multi asset world a new asset, we probably need to set some sort of parameters from the get go and maybe restrict who can create assets and things like that. So what are the kind of challenges and solutions regarding to creating new assets?
00:33:18.918 - 00:34:58.330, Speaker B: Right, so since most assets probably come from other chains, so you would want to have some kind of bridge to whatever chain the the multi asset shielded pool is on. And so when you bridge the assets and this is sort of independent of the shielded pool, you want to have that representation of each asset. And then you can either make it the shielded pool, perhaps permissioned, you need some permission to add a new asset, or you can make it permissionless. Whereas long as your asset type is unique and has a unique representation, it doesn't actually harm the other assets in the pool. You just need to make sure that when this new asset is deposited in the pool, that the new value base is created. And then when you're adding the new assets to the pool, then your value commitment. So recalling the when you had the sum of the transaction, all of the value commitments in a transaction, and we said, well, the sum of all the value commitments of the notes being spent is equal to the sum of the value commitment of the notes being created.
00:34:58.330 - 00:35:33.654, Speaker B: When you are actively adding assets to the pool, then instead of enforcing this equality, you're going to have the value commitment of the assets that are added plus the value commitment of the assets that are being spent, and that should be equal to the output notes that are created. And when you're taking assets out, you just move this to the other set.
00:35:33.792 - 00:35:34.670, Speaker A: Got it?
00:35:34.820 - 00:35:35.182, Speaker B: Okay.
00:35:35.236 - 00:35:44.798, Speaker A: And I guess the same could work for not only for Bridget assets, but if you have a chain that creates assets natively, the assets could be created outside of the shielded pool and moved.
00:35:44.814 - 00:35:45.806, Speaker B: Into the shielded pool.
00:35:45.838 - 00:35:50.686, Speaker A: And the logic for how you create and all of that stuff could live outside of shielded pool.
00:35:50.798 - 00:37:15.218, Speaker B: Right. Unfortunately, right now, essentially because assets will generally come from another chain, you have to have a transparent bridge. Okay? So whether this is like an ethereum bridge or Cosmos IBC or something like that, this is all transparent. The addresses, the values, the particular assets that are involved is all visible from the outside and cryptographically linked. And what would be really nice is to be able to have a shielded or private bridge where assets that are in a shielded pool on one chain can be bridged to a shielded pool on another chain. However, this is a very complex problem because already bridging between chains is already kind of a difficult thing. But when you have a shielded or private bridge, now you have to deal with the different trust models and different chains, and it's a whole research field.
00:37:15.304 - 00:37:28.982, Speaker A: And you probably want to have the assets to be exactly the same. Like, if you're using your elliptical representation, as you describe, for elliptical curve points for kind of encoding assets, the same thing has to happen on the other side. Otherwise it doesn't quite work like that.
00:37:29.036 - 00:37:41.770, Speaker B: Right, right. If you're thinking about not just a different trust model between different chains, but like actual different technical specifications, different token standards, and now you're trying to bridge across chains.
00:37:46.910 - 00:37:55.406, Speaker A: Okay, so we talked about just simple transfers, but is there anything beyond simple transfers like within the multi asset shielded pool. Can we do something more than that?
00:37:55.508 - 00:39:25.846, Speaker B: Absolutely. So of course, as soon as you have multiple asset types, the kinds of applications that people would want to do are much more complex and much more varied. And so some of the things that you might want to do are, for example, general computation. So if we think about ethereum and smart contracts on Ethereum and other kinds of general purpose computation where you can program into your tokens lots of interesting functionality that can be unique for each token, you might want to do the same thing inside of a shielded pool. There's a paper called Zexi about this which is very interesting and they describe how you might have different token types inside of the same pool with this kind of custom computation. But this is a very general approach and with generality is sometimes computationally expensive and so there's some trade offs but certainly is something very exciting that you would want to do. It's just the same kind of computation and programmability that you have with a transparent tokens.
00:39:25.846 - 00:40:40.638, Speaker B: Then the other things you might want to do is you might want to have a shielded decks and there's projects that are working on this as well with the idea that if you want to do a swap inside of your shielded pool. You don't want to have to unshield your tokens to a transparent address, do the swap, and then shield them again because some loss of privacy. And so if you build your decks sort of natively to work within the shielded pool, this is much better and it's a whole interesting problem again by itself. So another thing that you might want to do is you might want to have rewards or incentives inside of a shielded pool. This could take the form of many different things. Maybe you just want to have some kind of AirDrop inside of a shielded pool. Or you want to perhaps over time, provide some kind of incentive to certain tokens in the pool.
00:40:40.638 - 00:42:10.110, Speaker B: Or maybe you even want to do something like a shielded staking where there's staking rewards. Or you just somehow want to have more than just the static amounts of token. And the challenge of this of course is that because you don't actually know where all of the tokens are in the shielded pool, how could you do an AirDrop or something? Right? Of course, the way to approach this is to say, well, we need to have a little bit more programmability in the shielded pool where we do allow some kind of rewards claiming or AirDrop claiming process to happen. So that even though perhaps from the external world if someone provides rewards, they might not know exactly where they're going because a shielded tool obscures this. But each user might see that they're eligible and they can prove that they're eligible in zero knowledge and either claim their. Reward or AirDrop or something like that. When we want to ask this question of how do you provide rewards or incentives or otherwise just allowing people to somehow claim or change their tokens inside of the shielded pool, this is actually not impossible.
00:42:10.110 - 00:43:49.698, Speaker B: So if we recall the reason that tokens are not fungible. So if you have two asset types, a one and a two, and we put as a hard goal for a shielded pool that you sum all of the values across different asset types independently. So the amount of a one never affects the amount of a two. And this guarantees that these two token types are not fungible with each other. But if we wanted to do something inside of the pool where actually there was some kind of difference between these two, but we still wanted this fungibility. So like asset one and asset two maybe represent the same token type, transparently but encode some metadata, for example, reward claimed or not. So for example, maybe a one is some token type and then maybe the native token of the chain and then a two is going to represent the same token type outside of the shielded pool.
00:43:49.698 - 00:44:36.736, Speaker B: But inside of the shielded pool they're going to be distinguished because maybe one has some rewards that has yet to be claimed and this token type represents that the reward has already been claimed. Okay? And so then we want limited fungibility, meaning that we want to be able to sort of mix these token types and allow their values to interact, but we don't want to break the other than the limited fungibility that we add. We don't want to break the constraint that otherwise asset types value independently.
00:44:36.848 - 00:44:39.124, Speaker A: Okay, so how do we do that?
00:44:39.162 - 00:46:20.340, Speaker B: How do we do that? Well, the way that we do that is that if we have the value bases VA One and VA Two, instead of insisting that value bases always have to be derived by this hash to Curve, so the value base for asset one was derived from this hash To Curve and this was derived by another hash to curve. Instead, what we can do is we can introduce a new kind of value base which is not created by a hash To Curve, but maybe something like a one to a two. And it's going to be a combination of these two value bases. So we might have minus one of VA One plus one, VA Two. And this is going to be an entirely new asset type, not one that came from outside of the shielded pool, but is something that kind of only exists inside the shielded pool. And the amazing thing is that this asset type allows you to convert one unit of asset one to one unit of asset two. Interesting.
00:46:20.340 - 00:47:53.452, Speaker B: And the beauty of it is that it's because if you took one unit of asset one and combined it with one unit of this, I'll call it magic asset, then the value balance, the value commitment of this sum would be magically turns into one unit of assets two. Very cool. And so as long as you're kind of careful in how you allow these kinds of magic assets to be constructed, you can allow asset one to be converted into asset two. And you can implement some kind of rewards or something by saying, well, maybe you imagine now you have some asset three that you want to give to everyone that holds asset one. Well, you just have to change the magic assets type. Instead of just saying convert a one to a two, maybe you call it claim reward. And every time that you convert asset type one to asset type two, you get one of asset type three as well.
00:47:53.452 - 00:48:53.964, Speaker B: And so you're converting asset type one into one of asset type two and one of asset type three. And so now you've given people inside or users inside of the shielded pool this ability to sort of modify this metadata of their asset in a controlled way such that previously it represented one thing and now it represents something else. And as long as, like I said, you're careful in how you allow these very limited conversions, you can encode kind of the simple token operations that you might want to do other than like a simple transfer. And you can do this without having a full programmability, which is more expensive. You can do all of this inside of the homomorphic value commitment, which is very efficient.
00:48:54.092 - 00:49:02.230, Speaker A: And some of the examples we mentioned, Airdrops Rewards. Are there other use cases that you can do the same way.
00:49:04.200 - 00:50:07.400, Speaker B: Right? Well, certainly if perhaps some of these asset types encode NFTs or something like that, maybe you want to, under certain circumstances, allow some NFT to be minted. This NFT maybe is representing that there was some holding at some particular point in time of asset one that you want to represent. And so if if you want to yeah, if if you want to encode almost arbitrary metadata in these asset types, although you don't really get generalized computation, you can still get something that can do a lot of things.
00:50:07.550 - 00:50:25.920, Speaker A: By the way, so you mentioned NFTs, and one thing that I forgot to ask when you were explaining asset types is for NFTs, would every NFT have a different asset base or is there a way to combine them together and to put some NFTs under the same asset base or it doesn't make sense, right?
00:50:25.990 - 00:51:47.836, Speaker B: So the interesting thing is that when you have an NFT, then your value of an NFT note, well, value just more or less doesn't make sense, right? It's kind of always equal to one. So this means that you're encoding all info in the value base. Okay, so this does mean that, for example, it's not just kind of the type of NFT, but like all of the data as well somehow goes into this value base, or at least it's represented by this value base. And this does mean that when you're choosing the representations of each asset type and the representation of what an NFT looks like, that you have to make sure that all of the information is encoded properly in order to make sure that NFTs of similar type but different data don't get mixed together.
00:51:47.938 - 00:51:49.470, Speaker A: Makes sense. Makes sense.
00:51:49.920 - 00:51:50.540, Speaker B: All right.
00:51:50.610 - 00:51:56.512, Speaker A: This was super interesting. Thank you so much for coming on the show and doing this recording.
00:51:56.656 - 00:51:58.210, Speaker B: Thank you for having me. Great.
