00:00:11.610 - 00:01:01.710, Speaker A: Hey guys, I'm Jeff from Parity. We made many different things. So the thing I'm going to be talking about today is private transactions on the Ethereum blockchain. Public blockchain and sort of the secret store, which is the technology underlying that. So yeah, first things first, what's the motivation for private transactions on Ethereum? I mean, one of the benefits of Ethereum is that it's permissionless and also it's public, so everyone can see it. That is a selling point, you could argue. Yeah, permission source means anyone can submit a transaction and public means anyone can read a transaction.
00:01:01.710 - 00:02:24.620, Speaker A: But for sort of bigger companies, for sort of enterprise use cases, there are other reasons to have privacy, but the private transactions that we implement are more sort of aimed at enterprise. I'll get into exactly why it's not so useful for sort of like the Zcash send money to sketchy people on the internet kind of use case. We want to put this on the Ethereum blockchain rather than having our own custom blockchain for all the reasons that people like having Ethereum. It's got many validators. So yeah, we have a solution to this secret store, which is the technology underlying everything else. This is sort of yeah, it's a Federated encryption scheme, so no one person has the entire key and I'll explain exactly how that works later. And yeah, private transactions which are sort of this is wrong, I wrote this yesterday very quickly after landing from the US.
00:02:24.620 - 00:03:18.762, Speaker A: So it's actually transactions on the product Ethereum blockchain where the result is encrypted. That's not actually true. Don't read that. If you want to validate the state changes in the transaction, or if you want to submit a transaction, you have to sort of submit it to the secret store and then the secret store checks whether or not you have permissions to do this. The secret store, as I said, it's Federated, it's N of N. So I'll explain exactly how that works. If you want to ask me questions, I can't give you the exact details, but I can give you a sort of example of how exactly that works.
00:03:18.762 - 00:04:13.486, Speaker A: But suffice to say that there's some number of nodes, M, and you need at least N of those to sign off on. You encrypting something or decrypting something in order to decrypt it. And this is sort of enforced mathematically and yeah, you get a new key every time you want to encrypt something. You don't just have one key. This is quite important because otherwise you could just decrypt anything with the same key and it would destroy the sort of federation. And the permissioning is done on chain, which means you have like a smart contract which has one function. It takes whether the document ID and the address and then just returns, true or false, whether or not that person is allowed to decrypt this.
00:04:13.486 - 00:05:33.980, Speaker A: It's quite coarse grained, it's symmetrical, which means that you can't allow someone to encrypt but not decrypt, which for example you can't do with public key cryptography. The permissioning in Secret Store is very course grained. It's mostly like as I said, for enterprise use cases so where you don't want just anyone to do it. But within this organization it's generally okay for most people to read and write it. So yeah, if you want to encrypt a thing or sign a thing with Secret Store, which I'll get to exactly why you've got to do this and why it's useful for the private transactions, you first just generate a Document ID, which is like a hash of the document normally. I mean, it can just be like the same word for every document if you like, so that's just going to not be very useful. Normally it's a hash of the document and then you sign it with the key pair of your account, which is you sign it with the key pair of your account.
00:05:33.980 - 00:07:02.920, Speaker A: Sorry, I've annotated these with whether or not you send this to your local node or whether you send this to one of the Secret Store nodes in a particular Secret Store instance. It doesn't really matter which one you send it to because they all sort of have to you have to have some N number of them anyway. So the way that we recommend to set it up is to have just one of them that has like an HTP API that you can connect to if you want to generate your keys and whatever. But yeah, then that one can just communicate using the normal Secret Store communication methods. Otherwise but like from an application you only have one that runs the actual application level server. So yeah, you the generate the key that you generate the document on the remote that is unique for each document and it is unique for each account that you've signed it with as well the reasons that I outlined before. And then you use this key to generate a local key and then you encrypt that document with it and then you send the local key and the Document ID signed back to the mode and then it associates this so that other people can retrieve it later.
00:07:02.920 - 00:08:16.874, Speaker A: So yeah, decryption so say you've associated all this key and the signed Document ID with so you associated with the key with the Document ID. Then you send the encrypted document to someone else and they want to decrypt it. So first the decryptor signs the Document ID to make sure that it's them requesting it because yeah, it's permissioned on like a per account basis. So you need to make sure that the person who's requesting it, you can't just say it's any address and then you could say the address of somebody who does have permissions when you personally the person sending it doesn't have permissions. So you have to sign document ID. You request decryption keys from the remote which yeah, this is where the permissioning comes in. So each of the secret store nodes will call into the contract and check whether or not that document ID and address is allowed to decrypt and then use this key to decrypt the document.
00:08:16.874 - 00:08:50.806, Speaker A: It's pretty simple. It's not like super fancy zero knowledge stuff. The real useful stuff is in the N of M cryptography. So, yeah, private transactions which are built on top of this. I mean, I think that private transactions is a bit of a misleading term. I mean, it's really a private contract, but technically, all the execution that's done in a contract is done as part a transaction. Like, each transaction is a state transition, and the only time that code in a contract is run is in a transaction.
00:08:50.806 - 00:09:41.770, Speaker A: So that's why we use this terminology, but I think it might be a little bit confusing. The code and the state in the contract are both encrypted and can only be decrypted by a certain secret store instance. Not just anyone can validate the state transitions. Only validators that also have access to the secret store can validate the state transitions. So you have this wrapper contract. Really, the only thing that the wrapper contract does is accepts a state transition that you want to apply checks that it's been signed by. At the moment, it's all of the Validators that the contract has.
00:09:41.770 - 00:10:42.430, Speaker A: You set that up at deployment time, although that's not a fundamental limitation. I'll get into the limitations later. And yeah, so not only do you need to have access to the secret store in order to validate transactions, but also even just to submit transactions, you have to have access to the secret store. So, as I said, this is like for the enterprise use case, where you can have this sphere where it's trusted, but then outside of that sphere, it's not trusted. All the Validators must sign off on any state change. So the flow is you request a state change, you collect signatures from each of the Validators, and then the Validators would check that that state change is okay. And then if you get enough signatures, which at the moment is all of the signatures, then you submit the signed state transition to the public contract, and then that will be accepted.
00:10:42.430 - 00:11:43.918, Speaker A: So this is pretty like so yeah, this is this is useful already for private contracts, but it has quite a few limitations right now. So probably the biggest one is that you can only do one state change per block per contract. So only one transaction, but that transaction can do lots of stuff. If you wanted to make like, an ERC 20 token, you could probably roll up many transactions into one transaction that you send to the contract or any one state change. And so at the moment, you can't say only half the Validators have to sign off before a state change is valid. All of the Validators need to sign off, which is annoying. If some of the validators are down or some of the validators are being maliciously, having their packets slowed down by a nation state or whatever, you can't do events or logs, you can't call private.
00:11:43.918 - 00:12:08.666, Speaker A: Other private contracts you can call public contracts. So, yeah, the signing has to be done off chain. You can't have private contracts, call private contracts. And, yeah, there's no tracing or debugging support. But most of these are not fundamental limitations. I think maybe the private contracts not being able to call other private contracts might be fundamental for now. No, I don't think so.
00:12:08.666 - 00:12:25.110, Speaker A: No, I don't think any of these are fundamental limitations. They just haven't been implemented. Like the fixes haven't been implemented. Okay? And that's all I've got to say. It's quite a short one. Any questions? Excellent. That means I can go sleep.
