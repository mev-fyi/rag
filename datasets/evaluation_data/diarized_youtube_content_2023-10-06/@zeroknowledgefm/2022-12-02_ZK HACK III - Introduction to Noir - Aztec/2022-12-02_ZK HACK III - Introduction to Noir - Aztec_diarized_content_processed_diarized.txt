00:00:09.290 - 00:00:23.070, Speaker A: Welcome everybody to the noir workshop. I am Maxime. I'm a software engineer, language designer on the noir team here at Aztec, and I'll let Joss introduce himself.
00:00:23.730 - 00:00:27.270, Speaker B: I'm on the noir tooling team also at Aztec.
00:00:30.090 - 00:01:19.666, Speaker A: So today we're going to give an overview. To start with, an overview of noir, which is our ZK DSL. And then after that, Joss is going to take you guys through kind of a code together example. I'm going to provide a QR link later to our CLI tool for doing everything. But there was an email that was sent out like right before this session. So there's a link to our installation page if you want to get started on that a little earlier. So first we want to ask, why should you, as a developer, care about Noir? We want to enable developers of any background to easily get started writing ZK circuits.
00:01:19.666 - 00:02:20.154, Speaker A: As the line says here, write ZK programs without being a cryptographer. So now the properties of ZK proofs enable us to greatly expand the number of useful applications that we can have. We now can actually have privacy preserving applications that are also efficient to verify. However, for a while now, writing ZK programs has been quite challenging. A lot of ZK circuits were written using the APIs of a given proving system, and then interacting with that proving system usually required some knowledge of how the ZK proof construction operates, or also the underlying cryptography that makes that ZK proof system possible in the first place. And then if you wanted to switch proving systems, you also had to rewrite your program in that API of the new proving system. And aside from noir, there has been a lot of development of ZKDSLs to make these programs a little easier to write.
00:02:20.154 - 00:03:42.610, Speaker A: However, they are still oftentimes limited in their scope and the proving systems that they support. Our solution to making CK circuit writing easier is noir. So what does noir offer? Noir is, as I mentioned, our ZKDSL. It is written in rust, and it's fully open source for our native field data type, which I'll mention, I'll go into detail a bit later about, is based upon the arcworks library. But the main benefit that we try, what makes noir unique, is that we aim to be more flexible in our design than other domain specific languages that are currently out there. Noir compiles down to an intermediate representation that we call the abstract circuit intermediate representation. This IR, we call it the Acer, can be compiled down to a rank one constraint system or plonkish languages, really any MP complete language this IR can compile down to you can think of this as being analogous to something like the Lovmir, but rather than converting down the IR to a machine specific instruction set architecture, we are converting our IR to the constraint system of a given ZK proof construction.
00:03:42.610 - 00:04:22.670, Speaker A: This then enables us to have the decoupling of the backend proof system and the language. We currently have one fully integrated backend. That's the Aztec Brettenberg library that uses turboplunk. However, we do have plans for further integrations, such as GRaS 16 halo two. We do have an integration with Marlin. However, there are some missing features still, so I can't call it a full integration. And due to the fact that we have this, our IR allows you to have essentially these proving system optimizations, which essentially means custom gates.
00:04:22.670 - 00:05:10.970, Speaker A: And with Noir we're providing an interface where you can optimize circuits on the proving system layer. So we have these black box functions that we call like they're part of our standard library. We call them black box because their implementation is done by the proving system. A few examples of some of our standard library functions are shot. 56 Patterson Merkel checks however, there's many different optimized functions that we support. Noir was started with three main goals in mind, safety, simplicity, and performance. By being more high level, Noir can abstract away much of the cryptographic safety that would otherwise be necessary in a ZK circuit language.
00:05:10.970 - 00:06:18.706, Speaker A: The standard library then enables usage of cryptographic primitives with relatively little knowledge of the underlying checks and constraints necessary to keep that Zk circuit safe. And like how noir is rust based, we are also rust like in our syntax as well, with some slight adaptations. We try and have common programming constructs within Noir, just as you would in any other normal programming language, and make them simple to use. You can constrain variables based upon conditions and loops, and you can also constrain on any integer data type, as they will all ultimately translate to our native field type. We have flexible code organization so that you can separate your code into modules and external crates, which will enable developers to easily create libraries for noir programs. However, although noir is very high level, we do not look to sacrifice performance while adopting these higher level concepts. Noir compiles down to an intermediate representation similar to Lovm.
00:06:18.706 - 00:07:36.930, Speaker A: Before then compiling further down to the AceR, we optimize both this intermediate representation as well as the Acer. And then due to the fact that Noir has this Acer and is backend agnostic, we can also optimize at the proving system layer as well. Optimizing on the proving system layer is what enables us to significantly reduce our circuit size and thus speed up proving time, as we will now have a smaller circuit. I want to take the chance, though, to highlight some more of noir's more important features that are supported, and show you some more of the noir syntax before we just dive straight into the coding example. First, right here, I want to show you how you can easily separate your circuit logic into modules. A developer can import functions as you would in any other programming language, such as Rust, and then we also have globals that can be accessed inside multiple functions of a module, as well as function parameters, and then they can also be imported like a function would, in the same manner you would expect. It's important to take note, though, that we currently restrict globals to only literals such as fields or ints, and then there's also array literals in the pipeline.
00:07:36.930 - 00:08:51.062, Speaker A: There are plans to possibly enable compiled time expressions for globals, but right now they're currently restricted with an easy to reason about structure. We hope to make it easy for developers to construct libraries for their circuits and organize their projects, as this is the first noir snippet that I've shown you, I want to take the chance to highlight the field type, as I've already mentioned it a couple of times. This is Noir's native data type, which is derived from the proving system. In the case of Aztecs Brentenberg, the field is a 254 bit finite field value from the VN 254 curve, and then all of noir's integer data types will ultimately translate to this field, as they're just field types with range constraints, where we say that it has to be within this size bit size. So this field type though doesn't have to be 254 bits. For example, with Marlin you can have a field based off of the BLS 381 curve, but with Aztec you can always think about it being 254. Noir also has compound data types such as arrays, tuples, and structs.
00:08:51.062 - 00:09:42.566, Speaker A: In this snippet I'm highlighting two of these compound types, specifically arrays and tuples. Many of you may immediately already notice what is happening in this snippet. We are generating a Merkel route from a provided hash path and leaf node. This logic can then be used to construct a Merkel inclusion proof circuit in noir. This method does live within our standard library, and this is why you might see the usage of that crate prefix when I'm importing different functions. If you were to write this in your own noir crate separate from the standard library, you would have to import using the STD prefix rather than the crate prefix, and you're going to see that in some later examples and also the coding sample. And if you've already not taken note, you can see specifically the usage of tuples in the snippet inside that main if expression in the for loop.
00:09:42.566 - 00:10:48.694, Speaker A: And we're using that to set our left and right side of the Merkel nodes that we are going to be compressing to get to the Merkel root. So here's also an example of our structs that enable you to easily group data. These structs can be nested and they can implement public functions on them. We do also have the concept of self, as you can see in the snippet, and this is obviously very beneficial to you as a developer to be able to group data in this way. We support for loops and if statements and also logical and bitwise operators. In this snippet here, I am transforming a field element into a byte array using our standard library two bits method. If you look inside the inner for loop of these two for loops, you can see how I'm utilizing bitshifts, but also the or bitwise operator as I'm using bitwise or on u eight here, it will act as you expect for bitwise or also support bitwise.
00:10:48.694 - 00:11:38.182, Speaker A: And however, this bitwise or and can be used to mock what a logical or and operator would perform. Except that would be if you're performing it on a u one, our bool type translates to a u one type. So if you were to perform a bitwise or operation on two boolean statements, you can expect it to act as a logical or operator. And so this is how we currently mock logical or and in noir I want to show a bit more of the control flow. So here's a basic quadratic sort written in noir, as we did in the previous slide. You can see I'm nesting for loops and conditionals. It is then possible to constrain upon values altered inside of conditionals and loops when specifying constraints directly.
00:11:38.182 - 00:12:29.530, Speaker A: A lot of this conditional logic usually is handled in kind of an arithmetic expression such as a multiplexer. However, we abstract away much of the constraint generation for the developer. So we want to enable you to continue programming as you would expect in a classical Zk programming language, but now you are in a Zk DSL. We also have recently added generics, which are highlighted in this snippet here. There are two examples where the generic is defined directly, and also where the type is implied. First class functions are also active work in progress. We don't yet have a trait construct, but once these first class functions are implemented, it will be possible to mock the functionality of traits using first class functions, generics and structs.
00:12:29.530 - 00:13:16.902, Speaker A: So just a little warning, Noir is a work in progress. Do expect bugs and do expect some limitations with the language. However, we're proud of where it's at right now and expect constant improvements as we are going to be continuously iterating upon noir. So now let's get into how we would actually go about writing a noir program. So typical three step process. We have to set up and write our noir program, and then because we were writing a ZK circuit, we then have to prove and verify that program. So here is Noir's native package manager.
00:13:16.902 - 00:13:57.800, Speaker A: This is also the link that was sent out before the workshop. So for whoever wants to follow along, please scan that QR code and follow the instructions for installation. So Nargo is Noir's package manager. That is comparable to also Rust's package manager, Cargo. Nargo provides also all the necessary tools for proving and verifying your circuit. Aside from just compilation and proving and verification though will always require the backend proof system. So currently Nargo has to be compiled with an integrated backend system.
00:13:57.800 - 00:15:07.200, Speaker A: So we have binaries on that installation page for your respective environment and you can also compile it from source. However, unless you already have a set up environment, I recommend just using the binaries as the back end system is a big c plus plus library and compiling it from source might not go perfectly for you. So I'm going to just wait like 2 seconds, let people install it if they can give people a couple of seconds. I see someone posted the link. Thank you for that and I'm going to move on right now, but I'm just going to do a basic setup walkthrough and then there will be time to get Nargo set up. Once you have Nargo installed, we can make a very basic project. So create a directory where you want your project to live, and then if you've followed the instructions correctly, Nargo should then be installed into your path.
00:15:07.200 - 00:15:53.808, Speaker A: And so you can just call Nargo anywhere on your machine. So you should be able to do a Nargo new cas ballot. And this will create a very basic program that'll have a Nargo tomal file and a source file containing this main right here that looks like this. Nargotomal is a packages manifest file similar to cargo tomal that you would see in rust or package JSoN in an NPM project. If you're unfamiliar with rust, this is where we specify the compiler version as well as all your dependencies. The standard library is an external dependency, but is automatically added as a dependency. So that's why you're not going to see it listed under the dependencies there.
00:15:53.808 - 00:16:48.196, Speaker A: And if you look at the project, the snippet on the right, I also show an example of how you can import a local noir crate and use it as a library in your noir project. We also allow specification of git dependencies that would just require, instead of a path, you would have a GitHub URL and a git tag. And this can be seen. You can see how to do this in the book. So once you are assuming you're within the Nargo project that you just created, you can then run a nargo build and it's going to look at your main nr and look at the main function and see what inputs and outputs you have. If you look here, you can remember I have two inputs. One of them, though, has this pub keyword.
00:16:48.196 - 00:17:22.868, Speaker A: So all inputs to noir are going to be private by default. And you just have to use that pub keyword to say I want. The verifier also needs access to this input. So that's why you see, when we do this nargo build, we have an Xy in the proveral and then just a y in the verifier tomal. So now we're actually then going to prove the execution of our noir program. This is going to be done by whoever wants to prove something to the other party. So this could be one of the players of a game.
00:17:22.868 - 00:18:14.288, Speaker A: This could be someone you touching the finances of a company, or for example, what we're more familiar with a roll up sequencer who's rolling up all your programs to submit to Ethereum. So once your proveromal is filled in, because our circuit is just checking that x and Y are not equal, we're going to pick one and two as our values. Then we're going to run Nargo proof P. P will just be the name of your proof file that gets generated and spit out into a proof folder. And then now we can actually. Let's verify our proof. So in the examples I talked about earlier, the verifiers would be the other player in the game, an external auditor, or in the case of a rollup sequencer, the smart contract.
00:18:14.288 - 00:19:01.696, Speaker A: That's where you're verifying your roll up. However, we can just verify Nargo here. So we're going to do a Nargo verify P. It's going to look into that proofs folder that was created by Nargo proof, and it's going to use that proof to run verification of the program. And then you'll see the verifier tomal is also auto filled for the public input, as it can get it from the prover. So one thing to note here though, is if you are to change your x and Y to both be like one, or both be two, Nargo won't even let you generate a proof. It'll return all constraints not satisfied, because that proof is going to return false.
00:19:01.696 - 00:19:42.064, Speaker A: You could theoretically get around that and generate a proof yourself. But then if you try and verify that proof, that does not fulfill the logic. You're going to get a proof verified false. So you can try that as well right now if you're curious, but it should not let you generate a proof. So just to recap, we have our typical noir flow of setup, prove and verify setup. You might have noticed it's missing something, that if you're familiar with ZK proof systems, we don't have any kind of trusted setup that we were doing. This is because we're using the noir Bretonberg back end.
00:19:42.064 - 00:20:25.232, Speaker A: So the common reference string that we're using for all our proof programs is the same one from the aztec key generation ceremony all the way back in 2019. So this avoids the need for a trusted setup at the moment. But as we hope to have like grot 16 integrations and stuff in the future, we will probably enable you to also do a setup through Nargo. Okay, so now I'm going to take a chance to look at if there's any questions and answer them before. Can you take an array as public input? Yes, you can. Actually. Yeah, you can.
00:20:25.232 - 00:21:10.060, Speaker A: You can take in an array we just recently added. You can also have structs as inputs. However, those structs have to have either just arrays or field or integer types. Is noir currently using the aztec backend rust repo? Yes, that is our current backend. That's the one. We have the Brettenberg crypto library that's written in c, but we have to do some extra rust over top to have it interact with noir correctly. Will enum be supported soon? I don't know the timeline for enums in noir, but you probably could mock this functionality.
00:21:10.060 - 00:22:18.752, Speaker A: Is the field always the same? The field would differ dependent on the proof system. So right now with the aztec back end, it's going to be 254 bits, and you can do operations on it, such as addition, multiplication, addition, division. But you can't compare fields though the comparison operators aren't going to work because fields aren't necessarily ordered. So you have to have integers where there's those, like where you've had put range constraints on your field. We have a lot of questions here. There isn't a full documentation of the standard library yet, but you can look in the main noir repo and one of the main folders is the noir standard lib, and you can look at everything that's supported there. Ignite SRS is the common reference.
00:22:18.752 - 00:22:19.590, Speaker A: Yeah.
00:22:19.960 - 00:22:26.310, Speaker C: When you're answering these questions, can you just remember to say the questions? Because for the video after, no one's going to know what the.
00:22:26.760 - 00:22:30.680, Speaker A: You're right. Thank you. I think there's so many, I stopped saying them out loud.
00:22:32.860 - 00:22:35.144, Speaker C: I think you have three more to the top.
00:22:35.182 - 00:24:05.610, Speaker A: Okay, so one of the questions is, what is ignite SRS? That's the common reference string from Aztec's ceremony all the way back in 2019. It's what we use to. It's our common reference string for all our noir programs with the aztec back end that lets us generate our proving and verification keys. What kind of optimizations do we perform at the IR level? That's a good question. So there's technically a couple things that get done, because if you think about it, we have the intermediate representation and then we also have the Acer. So that intermediate representation, we do a lot of the optimizations that you would have in the normal kind of lovm ssa pass we have inlining, we do common sub expression elimination, we do unrolling, loop unrolling and all that in our SSA pass. And then also with the AcER, we do some basic optimizations as well, where we simplify some of the bivariate equations and we also remove kind of all coefficients in our equations that might have zero, just so that we can reduce the number of gates that you're going to have in our representation and then reduce your circuit size.
00:24:05.610 - 00:25:07.572, Speaker A: If you look at our documentation, we have a compilation overview and you can get the exact details of how we go through the optimizations for the Acer. Are you planning for any security related tools for auditors? That would be awesome. We don't have immediate plans for that at the moment, but that would be nice to have. Any word on IVC recursion vnoir by IBC recursion, I'm not sure what IBC means, but I'm assuming you just mean proof recursion in or there's. That's one of the main things we want to add. That's one of the immediate things hopefully should happen is on the pipeline. All right, I think I've answered a bunch of questions just now, and it would be good time to move on to the next part of the presentation.
00:25:07.572 - 00:25:20.350, Speaker A: But just throw them in. And we're going to take periodic breaks to answer more q a questions throughout. All right, I'm going to stop sharing now, and I'm going to let Joss take over.
00:25:20.960 - 00:25:21.790, Speaker B: All right.
00:25:24.800 - 00:25:25.676, Speaker A: Here we go.
00:25:25.778 - 00:25:27.410, Speaker B: Is that coming through? Okay.
00:25:30.100 - 00:25:31.410, Speaker A: I can see it.
00:25:31.780 - 00:26:20.080, Speaker B: Cool. All right, so the example we're going to be building together is on a simple quadratic voting app. So, first off, what is quadratic voting? You may have come across a concept or a similar form of the concept, say, on gitcoin. They have a quadratic finance there. So we're going to look at it in the context of voting here. We got two ballot cards for a range of candidates, and the idea is that you buy your votes for a particular candidate by spending tokens, but the cost of each successive vote is more expensive. So, you see, the cost of one vote is one, cost of two votes is four, three is nine, et cetera.
00:26:20.080 - 00:27:05.372, Speaker B: On the right, we've got a ballot being cast by somebody who really wants candidate five to win. That's all they care about. So they've just spent all 100 tokens that they're allowed to spend on buying votes for this one candidate. This other person here. They also want candidate five to win, but they're willing to put aside some of their tokens to express what compromises they're willing to make. And because they're willing to do that, they have more voting power. The voter is incentivized to consider what compromises they're willing to make.
00:27:05.372 - 00:28:30.392, Speaker B: You see, their vote is 80% more powerful than the person who is not willing to consider compromises. So we're going to be building such a system, and because we're building it with Noah, we're going to be able to have the voters hide their different preferences from everybody else, apart from the ballot manager, who they're going to submit their ballots to. The ballot manager will be able to see everybody's votes, but they won't be able to censor or modify them because they're going to be summing those ballots via a verifiable, zero knowledge proof. So here's a simplified view of the architecture. We've got two voters here, Alice and Bob. They've both got their ballots, and they're going to feed their ballot into a circuit locally, and that circuit is going to output, a commitment which is going to go onto a smart contract or doesn't actually have to be a smart contract, could be a peer to peer network, something like that. And then they're also going to send their ballot to the ballot manager and they're going to aggregate all the ballots together and then send a ZKP to the smart contract.
00:28:30.392 - 00:29:33.360, Speaker B: Again, who is going to verify it and say, yes, I can see all of the commitments have gone into this proof and the result that you've given me must be valid. So again, this is what each circuit does. So we've got a user circuit who is going to enforce a quadratic voting rules. So check that the numbers add up correctly, expose a commitment which is going to go onto the smart contract. Then the manager, they're going to take the ballots and sum them together and also prove that all their commitments have been incorporated into this summation. The smart contract is going to validate both of these proofs, or in the case of the users, every single proof submitted by a user, a voter, and it's going to store these commitments to be used later for validation of the summation, the aggregation proof. So in a bit more detail here, we've got a voter's ballot.
00:29:33.360 - 00:30:15.816, Speaker B: So they express their preferences, their votes for each candidate. To keep things simple, candidates are just identified as their index in an array. So we got 0123. Also included in the ballot is a secret. Now the secret is important because if you didn't provide a secret when you come to hash your different votes, the commitment that you output is vulnerable to a brute force attack. It would be pretty trivial to consider what all the different permutations of votes are. Hash them all, see what all the different commitments there are that can be produced.
00:30:15.816 - 00:31:20.960, Speaker B: So we need this secret ingredient to add some noise here so that the commitments all look unique. And the other thing this circuit is going to have to do is check the constraints. So we got to check for each of these numbers squared is going to be less than or equal to the token budget. The manager, they're going to take these ballots, they're going to also perform that same hash that the user performed and check that it is consistent with the commitment that was provided publicly earlier posted on the smart contract. Then at the end they're going to output the summation. So four plus zero, four three plus four, seven, et cetera. So first exercise we're going to be looking at the enforcing of the QV rule, which is checking that sum of the votes squared is less than or equal to the budget.
00:31:20.960 - 00:32:07.296, Speaker B: And we want to do this because this is how we know that we're following the rules of the game. In order to write this, we're going to be using a few of Noir's concepts. We're going to be using mutability because we're aggregating a sum. We're going to be looking at a few types. We're going to look at the global type for sizing the arrays, the integers which are going to be summed together, and the array that we're going to be iterating over, which is going to contain all the votes. You're going to iterate using a for loop, and we're going to be using the constraint keyword. Now this is an important concept which, if you've not written circuit code before, is new.
00:32:07.296 - 00:32:38.344, Speaker B: You won't see this in more traditional programming languages. This is the ingredient which allows you to say this circuit tells you that a certain thing is true. It looks a bit like an assert statement in other languages, except if you played with circum. It's different from the assert in Circom, which won't actually affect witness generation, but in the case of noir it does. Right on. Mutability. This is what declaring a mutable variable looks like.
00:32:38.344 - 00:33:10.864, Speaker B: You need the mute keyword. If you don't have that, then reassigning it is going to throw an error. This is what a global looks like. Globals are constant. You don't need to worry about a global getting reassigned and causing confusion later. An unsigned integer has its type constrained using the u, followed by the number which specifies the number of bits. So this is an eight bit integer and an array.
00:33:10.864 - 00:34:16.184, Speaker B: It follows this syntax here of saying what type the element is, and then the number of elements. You can assign it as a literal. There's also another literal assign you can do, which is like the first element is how you want to initialize every element in the cell, and then you have a semicolon and then the number of elements. This is what a for loop looks like. So you've got the range operator, which is familiar from rust, and here's a constraint keyword, so you can just have whatever binary operation you want to use here. So we're going to give you a bit of time to mess about with these concepts. If you go to the docs page, you'll see all of these ideas that we just covered there, and we'll give you a bit of time to check that you can compile a program, sign a variable, do a for loop, and then once we've done that.
00:34:16.184 - 00:35:11.900, Speaker B: We'll look at the spec for the first function that we want to implement, and then we'll go on to the implementation. In the meantime, it's probably a good time to take some questions. So in Maxime's part of the presentation, we saw that we can have an array without specifying a length. Is it a feature only available for the main function? Oh, hang on. Main function parameter. So for the main function, you will always have to specify a length of the array, because when the circuit gets compiled down, it has to have fixed length arrays. When you are writing more general purpose functions, you can write an unsized array as your function parameter.
00:35:13.760 - 00:35:56.810, Speaker A: You might have seen it in the, I think my compute root from leaf function, the hash path. It looks like a variable sized array, but that method is going to be called from a main function, and the main does have to, we do have to know the array size. We don't have variable sized arrays from main just yet. So the compiler would then figure out that the array being passed later down to another method that has a variable size parameter. What that array size, what that array size is. You currently do need to know the index of an array. It has to be compile time.
00:36:00.940 - 00:37:00.780, Speaker B: Got another question. Where do we see noar a year from now? And what features does the team want to see integrated? So I think in the short term there's a lot of features which just need fully integrating with each other. So we have arrays as inputs, but it'd be great to have arrays obstructs. I think that's going to be a great improvement to the language. This is what I'd personally like to see. Other big work we're going to be doing is related to the aztec free roadmap. At some point we've got to consider how we want to make the language extendable, to consider concepts like private state, getting setting of private state on contracts, that kind of thing.
00:37:00.780 - 00:37:07.840, Speaker B: Note that no r itself will never be a contract language. That would be an extension to noir, which would enable that concept.
00:37:09.540 - 00:37:37.064, Speaker A: Yeah, I think stateful noir is one of the big things that could be happening a year from now. Extraneous features like recursion and proof recursion inside of noir and other things should hopefully be happening sooner. I think the more exciting stuff is stuff like stateful noir and the extension language for smart private state like Josh just mentioned.
00:37:37.262 - 00:37:41.660, Speaker B: Yeah, I'm excited for proofrecursion. That should enable a lot of new use cases.
00:37:44.080 - 00:38:47.330, Speaker A: Thomas asked, how could you do a tornado cache like proof where you want to prove that a hash is included in a list of all user deposits. If your list has to be fixed size, well, you could do that through that compute route from leaf method. Tornado cache doesn't necessarily have a list of all user deposits. It stores it as a Merkel tree. So if you provide the correct leaf node and you provide the hash path up to the root of that tornado cache contract where the merkel tree is stored, you can do a tornado cache like proof. Yeah, you could theoretically mock it by having user deposits of a list of a max size of some sort, but you can also do it through a Merkel tree instead. And the hash path will always probably be like depth of 32 or something like that.
00:38:47.330 - 00:38:54.790, Speaker A: Take one more question, and then we can maybe move on to the next part.
00:38:55.560 - 00:39:01.990, Speaker B: All right, we've got is reference type, I e. Ampersand. Not implemented yet.
00:39:02.680 - 00:39:27.630, Speaker A: No, it is not. That would be a little bit challenging of a thing for a ZkDSL. That would essentially mean we have non determinism. This is actually very powerful, though, and it's something we want to implement, but we have to be careful about it, and we hope to have that eventually. But right now, no.
00:39:29.940 - 00:40:04.570, Speaker B: Cool, I'll move on. So, here's the spec for the function we want to write. We're going to be checking this quadratic function. So we are going to be aggregating the square of each of our votes and then checking that that summation is less than or equal to the budget. So our function is going to have two inputs. It's a budget that we're adhering to, and all of the votes that we're going to be iterating over, squaring, summing. And then at the end of this function, we're going to be performing this constraint check.
00:40:04.570 - 00:40:35.590, Speaker B: So, if you haven't already, as Maxime prompted earlier, create a Nargo project, a noir project, using Nargo new. Go in there and open your main file and get coding. And I think we're going to give you seven minutes to have a go at implementing that function. In the meantime, we can take any more questions if people want to ask.
00:40:46.710 - 00:41:07.340, Speaker A: Yeah, if you have errors, we can maybe answer them, too, although we're not looking at. It's hard to see what exactly. Everyone's coding, but. Yeah, Joss, maybe we go back to the specs. Someone just asked, can you give a link to the specs? Maybe we go back to that page.
00:41:08.030 - 00:41:09.340, Speaker B: Yeah, sure.
00:41:14.270 - 00:41:51.030, Speaker A: Wisdom you asked. Cannot find module. If you installed it using the. That's reminiscent of an old error that I'm surprised you're getting. If you installed using the binaries, it should be installing with a tool that doesn't use this old wasm based back end we had. You could also try to use the compile from source. You're just going to have to use the wasm executable back end.
00:41:51.030 - 00:42:06.380, Speaker A: It's in that installation guide. It's going to be option 2.1. You're going to have to replace the dependency in cargo tomal, but that should hopefully solve that.
00:42:07.070 - 00:42:14.960, Speaker B: I'd say it's worth noting if anybody is using an old installation of Nargo, it's worth updating because it changes quickly.
00:42:19.670 - 00:43:15.082, Speaker A: How can you pass in an array as input in the prover would be. You would specify it as you would in a list in a tomal file. Normally you would just have two brackets and then your list of numbers. I'm actually going to drop a link in one moment to our nargo tests that should have some examples of just some of the different inputs and all that, so you can get a look at it. So here's a link to an array test inside of noir. You should be able to see in the proveral there how you would specify an array in the tomal file. There's also from that same link.
00:43:15.082 - 00:43:21.950, Speaker A: You can go back into the test data directory. You'll be able to see a bunch more examples where we test noir.
00:43:25.010 - 00:43:28.160, Speaker B: We have a question. Sorry.
00:43:30.710 - 00:43:32.180, Speaker A: No, you got it.
00:43:33.190 - 00:44:19.900, Speaker B: Should we call our function main or check within budget and call it from main? So I would create a new function check within budget and you can call it from within main. You don't actually need to call the function in order for the program to compile. At this point, we just want to check that you know how to write the right syntax, but if you want to build and run it, then yeah, you would want to call it from main. Oh, right. Sorry, I did not bother explaining that candidate count is a global. I should have said that. So if you put that at the top of your file and set it to some number like ten is what we've been using.
00:44:19.900 - 00:44:30.480, Speaker B: So you'll have global candidate count equals ten semicolon, and then you can use it later on in your function signature.
00:44:36.190 - 00:44:53.780, Speaker A: And if you do write a main function that calls check within budget, and you'd also be taking in just like that there. You can use that candidate count in both the function signature of your main and then your check within budget function as well.
00:45:11.600 - 00:45:36.990, Speaker B: We'll give you another three minutes. We got a question. Is no r suitable to be installed in ubuntu 18.
00:45:40.610 - 00:46:08.760, Speaker A: It should be. I recommend just using the binary for this presentation, but you should be able to compile it from source on Ubuntu. Actually probably easier than on Mac or Linux due to the c plus plus back end, but I've mainly been working on Ubuntu 20 and some people have done 22, but I don't see why 18 would be a problem.
00:46:27.400 - 00:47:14.714, Speaker B: We have a question. Could we give a sense of what schemes are supported via what back end and if and where a solidity verifier is available? And do you have a roadmap that we can use to plan contributions? So at the moment the only backend that's fully supported is the Barrettenberg backend, and there is a command for generating a verify contract for proofs in this proving back end. As for other proving systems, do we have a roadmap? I imagine we'll be putting out grants.
00:47:14.762 - 00:47:38.950, Speaker A: Perhaps we're in discussions with some people who want to integrate backends with regards to someone planning contributions. You can take a look at our GitHub. We have issues, a bunch of issues. We probably should label which ones are better to get started with for the first time, but I would say it's not a roadmap, but it's somewhere to look if you're planning to contribute.
00:47:43.690 - 00:48:21.632, Speaker B: Shouldn't token budget be a field type? So the reason that we're not making it a field type is because of this part of the spec here. Laser pointer. We've got a range check here. If it were just a field, you wouldn't be able to do a range check. The concept just doesn't exist for fields. They don't necessarily have an order, but integers do have an order, so we need it to be an integer. Can an integer sum overflow, although you feel that one?
00:48:21.766 - 00:48:38.650, Speaker A: Yeah, but you can have overflow, same thing with, you know, multiple multiplication and all the other operations like that.
00:48:40.380 - 00:49:22.832, Speaker B: Cool, that's time. We'll come back to more questions later. So here's a solution, so global defined as stated. Here's our function signature. So we got the token budget, our U 32 type, and the array of votes, which is of length, candidate count, and all the elements are of type U 32. Here's our mutable variable, our mutable U 32 that we're going to be aggregating into. We're going to initialize it as zero, and we're going to iterate over every element in the array.
00:49:22.832 - 00:49:53.230, Speaker B: And that array is of length, candidate count, and for each one, we're just grabbing the vote. We're going to square the vote and we're going to add that onto the existing value of token spent. Then at the end we're going to check that token spent is less than or equal to the budget. That's it. I mean, this is just one way of implementing it. There are other valid solutions to this. That's the one we've gone for.
00:49:54.100 - 00:50:27.476, Speaker A: I guess I can answer a couple of questions though, while he's out. So just specifically, I saw one of them. I made your same solution, but I'm getting an error for I in zero to candidate account, the range of a loop must be known at compile time. I'm surprised that's the thing I mentioned earlier with how the array index must be known at compile time. But I'm surprised you're getting an error if you wrote the same exact code. I'm going to be posting the answers. I just posted it in the chat.
00:50:27.476 - 00:50:48.416, Speaker A: This is for the example 2.1 that we just did. So you can copy this code if your snippet isn't working and you want to continue following along with the other sections, and I'll continue posting updates for the new snippets once we get there. So if you have that error, Josh, you want to test out your audio real quick?
00:50:48.518 - 00:50:59.270, Speaker B: How's my sound now you're good. Wonderful. Right, hang on. Got to turn the questions filter on again.
00:51:00.280 - 00:51:32.872, Speaker A: So do you have simple debug tool like printline macro to trace the circuit? Not yet. We really want to add logging. This is something we do want to add. You can kind of debug using the constraint statement to determine where something goes wrong in your circuit. But it's right now very manual in the developer to debug. And we do want logging. It's one of the main things internally, these U 32s should be represented as field elements.
00:51:32.872 - 00:52:13.660, Speaker A: Yeah. All our integers ultimately translate to our native data type. A U 32 is just a field type with range constraints and that's also why we're using. But we need those range constraints to enact some type of order for when we do comparison operations like greater than and less than. Will we get a plus equals operator soon? Don't know. Maybe right now? No, you can mock it without. It's not a high priority because you don't have to use it to achieve the same functionality.
00:52:13.660 - 00:53:03.596, Speaker A: I saw the loops end with semicolon. Why is it necessary? So this is a kind of long story how we got here, but we used to support that you could aggregate the result of a for loop into an array. But we removed this functionality, but we were planning to add it back right now. We just added that literally like yesterday or something, that semicolons are no longer necessary. They're optional for four expressions. I don't know if the recently updated binary will yell at you for that, but in these examples I believe we have semicolons behind all our for loops, but won't be necessary anymore. Is the Vec macro not supported? No, we don't have those macros right now.
00:53:03.596 - 00:53:46.840, Speaker A: The only macros we really have are the ones that tell you whether or not a function comes from the back end. And I'll answer this last question and then we can go to the next section. Does the main function always return nothing? Can it return a Val which can be a public output? Yes, you can return values from main, we just haven't yet. And in the examples I provided, Main has not had any output and the output has to be public. It's essentially treated like syntactic sugar, as like a. You could think of it as like a public input as well, but you can return stuff from main. And I'll let Joss continue with the presentation.
00:53:47.740 - 00:54:38.360, Speaker B: Yeah, we're going to see that shortly, in fact. So moving on, we're going to jump over to the counterpart circuit. We're going to go over to the ballot manager circuit, who is going to count up these votes that we're producing on the other end. So we want to reveal the totals of all of the ballots summed together so that we know the result of the vote. We're going to be touching on some similar concepts again. To do this, we're going to be aggregating again. So we're going to be using mutability and we're going to be defining array lengths and globals, and we're going to be taking in votes as integers, so we'll be summing them as integers and we're going to be dealing with a nested for loop.
00:54:38.360 - 00:55:14.644, Speaker B: So at the moment we can't currently do 2d arrays. So we're going to flatten our array of ballots, which is kind of like a 2d array. Each ballot has got ten votes on it. So if you got an array of ballots, then that's like a 2d array, but we're going to flatten it for our purposes until we do have support for that. But we're going to need to do a nested for loop to iterate over that flattened array. And then we're going to look at return statements as well. So this is what a nested loop looks like.
00:55:14.644 - 00:55:46.224, Speaker B: Pretty much what you'd expect, one loop inside another. And you can see here's an example of some 2d array index arithmetic. Here is a return statement. So, like in rust, if you want to return something at the end of a function, you simply just don't have a semicolon at the end. So that final expression is what gets returned. Here's a function that returns 42. And then here's main, which is returning the value which is returned by get answer.
00:55:46.224 - 00:56:36.832, Speaker B: And again, there's no semicolon here. Notice at this point, we have specified a return value for the main function. And as Maxine was saying earlier, it has to be public. So we do explicitly state that it is a public type. And when you come to run the Nargo prove on this, if you leave the return property in the provermal as blank, then Nargo is going to infer that it should automatically generate it for you, and it will do that in the verify tomal. So here two a, that's 42 and hexadecimal. So we're going to give you a couple of minutes again to mess about with those concepts again.
00:56:36.832 - 00:56:55.350, Speaker B: You can look them up on the docs, and then we'll probably take more questions while you do that, and we'll return to the specification of the function that we want you to implement. After that, we got somebody saying that they were able to compile their four expression without the semicolon, so that binary must be out.
00:56:57.800 - 00:57:06.644, Speaker A: Well, that's good then. So I guess not necessary to have the semicolon. You can still have it, but don't.
00:57:06.692 - 00:57:45.652, Speaker B: Need it question, would you mind explaining the contents of the ToML files a bit more? So, there are three toml files. There's the nargo toml, which is where you're going to state your dependencies for your program. In the case of this one, we're not using any external dependencies, so you won't need to touch that file. Then you got prover Toml. This is where you can mock your inputs to the circuit. So you will write x equals whatever value, y equals whatever value, and return equals whatever value. If your public function, sorry.
00:57:45.652 - 00:58:23.334, Speaker B: If your main function has a return, then the return property name is what gets matched to that. Then there's also a verifier Toml. Once you've generated your proof, you will want to verify it. So inside your verifier Toml, you are going to state properties again. But those properties are going to be whatever public inputs you have to your main function. What do we have to do for this task? Sorry, so the task hasn't started yet. We were just talking about the concepts you're going to have to use.
00:58:23.334 - 00:59:06.658, Speaker B: So the returns, the nested loops and using, generating a return automatically. We're going to move on to the task now. So here's a spec. We're going to write a function, call it sum votes, and that is going to take a 2d array of a flattened 2d array of elements of all the votes, and it's going to turn that into a 1d array of totals. So here's what our input variable is. Notice that you can actually do arithmetic of globals inside the type declaration here. So this is a vote account of ten.
00:59:06.658 - 00:59:27.210, Speaker B: Sorry, a vote account of. We're just going to do two, Alice and bob, but you could do whatever number. In principle. It's just easier to test if we're doing two. For now, candidate account, we'll want it to be the same as we had in the other circuits. So we'll set that to ten. So global candidate count equals ten, global vote account equals two, and they're going to get multiplied together.
00:59:27.210 - 01:00:02.946, Speaker B: So the signature here is an array of U 32 of length 20. And then our function is going to output our array of totaled votes, and that's going to be of length ten, the candidate count. So, yes. Important to note, we're now doing this in a counterpart circuit. We're not doing this in the cast ballot circuit anymore. So you'll want to go up a level and create a new nargo project. Can call it count votes.
01:00:02.946 - 01:00:24.690, Speaker B: Go into there, go into the main file and start writing your function in there. We'll give you seven minutes to try that out. Seven minutes. Too generous. How are we doing for time? We got like 30 minutes left. We'll call that five minutes.
01:00:26.340 - 01:00:28.400, Speaker C: Actually, I think you have a bit more time.
01:00:28.550 - 01:00:29.490, Speaker B: Oh, yeah.
01:00:30.900 - 01:00:40.116, Speaker C: Our current trajectory is at seven or like at seven utc. So in 50 minutes we start the job fair.
01:00:40.298 - 01:00:41.350, Speaker B: Oh, okay.
01:00:41.720 - 01:00:55.368, Speaker C: A little earlier, we have a few slides, but not too much. There are a few more questions in the Q and a right now. And also just a quick did you answer the tumble file question explaining the contents of that?
01:00:55.534 - 01:01:01.144, Speaker B: Yeah. So we talked about the three tumble types, Nago, the verifier and the prover.
01:01:01.272 - 01:01:10.236, Speaker C: Okay. So I hope it's okay if I mark that as answered. But yeah, there was two more. One is like, yeah, just not sure how to.
01:01:10.258 - 01:01:49.052, Speaker A: So what do we have to do for this task? That's I think he asked that before we got to here, so that one should be answered. Maybe we can go back to the specs so people can have a look at it then. But there's one more question I didn't answer. Understand very well, we need to recreate a project. Yeah. So the previous circuit that we just wrote that function check within budget, that's checking on the person who's voting side. They're submitting a Z pay proof for that.
01:01:49.052 - 01:02:50.540, Speaker A: But then there's going to be a separate circuit for the actual ballot manager who manages these circuits. So it's going to have to be a separate project. So you're going to CD out of that old project you made for the check votes within budget, and you're going to create a new one for the ballot manager. And that's where your sum votes method is going to live it. If that's not clear, perhaps we can go through the infrastructure of the circuits once more. But essentially you're going to have two separate entities here. How do I create a new array? I can type something in the chat.
01:02:50.540 - 01:03:22.100, Speaker A: If I do let x equals. I see someone posted a reference to the project, but I would say hold off on that unless you want to get a peek at the answers. But there's some good examples of how to declare stuff and other projects in the Nargo tests.
01:03:39.680 - 01:04:23.880, Speaker B: Is the input flattened in this weight in this way? Vote one one, vote one two, vote two, one, vote two two. Yes, though it will be more than two votes per user. It'll be ten. So it'll be vote one one, vote one two, vote one three, vote one four, et cetera, et cetera, until you get to vote two. Actually, it'll start with vote. We're indexing from zero, right? So vote zero zero, vote zero one. But let's say that Alice got their commitment in first and then Bob got their commitment in.
01:04:23.880 - 01:04:44.140, Speaker B: So all of Alice's votes, followed by all of Bob's votes. Maybe it's okay for us to share the gist of the prover input for the ballot manager, since that's not actually a solution.
01:04:51.980 - 01:04:53.544, Speaker A: You doing that, Joss, or should I.
01:04:53.582 - 01:04:56.696, Speaker B: Grab the link if you beat me to it?
01:04:56.878 - 01:05:05.884, Speaker A: I got it right here. The prover tomal for the here, though.
01:05:05.922 - 01:05:15.280, Speaker B: Notice in that prover it's also got some extra ingredients that you don't need yet. You only need the votes so you can comment out the other bits.
01:05:40.010 - 01:05:42.300, Speaker A: Give it two more minutes, I guess.
01:05:43.790 - 01:08:00.050, Speaker B: Yes. I got two on my timer. Does the silence mean that it's easy, everyone's already done it. Or very hard question, do you need to allocate the output array? Sort of. You need to declare your mutable array element. Sorry, your mutable array variable. And you'll probably use an array literal, and that's going to have a length in it.
01:08:00.050 - 01:08:34.990, Speaker B: So you're sort of allocating the number of elements in that array then. I don't know if you'd think of it as allocate in the traditional sense, since memory management isn't really like a concern of noir, as far as I'm aware. What's the constraint here? There is none, actually. So there's an implicit constraint, which is the output of this program is consistent with what it's supposed to compute, but you don't have to use a constrained keyword.
01:08:39.860 - 01:08:41.936, Speaker A: Perhaps we should reveal the answer now.
01:08:42.038 - 01:09:14.792, Speaker B: Yeah, let's do that. So we got our two globals, the candidate count ten, the vote account, Alice and Bob two. Here's our function signature. It's going to take all of the votes. So that's our flattened 2d array, which is of size 20, which is those two globals multiplied together. We're going to output what is the. If you imagine that you had a matrix, you're just going to compress that matrix down to a vector.
01:09:14.792 - 01:10:05.470, Speaker B: So that's going to be just the length. Candidate elements here is where we're allocating our array that we're going to aggregate into the totals array. So we're just starting with every element in the array being zero and it's of length candidate count. So using a semicolon here to denote that. And now to index over this flattened 2d array, we're going to iterate over rows and columns Inj and we're going to do some index arithmetic here with I multiplied by the candidate count. And then you add J. We're adding that onto whatever total was already in there.
01:10:05.470 - 01:10:27.540, Speaker B: So it's kind of similar to how we were having to aggregate all of those squared votes before. We're not doing any squaring. What we're having to deal with is the indexing. So that's the puzzle in this one. And then at the end we're returning the totals. Notice no semicolon. That's that method.
01:10:27.540 - 01:10:57.580, Speaker B: And Maxim is going to post a gist to that snippet so that you can compile it yourself if you're behind. And that's also going to have the main function hooked up in it, so you could also prove on it if you wanted. All right, we've got another QA section. But we don't have anything in the QA yet. Is there anything in the chat?
01:11:02.800 - 01:11:06.690, Speaker A: I think we hit all the questions for this one.
01:11:08.260 - 01:11:47.772, Speaker B: All right, perhaps we'll move on then. We're going to go back to the user circuit. Now we're going to be outputting the commitments of your ballots. So this is important because if we just state how many votes we're. How did I do that? Yeah, without outputting the commitments we've got nothing to be held to later. When it comes to counting the vote and for producing this ballot commitment, we're going to need to use a hash function. Do you remember earlier we talked about.
01:11:47.772 - 01:12:14.990, Speaker B: Maybe I'll just go back to the architecture slide. Boom, boom. Not that one, this one. Here we go. We have a ballot. It's got a secret. And when we want to produce a commitment we're going to hash that secret with all of the votes in that ballot.
01:12:14.990 - 01:13:01.334, Speaker B: This is how we make our commitment. Brute force, attack resistant, jump forward again it so the concepts we're going to need this time we're going to be dealing with the field type. Up until now we've been using integers, but the field we're going to need to use because of the interface on the hashing function. And in order to access that interface we're going to have to cast our integers into fields. So we need casting. And to use this hashing function we're going to need an import statement. The hash we're going to be using is pedison.
01:13:01.334 - 01:13:47.134, Speaker B: You might be used to other hashing functions like poseidon. I think we got a grant out for implementing Poseidon, but pettitin is good enough for our purposes because we just need collision resistance. So this is an example of a field in use. So remember that a field is something that you're not going to come across in other traditional programming languages. It is specific to the realm of ZK programs because a field refers to the type that is used by the proving back end. Here's what it looks like to cast. So we start with an integer, and then we say that we want to treat this integer as a field.
01:13:47.134 - 01:14:31.850, Speaker B: An integer already is a field, but now the program knows that it should be handling it as a field. And here's what it looks like if you wanted to cast your u eight into a U 64. Here's what including the standard library namespace looks like, and here's that used in conjunction with the pedison hash. So it's part of the standard library, it's part of the hashing crate. It's going to take a transcript. There'll be an array of fields here. And notice that we're only interested in the first element that gets returned by this method.
01:14:31.850 - 01:15:06.834, Speaker B: The reason being is Pederson is going to return an elliptic curve point and we just want a single field element. So we're going to have an x and a y. We're just going to use the x. That's sufficient. This is what the function signature looks like for the standard library pedicon. You can check out the other standard library methods. If you go to the noir project in GitHub and go to the noir standard library and source, and then hash noir corresponds to the crate.
01:15:06.834 - 01:15:53.318, Speaker B: There are all the other standard library crates sitting alongside in that directory. You notice that we got this macro here, the foreign pedicon. We're just saying that we're using an optimized gate, a custom gate from the proving back end in order to use this function. Did I just give the answer there? I thought that was a hidden slide. No. Okay, I was just confusing myself. So we've touched on this already, but to recap, why don't we just use fields all the time we've been using uints until now? And the reason is because we want to do that range check.
01:15:53.318 - 01:16:33.154, Speaker B: You can't do the range check with regular fields, so in our earlier sample we needed that range check. So have a go at importing the pedison, have a go at doing some casting. We'll just give you a couple of minutes to mess about with that syntax and answer any questions, and then we'll go on to the actual task. So the task isn't set yet. We'll have the spec on the next slide. Can you give a prover toml file? I guess you want the prover for. You asked that five minutes ago.
01:16:33.154 - 01:16:39.318, Speaker B: So that would have been for the ballot manager. Yeah, I think I sent in the.
01:16:39.324 - 01:16:50.982, Speaker A: One for the manager, and then I also just sent the one for the user because they're about to do the user circuit again. So I just sent both of those proverbs.
01:16:51.126 - 01:16:51.820, Speaker B: Okay.
01:17:01.000 - 01:17:40.770, Speaker A: The return. Someone asked, can the return be empty in tomal? Yes, it can, but right now only for individual integers or field elements. We actually, I think, literally have a pr open that is just being reviewed to enable returning arrays with an empty. You can auto fill arrays in the verifier tomal as well. So that will be happening soon as well. You would just write return equals an empty string. One more question.
01:17:40.770 - 01:18:09.980, Speaker A: I get expected two number of values but got four number of values when trying to prove the ballot manager. So you're going to have to comment out probably some of the values in your approver tomal because we haven't finished the manager circuit just yet, and there's some extra inputs there that are going to be part of the next part of the workshop. You just need to match up the number of inputs in your main function and in your proveromel.
01:18:13.200 - 01:18:45.504, Speaker B: All right, let's move on. Here's the spec for what we're going to write. Oh, and also this is now back in the user circuit. So we started in the user circuit, then we moved over to the manager circuit. Now we're moving back to the user circuit. So CD up, go back into cast ballot and go to the main file in that this function we're going to write is calculate ballot commitment. So that's going to take as input what we saw on the architecture slide earlier.
01:18:45.504 - 01:19:31.990, Speaker B: So it's a secret followed by all of the votes. You can just put them all in an array together and then that will be your input for the Pederson function. So the input to this function we're writing is all of the votes. So that's the candidate count length again, and then also this secret. And then you output the field, which is going to be the x coordinate of the pedison. So the challenge here is forming the array, which is the transcript, which is going to be the secret, followed by all the votes, and then passing that into the pedison hash. We'll give you seven minutes to try that out.
01:19:41.980 - 01:20:35.050, Speaker A: One more question we have is nargo compile not yet implemented in the Linux binary version? The nargo binary should be feature complete. Perhaps there's some unique architecture edge case that's messing with that. Please hop in our discord or something after this. If you're having issues still with the binary, we would like to make sure you don't have those issues. I'm not sure why that might be going wrong, and a bug report would give us a lot more info. It should be working though, and you can also try compiling from source if the binary isn't working for you. And it should work on Linux with the wasm back end.
01:20:35.050 - 01:21:32.970, Speaker A: Is there support for big in noir? So, good question. Not yet. We actually do have a grantee working on a big implementation written in noir itself, and that should hopefully be not far away. But we are in discussion about putting big directly into the compiler as well, because we think it would be much more efficient that we can make it much more efficient that way. But it's something that we definitely really want, and there should hopefully be a noir implementation soon. And then someone asked, can you go back to the spec? Joss already got it, and he's put it up.
01:23:53.870 - 01:24:01.658, Speaker C: Just a quick reminder to folks, just be sure to put your questions in the Q A. Right. Sometimes I see them a little bit in the sessions chat.
01:24:01.834 - 01:24:25.430, Speaker B: Right, I see that now. Could you guys reveal just how to import the function to do the hashing? Yeah, sorry, I'll go back to that slide. So we're using the standard library namespace. It's going to be standard library colon, colon, the hash crate. Colon, colon, the method.
01:24:28.090 - 01:25:09.620, Speaker A: Yeah. And you might see that depth keyword that essentially means it's an external dependency. But because the standard library we automatically incorporate into noir, you're not going to see that in the nargo tomal. That's why your nargo tomal doesn't have any dependencies. For example, when I earlier showed if I have utils equals some local path in my dependencies, I would also have use depth utils, and then I can use functions from that import. So we're doing the same thing here. We just automatically are incorporating it.
01:25:12.470 - 01:27:17.450, Speaker B: I know when I get to this part of the code, when I've used this, my most common typo is to use a single colon instead of a double. You can get thrown off by that compiler error one more minute. Would it be possible for someone to run a version of cast ballot that ignored the token budget? I e, does the system mean that the count votes role is verifying that the budget was respected? So when you come to counting the votes, you don't need to check that the budget was respected, because when the user cast their ballot in the first place, they would have produced a ZKP which stated that they'd respected the budget, and then that commitment and proof would have gone to a smart contract, and that smart contract would have verified that proof and said, yes, this voter here has respected the budget. And so when the ballot manager comes to aggregating all these votes together, it just knows this is a valid ballot. It's okay because the smart contract has already verified it, or the ballot manager could verify it themselves. Is there neo vim syntax for star noir? I don't actually know anything.
01:27:19.260 - 01:27:47.804, Speaker A: We have like a preliminary vs code syntax highlighting that you can install from the vs code marketplace. I've actually never used neo vim. I'm sure it would be easy to port that over, but right now, I don't think so. For neo vim. And what about a formatter? Is another question. We don't have a formatter. It would be great to have Nargo.
01:27:47.804 - 01:28:02.570, Speaker A: FMt would make things really nice. This is some of the things that we will add as we've been heads down writing the language. Now we can start adding a lot more tooling, and that will be, hopefully a part of it.
01:28:03.900 - 01:28:38.842, Speaker B: All right, I'm going to move on now. Here's our solution. So we're importing that namespace. Here's our function signature. We're calculating the ballot commitment to using a secret, which is a field, and then the votes, and then we got to form this transcript. The transcript is going to be the length of all the votes plus a secret. So we've got a length of plus one here, and it doesn't really matter what value you initialize it to because we're going to assign all of them.
01:28:38.842 - 01:29:43.310, Speaker B: We assign the zero th element as the secret, and we're going to iterate all over the remaining votes and do that index plus one, assign it, and we're going to cast it to a field as we go, because the pedison hash requires that we input an array of fields and we are returning the x coordinate of the elliptic curve point that comes back from the pedison. Again, no semicolon, because this is a return. You see, we've got this field being returned in the function signature, and I think Maxime is going to share a gist of that, if he hasn't already. In fact, that will now be the complete user circuit. So that gist will also show how to hook it up to main. Have we got any more questions at this point? Do you plan to support exporting to Cairo?
01:29:45.190 - 01:30:33.070, Speaker A: That would be extremely challenging, if not impossible. Cairo is very specific to starknet, and they do have hints that enable private inputs or something. I need to look a little bit more, but Cairo, I don't think you can have basically like this hidden data like we do in noir. You could theoretically have for a. That would be neat. That's not something that we've been able to allocate resources towards. But if someone wants to write a Cairo verifier for turboplunk, that would work with noir.
01:30:33.070 - 01:30:59.434, Speaker A: And then as we upgrade our approving systems, if someone continues to also upgrade solidity verifier, it'd also be a Cairo verifier. That would be great. You could export noir programs to starknet. One more question here. Transcripts. Inner type is inferred as a field. Do you know what that question means.
01:30:59.434 - 01:31:00.138, Speaker A: Joss. Sorry.
01:31:00.224 - 01:31:00.714, Speaker B: Oh, okay.
01:31:00.752 - 01:31:04.380, Speaker A: Yeah, I think I get from there. Okay.
01:31:09.070 - 01:31:25.194, Speaker B: What have I said? Yes. So we've only called it zero, right. We haven't specified a type. So I guess at this point it's a polymorphic integer. Is that right, Maxime?
01:31:25.322 - 01:31:52.170, Speaker A: Yes. When you don't specify a type, it's going to be a polymorphic int. And then the first place it's used, that's going to be the int type. So here, the first place we use transcript zero, we're labeling it secret. So it's going to infer that transcript is an array of fields, actually. Good question. I wasn't sure what he meant by transcript.
01:31:56.670 - 01:32:22.130, Speaker B: Cool. No questions. So I think we'll move on. All right, we're jumping back over to the counterpart again, back to the ballot manager. So we've now got the user circuit producing these commitments. They're going to the smart contract or whatever consensus system we're using. And now the ballot manager wants to take all of those commitments and check that they're valid.
01:32:22.130 - 01:33:03.696, Speaker B: Sorry, we're not covering any new concepts at the moment. We're just going to combine everything that we've learned up until now. We will be needing to recalculate all of the commitments for all of the ballots which are being inputted into this manager's circuit. So remember, we've got that flattened 2d array of votes, so it'd be Alice's votes followed by Bob's votes. So we're going to have to take that chunk of votes and then combine it with a secret. You can see here are our inputs. We've got an array of secrets.
01:33:03.696 - 01:33:36.450, Speaker B: These arrays are all going to have to follow the same order. So this array of two elements is going to be Alice's secret, followed by Bob's secret. This array of commitments is going to be Alice's commitment, followed by Bob's commitment. And then all of these votes is going to be Alice's votes, followed by Bob's votes. So that's a task. And of course you're going to have to do a constraint in here. You can actually do a constraint on all of the hashes as you calculate them.
01:33:36.450 - 01:33:51.636, Speaker B: So go back over to the ballot manager circuit, have a go at filling out this function, check commitments. We'll give you seven minutes for that. This is the last exercise, by the.
01:33:51.658 - 01:33:52.230, Speaker A: Way.
01:33:54.200 - 01:35:56.940, Speaker B: If you made it this far, well done. Should we reuse calculate ballot commitment from the other file? So you can try and do this, but you're going to run into some challenges. You'll probably find yourself rewriting that function because of this flattened 2d array of commitments. It is possible to get something that looks close to that function, but you're going to need to add an extra parameter which would be like an offset inside this 2d array where you want to inspect. And then if you do that you're going to have to get into some other advanced concepts like compile time arguments. So if you want a challenge, you can try doing it that way. But I'd recommend re implementing it using a nested for loop.
01:35:56.940 - 01:36:05.510, Speaker B: Is there not a way to use the array as a pointer and just shift it?
01:36:08.840 - 01:36:40.380, Speaker A: This kind of relates to the old question about references we don't have. Arrays are technically like a pointer underneath. But once again we don't support this nondeterminism with arrays. And yeah, not right now especially. It's a bit more. Adding that to a ZK circuit language adds a lot of complexity and it can be very powerful. And we want to add it, but it does not exist right now.
01:36:40.380 - 01:36:44.850, Speaker A: You have to set your arrays so that they're known at compile time.
01:36:55.800 - 01:38:52.330, Speaker B: Got another four minutes. Question earlier you mentioned you did not support early return. Is this by design or something which may be supported later? I have no idea about that one. Maxime.
01:38:53.230 - 01:39:27.160, Speaker A: Yeah, so you can kind of mock early return through other. Haven't we just haven't added it? You can only return at the end of the last statement of a function right now. It may be supported later, but it kind of requires, you're almost like short circuiting and, and that's something that, it's just, we haven't prioritized just yet.
01:39:54.530 - 01:41:20.280, Speaker B: We'll give you one more minute. All right, that's seven minutes. Moving on. Here's a solution, or our solution anyway. So you're importing that namespace again. We've got our two globals. We already had those before.
01:41:20.280 - 01:42:01.826, Speaker B: To check the commitments, we're going to need all the inputs, which are the commitments, the secrets, and that flan 2d array, we're iterating over every voter. So Alice and Bob. And in each case we're going to have to reform their transcript. So again, that's going to be an array length of 1110 plus one. And we set the first element as secret according to the order of the voters. So this will be Alice's secret first, and then on the next iteration that'll be Bob's secret. And then we've got to do the same business of copying in all of the votes and casting them to fields.
01:42:01.826 - 01:42:56.600, Speaker B: But this time we're doing it with some 2d array index arithmetic, and then at the end we're going to constrain whatever input commitment is at that position in the array to the output of the pedison hash, or specifically the x coordinate of it. Notice that we're performing this constraint inside of the for loop. You could, if you wanted, have another mutable variable which that you set a boolean on if any one of them wasn't correctly matching the pedestrian, and then you could just constrain it at the end. Either way is valid. So, any questions? Oh yeah, Max Seaman, did you post that in the gist? Cool, thank you.
01:42:59.210 - 01:43:04.150, Speaker A: Posted the circuit inputs once more so you don't have to scroll up.
01:43:04.300 - 01:43:58.038, Speaker B: Sweet. So at this point we've got two complete circuits, so you can try running the prover and the verifier on them. You'll notice that the sample inputs for the user circuit has got the inputs for one of the voters commented out. I can't remember if it's Alice or Bob, but you can just switch the commenting out around and then rerun it. And then you'll notice in your verifier toml that you'll see the commitment being outputted. And if you look at back over at the user manager inputs, those are the commitments that got copied in the output in that verifier toml. And the user manager inputs is going to contain the complete set of inputs to say that I have got a valid summation of all the votes and then that would get posted on chain, it would get verified.
01:43:58.038 - 01:44:19.300, Speaker B: And so concludes the election. We got any questions? Is there a way to get more information about the line that caused the issue? In an error, I get index out of bounds. The length is 20, but the index is 20.
01:44:21.830 - 01:44:53.580, Speaker A: So you're probably indexing incorrectly, as it sounds like an indexing error. And the size of the all votes array should be 20. So you might be just somewhere the index is off. Perhaps your transcript array needs to be. It's actually length is 20, index is 20. So it's probably related to your all votes array there.
01:44:56.720 - 01:45:02.770, Speaker B: But to answer your question as to whether you can get a line number, I think at the moment you can't do that.
01:45:04.340 - 01:45:26.810, Speaker A: Yeah, we have to add a bit more around, I guess, some of the error handling, specifically when evaluating the program. We have some pretty good error handling with regards to compilation and building, but this is part of our tooling improvements that need to be done.
01:45:32.270 - 01:45:59.486, Speaker B: Cool. Well, I guess we're nearly at time and I can't see more questions? So this might be where I. Oh, sorry. Yeah, you might have seen it in the gists, but in case you hadn't seen it in the gists, this is what it looks like when you assemble it all into the main function. So this is the user circuit. So you're going to do the constraint check. You don't care about the return because the constraint check is happening inside that method and the calculate commitment.
01:45:59.486 - 01:46:31.134, Speaker B: You do care about the return. So notice the lack of semicolon, and notice that we got this public field being outputted. Here are those Toml files we were talking about. So in goes the inputs, out comes the commitment. Here inputs his commitment. And then we copied that, and then we assembled the main function for the manager circuit. So we're checking all the commitments, and then we're outputting all the summed votes, and that's what the inputs look like.
01:46:31.134 - 01:47:19.550, Speaker B: Here's if you're in the near future when you execute this yourself, you won't need to specify the return. But I think with the current build that's out. You do need to, because it's an array of returned integers, it doesn't know how to auto generate that just yet. The fix is on its way out, and if you want to see the complete example, you can go here. Contains everything you've just seen, I think. Sorry, there were a couple of slides for maxim to finish on.
01:47:20.320 - 01:48:46.408, Speaker A: These ones will be fast though. We do support generation of a solidity contract based off of your noir circuit, and this enables a lot more powerful use cases, so you can actually have verification in the smart contract rather than just like an individual verifying a circuit. And this can combine enables autonomous execution based off of your ZK proofs. Actually, I'm noticing someone asked a question, how do you get the user's commitment? We're assuming in this case that the users are sending it to the ballot manager, who's then using those commitments. But for example, if we had a contract where the user was verifying their circuit, the ballot manager could fetch the commitments from that smart contract and also see that these votes, the budgets are valid and the users have submitted valid ZK proofs. You could go to the next slide Joss and then in order to easily interact with these circuits and the solidity contracts, we also have typescript wrappers. This is one of the main places though that we are going to be working on tooling in the coming months, and you can expect lots of improvements and hopefully improvements for the developer experience.
01:48:46.408 - 01:49:21.240, Speaker A: So you can easily have noir circuits that are interacting with solidity contracts, or just in typescript if you prefer developing that way. And here's a bunch of the resources that might be relevant to you based off of this presentation. Please join our discord as well if you have any questions or errors while you're maybe programming. Um, yeah, I hope everyone enjoyed the presentation.
