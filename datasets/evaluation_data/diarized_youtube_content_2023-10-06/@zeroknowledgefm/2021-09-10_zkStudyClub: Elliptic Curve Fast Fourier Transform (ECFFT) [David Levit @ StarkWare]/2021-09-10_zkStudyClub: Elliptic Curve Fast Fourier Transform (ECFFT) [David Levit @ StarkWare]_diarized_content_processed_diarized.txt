00:00:00.490 - 00:00:27.560, Speaker A: Good morning, or good afternoon everyone. Today we have David Levitt presenting elliptic curves. Fast forward to transform some new techniques for elliptic curve cryptography that are relevant to snarks. Very excited for him to present that joint work that he did with Ellie, Vin Sassan, Dan Carmen and Swastik Koparti. And thank you very much for being here, David, and thank you everyone else, for joining day. So David with that, over to you, take it away.
00:00:28.090 - 00:01:03.860, Speaker B: Thank you, Alex. So, my name is David. I'm going to talk with you today about the ECFST algorithm. As Alex said, it's a joint walk that I did with Ben Sasson, Dan Carmon and Swastikoparti, and we published. Here is the link to the published paper of the first part. The second part is still in writing. So let's begin.
00:01:03.860 - 00:02:36.586, Speaker B: So, FFT is a classical algorithm. It is widely used in many applications, such as polynomial multiplication, integer multiplication, loading extension, arrow, query code, snarks, starks, and many more applications. So this is a very elementary and basic algorithm, and it has one problem, the very one problem it has is that it requires a field that is FFT friendly. This means that the size of the field should be of special form. For example, if the multiplicative group is divisible by a large power of two, then we have an FFT friendly field. There are some more examples, but until now there were many fields. Actually, most of the fields were not known to have an FFT like algorithm.
00:02:36.586 - 00:03:48.760, Speaker B: So what do we do? Let me say again that I would very much like you to jump in if you have any questions. I really like to communicate with my audience. So let me now show the sketch of the solution. The solution is very simple. We just replace the multiplicative group with some other group. We replace it by some elliptic curve group over the same field. And the advantage is that there are so many elliptic curves over any finite field that there is enough freedom to choose an elliptic curve of some order that is divisible by a large power of two.
00:03:48.760 - 00:05:35.590, Speaker B: Let's be more specific. So by the Hassel well bound, an elliptic curve e is always in this bound q plus minus two square root q plus one. So this is a bound of, it's an interval of lengths four square root q. So this means that if we want an fft of size two to the n, and if two to the n is smaller than a square root q, where q is the size of the field, then it is highly possible that we can find such curve and then use it for an FfT like algorithm. A result by Waterhouse actually tells us exactly which sizes in this bound are achievable. And actually, if two to the n is smaller than exactly square root of q, then we are promised that there is such curve that fits. Any questions by now.
00:05:35.590 - 00:05:47.610, Speaker B: So this is the really main idea of the algorithm. And from now on I will just describe it in more details.
00:05:49.550 - 00:05:56.800, Speaker A: Yeah, this in the chat as well. But if anyone has questions that they just prefer to type, feel free and leave them there and I can ask them.
00:05:59.090 - 00:07:17.320, Speaker B: Okay, thank you, Alex. So let's continue. This is the most general abstraction that I could find for what are the building blocks that we need for an fft like algorithm? So first of all, we need the field k, and we need an algebraic group g. So in the classical case, g is going to be the multiplicative group, and in etfta, g is going to be an elliptic curve over k. Then we need a set of points. This set of points is the evaluation set, which is predefined. It is considered a constant in the algorithm, and the algorithm gets as an input a function f from the algebraic group g two to the field.
00:07:17.320 - 00:08:00.360, Speaker B: It is given as coefficients in coefficients in some linear space of functions. So in the classical case, these coefficients are the coefficients of a polynomial. And the purpose is to evaluate f at all the points of s as fast as possible. As fast as possible. Until now. M log n. I'm sorry.
00:08:01.210 - 00:08:09.740, Speaker A: Yeah, sorry. Was there a question? Or maybe someone's unmuted? Possible. If there's a question though, yeah, feel free. Chime in.
00:08:10.270 - 00:08:16.380, Speaker B: Also, Alex, as the host, you can mute people if there's accidental background noise. I just.
00:08:17.150 - 00:08:18.890, Speaker A: Good call. Thanks for reminder.
00:08:20.690 - 00:09:23.966, Speaker B: Okay, thank you. So far, we described the very well known classical SFT, but we did it in a bit more general way so we can plug in some other building blocks that will serve our goals. Let's first of all, plug in the classical building block. So k is a prime field. It would be also a prime power. G is the multiplicative group of k, and s is a coset of the group of two to the n roots of unity. Why do I say coset? In the most classical case, it's the trivial coset.
00:09:23.966 - 00:10:35.110, Speaker B: It's just the group of two to the end groups of unity. But for example, if we do load extension, then we are given evaluations at one coset, and we apply inverse Fft and then regular Fft on another coset, and then we get the evaluations at a different coset. Okay, so I still call it a classical case. So this is s, the set of evaluation points. And then we have l, which is the space of all possible inputs, the space of all possible functions that can be given as input to the FFT. So in the classical case, it's the polynomials of degree, at most two to the n minus one. Here I have a notation for the Riemann workspace of some devicer.
00:10:35.110 - 00:11:47.150, Speaker B: Don't worry if you are not familiar with the Riemann workspace. I will not talk further about it. I will only note that it's the analog for polynomials of low degree for the case of algebraic curves. This is not, this is not a property that I'm going to use in this talk. I just note it because there are applications in which this property could be used, for example, zero knowledge proofs. But this is out of the scope of this talk. So these are the building blocks for the classical FFT.
00:11:47.150 - 00:13:42.020, Speaker B: And now we need to dive in for some more details. So the structure of the FFT is squaring in each step, right? So we need some two to one map that is classically the squaring map that takes our evaluation set s and shrinks it to a half sized set. And after log m steps it is shrinked to a single point. So if we are in the trivial coset, it will be shrink to the .1 and if we are in a coset, then it will be shrink to some other point. So this evaluation set is shrinked and then we actually recursively call to a smaller size problem of the same form. So this two to one map that shrinks s actually can be extended to all the multiplicative group g, right? So actually these are maps that are algebraic maps of degree two.
00:13:42.020 - 00:15:47.210, Speaker B: So in the classical case, all these maps are the same map of squaring, and all these groups are the same group, the multiplicative group. But here I formulate it in a more general way so that it can fit also to the elliptic curve case. Okay. And the reason that I intentionally separate the group itself from the set of evaluation points is exactly like I said before, the loaded gear extension case. So if we have this set, this set of the set s, it has to be all the pre images of a single point over these two to one maps. To construct such set, we need to take single point p and we say, okay, what are the two square roots of these points? And then what are the square roots of these two points that we have? This way we construct its set over which it is easy to evaluate the function. So in the classical case, we get a coset of two to the n roots of unity.
00:15:47.210 - 00:16:15.300, Speaker B: And in the elliptic curve case, we are going to get something else. Okay, so this is just to understand what is the methodology that is behind finding this set of evaluation points?
00:16:16.410 - 00:16:21.400, Speaker C: That's a nice way of looking at it, even for the standard fft, I think.
00:16:22.410 - 00:17:11.590, Speaker B: Right, because these cosets don't just come out of nowhere. This is the way that they are constructed. Okay, so let's continue here. I have the same slides from two slides ago, but with some changes. So the gray lines are the things that stay the same, and the blue lines are the new stuff. So we have again this phi I, which is the wearing map. It is a two to one map.
00:17:11.590 - 00:18:47.600, Speaker B: All the GIs are going to be the same multiplicative group, and the sets of evolution Sis are going to be cosets of sizes that shrink each time by two. Okay, so later on we're going to make a comparison between this slide and the case of the elliptic curves. Okay, one last important property of the Fft is that we have this decomposition. So if we get this input, f is the function that we want to evaluate at the evaluation set. So the most basic step is to decompose it as a sum of two functions. In the classical case, it is going to be the Od monomials and the even monomials. Right? So in the more general case, we replace the square in map by our other two to one map.
00:18:47.600 - 00:19:58.900, Speaker B: And here we have still this composition of some smaller functions, g and h, with this squaring map. And here we have this x that separates the two types of monomials. Here we have only even monomials after this composition. And here by multiplying by x, we get only even, only OD monomials. Right? So this function x separates the monomials between two different linear spaces. But actually it doesn't have to be the function x. It could be replaced by other functions with some properties.
00:19:58.900 - 00:21:26.516, Speaker B: That I will not get into detail now. Maybe later, if we have time, I will talk about it more. Let's formalize this decomposition in some higher mathematical notations. So every algebraic morphism like the squaring map has a pullback morphism, which we denote by the star. Okay, so if we had phi, which is squaring, then phi star takes as input a function of the image space and returns the composition function of g and c. Okay, so this is just a notation, but it's a very useful notation. It actually says that if we have g coming from some linear space, Li plus one.
00:21:26.516 - 00:23:03.910, Speaker B: Then after composing with phi, we get a function in the linear space phi star of Li plus one. Okay? And the same happens for h when it is composed with phi. We get a function in the space phi star of Li plus one, and then we multiply it by x to get some other linear space of functions. And since these two sets of functions are linearly independent, they don't instruct in anywhere but zero. So this is actually a direct sum of linear spaces, and the space of all possible f function sense is actually the direct sum of these two linear spaces. Okay, so let's get back to the algorithm itself. So the algorithm gets an input as input this f in the space of in the space l, which is classically the low degree polynomials of degree up to two to the n minus one.
00:23:03.910 - 00:24:06.370, Speaker B: And then it decomposes it to two functions, g and h in this l one space. And then each of them is decomposed to functions in smaller and smaller spaces, linear spaces, until we get to the final space, that is the space of constant functions. Ln is a space of constant functions, so it's just the field itself. K. Okay, any questions? Until now you are very quiet. Okay, so let's continue. So again, the same slide, only this blue line is a new line.
00:24:06.370 - 00:26:03.060, Speaker B: Before, we had only the first l, which was the polynomials of degree at most two to the n minus one. And here we actually realized that in each fft step we get a different set of functions, actually polynomials of degree at most two to the n minus I minus one when I is the number of the step. Okay, so when I gets to n, then we get polynomials of the gate mod two to the zero minus one, which means constant polynomials, constant function. And then it is easy to evaluate them at every point, actually, because they have a constant function. Okay, so this was the classical SFT, and here is a detailed explanation, a description of the algorithm itself. The first step is to apply phi I on all elements of the input si to get si plus one. Si, I remind you, it's the evaluation set, which is classically the sum coset of a group of size two to the n minus one minus I, and si plus one is all the squares of si.
00:26:03.060 - 00:27:05.610, Speaker B: So we apply squaring to get this other coset. This step actually can be pre computed because Si is known in advance, it's not considered an input of the algorithm. But even if we don't want to do computations, then still si is of size m. This step is linear. And in the next step it is going to be of size half m. So we are going to get the sum of geometric sequence which converges to linear complexity. Okay.
00:27:05.610 - 00:28:37.860, Speaker B: Then we are going to decompose our input f, which is given as coefficients of monomials. We decompose it using this decomposition into two spaces. We can see it also here that using this fundamental equation to get g and h. So in the classical case, it is very clear that g is only the even monomers, h is only the Od monomers. The composition is trivial in the classical case, but it is also trivial in the general case. Why? Because how do we represent Li is actually the span of some basis of, of spatial functions. But I didn't explain how do I choose this function.
00:28:37.860 - 00:30:11.510, Speaker B: So the right choice of basis would be just take the basis of li plus one, pull it back using phi, right? And use those functions and those functions times x to be the basis for li. The composition is trivial also in the general case. Okay, so this step is just taking our array of monomials and splitting it into two parts and looking at each part separately. So the next step is to solve by occurs and the smaller problems for g and h. Right. And the final step, which is the only step where we actually do something, is to use these evaluations that we get from the recursion and evaluate this equation to get the evaluations of f on all the points of si. Okay, so far so good.
00:30:11.510 - 00:31:30.780, Speaker B: This is the, this is the description of the classical algorithm that you all know, but only from a more general point of view. Okay, so the running time is, as you know, t of m is. We have two calls to, two recursive calls to problems of half the size, plus this of m evaluations in this last step. Right. So this is actually an of m logm. Okay, so this is a good point to ask for questions, because after this slide is the same slide that we already saw. It's just a reminder, after this slide, we are going to talk about the elliptic curve version.
00:31:30.780 - 00:31:51.842, Speaker B: So if there are any questions so far, please ask now. Okay, I see.
00:31:51.976 - 00:32:10.870, Speaker C: Sorry, I have a question. So there are variants of the classical FFT that are mixed radix or use different radixes, radices than two. Can those be put in exactly the same framework?
00:32:11.610 - 00:32:14.922, Speaker B: Yes. You are talking about the additive version, right?
00:32:15.056 - 00:32:15.738, Speaker C: Yeah.
00:32:15.904 - 00:33:22.720, Speaker B: Yes. This is a great question. So let's go back a few slides and just see what is going to be there. So in the additive case, instead of the multiplicative group, which is of size that is divisible by two to the n, we have the field is itself divisible by two to the n. It's the field of size two to the n. So k is going to be power of two field, a binary field, g is going to be the additive group of the field itself. S is going to be some linear subspace of this additive group, which is also of size two to the n, and l is also going to be polynomials of degree at most two to the n minus one.
00:33:25.010 - 00:33:32.434, Speaker C: I was talking about the case where let's say you have an FFT with radex three. Wouldn't it be three to the n?
00:33:32.472 - 00:34:22.580, Speaker B: Okay, here we have this two to the n. We can also do a three to the n case. Also in the multiplicative case, also in the additive case, the difference is going to be here the function, the morphisms fi are going to be three to one maps instead of two to one maps. But still you will have this one point in the end where all the evaluations are going to be in that point. And to understand what is the set of evaluations that you start with the s, you just need to look at the pre images of this point.
00:34:23.190 - 00:34:27.940, Speaker C: Okay. Because cubing has three roots. Yeah, right.
00:34:30.310 - 00:35:03.770, Speaker B: Okay. And this is also in the additive cubic case and also in the multiplicative cubic case. Okay, got it. Okay. And here we are going to have some other equation which will have three parts. Okay. The decomposition is going to be into three spaces with two different multipliers.
00:35:03.770 - 00:35:07.950, Speaker B: Here it's going to be one and then x and then x squared.
00:35:09.090 - 00:35:10.340, Speaker C: Yeah, makes sense.
00:35:11.110 - 00:36:38.400, Speaker B: So it generalizes perfect. So just a reminder for those of you who didn't see the first slide, the problem in the classical FFTs is that they don't work for fields that are not ffT friendly. And divisibility by Tutu Dn is just one example of FFT friendliness. But it is still not known, or it was still not known, that actually all fields can have an FFT like variant. And our solution is to replace the multiplicative group or the additive group in other cases with an elliptic curve group, which has much more freedom in its size. Okay, so let's start with the obvious building box. So k can be any prime or any binary field, or also a prime power field, just any finite field.
00:36:38.400 - 00:38:03.920, Speaker B: G is going to be some elliptic curve of nice order. By nice order I mean divisible by a power of two, but it can also be divisible by power of three or some other radix. As you wish. So the main question here is going to be what is the two to one map, what is the squaring map, actually? So the answer is that it's going to be an isogeny of actually something that is related to an isogeny. So let's first of all define what is an isogenic elliptic curves. They are not just curves, they are actually groups, and the homomorphisms between those groups are called isogenics. These are functions that are defined using rational functions, okay? And they preserve there are actually homomorphisms.
00:38:03.920 - 00:39:07.830, Speaker B: So, and there are actually enough such isogenous for our purposes. And this theorem describes exactly what we need. So the theorem says any finite subgroup of an elliptic curve is a kernel of some isogemy. What does it mean? It means that if I have some elliptic curve with subgroup of size two to the n, and I want to find a two to one map from this elliptic curve. I just look at the subgroup of this curve of size two. This subgroup is by this theorem is the kernel of some isogeny. Let's call this isogeny psi zero.
00:39:07.830 - 00:40:51.700, Speaker B: So this psi zero takes this subgroup of size two to the n to some other subgroup of some other elliptic curve, which is going to be of size two to the n minus one, not the elliptic curve itself is going to be of size n two to the two to the n minus one. Only the image of this morphism is going to be of size two to ten minus one. Then we get this other subgroup in this other elliptic curve, and it has in it also a subgroup of size two. This subgroup is the kernel of some other isogenic from e one to e two, which also is two to one map, because its kernel is of size two. So this way we can construct a chain of elliptic curves. They are all different curves, but it's, they are all different curves, but our general formulation of FFT can, can handle it. So let's first of all show an example of such exogeny.
00:40:51.700 - 00:41:54.830, Speaker B: Here we have a specific example. If we have e zero being the elliptic curve of this form. Notice that here we have b squared and not just b. So this is not a general elliptic curve and e one is going to be this other elliptic curve. Then we have this isogenic site that is of degree two. It takes x y to this point. And first of all, notice that, I want you to notice that the x coordinate of the result depends only on the x coordinate of the, of the given point.
00:41:54.830 - 00:43:02.000, Speaker B: Right, someone is typing, and can you mute it please? Okay, thank you. So I'm going to use this fact that, that the x coordinate depends only on the x of the input. Okay, before I go on, I want you to notice another thing, that this elliptic curve e one is almost of the same form, like e zero. What I'm missing here is that I need four ab plus eight b squared to be a square. If this value is a square itself, then e one is also of the same form. And then I can find another isogeny to some e two and continue the chain.
00:43:03.540 - 00:43:09.030, Speaker C: Do these have to be Montgomery curves or is that just for this example?
00:43:10.680 - 00:44:47.012, Speaker B: No, it's just for this example. Well, actually every curve can be of, we can turn into a various form. And actually there is an algorithm to find this isogeny of a given kernel, which is an o of one complexity. Okay, so given that if we are given this e zero, then finding e one is very easy. The only obstacle is how do you find this e zero? And this is a very well studied question. The most naive solution is to just exhaustively search for this e zero and just check what's its size. And heuristically, and also probably there are enough such elliptic curves to find one in quasilinaar time it.
00:44:47.146 - 00:45:06.936, Speaker C: So that would be size of the subgroup times however long it takes to count points on the curve. Is that right? I'm sorry, the time is size of the subgroup times however long it takes to count points.
00:45:07.118 - 00:45:21.260, Speaker B: Yeah, okay, exactly. Actually, we don't really need to count all the points. We only need to verify that it is divisible by.
00:45:21.410 - 00:45:22.908, Speaker C: Oh, that's a good point. Yeah.
00:45:22.994 - 00:46:24.204, Speaker B: Okay. So it's actually easier than counting all the points. Okay. As I stated in the previous example, the x part of Psi depends only on Dx. And this is actually a theorem that if e zero and d one are given in extended versus form, then this isogeny is going to be of this form with the psi x having being depending only on the export. And this is equivalent to putting these curves in a commutative diagram. So here we have e zero goes to e one using this psi.
00:46:24.204 - 00:48:03.088, Speaker B: Here we have the projective lines. The projective line is just the field itself, union the point at infinity so that we can actually do this map from an elliptic curve to the x part of a point. So if we give it the point and infinity of the elliptic curve, it goes to the point and infinity of this projective line. Okay, questions about this notation of projective line. No questions. Okay, very good. This map of taking the x coordinate, it actually, so we can make this psi x is the x part of this isogeny, and I can go from each direction and get the same result.
00:48:03.088 - 00:49:02.100, Speaker B: So if I take this psi of a point and then take the x coordinate of the result. It's just the same as taking the x coordinate of the input and applying psi x. Okay, this is the meaning of commutative diagram. It doesn't matter if I go from here or from here, we get the same result. So now that we have this theorem, we can just apply it on the chain of elliptic curves that I told you earlier that I can find easily. So we have here e zero goes to e, one goes to e two goes to e three, and so on. And each of them has a projection to the x coordinate morphism.
00:49:02.100 - 00:49:19.240, Speaker B: And all these projective lines in the second row have morphisms between them that make all this diagram commute.
00:49:21.100 - 00:49:23.224, Speaker D: I have a small question.
00:49:23.422 - 00:49:23.928, Speaker B: Okay.
00:49:24.014 - 00:49:38.640, Speaker D: You really need a chain of ellipsis curves. I mean, can you not just have one elliptic curve with a point of order to the decay and then work with a doubling map?
00:49:38.980 - 00:50:42.740, Speaker B: Okay, so the doubling map is actually four to one map, not a two to one map. It is possible to use this function. Not only that, it is possible. It's a special case of this more general formulation, because the doubling map is actually a composition of two isogenies. So in the case of the doubling map, you will have e two equal e zero. Okay? So this chain is going to be repetitive with a period. And the only problem here is that in order this to work, you need subgroup to be of special form.
00:50:42.740 - 00:51:11.310, Speaker B: You need it to be the composition of two subgroups of size two to the half n. Okay. Because you actually need all the pre images of a single point to be in your group. If these roots don't exist in the base field, then you will not have your evaluation points.
00:51:15.860 - 00:51:23.328, Speaker C: You said it's a four to one map. That's basically like the classical FfT with red x four. Is that right?
00:51:23.494 - 00:51:43.320, Speaker B: Right. Okay. So it will work. If you choose a proper elliptic curve, this formation doesn't care for which elliptic curve you find, as long as its size is good.
00:51:43.470 - 00:51:55.390, Speaker C: Yeah. I don't have any intuition for how efficient that variant is relative to using different curves because you don't have to compute the isogeny, but then you have red x four.
00:51:56.560 - 00:52:06.928, Speaker B: Okay? So computing the isogenes is actually far from being the bottleneck of the complexity. So it's fine.
00:52:07.094 - 00:52:07.810, Speaker C: Okay.
00:52:10.100 - 00:53:54.130, Speaker B: So now we have this chain of commutative diagrams. What we are going to do is actually say that the two to one maps that we actually care about is the two to one maps in the red path. Okay? So each map in this red path which start from this projection to the x coordinate and then taking only the x part of the isogenes. These are going to be the two to one maps that replace the squaring map in the classical FFT is it? Okay, so this way we actually can talk about polynomials in this construction because if we were talking about the endogenous themselves then the spaces where the functions would live where Riemann rock spaces of elliptic curves and not polynomials of some degree. Using this red path instead we can talk about polynomials in one variable. Okay.
00:53:58.520 - 00:54:05.030, Speaker C: I'm still not quite sure about the connection between the polynomials and the projective line.
00:54:05.960 - 00:55:13.070, Speaker B: Okay, let's continue and I hope I will answer your question in a few slides. Okay? If not then come back in a few slides. Okay, so let's detail about these building blocks. So we had this k which was any field, any finite field. G zero was some specific elliptic curve and all the other gis were the projective line. Okay? And now I ask you what is going to be the evaluation set? Anyone has an idea?
00:55:14.040 - 00:55:20.656, Speaker C: It's on the slide.
00:55:20.768 - 00:56:36.652, Speaker B: Yes, it's on the slide. Okay, so the evolution sets are going to be exactly what we said before. It's the pre images of some point in the final space. So if the final space is here the projective line we have here some point then its pre images using one its pre images in this red path is going to be exactly the pre images in the other path. Okay? Because this is a commutative diagram. So let's look at the pre images in this other path. So first of all we take this point and this point on the x line and we ask what are the points on the elliptic curve whose x coordinate is this point p that we started with.
00:56:36.652 - 00:57:35.360, Speaker B: Okay, so these are going to be two points that are plus minus of each other. Right. Now that we have these two points we are going to look at the pre images of them in the isogenic. So these are going to be four points, actually two pairs of points. Each pair is going to be two points that go to the same point. So these are going to be actually cosets of the subgroup of size two, right? And it's going to be two cosets of the sub of size two, a coset and its minus because here we get the point and it's minus. So here is going to be a coset and it's minus.
00:57:35.360 - 00:58:14.830, Speaker B: And each time that I go back one step I get a larger and larger, larger and larger coset, a larger and larger pair of cosets until I get to g zero, which will contain s zero, which is two cosets. A coset n is minus of some subgroup of size two to the n minus one.
00:58:15.840 - 00:58:25.810, Speaker C: So the isogeny commutes with negation which is why it only multiplies by two at each step instead of four. If I got that right.
00:58:26.740 - 00:58:27.440, Speaker B: Right?
00:58:27.590 - 00:58:28.288, Speaker C: Yeah.
00:58:28.454 - 01:00:04.140, Speaker B: Right. So now that we understand this evolution set, let's see what is going to be the phi function. So the first phi is, as we said, the x coordinate projection to the x coordinate and the next ones are going to be the x coordinate of the x part of the isogeny, which is just this simple function. Okay. And well, I thought that I will not have time to deep into more details but it depends on you. I have some more slides to talk about but I think this is a good point for questions and maybe I don't remember who asked the previous question which I'm pretty sure I didn't answer in the end. So can you repeat the question please?
01:00:06.750 - 01:00:10.540, Speaker C: Can you go back a few slides so I can remember what I asked?
01:00:12.350 - 01:00:13.722, Speaker B: Think it was here?
01:00:13.856 - 01:00:20.160, Speaker C: Yeah, it was to do with the relationship between the polynomials and the projective line.
01:00:20.530 - 01:01:23.602, Speaker B: Right. The polynomials. Okay. So I thought it would be in this slide, but it's actually in a slide later. The, what is the l spaces that are the spaces of functions. If we go back a few slides to the formulation of the general case, ln is going to be the constant function, right. And then in each step Li is going to be some decomposition of pulling back Li plus one and multiplying it by this function x, which actually does not have to be x.
01:01:23.602 - 01:02:23.190, Speaker B: It can be any function of degree one, any rational function of degree one, actually. So when we start with Li plus one being polynomials, then pulling it back with squaring map gives also polynomials. But in our case phi is not squaring. It's some rational function. So the result is not polynomials. It's going to be polynomials over some constant denominator. Okay, so Li is going to be actually all the low degree polynomials over some constant denominator.
01:02:23.690 - 01:02:31.350, Speaker C: So does the degree of the numerator increase by the degree of the isogeny?
01:02:33.370 - 01:02:44.170, Speaker B: Yes, the degree of the numerator increases by two if it's two to one map.
01:02:45.810 - 01:02:46.960, Speaker C: Right. Okay.
01:02:50.610 - 01:02:59.890, Speaker B: Then we get that li is a space of dimension two times the original dimension.
01:03:00.870 - 01:03:02.050, Speaker C: Yeah, I see.
01:03:02.200 - 01:03:53.986, Speaker B: Okay, so if you want to only talk about polynomials then you need to multiply this result by this denominator and then you will have here two functions. Here you will have one function and here you will have some other function. In this case, these two functions are one and x, but it could be some other functions. And then you will talk only about polynomials all the time. But in the more general case, you don't have to. You can stay with these polynomials of low degree over some constant denominator, and only in the end normalized by this final denominator, if you like.
01:03:54.088 - 01:03:54.466, Speaker C: Got it.
01:03:54.488 - 01:04:28.574, Speaker B: It depends on the application, of course, yeah. Okay, so this was one question I will gladly answer any other questions. Sorry. So, phi I in this new case is basically map between function fields. Right. In a case that we are, the phi star is a function. Yes.
01:04:28.574 - 01:04:55.958, Speaker B: The phi stars are functions between linear spaces of functions. Yes. The function space. Right. The phi themselves are maps between the other side by curves. Okay, so basically the normal Fft is basically on p one. Basically, it's a specific case that our curve is p is the rational line.
01:04:55.958 - 01:05:07.340, Speaker B: And now you're changing. Okay, thank you. Okay, other questions.
01:05:10.110 - 01:05:23.600, Speaker C: I think you answered my questions in the chat about how difficult is it to find the curves. Finding the esogenies is trivial. Yeah, okay, you answered all of those. Thanks.
01:05:24.610 - 01:05:57.370, Speaker D: Okay, so actually, now I'm finally confused by your last answer. I thought the spies were, I mean, they were sort of inherited from curves, but they were restrictions to x coordinate of these maps from curves. So aren't they all like maps of rational function? Sorry. In one variable.
01:05:58.190 - 01:06:50.220, Speaker B: Okay, let's have a reminder. Let's go to the right slide. So here we have this specification of the phi. In the ecffft case, the first phi, if you don't start from there, you can always start from the second step. So the first phi may be the projection to the x coordinate from the elliptic curve, and then all the other phi are going to be the x part of the isogeny, as you said. And this is in the ecffft case, in the multiplicative case, they are all going to be the squaring map. Okay.
01:06:52.910 - 01:06:54.060, Speaker D: Yeah, thanks.
01:06:59.810 - 01:07:00.880, Speaker B: Other questions.
01:07:03.970 - 01:07:33.850, Speaker C: So I'm interested in the relative efficiency of this compared to classical FFT, because obviously, let's consider a zero knowledge proof application. You have the choice of either going to the next power of two or switching to ECC FFT if you have some circuit size that is between two powers of two. So the question is, which is more efficient in practice?
01:07:34.750 - 01:08:08.420, Speaker B: Okay, so I'm not sure about snarks, but if you look at the loading extension problem, then actually the code is, I actually use the same code exactly for the two cases. I only change the twiddle factors. Okay, so it's extremely the same. Just the same.
01:08:09.350 - 01:08:23.306, Speaker C: Yeah, my intuition was more expensive. But if it's the same, then that's a big deal because that immediately applies. That immediately means you can have any circuit size. Yeah, that's great.
01:08:23.488 - 01:08:31.100, Speaker B: Okay, and do we have any other questions?
01:08:32.270 - 01:09:38.820, Speaker D: So, this is probably not like a silly question, but I'm still trying to get radix two from just doubling map. So say I fix one point of order two to the k in the curve, and now I take as my evaluation set the x coordinate of all its multiples. So that's two to the k minus one point, like two to the x k minus one field element. And now I think I'm wondering if on these two to the k minus one point, the doubling map now is just two to one. Like the restriction of the W map to the x coordinate is just to the one. And if you could use that for getting a radix key.
01:09:39.750 - 01:10:47.240, Speaker B: Okay, what you are going to get is actually in this decomposition. In this decomposition, if you use only two functions instead of four, as you should, in the case of four to one map, then the set of possible functions that you get is smaller than the more general set. So if in the ecffft case f is going to be, can be any low degree polynomial over some constant denominator, then if you drop to summons, then f will be just in some linear subspace of this space.
01:10:48.890 - 01:11:00.920, Speaker C: Also, I think doubling is more expensive than computing these phi axes, so there's no point in doing it that way anyway.
01:11:01.290 - 01:11:07.630, Speaker B: Yeah, it's just equivalent to having two steps of this ecfft.
01:11:08.210 - 01:11:34.200, Speaker D: Yeah, Alan, he answered my question, I think, paraphrasing, but for me it's easier to think about it. But yeah, basically the phi will be degree four. In the case of the doubling mat, I can't represent polynomials of a certain degree as.
01:11:37.770 - 01:11:38.520, Speaker B: Or.
01:11:40.650 - 01:11:49.420, Speaker D: Yeah, maybe I, or maybe I can if instead of times x I use, like I'm wondering if I can represent all polynomials of a certain.
01:11:50.910 - 01:12:10.850, Speaker B: Well, look at the dimensions here you have Li plus one is of some dimension, and then pulling it back, it stays with the same dimension, but the result that you wish for is of four times this dimension.
01:12:12.310 - 01:12:30.150, Speaker D: Yeah, well, at the very least it's messy. I mean, I don't get all polynomials of a certain degree. I get some weird subset of them if I just use two components.
01:12:30.890 - 01:12:31.798, Speaker B: Yeah, exactly.
01:12:31.884 - 01:12:32.840, Speaker D: Never mind.
01:12:40.390 - 01:12:43.080, Speaker B: It's okay. Any other questions?
01:12:50.240 - 01:12:53.550, Speaker C: Yeah, I think I'm going to go away and implement this.
01:12:55.440 - 01:13:01.390, Speaker B: Go ahead. Awesome.
01:13:02.100 - 01:13:05.732, Speaker A: David, that there's a follow up to this work coming, right?
01:13:05.866 - 01:13:38.670, Speaker B: Yes, there is a follow up that explains exactly how we can use this method to do starks over any field. And in particular we are interested in SecP field. So this is a non FFT friendly field. But we want to approve ECDSA claims about.
01:13:41.760 - 01:14:13.130, Speaker C: And in fact. So SEcP forms a cycle. And the only reason we aren't, for example, using sec P for sec P and sec Q, which is the other care of the cycle for halo two, is this issue of FFT friendliness. But if that issue is resolved, then there is no reason not to use that cycle for halo two and be able to approve things about, say, bitcoin signatures and things like that.
01:14:13.900 - 01:14:14.650, Speaker B: Exactly.
01:14:26.880 - 01:14:41.328, Speaker A: There's a couple more comments that are kind of being typed in here. I think Kobe mentioned that you need the radix two structure not only for FFT and some proof systems. I don't know if there's anything you want to comment or if you want.
01:14:41.334 - 01:14:59.640, Speaker C: To comment on that. I can comment about that. So Planck was originally described as relying on power of two subgroups, but I don't think it really depends on that in any essential way. It's easy to remove that assumption.
01:15:03.100 - 01:15:05.930, Speaker B: Okay. I'm actually not familiar with.
01:15:10.690 - 01:15:11.760, Speaker A: Anyone else.
01:15:12.950 - 01:15:24.840, Speaker D: Yeah, I guess you just need a subgroup of some order that's close to your circuit size. And besides the FST, you don't care if that group is a power.
01:15:30.790 - 01:15:41.830, Speaker C: Yeah, you need the subgroup. You don't need it to be a particular size, as long as it's larger than the second subscription or the number of rows, to be more precise.
01:15:46.570 - 01:15:49.720, Speaker A: Awesome. Any other questions in the group here?
01:15:51.230 - 01:16:12.110, Speaker C: So basically, it sounds like the performance is the same as radix two FFT. Are there any other downsides to this? Is there anything else why someone wouldn't use this? Or are we literally just saying, like now, anything's possible with nfDs?
01:16:12.530 - 01:16:35.240, Speaker B: Well, the only problem is finding the curve. It's not a big problem, but it is a small issue. It's a precomputation, but it's possible for, I think, any desirable FFP size.
01:16:36.250 - 01:16:38.440, Speaker C: Do we know the complexity of that?
01:16:39.950 - 01:16:44.540, Speaker B: It's quasilinear, I'm not sure. Exactly.
01:16:45.710 - 01:17:21.080, Speaker C: So if we go into that in more detail. So for each candidate curve, you have to check that it has a subgroup of the right size, right? So that is just a scalar multiplication of that size. Right. With that number of bits. Okay. So that's going to be pretty efficient, because you only have to do two to the n of those and each one takes, it's on two to the n, something like that.
01:17:24.810 - 01:17:27.334, Speaker B: Of n, what is n?
01:17:27.452 - 01:17:50.880, Speaker C: Oh, sorry. So if we call the, yeah, if we call the subgroup size, I don't know, we call it m. Okay, m, then it would be m log m, I think.
01:17:51.570 - 01:17:59.060, Speaker B: Okay, it's m because of the exhaustive search. And then you say it's log m.
01:17:59.430 - 01:18:03.134, Speaker C: To verify, to check each candidate.
01:18:03.262 - 01:18:10.758, Speaker B: Well, I'm not sure if it's exactly log m, but it's polylog m, I think.
01:18:10.844 - 01:18:31.770, Speaker C: Oh yeah, no, because it's log m times something that depends on the curve size. So it's lambda m log m, yeah, where lambda is your security parameter.
01:18:34.830 - 01:18:38.400, Speaker B: That's if you are using scoof, right?
01:18:40.610 - 01:18:45.200, Speaker C: No, that's just to do the subgroup size check.
01:18:47.030 - 01:19:06.920, Speaker B: Okay. I'm not sure how it's done, but I'm pretty sure that there are ways to get away from the size of the field problem.
01:19:11.470 - 01:19:12.026, Speaker C: Anyway.
01:19:12.128 - 01:19:20.460, Speaker B: Yeah, small constants like complex multiplication gives you exactly the size you like. You can use CM method to.
01:19:21.550 - 01:19:47.010, Speaker C: Oh, that might be the exact size. Yeah, I think you're right. You don't have to search for it by brute force. Can you use super singular curves? Does that work?
01:19:48.340 - 01:19:50.770, Speaker B: Yes, it will work. Yeah.
01:19:51.300 - 01:19:54.470, Speaker C: Okay. I think that makes it easy.
01:19:54.920 - 01:20:16.850, Speaker B: Of a binary field. That's exactly what you get. Okay. No, that's not what you get, I'm sorry. That's what you never get, but it doesn't matter. You can use supersonic. Yes.
01:20:24.740 - 01:20:37.770, Speaker A: Awesome. Well, David, thank you very much for your presentation today, and we're looking forward to your follow up work, and maybe we can have you back in here when that's out and do another study club session about that.
01:20:39.260 - 01:20:40.070, Speaker B: Thank you very much.
