00:00:06.090 - 00:00:44.950, Speaker A: Hello. My name is Rebecca. I'm not going to be presenting another Snark construction today, unfortunately. And instead I'm going to talk about what hash functions look like inside of Snarks, and most importantly, like how we can achieve hashing inside of Snarks efficiently. So the roadmap up is I'm going to show the state of the art for arithmetic circuit friendly hash functions. And the Snarks presented so far today have been kind of varied in their computation model, which you can efficiently prove things about inside the Snark. So I'm going to be focusing on ones that target like R one CS.
00:00:44.950 - 00:01:45.290, Speaker A: So think growth 16. We want to be minimizing the amount of field multiplications. And so what I'm going to do is say, what do we need to keep in mind when choosing hash functions? Like what is going to be expensive, what is not, what properties do we need, what properties can we maybe do without? And then which hash functions best satisfy these requirements? So the first thing you might ask when you think of hashing inside of elliptic habs. I mean, hashing inside of SNOX is like, why can't we just do what we've been doing for the last 20 years, which is use a hash function which has been made really fast. So Shawtu went through a standardization process. It's like really battle tested, achieves all of the properties you would want from a hash function, but it's really slow inside of a Snark. And the reason why it's really slow inside of Snark is because the things that make a hash function or any arithmetic on a computer really fast are like a lot of bitwise operations.
00:01:45.290 - 00:02:10.438, Speaker A: So this works with bytes and words. So each letter here is representing a variable, which is 32 bits. So like a word on a computer. And then it uses operations which act on these bits. So this happens practically instantly on your hardware. Xoring is really cheap, rotations great. And inside of a Snark, this is exactly what you do not want.
00:02:10.438 - 00:02:59.640, Speaker A: So if you're working in an arithmetic field, you don't have a 32 bit word, there's not really such a thing. So what you have to do instead is separate all of these into one bit per field element and then do all of the XOR's and ands and rotations in a bitwise fashion, which is terrible. It's not what you want. So this leads to a proof for a sha, two hash having about 27,000 constraints, which is huge for a 512 bit message to be processed. And one of these proofs creates like 1.5 seconds, which maybe isn't that bad by itself. But if you want to do multiple of these, it's going to be terrible fast.
00:02:59.640 - 00:04:06.074, Speaker A: This means it's about 54 constraints per bit processed. So you're doing almost 54 multiplications per every bit you're processing. We have a lot to improve here, so maybe if you think about the ways that we can improve, maybe first we can relax our conditions. So, Sha, as a hash function, it satisfies a lot of properties that you want from a hash function. But if you want to just use your hash function for commitments, then it's maybe a simpler goal. So commitments require only second pre image resistance, which means that given a message, it's hard to find another message that hashes to the same the output of the hash function is the same, or collision resistance, which is like you choose any two messages such that the output of the hashes is the same. So what happens if we only need this goal? And maybe we can first construct something which is simple, that just satisfies this.
00:04:06.074 - 00:04:50.582, Speaker A: So the reason why we would need just this goal is because in merkel trees, which are used a lot in cryptocurrencies that use Snarks, for example, we often have commitments to coins or to transactions that are constructed in a merkel tree. And each layer of this you need to use a hash function. But your hash function only needs to be collision or second pre image resistant. So we definitely have the motivation and we also have a solution. So thanks to Sean Bow, who you had earlier today, and Deira from Zcash, they constructed this really good hash function that satisfies exactly the requirements you need. In this case, it's called the Peterson. It's a Peterson hash.
00:04:50.582 - 00:05:35.670, Speaker A: And what you do is you split up your message into its bits or you could split it into little bit chunks and then you have generators, which are the GI in this case. And you can just multiply little sections of your message by each of these generators. And this is great because instead of where we had bit arithmetic before, we now have field arithmetic. So now instead of like one and between two bits being one multiplication, we have that one multiplication is one multiplication. So at least we've made some progress. You can do windowing, which is like instead of where I've written here, each bit is a labeled M. You can construct little trunks instead.
00:05:35.670 - 00:06:09.220, Speaker A: So maybe every mi would be like three bits. And you can hard code some parameters and then you can use some lookups which saves you on doing the multiplications. You kind of like pre compute the multiplication. So then instead of reperforming it, you can just say like, it's one of these eight values if it's three bits, and this is the one that it is. So this leads to about 1.7 constraints per bit instead, which is, if you recall, the last one was 54. Like, we've already done a great job, so Shonen Deer should definitely be praised for that.
00:06:09.220 - 00:06:59.726, Speaker A: Yeah, so it leads to around 900 ish constraints for a 512 bit message. And also, an important thing to stress here, compared to the hash functions that I'm going to be presenting next, is like this one has provable security from the discrete log assumption. So if you want to be conservative in your assumptions that you're using. You don't want to move fast and break things and you only need properties that are needed for commitments, then this one is a great choice. But what happens if you don't just need commitments? Like you don't just need collision resistance, then you need indifferentiability from a random oracle. So you need your hash function to look its output to look random. And common use cases which you need this for are for example signatures.
00:06:59.726 - 00:08:15.178, Speaker A: So if you replace the Verifier improver interaction instead with a hash function, then you need that hash function to have like a random looking output. And as well, if you want to compose SNOX verification with some of the newer snoks that are being produced, like the Universal Setup SNOX a lot of the time these use the Fiat Shmira Transform as well, which is the same if you have an interactive protocol where you have approver and verifier and you can replace that verifier interaction with a hash function as well. So this is a way that a lot of the newer universal setup Snoks get rid of interactivity. And so if you want to compose with one of those, if you want to verify that inside of a Snark, then you want your hash function to behave randomly. So what do we do? So there's been a line of work. So there's Mimsy hash. Originally this was started because in MPC, in some types of MPC you have a similar computational model that you get addition for free and multiplication you really have to pay for in terms of communication there.
00:08:15.178 - 00:09:11.310, Speaker A: So MC hash was suggested and then this is just more work that builds on memcy hash then the more recent line of work of which we have one of the authors in the room is there's a pair called Vision and Rescue and a pair called Snarkhead and Poseidon. And these are papers that are written for the motivation of hashing inside of Snarks. So they really take care to make sure that you're not wasting any multiplications. So they're pairs because one of them of each of them targets a binary field and the other one targets a prime field. We have rescue and we have Poseidon. So I'm going to do some thought leadership here and tell you which one I would conclusively use. And so for that we need to take a look inside of them kind of.
00:09:11.310 - 00:09:48.998, Speaker A: So Poseidon is made and Rescue as well are made of these three stage layers. So this is like one round and you repeat this many times depending on what security level that you're comfortable with. So the Ark layer is just add round key. So you add a constant in this layer. So inside of a Snark that's free. Then the M layer is like matrix multiplication. So this is also by a constant, it's by some constants and so this is also free inside of a Snark, then the little S in boxes, they're called S boxes.
00:09:48.998 - 00:10:47.754, Speaker A: And this is a kind of hash design taken from the hashes that were designed way before SNOX even existed. So the combination of these things is like something which people maybe believe is secure. So what happens inside the Xbox is really what's most important. And Poseidon itself has some partial layers, they're called in the middle, which only use one of these Xboxes instead of putting the whole state through an S box, just to even more simplify the arithmetic complexity of the entire circuit. And the concrete numbers are like approximately 228 constraints in the case of MNT, four and sixes curves, which remember, they're 753 bit curves. So you would have a really bad time in all of the other situations with these. But this one, you get 0.3
00:10:47.754 - 00:12:12.662, Speaker A: constraints per bit processed, because you also are working in field elements straight away here, processing one field element is processing 753 bits already, so you get a lot of efficiency straight away. So what do these Xboxes themselves look like? So, in Poseidon, you have X to the alpha as your S box, and this needs to be a bijection, which means you should use alpha as the smallest prime, so that your prime minus one is not divisible by that prime. So P minus one should be coprime or R minus one, in this case should be coprime with the prime number that you use as alpha. Yeah, so it recommends that you use one alpha one over alpha if three isn't coprime with R minus one. But we chose alpha equals eleven instead, because this is our smallest prime that's coprime with P minus one. So Rescue uses both X to the alpha and X to the one over alpha as Xboxes, which is exactly the same number of constraints inside the Snark. But if you want to be nice to your prover as well, then they might want to produce this hash function outside or run the hash function outside of the Snock as well.
00:12:12.662 - 00:12:57.800, Speaker A: And one over alpha raising a number to the power of one over alpha when all of the arithmetic is modulo. 702 to the 753 almost is very slow outside of outside of Snark. To do this on a computer, your computer is not very happy with you after speed. The recommendation is that you would use Poseidon. However, one caveat is that I haven't really said anything about the security of these recently suggested hash functions. And so I'm going to defer to Alan, who's talking right after this, about exactly that. So, like contrasting the security of these, that's his job.
00:12:57.800 - 00:13:42.450, Speaker A: So what happens instead? So far we've been hashing to field elements, so we've been hashing to practically bit strings. We don't need the output of the hash function to have any special structure. In some cases, you do need the output of the hash function to have a special structure. You are hashing to an elliptic curve point, and just to say what this is in one line, if you don't hashing to an elliptic curve point is kind of maybe a weird phrase. So you just want to sample a random elliptic curve point so you don't know the discrete log pretty much, and it's a random elliptic curve point. So the motivation for this one of them is Verifiable random functions. They rely on this super heavily password authenticated key exchange as well.
00:13:42.450 - 00:14:47.782, Speaker A: I've not seen this happen in a Snark, but if you want Verifiable password authenticated key exchange, then this would be a use case where you would need this. And then if you want to verify BLS signatures inside of a Snark, you also need to do this. And that one will be important for light clients, for any protocol that uses BLS signatures, for example. So just to motivate why Verifiable random functions use hashing to elliptic curve points, because it's kind of interesting. Instead of the normal back and forth where you prove that you have a private key that corresponds to a public key, this is kind of what Chanel signatures look like. Instead you prove that with this curve point, which is the output of a hash of a message, then you get to multiply your secret key by that hash of a message. And if for some notion of order, if the output of that hash function multiplied by your secret key is larger than a target value, this counts as like winning the lottery in some proof of stake protocols, like Aurora's Genesis, for example.
00:14:47.782 - 00:15:34.182, Speaker A: So where in proof of work, you do the repeated hashing, and if you find one that has a bunch of zeros at the start first, then you win. The proof of stake equivalent of how you win the lottery is you do a multiplication by the output of a hashroom message. And if I've just said your x coordinate is larger than some target value, but if you have some ordering, then you can define who wins the lottery. So this proof looks just like Schnar. So if you're familiar with the Schnar, schnar would just look like all of the H prime to the M. Here is your proving that the number that you multiplied by H prime of M is your secret key. And as I said before, in Schnor as well, you need to replace the Verifier by a hash function.
00:15:34.182 - 00:16:27.510, Speaker A: So here Bob is replaced by a hash function. And then another motivation is SNOX with private input. So maybe this isn't talked about very often, but growth 16, you can't actually put private information right in and not have malleability. So there's just a security property that says if you want this idea of if you only want people to be able to construct proofs, if they have a valid witness or know a valid witness, then you want simulation extractability rather than the security property that's in graph 16. By itself. And one of the extensions which gets you this is Bo Gabazon 18. And this does it by including a message hash to elliptic curve point as well, this stops people being able to malleat the proof.
00:16:27.510 - 00:17:23.526, Speaker A: So in this case as well, you would want an efficient inside of Snark hashing to elliptic curve. So what a Snark friendly hashing to elliptic curves hashes look like? So we saw in Sean's talk as well, there's such a thing as an embedded curve, and this is like the curve which is defined over the Scalar field of the original curve. So this is where the Snark arithmetic takes place. So this is kind of saying there is such a curve. So does hashing to elliptic curves inside of a Snark make sense as a phrase? And so what this slide is saying is, yes, it does. If you have elliptic curve points defined with their coordinates as the points in the original Scalar field, then you can define a curve. So this just means that arithmetic inside of the Snark can be used to describe an elliptic curve.
00:17:23.526 - 00:18:00.794, Speaker A: You can efficiently ascribe an elliptic curve group operation. Yeah so it just means the rest of my slides are going to make sense. So the first idea that you might try is called Try and Increment. And this is kind of like the folklore way to get an elliptic curve point. And the way that you do this is you just use a normal hash function. You hash your message. You say, like, if this was an x of an XY coordinate pair and elliptic curves, would it make sense? And if it does, then you say like, great, so I can solve the equation.
00:18:00.794 - 00:18:23.562, Speaker A: I can solve the curve equation. I can get my y. And if it doesn't, then you add one to that x, and then you say, like, is this one the solution to the curve equation? If it is, then you're great. If it's not, then you move on. So you can do this outside of a Snock. It's like an okay way to go about life. But finding inside of a Snock, it's kind of difficult.
00:18:23.562 - 00:19:21.294, Speaker A: So finding whether or not F of x itself, which is defined here as like the curve equation, is a quadratic residue. So if that's a square, if that's going to have a square root, so is Y going to exist? Finding out whether or not that has a solution that takes an exponentiation, which means, like, of order of the field size bits. So in our case, 753 constraints just for that, and then square rooting itself. So if that is a valid solution to that problem, then you need to square root in order to find your Y. And this can either be done with one more exponentiation, so 753 more constraints, or with a whole algorithm of its own, which is significantly more than that. Yeah so you need to add one for approximately half and then on and on and on. And there's very many analytic results about how well distributed the exits are.
00:19:21.294 - 00:20:07.882, Speaker A: So are you going to have to add 50 before you find something which is a square, or are you only going to have to have one? There's not very many results about that. And so to be conservative so that you don't run into bad case is all of the time, you're going to have to set that K parameter pretty high. And in SNOX, there's no way to say like, I'm done, now let's cut short from this loop. And so every time you want to do this, you're going to have to do it the way that you would do it in the worst case. And so it leads to very many constraints very fast. And then, so maybe the next thing that you would think of is like, how about we use a hash function that we just defined before? Those ones were really cheap, right? And multiply it by G and then we'll have an elliptic curve point. And this doesn't work because if you look at BLS signatures, everything is terrible.
00:20:07.882 - 00:20:45.686, Speaker A: If you use this as your hash function, you can immediately forge just from someone's public key and from whatever message that you want. The signature scheme kind of doesn't exist as a signature scheme anymore because you can just yeah, it's just because this equation holds. And so using only public information, you can just construct signatures. They're completely valid. It's also expensive. So moving on to the non expensive ones, these are the hashes to olive to curves of the pre Snark literature. Also, so you have ECAR style encodings.
00:20:45.686 - 00:21:15.170, Speaker A: They have these pretty simple equations. First you define this little rational function and then you have this one. So this is great if you're yeah, okay. So this only achieves one way, and it's number one. So this isn't by itself a solution to our problem, but this bit is solved. So you can extend this by just kind of using it twice. You just double everything, as in like double all of the formulas.
00:21:15.170 - 00:21:46.362, Speaker A: You can create a hash function which can be modeled as a random oracle. But this one assumes that your prime is two mod three. And this is because it uses cube rooting, and it needs cube rooting to be a bijection, which it means R minus one can't be divisible by three. So this doesn't work in our case. So then there's another suggestion. This one is pretty cool. So here G is the curve equation.
00:21:46.362 - 00:22:30.826, Speaker A: So pretty much you can pick three x points and then construct the curve equation for each of those. And because we have that, this is equal to a square, there's like, results from number theory which say things multiplied together that are equal to a square. At least one of them is a square. So what you can do is you can construct these instead of like the K many that you had to do and try and increment. You can just construct these three versions of the curve equation and then one of them will have a square root. So the formula again looks like this. It looks silly in its latex, but it's pretty low complexity arithmetically.
00:22:30.826 - 00:23:16.086, Speaker A: And then you can also make sure that this one is extended in order to satisfy the requirement of indifferentiality from a random oracle. Then really recent work of Dampenet and Riyadh Wabi, I think yeah, removes all of the restrictions from this one generalizes. It it proposes a constriction that even works in BN curves. And so this one's all good. It's like full speed ahead with that one. But what happens if we could do better than this because we're inside of SNOX? So the Wabi Bernay paper just targeted like constant time hashing to elliptic curves. They didn't consider that it would maybe be used inside of SNOX.
00:23:16.086 - 00:24:05.670, Speaker A: And what can we do inside of SNOX? So inside of snarks. Instead of for example, if we just wanted to compute a square root, then you can imagine that instead of having to compute the square root inside of the snark in the field arithmetic with all of the multiplication gates counting as constraints. If you wanted to prove something that has a square root, you could just feed in the square root and instead prove that that thing that you just gave squared is equal to your original number. So instead of doing a long complicated square root algorithm, you just do a multiplication and then you make sure that the things are equal. So you just add to your witness. So this takes us from Runtime, which is a cube of log r, which is how long square rooting usually takes to constant. So you just do one multiplication.
00:24:05.670 - 00:24:32.910, Speaker A: So maybe we could use this to our advantage. So each of the x's in the formula from the page before are actually parameterized by another T. And so how do we get that T? We use one of the hash functions that we just said. So we use inside of a Snark. We're going to use rescue or poseidon. Then we want to pick the first square. So checking the squareness outside of the Snark is an exponentiation.
00:24:32.910 - 00:25:28.600, Speaker A: Checking it inside of a Snark uses one of the uses also an exponentiation. But what happens if we have different ways to witness the fact that it's square or non square and it turns out that we do? So we can use what I just said before to witness that it is a square. So if it's a square, it has a square root. And so you can just submit the square root and then square it inside of the circuit and then you're finished. But what happens if it's not a square? So what happens if someone lies to us and they say like this one's not a square? How do you observe that something isn't a square. And it's because of this other result, which is like a square multiplied by a square in a prime field is still a square, but a non square multiplied by a non square in a prime field is a square. So if you choose a non square, which is like so QR is quadratic residue, which is just like a mathematician's way of saying a square number in a prime field.
00:25:28.600 - 00:26:11.134, Speaker A: If you have a pre computed non square, then you can only multiply things by this which are non square in order to produce a square. So we have two cases now. So either you submit the square root, like I said before, which is called x. In this case, that solves your equation, and then that can be checked inside. Or you submit the square root of the or you submit the square root of the number that you're wishing to prove is square or non square multiplied by this hard coded non square. So then this square root will only exist if the number A in this case is not a square. So then we have that you increase the witness size by two elements.
00:26:11.134 - 00:26:48.940, Speaker A: You give the square root of either A or A multiplied by your beta, and then you can check that the square of this is either this is just a bit. So the bit is showing like this is either square or non square. If the bit is zero, then you're in the non square case, and if the bit is one, then you're in the square case. So either way, that equation will have a solution, and this is how we do it. So, in summary, you can submit different things to your SNOX and Rearrange equations a bit and save a lot of constraints. SNOX and Hash functions can work together as friends. Thank you.
