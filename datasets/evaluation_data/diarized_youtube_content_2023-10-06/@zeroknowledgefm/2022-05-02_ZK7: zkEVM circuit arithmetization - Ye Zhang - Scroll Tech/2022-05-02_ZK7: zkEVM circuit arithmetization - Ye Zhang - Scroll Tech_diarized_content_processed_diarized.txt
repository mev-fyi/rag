00:00:07.290 - 00:00:40.150, Speaker A: Hello everyone, my name is ye. I'm the co founder and Ziki research at scroll. So today I'd like to introduce Ziki EVM circuit optimization. So this will be more technical talk like more technical than like yesterday at layer two beat. So the first half will be very similar because I still need some background for talking about Zikiro app and EVM like because there are so many cryptographers who are not even familiar with Zikroap. And second half we'll be talking about the circularization and how we are writing constraints to constrain the ZK EVM circuit. So basically, first introduction of scroll, because many people even haven't heard of that.
00:00:40.150 - 00:01:10.302, Speaker A: So we are building an EVM equivalent ZK rob. So that's one sentence introduction. So then we can move to more like interesting part. So the problem of blockchain layer one is that for each transaction you need to broadcast that into a p two p network. And every node need to reexecute this transaction to move from state one to state two. And this is problematic, right? Because they say there is a large redundancy there because every node needed reexecution. So the idea behind Zika rapi that instead of sending out all the transactions in the p two B network, you send all the transactions in a layer to a layer two node.
00:01:10.302 - 00:01:49.866, Speaker A: And then like this layer two node will run some ZK algorithm and generate a proof. And instead of broadcasting all the transactions, it will just broadcast the proof with some public input data needed for replication. But there are some problems, because to generate such a zero, not proof, you need to build an arithmetic circuit, right? All the ZK experts here must know how hard that is to write some arithmetic circuit. And also it need to be application specific. For example, if your transaction is on Dex, you need to build a specific circuit. For this Dex application, for example, you need to prove that your signature is correct, you have enough balance, and your pass is updated correctly in the Merkel pass. And so this is problematic.
00:01:49.866 - 00:02:29.382, Speaker A: And worse even you build multiple decade ops, there is still no compatibility between two decade ops. You still need some bridges to bridge two kilo ops. What Dickeyvma is doing is that in a nutshell, the given circuit is verifying what Ethereum virtual machine is doing in a circuit. So instead of writing circuits for each smart contract, you write a circuit. This is more general and for verifying the execution of an Ethereum virtual machine. So basically, you need to verify that your signature is correct, the smart contract is loaded correctly, the execution trace is valid, and your storage is updated correctly. So basically here, your smart contract is just the input of this EVM circuit.
00:02:29.382 - 00:03:01.670, Speaker A: It's not. You are building some circuit specifically for some smart contracts. So we have one universal circuit serving for all the smart contract logics. And before diving into even more detail to give you a sense of what is EVM. So basically they are like smart contract developer and they can write solid code, which is a high level language for developing DApps on Ethereum. And then there are three different levels. On the language level, you compile solidity and other EVM compatible languages down to some intermediate representation IR, which for example you.
00:03:01.670 - 00:03:41.758, Speaker A: So this IR is still very high level, but it gives you enough information for the low level details and because it still remains some high level semantics. And second is at the backcode level where it's well defined in the Ethereum yellow paper, it basically includes push pop and all those stuff. Third is that you have some runtime. It's an Ethereum virtual machine and which run your EVM bytecode opcode by opcode. So EVM is a stack based virtual machine. And that's why, another reason why it's hard to build like Ezk circuit, because in Zk it's more easier to build something which is register based. So this is EVM and a little bit more like a buzer comparison.
00:03:41.758 - 00:04:36.834, Speaker A: There are several approaches, and on the left hand side, like starkware and Zikk, they are building some language compatible Ziki EVM. So basically for starware, if you want to write some smart contracts in their starknet, you need to compile solidity using some external compiler called Warp, and then compile that down to some readable cargo and then run on their caro assembly code and then finally run on their Ziki virtual machine. And for Ziki zinc they are using the LVM compiler infrastructure. And so they also have their circuit language called zinc, but they are still compatible with solidity because this LVM IR front end, you can support the ir of solidity and also zinc. And then it also has its own bytecode and compile that down to ZKVM. And for what we are building, and also what Polygon Hermes is building, is that we want to build some EVM equivalent zikurop, which means we need to interpret the bytecode of ECM virtual machine. And so this ZKVM circuit, the input will be the bytecode.
00:04:36.834 - 00:05:34.086, Speaker A: It's even a lower level and more compatible. But there are still some slightly different technical approaches to do this. For polygon Hermes, for efficiency they also compile this bytecode to an even smaller subset of micro opcode and then run on their designed state machine or call UVM. And we are doing a more straightforward way, like for each opcode we will have some subsurface or several cascades to constrain like this opcode is executing correctly and then we will run that on our ZkeVM. And another maybe technical difference is that from the proving system side we are using like to write the circuit we are using plunketch optimization. And then for the recursive circuit we are also using Planck and we directly handle the non native field optimization. But for polygon hermit I think they are using stark to dealing with their EVM circuit and then use plank or grow 16 to freeze the proof size and reduce the verification cost.
00:05:34.086 - 00:06:04.246, Speaker A: So that's basically some differences. And now let's move to more technical part. The workflow of Ziki EVM is shown like in this graph. So basically you have a sequencer and you have prover. So this sequencer is a fork of gas and you can receive transactions and then you execute transactions on your gas node. And then it will generate some execution traits. Like for example it includes execution logs, log headers, transactions, contract, bytecode and Merkel proofs.
00:06:04.246 - 00:06:49.450, Speaker A: So those will be used as witness to fit into this leaky VM circuit. So I use the event circuit because it's actually composed of many different subsurcuits. For example, there is a Kashak circuit for proving that Kashak hash relationship is correct. And there are a lot of other subsurcuits and those are all some components of the given circuit. So after using this witness and running some ziki van circuit, you got multiple proofs and each for one specific circuit. And then you got some aggregation circuit to verify that those proofs are correct. And then you generate some aggregated proof and then you submit this proof on chain because you want to reduce the verification cost, because you don't want to verify too many proofs in smart contract and then together with some data and you know your transaction is valid.
00:06:49.450 - 00:07:41.482, Speaker A: So now let's move to some even more technical part, like the architecture of the EVM circuits. So basically from the top there is an EVM circuit which is built for verifying the execution or a state machine, because when EVM is executing the bytecode, it will execute opcode by opcode, right? So each opcode will be one state in this state machine. And so this EVM circuit is for writing constraints to constrain that this state machine moved correctly from state one to state two and state three. So that's EVM circuit. And so basically you need to write some constraints to constrain the state machine. And also for each within one state there is the opcode, right? So you still need to write some constraints to verify that this opcode execute correctly. So then you meet challenge one because there are so many ZK unfriendly opcodes.
00:07:41.482 - 00:08:31.550, Speaker A: For example there are the bitwise opcodes, which is super hard to prove in ZK circuits because basically you need to decompose the value into bit and prove that every beat is zero or one and then combine them together and prove that it's your value. And secondly that you have shar three and all those really they can inefficient opcodes. And so what we are doing is that instead of doing all those constraints in this eVM circuit we will just do some lookup operations. So basically I will just give an example. Like for example if you want to prove that some value is within the range between for example zero to ten, so what you do is that you generate a table. So this table like each entry is just you iterate from zero to ten. So it's basically this is a table single column, it's 0123 and till ten.
00:08:31.550 - 00:09:25.562, Speaker A: And then instead of proving that some value is within the range of zero to ten you just prove that this value belongs to this table. Because if you belong to that table it's absolutely true, your range is within zero to ten. So that's fixed table. When you are doing some bitwise operations you can just look up that you have some table which just iterate all the possible possibilities. For example we are doing ignore operations, you just iterate all the bits and then get the result and you prove that this entry belong to that table and that's enough. And for catch up table it's the same in EVM circuits for like you need to prove that this input and this output has some hash relationship. And instead of writing all the constraints in EVM circuit you just look up whether this input and this output belongs to some table and that table is actually storing all the input and possible output.
00:09:25.562 - 00:10:01.958, Speaker A: For Kai check. Now just assume that this table is generated correctly because just assume that there are some magic like you can generate this table and which has all the correct relationships between the input and output. And challenge is that as I mentioned, your ethereum virtual machine is a stack based virtual machine. So you need to verify that stack, memory and storage operations are all correct. So what you do is that you have some ram table, and for each operand you will just look up that whether this operand belongs to that table or not. And also I will give more detailed example later. And so that's how you do step and memory operations.
00:10:01.958 - 00:10:48.874, Speaker A: And thirdly, that you also need to prove that the opcode you fetch is correctly fetched from your bytecode. So you need a bytecode table. And also you need some transaction table to prove your signature and block context table to prove some other block context variables. And now, because basically what I just do is that you just assume that there are some magic and there is a table there and you just look up everything there. But in the first place, you don't even know whether those tables are correct, right? So you need a lot of subsurface to constrain that those tables are correct. So basically, for example, in kajak table, you have some kajack circuit for proving that this input and this output has this kajak relationship. So in this kajack circuit, you prove that this kajack table, all the entries in this kajak table input and output had this correct mapping relationship.
00:10:48.874 - 00:11:16.862, Speaker A: And for Ram table, because you involve some storage operation. So you also need some merkle potential tree circuit. And because like in ethereum virtual machine, your MPT is actually also composed of kaijack. So you also need to look up your kaijack table to know that this kaijack is a crack. And also you have some Ram circuit for constraining that Ram table. So I will give more detailed example, like it's still a high level overview. And for bytecode table, you prove that your bytecode has some cracked code hash.
00:11:16.862 - 00:11:53.406, Speaker A: And there is a transaction circuit for constraining that your signature is correct. And there is an ECDSA circuit for proving that your signature is correct. And there is a block circuit. Now let's move into some more ZK and technical detail, which is especially for you guys who are already ZK experts. So to write a circuit, what we are using is that we are using some ultraplunk or sometimes called planck case optimization. So basic idea is that instead of r one, the is just linear combination times linear combination equal to linear combination. But we are using a more flexible way.
00:11:53.406 - 00:12:25.642, Speaker A: We are using a table to represent your constraint system. So when you need to fill up your values or your witness, you need to put your values into some cells. And then after you fill up all the witness, this table will be full of variables. And then you can define some customized relationships. For example, there is cut gates. For example, we pick up some region which is in the right area, and you can define the relationships for those cells like within this region. I will give now a more detailed example.
00:12:25.642 - 00:13:26.762, Speaker A: For example, you have some layout like that, and you have variable vb zero, vc zero, and all those, those are values you filled up in this table. And then like for example, you want to prove that va five times vb five times vc five minus vb six equal to zero. So you just write that as your constraint. And what you are generating in the back end is that you generate one polynomial constraint, which is what I call custom gate. So basically, so the first column, you interpret that and you will get a polynomial for the first column. And similarly you will get a polynomial for the second column and the third column. And so because wave five belong to the first column, and so you write a one X times a two X times a three X minus a two omega X, because omega is actually your shift, because your interpretation actually happens on some FFT friendly field, which is some tidal factor of, it's just some tidal factor and exponentiation of tidal factor.
00:13:26.762 - 00:14:15.434, Speaker A: So that's how you are writing constraints. But if you are more familiar with ZKn, at the end of the day, you need to linear combine all those casp gates and using one vanishing arguments like it need to be divided by some x powers n minus one, because it need to vanish all those rows. So basically, these constraints can prove that all the vi times VBI times VCI minus VBI plus one is equal to zero. But what you really want is that you just want that specific area. So what you do is that you can have some selector polynomial, which is actual column. So this is pretty sparse, and you just open at a certain position like that area is one, and then you multiply with this polynomial s x. It's a selector polynomial which is interpreted from that column.
00:14:15.434 - 00:14:55.174, Speaker A: So that's other entries are just zero, and there is just one there. So this equation should be hold for all iterates from omega powers zero to omega powers minus one. And because only that row like zero, you got one there. So your constraint is just constraint in that specific area. So that's like how you are writing custom gate. And the second thing you can use in plunkish optimization is that you can have some very flexible lookup arguments. For example, traditional lookup arguments is proving that a zero, a one and a two columns.
00:14:55.174 - 00:15:30.370, Speaker A: All the values in those three columns belongs to a table like t zero, t one and t two. So that's what you have like in your traditional lookup arguments. But what we really want is that we want to look up some specific entry, right? So it's similarly you can also have some selector there and just multiplying with your input expression and you just prove that this polynomial belongs to this table and that's it. So that's basically like two tools we can use for writing our circuits. One is custom gate and one is lookout arguments. Now let's look at the EVM circuit layout. So as I mentioned, EVM circuit is for writing constraints for constraining your state machine.
00:15:30.370 - 00:16:13.406, Speaker A: So basically you have a lot of states and we use slot to distinguish that in your position in circuit. For example, there is slot I minus one, there is slot I, there is slot I minus I, sorry. And each slot will corresponding to some opcodes here. Like for example the first two rows are for push and then next several rows are for add and those slots are for multiplication. So basically you need to write all your constraints to constrain those opcodes within that certain number of rows. And more specifically there are three different ranges like within one slot. So there are the context, because you need to store the context of your state machines.
00:16:13.406 - 00:17:11.426, Speaker A: For example there is program counter, there is stack pointer, there is a guess and a lot of other stuff. It basically means that when you are executing your semachine, when you reach that step with your program counter with your stack pointer and how much gas did you left? And secondly the opcode and switch region. So basically if this region is add, then you need to open a selector at this selector add cell. So basically we are not using too many extra selectors for constraining a certain area, but instead we are just put them all in some region and then multiply with that number. And thirdly that we have some operating values which is free allocated for some opcode specific circuits. For example when you are writing add and you need three operands, right? You need to prove a plus b equal to c. And sometimes you need to carry and those more opcode specific witness will be filled up in that region.
00:17:11.426 - 00:17:51.566, Speaker A: And now let's look at a more detailed example like how we are really writing constraints. So for example, after you're getting the execution trace, you know what opcode you are executing and all the related witness. So firstly you need to fill in the context of state machine. Like if you are executing this state and what's your program counter number, what's your stack pointer number and what's your guess? And secondly that you need to set as add to be one, others are just zero. And then you need to fill in the operand of ad. So there is Va V and VC and carries because the EVM word size is 266. And we are working over the scalar field of BN 254 to be compatible with Ethereum's pre compiled.
00:17:51.566 - 00:18:23.854, Speaker A: So each cell, it works over a finite field which is 254 bit. So it's not enough for just putting 1256 bit. So we just decompose that into 32 eight bit numbers. And so that's why we have a sequence of variables there. And so that's a more concrete deeper look into the ad op code. And so how we are writing constraints. So basically, because we are not using actual selectors, we just put everything here.
00:18:23.854 - 00:19:11.430, Speaker A: So we need to prove that the switch here, there is just one switch opened. So for example, we need to prove that s add times one minus s add equal to zero, because all those should be one or zero. And also you need to prove that there is at most one open. So you need to prove that everything open equal to one. And secondly, that as I mentioned, you need to prove for some ad specific logic, right? As I said, you can define relationships over certain cells. So you can just open that as ad and multiply with other constraints you have, because only if that ad is one, you need to prove for those relationships. So those are the constraints you needed, like v zero plus vb zero minus vc zero and minus some carry because you are using eight bits for each cell.
00:19:11.430 - 00:20:00.086, Speaker A: So that's why you have 256 here. And now let's move to some constraining the context of this silly translation. So basically you have s add still s add there, because if this slot is proving for add, and then it means when you move to the next slot, your program counter need to plus one. So you need to prove that if s add is open and then your program counter, your next program counter minus this program counter minus one equal to zero. And then similarly you can also prove for stack pointer and guess. So that's for the unload constraints for a certain opcode. And now let's move to a more complicated example like the ram table and how we are using circuit to constrain that a table is generated correctly.
00:20:00.086 - 00:20:48.870, Speaker A: So basically, for example, this example is u for ad. For example, your ad is to prove that va times vb equal to vc, right? So your first operand is VA, second operand is VB, third operand is VC. So you firstly need to prove that this VA is fetched correctly. Because for example, when you are doing add, you need to pop two elements from the stack and push one element back. So you need to prove that this popped elements is exactly when you push in previous operations, right? So you prove that this operand belongs to some entries in this table. So there are so many columns and you need to prove that. So I'm doing the stack operation, this is my stack pointer and I'm doing read or write and what's the value? And then you need to prove that it's consistent.
00:20:48.870 - 00:21:34.326, Speaker A: So this is basically how this ram table look like you need to prove that some operands belong to this table. And now here comes the question, and this is for you, pop two and you push one. So every operand you need to prove this relationship holds three minutes. Okay? Yes, sorry, I just need to go very quickly. Sorry. So here's some question I mentioned, because each cell is just 256 bit and you can't actually fill VA here, right? So what we are doing is that instead of putting VA here, we are using some random linear combination to combine different eight cells into eight bit number into one encoded value a. And then we just put the RC encoded random linear combination combined value here in our ram table.
00:21:34.326 - 00:22:07.166, Speaker A: And then instead of looking up that one, you look up this linear combination. And then the problem is that your table is not constrained. So I need to write some circuits here to constrain that your table is generated correctly. But you know, like during the execution, you are not doing all stack operations one by one. You are actually doing stack operation, memory operation, and then maybe you again like stack operation, storage operation. So it's just math here, this is your real execution trace. But the problem is that when you need to prove for stack, you need to prove that it's consistent with previous stack operations.
00:22:07.166 - 00:22:45.274, Speaker A: So you need some sorting. So when we are filling with the table, we sort the rows based on tag address and rewrite index. And then secondly, we can more easily prove that the previous rewrite value is equivalent to the value you are using now because the address and the tags are just consistent. And you need to prove that the column values are valid, because for example there is just three tags and all those stuff. And you need to prove that some other related variables and finally that it's not just built by us. We are using the Halo two optimization. So we are heavily using the Halo two repos.
00:22:45.274 - 00:23:11.660, Speaker A: So we really appreciate that the builders who build hello to repo and also like there are a bunch of members from Ethereum foundation, especially the apply the KP team, and we just credit to all the community members who build this together. So this is our roadmap. We will firstly have some PoC demo for the KVM and then Testnet and then we will have some other features like crowdsourcing and move to Mainnet. And finally last slide, we are hiring and check out this website and thanks for that.
00:23:16.910 - 00:23:27.182, Speaker B: So if there's a question, we can take the question and then you guys can eat lunch. Okay, which opcodes were the hardest to implement and why?
00:23:27.316 - 00:24:07.786, Speaker A: Like for example calls. Yeah, I think there are different groups working on different. I think Kajak spends the most long time because I remember it takes months especially for the variable pidings, but that's a different sub circuit. But if you are talking about the specific EVM circuit, the switching logic I think is core because you need a lot of variable related to the code context. And also you also need to care about the revert, which I think revert and call should be the two hardest opcodes in this EVM circuit. But there are some other operations for them. Like you need to massively optimize for non AC failed for Ecdic circuit to make that really small and also catch up.
00:24:07.786 - 00:24:16.110, Speaker A: So there are different challenges all around. But if you are just talking about a state machine translation, I think it should be co and revert.
00:24:17.330 - 00:24:34.100, Speaker B: Cool. Okay, go ahead. As I understand you have really a lot of variables. So your bunker is a little bit modified. Yeah. And what is the maximum number of constraints you have?
00:24:34.870 - 00:25:07.226, Speaker A: I think roughly we have over 1000 customer gates. Like there are so many polynomials there. We are still doing some massive optimizations for this part. And also like I think around 100 lookup tables. That's a very rough number before we have done more optimization for call. Because for call it just over 100 lookup tables to look up all those bytes in this ram table. So the conclusion is that we need for example 1000 customer gates, 1000 customer polynomials for writing those constraints.
00:25:07.226 - 00:25:14.580, Speaker A: And it will definitely result in a lot of ffts and multiccalar multiplications in the back end. If that answer your question.
00:25:16.550 - 00:25:20.690, Speaker B: Go ahead. Sure you're eating into your own lunchtime.
00:25:22.230 - 00:25:24.820, Speaker A: We can talk offline, maybe. Go ahead.
00:25:25.990 - 00:25:37.446, Speaker B: At some point you're mentioning group aggregation and then recursive course. How are you talking these two problems? And also if it is with non native field for the recursive part, how efficient is that?
00:25:37.628 - 00:26:10.000, Speaker A: Yeah, I think I got some numbers but I can check that offline. But I think it's maybe around like it depends how many columns you are using. I think there are two versions. One is a highly optimized version where you use slightly more columns, but it can roughly get down to, I think 30k for one non native field of optimization on eludic curve. If you are using slightly smaller columns then you need over like one hundred k. I think I can check with you later.
00:26:11.570 - 00:26:15.330, Speaker B: Perfect. So thanks for everybody for coming and thanks deeper.
