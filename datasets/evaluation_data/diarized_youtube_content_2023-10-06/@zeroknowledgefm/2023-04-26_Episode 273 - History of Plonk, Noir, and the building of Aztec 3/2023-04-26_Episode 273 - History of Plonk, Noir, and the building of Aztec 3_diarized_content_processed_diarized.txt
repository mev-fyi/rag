00:00:05.450 - 00:00:54.540, Speaker A: Welcome to Zero Knowledge. I'm your host, Anna Rose. In this podcast, we will be exploring the latest in zero knowledge research and the decentralized web, as well as new paradigms that promise to change the way we interact and transact online. You this week I chat with Zach Williamson from Aztec. We cover the history of Planck from the start of the idea all the way up to his recent work, Goblin plank. We chat about Noir, the ZK DSL, as well as other advancements in the field, all of which have made a path for Aztec to release Aztec three, their planned private programmable L two. We also do a quick catch up on the state of ZK applications, folding schemes and what's on the horizon in our space.
00:00:54.540 - 00:01:24.258, Speaker A: Now, before we kick off, I do want to direct you to the ZK Jobs board. There you'll find jobs from top teams working in ZK. So if you're looking to jump into the field professionally, be sure to check it out. And if you're a team looking to find great talent, be sure to add your job to the ZK jobs board as well. I've added the link in the show notes. Now Tanya will share a little bit about this week's sponsor. Alio is a new layer, one blockchain that achieves the programmability of Ethereum, the privacy of zcash, and the scalability of a rollup.
00:01:24.258 - 00:01:49.630, Speaker A: If you're interested in building private applications, then check out Alio's programming language called Leo. Leo enables noncryptographers to harness the power of zkps to deploy decentralized exchanges, hidden information games, regulated stablecoins, and more. Visit developer alio.org to learn more. For questions, join their discord@alio.org. Discord so thanks again, Alio. And now here's our episode.
00:01:49.630 - 00:01:57.214, Speaker A: I want to welcome you back to the show. Zach.
00:01:57.342 - 00:01:58.210, Speaker B: Hey there.
00:01:58.360 - 00:02:14.194, Speaker A: This is your fourth time on the show, and in prep for this, I was digging through the archives to figure out, like, when did we first meet? What were you talking about then? What were the other episodes? So I'm going to give a little roundup.
00:02:14.322 - 00:02:14.806, Speaker B: Awesome.
00:02:14.908 - 00:02:45.794, Speaker A: In May 2019, you came on to talk about Aztec, which you are still doing. And we will talk about today in January 2020. You introduced plonk with Ariel, which we will also be talking about today. In April 2021, you introduced this concept of the Zkzk roll up. Because I was doing a series at the time of all about roll ups, and yours was the Zkzk one. Would you say? Is Aztec still a Zkzk roll up.
00:02:45.832 - 00:02:46.850, Speaker B: Oh, absolutely. Yeah.
00:02:46.920 - 00:02:47.538, Speaker A: Okay.
00:02:47.704 - 00:03:00.006, Speaker B: I mean, we are definitely Zk Zk roll up with the option of supporting ZK roll ups within our zk zk roll up. So possibly multiple zks. Let's see.
00:03:00.108 - 00:03:20.090, Speaker A: Wow. And then in June or July 2022. So last year, I actually had some of your teammates on the show, Joe and Charlie, came on to talk about Aztec Connect, ZK Money, and then told they. They sort of teased this idea of Aztec three. And I think that's what we're going to be talking about today.
00:03:20.240 - 00:03:23.482, Speaker B: Yeah. Very happy to shell Aztec three for as long as I can.
00:03:23.536 - 00:03:42.482, Speaker A: Cool, cool. There's a bunch of things I want to talk about, but I know that I want to start on the aztec front and get a catch up from you, especially because even since that interview last year, ZK money. And I don't know if that's still a focus. So I think we should hear what's going on with Aztec Connect. What's going on with ZK money.
00:03:42.536 - 00:04:24.946, Speaker B: So very happy to talk about that. Should we go back to the start? Because we first met and started talking about this back when the world was in black and white, and it was a long time ago because, yeah, it's been several years, but there is a narrative here, which is basically when I got started with zero knowledge cryptography. The goal was always to try and create private smart contracts. Basically take a solidity like language and add private state to it as a first class primitive and then just have an ability to just hack around with building Defi. Building dapps. But where you can hide information. Originally, this came out because we needed that for a very specific application.
00:04:24.946 - 00:04:35.358, Speaker B: So I think maybe when we first met, I was the co founder of a company called Credit Mint. Because we minted credit. Yeah. Times have changed.
00:04:35.534 - 00:04:41.414, Speaker A: Were you actually question here? Because I know you spoke at, like, ZK summit four, but had you been.
00:04:41.532 - 00:04:42.982, Speaker B: I was at ZK summit two.
00:04:43.036 - 00:04:47.318, Speaker A: You were at ZK. Did you also speak at the early ones in Berlin? I think you did, actually.
00:04:47.484 - 00:04:48.870, Speaker B: I don't think I spoke at two.
00:04:48.940 - 00:04:57.450, Speaker A: But you might have spoken at three. I remember that you were the only person in the breakout room who'd used the flip chart. I remember this.
00:04:57.520 - 00:05:01.370, Speaker B: That was plonk. That was me trying to explain the permutation argument was for Planck and failing.
00:05:01.450 - 00:05:01.934, Speaker A: Wow.
00:05:02.052 - 00:05:02.720, Speaker B: No.
00:05:03.570 - 00:05:07.966, Speaker A: Okay, so, yeah, we did know each other even before that episode then. Okay.
00:05:08.148 - 00:05:09.642, Speaker B: BP before plonk.
00:05:09.706 - 00:05:15.826, Speaker A: Before plonk. I think you make a good point. Let's go even further back. Let's do a little bit of the story from the start.
00:05:15.928 - 00:05:59.182, Speaker B: So, yeah, originally I got into web3 because I met my co founder, Tom, and he wanted to do private, like, corporate debt, just basically tradfi on Ethereum, bring real world assets to Ethereum. And I thought, wow, this is 2017. And I thought, this is the only actual meaningful use of blockchain that at the time was aware of, because 2017, it was all just junkie tokens and memes and not a lot of actual useful stuff, at least from the outside. So that's what I started working on with him. But then we realized very quickly, well, if you're going to try and do bring real world assets on chain, you need privacy. Otherwise you're leaking quite a lot of information about people and about what they own.
00:05:59.236 - 00:06:15.650, Speaker A: And actually, it makes sense that it was like sort of the business use case that was the first to be made clear. Yeah, I mean, that was always very clear to me as well. The fact that, how could you run a business if everything is transparent? Like every salary, every supplier's deal and stuff like that.
00:06:15.800 - 00:06:32.854, Speaker B: Yeah, well, I mean, it turns out that you can also just do it if you're some 16 year old anon on Twitter, that also works. But for some parts of the economy, you do need proper privacy. I came to this from a very commercial perspective, and I guess I basically got ZK pilled later on.
00:06:32.972 - 00:06:33.694, Speaker A: Whoa.
00:06:33.842 - 00:07:02.466, Speaker B: Because we needed privacy for what we were doing. And at the time, 2017, 2018, the only private tech out there really was Zcash, which, whilst incredible, was also not programmable. It wasn't any privacy on Ethereum or similar programmable chains. And so I started looking into ZK proofs, because I'm like, well, we need this for the business. I don't want to go back to my boring old job. This is too much fun. So I started reading about cryptography and learning about it.
00:07:02.466 - 00:07:05.774, Speaker B: Learning? Trying to figure out if we could port the Zcash protocol to Ethereum.
00:07:05.902 - 00:07:11.602, Speaker A: Wait, I just realized. What were you doing? What was your background? Actually, I always thought you were a cryptographer.
00:07:11.666 - 00:07:13.254, Speaker B: Oh, hell no. What?
00:07:13.452 - 00:07:17.702, Speaker A: I feel like you might have even told me this on an earlier episode, but I completely have.
00:07:17.756 - 00:07:36.926, Speaker B: Like, no, I'm very much self taught when it comes to cryptography, but my background is as a failed particle physicist. So I did a phd in experimental neutrino physics, because back in the day, I had delusions of grandeur about wanting to be a scientist, spending all my time sketching out equations on whiteboards, which.
00:07:36.948 - 00:07:37.870, Speaker A: You kind of do now.
00:07:37.940 - 00:07:43.994, Speaker B: Yeah, you can take the academic out of academia, but you can't take anticademia out of the academic.
00:07:44.042 - 00:07:47.280, Speaker A: I see. Okay.
00:07:47.730 - 00:08:26.586, Speaker B: But, yeah, I figured that didn't work out. I realized, actually, I didn't really like research because it was a bit too ephemeral, trying to measure the existence of particles that last for a billionth of a billionth of a second. It's interesting for a time, but I felt like I was basically speed running a midlife crisis, and I wanted to do something more real with my life. So I became a programmer for a couple of years to kind of sort my life out, finish my thesis, and then I met Tom, and he's like, I'm doing a startup. Do you want to join? And I'm like, well, yeah, I'm not doing anything interesting. Let's do this. And then that segued into needing privacy, which segued into me reading about cryptography, which then segued into falling down a crypto rabbit hole.
00:08:26.698 - 00:08:32.666, Speaker A: Early on, though, you had created, like, I remember you were using a different kind of ZKP.
00:08:32.778 - 00:08:33.150, Speaker B: Yes.
00:08:33.220 - 00:08:34.126, Speaker A: What was it again?
00:08:34.228 - 00:09:24.786, Speaker B: It's a sigma protocol. Okay. So before plonk, to get privacy, I put together, like, a Frankenstein cryptography protocol using older perimeters than ZK snarks, because basically, we wanted programmable business logic, and we didn't want to have to do trusted setups for every kind of effectively, circuit we were writing because we wanted it to be programmable. And so at the time, all snux required trusted setups per circuit. So given the lack of other options, I knocked together this very primitive cryptography protocol, which sort of did what we needed, but it was very expensive in terms of computational costs. In today's figures, it probably cost about $100 to do a transaction on Ethereum in terms of gas. But originally, basically, I became fascinated by ZK cryptography because it was a new area for me.
00:09:24.786 - 00:10:10.894, Speaker B: I didn't know it existed. The idea that you can prove statements about encrypted data was just radical. And I kind of realized very quickly, wow, you combine this with distributed ledger technology, you had the ability to actually create completely ledgers where the protocol is transparent and trusted, but the actual information trading across it is private. That could change a lot of things in this world. So I became a bit obsessed with it. Basically, one of my first introductions to cryptography was I did something which I later found out was a massive stereotype, which is that I got introduced to an actual cryptographer, Jens Groth, one of the OG folks. He's created the groth 16 snark he's been in the space for a long, long time.
00:10:10.932 - 00:10:11.662, Speaker A: He's been on the show.
00:10:11.716 - 00:10:26.942, Speaker B: Yeah. I owe a lot to him because basically, I got introduced to him. So I rocked up to his office, and I'm like, hey, yens, I've got this amazing new cryptography protocol. It's like, no, I'm not a cryptographer. I'm self taught, you know, but trust me, this one works. It's great. It's going to change things.
00:10:26.942 - 00:10:36.322, Speaker B: And then he read it in about five minutes. He's like, yeah, it's broken. So, yeah, that was my extremely stereotypical introduction to cryptography.
00:10:36.386 - 00:10:40.326, Speaker A: It's funny because it's like the don't roll your own crypto. But then you did.
00:10:40.428 - 00:10:48.934, Speaker B: Then I kept going. Yeah, exactly. I'm like, what's that? The definition of insanity is trying the same thing over and over and expecting different results.
00:10:48.982 - 00:10:50.938, Speaker A: Well, you did get a different result, though.
00:10:51.024 - 00:11:00.746, Speaker B: I did, because Jens was exceptionally good natured and kind of spent time advising my startup and basically mentoring me on how to actually do cryptography.
00:11:00.778 - 00:11:01.262, Speaker A: Wow.
00:11:01.396 - 00:11:10.210, Speaker B: And so that's what then, with his help, that's what then produced the original aztec protocol, which was this Sigma critical thing that I was mentioning earlier.
00:11:11.430 - 00:11:16.466, Speaker A: Even on that one, you had gotten something sort of functional. Where does Plonk come in?
00:11:16.568 - 00:12:03.810, Speaker B: Plonk comes in 2019. So we knew when we were building the original aztec protocol with this junkie Sigma protocol, we kind of were in a bit of a difficult spot because we knew that what we were building wasn't actually very good, and we didn't have the technology to build what we really wanted to build, which is not a good place to be quite demoralizing. And so I was basically spending all of 2019 and a bit of 2018 basically studying furiously everything about Zeke snarks, trying to figure out if it's possible to create what is now like, called a universal snark, which is one where you don't need, per circuit, trusted setups, where you could just do one trusted setup, or ideally, no trusted service, but at most, one trusted setup for your entire crypto system, and then you can program in any arbitrary circuit you want, and you don't need to do any more trusted setups.
00:12:04.230 - 00:12:08.518, Speaker A: And at this point, there was, like, sonics had been. Was that out?
00:12:08.604 - 00:12:23.942, Speaker B: Well, that was the inciting incident, because Sonic was published in 2019, I believe, or late 2018. I can't quite remember the date. So it was like Mary Muller's PhD thesis, I think it had Sean bow on it from Zkesh and a few others, and sorry, I can't remember the full author list.
00:12:23.996 - 00:12:29.446, Speaker A: I think we may have covered that at some point on the show, too, in detail. I remember doing a study club on that, actually.
00:12:29.548 - 00:12:38.458, Speaker B: And it. The first actual universal snark that was remotely practical, although not really usable.
00:12:38.554 - 00:12:47.102, Speaker A: Yeah, it showed something. It showed you could do this universal, trusted setup, but it didn't necessarily. Hadn't figured out the sweet spot.
00:12:47.166 - 00:13:13.370, Speaker B: Yeah, because the prover was extraordinarily slow, so you wouldn't have been able to use it in practice. But it showed techniques where it showed, hey, this is possible. And so I looked, I saw the paper, and I'm like, I have to figure out your secrets and see if there's something that can be evolved out of it. Which wasn't the easiest thing to do, because I do not wish to throw shade. I have an enormous amount of respect for the sonic authors. They've contributed immensely to the field of cryptography. There is a but, though.
00:13:13.370 - 00:13:49.906, Speaker B: And that but is that the paper is not the easiest to read, particularly if you're not kind of completely up to speed with the lingo of cryptography with a syntax of it. The sonic paper is split into two components. There's the component where they describe a snark that's universal, but it requires an untrusted third party helper who has a lot of computational resources to help make the proof. And then there's the part where you don't need that untrusted third party, but the prover is extremely slow. And that second part was the one I was interested in. But it was also the part that was kind of not really described that well, because it wasn't the main focus of the paper. It was kind of an aside.
00:13:49.906 - 00:13:50.886, Speaker B: Oh, by the way, you can do.
00:13:50.908 - 00:14:01.130, Speaker A: This, but this split you just described, the split does not correspond to the polynomial IOP and the polynomial commitment scheme or anything. This split, you're talking about something else. This is like.
00:14:01.200 - 00:14:01.866, Speaker B: It's different.
00:14:01.968 - 00:14:02.282, Speaker A: Okay.
00:14:02.336 - 00:14:26.302, Speaker B: Because both modes had two different polynomial ips, I believe. Yeah. There was a couple of. Couple of weeks where I basically camped out at a little bougie artisan cafe that was next to the flat that I was living. I camped out there with a supply of iced markers and a notepad and the solicit paper, and I went through it line by line and basically grinded through it until I understood how the damn thing worked.
00:14:26.356 - 00:14:31.170, Speaker A: Wow. It sounds like it was because you needed something like this for aztec to actually work.
00:14:31.240 - 00:14:31.522, Speaker B: Yes.
00:14:31.576 - 00:14:35.486, Speaker A: And what we're talking about here is it's still aztec one. Or is this aztec?
00:14:35.518 - 00:14:36.082, Speaker B: Aztec one?
00:14:36.136 - 00:14:40.486, Speaker A: Aztec one. Because you had created something. But did it not work?
00:14:40.588 - 00:15:01.174, Speaker B: Well, so aztec one was. It wasn't. It didn't have any scalability. So the idea was what it enabled was private ish value cryptocurrency transfers on Ethereum. But the values were hidden, but the identities weren't. And it wasn't scalable, as in, each transaction required a verification on Ethereum. And that cost a lot of gas, about 800,000 gas.
00:15:01.174 - 00:15:11.760, Speaker B: So it clearly wasn't a sustainable long term solution. And we needed something better. We needed better tech, and that better tech did not already exist, and that was causing an existential crisis for me.
00:15:13.090 - 00:15:19.390, Speaker A: So you're sitting in this cafe, you're figuring it out. Had Ariel already joined aztec?
00:15:19.470 - 00:15:29.350, Speaker B: No. So at the time, I barely knew Ariel. I met him once at a zcash conference. We shared a cab ride, but we didn't really know each other that well.
00:15:29.420 - 00:15:30.038, Speaker A: Okay.
00:15:30.204 - 00:15:45.610, Speaker B: And so that came a little bit later, about a month afterwards. So once I'd cracked the sonic paper under sour work, I'm like, right, okay, is there a way of making this fast? And I was basically drawing blanks there. It was like, how do I make this fast?
00:15:45.680 - 00:15:48.970, Speaker A: Well, did you go to Jenskrat again and ask him?
00:15:49.040 - 00:16:25.346, Speaker B: I didn't, because at the time. So he had to stop being our advisor because he joined definity. And so there was a slight conflict of interest. They poached him. And, yeah, he couldn't help, but his papers did, because basically, the path I was on before bumped into Ariel and actually had the inciting incident, which put it all together. There's a kind of a trifecta of papers that have come out over the last couple of years that were really. Whilst they didn't codify it explicitly, they were using this kind of general construction of creating ZK protocols using a polynomial interactive oracle proof and a polynomial comment scheme.
00:16:25.346 - 00:17:03.842, Speaker B: They weren't succinct, they weren't snarks, not really, but they were for, like, general purpose compute, not general purpose, sorry, special purpose computations. But they were kind of written by James Groff, Jonathan Bootle, that kind of crowd. And I was kind of devouring these papers because I had a kind of, like, intuition that there was something there that you could combine this with some of the stuff in sonic and somehow get something working. But I didn't really know how to do it. And that's kind of where Ariel came into the scene, because I met him at some crypto conference in London. I'm afraid I can't remember the name of the place. The company I hosted, it has since gone under.
00:17:03.842 - 00:18:10.818, Speaker B: But at the time, I was working on a problem where I was trying to create a bespoke ZK circuit for verifying Poseidon hashes. So very specific, and it was more of a toy at the time, I didn't really have a good use case for it, but I was like, here, Poseidon is a fun hash function. Can you make a very specific kind of, like, ZK protocol using these polynomial IoP ideas to do it? And I got to the point where I almost got something working. But there was this one minor linguing little issue, which is that basically, the way these polynomial IPS work is, generally, you'll use a commitment scheme to encode a vector as a polynomial, and then you'll perform some arithmetic over your vectors and basically define some kind of polynomial expression that checks the correctness of that arithmetic. And the problem that I had is, for my Poseidon protocol to work, I needed a shift. Basically, I needed to get a encoder vector as a polynomial, and also encode its shifted form as a polynomial and verify that those two were identical. And I didn't know how to do that using the representations that I was using, which was, at the time, this whole lagrange based thing, which is in plonc.
00:18:10.818 - 00:18:35.450, Speaker B: So, long story short, basically, I ran into Ariel. I'm like, hey, you're a brain. You know how this works. You know how cryptography works? Do you know how to do this shift thing? Ariel, to his credit, he spent a lot of time talking with me that day because I was struggling to explain the problem, because I was speaking in kind of a bit of like a butchered language, or cryptography, because I'm not formally trained in it. But he listened. He listened.
00:18:35.530 - 00:18:36.634, Speaker A: He translated you.
00:18:36.692 - 00:19:00.230, Speaker B: He translated me. Yes. He was the plonk whisperer. And he was like, I'll think about this. I went away, end of the conference. I was hacking around on my notebooks, and that evening, I realized, hang on a minute. This problem, if you can get this equivalent of a shift in a polynomial form in this kind of lagrange based idea, if you can do this and you can create a universal snark, then you could make sonic fast.
00:19:00.230 - 00:19:26.410, Speaker B: It triggered it. It clicked in my mind, and I remember it quite clearly, because I had an apple Watch at the time, and it started beeping at me, saying, hey, you're not doing an exercise, but your pulse is, like, 120. Are you okay? Because my heart was panicking because I'm like, oh, my God, there's something here. Whoa. But I thought this shifting problem, because I just wasn't familiar with how to solve it. I was like, oh, it's probably impossible. This is a pipe dream.
00:19:26.410 - 00:19:36.530, Speaker B: Move on. And then the next day at the conference, I turned up, and I was walking past Ariel, and he just whipped his head around, and he's like, oh, yeah, by the way, I've solved that problem you mentioned yesterday.
00:19:36.870 - 00:20:02.506, Speaker A: Oh, that's so. Actually, I want to say we interviewed Ariel last year about a little bit the history of planck on his side. So I will actually try to dig that up and add it in the show notes. But I love that. So you connected, and you weren't working together still, this was just like, people, you knew each other sort of peripherally, and this was the point where you started to work together, and it was on plonk, not even well ish.
00:20:02.538 - 00:20:41.154, Speaker B: I mean, basically, we were there just for one conference. Ariel was traveling around. And so at that conference, we hashed out a way where you could possibly create a universal snark. But it was still very foggy in our minds because what became the Planck permutation argument. When Ariel told me, there's this thing you can do. You can solve this problem, I'm like, dude, do you know what this means? And so we basically hit off in a side room, and I explained to him sonic's permutation argument, because not many people at the time had really dug into the sonic's permutation argument part because it was somewhat inscrutable. I wasn't teaching him permutations.
00:20:41.154 - 00:21:06.398, Speaker B: Ariel knew all about permutation networks. They've been around for donkeys years, but how to get universal snarks out of them was relatively new ish. And so, anyway, but once that clicked with him, he's like, oh, yeah, wow, there's something here. And then we had to split because we had our own lives to live. But then a couple of weeks later, we met at an airport waiting to board a plane to go to a Zkesh conference. And I looked at him, and I'm like, dude, this idea that we have, and he's like, yeah. I'm like, do you.
00:21:06.398 - 00:21:11.674, Speaker B: Should we write a paper about it? And he was like, yeah, I was thinking that too. Let's write a paper. And then eventually, that became plonk.
00:21:11.722 - 00:21:15.574, Speaker A: Did you know when you were doing this, how influential plonk would be?
00:21:15.692 - 00:21:17.320, Speaker B: I knew it was going to be a thing.
00:21:18.810 - 00:21:40.698, Speaker A: It took over so many systems like, people who were developing their own proving systems sort of sometimes threw them away just to use Planck, and it's evolved. There's like, all the variations on Planck. There's even, like, plonkish is like an adjective. You. Did you have any sense?
00:21:40.864 - 00:22:33.590, Speaker B: I mean, I had a sense that it was going to be quite valuable for the reasons why I wanted to use it for aztec, because a universal snark that's fast enough to put into production systems was completely new at the time. And, yeah, I knew it was going to get used. It's kind of why I gave it a silly name, because I thought, it'll be funny. But I didn't quite realize just how much it would take off and also just how much the community would embrace and adopt it, because the plonkish arithmetization, how do I put this? It would have been very easy for quite, for several groups or companies, institutions, researchers to basically just name their protocols whatever they wanted, as in if they use ingredients from plonk. But it doesn't mean you need to name it after plonk. But they've been quite good natured and kept the theme, and so it's helped the concept of plonk kind of worm its way into the wider cryptosphere to stay alive. Yeah.
00:22:33.680 - 00:23:00.518, Speaker A: Well, actually, tell me a little bit about the plank work you've done, maybe even since you first introduced plank on the show back in 2020. Yeah, even then, or at least the last time you were on, I think we were hearing about, know there was a hyperplanc, there was an ultra plank, there was a turboplank, there was an octoplanc. No, but I think I misheard somebody and then started, there might be an.
00:23:00.524 - 00:23:02.886, Speaker B: Octoplanc in the future, but not right now.
00:23:03.068 - 00:23:18.794, Speaker A: Actually, I asked, when I was interviewing Darren Strat, I think I mentioned this octoplanc also as a probably not real thing, and I think they did actually have a vision for what octoplanc could be.
00:23:18.912 - 00:23:19.386, Speaker B: Interesting.
00:23:19.488 - 00:23:21.558, Speaker A: So I think it should exist.
00:23:21.734 - 00:23:28.094, Speaker B: Yes. It's going to be like the cryptid of cryptography protocols. It's the one you hear about, but you can never really.
00:23:28.212 - 00:23:29.370, Speaker A: Can't find it anywhere.
00:23:29.450 - 00:23:30.270, Speaker B: Can't find it.
00:23:30.340 - 00:23:40.370, Speaker A: Yeah, but, okay, so from there, we just mentioned this, like plonked arithmetization. Arithmetization that you find in halo two. Do you find it in plonky two as well?
00:23:40.440 - 00:23:40.770, Speaker B: Yes.
00:23:40.840 - 00:23:43.010, Speaker A: Okay. What else do you find it in?
00:23:43.160 - 00:23:46.430, Speaker B: Where does a plonkish arithmetic worm its way in? Everywhere.
00:23:46.590 - 00:23:47.134, Speaker A: Everywhere.
00:23:47.182 - 00:24:27.402, Speaker B: Well, anything that isn't arbancs or a stark like air is basically plonkish. Because if you don't want to do a per circuit, trust a setup. The tricky part about doing a snark circuit is proving that your wires are correctly feeding into the relevant gates properly. Basically that your wires are copied where they need to be copied. And the way that you do that, canonically, what Plonck showed is that you can do this really efficiently with a permutation argument. And so that permutation argument is core to a ton of protocols. But I guess more broadly than that, plonkish arithmetization is a way of taking arithmetic that you want to express over vectors.
00:24:27.402 - 00:25:42.178, Speaker B: So imagine you're iterating over elements of a vector, and you're applying some arithmetic statement to the elements of that vector. It's a very nice transformation. I guess, at its core it's a way of, if you have vectors of information and you want to iterate over your vectors and apply some arithmetic operation, some arithmetic expression over those vectors, the longest arithmeticization is a very efficient way of converting that into arithmetic over polynomials at its core, combined with a way of correctly checking that copy, that basically certain elements within those vectors are copies of one another. It's kind of taken hold of it, because it's very expressible and customizable isn't you can. Well, back in 2019, I was talking about the side of custom gates, where basically, instead of doing additions and multiplications, which is the general way you create gates in a snark circuit, you can do like weird, funky custom arithmetic that's going to help your program be a bit more efficient. Things like range checks, bitwise arithmetic, elliptic curve operations. One of the big innovations, iterations that we did was in 2020, we published Polokup, which was yes, it's how to do lookup tables inside a plonkish type snark, which changed the game a little bit in terms of how the complexity of programs you can encode.
00:25:42.178 - 00:26:23.014, Speaker B: It's difficult to do complicated complex arithmetic in Ezekiel snark, because all your arithmetic is over these prime fields. It's all modulo big primes. And so if you want to represent a computer program as a snark circuit, you're faced with a fundamental problem, which is, well, computer programs use imperative programs that use binary arithmetic. There's lots of logic statements, lots of bitwise arithmetic, and it's very hard to translate that into prime field arithmetic without a relatively large blow up in the number of kind of constraints that you need and lookup tables solved this by basically being lazy and cheating. Instead of doing the computation, you just look it up from a table instead. And what really inspired me was a couple of things. One of them was early microcomputing in the 1980s.
00:26:23.014 - 00:26:46.474, Speaker B: So when the home computing revolution exploded in the 80s, programmers had to be very creative because these machines were very, very primitive. To give an example, like the common cpu chip at the time couldn't multiply. You had to add repeatedly to multiply. It couldn't multiply, it couldn't divide. It couldn't even do proper bit shifts. You could shift left or to the right by one bit. So we're talking like, unbelievably primitive.
00:26:46.474 - 00:26:53.642, Speaker B: And so what programmers did was they, well, they used lookup tables to store arithmetic computations instead of doing them like multiplication tables.
00:26:53.706 - 00:26:54.270, Speaker A: Wow.
00:26:54.420 - 00:26:59.026, Speaker B: And so I was like, there must be a way of doing this in a snark, too. And there was. Cool.
00:26:59.208 - 00:27:10.194, Speaker A: And that's the lookup arguments, basically. Lookup tables. We actually asked that question on the latest CK summit forum. What is the lookup argument, actually? What is the difference lookup table? Lookup argument?
00:27:10.322 - 00:27:28.038, Speaker B: Well, I mean, I'm not going to claim to have invented lookup arguments generally because they go back, but. So pluckup was just a way, was a way of doing them very efficiently in a plonkish arithmetic type circuit. So what's the difference between a lookup table and lookup argument? A lookup argument is a way of proving that you've correctly read from a lookup table.
00:27:28.134 - 00:27:48.546, Speaker A: Okay, got it. We talked just now about the ways that plonkish arithmetization has been used, and it's how it's showing up and some of these other techniques. But what about on your front, since we spoke, even maybe like in 2021, what kind of plonk variants or developments have you done?
00:27:48.648 - 00:28:21.578, Speaker B: Yeah, so quite a bit, because I mentioned at the start, one of the key driving forces behind Aztec is we want to do private smart contracts, and plonk on its own isn't enough. It's good. It's not good enough. So we always need more speed and more power, make things faster. And so that's what I've been trying to do well in tandem with a lot of people in this space over the last several years. And so part of that has been improving plonk. So adding lookup tables, adding custom gates, creating these new weird variants like toberplonk and ultraplonk, and then something else which kind of changed the game a little.
00:28:21.578 - 00:28:26.990, Speaker B: Bit flipped the board over. Was hyperplanc, which you didn't do. I didn't do.
00:28:27.060 - 00:28:27.882, Speaker A: That was Benedict.
00:28:27.946 - 00:28:34.980, Speaker B: That was Benedict. And the espresso systems. Yes. See, they pipped us to publication on that one.
00:28:35.350 - 00:28:37.618, Speaker A: Had you had something like that in the.
00:28:37.784 - 00:29:02.422, Speaker B: Yeah. So hyperlong at its core is plunked with using something called a sum check protocol. And it stems from a paper from 2020, I think Benedict wins also was an author on that, but I can't quite remember. So there's 2020 paper about how to do sum checks with cynical tensor codes. And it was quite clear from reading the paper this can be adapted to plonk. Relatively straightforward.
00:29:02.486 - 00:29:08.954, Speaker A: One thing, though, if this adding sum check or making it sum check was the change, what was it before? Zero check.
00:29:09.072 - 00:29:19.006, Speaker B: Yeah. So the idea is, if you have some arithmetic over your polynomials, you encode your vectors of information such that the resulting polynomials, they vanish on some subgroup. Yes.
00:29:19.028 - 00:29:21.226, Speaker A: And this was the vanishing polynomial.
00:29:21.418 - 00:29:25.458, Speaker B: The idea is you check arithmetic is zero modulo the vanishing polynomials of your.
00:29:25.464 - 00:29:26.210, Speaker A: Subgroup.
00:29:28.310 - 00:30:15.330, Speaker B: Zero checks quotient computations. So you can place that with a sum check protocol where you basically, instead of encoding things over in a univariate polynomial, you encode them as a multilinear polynomial. The idea is if you have a vector of size n, you take log n variables and you encode your data as a polynomial in those variables, where when you evaluate those, those login variables at zero and one, each combination of the zeros and ones gives you one of the elements in your vector. So basically you encode your data as the elements of a Boolean hypercube, an n dimensional boolean hypercube, which I love saying. Wow. Yeah. It's kind of a weird crossover between zero knowledge cryptography and psychological horror novels, but, yeah, hyperplunk.
00:30:15.910 - 00:30:23.410, Speaker A: I think Benedict gave the presentation as actually zk eight, potentially. It's like six months ago.
00:30:23.480 - 00:30:39.046, Speaker B: Yeah, we had very similar ideas, but we took our sweet time putting it together. Our paper is still not yet published for a couple of reasons, but we're nearly there. So, yeah, they pipped us to the post and got it. Pretty awesome work and very grateful that.
00:30:39.068 - 00:30:46.618, Speaker A: They kept with the plonk theme you recently released. Goblin plonk. But this is not this work. Right? This is something else.
00:30:46.704 - 00:30:51.206, Speaker B: Yeah. So the thing I was just talking about, at least the one that we're internally calling it honk.
00:30:51.318 - 00:30:56.458, Speaker A: Oh, that's honk. Okay, so you just skipped the hyperplanc and just went straight to honk.
00:30:56.554 - 00:30:57.200, Speaker B: Yeah.
00:30:57.570 - 00:30:58.960, Speaker A: Cut out all the middle.
00:30:59.730 - 00:31:07.862, Speaker B: Yeah. So, so it stands for highly optimized plonk with a few silent letters. Very good. But yeah, slightly different to goblin plonk.
00:31:07.946 - 00:31:12.430, Speaker A: Okay, but why would you keep working on honk if hyperplunk already exists?
00:31:12.510 - 00:32:02.340, Speaker B: Will you be adding honk? Should be adding some. Several additions to hyperplunk, because the hyperpllk paper treat is a very general description of how did you plonk when you encode things over brilliant hypercubes. So my take on it is that the authors, they wanted to create a general description, which means that they treat the various cryptographic sub protocols you need as black boxes. And the paper doesn't describe particular schemes you can use, and therefore all the particular ugly engineering hacks and tricks you can use to make it fast. And so things like cyclic shifts are expensive, and if you choose specific multilinear commitment schemes, they become very, very cheap. And so there's also tricks you can do. And so I guess our paper is, a, it's a collection of the tricks, but b, it's got a new multilinear polynomial commitment scheme, which should be more efficient than the other stuff.
00:32:02.710 - 00:32:03.890, Speaker A: What's it called?
00:32:04.040 - 00:32:05.186, Speaker B: Doesn't have a name yet.
00:32:05.288 - 00:32:07.118, Speaker A: But what would it be replacing?
00:32:07.214 - 00:32:28.054, Speaker B: KCG? No, it uses KZG as a subcomponent. It would be replacing something called Gemini. So Gemini is a folding scheme where basically you have an abstract multilinear polynomial, but you use a folding scheme to represent it, eventually to provide a mapping to map that maps it to a univariate polynomial commitment that you can then open with KCG.
00:32:28.102 - 00:32:31.978, Speaker A: Is this at all like playing on the Nova thing?
00:32:32.144 - 00:32:43.930, Speaker B: No, I've used the word folding it, but it's folding in a different way. Most of the UK crypto is basically it's folding schemes and polynomials at its core, I think. And, yes, it's a different way of different context.
00:32:44.010 - 00:32:46.874, Speaker A: Okay, so that's honk. Now, tell us about goblin Plunk.
00:32:46.922 - 00:32:50.978, Speaker B: Goblin plunk. Oh, yeah.
00:32:51.144 - 00:32:55.378, Speaker A: You were also just describing. You had to explain some Zen. What is it?
00:32:55.464 - 00:32:56.574, Speaker B: Generation Z slang.
00:32:56.622 - 00:33:00.758, Speaker A: Generation Z slang. To help me understand why you decided on this name.
00:33:00.844 - 00:33:58.118, Speaker B: Okay, so it's wider context is one of the things that's obsessing me is the cost of recursive proof composition. To do something like aztec three with private smart contracts. It helps immensely if you have recursive snarks as a very, very cheap primitive you can use, where you can just check the correctness of a proof within a proof, and that not add much overhead to the prover. We care greatly about this because if we can do client side recursion quickly. So proofs constructed in a web browser on an old computer with not a lot of memory. If you can do that, then it makes it possible to represent snark based smart contracts in a manner that's very intuitive for developers, where it allows you to abstract a lot more away. And so I've been assessing around fast recursion for ages, and Goblin plonk is a recursion scheme that I believe we've not finished implementing it yet, but I believe it's going to be exceptionally performant and have very, very low proverb costs.
00:33:58.118 - 00:34:03.354, Speaker B: And it's called Goblin plunk because it's when a recursion goes goblin mode, and.
00:34:03.392 - 00:34:10.618, Speaker A: Goblin mode is lazy, greedy, slothful and slothful. That's what you were telling me before.
00:34:10.704 - 00:34:11.242, Speaker B: Exactly.
00:34:11.376 - 00:34:11.770, Speaker A: Okay.
00:34:11.840 - 00:35:06.794, Speaker B: And the reason I call it that is because the recursion scheme, it's very lazy in that when you're recursing over elliptic curves, one of the big problems is you need to do something called non native field arithmetic, where you need to do lots and lots of arithmetic modulo a modulus, which is not the native modulus that your circuit is using. So generally that's a very expensive thing to do, which slows down provers. And the best way of doing it so far is the halo two curve cycle scheme, which I would consider block goblin plunk to be very much an iteration of because it still uses curve cycles. But basically the main innovation is that when you're actually doing your recursion, instead of performing all these, take the expensive computations you need to do, and instead of performing them or evaluating them, you cheat. You present a lookup table which just magically has the results you're looking for, and then you worry about proving the correctness of that lookup table later on in the protocol.
00:35:06.842 - 00:35:22.078, Speaker A: This seems to be a trend, though. This idea of like, you push the proving of something to later. Is this like halo two is doing it, or rather, Nova starts to do this, I think. And this is where it sort of sounds, again, familiar.
00:35:22.254 - 00:35:28.440, Speaker B: Yeah. So it's a good trend because it's always nice to make something somebody else's problem.
00:35:29.050 - 00:35:31.094, Speaker A: But isn't it still your problem just later?
00:35:31.212 - 00:35:58.186, Speaker B: Yes, true. Well, there's two ways of why deferred computation is valuable. One of them is genuinely is somebody else's problem. The idea is you have two previous one has very weak computational resources, one has lots of computational resources, but is perhaps not trusted. You want to basically minimize the computation that your weak prover does and defer as much as you can to the strong prover without leaking information to the strong proverb.
00:35:58.218 - 00:35:58.750, Speaker A: Interesting.
00:35:58.900 - 00:36:51.226, Speaker B: And that's kind of what halo two is doing with these curve cycles. And similarly, I think it's what Nova is doing as well. I'm not the expert on that, so I could be mischaracterizing the protocol. Goblin plug is slightly different, where it is still all your problem as a prover. But the idea is that what you can do is, as you're recursing, you're basically building up a giant lookup table that contains all of these elliptic curve operations you need to do that are over a foreign field, and then at the very end of your once you've actually computed all your recursive proofs at the very end, and somebody needs to prove the correctness of this transcript. And one way of doing that is basically you use these curve cycles. So you commit to the same information over your cycle curve, which basically translates the problem from doing this foreign field arithmetic, doing native field arithmetic.
00:36:51.226 - 00:37:35.566, Speaker B: So it reduces the complexity of the problem by about a factor of 1000, and then you prove the equality between these two commitments. So basically you have commitments to your elliptic curve operations over your main curve. You have commitments to your elliptic curve operations over your cycle curve, if they are equivalent. If you can prove they are equivalent, then the problem becomes very, very easy, because then you just create a custom snark circuit of your cycle curve to evaluate the correctness of the transcript. It turns out that actually it's not very hard to do that equivalence check. So I stole this from EIP 4844 because they have a similar issue where you take your cycle curve commitments, you just open them using the inner product argument or whatever commitment scheme is useful for you at some random point. And then what you want to do is use a snark circuit over your main curve to iterate over.
00:37:35.566 - 00:38:44.930, Speaker B: So you take your transcript commitments over your main curve, and you incorporate them into a snark circuit where the commitments become columns in a circuit. And then for each row, you're basically iterating over the coefficients of your polynomial, and you use foreign field arithmetic to evaluate the polynomial at the same random point that you opened your cycle curves on using the field of your cycle curve. And so long story short, it translates the problem of doing non native elliptical scalar multiplications into the problem of doing native elliptical scalar multiplications, which are very cheap, and five non native field multiplications, where if you only do five, that's also very cheap, especially in the Koblin scheme, you can basically create a custom circuit that just does non native field moles. Doing five of those is actually about the same cost as doing a native ellipsic curve multiplication. And my kind of back on the envelope napkin math is that this should be exceptionally proverient, as in possibly something like 8000 plonkish constraints, all into recursively verified proof, which would be, if I'm right, it would be like, at least one order of magnitude, I think, of an improvement over the existing stuff.
00:38:45.000 - 00:38:49.506, Speaker A: So what does that mean? Sort of like, in terms of speed, is it like half as long or.
00:38:49.608 - 00:38:50.646, Speaker B: No, like about ten x.
00:38:50.668 - 00:38:51.350, Speaker A: Ten x.
00:38:51.500 - 00:39:01.814, Speaker B: If it genuinely is ten x, less. Fewer constraints. And so, yeah, so basically the idea is then you can just use it as a cheap commodity, primitive, and recursion no longer becomes, like, a difficult problem.
00:39:01.932 - 00:39:02.514, Speaker A: Wow.
00:39:02.652 - 00:39:04.010, Speaker B: Which would be really nice.
00:39:04.080 - 00:39:06.678, Speaker A: Is it solved or is it, like, work in progress?
00:39:06.774 - 00:39:13.946, Speaker B: So we're implementing it, because we're implementing lots and lots of things at once. And so, yeah, we're doing our best.
00:39:14.128 - 00:39:14.970, Speaker A: I see.
00:39:15.120 - 00:39:27.182, Speaker B: One of the things that I did with goblin plunk was I just published it as soon as I had the idea. I just wrote it up and threw out into the worlds because I figured the more eyeballs on it, the more people can break it, improve it, et cetera.
00:39:27.326 - 00:39:29.810, Speaker A: But you have to implement it to really know if.
00:39:29.880 - 00:39:40.360, Speaker B: Exactly. Yeah. Until then, I'm just bullshitting. It's just basically me with a megaphone saying I've got this amazing idea, but she goes to the school next door and you can't see her.
00:39:42.250 - 00:39:53.114, Speaker A: I want to kind of bring in the topic of noir to this conversation about plonk. Because noir, is it aztec specific or is it plonk specific?
00:39:53.312 - 00:39:54.054, Speaker B: Neither.
00:39:54.182 - 00:40:05.950, Speaker A: Neither. Okay, so noir is a DSL domain specific language. And this was released when? Like, eight months ago or so. Ten months ago.
00:40:06.020 - 00:40:07.518, Speaker B: Yeah, about that.
00:40:07.684 - 00:40:22.638, Speaker A: And we actually hosted a workshop for Zkhack three where we got to actually see noir in action. I think there's a lot of people who are very excited about it. I always thought it was like, the Planck native. Okay, tell me then, what is noir?
00:40:22.734 - 00:40:44.460, Speaker B: Okay, so noir is our attempt to create a very generalized Zk programming language where the idea is it exposes a very high level programming language that's rust. Like that. The idea is that it compiles down to Zk circuits. But we deliberately made it platform agnostic because we didn't want this to just know the aztec thing or the plonk thing, because, well, it's an open source project, and we want as many people to use it as possible.
00:40:44.830 - 00:40:51.366, Speaker A: Does it favor plunk? Is it more usable with plunk? Is there any benefit to. Is there any connection?
00:40:51.398 - 00:41:38.662, Speaker B: I mean, I would say it's faster with plonk because plonk is the fastest arithmeticization scheme out there. But that's my. So it's. We want it to basically be the LLVM of snarks, where it doesn't compile to circuits or constraints. It compiles to an intermediate representation called ASIr Abstract circuit intermediate representation, where the idea is then once you have an ASIR program, then you can take any cryptography backend that you like and convert that ASIR into constraints for that backend specific proving system. So basically equivalent to how computer programming languages in general are constructed. The idea is you have a language front end, like rust or c plus plus or, I don't know, haskell, where you have your front end, the actual language you code in with its semantics as rules, et cetera.
00:41:38.662 - 00:42:04.622, Speaker B: And then the language compiler doesn't turn your program into machine code. Generally what it will do is it will turn it into, well, Llvmir, low level virtual machine, intermediate representation. It turns it into basically a kind of proto assembly, but for an imagined virtual machine that doesn't really exist. So that's what the language front end does. And then the language backend takes that intermediate representation and actually turns it into machine code for a specific computer architecture.
00:42:04.686 - 00:42:05.010, Speaker A: Okay.
00:42:05.080 - 00:42:34.026, Speaker B: And this is how you can have a program that you write once, and it compiles to Mac, to windows, to iPad, to iPhone, to tons of different cpu architectures. And so we're taking the same approach with ZK languages. So noir is a language front end for ASir. So it has its own special must like syntax that compiles programs to this AsIr representation. But that's where kind of noir stops. And then it's somebody else's job to take the ASir and turn it into an actual ZK circuit.
00:42:34.138 - 00:42:36.730, Speaker A: What would it work with then? Would it work with arcworks?
00:42:36.810 - 00:42:37.680, Speaker B: Yeah, I think.
00:42:38.370 - 00:42:40.350, Speaker A: Would arcworks be the second part of.
00:42:40.420 - 00:42:48.914, Speaker B: Yeah, exactly. So arcworks would be the backend, I think. I'm not sure we either have or are working on an arcworks integration. We have a gnark integration as well as the aztec one.
00:42:48.952 - 00:42:51.006, Speaker A: Yeah, the gnark one was. That's the consensus.
00:42:51.118 - 00:42:51.490, Speaker B: Yeah.
00:42:51.560 - 00:42:59.094, Speaker A: Okay. But is noir then on the same level as circum? Is circum doing the same thing as noir? Does it also compile down?
00:42:59.132 - 00:43:19.670, Speaker B: It's doing a similar thing, but circum is a bit more. I believe it's a bit more integrated in that circum has a R cs backend and a plonk backend, but they're tightly integrated in the language itself, so it doesn't really give you an intermediate representation that you can then compile using some other kind of proving system. So it's a bit less abstract in that way and less modular.
00:43:19.750 - 00:43:28.430, Speaker A: I see, actually, yeah. What you're saying, though, is because it has this intermediate representation, where does the plonk part start? Is that like, after that?
00:43:28.500 - 00:43:37.902, Speaker B: After. Okay, so your back end can take that IR and turn it into r one cs constraints and then compile those into a circuit. Or it can turn it into plunkish constraints and compile those into a plonk circuit.
00:43:37.966 - 00:43:42.674, Speaker A: Could it do something in, like, the midn error kind of context as well?
00:43:42.792 - 00:44:01.126, Speaker B: Yeah, I mean, it might not be the fastest because you're taking a program and converting it into VM code. You're taking the IR for Noir and then turning it into polygonmiden assembly, which is, again, another form of IR, and then that gets turned into a VM second. So you could do it? Absolutely. It might not be the fastest, but you could do it.
00:44:01.148 - 00:44:31.122, Speaker A: I. I see, see, at the recent ZK hack, I know a few people started to work on noir and used Noir. Is noir meant to be the language that a hacker could build a little ZK project with 100%, or is it? Okay, so it really is. Because that's what's sort of unclear. The way you described it, though, you're still sending it into this intermediate representation context. If you just use noir, you still need to use that second part, don't you?
00:44:31.176 - 00:44:52.618, Speaker B: You do, but the idea is, yeah. Okay, so an actual build of noir, a deployed version of Noir, will choose a specific crypto backend to use. And so the goal is to present an abstraction layer to the developer, where they just write their noir program and they just click a button and it compiles to a circuit with a smart contract, verify they can deploy it to.
00:44:52.704 - 00:44:55.562, Speaker A: An EVM chain underneath that they don't need to know about.
00:44:55.616 - 00:45:08.922, Speaker B: Exactly. The idea is the end goal is for it to be turnkey effectively, where you just code your up your knob program, and then you just run it, and you don't worry about anything that's happening under the hood. I'm not going to claim we're there yet, but we are working very hard to get the language.
00:45:08.986 - 00:45:40.514, Speaker A: Would Noir then be also used with something else? Say, you wanted to create, I don't know, some front end application that then on its back end, not back end, we're not talking circuit yet, but it's going to be using zkps under the hood. Would you be using something like solidity on the front end or JavaScript or something? And then you have actually it wouldn't be solidity, it would probably be JavaScript. So would you be using something like JavaScript then Noir, then it's automatically using arcworks.
00:45:40.642 - 00:45:41.282, Speaker B: Yeah, exactly.
00:45:41.356 - 00:45:42.314, Speaker A: Kind of what that looks like.
00:45:42.352 - 00:46:15.706, Speaker B: Yeah. The release of noir that you're using would contain either like an integrated arcwest backend or an aztec backend or nag backend. You would have a tool chain, I mean, we have a tool chain now which does this. Although for the aztec backend at least a tool chain where, yeah, you just compile a nois, it gets turned into a proving key, verification key. You can make your proofs and it's relatively straightforward. And yeah, we have a javascript wrapper around it all. So that if you're building a front end website that uses Noir where the user needs to make a noir proof, you can do that all by making JavaScript calls.
00:46:15.838 - 00:46:48.478, Speaker A: Now that we've gotten to this point, I'm like Aztec as an entity now we have to dig into it because I have always thought about Aztec as almost like a roll up. Right. Because we did the Zkzk roll up episode and you said at first it was like a smart contract directly on Ethereum and then migrated to this roll up concept. But now what you're describing, the fact that is aztec arcworks, then. No, sorry to confuse you. No, but this is.
00:46:48.484 - 00:46:52.202, Speaker B: Where is the question basically, why are we doing this with noir?
00:46:52.266 - 00:47:06.082, Speaker A: Well, it's almost like now that we've described plonc, then we've described noir, and what we haven't really described is like Aztec, which brings all of these things together and yeah, that connection point I think I want to understand.
00:47:06.216 - 00:47:10.950, Speaker B: Sure. So the reason we're developing noir like this is very much like transparently we have very ulterior motives.
00:47:11.530 - 00:47:12.358, Speaker A: You have what?
00:47:12.444 - 00:47:47.346, Speaker B: Ulterior motives. So in terms of like, we want noir to be a public good that is open source. Anybody can use it. They can build their own back ends, their own front ends. They can basically just use it however they want, even if it doesn't touch any other aztec system. And yeah, it doesn't benefit like Aztec as a company directly and. Well, why is that? It's because what is the end of state for the Aztec we are building a Zkzk roll up a layer two, where the layer two is effectively we want to recreate the smart contract ecosystem that Ethereum has.
00:47:47.346 - 00:48:30.462, Speaker B: But as a layer two, where you have private state as a first class default primitive, basically things become private by default, where as a developer you can write your smart contract and then just trivially, easily just include private data in your program logic. So that needs a lot of disparate components to work. You need an exceptionally fast ek premium system. You need an architecture that enables all of this, that represents programs as ZK circuits, and then represents evaluating these transactions over these programs inside some kind of ZK roll up architecture. You need the entire layer two architecture coded up as recursive ZK snarks, and you need a language that you program these contracts in.
00:48:30.516 - 00:48:30.782, Speaker A: Okay?
00:48:30.836 - 00:49:09.174, Speaker B: And this is where noir comes into the picture, because we planned for Noir to be the smart contract programming language for Aztec three. And so we want to very much grow the developer ecosystem for noir just generally. As in it's a positive some win win game for everybody, as in we build noir as a general purpose language that doesn't need to plug into a three, just commands to snarks or starks or whatever. You want to basically make it easy to write ZK programs. And the bigger that developer ecosystem is, the better it is for us, because then the bigger the stable of developers is, that could potentially write SX three programs and smart contracts.
00:49:09.222 - 00:49:51.002, Speaker A: I kind of want to go back to that description before of what a developer would do if they're deploying a contract or they're building an application. This sort of like we're using noir as this middle thing. We have JavaScript on one side, we have Aztec on the other side. Let's kind of rewind to 2021, when we were doing this series on all these roll ups you had, and I think most people listening to the show are probably familiar with it, but you often have this batching of transactions or state changes or whatever, and then they're writing something to the base chain. I always thought of the snark as just sort of like the thing that just does the validity. You add the ZK part, the secret part. But now I'm confused about how does.
00:49:51.002 - 00:49:58.490, Speaker A: If you're writing on top of this snark or you're writing on top of the Zkzk roll up, where is the circuit going?
00:49:58.640 - 00:50:00.598, Speaker B: Where is the circuit going? That's a good.
00:50:00.704 - 00:50:02.894, Speaker A: Do you kind of understand why I'm confused here?
00:50:03.012 - 00:50:04.160, Speaker B: Yeah, definitely.
00:50:05.570 - 00:50:23.038, Speaker A: I know a lot of the parts of this. But the actual way that an application on this roll up using zkps in its fullest form for privacy, then is also connected to this main chain, base chain. This is where I get confused.
00:50:23.134 - 00:50:31.842, Speaker B: Okay. So I can try and describe the astic three architecture at a high level. I'm about to record a one and a half hour presentation that describes the full architecture.
00:50:31.986 - 00:50:35.158, Speaker A: I'll try to find it by the time I release this.
00:50:35.244 - 00:50:41.138, Speaker B: Yeah. So I'll try and give it a quick go. So the idea is to start with, let's take a noir contract.
00:50:41.234 - 00:50:41.602, Speaker A: Okay?
00:50:41.676 - 00:51:00.698, Speaker B: So at least once we've added all the functionality we need into a noir, then you'll be able to define your contract as a set of public functions and private functions where a public function can modify public state. So it'll be like state as in the kind of state that you have already in a solidity contract, variables, mappings, et cetera.
00:51:00.714 - 00:51:04.686, Speaker A: But is this state also on the roll up, though? This public state on a roll up?
00:51:04.708 - 00:51:39.478, Speaker B: Yeah, it would be like what optimism has or something. Yeah, it's going to be like part of the l two s state database. Okay. And then your private functions, which modify private states where this state will. Again, it'll be part of the roll up, but it'll be encrypted. And it's going to use the similar abstractions that zcash use as an astrocase, where you have this idea of a Utxo set, unspent transaction objects and a nullifier set, where the idea is you can add encrypted data to the Utxo set, and then you can effectively delete it, adding its nullifier to the nullifier set. Unless you have the decryption keys.
00:51:39.478 - 00:51:46.720, Speaker B: You can't link a nullifier to a Utxo. And therefore, if you've deleted a Utxo, only you as the deleter know about that.
00:51:47.090 - 00:51:52.570, Speaker A: But the challenge of Utxos has always been like, there's no programmability in it, it's just about transfers.
00:51:52.650 - 00:52:09.158, Speaker B: Well, so the way we're representing it as a UtXO, it's just very abstract, as in the state that it encodes is not at the protocol level. We don't know or care about it. It's not values, it's not identities. It's just 64 bytes of information.
00:52:09.244 - 00:52:09.638, Speaker A: Okay.
00:52:09.724 - 00:52:43.006, Speaker B: Very much like a storage slot on Ethereum. Well, the idea is then the no contract you're writing, that's the thing that's defining the rules around when, what state that state is like, how it's encoded, how it changes. So you can write, say, a private token contract using a combination of these private and public functions. And the idea here is that these functions get converted into snark verification keys. And a contract on Aztec three is defined as the set of snark verification keys that correspond to all of the.
00:52:43.028 - 00:52:45.358, Speaker A: Functions of that contract, private and public.
00:52:45.444 - 00:52:46.078, Speaker B: Yes.
00:52:46.244 - 00:53:00.018, Speaker A: Does each contract then have, like, a unique way of the interaction between those two? I'm just curious, how do you still keep state if part of state is private and it's just a blob of data and it's not in any sort of account system?
00:53:00.104 - 00:53:02.226, Speaker B: Well, it's in a Merkel tree, but it's private.
00:53:02.258 - 00:53:07.898, Speaker A: And does this noir contract still, is it still able to go in and retrieve information from it?
00:53:07.984 - 00:54:07.814, Speaker B: Yeah, that's hard, but yes. So the idea is, basically, when you're actually constructing noir proofs or simulating and executing, et cetera, basically the aztec client effectively has a private state store. And so when you're running a noir program to make a proof, et cetera, basically the noir intermediate representation has state read opcodes, state write opcodes. And then when you're turning those opcodes into constraints, then you've got to send requests to a private state store to say, hey, can I read this information? Like, I've got a storage slot? Can I get the UtxO and the underlying data? And then that private state store, it has its own permission, security rules to say, well, either, yes, okay, I'm going to give that to you, or no, get lost. I'm not giving you my secret keys. So the idea is that basically inside the layer two kind of like state databases, we have a contracts Merkel tree. Like when I use tree, in this context, it's basically synonymous with database.
00:54:07.814 - 00:54:17.194, Speaker B: It's just a way of representing a database. Yeah. So the Merkel tree contains leaves that represent contracts, and each leaf, contract leaf is its own mini Merkel tree that contains all the verification keys for all the functions.
00:54:17.242 - 00:54:17.502, Speaker A: Okay?
00:54:17.556 - 00:55:05.110, Speaker B: And so that uniquely defines the contract. So if you're sending a transaction on the aztec network, you basically need to construct a proof over something that we call the kernel snark. So we're very much using the Zexi nomenclature here. And this is very much kind of, very much was derived from Zexi was kind of the OG that attempted doing this. And what the kernel snark will do is, well, it'll fish out a verification queue from the contracts tree that you're requesting, check it exists, and then the user will provide a proof for the crates of that function call that will then get verified recursively by the kernel circuit. And then the kernel circuit is going to do some logic. So it's going to basically grab the public inputs out of that snark circuit, and those public inputs are going to be interpreted according to a contract AbI.
00:55:05.110 - 00:55:47.782, Speaker B: And so basically, so some of the public inputs are going to represent chain state, some of them are going to represent state updates that the user is trying to make, things like that. And the kernel circus job is to check the validity of all of that to make sure that you're not lying, you're not presenting the incorrect chain state the user is not trying to make state reads that don't exist, et cetera. And so one kernel proof basically represents the correct execution of a private function. The way we use recursion. The problem is that, take ethereum for example. One transaction may be constructed out of multiple function calls to different contracts. If I'm, for example, if I'm trading on uniswap, my uniswap transaction is going to talk to at least two token smart contracts.
00:55:47.782 - 00:56:20.294, Speaker B: There's probably other contracts that Uniswap talks to to do things like get price fees, et cetera, et cetera. And so what you really need is composability. How do you get composability between multiple contracts in a ZK snark world? With privacy preserving properties. And this is where we add recursion. So we have this concept of a call stack. So the kernel sacket contains two data structures, basically arrays like vectors that represent your private function calls and your public function calls. And when you start your transaction, your private function call stack has one item on it, the contract you're calling.
00:56:20.294 - 00:57:06.750, Speaker B: But once it's processing that function call, one of the results from that can be that your function call can instruct the kernel circuit to add more function calls to the function call stack. And so the idea is what the kernel circuit is doing. It's a recursive structure where it's verifying a previous iteration of a previous kernel circuit, proof if one exists, and then it's popping a function call off the function call stack, processing it, and then conditionally adding more function calls onto the function call stack if that is required. And basically what you can then do is by iteratively computing kernel circuit proofs, you can wind your way down to eventually your private function call stack being empty. And at that point your proof is ready to be sent to a roll up sequencer. A sequencer, yes, to be aggregated into the roll up block.
00:57:06.830 - 00:57:14.886, Speaker A: In this case, you've used the term recursion, but are you talking about recursion in the ZK sense, or is it snarks? Recursive snarks, yeah.
00:57:14.908 - 00:57:37.402, Speaker B: Because the kernel circuit has to verify the correctness of function proofs, which is a snark circuit. Verifying a snark circuit. And also, if your transaction is consisting of more than one private function, then you have to repeatedly compute kernel circuit proofs, where at each iteration, your kernel circuit is verifying a proof of the kernel circuit at the previous layer, which is another layer of chunk of recursion.
00:57:37.466 - 00:57:40.970, Speaker A: Wild. I do feel like I'm going to need to see slides.
00:57:41.050 - 00:57:41.680, Speaker B: Yes.
00:57:42.290 - 00:57:44.190, Speaker A: Which I think we will see at some point.
00:57:44.260 - 00:57:49.934, Speaker B: Yeah, well, our architecture documents are finally public. We finally got them in a state where we're happy to show them to the world.
00:57:50.052 - 00:57:58.534, Speaker A: I want to see this. I want to walk through, like, when I get to re listen to this, I want to see it kind of with some imagery. So if you can send that my way, I'll add it to the show notes for folks as well.
00:57:58.572 - 00:57:59.046, Speaker B: I will do.
00:57:59.068 - 00:58:14.026, Speaker A: Yeah, this is fascinating. Aztec three was teased on the last episode I did on Aztec with Joe and Charlie. But at what stage is it? Is it close or is it like. Or which pieces maybe are already built?
00:58:14.128 - 00:58:17.610, Speaker B: So we're building it in anger, but it's a very.
00:58:17.680 - 00:58:18.502, Speaker A: In anger.
00:58:18.646 - 00:58:24.718, Speaker B: Well, sorry, it's a turn of phrase. We're going ham on it, as in, it's the focus of the company.
00:58:24.804 - 00:58:26.080, Speaker A: Going ham on it.
00:58:26.930 - 00:58:31.002, Speaker B: Can I swear on your podcast? I mean, ham stands for hard ass motherfucker.
00:58:31.066 - 00:58:34.590, Speaker A: Oh, okay. You're working hard.
00:58:34.660 - 00:58:35.134, Speaker B: Yeah. Okay.
00:58:35.172 - 00:58:45.266, Speaker A: That's what you mean. Kobe created, like, a translator for basically, like, british terms for other people. And I feel like we need to use it a little bit with you, but.
00:58:45.288 - 00:58:47.026, Speaker B: Okay, possibly, yes.
00:58:47.208 - 00:58:50.102, Speaker A: Go for it. So you're working hard.
00:58:50.156 - 00:59:01.942, Speaker B: Working hard on it. But it is an exceptionally complex project. No one's really attempted anything of this scale before. At least that's my biased take on it. So we're planning on a main let launch at the end of 2024.
00:59:02.076 - 00:59:02.566, Speaker A: Okay.
00:59:02.668 - 00:59:22.638, Speaker B: We don't want to do the thing where we're, like, overly optimistic with our timelines because this whole industry is very. It's got a bit of. A. Bit of a problem with actually correctly predicting launch dates. But we are hoping to get a local developer testnet out by the end of the quarter. So that'll be something where you can deploy the Astex fee network to your local machine, you can write no contracts, deploy them to the local network, test them, run them.
00:59:22.724 - 00:59:23.914, Speaker A: Wait, you mean this quarter?
00:59:23.962 - 00:59:24.222, Speaker B: Yes.
00:59:24.276 - 00:59:25.250, Speaker A: So like Q two?
00:59:25.320 - 00:59:26.850, Speaker B: Yeah, under Q two. Oh, wow.
00:59:27.000 - 00:59:28.018, Speaker A: 2023.
00:59:28.104 - 00:59:56.230, Speaker B: To be very transparent. This local Testnet will not have provers enabled. The goal is to basically present our planned manner of interacting with the chain, how you write contracts, how you deploy them, basically presenting users with developers with the developer experience and getting feedback from them about how it works. And then at a later point, when we're launching our testnet, we will integrate our privateech into it because we're developing everything kind of in parallel.
00:59:56.310 - 01:00:05.294, Speaker A: Wow. I want to ask about Aztec Connect and CK money because these were other products that we did talk about in the last show.
01:00:05.412 - 01:00:06.030, Speaker B: Yes.
01:00:06.180 - 01:00:09.182, Speaker A: So you, what do we call. Disbanded them? No.
01:00:09.316 - 01:00:09.882, Speaker B: Sunset.
01:00:09.946 - 01:00:10.638, Speaker A: You've sunseted them?
01:00:10.644 - 01:00:32.642, Speaker B: We've sunseted them, yes. One way we consider it is basically a bit of a trial run for Aztec three. As in, at the time, our tech wasn't advanced enough to get general purpose programmability in. But we did have the tech to produce a ZkZk roll up. So Aztec Connect goals was really to demonstrate a privacy is useful on chain. It's not just a mixer. You could do cool things with it, like Defi.
01:00:32.642 - 01:00:38.490, Speaker B: And that is valuable. And a. It's possible you can deploy Zkzk rollups to production. These are things you can build nowadays.
01:00:39.390 - 01:00:49.130, Speaker A: Was it almost like a custom application on this very kind of. Not fully fleshed out, but just the proof of concept? The MVP, I guess.
01:00:49.200 - 01:01:31.622, Speaker B: Exactly, yes. The idea is that instead of the users programming circuits, we as a first party company, we programmed a small set of circuits you can interact with on the Aztec Connect network. And yeah, basically part of it was also just for us to get experience about building Ziki. Zeke robs deploying them into production, actually shipping something and dog feeding our tech and making sure that we have the experience required to make it work. We would not be able to build Aztec three without the experience of deploying aztec connect. Without a shadow of a doubt. However, we've been having internal debates over several months about what to do with Aztec Connect because it was consuming quite a lot of resources, engineering resources from us, because it was our first go at doing Azika Zeka roll up.
01:01:31.622 - 01:02:24.182, Speaker B: And so as the architect, I'm very confident saying that it had some architecture problems, it had some issues that we wouldn't do again, that just design choices that at the time when you're figuring things out for the first time, what we ended up with was a system where you needed an enormous amount of domain knowledge to solve problems that cropped up. And so we ended up in this place where a lot of our most senior engineers were basically working full time, troubleshooting, keeping the network alive, building the improvements in to make it, to improve its stability as it grew. And basically, we reached a point where effectively, as a company, we had two children. We had aztec connect, and we had Aztec three. And at some point, you had to make a choice. You have to make a choice. Sometimes you've got to take your second most favorite child and take them up behind the shed.
01:02:24.246 - 01:02:24.860, Speaker A: No.
01:02:27.070 - 01:02:46.994, Speaker B: I'll stop the imagery there. Okay. No, I don't give parenting advice. But basically, we needed to focus our resources on Aztec three as an organization, we're 50 people, which, for web3, is large. For everything else, it's pretty tiny, and we needed to pull our resources and focus entirely on Aztec three.
01:02:47.032 - 01:02:47.474, Speaker A: Got it.
01:02:47.512 - 01:02:48.498, Speaker B: So that's what we're doing.
01:02:48.584 - 01:03:07.174, Speaker A: Cool. So it sounds like, as we speak, you have sort of set a bit of a timeline. 2024. What are the big building blocks that you still need to reach that? Do you feel like there's any additional research that's needed, or do you feel like, in general, the architecture is there and it's just implementation now?
01:03:07.292 - 01:03:10.502, Speaker B: Yes, I'm fairly confident it is a pure execution problem now.
01:03:10.556 - 01:03:10.774, Speaker A: Okay.
01:03:10.812 - 01:03:38.206, Speaker B: A very big one. But in terms of the tech, Hong Kong Goblin plunk ought to be more than good enough. So, yeah, there's big things we need to execute on, like, we need to build our sequencer software and our prover, like, our third party proverb software, because we want to launch this from day one, decentralized. And there are some unique challenges when you have privacy involved that change the architectures of how to coordinate sequences and provers. Yeah. So it's a lot of complexity. There's lots of network engineering.
01:03:38.206 - 01:03:47.294, Speaker B: There's lots of protocol engineering, lots of circuit building, circuit design. But, yeah, it's a very challenging execution problem, but the technologies is all there.
01:03:47.352 - 01:04:12.306, Speaker A: Wow. You were one of the judges with me, actually, at the ZK Hack Lisbon event that we just did. I feel like we just covered noir and what it's for. Do you think that. And this is. I don't want to put you on the spot here, but do you think that by the next time we do a hackathon circa end of 2023, that people could actually be using Noir to build these sort of hackathon projects?
01:04:12.438 - 01:04:15.422, Speaker B: That is the absolute intention, even though.
01:04:15.476 - 01:04:16.750, Speaker A: Aztec three is not ready?
01:04:16.820 - 01:04:40.054, Speaker B: Yes. The idea is you don't need Aztec three for noir. Noir compiles straight on its own two ZK circuits, proven keys, verification keys. You can deploy verifiers to Ethereum. We have a fantastic team building noir. We've got amazing people like this really is the brainchild of Kev, who as close to an RL anonymous, I think you can get. He doesn't have much of an online.
01:04:40.092 - 01:04:46.214, Speaker A: Presence, but anyway, I have tried to get him on the show multiple times to no success so far.
01:04:46.332 - 01:05:14.126, Speaker B: Yeah, but you'll see him crop up from time to time in photographs when. If people are taking pictures and he's not aware. But yeah, I think anyone in the space knows about who's deep in the space knows about Kev. We've got an amazing team building this. The goal is for it to be something that you can absolutely just quickly write programs to deploy, hack around with. So if we're in a place where in November, where people are not comfortable using a. You can hold me to account to this.
01:05:14.126 - 01:05:20.050, Speaker B: This is a massive failing on my part as the CEO of Aztec. If we can't get nor into a state where it can be used like that.
01:05:20.120 - 01:05:28.430, Speaker A: So by next Zkhack in person, Hackathon, we should be able to build things with hack.
01:05:28.510 - 01:05:46.490, Speaker B: Yeah, you can do it. Mean, there was a couple of hackathon people that did programs with nor. Noir as a product is relatively new, and so we definitely have work to do on the tool chains and all the tooling, but we've got an entire team now focusing on that and should be pretty plug and play fairly soon, given that.
01:05:46.560 - 01:06:03.262, Speaker A: Because Circom has been out there a lot longer and it has. I mean, what's crazy is you've seen things like the Xerox park group just build all these tools around it. Does Noir need to build the same tools, or is there something portable? Like, could you somehow use some of.
01:06:03.316 - 01:06:53.914, Speaker B: So I'm not sure how much of it can be used just because the paradigms are very, very different between noir and circum, because Noir has its own language, its own intermediate representation, where we had some very different design goals for Noir than circum, where for Noir, we wanted to make sure that most important thing for Noir is to present an abstraction layer for developers that's intuitive. So what Circom does is that the code you write to define your constraints in your circuit and the code you write to define the witness assignments to those constraints is different. And that can cause a lot of footguns for new developers. And it's not a very intuitive way of writing programs. What we wanted to do was unify those two, where when you program like a regular language and then the compiler front end is clever enough to figure out both what constraints that turns into and to derive the witness assignments. With that, we have been largely successful. But it does mean that it's a different language.
01:06:53.914 - 01:07:13.862, Speaker B: The tooling is not quite the same. We're also more modular, which means that we can't build like the. Because it compiles to a Cl. You then need to kind of have an integration with the back end, which adds a small amount of integration complexity, but means it's. Well, it's possible to add other backends of the proving system.
01:07:13.916 - 01:07:18.630, Speaker A: Yeah. Without having to hard code them. It's not really hard code, I guess, language, but like, whatever.
01:07:18.700 - 01:07:39.630, Speaker B: Yeah. As in do a PR into the Circom repo. You don't have to do that with noir. And so, yeah, we're very hopeful for the language. We would like to see a lot more backends. We'd love to see every back end, like, every cryptography like module supporting noir, because I think it could be a way of creating relatively agnostic apples to apples benchmarks for all these proving systems.
01:07:39.970 - 01:07:40.910, Speaker A: That would be good.
01:07:40.980 - 01:07:41.600, Speaker B: Yeah.
01:07:42.370 - 01:08:05.974, Speaker A: I think we're almost at time, but I did want to talk to you just about the general ZK space quickly, where we're at. I mean, we're recording this about two weeks after, or not even after this crazy week of events that me and my team put together and you were at. And actually, we're recording here in person at a place where we're going to be seeing more ZK stuff.
01:08:06.012 - 01:08:07.922, Speaker B: Absolutely. ZK week at Zuzali.
01:08:07.986 - 01:08:15.740, Speaker A: Yeah. So tell me a little bit about, like, you and I have been in space for a while. I think you're 2017, like I am.
01:08:16.510 - 01:08:21.130, Speaker B: When it comes to the ZK, we are both. We're old, ancient. We're fossils.
01:08:21.630 - 01:08:22.630, Speaker A: The elders.
01:08:22.710 - 01:08:25.074, Speaker B: We are. I mean, it's such an insane.
01:08:25.142 - 01:08:29.482, Speaker A: It's funny, though, the cryptographers who made this up in the 80s are kind of like, you are not the elders.
01:08:29.546 - 01:08:46.370, Speaker B: Yeah, I know, but the thing is, Anna, we're cut from a different cloth. Those OG cryptographers, they were the academics and the ivory towers. But we do something a little different here. We do cryptography on the street. We don't publish on Eurocrypt. We write hackmd observations.
01:08:47.210 - 01:08:48.162, Speaker A: ZK hustle.
01:08:48.226 - 01:08:48.840, Speaker B: Absolutely.
01:08:50.410 - 01:08:56.114, Speaker A: That's got to be a hackathon project soon. If it isn't already street crypto or. Street crypto or ZK Hustle.
01:08:56.162 - 01:08:56.706, Speaker B: ZK Hustle.
01:08:56.738 - 01:08:58.086, Speaker A: I don't know what that is, but.
01:08:58.188 - 01:09:30.002, Speaker B: Yeah, we'll figure it out. It's going to be something. Okay, I guess to the question you asked about how has the space evolved, I think one of the things that was really positive to see was just the energy in the last Zkhack you organized, because really, for the first time, you had people coming to the space who were complete noobs, like not cryptographers, didn't know much about ZK at all and could actually build stuff, actually build ZK applications with the tools and technology that this community has built. And that is really exciting because we've been trying to do that for years.
01:09:30.056 - 01:09:30.530, Speaker A: I know.
01:09:30.600 - 01:09:46.018, Speaker B: And it's always never been ready. It's always not been quite good enough. You got to understand cryptography, or you got to understand very, very complicated tool chains to do anything. And now things are slowly changing. We're kind of almost there now, and that's really exciting.
01:09:46.194 - 01:10:28.354, Speaker A: I was just thinking that last year you could do things, but you would often. And if you look at the programs that existed, I think Zero X Park was an amazing example of this, where they got things built, but they weren't built in a weekend. It was often like someone would set out to build something and then realize that all of this tooling was missing. And so then would have to build the tooling, and over a few months could kind of create that hackathon project now. And I mean, those also developed into full projects and companies and stuff. But this past this ZK hack was so crazy to see that in 48 hours, people could actually start to do things. And it's still hard.
01:10:28.354 - 01:10:30.306, Speaker A: And I don't think it's like, oh.
01:10:30.328 - 01:10:41.734, Speaker B: It'S still like chewing glass. Yeah, I don't think any of us would say it's easy. And the tooling is nowhere near as good as where something languages and platforms. But it's getting there.
01:10:41.932 - 01:11:09.278, Speaker A: You're also seeing, I mean, even this week it was East Tokyo was just happening. I think it's just wrapping up now. And there's a ton of projects that are using ZK. We've been seeing that at the ETh global events and stuff, like more and more ZK use. And so, yeah, I can't wait to see what this year brings in terms of these projects and just the ideas that can come out of a hackathon. These are the things that could be used by people and potentially have incredible impact. So it's very exciting.
01:11:09.454 - 01:11:10.180, Speaker B: Absolutely.
01:11:11.430 - 01:11:14.834, Speaker A: Cool. Zach, thanks for coming back on.
01:11:14.952 - 01:11:17.346, Speaker B: Thank you. Thank you. It's been a pleasure. It's been a pleasure.
01:11:17.458 - 01:11:36.310, Speaker A: And thanks for doing this recap of sort of the history of Planck and pre Planck and Aztec. I think for folks who hadn't heard those earlier episodes or, like, newer, I think this could be really great to add some context. Most people have heard about plonk. Not everyone knows where it came from, so this is cool.
01:11:36.380 - 01:11:42.206, Speaker B: Yeah. Happy to talk about it. It's been a long ride, and we're not done. Oh know, we barely started. Cool.
01:11:42.308 - 01:11:43.402, Speaker A: All right. Thanks, Zach.
01:11:43.466 - 01:11:44.250, Speaker B: Cool. Cheers.
01:11:44.330 - 01:11:50.650, Speaker A: I want to say thank you to the podcast team, Tanya, Henrik, and Rachel, and to our listeners. Thanks for listening.
