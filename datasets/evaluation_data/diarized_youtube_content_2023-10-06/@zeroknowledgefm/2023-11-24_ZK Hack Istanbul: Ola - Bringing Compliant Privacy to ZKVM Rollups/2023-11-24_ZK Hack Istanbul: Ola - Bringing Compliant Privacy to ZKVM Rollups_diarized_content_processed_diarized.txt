00:00:08.730 - 00:00:54.960, Speaker A: So hi everyone. My name is Philip, and I am the COO of Ola. If you haven't heard about us before, now you have. We're a very small team and we've kind of been under the radar, but essentially we're looking to build a Ckvm that bridges the gap between private and public DApps. I actually have a few slides in this presentation that we won't be looking at, so we might skip a few here because we only have 30 minutes, but we're going to walk you through the entire architecture of Ola and at the end I'll give a quick demo. We're not going to deep dive too much because running the Ola infrastructure is actually part of one of our bounties. So I don't want to give it all away before we even get going.
00:00:54.960 - 00:01:51.546, Speaker A: So yeah, skipping a few slides here. We have been looking to solve some of the issues in Web Three. This is a CK event, but I think a lot of the teams have its origin coming from the Web Three world looking to scale public blockchains and looking to bring privacy to public blockchains. And these problems here on the screen is essentially what we're looking to do. We want to empower the users currently on chain, everything is transparent and anybody, even though you're pseudo anonymous, can get a hold of your data at the same time. When dealing with privacy enabling schemes, we don't want this to completely pivot away and not work with current regulators and government bodies. So we want to be able to provide a compliant tech stack which doesn't compromise end user privacy.
00:01:51.546 - 00:02:43.882, Speaker A: This has also been one of the core goals we've had at Ola to give a platform to the sovereign individual but still be able to work with current governments. So when doing this and when looking specifically into the Web Three stack, if you work with Ethereum, you know that an example given keshuck is used quite frequently as a hash algorithm. You also have the secure hash algorithm family, and these are just two examples. Now, they aren't very CK friendly, so we're using alternatives in Poseidon Two and in Blake Three hashes, et cetera, just to make everything efficient. Now this is also at the core of what we're doing. So in the design choices we are making with our virtual machine, we are opting for efficiency. If a system is ever to be used in production, then it needs to be fast and efficient.
00:02:43.882 - 00:03:13.318, Speaker A: We do have some benchmarks on this as well and some of the stuff we're doing. We also have some other tips and tricks up our sleeves in terms of getting more efficient. CK proof generation. If you've ever worked with Starquare and their ecosystem, you might be familiar with the concept of hints. It's basically just about taking some computation out of the trace and then you can with fewer opcodes, you can verify that in the trace of the VM. So different tips and tricks here. Yes, to make it more convenient and more fast and efficient.
00:03:13.318 - 00:03:42.686, Speaker A: I do have an example of this as well. I'm not going to deep dive into it, but we're going to look at some numbers on it. Aside of that, our VM is based on risk, very similar to the risk Certimus. Here we run what's known as algebraic risk taking inspiration from the startware team. So there are some slight differences in how this works. We're also utilizing concepts such as the built ins. This is example given, how you would call a pre compiled contract in Ethereum.
00:03:42.686 - 00:04:06.140, Speaker A: Keshek would be an example given. I think they have about ten of them in Ethereum. So we're reusing that concept to also have further efficiency. One big change in Ola. I'm not sure if this is visible, I hope it is, but it's basically that in Ola we don't support EOAS. So externally owned accounts. This is what's used in Ethereum today.
00:04:06.140 - 00:04:35.380, Speaker A: Instead, and forgive me if this is wrong now, but I think it is ERC four, three, seven, which looks to do account abstraction for Ethereum. And we have that in Ola as well. That's the only type of account we support. This is a much better design and it gives freedom to the end user. You can pay your gas in different tokens. There are more benefits than that. But this is the only account we have in Ola and it's the base hype, so that's the difference.
00:04:35.380 - 00:05:11.902, Speaker A: This is also very small, I hope you can see. But basically this is how the privacy scheme and the entire architecture works in Ola. So as you can see on the screen here, to the left in red, we have representing the client side. So that would be your end user device, your laptop or whatever that may be. And then we have the node side here, which is the blue side. And this would be actors participating in the Ola network and helping out to do proof generation. And these nodes could then supply a proof to any layer one or L2 for that matter.
00:05:11.902 - 00:05:54.294, Speaker A: It should be noted that Ola and the VM itself, it's to put it shortly, an encrypted execution environment. If we wanted to, we could deploy Ola on top of Cksync as a layer three, we could deploy it on Celestia, we could deploy it on Ethereum. So you have some kind of layer where you want to send your proofs and they can be verified. So to the red here. How this works is basically under the hood. We have UTXOs, but we also have the traditional account based model of Ethereum. But if you're dealing with a private DAP, how it works is that on the client side you would generate a proof relating to the private part.
00:05:54.294 - 00:06:26.642, Speaker A: So you maybe have some UTXO. Alice wants to send Bob some money, let's say $100. Then that UTXO would need to be consumed. That end user device would at the same time also be creating a subproof relating to the private parts. So we are not giving that data to the blue side here, the node operator. So you sign that message and you send your signature with it. The node can then verify that this has been done correctly and continue with the rest of the public functions.
00:06:26.642 - 00:07:06.370, Speaker A: So basically what the client side would do in this scenario is you would calculate a proof relating to your private transactions and together with the rest of the public functions, you would send that through. Then, as you can see on the blue side here, it's very small, but over here we have some proof generation and a lot of this is happening in parallel. So it's kind of a divide and conquer approach where we can divide the proofs into smaller chunks. We can prove them in parallel, separately, and then using recursion, we can prove them all the way back up to the top. The proving stack, by the way, is start based proving stack. We run plonky two. We have made some additions to it so it's not really the exact Plonky Two.
00:07:06.370 - 00:07:39.200, Speaker A: And then Starkey. For block generation, we use Plonky Two. For recursion. We have also looked into it's very small here, but it says aggregation and folding at the end. We looked into some of the schemes with IVC incrementally verifiable computation, with the different flavors of Nova and so on. And then we also looked into using a snark to make it more succinct with the byte size that's sent up to the layer one or L2 or whatever layer that is. So we did look into using F flung for that as well, which is applicable, but it's not in the current design.
00:07:39.200 - 00:08:15.400, Speaker A: Another view here of the public and private logic. So I think we covered most of this, but as you can see, I'll just repeat it real quick. User side if you're dealing with anything in private, it's red here. Again, this is basically the example I gave you before. So user side the local VM would execute that. And as you can see here in the transaction, it actually says that the proof here that's set in black is sent together with the encrypted commitments. The commitments is the UTXO objects and the remaining public data to be executed.
00:08:15.400 - 00:08:55.966, Speaker A: So that's how we deal with keeping and maintaining that end user privacy. So they have that partial CKP and then the node side would take care of getting the full CKP that's sent through. I think Thor in the intro speech mentioned that Olang or Ola lang, the ola language that we use for developing contracts on top of ola has taken inspiration from Solidity and that's basically what we're looking at here. So we have the function types very similar to Solidity, if you ever use that. Otherwise I'd say that Ola is almost a rust fork. So if you're familiar with rust and solidity. You are good to get going.
00:08:55.966 - 00:09:50.350, Speaker A: It's very simple to get going. I'll show you an example of this as well for a short demo. So, to the bread and butter of our solution, this is just a comparative slide. On the example here I have Aztec and maiden. So, a big difference between our teams here is we are going down a route where we're looking to maintain and protect the end user, but we still want to be able to trace encrypted data in the network, because we think that this brings a lot of value when working with regulators. And if bad actors would ever hop onto your system, So, as you can see here by the slide with the example of Mitre and us, we both have a sparse tiered merkel tree as the public tree. But then the difference is on the private side of things.
00:09:50.350 - 00:10:23.914, Speaker A: So instead of managing two different trees here, and why you would want to do that is because you want to decouple the spending of UTXOs. Because if you have that coupling between them, then you can derive who spent what. Now this is a little bit more overhead in terms of the computation that needs to be done. If you manage one more tree, obviously that will be more resource intensive. So we just have one tree that's updatable. And why we have that we'll be looking at in the following slide here. This is again very small.
00:10:23.914 - 00:10:50.770, Speaker A: So I'm sorry if you can't see anything. But in the system, as you saw in the previous slide, we have two trees. We have one public merkle tree and we have one private. Now, to the far left here, it says the root of the public tree. So that's the public tree. And then just going to the right here, we have the private trees. So, once again, if we would have Alice and Bob hop onto the system and Alice would be the one furthest left and she wants to send $100 to Bob.
00:10:50.770 - 00:11:35.614, Speaker A: And with UTXOs, as some of you may be familiar, if you don't send the exact amount that's in the UTXO itself, there will be change. But for the simplicity of this scenario, we always send $100. So if Alice then wants to send Bob $100, what would be seen in the first transaction here is that Alice has been deducted $100 from her public account and a UTXO has been created and that's been sent somewhere. But we have no clue of where that went. But we know that Alice, who came into the Ola ecosystem, was the one to send this UTXO of $100 somewhere. And that would then be represented by the darker green blob here where it says CM Zero. CM, by the way, stands for commitment.
00:11:35.614 - 00:12:14.250, Speaker A: And that's just the encrypted data in the Ola system. So imagine then that Bob wants to send this to Charlie. And Charlie here is commitment number two in this transaction we can't see anything. But what we can see is that commitment Zero has been consumed. So it's not a member of the Merkel tree anymore and commitment two has been created. But looking from the end user perspective, the end user data is completely protected. Now would Charlie here then wish to exit the system? Now it says nothing here because the image just continues in the private tree.
00:12:14.250 - 00:13:09.470, Speaker A: But should he want to exit the Olake ecosystem and move his funds elsewhere, he'd have to go back to the public tree. And in such a transaction the only thing that you would see is that maybe that's me. Philip, I have received money but we don't know from whom I've received this and the entire UTXO back chain is still hidden. And why this is important is imagine illicit activity or fraudulent illegal activity happens on the chain. There is mechanisms that could be implemented here. But comparing this to other systems which is fully private we can provide the option to work with regulators and government bodies and show them well if know it turns out that Alice wasn't Alice, that was North Korea or somebody that governments don't want working there because they're washing money. Well then we can showcase well this is actually where the money went and this is when it exited.
00:13:09.470 - 00:14:03.442, Speaker A: Otherwise it would be a complete black box as we've seen with example given tornado cash and the sanctions that went against that. So we're looking to build this scheme where end user privacy is at the core, but we can still provide means to be compliant and work with regulators. So there are other ways to share your data in such a system. So when everything's private you don't see anything in the system if you just see encrypted data. Well what if you want to do your taxes? Or what if third party teams like Chain Analysis who base their entire business model around scavenging data on chain no longer can do that? We have a key system for this. This is very similar to most of the teams working in the space of privacy. But basically we'd be looking at a key here called the viewing key.
00:14:03.442 - 00:15:03.542, Speaker A: So you have the functionality and option as an end user to decide whom you'd like to share your data with. So if I want to showcase all my transactions, I will just share my full viewing key and I can even set dates for this and I can revoke that so I can give access where access is needed to share data with a third party, essentially. So there's many ways here in this fully private scheme to share your data with outsiders. And we mentioned some of the principles of Olalang. It's a rust like language with solidity inspiration. One thing that I think is important for developers to know, and this was covered in the intersection by Thor is that we are not a DSL, we are looking to abstract away all the complexities that come with building CK circuits. So the level of abstraction in Nola is very high.
00:15:03.542 - 00:15:36.754, Speaker A: You don't need to have that niche CK knowledge to start building. We take care of that. So to compare to other teams, some of them, you need to work with field elements in the language. We abstract that away. The Ola VM itself, it's turing complete well, with the limitation of Gas, of course. So instead of being limited by computational resources to whatever program you're running, you may be limited by Gas because that's how you counter DDoS attacks on decentralized systems. And we can run any code.
00:15:36.754 - 00:16:18.490, Speaker A: It doesn't need to be deterministic. Some of these DSLs, because of the step, when the actual circuit is generated, then everything by that point, well, the circuit is generated and it turns into bytecode and deploys. Then everything needs to be deterministic. And that's not the case in Ola because we put constraints on the VM itself. So you could run any program as it is true and complete with the exception of Gas, of course. And a quick example here of the profit module that I spoke about briefly before, and this is the concept of hints from Starquare. I will not deep dive into this, but we have a quick example here with the calculation of a square root.
00:16:18.490 - 00:16:56.998, Speaker A: Now to the left here you have the native implementation. You have these 17 lines of code. And to the right here we have the profit. And we're not actually seeing the Profit code itself. We're seeing in the first five lines of code that the Profit implementation is being called. And then you can see on line ten and on line 13 we just assert that we are getting the result we expected. So that means if we're looking at the actual trace for the CTP generation part, we've now done this with two opcodes instead of all the opcodes required.
00:16:56.998 - 00:17:44.666, Speaker A: To the left here with doing this natively. And we have run some benchmarks on this as well. So we ran the calculation of a square root a thousand times and you can see that the execution time vastly is lowered and the same thing goes for the proving time. So utilizing means like this and having this for more things that are CK unfriendly can speed up the throughput. In such a system, code and documentation, everything we do is open source. You can scan this QR code and I believe that contains all our socials and maybe also a live telegram group we have for the hacking happening here in Istanbul. So I'll leave this on for a few more seconds, then I don't have a timer, so I'm not sure.
00:17:44.666 - 00:18:09.906, Speaker A: How are we doing on time? 10 minutes. Okay. And then we have a roadmap. Actually, this is an outdated roadmap slide. I can maybe pull up another roadmap and I can showcase that or actually we'll skip that. We're going to talk later as well. So I'll show the roadmap then, but that's it for the presentation here.
00:18:09.906 - 00:18:56.176, Speaker A: I will quickly also show you guys an example. Let's see if this one works as well. It does. So here we have a basic example of a Fibonacci program. What I'm going to do is I'm basically just going to show you how to get started in the Ola ecosystem and we have docs on this that I will pull up and show you guys. Now I won't be generating a proof actually for our bounties that we have for this event. It's basically doing what I'll be doing but with a different contract.
00:18:56.176 - 00:19:30.296, Speaker A: So I don't want to give it all away. So what we've got up here is just Visual Studio code. We have actually the contract here doesn't matter but we have the Fibonacci contract up here and then I have my terminal here to the left. So what I'll be doing here is writing Cargo clean. If you're familiar with Rust, you know what cargo is as a tool. So I'm just cleaning the environment and then we'll go ahead and build. So we're just compiling now and I have by the way downloaded a lot of prerequisites such as Ola C, the Ola compiler.
00:19:30.296 - 00:20:16.316, Speaker A: We have Rust installed and if you're an M One Mac user like me, actually Rust has some bugs on their end with the latest nightly builds. I will just highlight that, that it's a current bug on the Rust issue section on their GitHub. So if you're using an M One Mac and Rust then you need to lower your nightly to 1.72 or 1.75 being the latest. But we can talk more about that offline if anybody should bump into any issues. So what we've done now is basically we have just compiled the program and I think I need to change some directories here because as you can see here to the right, our contract file is actually not in the directory that I'm standing in right now.
00:20:16.316 - 00:21:16.588, Speaker A: So it's in the examples directory. So we'll just go ahead and swap over to the source code directory of that. And what we can do then is we can just write, let's see, compile and we will compile this Fibonacci sequence. So when you get this output you know that you've successfully compiled the program. The next steps, which I will not be showing you guys, but what you would be doing now is that now that we have everything compiled is we need to interact with the program, right? And there's many ways of doing this but for the example here today and what we're doing for the bounty is that you're going to be using a shell script to call the actual functions on the deployed program and generate the proof for this set program. So I think we have a few minutes left but I'm going to end it there. What we've gone through is the overall architecture.
00:21:16.588 - 00:21:46.730, Speaker A: We've seen some simple examples, so if there's any questions, I'm happy to answer them now, and if not, I'll be outside as well and happy to help out with any problems you guys face. We're super excited to, as a small team of roughly ten people, to be able to pull something off and something that you guys can actually use. So we're super looking forward to you guys just trying this out and trying to build on top of our stack and submit any bugs you may find. Thank you.
00:21:47.420 - 00:22:02.816, Speaker B: Round of applause. Thanks, Philip. Yeah. As we said in the intro, getting feedback is also why we're here. That's part of the game. Are there any questions for Philip? We have like five more minutes. No.
00:22:02.816 - 00:22:12.240, Speaker B: Yeah, one here. Would you like to give some hint for the bonte or hackson?
00:22:13.140 - 00:22:14.816, Speaker A: Sorry, could you repeat that?
00:22:14.998 - 00:22:18.520, Speaker B: Would you like to give some hint about the hackson?
00:22:18.700 - 00:23:00.944, Speaker A: Yeah, for the bounties and the hacks, actually. So there's two parts and we will be covering this, I think in like an hour from now or like an hour and a half where we represent or sorry, where we're going to present all the bounties, but basically it's on our GitHub already and that's open source. Everything is open source. What we do, if you're sneaking into the GitHub, you'll find everything you need to get started and actually a few people have already. But the hack, which is already open source, is about running the Ola Tech stack, which we're looking to get feedback from. So, I mean, if you find anything that sucks, let us know or anything that's good or we can improve. And it's basically about running another smart contract and interacting with it.
00:23:00.944 - 00:23:15.940, Speaker A: And in the end, if you do it correctly, you'll get a prompt and then you can come and show our team that you've done the challenge. And then we have a second challenge, which is about basically coming up with ideas and looking well, building anything pretty much in the ecosystem.
00:23:17.080 - 00:23:28.170, Speaker B: Yeah, you're getting the sneak peek into the presentation that would be at 630 with basically all the bounties that we have at Gkhec this year. Any other questions? Yeah.
00:23:33.710 - 00:23:47.550, Speaker C: I can see that Ola has taken advantage of Rust performance efficiency, so this example is pretty simple, but do the developer need to pay attention to memory management in Rust while doing Rust?
00:23:48.930 - 00:24:14.550, Speaker A: So I think as a best practice, yes, I would always advise for that. So developers can always make improvements right, to how they write their code. And I think this has been seen in Solidity as well, right? Where if you write something straight in Solidity, historically doing that, parts of the contract and assembly could be more efficient. And I think that's like a general rule that applies to a lot of things, right? To think about these things.
00:24:14.700 - 00:24:20.630, Speaker C: Also, for the Fibonacci example, is there a way to test directly or just it's like testing normal with rust.
00:24:21.690 - 00:24:30.970, Speaker A: So I would love to give an honest answer here and say that I have not been involved in these specific parts. We can loop them offline, if that's okay.
00:24:31.040 - 00:24:32.890, Speaker C: Yes, thank you.
00:24:33.040 - 00:24:59.570, Speaker B: Yes. And also I think it's a good time to mention that tomorrow at 10:00 A.m., we will have a Q and A session with Ola, your team, here on the main stage. So, yeah, if you have any question that pops up until then, you're also welcome to ask them tomorrow morning at ten. We have time, maybe for one last question, if there is any. Okay. Well, thanks again, Philip.
00:25:00.150 - 00:25:01.440, Speaker A: Thank you so much for having us.
