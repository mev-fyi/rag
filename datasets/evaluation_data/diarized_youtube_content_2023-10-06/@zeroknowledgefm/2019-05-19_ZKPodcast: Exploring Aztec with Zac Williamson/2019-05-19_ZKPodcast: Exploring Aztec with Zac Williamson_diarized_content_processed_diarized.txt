00:00:06.330 - 00:00:18.750, Speaker A: Welcome to Zero Knowledge, a podcast where we explore the latest in blockchain technology and the decentralized web. The show is hosted by me, Anna and me Frederick.
00:00:24.610 - 00:00:34.870, Speaker B: In this episode, we sit down with Zach Williamson to talk about zero knowledge tools, range, proofs, the aztec protocol, and the development of zero knowledge standards.
00:00:43.630 - 00:01:18.658, Speaker A: Before we start, we want to say thank you to this week's sponsor, Noifund. Noifund is building an ERC 20 compatible open source technical environment which enables the tokenization of real world assets, assets like equity in a company or real estate. Noifund does this by implementing different basic protocols that bind off chain assets with their on chain representations. They are currently looking for a QA lead to help them test their dapps, backend, and smart contracts. If you're interested, check out the job offer@noifund.org. Slash careers or review Noifund's GitHub@GitHub.com Slash Noifund.
00:01:18.658 - 00:01:41.030, Speaker A: All links will be in the show notes. So thank you again, Noifend. And now here's our interview with Zach from aztec. So this week, we're sitting down with Zach from aztec protocol, and we're going to be talking a little bit about what they're working on and a lot of ZK stuff. So welcome to the show, Zach.
00:01:41.190 - 00:01:43.582, Speaker C: Hi there. Thanks for inviting me. It's great to be here.
00:01:43.716 - 00:01:45.306, Speaker A: And as always, we have Frederick.
00:01:45.418 - 00:01:46.174, Speaker B: Hello.
00:01:46.372 - 00:02:09.958, Speaker A: We always start with a quick intro from our guests, but I saw this comment on Twitter that sort of said, why does everybody always start with just like, please introduce yourself, blah, blah, blah? And I felt that. And so, actually, this time, I want to try something. Please do introduce yourself, but also maybe just give us a little bit of insight into what inspired you to get into this.
00:02:10.044 - 00:02:44.762, Speaker C: Okay, sure thing. So, hi, everyone. I'm Zach. And I am the CTO of Aztec, the asset critical. And we are a privacy provider for Ethereum, where we allow our tools and technology can be used to create private representations of existing public digital tokens. As for what really inspired me to get into this laziness, to be honest, pure indolent laziness, to tell the honest truth. Originally I was working on building a syndicated loan platform for Ethereum using smart contracts to create financial instruments.
00:02:44.762 - 00:03:59.382, Speaker C: And we needed privacy for product to work, and we weren't going to get it because there wasn't an existing privacy solution for theorem or other kind of Turing complete public blockchains. And when I realized this, I started digging around into zcash ZK snarks and how to looking at the kind of work that would be required to bring ZK snarks to Ethereum, because at the time, things like Socrates were just very in the very early stages, I have to be honest, when I first started digging into the questions for the tech and started reading the papers, I thought, my God, there must be a simpler way of doing this, because, effectively, what we were trying to do was prove extremely simple statements and zero knowledge, things like the sum of the inputs equal to some of the outputs, like, I know a secret, and this secret is. Plus another secret is equal to, like, ten really simple statements. And so the general purpose solution provided by ziggy snarks felt like cracking it up with a sledgehammer. And so I started digging into the tech behind this, looking at the homomorphic arithmetic and range proofs and all that jazz, and realized that there was probably kind of a somewhat simpler solution specifically for this problem we were trying to solve.
00:03:59.446 - 00:04:20.734, Speaker B: So you started at almost like a higher level of trying to solve general financial instruments application stuff and then dug into the privacy parts. Have you gone back up to the financial instruments now, or are you still at the privacy. Where are you and where do you want to be?
00:04:20.852 - 00:04:49.458, Speaker C: Of course, when I started putting together digital was proving tech that we needed for our silicone platform. Really, the overriding thought was, wow, this stuff is really cool, and that this is a lot more valuable than just what we wanted to use it for. So, as a startup, we have pivoted to basically providing a privacy solution that will enable other developers, other companies, institutions to basically build. What we were trying to build at the time was called credit mint.
00:04:49.634 - 00:04:51.154, Speaker A: What was it called? Credit mint.
00:04:51.202 - 00:04:51.842, Speaker C: Credit mint.
00:04:51.906 - 00:04:52.854, Speaker A: Credit mint. Okay.
00:04:52.892 - 00:05:13.306, Speaker C: But, yeah, we'd done a little bit of a pivot to propagate our privacy solution, but we have kind of climbed back up the stack. And so we've been putting together tooling zoologists like proof construction and smart contraction verification engines that focus very specifically around private transaction settlement and trades of different private assets between counterparties.
00:05:13.418 - 00:05:20.850, Speaker A: Okay, so let's find out what aztec protocol really is. So this is the project that you've been working on for how long?
00:05:20.920 - 00:05:26.886, Speaker C: I've been working on kind of privacy tech since the start of 2018, so it's been well over a year now.
00:05:27.068 - 00:05:28.550, Speaker A: And when did Aztec start?
00:05:28.620 - 00:05:49.866, Speaker C: Aztec really got off the ground in November last year. That's when we published our proof of concept of the aztec protocol and created a private version of the dice tablecoin on Ethereum mainnet and traded it around and actually launched a second announcement. Hey, this is now a thing that can happen.
00:05:49.968 - 00:06:00.506, Speaker A: When I was looking at Aztec, the question that first came up for me was, how does this differ? Like, how is the Aztec using ZK for privacy different from something like Socrates?
00:06:00.618 - 00:07:45.686, Speaker C: So, at the most fundamental level, Aztec, the essay critical is not based on AZK Snop. It uses a different kind of xernal proof that does utilize bilinear pairings, like a snop, but fundamentally, it's constructed in a very different way. And what this enables is, effectively, it's a lot closer to a bulletproof type system than a snark type system, in that you have a way of proving that a commitment is bounded within a range. And then you can use traditional homomorphic arithmetic, focusing around things like Sigma protocols, to create algebraic statements involving these proofs, where the kind of the algebra you're validating is directly expressed in the exponent of an elliptic curve. Instead of reducing a program or series of statements into a polynomial equation and then proving that, you know, a satisfying assignment to that polynomial, it is a simpler form of tech. So, do you mind if I take a step back, actually, to really answer that question? Because I approached this maybe from the opposite ends of things, which was what I want this thing to do, and what's the most efficient way of getting there? And what we wanted to do was create a private token standard, a method of representing value confidentially, where users had agency over the specific semantics of these confidential transactions. So that if you're building a private asset that has, for example, edge cases like, say, baby, you're building a decentralized exchange, you have a minimum trade threshold, so you can't have frivolous bids, or you're building a private security token, and you need to prove that every trader has less than 10% of the total supply.
00:07:45.686 - 00:08:57.670, Speaker C: Regulatory reasons, you need that flexibility, but it cannot come at the cost of compatibility and interoperability, because, for example, with a traditional ZK snark, at least before sonic came along, if you were coding up the semantics of a private transaction inside a zksnark for a set of private assets, none of them would really be able to communicate with one another, because none of them could trust that each other's setups were performed correctly. And this would be a nightmare of buildings, for example, a zero knowledge DAP, which interfaces with these tokens. And so we needed all of our private asset, all private assets using our protocol to use the same common reference string. It's basically requiring they don't have to perform trust, a subbit, so that we could create a standard that everyone could conform to. But that standard still needed flexibility for these edge cases. And so with aztec, what we do is we use bellinear pairings and our kind of aztec commitment function, which I can go into to perform an extremely efficient range proof. And then what we can do on top of that is create modular sigma protocols, basically specific discrete zero knowledge proofs that perform discrete bits of business logic.
00:08:57.670 - 00:09:25.570, Speaker C: Like for example, like a dividend proof to prove that one value is a percentage of another, or a join split proof. So you have some input notes and some output notes, and you prove that the encrypted values of the sum, like the sum of the inputs, equals the sum of the outputs. And what a user or developer or builder can do is when they're building a private asset, they can effectively take these off the shelf proofs and kind of fit them together in a modular fashion to create a more expressive statement. Validated and zero knowledge.
00:09:27.030 - 00:09:30.978, Speaker A: Are you building libraries or are you building, what are they?
00:09:31.064 - 00:10:25.060, Speaker C: A very good question. So, at the smart contract level, we're building this thing called the cryptography engine, which validates the family of asset proofs. So at the moment we have five, but we'll have a lot more over time. And we're building some libraries, yes, that people can install their client side at the moment, but we're building out server side solutions as well that construct the required proof. So the end goal for all of this is that if you're putting together a private, some private asset or some service, you can use a libraries to go, hey, I want to make me a joint split proof or make me a dividend proof, or there's a minimum trade threshold. So I want a range proof in the same way that you can very easily and efficiently make easy day SA signatures using a library without having to know the actual mechanics of how an easyd SA signature works. We want our stuff to be intuitive to the point where you don't need to be literate in zero knowledge cryptography to use it.
00:10:25.060 - 00:10:29.320, Speaker C: So we're building out our standard library to enable that.
00:10:29.850 - 00:10:45.386, Speaker B: I wanted to dig into more of the range proofs and what these proofs actually are. So you mentioned these are range proofs. It's sort of similar to bulletproofs, but as far as I know, I think bulletproofs are range proofs as well, right?
00:10:45.568 - 00:10:54.842, Speaker C: Yes, you can use bulletproofs for arbitrary computation, but their main application is range proofs.
00:10:54.906 - 00:11:12.978, Speaker B: So my question is, what are range proofs mathematically? And then I'm also curious, do you consider what you're doing to be research, are you inventing new methodologies or is it engineering? Like, are you taking known mathematical constructs and creating code around them?
00:11:13.064 - 00:12:11.106, Speaker C: Really, it's both. It's this nexus of cryptography research and software engineering, using cryptography to solve the problems that software engineering throws up. When it comes to the range proof, it is new research. It wasn't something that I took off the shelf because there wasn't really anything off the shelf I could take for the solution because we needed something that was much more succinct than existed, that didn't involve using a ZK snark at the time. I really, really wanted something that used the same common reference string for multiple proofs and snarks couldn't do that. The way it started was I started tinkering around with, looking at, digesting cryptography papers, kind of stalking the halls of Google scholar and shaking down crypto papers for loose bits of tech and ip that I could use. And in March, I came up with what I thought was a very efficient and succinct range proof.
00:12:11.106 - 00:12:49.090, Speaker C: And I got put in touch with Jens Groff, who at the time was at UCL. And I went to him and I was like, hey, Jens, I've got this great range proof and it's succinct and efficient and what do you think? And he was like, no, it doesn't work, it's got a problem. And yeah, looking back at it, I had an amateurish security flaw. I went back, beaved away at it and then came back again. I'm like, okay, second time, what about this? And he was like, no. So that was fun. Basically, at that point, Jens agreed to join us as an advisor for our company.
00:12:49.090 - 00:13:44.222, Speaker C: And I came up with him for a third time after iterating the paper. And I'm like, okay, what about this version? And he was like, okay, maybe, but you need a bit of soundless proof. And then that was kind of a very iterative process where I worked with the ends to really refine the asset paper and bring it up to the kind of standards required to formally prove its completeness and soundness and kind of on its verifier zero knowledge properties. And so, yes, basically this is new research. It takes stuff that did exist in some form, like it's a special case of a polynomial commitment scheme. This stuff has existed for a while. We combine range groups with a commitment scheme, which hasn't, to my knowledge, really deem done before in this way, where effectively we create what's like something which is quite similar to a pedison commitment.
00:13:44.222 - 00:14:11.894, Speaker C: But the difference is with an aztec commitment, if you want to prove that, you know, an opening to an astec commitment, so you want to create a general proof saying, here is an aztec nose. I know what it's worth, but I'm not going to tell you what it's worth. That proof is basically the same as proving, you know, an opening to a pellet and commitments with a very, very tiny modification, which means that by being able to present that kind of proof, it is implicit that you know, that the integer that's in the note is constrained within a range.
00:14:12.022 - 00:14:17.566, Speaker A: Well, I wonder, have we explained exactly what an efficient range proof is?
00:14:17.668 - 00:15:31.414, Speaker C: Okay, so what about range proofs? Why are range proofs a thing? Why are they needed? What the hell is a range proof? When it comes to private transactions and being able to prove that the validity of a private transfer? Range troops are extraordinarily important to prevent double spending. So what they do is they enable somebody to present an encrypted number to a verifier and prove that whatever that number is, it's within a given defined range. The very basic example would be like, for example, imagine you need to prove your age. Imagine you need to prove you're over 18, but you don't want to reveal to the verifier precisely how old you are, that kind of stuff. The reason why it's really important for private transactions is because private transaction systems, confidential transaction systems, use something called homomorphic arithmetic, which I imagine has come up a lot on your podcast, being able to evaluate mathematical statements over encrypted variables as if they weren't encrypted. You can use elliptical cryptography to do this. But one of the problems with this is that the arithmetic that you're evaluating, it's not over normal numbers, it's over integers that are modulo a large prime number.
00:15:31.414 - 00:16:15.054, Speaker C: So in this weird realm of homomorphic arithmetic, minus one isn't actually minus one. Minus one is basically, it's actually an extremely large positive number. So if the homophobic arithmetic was all modulus seven, then minus one would be six. And this is a huge problem because it means it makes double spending if you don't account for it very, very easy. Because for example, imagine I want to prove that if I have a transaction where I'm sending you some values, imagine I'm sending you some private die, I have ten private die, and I'll send you five. Normally I would create a note worth five and give you a net worth five. And then my outputs equal my inputs.
00:16:15.054 - 00:16:36.714, Speaker C: But now imagine my inputs are worth zero, and I give you a die note worth one, and I retain a die note worth minus one. Obviously, minus one. Plus one is zero. But in the world of homo arithmetic, what I've done is I've actually just created a note that has an extremely large positive number. I've basically created more value than exists in the observable universe, which is a huge problem for a crypto system. And range proof. Solve this.
00:16:36.714 - 00:16:56.420, Speaker C: It deals with a fundamental problem that you cannot tell the difference between a positive and a negative number in a homo crypto system, like on the ones created over elliptic curves. And so range proofs are used to completely remove the possibility of negative numbers creeping into your crypto system.
00:16:57.990 - 00:17:10.946, Speaker A: So there's like a family of range proofs, I guess. And you mentioned one, bulletproofs. Are there other sort of projects or concepts that we might have heard of that are also considered range proofs?
00:17:11.138 - 00:17:44.654, Speaker C: So there are a lot out there, and I wouldn't be able to give a full account of all of them because my own knowledge isn't complete. So, Zcashnax, most of them contain range proofs within them at some level. So, for example, zcashes joins flip transactions. They also require, if you want to issue one of these Ek snark proofs inside the snark circuit, you're implicitly providing a range proof. There's bulletproofs. There's also. I don't know, I'm not sure why it's called this, but in the literature it's called the folklore bit commitment scheme.
00:17:44.654 - 00:17:56.354, Speaker C: Sounds like it's because nobody can find a reference to the original bits commitment scheme because it's so old, weaved into the oral tradition and history of azerological cryptography.
00:17:56.482 - 00:17:57.160, Speaker A: Wow.
00:17:59.610 - 00:18:08.934, Speaker C: I feel like I should get a Luton accordion and start strumming some folk attune when I'm talking about the folklore commitment scheme, but basically it's a way.
00:18:09.052 - 00:18:12.342, Speaker A: Wouldn'T be out of character for the ZK community. Wizard hats.
00:18:12.406 - 00:18:14.550, Speaker C: I know. Loots.
00:18:14.630 - 00:18:15.930, Speaker A: I'm sure it's all good.
00:18:16.080 - 00:18:57.990, Speaker C: It's a strange crowd, isn't? It's a great crowd. In the focal bit, kibiski, basically, you provide encrypted representation of every single bit in your number, and you prove that each encrypted bit is either zero or one, and then you can combine them all together to create your actual number. That's traditionally how it's done. It's not very efficient, and the proofs require are huge because if you want to prove a 32 bit number, you need 32 individual dispute symbols, proofs with all of their inputs. And you can get proofs that there's dozens of kilobytes large. And the verify computation is extremely intensive. Bulletproofs compute on this massively, massively, massively, massively.
00:18:57.990 - 00:19:24.590, Speaker C: And it's an absolutely amazing system where you can use. It basically takes a traditional focal bitcoin scheme and compresses it down. So the size of the proof is logarithmic with the number of bits in your number. And it does this through a kind of proof recursion. So instead of proving that, you know, an opening to each and every single bit, you prove that, you know, basically.
00:19:24.740 - 00:19:28.146, Speaker A: An opening, that the opening before was correct or something like that.
00:19:28.168 - 00:19:45.250, Speaker C: Yeah, you have a vector of bitcoins. So at the core, bulletproofs, this is kind of vector product proof, where you can take the product of two vectors and prove, you know, a given commitment is an opening to this vector product. And that proof is logarithmic in the actual length of the vector, which is an enormous improvement.
00:19:45.330 - 00:19:48.074, Speaker A: Got it. So what is Aztec doing differently, then?
00:19:48.112 - 00:20:49.980, Speaker C: So what Aztec does differently is it uses, at the moment, what is really a unique range proof and a unique method of encryption to create extremely short zero knowledge proofs that focus very specifically around private transactions and settlements of private private transactions. It uses the range proof to make these proofs very efficient, and it uses the fact that we only need one trust to set up to create a large set of proofs. The fundamental goal of Aztec is to present a solution to developers, builders, companies, that enables them to create private digital assets without them having to know a lick of zero knowledge cryptography. So in that way, it's a little bit similar to what zuckerbergs have tried to do, but we're approaching it from a very different angle, which is instead of giving people the tools to build their own zero knowledge proofs, we're giving people the zero knowledge proofs that they need to build to solve their own, solve their problems.
00:20:51.490 - 00:21:03.970, Speaker B: How small are small proofs? And when you say that they're efficient, do you mean size or, like, proof generation time or verification time or all of it?
00:21:04.040 - 00:21:51.866, Speaker C: Right. So, to answer that question, it's complicated, because the range proof is extraordinarily succinct and short. And the kind of german logic that we use this range proofs for that stuff is linear in terms of its proof size and the amount of verification time required and proving this prover time required. However, the kind of the constant multiplicative factor in that linear relationship is extremely, extremely small. So the range proof in terms of proof size, I believe at last the last count is about 700 bytes. For traditional, like a typical joint split transaction with two input notes and two output notes. It does vary, though quite substantially, because if you're sending the proof to a smart contract, there's auxiliary information not relating to the proof.
00:21:51.866 - 00:22:50.046, Speaker C: But you still need that information for Ethereum, so does that count as a proof size? Also, when we send these transactions to ethereum, we don't compress the elliptic curve data with a traditional zero knowledge proof. When you're constructing your proof transcript, you can represent an elliptic curve point with half the data that you actually need, because on ellipsic curve you can represent the y coordinate as a single bit, because the x coordinate, any given x coordinate will only result to two elliptical curve points, and you can differentiate them with a single bit. But on Ethereum, we don't compress elliptical curve points because the amount of gas required to decompress the point is more than the amount of gas required to actually just send the uncompressed points in as input data. So that increases our proof size. But it's not like we could make smaller proofs. If we had a blockchain platform where computation was cheaper, we could get our proof subs about 500 bytes or less. They're generally a little bit larger than a Groff style Zksan proof.
00:22:50.046 - 00:23:44.334, Speaker C: When it comes to proof construction, that's one of the real key strengths of Astec is proof construction is trivial because you're not performing this reductive, you're not taking a rack one constraint system and then creating a heavy spike polynomial. You're not solving 1 million degree polynomials. You're just creating these really simple protocols where the range proof, that's the hard part, is basically taken care of because you use a lookup table really to select an element from a common reference string. And if you didn't have that lookup table, like the amount of competition, we would need to be quite large in a way, I believe with a full version of our protocol. It's accurate to say that both proof construction and proof verification has a level of succinctness to both sides of it because of the fact that we basically trade computation for storage with these precomputed tables.
00:23:44.462 - 00:24:06.010, Speaker B: So you have this system that can efficiently prove things. You have the theory of private transactions on Ethereum, but how do you go from that theory to actually having a working system? There's obviously engineering challenges along the way there. What does that look like.
00:24:06.160 - 00:25:02.480, Speaker C: Yes, thank you, that's a really good question. There are immense challenges, and this was the topic of a talk that was giving at the fantastic zero knowledge summit that you were hosting last month in Berlin. My word, there are some challenges. What we're doing is we're enabling other people to build private assets on top of Ethereum. So that adds an enormous extra level of difficulty with traditional xerox proving tech because, well, how do people normally interface with Ethereum, Dapps and applications? Through a web browser or through something on their phone? But typically right now it's the web browser, which means that if you require zero technology, it needs to be able to be performed inside a browser using webassembly. And that then means that the proof construction has to be extremely efficient. Because you take a traditional ZK snark proof with a large number of constraints, it's difficult for some of these proofs to perform them on.
00:25:02.480 - 00:25:49.286, Speaker C: Just like optimized code compiled down for a computer processor, running that webassembly adds an extra complication. But more to the point, it presents enormous, enormous UX challenges because interfacing with a blockchain is already quite difficult from a UX perspective. You have private keys and accounts and weird hex decimal strings flying around, and then maybe you need to build some kind of custodian solution so your customers don't need to know what the private keys are. You need to connect Ethereum nodes and broadcast your transactions and create digital signatures. It's already really difficult. And then on top of that, our users are going to ask required their users to build some construction proofs. And we can't even expect our users to really understand the proofs that they're going to be asking their users to construct.
00:25:49.286 - 00:26:29.606, Speaker C: This presents enormous UX challenges. And so what we are doing is abstracting away pretty much all of the zero. That's the goal. It's still a work in progress with Octooli, but the goal is to create a standard library, a JavaScript library you can plug into a browser where you have very simple API calls to make the required zero increase. And ideally this also includes things like metamask integrations and typical traditional model integrations at a high level. What's really needed here are standards. When a developer or builder is building a stake, they need to know what our zone order proofs do.
00:26:29.606 - 00:26:36.650, Speaker C: They don't need to know how it happens, but they need to know what they do, the inputs they need and the outputs that should be expected.
00:26:37.230 - 00:27:04.174, Speaker B: You're building a system that's for Ethereum and you're building these libraries, the Javascript side and everything else, but you're still only targeting like we had matter labs on recently, and they're planning on building this whole separate network that deals with all the things that are doing like proof generation, off chain, et cetera, et cetera. You don't have that off chain component, right? Like you're trying to do everything on chain.
00:27:04.302 - 00:27:54.290, Speaker C: Precisely, yeah. At the moment we're not really targeting scaling solutions. We're very much focusing on how do you represent value privately on chain at the layer one main net level, because we think that's very valuable and very needed for a lot of applications in blockchain. Because our tech is designed to be used by people building on Ethereum. We want to make the absolute bare minimum requirements or expectations on them. And so we don't want them to have to be able to run some kind of parallel auxiliary network or side chain, and we don't want them to have to get their users to install clients just for aztec. And we have a lot of freedom to do that because we're not doing scaling, we're doing privacy, and we do have the tech to do this all mainly by smart contracts because of our relatively succinct construction and verification.
00:27:55.270 - 00:28:09.526, Speaker A: The question of standards comes up a lot in all sorts of fields, but in zero knowledge. I know that there's like even a meeting, I think that just happened all about standards. Right. What's your take on that? Are you participating in sort of these standards talks?
00:28:09.558 - 00:29:00.360, Speaker C: That's a really good question. Yes, I was at that zoonology standards workshop that was in Berkeley just last week, still recovering from the jet lag from it, and it was a fantastic workshop and it was an enormous fusion of ideas between a lot of different groups. I think one of the greatest takeaways from it was, yes, we need standards for xerological geography, but there's not a lot of consensus around what the standard should be. And right now we're proposing Ethereum specific standards. When our own technology is more mature, we like to convert those into more formal standards that don't just apply to Ethereum blockchain. But right now there is no uniformity at all, which is an issue.
00:29:00.810 - 00:29:29.874, Speaker A: Back to that event. When you talk about standards in that context, are they academic standards? Is it only for blockchain? What conversation is that even about? We've actually never really talked about this on the podcast, and I know it's a topic I'd like actually like to dig into. Just when you're talking about a sort of combo academic corporate projects, open source ideas. Where are the standards, where do they live? And what are they for?
00:29:30.072 - 00:30:45.686, Speaker C: So again, it's kind of complicated because there's no consensus around what a standard in this field, or at least you ask ten people, you get ten different responses. It was more at an academic level than like an application specific level, because a lot of people there, a lot of different teams, had all using similar technologies, but for very different purposes. So you give an example of some standards that I've proposed, for example, a standard for composing and transmitting rank one constraint systems that are required for ZK snunk proofs, so that you can have multiple languages, compilers for ZK snarks that all create these. They compile to the same rank one constraint system format that you can then convert into proofs across multiple different elliptic curves. Another exchange, for example, is right now the community is deriving a lot of new elliptic curves, which is quite a new development, because there's an enormous demand and desire to perform elliptic curve cryptographic operations inside of a ZK snark circuit. And if you want to do that, you need to very specifically choose the parameters of the elliptic curve that you're doing your arithmetic on, to the point where the existing nist curves, none of them are suitable. And so people are deriving their own curves.
00:30:45.686 - 00:31:11.698, Speaker C: And so there was a workshop on, well, hey, can we formulate some standards around how to derive elliptic curves for zicky snux? Because it's not easy. It's very easy to get that completely wrong and basically just make a completely insecure curve because you've chosen your parameters poorly. And so standards around that, and those are the kind of the narratives at that conference, much more at a high level.
00:31:11.864 - 00:31:33.386, Speaker A: So, given that you are actually focused very much on bringing privacy to Ethereum, you're working within the ethereum sort of standards framework. Tell me a little bit about ERC one seven. Wait, ERC 1724, or is it ERC 1723 because somebody fed me both of these?
00:31:33.568 - 00:32:24.566, Speaker C: No, it's both, and I'm amazed you knew the numbers, because I myself had forgotten them. It's a shame that the lower ones are taken. So ERC 1723 is a standard for our cryptography engine, and ERC 1724 is a confidential token standard that uses the cryptography engine standard. And so, yeah, when it came to these standards, well, when I was putting together our stake in November and December, I was realizing, well, hey, we're having to answer a lot of questions that have not really been asked before. Which is like things like how do you actually do confidential trades of different assets and getting them all to resolve neatly? Because a lot of tech has been focused on unilateral value transfers, not bilateral value transfers. So we haven't fully implemented yet. But I have a proof, for example, for partial order filling.
00:32:24.566 - 00:33:23.898, Speaker C: So you have an order maker and you have a set of order takers that don't entirely fill the order, but mostly do. And there's general proof that guarantees that the trades are fair and everything has been executed correctly privately. But how does that get integrated into a standard? How do we create a systematic way of introducing these kind of modular, composable zero proofs into a system that developers can use and integrate with and can understand? And so ERC 1723 is our solution to that, is our cryptography engine. Effectively, what it does is it abstracts away proof verification and takes it out of the hands of the individual smart contract developer builder so that they don't have to deal with it. There's a lot of other reasons why we do that. I'll get into them in a bit. But basically it's a suite of smart contracts that live on chain that act as the kind of ultimate arbiter of the correctness of a zero proof, and specifically in our case, the correctness of aztec zeros proofs.
00:33:23.898 - 00:34:04.902, Speaker C: But the standard is more generic than that. This is really useful for a lot of reasons. The first one, obviously, is that you can completely abstract away the proof verification from the digital assets smart contract to the point where, for example, we categorize proofs by identifiers, and we have at the moment five proofs. They all perform. Business is logical when it comes to actually verifying these proofs at the digital asset level. You're just saying, hey, I have a proof with an idea of like seven relevant this proof, please. And so you can have a very simple interface that accommodates a large and ever increasing number of journals, proofs of all the different things, without it being inconsistent with kind of what the digital asset is trying to achieve.
00:34:05.046 - 00:34:15.058, Speaker A: So are you doing that with other people? Is it just an aztec proposal or. There's some other teams working on ZK stuff? On Ethereum?
00:34:15.174 - 00:34:52.280, Speaker C: Yeah, so there are other teams working on ZK stuff, but it's very early days. Most of the other teams, they aren't dealing with privacy, they're dealing with scaling solutions. So, for example, Barry Whitehead's roll up and the metal Labs team, when it comes to private transactions other than like hackathon projects and the OD thing here and there, I can't really think off the top of my head of a team that's specifically focusing on private transactions. I guess maybe there's ether guys, but I think they're more academic at this stage. I mean, we'd love more cooperation at the zero launch tech level. It's just that we've kind of been kind of screaming to the ether of them. There's not a lot of people to get meaningful feedback on the cryptography part from the Ethereum community.
00:34:52.280 - 00:34:59.846, Speaker C: Not that there is any expertise there, it's just that everyone's focusing on their own stuff, and right now privacy is not the focus of a lot of people is scaling.
00:34:59.878 - 00:35:40.166, Speaker B: Yeah, there's also been a wave of privacy, like private transactions, like parity has built in private transactions, but it's off chain private transactions. And that was the path that a lot of people were going for a long while, is not use their knowledge proofs at all. But I know my endpoint, like, I know the pair that I'm talking to, and I might communicate on chain of like how do I connect to you? But then do your transactions off chain, and you just commit an encrypted state on chain. So you have private transactions, but in a completely different way, though. It doesn't really relate to what you're doing.
00:35:40.348 - 00:35:53.930, Speaker C: Yeah, exactly. And I think it's kind of different technology, different kinds of solutions, as it was very much focusing on kind of the, kind of the have your cake and eat it model where you want to enjoy the consensus benefits of a public blockchain.
00:35:54.270 - 00:36:23.000, Speaker B: I'm curious, like when you were working on these ERC processes or like ERC standards, and generally in working in your products, how much do you think about the core level protocol? At some point you must have gone, if only this thing existed, this other thing would have been so much easier and I wouldn't have to deal with all of this stuff. Like what on the core level do you wish was different?
00:36:23.370 - 00:37:30.790, Speaker C: So at the core protocol level of Ethereum, yeah, you ask any Ethereum wants to develop on Ethereum, they'll have a massive laundry list of things they would like to change, and we're no exception to that. But I do want to kind of preface this with what I think Ethereum is being accomplished is actually quite significant in that because it allows you, the fundamental goal of Ethereum really was its creators. They realized they could not define the potential use cases that people wanted a blockchain for. And so by creating this for contract language, they allowed other people to decide how they can add value and they were really trying to kind of follow in those underlying philosophy by giving people the tools that they need to build their own zero knowledge assets instead of doing it for them. Ethereum was not really designed to validate zero cryptographic protocols. It was designed to do relatively simple things like transfer around ERC 20 tokens. And so it's a virtual machine is quite inefficient when it comes to actually validating, like performing the mathematics required to validate a xeron's proof.
00:37:30.790 - 00:38:20.874, Speaker C: And because it's inefficient and you can only process so many transactions a second, it means that the concrete cryptocurrency cost gas cost of validating Xeron's cryptography is extremely high. This has been approved recently with the addition of these pre compile smart contracts. They're like extensions to Ethereum virtual machines. So you can perform elliptic curve cryptography on very specific curves, but it's still extremely expensive because the implementations originally they weren't particularly efficient because they were focusing more on the security side of things than speed. But basically the takeaway from this is the amount of computations that an Ethereum node is performing. To know that it's an astic signal as proof is roughly ten times more than is actually required, just because of the inefficiencies of the underlying, of both the smart contract platform and the pre compiled smart contracts. And so, I mean, I guess two things.
00:38:20.874 - 00:39:06.422, Speaker C: One is there's a movement in the works to add some more pre compiles to Ethereum, which enable you to perform elliptic curve arithmetic over a much wider range of elliptic curves, which would be extremely useful for aztec, as well as reducing the gas costs because reducing the computational complexity, which would also be useful for Aztec. We're also very interested in the kind of ethereum one point x proposals to improve the Ethereum virtual machine and make it a little bit faster to run programs and perform mathematical operations, because that again would help us. We actually have a smart contract that performs the majority of the arithmetic required to validate our zone or proofs, so we don't need the pre compiles. In fact, the smart contract is cheaper than the pre compiles, even though it's written as a smart contract, and so actually improving the interpretation layer, but also enable us to be more cool and innovative. Zone autocrapy.
00:39:06.486 - 00:39:14.010, Speaker A: So why would you want the pre compiles? Like more options for pre compiles if you have a smart contract that's actually faster?
00:39:14.170 - 00:39:33.038, Speaker C: I mean, we'd like more options that are faster as well yes. Also things like our smart contract, it performs arithmetic over the bn one, two, eight. I don't know what to call it. Bn one, two, eight, b and two, five, six, b and t five, four. I've heard it called all sorts of different names, but Zcash's old curve, it performs arithmetic on that curve. We are very much like X's.
00:39:33.134 - 00:39:40.120, Speaker B: It was kind of ironic that that curve was added for zcash interoperability and then zcash change it.
00:39:40.490 - 00:39:43.350, Speaker A: Oh, yeah, I heard about that.
00:39:43.420 - 00:40:08.058, Speaker C: Yeah, it's ironic, isn't it? Because Zcash are using that curve, and now we're using Zcash's curve to do completely different kind of xeron streaming techniques and a lot of other people in the same boat. Even the zether paper that does bulletproof. The whole thing about bulletproof is they don't need trust, a set off. And so they can use more secure, and they don't require binary pairing, so they can use more secure curves. But they have to use this bn one to eight curve on Ethereum if they want it because of the precompass.
00:40:08.154 - 00:40:09.662, Speaker A: What was that paper you just mentioned?
00:40:09.796 - 00:40:10.570, Speaker C: Zether.
00:40:10.730 - 00:40:25.486, Speaker A: Zether. Okay. Yes, I have a question about, like, you mentioned it for a second. You mentioned aztec users, and I'm curious, who are the aztec users? Are they dap developers? Who uses Aztec?
00:40:25.598 - 00:40:34.578, Speaker C: So the aztec users are not retail consumers. They are DAP developers and companies building Dapps and smart contract systems on Ethereum.
00:40:34.754 - 00:40:44.182, Speaker A: So how do you actually see, we follow a lot of the zero knowledge stuff going on, a lot of the zero knowledge stuff on Ethereum as well. And so how do you see that developing?
00:40:44.326 - 00:42:00.754, Speaker C: If I do my job, if ASIC fulfills its mandate and does what it sets out to do, then I cannot answer that question, because the people who will be answering that question will be the people using ASIC and using other xenon technology. Because the fundamental, I think the fundamental challenge of this industry right now is access. Instead of having this kind of the high priest of cryptography deciding what the problems are and then running solutions for those problems right now, that's kind of how it has to happen, because it's so complicated and so abstract and so difficult. But we really want to move towards a world where we're giving the tools and technology to users and developers so they can solve their own problems using zero knowledge tech, and we don't have to decide what they are. And so basically, I think that what we're going to see in a few years is a much larger set of people using zero knowledge tech technology and zero knowledge tools, ultimately, a subset of those users won't even know that they're using zero knowledge technology and zero knowledge tools because it'll be abstracted away. But they'll still have the kind of the ability to use this tech to actually define their own, solve their own problems. And so how do I see it developing? I want to see a lot of people using xealous tech.
00:42:00.754 - 00:42:19.274, Speaker C: I not entirely sure how they're going to use it, to be honest. And if people are using xeonology tech exactly the way that I prescribe and how I see the world, then I failed because I've not provided the access that I seek to provide, because I've not been able to allow people to solve their own problems.
00:42:19.472 - 00:42:24.986, Speaker A: So you want to basically spur creativity in other people and figure out what they do.
00:42:25.008 - 00:42:25.578, Speaker C: Absolutely.
00:42:25.744 - 00:42:31.690, Speaker A: Cool. Yeah, I have a last question, and this is about the name Aztec.
00:42:32.110 - 00:42:32.570, Speaker C: Yes.
00:42:32.640 - 00:42:33.902, Speaker A: Where did you come up with that?
00:42:33.956 - 00:43:01.954, Speaker C: To be honest, it wasn't really intended to be the name of our privacy technology. It wasn't our name of our company, but we needed a name for this thing. Basically there's a zero knowledge tech ad name. And so originally I came up with Zap zero knowledge Anonymous. Was it proof or protocol? But then I found that Zap was actually like a company operating on Ethereum, so I couldn't call it zap. And so I thought, well, I need the name, need an acronym. So I come from particle physics, experimental particle physics.
00:43:01.954 - 00:43:14.410, Speaker C: And if there's one thing physics are great for, it's coming up with obscure, weird acronyms. And so ASICS stands for anonymous zero knowledge transactions with efficient communication. Some of those letters are silenced.
00:43:17.070 - 00:43:18.140, Speaker A: That's cool.
00:43:18.670 - 00:43:28.670, Speaker C: And so I came with the name because we needed a name and it kind of rolled us off the tongue and the rest of the team liked it. And so we decided to, it was the asset critical and we rolled with it.
00:43:28.740 - 00:43:30.766, Speaker A: It's pretty cool. I think it's good.
00:43:30.948 - 00:43:41.202, Speaker B: So to wrap up, where can people find out more about the protocol? The research papers that are interesting, like how do I learn about this stuff?
00:43:41.336 - 00:44:12.010, Speaker C: The majority of our activity is on our mono repo or aztec GitHub repository. So GitHub.com aztec protocol. We also have a medium publication which describes in high level terms what math we're doing and why we're doing it. And those are really the two main go to sources. Our paper is in our monorepo, which describes the fundamental asset tech. We are going to be adding a lot more papers to that.
00:44:12.010 - 00:44:21.406, Speaker C: So we have a few papers in our kind of final stages that we're going to throw out there, for example, about untrusted setup. But that's where all the activity is.
00:44:21.588 - 00:44:31.460, Speaker B: You mentioned that you had taken this paper to Yenscroth. Do you peer review papers in general, or do you just publish what you have?
00:44:34.470 - 00:44:52.742, Speaker C: The only paper was public at the moment is the original critical paper, which was created with extensive feedback from Jenscroth. And so, yeah, I mean, we wouldn't put anything public domain if it hadn't been peer reviewed by an academic cryptographer, for sure.
00:44:52.876 - 00:44:56.294, Speaker B: Cool. Well, thank you very much for being on the show.
00:44:56.492 - 00:44:59.366, Speaker C: Thank you very much. It's been an absolute pleasure. Thanks for inviting me.
00:44:59.468 - 00:45:02.506, Speaker A: For sure. Her. And to our listeners, thanks for listening.
00:45:02.618 - 00:45:03.290, Speaker B: Thanks for listening.
