00:00:00.650 - 00:00:19.550, Speaker A: Hello. Yeah, thanks. So, yeah. Hello, everyone. My name is Carlos. I'm the IBC engineering manager at interchange jmbh. And today I'm going to be talking about one of the most important, but sometimes difficult to understand core building blocks of IBC, which is the light clients.
00:00:19.550 - 00:01:42.270, Speaker A: Yeah, I'm going to talk about what they are, what why they are one of the differentiating factors of IBC. I will talk a bit also about the vision for IBC and what part zero knowledge proofs could play in the so, okay, so probably everybody is familiar with IBC, but for those that are not, just very briefly, IBC stands for InterBlockchain communication. It's a protocol that allows sovereign, independent chains to communicate with each other. So, yeah, this picture at a very high level shows the main actors involved engaged in inter blockchain communication. We have the nodes participating into chains, chain A and chain b, and we have some off chain processes called relayers that are able to submit transactions on each chain. IBC relies very heavily on light clients to guarantee the correctness and the security of the protocol. And this is one of the differentiating very distinctive factors of IBC comparing with other bridge or interoperability solutions.
00:01:42.270 - 00:03:11.930, Speaker A: In general, a light client is a client that connects to a full node, requests new headers, is able to verify by checking hashes and signatures that those headers are trusted and are generated by the underlying blockchain. And in the context of IBC, chains run a light client of the counterparty chain with which they communicate. So in this case, chain a runs a light client for chain b, and chain b runs a light client for chain a. The light client on each chain tracks the consensus estate of the counterparty, and it knows how to verify proofs against that consensus estate. So, for example, if we talk about a very concrete example of token transfers, for example, if I want to send tokens from chain a to chain b, there would be a transaction in chain a that stores in a state a commitment for sending those tokens. That commitment a proof of that commitment, together with a block header, is relayed by the relayer to chain b. And there, the light client for chain a can verify that that commitment for sending tokens is actually stored and the tokens can be received.
00:03:11.930 - 00:03:56.706, Speaker A: And, yeah, this is the reason why we say that the design of IBC is trustless, because there's no need to trust any other party except the two chains that are involved in the communication. We don't even need to trust on the relayers. We only need them for liveness. We need them to submit messages, to update the light clients, to transfer data packets from one chain to another. But we don't need to place any extra trust on them for the security of the protocol. Yeah. Now, if we compare with breaches another interoperability solutions, one of the other solutions yeah, there is an extra trust ledger.
00:03:56.706 - 00:05:29.350, Speaker A: We need to trust the breach validator set. And yeah, what happens if you cannot trust the validator set of the breach? We have seen in the last months several high profile hacks, like the wormhole attack, where the attacker was able to submit transactions with valid signatures from the validators of the breach, withdrawing basically the wrapped ETH on Solana and then exchanging it for ETH in Ethereum. This was actually the main problem was that there was a smart contract exploit, to be fair. But recently we also had the running hack where the attacker yeah, running is an Ethereum side chain, but was one that it was very centralized. So there were only nine validators, and the attacker managed to take control of the private keys of five of those validators to fake forged withdrawals of the funds in the bridge. So, yeah, as more and more value flows through cross chain bridges, this become a more attractive target for hackers. So, yeah, cross chain bridges and protocols are critical infrastructure, and any successful attack has cascading effects.
00:05:29.350 - 00:06:25.510, Speaker A: At the moment, the three largest by dollar volume hacks are attacks on breaches. So that's why it's a critical infrastructure at the moment and deserves special attention. So if we talk about the vision for IBC IBC launched last year with one application with fungible token transfers. We released interchange accounts recently, and it went live on the hub this week. We're going to release religious integration very soon, and we have in the pipeline some very exciting features. Yeah. Some teams in the IBC community are working on IBC queries, which will allow chains to query the state of their counterparties.
00:06:25.510 - 00:07:16.626, Speaker A: Also, teams are working on NFT transfers. We also have in the pipeline features to make IBC more sustainable and scalable, like connection and channel upgradability. This will allow chains to take advantage of new features without having to create new connections and channels. And we also have multi hop routing. This is a feature that will allow to send data packets from a source chain to a destination, but hoping through an intermediate chains. And at the moment, the Cosmos ecosystem consists of more than 40 zones, all of those interconnected with IBC. These chains are built with the Cosmos SDK.
00:07:16.626 - 00:07:56.920, Speaker A: They are using the Tendermint consensus algorithm. But the vision of IBC is to make it a universal standard protocol for inter blockchain communication. So we want to expand beyond Cosmos. We want IBC to be used in other ecosystems. And for that reason, we also need light clients for the consensus algorithms of those other blockchain ecosystems. And there are efforts going on on that front. So, for example, there is work being done on a beefy lite client in Go.
00:07:56.920 - 00:08:59.770, Speaker A: So this would be the lite client that Cosmos SDK chains can run to verify a state of chains built on substrate. There's also work being done to develop IBC and a tender Minlite client in Rust. So substrate chains can run the Tender Minlite client and verify the state of Cosmos SDK chains for EVN compatible chains that run the IBFT 2.0 consensus algorithm. There's also work going on to implement IBC and the IBFT lite client in Solidity. This implementation of IBC in Solidity is also being used for a Tendermin lite client for the Cello EBM. And there's also an implementation of the Cello Lite client that is targeted to run as a WASM binary in Cosmos chains.
00:08:59.770 - 00:09:54.490, Speaker A: And beyond this, there would be also in the future work to implement light clients in other blockchain ecosystems like near or Algorand. And yeah, another potential area of research that will eventually probably come to our roadmap is the use of zero knowledge proofs. We consider at the moment, like two use cases. One of them is related to computation, optimization or compression. There are two places where this can be applied. One of them is when updating live clients. This is one of the most expensive operations because we need to verify the signatures of the validators that have signed the block header that is going to be used to update the light client.
00:09:54.490 - 00:11:17.350, Speaker A: And also when verifying the state transitions of a chain, there needs to be a Merkel proof computation to compute a root hash. And as the state trade state trees becomes more larger, the computation becomes more expensive. So one possible optimization there is to wrap or convert the Merkel proof into a CK snark that is Verifiable in constant time, independently of how large the state tree grows. This imposes extra complexity on the prover to generate the CK snark, but the verification becomes cheaper for the Verifier. And the second area of use is obviously privacy. So as more chains or zones are joining that have shielded features, then it would make also sense to be able to send or receive packets in a private way, so basically to have shielded transactions over IBC. And yeah, I would like to thank also the folks at CCASH, Socrates and Anoma for their time that they spent with us discussing these ideas and sharing their ideas on this topic.
00:11:17.350 - 00:11:41.870, Speaker A: And that's the end of my presentation. So if you have any questions, I will be happy to answer. Hey.
00:11:42.020 - 00:11:57.234, Speaker B: Hello. All right, I want to apologize. I actually missed the beginning of your presentation, but with what you just shared, what's the roadmap or timeline for this?
00:11:57.432 - 00:12:38.222, Speaker A: For the serial knowledge? Yeah, this is difficult to say. It's really very early stage kind of research idea. We have other things still in the pipeline, like upgradability multi hop routing, other features. But this is something that can come at some point. At the moment, we don't see bottlenecks on, for example, updating clients or computation of Merkel proofs. But as the usage of IBC exponentially grows, hopefully these are areas that could be affected performance wise, and then zero knowledge proofs could offer some solution there.
00:12:38.356 - 00:12:48.298, Speaker B: And the first one, the sort of light client? Is that using that kind of compression technique? Is that the idea there, that you would make it like a smaller group using recursion?
00:12:48.314 - 00:12:49.662, Speaker A: That's the idea, yeah. Cool.
00:12:49.716 - 00:12:51.178, Speaker B: Is it influenced by Plumo?
00:12:51.274 - 00:12:51.630, Speaker A: Sorry?
00:12:51.700 - 00:12:57.654, Speaker B: Is it influenced by Plumo, the cello light client at all? Well, I'll tell you about it.
00:12:57.692 - 00:12:58.440, Speaker A: Okay. Yeah.
00:12:59.050 - 00:13:10.046, Speaker B: Cool. Any other questions? All right, thanks.
00:13:10.148 - 00:13:10.460, Speaker A: Thank you.
