00:00:06.410 - 00:00:17.870, Speaker A: We're going to have Henry Devalence who's going to talk about a topic very near and dear to my heart, which is how to build a private Dex harder than it seems. Anyways, give it up for Henry.
00:00:36.730 - 00:02:10.034, Speaker B: Great. So yeah, my name is Henry, I work on Penumbra. I'll be giving you this talk on how to build a private decks and to kind of start know, this is sort of a little bit of a joke but also a little bit real. We have this somewhat sad state of affairs which is if we imagine a Venn diagram where one part is chains that people use and then the other part is chains with privacy, then it's like almost two circles and the intersection is basically the people at this conference, right? And I say this as somebody who spent like the last five years trying to build privacy infrastructure. I don't think this is because of lack of trying. It's just like a very hard problem and actually a lot of the most successful deployments of ZK that we've seen so far have actually been on the scalability side rather than the privacy side. And so I think that points to some kind of issue of like we're just somehow not thinking about this right or something, right? And for me and how we got started on building Penumbra, the thought was like, okay, well, what if we tried to build just like one useful application? So I personally am not smart enough to be like, okay, I'm just going to sit down, I'm going to come up with this perfect idealized programming model for private programmability.
00:02:10.034 - 00:03:26.378, Speaker B: It's going to burst out of my forehead and that'll just be like the perfect thing, right? So what if instead we just try to build sort of one thing that has some kind of fixed functionality, figure out how we could make that useful and then after that see whether or not we could generalize anything. And that's basically what this talk is going to be about. It's about some kind of vague ideas of how you could generalize the approach that we've come up with into some kind of more general programmability system. So just from a kind of like product perspective, how would you provide useful functionality on a private ledger? If you were going to build one application, what would it be? For us, we kind of landed on trading as a use case to get started. And the thought process there is that trading is in one sense it's kind of this minimum viable transaction. A lot of the time people will think of like, oh, payments, that's the simplest possible thing you could do on a blockchain. But actually a payment is really quite complicated because whenever you have a transaction, the counterflow of that payment is going to be recorded off chain.
00:03:26.378 - 00:04:38.710, Speaker B: So if you want people to use it now, you have to sort of build and scale this whole parallel social infrastructure trading, you can have a transaction that in itself is economically useful for that person. And trading is also really interesting because it's an area where privacy thought of as control over the disclosure of information is not just this kind of abstract principle or human right or whatever, but it's something that has a very quantifiable near term financial value. People don't want to get front run and so you can actually sort of potentially move out of oh, we're going to like, you know, build this privacy product to we're going to build something that is better because it is private. So that's kind of what we've landed on. So what we're building is this private proof of stake l. One that has a cross chain shielded pool that can record any type of asset and an integrated private decks. And so before getting into sort of what's the interesting technical idea or challenge, the next thing that I want to try to convince you of is that useful blockchains revolve around public shared state.
00:04:38.710 - 00:06:02.330, Speaker B: This is actually really relevant for building a private system because if the goal is oh, just like make everything private, I think you end up actually not building a system that's very useful. So for instance, considering a market, if you made the entire state of the market completely private, you end up with something that nobody really wants to use because nobody has any idea like how much liquidity is there is, what's the trading volume? What kind of prices are people getting. Instead you have to figure out like, okay, the point of the blockchain is to be this kind of coordination fabric. If you don't have any public shared state then all you're using it for is some kind of like messaging or settlement layer for some kind of off chain coordination. And that's basically like a kind of fancier form of payment channels which don't really seem to be that useful. So how do we get then to being able to have private interaction with public shared state? I think this is kind of the fundamental big thing that we have to figure out in order to build useful private applications and to explain a little bit about why this is such a problem. We can kind of recap what may be familiar to some people in the room the key differences between the state model of a transparent or a shielded chain.
00:06:02.330 - 00:06:51.662, Speaker B: So let's say we have this transparent chain like ethereum. The basic kind of mental picture is that we have this big global mutable state. We have transactions that we've come to consensus on and we're just applying them in sequence and each transaction is like locking the state, doing stuff, unlocking and then we do the next one and so on. In order to make this private, we first have to move to composable state. So I guess this is kind of like rewinding backwards to bitcoin. But the idea is instead of having like one big global state, we'll have this tree of little state fragments. And then each transaction is only going to have some determined set of inputs that it consumes and it composes those together to form new state fragments that get appended into the chain state.
00:06:51.662 - 00:08:04.182, Speaker B: And the reason that you want to do this is that you can replace all of the state fragments with commitments to the state fragments and then you can replace the actual sort of clear text transaction contents with a proof of a valid state transition. But this diagram is like a little bit of a lie or it's not quite capturing something important, which is that what's actually happened is that we've successfully moved all of the user state off chain and replaced it with these commitments. And the only on chain thing is just this proof pi. But that means that the execution has moved off chain. And so this only works when there's no shared state. Because if, for instance, I want to interact with a Dex like, say, I want to trade on Uniswap, if I'm going to move the execution off chain, then one of the inputs to my state transition that I'm supposed to be supplying this kind of sealed verifiable proof of is going to be the state of that AMM and the state is just going to change out from under me. And I also can only be touching my own state.
00:08:04.182 - 00:09:40.760, Speaker B: I can't interact with anybody else's shared state or anybody else's state fragments because I don't know what they are. And I'm making ZK proof, so I have to have knowledge of the whole complete state transition. So what this points us to is actually that we need some kind of better computational model for concurrent state. The big idea is if we forget that we're in blockchains, right? Just imagine that we're doing systems programming and we want to build some kind of really high performance parallel concurrent system the way to do that is not to take all your app state and put one big global lock on it, right? It's actually not even to have finer locking like you could do that, I guess. But a much much better and cleaner way to do concurrency is by having independent actors that are each controlling or responsible for one piece of state and then you have message passing between those and that's how you avoid the need for some kind of explicit data synchronization. So what would that look like in the context of a blockchain? Well, we could get some kind of actor model for blockchains, where instead of having each transaction acquire a global lock on the whole state and then do some synchronous function. Call we could say a transaction is going to pass a message to a contract.
00:09:40.760 - 00:10:55.200, Speaker B: Then each contract can execute exactly once per block on input of all of the messages that were sent to it in that block. And this allows the contract to do batch processing if it wants. Or it could do whatever kind of arbitrary application logic it wanted. So for instance, if you had an auction, you could sort the messages by the bid or something and the user state is going to execute asynchronously off chain using ZK proofs. So as a side effect that I won't get into in this talk, this also, in my opinion, mostly solves mev. But the interesting thing here is like, okay, when I say we're going to do some kind of async execution of the user state off chain, what does that look like? So we're going to start instead of having the ability to have all of our inputs and outputs, we know that we're trying to communicate with some contract asynchronously. So we need to have some kind of way to take our private inputs and then send a message out to the contract.
00:10:55.200 - 00:11:55.920, Speaker B: But at that point we can't continue executing, we can't continue preparing this sort of pre sealed state transition because we haven't got the result of the contract execution, we haven't received a message back. So what we're going to do instead is we're going to mint to ourselves an NFT that will record the intermediate state of our execution. So here I've got this kind of little schematic diagram. The circle is meant to represent like, okay, that's going to be like the state of the AMM or the dex or whatever. And these hollow boxes are the outputs that we know we're going to want to mint later. And so the idea is that this state NFT is modeling that future computation. And technically the way that you do that is you just mercalize all of the execution state using a Snark friendly hash and then you use that as the asset ID for this NFT.
00:11:55.920 - 00:13:03.204, Speaker B: That means that later, after we get a message back from the contract in some later block, maybe the next one, we'll get this message from the contract and then we can consume the state NFT and then open that. Mercalization of the intermediate execution state show that we're modeling the correct future and then use the message from the contract to mint the private outputs that we were supposed to get. So the trade off for this is that the execution is now potentially spread over multiple blocks. But on the other hand, you can actually have private interaction with the public shared state. So as an example of how you can, that's a fairly general kind of abstract description, but to see how this works concretely, let's see how we can do some batch swaps on Penumbra. So this is looking at the private state part of it. So we have our private input that some user wants to contribute to the batch swap for some block.
00:13:03.204 - 00:14:03.020, Speaker B: What they're going to do is actually verifiably encrypt their input amounts with a threshold key that's controlled by the validators. That's going to be their message to the contract. Effectively, they mint to themselves this private state NFT. And now that the chain, when it's processing these messages, will have this batch of inputs, the threshold encryption is actually going to be additively homomorphic. So they can sum up the ciphertexts, compute an encryption of the batch total, and decrypt that. And now the only thing that's revealed is the aggregate flow into this trading pair in that block. At that point, you can execute the Dex contract just once per block, get the batch outputs, and then that can be fed into this secondary swap claim transaction that consumes the user's swap NFT and mints their private outputs.
00:14:03.020 - 00:14:58.716, Speaker B: But what's really cool about this is that because we're actually executing each contract, in this case, it's a hard coded Dex, but we're only executing it once per block. And so that means that we can amortize the computational cost of whatever work we do over all of the transactions in the block because we know that we're only going to have to do it once. And so that lets us actually do a substantially cooler and more sophisticated thing, which is instead of having to do kind of middling like gas optimization of every single transaction that we're going to be interacting with this dex. Like 1000 times a block. We can just group all the inputs of all the assets in different trading pairs. Batch them all together, decrypt them. And now we have this kind of global view of all of the trading intent in the block that we can just globally resolve using optimal arbitrage, like get all the prices in line.
00:14:58.716 - 00:15:50.076, Speaker B: We can do like multi hop routing. And all of that is happening only once per block. So if it takes a little longer to run, it's not that big of a deal. At the end of that, you get all the prices, and now you can feed back into the second part of that private state flow. So this is pretty cool. We're still obviously just focused on the one application to start, but I think this is a kind of interesting thought experiment of how we could build a really useful asynchronous programming model for doing interaction between private user state and public chain state. The other thing that's pretty cool is that actually this works.
00:15:50.076 - 00:16:15.910, Speaker B: So if you want to go and use this, the full kind of like, cool, globally optimal Dex part is not implemented, but the sort of interesting part of how do you interact with the state model? How do you have this future in the shielded pool? You can go play with that at the moment. If you go to Guide Penumber Zone, there's instructions on how to play with the testnet. So cool.
00:16:25.420 - 00:16:35.510, Speaker A: All right, are there any questions for Henry? Really? Everyone knows how to implement a private Dex already, and it's perfectly good.
00:16:37.320 - 00:17:27.380, Speaker B: All right. Hey, thanks for the talk. You mentioned that you're spitting out the execution of the contract over multiple blocks? Is it locked in for those multiple blocks, or can you anyway, the contract execution is once per block. What is spread over multiple blocks is the user state. So, for example, in the swap application, as soon as the user submits their when a user submits a transaction with a swap in it, as soon as they see that that transaction has been included in a block, they have control over this swap. NFT that already has effectively the value of whatever their outputs are. It's just that they haven't sort of driven that to completion.
00:17:27.380 - 00:17:56.220, Speaker B: So there's still this kind of atomic execution on the public chain state. The part that takes potentially a second phase is sweeping those outputs from being represented as, here's the receipt for your participation that you could redeem to actually redeeming it. But either way, the execution has happened by the time that they see that they have control over that. Note.
00:18:01.020 - 00:18:16.128, Speaker C: Yeah, first I want to say this is super cool. Thanks for sharing. I was curious on the execution layer, besides being able to support this function call at the end of the block, are there any other changes? And then, yeah, first I think yeah.
00:18:16.214 - 00:19:30.992, Speaker B: The main thing is the ability to have an end block phase. The other piece that is kind of a little bit TBD is if you weren't doing this as hard coded functionality, you have to think about like, okay, what does the trust model look like, right. For us, because the Dex is kind of integrated functionality. We can say like, okay, well, here's a way that you can burn these tokens, mint this thing. Later you can do a mint of your output tokens and prove that that's honest and that's all fine because we're pretty sure that those state transitions are correct. Whereas if you're going to allow arbitrary user code, then how do you know you need some kind of fault isolation? And the kind of interesting perspective there is there's actually some kind of analogy lurking in the shadows between this and the kind of cosmos maximalist. Like, everything is an app chain that communicates over IBC, except that instead of doing IBC between these things, it's like all the messaging is just done on one chain.
00:19:30.992 - 00:19:33.376, Speaker B: So it's sort of like app chains on one chain.
00:19:33.568 - 00:19:51.790, Speaker C: Yeah, I was asking because I was curious. Maybe I know in your case it's really important to have this function called the end of the block. But I think your program model, for example, could work on Ethereum, and maybe you have some relayer node that calls some function to do the end of the block transaction, or maybe there's like multiple block latency or something like that. But yeah, just thought it was super cool.
00:19:54.400 - 00:21:28.492, Speaker B: In principle, you could kind of multiplex this type of execution model over some other system in the way that you described where people can make a transaction where the transaction is like registering the message or saving it in a queue or whatever, and then there's some kind of thing that's going to trigger the end phase. If you want to have low latency, I think that's kind of a challenge and you might end up with sort of weird issues where you're kind of like aliasing the time resolution. The other sort of philosophical point of wanting to have this kind of batched actor model is the idea that and this is kind of getting into the mev point, at least in my opinion. A lot of the mev is the result of people designing mechanisms that operate at a higher time resolution than is actually provided by the consensus mechanism. And then because there's this attempt to sort of have a higher sort of fidelity of time than is actually provided by consensus, you get all this kind of bullshit mechanical arbitrage about the intra block ordering. And so the other piece of this approach is it's sort of saying like, look, you shouldn't build mechanisms that can operate at a higher time resolution than is actually provided by the underlying consensus. And so really you shouldn't even be doing any processing in the transaction handling at all.
00:21:28.492 - 00:21:42.800, Speaker B: All of the processing should be in the end block handler. Cool. That's just a philosophical idea, not an actual concrete system design idea. It doesn't actually work like that. There's reasons.
00:21:43.620 - 00:21:45.250, Speaker A: Are there any more questions?
00:21:51.250 - 00:23:30.740, Speaker B: Um, what proving system is Penumbra using? Is it graph 16 or a bulletproof space design? So this is kind of funny actually, as you can maybe tell from the talk, the emphasis that we've sort of had so far is like the hard part is figuring out the data flow and the data model. And so in order to be able to iterate on that, we've actually been using a really cool proving system that's called protobuffs, in which you take all the witness data and you just put it in a proto and then you don't look. And that sounds extremely stupid and in a way it is. But also the thing that's cool about it is that you end up with a software object that has exactly the same interface that you're going to end up having when you have circuits, but where you can just change it in 30 seconds if you decide that you want to change your data modeling. So for example, in the coming weeks we're probably going to redo the whole data model so we have like 128 bit note values to have better compatibility with sort of ETH issues. And that type of change is like a lot easier to make if you don't actually have to go and reprogram all your circuits. So sometime this fall we'll then take those as a sort of like machine executable spec and then turn them into Grout 16 proofs, which is probably the real answer that you were looking for.
00:23:34.150 - 00:23:57.260, Speaker A: Well, I have a question actually, this is more of a philosophical point, but do you think the same trick of kind of batching execution can actually be achieved on different other protocols that aren't just DEXes? Because it feels like it relies a lot on the fact that you can kind of batch execution, but do you think it's more generally possible and we just need to do more research on it.
00:23:57.870 - 00:25:39.370, Speaker B: So what I would say is that there's kind of two different uses of the word batching that are mixed together. There one sense is from the kind of specific dex application sense, there's an idea of like, okay, we're going to batch all of these trades into one trade and only execute the one trade. But also from just a general system design perspective, there is some kind of batch execution in the sense that if we were to generalize this to arbitrary contracts, each contract would be receiving a batch in the sense of like. Here is a list of all the messages. And then, depending on the application, they may or may not be able it's going to vary how much work they're going to be able to overlap between processing of each individual items. But in general, if the interface is that you get all of the messages, then your application can choose, does it make sense for me to batch? Can I reuse work between different items? What is that for my specific application? But if the interface that your contract has is like, I'm getting all these things independently, then you just can't do that at all. So I think in every case, it's definitely not worse and probably better, even if you can't necessarily get to the sort of so hilariously optimal thing as on a batch swap, where you can just execute one trade.
00:25:41.070 - 00:25:53.100, Speaker A: All right, we have time for one more question. If there are no more, I think I will ask for Anna to come on, think. No, no more questions.
00:25:53.630 - 00:25:55.658, Speaker B: Really? Zero? Okay.
00:25:55.824 - 00:26:00.610, Speaker A: Well, thank you, Henry, for presenting how to privatize the debt.
00:26:02.550 - 00:26:02.960, Speaker B: All right.
