00:00:06.330 - 00:00:18.750, Speaker A: Welcome to Zero Knowledge, a podcast where we explore the latest in blockchain technology and the decentralized web. The show is hosted by me, Anna and me, Frederick.
00:00:26.890 - 00:00:45.110, Speaker B: Today we sit down with Axel from Fest to explore some crypto economic principles and the incentive models around Staking. Hi, Anna.
00:00:45.190 - 00:00:45.674, Speaker A: Hello.
00:00:45.792 - 00:01:04.080, Speaker B: We're sitting with Axel Erickson, or Axelaxon, as Sweden May wants to say from the company vest, I guess formerly one protocol. And we're going to dig into some super interesting topics today. Axel, why don't you kick off with just introducing yourself and your background a little bit.
00:01:04.530 - 00:01:38.714, Speaker C: Sure. Thank you both so much for having me on. Like Frederick mentioned, I'm originally from Sweden, moved to California to do CS at Stanford four years ago in 2014. I lasted at Stanford for about two and a half years. Late 2016, I quit to work on Ethereum essentially full time. And in the beginning I was working with my then roommate at the time, Zach, who became co founder at Vest on essentially Ethereum infrastructure related things. So there are lots of things that you would want Ethereum to be able to do.
00:01:38.714 - 00:02:30.822, Speaker C: For example, you would want to be able to react to things happening on chain, and you would want to be able to chain certain events together. Everything that happens on Ethereum right now needs to be initiated by a transaction that gets sent to the network. So we essentially created this generalized alarm clock system. There was an Ethereum alarm clock at the time where you could schedule transactions to happen based on blocks, but we essentially came up with a design where you could schedule transactions to happen based on any condition on the system. And the cool thing about this is that we set this up as a staking protocol where you could send a job to the set of machines. The machines could take on the job and essentially look at the condition that you sent and then whenever the condition triggered, a transaction would be started. So the trick here was to punish the machines when they took on a job and they said they were going to watch this condition, but then they didn't do anything when the condition triggered.
00:02:30.822 - 00:02:31.162, Speaker C: Cool.
00:02:31.216 - 00:02:44.558, Speaker A: So that actually leads us a little bit into what we want to talk about today. We're going to be talking about incentives and staking. I think to start, it might be helpful for us to define a couple of terms exactly.
00:02:44.644 - 00:03:29.886, Speaker C: So this is such a broad area of study that it's helpful to first just talk through the normal terms that we use when we talk about incentive systems. And these are like half borrowed from game theory. So the people that have studied this are going to be pretty familiar. And then using those terms, there's a pretty simple model that you can use for how to think about incentives in general, and we use it quite a lot and it helps clear things up the first sort of thing is that we can think about these systems as essentially games with a bunch of players. And the first thing that we want to say about the players is that they're rational. And this of course means that they're acting in their self interest. And the reason we want to make this assumption is that if we assume that the players can be irrational, we are essentially saying that they can do whatever they want.
00:03:29.886 - 00:03:43.602, Speaker C: Which means that there's no way to predict. Basically there's no way to predict and there is no way to reason about the system because you could have a machine that joins and just does something super weird. And there's no way that we can bind properties of the system if they can do anything.
00:03:43.656 - 00:03:47.286, Speaker A: So you'd have to assume something rational in order to create a model at all.
00:03:47.388 - 00:04:36.270, Speaker C: Exactly. And for the rational players, essentially what we're interested in are the actions that these rational players can take. And this seems neat because it seems like there may be two or three different things that a machine can choose to do and then we should be able to reason about the system as a whole. The problem is that even if we try to look at these actions, it's very difficult to know ahead of time what they are. So there's this great example from Bitcoin which is called the Selfish Mining attack, where for the longest time it was assumed that when a miner mined a block, it would just broadcast it instantly. But it turns out that there was this other action that the machine could do which was simply to withhold the block. So you mine a block, you wait five or 10 seconds before you broadcast it, and then of course, you get a five to ten second head start on the next block.
00:04:36.270 - 00:05:21.458, Speaker C: So this was an assumption that was made about Bitcoin that the blocks would just be broadcast, but there was this hidden action that wasn't known for years that turned into this attack. Even if we try to nail down the actions in order to think about the systems themselves, there are always other weird things that the machines can do. Leaving Bitcoinland. There's another example for blockchains in general called the Verifiers Dilemma that has almost the same properties. So the idea is that let's say you have an ethereum style blockchain and then it becomes super popular. And then the blocks you have a very high block gas limit, which means that there's a lot of code that needs to be run inside each block. And normally the assumption is that when a node or a miner receives the block, it checks through all the transactions to see that the block is valid and that everything is fine.
00:05:21.458 - 00:05:57.674, Speaker C: But there is this problem when the block is too large, it may be in the best interest of a miner to not check through the entire block. And essentially just probabilistically guess that it's true and then instantly start mining on the next one. Let's say that going through a block takes an hour. Well then you need to do an hour's worth of work before you're able to continue mining. So there's this problem where the verifier or the miner essentially skips the verification. So here's another example of this. There was an assumption about these blockchains that the miners would just always be able to check through the blocks because that was one of the rules.
00:05:57.674 - 00:06:28.646, Speaker C: But it's fully possible for the miner to choose not to do that. And then all of a sudden you've broken higher level properties of the system. Like consensus. This is like quickly on actions that these rational actors can take. And essentially the goal is to create systems that have what you can call good equilibrium. So with this assumption that we like to talk about rational actors and we like to talk about their actions, the goal when designing most of these systems is to design a system with essentially a good equilibrium. And what I mean about that is very simple.
00:06:28.646 - 00:07:00.222, Speaker C: Essentially a good equilibrium is one that produces some sort of output that's good for the system. So if you're designing a consensus protocol, this could be consensus is achieved. And then the other property is essentially that it's very expensive to deviate from this equilibrium. And the reason the second property is necessary is that if you simply have tons of equilibrium or equilibria where it's very easy to shift between them, then essentially the machines can choose between these things and you don't end up having a system that performs one task.
00:07:00.286 - 00:07:47.794, Speaker B: And a lot of these things are actually like it's not just designing the system at a high level to like we're going to achieve an equilibrium like you're saying you need to achieve maybe a particular one. So like in the case of Ethereum, you mentioned the verify dilemma there. We set a gas box size limit for a reason. If it was infinite, then obviously you could include 100 megabytes of data and that in itself might be hard to send around. But beyond that, verifying all the transactions in 100 megabytes of data would be so costly computationally that it would probably not be rational to actually do it. And you're better off just probabilistically assuming it's correct and going about your work for the next block on that. So we can't have a too large limit and we can't have a too small limit either.
00:07:47.794 - 00:07:56.462, Speaker B: So there needs to be a parameterization that sets this scene and has the correct cost of deviation and all the things you're mentioning.
00:07:56.606 - 00:08:44.334, Speaker C: That's exactly right. Just quickly on essentially having the system converge onto a specific equilibrium. Another way to frame that is essentially to say that there's a high cost to moving to other equilibriums or moving anywhere else. And this is actually very closely related to the security of the system. So normally when we talk about the security of the system like this we essentially just talk about the cost of cheating and this is actually the same as the cost of moving away from one of these equilibriums or doing something that you're not supposed to do. And in proof of work land the security of the system is the cost of cheating and what is the cost of cheating? Well, it's the cost of getting more than 50% of the hash power. And then similarly, in proof of stake the security is the cost of cheating, which is the cost of acquiring, essentially a large enough voting chair.
00:08:44.334 - 00:08:46.430, Speaker C: So there's cost of buying the tokens.
00:08:46.510 - 00:09:00.410, Speaker A: And this is why I'm assuming this is why often when you talk about attack vectors, you'll say things like, yes, it could be attacked, but the price would be so enormous that it would make no sense. This is what you're describing here exactly.
00:09:00.560 - 00:09:24.490, Speaker C: And you're hitting a key point there as well there is a cost to attacking these systems but it's fully finite. It's always possible to, with an army of people or something like that attack all these systems. It's always possible to go around the world with some sort of SWAT team and take down every single bitcoin node or ethereum node it's just that the cost would be near infinite.
00:09:24.570 - 00:09:30.354, Speaker B: I mean, let's be honest like any major nation state can take down bitcoin or ethereum like any day they want.
00:09:30.472 - 00:10:01.718, Speaker C: It's likely really. It's likely. And this goes back to what we talked about with actions, where we're looking at an adversary and we assume that the actions that are available are like these simple tricks. But the actions could involve network level attacks or they could involve an army comes and puts a gun to your face. And this just reinforces what we said before, that it's so difficult to reason about these systems because the set of actions that are available are usually a lot larger than what you would assume.
00:10:01.894 - 00:10:52.746, Speaker B: You're talking about a lot of these sort of assumptions that you make in designing the system and I think we've all heard of the honest majority assumption which is the same thing as like a 51% attack if there's more than 50% are dishonest then it violates the honest majority assumption. There are other consensus systems where you assume two thirds are honest or something like that and others that are super conservative where you assume one third is honest. Different designs, different properties of the system come out of it but there's another key thing that you were talking about which is an assumption on rational actors and there's some evidence to say that humans are irrational some and like is there a similar sort of limit system like we assume majority rational or something?
00:10:52.848 - 00:11:43.514, Speaker C: One way to look at this is to just look at it empirically. In the very beginning of Bitcoin, for example, it was irrational to waste your GPU power or your CPU power on mining a useless currency because it had no value in the beginning. So in order for the system to work, you needed essentially a few years worth of irrational miners. I'm not sure that I would go so far as to say that there is a majority rational or any portion rational assumption, but at least in the beginning there is some irrationality needed. And we may get into this when we start talking about proof of stake as well. There is this irrationality assumption there as well, where token needs to be valuable before it can be used, before it becomes costly to use it to vote on different histories. And you could also argue that there's this necessary irrationality there to bootstrap the currency, make it valuable before it can be used for voting.
00:11:43.562 - 00:11:50.362, Speaker A: But also when you talk about malicious actors, if they're acting maliciously in a system with equilibrium, are they irrational?
00:11:50.426 - 00:12:04.222, Speaker C: It's fully possible that the system is just not designed properly. And there is an equilibrium where the miners always try to cheat because the miners let's assume that they're still rational. Well, there may be equilibriums where they essentially make more money by always cheating.
00:12:04.286 - 00:12:09.154, Speaker A: But what you're saying there is they're still acting rationally within that wrongly defined equilibrium.
00:12:09.282 - 00:12:13.238, Speaker C: Exactly. It would just mean that the system doesn't produce the outcome that we would want.
00:12:13.324 - 00:12:23.334, Speaker B: If you had the capacity to produce a 51% attack on Bitcoin, it would be rational to do so. So I mean, you're irrational, but still bad behavior.
00:12:23.462 - 00:12:36.122, Speaker A: But then if there is this equilibrium, you just sort of said that there is a need, at least at the beginning, for some form of irrationality. I'm wondering if there is that connection between acting maliciously or wrong and being irrational.
00:12:36.186 - 00:13:16.278, Speaker B: Yeah, there's an interesting I'll try to find a link to this and put it in the show notes. There's a game theory game. It's like a little browser based game JavaScript thing and you click what you want the actor to do and it's like a three choice system. And basically you build like this bot and you make your choice once and that's like a one time game and it doesn't seem like there's a bunch of useful information coming out of that. But then you start playing these repeated games and you set a strategy instead. Like I will always pick this or like I will pick this, depending on what my opponent picks. And there you can simulate an irrational actor by saying I'll pick any choice completely randomly.
00:13:16.278 - 00:13:34.526, Speaker B: And in a well designed system they should be eliminated. So eventually they'll lose the game enough times that they are eliminated from the game if they behave irrationally. But yeah, capturing all of this irrational behavior in a system is incredibly hard.
00:13:34.628 - 00:13:45.154, Speaker C: I guess a design goal then would be to starve irrational players eventually when designing consensus protocols and other systems. But my guess is that would be extremely difficult to get, right?
00:13:45.192 - 00:13:45.586, Speaker B: Yeah.
00:13:45.688 - 00:13:58.406, Speaker A: Okay, so we've talked a little bit about these terms and this equilibrium and incentives and I'm curious how do you then take this and create a model? What does a model actually look like?
00:13:58.508 - 00:14:42.242, Speaker C: Right, so it turns out that there's this pretty simple model that we can create using these terms to reason about essentially the two major incentive strategies that exist in blockchains. And the model is very straightforward. We essentially start by having what we call a market protocol. Market protocol is extremely simple. You have a set of buyers, you have a set of sellers and they're buying and selling some sort of digital service. So in the case of blockchains, the sellers would be the miners and the buyers would be people that hold private keys and sign transactions. And if you think about it, when you sign a bitcoin transaction or when you sign an ethereum transaction and you send it away, what you're really buying is the service of having your transaction included in the state of that blockchain.
00:14:42.242 - 00:14:43.906, Speaker C: That's why you're paying the transaction fee.
00:14:43.938 - 00:14:45.986, Speaker A: And the cost is the gas.
00:14:46.098 - 00:15:35.800, Speaker C: Exactly, it's the gas or whatever sort of fee exists in the blockchain. Expanding on this model sort of a key thing is always that they're fully sort of open and permissionless so anyone can plug in as a seller. I just run a piece of software on my laptop and all of a sudden I'm a miner. The problem then is that we still want the system to produce something good for the users so if anyone can join and when they join they can really run any piece of mining software they want. They can send any messages to the network. How do we make sure that this good equilibrium is still achieved? So it turns out that there are really only two major strategies for incentives that exist and the first one is to just play with the amount of money that you pay the machines in the case that they perform correctly. So this is in proof of work land.
00:15:35.800 - 00:16:11.570, Speaker C: These are the block rewards and what they do is that you essentially make sure that the machine gets paid just a shit ton of money in the case that it performs correctly such that there is some stream of earnings that it doesn't want to lose out on if it does anything else. This would keep it honest. The properties is pretty direct in most proof of work systems. If you mine what ends up being the canonical chain you get paid a shit ton. Which means that any other strategy like trying to do minority fork or something like that which is essentially just you going out on your own trying to deviate from history it's just costly because you're losing out on that money.
00:16:11.640 - 00:16:15.170, Speaker A: You wouldn't actually earn any block rewards if you did that.
00:16:15.240 - 00:17:02.782, Speaker C: Exactly. So that's sort of strategy number one and it seems fine because we've essentially just played with a payment and then all of a sudden we've created a cost of cheating which means that we've essentially created some sort of good equilibrium. The problem is that per definition the users are paying a lot all of a sudden. So if you have no inflation this means that the transaction fees probably need to be fairly high to get good security. Or if you have inflation, well that just means everyone is paying. So it turns out that instead of just playing with the amount we're paying the machine, the second sort of broad strategy and incentives is it's the underpinnings of staking. But it's essentially the idea that we can somehow take something away from the machine when it cheats instead of just relying on what we give to the machine when it doesn't cheat.
00:17:02.782 - 00:17:52.014, Speaker C: The sort of broad idea is that we make it a part of the requirement to be a miner in this system that you also put up this big security deposit. We build the system so that we try to detect every case where the machine cheats, which turns out to be incredibly difficult. But if we're able to build it so that we can detect every case, we can essentially confiscate or slash the security deposit when the machine cheats. And the key idea there is that we can create the same disincentive to cheating as before. But all of a sudden the users don't need to pay a shit ton every time they buy a unit of service, which means that you get the same sort of security. But all of a sudden we can massively reduce inflation or the cost per unit of service goes down. And if you look at some of the Casper proposals you will also see that the inflation rate generally is lowered.
00:17:52.014 - 00:17:53.950, Speaker C: So this is directly correlated.
00:17:54.030 - 00:18:02.294, Speaker A: I mean what you describe is just the what is it? The carrot and the stick. But guess you know that expression, this.
00:18:02.332 - 00:18:08.390, Speaker C: Is carrot and stick. And it turns out that the only two weapons we have to play with is the carrot and stick.
00:18:08.810 - 00:18:12.466, Speaker A: But there's like lots of different sticks and various carrots.
00:18:12.578 - 00:18:12.998, Speaker C: Exactly.
00:18:13.084 - 00:18:13.926, Speaker A: And turnips.
00:18:14.038 - 00:18:26.558, Speaker C: Exactly. And it turns out that it's very difficult to get stick to work. But that's essentially it. And this shouldn't be surprising but it's almost funny that at the end of the day these are the two things that we're still playing with and it's really not crazier than that.
00:18:26.644 - 00:18:34.450, Speaker A: In current proof of work though, is there actually any sort of stick other than removing the block reward?
00:18:35.030 - 00:18:39.950, Speaker C: There is some stick and this is sort of an economical stick.
00:18:40.110 - 00:18:44.882, Speaker A: Is this because they've invested money into their equipment that's not being used? Like opportunity cost?
00:18:45.016 - 00:19:25.678, Speaker C: That's exactly right. And by the way what you said right there is super important. There is opportunity cost to using your mining rig towards a certain purpose when there's something else that you could use it for. So we actually want these puzzles to be as useless as possible because if you could use your machinery for something else then all of a sudden the cost of attacking goes down because you can sell sort of the output of your machine. But essentially there is this very implicit stick which is that if you do spend your hash power on, let's say for a month trying to pull off some attack, yes, there's some opportunity costs because you may have been able to do something else with it. For example, mine on another system. But there's also the economic depreciation in the machinery.
00:19:25.678 - 00:19:47.062, Speaker C: So what's the resale value of the machinery? And that should go down if you've had the machines on, which is a tiny stick. But what we really are relying on is the block rewards being high enough so that you would just choose essentially to make a shit ton of money instead of cheating. And we really aren't relying on these very minute economic things but it's also.
00:19:47.116 - 00:19:59.466, Speaker B: Like part of the reason that you could lower fees in a proof of stake system is also that you don't need these mining farms anymore. You can run a validator node on a VPs for $3 a month or like on your home computer.
00:19:59.568 - 00:20:30.790, Speaker C: That's exactly right. I guess there is still costs to becoming a miner because you need to acquire all the tokens but generally the costs, I guess are lower. There's much lower friction to become a minor. So that's exactly right. So we've gone through now just this very simple model for how we can think about incentives and what sort of popped out of it were the two underpinnings for proof of work and proof of stake. And you mentioned the carrot and the stick and these really are the underpinnings of the two different strategies and there is really nothing more to it.
00:20:30.860 - 00:20:45.430, Speaker A: So we've just talked about these incentive models but what is the act of modeling really like? What is that? Is it just writing things on whiteboards? Is it testing things out? I'm curious when you're creating these models, are they only theoretical? Do they live somewhere?
00:20:45.590 - 00:21:27.282, Speaker C: I wish that we could use normal game theory to think about these systems. You can usually just use game theory when the action space is known. If you don't know all the actions you can make, you can't really make any conclusions about the system. So just off the bat, this means that designing these systems is usually a bit more fuzzy. And then beyond just setting up frameworks and shooting out ideas, there are these instances where you also need to do live testing. So in some of these systems you may have sort of these magic variables, these magic numbers that sort of help the system to perform and there's always this question about what those should be and normally you would want something live to be able to test that. And Frederick mentioned something before which is sort of the block gas limit.
00:21:27.282 - 00:21:35.782, Speaker C: If that didn't exist or was set completely differently, you may get different properties, which is why it's so useful to have a live system where you can just test these things slowly.
00:21:35.846 - 00:21:58.066, Speaker A: This actually speaks a little bit to an earlier episode we did with Ethan from Cosmos about testnets and trying to incentivize actors on Testnets where they're using tokens that don't have any value, how to get them to act in any way like they would if you could actually act maliciously and earn something. That's why I'm curious about how you would actually model this.
00:21:58.168 - 00:22:22.186, Speaker C: No, it's extremely difficult to do and to get people to actually behave like they would in a live setting. And the funny thing is that some attacks, and this is usually attacks for bitcoin, are actually tried on smaller chains like Litecoin. And you can sort of see people trying to pull these things off just as a testing thing to build up sort of their arsenal for later stuff.
00:22:22.368 - 00:22:31.150, Speaker A: That's so mean. You just use some competitors blockchain and be like, let's destroy it. We're going to learn everything we can.
00:22:31.300 - 00:23:02.422, Speaker B: So we're talking about these incentive structures. Proof of stake has been mentioned a little bit, but we have a whole episode previously with Robert Havermeyer on consensus algorithms and consensus systems in general, and sort of what properties you look for them. And if you want to deep dive into that, I recommend listening to that episode. But maybe it'll be good to recap a little bit about what is consensus, what are we looking for, and then we can dig into a little bit more on the proof of stake side.
00:23:02.556 - 00:23:38.370, Speaker C: Sure. And that's a good way of doing it too, just so we get some of the terms out of the way. There are a lot of consensus protocol specific terms that can be confusing, so it's usually good to just walk through them. A pretty simple way to think about consensus systems is that you essentially just have a bunch of machines that are sending messages to each other in some way. And the goal of this whole system is for them to sort of agree on some value. And the simplest way to think about that is just that they're agreeing on a bit. There are variants of this where the machines are actually generals that are sending messages back and forth to decide on whether to attack or not.
00:23:38.370 - 00:24:19.422, Speaker C: But it's essentially the same thing. They're deciding on some value. And when we're looking at consensus protocols, we're essentially interested in three key properties. So the first one is whether or not the system is synchronous or asynchronous. This really only has to do with whether or not messages arrive within a certain time frame. So you can think about your own computer or your own phone as a synchronous system, there are separate components that talk to each other, but we have some guarantee that the signals are going to arrive at some point. Whereas something like the Internet is an asynchronous system, there are all these machines that are connected to each other, but when you talk to a server or to another machine, it's essentially a black box.
00:24:19.422 - 00:24:24.030, Speaker C: You're sending away a message and you have no idea when or if it's going to come back.
00:24:24.100 - 00:24:25.726, Speaker A: And if the server is online.
00:24:25.908 - 00:25:01.994, Speaker C: Exactly, that's the key property. When you send away a message, you actually don't know whether the server is taking a really long time to respond or whether it's just gone. So that's property number one and property number two is availability or liveness. And it's fairly straightforward. It's that all these nodes or all these machines in the network eventually decide on a value and then the last one is essentially correctness or safety. And the property there is that these machines decide on the same value. Or rather two honest machines are not going to be convinced that two different values are true.
00:25:01.994 - 00:25:39.530, Speaker C: So these are sort of the key properties that you have in these systems. There are some famous results that people may have heard of that we could go through very quickly now. And the first one just has to do with fault tolerance. So some people may have heard the term like Byzantine fault tolerance being thrown around. Normally this is just called like BFT and the fault tolerance just refers to the portion of machines that can be faulty or trying to cheat before the consensus breaks down. So it turns out that in a synchronous network, half of the machines can go offline before things break down and in an Asynchronous network, only one third of the machines can go down.
00:25:39.680 - 00:26:13.474, Speaker B: I just want to add in that the Byzantine part is important because it means that we can tolerate any type of fault, including like maliciously generated faults. So there's a lot of consensus algorithms like Raft, et cetera, that are fault tolerant to basically machines being offline and that's the only type of fault they can tolerate, but they can tolerate it perfectly well. But the Raft algorithm can't tolerate a machine maliciously or like cooperating with other machines to try to convince the rest of the network that some other value is true.
00:26:13.592 - 00:27:08.274, Speaker C: Just quickly on consensus protocols, continuing on the recap, before we can do a bit of a deeper dive into proof of stake, there's this other result that is also pretty famous that people may have heard of, which is called the FLP Impossibility. FLP doesn't stand for anything, it's just the names of the authors. But essentially it says that if you have an asynchronous network, right, so this would be like the Internet or like Bitcoin, that network can't be both live and safe. So this is highly problematic. So essentially what it says is that you can't have a guarantee that the. Machines are eventually going to come to a conclusion and they're going to come to the same conclusion, which is highly problematic. And the trick with something like Bitcoin is that it's actually not a safe or correct system and that there is no guarantee that all the nodes on the network are going to have the exact same view of what's happened.
00:27:08.274 - 00:27:36.318, Speaker C: And this is why you're waiting six blocks or something like that to just have a pretty high guarantee that your view of the network is probably the same as other people's. But this is the trick that Bitcoin pulls to get around this FLP impossibility. And normally people say that there was some big problem in computer science that was solved. This isn't entirely true. Essentially there's just this tiny cheat where you remove the safety of the system and you get probabilistic safety instead.
00:27:36.404 - 00:27:42.538, Speaker A: Probabilistic. So the true safety would mean like 100% of nodes would decide on the same value.
00:27:42.644 - 00:29:06.234, Speaker B: Finality is in blockchain terms. So that's actually an interesting point in a lot of the sort of innovation, quote unquote innovation in consensus algorithms and people invent new ones or variations of consensus algorithms, they usually play with these properties. So there might be a synchronous one that matches all of it, but then you have all machines need to be online always kind of thing that's like a traditional PBFT tendermint like setup. But then you have like Honey Badger BFT, which is asynchronous, but then sort of plays with the other factors. So you can have probabilistic finality, but you can also have probabilistic liveness, so you can say it will come to the correct decision if it comes to a decision. Vitalik tweeted once a poll asking what fault tolerance would you accept in your blockchain? And it's like one block failure in every thousand blocks, one in every million and never, I would never accept any faulty block at all. And you cannot design a system that would never accept any faulty block and yet like 90% voted that option systems you have to think about this of what is my fault tolerance actually and when will things break?
00:29:06.352 - 00:29:15.658, Speaker A: So one of the topics that we want to touch on is proof of stake. And I'm curious to see how all of this can be incorporated into proof of stake modeling.
00:29:15.754 - 00:29:54.646, Speaker C: The general setup is fairly simple. In proof of work mining, you're essentially voting on blocks with your hash power. You can choose different histories to sort of build on and to vote on. And the reason you choose the one that is most likely going to end up being right is because there's some cost to voting and proof of stake really follows the same properties. You vote with something, it happens to be this sort of on chain token that is valuable. There's some cost to voting because you can only ideally vote on one of the histories at once and then you sort of end up with the same properties. So that's like the general overview of proof of stake.
00:29:54.646 - 00:30:35.794, Speaker C: There are some normal straw man arguments that are pulled out fairly early on. And the first one is that even though you're parking money in one of these systems to be able to vote, there's not actually a cost to voting because I park a million dollars for a day to be able to vote during that day. At the end of the day, I still have my million dollars. So this counterargument is that if you park a million dollars for a day, the cost of doing that vote is not actually a million dollars, it's just the opportunity cost on that million dollars. So you may have been able to get some sort of returns from the money by doing something else. So essentially the cost of voting then for that day is what you could have done with the money. So that doesn't really hold up as an argument.
00:30:35.794 - 00:31:16.974, Speaker C: And then there are these other sort of simpler arguments that are pulled against proof of stake as well. Like, it completely has different assumptions because it requires there to be an onchain token that's valuable that you can lock up. And it's true that it requires this bootstrapping event where there is no cost to voting and the system doesn't really work until the tokens are valuable. But the truth is that something like Bitcoin that does not start with this pre allocation or presale relies on the same thing. There are no rational miners that are going to join the system until the token is valuable. We touched on this briefly when we talked about rationality assumptions. Bitcoin did rely on probably a year, a year and a half worth of irrational mining.
00:31:17.022 - 00:31:19.110, Speaker A: People were mining even though there was no value.
00:31:19.260 - 00:31:20.006, Speaker C: Exactly.
00:31:20.188 - 00:31:21.478, Speaker A: Seemingly no value.
00:31:21.564 - 00:32:07.000, Speaker B: Yeah, I mean, that's the typical community bootstrapping problem. Like if you wanted to start a new blockchain today, you have these two options of either doing proof of work or proof of stake. Proof of stake, you need to do some sort of ICO and build up a bunch of value and hype and do this whole thing. But if you wanted to start a proof of work chain, it's actually completely nontrivial to get this going. Like, how do you get security for this chain when you don't have a community and you don't have value? You actually have to build up this community of miners and there has to be a significant community of miners to actually build security. And we see this in practice. Like take a security analysis from almost anyone on the coin market cap, like top ten blockchains or like top hundred.
00:32:07.000 - 00:32:24.106, Speaker B: Vast majority of them are super easily attacked. They just don't have security. Yeah, I don't buy that argument either. That it's hard in proof of stake to build initial security. That's hard in any system. It doesn't matter where it is.
00:32:24.208 - 00:32:39.440, Speaker A: Yeah, I'm thinking about that beginning when you're trying to get people to mine actually, it's not only that you need them to actively do this, they're going to be spending money which will not, I'm imagining would not be matched by any block reward possible at that time.
00:32:39.970 - 00:32:55.330, Speaker B: It depends on a lot of factors. But I mean it's the same thing. Like either you spend money to buy a token in a presale ICO type thing or you spend money to buy hardware to mine a proof of work chain that is not secure yet.
00:32:55.480 - 00:33:13.898, Speaker A: That beginning part of a proof of stake system that actually is super fascinating. Like when you start a proof of stake system the token would need to have value. If it doesn't have value and you just start staking these worthless things. I guess it's kind of like the testnet example. No one's going to act in any way correctly because they don't care.
00:33:14.064 - 00:33:39.378, Speaker C: Exactly. The good news is that it turns out that there are many ways to make something on chain valuable. The naive solution is just to simply become a market maker and literally buy and the sell the token at a certain price if you really wanted to. But then you completely lack any sort of organic group that is going to join and provide useful resources later. So that's probably not what you want to do.
00:33:39.464 - 00:33:41.378, Speaker A: It's sort of uncredible in a way.
00:33:41.464 - 00:33:46.934, Speaker B: The correct solution is to provide some utility so people actually want your token and want to use it.
00:33:46.972 - 00:34:26.114, Speaker C: No Frederick, that's crazy. No. So this is like the normal sort of straw man arguments against why proof of stake could work. There are though actual attacks that are very thorny and problematic that are also used as arguments against proof of stake. But most of these have been sort of resolved and the sort of first one that's fairly well known is the nothing at stake problem. And the idea there is simply that what you're doing as a miner is that you're essentially voting on one of a number of possible histories. So let's say that there are two histories that you could sort of vote on.
00:34:26.114 - 00:35:24.354, Speaker C: Well in both of those histories or in both of those blockchains you will have your deposit of a million dollars worth of something. It's fully possible that either of them becomes canonical. So why don't you vote in both? And this is the nothing at stake problem and it's related to this argument that actually it's free to vote in general and this was a problem. But the solution is you just add this component to the protocol where machines can essentially tell on each other and sort of rat each other out and say hey, I detected a vote at the same block height on two different histories. And then that becomes one of the conditions that causes you to lose your stake. And in ethereum there is this concept called an uncle which is a block that was mined at the same height and it can sort of be included and give you some tiny reward for at least doing some work. And then these blocks that you vote on in at least Casper at the same height, they're called Duncles or dark uncles, which people may have heard.
00:35:24.354 - 00:36:00.394, Speaker C: So that's the nothing at stake problem. Another problem that is also thorny but doesn't have a clean solution is the long range attack problem. And the idea there is that let's say you go back to the beginning of the history of the chain and you either are one of the people that has a lot of tokens and therefore a lot of voting. Power or you simply go to the person that did have those tokens in the beginning and you buy their private key and you say you can continue on the canonical chain. I just want your private key to be able to act as a voter on block zero. And then you essentially create your own history, you create your own blockchain. So you sign up as a miner.
00:36:00.394 - 00:36:51.882, Speaker C: Your miner is the only one that believes in this history and you start voting and creating blocks and then you broadcast this entire new blockchain that you've created to the world. And the issue is that for a new node or new miner that joins the network, they essentially have a choice. Now they can either join the canonical one and be with everyone else or they can join your chain. The problem is that they have no good way of telling the difference. For example, in Bitcoin there is a similar problem where theoretically there could be another chain that has a bunch of proof of work done on it and it exists as this alternate chain that you could choose to believe in. And this is actually what the 51% attack is, right? And the sort of choice rule that exists in Bitcoin is to just follow the chain with the largest proof of work. What do you do in proof of stake? You have these votes, they both look legit.
00:36:51.882 - 00:37:03.938, Speaker C: How do you choose between these two chains? So this is a problem and the solution is essentially to use some sort of outside information to make that choice. So this could know you go to.
00:37:04.024 - 00:37:06.306, Speaker A: Something'S published on Twitter, it could be.
00:37:06.328 - 00:37:44.714, Speaker C: Vitalik tweets a checkpoint, or it could be the Ethereum Foundation runs a beacon. It really could be anything. So you need to use some information the first time you start your node to figure out what history to sort of believe in. The argument now is that oh, this breaks the assumption that we had about the system in Bitcoin land. All I need to do is to look at the one with the highest amount of proof of work on it and then per definition, that is the canonical chain. Whereas now you've added this new assumption where I need to go to Vitalik's Twitter to figure out what Ethereum is. So this is a problem, but in reality it's not a breaking problem, it's just an assumption change.
00:37:44.714 - 00:38:08.122, Speaker C: And there's this pretty neat argument which is that, hey, wait a minute, even if you are joining Bitcoin or something as a new node, you're also using outside information. You're going to get your Bitcoin node software from a specific website that you're going to search for on a search engine. So you always use other sort of information to figure out where to start anyway. So it's not the worst sort of thing in the world.
00:38:08.176 - 00:38:12.090, Speaker A: I mean there you run into the problem of like phishing sites.
00:38:14.430 - 00:39:21.358, Speaker B: We already do this in Ethereum, so both geth and parity hard code and header chains to basically super quickly like sub ten second sync lite clients. So I mean, this is already done, it's not a big deal. I think a cool sort of neat solution to think about is and I see a lot of systems popping up like this and what Casper initially was intended to be but sort of reversed. So Casper on Ethereum was supposed to be a proof of work chain and they used a proof of stake system to notarize every hundred blocks or something. You can flip that on its head and have a proof of stake system where every 100 blocks or every thousand blocks even, is sort of notarized by a proof of work block. And then to have a long range assuming the chain is long enough to have a long range attack, then you still have to produce a bunch of proof of work making it probably intangible. Yeah, I think there are some neat, like actual technical solutions, but practically like you're saying, we trust node developers anyway, so might as well hard code it in.
00:39:21.444 - 00:39:26.818, Speaker A: You were mentioning miners not validators. Why were you saying that?
00:39:26.904 - 00:39:46.806, Speaker C: Oh, sorry, I was just using the terms interchangeably. I think miner is a pretty neat sort of broad term. Different systems use different terms for their proof of stake miners, so it could be staker or validator or even baker in Tezos for some reason. So we have all of these different terms.
00:39:46.908 - 00:39:57.338, Speaker A: So I think what we want to talk about is proof of stake. I want to go back to that incentive idea and just very quickly define what are the carrot and sticks in a proof of stake system?
00:39:57.504 - 00:40:38.770, Speaker C: Absolutely. So it's not a strict stick, it's more like the miner joins with something valuable, usually some sort of on chain token that they park and then if they cheat, they lose that token. So there's the stick in that there's something at loss and then the carrot is not really relied on in proof of stake systems as much. There is of course still a reward for producing good work or like doing what you're supposed to, otherwise you wouldn't join in the first place. If you're not getting paid for it. But the point is that we're not relying on the carrot to create a cost to cheating, we're relying on the stick to create a cost to cheating.
00:40:38.850 - 00:40:45.066, Speaker A: And is the benefit or the carrot is that way less in proof of stake usually than proof of work.
00:40:45.168 - 00:41:31.406, Speaker C: So just using the model that we went through, it should be able to be less because before there were essentially two components to the carrot. One was the price of the service being delivered. So we need to pay the machine to be there and do something. And the other component was this extra bonus that it gets just to give the system some security and we can essentially skip this extra bonus. But what we're really doing is that we're just shifting who pays for the incentive. So in proof of work style systems where we're using these block rewards, the users or the token holders are the people that indirectly pay for the incentive. And now we've changed the setup a little bit and we've added this huge extra burden essentially for the miners.
00:41:31.406 - 00:42:15.394, Speaker C: They need to put up these massive security deposits, they need to go and buy massive amounts of tokens. So there's now a cost for them and not the users. So we've really shifted just who bears the cost for the incentive from the users to the miners. And that's really all that's happened. The benefits of proof of stake really lie in other properties and other design goals. For example, now that we have on chain tokens that create this cost of voting, we can slash them remotely. Whereas in proof of work systems there is no way to make your mining farm fail or I guess normally be punished.
00:42:15.394 - 00:42:51.474, Speaker C: Be punished or like go up in flames or something like that remotely. So the difference is that the miners pay for the incentives instead of the users. But the benefit comes from other properties that we get by building them this way. With these attacks and strawman arguments out of the way, it's also important to go through sort of the pros of proof of stake. There are actually massive benefits to these systems which is why there's so much interest in them and sort of interest in moving away from proof of work eventually. And the goals are fairly straightforward. The first one is usually called asymmetric security and cost.
00:42:51.474 - 00:43:52.674, Speaker C: And the idea there is that in proof of work systems, like we've talked about, your security is highly related to the amount of money you pay to the miners, right? So your block rewards for this extra bonus is going to essentially define your security. Whereas in proof of stake you essentially get asymmetric security and cost. Because the miners put up these massive security deposits, the users only need to pay tiny amounts of money to buy units of services. But we can cause massive damage to the machines simply because we can slash them and punish them remotely. So that's the Asymmetric security property, and this is actually a very important one. There are arguments that eventually when the Bitcoin block reward is low enough, the transaction fees won't be high enough to incentivize any amount of hash power to join the network, which means the security may ultimately falter. Based on that, if you can sort of escape that whole setup with inflation, it's a lot neater.
00:43:52.674 - 00:44:37.682, Speaker C: So that's like the first design goal. The second design goal is slightly less obvious, but it's essentially that you have lower economies of scale with proof of stake, which hopefully leads to less centralization. So the insight there is that there is friction to setting up a mining company, there is friction to getting a land permit and finding cheap electricity and buying like $10 million worth of Asics. And because there is friction to all these steps, there are essentially economies of scale. If you figure out how to do it, you're going to do it even more. And it's very difficult for new people to join. And this just essentially makes a topology where there's a small number of very large miners, ideally in a proof of stake system, it's much cheaper to join.
00:44:37.682 - 00:45:13.554, Speaker C: There's no difference between running a raspberry pi in your closet or something like that, versus running some other sort of super professional rig somewhere. And then all you should have to do is to go to an exchange, buy the tokens, and then you should be set to go. So that's another sort of design goal. There are things that may counteract this and we'll get into this later when we talk about depos or delegated proof of stake. But at least this is a design goal in proof of stake only. And the last sort of design goal is to just essentially have lower negative externalities. I'm sure a lot of people in the audience are aware of proof of work.
00:45:13.554 - 00:45:49.850, Speaker C: Mining consumes a lot of energy. Essentially you could argue that this is extremely wasteful. I've heard arguments both ways where like actually in a proof of stake future, where we're locking up billions or hundreds of billions of dollars worth of value in these systems that's also wasteful because you could use all that money to do something productive in the outside world. But at least beyond comparing these two and trying to figure out which one is the biggest culprit, at least we empirically see that Bitcoin and other proof of work systems consume a lot of electricity and it would be neat to get away from that.
00:45:49.920 - 00:45:55.710, Speaker A: That's basically it would be either you're going to waste electricity and energy or you're going to waste capital.
00:45:56.050 - 00:46:15.610, Speaker C: Exactly. And it turns out that capital buys electricity, so they may actually be the same thing. So that's just quickly on the design goals of proof of stake. As we went through with some of the attacks, like long range attacks and nothing at stake, it is tricky to implement these systems. And a lot of these questions are actually still unsolved.
00:46:15.710 - 00:46:44.622, Speaker B: We're talking about proof of stake. There are some proof of stake systems in practice, but most of them today or all, I'm not entirely sure, are what's called DPOs or delegated proof of stake systems. And they've gotten a lot of flack, but it's also unclear if there's any other type of system. There's not many proposals that don't involve some sort of delegation. So what is delegated proof of stake, and can we avoid it?
00:46:44.676 - 00:46:46.026, Speaker A: Yeah. Is it inevitable?
00:46:46.138 - 00:47:35.646, Speaker C: You're entirely right, Frederick, in that a lot of these systems are either delegated proof of stake systems out of the box. But I would even go further and say that if you have a full VM essentially, and your blockchain looks like Ethereum and you can write smart contracts that can do enough things, you can actually turn a normal POS system like Ethereum Casper or something like that into a delegated proof of stake system. And this is part of what we've been working out on at Vest. You can essentially build the delegation scaffolding into Ethereum by building all these smart contracts that determine how is a delegate matched up with a machine, how do the tokens travel, how are they split when the work is complete, et cetera, et cetera. So my argument would be that it's probably pretty inevitable that most POS systems become delegated POS systems, even if they.
00:47:35.668 - 00:47:37.850, Speaker A: Didn'T bake that into the protocol originally.
00:47:37.930 - 00:47:40.766, Speaker C: And it may not be that bad of a thing.
00:47:40.868 - 00:48:02.918, Speaker B: I'll also add here a little bit that you mentioned smart contracts. And if there's a smart contract platform well, I'd argue even if there isn't a smart contract platform, delegation is probably inevitable, because what we see today with Blockchains is that most people are perfectly happy giving away their private keys to corporations, so there's no reason to believe that they wouldn't do that in the future as well.
00:48:03.004 - 00:48:31.514, Speaker C: That's exactly right. So the naive way of doing delegation, I guess, is to set up Axel Mining LLC and then have people give me money and have some sort of out of band contract that determines what happens with the money, and then I stake with it. That's entirely right. It's just that the friction of doing that is a lot higher. And if you have an Ethereum style VM, then we can essentially take all those interactions and just put them into solidity, and then all of a sudden it's a lot easier, at least automated.
00:48:31.562 - 00:48:43.742, Speaker B: A lot of people argue that coinbase is easier than whatever other wallets there are for Ethereum. So it may actually be the case that the corporate route is the easier one to stake.
00:48:43.806 - 00:49:30.382, Speaker C: We'll see, I guess. But essentially the change that we make in the POS system when we allow delegation is that we allow people that are not running their own machines to essentially allow machines to work with their tokens so you have a choice of a bunch of machines to delegate to. If you like one of the machines and you like its terms you can essentially just allow it to act as if it had those tokens at stake on its own. The idea is that you would get a share of the earnings of that machine. So the first sort of thing that sort of pops out here is that hey, wait a minute. The way we incentivized the miner or the machine originally was that we had to put up something at stake and now it's working with other people's money. What incentive exists now for it to act correctly? And the answer is that we can either use our carrot or our stick.
00:49:30.382 - 00:50:26.110, Speaker C: We can either rely on the machine just getting a large portion of the earnings of the work so that there's some stream of earnings that it doesn't want to lose out on. And for the same reasons that we've discussed before it's probably better to just have the machine stake itself. So okay, we allowed people to delegate to a machine and then we concluded that in order for that to work we probably want the machine to stake something of its own. But then the question is if I have 100 Ether and I get matched up with a Casper miner how much does the Casper miner put up? And the answer is that it could really be anything. But it's arguably riskier for a person to delegate to a machine that has one Ether at stake or whatever the minimum is versus delegating to a machine that has like a million Ether at stake. So it turns out that the ratio between the machine stake and the user stake is actually just the risk that the user is taking. And this is pretty neat.
00:50:26.110 - 00:51:10.494, Speaker C: So that's like the first sort of thing that we notice. Beyond that there are these crazy new attacks that come out of delegated proof of stake systems. I'll sort of give you one of them. What we care about when we look at the miner and its behavior is essentially what it can gain and what it can lose. Well, what it can lose is essentially its own stake and it doesn't really get hurt if it loses other people's stake. And you could argue that like oh, you may have reputation but not assuming any of those things it essentially just gets hurt by whatever it puts up on its own. But what can it gain? Well, it turns out that there's this insane attack that's similar to the plot of an old James Bond movie called Goldfinger.
00:51:10.494 - 00:52:16.022, Speaker C: And in the James Bond movie there's this very evil and rich man called Goldfinger who has a lot of gold and his plan is to go to Fort Knox in the US. The movie was made in the 60s or something so that's the time when all the other countries also stored their gold in Fort Knox. His plan is to nuke Fort Knox, irradiating the gold supply of the world, making it unusable, therefore deflating essentially gold as a currency and then massively increasing the value of his own gold. So there is a version of this attack in Delegated Proof of Stake, where essentially an evil and rich miner like ETH Finger or something like that, has a shit ton of ether. And then he takes a tiny portion of that ether, let's say one or 5% or something like that, signs up as a miner and then broadcasts really good terms. So he goes on a delegation marketplace or something like that, which by the way, is what we're building. And he broadcasts really good terms and says I'll give you 80% of the earnings and I put up a lot of money.
00:52:16.022 - 00:52:35.934, Speaker C: My 5% is worth a lot of money, so it's pretty secure. And then ETH Finger broadcasts his rig and says that it's a good setup, I have redundant electricity, and a lot of people delegate to Ethfinger. He gets, let's say, all the other ether in the world delegated to him. He becomes Fort Knox and then what can he do?
00:52:36.052 - 00:52:37.514, Speaker A: Well, he nuke himself.
00:52:37.642 - 00:53:11.638, Speaker C: Exactly. He can nuke himself. So he can choose to cheat inside Casper and be slashed, be slashed along with everyone else's money. This destroys all the other ether in the world. And then what's left? Well, what's left is the 95 or 99% of ether that Ethfinger chose to just keep in a secret stash so he can effectively deflate the currency itself and make a shit ton of money. So this is an entirely new attack vector that exists simply because we allowed people to delegate to him. And it's pretty worrying.
00:53:11.734 - 00:53:23.406, Speaker A: I mean, this is an amazing story and case, but doesn't Delegated Proof of Stake already have problems? Just in that you're delegating to individual.
00:53:23.508 - 00:53:37.682, Speaker B: Node miners actors, you're recreating this centralizing force instead of having it be economies of scale. It's sort of the delegation aspects, recentralizes things.
00:53:37.736 - 00:53:51.654, Speaker A: Again, Delegated Proof of Stake always struck me as like a popularity contest or something that could be very easily manipulated without even doing these crazy scenarios, just having political actors saying what people want to hear.
00:53:51.852 - 00:54:27.778, Speaker C: This is probably true and it is also probably worrying. The argument there is another way to frame that is let's say Coinbase ran a staker and they broadcast themselves in some neat way. Would you delegate to them? Probably so. What Frederick mentioned is also entirely true. We had this design goal in Proof of Stake to have less centralization than before by having lower economies of scale. And then we've essentially reintroduced those. So these are like two forces acting against each other.
00:54:27.778 - 00:55:30.806, Speaker C: There's less friction to setting up a minor, but for all the delegates, they would rather go to the machine that other people have delegated to and then just going back to the goldfinger. ETH finger attack. There are systems that try to partially patch this and they say that okay, if a user has delegated to a minor and the miner cheats, the miner can't actually slash the user funds. So one example of a system like this is tezos, where there's essentially an amount that the miners can accept from other users, where even if the miner cheats, it can't slash the funds. And then if you're above that amount, it's called that you're overdelegated the issue with introducing that is that, yes, you kind of half patch this ETH finger attack, but all of a sudden there's this new attack where I, as a minor join the system. I have some number of tezzies. I take 10% of my tezies and I sign up as a staker or a baker in their system and I take the other 90%, I send them to a new address and delegate to myself.
00:55:30.806 - 00:56:05.906, Speaker C: All of a sudden I've protected myself from my own potential misconduct. And this is absolutely in the interest of a rational minor because even if you're now protected against your electricity going off or something like that, because those 90% of funds are from the system perspective, it looks like it's someone else's. So they're protected. And effectively what it means is that there's less value at stake, which lowers the security of the system itself. So there are always these trade offs and other attack vectors that pop up.
00:56:06.088 - 00:56:22.006, Speaker B: On that note, there is a pro to having delegation as well, which is that you increase the amount of stake and therefore increase the amount of security of the network. So it's not only a loss scenario, like there's an actual upside, right?
00:56:22.188 - 00:57:19.298, Speaker C: I'll give you two sides to that upside. So from the perspective of the machines, if you allow delegation, then essentially you're lowering the cost of becoming a minor or becoming a big miner. So let's say that you could even borrow money from other people to overcome some sort of minimum, right? This just serves to make it easier to sign up as a machine. And the sort of ideal case there is that I just open my laptop, I run a piece of software, I broadcast that I run a certain version of the software, people believe in me, and I just get automatically delegated some funds and I'm a part of the network. And then from the perspective of the users, the benefit is exactly what you said. And a way to frame it is that the cost of joining mining for users that don't want to run their own machines has also gone down. So the cost before was like the cost of figuring out how to run a laptop or Raspberry Pi or something like that, which is like a software cost essentially.
00:57:19.298 - 00:57:27.318, Speaker C: And it's also the cost of keeping the software updated. And we've lowered that cost to the cost of sending one transaction to the network.
00:57:27.414 - 00:58:54.950, Speaker B: I think, as usual, when it comes to a lot of this stuff, and I think, especially here, the devil is in the details. And if we take the argument that delegated proof stake is inevitable, which I kind of agree with, then it's a matter of how do you delegate? What factors do you take into your system? What are the exact parameterizations of what you're doing, if you can increase the friction enough that you try to counteract some of these things? As an example, the super naive delegated proof of stake is that you choose the validator proportional to how much stake they have or have delegated to them. So if you have some super popular guy that has 90% of all stake, he gets to vote on 90% of blocks, or, like, he gets to produce 90% of blocks and therefore has total control of the network. So instead of allowing that, you could say, well, we give everyone equal chance to produce blocks, but you get returns proportional to the amount you've staked. Well, now you're not that much better off because you have no civil resistance than the system. So you can just start up 100 mining nodes and spread out your load and still expect to get 90% of blocks produced. But it's so much harder to do that than it is to just post your server address on a forum and get 90%.
00:58:54.950 - 00:59:39.794, Speaker B: So maybe that small Tweak is enough to try to prevent this. Enough. And every system that is taking this seriously is trying to introduce some system like this where Dfinity has this thing where you can't stake more than X amount and they encourage people to create multiple identities. And then they have this huge trust network that if I delegate to a friend and then he delegates to someone, then I delegate to whatever he delegates to. And so they hope to create this sort of neural net that automatically load balances all the stake delegation. We'll see if it actually works out. But people are working on think, yeah, like I said, devil is in the details.
00:59:39.794 - 00:59:44.360, Speaker B: What are you actually like, what's your exact parameterization of this? I think that's important.
00:59:44.730 - 00:59:48.498, Speaker A: So, Axel, I want to say thanks for joining us on this podcast.
00:59:48.594 - 00:59:51.190, Speaker C: Thank you so much, both of you. This was a lot of fun.
00:59:51.340 - 00:59:53.602, Speaker B: And to our listeners, thanks for listening.
00:59:53.666 - 00:59:54.290, Speaker A: Thanks for listening.
