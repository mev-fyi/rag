00:00:06.890 - 00:00:12.202, Speaker A: She's talking today about Tiger, a dark forest for composable private applications.
00:00:12.346 - 00:00:27.842, Speaker B: Take it away. Thanks. So, yeah, I'm going to talk about Tiger. And first of all, I'm going to introduce you the Tiger team. It's like all people working on making Tiger.
00:00:27.906 - 00:00:28.146, Speaker C: It's.
00:00:28.178 - 00:00:46.220, Speaker B: Simone. Alberto. Joe Shuyang, me and Vasily in the Dark Forest. Of course. So now back to Tiger. First of all, what problems Tiger solves? So there are some projects that provide counterparty discovery and oh God.
00:00:51.150 - 00:00:52.060, Speaker C: I see.
00:01:00.370 - 00:01:02.080, Speaker B: Okay, yes.
00:01:03.330 - 00:01:04.080, Speaker C: So.
00:01:14.010 - 00:01:53.140, Speaker B: There are projects that provide shielded state transitions, like Zexi. So you can do arbitrary transitions but privately. And Tiger kind of is no, okay, I'll just continue talking. And Tiger is kind of in the intersection of these projects. But also on top of that, Tiger provides private account abstraction. Might sound like complicated, but private account abstraction basically means that users can choose how to authorize their transactions, like signature or whatever they want. They can specify it.
00:01:53.140 - 00:02:46.774, Speaker B: So for people who are familiar with anoma, what is the relationship between Tiger and anoma? Well, Tiger is a privacy preserving part of anoma that takes care of shielded state transitions, but it also can be used as a standalone component with separate storage and Tiger overview. This is like the word is slide of the presentation, but it's not going to be like that. But if you need one slide overview what Tiger is. It's this. So starting from the first point, it's an operating system for distributed applications as the talk description says. So it means that users of Tiger can build applications on top of Tiger. And Tiger makes sure they work correctly as they should.
00:02:46.774 - 00:03:10.960, Speaker B: Just like normal operating system has applications, tiger is shielded, meaning that it provides both data and function privacy. Yeah, private account abstraction, as I mentioned, is that users define their own rules and as many other privacy preserving projects, it's UTXO based. So every transaction on Tiger is.
00:03:12.930 - 00:03:13.342, Speaker C: List.
00:03:13.396 - 00:03:48.586, Speaker B: Of input and output nodes. So nodes will be like important thing in this talk. And Tiger also uses the notion of validity predicates, which are basically declarative smart contracts. So in more well known smart contracts, you just write down what to do and it just executes. Right. And in validity predicates, you describe the final state transition or the properties it should have. And Tiger makes sure that they are satisfied and doesn't really care how it's done.
00:03:48.688 - 00:03:50.860, Speaker C: So on the picture you can see.
00:03:52.270 - 00:04:25.106, Speaker B: Food style comparison of these paradigms. Tiger provides atomic state transitions of arbitrary complexity. Sounds complicated, but I'm going to talk about that more later. And it also has intent centricity. So it's built around intents, which are user preferences. Users describe what they want and Tiger tries to make sure their intents are satisfied with the help of counter party discovery layer. So matching intents is taken care of.
00:04:25.106 - 00:05:12.206, Speaker B: So this big slide is done. And now the map of the rest of the talk so there will be three main sections. First one is what are tiger applications? Next one is how to achieve atomic state transitions and the next is how tiger achieves data function privacy. First one tiger applications, very short one. So there is a shielded pool of nodes like utxml, right? And all of these nodes like floating around there. And applications are basically the things that tell users what is allowed to do with these nodes and what is not allowed. So an application contains two main parts, it's application state and application logic.
00:05:12.206 - 00:06:20.038, Speaker B: Application state is built from all of the nodes the application owns. An application logic is expressed as a validator predicate. So basically you can say that validity predicate of the application defines the application. So application it's a state and logic right now talking about atomic state transitions of arbitrary complexity, in case you don't know what does it mean to be atomic. So many systems, when they want to provide transactions of arbitrary complexity, they can't really achieve it in one transaction. So there are many many transactions, there is a sequence of transactions to achieve a certain state and this is not super good because the system can end up in the intermediate state if something goes bad and we don't want that. So in tiger we make sure that there is just one transaction that takes the state to the desired one and if something goes bad, it stays in the initial state.
00:06:20.038 - 00:06:52.782, Speaker B: So the worst case scenario is that nothing changes. So here's the recipe for atomic state transitions. It takes three components partial transactions, intent, application and solvers. But you don't know what it is right now. So I'm going to explain partial transactions. Well, first of all, what is a valid tiger transaction? Like a normal one, it has to satisfy two properties. First is that validity precuts of all involved applications are satisfied.
00:06:52.782 - 00:08:09.770, Speaker B: What does it make an application to be involved is that if transaction tries to change the node that belongs to an application, application needs to approve it. So we need to make sure that all changes are authorized by valid precuts of these applications. And the second one is that transaction needs to be balanced which means that well, all nodes, they carry some numeric value. In some applications it can be more natural like cryptocurrency application just value like five ether is like just five Ether, right? But in some applications it can be more abstract. But all nodes have value and a balanced transaction is a transaction is a transaction when for each application type the total value of input nodes equals the total value of output nodes. Well, it's a little bit more complicated than that, but I'm just emitting the details here, it's not that important. So valid transaction, valid repair cuts are satisfied and it's balanced and such transaction can be published on the blockchain.
00:08:09.770 - 00:09:28.790, Speaker B: So a partial transaction is just a normal transaction but it's not balanced and because it's not balanced, it cannot be published on the blockchain. But validator predicates must be satisfied, right? So the quick idea of what we want to achieve is that we want to combine partial transactions together until their total value is balanced and then we can publish it on the blockchain as a single transaction. So you can see on the slide that there are two partial transactions. Both have valid Pericard satisfied, but they're not balanced in the gray application type. But if we combine them together, it's all balanced and everything is nice, but we don't know how to do that yet. So the next one is the intent application. Intent application is just an application that works in certain way, right? So the user who wants the intent to be satisfied, they send the intent to the intent gossip network and they add intent application node to their intent.
00:09:28.790 - 00:10:21.640, Speaker B: And while this intent node exists, the transaction cannot be balanced because the amount of input nodes of this application doesn't match the amount of output nodes. We created this node but not destroyed. Right? So in the next step, Alice here it's, alice receives what she wanted and she can destroy her intent node and her part of the transaction is balanced. And once all of the users in this transaction destroy their intent nodes, the transaction is balanced and can be published on the blockchain. So basically, intent application makes sure that the transaction is not balanced until the intent is satisfied. And the last thing in the recipe is solvers. Solvers are basically the actors who make everything possible.
00:10:21.640 - 00:11:15.190, Speaker B: They build transactions, receive intents and merge them together. So to create atomic transaction of arbitrary complexity, solvers, when they receive partial transactions and partial transaction sets, what I call is like not really official name, they combine them together and update these sets of partial transactions until it's all balanced. And once it's balanced, they can publish it. So to summarize three things partial transactions, intent application solvers, partial transactions cannot be published on the blockchain. Intent application makes sure that transactions are partial as long as the intent is not satisfied. And solvers try to update this transaction until it's satisfied. So altogether it allows to create atomic state transitions of arbitrary complexity.
00:11:15.190 - 00:11:58.074, Speaker B: Yeah, here is the example of it. It might look a little bit scary, but it's not, I promise. So it's going to be three party barter. What I mean by three party barter is like when there are three users that want to get something and they have something but they can't really satisfy one of the others. So they need to kind of be combined in a cycle. They don't know about that yet, obviously they just publish their intents and want them to be satisfied. So in the first step, every user, Alice, Bob and Charlie, they create their first partial transactions and they also create intent notes.
00:11:58.074 - 00:12:46.626, Speaker B: Intent notes are marked like gray notes with colorful bottom. So you can see balances per each partial transaction on this slide because these transactions are not in the same set yet, so you can see it's not balanced, right? Then these partial transactions go to the first solver. The first solver receives only two of them so far and sees that, well, Alice wants a dolphin and Bob has a dolphin. So the solver naturally decides to give Bob's dolphin to Alice and because Alice's intent is satisfied, they can spend Alice's intent. Note this transaction. Like the total balance of this partial transaction set is not zero. So needs to be solved further.
00:12:46.626 - 00:13:26.850, Speaker B: So this goes to the next solver. And next solver also receives Charlie's partial transaction and the solver sees that Charlie wants a star and Alice had a star. So the solver sends the star to Charlie. And the same way Bob wanted a tree and Charlie had a tree. So the solver sends tree to and because everyone is satisfied here, all intent nodes are spent. Yeah, just like node. I'm saying spend, but destroyed and spent is kind of the same thing.
00:13:26.850 - 00:14:10.398, Speaker B: We can't really destroy a node but we kind of mark it as destroyed because it can't be used anymore just to avoid confusion. Sorry. So at this point, everyone is satisfied and the transaction can be published on the blockchain. So the final transaction contains this like three party barger. And the intent nodes are also kind of being created and spent, not like non existent, right? So that was the example of what I'm talking about, atomic state transitions. And the last part is the privacy in tiger. So I tried to create like a sketchy table of what we do and how we do it.
00:14:10.398 - 00:15:06.686, Speaker B: So we achieve both data and function privacy. And I divided data here into nodes and like, transaction data. So nodes means basically the node content, like the value, the application type, all of these things. We keep nodes encrypted, we use Verifiable encryption to make sure that they're decryptable and to establish the existence of the node. We use node commitments. So we publish node commitments and people know that some node just started to exist. And for transaction data, like what exact nodes are being transferred or like created, destroyed, who participates in a transaction, the amount of nodes and the values, the applications for that, we use their knowledge proofs to prove that state transition was correct without revealing the state transition.
00:15:06.686 - 00:16:11.282, Speaker B: And also hashes and blinding and other stuff like that to kind of keep everything private. And for function privacy, which refers to valid predicates because valeria predicates, they represent application function, right? And we want it to keep private, so we need to hide them somehow. So we use zero knowledge proof recursion for that. So basically the proof of a valid prey cut is hidden inside another proof. So like, the outer Verifier can't really know what's inside the valid preycut. The proven system we use is Halo Two, the one that is built by Zcash. And we considered many proven systems like Plunk based and many polynomial commitment schemes, but we decided to use Halo Two because it has some nice features, it supports recursion and accumulation.
00:16:11.282 - 00:17:02.454, Speaker B: And for us, recursion is important and has some helpful gadgets available, like elliptic curve operations or some hashes that we want to use. And a nice feature of it is that it doesn't have trusted setup. So when you have a lot of circuits, it's kind of like cool feature for us. So the current stage of Tiger is that there are still many details to be confirmed, so the details might be not decided on yet. But I would say the design is pretty solid right now. So if you want to check it and check how we use Halo Two and check how we do everything, you can go to the repo and check it. GitHub.com
00:17:02.454 - 00:17:07.990, Speaker B: Enoma Tiger and the future of Tiger is bright.
00:17:11.310 - 00:17:11.722, Speaker C: Yeah.
00:17:11.776 - 00:18:11.020, Speaker B: So eventually, I think we are planning to unify all of the execution environments, public environment, shielded environment, and private into single one, which is like long term plans. Right, because like, fully homomorphic encryption complicated. And we probably also want to have a closer integration with Fervio, which is another product we're developing. So we could prove correspondence between private state and the data encrypted to Ferreiro using zero knowledge proofs. So basically Ferro is for encrypting transactions so that you couldn't order them in a sneaky way and just not be biased. Right. So if we could prove correspondence between private state that is like fully homomorphic encryption and data encrypted to Ferro, it could be cool, right? Right.
00:18:11.020 - 00:18:30.020, Speaker B: So that's basically it. Thanks for listening. And if you have questions or you want to send me an email, send me an email, or if you want to, I don't know, talk to me. So, yeah, I'm open to discussions. Thanks.
00:18:36.070 - 00:18:37.060, Speaker C: I'll try.
00:18:37.430 - 00:18:41.474, Speaker A: All right, we can take one or two short questions. Anyone?
00:18:41.592 - 00:18:43.780, Speaker B: Yeah, questions.
00:18:44.790 - 00:19:00.090, Speaker D: Hello. So you mentioned intent application, intent notes. You said solvers checking whether an intent was satisfied, and you said something else again. But all this my question is simple. What is an intent?
00:19:00.910 - 00:19:05.254, Speaker B: In very simple terms, intent on like.
00:19:05.312 - 00:19:24.420, Speaker C: Technical level, it's a valid predicate. On less technical level, abstract level, it's just a way to describe for user its preferences. So, like, I want a car, this is my intent. You want a bitcoin? It's your intent. I write it down in a form of a validity predicate. Sorry, I was not talking into Mike. Sorry.
00:19:25.290 - 00:19:27.254, Speaker D: Okay, thank you very much.
00:19:27.372 - 00:19:28.040, Speaker B: Okay.
00:19:29.930 - 00:19:31.080, Speaker A: Any other questions?
00:19:34.970 - 00:19:52.018, Speaker E: So you briefly mentioned that partial transactions aren't balanced and that you have values attached to inputs and outputs. Are those scalars or is that a more complex structure? What is a value in that context?
00:19:52.214 - 00:19:54.490, Speaker C: Yeah, valuers are scalars.
00:19:54.650 - 00:19:56.000, Speaker E: Okay, thank you.
00:19:58.890 - 00:20:11.242, Speaker F: Hi, thanks for the talk. Are intents encrypted and if they are encrypted, how do the solvers know if it's balanced? Is there, like, some homomorphic encryption at play, or how does it work?
00:20:11.376 - 00:20:40.530, Speaker C: It's a good question, but there is a chance I heard it incorrectly. So the question is, intents are encrypted or not, right? Yeah. So intents are encrypted, but because you can't really satisfy intents of the other person if you don't know what they want, you need to reveal this information to solvers, but you don't have to reveal it to everyone, but you need to give them some information to be able to satisfy your intent.
00:20:44.890 - 00:20:47.974, Speaker G: So how do you selectively reveal your.
00:20:48.012 - 00:20:49.270, Speaker F: Intent to the solvers?
00:20:49.850 - 00:21:13.150, Speaker C: Well, you see, it's like, on a very abstract level, if my intent to buy a car and I write it in a valid preycut, I can tell a solver I want to buy a car or just open a validity precut to them. It's like, up to you how you do that, but they just need to know what exactly to do to satisfy your intent.
00:21:16.620 - 00:21:17.930, Speaker A: Any other questions?
00:21:20.460 - 00:21:47.920, Speaker H: So as far as I understand all this, a lot of the kind of finality of it lies in the validity predicate, but it seems like a lot is kind of open for interpretation as to how you get there. And that applies to things like intents, but also, like, the private account abstraction you were talking about. So I guess a question would be like, what type of guide rails are there or limitations on how you can get to a valid validity predicate?
00:21:50.420 - 00:21:53.984, Speaker C: I'm not sure I understand the question, to be honest.
00:21:54.102 - 00:21:55.988, Speaker H: Yeah, it can chat afterwards as well.
00:21:56.074 - 00:21:56.372, Speaker C: Okay.
00:21:56.426 - 00:21:59.670, Speaker H: Yeah, I don't know how to ask it.
00:22:01.020 - 00:22:01.770, Speaker C: Yeah.
00:22:03.580 - 00:22:04.730, Speaker A: Anyone else?
00:22:10.900 - 00:22:19.684, Speaker B: Do the provers make any intelligent choices about what intents they're trying to accumulate, or do they just accept any of the intents that get out there?
00:22:19.882 - 00:22:47.310, Speaker C: It's up to the solvers. We don't specify that. Solvers can define what they want, what they don't want. It makes sense for solvers to be kind of be related to some application. So, for example, me as a solver only accepting tents that are related to some, I don't know, Sudoka application, like people who want to solve Sudoku or know something like that.
00:22:48.000 - 00:22:48.910, Speaker B: Thank you.
00:22:51.520 - 00:22:53.150, Speaker A: Okay, last question.
00:22:54.400 - 00:23:20.970, Speaker G: Thanks for the presentation. I mean, don't want to get into the loop of encryption of intent and everything. We can keep on speaking about it, but I think that's what we're here for. But just to understand who would be kind of your competitor or colleagues in the space, just to have a better kind of idea of what you guys are doing and how do you mainly differentiate yourself? Probably have missed it, but I think it's a great question to ask it here.
00:23:21.660 - 00:23:26.964, Speaker C: Just to check I've understood it correctly. Who are the competitors of Tiger?
00:23:27.092 - 00:23:33.550, Speaker G: Yeah, kind of what you're doing, who kind of give the same value proposition and how do you differentiate yourself?
00:23:34.000 - 00:24:12.440, Speaker C: Well hard to say. Let me open a slide quickly. Ah, okay. Yeah. So there are projects that have private state transitions, which we also do, but there are also projects that provide counterparty discovery. But as I know, there are no projects that combine these features. So in that sense, Tiger is different from them, but I would say it's pretty similar to Zaxi in design.
00:24:12.440 - 00:24:17.610, Speaker C: And we also take a lot of inspiration from Zkesh, so it's know.
00:24:18.220 - 00:24:19.130, Speaker G: Thank you.
00:24:21.100 - 00:24:30.380, Speaker A: All right, I'd say let's wrap up this session. Let's thank Julia. Again. It's.
