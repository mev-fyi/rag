00:00:06.250 - 00:00:40.122, Speaker A: My name is James. I co founded Suma and storage, and I'm an advisor at a couple places. And right now I'm representing cross chain group, which is a trade group of cross chain engineers who work on various problems of cross chain communication and engineering on multiple chains. Okay, so we're here to talk about rollout, but first we're going to cover what a roll up is, because rollout is an extension of the roll up scheme. All right, so this is not a formal description. We're not going to go into any math. I'm going to talk about a sketch of a system I think it's possible to build.
00:00:40.122 - 00:01:07.970, Speaker A: This idea is about seven days old, so it's very high level. Don't yell at me. Too much for it. So, ZK rollup. I borrowed these slides from Barry Whitehat, who's a great person. ZK Rollup is a scaling scheme for public blockchains. It gives a constant factor improvement on throughput by putting data on chain and doing computation off chain.
00:01:07.970 - 00:01:47.200, Speaker A: So in ZK rollup, we have transactions that affect a state tree. We commit to the transactions and a proof of their validity on chain. So all of the transactions are published, but not evaluated by the blockchain. Generally speaking, this is what a rollup scheme does. It puts transactions on chain and evaluates them off chain. Zkrollup uses a validity proof, so we have a snark that every tree state transition was valid. All right, the alternative is optimistic rollup, which is I borrowed these slides from the plasma group, so they're completely different.
00:01:47.200 - 00:02:37.470, Speaker A: Okay, plasma group loves their emoji, so optimistic roll up, as opposed to providing a validity proof. We have the operator commit blocks of transactions that are not evaluated on chain because it's a roll up. And we wait for people to submit invalidity proofs, fraud proofs. So blocks are accepted optimistically. And if any off chain actor sees an invalid block accepted, they're responsible for providing a proof of that block's invalidity. In this case, that means that they instruct the main chain to evaluate the entire block of transactions against the state, which can get quite expensive. Optimistic roll up fraud proofs can be in the neighborhood of millions of gas, so can consume entire Ethereum blocks.
00:02:37.470 - 00:03:11.450, Speaker A: But again, this is a roll up. We have on chain data availability off chain data processing, except in the worst case of fraud proof. Okay, so typically speaking, we have roll ups. They have one chain associated with them. Everything's going on to Ethereum roll out. We have the same scheme with any number of chains involved, right? So it's a sharded roll up on all chains. Any chain that wants to implement this can join, any operator, can add any additional chain anytime.
00:03:11.450 - 00:03:34.180, Speaker A: So here's the goals of the system before we get into how it works. We want a roll up. We want it to support any number of blockchains. We want asset portability. So you should be able to take your ether and move it through the roll up to some other chain. And we want no crosschain communication in the traditional sense. I keep dropping this thing, I'm going to put it down.
00:03:34.180 - 00:03:58.982, Speaker A: We want no cross chain communication in the traditional sense. This means no relays, no SPV proofs, no light clienting. The chains should be naive of each other. We should not have state on one chain depending on the consensus process of the other. And we want a coherent authentication model. We'll come back to that in a second because I want to explain exactly what it means. So let's run through these goals real quick.
00:03:58.982 - 00:04:34.162, Speaker A: Portability, you should be able to take your ether, move it to some other chain and move it back. You should be able to do the same with arbitrary messages. You should be able to move the message from one chain to the other, potentially call some contract and send some results back. So no direct cross chain communication. So typically, when we have two chains, the way they communicate is by referencing each other's consensus process. So we make a bunch of cross links, we validate proof of work or proof of stake. This has an n squared problem.
00:04:34.162 - 00:04:59.830, Speaker A: When you have multiple chains, it really becomes a nice mess because you need every chain to light client, every other chain. We don't want to do that. We don't like n squared problems. Rollout kind of replaces this with a hub and spoke model where the hub is the rollout chain. So this is what we want. We want no cross chain consensus. References.
00:04:59.830 - 00:05:47.190, Speaker A: Okay, authentication model. If you see a crosschain asset, how do you know that it's any good? Is this thing actually ether? The idea of rollout is we can't decide on chain. Only off chain actors can decide whether the represented asset is equivalent to the native asset that belongs to another chain. So when you represent ether on tezos, the Tezos chain does not know whether that is ether or not. But any off chain actor that cares can verify that that asset is currently redeemable for ether on demand. All right, so these are not goals of the system. We're not trying to make a succinct chain.
00:05:47.190 - 00:06:11.790, Speaker A: So we're not trying to do the recursive snark thing. We're not trying to deploy a new consensus system. There should not be a proof of stake or proof of work system to extend the rollout. We're not trying to create price pegs again. We're going for asset redeemability and portability. We're not going for like perfect asset price correlation. And we don't need to support arbitrary smart contracts in the rollout.
00:06:11.790 - 00:06:56.998, Speaker A: This is in contrast to optimistic roll up, which wants to support arbitrary smart contracts. So that leads to the question like what is rollout? If we have this system here that's got our money in it, what is that system? Which is what I'm going to try to answer in the next 20 minutes, give or take. So what is rollout? It's a long transformers joke that I'm going to skip over real quick. Rollout, in the current conception is an extension of ZK roll up. So we're using zero knowledge, validity proofs to achieve this. So going back to roll up, this is the general structure. We have a tree that is the state of the rollup.
00:06:56.998 - 00:07:36.190, Speaker A: It commits to a number of accounts, each of which have a pub key and balance nonce and token identifier. So roll up can have multiple assets already. That's very nice. ZK rollup commits state updates, but not state to chain. So we're going to do the same thing. However, we're going to take the roll up tree and shard it. We're going to make multiple subtrees, each of which is associated with a specific blockchain.
00:07:36.190 - 00:08:16.460, Speaker A: You can add subtrees to this construction at any time. There's no special state transition required to do that. So we're going to have one subtree, that's Tezos, that has all of the Tezos associated balances, one that's ether and has all of the ether associated balances. This does not mean that subtree only has tezies in it, or that it only has, or that the ETH subtree only has ether in it. They can host any asset. When you are outside of your native chain, your asset is namespaced. It has an identifier that specifies its origin.
00:08:16.460 - 00:08:53.720, Speaker A: So things that originate are native to the ETH chain can be held in the Tezzo subtree and vice versa. We are sharding this so that we can separate state updates into different blobs that go on different chains. So we separate transactions that affect the Tezos associated subtree from transactions that affect the ether associated subtree. And when we commit those to chain. Well, okay, so let's back up for a second. We can have any number of subtrees. We can add these anytime we want.
00:08:53.720 - 00:09:47.766, Speaker A: The security model is that off chain actors have all of the information necessary to verify the system's state and validity, but the chains do not. So we have multiple different subtrees associated with different chains. The rollout chain gets updated by applying all of these transactions to the affected trees and going from an old rollout route to a new rollout route. And we produce a validity proof of the tree state transition. So this is a zero knowledge proof, some sort of snark, potentially a recursive snark, depending on how complex this is. To implement that these transactions took the tree from this route to the next route, that we produced a valid new block. And we build that into a chain.
00:09:47.766 - 00:10:41.254, Speaker A: We can take transactions, apply them to the old route, generate the validity proof, and repeat indefinitely. Okay, so we take those transactions and we shard them when we commit to chain. So we have this rollout state update that updates the entire off chain system with all of the transactions. But when we commit it to chain, we don't put all the transactions on each chain. The tezos chain sees the Tezos subtree transactions, the dot chain sees the dot subtree transactions, and the ether chain sees the ether subtree transactions. Each chain verifies its own peg in and peg out transactions and verifies the validity proof of the whole system. So we have this really small rollout update commitment that is different for each chain.
00:10:41.254 - 00:11:21.960, Speaker A: Each chain commits to the validity proof of the entire state transition and to the availability of a subset of those transactions, the subset of transactions that affects its subtree. And it looks kind of like this. This is what the Ethereum chain actually sees, is the old route, the new route, the transition validity proof, and the Ethereum subset of transactions. All right, so it looks kind of like this is the Ethereum chain is progressing. The rollout chain is progressing, except I got the numbering backwards, so just ignore that part. I threw these slides together last night. Don't worry about it.
00:11:21.960 - 00:12:02.930, Speaker A: Okay, so the rollout chain is progressing. The Ethereum chain is referencing update proofs, and it's making available the Ethereum subtree transactions. So we actually want to share that proof between multiple different updates. And so the Tezos chain over here on the right side is seeing the same proof but a different subset of transactions. And it's seeing the same roots, but a different subset of transactions. Okay, so we have this rollout chain that's progressing. It's being referenced by multiple chains, each of which sees validity proofs for the state updates.
00:12:02.930 - 00:12:45.790, Speaker A: Okay, so we kind of use this to achieve indirect crosschain communication. And the tree transition rules are critical to doing that. The only other system that achieves indirect crosschain communication that's been explored is atomic swaps and atomic swaps. The way they work is that both chains commit to some off chain information. Right, and that's essentially the same way we're doing this. Both chains also in the atomic swap commit to the state update rules, which are related but not identical on each chain. So these are the state update rules for our indirect crosschain communication.
00:12:45.790 - 00:13:23.530, Speaker A: So on the left side we have what has to be snarked, and on the right side we have what has to be verified in the chain's consensus process. Smart. Contracted. So the snark needs to support tagged assets. It needs to ensure that supply is preserved of any given asset across any tree state transition, and it needs to support transferring between subtrees. So we need to have a full system proof that verifies that it is preserved even when moving a leaf from one subtree to another. And the chain needs to verify entry and exit into the rollout.
00:13:23.530 - 00:14:04.380, Speaker A: So when you move ether from ethereum to the rollout, the chain needs to verify that and vice versa. And it needs to verify that transactions creating the state update are available. Okay, so these are permitted. You can move funds from one leaf to another leaf, even in another subtree, and those are verified by the snark. And you can move things on and off of a subtree, but only to its associated chain. And that's verified by the main chain, just like in ZK rollup. But now it's a subset of the system that goes to a single chain rather than the whole system.
00:14:04.380 - 00:14:46.230, Speaker A: So who makes blocks in the rollout chain? This is kind of an open question, but we have a few different models. We know how to do this inside chains. It's a question of what is most expedient to apply. We can have a trusted single operator, we can have a bonded single operator, we can have bonded federations. We could even potentially make an entire blockchain that runs the rollout. But I'd rather not do that because I don't like deploying new consensus systems. So I think it's most likely that we see bonded single operator or bonded federation.
00:14:46.230 - 00:15:42.170, Speaker A: And there's some really cool properties of bonding in this system that don't apply to any other system that we can talk about afterwards if we have time. Okay, so let's look at the bonding case really quick. We've said that the main chain needs to verify certain things, right? So what do we need to actually verify? What can we slash if the operator is malicious or broken or byzantine in some way? So double updates. Two rollout blocks at the same height obviously should be slashable. We don't want that to happen. That could partition Tezos onto one history and ether onto another, and that's bad unavailability. If the Ethereum chain stops receiving rollout updates but the Tezos chain continues receiving those updates, we should be able to slash that in some cases.
00:15:42.170 - 00:16:12.450, Speaker A: And liveness failure if the whole rollout stops, we should be able to slash that. Okay, so double updates or equivocation. It's pretty straightforward what that is. It's two blocks at the same height. We can actually just burn them down because one validity proof was published on Tezos and one was on Ethereum. They're both public, everyone can see them. Anyone could submit them to the other chain and we can slash the operator on every chain.
00:16:12.450 - 00:17:07.510, Speaker A: Two valid proofs at the same height can be slashed everywhere because it's public information unavailability. This is a little complex because it can be available on Ethereum but not on Tezos. So the rollout could be making progress one place but not other places flashing in this case has to assume that eventually the rollout either dies or starts making progress on that chain again. So there's a lot of subtleties here. We can't punish the operator if Tezos is just congested and the operator can't get a block on chain. So that means we need to have this kind of failure case where a specific subtree is allowed to stop making progress. If you can't get an update onto Tezos, you should be able to just halt the Tezos subtree as the operator safely and not be slashed.
00:17:07.510 - 00:17:57.830, Speaker A: This means service degradation for anyone using that subtree, but that the rest of this system can continue unaffected. We need to allow one update, but not two consecutive updates without data availability. One update could be just the chain is busy and you can't get a transaction right now. But two updates in a row without making data available to that subtree is obviously malicious. That's the operator withholding blocks. Okay, so we can have localized slashing in this case. Specifically, if Tezos sees two validity proofs that attest to a new Tezos subtree in a row without seeing the associated transactions, then the Tezos chain can slash pretty permanently.
00:17:57.830 - 00:19:24.260, Speaker A: So only one chain is aware of this unavailability. But all off chain actors are aware, and so the off chain actors can see whether the operator properly halted the subtree or not, and decide whether the Tezos subtree and Tezos rollout namespaced assets are still worth anything. We're going to skip over this because I worked it into the previous slide, but in the case of liveness failure, liveness failure is a little complicated, like what if the rollout halts altogether? We have some ideas in this direction, but it's mostly around progressive flashing over time, and there's open questions around how does this interact with rotating operators? So I've touched on this briefly earlier. Let's talk about reasoning about cross chain assets. Rollout should have basically the same asset authentication model as IBC in Cosmos, which know the local chain, knows that this is a representation of a remote asset, and knows that it came from this communication channel, but does not know whether the origin of that message is any good, whether the asset's worth anything, whether the remote chain is still progressing. All of that is left up to off chain actors to decide. So, like, we can tell where it came from or where it says it came from.
00:19:24.260 - 00:20:12.938, Speaker A: We can tell that it's a representation of something, but off chain actors are responsible for figuring out whether it's worth anything at all. Off chain actors, fortunately, can tell whether or not the rollout is valid. And a really cool property here is that they can sync only the subset of rollout subtrees that they care about. So if I don't care about dots, I don't have to sync that subtree to know whether a Tezos asset on Ethereum is valid. Okay, so off chain actors can tell whether the rollout's valid live, whether the asset's likely to be redeemable on the home native chain, and if not, they can bail from that asset. We're going to come back to this in a second, because it creates a really cool property. We have failure modes which we've mostly talked about already.
00:20:12.938 - 00:21:18.834, Speaker A: We have local halt, so the subtree halts, some subtree, or some number of subtrees halt. We can have a full system halt due to equivocation or due to a liveness failure. And this does actually permit inflation, but only of represented assets, not native assets. And inflation will force permanent unavailability on some chain and will be immediately visible to off chain actors. So how this is achieved is the operator can accept slashing on Tezos to inflate any Tezos namespaced asset. This is any asset that's native to the Tezos chain, and they can make an improper tree state transition when pegging assets into this rollout from Tezos because the Tezos chain is no longer validating their updates because they have accepted that they will be slashed on tezos. So anyone holding Tezos namespace assets, whether it's in the rollout or on another chain, loses redeemability of that asset.
00:21:18.834 - 00:21:58.690, Speaker A: So there's actually fairly high damage from this, but the operator can't monetize the attack and will lose money as a result. You can't monetize it because no person will be willing to accept the inflated asset for value. So again, we're falling back to the authentication model of off chain actors. Decide what it's worth. Okay, this creates kind of a cool property, is that subtrees fail separately. The actual chance that the system as a whole will fail is fairly low. And any individual subtree failure only affects people holding assets namespaced to that subtree.
00:21:58.690 - 00:23:02.520, Speaker A: Okay, so the big open question right now is how do we rotate operators? We don't want to have a single trusted operator forever, and you cannot bond a single operator forever. Bonds need to have a time duration, which implies that we need to rotate at some point. My current thinking is that operator rotation needs to be done within the rollab tree because that's the only way to have global eventual knowledge of the operator update. If you do it on a specific chain, the other chains can't authenticate that it was done correctly. But that leads to the other cool property. If the operator is selected on the rollout tree, they can also be bonded on the rollout tree. And bonding the operator on the rollout tree creates this really cool effect, which is if you bond the operator on each subtree and that subtree halts, the operator automatically loses money.
00:23:02.520 - 00:23:30.560, Speaker A: It just happens immediately. It's not a result of protocol action that their bond is slashed. It's a direct result of them halting the tree that held their bond. Okay, so we have about 510 minutes for questions. Again, this is a very high level system sketch. We haven't implemented any of this, and it's based on, as of yet, barely implemented ZK roll up stuff. All right, question.
00:23:30.560 - 00:24:22.830, Speaker A: I think this system isn't resilient, though, against underlying chain failure. If Tezos fails, the Tezos subtree fails. Any Tezos namespaced asset is no longer worth anything. Okay, what about an ETH asset that moved into the Tezos namespace also failed? Specifically, if Tezos fails anything, that's Tezos namespace fails. And anything in the Tezos chain or Tezos subtree fails. So your ETH liability, like your ETH damage, is limited to the amount of ethereum ether currently represented within the Tezos subtree and the Tezos main chain. Any ether represented in any other subtree or any other chain will still be redeemable.
00:24:28.240 - 00:24:46.304, Speaker B: If there's a publicly known vulnerability difference between chains, don't I have an incentive to take my assets denominated in the vulnerable chains and then convert them into the more reliable namespace? Running away from Tezos into ETH, for example.
00:24:46.502 - 00:25:13.160, Speaker A: Well, you can sell your tezzies for ether, but again, like we were talking with Zucky, if the Tezos chain fails or if tezzies are inflated, your ether represented Tezzies will not be worth anything. So you can get a representation of tezzies on ether, but you still can't escape the Tezzi assets value reliance on the Tezos chain.
00:25:23.290 - 00:25:43.034, Speaker C: I was curious if you've thought about ways of composing this with like shielded pools and a totally pie in the sky future where say the roll up chain is using the same proof system as the one with a shielded pool, and you could potentially use like a recursive proof instead of doing the kind of like transaction balancing and proof of supply kind of stuff.
00:25:43.152 - 00:26:43.854, Speaker A: So I think you can do that. I think that there is a possible future where the rollout chain is fully recursive and everything snarks all the way down. And there's one summary snark for a state update. You could even probably make it succinct so that you're catching up on the whole pass validity that is significantly more complex than I could reason about within the last week or two. Is there a way to support Utxo chains, things that don't have native smart contract systems built into them? You can always hard fork in an application specific protocol rule that creates these rules as a consensus rule. Would like a side chain kind of mechanism also work? Yes, with a bunch of caveats and engineering difficulties. Fair enough.
00:26:43.854 - 00:26:44.960, Speaker A: Thanks. Yeah.
00:26:49.750 - 00:27:33.120, Speaker D: Given this model works under the model where operators supposed to have very high computation power and in the cases where you have a time window, I guess to submit invalidity proofs. So it could run into cases where you can't really generate proofs within that time window because you're assuming that operator will be the one with the ASICs and superior hardware. And if there could be a computation sort of generating proof that would not be possible by say someone trying to. There needs to be another, right?
00:27:33.490 - 00:28:13.514, Speaker A: The nice thing here is that you never need to make an invalidity proof. The only thing that you, as the user of the system would have to do is submit two valid but equivocating proofs that the operator created. So if you can show that the operator committed to two different state updates at the same height on different chains, which they are required to publish the validity proof that they created in order to do that, then they get slashed. Right. But you as a user never need to create any sort of snark or ZkP that describes the system state at all.
00:28:13.632 - 00:28:38.210, Speaker D: So that's what I'm saying. I'm not concerned about equivocating proofs, I'm concerned about the proof itself. It's like the state transition is like there's a proof for invalid state transition that someone generated and submitted that proof is verified, but it's not a valid proof. It's not a valid state transition.
00:28:39.530 - 00:28:56.270, Speaker A: You should not be able to generate a valid ZkP of an invalid statement. Zkps have soundness as a property. Right? Yeah.
00:29:01.200 - 00:29:29.510, Speaker E: Hi, I want to ask you whether it makes sense for why do you think this will be a long running chain instead of just a referral chain that whenever you want to cross chain like a transaction, you set this up with ideally a time limit, and after a certain time it has an incentive for the operator to actually pull everything out of the system. And next time you start again. So, I mean, have you thought about that?
00:29:30.360 - 00:29:56.380, Speaker A: I think that's really interesting. It does kind of bound the scaling benefits of a system like this, because one of the cool properties is that rollout should legitimately help any chain. It's deployed on process more transactions. But having a bounded period of time for this rollout chain would solve a lot of operator rotation and bonding issues.
00:29:56.450 - 00:30:07.820, Speaker E: Right. Well, the idea is always, if you have a way to set it stop, anybody can start setting this up. And you have multiple parallel operations, essentially.
00:30:07.900 - 00:30:32.696, Speaker A: Right? That's true only to a certain extent. Consider ethereum has a block gas limit and can only do a few zero knowledge proof verifications per block. So if you have too many ZK roll ups running with the same host chain, they'll be competing for block space. There is an upper limit to how many of these systems can be simultaneously deployed on the same chain without breaking each other.
00:30:32.798 - 00:30:33.352, Speaker E: Right.
00:30:33.486 - 00:30:38.430, Speaker A: Which is one of the big downsides of roll up and any layer two system.
00:30:39.280 - 00:30:45.950, Speaker E: Also, a follow up question is how do you handle the asynchronous nature of the withdrawal from the system?
00:30:47.440 - 00:30:49.920, Speaker A: The asynchronous nature of withdrawal from the system.
00:30:49.990 - 00:31:00.690, Speaker E: Right. So I mean, you deposit something easily into the system, and then you get pezels. Right? And then you took out pezels. But how do you handle that? Right.
00:31:01.560 - 00:31:46.432, Speaker A: It's kind of really interesting because time in this system is not intuitive, because different chains can receive the same state commitments at different wall clock times. So there's even cases in which an asset can reach the destination before it has left the host, from the subjective perspective of the host. So we don't generally worry about that. The rollout chain is a unified tick for this system across all chains. Chains might learn that the clock is ticked later than other chains, but it shouldn't matter. And again, the goal here is that you can reason about the assets namespaced within a specific chain. Right.
00:31:46.432 - 00:32:11.300, Speaker A: The goal is that if Tezos halts, you should be able to tell. And even if Tezos is like five rollout blocks behind, we can still tell that it halted and off. Chain actors can act according to whatever they do when Tezos fails. So we leave what to do with asynchronous problems up to the people who are holding the assets involved. Cool.
00:32:11.450 - 00:32:14.324, Speaker E: But the operator need to send the asset to them, right?
00:32:14.362 - 00:32:29.290, Speaker A: They could not exactly. The operator will get slashed if those transactions exist but are not eventually made available to the chain. But they don't exactly need to send main chain transactions to people.
