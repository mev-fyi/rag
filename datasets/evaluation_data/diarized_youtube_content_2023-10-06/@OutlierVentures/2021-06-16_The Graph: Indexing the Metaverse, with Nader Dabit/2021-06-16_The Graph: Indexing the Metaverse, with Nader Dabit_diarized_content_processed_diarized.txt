00:00:05.620 - 00:00:18.936, Speaker A: Hello and welcome, everyone. I'm Arnold Vanvers, CTO and founding partner of Outlier Ventures. And with me is Nader Davitz of Edge and Node, the original team behind the graph. Hello.
00:00:19.038 - 00:00:21.050, Speaker B: Thank you for having me. Excited to be here.
00:00:21.500 - 00:00:55.188, Speaker A: Yeah, great. We're excited to have you. Yeah. So today we'll go into indexing the metaverse, indexing everything, crypto, defi nfts with the graph. How do you do it? How do you use it as a developer, and how does it work under the hood for people using Defi nfts and all those things? As a user, how does it make that work smoothly? So start off, could you tell the audience just a bit about what are you doing? How did you get involved with the graph, edge and node?
00:00:55.284 - 00:01:46.744, Speaker B: Yeah, totally. So I've been with edge and node for, I guess about three months now. And before joining Edge and node, I was actually leading the developer relations or developer advocacy team at AWS, front end web and mobile. And I was there for a little over three years and I got really interested in the graph, which ultimately led me to an opportunity to work with Edge and node. Like you mentioned, they're kind of the original creators of the graph, but now the graph is managed by foundation. So the founders created Edge and node for us to help support the graph protocol, but also to explore and build out different ideas in the web3 ecosystem, investing in people and ideas and technologies and stuff there. But I really got interested in the graph because I had been working with GraphQL at AWS for I guess like three and a half years or so.
00:01:46.744 - 00:02:44.084, Speaker B: But I've been really working with GraphQL for like maybe four years. So GraphQL is essentially kind of the querying language or the API language that the graph uses. And we saw rapid, rapid, massive adoption at AWS with a lot of customers and people and developers in the back end, front end, all of the different web ecosystems. So GraphQL was something I was really interested in, really passionate about, and something that I really like using. And then before I kind of really understood the technology of the graph, I was essentially kind of like someone that was speculating on buying and selling crypto, really ever since maybe 2015 or so. And I started looking into the graph protocol because I had bought some GRT and was kind of like sucked into this rabbit hole. And I started really seeing some of the things that were happening not only with the graph, but really in the web3 ecosystem.
00:02:44.084 - 00:03:18.070, Speaker B: And I got really fascinated and drawn in around the idea of decentralization, decentralized web infrastructure. And what the graph was doing was really exciting to me. So one thing led to another. I was really in a cushy, comfortable job at AWS. No reason for me to leave. But when I started getting an understanding of kind of what the founders of the graph had done and some of their ideas for the future, I really, really got excited and I decided to just submit my application, essentially on a whim, on their website. And one thing led to another, and now I'm here.
00:03:19.880 - 00:03:29.176, Speaker A: Great stuff to hear about it. And I love the clock behind you. It keeps me on my toes for scheduling here. That's great.
00:03:29.358 - 00:03:38.412, Speaker B: Yeah, it's something that I can actually change the different pictures on, so maybe I'll change a picture in a moment. Nice.
00:03:38.546 - 00:04:15.348, Speaker A: Great. All right. Yeah, so I'll start off by just giving a quick introduction about what indexing and querying is in the web3 world and why there would be a need for something like the graph. And also explain why have we called this indexing the metaverse and how does it fit in with what we do in divinities. So of course I have some slides for that. And of course we start off with a beautiful disclaimer. None of this is about any financial promotion or investment advice or otherwise.
00:04:15.348 - 00:05:16.990, Speaker A: Of course, in the web3 world we have lots of tokens flowing around. We're talking about tech today, brief background about us. We have been backing web3 founders since 2014 with always a blockchain agnostic view to the world. It's a multichain world. And we feel ever more sort of encouraged in that thesis or that part of our thesis, because we're in a day and age where there are many mature platforms and technologies to build on. And our investment thesis has evolved to contain this view of the open metaverse, which includes things like new data economy and data trading, which includes everything digital in virtual and the real world, includes things like DFI and nfts to form components of virtual worlds of metaverses. And I'll say a bit more about that later.
00:05:16.990 - 00:06:13.230, Speaker A: And the main activities that we do is our base camp accelerator, where we work with early stage teams in web3 and metaverse to really give them a way up to being more successful in a very compact trajectory program. And we also do a token launch program for more mature teams who are close to a token launch. And we help them with everything going from our experience in the space since what is in crypto years probably more than in real years since 2014. And we also run validates on a number of decentralized networks. We don't run validators on the graph yet, maybe, or validates, I don't know how you call them, indexes. Maybe we should. But at this point, these are the networks that we directly support in that way.
00:06:13.230 - 00:06:51.636, Speaker A: So just for framing. So you have crypto networks and you have programmable blockchains, some with lesser possibilities, some with more. You have the ability to create something that is censorship resistant, that's open, that's verifiable, and you can use that to build apps or dapps. Or dapps, or how you pronounce it. Well, great, so you can build something like uniswap. To swap tokens. What you would need is you would want to build the user interface for people to say, hey, I want to swap one ETH for one die.
00:06:51.636 - 00:08:01.056, Speaker A: And you would need a smart contract on the back end that would be able to process that and provide information for, okay, there's this many ETH in the pool and this many die. And so if you convert, you get this price and there you go. So that's all you need, right? Well, in theory, yes, in theory that could work, but it becomes very slow and very cumbersome. Why is it slow? Why is it cumbersome? Because things like Ethereum nodes, they provide, of course, an API, or APIs, various forms of APIs, to interact with them and to say, hey, blockchain. Which pools are there for swapping tokens on my uniswap app and how many tokens are in there? And if I want to do this, what would be the conversion rate? But that JSON RPC API is very rudimentary in the terms of it's very close to the blockchain element. So you can say things like, give me this block or give me this transaction, or I have this transaction for you, or give me this contract. And that's helpful, that's what you need.
00:08:01.056 - 00:08:38.296, Speaker A: But if you want to say, you want to ask things like which pairs are there and what's their liquidity. So that becomes a quite complex combination of information. So if you want to get it directly from the JSON RPC API, you end up with running many of those types of calls to JSON RPC API. Each of them are slow. You would need to run a lot of ethereum nodes, and that's just for one app, that would be your uniswap clone. So every single app would have to do those things for themselves. And so that's not ideal.
00:08:38.296 - 00:10:14.528, Speaker A: So what's happened over time is that many teams building dapps have introduced some form of caching, indexing, querying in the middle. So basically saying, okay, well I have my smart contracts layer here, I have my ethereum node or I have my bitcoin node or I have my whatever level one layer, one blockchain it is that I'm building on node. And then I have some piece of software usually using some established database technology and that continuously asks the blockchain for hey, what's, what's happening with my smart contracts? What's happening, what's happening? What's happening? And then putting this layer that's very structured and verifiable and queryable, then that is able to answer such questions so that your uX, your front end, your web application only needs to ask more simple questions and it gets an answer quick so it's able to populate its UX quickly. That is still a very much simplified version of the world, but it is sort of indicative of what the domain is. So there are of course many technologies to do collecting of data, structuring and storing it, things like postgres, things like MySQL. There's a bunch of very mature dbms. There's of course the wholesQl movement with MongoDB as one of the leading platforms or packages that you can use to basically help form this layer.
00:10:14.528 - 00:11:31.584, Speaker A: But again, every team would need to get their nodes up, get the database up, write code to specifically query these smart contracts, provide it to the UX. Basically everybody has to reinvent this wheel. That could be done better, of course. So the idea of the graph is to do that, in summary, to do that in a generalized manner so that as developers you can concentrate on building great smart contract logic or whatever it is, ipfs, you're talking about storing data, doing that, which you do in a centralized manner in a great way without needing to be bothered too much about how is that data, how it's possible to access that, how it's possible to build great applications on top of that. And on the other end, from a UX perspective, only needing to work with common, mature, widely understood graphQL API queries to say okay, here there's a list and the list shows this bit of data. Here there's a button. And when I do that button, I want to show this other bit of data that would be in a nutshell, why the graph and how.
00:11:31.584 - 00:12:31.844, Speaker A: And we'll get in. Well, there's more to why than the how. We'll get into more of the how as we go into the more interactive part of the session and to give some more context on this whole metaverse thing. Beginning of this year, we released this report called the Open Metaverse OS. And it's our view on how virtual worlds, and partially virtual worlds and decentralized technologies and applications are basically blending into one big thing. I'd have to say it in one or few sentences. If you look at virtual worlds like gaming environments, but also you have of course, many gaming environments that are continuously on, that are mmorpgs, which have either a very high fidelity, highly graphical experience, or a more lo fi way to experience them.
00:12:31.844 - 00:13:59.280, Speaker A: Maybe on mobiles, maybe on desktops and consoles. And there are many of those. And there's also things like Second live and those type of more generic virtual worlds which might have games in them, but each of those has probably to some expect some of these components. So physical things that live in the virtual world, space, objects, avatars, economics, currencies, often virtual worlds, closed and open ones have a currency or had a way to use currencies, financial instruments, marketplaces, and of course the mechanics that make them all tick. Now, looking at all of those things, you can for each of these identify components out of the web, three world that can support those parts of virtual worlds. So for example, for tokenization of the platform itself, of course you can use tokens and governance mechanisms for all these sovereign virtual goods, as we call them, these in game or in world goods, you can of course use nfts and the rising growing amount of platforms and marketplaces and ways to work with nfts, currencies and financial instruments. That's of course a square fit for crypto tokens and defi protocols.
00:13:59.280 - 00:15:08.840, Speaker A: And when we wrote this report, we had already included the graph as a possibility to where can that play a role? Well, actually to bridge to externally query things that are in these worlds. But actually, when you think about it, it could be more widely applied in querying and indexing. Role of almost all of these things in the more open virtual worlds. And when I say open virtual worlds, I'm talking about things like Decentraland, crypto, voxels, the sandbox. There's quite a few of these, which at least are to some extent or a great extent entirely built on decentralized components. And as we look at some of the examples of using the graph, we'll actually show the decentraland marketplace where you can just see, hey, I can query wearables and things for sale in Decentraland through the graph and close this off. If you look at multiple virtual worlds, some that might be more closed and some that might be more open.
00:15:08.840 - 00:16:06.568, Speaker A: Even in closed virtual worlds you might have start opening up some aspects. So maybe in something like Fortnite you would have your wearables, maybe some wearables could be exchanged with other worlds and maybe you could start to spend your die there. Or maybe some agents would be able to interface with some of these worlds. So as these things come together and more and more bridges form, that's when this starts to look more like one single open metaverse composed of all these things. So yeah, let's share some stuff. This is a view of the playground of the graph, which I love because you can just go to the website and it works. Now I unlike you nader, I am absolutely not an expert in graphql.
00:16:06.568 - 00:16:51.690, Speaker A: So I can just run stuff and get some results. But I'm sure you can get something more substantial than I did. But just to show very quickly, like starting off with Uniswap. Now obviously the thing that I showed was from Uniswap V one, but we're now of course in v two and v three. But for example, here is a way to interact with the Uniswap v three, v two, or a uniswap vt two subgraph, I must say, because this is after all an open platform, anyone could create a subgraph, but this is sort of the more widely regarded one. That is good. I see I got an error message because I run my query before.
00:16:51.690 - 00:17:31.430, Speaker A: But you can query swaps, you can query pairs, you can query which tokens are there, those kind of things. But running this and I saw that it was quite a heavy query. So let me see if it gave some results later on. And in the meantime I'll look at EnS, the Ethereum naming system. So the main name system on Ethereum, this is the ENS website. I don't know if they use the graph behind the scenes or not. I know that Juneswap themselves, they do actually build on the graph with their analytics page.
00:17:31.430 - 00:18:27.496, Speaker A: But going at ens you can do things like, hey, give me all domains where the name contains fish or let me now are we in a bull market or bear market? I'm going to be optimistic. Name contains bull. Let me see what we get. Yeah, we have pushbullets eth, Admiral Bulldog eth at bulls eth. So as you see that, it's pretty, this is fast. This is the level of performance that would be very good if your UX would be using that. There's no way that using individual JSON RPC calls to even a large group of heavily optimized Ethereum nodes would give you these kinds of results so fast it could be going to the central end.
00:18:27.496 - 00:19:23.080, Speaker A: So this is what you can see on the front end, how their front end to their marketplace is, which is again composed of a number of smart contracts and using nfds. But if you go to the graph, you can say, okay, just give me the total amounts of items that are there and give me all wearables. Well, the first five where the name contains shirt or, let me see, do we have trousers, any trousers on your trousers? Yeah, we are DC nifty blocksmith trousers. So again, this works quite rapidly. This is all highly machine readable and usable in apps. And finally, for one of the NFT minting platforms, Mintbase, there's also a good subgraph. So this again is the Mintbase website itself.
00:19:23.080 - 00:20:01.620, Speaker A: But if you go to the subgraph, you can say which stores are there. And I was happy to see that actually, Toxam, that's crypto avatars. They're in the current base camp cohort. Happy to see them show up as one of first. And of course, again, there's extensive querying just to give you a quick flavor of what querying is with the graph and how that works. So, yeah, Nader, you got a very ambitious plan. We're going to build a subgraph.
00:20:01.620 - 00:20:04.170, Speaker A: Tell us more. What is that?
00:20:05.660 - 00:21:04.600, Speaker B: Yeah, totally. The plan is to build a subgraph from scratch and then deploy it and then kind of show you a front end that was maybe built on top of a subgraph and show you kind of how to query from a client side application. But the API itself really works the same across any application. So if you're querying from a client application on the web or mobile or even on a server, the cool thing about graphQL is like once you learn it, once you're able to use any GraphQl API that is out there in the entire universe, really. So if you learn Graphql and you're working at one company, you're starting to see it being more and more adopted. So you learn at once and you can kind of build anything. And I think the cool thing about the graph is about the idea of kind of, you're starting to see because more and more teams are picking up graphql that you're just able to do more and more.
00:21:04.600 - 00:22:01.756, Speaker B: And there are really interesting projects out there even that are outside of the web3 ecosystem that are kind of aggregating traditional rest APIs that typically required you to kind of learn and understand the API itself, which takes time and resources and stuff like that. And they're turning them into GraphQL and then putting them into things like this comprehensive graph. So one of those projects is called one graph, and it allows you to query data from a bunch of different applications like YouTube, GitHub, all these types of and Twitter, all these APIs that were typically rest APIs. And I think the cool thing about the graph is that we're kind of doing something similar, except we're doing this for all of the world's public data. So right now we support mainly blockchains and ipfs, but in the future we'd like to expand that and anyone that wants to index any data can do so using a subgraph. And we're going to kind of walk through what that looks like, I think, in this demo. So yeah.
00:22:01.756 - 00:22:04.412, Speaker B: Are you ready for me to go ahead and start writing some code?
00:22:04.466 - 00:22:06.252, Speaker A: Absolutely, yeah. Great.
00:22:06.386 - 00:22:14.544, Speaker B: Okay, cool. So I'll go ahead and share my screen and you can see that.
00:22:14.582 - 00:22:18.770, Speaker A: All right, definitely. Yeah. Events tech.
00:22:19.380 - 00:23:03.132, Speaker B: Cool. So the graph that we want to build is going to be for foundation. So if you've ever been to foundation app, this is a really cool NFT site. And one of the great things that I like about it is the know, the design is just beautiful, I think. And they've done a really great job on the, I would say not only the design itself, but how performant it is. So like when you're scrolling, the images come up pretty quickly. So they've basically done some work not only in getting their subgraph deployed and ready for consumption by anyone because it's actually public as well, but they've also done a good job around image optimization.
00:23:03.132 - 00:24:09.350, Speaker B: So I think what they're doing behind the scenes is they're kind of like taking the images and they're doing some performant updates and kind of like storing them elsewhere. So we're not going to be doing all of that, but we will be building out a similar application as this. Now, the really cool thing about foundation also is that they have a developer site. So you can go to FND dev. If you're a developer, you can kind of see the developer docs. And these are meant for people that want to kind of build out applications on top of their smart contracts. And I think that's another one of the really unique and interesting things about Ethereum and blockchain development is that any application that is deployed to a smart contract is completely open for anyone to build out their own UI on top of it, because you can kind of think about the smart contract as more of the interface and then the client front end can be a different abstraction or user interface on top of that I would say like the UI I guess would be the interface and then the smart contract would be like the business.
00:24:09.350 - 00:24:50.870, Speaker B: But like the cool thing know foundation is that they've created a completely separate site just for developers. So here we can kind of see that we have subgraphs and in the future they're going to have the contracts and looks like they're working on open source package. But if you go to their docs, you can actually see that they have now open source their smart contracts. So they give you kind of a link directly to where their contracts are. And then if you go to their foundation subgraph they actually have a link to their subgraph. So you can just click right here and it gives you kind of an example query to kind of work with. So I'll zoom in a little bit.
00:24:50.870 - 00:25:18.620, Speaker B: So if we just hit play or execute, we'll kind of get some information back. But typically what you want for an NFT is kind of like the IPFs address. So you can kind of see the image itself. So you might do something like NFT market auction. Then here we might say NFT.
00:25:20.880 - 00:25:21.196, Speaker A: And.
00:25:21.218 - 00:25:34.096, Speaker B: Then token ipfs path. And here we have the IPFs path. So if we wanted to kind of get that, we could get that. And let's see here what else on.
00:25:34.118 - 00:25:37.440, Speaker A: This one you probably need to increase the font size somewhat to make it.
00:25:37.510 - 00:25:38.608, Speaker B: Increase it a little bit more.
00:25:38.694 - 00:25:39.730, Speaker A: Let's do this.
00:25:42.040 - 00:25:42.772, Speaker B: How is that?
00:25:42.826 - 00:26:09.976, Speaker A: Yeah, it is better. Yeah. Great. One more to interrupt you. You mentioned subgraph and I showed a few ways where you can query things. What is a subgraph? In a few sentences it's like definition of here are some things and this is how they look and this is how they can be queried. But that would be very rudimentary.
00:26:09.976 - 00:26:11.470, Speaker A: You have a better one I'm sure.
00:26:13.360 - 00:27:06.904, Speaker B: Yeah. A subgraph is basically an API that anyone can deploy on top of any individual smart contract or combination of smart contracts. So a subgraph is essentially kind of, I would say combination of code that describes the data that you would like to be indexed. So if you think about something like foundation, I can deploy a subgraph and I can say I want to index and store and make available all of the NFT data as well as maybe the auction data and maybe even the user data. And then basically you describe that in a subgraph configuration and you write a little bit of business logic code. That kind of describes how you would like these entities to be saved. And then the graph will basically go into the smart contract and will start at a certain start block.
00:27:06.904 - 00:27:51.756, Speaker B: So you can either go from the very beginning or you can kind of decide, okay, I want to start at this block. And then it will basically crawl and go from there until right now and find every transaction for that smart contract. And it will look inside of it and it will basically look for different functions or different events and it will kind of take the data and then it will store that, making it available in something like this. And I think it'll make more sense. We basically build one to kind of give you a better idea. And then also I think it's pretty interesting here. If you go to the foundation docs, they actually give you a couple of queries that you can use.
00:27:51.756 - 00:28:17.748, Speaker B: So if you just want to kind of from start from somewhere, they give you a couple of these. So if you go to subgraph examples, we could literally copy and paste this code here. And here we're going to say we want to have the NFT market auctions and the token ipfs path is right here. So that's pretty cool, right?
00:28:17.834 - 00:28:23.860, Speaker A: Yeah. To get the image and other metadata of that NFT.
00:28:24.380 - 00:28:49.308, Speaker B: Yeah. And then the contract itself on ether scan. And then I think this is a proxy so you can kind of click here. And then here you actually see the contract itself. And what we're going to be needing for our project are the Abis. So if you scroll down here, you'll see that we have the Abis. And the Abis essentially kind of describe the events with the metadata around those events.
00:28:49.308 - 00:29:22.650, Speaker B: So, for instance, if the event is emitting like a string or an integer or whatever, it kind of gives us the typing and stuff. Like. So what I basically want to do is I want us to kind of go to this smart contract, build out a subgraph from scratch. And then we want to have like a Ui on top of it like this. So let's kind of start from there. That's a lot of stuff. So we're going to be writing some code from scratch, but we're also going to be using a front end that I've already kind of built.
00:29:22.650 - 00:29:27.512, Speaker B: Essentially. Is this font size big enough or you don't make it a little bit bigger?
00:29:27.576 - 00:29:31.420, Speaker A: This is good. This is good. Yeah, for the general window it's good.
00:29:31.570 - 00:30:00.870, Speaker B: So basically, to initialize a new subgraph, use the graph CLI. So to install that, you just say NPM install and then graph Cli and the graph docs actually describe this really well. But what I would like to do is just go ahead and initialize a new subgraph. And here it's going to walk me through a few different steps. Now the first thing I need to do is give the subgraph name. Now in the graph console or the graph explorer, let's see. Here we can go to the graph.com
00:30:00.870 - 00:30:29.740, Speaker B: and here you can go to your dashboard after you've created an account and you can click add subgraph. And then this will basically walk you through the name and the subtitle. And then that will give you like a new subgraph. Now, I did that before this started recording, and this is kind of the subgraph that I have here. So this is completely empty. There has not been anything deployed there. So you can see it says undeployed.
00:30:29.740 - 00:31:03.556, Speaker B: So what we want to do is deploy. So I'm going to go ahead and copy the path to this subgraph, which is dabbit three, foundation three. So I can go ahead and give that the name here. And this will create a new folder called foundation three. And then we can choose where we would like to be querying, indexing our data from. So here we can kind of see that we have a list of many of the different networks that we support. So this is going to be expanded in the future, but let's say Ethereum mainnet.
00:31:03.556 - 00:31:40.980, Speaker B: And then now we can kind of start off with the contract address. And all this is really going to do is it's going to go ahead and build out some boilerplate code for us in our subgraph yaml. And our subgraph yaml is where the configuration for our entire subgraph is. So where will we get that address? Well, here we can just kind of like copy maybe this address because this is one of the addresses. But again, it doesn't really matter because we're going to have to go in and we'll have the ability to go in and configure this ourself. And then for the contract name we can kind of give it a name. I'm going to call this token.
00:31:40.980 - 00:32:15.440, Speaker B: Now this is going to go ahead and initialize a basic subgraph. And I think what I need to do is go ahead and change into this new directory. And here if I go ahead and list out the files, you'll see that I have all this stuff here. And we'll walk through that and we'll go ahead and open this up in a text editor. But I think I need to go ahead and run NPM install to install all the dependencies. So while that's doing that, I'll go ahead and open this in my text editor and we'll walk through kind of like the structure of a subgraph.
00:32:16.420 - 00:32:25.380, Speaker A: Yeah, great. So when you initially supply that contract address, it does a bit of analysis of what's there and what might you use.
00:32:25.530 - 00:32:39.192, Speaker B: Yeah, it actually fetches the abis. So we see that we already have an abis folder here, and this is actually something that the cli, it went to the contract, it fetched the ABI and it brought it back down. Yeah.
00:32:39.246 - 00:32:45.996, Speaker A: So that knows which functions does this contract have, which public storage does it have, the events that it has?
00:32:46.178 - 00:33:26.936, Speaker B: Yes, exactly. And then the other thing that happened is it went ahead and created this subgraph yaml with the address here. So this is the address that we passed in. And this subgraph yaml is really all of the description that you have for your subgraph. And if you've ever written any yaml before configuration like Json, you could probably understand essentially how this might be formatted. If you've ever done any cloud development and you've written any infrastructure as code, if you've ever done cloud formation or CDK or any of that stuff. Very similar.
00:33:26.936 - 00:34:19.588, Speaker B: A lot of stuff in software programming has these types of configuration files, but typically you can define and describe your subgraph in 50 lines of code or less for the most part, for most basic to intermediate examples. And you see that we have about 26 lines of code here, and we're going to be making additional changes. And this is going to be a little bit larger, but you can see that it's not a ton of code for getting your base definition. And this is going to actually be like your main starting point for the most part. So one of the keys to check out is this data sources key or field. And the data sources field basically can be one or many smart contracts. So you can combine a bunch of different smart contracts together and index multiple data sources together, which is extremely powerful.
00:34:19.588 - 00:35:15.080, Speaker B: If you think about how you might aggregate data and make it exposed and accessible, you can basically start with, let's say we have two or three different smart contracts. Once you get that first piece of data and you save it, you can now have access from your subgraph to query data not only from the smart contract, but also the node where the data is stored. So if that makes any sense, you could think of like maybe we have this foundation subgraph and maybe we have access to some type of user identity platform, and maybe we want to take the address from the user that created an NFT and then fetch their profile data and then combine that, you could do stuff like that. So you would be able to basically query data both from the smart contract as well as the node as it's being saved, as it's being indexed.
00:35:16.240 - 00:36:03.716, Speaker A: That's clear. So we have multiple smart contracts that probably have some interrelation. Indeed, when you refer to, or for example for Uniswap, like Uniswap itself has this list of other token swapping protocols that have this list of, okay, these are the markets within a market we have, these are the tokens and those tokens have an address. So for example, if it's EtH versus dai, or wrapped ETH versus dai, Dai contract also has a contract, and you might get the token ticker or additional information from. And ipfs can also be a data source. Can you also combine smart contracts and ipfs in a single subgraph?
00:36:03.828 - 00:36:54.632, Speaker B: So the way the IPFS works is that we have APIs that allow you to query ipfs from within the subgraph itself. So let's talk about where you might actually be writing the code itself that does this work. So in most smart contracts you have events that are emitted. So if we go to foundation smart contracts and we just look for events, you'll see that we have these different events. Every time an event is emitted. It's an opportunity for us to basically look and see the data that is emitted from that event and index it. So in our subgraph we have these event handlers, and the event handlers basically listen for those events and then take that data and invoke a function.
00:36:54.632 - 00:37:15.920, Speaker B: And the functions that are being invoked are kind of how we actually store the data from the smart contract. And we do that in this mapping typescript file here. So I can kind of go in here and delete some of these comments just to kind of show you a little bit what's going on without it.
00:37:16.070 - 00:37:19.872, Speaker A: This is the boilerplate code generated from those events, right?
00:37:20.006 - 00:37:21.216, Speaker B: Exactly. Yeah.
00:37:21.398 - 00:37:29.860, Speaker A: Indexing it, there's these few events. You probably might want to do something when that event happens. Here's already some functions for you to write that code.
00:37:30.010 - 00:38:07.660, Speaker B: Totally. Yeah, exactly. And it makes a lot of sense to kind of get people started with some example code, because really what happens in these handlers is essentially kind of the same thing across most subgraphs. What you're basically doing is you're going to be getting data out of the event and then you're going to be saving it into the node. And what happens between here and here defines kind of like the shape of that data. So in this example, we're creating an entity, which is probably going to be something like a map or an object, and then we're going to be adding different fields to that object, and then we're going to save that object. So here we're basically saying we have an entity.
00:38:07.660 - 00:39:25.992, Speaker B: We're going to add a field for count, a field for previous admin, and a field for new admin. But the general structure for these different events is very similar across all the different subgraphs that I've seen. And the more complex it gets, the more lines of code you might have here, you might be not only saving data from the event, but let's say we want to do something like call ipfs and get some data, and then we want to call a different smart contract, and then we might want to call a node, we're going to be doing all this stuff, getting data, and then we're going to save that data right here. So we're going to be writing a custom mappings for ours. So I think when I submitted the smart contract address, we basically gave the smart contract address that was given to us here. But like I mentioned earlier, this contract address is actually a proxy to an actual ERC 721, which is actually located here. So the ABI that was pulled down, actually, I probably should have started from this contract address, but the ABI that was pulled down is probably not correct.
00:39:25.992 - 00:39:58.336, Speaker B: So let me go ahead and copy this ABI and paste it here. I can try to maybe format this a little bit better. There we go. So we have this token ABi, so I just need to fix that. And then the next thing we want to do is we actually are going to be working not only with the token, but the auction itself. Because if you look at foundation, you'll see that these aren't just the tokens, but it shows you the information about the auction. So we have like the price when it's going to end and all this other metadata.
00:39:58.336 - 00:40:55.968, Speaker B: So what we want to do is we want to add an additional smart contract, which is going to be the auction contract, and that is also available here. So you see that it kind of lists both of them. So what I'm going to do is I'm going to go ahead and open our smart contract. I'm sorry, open our subgraph and I'm going to go ahead and just update our yaml to have not only this contract, but we're also going to add this market auction contract. And for each data source we're defining event handlers. So for the token contract we have the handle IPFS path updated and the transfer transfer is kind of going to be called whenever a new token is minted. And then IPFs path updated just means someone's actually changed the location of the metadata for that token.
00:40:55.968 - 00:41:28.112, Speaker B: So we're going to be kind of handling both of those events. And then we have the market auction contract here. And the only handler that we're going to be dealing with right now is reserve auction created. You probably want to also listen to reserve auction updated if something was changed to deal with that. But for this example, we're kind of trying to go maybe a little as simple as possible. A couple of other things that we have here that are interesting, I think are the start block. So here we're kind of saying we don't want to start from the beginning of time.
00:41:28.112 - 00:42:03.790, Speaker B: Let's go ahead and skip all of the blocks that did not even exist or our contract did not exist at that time. And let's go to maybe when the contract was deployed. So that's typically what you typically set for the start block is like the block that the contract was deployed. And then that way you're kind of saving resources by not indexing everything. And then the other thing that's interesting is the entities. So these are kind of going to be the pieces of data you would like to be stored and available for querying. So the entities that we've kind of checked out so far are.
00:42:03.790 - 00:42:21.170, Speaker B: Well, if we go back here to subgraph examples, you could consider NFT market auction as an entity. You could consider NFT as an entity. Anything that is an actual know or a map would be considered an.
00:42:22.760 - 00:42:37.016, Speaker A: So it's like things like ens. Then the entities are domain name transfer, domain name. With the centralized market, it's wearable, it's estate, those type of things. So those are the domain specific categories of things that you have.
00:42:37.198 - 00:43:07.164, Speaker B: And the two entities that we have are token and user for the token smart contract. And then for the auction we have NFT market auction. So the way that we can define these is in our graphql schema. So I can go ahead and kind of create basically types for each of these. So we have a token type, a user type and an NFT market auction type. And these correlate directly with our entities. So here we have NFT market auction.
00:43:07.164 - 00:43:41.550, Speaker B: And here we have NFT market auction. And you can actually look at the arguments here. And these are going to map also to the fields that we kind of want to save for the most part. And then we could also create our own fields that kind of combine other and deal with other pieces of data. But for the most part you could kind of get started by just indexing whatever data is coming off of the event. So here we kind of have these arguments and here we're going to kind of like save those with identifiable fields. So we're going to index the seller, which is going to be like an id, an address actually.
00:43:41.550 - 00:44:39.932, Speaker B: We have the duration of the auction, the reserve price, et cetera. And then one interesting thing is that we're also able to map relationships. So here we see that we have the token is actually of another type token. And here on the token type we're able to kind of then get that metadata from there, which is really nice. And then another thing is also one to many relationships where we have a user with many tokens, which is a pretty interesting thing that you can do. And all you need to do is kind of use these directives that are supplied to you by the graph add entity is the directive for actually creating an entity that can be stored and derived from, allows you to define one to many and many to one relationships. So we have our schema defined and this maps to our entities in our subgraph.
00:44:39.932 - 00:45:23.500, Speaker B: Yaml the last thing we need to do, or actually, you know what, we also need the APIs for NFT market auction because we're kind of like referencing this NFT market auction. So let's go ahead and create that ABI. And the only thing we need to do to kind of get that is we're going to go to the address here, same way we did earlier. We're going to go to the contract and we're going to go get abis down here and we should be able to go ahead and save those here, format those.
00:45:23.650 - 00:45:23.964, Speaker A: Cool.
00:45:24.002 - 00:46:10.456, Speaker B: So we have our abis, we have our graphql schema, we have our subgraph. The last thing we need is our mappings. So to generate our mappings, I'm sorry, to build our mappings, we actually can generate some code that is going to be based on a combination of our abis and our graphql schema that make it really easy to kind of write some of this code. And to do that we can go to our CLI and we can actually run the code gen command. This will go ahead and generate a bunch of code for us. So now we should see a folder called generated and this contains a typescript schema as well as some other helpers. And this is actually really nice for being able to do type checking and stuff in our mappings.
00:46:10.456 - 00:46:54.504, Speaker B: And the mappings again are the things that we went over that kind of define how you handle the functions that are called when an event is emitted. So the first thing we'll do is we'll go ahead and import our imports. We're importing some stuff from the NFT market auction as well as the token that was generated for giving us ideas around different functions that we can call. And then we also have the schema itself. And I know we're kind of getting close on time, so I'm going to be kind of going through the rest of this kind of fast. But the three functions that we want to deal with are handle transfer, handle token URA updated and handle auction created. So I can go ahead and create each of those.
00:46:54.504 - 00:47:29.670, Speaker B: And here this is kind of a basic really example of what you typically would write in one of these functions. We're basically going to be handling a new auction created. And that means that this auction did not exist. We don't have to worry about going and fetching it already because we know for sure this is brand new. So we're going to create a new NFT market auction. We're going to then load a token using the token id that comes in as a parameter and then we check to see if the token exists. If it does not, we just return from the function and if it does exist, we go ahead and add a bunch of metadata and we save it.
00:47:29.670 - 00:48:04.304, Speaker B: So I will show where this code is located later because it's all open source. And I'm just going to go ahead and create the other two functions as well. So we have the handle token URL updated and handle transfer functions as well. And these were all the ones that we kind of defined in our subgraph, Yaml. And that's it. So we have our yaml, we have our schema and our mappings. Those are kind of like the three main things you need to do this.
00:48:04.304 - 00:48:21.540, Speaker B: And the last thing we want to do is we want to authenticate and you basically can authenticate by using this access token. So I think I forgot the API for authenticating. So let me go ahead and google that. I mean, go to the graph docs.
00:48:23.740 - 00:48:35.532, Speaker A: Yeah, so that's authenticating with the graph to say, okay, this is my subgraph. Yeah, deploy it.
00:48:35.666 - 00:49:05.860, Speaker B: All right, so I'm going to go ahead and copy this code here so it's graph off deploy and then I can kind of copy this access token here. All right, so we are set, we should be able to kind of deploy this. So let's go ahead and try to deploy this. We read a lot of code, so I don't know if this is going to work for sure, but we'll see. You can do yarn deploy or NPM run deploy. And this should go ahead and deploy your subgraph.
00:49:13.900 - 00:49:54.070, Speaker A: It uploads the subgraph to ipfs, so it stores all of the things that you just created on ipfs, so it's available through decentralized storage. And that's important because then whoever uses the subgraph can then inspect how you actually get your data, that you don't say, hey, here's the foundation subgraph. And actually for half of the NFTs you say, well, the owner is data. Or the other way around, you could of course do a lot in those code files. You want to make sure that they are verifiable, and in this way they are.
00:49:54.680 - 00:50:15.352, Speaker B: So it looks like it uploaded successfully. Looks like I just switched that. Yeah, so it looks like it kind of uploaded successfully. So it kind of gives us the idea of our build. It tells us where it was deployed. And we should be able to go ahead and refresh here and see that we are syncing. So we have that syncing and we're at 93.3%.
00:50:15.352 - 00:50:19.956, Speaker B: That just means that we skipped like the majority of the blocks on Ethereum.
00:50:19.988 - 00:50:25.820, Speaker A: But it started at that block that you indicated, and it starts scanning the chain for those events specified.
00:50:27.840 - 00:50:49.812, Speaker B: And the cool thing is though, we actually see that we have some entities that are being indexed. So we see 324 entities. Now, if I run a query, we might not get any data back. Oh, we are getting data back, I was going to say, because it's still kind of early, but I guess since there's 324 entities, or 390 entities, we successfully deployed a subgraph. That's exciting. I'm actually surprised that I was able to get that working with.
00:50:49.866 - 00:50:51.216, Speaker A: Yeah, congratulations.
00:50:51.408 - 00:51:23.344, Speaker B: No errors. So let's look at the front end that I built on top of that. But before I do, I just want to show you the code for this subgraph. So if you go to my GitHub, you'll see that I have two repositories. I'm going to share these with the host, and he can basically, hopefully share these as well. But I have the foundation subgraph, which is essentially the subgraph I just built with all the code. And I also have the UI that I'm going to be showing here.
00:51:23.344 - 00:51:57.480, Speaker B: It's called Beautiful Uis on Ethereum. It kind of know, basic would show you how to query data and render it. So, like with the graph, we're just using GraphQl. So you can basically use any graphQl client, but we have some docs called under the section querying from your app that show you how to basically do this. And there's a few different clients that are popular out there. I think two of the most popular ones are Apollo client and Urkel. And either one of these allow you to kind of use a client.
00:51:57.480 - 00:52:22.770, Speaker B: You know, before we were doing these types of queries from the UI, but on the client, you would just basically need to kind of adhere to this API and you should be able to query data. And I have an app that I think is already running on localhost, $3,000.
00:52:23.720 - 00:52:28.500, Speaker A: What I think is the URL to your repository in the chat.
00:52:28.840 - 00:52:56.590, Speaker B: Thank you, I'll share that. And here we are. This is basically an example app that is using the same graph that we just deployed, and it's actually rendering these on a client app. You'll see that's a little bit slower than foundation. Like if I refresh foundation, you'll see that everything renders a lot quicker. Again, I think they're doing some better image optimization and video optimization than I'm doing.
00:52:59.440 - 00:53:13.860, Speaker A: Actually about. Because presumably those images are stored on ipfs and maybe they're loaded from ipfs by the browser, or maybe the browser loads them from some pinning or caching server.
00:53:14.200 - 00:53:24.330, Speaker B: Yeah, I feel like they're maybe running some type of function that basically optimizes them, reduces the size perfectly or something.
00:53:26.140 - 00:53:31.928, Speaker A: Because here we're kind of like the full size artworks is going to be a lot of data that, right?
00:53:32.094 - 00:53:49.880, Speaker B: Yeah, a lot of these are huge, but this is it. We're kind of getting the price, we're getting the name, we're kind of getting the actual rich content, whether it's a video or whether it's like a GiF or a JPEG or a PNG.
00:53:50.040 - 00:54:11.236, Speaker A: Such optimizations. Could you do that in your subgraph? It's like, okay, in the subgraph, I know this is some metadata. I'm going to check that. Okay, it is a PNG or a jpEg. I'm going to run it through some processor to make a small, large or medium and a large. And I'm also going to store those in the subgraph or no, probably that.
00:54:11.258 - 00:54:47.068, Speaker B: You can do from those mappings. But the idea for the subgraph is that most of the data, or all the data, really, right. Needs to be verifiable and it needs to be coming from a public data source that we know is going to be giving true data. So the more that people go out there and make calls to other services and stuff kind of often will erode the trust that people might have in that data. So I think there are limitations around what you can do as far as calling other services. But it would make sense though, like you mentioned, to do something like that. So I'll have to investigate.
00:54:47.068 - 00:55:04.388, Speaker B: I know you can pretty much write a lot of different assembly script and typescript code that does different stuff, but as far as how far you can go with that, I'm not sure, but yeah, that would be interesting. I think it would be a cool blog post or something for us to put together to show how to optimize images from ipfs.
00:55:04.564 - 00:55:09.576, Speaker A: Yeah, definitely. And maybe the foundation team wants to share how they did it.
00:55:09.758 - 00:55:39.170, Speaker B: Yeah, they've been sharing a lot. I mean, I really like their dev site. It's really nice that they spent the time and put that out there, but that's it for me. Man, I hope everyone that was checking this out kind of learned a lot. We did cover a lot, but I think the three main parts that you can kind of really focus on if you want to become a subgraph developer, and it's cool because now we're doing the decentralized network. You can actually make money by deploying a subgraph if people use it. So that's pretty cool.
00:55:39.170 - 00:55:59.960, Speaker B: The three main things though are like understanding your graphql schema, understanding how to write the subgraph yaml, and then understanding how to write the typings. So those three things put together, you can pretty much do anything. So if you want to become a subgraph developer, those are the things that I would probably tell you to focus on. Yeah, so I'm going to go ahead and stop sharing my screen, I think.
00:56:00.030 - 00:56:26.144, Speaker A: Yeah, awesome. Yeah. Very impressed that it all worked together. One short note about what you said about making money in subgraphs, because now you showed what would you do to create a subgraph? And then that of course has to be run by someone. Somebody has to take the effort to actually run your code, to process blockchain, to put that somewhere. And that's how the token model works for the graph. Right.
00:56:26.144 - 00:56:37.828, Speaker A: People stake on certain subgraphs and they think, well, the one you created is very good and will actually be used. So I'm going to put my tokens on there and then they get rewarded if it actually gets used.
00:56:37.994 - 00:57:06.220, Speaker B: Yes, that's exactly right. There's different people that play different roles in the protocol and the network. So you have people that are running indexing servers, you have people that are basically staking on a subgraph or they're staking with an indexer and it's essentially like signaling like, oh, I think this is a trustworthy individual or trustworthy source of truth, therefore I'm going to stake and then I get a percentage of those rewards.
00:57:06.640 - 00:57:20.210, Speaker A: Yeah, cool. And of course people can find more on the grass site and various resources there. And my other question was about your front end. Which frameworks, platforms, libraries that you use for the front end?
00:57:20.660 - 00:58:04.880, Speaker B: Yeah, so I'm using react with nextjs and then I'm also using tailwind for the styling. And I use react with nextjs because it does like server side rendering and static site generation. So if you ran a build and deployed the site, it would be a little bit more performant while also offering kind of the flexibility of client data fetching and stuff like that. Yeah, I think it doesn't really like, I wouldn't say it's like that big of a deal to use something like that over just a regular single page application framework like React or view without the server side rendering. I just have been playing around with next JS a lot so I kind of enjoy using it.
00:58:05.030 - 00:58:37.640, Speaker A: Yeah. Cool. All right, well, we're at the top of the hour. I want to thank you very much. This was really impressive to, in such short time span show it actually work. If you want to learn, dive into the code, links are in the chat and of course we'll put some links to further graph resources there. So yeah, thanks very much for coming on today, Nader, and for all of the audience attending and hopefully learning a lot as I did and yeah, thanks a lot.
00:58:37.790 - 00:58:40.660, Speaker B: Thanks for having me, Andre, being here. Cheers.
