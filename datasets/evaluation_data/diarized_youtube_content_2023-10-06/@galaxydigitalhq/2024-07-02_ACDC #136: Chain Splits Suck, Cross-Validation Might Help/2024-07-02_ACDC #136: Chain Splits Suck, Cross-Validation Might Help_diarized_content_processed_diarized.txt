00:00:10.480 - 00:00:52.722, Speaker A: Welcome to the Infinite Jungle. On today's show I'm going to be summarizing all core developers consensus call number 136 ACDC 136, where developers it was a pretty uneventful call, so developers did not give very many, did not make very substantial decisions on the call. But there were some pretty funny and interesting tidbits for the call this week that I will be talking about on today's show. Before we get started with the show, I wanted to give a quick programming note. There will be no Infinite Jungle episodes published next week. Next week is the week of July 4. It'll be a holiday here in the US, so we're gonna take a little bit of a break.
00:00:52.722 - 00:01:23.246, Speaker A: There will still be an infinite jungle episode for tomorrow. I do an interview with an old colleague and a good friend, Sal Khadir, who is the co founder and CEO of Bullpenhe. So you can still look forward to an episode of Infinite Jungle tomorrow. But for your awareness, to my dear listeners, next week there will be no Infinite Jungle episodes. And happy 4 July to everybody who observes. So before we get started with the show, here is a quick show disclaimer.
00:01:23.358 - 00:01:39.900, Speaker B: I need to remind you to please refer to the disclaimer linked in the podcast show notes and note that none of the information in this podcast constitutes investment advice, an offer, recommendation, or solicitation by Galaxy Digital or any of its affiliates to buy or sell any securities.
00:01:40.020 - 00:02:45.270, Speaker A: All right, so the latest all core developers call was quite the uneventful one. Developers shared some quick updates about how they're progressing with the Pektra upgrade. This is the upgrade that developers have jam packed quite a few code changes into and are now aggressively working towards trying to implement all of them. Developers shared that picture Devnet one the next testnet, activating all of the code changes in a very controlled, closed environment for developers to see how these code changes interact with one another and how they perform that. Petra Devnet is very close to being ready to launch, but they are still waiting on the readiness of execution layer client teams. So I would imagine that in the next couple of days, definitely over the next week, Pectra devnet one will go live. Developers did share that the next devnet devnet one for the peer Das code change has already gone live.
00:02:45.270 - 00:03:52.580, Speaker A: As a little bit of a reminder, Peer Das is the upgrade that developers are going to rebase on top of Denkun. The upgrade that just went live on Ethereum and is already activated on Mainnet is the Denkun upgrade. Because pure Das doesn't require a hard fork to activate and pure DAS is one of those code changes that does require it's very complex. It requires quite a bit of testing and development to really make sure it is safe to activate onto the network. Developers have decided not to test and implement peer Das alongside the other Pectra eips. Developers are going to test peer dast kind of in a silo on its own, on top of a version of Ethereum where Denkun has already gone live. And later, once Pectra eips are already finalized and once Petra eips are more or less stable, they will rebase peer Das on top of those Pectra Eips.
00:03:52.580 - 00:05:26.660, Speaker A: I guess if also the peer Das code change is finalized and stabilized and ready to go, they'll start to to move it over and merge it with the other Pektra eIps. So for now that Testnet, that Devnet for peer Das has gone live and developers are working towards it, they did mention that there were a couple of bugs already that they found in climate implementations for peer Das, but that they've launched that and it's good to go. They're going to be working towards the next Devnet Devnet two for peer Das just as soon as all those bugs from the first devnet are resolved. Developers also shared some updates for two other code changes that are related to updating Ethereum's data serialization methods to a serialization method called SSC. EIP 7688 and EIP 76493 are two co chains that haven't been included in Pectra but that developers are working towards. And so there were some updates on various clients that have already implemented or working towards implementation for those two eips, and some pretty funny conversations about whether or not developers should really start committing to having those two eips formally included in Pektra by adding it into one of the pectra devnets. So these were some of the smaller updates that were shared about the Pectra upgrade.
00:05:26.660 - 00:06:30.280, Speaker A: There were two other topics also discussed on the call, and they were more research related. These topics are nothing. They don't have immediate implications for what developers should be working on alongside of Pectra. I mean, developers have quite a bit on their plates already as it relates to the pectra upgrade alone. But these were two research, ongoing research initiatives that certain developers wanted to give an update on and ask for feedback on so that they don't get stale, and so that the research work also continues to move along, albeit at a slower pace. So the first one was shared by a researcher at Nethermind. The research was related to a study done on how nodes, people that run software to connect to the Ethereum blockchain, how these nodes can better report what client they're using to connect to Ethereum.
00:06:30.280 - 00:07:52.088, Speaker A: Ethereum very uniquely has a diversity of many different clients, many different softwares that users can choose from in order to connect to Ethereum and validate blocks and verify the rules of the network. You have five different execution layer clients and I believe five other consensus layer clients as well. You have to run both in tandem if you really want to run the full Ethereum node and behave as a validator on Ethereum, aka earn staking rewards and there is a little bit of a concern that on the execution layer side, the vast majority of node operators run a single client, the geth client. And so there were some concerns that if the geth client gets too adopted in relation in comparison to some of these other clients, then a bug in geth could have very catastrophic effects on the liveness and the, and the security of Ethereum. And this is a bit of a controversial topic, too. We talked about this in my interview with James Prestwich very recently, last week. But it takes quite a bit of resources, and building a client for Ethereum is not an easy task.
00:07:52.088 - 00:09:17.400, Speaker A: It requires a very high degree of technical expertise on how Ethereum works, and it takes a lot of resources to just continually maintain and update, because the Ethereum developers are constantly changing the protocol of Ethereum and constantly changing what client versions actually work to connect to Ethereum and what client versions don't. Usually the client version that you run could become obsolete within six months, especially if Ethereum completes a hard fork upgrade. So the Nethermind team had received a grant from the Ethereum foundation to be able to study and do work on how nodes can better report what clients they're operating. A lot of the data that we have on the majority of Geth, on the percentage of node operators that run Geth is based on self reporting on major node operators choosing to declare to the public. I run this percentage, this many geth nodes, and then I run a few nodes using the Nethermind client or some other client. And this isn't always the most accurate or the most sustainable way to get information about what clients are being run. This would require these large node operators to self declare, and who knows, maybe one year they decide not to declare and share that information.
00:09:17.400 - 00:10:56.856, Speaker A: It also doesn't really, it's also very hard to get information about the tail end of node operators. Node operators that are not large businesses, they are perhaps solo stakers or independent validators that just run one piece of software. It is very difficult to get information about what kind of software they're running if there's really no formalized process in which that data can be shared. So the Nethermind team shared three different approaches to be able to get that data, for node operators to be able to share that data. And they evaluated each of these approaches based on how the node operator can keep their technology, their hardware, hardware, other details about their operations, completely private and anonymous. And one of the solutions that had been shared, that had been further looked into by the nethermine team, is this idea of perhaps the information about a client can be included in the graffiti field of block node operators that propose blocks, validators that propose blocks on Ethereum, as they're proposing, they can include a little bit more information about their client in the block that they propose to the network and they get rewards from. But this approach is very bad for node operator privacy, because it's very difficult to try and anonymize then who the proposer was and the information and the information that they include in that graffiti block will of course be linked to the node operator that proposed it.
00:10:56.856 - 00:11:56.416, Speaker A: So it's a little bit hard to keep certain information about the node operator anonymous. And there were different kind of approaches that would allow validators to aggregate that information and finally be able to see what percentage of the network is running geth versus other types of clients in a more aggregated fashion. So there was, so the research for that is actually linked in the call notes. And the Nethermind team did request more feedback and more comments on it from the Ethereum community. So if you're interested in diving a little bit deeper onto those three approaches, I'd recommend clicking on the detailed show notes, the detailed summary that's linked in the show notes, and it has all of that information about the study. The second research item that was shared on the call was shared by Peter. He's a geth developer, a very long time geth developer.
00:11:56.416 - 00:13:21.260, Speaker A: And back last year, during back last, in November 2023, he shared this kind of new idea for making Ethereum more resilient, even if Geth continues to be the majority client that's operated on Ethereum. So even if there's a catastrophic bug in Geth that impacts 60 or 70% of Ethereum nodes and takes it down, is there a way to kind of prevent the, the ensuing kind of pandemonium that would happen on the network? And there are two different flavors of what could really happen. First, Ethereum could experience just a bit of delayed block production. There could be a bit of downtime when transactions that are included in a block. A validator just fails to be able to include those transactions and propose the block ultimately, which means that the chain gets stalled, the networks get stalled, and transactions are finalized for a period of time. That problem is not really the problem that Peter is trying to really solve for with the solution that he has been testing. He's really trying to solve for the problem of if a bug in Geth makes it so that 60% of validators produce invalid blocks, they produce a series of blocks that are built using maybe a slightly different rule.
00:13:21.260 - 00:14:34.184, Speaker A: And it makes it so that these validators get split off, forked off, and separated from blocks produced by the rest of the network. The other, you know, we say 40% of validators, for example, that are running other clients, and it creates this chain split, a continued chain split. And somehow developers would then have to figure out a way to bring back the histories of Ethereum together. They'd have to choose, well, maybe those 60% of validators lose, they get penalized for producing these invalid blocks because of this bug. They have to upgrade their geth software, they've lost some money, and now they have to revalidate the correct chain and catch up to the version of the chain where the bug did not affect the other clients and the. Yeah, and then the validators that are running the correct clients so that they can continue to validate the correct chain all together with the right software. So as you can see, there's actually quite some, what do you call it? There's some issues that arise when you have client diversity, as wonderful as that term kind of sounds from initially, like when you just hear that word, like, oh, client diversity.
00:14:34.184 - 00:17:18.852, Speaker A: Having a multitude of clients, that sounds great. There are some bits of weaknesses that client diversity can present to the network, and some thought experiments of what happens if there is an equal, a pretty equal split between different clients? What happens if two thirds or certain amount of clients gets kicked off the network? And how do they get back onto the network? How do they get back onto the correct chain? And will the Ethereum community be okay with a very large percentage of validators losing their money? So these are all kind of questions that Peter had shared in his initial post back in November. And in that post he outlined this idea of, well, what if node operators could opt in to validating, verifying their blocks with not just one client, but multiple? So this was a very different idea from requiring node operators to run multiple clients. So instead of running a full geth node and a full reth node and a full Aragon node, and in that way, you know, increasing, decreasing the likelihood that you get caught, caught up in a chain split, or one of the bugs of these clients starts impacting your revenues as a validator and staking node operator, what if you could have it so that you just run one client, but you can cross validate the blocks that you are proposing to the network with other clients? So if I'm a geth node and I propose block, what if I could validate that block with anothermind client and with a Aragon client? And in the event that the verification fails, and it shows that there's some discrepancies between that block and what was expected by some of these other client softwares, then you could trigger, you could automatically kind of prevent that validator from proposing the block. And so in that way you could prevent instances where invalid blocks gets proposed to the network. So this is called execution layer cross validation, El Cross validation. And back in November, it was an idea, a theory of like how would this look? And on the latest dev call, Peter shared that he started to, he and his team at Geth started to implement the idea in the geth client, and they ran some benchmarking tests on it of how much latency that would add to running your node if you were to cross validate it with other clients, client versions.
00:17:18.852 - 00:18:43.652, Speaker A: And he shared some pretty interesting numbers. He said, quote, it's about a 20% performance hit to block imports. He thought that that was very cheap, that just the increase of 20% increase in block importing times was really not that much for the benefit that you could get for verifying these blocks. And he got quite a bit of questions, of course, from other developers about other benchmarking tests that would be very helpful, and also the complexity of trying to implement something like El cross validation, because that would require significant changes also to the engine API, which is a piece of software that allows the execution layer and the consensus layer to communicate with one another. And so these were all very preliminary questions about the real concrete details behind the implementation that Peter and his team have been working on for the last couple months. And really the takeaway was that developers will continue to explore this idea. But there was quite a few developers on the call also that kind of expressed their concerns about putting all of their resources into really making elcross validation a reality on Ethereum, especially when developers are working on several other changes to the engine API for the Pectra upgrade.
00:18:43.652 - 00:19:42.978, Speaker A: And there are certain developers also working on upgrades after Pectra, like the vertical code changes that are coming up and this not being really like the highest priority on developers minds. So two interesting research initiatives that I'm sure we will hear about on future calls. But there weren't really concrete takeaways, I would say, for there weren't that many concrete takeaways for what developers needed to decide on right then and there. A few decisions that I will highlight kind of in the last couple minutes of the show though, about what to expect from Pectra. So we heard some of these minor updates on how Pectra code changes are developing. And of course the next real milestone to be looking out for is Pectra Devnet two and peer das devnet two. Pectra Devnet one of course is not live, but as I said, it will probably go live post haste.
00:19:42.978 - 00:20:33.910, Speaker A: They're really just looking for maybe a handful of execution layer clients teams to be ready for implementation on Devnet one. And I think a lot of execution layer teams are close and also the spec changes, like how much the code changed really from Devnet zero to Devnet one I don't think was all that big. But for Devnet two, a lot of major questions. There's a lot of major things to watch out for and stay tuned for. So for pectoral Devnet two, one of the things is around EIP 7702. This is the code change that's supposed to help the usability of Ethereum, especially as it relates to the flexibility of user owned accounts, eoas on Ethereum. And developers haven't figured out the revocation mechanism for this EIP.
00:20:33.910 - 00:22:02.392, Speaker A: So one big question is whether or not developers will have finalized that EIP and finalized those details for EIP 7702 in time for testing on Devneta in time for testing on Devnet too. And the second one of course is SSE, those eips that developers are continuing to implement that will impact the serialization that will create improvements, the serialization method of Ethereum right now, will those eips get included into Devnet too? Because there are certain developers that really want it in. But of course there are others that say Pectra is already big enough as it is. So that will be another area of decision making that developers did not get to on this call but will have to get to in the near future. And then finally another kind of major co change that developers are way that have already agreed to include into Pectra but haven't included into a Devnet yet, is EOF. Will eof eips get included into Devnet too? I think that's another kind of big area of questioning that developers, a line of questioning that I think developers will have to come to terms with for Devnet two and the launch of Devnet two. So lots of changing scope, I would say, for the upgrade as we move along these devnets.
00:22:02.392 - 00:23:15.820, Speaker A: This is something that I shared quite a bit on these episodes before, but that because the scope of Pectra is so large, developers aren't able to test everything all at once. And what will eventually make it into Pektra, to figure out what will eventually make it into Pectra and what will perhaps be split out into a separate hard fork. All of that depends on what gets into a devnet and the testing progress that happens on devnets. So important to continue to kind of follow along on the Devnet progress for these upgrades, and also really kind of important to follow along about the nature of these code changes for Ethereum. I think for this Ethereum upgrade, Pektra, there's quite a bit of code changes that are trying to tackle different elements of Ethereum's future vision of what Ethereum wants to be. There are certain code changes that will help Ethereum be a data availability layer for Rolla. There are other code changes that will help Ethereum be a hospitable environment for smart contract developers for execution layer focused code changes like EIP 7702.
00:23:15.820 - 00:24:36.680, Speaker A: And then there's a bunch of other upgrades that are really focused on making Ethereum more resilient and more secure and more decentralized as well. But there are different competing priorities, I think, and a lot of these priorities, these developers are trying to implement it all at once in Pectra, but it's clear that they will have to prioritize some over others in the process of scoping out this upgrade. So I think that's another kind of big area of the pectoral development to keep watching out for, of how priorities behind these code changes change and how perhaps certain developments in the Ethereum system itself will push and give greater support for certain upgrades being implemented ahead of others. So yes, lots to keep thinking about and lots to keep watching out for as it relates to Petra upgrade development. I will be back for another summary of the Ethereum dev call in two weeks. Developers will still have their regular ACDE call next week, but I will not be covering that one. I will cover the next one after that.
00:24:36.680 - 00:24:58.240, Speaker A: So thank you so much for listening to another episode of the infinite Jungle. I hope you learned something new about Ethereum, and I hope you will join me again for another episode in the future. I am signing off from New York City, the concrete jungle in your explorations of the infinite jungle that is Ethereum. Stay safe out there.
