00:00:14.160 - 00:01:09.894, Speaker A: Welcome to episode ten of Unlayered. After a brief hiatus for July 4, we are back with an amazing slew of guests starting today with Kevin. Kevin's been a big fan of the podcast, and you, a close friend of ours. We've been talking on and off with for months now about this topic at hand, which is blockchain basics. And by way of introduction, Kevin is a former embedded engineer at Apple with focus on signal processing, and he worked specifically on the AirPods team, former Solana Labs core engineer, and during that process actually discovered his passion for developer relations and has recently transitioned over to a role as a developer relations engineer at Monad Labs. So super exciting. And obviously he has a very interesting background across multiple blockchain ecosystems, which is why I think kind of the perfect guest for today's discussion.
00:01:09.894 - 00:01:22.514, Speaker A: Kevin, why don't you tell us about your thoughts on blockchain basics and why you think this convo is so important to have.
00:01:22.674 - 00:02:31.914, Speaker B: Yeah, so just to give some background, you know, we've been chatting about this for months. I think, you know, me, Sal and Dave kind of came together, actually, over this conversation. I was fed up with, like, simplistic explanations of blockchains. You know, this, like, blockchain trilemma, while it's a good abstraction, like, it was kind of presented for a very specific, like, scaling trade off, right? It was botalic discussing sharding, right? And it's been like, uniformly applied to, like, every construction of blockchain since, you know, as if it's like, as legitimate as cap theorem, which has like, actual, like, math and theory behind it, and peer review, you know, and so, like, I find, or I have found that that's like, actually hindering kind of adoption and like, the view of blockchains. And that's, you know, working in alternative ecosystems, that's become pretty frustrating because essentially there's this predominant view out there. Engineering is really simple, and that if you don't build this one way, then it's wrong. And I think when you're practicing engineer, you realize everything is just a series of trade offs.
00:02:31.914 - 00:02:43.680, Speaker B: And not giving airtime and light to the actual things that make up those trade offs is actually hindering the understanding of what blockchains could be or are currently.
00:02:43.872 - 00:03:04.512, Speaker A: I guess the thing that I've noticed is it seems like anything that doesn't come out of the kind of ethereum, academia side in terms of blockchain architecture and how to scale long term is almost disregarded as not valid. Have you noticed that? And obviously, I don't think you have that view. Like, there's many more approaches that I think could be feasible as well.
00:03:04.688 - 00:03:37.770, Speaker B: Yeah. So I think this comes kind of down to the difference between research and actual practical development. And what you find is there's research leaning institutions that if something isn't peer reviewed, it is kind of viewed as invalid. And then there's another school of thought that's move fast, build prototypes, prove it works. I think both these things have merits. Like, at a certain point, research is, you know, research can go on forever. It's an open question.
00:03:37.770 - 00:04:14.736, Speaker B: And, like, engineering is all about, like, taking research and putting it into practice. And so there's definitely, like, this, you know, dichotomy between the two views of the world. And I think both have value. I think Solana leans very heavily on the don't do research prototype, game it out. You know, like, the research is actually modeling it out, like building a prototype and seeing if it works. Whereas I think Ethereum leans very heavily on the, like, just do the research, do the peer reviews, make sure everything's really solid. I think practically, like, being a startup, you need to be somewhere in between.
00:04:14.736 - 00:04:25.924, Speaker B: Right. And so I just think most things in blockchains aren't black and white. And, like, it's worth bringing light to the fact that, like, everything is a series of trade offs at the end of the day.
00:04:26.424 - 00:04:35.096, Speaker C: Do you not believe that actually there are other factors to include within that? It's not just the case that it's only security decentralization.
00:04:35.280 - 00:05:23.104, Speaker B: Okay, security, right. That is a very, like, arbitrary term, like security. And what, like, how easy it is to hack the chain, you know, economic security, which, like, there's an argument that that's not even real because you can just steal stake from remote code execution attack, essentially, like, get people to run the wrong code on their validators and just steal all their stake. That's practically the easiest way. And so, like, it's not really like, oh, you have to acquire it on the open market. And so this question of security, it becomes a lot more nuanced than just saying, oh, there's a lot of economic value on the chain that doesn't actually capture the real attack vector with decentralization. It's like, okay, are you talking about Nakamoto coefficients like geographic distribution? There's so many things that go into that.
00:05:23.104 - 00:06:28.108, Speaker B: How many full copies of the state are there? How many full nodes are there? How easy it is to run a light client? How easy is verifiability? And I think just saying decentralization and looking at a single metric is really reductionist. There's also finalization times come into that and that has play into security as well as decentralization. How fast it is to sync and get consistency across a bunch of nodes, how fast do you have guarantees that what the chain tells you was confirmed is actually confirmed? Like finalized? And then, yeah, there's like scalability is. What does that mean? Like practically like TPS. But like, what if your transactions are bigger, you know, then like inherently you're going to have less TPS because they're bigger. And so like you need a metric, something like throughput, where it actually has like bytes per second, right? Something that's kind of uniform. And so I think like the, like the blockchain term is a very like subjective, kind of not really quantifiable thing where.
00:06:28.108 - 00:06:52.704, Speaker B: And a lot of people like equate that to cap theorem because it's somewhat similar. But whereas cap theorem has very hard to find definitions and is peer reviewed and understand throughout the industry, I think a lot of the blockchain trial in the term is just like, it's not clear how we measure these things. And especially in a world of l two s where you're modularizing everything, these trade offs become a lot more complex to reason about.
00:06:52.884 - 00:07:06.344, Speaker A: It seems like there's a lack of rigor, especially when it comes to this trilemma that keeps popping up anytime people try to compare blockchains. So maybe on that point, actually, how can we think about blockchains from maybe.
00:07:06.384 - 00:07:49.302, Speaker B: First principles, you can think about it as like a distributed database. So database is just like a series of independent servers with some memory and essentially instructions of code to run on them. And so there's hundreds of these is what we call full nodes, or thousands if you're a bigger chain. And essentially they're all essentially a ledger database. And so they track pieces of information that you send to them as transactions. You can think of these as just line items in whatever coding language telling you what to do. And then essentially this database on all these replicated computers goes ahead and executes those instructions.
00:07:49.302 - 00:08:57.283, Speaker B: Now, kind of the fundamental thing of why it's a blockchain is because these blocks, this kind of like this database that's getting updated, is replicated on every machine. And that's extremely important. In traditional distributed systems. There's something called availability, which is just how guaranteed are you if you hit a node to get something back? In a lot of these systems, not every node stores every piece of information. And so they'll maybe ping another node to get it in blockchains, it's actually really important that every node has the canonical state, essentially the same view of the world. Another thing is that because it has this replicated state, it doesn't necessarily inherit, but the way that they're designed and the principle that makes them blockchains is immutable history. And so like this state, as it progresses, you have some sort of ledger database, right about like, what were the things and the essentially like, data that went into that state transition function to bring it to the new state.
00:08:57.283 - 00:09:17.442, Speaker B: And so typically validators only hold in memory, like the current state, but then they have some amount of history. And this is actually dependent on chain. We can get into this a little more as we go down the rabbit hole here, how much history they actually store. Like bitcoin stores it all. That's fundamentally their perceptible.
00:09:17.578 - 00:09:21.450, Speaker A: The next question is, why do we need this type of thing? Why do we need blockchains?
00:09:21.602 - 00:10:33.788, Speaker B: The easiest way to put it now this is like hard for a typical person to understand, but it hits the problem nail on the head, is it solves the double spend problem. And that's like the byzantine general's problem. But okay, what is that? If you're not going to go read a textbook, what actually is that? It essentially guarantees that you have a shared state of the world on every machine, which means there's objectiveness about the truth of the world, because the ultimate goal is to be able to take a single copy and have assurances that what's on that single copy is the same thing on every other copy. And so essentially the double spend problem is, how can I guarantee if three people are in a room when I talk to one person, if I tell that same information to the other person, that I haven't told them two different things. And so I can't tell you I spent $5 and tell someone else they spent $10 and pocket the difference. And so that consistency problem is essentially part of what blockchain solve. Another very useful fact that falls out of this is like, in order to have consistency, you end up having shared state.
00:10:33.788 - 00:11:15.104, Speaker B: You know, like web one, right? We had protocols on the Internet, and it's just like TCIP, whatever. Like if you followed the rules, you were able to join, there's no policies, right? If you follow these protocols, you get this access. And so, like when you have this shared state, it essentially turns the fabric of the Internet into this like framework of arbitrary programs that people can just call. What this means for app developers is like, you're not subject to a distribution channel. Besides the blockchain itself. If you want to launch an app, you launch an app. If a protocol wants to support apps on a chain, they support the chain.
00:11:15.104 - 00:12:08.244, Speaker B: They don't support your app. It removes this segmented property that we ended up kind of falling out of web two from web one, right? People wanted to build businesses. What's the typical way to build businesses? Like, fundamentally, blockchains are social coordination technology, right? And so web two was like, okay, now we can, like, not just, like, read. We can read write, right? It was like, okay, we have this, like, communication channel. And, like, I bet you've heard this before, is like, you know, web3 is read, write own, right? But inherent in that own function, like, means that there's, like, a neutral arbiter saying, like, who owns what? And that neutral arbiter ends up being this, like, shared state, because you have guarantees that it's the same on every machine. You also have guarantees that you don't have to trust a single one of them. And it's.
00:12:08.244 - 00:12:57.028, Speaker B: It ends up being kind of like the Lord of the Rings thing, where it's like, the ring is too powerful. So, like, what do we do? We throw it into Mordor and let the power distribute. Right. And fundamentally, this poses issues for the way that we've traditionally monetized in web two, because I think web two was a lot about splitting up these segments on these neutral layers in order to create cost centers and profit centers to solve problems. Web three is throwing that up in the air and saying, okay, wait, actually, we can do these same things by just coming up with common sets of rules that everyone follows. The problem is, and I think a big problem with adoption of blockchains for web two companies is that's antithesis to their business models. They make the money by the walled gardens.
00:12:57.028 - 00:13:51.070, Speaker B: Apple doesn't want to open up its ecosystem. When you buy an iPhone, you buy AirPods, you buy a Mac, because they all work together. Blockchain is like, what if we could do that for all technology? And Apple or Google is going, wait, but then we have to work with all these other people. But it's odd because there's this dichotomy of like, okay, well, people are building on blockchains, and they, as long as enough people join that blockchain, they don't have those same issues, right? And so never everyone building on a blockchain gets the same distribution like you would have gotten in web one. And so, like, there's kind of this dichotomy of like, how do you move web two onto web3. And while I think that problem has been a little bit hard to get product market fit recently, like just with the advent of AI and what we've been seeing, I think it literally forces the issue. You need to be able to know if something's human or not.
00:13:51.070 - 00:15:00.614, Speaker B: You need to have some level of data sovereignty to say, AI, please don't eat this, it's mine. And when web two businesses start realizing this, I think they're going to see the necessity of blockchains because whereas I'm like a Google, right, they make a lot of money from their ads and, and, well, where do you see ads when you're browsing? You're going through different sites, you're doing a Google search, you're trying to find the right information. And as you're doing that, it's like contextually popping up ads for you in a world of AI where you can just ask a question and spits you back an answer. Google doesn't have this distribution channel anymore. Like, their profit centers are already disrupted and web3 and blockchains kind of provide this like new neutral fabric that they could plug into to actually, like, identify what's human, what's AI like, you know, serve content and stuff like that, essentially, like segmenting data in a way that can be accessed. And I, I think, like, this problem is still a little bit years away from being solved because fundamentally, like, the Internet doesn't understand blockchains, like in its native TCIP fabric. Like blockchains have their own protocol.
00:15:00.614 - 00:15:16.822, Speaker B: The Internet have its own protocol, but there's not like a browser that just is a blockchain where when you're pulling down browser code and rendering it, it actually understands this is coming from blockchain and therefore there's certain restrictions about who can access it.
00:15:16.958 - 00:16:34.658, Speaker C: I think just to put a pin on the point that you're making time and time again here, the difference, and really the breakthrough, I think, of bitcoin and of solving this double spend problem was being able to have a distributed, decentralized system. Because when everything is decentralized and you have loads of different nodes and certainly in a permissionless state, suddenly you can have that neutral, censorship resistant substrate, really, to all of these things that you're talking about. I always struggled slightly to contextualize this, the double spend problem. But I think prior to bitcoin, there were attempts at doing digital money, but they were centralized, because if it's centralized, then you can sort of, we can have one person who just decides what the ledger is and make sure that no one's double spending the money. But as soon as you try and open that up, and obviously those attempts didn't really work because I think the governments were just shutting down these centralized options. So I think Satoshi knew you have to decentralize it, you have to open it up to have this neutral substrate, as you say. And he was the one who sort of solved that double spend problem because suddenly as soon as you have more actors who are maintaining the same ledger, suddenly you have that issue of maybe different people are recording different transactions.
00:16:34.658 - 00:16:59.536, Speaker C: And that's how unfortunately, you can have slip ups basically go through and suddenly you can get a double spend go through. So I think that's the crucial blocker, really, to having decentralized systems was this double spend problem. And that's what bitcoin did. And that's just unleashed really this world of decentralization, neutrality, censorship, resistance. Is that about right?
00:16:59.720 - 00:18:03.020, Speaker B: Yeah, I mean, I think you guys just talked to Josh Rosenthal and like, you know, like the very first, you can almost think of it as the very first blockchain was double entry bookkeeping. You know, it's like. But that's between two trusted parties, right? So they know the other guy has the same thing in their ledger. And like when you get into that and like end parties, you know, the most obvious application of like fixing the double spend problem is money, right? So it's very like intuitive that the first application for blockchains would have been bitcoin, right? It falls out from that problem. Like just fundamentally now, I think, like the reason centralized ones failed before is because like, I mean, a nation states, two main powers are like the power of violence and the power of the purse. And so like, fundamentally you're saying, hey, nation state, we don't want you to have power of the purse, right? You do that in any centralized entity, like the government's going to crush you. And that's where censorship resistance comes in, very importantly.
00:18:03.020 - 00:18:41.278, Speaker B: And it's kind of the same model for web two companies, right? They're not going to move on the blockchains if you're saying, like fundamentally, like, we're taking away your power, right? And so you need to like provide another value prop. Beyond that. You can't disrupt web two and give them new value props if the only thing you're doing is taking their profit centers away. Like, you actually have to, like also solve problems. And all of web two was about like scaling it to solve those problems. So I think that's kind of where we're at, you know, in the blockchain system, it's like, okay, you know, money, it makes a lot of sense. Bitcoin solves store value.
00:18:41.278 - 00:19:15.074, Speaker B: It's decentralized, it's probably good enough for a while. I think the Ethereum cases an Internet bond is pretty strong and it's probably good enough for a while. But at some point it's like, okay, we need to move past monetary use cases. This problem is a fundamental community of science problem, and it can be applied to a lot more things. And it's just showing, hey, how we build these systems are going to solve these problems in different ways that can actually add value rather than just taking away actual profit centers for these businesses.
00:19:15.574 - 00:19:56.354, Speaker A: Basically, web one was just the original version of the Internet. And what made it powerful was that no one controlled it. As you said, TCIP was basically the only protocol you interacted with. As long as you knew how to do it. You could put your content on there and anyone could read it. And then web two, with this idea of read plus write, it brought down the barriers to entry for regular people to contribute content for others to read. But what it birthed was these control vectors in the form of companies like Facebook and these social networks, and even search engines too, where the price we pay for content aggregation and curation on behalf of consumers was that they got to decide who does what or who sees what and when.
00:19:56.354 - 00:20:31.108, Speaker A: Now, the reason why blockchains are so interesting, as you alluded to earlier, is that it's the same ethos as Web one, where it's bringing things back to this community owned permissionless world, where it's not just about users owning assets, it's theoretically no one owns the network. And at the same time, everybody owns some of these dapps based on how they're architected, we can marry a lot of these principles from Web two and web one to create, in our view, and a lot of other people's view, a better Internet that's more composable and more permissionless, while still retaining a lot of those benefits that we talked about.
00:20:31.236 - 00:21:30.384, Speaker B: This is where you have to get into discussions of how blockchains are built and what decisions these blockchains are making. Because as we've seen, permissionless blockchains, they're somewhat successful, but it's not like massive money is moving on chain. Yet when you talk to these companies, what you find is like they're a little hesitant of going like, fully permissionless, you know? And while that's what the people want, like something needs to force that issue. And like, I think with the advent of AI, we're going to see that very quickly. But beyond that, like, there are actual, like new value propositions you can make. It's more of like, how do we overcome those network effects and prove to web two that those value propositions, like, are big enough for them to change their existing business models? And the promise of blockchains is that you can do that. You're not gate kept from running that experiment.
00:21:30.384 - 00:21:57.054, Speaker B: Because we all have this control and because it's distributed, we have the ability to literally say with just the knit and grit of developers, we are going to prove it to you that we can build something better. I think the soul searching of crypto right now is we're finally getting the scalable enough systems where we can say like, hey, this is an actual value prop beyond just me owning my stuff.
00:22:02.914 - 00:22:49.988, Speaker C: I think one of the other core proponents of blockchains is their ability to get the flywheel going because you're sort of distributing the power and the value of that network to the crowd, if you like. I mean, bitcoin digital money wouldn't really have got off the ground if you couldn't get the common man basically to participate in the network and gain a reward from that network. So, yeah, so just when you're talking about how can we overcome the network effects? And also looking at sort of the web two, this recentralization of the web two, and these huge network effects that they built up, it really does feel that you need, you need these sort of distributed systems to have any chance really, of breaking that oligopoly.
00:22:50.076 - 00:23:48.404, Speaker B: Yeah. And I think you hit on something that's quite important. These blockchains, beyond just being distributed ledger databases, they have this kind of soft property of crypto economics. And what you see is that the most successful crypto apps are the use cases that make people go, oh, that's a good idea, are the ones that actually leverage the soft, squishy social side of blockchains. And so things like helium where it's like, oh, you're solving that last mile problem. Fundamentally, 5G towers have a 10th of the range as 4g towers. And how much investment cost does it cost for all these centralized entities to go and put up all these towers? You've solved this like, oh, I have a profit motive to then go put up a 5G tower to cover that last mile and partner with a bigger player and have a profit sharing incentive there.
00:23:48.404 - 00:24:30.628, Speaker B: You're essentially able to bootstrap these network effects. But you're not just bootstrapping them because, oh, it's shared state. It's that soft squishy thing that the property of solving double spend solves, right? That economic problem, that coordination problem. And I think like a lot of people building in web two tend to forget that, like that is actually one of the main value props. You know, they go to interoperability, they go to co pose ability, they go to like neutral parties. But the other like kind of special superpower is this like social coordination aspect and the ability to like bootstrap those network effects on your own.
00:24:30.716 - 00:25:15.002, Speaker C: Because again, it started with bitcoin and it basically said, follow the rules and you'll get money, you'll get a share of the network and hopefully it's going to go up in value. Don't follow the rules. And certainly on ethereum, we'll start taking your money away. Basically, you put money up and we'll start taking it away. So it's that sort of socio economic drivers really the game theory of blockchains, which as you say, it sort of fits the human side of blockchains, that's what you need to make them work because the rules have to be followed by humans just as they are by the software effectively. And so you need these sort of game theoretic principles in place to make sure that the humans also behave correctly, just as the software does.
00:25:15.098 - 00:26:22.704, Speaker B: Yeah, there's like that incentive angle, right? It's like not just coordination, but you have to like incentivize that coordination. And so I think, like a lot of people get pulled down like incentives in like a speculative form, you know, into this, like, oh, we can make number go up, you know, but I think these incentives are actually like much more fundamental and much more kind of the fabric of what makes the blockchain powerful. And the more apps and use cases that can think about those in non just monetary terms are really going to be the major unlocks. It's like, how do we use the superpower of coordination within an application? You know, going beyond just value transfer, like literally solving coordination problems such as the last mile problem with distribution or even payments. It's hard. It's almost one of the most obvious applications of blockchains is just payment rails being better. And it's like, okay, why isn't there any adoption? It's because there's no incentive to adopt a new payment system right now.
00:26:22.704 - 00:26:38.426, Speaker B: And like beyond that, there's just like there's scale and cost involved. And so like, I think the person that can like crack that nut is gonna like that's where you get like these really like interesting use cases, like deep in and stuff like that with.
00:26:38.450 - 00:26:58.066, Speaker A: These key primitives in mind. So we have this new super powered database that's called a blockchain. Now, I guess the question is, why should we care about anything that's not Ethereum? Didn't they figure it out already? Most people are using it. They have istvl, you know, so on and so forth. All these kind of metrics people threw out there. Why should we care about alternative designs to blockchains?
00:26:58.250 - 00:28:05.594, Speaker B: Yeah, and so I think this goes back to like the like trade offs thing. It's like Ethereum has made a very opinionated and very specific set of trade offs for what that community finds valuable. And not considering other designs is essentially saying that no other, like, ideological definition of that is valid, which is almost fundamentally against decentralization. If you want something to be decentralized and distributed, then you should want there to be other constructions and other avenues of exploration into seeing what's best. Fundamentally, blockchains are made up of three main things. There's data availability, consensus, and execution. Just to quickly give a summary of what each one of those are, and then we can dive deeper into each one, data availability is saying, like, okay, if I ask the network for this data, what's the guarantee I'm going to get it back? And how fast am I going to get it back? There are metrics that you can measure those properties by, and we can go into what those are.
00:28:05.594 - 00:28:52.306, Speaker B: But essentially the data availability problem is all about. Now that I have this history and this immutable store, when I need to use it in my app or do something, how fast can I get it, how fast can I verify it? Yada yada. Then there's this consensus problem. This is the other arm that blockchains kind of need to deal with. And this is like in cap theorem, it's actually like it's guaranteeing consistency. So it's saying that if I ask one node a question, it doesn't matter which node I ask, because they're all going to have the same information, and so I'm guaranteed to get a consistent answer back. The job of consensus is essentially to make sure that every full node has that same view of the world at some point.
00:28:52.306 - 00:29:56.670, Speaker B: It's this problem of how do we come to agreement on it? Then we have execution. Execution is the thing you hear most people talk about because it's the easiest to innovate on. You can just think of that as the operating system, macOS versus Windows and we might have like different computer developers. You might have like Apple who uses macOS, but then you also have like HP and Dell that use Windows, right? And so you can almost think of Solana and the SVM as like Apple Mac, right? And then like, you know, all these other chains that are EVM chains as like different computer manufacturers, but fundamentally they're all using windows. And so, yeah, consensus is kind of the easiest thing to innovate on because there's a lot of audio knowledge about like, okay, how can we change this to make it faster? How can we do these things? But because it's a blockchain, you can't think about it like a traditional computer. Like, there are trade offs that happen because of the other two parts that we talked about, consensus and data availability.
00:29:56.862 - 00:30:12.998, Speaker A: There's ways to, because I'm not even familiar with this, there's ways to kind of quantify, like one blockchain's and people abbreviate it to da oftentimes. But one blockchain is data availability versus another. How do you think about that? How do you compare? And maybe let's double click on that developer experience too.
00:30:13.126 - 00:31:13.154, Speaker B: So I think there's like two kind of maybe flavors of the data availability like characterization. I think one of them is much older. This is the BTC versus ae thing. It's like, how much of the history should a single node store, right? If this thing is going to run to infinity, there is some point at which the memory of a node is just expensive because there's a lot of history and it's been running for a long time. This was the small block, big block wars in Ethereum versus bitcoin. Bitcoin was like, ethereum is invalid because you can't sync from Genesis without an archive node, right? And like, in the bitcoin world, like, it's very important to be able to like start from the beginning and run all the way to the end and everything be there like every transaction, every historical state change and all that. Ethereum and like modern day blockchains, like high throughput blockchains.
00:31:13.154 - 00:32:40.774, Speaker B: The reality is, is that like, at some point the data, like, the state growth is just too big, okay? And so you have to kind of like, look at it as almost like a proof by induction. And so how that works is like you essentially have a base case that you assume is true, okay? And you have a set of rules that you assume is always correct. And if you move through that set of rules from your base case, you'll get a new state and you have a guarantee about that new state being correct, because the thing you started from was correct, and you believe that the steps to get to the next thing was correct. Right? And so if you can say that me moving, if you can prove, like, mathematically that the correct things happened when I moved from state zero to state one by induction is what it's called, you can prove that every state transition after that is also correct. And so using that principle, you arrive at a point where, okay, I can actually just store like some amount of historical state, but then checkpoint that with, you know, cryptographically secured, you know, either ZK or state routes or like merkle trees and stuff about, like, you know, hashes about things that happened before. And then when someone wants to come back to me from long, long ago and say, is this valid? They actually have the job of finding that data somewhere. You know, like, there are lots of teams, like, dedicated to kind of solving this problem.
00:32:40.774 - 00:33:27.354, Speaker B: Like Filecorn, Arweave, just like the graph does a lot of this essentially, RPCs do a lot of this, essentially, like taking everything past like a predefined, what most blockchains call an epoch worth of data. And essentially like, providing that against the little bit of data that's actually on the chain to say, this is valid from there to there. Now archive nodes and full nodes. Like, the idea is that you have all that state, but as these chains start to scale to infinity and these becomes like years and years, and running, there becomes a point where you just have to trust. Ten years ago, if we believed ethereum was valid, that it's valid today. If I run ten years of history, even though maybe I don't know what happened eleven years ago, this is just the reality of state growth.
00:33:27.894 - 00:33:40.102, Speaker C: So are you saying that especially with these highly performant blockchains, that there will be a point, or maybe there currently is a point where you just can't look into the history of transactions on that blockchain.
00:33:40.238 - 00:34:30.304, Speaker B: Yeah, it's more of like, you could. There's probably like a couple of actual providers that are, you know, like holding it like Filecoin. Like, I know Solana right now is in the process of moving everything, the entire historical state, to Filecoin, which is kind of like a distributed history, you know, like solution for like the very old state. But Solana nodes only store like an epoch in the node. So that's like, an epoch is like two and a half days on Solana. And then they also hold, I mean, you have to hold what you can't get around is holding the state of every account, right? Like, you have to know the current state of everyone's balance. But all those transactions that made it go from the next one to the next like that, you only need to hold like maybe an epoch, and then the rest gets pushed off to RPC's other data warehousing solutions.
00:34:30.304 - 00:35:03.940, Speaker B: There are like entire blockchains dedicated to solving this problem. Like Genesis. Go on, Solana. Are we've filecoin. This is just a reality of what high throughput chains are going to have to deal with. What that ends up being is it's what web two people do is if you're building an app and you care about the data relevant to that app, then you should have an RPC storing the historical state relevant to that. Apparently you can always verify that states correct against the blockchain.
00:35:03.940 - 00:35:08.172, Speaker B: But when you want to serve it up and do things quickly, you have it locally and you can do that.
00:35:08.268 - 00:35:28.902, Speaker A: Kind of to add some more numbers to this, because you mentioned Solana nodes storing all the current account states and about an epoch of data that quantifies into what, like tens or hundreds of gigabytes of data on the actual machine, like individual machine versus Ethereum, which might be single digit gigabytes. Is that like a decent kind of approximation for scale of size data?
00:35:28.998 - 00:35:47.246, Speaker B: The actual history data is what's expensive, right? And so you're still probably in like the couple of gigs on Ethereum, but it is like much lower because the, essentially they're producing new data every 12 seconds on Ethereum and Solana, it's every 400 milliseconds. And so there's just like a lot more data there.
00:35:47.430 - 00:36:05.044, Speaker A: I guess I don't immediately see a problem with just trusting archive nodes, but is the issue that because it gets more and more expensive, especially for these high throughput chains like Solana, to store all that history, that in and of itself is a centralizing vector. Is that the main criticism, or is there, are there other criticisms here?
00:36:05.864 - 00:37:17.094, Speaker B: Yeah, pretty. It's like the people who are willing to bear the cost of stolen, like, petabytes of data are going to be relatively limited, right? A better solution is to put it on a blockchain that's literally designed for this, right? Like, you know, filecoin or error. Where are we for Genesis go? Like a solution that's like literally thinking about if you have petabytes of data, how do we distribute this around a bunch of other nodes so that you can call it up and get it back? And Solana, like, fundamentally, I think it's more designed as, like, no, we want to, like, the current state is like, real time censorship resistance, essentially. It's like you can maybe, like, not have the history right away for very old things, but in the real time, like in financial markets or stuff, when you need that, it's there, it's available, it's quick, it's fast, and then there's, like, decisions about how long we want that to stick around. And I mean, this is even a problem with roll ups because, like, ethereum can't store all this data. It's very expensive. If you look at EIP 4844, like, they literally are implementing blob transactions that Ethereum is only going to store for a month, right? And then all that history on the l two is gone.
00:37:17.094 - 00:37:54.480, Speaker B: Like, unless the l two has a data warehousing person to store it. Like, it's gone. And so, like, you know, all these chains, when you get up into the point of where you're having a lot of data, a lot of transactions have to make decisions around what to do with this. And, like, they have, like, very deep implications. You know, they tell you, like, on an l two, you can always escape, right? Well, in order to escape, like, the chain only holds the state root. It doesn't hold all the historical transactions. So if, say, you're in a defi position, you now have to say, here's the state route that I came from.
00:37:54.480 - 00:38:18.448, Speaker B: Here's all the history of the transactions that got me here. Include that Ethereum. Well, Ethereum can't do that unless you can provide that difference from the state route to where you're at currently. And if that difference expires in a month, you can imagine a situation where you're in a defi protocol for a long time. Your state's gone. Your historical state's gone. No one warehoused it.
00:38:18.448 - 00:38:34.484, Speaker B: How do you exit? You can't prove to Ethereum that it's time to exit anymore. And I like Ethereum. Researchers are thinking about this. Like, this is a very solvable problem, don't get me wrong, but it's a much more complex thought process than is currently marketed. Right?
00:38:39.424 - 00:39:24.464, Speaker C: So you're saying, okay, so you're on a L2, the sequencer at the moment, they're centralized sequences. Maybe that's gone down. And there are these escape hatches, basically, where you can still send your transaction from the L2 over to the Ethereum layer one. So that's why people say you can inherit security of the ether one, even if you're using the L2s, basically, because you can always escape there. And you're saying that there's this problem, and I just like to try and put a pin on why that problem would exist, that there's a problem where you can't just say, this is my current balance, which would be sort of the current state. There's also the sort of historical bits and pieces which may not be immediately available or may have just been deleted. And so why would you need those historical balances?
00:39:24.844 - 00:39:56.186, Speaker B: Because you have to prove to Ethereum that how you got to your current state is valid. Like you followed the rules of Ethereum. And so if it's not in the state route immediately, like Ethereum has to be like, oh, it's a little different than what my view of the world is. Like. You have to prove to me that all these things happened before. I'm going to let you roll that back or come onto Ethereum. L1 that's like, okay, you better have your call data ready and you can definitely build solutions around this.
00:39:56.186 - 00:40:51.408, Speaker B: It's not an unsolvable problem, but it's definitely hidden under the hood. It's one thing if you're just an account on an l two, if you're just holding eth on an l two, there's nothing to unwind. Like you can submit, like transfer back to the one. But if l one is not for users and all defi activities moving to l two, you have to assume most of these coins are not just sitting in wallets, they're in staking contracts, they're in defi being active, they're being traded against, right? And so when this event happens, there's like, there's two main problems, essentially. Like one, you have to get the data in order to prove to Ethereum. But also there's like a time element in defi, right? And as much as like a centralized sequencer going down, like, if no one can move any money, that's fine, because like no one can essentially liquidate you. The chain is down.
00:40:51.408 - 00:41:26.108, Speaker B: Right. The problem is the price of those assets is not static static, because price is not an on chain thing. Price is trading on centralized exchanges, it's trading on other roll ups. Oracles are telling the chain, like, what the price is, and oracles are basically anything that's not on chain. How do I get information about it? Price is a very price of what? In dollars. And it's a very human soft thing. It's not actually defined on a blockchain when a centralized signature goes down.
00:41:26.108 - 00:41:50.966, Speaker B: If you're in a defi position. And then like, and we've seen this happen on Solana. Solana goes down, people get bearish on Solana, start dumping it on centralized exchanges. Nothing on chains being liquidated, but the price is moving. As soon as the chain comes up, this liquidation engine goes, oh, price is down here, bam, you're done, right? And so that's the risk. As much as you can say, oh, I can exit to an l one. Yeah, you can exit to an l one.
00:41:50.966 - 00:42:49.688, Speaker B: If you're doing nothing but holding it on the l two, you have all your call data, and, like, you're ready to go. The immediate, this happens, you know, but that's not things people are thinking about. You know, they're saying, oh, I'm safe on the l two. Like, let me go get into all these positions, right? Okay. Like, so the other problem with data availability is bandwidth, right? And so to go back to the data availability question, and then we can go into, like, consensus, because that kind of is the other shape of this problem is finality. It's like, when do you know things are actually consistent? The same problem with the l two exit, right? It's like you need that historical state at some point, and how much of that historical state is on chain is actually like a bandwidth problem, right? Like how much can be served up at one time? Then we get into, like, kind of scalability issues, right? And I think, like, data availability is one of the main bottlenecks for performance, because at the end of the day, like, what is a chain doing? It's writing bytes somewhere. Okay.
00:42:49.688 - 00:44:05.536, Speaker B: And how fast it can do that, and how much it can do that at once is actually like a very fundamental, like, well, your TPS can't go above that because it's just simply like, there's not enough network bandwidth to, like, support it, right? And so the other kind of shape is, we were talking about these two shapes of the data availability problem. There's the, there's the historical state problem, right? But there's also the, just, like, how much data can I send to you and how much can I get back at a given time, right? And this has, like, a lot of implications for, you know, like the more bandwidth, like fundamentally, like when you're going to a cloud provider or even just a bare metal or scene or even just running at your home, like, if you want more bandwidth, you want a ten gigabit connection, you know, from whatever your ISP provider is, right? It's going to cost more than a one gigabit connection, right? And so, like, scalability right. Is limited by bandwidth, which has a cost. Okay? And those costs, like, fundamentally, like, blockchains have to make a decision. Like, they can't get around this. Where do we want to put those costs? Okay? And this is like, it's philosophical. There's no, like, real actual, like, this is the right way to do it.
00:44:05.536 - 00:44:43.212, Speaker B: Answer. I think Solana has landed in this camp of, like, we believe the validators, the people running the network should bear the cost so that the users and the businesses built on top of the network don't have to. Okay. Ethereum is in the extreme opposite direction saying, you know, the validators should be the ones making the money and the users and the apps should bear the cost. Like, is one better than the other? Like, ultimately this is a sliding scale. Right. And where you slide, that actually has, like, implications on cost of the node because the bandwidth requirements.
00:44:43.212 - 00:45:34.574, Speaker B: Right. And so, yeah, I think, like, this gets very pedantic in a lot of circles about, like, oh, you have big nodes, like, therefore it's bad. It's like, well, like, you can't scale without them. Like, you know, and so, like, who bears that cost? It's really like more of a fundamental, like a philosophical decision, you know, I think. And this is kind of getting in a little bit to, like, consensus, but like, you know, it's like, how expensive is it to verify the chain? Like, to make sure that, like, something is correct? And I think, like, the majority of blockchains are converging on this idea that, like, it's okay if, you know, the full state and like, the full building of things are a little more expensive. As long as me, as a user, I can verify that that's correct cheaply. And this is where things like lite clients come into play.
00:45:34.574 - 00:45:51.454, Speaker B: And I think when you look at these ecosystems, what you realize is everyone faces this. There's no way around it. And it's just a matter of where you're setting this cost scale. And then can we offset that to get the trust properties we want via like, clients and other solutions?
00:45:51.834 - 00:45:59.650, Speaker A: Why don't we kind of change gears and talk a bit about consensus and kind of how that's the next key property here about blockchain design. Design.
00:45:59.762 - 00:47:07.048, Speaker B: Yeah, so there's like, you know, data availability is kind of that fundamental. Like, how much, like raw bytes can I get through? Like, the actual wire that's running from my house to yours, you know, whereas consensus is then, like the layer right above that, okay. It's like now that we have, you know, this much total space like, how fast can we agree on what happened? Okay, and how fast can we give guarantees that everyone on the chain has the same view of the world? Or even are we going to give guarantees that everyone on the chain has the view of the same world? I think Solana is very opinionated in the fact that every full node is synced at the speed of light around the world. Things like avalanche with subnets, a subset of their network, has a view of the world sharding. That's literally what sharding is. It's taking this opinionated stance that, oh, not every node needs to know everything, but they all need to be verifiable if they ask each other. This has, like, implications for ux, right, about, like, who you can ping where and then gets into, like, bridging problems and stuff.
00:47:07.048 - 00:48:15.516, Speaker B: So, like, yeah, there's definitely implications, but this is the shape of the problem, right? And so, like, consensus is, right, the set of rules that nodes follow in order to, like, eventually agree on something. And that, like, the kind of the shape of the parameter that you're looking at there is, like, what is eventually? What does that mean? Right? And you hear, like, a lot of buzzwords like finality and slot times, right? And finality is basically saying, like, when do we have a guarantee that 67%, like, the majority of the network, I think 50% improve of work, right? Like, will say that this is correct every time you ask them. Okay, and how fast does that happen? So, like, there's kind of multiple flavors of this. I'll go, I'll go into them a little bit. And then maybe if you got some questions, there's, like, deterministic finality and probabilistic finality, like, in proof of work, there's never a point where, like, you can say, like, this is final, this is 100% final. There's no probability that this will ever be rolled back in proof of stake. It is like that.
00:48:15.516 - 00:49:10.376, Speaker B: And this is like a, just the way the consensus algorithms work in probabilistic finality, you're making the assumption that the network incentives are so high to overcome past a certain point, the probability of it ever changing is almost intestinally zero. And so, like, on bitcoin, that's saying, like, the amount of hash power you would have to have in order to rebuild the chain to propose a longer one, is beyond what normal computers can do today. And therefore, you have, like, some probabilistic guarantee that no one can propose a longer chain and essentially, like, change the history. And actually, Solana works on this principle a little bit too. With proof of history. It's essentially saying, you know, it's actually proof of work with time is what proof of history is now. It's hybrid in Solana in that, like, actual consensus is proof of stake.
00:49:10.376 - 00:50:06.762, Speaker B: But they do make this assumption that if you're, you know, if from a certain point, it's like this probabilistic finality as Solana is like working through this like proof of history thing, at a certain point it gets, like, locked in and that's it, no matter what. But you can imagine being like a quantum computer or very fast computer, like, at the last state route, and then you just like, calculate a bunch of stuff way faster than any other computer could and propose it, and Solana accepts it. The cool thing with, like, deterministic finality is you limit the damage that that could be, you know, and so, like, on Eth now, and Eth is kind of a hybrid, it actually, like, in times of. And we can go into this, like, safety versus liveness, this is kind of the other property of consensus. In times of, like, slowness, it falls back to, like, probabilistic finality because it used to be proof of work. And then when it's operating normally, it actually is like proof of stake. And there's like a point at which you can say like, no, this will never be rolled back.
00:50:06.762 - 00:50:16.026, Speaker B: And so it's like, in Solana, it's 32 slots, right? So once like a slot is 32 past, you're guaranteed, like, this is, this.
00:50:16.050 - 00:50:18.666, Speaker A: Is how it is, a slots 400 milliseconds, right?
00:50:18.690 - 00:51:27.914, Speaker B: So that's about almost twelve and a half seconds. It's almost the same as Ethereum. Now, the, the cool thing with Solana is you get like optimistic finality, which is honestly, like, it's hard to say it's any really different than roll ups, right? Getting soft finality, right? Except that, like, roll ups do it by like literally having another consensus mechanism. If they're gonna, if they're gonna do this, you know, if you're gonna decentralize a sequencer, like, you essentially have to build a construction to give that, like, oh, this is what's going to get committed within like, some amount of, you know, security guarantees. And like, in Solana, it's essentially saying that, like, your honest majority security guarantees, you know, in those 32 slots. But when that majority decides that, hey, we've all seen this block, you can have like a soft confirmation that it's not going to just suddenly reorg because of the way, like, the towers are built in Solana, like, it's kind of like a sliding window as it's like building this consensus tower. And essentially, like, at a certain point when you get 67%, you know, like, the majority of the network is not going to switch to another fork.
00:51:27.914 - 00:52:01.546, Speaker B: And so you get this essentially, a lot of people use. That's why, like, Solana is considered fast, is because, like, when you're bridging, they're like, no, we have to wait for 32 slots because you're taking value off this chain. We want the strongest guarantees that this is never going to be rolled back. But in normal apps, optimistic finality, or I think it's called confirmed, not finalized in Solana, means, okay, 67% of a network is committed to this fork. So the likelihood of them moving to a different fork is very small at that point.
00:52:01.690 - 00:52:23.136, Speaker C: Because I was wondering for payments, because I thought, yeah, if you have to wait for the final finality, the twelve and a half seconds, maybe that's going to be too long for using Solana as a payments rail. But do you think that they would actually probably revert to the optimistic finality, which is when, as you said, over 66% of validators have agreed, I think.
00:52:23.200 - 00:53:21.166, Speaker B: Yeah, mostly they can rely on confirm, because, like, 32 slots in slot 12 seconds, that's not a lot of, like, especially in a payment application, there's not a lot that can go wrong in 12 seconds. Now, trading venues like market makers, this actually becomes a problem. And if you talk to people, even Solana is supposed to be designed as the trading firm. But in order to hedge the fact that maybe when I say this is a trade, it gets rolled back, they end up having to quote wider to adjust for that risk, or just spam transactions to hedge the fact that things might be moving against them within that time window. That's kind of where we get into this discussion of, like, chains that are doing single swap finality. Essentially some guarantee that, like, within the first round, like, you have a guarantee it's going to land in that order, even if it hasn't come to consensus yet.
00:53:21.270 - 00:53:37.754, Speaker A: No, I think that's a very valid point. It's one of the main criticisms I've heard about Solana that perhaps is valid, is that this timed up finality might be too long for some use cases. I'm less familiar with blockchains that have single slot finality. Are there any examples? And how do they accomplish that?
00:53:38.054 - 00:54:41.304, Speaker B: There's essentially this new algorithm everyone's clamoring over called hot stuff. It's a modified tendermint, the way tendermint works is every node in the network first agrees on what the order of the block is going to be, and then they agree that that's a valid block. They all execute it and say, okay, this gets added to the blockchain. But by separating those two steps, what ends up happening is you can have some guarantee in that first round that, like, oh, this is the order things are going to land. Right? And so hot stuff is it's a modified tendermint kind of flavor that allows this to be kind of pipelined. It separates the ordering problem from the consensus problem in the same way, actually, the exact same principle that proof of history does for Solana, right? Proof of history says you're guaranteed that transactions were timestamped in this order. So you can then come to consensus, like, in parallel of, like, the blocks actually being arranged.
00:54:41.304 - 00:55:34.506, Speaker B: Tendermint and hot stuff is kind of doing the same thing. And what ends up happening is you can, like, even though it's multiple rounds, you can end up stacking them. So, like, while some of the nodes on one block are coming to, like, ordering consensus in another thread in the same computer, like, on the previous block, they're actually saying, okay, we're confirming it, right? And so you end up having this, like, pipeline of stages where you can kind of decouple the act of saying, this is the right order from. We all agree on that order or that it's a valid execution. Essentially consensus algorithms, right? This is the main way. Like, we've seen edms change scale. Like, a lot of them, just like Fort Geth, and just like, build another consensus algorithm, right? And then essentially, oh, great, you know, now we're much faster in coming to agreement.
00:55:34.506 - 00:56:45.154, Speaker B: Like, the state of consensus research is continually evolving. Like, why don't we use that research and essentially build something faster, right? There are very few teams that are tackling all three of those, right? Solana is like one of them, right? But they take this very opinionated stance about like, hey, we don't like the execution layer. We're going to do something different. And then Monad is kind of taking this opinion of, we can optimize all of this stuff, and we don't have to just optimize the execution layer to essentially get the modern day benefits of current ethereum research where you fall on this, and I want to touch on this. So I'm going to take a tangent here a little bit, is safety versus liveness. And I think this is something Solana gets a lot of shit for. Is that like, oh, Solana goes down, right? And it's like, well, if the safety is, like, the security of the chain is guaranteeing that there's the most survivable copies of the same thing, right? And so if you think about a chain that's, like, really fast, that all of a sudden, like, diverges from consensus.
00:56:45.154 - 00:57:34.916, Speaker B: Like, half the nodes think one thing, half the nodes think the other thing. If you let that go on, there's a possibility that, okay, this half then splits into halves again, right? And it just keeps forking. And where do you say, like, what's the canonical state? You get into this state of, like, if I just let it run, like, there's a very real possibility that all of a sudden, all my, like, secure copies are corrupt, and I don't know which one's true. And so you have to make this decision of, like, no, we need to stop at a certain point and say, hey, at this point, humans need to get involved. Or maybe a different protocol needs to come in. And I think Solana is working on actually implementing an automated protocol to do this, to say, hey, validators, you all stopped here. What is your view of the world? Let's all think on that and then restart from there.
00:57:35.020 - 00:57:50.406, Speaker C: The big difference there between something like Solana and something like ethereum l one, is just that the. The amount of transactions happening on Solana are so, like, so many more transactions happening on Solana. So there's so much more memory. Is that the point which is being taken up by all of these forks?
00:57:50.550 - 00:58:31.364, Speaker B: Yes. And so another thing you have to realize is validators need to track all the forks, okay? Because they're talking to all these other chains. Even if, like, 33% is off there and, like, six, you know, the other 67% is off here. Well, I guess at that point, it'll converge. But, like, if maybe you have 50 50, the validator itself is still tracking all the changes on this side, as well as all the changes on the other side. Imagine if that happens again and again and again, you're essentially just blowing up memory that this validator has to keep track of. There's a very real point at which validators just don't have enough memory.
00:58:31.364 - 00:59:05.292, Speaker B: Then they crash, and then they could co op their own ledger, and then all of a sudden, like, safety is a problem. You know, you don't have canonical, and so you have to make this very opinionated choice of, like, that's too high of a risk. These are, like, very, you know, it's better to halt and make sure everything is consistent than to just let it go on. And, like, essentially maybe end up in problems where you have corrupted ledger states. And then we don't know what the canonical chain is. Now, Ethereum makes, like, the decision, because it came from proof of work. It kind of had this benefit of, like, having probabilistic finality.
00:59:05.292 - 00:59:40.730, Speaker B: So, like, even, like we saw in the Ethereum incident, the deterministic finality kind of failed and, like, knocked over because, like, one of the clients was misbehaving or something. Right. And what we saw is, like, probabilistic finality kept going. Okay. And so you couldn't say it was finalized, but you had, like, pretty good guarantees that what the chain had agreed on was going to eventually get finalized. And there's kind of two things that enable this. It's like, one, it's just lower block times, like, the risk of memory running out on forks, it's just much lower.
00:59:40.730 - 01:00:14.264, Speaker B: And then two, they have mempools. So, like, mempools are great in the fact that they save your ass if something goes wrong, because all of a sudden, you have, like, a buffer in front of everything. And so, like, whereas Solana, like, there is no buffer. As things come in, they either make it or they don't. And that is really nice for ux, because you don't get this problem of, like, oh, it's in the mempool. When is it going to land? Can I send a new transaction? Right. But it's also, like, from, like, a high throughput angle.
01:00:14.264 - 01:01:08.764, Speaker B: It kind of forces the issue of choosing safety, because you can't just have, like, too much stuff building up. Like, you need to come to essentially, agreement on what the canonical state is before you can start ingesting more transactions. Now, one thing we saw with ethereum is that multi client architecture really saved them. I think that's the thesis behind fire dancer, is you have multiple clients, and so if one of them falls over, you still have the possibility that the other one is still going. And the way fire dancer is designing their ingestion, so they don't have a mempool. So they have to take this approach of, like, we literally have to support the maximum amount of transactions that, like, the wire coming into my physical server can send me. You know, so fire dancers taking this approach of, like, you couldn't send enough bytes through this wire to knock me over if you tried.
01:01:08.764 - 01:02:02.800, Speaker B: Whereas, like, a lot of other chains are like, no, we'll put a mempool there, and then we'll deal with it as it's buffering. So I think that's kind of like the philosophical decision there. I think the reality is it has to be somewhere in between. There's ux implications for either one of them. It really just comes down to a philosophical decision of what do you need as an application and what do you think is the most successful way to build a blockchain? I think kind of like to go back to the main point of this discussion is like, all these things have very nuanced implications. And if people aren't, like, willing to have conversations about what they mean, it really makes the whole blockchain discussion very myopic and kind of like shrinks the space into what even people think can be done on blockchains because they're like, oh, they work this one way.
01:02:02.912 - 01:02:30.904, Speaker A: Yeah. So actually, before we kind of proceed on, want to do a quick kind of sidebar to help our listeners out, because we talked about chains like Solana as well as other, quote unquote EVM chains or EVM equivalent chains, maybe like, help us understand what does that actually mean from the developer standpoint, the user standpoint at what properties are, quote unquote evm chains inheriting from ETH and which ones are they not inheriting? Like, how do we think about that?
01:02:31.064 - 01:03:11.664, Speaker B: And actually, maybe this is like a great segue into what execution is, because when we're talking about EVM versus SVM, essentially we're talking about the operating system. So EVM chains, the only thing that defines an EVM chain is that if I were to take my code and put it into another virtual machine, like Ethereum virtual machine, it's going to understand it the same way. Whereas if you, like, you took that code and put it into SVM, it's going to say, I don't know what these words mean. So EVM is just this definition of like, okay, if I take my code and put it on any EVM chain, it's going to understand what I was talking about from the beginning.
01:03:12.524 - 01:03:27.410, Speaker A: A quick follow up on that. Does that mean for just users or developers either a, like, it's easier for a developer to write applications on an EVM chain because the code is the same? Or are there implications for applications that want to bridge? Like, how do we think about that?
01:03:27.572 - 01:04:43.014, Speaker B: Yeah, so this is like, it kind of depends. Like every, like, a lot of EVM chains are not like, fully EVM compatible. And so you might have to make minor changes to your, like, application to get it to work, but the set of changes you would have to make is, like, much smaller than an SVM. Like, so SVM takes, like, it's a completely different computer system. And I think, like, a lot of people, like what? And this is actually, like, what brought me into blockchains is that, like, the reason I never wanted to work on cloud before is it wasn't constrained enough. Right? You have this, like, environment of, like, just a computer, and you can do whatever you want, right? Whereas in, like, the reason blockchain is attracting me from hardware is because, like, fundamentally, you can't code a smart contract with, like, understand without understanding how these things work underneath, right? And so Solana takes this opinion that everything, every piece of memory should just be an account. You can have a program, but the data that that program, the state that that program acts on is also another account, okay? And what this enables is that, like, if I build a program, anyone else can use that program and put in different data, right? And so this is a two sided sword.
01:04:43.014 - 01:05:22.404, Speaker B: It's great in composability, but it's also, like, not great for. For distribution. And I'll get into that in a little bit. Whereas the EVM makes this opinion, and so does cosmwasm, actually, that state and data should be coupled. And so when you have a program on the EVM and you call it, not only does it know the steps of what to do, but it has memory about, like, what was there before, whereas on Solana, it knows the steps to do, but you have to tell it, where is my memory? You know, where. How do I go recall things, right? And so you can have it recall different things. Whereas on, like, the EVM, you literally have to, like, make a new contract and deploy it.
01:05:22.404 - 01:06:23.224, Speaker B: Right? If you want it to have different memory, it's good and bad in ways. The big problem that we're seeing on Solana now is that, like, it essentially it breaks interfaces, you know, and so everyone can define now, like, because there's no uniform, you don't know what's coming in, right? Anyone can pass any arbitrary data into this program. You also don't have, like, as a developer, if I want to call this contract, I have to know what that contract expects, right? There's not just, like, shared standard that I'm like, okay, it takes, like, a deposit function. It takes, like, a withdrawal function for all of these type of. You know, there's not even a word for it, but, like, let's call it like a SVM 20 token that doesn't exist. Whereas on the evm, there's this erc. The ERC standard is essentially, it allows the entire ecosystem to agree on.
01:06:23.224 - 01:07:21.186, Speaker B: If I want a token, I'm going to have these function calls, and you don't have to understand what data I need to pass into those function calls. I just know that if I call them, they'll do what they say. And so, like, how this manifests, like, physically, is kind of this problem of, like, metaplex owns the Solana NFT standard now. And, like, if anyone wants to make a new Solana NFT standard, all the Dapps have to agree. Okay, I'm gonna, like, understand how to interact with your contact and integrate with it, which poses this really big distribution problem, because then you're, like, all of a sudden having to go to, like, all the wallets, all the marketplaces, and be like, please support my standard. Right. On Ethereum, you have this model where it allows, like, if you support ERC 20, I can make any variation of an ERC 20 contract and, like, have certain guarantees about, like, oh, your marketplace is going to understand how to interact with me.
01:07:21.186 - 01:07:35.374, Speaker B: There's, like, good and bads to this. And I think Solana is actually, like, currently trying to fix this. It's like, literally the interface is problem. There's Twitter spaces on it. Like, it's like, an ongoing discussion within Solana to, like, come up with a standard to fix this.
01:07:35.454 - 01:07:38.430, Speaker C: Yeah. Cause it sounds worse to Elaine.
01:07:38.462 - 01:07:54.554, Speaker B: Yeah, it sounds worse than it is. Yeah. But it's, like, fundamentally, this is just a computer science problem. Right. Like, it's not that hard to solve. I think Solana took the opinion that, like, you know, like, ERC 20 is not baked into the protocol. Right.
01:07:54.554 - 01:08:12.802, Speaker B: It's a standard built on top. Right. And Solana, it's kind of taking this opinion in the same stance is, like, this isn't important enough to enshrine into the protocol. Like, the social layer should come to consensus on what this should look like. And Solana, just being the newer chain, I think, is just, like, in that phase of, like, figuring that out right.
01:08:12.818 - 01:08:22.457, Speaker A: Now is the reason why Solana is architected like that, to accomplish its goals of, like, parallelization of execution by separating out the data.
01:08:22.585 - 01:08:39.593, Speaker B: Yes. Yeah. So there's two things. You get essentially native account abstraction now, because you, like, everything is an account. Just like what account abstraction brings to Ethereum is everything's a smart contract. Right. Well, in Solana, everything's already an account.
01:08:39.593 - 01:09:26.523, Speaker B: And so you can have a program owner account, which is called, like, a PDA, a program derived account. And that essentially is, like, makes account abstraction. That's like, what account abstraction is. Right. It's like, now all of my sudden, my smart contract can own another smart contract, right? And that's exactly what account abstraction is in Ethereum. There's slight differences in Solana in the sense that, like, there's like, because Solana is trying to be so performant, there has to be, like, restrictions on how big accounts and transactions can be, because they're solving this real time problem every time you submit of who touches what and how can I arrange it. And if the size of what they're arranging is always changing, it's much harder to make an algorithm for it.
01:09:26.523 - 01:10:23.796, Speaker B: If they know the max amount of data I'm going to have is this, then you can actually come up with a very, very efficient algorithm to arrange things. Separating state and data allows you to essentially parallelize the execution, because you can do this upfront analysis of what data are you touching, what state are you touching? And if it's the same, then we'll run it in serial. And if it's not, then we can run it in parallel. This is possible on Ethereum, just like the EVM doesn't do it. The simplest way to do this, and actually currently how Solana does it, is you just spin up multiple vms. Each core in your computer is literally running a different instance of Solana operating system, right? And as they look, when transactions come in, they go, okay, which one of these touched the same state? We'll run that all on one thread, and then run the other ones on another thread. Run the other ones on another thread.
01:10:23.796 - 01:11:01.444, Speaker B: That's something you can do on Ethereum, right? They don't specify state and data up front, but that also almost makes it easier because, you know, like, oh, okay, like, all my state and data is together right here. So two people calling the same thing, it has to be serialized, right? And so it's kind of the same problem. It's more about, like, an interface and like, how devs, like, interface with it. And I think, like, the current way the Ethereum virtual machine is designed is like, not to split that up, but, like, the easiest, most direct path to, like, making a valid, like, an EVM parallel would just be, well, computers have multiple threads nowadays. Let's run up multiple evms.
01:11:01.784 - 01:11:08.304, Speaker A: I mean, that's always been a criticism of Ethereum, is that it's single threaded. But you're saying it is theoretically possible for that to change.
01:11:08.924 - 01:12:10.424, Speaker B: Yes. I think you can go farther in the optimization with Solana, and that's what program runtime v two is about. It's like, on their roadmap, essentially. It like, and this is getting really technical, so maybe pause me if it gets too detailed, but the instructions that the actual operating system understands essentially has extra information that will allow it to not have to be in a separate VM. And so the VM can understand what touches what. And so, yeah, you could run multiple of them, but a single VM can also just take advantage of hardware level parallelization and act on it, which just means less memory overhead in the parallelization size, because you don't have to spin up completely separate environments. You can have one environment that has a very strict idea of what belongs where and then operates like that.
01:12:10.424 - 01:13:08.704, Speaker B: This is actually the same principle that move chains are taking. This is the paradigm move is built on when Solana implements program runtime V two. They bring that paradigm to support the move language, but they also get that paradigm on every other language. Now, like, when you write the language, the compiler may not enforce those rules, but it's technically possible. And so Ethereum, as I found out recently, actually has the ability for you to specify, like access lists. Okay. And so there's like this ambitious problem that like, can we then, okay, now we know what data and state you're trying to touch, besides just running all this stuff in parallel vms, can we maybe like try to squash those parts of the VM that are common together and then run them in parallel? And I think that's just like a problem not many teams are solving on the UVM right now.
01:13:16.484 - 01:13:45.644, Speaker C: I think it does really get enough notoriety if you like the runtime V two. But it sounds big. It sounds big. So effectively, if I understand it right, this means that then you could use move the programming language and use that basically on Solana. And then there'll be this compiler, and the move language will go in and it will spit out maybe rust on the back end and sort of operate just as, just as rust would really on Solana. Am I understanding that? Correct. And likewise, you could do that with other.
01:13:46.254 - 01:14:30.474, Speaker B: Yeah, I mean, it's not rust. It's like, what you're saying is correct, but it's, I think I call it terrible name choice, SBF. But Solana byte code format, amazing. But essentially that bytecode format is the same thing as like the Ethereum bytecode format, right. And so, yeah, they're kind of essentially making that bytecode format more flexible. What it does, though, is actually bring it that same interface problem I was talking about, Solana and Ethereum. It ends up solving that because when your vm understands that everything is a segmented object, essentially, it brings an object oriented nature to assets on chain.
01:14:30.474 - 01:15:19.894, Speaker B: It essentially allows you to have arbitrary function calls. Right now, like, the way programs work on Solana is like, you know, I kind of have to know the interface, and then I can call into it, and then it'll go, and I pass it some data and it does something. What move does is kind of make all those entry points very generic. Okay. In the same way that, like, ERC standards kind of do it. I mean, it's not completely analogous, but, like, from a user perspective, it's kind of, that's what you're going to feel, you know? And so it kind of removes a lot of the current developer bottlenecks for Solana right now. And it's almost like both vms are attacking this from the same direction, or, sorry, from adjacent directions coming at the same problem.
01:15:19.894 - 01:16:02.646, Speaker B: It's like Ethereum already has kind of like the interfaces and composability side figured out in the way that it's virtual machine is designed, but it never quite figured out the parallelization and optimization portion. Solana figured out the parallel and optimization portion and is now kind of going through this. How do we change our vm to be more composable and permissionless? I think Monad's taking this opinion of, hey, we can go a lot farther on how fast we can make this actual execution side and parallel side, because we have the benefit of already having the composability and interfaces figured out. And that's kind of like, that's actually why I joined, because I think it's like a very exciting effort.
01:16:02.830 - 01:16:13.190, Speaker A: How would you kind of describe for some listeners that are less familiar with Monad, the differences between, like, Monad versus eth versus Solana on a spectrum, even if that's, if that makes sense, it's.
01:16:13.222 - 01:17:04.504, Speaker B: Kind of like a middle ground. I would say it's like, very much taking this, like, we can do things like Solana, but we can do them with the prevailing, like, like, kind of programming language, Ethereum. And, yeah, maybe we'll never get to like 300, 500,000 tps, but we can realistically get to levels that are far beyond what current blockchains are using. Right. And like, they're like, when you get to a certain level, it's like, okay, that's probably good enough, you know, for certain applications. And so it's like, yeah, ethereum, like Solana, may be the fastest chain out there, and that'll be necessary for certain use cases. But Mona is kind of saying, like, the EVM has, it's the one thing that kind of has, like, product market fit right now.
01:17:04.504 - 01:18:06.198, Speaker B: And so, like, why don't we just actually take this, like, engineering and innovation driven approach to, like, making it something that can compete with something like Solana and essentially, like, bringing that kind of like world class ux that Solana is known for to the EVM because the EVM is something like JavaScript where everyone knows it's crap, but everyone uses it because it's the most optimized thing out there. What did Google do? They went and created a very fast version of it because they knew that if they tried to change everything, no one would use it. It's that same thing. It's like, okay, if I was the most ideological engineer, yeah, maybe I'd go build it like Solana's doing it or fire dancers doing it. But the reality of, like, what currently has product market fit, it's like you can actually juice that to a level that like, kind of like what Google did with JavaScript to, like, make it fast enough to where. Yeah, it'll just be used everywhere. And so it fits this, like, nice middle ground.
01:18:06.198 - 01:18:49.058, Speaker B: It's also taking the stance that, like, which I got into blockchains through Ethereum. So I'm kind of like a, like decentralization Maxi, although I'm like practical decentralization maxi from my background in hardware. So it's like, look, running on a raspberry PI is never going to happen, right? That's just impractical to say that the nodes need to be that small. But I don't think it's impractical to say running on a MacBook M two. Sure it's an expensive laptop, but it's not 200 a month server costs. Right. And so it's like taking this middle ground of like, yeah, everyone can run a node.
01:18:49.058 - 01:19:13.954, Speaker B: No, it's not cheap. You know, like, for like, people in, like, India. Yeah, it's going to be expensive, right? But it's cheap enough that, like, the network economics should pay it back a lot more sustainably. Right. And I think that's like, another thing Solana is going through right now. It's artificially set its fee very low. And like, this is like, currently like a discussion.
01:19:13.954 - 01:20:18.400, Speaker B: Like, when I was at Solana, I was actually kind of driving this discussion a little bit about fee changes because, like, fundamentally, like, Solana is going to have to make fee changes, right, in order to be long term sustainable. And, like, what those look like is just like a huge conversation with the community. Now, I think you can arguably say that, like, fee changes are kind of, like, the easiest thing to make. Like, technological changes are way harder, but it's a much more, like, social problem, right? And so it's like, you know, Solana's taking this opinion of, like, we need users first, then we'll figure out fees, right? And they have so long to do that before, like, the network economics essentially become unsustainable because, like, Solana actually does tail off. Like, the reward rates go down every year by 1.5%. So there is this ticking time bomb on Solana of, like, okay, eventually we need to figure out, you know, like, exactly what we're going to charge for different state access and have opinions about, like, what costs more. Should it cost more to read? Should it cost more to write? Should it cost more to, like, lock accounts? But these are like, active conversations.
01:20:18.400 - 01:20:52.560, Speaker B: If you go and read, like, Solana Simd's, this is like, very active development conversations that are going on. So the one thing that kind of, like, reassures me about Solana is that, like, they are thinking about these things and they're attacking them. The benefit with EVM chains is there's already kind of a model to go off of. Now, I don't think, I think Ethereum takes a little too much of an opinionated stance on where that cost would be. Whereas Monad's kind of in the middle there, where it's like, no, we need to be cheap, but we need to be practically cheap. Yes. Hundredths of a cent transaction, but maybe not millionth of a cent transaction.
01:20:52.560 - 01:20:58.302, Speaker B: And for a typical user, that doesn't matter much. And when Solana does full optimizations, it.
01:20:58.318 - 01:21:47.864, Speaker C: Might be 100 of Akira, your discussion on Monad, it sort of comes back to what we were saying at the very beginning. It's about trade offs. And as you said, probably Monad is never going to be quite as performative as something like Solana, but it inherits the EVM. And to me, it seems a more, I don't know, sensible approach to scaling, probably on Ethereum compared to the current more modularized approach, where they're sort of leaving the Ethereum l one alone, and then they're trying to scale through the L2 s. Yeah. And it seems more sensible to me to actually try and transform and change that layer one, the actual execution layer. So I suppose just leading on to that'd be really interesting to get your view on this debate between modular versus monolithic architectures and, yeah, how you see the likes of Solana Monad.
01:21:49.264 - 01:22:48.398, Speaker B: So you can kind of, like, bucket this into two kind of like prevailing views, you know, and the modular thesis looks at it as kind of the way like current cloud infrastructure is going to evolve. And the monolithic view kind of looks at it as the way like current hardware infrastructure evolved. And what this means is like from a modular standpoint, right? If you think about like current web infrastructure, it's like there are a few main, like service providers, like GCP, AWS, Azure. When you go onto their sites in your company and you're like, okay, I need a database solution, but I need a database that does these particular things. And they have some product catalog that you can pick all these components off the shelf and they'll put this server construction together for you and serve it up for you. Then there's very smaller niche service providers that do this for very specific web. Two companies, I think Snapchat had their own partner that did all their infrastructure for them.
01:22:48.398 - 01:23:46.774, Speaker B: Okay? And so this is like kind of how we see like these modular stacks developing. You see like op building, op stack, Starkware doing like, you know, it's like Starkware stuff, you know, and it's kind of like they're marketing like, hey, like come we're, you know, this like cloud platform provider and we have all these things you can put together and like build a, you know, a blockchain out of me, I'm going to stop there. I have opinions on that. Because fundamentally it feels like you're rebuilding Web two, you're just rebuilding silos. And yes, maybe these stacks can work together, but there's still a lot of stacks. It's like, maybe all the AWS people can work together, but it's not going to work between AWS and GCP. It's like, okay, do we really want to go down that path? I think that's more of an ideological decision.
01:23:46.774 - 01:24:51.064, Speaker B: We know that path is product market fit. But wasn't the purpose of blockchain's composability and bringing these promises of crypto economics? The monolithic thesis is on the other side of that. It's looking at how did performance systems come about today? When we really look at what juice performance, like, what was the main principle that did that? And what you find is really common between all these high performance systems is co location. It's like the fundamental thing. It's like if you put things close together and have less communication overhead, less synchronization overhead, less trust assumptions, you can just build systems faster by assuming certain things because there's like less communication in between that you have to handshake and make sure are you doing the right thing? And so this has played out very tangibly in the computer chip market. If you noticed, intel inside was the biggest thing for the longest time. Core two duo, yay.
01:24:51.064 - 01:25:33.568, Speaker B: Intel inside and have all these discrete components. That intel was like, we're going to make the best graphics card, we're going to make the best processor, and then you can just like, put them all together in your own computer, and it's going to be a fast computer, you know, and a lot of people bought into that for a long time. And that's like, essentially how the computer market developed. And we saw, you know, kind of the performance of, like, computers kind of, you know, logarithmically taper off. They weren't really going that much faster. And it was like, okay, like, well, what's the bottleneck? It turns out, like, communicating between all these chips was the bottleneck. So what did Apple do? It goes, we're going to integrate all these onto a single die.
01:25:33.568 - 01:26:22.964, Speaker B: They slap the m one and the m series table on the table, and instantly you get a ten x improvement in performance, something we'd never seen in computer chips in almost a decade. It was just like, wow, okay, co location matters. And then you kind of see this in, like, in high performance cloud systems. They use something called, like, edge compute, which means, like, push everything down to the local device and have it do a lot of the work. Right? And the fundamental principle behind that is co location, you know, for like gamings and stuff. Like, they just send, like, they rely on that server, the local thing, you know, like actually rendering the stuff and doing it quickly because they can't do that up in the crowd and then send it down. And so you end up seeing that, like, if you want performance, you need colocation.
01:26:22.964 - 01:27:04.534, Speaker B: At the same time, like, the way current markets have developed, there's like a very strong kind of product market fit for the current way, like current cloud computing systems are, you know, architected, you know, and so, like, in reality, like, I think it's gonna, and I think most blockchains are converging on this, this kind of, kind of hybrid. Right. Ethereum is like taking this very opinionated stance. Like, everything should be modular. And that has, like, very deep implications. I think I want to get into after this. Whereas, like, Solana is saying, like, okay, if you want to integrate with us, you know, like, as a da layer, like, you have to conform to how Solana deals things.
01:27:04.534 - 01:27:48.158, Speaker B: We're not just going to, like, provide you like a generic interface, right? And that's kind of the difference is, like, when you go to generic interfaces and say, anyone can plug into me, you necessarily have. You can't make assumptions about, like, data formats and communications that allow you to speed up. It's like you have to check those assumptions every time. And so, like, it's kind of like, what's going to win out? Probably something in between, you know, like, probably something with, like, enshrined components of some sort. You have to conform to this construction of an l two in order to plug into us. But we'll let you plug in, and then you'll get the performance, because we can make assumptions about how data flows between these things.
01:27:48.326 - 01:28:03.404, Speaker C: Maybe you're going to touch upon it, but it'd be interesting to get your view. You said Solana is going in this way. Are you talking about L2s? Like, uniform L2s being built on Solana? Is that the direction is going, or are you talking about compressed accounts? You know, just wondering.
01:28:03.864 - 01:28:39.208, Speaker B: It's more of this idea of, like, we can split up certain parts of Solana. So, like, a very recent equivalent of, like, a eip on Solana. Yeah. That anatoly just put out is asynchronous block production. And you can kind of think about it. It's not the exact same, but it's like proposer builder separation on Ethereum, realizing that, like, builders are, like, highly incentivized to, like, extract Mev and run big machines to, like, find the best ordering to get a lot of value out of it. And validators, like, are not incentivized to do that.
01:28:39.208 - 01:29:02.904, Speaker B: Right. They just want to, like, validate and collect their rewards. Right. And so if you can split these two things up, like, the incentive systems kind of work better, but beyond that, like, it also just, like, kind of allows each piece to work, like, very quickly, you know, together. You know, like, they can. They do what they do do best. Right? And so that's kind of the thesis between monolithic chains.
01:29:02.904 - 01:29:30.060, Speaker B: Like, okay, well, everything's going to do its best. The difference with Solana is it's making a very opinionated stance about how these two things connect in a modular chain. You're saying, like, oh, you just, like, generally conform to something and we'll, like, make sure it goes together. Solana is saying, like, no, we will separate these. But we're very opinionated about, like, how you communicate between the two, because that equals speed. And so I think all these ecosystems are generally heading this way. They're kind of like.
01:29:30.060 - 01:30:03.844, Speaker B: I think the prevailing view at this point is if you want performance, you're going to have to have heavy builders or some part of the block building process. But you could still give security guarantees very cheaply to users through things like diet clients and white clients, which is much more practical. It's like when I want to interact with the chain, I have trustless guarantees that those things are acting correctly, but the actual node operators are incentivized to run big things to extract value and stuff like that.
01:30:04.184 - 01:30:27.274, Speaker C: It comes back to Vitalik's quite famous Endgame blog post that you put out recently, where basically monolithic chains, Alex and modular chains like Ethereum are eventually going to converge on the same end platform, place of centralized block production, but decentralized verification, basically. And they're both getting there in different ways.
01:30:27.694 - 01:31:21.534, Speaker B: And I think like the very nuance there, the nuance between these two approaches, is taking opinionated stances on how these modular pieces talk to each other in a modular chain. You're taking a very open approach to that. You're saying, anything can plug in in a monolithic chain. You're saying, no, you must conform to this way of talking to me. And because of that I can give you very good performance guarantees. I think, like what a lot of people miss is like modular is inherently saying that if I want to get adoption, I better be the best at the piece of what I'm doing, right? Because if you have 100 DA layers, 100 execution layers, and 100 consensus layers, right, in a modular ecosystem, you're taking the bet. I am the best at one of those things, and I'm going to be pulled off the stack.
01:31:21.534 - 01:31:58.178, Speaker B: When people go to this stack to shop for what I want to do to build a blockchain, I'm going to be the best at one of these things. I think it makes a lot of sense for things like Celestia, where they're very much taking that first principles of both. They're like, we are the best DA layer, or Eigen layer is saying we are the best DA layer. And then like, you know, execution, like fuel is like saying we're the best execution layer. And you know, move chains are saying we're the best execution layer. Solana is saying we're the best execution layer with the SVM. The thing is like, it's clear that the EVM is not the best execution layer, right? It has product market fit.
01:31:58.178 - 01:32:31.270, Speaker B: So like, that's another argument, like in its favor. But it's clear it's not the best execution execution layer. It's also clear it's not the best DA layer because we wouldn't have things like Eigen layer and slash. You're trying to solve these problems, right? What's not clear is that it's not the best consensus layer. Like, Ethereum might actually be the best consensus layer. And that's like, that's where it gets complicated, right? If it's not, then like, what is ethereum the best at? Why would it be used? If it is, you know, it really validates of their thesis around, like, why the chain is used. Now.
01:32:31.270 - 01:33:28.298, Speaker B: I think where this gets kind of complicated is like, the ETH community is actually the forefront of a lot of this research. And so, like, inherently they're kind of saying, like, we could make consensus better. Like, hot stuff and hot stuff too are like kind of out of the evm, like, landscape of building. And like, the fact that they're like, really, you know, this is getting a lot of hype and nothing being used in a lot of chains is kind of coming to consensus that, like, wait, this is the new best consensus layer, right? And so you're putting this weird position in the monolithic chain. It's like, if you're not the best, are you going to be used? And so what is ethereum the best at having liquidity? And like, how much does that matter? Like, all these l two s are kind of bets that, like, oh, you'll move this liquidity to me. And then it really puts the value prop of Ethereum in dire straits. You can make an argument for economic security.
01:33:28.298 - 01:33:36.642, Speaker B: I just don't believe it. Because if someone actually wants to hack a chain, they're going to send a bug in the code and steal the stake. They're not going to try to buy it off the open market.
01:33:36.778 - 01:34:14.582, Speaker C: Yeah. We had a previous conversation with Lamar about economics of blockchains, and he talked on the commoditization of block space that eventually this tribalistic cheerleading of particular blockchains will go away. And as you said, it's going to be a case of, okay, well, what's going to give me what I need? And that's not necessarily going to be ethereum just because I've heard about it and I really am a big fan of the movement. It could well be. No. What's going to be cheapest? What's going to knock sense off off my dollar of expenses, basically.
01:34:14.718 - 01:34:39.986, Speaker B: Yeah. And I think, like, the EVM has provided that moat, like, as of now, because the EVM is proud of market fit. It provides that moat. Right. But as soon as you get, like, a credible EVM, that's better at all these things. Like, it really starts to, you know, nip away at this, like, ten year old, twelve year old technology. Like, you know, I mean, fundamentally, like with the single threaded versus parallel, like, just look at history.
01:34:39.986 - 01:35:42.254, Speaker B: How many single threaded computers are still in existence today? Like, I literally couldn't go and buy one if I tried. And that's where it's like, you gotta fix that at least, you know, and then you get into like, okay, well, you can fix parallelism on, you know, the execution side, but Ethereum has enshrined the EVM into data availability, which mean the way it does the data availability is with a single threaded execution layer. There's no separation there that Celestia makes. And so they're taking a very opinionated stance that your data availability will never need to be parallelized. So even if you can parallelize the execution, if you're not parallelizing the consensus by separating ordering from actual consensus, agreeing on what happened versus what order they happen in, which is kind of what Solana's proof of history is. It's also what Celestia is doing. It's what hot stuff is able to do by having parallelized stacked pipeline stages.
01:35:42.254 - 01:35:56.588, Speaker B: You enter this case where it's like, okay, your execution is parallel, but to really get that performance, you need to parallelize all the other parts. And Ethereum's taking this very opinionated stance about saying, no, we're not going to do that.
01:35:56.756 - 01:36:30.398, Speaker A: That kind of brings me to a question I have that might start pulling a lot of these things we talked about together, which is, how do we best think about trade offs between these different ecosystems, like Ethereum? Seems like you're making a bet almost that that consensus layer is super important, that they're doing it the best. Maybe SVM, like Solana, you're kind of betting that their approach to execution will win out in the long run because it's so scalable and then even like, quote unquote monolithic EVM chains. And then you have the whole modular ecosystem with roll ups. Like, how do you think about the trade offs all these players are making.
01:36:30.446 - 01:37:29.434, Speaker B: And what they're prioritizing, really, like, tangibly? It's just going to come down to where the killer use cases are built. When you find a stack that can support that killer use case, it's going to get all the adoption right. And so right now, we can say that the majority of apps are built on an EVM. And so, like, EVM is product market fit, and therefore it's clear that maybe we should pursue the EVM. But the minute there's an SVM app that's amazing and brings in more users than all of crypto had, then maybe the SVM gets adoption. While we can sit here in today's day and age with very little blockchain adoption relatively to web two apps, you can theorize about what standard is going to win out, you know, but I think, like, it's really going to be the standard that supports the apps that everyone wants to use. Right.
01:37:29.434 - 01:38:31.356, Speaker B: And, you know, all these companies are going around and making different trade offs saying, like, we think this construction is going to support that app that everyone's going to want to use, you know, and I think you have to think about most blockchains besides, like, bitcoin essentially as, like, tech startups. You know, it's, like, not helpful to think of them as currencies like bitcoin. All it does is store value. It, like, makes sense as digital gold. But these other ecosystems, you know, fundamentally, they're all like tech startups, and they're saying our construction, we think, will support this ecosystem the best, you know, and I think you just have to evaluate about, like, what can be built on this tech stack. Do I believe that's the thing that's going to take us from that, like, zero adoption to one adoption, you know, like that zero to one moment in adoption, and most likely that's going to be the stack that wins out, to be quite honest, because people follow users fundamentally.
01:38:31.500 - 01:38:41.734, Speaker A: Right. Maybe a kind of asking it in the inverse is what can we do on a chain like Solana or a chain like Monad that we can't do on an l two, like arbitrum or optimism today.
01:38:42.394 - 01:39:15.700, Speaker B: Yeah, I think that just comes back to, like, scale really is like, I think there are ways to do most of this stuff, you know, only possible in Solana is mainly only possible because Solana is the only one with scale. Right. But, like, the minute you start getting EVM chains that are reaching, like, 400 actual TPS, you know, Solana has a lot of votes, and there's very, like, we can go into why that's actually, like, a pretty important point to make. But, like, the actual transactions is somewhere around like 400, 500 a second.
01:39:15.852 - 01:39:17.052, Speaker A: The normalized TPS.
01:39:17.148 - 01:40:06.158, Speaker B: Yeah, it's like 400, 500 TPS. So once you start getting EVM up to that range, which is very possible, you know, it starts being like, okay, what's only possible? Then you have to start differentiating on, like, okay, what is state separated from data? Enable that, like, just raw scale doesn't. I think compressed nfts are one of those. There's like a very, like, it's hard to do compressed nfts when state and data are together. It's not an unsolvable problem, though. And so it's like, okay, like, first I think EVM has to get to the point where, like, the only possible on Solana meme is put a question just purely because, like, oh, it's actually fast enough, right? And then you get into questions of like, okay, what value props does move bring, does, you know, state versus data being separate bring. And then you have to start comparing on other things.
01:40:06.158 - 01:40:44.644, Speaker B: I think right now we're very much in this stage of, like, we just need raw scale. You know, like, most apps, like helium's running on Solana, it's still only 500 gps. And so, like, that tells you something about, like, how much actual usage is on helium. Like, it's, it's great. I think it's like one of the most bullish use cases of crypto because it's so tangibly there. But fundamentally, like, the next chain to get 500 tps, like, real tps could theoretically steal that away pretty easily. Local fee markets are a big innovation, but when you get into, like, parallelism, that kind of falls out from it pretty easily.
01:40:44.644 - 01:41:52.364, Speaker B: And so, like, you can start having local fee markets on the EVM if you start having parallelized DBMs and stuff. And so it's like, okay, what's going to be the moat, quite frankly? Like, probably user adoption and use cases. I think Solana has a very credible path to be, like, the highest performing TPS chain. But from, like, a user adoption perspective, like, an EVM with, you know, even like, if Solana is running at 100,000 tps, and like, well, you have to say how many of those are votes? But, you know, say we have 100,000 real transactions a second, right? And an EVM has 10,000 real transactions per second. Is that a differentiator? Right, if we're only using 500 right now, is that a differentiator? Because you have so much headroom anyways, it's kind of a bet on, like, what's going to support bigger adoption. I think one thing monolithic chains have really going for them is cultural. Is that, like, you know, it's a lot easier to have a shared vision of an ecosystem and a culture and composability when everything's on one chain.
01:41:52.364 - 01:42:24.812, Speaker B: I think that's like, what a lot of people underestimated about Solana is just how that community is so fervent, because they're like, you're on one ecosystem all the time. It's not splitting up into l two, saying one's going to be bigger than the other. It's, let's all work together to make this thing succeed. And I think, like, monolithic chains, I think that's what built the strength of ETH originally. It's what built the strength. Strength of bitcoin originally, is you need that kind of evangelist community that's not constantly looking over their shoulders going, like, could that be a little better?
01:42:24.948 - 01:42:48.852, Speaker A: I agree with you on a lot of those points. It's hard to predict, actually, where we're going to go with all this, given all the camps that are out there, so to speak. I think what's clear is that base layer eth is not usable for most people. And so that's why we have l two s. That's why we have all these monolithic l one s that are EVM compatible. Some aren't. But, yeah, it will come down to, I guess, what can scale to everybody.
01:42:48.852 - 01:42:52.424, Speaker A: And it's still, I think, an open question that's unresolved.
01:42:52.804 - 01:44:02.376, Speaker B: I think one final point I'd like to make, if I could, because I did touch on it a little bit, is kind of like, why Solana has so many votes, because it's something Solana gets a lot of flack for. And I think it's worth talking about it because it actually has very deep implications for decentralization. Fundamentally, all blockchains need to do this task of, like, it's called block propagation, you know, and that means, like, okay, if I'm a builder and I say, like, this is, like, it's my turn to, like, say, this is the block that's going to go to the chain. Like, how do I tell that to everyone? And how do I do that quickly? Right? If you have 400 millisecond slot times, it means that, like, everyone needs to get that in 400 milliseconds. And if you have thousands of nodes, that's, like, really hard, right? You're, like, trying to send this to thousands of nodes, like, as quickly as possible. And then beyond that, they have to, like, reconstruction and execute it and do all that all within 400 milliseconds, right? And so Solana designed this thing called turbine, right? Because they needed to get that data to all these other nodes, like, as fast as possible. Okay, well, it turns out that, like, a vote is the same thing.
01:44:02.376 - 01:45:38.564, Speaker B: Like, even if you send it on some other network, right? Even, like, a gossip network, the same way to optimize block production is the same way to optimize, like, any gossip network. And so it's like, okay, well, if we already built, like, the fastest block propagation protocol, like, we should just actually put votes in there too, because what that means is, like, now you're like, how many nodes you can have is not bottlenecked by, like, this other algorithm. Like, you only have one algorithm to worry about, right? And so for a lot of these, like, other chains, you know, like, even though votes aren't in the blocks, right, the validators still need to communicate with each other. These votes and the how they get that data is still the same problem as how they get transaction data. Right? Now, if your block times are longer, your slower chain, it's like, it doesn't matter. You can have, like, the gossip protocol be faster, right? But if you're getting up to, like, thousands of nodes, like, tendermint chains don't need this because there's typically you can only scale up to, like, 100 nodes, you know? And so, like, gossip is fast enough with 100 nodes to make the UX experience of, like, actual transactions pretty nice when you're reaching Solana levels, you know, it's like, okay, do we design two protocols to do this, or do we just optimize the crap out of one and then send the votes down there? Right? And so you do have, like, a lot of votes there, but, like, it's actually good because the more TPS you can support, it means the more validators you can support. And so Solana TPS isn't just a question of, like, how many.
01:45:38.564 - 01:46:41.306, Speaker B: Yeah, maybe it's only 400, 500 actual transactions. All that other headroom is, like, what enables there to be 2000 nodes on the network syncing at the speed of light around the globe, right? And, like, as you get into scale, that becomes, like, a much bigger problem. And, like, like, it's kind of the reason Monad's, like, not choosing to be an l two, right? Like, at some point, you have to do, like, a tree topology for block propagation. And then there's, like, all sorts of other clever things you can do, like, not send the full block, you know, like hashes and stuff like that, to essentially, like, make the amount of data you're broadcasting, like, much. And, yeah, these end up, like, when you get to scale. Like, Solana is dealing with a lot of these problems that every chain that is going to scale to that level is going to have to eventually deal with. And so these monolithic ecosystems are kind of, like, tackling that first, I think the modular ecosystems are tackling this kind of product market fit of server side kind of stuff.
01:46:41.306 - 01:47:05.658, Speaker B: Like, rather than dapps, like, okay, if I'm, you know, if I'm taking the view of a cloud developer and I'm trying to like, build a lot of blockchains everywhere, like, they're taking this view of like, okay, well, we need to build, you know, things that would make that very easy. And I think like, monolithic chains are more of this perspective of like, well, that's great. They'll figure that out. We can always add that, but like, fundamentally we just like, actually need to make this thing fast so we can run actual products on it.
01:47:05.826 - 01:47:20.764, Speaker A: That makes sense. I think that's a. A great overview. And obviously throughout this conversation we touched on a lot of different topics, but really appreciate you bringing your engineering expertise to help us demystify the differences between all of these blockchain ecosystems.
01:47:21.104 - 01:48:02.154, Speaker B: I think it's just like really important as people think about these systems to not get sucked into these, like, tribal. This is best. That is best, right? Like, if this industry as a whole wants to scale, like, there needs to be conversations about all these things in order to enable new use cases. Especially with AI and the advent of all these things, if we want these new use cases to proliferate, then we can't be kind of myopic about our views of blockchains. We have to expand that to understand what are the different trade offs, what applications would be good on these blockchains. And like, do I believe in that thesis?
01:48:02.274 - 01:48:05.178, Speaker A: Some great words to close on. Thanks again for joining us, Kevin.
01:48:05.266 - 01:48:05.634, Speaker B: It was great.
