00:00:13.200 - 00:00:42.490, Speaker A: Welcome to Unlayered, the show where we explore next gen blockchains Amir Osal alongside special co host Zen Lama. And here we're in another episode of our more technical series. This time we're speaking with Piers Ridyard, CEO of Radix. Their website's radixdlt.com dot. We'll have that in the show notes. And it is a very interesting architecture that Radix has built for their protocol powering web3 and defi applications.
00:00:42.490 - 00:00:59.556, Speaker A: We're going to get into how that all works and how it's different and why it's interesting from a technical standpoint and fits into our theme of being a next gen blockchain. But before we get into that, Piers, thank you so much for joining us. This is an episode we've been wanting to make happen for a long time and happy to finally make it a real thing.
00:00:59.740 - 00:01:06.864, Speaker B: Yeah, thank you very much for having me on the show and shout out to avant from our community who has tirelessly made sure that this happens.
00:01:08.364 - 00:01:15.664, Speaker A: Absolutely. I guess let's start really simple here. How would you describe what Radix is?
00:01:16.164 - 00:02:22.152, Speaker B: Yeah, I think there's many layers to this, so let's start off with the highest level possible. Radix is a layer one protocol. So it's a public decentralized ledger focusing specifically on decentralized finance and web3. And the three things that we really solve for the DeFi and web3 space is scalability, usability from a developer point of view. So developer experience, especially from the point of view of making it really accessible for new developers coming into the space to be able to easily build DeFi applications, defi front end and usability for an end user point of view. And this is specifically thinking about how do you make it accessible for a mass market to be able to easily come on and use web3 and Defi directly via a non custodial wallet, and what needs to be true for that. So thinking about things like making it really easy to onboard, getting rid of seed phrases, making it really easy to understand, so making it so that your transactions that you do are human readable.
00:02:22.152 - 00:03:24.000, Speaker B: So no such thing as blind signing, make it really hard to mess up. So things like man in the middle attacks, signature manipulation attacks, sort of like fake front end attacks where you sort of get token permissions to be able to drain funds, just make that impossible to do on top of the Reddit network, and make it really easy to do the thing that actually we think matters the most from a user experience point of view, which is connecting to Defi applications and Defi and web3 applications. What I mean by that is most wallets are built around this concept that my wallet is. The main thing I use my wallet for is holding my tokens. I actually think that's the smallest percentage part of what a wallet is actually for. What a wallet is, is it's your access, it's your window into web3 and defi usability into deb three and win web3 dapp usage. So really the key thing about your wallet is about connection and permission, so that you can actually use web3 and defi natively.
00:03:24.000 - 00:03:46.344, Speaker B: And so we can move these hundreds of millions of users that are currently in these weird walled gardens that we called exchanges and actually get them using web3 and definated. So those are the three things that radix focuses on, and that's what the stack is all about. It's great usability from a user point of view, great developer experience from developer point of view, and scalable, insufficient scalability to be able to go mainstream with crypto.
00:03:48.004 - 00:04:21.488, Speaker A: So you touched on a few really interesting value props there. I think what stood out most was making it hard to mess up and reducing the surface area for potential exploits and attacks. Because I think a lot of us, it's almost a rite of passage in crypto where you fall in for a grift, you've signed the wrong transaction. Maybe you've gotten phished to say that it's possible to the protocol level, make that not a thing. I guess my question is, how do exactly how does that work? How are you able to do that?
00:04:21.656 - 00:05:18.704, Speaker B: Yeah, so again, there's many layers to this answer. So I'll sort of drop one level down and sort of give conceptual answers here, and then we can drop again down to sort of more technical specifics if you want. So the starting point for this was we realized that there was a problem in how crypto specifically DeFi was being built in 2019. And in 2019 we took the strategic decision that we were going to focus on decentralized finance as the main thing that we thought was going to be the value proposition for public ledgers. That was going to be the main way in which finance and eventually sort of the entire GDP of nations is going to move on top of public ledger. So finance was going to be the enabling factor for that. And DeFi was only just emerging.
00:05:18.704 - 00:06:06.324, Speaker B: Aave had recently changed from Ethlend maker Dao, and Dai was the main game in town. And it was actually the DAi savings rate that started the trend for DeFi. People don't remember this, but the dive savings rate was 5%. And at the time the yield on treasuries was less than 1%. And people were like, wow, 5%, great low yield environment, DeFi, high yield environment at 5%, which seems crazy. Now we watch this industry start to emerge where people are trying to build autonomous marketplaces that were dealing, starting to deal with tens of millions and then hundreds of millions of dollars of cash. And then we were starting to see all these hacks and these exploits.
00:06:06.324 - 00:06:59.724, Speaker B: And we went and we went and interviewed the DeFi developers and the DeFi projects at the time to understand what were their main problems they were facing. And there was so three sets of problems. I called two of them business problems and one of them specifically a developer problem. The developer problem was that a developer was typically spending about 80% to 90% of their time when building a DeFi app on security. So about 10% of their time was on functionality. How do I get it to do the thing I do? 80% to 90% was how do I stop it from messing up? Yet despite this, you are still seeing hacks and exploits happening all the time. Common issues like unsafe reentrancy or signature manipulation, or permissions escalations, like all of these kind of things happening over and over again.
00:06:59.724 - 00:08:09.954, Speaker B: And so you sort of dived into, well, what's a developer spending most of their time doing? And what it turned out is there was a bunch of patterns that emerged from that now. And a lot of these patterns were based on low level primitives that developers were having to rebuild every time. A simple example of this is when you build a token in Ethereum land, you don't just say hey, to the ledger, hey, I want a token. You actually have to create a contract that defines what it means to be a token, what it means to be able to transfer a token and all of the balances of that token. And then you have these standardized interfaces, which is actually what the ERC 20 standard is to be able to so delegate permissions, to be able to update balances and all this kind of stuff. And all of these hacks were coming from things like, sort of like permissions escalations or permissions delegation, like unlimited permissions, all of this kind of stuff. And the complexity of how you architected when the ledger didn't understand what a token was, and you had uniswap, now having to actually just coordinate messaging between multiple different balance holding smart contracts to be able to facilitate a swap.
00:08:09.954 - 00:08:58.005, Speaker B: And the architecture of the smart contracts, when you looked at it when you actually drew it out, look, nothing like what you'd expect if you came to someone and said, hey, I want you to build a swapping application that's swapping tokens. And they drew the architecture, and then you showed them what it looks like in Ethereum land. They'd be like, that's mad. So this is where all this complexity was coming from. So we took a page out of the game industries playbook. When the computer game industry was first getting started, you had to be a God tier developer to be able to build a computer game, right? That's why people like John Carmack were considered this like prodigious developer, because he was able to develop all the way up and down the stack. He understood low level implementation, the creation of rendering engines, the creation of physics engines.
00:08:58.005 - 00:09:29.690, Speaker B: And he also had a feel for art, and he had a flair for game design and was able to build the high level stuff as well. But most people were not that level. And so the games industry was relatively cottage industry. The thing that changed the games for the game, the thing that changed the game for the game industry was the games engine. So unity and unreal. What they did is they standardized the way in which you built games, and they standardized the format, the components that you could use to build games. So they gave you a standardized rendering engine, standardized physics engine.
00:09:29.690 - 00:10:15.102, Speaker B: They did all of the low level implementation on a per platform basis, and they also created modularization of the components that you could use to build a game. What that did is it lowered the barrier to entry for new developers to come in and build in the games industry. But it also meant that you had a standardized set of tools. So if you built in Unreal, then you could go and work in any games company that was using the Unreal engine, and you could go straight into it. The maintainability was much higher then you had this ability to build more and more complicated games as a result of these modular, standardized underlying components. And that's essentially what we did with Radix. We created what we call the Radix engine in Ethereum land, you have the EVM.
00:10:15.102 - 00:10:53.714, Speaker B: In the Radix land, you have the Radix engine. The Radix engine is both the execution environment, but it also has a bunch of enshrined components into it. We've pushed a bunch of the high level concepts that you have to implement in Ethereum land as a developer, and we push them down into enshrined components within the Rex engine. So you can kind of think of these as I sometimes describe them as like asset co processors beside a cpu. Like enshrined objects is like what Vitalik talks about. And the key enshrined objects are tokens are enshrined objects, nfts are enshrined objects, accounts are enshrined objects. The permission stack is an enshrined object.
00:10:53.714 - 00:11:28.612, Speaker B: And then the concept of asset handling is actually. So asset transactions, asset transfers, are actually handled by the ledger itself. So when you create a token on radix, that token is a native object of the ledger, and the balance maintenance is actually done by the ledger itself. So if I transfer from my wallet to your wallet, I'm actually transferring from my wallet to your wallet. I'm not updating a balance on a smart contract. That is a ledger controlled object. But the best way of thinking about this is actually that each of these are frameworks for the issuance of resources or the use for resources.
00:11:28.612 - 00:11:59.476, Speaker B: So we don't just say, you know, this is the ERC 20 standard in radix, or this is the ERC 71 standard in radix. We say, here's a framework for the issuance of NFT type objects. And within this you have the ability to change your metadata, you have the ability to specify how the object looks on ledger and what the attributes of it are. But it's within a standardized framework for doing that. And for tokens, it's the same. You can essentially think of it, you have flags for the tokens. So you go, I want a token.
00:11:59.476 - 00:12:32.582, Speaker B: I want this object on the ledger to be a multi issuance object. I want the right for that multi issuance object to be controlled by the permission stack. And I want this account to be the first one that has the right to do new issuances of it. I want it to have, you know, I want it to be recallable, I want it to be freezable. Let's say that you're issuing a stable coin, and then I specify that against the standardized framework for the creation of tokens. And now I've created essentially a recallable, freezable multi mint token. But that's a native object of the ledger.
00:12:32.582 - 00:13:29.104, Speaker B: And the thing that then happens is those flags, that metadata, actually flow all the way up into the user experience. So if I sent you that token into your wallet immediately, it would appear it didn't matter if I created it five minutes ago, it would appear it's a native object of the ledger. So your wallet didn't have to know to look up this custom contract address for you to be able to see the peers multi issuance token. But importantly in your wallet, you would also see under the description of the token or as underneath the metadata. And very visible is oh, this is a recallable token, this is a freezable token type. This is a multi issuance token type. So there is no ability to create a token that pretends to be one thing, but actually has something hidden within the asset rules within the smart contract that actually means it's something else, right? And the important thing around these native objects is now the way in which you pass authorization in transactions becomes much simpler.
00:13:29.104 - 00:14:28.480, Speaker B: This is how we get human readable transactions, because you have this ability to go, I'm not giving this, this smart contract, let's say a swapping smart contract, the permission on my behalf to update my balance in this other smart contract that's maintaining balances, which is what happens in ethereum land on radix, you're going, I am in the transaction. And we can talk about the transaction layer in a little bit more detail because it is very cool. It's a fully programmable transaction layer which allows you to specify, you to basically compose together many, many different objects all in the same transaction, and many, many different interactions with applications, all atomically. But just very simply here in the transaction layer you're specifying, you're saying, hey, I'm taking ten p tokens out of my wallet, I'm interacting with this application. Now, this application only has the right to deal with these ten tokens. It can't do with anything to my wallet because that's not part of what I'm actually giving it permission to do. I'm hold, I'm passing over these ten tokens, then I expect to get back from this smart contract.
00:14:28.480 - 00:15:14.966, Speaker B: I expect to get back at least 20, you know, unlayered podcast tokens. And those guarantees are set at the ledger level, so you actually have the invariance in the, in the ledger level so that the smart contract, even the smart contract was a fake smart contract and it actually didn't do anything. It was just trying to drain peers tokens from me. It wouldn't execute at consensus time, it wouldn't execute, the network wouldn't actually execute it because you're not adhering to the rules that have been put by the user into the transaction itself. So if it doesn't return you 20 tokens in that transaction, it fails. And you can set, you can change that to be like 18 tokens if you're happy to take some slippage or whatever. But that invariance is actually at the user level, and it's again completely visible within the wallet.
00:15:14.966 - 00:15:44.394, Speaker B: And so that gives a bunch of what we call basically guardrails for the user, but it also gives a bunch of guardrails for the developer. So by having these native objects, by having a enshrined permission stack, things like unsafe reentrancy is not possible. In radix. Things like mistaken asset handling is much, much more difficult. So scripto itself is a programming language based on rust. This is our programming language. So in Ethereum land it's solidity.
00:15:44.394 - 00:16:40.400, Speaker B: In Radix land it's scripto. That programming language fundamentally understands the concept of assets. Assets are a primary, or what we call resources are a primary object of the ledger. And all of the things, all of the functionality, the enshrined feature set of the rights engine essentially is used within the scripto programming language. So all of the low level things you need to worry about in terms of like have I correctly sent these tokens? And what happens to the change? Like what happens if I've got a return? All of those things are basically dealt with by the ledger and by the radix engine itself. Things like reentrancy are dealt with. We have safe reentrancy, rather unsafe reentrancy, which is dealt with by the permissions system, which essentially gives you an ephemeral token at transaction time for one time re entrancy or whatever, these things are all dealt with so that you can't, it's much harder to mess up.
00:16:40.400 - 00:17:12.610, Speaker B: And this is where the guardrails for developers comes in. The programming language understands the concept of assets. It has a bunch of enshrined tools which abstract away a lot of the hard low level stuff that the programmer has to worry about. And the compiler actually understands safe asset handling. So if you've done something like stupid in how you've handled assets in your program, it won't even compile. And so by the time you get to compilation, you know, you're about 95% of the way there. You may have made some business logic errors, but you're not going to have made some asset, some fundamental errors associated with asset handling.
00:17:12.610 - 00:17:20.114, Speaker B: And all of that results in these claims that we're making about it being much safer for a user, much safer from a developer point of view.
00:17:25.934 - 00:17:58.370, Speaker C: So if I can follow up here, it sounds somewhat like it's somewhere between move and Solana in the sense that like move has, it understands like object types right natively at the bytecode level, and then Solana has the SBL program library, where it has the concept of standardized logic that you can call into to do certain things, maybe you could compare and contrast both of them and how it's slightly different or somewhat the same.
00:17:58.562 - 00:18:08.850, Speaker B: Yeah. So was the library in Solana previously called Anchor? Or is what you're mentioning something?
00:18:08.962 - 00:18:19.034, Speaker C: So anchor is a framework, but the SPL library is like a standardized program set. Now, it's not enshrined, but it is, it's almost like a precompile.
00:18:19.194 - 00:18:20.298, Speaker B: Right. Okay.
00:18:20.426 - 00:18:28.454, Speaker C: And the EVM. So it is like a program, right. That's not in the smart contract that has like defined logic, but. Yeah.
00:18:28.874 - 00:19:29.034, Speaker B: Yeah. So obviously, making it enshrined into the ledger is, has, it has a bunch of benefits to do that are relatively multifaceted. I mean, the simplest one to point to is performance. You end up, because the radix engine, enshrined objects are much, much more performant to execute. You end up getting a huge performance difference when you're looking at DeFi throughput. So a simple example of that is, if you take the example I always take, is the dragonfly benchmarking that they did of different ledges where they went, okay, there's the advertised throughput, 65,000 transactions per second for a Solana. But how many Dex swaps per second can you do on orca? And they came back with a benchmark of 275 dexwatch per second as the maximum throughput.
00:19:29.034 - 00:20:40.726, Speaker B: And part of this is because of how the logic associated with the, with the swapping mechanics is architected and then executed, and how that actually has to run through execution time with the radix engine, because you're dealing with enshrined objects that are executing highly performant to the ledger itself, we get a 80% efficiency. That means that if our advertised throughput is 1000 transactions per second, we should be seeing about 800 Dex swaps per second. And the reason that matters to us, or what we think it matters in DeFi in general, is that the majority of transactions that happening in public ledgers are not transactions of one account to another. They are interactions with smart contracts. And the majority of those are some form of swapping or exchanging. So this enshrinement gives you a huge amount of performance versus having it as sort of a precompiler program. On top of that, the ledger going deeper into that, I don't know how, in Solana's example, I don't know specifically what are part of that pre compile or not.
00:20:40.726 - 00:20:55.674, Speaker B: So I couldn't really compare it to accounts. I mean, for example, on Solana, are smart accounts a native object, or do I have to do the same thing that I have to do with abstracted accounts in Ethereum to get an abstracted account?
00:20:57.384 - 00:21:11.456, Speaker C: It's kind of both. So like, the accounts are kind of dumb. And then you can like delegate to like another account. So it has native, like, delegation to a smart contract. That could be a smart account, but the, like accounts as primitive or just accounts.
00:21:11.600 - 00:21:18.016, Speaker B: Got it. Got it. And is an account by default a public private key pair? Is an eoa address or is it something?
00:21:18.080 - 00:21:27.806, Speaker C: Yeah. So they all, they're all public private key pairs. Yeah, and some of them are like data accounts and some former, like program accounts. And then you can like pass data into program accounts.
00:21:27.950 - 00:21:47.918, Speaker B: Right. So let's compare and compare that to Radix. Yeah. On Radix we have no EoA addresses. You can't, you cannot have anything sent to a public key. The, everything on Radix is a smart contract account. And accounts are enshrined object as smart contract accounts with specific functionality.
00:21:47.918 - 00:22:37.394, Speaker B: So for example, when I create the account, I create the account object and I associate a public key to that as the first authorization for that account. But I can then add from that point forwards multiple public keys. So I can have decentralized recovery, I can have multisig, I can have all of those things just off the bat. And that means I can lose my phone, lose my keys. This is why we're able to have seed phrase free onboarding because you can get to this point very quickly where you can have take someone through a user flow where they set up their account and then they immediately set up a recovery factor. And now they don't actually need their seed phrase because they've got their recovery factor and you can have multi recovery factors. We have a whole rule set around a recovery which is sort of actually very robust.
00:22:37.394 - 00:23:09.930, Speaker B: And we've extensively tested over a two year period on getting normies. Everyday people using. There's. But then that account primitive because it's standardized. Every single interaction with a smart contract or every single interaction with a user follows the same pattern. So there is no confusion as to, I have to support multiple different ways in which people have chosen to implemented accounted accounts, delegated authorities, all of this kind of stuff. There is just the radix account type.
00:23:09.930 - 00:23:42.258, Speaker B: You support that you support every single account on radix, but there is no such thing as eoas. So you're always interacting with smart contracts. Then there's a more complicated functionality you can add to like that. Like where you can have, like, what's it called? We have a specific term for it, allowances. So you can say, then you can do things like, you know, I want to have regular payments off this, and there's an allowance on that. Or I'm using, I'm playing a hand of poker, and I don't want to have to authorize every time I'm betting chips. Like, all of those kind of things can be done against smart contracts.
00:23:42.258 - 00:24:56.574, Speaker B: Smart accounts allow that to happen, and that only really happens when you have it as an enshrined object. The other thing that is, like, really boring, I get really excited about, but not many people get excited about, is this sort of like, enshrined permission stack. Like, permissions are just everywhere in smart contracts and in interactions with web3 and Defi. And also you see it in finance all of the time, where you might have in finance called a four eyes process, where you have the initiater, the verifier, and the signer, which is a six eyes process, where you have a specific set of people who are allowed to do one thing, and it could be one of six of that, and then a specific set of people are allowed to do the next thing, and it could be two or three of that, and then a specific set of people who can do the last thing. But you might need to have certain rules where you go, well, if it's up to $100,000, then it has to be this set of people. But if it's over a million dollars, then it has to be two of three of these. Those all can be modeled directly on ledger using the native permission stack, including then things about sort of cross ledger calls between accounts of smart contracts, where you're like, I want to allow this set of smart contracts to be able to call this particular function, but this set of smart contracts can only call this particular.
00:24:56.574 - 00:25:40.016, Speaker B: Again, all of that's done by then. The stack, that standardization of the permissioning rules over time creates this immense degree of operational security, because there's a familiarization with everyone who comes in and uses it, which means that you know the right ways of configuring it. There is the correct pattern, a strongly opinionated pattern about how you should do correct security within this. But then that standardizes how you expect to be able to interact with another smart contract or how you expect to be able to interact with the service. So again, those in tried services make a much better play for development. And I think that the industry is kind of looking towards that. This is why Solana is going down this route with the library services you're talking about and the anchor as the framework.
00:25:40.016 - 00:27:22.186, Speaker B: But Radix goes this whole hog of enshrining it truly into the ledger, which we were able to do because we launched later than other people. The move version is a really interesting one to compare and contrast, and it becomes a bit more abstract around how you think about objects and logic. So we have this concept in Radix where we talk around business objects and business actions. And the whole pattern in crypto right now is I go, I've got an object, and I'm going to put the logic, the business logic associated with the handling of that object into the object. So I've got an NFT, and I want to have some logic associated with how the NFT is allowed to be transferred, who's allowed to own it, and I put all of the logic into the object, and this is the route that sort of move and swe have gone down, where objects essentially contain the logic associated with those objects as well. On radix, we've taken a very specific path where we've said there are objects and then there are rulesets associated with objects, and the two things are separated, and they're separated for a large number of reasons. One is that you may want to update the rule set associated with an object, but you don't want to update the object itself.
00:27:22.186 - 00:28:08.724, Speaker B: The other is that by separating those two, you can have standardized objects that are understood by applications and wallets and all this kind of thing within the ledger natively. But by pushing the business logic into it, suddenly the behavior of those can become entirely unpredictable. So on radix, you have the enshrined resources, which are the objects. And then you have the ability to add business logic to things, to like transfer rules and ownership rules and all that kind of stuff at the scripto programming level. But it's this key separation between there is the radix engine with the enshrined low level primitives, and then there's the programming language that's responsible for dividing business logic. And Radix is the only place that actually separates those two things. There's two levels of abstraction rather than one.
00:28:08.724 - 00:28:36.022, Speaker B: Everyone else just pushes everything into one level of abstraction, which is the programming language, which then breaks your standardization framework for creating good user patterns, for building things, because suddenly you've got this much more open environment for defining whatever user pattern you want. But then that breaks the standardization that makes it easy to be able to build things in the first place. And that's what we think is the fundamental mistake that move has made. Awesome.
00:28:36.078 - 00:29:06.372, Speaker C: So we've delved quite deeply into the developer experience, and that comes mostly from the VM, the Radix engine. I would like to explore a little bit more about the architecture on the other side. So consensus as well as the database, if we can maybe get into that a little bit. I think what really was differentiating for Radix, when I came across and looked at it as an architecture, was this concept of shard space base.
00:29:06.508 - 00:29:07.068, Speaker B: Right?
00:29:07.196 - 00:29:32.224, Speaker C: So Radix, unlike Solana. Right. Solana is maybe like the most monolithic version of a blockchain that you can get, or integrated version of a blockchain that you can get, whereas Radix is going the completely opposite way. And so they've literally done this thing where they split up all of state space into something called shard space. Yeah. And so maybe we can go into what that means and just conceptually what that's like.
00:29:32.364 - 00:30:09.778, Speaker B: Sure, yeah, for sure. I think before I dive into it, just as sort of like an orientation for the listeners. The first version of the Radix network is live today. As of the 28 September last year, it went live. The current version of the Radix network is not sharded. It's a single sharded instance that has the Radix engine, the scripto programming language, the Radix UI, UX environment in the rights wallet. That's all live and it's all been architected with respect to what I'm going to be talking about now in terms of the fully sharded end state.
00:30:09.778 - 00:31:29.670, Speaker B: So everything that we've built from the UI down is already architected for sharding, but the first version is not sharded. So I want to premise that upfront, so that people don't think that we're already sharded, which we're not. So the starting point of the Radix consensus, which is called cerberus, was, I think some relatively, when I say them, they're relatively obvious insights, but I think that they were really important insights. The first was, is that if you have two unrelated transactions occurring, there is no reason to order them against each other. That's the first step. The second step is saying, can the data layer itself help you separate, help consensus separate between things that are related and things that are unrelated? So the thinking was, you can't shut, you can't, you can't linearly scale any vertically scalable infrastructure. You have to horizontally scale at some point.
00:31:29.670 - 00:32:44.344, Speaker B: You can't infinitely vertically scale, you always have an upper limit to that. So at some point, you have to horizontally scale. You have to be able to add more computing horizontally to a system to be able to scale its throughput infinitely. So if that's the case, then sharding is kind of an inevitability in one form or another. Now, if you take sharding to the extreme, if you say that the entire world is using the public ledger, and for the entire world to be using a public ledger and to be, you know, taking the bandwidths and storage requirements of the Internet into account, how many shards would be necessary for an average computer, you know, an average server that I'd find at Iows to be able to be part of processing that you're probably looking at millions of shards, if not more. Okay, so let's run like a simple thought experiment here. If I have millions of shards on a public ledger, what is the probability that any given transaction is going to be to another account on the same shard I'm on versus on a different shard? Well, your probability is basically one over the number of shards.
00:32:44.344 - 00:33:35.244, Speaker B: So if I've got millions of shards, there's a say I've got 10 million shards. There's a one in 10 million chance that a transaction is actually going to be happening, that I'm doing is going to be happening on the same shard. But most transactions, therefore, in our future world, where bandwidth requirements and storage requirements and usage requirements and throughput requirements require there to be a huge amount of sharding, most transactions are going to be cross shard. Okay, if that's true, then actually, your problem isn't single sharded consensus. Your problem is cross sharded consensus. Your constraint is always going to be the coordination between shards, not actually the throughput of any given shard. That's what we're caring about right now as an industry.
00:33:35.244 - 00:33:56.962, Speaker B: Solana is a great example of that. But, you know, so is avalanche, and so is all of these other ones where they're going. Our maximum throughput on a network is 3000 transactions per second. Sure. But your problem is actually this cross chain component. So those are the key insights. So the outcome of that is.
00:33:56.962 - 00:35:08.004, Speaker B: Okay, well, to actually create linear scalability within a multi sharded with a highly shard environment, you have to develop a cross chain consensus algorithm, a cross shard consensus algorithm. And ideally, that cross shard consensus algorithm has to have the. The feature of atomicity. So you have to be able to have all shards agree to an update, a state update simultaneously, or it to fail, because if you don't do that, if you can't have atomicity, what you end up in this problem is intermediate state. So if I'm swapping from, you know, just to put this for the reader's point of view, I can see that you get it, Kevin. But if I want to do a trade between arbitrum and optimism, where I'm borrowing from arbitrum, trading on optimism, and then repaying a loan on arbitrum, I have to first borrow on arbitrum, complete the loan, move my assets across, try and complete a trade on optimism, and then go back and repay the loan. But I may have taken the loan out without the opportunity still being there.
00:35:08.004 - 00:35:33.054, Speaker B: So what I'm left is this intermediate state. I didn't actually want the loan at all. I wanted the loan if I could get the trade, but if I can't get the trade, then I don't want the loan. But I've ended up in an intermediate state. And you can actually get in much more complicated, problematic intermediate states. And the basic point is, if you don't have atomic cross shard composability, you also end up in these problems of rollback states, which, in consensus, is a nightmare. So you always want to avoid.
00:35:34.514 - 00:35:45.562, Speaker C: If I can jump in right there, because I think this is a really important point conceptually. I think this is why the monolithic chains so far have made sense, right?
00:35:45.618 - 00:35:45.946, Speaker B: Yeah.
00:35:46.010 - 00:36:14.354, Speaker C: Because they look at this problem of cross shard composability. Composability. If you think of shards as logical shards, like l two s, and it's just a no go for user experience in most cases, this exact problem you're talking about. Right. There's efforts to solve this through intents and stuff that coordinate things, but it's a very complex problem. And so I just want to double click on the point you're pointing out here is that cross shard communication is the entire reason Solana is an integrated chain.
00:36:15.614 - 00:36:16.982, Speaker B: Yeah, yeah.
00:36:17.038 - 00:36:18.566, Speaker C: I'll let you continue, but I just.
00:36:18.670 - 00:36:53.026, Speaker B: Double click on that. And like, this. This. This is the DNA. This is the early DNA of Radix. Radix was established, founded by Dan Hughes back in 2013 as his sort of a research project spun out of his work in bitcoin. Or it's like he's sort of, like, he got involved with the bitcoin community in 2012, realized that bitcoin's approach wasn't going to scale, and sort of went from there to be like, I think I could build something, knock something up in six months, and then seven years later, got to the point that we've published consensus.
00:36:53.026 - 00:37:35.114, Speaker B: The Cerberus, our consensus algorithm, in computer science journal, worked with the University of California, Davis, to verify our maths and theory behind this. But it's been a very long journey to now, and it's exactly that problem you just double clicked on. So, going back to this sort of, like, starting point of going, well, if you have to have a massively sharded network, then just, then just lean into it. Just go, let's have a shard space that we never have to change. So let's have a shard space that is incredibly big. So the shard space for this system is two to the power 256 shards. And.
00:37:37.254 - 00:37:42.926, Speaker C: So to put that in scale for people, that's, like, more atoms than that are in the universe.
00:37:43.070 - 00:37:43.438, Speaker A: That's right.
00:37:43.446 - 00:37:45.034, Speaker C: It's a massive number.
00:37:47.334 - 00:38:24.360, Speaker B: So I think I did a calculation when it was. It used to be two to the power, two to the power 128. I think it used to be. It's now two to the power 256. Something to do. It's something to do with the hashing algorithm. But the toothpower 200 128 was if you took all of the data that humankind has and you dropped it into digital data and you dropped it into that shard space, you'd end up with, like, two bits per shard or something like that.
00:38:24.360 - 00:39:00.774, Speaker B: So it's an astronomically large shard space. And then what you do is you then deterministically map your state data to that shard space. So I'm going to take a simple. It's not actually specifically accurate, but I'm going to take a simple example that makes it easy to conceptualize this. Imagine that we just mapped accounts to shards. So I create an account, and that account is on shard five. And you create an account, and that account is on shard ten.
00:39:00.774 - 00:39:30.414, Speaker B: If I send a transaction from my wallet, I'm going to be sending cross shard, say I'm sending to my mother, right? And you send in a transaction from your wallet, you're sending to your mother. We don't have the same mothers. We're not the same people. They're not coming from the same place. So now you already have this idea that I can see when things are unrelated, but I can also see when things are related. A double spend will always have to come from my account. It's always going to have a double spend from my account will always come from shard five.
00:39:30.414 - 00:39:59.494, Speaker B: Right? And a double spend from your account will always come from shard 20. So you now have this very nice feature that by deterministically mapping your state to your shards, you're actually helping consensus along. You're going, well, conflicting state is going to be happening from the same shards, unconflicting state or potentially unconflicing state. Because it's not always unconflicting. Right. We could both be trying to trade on the same decks, for example. But like, potentially unconflicting state is going to be coming from different shards.
00:39:59.494 - 00:40:50.348, Speaker B: This allows you then to move to the next stage, which is parallelization. You can say, look, I can now run the system essentially embarrassingly parallel. I can go if I don't care that when my confirmations for these things start or end. If any validator is validating these shards, then all the validators have to do is come to an agreement that this transaction was valid, but they don't have to come to agreement that this transaction was valid and the timeframe versus another transaction. So your transaction and my transaction can both be confirmed simultaneously. So you get these virtual consensus instances where basically consensus on any given transaction can start or end when it needs to, rather than having to order it monolithically, sorry, monotonically against each other for the entire.
00:40:50.396 - 00:40:52.428, Speaker C: So these are, these are unrelated transactions.
00:40:52.476 - 00:41:36.164, Speaker B: You're talking about unrelated transactions. Yeah. Okay. So now you get into the stage of related transactions. So how does the network know what are the related transactions? This is where really importantly, the transaction manifest and the transaction layer of the rally network becomes really important because in the transaction manifest, what you do is you declare your transactional intent and you declare what state you're operating on and you declare what applications you're interacting with. And so that allows consensus to. It basically informs consensus what it needs to be concerned about from the point of view of coordination across shards.
00:41:36.164 - 00:42:31.150, Speaker B: And so you have a cross shard consensus mechanism called Cerberus. And what the cross shard consensus mechanism called Cerberus basically does is it's a three phase commit, which allows it to bring in validators on multiple shards to come to an agreement, atomic agreement together on the state update of multiple shards. So go. Okay, I've got five different validator sets on, you know, over ten different shards for a complex defi application transaction. And these all need to agree on their local state and on their crush state. And the Cerberus consensus mechanism is specifically the algorithm that is run to enable the nodes to go, do I think this is valid locally? I'm not going to commit to it yet. I'm just going to say do I think this is valid locally? Yes, I think it's valid locally.
00:42:31.150 - 00:42:54.978, Speaker B: Okay, who are the other nodes that I need to talk to? Well, I know what state I'm dealing with. So as a result of that, that map to my known validate set. So I call out to those validates and I go, hey, guys, I'm processing this transaction. They go, oh, we are, too. Let's have a conversation about whether or not we think we're all locally valid. Yep, we're all locally valid. Okay, are we going to commit to make it to making this atomically committed across the shards? Yes.
00:42:54.978 - 00:43:30.684, Speaker B: Okay, we've all committed, and now we're going to commit to it locally as well. And that's essentially what Cerberus is doing. But the whole point is that everything is cross shard. There is no such thing as a transaction that doesn't touch more than one shard, really, in that environment. So everything is a cross shard operation. Everything runs around that cross shard consensus. But because you can parallelize, and because the shard space is so big, unless you are explicitly declaring that things are connected, you can just run them in parallel, which allows you to have this massive throughput as a result.
00:43:30.984 - 00:43:54.876, Speaker C: So this brings me to a couple follow on questions. So, as I'm understanding it, and correct me if any of this is wrong, I'm going to try to summarize here. If you have shard space, that's two to 256. My understanding is you probably have an address space space, right. And so your validators, I assume, are like, assigned to some segment of this address space that it's validating.
00:43:55.060 - 00:43:55.784, Speaker B: Right.
00:43:56.284 - 00:44:05.700, Speaker C: And so then when you have transactions and accounts, it declares the address space it touches, and then it needs to go essentially like, synchronize with the validators that are validating that address space.
00:44:05.732 - 00:44:06.304, Speaker B: Yes.
00:44:07.444 - 00:44:19.942, Speaker C: What that leads to, in my mind, is like, doesn't that mean that not all the nodes on the network are always seeing the same state? And when does that get synced back to the rest of the nodes?
00:44:20.038 - 00:44:20.710, Speaker B: Right? Correct.
00:44:20.782 - 00:44:31.474, Speaker C: And how do you have byzantine fault tolerance if it's only a small set of the network that is ever validating some address space versus the full consensus set?
00:44:31.774 - 00:44:56.526, Speaker B: So essentially, your nodes are constantly churning between. So you have a pre image resistant way in which you churn the validators. You have a randomization function for doing that. And the validators are basically constantly churning and resyncing on their address.
00:44:56.590 - 00:44:58.462, Speaker C: So there's rotating address space that they're.
00:44:58.478 - 00:45:00.574, Speaker B: Validating on address space that they're validating.
00:45:00.614 - 00:45:07.634, Speaker C: So it's almost like a leader rotation, but instead of rotating leaders, you're rotating what they're actually validating. Okay.
00:45:09.614 - 00:45:55.244, Speaker A: I have a bit of a different question. Basically what you're talking about at the protocol level, it enhances in some ways user experience, developer experience, security guarantees. Is there a trade off you're making here by making these optimizations in terms of what developers are able to build concretely, like new standards like 404s on Ethereum and Solana, or even just what you could do with on chain games and like friend tech, for instance. Would these applications be possible to have been built in this kind of paradigm where you're giving that a very opinionated view on how people can do things and move money around? How do you think about that?
00:45:55.984 - 00:47:11.188, Speaker B: Yeah, the answer is absolutely. ARC 404 has already been implemented on radix and it didn't require a standard and didn't require a standard because of the entry objects of Radix, like ERC 404. You know, there's a vant, the guy who helped set up this podcast has implemented it himself and implemented a token type called ice and water, which basically allows you to move between water tokens and ice nfts, which fully implements ERC 404. And he basically did it in a weekend. And wallets automatically understand and are able to interact with those objects because they're using the entry objects of the ledger. There's no standard to go around and get everyone to agree to fintech. The same thing we basically to get to the radix engine and scripto, we spent two years and spoke to about 1000 developers and projects to, and then spent another two years just realizing how long it's been now testing it within our community of constantly getting people to come to us before we enshrined it into the ledger.
00:47:11.188 - 00:48:17.634, Speaker B: Right? We had this one and a half year period of building our developer ecosystem where part of the things we did is every month we run challenges where we're like build dexs in Scripto this month, build lending protocols in this month, build social applications, build all of this stuff. And part of it was going, can we break this model? Is there something we can't make that break? Some fundamental thing that people want to be able to do in crypto? And the answer has been for the 99% of the cases, none. And for those small cases where we find an exception that actually results in a significant problem for market addressability, then you can just update the radix engine. And the update to the radix engine doesn't break any of the existing smart contracts. It just adds a functionality, it adds an extra element of functionality to the radix engine that new applications can then use. And you've rolled that out for everyone immediately. You haven't had to get exchanges to agree to integrate this new standard type because they are integrated with the Radix engine.
00:48:17.634 - 00:48:41.254, Speaker B: Like by integrating the radix network, you are integrating the Radix engine. So if you update the network state, you update all of your integrations, custody exchanges, wallets, everything. So, yeah, not only have we not come across things that people can't build, this undiscussed burden of new standard adoption within infrastructure just goes away as well.
00:48:46.224 - 00:49:05.992, Speaker C: So I guess like one thing I'll ask is how are you thinking about developer onboarding? Anytime you have a new programming language, it's inherently a hurdle to get over. We've seen that in the movie cause these, we saw that in Solana in the early days. It was kind of amazing that Solana has even gotten the developer adoption.
00:49:06.088 - 00:49:07.004, Speaker B: Amazing.
00:49:07.344 - 00:49:16.534, Speaker C: Yeah. And so how do you think about that? Like Monad, we've consciously made the decision to go with the EVM because developer onboarding is much easier that way.
00:49:16.614 - 00:49:16.854, Speaker A: Right?
00:49:16.894 - 00:49:17.514, Speaker B: Yeah.
00:49:17.894 - 00:49:24.654, Speaker C: And so like, how do you think about this? Right? Like how, how do you think about this as a philosophical question?
00:49:24.774 - 00:51:02.894, Speaker B: So I'll start with the philosophical quote first and then I'll go into like the practical, like how do you actually onboard develop philosophically? Like are we in the first innings or the last innings of the game? Right. We, I look at from all of the interviews it that we did and the size of the crypto space from a developer point of view, tiny. The electric capital report is 25,000, 28,000 full time web3 developers. Truth is, in terms of the people actually building in Web three and DeFi, everyone knows everyone and that's really difficult to get if you have got something more than 2000, 3000 people who are like seriously involved in the community, the size of the developer market, the number of developers in the world today is 25 million. And if we believe that these public ledgers, Defi and web3 is truly going to be an innovation as big as the Internet, it absolutely makes sense that you build a programming language that is as accessible as possible, as secure as possible, and is as easy to pick up as possible for new developers coming into the space. This was one of the things that we really focused on in that sort of one and a half, two year period that we spent building scripto was we didn't actually start with going what tech stack? We didn't go oh, we're going to use WASM or are we going to use rust or oh, we're going to use whatever. We actually started with the docs first.
00:51:02.894 - 00:51:53.960, Speaker B: This is how sort of like insane the process was. I mean, it makes perfect sense when you think about it from product point of view. But like, we started with the docs, we went, all right, new programming language, let's just build the docs around this pretend programming language that we're going to call scripture. And we built all pseudo code and we just, we spent a good six months of just doing user interviews with new developers and existing web3 and Defi developers and sitting them down with the docs for a couple of hours and talking through at the end of it whether or not they understood the approach. And it was only when we started to do that and you know, we do it for 2 hours, they go home, they wouldn't take the docs with them, and over the weekend they'd then send us and be like, hey, I think I've coded up Uniswap in your like programming language. Does this look right? We'd be like, holy, holy shit. Like, yes, that is.
00:51:53.960 - 00:53:15.000, Speaker B: So now we're getting to the point where we're really getting through to people. So like that's my philosophical view is it's easy in the presence to view something as inevitable because of what it feels like it has momentum behind it. But when you actually contextualize how little an impact solidity has had in the wider adoption of people programming it, and the huge problems and pains it causes, the significant difficulty to hire good solidity developers, yes, you can pick up solidity easily, but being good at it in a way that you're like, yeah, sure, I'll trust ten, 2100 million dollars into that really hard. Then you're going down to a few hundred people, maybe they're at that level, right? And going right back to the start of this conversation, I said, you know, there were three problems we identified when we were talking with DeFi projects. One of them was developer focused and two of them were business focused. The two business focused problems were, one, I can't hire enough developers. Height of Defi summer, talking to some of the leading projects in the space, we were like, what's your number one problem? We were expecting them to come back with scalability hacks and exploits.
00:53:15.000 - 00:53:58.794, Speaker B: They just went, we can't hire enough people, we can't hire enough good developers to be able to build what we actually need to. We got the users, we got the capital, we got the hype, we can't actually deliver product. And at the height of Defi summer, when you've got the charts of the number of developers in solidity going up, and you've got these projects that have got more money than they know what to do with, and they are saying, I can't hire developers for love nor money. At that time. People are throwing 3400, $500,000 salaries at people who'd done solidity for two years. Insane. That's what I look at when I go, that's why scripto.
00:53:58.794 - 00:55:08.516, Speaker B: And then the, incidentally, I may not get to it. So just to mention the other number two problem was bounce rate. So the number of people who came and tried to use their application and then wasn't actually able to add money to it because they found the usability too hard of metamask or things like that, they bet, like a lot of these projects, even at the height of Defi summer, had a bounce rate of like 98%, which is insane. So that was the number two problem. And like those three things really define a lot of the trajectory of what we decided to build as tech. From the point of view, how do you on board developers? I segment, I segment in my mind the developer market into, into four quadrants. And if you imagine an x axis and a y axis, right? So along the x axis you have level of developer experience, right? So how good as a developer are you? And zero, you've got like, you know, a script kiddie, someone who's just learned Python for the first time or something like that.
00:55:08.516 - 00:55:42.950, Speaker B: Not to disparage Python, Python's great. And I can't, you know, I'm not, not particularly a programmer, I can't program. So like, but just, just someone who's just started picking up like Python. And then on the other end you've got Linus Torvald, the creator of Linux. So zero to 100. And on the y axis you've got level of defi understanding. And so at zero you've got, let's say, I can't remember, Warren Buffett level of defi understanding zero.
00:55:42.950 - 00:56:19.664, Speaker B: And then at the top you've got Andre Cronje level of Defi understanding 100. And then that creates your four quadrants. And your top right hand quadrant is basically where all of your top solidity developers are. They are both very high level Defi understanding and very high level of competence because they have to be, to be able to be building the programs that can hold this much value. We ignore that segment that segment. Those guys are getting paid incredibly well and have a skill set that is incredibly valuable for that market. We're not going to go after those guys.
00:56:19.664 - 00:56:48.128, Speaker B: Let all of the other projects, let all of the other ecosystems that are getting all of this funding go and duke it out for that tiny market. Fine. If you're EVM compatible, that's where you're fighting. Sorry. Then, then you've got sort of to the left of that. The people that we call the frustrated Defi developers, they were high level of Defi understanding. They're not quite at the level of like God tier developer to be able to be in that top right hand quadrant.
00:56:48.128 - 00:57:17.414, Speaker B: They've maybe built some stuff and it got hacked or they thought about building it, but they felt like they would get hacked, so they didn't want to actually go in to do it. And so we estimate that to be around half a million developers. About half a million developers have given solidity a go and decided not to do it for various reasons, either to do with risk or to do with complexity or to do with competence. So that's one of the big markets that we go after because it's easy to convert them. You go, hey, you're a frustrated defi developer. You want to build something in Defi. Here's a better tool to be able to do that.
00:57:17.414 - 00:58:09.564, Speaker B: Here's how you can actually realize the thing that you've always wanted to build, but just felt like it would be too scary, risky or problematic. Do using slips. So we really go after those guys because that's a great market to move them off. And then your bottom right hand quadrant is really where your biggest potential is. So everything like you have these highly competent developers who don't know that much about DeFi but could easily move into it. So, you know, all of the people working who are doing programming for investment banking, everyone in the back office who's doing code for Goldman Sachs and JP Morgan who hired hundreds of thousands of developers, everyone who's working at like a boring web, two SaaS financial application, those guys, you can move up the DeFi competence curve very quickly. Also.
00:58:09.564 - 00:59:06.920, Speaker B: That's where we see the high potential DeFi developers. That's also where we focus. And so our like, sort of our marketing strategy, our like, our attraction strategy on Scripto follows those two. A, frustrated Defi developer and b, high potential Defi developer quadrant. And we've had a lot of success in that. The programming language went live in test Scripto and program, the scripture programming language, went live in test at the end of 2020 and went through a two year period of beats testing. And in that two year period, we sort of scripto downloads, went from zero to about 20,000 scripto downloads scripture and our developer community, sort of active developer community within our discord sort of like continuously grew and we got this sort of really great ground.
00:59:06.920 - 01:00:00.762, Speaker B: And it was grassroots because the point wasn't, hey, come in and build now, go launch now. It's like, hey, we've got an idea that we think is the right route to actually be building smart contracts on top of public ledgers. Come and get involved in helping formally edit that. And that really was the sort of the starting point of building this grassroots movement of a true community that believed in the way that we were doing things and was engaged in doing that and helping us out and improving it. And that's sort of, I put a large degree of credit to why the documentation is good so good, why Scripto as a programming language is so good. It just came from that work with the community over that two year period, which now leaves us this point now where we have that core community who is super responsive. You come into the, into the discord channel and ask any question about scripter and instantly you get an answer from the community or from one of our own mods.
01:00:00.762 - 01:00:24.674, Speaker B: But the community, very often highly supportive. Take people like avant, like saw Erc 404 and went, I could do that in scripture, no problem. Then banged out on a weekend like that. That is so much, so important contextually around the programming language. Not just is your documentation good, but is the community supportive? Are people coming up with ideas? Are people reaching out? So, yeah, that's the long and short of it.
01:00:25.454 - 01:00:47.200, Speaker A: Well, we covered a lot of topics and I think we could probably talk for hours about all the differentiators between Radix and all the other choices developers have. Do you have any closing thoughts that you want to leave our listeners with, as they would potentially want to get up to speed with this ecosystem and potentially any resources that would be great for people who want to do a deeper dive?
01:00:47.392 - 01:01:16.714, Speaker B: Yeah, sure. So like, if you like the tech, then if you, you know, you want to dive into the white papers, then go to radixdlt.com. And there's our white papers on there, including like sort of the, the peer reviewed published one around our consensus algorithm. If you're interested in diving in as a developer, want to try it out, then docs dot radixdlt.com is where our docs are. We pride ourselves on our docs. So please do go and check it out.
01:01:16.714 - 01:02:07.932, Speaker B: It is very easy to get up and running and then if you're interested from a user point of view or want to explore the ecosystem more, I highly recommend downloading the Radix wallet and just giving some of the apps in the ecosystem a try. My sort of top three recommendations are caviar nine.com comma, which is a concentrated liquidity DeX on Radix super simple swapping interface. And just use the DeX once on the Radix wallet to get what I'm talking about. When it comes to user experience, you'll get to see human readable transactions, you'll get to see almost instant finality, sub second finality at the moment, and you'll get to sort of like feel what it means to be able to have a an underlying ledger. That way you understands all of the things the Radix engine offers. Aussieswap.com,
01:02:07.932 - 01:02:59.906, Speaker B: which is an implementation just gone live of uniswap V four with all of the hooks. So it's a hook implementation, hooks centric implementation of Uniswap V four before Uniswap V four has even been implemented on Ethereum. So if you're sort of a trading geek and you want to get into that, or you just want to be able to put on limit orders and things like that, Aussie swap V four is great. Sorry, Aussie swap V two, Uniswap v four clone is great for that. And then I'd also recommend checking out trove, which is trove tools, which is like an NFT trading platform. But the reason I'm recommending it is just got this really clean uI, really cute clean ux, and it sort of really meshes really nicely with the relics wallet. So you get to sort of feel, oh, and if you want to get some free Radix tokens to be able to do all of these things, then go to when you download the wallet, wallet dot radix dlt.com,
01:02:59.906 - 01:03:10.454, Speaker B: you'll get invited to participate in something called Gumball Club, and Gumball Club will teach you how to use the wallet and also give you a couple of free tokens to then be able to access all of the other stuff on the radio.
01:03:11.354 - 01:03:26.844, Speaker A: Awesome. We're definitely excited to see what comes of Radix. Clearly a lot of thought has been put into the architecture of this ecosystem. So super excited to see what's going to happen next and thank you so much for taking the time and giving us the complete rundown.
01:03:27.384 - 01:03:28.664, Speaker B: Thank you. Thank you for having me.
