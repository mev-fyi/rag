00:00:00.890 - 00:00:41.126, Speaker A: Welcome everybody. I'm excited to see some new people and some familiar people. We are recording and are going to post this on YouTube afterwards. My name is Paul and I've been working with RISC Zero for a while now. I'm excited to dive into a little introduction on read Solomon codes. We started these study club sessions as a way to kind of get our internal team up to speed need, but it was suggested that we should make these available to the general public and I'm excited to be doing that. So thanks for joining us on this initial slide, which the slides are going to be on the website shortly.
00:00:41.126 - 00:01:44.266, Speaker A: And I'll post a link on Twitter directing you to those slides. On this first slide, there's a few references that are intended to give you some resources to sort of supplement this presentation. We have a little reference doc on the website about Reed Solomon codes. Most of my knowledge about Reed Solomon codes comes from this wonderful course that Mary Wooters at Stanford put together. So there's a link to this course on algebraic coding theory and specifically the lesson on Reed Solomon codes. I also included a link to the original Reed Solomon paper, which is refreshingly simple. It's like, I think, five or six pages, maybe, definitely under ten, and pretty readable if you have a basic finite field background, if you want a little bit more of an intuitive reference rather than a technical reference.
00:01:44.266 - 00:02:20.486, Speaker A: Three blue, one. Brown has a video about hamming codes which are reasonably closely related to Reed Solomon codes. And that video provides a pretty good intuition for what's going on with error correcting codes in general. And then the last reference that I have posted here is on the website. We have a little walkthrough of a kind of numerical example of constructing our seal, the sort of zero knowledge proof that lives on our receipts. So you can walk through that. And that shows a little bit of a quantitative example of Reed Solomon codes.
00:02:20.486 - 00:02:51.426, Speaker A: We'll see some of that in the slides. So those are our initial references. I want to invite this. I'm going to be mostly kind of lecturing, but I'm going to pause frequently to invite questions. And I want to invite that. If you have questions, feel free to just interrupt me. I would kind of rather you actually just jump in and interrupt rather than using the raise hand button, because it's hard for me to distinguish the raise hand button from the new people joining sound.
00:02:51.426 - 00:03:19.286, Speaker A: So do feel free to interrupt me. And I want to, I guess, just emphasize that whatever questions are on your mind are going to add value to the presentation. So please don't sort of hold back questions for fear of interrupting. So I already sort of welcomed you a little bit. Thanks for joining us. And I said a little bit about why we're here. I wanted to kind of invite at this moment in the presentation.
00:03:19.286 - 00:04:59.770, Speaker A: For those of you that are joining externally, I'm kind of curious, and I think our team is a little bit curious, like, what's motivating you to be here today? So, if you care to share a little bit in the chat, feel free to introduce yourself, say a little bit about why you're here, whether read Solomon codes are something you've been thinking about previously, or if it's a new topic to you. From my perspective, I'm sort of here to help you understand what Reed Solomon codes are and where they fit into risk zero's system. So let me sort of start the talk with a kind of brief introduction to how read Solomon codes fit into risk zero's technology. So at a very sort of high level zoomed out view, the way that we produce this receipt that attests to computational integrity in our system is we have this zero knowledge virtual machine, and you execute some RISC five binary file inside our virtual machine. And the virtual machine records the execution trace, the sort of complete record of that binary file executing, and we get columns. When we do that, we then use read Solomon encoding on each of those columns. So right off the bat, we compute an execution trace, and then we encode it using read Solomon encoding, and this encoding turns our columns into blocks.
00:04:59.770 - 00:05:39.802, Speaker A: Then we do a bunch of complicated math stuff to these blocks. We evaluate some constraints, we compute some quotients. And after we do all that math stuff, we need to convince the verifier that the result of all that is still a valid read Solomon code word. And we use the fry protocol at the end in order to do that. So this is sort of a zoomed out view of the way our system works. We generate an execution trace in terms of columns. We encode those columns into read Solomon code words.
00:05:39.802 - 00:06:42.010, Speaker A: We transform those code words in some way, and then if the result is actually a valid read Solomon code word, it serves as an argument of computational integrity. So that's the sort of high level view. Does anybody have any questions at the moment? Is there parts of that that I feel sort of, like, fuzzy or confusing? Of course, this is a pretty zoomed out view. So on some level, I'm leaving a lot of black boxes here. But before we dive into sort of the next steps, which we're going to sort of look at some of these steps a little bit more explicitly questions about where Reed Solomon codes fit in. Okay, so let's go ahead and move forward. The plan for today is to show you a really simple version of read Solomon encoding, like a slightly, a simplified version of it, not using all of the technical jargon.
00:06:42.010 - 00:07:33.294, Speaker A: And then we're going to see what it looks like to try to decode a read Solomon code word. And then we're going to look at those steps a little bit more in detail to kind of show what we mean by those steps. So let's dive in with a sort of intuitive version of read Solomon encoding. The basic premise of an encoding is it's a way to start to translate messages into code words. So any sort of simple cipher, like just a letter shift, is an example of an encoding. This is like kind of math notation. Here you can think of the encoding as a function that receives some message and spits out some code word.
00:07:33.294 - 00:08:09.100, Speaker A: So it's a map from the collection of possible messages to the collection of possible code words. And the code is then anything you could possibly get by running an encoding. So when we say the read Solomon code, what we mean is the collection of all possible results of running read Solomon encoding. So here's what it looks like to do. Read Solomon encoding. You start with some message. In this case, let's just say our message is hello World.
00:08:09.100 - 00:09:07.980, Speaker A: The first step is to create a polynomial that kind of matches that message. And what I mean by matches here is the, well, f of zero equals h, f of one equals e. I hope it's sort of clear what I did here. Just the numbers zero through nine are associated with the 0th letter, first letter, second letter of your message. So this process, I won't at this point go into the specifics of how we find that polynomial, but we find some polynomial of low degree that matches this, and then we just evaluate that polynomial on a larger domain. So here I've put in between all the integer values here. We could evaluate it at one half and one and a half and two and a half.
00:09:07.980 - 00:09:48.540, Speaker A: And the point here is that these values in the second column here, what I've written as qwerty uiop, it's literally just the sort of top line of your keyboard. You don't really get to choose those. You have a message, the message forces a polynomial choice, and then the polynomial forces the evaluations on those other points. And at the end here, we get a code word. And if you look at the code word, you can see it's twice as long as our original code word. Every other letter here is actually the original message. Hello, world appears as the first 3rd, 5th, 7th, 9th entry here.
00:09:48.540 - 00:10:27.266, Speaker A: And the sort of redundancy that was added by evaluating on a larger domain is there in between questions about this process. So there's some choices that you could make along the way here. I added one point in between every. My larger domain is twice as large as my original domain. You could make it three times as large or four times as large. So there's a sort of choice here. But roughly speaking, this is the process.
00:10:27.266 - 00:12:03.410, Speaker A: You start with a message, you form a polynomial based on that message, you evaluate on some larger domain, and now you have a code word. So I do really want to, if part of this feels fuzzy, I want to invite questions at this point because we're going to be sort of assuming this as understood as we move forward. Okay, so this is the simple version. There are, I think, some natural questions to ask about this, like what is it good for? What's the relevance in risk zero. And then in terms of the actual details here, how do we find this polynomial that I mentioned? How do we choose this larger domain? And our system is a zero knowledge protocol, and there's a little bit of change that needs to be made here in order to make this compatible with a zero knowledge system. Unless there's any questions from any of you at the moment, I'm going to sort of proceed and try to answer roughly the questions that are on the screen right now during the rest of the presentation. Okay, so to recap or not to recap, to circle back to this slide that I showed you at the beginning of the presentation, here's where read Solomon codes fit into our system.
00:12:03.410 - 00:12:50.670, Speaker A: And I want to now kind of unpack that. Well, I guess, actually, before I want to unpack that, I want to look at an example of receiving a code word with an error. So here's a slide that I took from Mary Wooter's course, and it sort of gives a stick figure version of how this might be used in practice. So Alice has some message that she wants to send to Bob. Maybe the message is hello world. She encodes it as some code word using this process that I described before, and she sends it over a channel that might have some noise. So there might be some distortion here, there might be some errors in the message.
00:12:50.670 - 00:13:45.488, Speaker A: And then Bob receives a message. This c twiddle here may or may not actually match with c. And Bob looks at this message or this code word, I should say this block is the result. And Bob says, what was the original message? And so Bob has to then try to decode the original message. So how do we actually do this? Let's say that we're Bob and we received some block. This is identical to the block that we looked at before, except there's one error, the first character of the original, of the sort of valid block that if we start with hello, world, we would get exactly this block, except with an h at the beginning. So Bob receives this block and says, okay, I want to decode this.
00:13:45.488 - 00:14:30.328, Speaker A: Let me construct the polynomial associated with these entries. And what Bob's going to find here, because there was this error, is that this polynomial is actually going to be way higher degree than is appropriate. In particular, Bob wants to find a degree less than or equal to nine. That's what happens if you make a polynomial with ten points. This is sort of like if you try to make a polynomial, that if you try to make a line, if you try to connect two points, you can do it with a line. If you try to connect three points, you need a degree two polynomial. If you try to connect four points, you need a degree three polynomial.
00:14:30.328 - 00:15:01.816, Speaker A: So in this case, my message, hello world, had ten points. So an interpolation of that should give something that's no more than degree nine. So if Bob sees something that is actually degree less than or equal to nine, then he'll conclude, yeah, okay, this block was valid. And if not, then he'll say, oh, okay, something went wrong. Can I fix this? And this is really like the raised hand. Oh, yeah. Okay, great.
00:15:01.816 - 00:15:04.904, Speaker A: Let's hear the raised hand. Thanks, Tim. Yeah.
00:15:04.942 - 00:15:14.110, Speaker B: I'm sorry. In this example, don't you have 20 points instead of ten? And won't you always have a polynomial of degree greater than nine?
00:15:15.440 - 00:15:57.210, Speaker A: So in this case, Bob will certainly find a polynomial that is too large. But if this first point was actually an h, then this interpolation will actually return something quite small, because it's sort of like, sure, yeah, there's 20 points, but you can think of it like, let me imagine I just took two points, and I draw the line between them, and then I add some extra points on that line. Now, when I try to form a polynomial based on all of those points that are collinear, I'm still going to return a line even if I do the interpolation on a bunch of points.
00:15:59.360 - 00:16:05.950, Speaker B: Is it correct to say then the guy who is interpolating is going to interpolate on every other point?
00:16:06.720 - 00:16:50.504, Speaker A: No. So in this example, the guy who's doing the interpolating is going to interpolate on every point. And if the block is actually valid, that interpolation will result in something quite small degree. But if there's something fishy that happened, if there was an error, that interpolation will result in something high degree. Yeah, it's a kind of subtle point. I'll sort of try to circle around that idea one more time, and then we'll move forward, and hopefully it will make sense. If we start with something valid.
00:16:50.504 - 00:17:42.412, Speaker A: If we start with something that's ten characters, and then we construct a polynomial based on it, it's going to have degree nine, presumably. And then if we send a bunch of points that are associated with that degree nine polynomial, when you interpolate those points, you're still going to get something degree nine. So it's sort of a specific construction that if I just look at an arbitrary collection of points here, 20 points, I'm not going to expect something low degree. But if they did come from Alice genuinely encoding a short message, then it will actually be degree. So hopefully that tracks interpolation used.
00:17:42.546 - 00:17:44.380, Speaker B: Maybe that will also clarify.
00:17:44.800 - 00:17:48.940, Speaker A: Yeah, okay. Yeah, we'll see that a little bit shortly.
00:17:49.280 - 00:17:55.200, Speaker C: It's a fair analogy to say that evaluating over the larger domain is analogous to adding parity bits.
00:17:55.540 - 00:18:23.080, Speaker A: Absolutely. Yes. Evaluating over the larger domain is 100% analogous to adding parity bits. And in this case, the sort of parity bit analogy would be like, well, I don't know how to sort of finish that analogy, but yes, absolutely. That analogy is very strong. And in fact, the hamming code video that I suggested might kind of contextualize that a little bit more clearly.
00:18:25.260 - 00:18:41.960, Speaker D: Another way to think about it is if you have three points on a line, it's pretty easy to determine that they're all Collinear. And so any two of those points could reconstruct the same line. If there's an error in one of them, the polynomial that intersects all three of those points is definitely not a line anymore.
00:18:42.120 - 00:18:42.830, Speaker A: Exactly.
00:18:43.440 - 00:18:46.300, Speaker D: It's by definition, like, going to be much higher a degree.
00:18:46.460 - 00:19:40.450, Speaker A: Yeah, good question. And, yeah, it's maybe a point that I could have clarified a little better. Next time I'm teaching it, I'll clarify it a little better. So in this case, when Bob receives this block, this is not actually going to create a degree less than or equal to nine polynomial. When Bob runs this interpolation, because there was an error here, he's going to end up with something that's like degree 19, presumably. And so Bob then is going to say, can I fix this? And in order to sort of think about this idea of can I decode this? We need to introduce some new notions, I guess. So I'm going to try to introduce a little bit of a geometric perspective on this question.
00:19:40.450 - 00:20:21.490, Speaker A: So on the screen I have the collection of all the valid code words. There's only a few dots shown, but you can imagine there would be a lot more valid code words. And we're assuming just code words based on messages of length ten. So let me make this a little more concrete. Here's an invalid code word. We started with this message of hello world and encoded it into this code word here. And if we had instead started with this message of Jello world, maybe we would end up with this code word here.
00:20:21.490 - 00:21:23.570, Speaker A: But what we actually received was this block, which is not actually a valid code word. So Bob runs his interpolation on this, and he says, okay, this isn't actually a low degree polynomial. This is degree 19. I was hoping it was degree nine. So can I decode this? And in order to answer that question, Bob says, well, is there some code word that's kind of close? What do we mean by close here? I've drawn sort of a line between these points here, and we could try to ask a question of what's the distance between these blocks? The way that we measure distance here is by looking at the number of entries that disagree. This is the hamming distance is the technical term for this. It comes up all over the place.
00:21:23.570 - 00:22:37.280, Speaker A: So here's those three blocks laid out a little bit more explicitly here. The top one here is the word that we received, and Bob looks at it and says, okay, yeah, that's not a valid code word. And then there's two examples of code words here, and the red color coding indicates where they disagree. So the first and second entries here, the first and second rows, I should say, have a distance of one from each other, whereas the first and third one have a distance of eleven from each other. And it turns out that these are actually going to be like the closest and tied for second closest examples here. And based on that sort of discrepancy in the closest distances, Bob is able to say, okay, yeah, I'm pretty sure that Alice actually meant to say hello world, not Jello world. So the kind of key value of read Solomon encoding is the code words are pretty far apart from each other.
00:22:37.280 - 00:23:22.880, Speaker A: In particular, degree nine polynomials can't agree in like 15 places. They can't agree in any more than ten places unless they're exactly identical. So Reed Solomon encoding, sort of makes use of the fact that low degree polynomials can't share very many points. In order to give a way to decode potential errors. I introduced a decent amount of new ideas here I want to pause before we move forward. Is this making sense at all?
00:23:28.870 - 00:23:45.350, Speaker C: Questions at the moment, I have a question that, sure, the space of valid code words. This seems pretty large. How do we find like a close valid code word? Just use something brute force or. I'm guessing there's like a fancy algorithm.
00:23:47.710 - 00:24:50.460, Speaker A: There are some fancy algorithms, and there's two fancy algorithms that come up, one of which works if you're pretty close, and the other one works if you're kind of farther, and they're called the burlicamp Welch decoding algorithm, and the, I can't remember the other name attached to Guruswami Sudhan decoding algorithm. So the first one will return, assuming that the first one works if there is a unique closest word, and the second one works if there's actually a tie for closest. And I'm not going to go into the details of those algorithms, both because they're out of scope and because they're out of my mastery range, but more or less.
00:24:53.010 - 00:25:03.540, Speaker D: Those algorithms also can detect if it's an invalid code, like somebody just made something up in this example. You'd expect it to match almost to nowhere, I guess.
00:25:06.550 - 00:25:23.720, Speaker A: Yeah. Regardless of sort of how much nonsense it is, you would always be able to ask the question of like, well, what's the closest valid code word? So you can get a sense of.
00:25:26.170 - 00:25:45.662, Speaker D: Any message could be arbitrarily corrupted, and then you have no idea whether it's valid or not. So it's just how much you want to trust the. I guess that's another question of how many points can get corrupted. And with you still being able to recover the original code word or the original message with a high degree of certainty, maybe that's what you get into.
00:25:45.796 - 00:26:22.440, Speaker A: That's like, exactly the fundamental question in error correcting codes is like, how much redundancy do you have to add in order to be able to correct how many errors? And if you add more redundancy, then you have a higher error correcting capacity. And capacity is the word that's used for that exact question of how many errors you can either detect or correct. Great questions, other points of confusion at the moment.
00:26:25.130 - 00:26:43.790, Speaker B: So I think maybe I'm coming back to the older question. Is the guy who is interpolating, does he already have a notion of what degree to expect? And then he tries, okay, yeah, then he tries to find the coefficients of that polynomial using all the 20 points that he received.
00:26:44.130 - 00:26:44.880, Speaker A: Exactly.
00:26:45.410 - 00:27:04.950, Speaker B: And then he says that, look, whatever I have just interpolated, what I don't understand is that where does he find the discrepancy? I mean, I can interpolate, given any set of 20 points, I can always find a polynomial through it. What tells me that this is not valid?
00:27:05.530 - 00:27:36.340, Speaker A: You look at the degree that you get. I see. So if you interpolate 20 points, you are going to expect degree 19. But if you end up magically getting something that's degree nine or less, that is your indicator of a discrepancy. That's your indicator that there's not a discrepancy. So degree 19 is what you would generally expect if you interpolate 20 points. But that's the indication of a discrepancy, is the degree of the result.
00:27:38.310 - 00:27:43.300, Speaker B: Oh, I see. So there is some magically getting a lower degree going on here.
00:27:44.490 - 00:28:28.370, Speaker A: It's not so much. It's like what the analogy that Brian was making earlier was like. You have three points that are collinear, like, in this case, you have 20 points that are living on the same degree nine polynomial is sort of not what you would expect if you randomly generated 20 points. So the discrepancy is like, do those 20 points actually live on a degree nine polynomial? Which is an extremely unlikely result in a random situation, but exactly the result if the encoding was done honestly and there was no noise in the signal.
00:28:31.510 - 00:28:32.820, Speaker B: All right, thank you.
00:28:33.270 - 00:29:00.320, Speaker A: Yeah, great questions. Okay, so we've introduced a rough mechanism for how you construct a read Solomon code and how you kind of try to decode a word if it's invalid. Any other questions? And we, I guess, introduced a notion of distance. Any other questions at the moment? Before we continue.
00:29:02.690 - 00:29:16.020, Speaker D: I do have something that's kind of been on my mind throughout this presentation so far, is why we use polynomials. I feel like it kind of just snuck in.
00:29:17.110 - 00:30:10.610, Speaker A: Yeah, great question. The polynomials. Polynomials don't share very many points is the sort of the magic here. So in particular, this collection of valid code words that's on the screen right now, they're all no closer than distance ten from each other. And that's because polynomials can't share too many points. So if we want to be able to essentially over and over and over again, the results that we're working with here rely on the number of points that polynomials can share is related to their degree, and that's not true for functions that aren't polynomials.
00:30:11.510 - 00:30:26.734, Speaker D: So it's like a way to get something, it's like an idea, it's like a construct so that we can get something unique and a way to conveniently label something as indistance.
00:30:26.802 - 00:30:48.814, Speaker A: Okay. Yeah. There's only one degree nine polynomial that will go through hello world. And there's a bunch of functions that will go those ten points. Yeah, it's a forcing function for uniqueness. It also tells the person constructing the polynomial how to interpolate. Right.
00:30:48.814 - 00:31:04.034, Speaker A: Like when you're trying to evaluate at 0.51.52, .5 et cetera. If it's a polynomial, you know how to do it. But if it's just a function, you can put anything you want there. Yeah. Cool.
00:31:04.034 - 00:31:38.740, Speaker A: Thank you. I'm loving these questions. I want to again invite if there's more at the moment, we can take them or we can continue. Ok, let's keep going. So where are read Solomon codes actually used? I don't know why there's a hyphen in standard practice there. I guess maybe that makes sense. Read solomon codes are the basis for QR codes, which is kind of cool.
00:31:38.740 - 00:32:40.866, Speaker A: And they're also used in cell communication and satellite communication. They're a really effective way to balance the trade off between adding redundancy and enabling error amplification and error correction. In our context, they're used in starks, scalable, transparent arguments of knowledge is the technology that risk zero's receipts are based on. And Reed Solomon codes are pretty central to the process of constructing a stark. Let's sort of come back to read Solomon codes in our context a little bit more explicitly. I want to sort of talk through these steps in a little bit more of a concrete context. So the first step that I've listed here is we execute a binary file and we record an execution trace.
00:32:40.866 - 00:33:19.300, Speaker A: And this makes columns. So we have a more explicit example of this up on the website using kind of Fibonacci program. So this program is taking inputs of 24 and 30, and it's doing a sort of Fibonacci addition. So in the first round we just do 24 plus 30 is 54, then we sort of copy the 30 and 54, and we do 30 plus 54 is 84. We're working mod 97. So in the next row we have 54 plus 84. Modulo 97 is 41.
00:33:19.300 - 00:34:25.046, Speaker A: And the last sort of we just do four Fibonacci ads. And this sort of execution trace is designed to assert that if you start with inputs of 24 and 30 and you run four rounds of Fibonacci addition modulo 97, you'll get out the output of 28. So I'm not going to talk through these control columns. What I really want to do is just focus on we have an execution trace and we have a column of that execution trace. So don't stress too much about the details of this program here, although if you want to sort of check that out, there's like ten lessons that walk through the construction of our receipts. So let's follow along the process of what happens to this column as we sort of proceed through our process of generating a seal. So the first thing that we do with this column is we add some random padding at the end.
00:34:25.046 - 00:35:08.562, Speaker A: So this is not read Solomon encoding. This is just a kind of detail in order to make our protocol zero knowledge that I'm not going to worry about so much. But so for our purposes today, the column of the trace is these eight values. The first four are the actual execution trace data, and the second four are some random padding that was added. So that was step one. Step two says that we encode each column using read Solomon encoding. So I'm going to walk through this now a little bit more explicitly in terms of some finite field context.
00:35:08.562 - 00:36:12.534, Speaker A: So if the finite field stuff isn't familiar to you, this part might get a little bit confusing. Although we do have some nice reference materials on finite fields that you can find. I'll put links up. So to recap or to review, what we're going to do is we're going to take this eight entry message, this column of eight entries, we're going to turn it into a polynomial, and we're going to evaluate it to make a code word. So here's python code for actually doing the first step of this. An INTT inverse number theoretic transform is a function that will receive some entries and will spit out coefficients of a polynomial. So here's the polynomial that results from interpolating these eight points, and then we evaluate it on a domain that's four times larger.
00:36:12.534 - 00:36:28.160, Speaker A: So we had eight entries in our column, we're going to have 32 entries in our blocks, and in the next couple of slides I'm going to walk through specifically where we evaluate it. Questions at this point.
00:36:31.250 - 00:36:37.730, Speaker C: The larger domain, I presume you're not doing like interpolation between the points, but something more sophisticated.
00:36:38.150 - 00:37:18.800, Speaker A: The larger domain, I mean, I would actually say less sophisticated. Let me hold off on the question about the larger domain for a minute or two and you can circle back to it if it's still any questions about this intt thing is, I think the biggest black box on the screen right now. And Bolton is going to be giving a presentation. Unpacking that black box in a couple of weeks. But loosely speaking, an intt is a way to turn evaluations of a polynomial. Into the coefficients of the polynomial. So the way that we add.
00:37:19.170 - 00:37:25.778, Speaker B: Sorry, the amount of random padding you add, is it fixed? Is it some nearest power of two?
00:37:25.944 - 00:37:55.770, Speaker A: Yeah, great question. The random padding is based on the number of queries that we do as part of Fry. So, essentially, each row of random padding adds one degree of freedom. And each fry query sort of steals one degree of freedom. So if we want a zero knowledge system. We need to add at least as many rows of random padding as we have fry queries.
00:37:57.310 - 00:37:58.378, Speaker B: Okay, cool.
00:37:58.544 - 00:38:23.140, Speaker A: And we need to make sure that we end up with a power of two. In order to be able to do an intt. So we add enough random padding. That the column is a power of two. And that after we do the fry queries. Our degrees of freedom will have been compensated between the padding and the queries. Awesome question.
00:38:23.140 - 00:38:49.278, Speaker A: So let's sort of unpack. The example that I gave up front was we had the points zero through nine. And then we added 0.51.52. Practice. We're not working with integers and decimals. We're working with finite fields. In this example, we're working over the field of 97.
00:38:49.278 - 00:39:17.160, Speaker A: Field of order 97, I should say. And we're going to focus on the number five. Because five is a multiplicative generator for this field. So if that terminology is unfamiliar. You can go back and watch our video introducing finite fields. But roughly speaking, what this means is that every element in the field aside from zero. Can be expressed as a power of five.
00:39:17.160 - 00:39:42.446, Speaker A: So we use powers of five to index our column. And in particular, here I have five to the zero th. Five to the 12th. Five to the 24th. The point here is that the next one on that list. Would circle back to the first one on the list. Five to the 96 is the same as five to the zero.
00:39:42.446 - 00:40:05.572, Speaker A: So that's sort of why I chose five. Because it's a generator. And I chose five to the twelveth. Because I wanted to have eight terms on the list. Before I circle back to the beginning. The points that I then add. I've sort of just spread them out.
00:40:05.572 - 00:40:46.200, Speaker A: On this farther right column here. There's a bunch of points in between. Five to the zero th. And five to the twelveth in particular. Because I want to expand it by a factor of four. The additional points that I'm going to evaluate on are five cubed, five to the 6th, five to the 9th. So we started with the generator to the 12th power, and then the expanded thing is the generator to the third power, and here's the actual result of evaluating that polynomial on those points.
00:40:46.200 - 00:41:44.620, Speaker A: So this is really the full version we opened up with this hello world jello world thing to just give a little bit of intuitive understanding of the ideas without the need to have the finite field complexity on the page at the same time. But it's really the exact same idea. So this is how you make a read Solomon code. You start with a column, you run an intt or some other interpolation in order to make a polynomial, and then you add some in between points and you evaluate on those in between points. So on the left we have the column, and on the right we have the block, which is actually a valid code word. Assuming that there's no typos or errors in the computation.
00:41:45.600 - 00:42:00.130, Speaker C: Questions, I have a quick question. So it looks like you're limited to only like 96 quote unquote computations in a way, or else you won't be able to add additional code words.
00:42:04.340 - 00:43:04.884, Speaker A: Yeah, so in order to sort of do any of this arithmetic, you have to choose a world to live in. And in this case, the world I'm living in is the field of order 97. And we chose this as just a sort of contrived small example. In practice, we're working with a field that's about two to the 32 large. So you're absolutely right here. I guess in this context I showed here a rate one fourth. Read Solomon encoding is the technical sort of terminology here one fourth, because it's an expansion factor of four, and given the size of my field, I couldn't go any bigger, I guess, than a rate 112 expansion here.
00:43:05.082 - 00:43:19.690, Speaker C: Another question I want to build upon. Maybe you described it, but it was a little confusing to me. Why are we evenly spacing, I guess our generators essentially by five to the twelve?
00:43:21.040 - 00:43:40.480, Speaker A: The evenly spacing is necessary in order to be able to have the interpolation be efficient. Interpolation naively has n squared complexity, but if you evenly space the indexing, then you can do it in n log n complexity.
00:43:43.700 - 00:43:46.896, Speaker C: So it doesn't have to be this way. I guess it's just for.
00:43:46.998 - 00:44:15.100, Speaker A: Yeah, you could do a read Solomon encoding that did not evenly space the points like any choices of points here. If you just choose a domain, do an interpolation, choose a larger domain, do an evaluation that works, but if you want it to be efficient in practice, then the evenly spacing lends itself to NTTs and INTTs.
00:44:15.840 - 00:44:35.970, Speaker C: And my last question is, since you mentioned you're operating over a finite field of size two to the something I forgot, and you have to evaluate over all those points, does it get extensive, or does the fact of this evenly spacing by the fact that the complexity is n log n that you get, I guess, a major performance boost that doesn't really matter.
00:44:36.680 - 00:45:10.460, Speaker A: No. The process of running the interpolations and evaluations is the most expensive part of our prover protocol. It's still pretty manageable. And login complexity is not too bad. But if you look at the sort of amount of computation time for generating a receipt, I think something like 80 plus percent of it is spent doing interpolations and evaluations.
00:45:14.230 - 00:45:30.714, Speaker B: Another question, can you give a hint of how, given this right hand side 32 numbers, these are all evaluations of some polynomial, how do you go about interpolating a polynomial out of this? Is it just an intt done on this thing?
00:45:30.912 - 00:45:51.840, Speaker A: Yeah, the direct way to sort of check this would be just run an intt on the full column there and hope that your result is low degree. And if the result is low degree, it's an indication that it's a valid code word. And if the result is not low degree, then it's an indication that it's not.
00:45:52.550 - 00:45:53.106, Speaker B: Got it?
00:45:53.128 - 00:45:53.362, Speaker A: Okay.
00:45:53.416 - 00:45:55.662, Speaker B: And by low degree, you mean matching.
00:45:55.726 - 00:46:25.242, Speaker A: Some bounded degree expectation and matching the length of the column. The initial thing that we started with had eight terms, so I would expect a degree seven polynomial to result from this. So if I run an intt on that giant list of 32 entries and actually get something degree seven, then I'll conclude that it was a valid code word. Cool. Okay.
00:46:25.296 - 00:46:30.570, Speaker B: Is there a reason why it's not called bounded degree, but called low degree? Is there some other nuance?
00:46:32.530 - 00:47:18.620, Speaker A: Wonderful question. I would say the answer, in my vernacular, is that the fry paper uses the term low degree. Test. The term low degree I find to be somewhat misleading here, because in practice, our low degree polynomials are like degree two to the 16th or something like that. So it's certainly a misleading term to call it low degree, but it's low degree with respect to the block size, but bounded degree. If you, for your own purposes, want to think about it in terms of the phrasing bounded degree, I think that seems like a clearer way to think about it for yourself.
00:47:21.970 - 00:47:54.760, Speaker E: One question, I think, from the data column, the first four items actually was decided by the Fibonacci calculation and why it still fulfills power to the zero file, power to the twelve. It's encoding. No, it's not encoding. So why it still fulfills that requirement? Are you just do the mapping for that?
00:47:55.130 - 00:47:58.390, Speaker A: Sorry, what's the requirement that you're asking about fulfilling?
00:47:58.830 - 00:48:08.282, Speaker E: I mean. Okay, I got that. Sorry, I got that.
00:48:08.416 - 00:48:15.422, Speaker A: Okay, thank you. Yeah, I'm curious about what the point of confusion was, but five power 20.
00:48:15.476 - 00:48:19.166, Speaker E: Is not equal to the 24th rate.
00:48:19.348 - 00:48:25.310, Speaker A: No. So this is like an ordered pair. It's an indexing, it's not an evaluation.
00:48:25.470 - 00:48:35.460, Speaker E: Something like mapping from the original word to the code word.
00:48:38.620 - 00:49:04.080, Speaker A: Yeah. So the values on the left there are the x coordinates of your inputs and the values on the right there are the outputs. So I could say f of five to the zero is equal to 24, f of five to the twelveth is equal to 30, where f is the polynomial that results from this interpolation.
00:49:06.500 - 00:49:08.224, Speaker E: Okay, thank you very much.
00:49:08.422 - 00:49:11.600, Speaker A: Awesome questions. I'm loving the engagement.
00:49:12.260 - 00:49:19.220, Speaker C: One follow up question. I'm having you apply the same process, same generator, same finite field across all columns.
00:49:20.040 - 00:49:59.010, Speaker A: Correct? Okay, yeah, cool. Let me do a quick time check. Oh, wow. Okay, it's 955. We're scheduled for nine to ten, but I think that I'm going to go ahead and present the rest of this presentation because I have another 20 slides here and it would be worthwhile, I think, to have the video of the whole thing. So if people want to stick around, that would be great. But sort of manage your own time, I think.
00:49:59.010 - 00:50:58.480, Speaker A: So let's proceed a little bit. If we want to make this zero knowledge, all we need to kind of do is shift our evaluation a little bit. So I've listed the expanded domain here as five to the zero, five to the third, five to the 6th. But if we do a little shift and instead evaluate on five to the first, five to the fourth, five to the 7th, then when we later do our fry queries, we'll be able to maintain a zero knowledge protocol. So we've now kind of discussed the first two steps on this page. We showed what I mean by the columns. We showed some random padding added to the columns.
00:50:58.480 - 00:51:00.580, Speaker A: We did a read Solomon encoding.
00:51:02.840 - 00:51:07.108, Speaker B: The word block. Is it just the right hand side, the evaluation?
00:51:07.204 - 00:51:52.714, Speaker A: Yeah, the block refers to something that may or may not be a code word. So a column is the shorter object and then a block is the larger object. Assuming things went as planned or like, honestly, the block will be a code word. But operi, when I receive something of length 32, I don't know whether it's actually valid or not. So block is, before you know whether it's a valid code word or not, you can still call it a block. Okay, so I want to talk a little bit about the process. Basically, we start with an execution trace.
00:51:52.714 - 00:52:40.286, Speaker A: We take each of the columns, we turn it into a valid code word, and then we do some complicated math to that. And then at the end, we have to convince the verifier that the result is a valid code word. And I suggested an algorithm for this already. It looked like this. This algorithm is not the one that's actually used in practice, because doing the interpolation on these 20 points for the as. Bob, I just received this message, or I should just receive this block, I should say, I don't want to do that. Giant interpolation in particular, this step of constructing the polynomial is pretty expensive for Bob to compute, and Bob would rather not do that.
00:52:40.286 - 00:53:17.850, Speaker A: So rather than using this kind of naive algorithm for decoding a block, we actually use this thing called the fry protocol. And the fry protocol has a better complexity range. Bob has to do. Oh, actually, the thing that's about to appear on the screen is misleading. I'm going to just skip through it because the complexity that I'm. So I'm going to just move on. I put a lie on a slide.
00:53:17.850 - 00:53:54.966, Speaker A: So I want to just briefly sort of give a picture of what this fry protocol actually looks like in practice. This is going to be a very bird's eye view. The prover sends. So this is Alice sends some big block to the verifier and says, hey, this is a valid code word. And the verifier says, yeah, that's pretty big. I don't really want to run an interpolation on that. How about I just send you back a random value, and you can use that random value to make a smaller code word? And the verifier says, yeah, that's still pretty big.
00:53:54.966 - 00:54:25.150, Speaker A: I'll send you back a random value, and you can use that random value to make a smaller code word. And then eventually the verifier says, okay, yeah, that's small enough. I'll check it myself. So now the verifier, instead of having to run an interpolation on this big 20 entry code word, instead only has to think about a five entry code word. So that's the fry protocol in two minutes. Less than that, maybe 45 seconds. Questions about the Fry protocol.
00:54:34.670 - 00:54:37.820, Speaker C: What do you mean by check it themselves?
00:54:38.510 - 00:54:45.790, Speaker A: By check it, this algorithm that I showed here, more or less, I see? So this algorithm.
00:54:47.970 - 00:54:49.470, Speaker C: The agreed upon degree.
00:54:50.930 - 00:55:02.834, Speaker A: With 20 entries, this is super expensive, but if we do a couple of interactions in order to make that smaller, then it's manageable, I think. I was talking over you for a second. Did I answer your question?
00:55:03.032 - 00:55:16.470, Speaker C: Yeah, I was just clarifying that with sort of a smaller code word, you can then check if the interpolated polynomial is below the agreed upon degree.
00:55:16.890 - 00:55:57.570, Speaker A: Yeah. And there's some implementation options here in terms of what the end of this actually looks like. In the fry paper, you go all the way until the last thing is a constant polynomial. In our implementation, we go until the last thing is degree 256. And the details of, like, we actually don't make the verifier do the interpolation on the degree 256 thing. Instead, the prover does the interpolation, but on some level, at the end, the verifier says, like, okay, yeah, you've done enough of the work for me. And then the verifier does some checking it myself.
00:55:57.570 - 00:57:05.014, Speaker A: And the checking it myself part, I guess, includes not only a check that the thing at the end is valid, but also these random values provide a sort of audit trail for the interactions. So this is an interactive proof protocol succinctly put into this presentation on read Solomon codes. Other questions about Fry. I think it's, for many of you, probably the reason that read Solomon codes are on your mind at all. Okay, so we've now seen step one, step two, and step four. And I'm not going to get too much into step three, but I want to sort of just leave you with some things to think about with regards to what's going on in the middle here. And I'm going to leave you with some practice problems related to this part.
00:57:05.014 - 00:58:27.140, Speaker A: So, a question that is important to consider this is sort of, mathematicians are always asking this, if I have two things that are code words and I add them together, do I get another code word? Is an interesting question. This is a sort of math notation for this. If I take two things, a and b, that are both in the set of code words, is there some still a valid code word, a sort of extension of that, which is extremely relevant in our protocol, if I take a bunch of valid code words and I take a linear combination of them. So here, alpha is some field element, and I'm taking a linear combination of these based on this alpha, which in practice is actually a random variable choice. So the question that I have here is, if I start with a bunch of valid code words, and I take a linear combination of them, do I get another valid code word? And I'll spoil this for you. Although I would encourage you to sort of think about it for yourself, the answer to both of these questions is yes. If you start with valid code words and you do some simple arithmetic on them, you'll get out another valid code word.
00:58:27.140 - 01:00:26.294, Speaker A: But in practice, we're actually interested in a harder question, which is, what if these two blocks are not necessarily valid, but they're just close to valid? If I take two elements, a and b, that are each close to a valid code word, and I add them together, is the result still close to a valid code word? And the final thing that I'll sort of lead you with is we could think about these questions in the reverse direction as well. In other words, if I say the sum of two things is close to a valid code word, does that imply that a and b were close? And this is perhaps the most important question for our purposes in this frame. If I take some linear combination of things, and the result of that linear combination is close to a valid code word, does that imply that the stuff that I added together was actually close? So this last question here is essentially what the proximity gaps paper for Reed Solomon codes addresses, which is the kind of key to our security analysis. Is this result from Eli Benson at all about when we can make conclusions about this last question on the. So that's the end of the slideshow. We'll have a recording of this as well as the slides and those practice problems up on this. Read Solomon code reference doc.
01:00:26.294 - 01:00:54.770, Speaker A: Probably by the end of the day. We'd love to see you in the discord. Or you can ask questions on Twitter, too. I'm going to close my share and invite any last questions, and then hopefully I'll see you in a couple of weeks for Bolton's presentation, unpacking that idea of number theoretic transforms, which is our method of interpolating and evaluating polynomials.
01:00:55.590 - 01:00:56.898, Speaker E: One quick question.
01:00:57.064 - 01:00:57.780, Speaker A: Yeah.
01:00:59.590 - 01:01:28.080, Speaker E: As far as I know, there is a bunch of choices of different kinds of error correcting code and resonance code is a very classical one, but I don't know if it's the best choice or any other project or any other researchers use or try to use other coding schemes for stock or for fry or anything like that.
01:01:29.810 - 01:02:18.190, Speaker A: I'm not aware of other error correcting codes being used in modern ZK protocols. I think largely the fry paper makes possible a lot, and the fry paper relies on Reed Solomon codes. And so Reed Solomon codes have that going for them. I would point you I guess, to that Mary Wooters course on algebraic coding theory if you want to look into some of the alternatives to read Solomon codes. But my understanding is that read Solomon codes are a pretty optimal solution to this sort of fundamental trade off between redundancy and error correcting efficacy.
01:02:19.970 - 01:02:32.030, Speaker E: Okay, thank you. Actually, my core question is if anyone tried to replace resonance code on stock with other coding scheme.
01:02:33.250 - 01:02:59.128, Speaker A: Not to my knowledge. Yeah. Thanks, everybody. Any last questions? Cool. Well, I guess I will go ahead and sign off then. And hopefully I will see you in a couple of weeks. Maybe sooner.
01:02:59.128 - 01:03:00.120, Speaker A: We'll be on discord.
