00:00:08.970 - 00:00:39.660, Speaker A: I want to dive back into code. This is going to be another example where I'm showing you something rather than you following along because it's the most complex example. I'm going to show you a zero knowledge checkmate. I'm going to prove that. Oops, I clicked the link and actually, I just, just want to go to the chess example in here. We're going to prove that a chess position has a checkmate without revealing what the checkmate is. So we can do that with zero knowledge because.
00:00:39.660 - 00:01:22.998, Speaker A: Sorry, I'm trying to talk and navigate between directories at the same time and that doesn't really work. Yeah, it really doesn't work. CD chess cargo run. Okay, there we go. So we're going to be proving that there's a checkmate and without revealing what the checkmate is. And we can do that with zero knowledge proofs, because what we're going to do is we're going to load privately a board state and a move with that move being a checkmate, and we're going to commit what the initial board state was, but we're not going to commit what the move was. So going back to our design principle of letting make public and private, we made the board state public.
00:01:22.998 - 00:01:43.814, Speaker A: The initial board state, not the ending state, made the initial board state public. So you can check. So that people say, yes, this is the position we are checking for. Checking for a check made in. We're not going to make the move public because that's the thing we're trying to keep private. We don't want someone to see our checkmate. I mean, it's chess.
00:01:43.814 - 00:02:15.686, Speaker A: You looked for a while, and if you know the rules of chess, you eventually figure it out, especially because it's a mate and just one move to make the example simple. But nevertheless, here's the board. There's a checkmate for it. I ran this code as we're going to see momentarily. It really does prove that there's a checkmate here. But if you haven't found it yet, you don't necessarily know what the mating move is. Now, if you do know a chess, you probably do.
00:02:15.686 - 00:02:20.310, Speaker A: This is the scholars mate. It's actually pretty famous, but nevertheless.
00:02:22.090 - 00:02:22.418, Speaker B: There'S.
00:02:22.434 - 00:02:57.974, Speaker A: A checkmate here and we haven't shared what it is. So let's go look at how this chess proving code works. So the first thing I want to point out is I didn't write the chess code here. We're using this. Shockmate is the name of the library we're using. It's one of the common rust chess libraries. And it's not my code, so I don't have to figure out how to make chess work.
00:02:57.974 - 00:03:34.000, Speaker A: So over here, actually, I'll show you this before explaining the code too much more detail. Actually, I think I mentioned much earlier in this presentation, there's something called fens, two people's name notation, something called fens that's used to denote the state of a chess game. And this is what a fen looks like. And you can translate between it and this board. In fact, what I have highlighted and this board I'm showing at the bottom of the screen, they are the same chess position. There's actually a little more detail up here. It tells you white is moving.
00:03:34.000 - 00:03:55.142, Speaker A: That's over here. It also tells you who's allowed to castle. It tells you whether there's on passant happening. It tells you what move of the game is going on. So there's some additional chess details than just what's rendered here. And this is what we're going to be securing. And I mentioned in design principles, you should have your UI over on the host side.
00:03:55.142 - 00:04:50.582, Speaker A: We have this nice rendering is happening way down to the bottom because it's somewhere down here, right when we just use this colon question, this rest tat show the debug output. When we render the board, just using that debug output, it pretty prints it. And we're doing this over on the host side, we don't have. This entire board is not what's being committed. If we go chase this code backwards a little, the committed state, well, it's just a string, and that string is ultimately, if we walk through the entire code, the string ultimately comes from this position of the board. So that's an example of how you want to do your UI separation, that principle I was mentioning earlier. But okay, let me back up and explain everything that's happening.
00:04:50.582 - 00:05:13.790, Speaker A: Let's go look at the guest side. I just wanted to dive in a little on that point since I made it earlier. So let's look at the guest side code. What's happening on the guest side? So we read a move, we read the state of the board. We commit the initial state of the board before we made a move. And that's how the people reading our receipt know. Okay, when you have a check made, it really is starting from this position.
00:05:13.790 - 00:05:45.820, Speaker A: That's how they know a position it's starting from. And that's the only thing we're going to be writing into the receipt. Then we're going to use our chess library. We're going to take our initial state, we're going to convert it into a fen, we're going to create a setup function for the board, which is part of how the chess library works. We're going to create the actual chess position from this setup. We have to tell it that we're using the normal rules of chess. That's part of how the library works.
00:05:45.820 - 00:06:34.090, Speaker A: Similarly, the move, the move is also a string. It uses san, which is another chess thing called, stands for simplified algebraic notation, I believe simple algebraic notation, something like that. And the library comes with the ability to parse this. So we parse the move, and then we say from this chess position, we play the move and produce a new chess position, and we assert that the position is a checkmate. And by having this assertion at the end, if we don't have a checkmate, we're going to panic here. And so the fact that we don't panic means that we really do have a checkmate. And over on the host side, we essentially just need to get the relevant data to the guest and then pretty print the results.
00:06:34.090 - 00:06:59.694, Speaker A: So we have a command line. This example comes with a command line interface. Oh, I scrolled up and I want to show you something I mentioned early on. I mentioned that standard support is a little bit experimental. There's actually a bug in 00:11 to have to do with alignment issues on strings. I'm pretty sure it's fixed in the current version, although I haven't updated this example to the current version. I guess it could still be broken.
00:06:59.694 - 00:07:09.122, Speaker A: I do think it's fixed, though. There's a workaround. Just wanted to mention. Yeah, it really is a bit experimental. You will occasionally hit bugs. Come talk to us. We're on discord, we're on GitHub.
00:07:09.122 - 00:07:52.446, Speaker A: Talk to us if you had issues, open issues, if you had issues. Okay, back to my explanation. So, right, just set up a command line interface and pretty print things. So here we have a command line interface. We put together a nice inputs object so we don't have to pass multiple separate things. We add our inputs, we prove the result, we interpret what we committed as a chessboard. Actually, I have this assert that says that what I sent to the guest is the same thing the guest committed, which we proved in the guest that if we look at the guest side code, the inputs is the thing we committed.
00:07:52.446 - 00:08:16.742, Speaker A: So this is not necessary for security. This is just sort of my standard. Oh, I wrote two things that are the same. I should add an assertion because it's a good coding practice, but there's no security here asserts on the host side don't provide security. I wanted to say that. And then we started from a string. So again, we have to render this into an entire chess position using the library.
00:08:16.742 - 00:08:37.780, Speaker A: We come back and we have the board, and it proves it's the checkmate. And if it wasn't a checkmate, if we pass in some different move, which I could do from the command line, it will be mad at me. Yeah, assertion failed. It's not a checkmate. So we really did prove it's a checkmate. Questions.
00:08:40.150 - 00:09:53.462, Speaker B: Just by the way, I'd like to really point out that one of the big values of using risk zero as your proof system is chess is complicated, verifying the correctness of a move and the whole state of the board and all of these things, and we can just import a library and do that. And I think that sort of the big value is that we are leveraging the entire existing ecosystem of rust inside of zero knowledge proofs. And so I think that as an example of the person who is proving the proof of reserves on near actually just imports a bunch of near crates and uses that to walk over the near's merklized data structure. Right. Re implementing code for complicated things like that is a large task. And so if you're using a custom language or a serial knowledge proof system that forces you to start from zero for everything, you just can't develop nearly as fast. So I think that this is a good sort of medium complexity example of how we can really leverage the state of libraries.
00:09:53.606 - 00:10:43.740, Speaker A: This is more complex than previous examples, but what we're doing with RISC five isn't more complex than what we did in JSON. I mean, I guess we have two inputs and two outputs instead of one of the inputs, but nevertheless, actually it was two in JSON as well. This isn't more complicated than the JSON on the risk five side, it's more complicated on the chess side, and we're just using a library for that. Questions. Have we addressed all the questions at this point? You're also welcome to come talk to us in the networking stuff afterwards.
00:10:44.640 - 00:11:20.280, Speaker B: So there was one other question of whether the prover runs in WASm, I believe. And the answer is, I don't think it currently does. Nothing technically would prevent that. I think currently we have some gpu acceleration support and a number of other things that probably will cause it to not compile in WASM. But if you turned that off and did it purely on cpu, it should be possible to build a proverb to run in WASM, which I think has actually a lot of use cases like on the web case. If I wanted my web browser to generate a proof that would be reasonable and feasible for small sizes of proofs. So we probably should actually add WASM support.
00:11:20.280 - 00:11:33.820, Speaker B: But we don't currently have it on the proverb. We do have it on the verifier in release candidate three, or whatever it is now. So we're very close to 10. We're doing the release candidates right now. We're at zero point eleven.
00:11:43.200 - 00:11:46.250, Speaker A: Thank you, everyone for coming. We really appreciate you being here.
