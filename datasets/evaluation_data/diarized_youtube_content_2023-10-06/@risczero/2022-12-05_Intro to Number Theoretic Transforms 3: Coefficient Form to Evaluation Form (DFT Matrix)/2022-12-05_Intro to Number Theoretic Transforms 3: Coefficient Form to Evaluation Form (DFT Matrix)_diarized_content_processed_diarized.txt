00:00:00.650 - 00:00:54.110, Speaker A: Okay, maybe I should move on and talk about how we can go from coefficient form to evaluation form. So, starting with some polynomial, we would like to evaluate it at four different points. And perhaps we can start with a nice concrete example using the finite field f five. So this is the finite field that has five elements. You can think of it basically as the clock arithmetic or the modular arithmetic that Paul presented a few weeks ago. Whenever you get a number, you take the remainder, dividing by five, and that gets you your new number. So let's choose some random, basically coefficients here.
00:00:54.110 - 00:01:29.660, Speaker A: I've sort of chosen them arbitrarily. We have the polynomial three x cubed plus four x squared plus four x plus one. And let's say that we want to evaluate it at these four points .123 and four. So one way we could do this, as I was sort of alluding to, was brute force, right? We can evaluate p one by just sort of multiplying things out, right? We have one cubed, one squared, one. All of those are equal to one. And so if we add all these up, we get twelve, which is equal to two mod five.
00:01:29.660 - 00:01:53.706, Speaker A: And so that would tell us b zero directly. And then we could do the same thing for evaluating at two. We can do two cubed, two squared, two. We can multiply all of these numbers together. And you can use a calculator to check my math if you want. This comes out to 49, which is equal to four mod five. And we can do the same thing with three.
00:01:53.706 - 00:02:52.258, Speaker A: And it comes out to zero mod five. And we can do the same thing with four, and it comes out to three mod five. But the sort of vaguely disappointing thing about doing things this way is that it takes actually a lot more time than you would want to. And the reason why this is sort of a very slow algorithm for computing this essentially has to do with the fact that we're doing a lot of different multiplication operations here, right? So for each and every one of these evaluation points, there are four different numbers to raise to a power, four different multiplications to do. And there's four different evaluation points. We're doing at least 16 multiplications right there. It's basically the square of the number of coefficients that we started with.
00:02:52.258 - 00:04:03.580, Speaker A: And that's bad because it might be possible for this polynomial, because there's only four elements here. But for the sort of polynomials that we're dealing with, when we run a stark protocol, those can be very long, very high degree polynomials indeed. They can be almost as long as, almost as long as sort of the execution trace of whatever program you're trying to verify. So doing this sort of n squared, quadratic, all of this work, this is not the fastest way of doing things. And we sort of want to look for a better way. But before we look for a better way, maybe it's helpful to just sort of realize the structure of the problem as it already exists. So let me first point out that this process of multiplication can actually be viewed as a matrix equation or an equation in linear algebra, if you're familiar with that.
00:04:03.580 - 00:04:57.020, Speaker A: So what you can see here is a matrix multiplied by a vector, and that gives us another vector. And this matrix here is meant to represent the coefficients that we see in this set of four equations here. So we have ones all down the side here. We have 1234, we have one squared, two squared, three squared and four squared. And we have one cubed, two cubed, three cubed, and four cubed. And so we basically make a four x four matrix out of those numbers. And then if we multiply by this vector here, which represents the coefficients, right, these are the four coefficients of the polynomial in coefficient form.
00:04:57.020 - 00:05:39.190, Speaker A: Then doing this sort of matrix vector multiplication that is giving us exactly what we want, it's giving us the vector of evaluations. And you might notice that this matrix here, it definitely looks very structured, right? It's what you might sort of call mathematically structured. It's not just a bunch of random elements. Every single element of this column is a one. In this column, you're going 1234, you're sort of counting up. And in this column, you're going up by squares. And so there's definitely a pattern.
00:05:39.190 - 00:06:45.360, Speaker A: Every single element of this matrix follows a pattern. So let's see if we can sort of isolate what that pattern is. One thing that we can do to make the matrix even sort of more structured is to rewrite things in terms of powers of two. This is something that we sort of saw last week, two weeks ago, I should say, in Paul's presentation about Reed Solomon codes. That was another situation. And because Solomon codes are essentially polynomials, that was another situation where it turned out to be mathematically useful to think of things instead of just as numbers in this finite field, we can think of them as powers of two. And it turns out that all four of these numbers, 1234, can be rewritten as a power of two.
00:06:45.360 - 00:07:36.154, Speaker A: So maybe the first thing we can do is we can check, how can we rewrite four as a power of two? Does anyone have a sort of conjecture about what power we can raise two to get four? This is maybe too easy of a question. Yeah, two, I think I heard two. And that's right. So we can replace four by two to the second power, and that gives us basically an equivalent way of writing four. And now we can rewrite three actually as a power of two as well. This is maybe a bit harder. And I see a question in chat from Jacob.
00:07:36.154 - 00:08:23.520, Speaker A: Was two chosen to be a generator of the field or for some other reason? And the answer is yes, it was chosen to be a generator of the field. If you sort of recall from last week, Paul, there was a bit of discussion about generators. But the nice thing about two is that you can raise it to different powers and you can get every non zero element of the field. And I see an answer in chat for the question of three, and it says that, yes, two to the third power is actually three. And that's something you can sort of evaluate in your head. Two to the third power is eight, and eight mod five is equal to three. So we can rewrite that, and we can actually rewrite the twos and ones as powers of two as well.
00:08:23.520 - 00:09:33.060, Speaker A: So I'll just do that there. And now that we have all of this, we can apply a rule to sort of simplify things. If you have two to the power three to the power three, that's basically that taking an exponent twice is sort of the same thing as multiplying those two exponents. Right. Two to the three to the three is actually going to be the same as two to the three times three. And so if I do that rewriting, I get this matrix, which now has a very sort of, it's a little bit more verbose than what we had before, but it's also a little bit more clear what the sort of structure is here. So now, not only is it the case that we have two to the zero down the column, but we also see that we have two to the zero along the top here, and we have one, two, three here, and we have two, four, six here in the bottom row, and we have three, six, nine in this sort of middle row, row here.
00:09:33.060 - 00:10:33.590, Speaker A: Now, we notice that the exponents here are very close to being a multiplication table. And this is something I think we noticed in the talk two weeks ago as well. And so if only it were the case that these two rows here were switched around, then it would actually be a perfect multiplication table. So I'm going to make one more change, which is to switch those rows around so that we can have that sort of perfectly line up. And that's sort of fine. All I have to do in this sort of matrix multiplication here is I switch these last two rows, I switch around the last two elements of this vector, and I switch around the last two elements of this vector and everything sort of works out. So what we get here is a matrix which is a sort of very special matrix.
00:10:33.590 - 00:11:39.930, Speaker A: It's known as the DfT matrix or adft matrix. You could think about a DfT matrix for a different generator, right? For example, three is also a number which is a generator of this field. And so you could think about three to the zero, three to the zero, three to the one, three to the four. But all that, we see that to solve this sort of coefficient to evaluation problem, essentially all that we're doing is we have to find a very quick way of multiplying this matrix to this vector. And while this would sort of, in general, it would be pretty hard, because this is a pretty big matrix, it's an n squared sized matrix. The fact that it's so structured, right, basically every element of this matrix is two to this sort of multiplication table element we conjecture. And we'll see that perhaps there's actually a faster way of doing this transformation.
00:11:39.930 - 00:11:48.480, Speaker A: It. Before I move on to that, maybe I'll pause for questions again.
00:11:55.820 - 00:12:21.570, Speaker B: I have a quick comment about the size of the matrix as it relates to our system. So we see this example of having four columns, but in reality, in risk zero system, the execution traces are powers of two. So to just give people in the audience who might not be familiar an idea, this could be very large.
00:12:22.260 - 00:13:11.130, Speaker A: Yeah, that's definitely an important thing to note, is that four here is the critical number, but instead of four, it would really be the number of cycles, approximately, of whatever programming program you wanted to execute. And it's also worth noting that instead of f five, right, the field of numbers modulo five, it would actually be a much bigger field. In fact, much, much bigger, even bigger than the number of cycles, because it's important that you don't randomly get two field elements turning out to be the same when they shouldn't be the same. That's sort of a cryptographically important thing. So.
