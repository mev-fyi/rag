00:00:00.410 - 00:00:45.574, Speaker A: We're going to look at the paper more or less like, sentence by sentence, starting from the beginning. And I'm going to try to unpack the context and references as much as I can as we go. So, the first sentence says, this document is an informal summary on the fry low degree test and deep algebraic linking. And it lists some references. And I just want to talk a little bit at the beginning about what are these references? So, the three references that it mentions here are the fry paper, the deep fry paper, and the proximity gaps paper. And I'll also throw into the list for discussion. The stark paper, and I think the academic literature of our protocol is pretty completely described.
00:00:45.574 - 00:01:20.786, Speaker A: Well, that's not true. There's some plonk and pluckup stuff that's separate, I guess. But within the stark and fry part, like, these four papers are the bulk of it. So, let me unpack a little bit of how these four papers are connected and then continue. So, the stark paper is really, like, that's what we're doing. We have a stark. It's a scalable, transparent argument of knowledge, is what the seal on our receipt is very literally a stark.
00:01:20.786 - 00:01:51.614, Speaker A: So, a stark is a way of proving computational integrity. Meaning a stark is a way of convincing a third party that the computation you ran is actually the computation that you said you ran. The first part is an algebraic linking protocol. And the second part is a. Read Solomon proximity testing protocol. And I'm just going to leave those as black boxes. I'm not going to talk about what an algebraic linking protocol is at all.
00:01:51.614 - 00:02:42.720, Speaker A: Today, we'll talk a little bit about the idea of a Reed Solomon proximity testing protocol. Because that's what fry really is. But for the purposes of this slide, I just want to contextualize that a stark has two parts, algebraic linking. And then Reed Solomon proximity testing. And specifically the algebraic linking part turns our assertion of computational integrity into a Reed Solomon assertion. And then the second part proves that Reed Solomon assertion. So, a lot of black boxes here, but hopefully, the sort of breakdown of a stark consists of two parts, algebraic linking and resolving approximity testing feels relatively okay.
00:02:42.720 - 00:03:00.130, Speaker A: Each of those has two versions. There's a regular version and a deep version. We have our algebraic linking without deep. And we have our algebraic linking with deep. We could do either of those. And we have a. Read solomon without deep.
00:03:00.130 - 00:03:32.030, Speaker A: That's fry. Or read Solomon proximity testing protocol with deep. That's deep fry. So, this is our first couple minutes of the presentation. A lot of technical words, questions at this point. Of course, there's the question of what is algebraic linking and what is deep? But I'm going to assume, because I haven't heard any voices or hands, that I can continue. I had a little note here about, like, I could be a little bit more technical.
00:03:32.030 - 00:04:09.370, Speaker A: I'm not going to talk about algebraic intermediate representation too much, but there's a little note. So I mentioned that there's these two different versions. There's the without deep version, and the with deep version. Deep stands for degree extension for the elimination of pretenders. When starks were originally created, there was no deep. Yet it was Ali and Fry. And then a year or two later, this deep technique was invented, created.
00:04:09.370 - 00:04:57.290, Speaker A: And at that point, people were running starks using deep, Ali, and deep fry. And then a little bit later, the proximity gaps paper showed that, in fact, deep is not actually an improvement over the original fry. So where we are today is that when we run starks, we use the deep version of the algebraic linking protocol, but we don't bother with deep on the fry protocol. So that's the kind of context of the timeline of how starks have evolved over time. There was the original, then the deep improvement, and then the realization that the deep improvement only actually applies to the first part of the protocol.
00:04:58.190 - 00:04:59.260, Speaker B: Quick question.
00:04:59.970 - 00:05:00.814, Speaker A: Yeah.
00:05:01.012 - 00:05:13.860, Speaker B: When you say fry is actually better than deep fry, does that relate to the execution time or execution time relative to security?
00:05:14.470 - 00:05:52.400, Speaker A: Great question. So, deep is computationally more intense than not deep. So there's a little bit of extra computational burden in order to do deep. And the thought was that by doing that extra computation, you get better security. And the realization in the proximity gaps paper was that the original fry protocol actually had better security than originally proven. And the improved fry security achieves the deep fry security without the need for the extra computation of the deep parts. Does that answer your question?
00:05:52.850 - 00:05:53.820, Speaker B: Yup. Great. Thanks.
