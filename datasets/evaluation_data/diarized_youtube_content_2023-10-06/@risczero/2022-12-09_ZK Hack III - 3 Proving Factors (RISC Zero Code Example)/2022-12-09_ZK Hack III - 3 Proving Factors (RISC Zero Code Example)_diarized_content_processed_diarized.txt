00:00:09.210 - 00:00:47.530, Speaker A: So in this example, we're going to be looking at proving the factorization of a number. So imagine you're someone and you have a number that you know is composite and you know how to factor it, and you want other people to believe you that this is composite number, but you don't want other people to know how to factor this number. So this example will let you prove that to them. I'll mention at the bottom there's source, if you want to click the fuller source, but I'm going to explain all the core components to this. So here we're looking at, at the moment, the guest side code. We're looking at the code over here. This is what's going to be proven.
00:00:47.530 - 00:01:27.046, Speaker A: And in this guest side code, what are we doing? Well, we are going to, I guess down here is the core thing happening. It's multiplying. So the algorithm we're going to be using is we're going to multiply two numbers and write their product to the receipt. And so if we think about what we're trying to accomplish, proving how to factor a number, one way you can prove that is to say, hey, I computed this number that I want to show as composite. The way I computed it is by a product of two numbers. And if it's a product of two numbers, it has to be a composite number. So that's what we're going to do here.
00:01:27.046 - 00:02:06.046, Speaker A: We're going to prove that it's a product of two numbers. And since we don't want to share those numbers with anyone verifying this, we're going to read them as private data from the host. So we don't hard code the numbers into the code because the code is in the receipt. Instead, we use this env functionality from the racim guest crate that lets us privately load the number from the host. We do that for both numbers. We're going to check that neither of them is one. Because if one of them, you could say, oh, yes, 47 is prime, is composite.
00:02:06.046 - 00:02:36.000, Speaker A: It's one times 47, like, no, that's not composite. You need nontrivial factors for it to count as composite. So we confirm that neither of them is one. So we're not doing anything jerky here. And then we compute the product of them. So we use this checked mull, which is a rust function that returns an error when you overflow or that sort of error condition. Overflow is what applies in this case.
00:02:36.000 - 00:03:13.414, Speaker A: And so we compute that, we make sure there's no overflow that gives us the product and commit means writing the product to the receipt. So by the end of this process, what we have is a receipt that contains only the composite number. And we have this source code that we can prove ran. But this contains nothing about what the factors were. That's the zero knowledge part. And we know that we had to successfully run to get this product, because if we tried to do something tricky, this set things equal to one. We used one as one of the factors.
00:03:13.414 - 00:03:30.398, Speaker A: Or if we overflowed in our multiplication, it would have panicked and we can't have gotten to the commit. Let's look at what that looks like on the host side. Right. That's the thing we are proving. That shows how it gets proven. So how are we going to do this on the host side? Well, we privately pick two numbers. The host no.
00:03:30.398 - 00:03:59.222, Speaker A: Has the private data. This doesn't show up in the proof because it's the host side. So we can privately pick our two numbers. We're going to multiply them using the code we just saw. So to do that, we load the code we just saw and initialize approver based off of it. That's what this code here does. The risk zero has a build script that builds code to a specific path and makes constants saying where that is.
00:03:59.222 - 00:04:19.822, Speaker A: So here we're loading the code from where we built it. Then we're setting up approver. This multiply id is what we call the method id. It's the hash. The thing I put in scare codes earlier is the hash of the code that's going to go in the receipt. We set up approver based around this code, both the source and the hash. We send it the two private numbers.
00:04:19.822 - 00:05:01.926, Speaker A: These add input functions, send the two private factors. And there's both this. Adding the input data and also this to VEc is serialization procedure. So because we have a RISC five architecture is fairly minimal and 32 bit based, we send it data just as 32 bit words. So we have to serialize our data into appropriate 32 bit words. So that's what we have this helper function to serialize from a nicer type into the words that we need to be able to read it on the circuit. And then we add that input.
00:05:01.926 - 00:05:23.246, Speaker A: We do that for both numbers. And then here's where we run that guess code we just saw. We do that multiplication. We get a composite number out. We get a receipt that contains the journal, its composite number, and a seal saying this was the result. And this over here was the source code we used to get it. When you're proving, you don't actually have to verify the receipt.
00:05:23.246 - 00:06:19.634, Speaker A: You know, you constructed it faithfully, but we're doing it just to show that it verifies correctly and to demonstrate that, look, here's how you verify. So here's how you verify. You specify the hash that you're expecting from the source code, and you just say, hey, verify this receipt. And if the receipt is invalid, if someone's trying to lie to you and making a fake receipt, this will return an error instead of executing correctly. Now we're imagining we're putting on our verifier hat in this part of the code. In practice, you'd probably be transmitting this in some way in production examples, but for your basic use case where you're just doing development, trying to figure out if your code works, we're just going to do the verifier in the same code as those and print it to the screen. So here we're going to read the journal, right? The journal contains that composite number we've computed.
00:06:19.634 - 00:06:58.722, Speaker A: So we read the journal, we deserialize from our U 32 words into the type we specified. So we're multiplying U 64s. If you go look back over here, you were multiplying U 64s in there as well. So we're expecting a U 64, and then we can print it. We can print, hey, I've read from the receipt that these are the factors, and therefore we have a proof that these factors are known. Sorry, I have in the receipt that this is a composite number whose factors I know, and this is the receipt to prove it. And so that's how proving works.
00:06:58.722 - 00:07:22.758, Speaker A: And I'm going to show you how this code works as well. I have my previous example up, and I have never run this code, so it's going to take a moment to compile. So while it's doing that, questions at this stage, if someone could read that to me, that would be wonderful.
00:07:22.854 - 00:07:35.390, Speaker B: Perfect. Yes. So there's four questions. One's going back about eight minutes. So one is, is the hash of the program the hash of source code, or the hash of the RISC five bytecode?
00:07:35.810 - 00:07:42.046, Speaker A: It is the hash of the bytecode, specifically the elf file we use. Jeremy, do you want to add?
00:07:42.068 - 00:08:06.520, Speaker C: Yeah, it's not like a shot 256 of the elf file. It's kind of an unusual, complicated hash for specific reasons for use in the ZKP. But yes, it's basically the Elf file, which means that if you want to verify it relative to source code, you need a way to reproducibly build your source code. To the Elf so that you can verify that.
00:08:08.570 - 00:08:15.910, Speaker B: Cool. Another question is, is the best way to abort a computation if some assertion is invalid? To panic?
00:08:17.130 - 00:09:07.638, Speaker A: Yeah, excuse me, I'm going to talk about this a little more later. But also yes, because, well, for one thing, it's lightweight and the circuit is a small system, but also because anytime you're running the guest, there has to be a host as well, and you can do your nice hit error handling over on the host side. Let's see, where's my host site code? Yeah, this is my host site code. Right. So in this line right here, prover run unwrap. So here, this unwrap means there isn't nice error handling. But if I had changed this to some sort of expect, then when I had panicked, let's say we ran into this case and I panicked when I panicked my error handling over here, this would return an error value because it panicked.
00:09:07.638 - 00:09:16.942, Speaker A: And then my nice error handling over here could do whatever and not wanted, and could present to the host a well formatted error of whatever sort.
00:09:16.996 - 00:09:21.418, Speaker C: And of course the VM panicking doesn't panic the host.
00:09:21.594 - 00:09:23.280, Speaker A: Yes, good point.
00:09:24.930 - 00:09:36.038, Speaker B: All right, another question is, could you compile a rust compiler to RISC five and run it on risk zero to prove some bytecode corresponds to a given source code?
00:09:36.204 - 00:10:21.506, Speaker C: So in theory the answer is yes. In practice, we need to add another feature for long running code, because the rust compiler is quite a huge program. So currently it doesn't fit in the sort of small environment that our prover runs in. However, we are currently working actively on support for what we call continuations, where you can generate a very large proof by generating a bunch of smaller proofs and using recursion to roll up the results. And actually at some point I think that one of the things we would like to be able to do is in fact offer a service of verifiable compilation of code. So in theory, absolutely in practice, right now, if you try it, you will.
00:10:21.528 - 00:10:22.770, Speaker A: Run out of cycles.
00:10:24.790 - 00:10:32.470, Speaker B: And the last question on this batch rejoined a bit late. Can you quickly summarize the difference between the journal and receipt to get up to speed?
00:10:32.810 - 00:10:47.030, Speaker A: Right, so the journal is a portion of the receipt. So the receipt has two components, the journal and the seal. The journal is where you write the public outputs, and the seal is the cryptographic information saying what code was run and proving that the receipt is valid.
00:10:49.450 - 00:10:50.200, Speaker B: Cool.
00:10:50.690 - 00:10:53.420, Speaker A: Okay, thank you everyone. Great questions.
