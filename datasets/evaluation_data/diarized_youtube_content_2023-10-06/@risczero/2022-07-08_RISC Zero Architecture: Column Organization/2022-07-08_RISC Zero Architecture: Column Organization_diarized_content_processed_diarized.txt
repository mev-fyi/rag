00:00:00.250 - 00:01:07.678, Speaker A: One of the things that's notable is that in your stark, there's typically a set of columns which represent sort of like a hardware register, if you will, over time, every given cycle, that each of those columns has a value. We actually divide the set of columns that we use into three distinct groups of columns, and each, each group of columns actually is put into a separate Merkel tree. So the first set of columns are actually what we call the code columns, and those columns represent public data that is known to both the prover and the verifier. And this is actually where we encode both the control sort of flags that say, okay, well, this is the initialization cycle. These are the load cycles. These are the sort of three cycle structure of the execution, as well as where we put the actual elf data that's to be loaded. And so by doing that, we're basically able to put all of our sort of control logic into that set of columns.
00:01:07.678 - 00:01:43.306, Speaker A: And that's part of the Merkel tree that is checked in the proof system, similar to the main data Merkel tree, but because they have different Merkel rules, as a result, we end up having to prove two Merkel paths instead of one when we're doing the verification. But what that allows us is it allows us to fit a huge amount of constant data in and make the proof system be able to make use of all of that, which is important. So that otherwise we'd have to say, for example, prove that our code hashes to some value, which would be much more expensive. Right. So that's kind of a good trick.
00:01:43.338 - 00:01:45.994, Speaker B: There maybe a related question on the chat.
00:01:46.042 - 00:01:46.302, Speaker A: Yes.
00:01:46.356 - 00:01:49.450, Speaker B: Do you also implement control and status registers?
00:01:49.610 - 00:02:44.734, Speaker A: So interestingly, the RISC five. Oh, the control status registers within the risk five architecture. Yeah. So currently we don't, although we are going to add support for the, because we only operate in user mode effectively, and the normal mechanisms by which one calls into the system modes, we actually just implement, as that's what induces the termination of the program. That's like effectively the halt instruction in our next version of the circuit. We do intend to support the CSR registers, including the standard sort of timer registers, as well as we don't intend to support the full system mode, but we also do intend to use the normal system call mechanism to do our interactions with the external world. Currently we use this memory mapping trick to do our external world follow up.
00:02:44.772 - 00:02:47.902, Speaker B: Question on this. Is the program by default a public input?
00:02:48.046 - 00:03:35.746, Speaker A: Yes. So the program is by default a public input. Now, technically the only thing you need to do the verification is the Merkel root of the control set of columns. So in theory, one could, for example, pad your program with a bunch of extra random bytes and then generate the appropriate Merkel route. But certainly the prover needs to know the program, and the verifier needs to know the hash of the program's sort of control traces in order to do verification. So you could technically verify a program that you don't know what the program is. Typically, none of our use cases do.
00:03:35.746 - 00:03:36.850, Speaker A: We make use of that back.
00:03:36.920 - 00:04:04.860, Speaker C: All right, although I will add just briefly that you can imagine use cases where some, say governmental or otherwise trusted body audits a bit of code and attests to some bit of code having certain properties, and says this code that has this hash has these properties. And then people could run it, prove that the results come from this bit of code without necessarily ever revealing the code. But that's like, I don't know, future use case, let's say.
00:04:06.430 - 00:04:45.490, Speaker A: So then the next set of sort of columns represent the sort of standard columns you'd have in any sort of a stark. And they hold the state of the risk five during execution. And they also hold the information necessary to do the memory transactions, as well as the memory verification, which I'll get to in a bit. And then we basically have the effectively accumulation set of columns, which basically hold products for the Planck permutation verification mechanism. So we use basically a plank style way to prove a permutation, which is used as part of the memory consistency evaluation.
