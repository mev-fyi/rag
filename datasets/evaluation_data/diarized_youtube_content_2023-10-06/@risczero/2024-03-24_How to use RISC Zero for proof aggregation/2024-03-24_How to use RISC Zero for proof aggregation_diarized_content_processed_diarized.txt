00:00:01.480 - 00:01:16.640, Speaker A: Okay, so how do you go about actually aggregating proofs? The the process is to run a verifier for, say, two proofs inside another ZK circuit, and that will spit out a single proof that attests to both of the two original proofs. So you can use this method of recursive verification in order to compress two snarks into one snark. And that's sort of the core of the magic that makes ZK so important to the world of computation. So all you have to do is verify two proofs inside a snark circuit, and you'll get out a new proof. And that's the sort of technical core of proof aggregation. If you want to do this with RiSC Zero, all you need to do is run the verify command inside the ZKVM. And our proof composition technology sort of takes care of everything behind the scenes.
00:01:16.640 - 00:02:37.634, Speaker A: So if you want to understand how composition works, you can dive into the study club on composition. But as a developer, if you have a bunch of proofs that you want to aggregate, all you need to do is run verify inside the ZKVM. Now, this assumes that they are risk zero proofs that you're trying to aggregate. If you're trying to aggregate proofs from proof systems, other than risk zero, there's going to be one additional step, which is that you need to convert them from the other proof system into a RISC zero proof, and then you'll be able to aggregate them. So in order to do that second step, or I guess the first step, the other step, you're going to need a verifier that will run inside the ZKVM that will verify proofs from your other proof system. So, as an example here, if you'd like to aggregate ZkSync proofs and Polygon proofs on RISC Zero, you're going to need a polygon verifier that will run inside the ZKVM and a ZK sync verifier that will run inside the ZKVM, and then you'll be good to go. So that's a little TLDR on how to get going with proof aggregation.
00:02:37.634 - 00:02:38.694, Speaker A: Happy building.
