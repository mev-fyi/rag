00:00:08.890 - 00:00:45.980, Speaker A: So I mentioned at the beginning we're focused on the practicalities of the code and this section. You don't actually need to know this to know how to write code for the risk zero ZKVM. But I think it's cool. I think probably many of you want to understand at least a bit how it works under the hood, what's going on cryptographically. Fundamentally, if I'd spend the entire 2 hours trying to explain it, that wouldn't be enough time. So I'm also going to be giving some links to educational material, other resources at the end, because there's a lot. But I do want to give at least a bit of an overview as to what's happening.
00:00:45.980 - 00:01:27.842, Speaker A: Okay, let's talk about when the host is emulating the guest and the guest is executing code. What is happening when that happens? In addition to just like running the VM, what's the stuff that's also making the proof work and making the receipt work as the VM? I think I've actually talked about most of the slide already. We chose risk five. It's open, it's lightweight, compiles from rust. Yeah, I've talked about this already. Sorry for the extraneous slide. But what's happening cryptographically while you're running the VM? Because it's not just a virtual machine.
00:01:27.842 - 00:01:53.760, Speaker A: The prover is keeping track of the state of the VM at all times in something that's called an execution trace. And the execution trace is this giant table where each row is a clock cycle. So when I say it keeps track at all times, every single cycle, it knows. Well, what does it know? It knows what's in the columns. And every column is a register. Well, every register is a column. At least.
00:01:53.760 - 00:02:29.978, Speaker A: It's actually more than that. There's some additional columns that do things like handle memory. But if we're just to simplify, we're thinking every row is a clock cycle, every column is a register. So you know the exact state of this RISC five circuit at every single clock cycle for program execution. And I want to quickly say, if all we cared about was proving correct execution, we would be done right. Like, we've simulated the entire computer or the entire circuit. At this point, we know exactly its state at all times.
00:02:29.978 - 00:02:43.860, Speaker A: And we can just check. Yes, the beginning is what it should be. It matched the code. Oh, yes, the end is what it should be. It put the right results in the right places. Yes, every step was a legal risk five transition. We're good.
00:02:43.860 - 00:03:10.374, Speaker A: This is not a good idea, though. The verifier performance is terrible. Like, you're running a simulator, not some sort of more condensed thing. And it's the exact opposite of zero knowledge. You're running a simulator, you know exactly what's happening at every single time step. This is not achieving the other goals of our ZKVM. Right.
00:03:10.374 - 00:03:42.094, Speaker A: I just talked about why verifying the trace would be enough. Like this was sufficient. Because we know the initial state, it matches, we know the results, they match, and there's computational integrity. Every step is what an actual physical risk five circuit would have done at that step. And we encode this using algebra. Those conditions I just mentioned in these three bullets, those become algebraic constraints. And that the binary zeros and one encoding, we turn those into field elements.
00:03:42.094 - 00:04:10.010, Speaker A: And that encoded trace is something called a witness to the algebraic constraints, meaning it is something. The algebraic encoding of the execution trace satisfies every single one of the algebraic constraints. And so it witnesses this. Right here is a solution to all the constraints. It has the right initial state, it has the right results, it has computational integrity. All these constraints are satisfied. That's called being a witness.
00:04:10.010 - 00:04:36.854, Speaker A: So, okay, we've encoded things into algebra, so we can start doing cryptographic math on it. And is that what goes in the seal? No. So what's going to go in the seal? Actually, let me remind myself what my future slide is. Right? So the seal needs to have the zero knowledge proof, and we haven't solved the. This is a simulation. It's zero knowledge, and it's the exact opposite of zero knowledge. None of that has happened yet.
00:04:36.854 - 00:05:28.254, Speaker A: We've just encoded it as algebra. What is going to go into the seal is a ZK stark, a scalable, transparent argument of knowledge. That's what stark stands for. And how is this related to that execution trace that I just mentioned? Well, so it's related in the cryptography that prover and verify are going to be doing. We are going to prove and verify the execution trace satisfies. Appropriate constraints, like I sort of described loosely, could just be done by looking at the algebra. But instead of proving them by having to look at the entire algebraic encoding of the constraints, we are going to use fry and deepali with a shatu implementation of the fiat shamir heuristics.
00:05:28.254 - 00:06:07.300, Speaker A: So fry and deepali without fiat Shamir are an interactive oracle proof where what happens is you spot check the execution trace instead of saying, hey, I'm going to check that every single constraint is met at every single place. The verifier, the person who wants to know that this is correct is going to randomly spot check various places for the constraints to hold. And if they hold in a bunch of places that was chosen randomly without the prover having input, that's good evidence that the whole thing is correct.
00:06:08.790 - 00:06:38.380, Speaker B: More specifically, I think one thing that's important to note is that before that spot checking is done, the thing is encoded into an RS code, which is an error correcting code such that if there's even a single error, then about three, four of the entire thing will be an error. And so what you're doing is you're effectively amplifying the error and then spot checking. And so you can very quickly spot check a small number of places and detect an error anywhere. And that's sort of part of the underlying magic. I don't want to go into too much.
00:06:39.870 - 00:07:09.938, Speaker A: Yeah, yeah, that's good. That honestly should have been in this slide. So thank you for adding that, Jeremy. Yes. So that read Solomon code word that read Solomon encoding that Jeremy mentioned, that makes any error be like, most of it's an have didn't make it into my slides at all, but we actually have a video about how that works, sort of the basics of read Solomon encoding on our YouTube channel, which is linked at the end of these slides. Right. So you're going to be spot checking.
00:07:09.938 - 00:08:20.330, Speaker A: And because you have this error amplification, if you do even just one spot check, you probably find the error. And if you do a ton of spot checks, you become cryptographically likely to find the error. And then when you add the fiat Shamir heuristic to this process, that means that uses everything you've already done, what the execution trace was, everything you've already done to generate, to generate the random points you are checking. And so the prover doesn't have control over that. It uses, actually uses Sha two to figure out where those random values are, uses cryptographically secure pseudo random generation based on that shotu algorithm. And so that makes it non interactive. You don't have to, when I hand you a receipt, the receipt isn't about the verifier coming back and talking to me and being like, hey, is this point correct? Is this point correct? Is this point correct? It's a non interactive process because of the Fiat Shamir heuristic.
00:08:20.330 - 00:08:59.270, Speaker A: That was a very high level summary of what's going on. There's a lot of rather thorough cryptography, so if you're curious, we very much invite you to learn more. Our website has a section explaining the technology we use. We have an ongoing resero study club series, the playlist on our YouTube channel. Also, this is a pretty long URL. The slides have it linked, but also we will show you. I'll link the YouTube channel at the end, and you can navigate to our playlist from there.
00:08:59.270 - 00:09:27.474, Speaker A: So that's an ongoing series. So we do have recordings of the previous Risero study club meetings, but also these are open, public, online meetings. You are welcome to attend and see them live as we put out more study club material. And while we have some ideas for the upcoming study clubs, if there's parts of our system you want to understand better, we absolutely are taking ideas for things we should cover in the study club, so feel free to make suggestions to us.
00:09:27.672 - 00:10:20.180, Speaker B: Now, one thing I would like to mention really quickly is that fundamentally, most of this sort of cryptographic process that we're doing for the zero knowledge proofs is not something that we have invented. This is basically ZK starks. It's the same underlying cryptographic system that starkware uses, that Mitin uses. The main innovation is sort of in terms of both the efficiency with which our prover and verifier do that cryptographic process, as well as, of course, the RISC five circuit and the RISC five vm, of course, so that you can run arbitrary rust code. I do think that we are trying to help the world understand how these cryptographic systems work under the hood. But as a cryptographer, whenever I hear someone's doing some kind of new cryptography, I get a little nervous. So I just wanted to clarify that.
00:10:21.110 - 00:10:43.654, Speaker A: We'Re very much using existing materials or standing on shoulders of cryptographic giants here. And actually, that's a very good addition. And help tends to be a good transition to my third bullet, which is it's not just our own educational resources. Right. Right here. As part of the Zkhack series, the whiteboard sessions are really informative. There's one on zkvms that I thought was a very good session.
00:10:43.654 - 00:11:34.340, Speaker A: For example, it was like number seven, maybe I forget which one it was. But there's one on zkvms in general that's applicable to ours, but applies more or less applicable to ours, but applies to the CK VMS generally. And there's other good general background that's helpful for how Ck things work for more than just us. And we really are using. How do I go backwards? Yeah. The Starks, that's what's in our seal is, as Jeremy said, stuff that's developed by others, well, worked out in a series of papers by Ellie Ben Safon and others and other contributions as well. But, yeah, we're using technology other people are using as well for this security.
