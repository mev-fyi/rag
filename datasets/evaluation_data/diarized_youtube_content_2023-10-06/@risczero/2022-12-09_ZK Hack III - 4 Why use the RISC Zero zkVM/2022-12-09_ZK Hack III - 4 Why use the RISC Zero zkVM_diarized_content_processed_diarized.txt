00:00:08.890 - 00:01:03.166, Speaker A: Why would you use the risk zero Zkvm? There are actually sort of two parts to that question. Part of it is, why use a ZkVM at all? And I'm going to start there. So, in general, not even thinking about zkvms at the moment, just thinking about algorithms, it computer science problems. It can sometimes be easier to check someone's work than it can be to redo their work. And depending on the problems, some problems are just sort of naturally like this. So if we think of a graph theory problem, if we think of coloring a graph, if I asked you to look at this graph on the left here and asked you, hey, is it possible to pick three colors, color the nodes with those colors, such that no two adjacent nodes have the same color? And I just showed you the graph on the left, you could probably figure it out, but take a bit of work. If I showed you the graph on the right, you still do need to check something.
00:01:03.166 - 00:01:26.674, Speaker A: You need to look at the nodes and see if some of them are adjacent. But it's easier. It's easier to check work for this problem. It's easier to check work than it is to redo work. But that's not true for all problems. Like imagine a hash function depending on exactly what I mean by check your work. It's either, well, oh, this is the hash of ABC.
00:01:26.674 - 00:01:35.306, Speaker A: Well, that's checking the work just is redoing the work. Or if you mean, oh, this is the hash, tell me what it's the hash of. Good luck with that.
00:01:35.328 - 00:01:35.466, Speaker B: Right.
00:01:35.488 - 00:02:48.670, Speaker A: The whole point of hash functions is they're cryptographically secure against doing such a thing. So only some problems are like this, but with a provable ZkVM, suddenly it's possible to check any algorithm, just a general algorithm, in constant time with approvable ZkvM, all you need to do is look at the receipt, and all you need to do for that is, well, see that the seal is valid, and see that the outputs are what you want the outputs to be, and that's not related to the code. I guess I suddenly realized there's a slight nuance. You can verify that we're seeing constant time, but verifying that it matches the source code that the hash says it is, you need to read the entire source code, and reading code takes time. But beyond that, verifying in constant time. Right. So what does that look like? You have this hash function example, well, if you have a receipt, if you ran a guest code, that's just Shaw 256, this input, if you ran that guest code, what do you have at the end? You have a receipt.
00:02:48.670 - 00:03:47.254, Speaker A: The receipt says this is the hash and the seal says, I ran the Shaw 256 algorithm on private input and this is a zero knowledge proof that this hash is the result I got. So you know that this thing over in the receipt, you don't know what it's a hash of, but you do know it was computed by someone actually running SHA 256. This isn't someone just keyboard mashed the valid hex characters. This is actually a SHA 256 output. And yes, I sort of led to this point already. If private information is affecting the result, if you're just sort of naively checking in that early graph theory example, there's no way to check or redo the problem with private information because the result would be different depending on the private information. So if you don't have it, you can't see if the result is right.
00:03:47.254 - 00:04:44.614, Speaker A: But the zero knowledge part of a ZKVM means that back here, this input, it's still private, but this output, it's still proven. You are still convinced you can check the work without revealing the private. So, and sort of a general principle, this is the sort of reason you want to use a ZKVM. Well, why would you want to use the risk zero ZkvM? As Brian mentioned in the beginning, you have a bunch of options here. Why ours so at risk zero? I think it's really valuable that your zero knowledge proofs be another rust crate you use, not some new language you need to learn. I think it's really convenient to just write rust code in the way any rust tutorial on the Internet. Probably you want to read the rust book, but any rest tutorial on the Internet can tell you how to write rest code.
00:04:44.614 - 00:05:34.802, Speaker A: Great to get all the rest tooling. Great to use other crates. Today we're going to be seeing using the JSON crate and chess crate, whose name I'm blanking on because it's complicated. But we're going to be using rest crates, and that's great to not have to reinvent code that other people have already worked on. And sure, you can have a great open source community for your zero knowledge proving your Zkvgam, and we certainly hope to have one. And I know other people have great ones, but I don't think anyone has open source community the size of rust, and I don't think that's a very practical thing to expect, and I don't think you need it because we can just use rust. Also, we are using a risk five architecture.
00:05:34.802 - 00:06:06.174, Speaker A: It's an open architecture. It's well supported, well studied. You can compile to it from a variety of places. Rust, for example, compiles to our risk five architecture. We have compliance tests that we pass because it's an open architecture, and it comes with compliance tests. And also, the RISC five is nice because it's a good extensible architecture. And so we have some custom accelerators, things like doing finite field arithmetic fast, because under the hood, the ZKVM is based on finite field arithmetic.
00:06:06.174 - 00:06:39.718, Speaker A: And no one set an instructions at architecture for the risk five circuit. To be able to do finite field arithmetic is a sort of primitive behavior, but for us, it's easy. So we can add an extension for it. We also have an extension for Shaw that we're going to be seeing today. So those are some reasons that I think the risk zero ZKVM is a great one to choose. And speaking of why you would choose it, what could you do with this ZKVM? I said, here's what you can do with ZKVM. Here's why you would choose ours.
00:06:39.718 - 00:07:18.806, Speaker A: There are a few answers. There's, well, what have people done already? For example, Linksar and Yukimend. I'm sorry if I'mispronouncing those. Have a project proving the sum of near balances risk Zero's own. Bolton Bailey has a metamath verifier has a project working on a metamath verifier to prove that a mathematical theorem is true without revealing what that proof is. Stark Oracles has a Winterfell verification run inside risk zero. So you can sort of recurse these zero knowledge systems if you want to.
00:07:18.806 - 00:08:02.306, Speaker A: Recurse is not quite the right word, but you can stack the zero knowledge systems if you want to, in this way. But also, there are all sorts of amazing future possibilities, and some of these are limited on performance max cycles, as Jeremy was alluding to in an earlier question. But there's some amazing ideas. You can prove ZKML, you can prove machine learning output. Oh, this machine learning system. I can prove that it thinks a picture with this hash is a cat. Or you could go through bitcoin history and be like, I can prove that there's a transaction involving a thousand bitcoins of this account somewhere, somewhere out there, we could have provable GCC.
00:08:02.306 - 00:08:51.446, Speaker A: This is sort of, I think, related to the question that came in. Have. If you're thinking this binary, this binary being given, was it compiled from this source code? You can have a provable GCC compilation, you can sort of look at your source code supply chain and have some sort of certainty around that. With provable compiler, we could also do a zero knowledge database thing. Maybe you have some database setup and you want to prove that you've transitioned from one database to another, and that that transition probably came from some particular query. You could have zero knowledge databases. Again, many of these will run into cycle limits if you try and do them right now.
00:08:51.446 - 00:08:58.342, Speaker A: Certainly GCC, for example, would hit many times over the cycle limit, but we're working on that.
00:08:58.396 - 00:08:58.662, Speaker B: Right.
00:08:58.716 - 00:09:09.980, Speaker A: So I think there are all sorts of exciting design possibilities, many of which I haven't even dreamed of yet. Okay. Actually this is probably a good point to ask if there are more questions.
00:09:12.930 - 00:09:59.850, Speaker B: So there was a question about what are the restrictions on the rust code? And we're going to be covering that in a little bit more detail later. But currently you can use STD, although experimental, it's a bit experimental and it doesn't do all that. Like, obviously if you try to open a file, it will just panic because there is no files in the VM. Currently, we do intend to provide more extensive support for that, including potentially even access to the host's file system through some mechanism and so on. But right now it's a pretty bare bones. But we do support it specifically because a lot of other crates will import STD and fail if you don't. So it's helpful to allow a wider range of available options.
00:09:59.850 - 00:10:17.090, Speaker B: Although generally I still write no standard when I can get away with it. It just saves a little on program size. The overall machine you're running on is fairly small. Tim, do you remember the specific number for the size of ram? I think it's like 64 megs or something like that.
00:10:17.160 - 00:10:22.398, Speaker A: A little complicated because we have different memory regions. Frank gave me an answer like five different memory regions.
00:10:22.574 - 00:11:02.670, Speaker B: But effectively you're not running on a modern super high performance machine. You're running on a small. Think of it like sort of embedded programming, right? If I was going to do some work on a raspberry PI, or maybe even a little smaller than a raspberry PI, more like, but bigger than a microcontroller, probably. So it's a small machine. You do have to be careful with your speed. The other question was also sort of, what's the sort of cost to how fast do these things run? So basically on the 10 branch, which is still under RC on my MacBook, I get about 50,000 cycles per second, or instructions per second of risk. Five instructions on my MacBook.
00:11:02.670 - 00:11:11.118, Speaker B: So it's not extraordinarily fast, but usable for many types of applications.
00:11:11.294 - 00:11:19.394, Speaker C: Just one thing, Jeremy. When you're answering the questions, just remember to read them out, because for the video after, we won't have any copy of them.
00:11:19.592 - 00:11:20.342, Speaker B: That is a good.
00:11:20.396 - 00:11:22.502, Speaker C: If you want to go for it, go for it.
00:11:22.556 - 00:12:04.530, Speaker B: Sure. The question for that was, what was the average amortized overhead of running a program in the VM environment as opposed to direct execution? The next question is, maybe I missed it, but what is the underlying execution layer on which Risk zero is based? So it's basically the RISC five instruction set architecture. So basically we emulate a RISC five computer. So RISC five is an open standard ISA, similar to. It's a RISC architecture, sort of like arm. It's actually even simpler than arm.
00:12:05.850 - 00:12:12.070, Speaker A: Specifically the RV 32 IM instruction set one, plus custom extensions.
00:12:14.410 - 00:12:14.870, Speaker B: Cool.
00:12:14.940 - 00:12:16.280, Speaker A: Was that it for questions?
00:12:18.330 - 00:13:07.190, Speaker B: Yeah, so there's another one more question popped up, which is, can you describe some challenges with CISC? And so, to answer that, yeah, fundamentally we have to make an arithmetic circuit that implements the entire full ISA support in order to allow us to use normal existing compiler tool chains, like the existing rust tool chain, to compile down to RISC five. If we were to try to do that with X 86, for example, the instruction decoder alone would make the circuit massively larger. In fact, we very carefully looked at all of the sort of execution environments we could use. Even webassembly adds a significant amount of complexity over risk five. RISC five is a very small design in terms of the instruction set, which is very helpful.
00:13:08.090 - 00:13:34.010, Speaker D: I can fill the next one. The question was, I think the layer question was about a L2. And I'll say right now we don't have sort of formal support for any particular chain. There's been examples on neo error and CoSm because you can very readily fire on those chains. But we will be announcing a system sometime in the near future that will let you execute these on any chain.
