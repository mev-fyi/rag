00:00:00.000 - 00:00:01.566, Speaker A: If we look at the ZKBM, is.
00:00:01.588 - 00:00:04.174, Speaker B: There a way to sort of make.
00:00:04.212 - 00:00:25.138, Speaker A: The program execute in a way that we can make scale? And so our approach is basically let's split the execution up into separate parts. We call these segments. Once you split them up into separate parts, you can now prove each one of these parts independently. So there's a first phase where we have to basically run the entire thing in serial.
00:00:25.274 - 00:00:28.534, Speaker B: But once that's done, we can do.
00:00:28.572 - 00:00:35.606, Speaker A: The proving of each part in parallel. And then of course we can use recursion to do a roll up where we get a single succinct sort of.
00:00:35.628 - 00:00:36.920, Speaker B: Proof at the very end.
00:00:38.910 - 00:01:03.874, Speaker A: So yeah, what's nice about this is the programmer doesn't have to know anything about it. The execution engine can basically figure out where all the splits need to go. The user does can control basically how big each segment wants to be up to the cycle limit. But other than that, if they wanted to turn down the limit for each.
00:01:03.912 - 00:01:05.554, Speaker B: Segment, they can do that.
00:01:05.592 - 00:01:09.330, Speaker A: And what's nice about that is that it uses a lot less memory.
00:01:10.710 - 00:01:13.620, Speaker B: And of course we get parallel proving by doing this.
00:01:13.990 - 00:01:15.446, Speaker A: So this is just kind of an.
00:01:15.468 - 00:01:25.078, Speaker B: Example of the host side code to be able to configure and execute the.
00:01:25.164 - 00:01:39.180, Speaker A: Executor and then to request approve. So yeah, we can kind of see the execution environment. We're setting up a builder. We're basically giving it what the segment limit wants to be. And this is specified through powers of two.
00:01:41.090 - 00:01:43.118, Speaker B: We add some inputs, we go ahead.
00:01:43.124 - 00:01:46.206, Speaker A: And run the execution, get provided a.
00:01:46.228 - 00:01:49.454, Speaker B: Given elf file, and then we have.
00:01:49.492 - 00:02:28.954, Speaker A: This sort of session callback mechanism where we're going to be calling the executor. And every segment that gets produced as we're running the execution gets collected here into this file segment. We can store these segments on disk. The reason for that is so that we can kind of keep our execution memory. The memory needed for execution can remain fixed so that we don't need to sort of, as you keep running segments, each segment is going to cost a certain amount of memory in order to keep all that resident. So if we kind of swap it out to disk, we can keep the.
00:02:28.992 - 00:02:34.990, Speaker B: Fixed amount of memory cost for the execution. And then later I've got the session.
00:02:35.330 - 00:02:44.110, Speaker A: I can now kind of prove the entire session. And what I get back is a receipt. The receipt contains a bunch of segments.
00:02:44.450 - 00:02:47.150, Speaker B: And I can also get the journal.
00:02:47.230 - 00:02:52.802, Speaker A: Out of the receipt. So it's kind of similar to what we had previously. The API is a little bit different.
00:02:52.856 - 00:02:55.378, Speaker B: Now, but the basic gist is that.
00:02:55.384 - 00:03:03.270, Speaker A: We have this execution phase, we have approving phase, and then you verify. Take the receipt, send it to the other party, and do a verify.
00:03:04.650 - 00:03:11.114, Speaker B: I should mention that there's two kinds of receipts that we currently support, and.
00:03:11.152 - 00:03:36.370, Speaker A: One is sort of this flat continuations, and the other one is like a rolled up continuation. So flat continuations means run the executor to split it up into multiple segments. And then when I call, prove what I get back is a list of a collection of receipts, one receipt for each segment, and you can then verify each segment independently.
00:03:36.790 - 00:03:38.610, Speaker B: The other thing you can do is.
00:03:38.680 - 00:03:51.910, Speaker A: Ask for a rolled up proof, which basically returns a single receipt. And by verifying that single receipt, I can go ahead and ensure that the entire session was run properly.
00:03:53.530 - 00:03:55.142, Speaker C: Can I ask a clarifying question?
00:03:55.276 - 00:03:56.422, Speaker B: Yeah, go for it.
00:03:56.556 - 00:04:11.930, Speaker C: Yeah, I guess one thing we talked about, what actually is a segment in terms of memory, what's actually stored in a segment, and why is it that a chain of segments actually constitutes a full computation, actually proves a computation.
00:04:13.310 - 00:04:18.542, Speaker A: So I have some material in a little bit that goes into the details of, I guess, what a segment is.
00:04:18.676 - 00:04:18.974, Speaker C: Great.
00:04:19.012 - 00:04:19.406, Speaker B: Yeah.
00:04:19.508 - 00:04:26.850, Speaker A: Let me see if that answers your question in just a minute. And if not, we can dive into more details.
00:04:30.230 - 00:04:35.986, Speaker B: Right. So we have this execution, which basically.
00:04:36.168 - 00:04:38.726, Speaker A: Determines, basically takes a snapshot of.
00:04:38.748 - 00:04:45.366, Speaker B: The idea is that we have a memory state. So you can imagine that you've got.
00:04:45.468 - 00:04:56.700, Speaker A: The computation that you're doing. You've got some sort of program that says, go and run all these instructions. Those instructions are going to make side effects. They're going to cause different parts of memory to be read or written to.
00:04:57.630 - 00:05:00.154, Speaker B: And the idea is that we want.
00:05:00.192 - 00:05:02.234, Speaker A: To take a snapshot of this memory.
00:05:02.282 - 00:05:05.086, Speaker B: State, and then when we want to.
00:05:05.108 - 00:05:07.178, Speaker A: Continue, like if we pause one segment.
00:05:07.274 - 00:05:16.866, Speaker B: We stop the execution of one segment, and then we want to continue that execution on a different segment. The trick is, well, how do we.
00:05:16.888 - 00:05:36.530, Speaker A: Make sure that these two segments are related to each other? How do we make sure that, cryptographically speaking, everything is verified so that people can't sort of inject their own instructions in between or they can't play around with the verification of the computation?
00:05:36.610 - 00:05:44.346, Speaker B: So the idea is let's get a snapshot. Let's then prove through various means that.
00:05:44.448 - 00:05:46.458, Speaker A: The snapshot from one relates to the.
00:05:46.464 - 00:05:47.740, Speaker B: Snapshot of the second.
00:05:50.110 - 00:05:57.086, Speaker A: So, yeah, that's how we do the splits. We use a merkalized data structure. I'll get into that in a little.
00:05:57.108 - 00:06:05.962, Speaker B: Bit on what that looks like. So, yeah, this is kind of a representation here of the execution.
00:06:06.026 - 00:06:16.726, Speaker A: We do this kind of pre flight, we call it, which is basically running the execution in serial to figure out where all the splits need to go. It also does things like record all.
00:06:16.748 - 00:06:19.574, Speaker B: Of the host guest I o the.
00:06:19.612 - 00:06:43.126, Speaker A: Interaction with the host. All that stuff gets collected during the pre flight. Once that's done, we can then farm out, we can take each segment, segment one, segment two. All these segments can be farmed out to different machines potentially, and each segment can be run in parallel independently. The proof, I should say once that's.
00:06:43.158 - 00:06:48.682, Speaker B: All done, you can imagine you've got all these leaf nodes of proofs for each segment.
00:06:48.746 - 00:07:05.910, Speaker A: We can then do these join operations, which is kind of a recursive operation where we can run the verify of the a and b together into a single segment or session. And that's what we call the join sort predicate.
00:07:06.730 - 00:07:08.358, Speaker B: If you do this enough times, you.
00:07:08.364 - 00:07:12.626, Speaker A: Kind of do this in a binary tree fashion. You finally get a final succinct proof.
00:07:12.658 - 00:07:14.980, Speaker B: At the very end. If.
