00:00:00.490 - 00:00:50.960, Speaker A: Let's sort of come back to read Solomon codes in our context a little bit more explicitly. I want to try to generate, I want to sort of talk through these steps in a little bit more of a concrete context. So the first step that I've listed here is we execute a binary file and we record an execution trace. And this makes columns. So we have a more explicit example of this up on the website using kind of Fibonacci program. So this program is taking inputs of 24 and 30, and it's doing a sort of Fibonacci addition. So in the first round we just do 24 plus 30 is 54, then we sort of copy the 30 and 54, and we do 30 plus 54 is 84.
00:00:50.960 - 00:01:47.470, Speaker A: We're working mod 97. So in the next row we have 54 plus 84, modulo 97 is 41. And the last sort of we just do four Fibonacci ads. And this sort of execution trace is designed to assert that if you start with inputs of 24 and 30 and you run four rounds of Fibonacci addition modulo 97, you'll get out the output of 28. So I'm not going to talk through these control columns. What I really want to do is just focus on we have an execution trace and we have a column of that execution trace. So don't stress too much about the details of this program here, although if you want to sort of check that out, there's like ten lessons that walk through the construction of our receipts.
00:01:47.470 - 00:02:32.960, Speaker A: So let's follow along the process of what happens to this column as we sort of proceed through our process of generating a seal. So the first thing that we do with this column is we add some random padding at the end. So this is not read Solomon encoding. This is just a kind of detail in order to make our protocol zero knowledge that I'm not going to worry about so much. But so for our purposes today, the column of the trace is these eight values. The first four are the actual execution trace data, and the second four are some random padding that was added. So that was step one.
00:02:32.960 - 00:03:26.558, Speaker A: Step two says that we encode each column using read Solomon encoding. So I'm going to walk through this now a little bit more explicitly in terms of some finite field context. So if the finite field stuff isn't familiar to you, this part might get a little bit confusing. Although we do have some nice reference materials on finite fields that you can find. I'll put links up. So to recap or to review, what we're going to do is we're going to take this eight entry message, this column of eight entries, we're going to turn it into a polynomial, and we're going to evaluate it to make a code word. So here's python code for actually doing the first step of this.
00:03:26.558 - 00:04:08.922, Speaker A: An INTT inverse number theoretic transform is a function that will receive some entries and will spit out coefficients of a polynomial. So here's the polynomial that results from interpolating these eight points. And then we evaluate it on a domain that's four times larger. So we had eight entries in our column. We're going to have 32 entries in our blocks. And in the next couple of slides, I'm going to walk through specifically where we evaluate it. Questions.
00:04:08.922 - 00:04:09.900, Speaker A: At this point.
00:04:13.010 - 00:04:19.470, Speaker B: The larger domain. I presume you're not doing, like, interpolation between the points, but something more sophisticated.
00:04:19.890 - 00:05:00.620, Speaker A: The larger domain, I mean, I would actually say less sophisticated. Let me hold off on the question about the larger domain for a minute or two, and you can circle back to it if it's still any questions about this intt thing is, I think, the biggest black box on the screen right now. And Bolton is going to be giving a presentation unpacking that black box in a couple of weeks. But loosely speaking, an intt is a way to turn evaluations of a polynomial into the coefficients of the polynomial. So the way that we add.
00:05:00.930 - 00:05:07.518, Speaker C: Sorry, the amount of random padding you add, is it fixed? Is it some nearest power of two?
00:05:07.684 - 00:05:37.590, Speaker A: Yeah. Great question. The random padding is based on the number of queries that we do as part of fry. So, essentially, each row of random padding adds one degree of freedom. And each fry query sort of steals one degree of freedom. So if we want a zero knowledge system, we need to add at least as many rows of random padding as we have fry queries.
00:05:39.130 - 00:05:40.118, Speaker C: Okay, cool.
00:05:40.284 - 00:06:17.350, Speaker A: And we need to make sure that we end up with a power of two in order to be able to do an intt. So we add enough random padding that the column is a power of two. And that after we do the fry queries, our degrees of freedom will have been compensated between the padding and the queries. Awesome question. So, let's sort of unpack. The example that I gave up front was we had the points zero through nine. And then we added 0.51.52.
00:06:17.350 - 00:06:49.786, Speaker A: .53.5. In practice, we're not working with integers and decimals. We're working with finite fields. In this example, we're working over the field of 97. Field of order 97, I should say. And we're going to focus on the number five because five is a multiplicative generator for this field. So if that terminology is unfamiliar, you can go back and watch our video introducing finite fields.
00:06:49.786 - 00:07:49.844, Speaker A: But roughly speaking, what this means is that every element in the field aside from zero can be expressed as a power of five. So we use powers of five to index our column. And in particular here I have five to the zero th, five to the 12th, five to the 24th. The point here is that the next one on that list would circle back to the first one on the list. Five to the 96 is the same as five to the zero. So that's sort of why I chose five, because it's a generator, and I chose five to the twelveth because I wanted to have eight terms on the list. Before I circle back to the beginning, the points that I then add, I've sort of just spread them out on this farther right column here.
00:07:49.844 - 00:08:59.234, Speaker A: There's a bunch of points in between five to the zero th and five to the twelveth in particular, because I want to expand it by a factor of four. The additional points that I'm going to evaluate on are five cubed, five to the 6th, five to the 9th. So we started with the generator to the twelveth power, and then the expanded thing is the generator to the third power. And here's the actual result of evaluating that polynomial on those points. So this is really the full version we opened up with this hello world jello world thing to just give a little bit of intuitive understanding of the ideas without the need to have the finite field complexity on the page at the same time. But it's really the exact same idea. So this is how you make a read Solomon code.
00:08:59.234 - 00:09:30.218, Speaker A: You start with a column, you run an intt or some other interpolation in order to make a polynomial, and then you add some in between points and you evaluate on those in between points. So on the left we have the column, and on the right we have the block, which is actually a valid code word. Assuming that there's no typos or errors in the computation questions, I have a quick question.
00:09:30.304 - 00:09:41.840, Speaker B: So it looks like you're limited to only like 96 quote unquote computations in a way, or else you won't be able to add additional code words.
00:09:46.130 - 00:10:27.722, Speaker A: Yeah. So in order to sort of do any of this arithmetic, you have to choose a world to live in. And in this case, the world I'm living in is the field of order 97. And we chose this as just a sort of contrived small example in practice. We're working with a field that's about two to the 32 large. So you're absolutely right here. I guess like in this context, I showed here a rate one fourth.
00:10:27.722 - 00:10:46.500, Speaker A: Read Solomon encoding is the technical sort of terminology here, one fourth, because it's an expansion factor of four. And given the size of my field, I couldn't go any bigger, I guess, than a rate 112 expansion here.
00:10:46.870 - 00:11:01.420, Speaker B: Another question I want to build upon. Maybe you described it, but it was a little confusing to me. Why are we evenly spacing, I guess our generators essentially by five to the twelve?
00:11:02.750 - 00:11:22.190, Speaker A: The evenly spacing is necessary in order to be able to have the interpolation be efficient. Interpolation naively has n squared complexity, but if you evenly space the indexing, then you can do it in n log n complexity.
00:11:25.410 - 00:11:28.654, Speaker B: So it doesn't have to be this way. I guess it's just for.
00:11:28.772 - 00:11:56.890, Speaker A: Yeah, you could do a read Solomon encoding that did not evenly space the points like any choices of points here. If you just choose a domain, do an interpolation, choose a larger domain, do an evaluation that works. But if you want it to be efficient in practice, then the evenly spacing lends itself to NTTs and INTTs.
00:11:57.550 - 00:12:17.700, Speaker B: And my last question is, since you mentioned you're operating over a finite field of size two to the something I forgot, and you have to evaluate over all those points, does it get expensive, or does the fact of this evenly spacing by the fact that the complexity is n log n that you get, I guess a major performance boost that doesn't really matter.
00:12:18.470 - 00:12:52.250, Speaker A: No. The process of running the interpolations and evaluations is the most expensive part of our approver protocol. It's still pretty manageable. And login complexity is not too bad. But if you look at the sort of amount of computation time for generating a receipt, I think something like 80 plus percent of it is spent doing interpolations and evaluations.
00:12:55.960 - 00:13:12.330, Speaker C: Another question, can you give a hint of how, given this right hand side 32 numbers, these are all evaluations of some polynomial? How do you go about interpolating a polynomial out of this? Is it just an intt done on this thing?
00:13:12.700 - 00:13:33.650, Speaker A: Yeah, the direct way to sort of check this would be just run an intt on the full column there and hope that your result is low degree. And if the result is low degree, it's an indication that it's a valid code word. And if the result is not low degree, then it's an indication that it's not.
00:13:34.260 - 00:13:41.808, Speaker C: Got it? Okay. And by low degree you mean matching some bounded degree expectation and matching the.
00:13:41.814 - 00:14:05.210, Speaker A: Length of the column. The initial thing that we started with had eight terms. So I would expect a degree seven polynomial to result from this. So if I run an intt on that giant list of 32 entries and actually get something degree seven, then I'll conclude that it was a valid code word.
00:14:06.300 - 00:14:12.300, Speaker C: Cool. Okay. Is there a reason why it's not called bounded degree, but called low degree? Is there some other nuance?
00:14:14.240 - 00:15:00.430, Speaker A: Wonderful question. I would say the answer, in my vernacular, is that the fry paper uses the term low degree. Test. The term low degree I find to be somewhat misleading here because in practice, our low degree polynomials are like degree two to the 16th or something like that. So it's certainly a misleading term to call it low degree, but it's low degree with respect to the block size, but bounded degree. If you, for your own purposes, want to think about it in terms of the phrasing bounded degree, I think that seems like a clearer way to think about it for yourself.
00:15:03.680 - 00:15:36.550, Speaker D: One question, I think from the data column, the first four items actually was decided by the Fibonacci calculation and why it still fulfills power to the zero file, power to the twelve. It's an encoding. No, it's not encoding. So why it still fulfills that requirement or you just do the mapping for that?
00:15:36.940 - 00:15:40.120, Speaker A: Sorry, what's the requirement that you're asking about fulfilling?
00:15:40.620 - 00:15:50.044, Speaker D: I mean. Okay, I got that. Sorry, I got that.
00:15:50.162 - 00:15:57.132, Speaker A: Okay, thank you. Yeah, I'm curious about what the point of confusion was, but five power 20.
00:15:57.186 - 00:16:00.830, Speaker D: Is not equal to the 24th, right?
00:16:01.140 - 00:16:07.020, Speaker A: No. So this isn't like an ordered pair, it's an indexing, it's not an evaluation.
00:16:07.180 - 00:16:17.250, Speaker D: Something like mapping from the original word to the code word.
00:16:20.410 - 00:16:45.870, Speaker A: Yeah. So the values on the left there are the x coordinates of your inputs and the values on the right there are the outputs. So I could say f of five to the zero is equal to 24, f of five to the twelveth is equal to 30, where f is the polynomial that results from this interpolation.
00:16:48.210 - 00:16:49.934, Speaker D: Okay, thank you very much.
00:16:50.132 - 00:16:53.680, Speaker A: Awesome questions. I'm loving the engagement here.
00:16:53.990 - 00:17:01.010, Speaker B: One follow up question, I'm having you apply the same process, same generator, same finite field across all columns.
00:17:01.750 - 00:17:52.338, Speaker A: Correct? Okay. If we want to make this zero knowledge, all we need to kind of do is shift our evaluation a little bit. So I've listed the expanded domain here as five to the zero, five to the third, five to the 6th. But if we do a little shift and instead evaluate on five to the first, five to the fourth, five to the 7th. Then when we later do our fry queries, we'll be able to maintain a zero knowledge protocol. So. So we've now kind of discussed the first two steps on this page.
00:17:52.338 - 00:17:58.110, Speaker A: We showed what I mean by the columns. We showed some random padding added to the columns. We did a read Solomon encoding.
