00:00:09.050 - 00:01:03.002, Speaker A: I'll start by saying sort of what happens with Rishero? What is the Risero ZkVM at all? And a bit about how it's architected. So what is the Risero ZKVM? Well, as Brian mentioned, a little, it's a virtual machine. It's a verifiable, zero knowledge virtual machine. So by virtue of being a virtual machine, it runs code. If you have code, that would execute on a physical risk five circuit of the same architecture, same specific risk five architecture as our virtual machine, running it on the risk zero virtual machine is going to work in the same way. We have some extensions added to it to interact with the host to commit data to the receipt. I'll be talking about that stuff later.
00:01:03.002 - 00:01:57.460, Speaker A: But fundamentally, it acts just like an actual physical circuit would. It runs that code, it's verifiable and zero knowledge, which means it's not just that it runs the code, it's not a bare virtual machine. When you run the code, it produces, it comes with a receipt saying, hey, this code that I just ran, I ran it, and there's cryptographic data that proves that I ran that exact code, and it's zero knowledge in the sense that anything that isn't the code and that it doesn't explicitly publish is private data. And handing someone the receipt, proving the execution, tells them nothing about that private data, that's what zero knowledge means in this context. So it's verifiable zero knowledge virtual machine. That's what we have. That's what we were working with.
00:01:57.460 - 00:02:47.726, Speaker A: Rust compiles to it, so you can prove to people that you have, even if they don't trust you, you can prove, no, this rust code, I really have run it, and this really was the output I got from running it, and they can know that it was not manipulated by you in some way. So what does the architecture look like? Well, in some sense, you have a standard virtual machine architecture where there's a host and a guest, and the host emulates the guest. The guest executes whatever it's being asked to execute. Because we're in the zero knowledge context. The host can send the guest private data. Actually, in general, there's private communication allowed. But in the straightforward examples, the host sends the guest private data, and that data does not show up in the receipt.
00:02:47.726 - 00:03:28.110, Speaker A: Nothing is proven about it. But what is proven is which code was executed on the data and the results of executing that code. And that gives you something called a receipt. The receipt comes back to the host. So that's the proof that the computation was done the way it was intended to, and the host is then able to send that receipt off to verifiers. It can forward the receipt to skeptics, whoever the host thinks, oh, this person should know what I computed, and I want to convince them I computed faithfully. And so that goes off to the verifier, what we'll talk about now.
00:03:28.110 - 00:04:13.998, Speaker A: So in the verifier end, really, we're sort of thinking about what's the architecture of the receipt on the verifier end, all the verifier is going to do is inspect the receipt and be like, if I see the outputs, and this is a good proof, this code really was executed correctly. So the receipt has two components, the journal and the seal. The journal is what contains the outputs of the program, and these are public outputs. If you write it to the journal, anyone can see it. So this is the part, sort of the results that you are proving. The seal side is the cryptographic information you need to then verifier needs to know that the proof was faithfully executed. It contains a bunch of cryptographic data.
00:04:13.998 - 00:04:45.650, Speaker A: It also includes a hash of the program saying that this is the program that was proven. The prover didn't sneak in some other second program, say, hey, I'm proving the execution of this. And actually they're proving some other program. That's not possible because the seal contains this hash of the journal, but the hash and scare quotes, because technically it's like a collection hashes, but essentially it's a hash. You can think of it as a hash, and you'll very much have the right idea. And that's what happens. That's.
