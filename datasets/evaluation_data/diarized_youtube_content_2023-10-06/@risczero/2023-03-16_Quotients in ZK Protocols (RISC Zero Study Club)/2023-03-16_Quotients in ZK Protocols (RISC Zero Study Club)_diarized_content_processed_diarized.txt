00:00:00.570 - 00:00:31.122, Speaker A: So welcome everybody. Thanks for coming. My name is Paul. I work at risk zero, doing kind of educational content and ZKP stuff. And we've been doing this study club session for a few months now, I guess in order to try to make our technology a little bit more accessible, both to people with technical audiences or technical backgrounds, but also it to people with less technical backgrounds. And there's a lot of confusing ideas.
00:00:31.186 - 00:00:35.654, Speaker B: Behind our tech, and I would like.
00:00:35.692 - 00:01:28.522, Speaker A: To believe that we can make them feel quite simple. I've said a number of times that what we're really doing is just algebra two over finite fields. And if algebra two isn't so scary and finite fields aren't so scary, then hopefully the technology behind risk zero won't be so scary. And I've done some material in the past on finite fields, so I am going to assume a little bit of I'm not going to be covering finite fields in this talk, but most of the ideas that we're going to need about them aren't. You're not actually going to need anything specific about finite fields today. What we're going to be doing today is sort of connecting the dots with the algebra two pieces. So I'll say more about that as we move forward.
00:01:28.522 - 00:02:02.930, Speaker A: But in a lot of ZK protocols, there is this moment where you have a couple of polynomials and you divide one polynomial by the other in order to accomplish a task. And I'll say more about the sort of mission today is to make sense of where are we doing these quotients? Where are we dividing polynomials by each other? And what's the intuitive motivation for why that's a useful thing to do? This table apparently slides.
00:02:05.030 - 00:02:06.338, Speaker B: I have a few references up on.
00:02:06.344 - 00:02:52.894, Speaker A: The screen, and they'll appear also at the end of the presentation, so don't worry about writing them down. But just to run through them briefly, two of them are like risk zero specific links. One of them is the link to all the past study club sessions and the future ones that are planned. One of them is a ZKP white paper that we released a couple of weeks ago, and then the other two are external references. The deep fry paper is extremely technical. I don't necessarily recommend it as an initial reference, but it is like the main reference for a lot of what I'll be discussing today. And then this KZG explained, the ZK whiteboard sessions are fantastic.
00:02:52.894 - 00:03:01.766, Speaker A: So if you are looking for a place to dive in, that is not our study club. The ZK hack whiteboard session, which is the last link on this page is.
00:03:01.788 - 00:03:04.600, Speaker B: A really good choice of where to start.
00:03:06.410 - 00:03:52.950, Speaker A: Before we get into the nitty gritty, I want to just invite please do interrupt questions are super helpful and productive, both for me, for you, and for the rest of the group. And I want to just invite that you don't need to necessarily wait for permission to ask a question. Feel free to just unmute yourself and interrupt. In particular, I don't see the chat window very easily when I'm in a full screen sharing, so if there is a question that appears in chat and I don't notice it, it would be helpful if somebody would surface it for me. So I already said a little bit about welcome and thanks for joining us and who I am and why we're here. I want to just give a really.
00:03:53.020 - 00:03:55.986, Speaker B: Brief, high level overview of what we're.
00:03:56.018 - 00:04:57.370, Speaker A: Talking about when we talk about Risk Zero's tech. I imagine this is familiar to the people that are showing up to this, but just at a very high level, what is risk zero doing? We're trying to introduce techniques for verifiable computation. So in the status quo, if you have some code that you want to delegate to some third party, you'll send it to Amazon. Amazon will do some computation, they'll send you the result and you'll forward that result to a third party as needed for your application. And in this case, we have to just sort of rely on Amazon as a trusted agent to do the computation that we wanted. On the other hand, with RisC zero, rather than sending the code to a third party, you execute the code in a vm, a zero knowledge virtual machine. And rather than just providing the result of the computation, you also get a proof of that computation.
00:04:57.370 - 00:05:15.250, Speaker A: So the pairing of the result of the computation and the associated proof, we call a receipt. And then instead of just forwarding an untrusted result, you can forward this receipt to the third party. And the third party has the ability to verify that receipt.
00:05:15.990 - 00:05:22.450, Speaker B: So questions at this point. Okay, cool.
00:05:24.500 - 00:06:30.456, Speaker A: So this computation that you're running may also have some secret data involved. And in the status quo situation where you're just sending something to Amazon, you're trusting this trusted agent, you're trusting Amazon with this secret data, whereas in the ZKVM context, you can actually just run the whole operation locally, in which case you don't actually need your trusted data to leave your machine. So because you can run the ZKVM locally, you get some privacy. And because a third party can verify the receipt, you get a scalability feature. So this is the 92nd overview of what risk zero is doing, and what we're doing with study club largely is unpacking the question of what do you mean by receipt? How do we really verify some computation as a third party? So let me dive into a kind of high level overview now of what.
00:06:30.478 - 00:06:32.824, Speaker B: It takes to produce a receipt, and.
00:06:32.862 - 00:07:26.984, Speaker A: Then we'll sort of zoom in on the part of that that we're going to be focusing on today. So in order to produce a receipt, what we do is we execute some RISC five binary file in the ZKVM, and we record the execution trace, meaning. So the virtual machine consists of a bunch of registers, and we record the values at each register at each clock cycle. So we get a big sort of, you could think of it as a big rectangle where each column represents one register of the machine and each row represents one clock cycle of the execution. And then with each column we encode those using read Solomon encoding. And a few weeks ago we did a session on read Solomon encoding. So I'm not going to dive into that in detail right now, but the idea there basically is we take this.
00:07:27.022 - 00:07:30.728, Speaker B: Column and we encode it as a.
00:07:30.734 - 00:07:31.720, Speaker A: Polynomial.
00:07:34.240 - 00:07:37.480, Speaker B: And this is the most opaque.
00:07:37.640 - 00:07:56.450, Speaker A: Of the steps that I've written here. Then we do some stark math stuff to the trace blocks, trace blocks meaning the result of that encoding. And finally we have to convince the verifier that after we do this stark math stuff, we still have a valid read Solomon code word.
00:07:57.640 - 00:08:00.644, Speaker B: So to sort of run through that.
00:08:00.682 - 00:08:36.850, Speaker A: A little more succinctly, we first generate some columns. Then we encode those columns into trace blocks with Reed Solomon encoding. And now here's the part that we're going to be focusing on today. We evaluate some constraints on those blocks, and we compute some quotients with those constraints. And what I want to sort of try to unpack today is some of the details of what do I mean by evaluate constraints and compute quotations. And then the final step here after that is we use the fry protocol to achieve step four.
00:08:38.260 - 00:08:39.010, Speaker B: So.
00:08:40.820 - 00:08:49.430, Speaker A: There'S a lot of ideas packed into this slide, and I want to invite, if there are questions at the moment, I'm happy to take them.
00:08:52.440 - 00:08:53.590, Speaker B: What does that mean?
00:08:55.000 - 00:08:56.070, Speaker A: Yeah, go ahead.
00:08:58.200 - 00:09:00.772, Speaker C: Does that mean mine was actually from the previous?
00:09:00.916 - 00:09:04.968, Speaker B: So the verifier needs to have just.
00:09:05.054 - 00:09:08.890, Speaker C: The receipt, or do they also need to have the code that was run?
00:09:09.740 - 00:09:37.190, Speaker A: They need to have some identifier for the code that was run. They need to be able to sort of confirm that the code that was run is the correct code, it doesn't necessarily need to be the case that the verifier has. There needs to be a trusted party who sees the code and generates the sort of cryptographic id for that code.
00:09:38.440 - 00:09:39.190, Speaker B: So.
00:09:42.840 - 00:10:39.620, Speaker A: The most straightforward way to do this would be for the verifier to have access to the code and generate a cryptographic id for the code to verify that it is actually, essentially, when you run the verification, the verification receives a receipt and it receives this cryptographic id. And the verifier needs to be able to trust that the cryptographic id that they're using is the one that they want to use. So it could be that if the code is not really changing very often, it could just be that there could be some small selection of trusted agents who have access to the code and confirm that the ID is correct, or it could be that the ID is sort of just like hosted in a public place, but there needs to be some trusted channel by which the verifiers can see that the cryptographic ID is the correct cryptographic.
00:10:41.100 - 00:10:48.090, Speaker B: Thank you, Louie. Did you have a question, too? Yeah.
00:10:50.140 - 00:11:11.890, Speaker D: I just wanted to understand, I guess, the players in each of these steps. So when you say executing a binary file in the ZKVM, is that the only step that's taking place inside the VM, or are the others also, would you say those are being executed in the ZKVM as well?
00:11:14.260 - 00:11:18.756, Speaker B: I would say that essentially everything here.
00:11:18.858 - 00:11:56.752, Speaker A: Is happening within the ZKVM. You can run the ZKVM without generating a proof. So you could sort of turn off the final steps where the proof generation happens. We refer to this as like, insecure. Skip seal is the sort of prover feature in the rust crates where if you want to, just for debugging or testing purposes, if you don't want to sort of spend all of the time generating the proof, you can run it without. But all of this is happening on the prover side.
00:11:56.806 - 00:12:12.300, Speaker B: All of this is happening on the local side or on the bonsai side if you're using bonsai, but good question. Anything else at the moment?
00:12:12.910 - 00:12:24.314, Speaker A: So I'll post the slides for this afterwards. And these underlined words are links to references to unpack some of those details.
00:12:24.362 - 00:12:28.606, Speaker B: So it's not quite as opaque a.
00:12:28.628 - 00:12:31.760, Speaker A: Collection of black boxes as it might appear at the moment.
00:12:32.690 - 00:12:43.410, Speaker E: We have a question in the chat, and I can read it. So it says, what is or are the most computationally intensive operations for proof generation?
00:12:44.390 - 00:12:45.700, Speaker B: Yeah, good question.
00:12:46.970 - 00:13:43.410, Speaker A: So there's this thing called a number theoretic transform, which is basically FFT. It's the FFT equivalent for finite fields. And in producing a proof for a risk five execution, it is, by far, entities and inverse ntts, I think, take up over 90% of the computational time. We have sort of two types of proofs that we generate. One is a RISC five execution proof, and the other is a recursive proof, in order to take a bunch of proofs and compress them into a single proof. So, in the first type, the RISC V execution proof, it's almost all entities and intts. And in the second type, the recursive proof, it is mostly Merkel branch checking.
00:13:43.410 - 00:13:56.810, Speaker A: So the recursive proofs rely a lot on hashing and the original proofs, the risk five proofs depend on these ntts and intts.
00:13:59.550 - 00:14:04.240, Speaker F: Yeah, I guess in this diagram. But step two. Right. Is where the ntts happen.
00:14:05.090 - 00:14:06.318, Speaker A: Sorry, I couldn't hear that.
00:14:06.324 - 00:14:07.310, Speaker B: Victor, what did you.
00:14:07.460 - 00:14:11.360, Speaker F: Oh, in this diagram, step two is where ntts happen.
00:14:12.050 - 00:14:13.890, Speaker A: In this diagram.
00:14:17.350 - 00:14:17.858, Speaker B: Yeah.
00:14:17.944 - 00:14:20.500, Speaker A: Step two is where ntts happen.
00:14:23.990 - 00:14:24.740, Speaker B: Yes.
00:14:31.390 - 00:14:34.300, Speaker A: Other questions before we continue.
00:14:38.590 - 00:14:39.340, Speaker B: Okay.
00:14:42.710 - 00:15:10.640, Speaker A: Let'S dive in, then. So, our guiding questions for today. Oops, that's not what I wanted to do. Our guiding questions for today are we're focusing on quotients. Today was the sort of topic that I chose to highlight for today. And the questions are, where are quotients used? And why are quotations used? So that's the sort of primary objectives for today. And the answer quotations appear all over the place.
00:15:10.640 - 00:15:37.646, Speaker A: And what they allow is for us to make some to enforce constraints on polynomial commitments. So I want to kind of unpack what I mean by polynomial commitments, and what I mean by constraints on polynomial commitments a little bit at a high level before we dive into how the quotations actually apply. So the roadmap for today is going to be a review of what are.
00:15:37.688 - 00:15:40.998, Speaker B: Polynomial commitments, and then a review of.
00:15:41.004 - 00:15:49.878, Speaker A: Some polynomial algebra stuff. This is really the meat of what I wanted to get at today is, what do I mean when I say it's just algebra two over finite fields?
00:15:49.974 - 00:15:51.340, Speaker B: That's this part.
00:15:51.950 - 00:17:05.826, Speaker A: And then we'll close today by looking at some quotients in some particular places, in the context of starks, in the context of KZG commitments, and in the context of deep degree extension for the elimination of pretenders, is what that acronym stands for. So let's dive into talking about commitment schemes for a minute. A commitment scheme is a way to ensure that someone doesn't change their answer after the fact. So my favorite example of a commitment scheme is if you're playing some sort of guessing game with, say, some children, and you say, I'm thinking of a number between one and 100, and they start guessing, they might not trust that you actually chose a number, and you might use a really simple commitment scheme of, I'm just going to write down my number on a piece of paper before we start. And then at the end, when you don't believe me, I'll just show you the piece of paper, and you'll be able to confirm, oh, yeah, okay. I watched him write that down, and he showed me at the end. So a commitment scheme, it's binding in this case, I wouldn't be able to change my number after I write it.
00:17:05.826 - 00:17:24.966, Speaker A: And it may or may not be hiding. I'm not going to sort of get into the details of what I mean exactly by hiding here. That's sort of a commitment scheme may or may not be zero knowledge. And what you need for a commitment scheme is a way to commit, a.
00:17:24.988 - 00:17:28.774, Speaker B: Way to reveal, and then a way.
00:17:28.812 - 00:17:53.842, Speaker A: To make sure that the thing that you revealed actually matched up with the thing that you committed. So in the most simple example I gave just a second ago, you commit by writing something down, you reveal by unfolding it. And then the child in the room can just look at the number and can say, oh, yeah, that is actually. So there's nothing necessary in order to check.
00:17:53.896 - 00:17:54.820, Speaker B: In this case.
00:17:56.550 - 00:18:05.278, Speaker A: We use a sort of Merkel based commitment scheme. So in this case, what we do for the commitment is we send a.
00:18:05.304 - 00:18:09.334, Speaker B: Merkel route, and the reveal is to.
00:18:09.372 - 00:19:11.360, Speaker A: Show the contents of a Merkel leaf. And then the proof of the reveal, the sort of check happens by showing the Merkel branch that connects the leaf to the root. Questions about these ideas. So I can take whatever contents I want to commit to put those contents in the leaves of a Merkel tree. And now I have a way to commit to a whole bunch of data with just a very small commitment. So in the context of a polynomial commitment scheme, what we're doing is we're committing evaluations of polynomials. So we use a Merkel based polynomial commitment scheme, and we sort of pre agree the leaf contents are going to be, we're going to put, like, f of zero, f of one, f of two, f of three, f of four in the leaf contents.
00:19:11.360 - 00:19:33.340, Speaker A: And then we'll merkel hash that to a single merkel root, and we'll send that along. And then at some point later on, the verifier is going to say, oh, I'm interested in f of seven. And we can reveal the leaf associated with f of seven, and we can provide a Merkel branch to connect the merkel root to that merkel leaf.
00:19:36.440 - 00:19:43.236, Speaker B: Cool. Little fuzzy. Yeah, go ahead, kai. Questions are good.
00:19:43.338 - 00:19:51.530, Speaker C: So you would do this without revealing the other leaves contents by showing the hash of the other leaves, and then do that all the way up to the root? Is that how it works?
00:19:52.060 - 00:20:27.168, Speaker A: So in the initial commitment, all I send is the top of the tree. And then when I want to reveal f of seven, I need to reveal sort of the neighbors up the tree. So I would reveal f of seven itself. I would say, I claim that f of seven is 23. And then in order to convince you that that actually matches with the Merkel route that I sent earlier, I would provide a branch. And that branch doesn't need to include any other evaluations. It just needs to include a bunch.
00:20:27.184 - 00:20:34.592, Speaker B: Of hashes that connect the bottom to the top fuzzy.
00:20:34.656 - 00:20:45.076, Speaker C: Still no each of the leafs values. If you could brute force it such that you could find the hashes, maybe that matters, but in general, it doesn't.
00:20:45.268 - 00:20:45.672, Speaker B: Yeah.
00:20:45.726 - 00:21:00.350, Speaker A: And this sort of gets into the details of whether the commitment is hiding or not. We are not actually concerned about.
00:21:00.880 - 00:21:02.510, Speaker B: How do I want to put this?
00:21:08.000 - 00:22:00.700, Speaker A: We are not providing enough information for the verifier to be able to brute force anything interesting, I guess, is the short of it. The scheme that I just described is in some sense not hiding because of the brute force thing that you're getting at here. And we sort of handle the concealing information at a slightly different part of the protocol here. So it's okay if the verifier is able to sort of guess a single value of the thing that we commit to, because the thing that we commit to is not exactly the secret. I think I'll have to do a separate study club to make that a little bit less hand wavy.
00:22:01.360 - 00:22:03.230, Speaker B: Thank you. Yeah.
00:22:04.400 - 00:22:38.330, Speaker A: Okay, so that's the review that I'm going to do on the idea of commitment schemes and polynomial commitment schemes. And we're going to talk more about Merkel based commitment schemes a little bit later. But I want to now transition to the algebra two part of the presentation. And this really gets to the heart of why do I keep seeing quotients every time I try to look at a ZK protocol? Why is it that some point or another, there's a quotient built in?
00:22:39.980 - 00:22:40.730, Speaker B: So.
00:22:42.460 - 00:23:21.300, Speaker A: Let'S just chat for a second about facts about polynomials, and these are facts about polynomials that are true, whether we're talking about finite field polynomials, or your sort of familiar polynomials that you saw in high school. So if we're looking at some polynomial and we know that it has a zero, there's some point that when I evaluate f of three, I get zero. There's an important thing that we're able to do with polynomials when we know where their zeros are. And that thing is factoring.
00:23:21.800 - 00:23:22.550, Speaker B: So.
00:23:24.380 - 00:24:17.210, Speaker A: This is sort of the key result that if you understand finite fields and you understand this fact, a lot of the sort of opaqueness of ZK protocols starts to feel a lot more clear. So let me make this a little bit more concrete with an example here. So here is a polynomial that if you plug in three, you get 27 -15 minus twelve, you do get zero. And I can factor this polynomial like this. I'll sort of not go through the oil to confirm that this is actually a valid factoring here. But you can check the details yourself. If you multiply this polynomial out, you'll get exactly x cubed minus five, x minus twelve.
00:24:18.540 - 00:24:21.016, Speaker B: So what that means is that I.
00:24:21.038 - 00:24:23.524, Speaker A: Can divide both sides by x minus.
00:24:23.572 - 00:24:28.616, Speaker B: Three, and I don't get like the.
00:24:28.638 - 00:24:34.956, Speaker A: The quotient on the right hand side cancels out. I get a lower degree polynomial on the right hand side than the one.
00:24:34.978 - 00:24:41.424, Speaker B: That I started with. And this will happen precisely when the.
00:24:41.462 - 00:24:45.330, Speaker A: Polynomial sort of evaluates to zero at the point in question.
00:24:47.780 - 00:24:48.530, Speaker B: So.
00:24:51.240 - 00:25:05.656, Speaker A: This is, I should pause, I guess, any questions? Confusion about this. I have this term here, rational function.
00:25:05.758 - 00:25:08.424, Speaker B: At the bottom of the screen here.
00:25:08.462 - 00:25:46.530, Speaker A: And this is just the term refers to a ratio of two functions. And the idea here is rational functions are sort of not so nicely behaved. Low degree polynomials are quite nicely behaved. And if I try to divide by x minus three, but f doesn't evaluate to zero at that location, then instead of getting this sort of nice polynomial with a lower degree than what I started with, instead I get a rational function. So we've seen our first quotient.
00:25:46.690 - 00:26:18.270, Speaker E: I have a question about the last example there. When you divide by x minus three, so we have x squared plus three, x plus four. But isn't this kind of like constrained because we're dividing by x minus three, so technically something happens at three, we have x squared plus three, x plus four. Are there any details that we should be aware of about this new polynomial?
00:26:19.730 - 00:26:22.340, Speaker A: Yeah, that's a good point. There is a.
00:26:23.590 - 00:26:24.340, Speaker B: So.
00:26:26.070 - 00:27:05.790, Speaker A: As formal polynomials, the division works out cleanly. We should be careful about using an equal sign here. Precisely. If we're talking specifically about the value where x equals three. And for the sake of kind of trying to present this in a way that is intuitive and accessible, I'm going to reasonably frequently be somewhat hand wavy about some of those. If we were going to write formal proofs, we have to be more careful than I'm doing in these slides.
00:27:06.690 - 00:27:07.440, Speaker B: Okay.
00:27:10.330 - 00:27:12.454, Speaker A: There'S a question in chat, it looks like.
00:27:12.492 - 00:27:14.538, Speaker B: Also, I can't see it because I.
00:27:14.544 - 00:27:15.610, Speaker A: Don'T have a mouse.
00:27:16.350 - 00:27:21.702, Speaker E: It's a comment saying, I've missed polynomial math. Good to see it come up more in crypto conversations.
00:27:21.766 - 00:28:08.874, Speaker A: Like, it's fun. So I used to be a high school math teacher, and I have taught polynomial division to a bunch of 13 1415 year olds. And the question inevitably is like, why would I ever care about polynomial division? And until this job, I had no good answer for that question. The answer was like, oh, it's just on the test. But I'm shocked that at this point, I have a job where largely what I do is think about polynomial division, by far the most applications I've seen for polynomial division in my life. Okay, let's look at a slightly more complicated example that's almost exactly the same here.
00:28:08.992 - 00:28:15.886, Speaker B: Instead of f evaluating to zero, I want to ask, what about if f.
00:28:15.908 - 00:29:08.540, Speaker A: Evaluates to five at this specific point? So I've contrived an example here. It's very similar to the last example. I just sort of altered one of the terms in order to. But you can confirm that if you plug in three here, you get 27 -15 minus seven, which will be five, and we get a nice, clean quotient out of this as well. In particular, if I subtract five from both sides, then I can factor it just as I did before. And similarly, if this evaluation wasn't the value that we were interested in, then this won't be a polynomial. It will be this slightly uglier type of function, a rational function.
00:29:12.020 - 00:29:15.760, Speaker B: Okay, so let's try to put this.
00:29:15.830 - 00:29:21.036, Speaker A: Into action a little bit. Let's say that I've made a commitment.
00:29:21.068 - 00:29:25.140, Speaker B: To some polynomial f, and I'm interested.
00:29:25.210 - 00:29:33.780, Speaker A: In convincing someone that this polynomial has zeros in these particular places.
00:29:34.680 - 00:29:36.456, Speaker B: So f of one equals zero, f.
00:29:36.478 - 00:29:53.724, Speaker A: Of two equals zero, f of three equals zero, and f of four equals zero. I could just reveal the associated leaves. If it's a Merkel based commitment, I could just say, okay, yeah, I'll just show you the leaf for f of one and the leaf for f of two, or the leaf for f of three.
00:29:53.842 - 00:29:58.844, Speaker B: Well, and I should say, but I.
00:29:58.882 - 00:31:11.436, Speaker A: Can do this sort of clever thing. Instead, these constraints will hold if and only if this quotient kind of works out cleanly, meaning if and only if I can factor out those exact terms from the numerator and have them cancel. So this is really the crux of the presentation today is I can enforce constraints by constructing a quotient where the denominator sort of specifies where I'm interested in enforcing these constraints. In the previous slide I listed this as one, two, three, and four. On this slide I've just made a slight change. We don't handle our indexing in these protocols, typically in a sort of like standard counting way. Instead, we choose some omega, some root.
00:31:11.468 - 00:31:14.016, Speaker B: Of unity in a finite field, and.
00:31:14.038 - 00:31:57.440, Speaker A: We look at hours of that root of unity as our indexing set. So this is if those words are unclear. We have study club videos for that, where we unpack the idea of finite fields and generators in this context. But this is the exact same sort of assertion as before. We've just changed where we're changed how we've identified the points that we're interested in. So I think we're now ready to see sort of a very brief presentation of what happens. In a stark protocol.
00:32:00.100 - 00:32:06.512, Speaker B: The prover generates some execution trace, and inside this step.
00:32:06.566 - 00:33:11.032, Speaker A: We'Re also doing the read Solomon expansion. But the prover makes a commitment to some polynomials f that sort of encode here's the execution trace for my computation, and there are some constraints that describe like, well, what does it mean for that trace to be valid? This execution trace is valid, meaning it follows the rules of the instruction set architecture and sort of is specified to the binary file. If these constraints, which I'm not going to list all of the constraints, there's something like somewhere between 1010 thousand constraints in our system, I guess. But the idea is that the constraints should evaluate to zero at each of the relevant points, and so the prover can justify the assertion that the trace satisfies the constraints by showing that this.
00:33:11.086 - 00:33:15.000, Speaker B: Quotient is a low degree polynomial.
00:33:17.750 - 00:33:28.150, Speaker A: So very similar to the slide to the previous slide, except here instead of just f of x in the numerator, we have the constraints applied to f of x in the numerator.
00:33:33.300 - 00:33:38.976, Speaker B: So I will echo a comment that.
00:33:38.998 - 00:34:26.644, Speaker A: Victor made a couple of weeks ago in his presentation about multiplication methods. I don't expect, especially if this is like a first viewing for these ideas. I don't expect for this to all be super clear, I'm hoping that this presentation is helpful in generating some intuition so that when you're looking at resources in the future, there's a little bit more of an ability to connect the dots between what you're looking at. But if you're looking at this and feeling sort of overwhelmed and confused, it's overwhelming and confusing the first handful of times you encounter it. So don't stress about, okay, oh, those.
00:34:26.682 - 00:34:28.310, Speaker B: Arrows aren't supposed to be there.
00:34:29.000 - 00:34:31.556, Speaker A: So we just saw Starks in a.
00:34:31.578 - 00:34:34.984, Speaker B: Nutshell, and we're at this point, like.
00:34:35.022 - 00:35:20.036, Speaker A: Reasonably far through our roadmap. We've done the review of polynomial commitments. We've done the review of polynomial algebra, and I'm starting to sort of show you some quotients in context. And I said that I was going to show you quotients in the context of Starks, quotients in the context of deep, and quotients in the context of KZG. So this was the quotients in the context of Starks. I want to dive into this degree extension for the elimination of pretenders idea. So let's imagine that we've committed to some polynomial, and we would like to convince someone that this polynomial evaluates to two at the value of five.
00:35:20.036 - 00:36:12.440, Speaker A: So f of five equals two. The basic option here would be, if there's a leaf for f of five, just show the leaf in the Merkel tree that's associated with f of five, and show the branch that's associated with that leaf, and we're done. But there is this sort of clever alternative option called deep. And the premise here is, instead of just providing an opening proof, instead of just providing the Merkel branch, we can construct a second polynomial. And this is exactly the sort of quotienting technique that I showed you earlier. It's referred to as quotienting in the deep fry paper. So the minus two and minus five is exactly the idea from earlier.
00:36:12.440 - 00:37:11.896, Speaker A: And the key idea here is that if f of five does not actually equal to, then the result of this quotient will not actually be a polynomial. So rather than providing a Merkel branch to justify this assertion, if the prover can convince the verifier that the original thing and the result are both polynomials, then they can make a convincing argument about the value f of five without providing a Merkel branch. Why should I care? The point is that this works for values that aren't in the original Merkel tree. So if the prover constructs a Merkel tree with, say, all the evaluations from f of one up to f of a million, but then wants to make.
00:37:11.918 - 00:37:15.980, Speaker B: A proof about f of 10 billion.
00:37:16.720 - 00:37:46.710, Speaker A: The option one here doesn't work. Option one is limited to the number of leafs in your commitment. That's all you can make proofs about. So this deep technique allows you to make arguments about the polynomial that are not associated with the domain of the Merkel tree. And this is valuable because.
00:37:50.440 - 00:37:51.044, Speaker B: We'Re making.
00:37:51.082 - 00:38:15.804, Speaker A: These sort of probabilistic queries in these protocols. And the denominator of those probabilistic queries can be a lot bigger if we use this deep technique. So, in particular, if we limit ourselves to the original Merkel tree, then we only have a denominator the size of the original Merkel tree. Whereas if we don't, then we have a denominator that can be the size.
00:38:15.842 - 00:38:17.996, Speaker B: Of the whole field or an extension.
00:38:18.028 - 00:38:39.216, Speaker A: Of that field, even. And the disadvantage is that you have to do an extra round of interaction. The prover has to actually construct another polynomial. And we have to make a commitment to that second polynomial. And instead of just having to do a fry proof about the first polynomial, now we have to do a fry.
00:38:39.248 - 00:38:49.096, Speaker B: Proof about both of these polynomials. So this deep technique appears in a.
00:38:49.118 - 00:39:16.690, Speaker A: Couple of places in the literature. The deep fry paper is when it was first, sort of announced, discovered, released. I don't know one of these words for what happens when people release cryptographic ideas. And there's a protocol called deep Ali and a protocol called deep fry. And each of these is a way.
00:39:17.620 - 00:39:21.216, Speaker B: There's an Ali protocol and a deep AlI protocol.
00:39:21.328 - 00:39:59.120, Speaker A: And there's a fry protocol, and there's a deep fry protocol. And in each case, switching to the deep version costs an extra round of interaction. And gives you the ability to query outside the original commitment domain. So, in practice, we use deep Ali, but not deep fry. Because the proximity gaps paper shows that deep fry doesn't actually provide any advantage over the original fry.
00:40:01.220 - 00:40:02.236, Speaker B: That's deep.
00:40:02.268 - 00:40:03.360, Speaker A: In a Nutshell.
00:40:06.740 - 00:40:09.920, Speaker B: This idea is very subtle.
00:40:10.340 - 00:40:21.910, Speaker A: And again, I'll echo that comment before of, if this feels confusing, treat it as a first exposure. That will become clearer and clearer as you encounter the idea more times.
00:40:24.460 - 00:40:25.930, Speaker B: Questions. At this point.
00:40:30.620 - 00:40:56.880, Speaker D: I have kind of a broad question for this session. If it's possible to make this comparison. How would the flow that you're describing work differently if you were working within an EVM rather than the risk zero vm?
00:40:58.100 - 00:41:10.756, Speaker A: The EVM versus Zkvm is going to be, I think, completely immaterial here. The question of EVM versus EkvM is.
00:41:10.778 - 00:41:14.776, Speaker B: A question of how many columns are.
00:41:14.798 - 00:41:28.008, Speaker A: You using and what are those columns representing? But you can do a stark that uses deep Ali and or deep fry.
00:41:28.104 - 00:41:35.150, Speaker B: In an EVM context or a VM context. So I guess.
00:41:37.760 - 00:42:06.200, Speaker A: The plonky two approach to zke evms uses roughly, almost exactly this approach, whereas the polygon Hermes and scroll approaches to zke EVM don't use this approach. But it's possible to use this approach or not use this approach in either a ZkeVm context or a ZkvM context.
00:42:08.460 - 00:42:09.016, Speaker B: Cool.
00:42:09.118 - 00:42:10.010, Speaker D: Got it.
00:42:12.620 - 00:42:25.914, Speaker B: Any other questions for now? Okay, so this is an excerpt from.
00:42:26.112 - 00:43:08.680, Speaker A: The white paper that we released recently, and I just wanted to sort of highlight in context where quotients actually appear in our specific protocol. So we use two quotients in the risk zero zkp protocol, and they're exactly the two quotients that I just sort of introduced. The first one is a quotient to enforce that certain things equal zero in the places we want them to. And the second quotient is this deep quotient. So I highlighted in yellow here.
00:43:11.550 - 00:43:11.914, Speaker B: We.
00:43:11.952 - 00:43:26.240, Speaker A: Note that this bold face c is a polynomial of unknown degree. And then on the second line of the yellow here, it says c at some specific points equals zero.
00:43:26.850 - 00:43:32.526, Speaker B: And that is exactly the analogous to.
00:43:32.548 - 00:44:01.186, Speaker A: The slide a few slides ago where I said, well, what if f of omega to the zero equals zero and f of omega to the one equals zero and f of omega to the two equals zero? And it says, we divide the result here by a zeros block, which is exactly that. X minus omega to the zero times x minus omega to the one times x minus omega to the two. So this is the vanishing polynomial over that domain.
00:44:01.298 - 00:44:05.178, Speaker B: So some technical language here, I'm not.
00:44:05.184 - 00:44:07.180, Speaker A: Going to get too caught up here.
00:44:07.550 - 00:44:10.026, Speaker B: You can certainly take a look at.
00:44:10.048 - 00:44:14.094, Speaker A: The paper, and if you have questions at the moment, I'm happy to take them, but I want to just sort.
00:44:14.132 - 00:44:17.322, Speaker B: Of give a nod to the formal.
00:44:17.386 - 00:44:57.150, Speaker A: Technical stuff rather than getting too wrapped up in it. And the second place that we use quotients is this deep technique. And I'm going to not try to unpack the technical language on this slide, but I will sort of point out the denominator in this quotient hopefully looks somewhat familiar if you replace those x sub one through x sub n with the points that we're interested in making assertions about.
00:44:57.600 - 00:45:10.074, Speaker B: This is the technique that we just looked at, so don't have a whole.
00:45:10.112 - 00:46:04.394, Speaker A: Lot more planned for today. In fact, I think this may be the last slide that I actually have in the presentation, and I'm not going to talk too much about KZG, both because it's not involved in our protocol at all and because I'm not an expert in KZG. But I just wanted to include this for those of you that might have more of a sort of exposure to KZG. This is a very similar technique to what we looked at earlier. And this is actually the way that in KZG, once you make the commitment to a polynomial, if you want to make an opening proof, meaning so you made a commitment to some polynomial. Now I'm interested in proving a particular evaluation of that polynomial. The way that we do that is exactly the quotienting technique that we looked at earlier.
00:46:04.394 - 00:46:07.118, Speaker A: So this line goal f of u.
00:46:07.204 - 00:46:10.938, Speaker B: Equals v, you could replace that with.
00:46:10.964 - 00:46:20.450, Speaker A: The f of two equals five that we looked at a few slides ago, and the rest will be pretty much exactly equivalent to the remainder of that slide.
00:46:24.570 - 00:46:27.240, Speaker B: So thanks for coming.
00:46:27.690 - 00:46:31.990, Speaker A: I hope this felt useful. I imagine it also felt somewhat.
00:46:33.770 - 00:46:34.086, Speaker B: If.
00:46:34.108 - 00:46:41.580, Speaker A: It didn't feel confusing, I think I'm very surprised. It's a confusing topic that.
00:46:44.910 - 00:46:45.434, Speaker B: It has.
00:46:45.472 - 00:46:59.150, Speaker A: Taken me a number of months to fully wrap my head around. Well, to wrap my head around these ideas, to the point that I have currently wrapped my head around these ideas, which is not quite fully. I think I still have some learning.
00:46:59.220 - 00:47:02.586, Speaker B: To do in terms of fully connecting.
00:47:02.618 - 00:47:03.454, Speaker A: All the dots here.
00:47:03.492 - 00:47:04.080, Speaker B: But.
00:47:05.830 - 00:47:30.282, Speaker A: I'll open things up for questions and discussion, either about the specifics here or more broadly about whatever you want to sort of ask about with respect to risk zero. And I'll post the recording to YouTube probably by the end of today, and the slides will be up in the description there. I'll go ahead and close my screen.
00:47:30.336 - 00:47:33.660, Speaker B: Share and we can just chat for a little bit.
00:47:42.110 - 00:47:53.662, Speaker F: Yeah, I have one question. Basically, earlier, we are basically saying that rational functions are kind of not polynomials, although in.
00:47:53.796 - 00:47:54.574, Speaker B: Right.
00:47:54.772 - 00:48:16.130, Speaker F: And I guess the question I have is, I say to what extent? I guess there is probably a specially, especially over finite, at least over finite domains. First of all, over infinite domains. Is that more true? Is it basically rational functions are not polynomials over infinite domains like the reals?
00:48:16.290 - 00:48:17.670, Speaker B: Is that fair to say?
00:48:17.820 - 00:48:33.310, Speaker A: Yeah. So, Victor, getting at a sort of important nuance about the difference between finite field polynomials and polynomials from algebra two. In the finite field context.
00:48:35.010 - 00:48:35.918, Speaker B: Any function.
00:48:36.004 - 00:48:59.382, Speaker A: Can be thought of as a polynomial in the finite field context. And so where I'm using the term isn't a polynomial or is a polynomial, it would be more precise to say is a low degree polynomial in the infinite domain context. If you look at something like one.
00:48:59.436 - 00:49:04.658, Speaker B: Over x, it's just not a polynomial.
00:49:04.834 - 00:49:07.510, Speaker A: Whereas in the finite field version.
00:49:10.430 - 00:49:10.890, Speaker B: You.
00:49:10.960 - 00:49:16.170, Speaker A: Could rewrite it as a very high degree polynomial with a restricted domain.
00:49:18.030 - 00:49:21.100, Speaker B: So, yeah.
00:49:22.850 - 00:49:24.366, Speaker A: The more precise version would.
00:49:24.388 - 00:49:28.880, Speaker B: Be to say, when I divide by.
00:49:29.250 - 00:49:31.546, Speaker A: This x minus five or whatever I'm.
00:49:31.578 - 00:49:35.022, Speaker B: Dividing by, I would like my result.
00:49:35.076 - 00:49:41.010, Speaker A: To be a lower degree polynomial than what I started with, rather than just a polynomial.
00:49:42.950 - 00:49:45.442, Speaker B: I don't know that I answered your question. Yeah.
00:49:45.496 - 00:49:47.940, Speaker F: Well, I'll set a follow up with that.
00:49:50.390 - 00:49:51.140, Speaker B: What.
00:49:53.830 - 00:50:21.006, Speaker F: I guess, how do people estimate the degree, or bound the degree, or basically have a probability over the degree of the resulting approximation equivalent polynomial in a finite domain from a rational function? I guess if you divide by some random thing, that's not a divisor. Basically. I generally see people assume that you get a high degree thing, but I've never seen anybody analyze how high of.
00:50:21.028 - 00:50:22.160, Speaker A: A degree it is.
00:50:23.170 - 00:50:39.774, Speaker B: Seems important. You're muted. I'm muted.
00:50:39.822 - 00:50:52.694, Speaker A: Thank you. Yeah, I guess I haven't thought about that question before. I have been just sort of working.
00:50:52.732 - 00:50:56.934, Speaker B: Under an assumption that it is going.
00:50:56.972 - 00:51:14.854, Speaker A: To be very high degree. Very high degree, meaning almost as high degree as the field that you're working over. But now that you mention it, I think that I have just been sort of working under that assumption and don't.
00:51:14.902 - 00:51:22.654, Speaker B: Have a strong grounding in it. I wonder whether it is possible to construct a quotient in this sort of.
00:51:22.692 - 00:51:25.630, Speaker A: Way that isn't that high degree.
00:51:29.870 - 00:51:30.246, Speaker B: A.
00:51:30.288 - 00:51:35.200, Speaker A: Question to think about offline, unless anybody has some more insight to add to that question.
00:51:48.120 - 00:51:51.300, Speaker B: Other things on people's minds.
00:51:53.080 - 00:51:55.830, Speaker A: Yeah, go ahead.
00:51:59.310 - 00:52:00.490, Speaker B: Go ahead, Steve.
00:52:01.470 - 00:52:51.590, Speaker G: I think mine might be less related to the mathematics, although as I said, I'm actually very pumped about it. I'm a dev, but I just don't hear about the math side from what I should. But anyways, yeah, so I was fortunate enough to meet some of the Risero team in E Denver and Kay, as well as Ramit. I can't remember the name right now, but anyways, and I was just curious about, am I understanding it correctly? I'm looking at using like, roll kit, I don't know if you've heard of it, with Celestia. So basically they can create sdks with different, basically blockchain software like components such that people can create new roll ups on top of different settlement layers or what have you, or vice versa.
00:52:51.670 - 00:52:53.270, Speaker A: Data availability layers.
00:52:53.430 - 00:53:50.090, Speaker G: So roll kit recently, it's honestly like a shit post that just went viral, but created a roll up on bitcoin for funsies, essentially. And I wanted to just kind of get my hands dirty with risk zero and kind of see if I could create like a risk zero SDK. So I guess I'm picturing it with the DKvM risk zero package everything and then have it instead of. Because I know that. I thought I read somewhere that you guys are looking at settling on top of on tendermint with cosmos chains as well as the EVM. But I was curious if I could do it with roll kit and make an SDK that settles on top of celestia. So I don't know, I guess I'm just kind of like throwing it out there to say, am I crazy? Am I understanding risk zero and what it offers to me, it's like the execution layer that you could have then plug into any settlement layer.
00:53:50.090 - 00:53:53.840, Speaker G: But I don't know if that's true or not. Did that make sense?
00:53:56.610 - 00:54:04.500, Speaker A: Yeah, that roughly made sense. I don't know that I'm the best equipped to answer that question. Maybe there's somebody else on the call who feels like they can comment on that.
00:54:05.030 - 00:54:06.226, Speaker B: Yeah, sure.
00:54:06.408 - 00:54:07.860, Speaker F: That definitely is not crazy.
00:54:08.630 - 00:54:08.994, Speaker B: Yeah.
00:54:09.032 - 00:54:30.994, Speaker F: Risk zero is definitely an execution environment. It's a provable execution environment. And so basically you get all the ZK roll up properties with some work. And so basically it's definitely a very suitable execution environment for use in this kind of context.
00:54:31.122 - 00:54:35.500, Speaker B: That is definitely not a crazy idea at all. Nice.
00:54:35.950 - 00:54:55.374, Speaker G: Yeah. Like I said, I've talked to Kay in person a number of times. Someone else there, but if there's other people I can chat with, run the receiver team, that'd be great. Just because I know everyone's busy. I'm just trying to get into the community and build. I'm a smart contract dev, but I just want to get my feet wet or whatever with.
00:54:55.572 - 00:54:56.178, Speaker B: Yeah, yeah.
00:54:56.264 - 00:55:01.762, Speaker F: A lot of us are devs and interested in math. So you're not a dev, but interested in math. I think you're a dev.
00:55:01.816 - 00:55:02.420, Speaker B: And.
00:55:04.410 - 00:55:07.480, Speaker A: Steve, are you involved on the discord at all yet?
00:55:09.530 - 00:55:15.640, Speaker G: I joined. Honestly, discord and Telegram is overwhelming, but yeah, I'm in there.
00:55:16.170 - 00:55:16.918, Speaker B: Cool.
00:55:17.084 - 00:55:44.980, Speaker A: Yeah, the discord Q a stuff is pretty active and we're reasonably quick to respond. So if you want to articulate your roadblocks as you're diving into that in discord questions would probably be the easiest way to connect. Although I think that if you want to Kay, I think, would be happy to schedule a call with you if that's something that would be useful for you as well.
00:55:46.070 - 00:55:46.690, Speaker B: For sure.
00:55:46.760 - 00:55:55.782, Speaker G: Yeah, I'm chatting with people from roll, kit and Celeste. As I kind of do it, my plan was to go through the tutorials. All right, thanks, everyone. Sorry, I don't want to monopolize time.
00:55:55.836 - 00:56:01.046, Speaker B: No, thanks, Steve. I think Eric also had a question. Yeah.
00:56:01.228 - 00:56:30.474, Speaker E: So from this presentation, you're talking about the polynomials from the execution trace and whatnot, and we divide that by the constraint polynomials or the constraints as the divisor. What happens if the divisor degree gets really big?
00:56:30.612 - 00:56:31.540, Speaker B: For example.
00:56:33.750 - 00:56:41.490, Speaker E: What could happen if that degree is higher than the top of the fraction?
00:56:44.760 - 00:56:46.628, Speaker B: You're muted. Yes.
00:56:46.714 - 00:57:29.440, Speaker A: Unmute first. So the degree of the denominator is very well understood. It's not a sort of like the highest. Let me first clarify. We're not dividing by the constraints so much as dividing by where we want the constraints to be satisfied. And we have a clear understanding of where we want the constraints to be satisfied. So there's no sort of unexpected behavior here with respect to these degrees.
00:57:29.440 - 00:57:33.570, Speaker A: I can be a little more specific.
00:57:34.440 - 00:57:35.190, Speaker B: On.
00:57:37.800 - 00:57:53.960, Speaker A: The numerics there. Let me bring my slides back up to do that, I guess. And if people need to run, feel free to run. But I'm still available for a little bit, so I'll stay on to answer questions as they appear.
00:57:56.540 - 00:58:16.448, Speaker B: So let me go to this slide here. So, in the numerator here, we have this polynomial f of x, which the degree of that polynomial is going to.
00:58:16.454 - 00:59:05.772, Speaker A: Be the same as the length of the execution trace. And then we compose that with the constraints. And the maximum degree constraint that we deal with is degree five, which makes the numerator here have a degree that's going to be five times the length of the trace. So the numerator here is five times the length of the trace, or the degree of the numerator is five times the length of the trace. And the degree of the denominator is exactly the length of the trace. And so this quotient here should have a degree four times the length of the trace.
00:59:05.836 - 00:59:11.984, Speaker B: And that's sort of fixed in our system. Yeah.
00:59:12.102 - 00:59:13.570, Speaker A: Does that answer your question?
00:59:13.880 - 00:59:14.870, Speaker E: Think so.
00:59:16.600 - 00:59:17.540, Speaker B: Meaning?
00:59:18.040 - 00:59:49.740, Speaker E: I'm just thinking about circuit development. So when we're writing our circuit definitions, we have all these Eqz, which represent the polynomial. And so the more we write Those, the more the denominator gets BIGGER, is what I'm assuming. Are we multiplying all of those constraints together? We should be mindful about WRiting constraints.
00:59:53.140 - 00:59:59.424, Speaker A: Yeah, it's a good question. If the constraints get more and more.
00:59:59.462 - 01:00:05.460, Speaker B: Complex, the degree of the numerator here will become larger.
01:00:07.480 - 01:00:24.436, Speaker A: We're not dividing by the constraints, we're dividing by the places where we want the constraints to be satisfied. And that's not going to change as we change the constraints. We want the constraints to be satisfied at every value that corresponds to the original execution trace.
01:00:24.468 - 01:00:27.956, Speaker B: So the denominator here on the slide.
01:00:27.988 - 01:00:40.910, Speaker A: That I'm showing right now, regardless of the complexity of the constraints, our denominator is going to look exactly the same as it looks on this slide. I see what will change, THOUGH, is the DegreE of the numerator here.
01:00:41.380 - 01:00:42.130, Speaker B: Okay.
01:00:43.300 - 01:01:40.876, Speaker A: And I unpack this. Well, it's quite a succinct description of this, but I do kind of reference. There's this five that appears in this yellow block here, and that five is referring to the maximum degree of the constraints and the curly d of omega here. That's the length of the execution trace. And I didn't talk about this at all in the presentation today. I will talk about it a little bit in next study club. I think after we do this quotient, we do this splitting technique, and if the degree of the constraints is higher, then we'll have to split it into more pieces.
01:01:40.876 - 01:01:47.220, Speaker A: So there is some cost, certainly, of adding more complexity to the constraints.
01:01:50.760 - 01:01:51.510, Speaker B: Yeah.
01:01:54.600 - 01:02:08.650, Speaker F: If I understand correctly as well, because we're using air, which is a type of constraint system, each time you add a constraint, it creates a new polynomial, is that correct?
01:02:10.000 - 01:02:25.680, Speaker A: Every constraint will have a polynomial associated with it, but those get condensed into a single polynomial before we do the quotient.
01:02:26.740 - 01:02:27.490, Speaker B: Right.
01:02:27.940 - 01:02:30.652, Speaker A: There is a cost to some degree.
01:02:30.716 - 01:02:36.004, Speaker B: In terms of both the number of.
01:02:36.042 - 01:02:50.040, Speaker A: Constraints adds a little bit of cost in terms of actually generating those columns. And the degree of those constraints adds a little bit of cost in terms of the complexity of the split operation that follows.
01:02:51.820 - 01:02:52.570, Speaker B: Right.
01:02:53.100 - 01:03:13.056, Speaker F: And so earlier, when Eric, when you were asking about the EQC, like adding eqcs, which basically is within our circuit language, that's EQC is how we create and add a new constraint. Then basically each EQZ adds a new constraint, but basically the constraint within each easy has a max degree, which in.
01:03:13.078 - 01:03:14.128, Speaker B: Our case is five.
01:03:14.294 - 01:03:15.010, Speaker A: Okay.
01:03:16.420 - 01:03:23.312, Speaker B: Right. Awesome.
01:03:23.446 - 01:03:29.430, Speaker E: I guess for those of you who are not familiar with some of these constraints, they can be things like.
01:03:31.240 - 01:03:31.652, Speaker B: A.
01:03:31.706 - 01:03:45.670, Speaker E: Bit is either a zero or a one, and we can have polynomial expressions for that. So those are some of the risk five specific constraints. But you can imagine that for other circuits it could be anything.
01:03:48.600 - 01:03:50.110, Speaker B: You it.
01:03:54.560 - 01:03:59.772, Speaker A: Thanks for the questions. Anyone else have anything on their mind.
01:03:59.826 - 01:04:02.316, Speaker B: That they want to chat about while.
01:04:02.338 - 01:04:03.050, Speaker A: We have a group here.
