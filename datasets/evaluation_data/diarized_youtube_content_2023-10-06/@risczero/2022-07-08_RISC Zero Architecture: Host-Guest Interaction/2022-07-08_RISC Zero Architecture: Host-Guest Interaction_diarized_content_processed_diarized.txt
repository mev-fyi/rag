00:00:00.170 - 00:00:30.022, Speaker A: I want to talk a little bit about how we do the interaction between the actual ZKVM, which we call the guest, in sort of standard virtual machine kind of terms, and the sort of prover, which is the host from a sort of a normal term. So let's say we want to have the guest send something to the host. Well, the guest just writes to an address that is a particular, well known address. And host is like, oh yeah, I see you right there. Right. Because obviously it's just running an emulation. The host can see the whole world.
00:00:30.022 - 00:01:13.438, Speaker A: So trivial. On the other hand, if we want to get something from the host to the guest, then the guest reads, there's a region of memory that we set aside for host to guest communications. And the guest keeps track of a pointer, and it keeps bumping that pointer and reading the next address. And as it reads those addresses, since those addresses have never been written to before, they're uninitialized. Any value is allowed to be returned. And so, right when that address is read, at that moment, the host will decide what it would like the guest to read and places that in there. We use this to basically generate what is effectively sort of a private two way stream, which we actually currently we have sort of our own sort of read and write calls.
00:01:13.438 - 00:01:50.110, Speaker A: But we're actually going to move that inside of lib C so that they'll actually be like real things that look like file descriptors that you can read and write to, to talk to the host of the guest and things like that. And then we're going to also implement a number of other sort of systems on top of that. I probably won't go into detail, but if you're anyone's interested in how we can build something that looks like a file system inside of a zero knowledge proof system, we do actually have a plan for that. Even so, I don't think. Do I talk about. No, I didn't get the slide. Yeah, I think that's it.
00:01:50.110 - 00:02:54.700, Speaker A: The only other thing I wanted to mention is it's not explicitly written here, but I think it's one interesting note on the model is that the other sort of interaction between the proof system and the outside world is this thing we call the journal. So basically, there's another region of memory that the guest writes to. And at the termination of the guest from the normal execution, we go into the Shaw accelerator circuit, where we shaw up that region, and that ends up coming onto the output of the proof. So effectively, basically, if you want to talk privately to the host, you can read and write to these sort of logical streams. And then there's also this other region that you can write things you want to be publicly known, and then those get basically emitted, and those become part of the public record. So when you provide a proof, you're basically showing what is the journal? What did this thing write to the journal? What is the code that this thing is running? And then a bunch of sort of opaque cryptographic goo that basically allows you to verify the correctness of that. So here we.
