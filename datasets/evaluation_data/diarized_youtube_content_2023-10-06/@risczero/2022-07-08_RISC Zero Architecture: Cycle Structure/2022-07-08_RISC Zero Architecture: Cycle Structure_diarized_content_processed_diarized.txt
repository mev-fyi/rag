00:00:00.490 - 00:01:17.418, Speaker A: The first thing I wanted to talk about is how we represent the program that the user passes us the Elf, and the loading of that within the proof system, as well as sort of the overall structure from a time perspective to how the processor itself works. So the notion here is that we divide. The starks are naturally sort of divided into cycles, and there's a repetitive sort of arithmetic circuit that relates each cycle to the previous cycle within the execution of a given program. In our system there's sort of this process by which initially there's a special initialization cycle that sort of resets the state. Then there's what we call the program load phase, wherein we're effectively loading the program data for the particular Elf into our emulated memory. And then we sort of do a reset which jumps the program counter to the beginning of the execution. And then basically the actual processor takes three cycles to execute each instruction, which is basically composed of instruction to code, and then a compute load phase and then a register update write to memory phase.
00:01:17.418 - 00:02:05.140, Speaker A: What's notable is that effectively we always have at most one memory transaction for each logical cycle, which is important to the way that we actually implement the memory system. That's right. Compile it down to risk five. Risk five, exactly. That's right, exactly. I think one of the great things about this is that by using this sort of mechanism, we then look like a normal computer to people, and people can reuse existing software. We're reusing a huge amount of the existing tool chain in terms of compilers and language support.
