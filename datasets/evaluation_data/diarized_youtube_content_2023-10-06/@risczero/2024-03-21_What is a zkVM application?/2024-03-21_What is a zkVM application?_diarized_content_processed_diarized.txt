00:00:01.690 - 00:01:04.962, Speaker A: Okay, let's dive into a little introduction of how to think about zkvm applications and how to start building zkvm applications. So the big picture view is that you're going to need to write an application for the risk zero ZKVM. You're going to need to generate proofs for that application and then assuming you're trying to do something with blockchains, you're going to need to integrate those proofs into on chain applications. And in this video, I want to dive into the first part here of how do we get started writing an application for the risk zero ZKVM. So if we click on this link from the getting started page, it's going to pop us down to the quick start. But before we dive into the quick start, I want to just rewind a little bit to consider the question of just like an overview of the ZKVM. And in particular I want to scroll down on the zkvm overview to this diagram here in order to sort of just contextualize the pieces of the system.
00:01:04.962 - 00:02:01.522, Speaker A: So the ZKBM lets you prove correct execution of rust code. So you're going to provide some rust code. The guest code is what's going to get proven and you're going to compile your guest code using the cargo risk zero tool into an Elf binary. This is like the RISC five format of binary files. So then you're going to run your RISC five binary in the ZKVM, which is essentially this box here. So the ZKVM is going to spit out a receipt and you're going to be able to use this receipt on chain to prove correct execution of your rust code. So inside the ZKVM there's some kind of implementation details that you don't really need to worry too much about at this point.
00:02:01.522 - 00:03:12.300, Speaker A: But just to sort of introduce you to the idea, the executor is going to produce. The executor is going to produce the execution trace, which is split into a bunch of segments. So the session is the entire record of your giant computation. Or maybe it's not a giant computation, but let's say that you're running some large computation in the ZKVM. The session is the full record of the complete computation and it's going to get split into segments, and then those segments are going to get proven and those proofs are going to get aggregated, and then you're going to end up with a single succinct snark that you can post and verify on chain. So that's the kind of overview to the ZKVM. The thing that you're going to need to focus on most in order to sort of successfully develop a zkvm application is the guest code, which in order to learn a little bit more about writing guest code, we could pop into this doc here.
00:03:12.300 - 00:04:12.814, Speaker A: So the guest functionality that you really need to focus on most is the guest needs to be able to read inputs. It needs to be able to, I guess I'll highlight here instead. Needs to be able to read inputs, needs to be able to write private outputs to the host, and it needs to be able to commit public outputs to the journal. So this is just for like during execution. Maybe there's some input output between the guest and the host. You're going to use the write functionality, and if you want to have something actually appear in the receipt, you're going to use the commit functionality. So there are some links here to some of the kind of most important functions that you're going to need to play with.
00:04:12.814 - 00:04:44.260, Speaker A: Each of these are going to point you to the rust crates for the associated functions here. And then we also provide here some tools for debugging and optimization. There's also a whole optimization section later on here, so I think that's enough for now. As a kind of orientation, we walked through the overview and the guest code. There are of course a couple of other docs here that you can take a look at yourself if you're interested in reading a little bit more. Thanks for watching.
