00:00:00.490 - 00:01:00.234, Speaker A: At a very sort of high level zoomed out view. The way that we produce this receipt that attests to computational integrity in our system is we have this zero knowledge virtual machine, and you execute some RISC five binary file inside our virtual machine. And the virtual machine records the execution trace, the sort of complete record of that binary file executing, and we get columns. When we do that, we then use read Solomon encoding on each of those columns. So right off the bat, we compute an execution trace, and then we encode it using read Solomon encoding. And this encoding turns our columns into blocks. Then we do a bunch of complicated math stuff to these blocks.
00:01:00.234 - 00:01:51.180, Speaker A: We evaluate some constraints, we compute some quotients, and after we do all that math stuff, we need to convince the verifier that the result of all that is still a valid Reed Solomon code word. And we use the fry protocol at the end in order to do that. So this is sort of a zoomed out view of the way our system works. We generate an execution trace in terms of columns. We encode those columns into read Solomon code words. We transform those code words in some way, and then if the result is actually a valid read Solomon encode word, it serves as an argument of computational integrity. So that's the sort of high level view.
