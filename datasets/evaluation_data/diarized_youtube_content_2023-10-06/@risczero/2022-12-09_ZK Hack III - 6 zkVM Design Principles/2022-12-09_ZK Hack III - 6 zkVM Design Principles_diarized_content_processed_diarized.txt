00:00:08.970 - 00:00:57.726, Speaker A: What are some design principles you want to take into account when we're writing code for a ZKVM? So, first of all, I want to mention that zero knowledge means zero extra knowledge. If you actually just don't commit anything to the journal, for example, and just hand someone the receipt, don't tell them anything, just hand them the receipt, all they're going to know is, I am holding a cryptographic proof that some code, I mean, they know the hash, but that's not very helpful. They know that some code was run. That's sort of it. That's not super useful. So what you actually do when you hand someone receipt is you put something in the journal, like, for example, the hash of the password, and you tell them what code was used and that.
00:00:57.748 - 00:00:59.390, Speaker B: They can check against the hash.
00:01:00.290 - 00:02:11.074, Speaker A: Zero knowledge, in practice, means zero extra knowledge. Everything you deliberately publish is secured, and everything you don't deliberately published, there's no information. And so when you're thinking about how to design these zero knowledge programs that you're going to be running in RCKVM, you want to think about what you want to secure and keep private and what you want to securely and provably publish. If you're doing it in the guest, it's going to be secure either way. But you want to know, is it securely public? Everyone can look at it, but there's a proof that it is what it is. Or do you want it to just be private if no information is shared about it? So things like secret information, your password, for example, in the previous example, secret information or other sort of internal data, you probably want to use the zero knowledge functionality and keep that private between the host and the guest. And conversely, things like hashes, so that you wouldn't know if I hadn't at the very end included the hash of the password.
00:02:11.074 - 00:02:14.006, Speaker A: Well, for one thing, the person I'm handing this to isn't going to know.
00:02:14.028 - 00:02:15.366, Speaker B: How to check my password in the.
00:02:15.388 - 00:02:31.866, Speaker A: Future, but they don't know if I'm switching things up. If you don't include a hash, you can just say, oh yeah, I totally have a password that includes a special character and just pass a special character string in and then use something else as your password. And there's nothing to verify because you.
00:02:31.888 - 00:02:32.970, Speaker B: Don'T have the hash of that.
00:02:33.040 - 00:02:43.554, Speaker A: So you often are including hashes of important data you're proving things about. Even if the data itself is private, the code is going to be securely published because you have that method id.
00:02:43.672 - 00:02:46.082, Speaker B: That hash that can be checked against.
00:02:46.136 - 00:03:30.106, Speaker A: The code and just public data in general, you tend to want to securely publish, so that's a design consideration. You also want to think about keeping the guest code relatively simple, because the risk drive architecture we're using is small, it's lightweight. As Jeremy mentioned earlier, you want to be treating it a bit like an embedded system. So don't put your UI in the guest. You want to separate the component that's producing data from the component that's rendering the data to your users, and that's often a good design pattern anyway. But you really want in the guest, you want what can be proven. And in the chess example, there's a string at the end representing the position of the chessboard.
00:03:30.106 - 00:04:13.722, Speaker A: And that string uses something called fen. It's a chess term, fen, which is a way of writing the state of a chess game. And that, I mean, maybe if you're good at chess, that's easy to read. I don't know, I do not find it easy to read. And so the chess library I'm using also has a rendering software that turns that into like pretty ascii art of the chessboard that's more readable, at least to me. So the fan, since you produce it in the guest, is going to be, that's enough information, like what you produce in the guest, that's the only stuff that will be secured. So you do need to secure whatever data actually needs to be proven that does need to go in the guest.
00:04:13.722 - 00:04:47.970, Speaker A: So producing the relevant data that's in the guest, but rendering it, well, as long as anyone can see that the rendering is a faithful rendition. Like, if you really want to check, you can go look at that fen and inspect it and be like, okay, this string really does match this prettily rendered chessboard. As long as you can do that, you really should be putting that UI in the host side. Also, this came up earlier. It's fine to panic in the guest. Panicking the guest does not panic the host. All your nice error handling for that panic goes in the host.
00:04:47.970 - 00:05:27.330, Speaker A: So you can simplify the guest code down and just terminate abruptly. If you're in a situation where if you're trying to prove something, you don't want to be able to prove, if you're in the, oh, I'm trying to factor this number using a one scenario or, oh, this password that I want to prove has special characters. It had no special characters. Just panic. Do your error handling over in the host side, and in general, be thinking about this sort of like an embedded system, right? There's limited memory, the RV 32 Im architecture we use does not have native float instructions. That doesn't mean you can't use floats, but it's not native float support, so they're pretty slow, those sort of considerations.
