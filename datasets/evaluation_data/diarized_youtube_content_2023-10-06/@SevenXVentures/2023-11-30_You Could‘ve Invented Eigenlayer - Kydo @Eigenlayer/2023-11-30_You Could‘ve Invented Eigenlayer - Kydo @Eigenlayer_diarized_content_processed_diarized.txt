00:00:00.330 - 00:00:09.786, Speaker A: Alright. Hello, everyone. I'm Kaido. I'm from Eggelayer. I'm a critical researcher. Today I'm going to talk about ikoro invented eggelayer. Just a quick disclaimer.
00:00:09.786 - 00:00:37.570, Speaker A: I'm a very fake researcher compared to everyone sitting here and I didn't get a memo. Today's title is research talk, and so mine's going to be pretty engineering focused and design one. So disclaimer ahead. So I'm a very fake researcher. Okay, first thing is the way you're going to reference this article or this slide is going to be, you could have been to eggon layer. Yci. YC.
00:00:37.650 - 00:00:38.290, Speaker B: YC.
00:00:38.370 - 00:01:08.734, Speaker A: YC. You're just going to call it the YC piece? I said I'm a fake researcher and the reason why it's going to be called the YC piece is I really hope once you understand what eggnogulayer is on a technical level and an implementation level, you can brainstorm a lot of new and brand new ideas. All right, so first the quiz. What is Eigen layer? Do you think it's a. Who's familiar with a? All right, perfect. Who's familiar with b? Oh, we have two. Very happy.
00:01:08.734 - 00:01:36.966, Speaker A: All right, so at the end you're going to see b and you're going to. Yeah, I understand it. Now, second layer, and I can explain from first principle, why does it design this way? So the goal is we're going to go through four steps. The first step is understand what is the problem. The second step is, okay, this is a problem. What are requirements we need to do to solve that problem? The third one is let's build out MVP given these requirements. Lastly, let's build a product on this MVP.
00:01:36.966 - 00:02:06.830, Speaker A: Right. Very, very clear and straightforward. So hopefully we can have time to finish everything. First is a problem statement. The problem statement can be summarized in this bootstrapping any decentralized infrastructure is difficult. Why is it, oh my God, I don't want to walk left or right so much. Why is it difficult? Because crypto aims to remove intermediaries and when not possible, that we have to be able to decentralize it in a way to increase the security and resilience.
00:02:06.830 - 00:02:33.502, Speaker A: Sometimes decentralization may not be the only way. Using a trusted execution environment and other techniques are also viable. So why is building a decentralized service is hard? The first thing is decentralized services always need consensus. And consensus is hard. Yeah, there's a lot of people here. I don't want to block it to you. Okay.
00:02:33.502 - 00:02:59.282, Speaker A: Consensus mechanism is hard. You have proof of authority, which is very similar to a multi sig. It's very centralized. We can move it to here a little bit more. You're good. Oh my God, this is perfect. It's pretty centralized.
00:02:59.282 - 00:03:31.082, Speaker A: The other way that people normally reach consensus among many different nodes is proof of work, but it's very wasteful. Energy, has good benefits. I'm not going to go into that. Lastly is where most people nowadays use to coordinate a large set of nodes is proof of stake. And the stake in the proof of stake part is the actual difficult part. And why is that? Because most of the time, stakes represent some kind of economic financial value. So basically you have a network.
00:03:31.082 - 00:04:13.526, Speaker A: You want someone to provide capital to contribute to security. So it's very difficult between the people who are developing these systems for generally engineers, really technical folks, connect them to the capital allocators, the stakers. The second is whenever in the current proof of stake scheme is whenever you want to contribute security to any system, you essentially have to buy their token. Their native token are generally very volatile. They have much higher inventory risk, meaning when you hold it, you have to be very well compensated for it. The last part is because you're holding a native token that's not ETH, which is already generating like the risk free 4%, 5% yield. You have to always add additional yield on top of your stake network.
00:04:13.526 - 00:05:04.602, Speaker A: So you just print more tokens to ensure people can get on your network. The last part we're going to touch a little bit deeper is just basically where you have different middlewares trying to bootstrap different proof of stake network using their own tokens. You fragment security, which leads to the current day and age where other than bridges, no protocol really integrate with any other third level protocols. So just like talk about a little bit each of these a little bit more in depth. The first one, it's difficult to identify where the stakers are, and there's no single place where developers can find stakers. And the key thing behind this is you think of the current way, how any system look at Cosmos is great example how any system bootstrap their security is. They raise a large ground from vcs, and these vcs then in turn become validators.
00:05:04.602 - 00:05:57.626, Speaker A: And because they have their capital holding requirement, they get their lock anyway, et cetera, et cetera. And these vcs basically become the anchoring thing. But it's very limiting, right? Because that means only these people who have larger money can contribute capital and earn a big chunk. So there could be another way for stakers who interact with the infrastructure developers. The second and third are very much similar, which is whenever for a new protocol to exist, you want them people to buy your token, whether it's atom, osmosis or neurocosal chain, you want them to hold a token that can very likely go to zero. So in order to compensate for that risk or reward for that risk, you give them very, very high reward risk. It's very common for 20%, 30%, even 50% aprs in Cosmos world for encouraging people to hold your native token.
00:05:57.626 - 00:06:53.722, Speaker A: And that just basically is very bad because you have this death spiral where you have to print more tokens, so people sell your token, your token price goes down, so you need to print more and more of your token. The negative fee value is very bad. And the third part is on top of this, you are also competing with other opportunity costs, right? If you just, I just buy ETH and I hold a stake it, I earn 4%. So if I buy your native token, then I should really, really get much higher than 4% plus whatever the inventory risk. I feel like the last part is this fragmented security model. So this is, I think the by diagram to illustrate this, let's say adapt is living on three ads here, ads staff, you can think of it as middleware, like a bridge and oracle. I think the way and on each of these middleware ads, they have ability of economic security budget for them to be attacked.
00:06:53.722 - 00:07:25.786, Speaker A: So now you see, even though you live on Kuria, whenever you rely on these different services to attack, your protocol is the lowest denominator. What if there's another way where these three AbS tokens, they all become e and you have 13 billion as a base layer. They all share security among each other. The cost to corrupt the DAP now changed from 1 billion to 13 billion. In case the bottom. But you get the point. So these are the three basic problems, four basic problems.
00:07:25.786 - 00:07:46.898, Speaker A: And now we're just going to go through them and see how we're going to solve them. The first one is there's no platform to connect them. Second is they have to hold the native token. Third is competing with opportunity cost. Lastly is fragmented security. We're going to take a quick pause, see if there's any questions. All right, perfect.
00:07:46.898 - 00:08:28.080, Speaker A: So if we want to build this egg and layer protocol that we want to solve these different problems, we need to first become a platform. I'll explain what that actually means. I think it's pretty obscure at this point. Second, you should be able to offer economic security using any token. You should be able to use it for the native token so that you don't need to run into this inventory risk problem. Second one is it will be better where potentially it could be interesting if you are allowed to lower the opportunity caused by earning different things at the same time. Lastly is through some sort of mechanism, we're calling it restaking, you should be able to achieve full securities fragmentation of the security we demonstrated before.
00:08:28.080 - 00:09:13.578, Speaker A: So we're going to build out, we have the four things, we're going to build each one. Now the first one is, okay, we need a platform connecting stakers and infrastructure developers. What does that even mean? So we're going to run through a very simple, very simple diagram of what is like a current proof of stake protocol. So you have stakers who stakes into the protocol. You have some developers who are writing the protocol software, and at the end the protocol serves some kind of user. Let's say for example, I use Oracle as example, the end user may be some smart contract on Ethereum. So the promise that the protocol is Oracle provides to this Ethereum contract is whenever you query a price feed, I'm going to return some price feed.
00:09:13.578 - 00:09:52.886, Speaker A: Given some economic security prediction, given some different assumptions been made, does that just make sense? Right, this abstraction, perfect. So now is what happens when this promise is broken, right? When the protocol promises this user something but doesn't deliver at the end. So when the promise is violated, basically someone in the protocol, basically the stakers, and here the stakers are the validators, they're the same thing. For now, bear with me. They're going to be slashed, right? Because that means someone was malicious, some guarantee was broken. Therefore they're going to be slashed. So this is actually the entire abstraction.
00:09:52.886 - 00:10:36.630, Speaker A: If we go high enough of any proof of stake system, which is developer writes codes, staker contribute capital into a protocol, protocol delivers a promise to the user. If the protocols didn't fulfill that promise, the stakers get option developers design commitments. The protocol stakers make these commitments by staking into the protocol, and the protocol enforces these commitments. So how do you actually build this platform? Right, this is the abstraction of proof. Stake is between connecting between these two parties. You actually just need two things. You need the ability to make commitments and you need the ability to enforce commitments.
00:10:36.630 - 00:11:18.502, Speaker A: How do you make a commitment? You can write some code. How do you enforce a commitment? By running the function where you can do it on Ethereum, you can encode your commitment into a smart contract as any protocol, unisoft, all these things, you can think of it as making commitments. And enforcing a commitment is by calling some function. In concrete terms, this is what it would look like. You have some staker that can stake into a pool and there's some slashing or commitment logic coded in into the pool. And if the user with a staker violates this commitment, anyone can call a function and slash the user. So the API will look something like this.
00:11:18.502 - 00:12:10.680, Speaker A: I'm going to give you a quick second to read while I take a sip of wine. So let's first look at the functions you can stake into the protocol. Very common once you stake your balances, and also you can withdraw. And lastly, anyone can call the flash function pass in some sort of identifier for the staker and some sort of proof. And this proof is purely customizable, right, because it's whatever logic you put into this token pool. So for example, if you want to bootstrap a very simple proof stake chain, a blockchain, then you can say, hey, if this staker double signs at the same block, then I'm going to stash it. So this proof will be two block headers under the same block number.
00:12:10.680 - 00:12:43.322, Speaker A: So that would be one example, and you can come up with any example you want for the stashing condition. Unequivocalistic system. All right, so we check out one, so that entire thing, just two simple, check out our first requirement by enabling this platform connecting these two parties. The second one is we can offer economic security using any token. And that one sold. Because we're on ethereum, there's a lot of ERC 20 tokens we can choose from. The third one we're going to take it easy and just say we're going to use deep or we're going to use rocket pool, we're going to use CBE.
00:12:43.322 - 00:13:45.410, Speaker A: So I can provide some ERC 20 token as economic security at the same time being exposed to the underlying ethereum portfolio. I'm doing some cheats here at the third bullet point because I want love standalone talk on how we actually do native restaking and how we track balances across consensus layer and execution layer. And the last part is restaking, this part we haven't touched on specifically, how do we solve the fragmentation of security problem and we can issue shared security. So this is a currency sign, right? You deposit something into the token pool. Token pool has some slashing conditions subject to it, and then you go into the same security fragmentation problem, right? If I stake this token pool, I can stake into this token pool which have a different economic, which have a different commitment logic et cetera, et cetera. So one way we achieve this is by compartmentalizing or modularizing the slashing function. So the way we do is the following on the token pool part.
00:13:45.410 - 00:14:29.730, Speaker A: We remove the slashing function and we have a new function called enroll. The way you can think about enroll is the user would deposit, the staker would deposit their stake, their tokens here, and basically whenever they want to make a commitment into some slasher condition, they will enroll into a slasher contract. The slasher contract is basically a mapping and also a slash function. The slash function is the same slash function we talked about from the previous part, which basically takes a staker. If the slash function basically returns a Boolean value, it knows it's true. It's going to set whatever the staker address is to its slash. Does that make sense? So now if I'm a staker, the flow of depositing is going to be the following.
00:14:29.730 - 00:15:08.160, Speaker A: I'm going to call the stake function, I'm going to stake into the token pool. Let's say I want stasher one and two. I'm going to call an enroll function pass in the slasher contracts and I'm going to enroll in these. Let's say I'm malicious stasher two. What could happen is anyone can submit a proof to slasher two and this mapping of my address would be frozen on the withdrawal side. Whatever staker wants to withdraw the token pool will just check with individual stasher that the staker is enrolled in and see if the staker is currently being stashed. We revert and your withdrawal is complete.
00:15:08.160 - 00:15:11.774, Speaker A: Any questions? Yes.
00:15:11.892 - 00:15:18.690, Speaker C: How do you coordinate the update between essentially committing to multiple?
00:15:21.430 - 00:15:22.482, Speaker A: How do I.
00:15:22.616 - 00:15:30.238, Speaker C: So let's say I commit to securing multiple protocols.
00:15:30.334 - 00:16:12.482, Speaker A: I secure to multiple. And actually at the same time, I'll touch on the question at the end because if I'm going on that tangent, I think I'm not going to, but that's a great question. Okay, so we check out this requirement, right? By using this design calling enrolling, we can compartmentalize the stashing function and then at the same time post security, but at the same time the use point, which is there's some caveats involved that could be potentially interesting. Okay. And actually we design Eigen layer. This is the most minimal viable protocol of what Eigen layer is. Everything I'm going to talk about from this point on is actually making it into a product.
00:16:12.482 - 00:16:51.054, Speaker A: There's a lot of features here that it's not going to be easy for developers to use, not going to be easy for stickers to use, et cetera, et cetera. But this is actually the MVP of ICLR. All right, so how can we make it into an actual product? The first thing we're going to think we realize is staker doesn't really always want to be validators. They don't want to operate their own thing. What a shocker. So the way we want to do this is we're going to add the role of the operator into egg layer. So basically if you're a staker, you can provide the tokens, can delegate your token shares to some operator running the auction software for you.
00:16:51.054 - 00:17:39.198, Speaker A: I'm not going to go into every single variable here, but you can think of it, we're going to track the staker balances, the operator balances the staker operator relationship, and then a bunch of other things. But if we do this, everything is in a token pool. It's very messy. A lot of different contracts going to get really overblown, not very modular. The way we designed it is we compartmentalize all the sort of the operator functions into what is called a delegation manager. And delegation manager basically tracks which operator is, sorry, which staker is delegated to which operator. What's the status of each operator? What ABS is or input structures is the operator enrolled in.
00:17:39.198 - 00:18:07.922, Speaker A: So contract is going to be a lot simpler. So the token pool is going to be tailored towards the stake. You can stake and you can withdraw. The delegation manager is going to be tailored to the operators. Anyone can call the delegate two to delegate to any operator. Sorry. The operators can enroll into any slasher and also slasher stays the same way, which is basically keeper rep mapping.
00:18:07.922 - 00:18:37.278, Speaker A: The only difference here is this address variable will no longer track the staker, but only track the operator. This is right. The operator is the one who's running these different things. The second thing we identify is this design only supports one token at a time. So if we want to do this thing for Steve, we have to redesign all these contracts. Now we want to do it for rocket squeeze. We need to replicate all these contracts.
00:18:37.278 - 00:19:10.220, Speaker A: It's very cumbersome. So it's a way for us to support more than one token at a time. Very simple. We're going to use the uniswap liquidity pool model where you have a token manager that tracks all the corresponding token shares everyone have in this individual token pool. And you can think of an individual token pool just holds one kind of token. So this would be Steve, this would be rocket pool, this would be CBE et cetera, et cetera. We're not going to go over this, but it's a simple lp accounting model for keeping track of who owns what.
00:19:10.220 - 00:20:22.990, Speaker A: This part is a little bit more tricky, which is why I call it expanding ABS design, because in the current design there's actually a very critical flaw. So this is one attack vector that's very in the current design that could be happening, which is at time zero, the first red arrow, the staker or the operator commits some malicious behavior. Right after that, the staker plus operator withdraws from a ligand layer right away and at some other later time, finally some fraud is detected and people submit the fraud group to eigen layer to slash this specific operator. However, there's nothing to slash at this point because the malicious operator by slasher has already withdrawed from the protocol. So this is a very classic unbounding period problem for most proof of stake blockchains where you want to have at least enough time for anyone to submit the prop to the blockchain or to broadcast. So you understand some fraud has been submitted. We're not going to change anything on design, but we're just going to add one variable that we're going to check during the withdrawal period.
00:20:22.990 - 00:21:24.310, Speaker A: And this variable is basically we're going to call the onbounding period. It tracks for this list inside the delegation manager, meaning for each operator there's going to be an onbounding period. For simplicity you can think of the onbounding period just some fixed number like seven days or 14 days. But more dynamic, it can also be set dynamically based on if I enroll in slasher one, slasher two and slasher three, I'm going to take the longest onbounding period of the slasher and currently enroll. Since this is a very individual treasure specific variable, the token manager, others a question doesn't that defeat one of the purposes of IBM layer mainly the one that these papers don't want to lock their stake because of the volatility of the. No, I don't think that was part of the requirement we're trying to hit. Right, the requirement that might be another problem rather than you can't get around that by building sort of like a liquid restaking token on top of eken layer.
00:21:24.310 - 00:22:14.982, Speaker A: Fun fact, there's actually eleven liquid restaking protocols on top of icon layer. More now I'm sorry. There's definitely a way to get around that for a liquidity problem because this unbounding period also going to change something on the withdrawal period when the token manager is the only one who can coordinate the withdrawal. So instead of you can withdraw right away, you need to queue your withdrawal and then complete with your withdrawal at a later date. There might be adding some user complexity, but it's going to be needed to make sure the design is safe and sound. All right, last point, very simple is what I call modularizing the slasher. So why is modularizing the slasher needed? If we go through the workflow of how do we even withdraw from this complex system? Right.
00:22:14.982 - 00:23:08.802, Speaker A: I talk about withdrawing very simply in the beginning. We're going to walk through it one more time. This is how you withdraw from the system. The staker would basically tell the token pool, hey, I want to withdraw the token pool is going to check with the delegation manager which operator is the staker delegated to right after that we know that which operator is actually running the staker's tokens? We're going to check which is this operator enrolled in which slasher and then it calls individual slasher one, slasher two and all the slashers the operator is enrolled in to check if the operator is broken. There's a lot of cross contract calls and just in general, cross contract calls are expensive, especially for a person who stake 500 USDC or 0.5 e into the protocol. It will be really cost prohibitive for him to withdraw.
00:23:08.802 - 00:23:54.358, Speaker A: So what we're going to do is we're going to modularize the slasher even more such that individual slasher will not track the mapping. Only the slasher manager will track the mapping. So if anyone submits approved to slash a certain operator, we're going to change the mapping variable inside slasher manager for that specific operator to be true. So now when you are withdrawing, you don't need to call individual slashers anymore. You just need to call Slasher manager to know the status of any given operation and you have invented egg and layer. That's the entire end to end design from the problem all the way to the protocol it is today, which is a huge caveat. I talk about slashing a lot, slashing manager here and there.
00:23:54.358 - 00:24:18.046, Speaker A: A lot of these design are not off the site yet, so there could be still changes to the final code. But this is a great mental model for everyone to have on how this ego works. If you want, please scan this QR code and it's going to give you a Tweet prompt. You can just send that. I will greatly appreciate that. That's in my KPI. That would really help me out a lot.
00:24:18.046 - 00:25:23.570, Speaker A: Okay. All right. Any questions before I go with you? Josh what are the limitations on an operator choosing to do fewer things? Like an operator is optim to certain flashing conditions. If you're an operator and you're like, oh, there's a bug, or you just want to reduce your thing, but you have however many people delegated with an unbonding period for a given staker to pull out of delegating to an operator. Right. Can an operator, what is the restrictions on an operator's time period of pulling out of staking things? Yeah, so the question is how long is the unbonding period? But it's like an unbonding period on the operator versus, because whenever you do any change of delegation, there's always going to be slash. But it's very much, we're not sure how is that going to actually, I believe there will be a lot of complications around the slasher.
00:25:23.570 - 00:25:49.350, Speaker A: We will try to be similar to the liquidation for lending. Also, you're saying that the question is, will there be Meb when submitting the slasher transaction? Any transaction has Meb. In my view. I don't think there's going to be a lot because you're not liquidating some position. You are just like calling and changing a variable. You don't get anything in return. You could, but you don't.
00:25:49.350 - 00:26:12.290, Speaker A: Not in this design yet. So here, for example, if they prefer the direction, they won't get any reward or there's a fleet between the, oh, there could be. Then if there's certain reward, then you have some external keeper bots where submit. That's perfectly fine. Two quick questions. Can you go back to the last slide?
00:26:13.350 - 00:26:15.410, Speaker D: Yeah, I thought it was YC.
00:26:15.750 - 00:26:21.300, Speaker A: It is YC. Sorry. Okay. But.
00:26:23.130 - 00:26:44.026, Speaker D: On the unbundling attack that happened on l one pds, there was this scenario where a validator committed to take an action, but then also did this other action because the reward was greater than the slashing risk. Are there any abs where that could potentially be a thing in item there?
00:26:44.128 - 00:27:16.054, Speaker A: Yeah. So the question is what is the cost? The formal way for us to think about it is what if the profit from corruption, meaning deviating from the protocol, is higher than the cost of corruption? Then any rational right. If you assume everyone's rational, that will be a problem. One way you can get around that is make sure you have a higher capital pool. So you increase the cost of corruption one way. The other way is you just make it cryptographically impossible for anyone to exploit protocol from that perspective. In that case, how.
00:27:16.054 - 00:28:07.942, Speaker A: Do you have a question? I have a question. I'll add to the exit liquidity points about operator. There is a project that's working on other than just liquid restaking tokens, and that's secondary market for positions of operating positions and safer delegating without being part of a liquid restaking token. So again, another abs that's trying to build secondary. Can I install that question? Oh, yeah. Multiple flashing conditions. All right, I'm going to test this out.
00:28:07.942 - 00:28:32.270, Speaker A: Okay. This is my analogy. I don't think it's my way of understanding this system. So let's say I'm a student and I'm in five classes. I make a commitment to all the teachers that, hey, if I cheat on my exam, I am going to. Sure, let's go down. I'll kill myself.
00:28:32.270 - 00:29:11.734, Speaker A: Right? And then on the final exam day, I cheated on all five of the exams. I cheated on all five exams at the same time. Right. And I killed myself. Now the question is, did I fulfill my promise? Did I fulfill my commitment? I did, right? But now you replace cheating on the exam with violating abs and then commitment, and then for killing myself, I'm going to burn some amount of e, right? So I think the way I would explain it is, yes, that could be a problem, but it's not going to be a problem because you actually fulfill your commitment. But once it just accumulates the rewards.
00:29:11.782 - 00:29:13.198, Speaker B: You get for cheating, or like, if.
00:29:13.204 - 00:29:16.026, Speaker A: You cheat at all, if you cheat.
00:29:16.058 - 00:29:18.526, Speaker B: Like 100 times, that will be like a lot of.
00:29:18.708 - 00:29:32.340, Speaker C: Yeah. So that's my question. Is there no leverage? So if you have 32 and let's say one slashing event is like one e burn, you can only commit to 32.
00:29:36.710 - 00:30:03.680, Speaker A: So I think we're touching a lot on our future state tour models. In the current one state, slashing is zero or one thing for now. So you get slash, you slash a little bit. The second one is, you think in this model, I don't even talk about the 32 e because I didn't even touch native restaking. This is just you depositing some token into the protocol. So basically, for the operator you're enrolled in, I say this operator has 100 million e. That's a little too much.
00:30:03.680 - 00:30:37.266, Speaker A: Operator. This operator has 500,000 e, right? If he committed something wrong, he will be slashed for the full amount. Right. It's just basically your frozen status on Sasha manager, and he couldn't do anything. But in the future, I think you're explaining, it's like, oh, what if I don't make this over nothing commitment, but I make a bunch of smaller commitments to a lot of different people. Then yes, definitely. That's like one protocol we're thinking about called stakeholder mike.
00:30:37.266 - 00:30:41.900, Speaker A: I think this is probably the last question I want to give Mike Mark some time as well.
00:30:42.430 - 00:31:09.474, Speaker B: Yeah, I guess my main, and I've given you this feedback before, but my main issue with the term economic security, especially in terms of delegated stake to a node operator, is that the number 10 billion looks really big, but it's not actually the amount of stake for the node operator themselves. And it's just like the classic consolation problem. So curious how you guys are thinking about this issue where as a node operator, I'm playing with someone else's money, not my own.
00:31:09.592 - 00:31:51.790, Speaker A: Yeah, that's a good question. There are two ways you think about this question, in my opinion. This is my opinion alone. The first one is, okay, can we solve first of all, agent problem? I would say goodbye. The second thing I've been thinking about is through the way of how do I lower the barrier to become an operator? And there's actually an amazing design that recently just posted on our research forum. It's about actually using PBS for operators and how you can delegate the role of running these abs outside at the same time. So your problems are that the outside people who are running these abs have enough economic stake so they have skin in the game to alleviate this principle.
00:31:51.790 - 00:32:00.730, Speaker A: Anyway, I hope that's a good wrap on the, on the talk. Thank you everyone, for invitation.
