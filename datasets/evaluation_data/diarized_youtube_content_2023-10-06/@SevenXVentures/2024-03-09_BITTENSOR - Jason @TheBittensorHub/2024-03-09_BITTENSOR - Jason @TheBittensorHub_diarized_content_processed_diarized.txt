00:00:00.330 - 00:00:52.510, Speaker A: People yapping, I'm sure. So I'm going to kind of not take up too much of your time. I know you guys have been kind of at this for a while. Really, I just want to get across, you know, kind of what is bittensor? What are we doing? Why is it important? Why is it interesting? And at a very high level, what bittensor really is, is a decentralized and abstract act computation protocol. You want to be able to incentivize any compute that people can dream of. And so we have what's called a consensus mechanism, where you actually are able to achieve consensus with any abstract digital commodity product. So what does bitcoin do? Bitcoin produces Shaw 256 hashes, and that's kind of its core product.
00:00:52.510 - 00:01:44.410, Speaker A: But really, what does it do? It doesn't do much other than incentivize faithful reproduction of the chain history. And so this is really useful primitive. But what we want to do is abstract this way and be able to come up with any incentivized digital commodity product. And so what the consensus mechanism does is allow people to write their own bespoke logic into what we call subnets. And subnets are the ability for you to write these consensus mechanisms on your own and then be able to achieve whatever desired digital commodity you want. So let's give some examples here. So really what I think we want to get at is here is kind of a small example of there are things we're calling wrong one.
00:01:44.410 - 00:02:19.430, Speaker A: Yes. So really what I want to get across is bittensor actually is enabling an emerging application layer where you can write bespoke, any kind of logic to source any kind of compute that you want. And these are some of the examples of subnets that are operating on bittensor right now. And what they do are achieving particular goals. So you have a time series prediction subnet. You have a music generation subnet. You have a model pre training subnet, so you can do model fine tuning on foundation models.
00:02:19.430 - 00:03:15.930, Speaker A: You have an inference subnet, you have image generation. Wombo has just launched their subnet the other day. You have text to video, you have storage. Really, what this is doing is enabling people to be able to write composable modular computation units so that we can get more complex bespoke digital commodity products. So long term, what the vision is to actually create this kind of application layer. And so this application layer is something that's being built right now, and this is something that incentivizes sourcing the compute to do whatever you want. So what it takes to do this is actually somewhat complicated because you need to actually understand how do I want to source the compute, how do I rank order those outputs, and then how do I get the servers, in this case the miners, to be able to do whatever I want them to do.
00:03:15.930 - 00:04:24.820, Speaker A: So if people, I think coming into the space, if you're an artificial intelligence researcher, if you want to provide a service like wombo where they're providing image generation, there's an added component to being able to do this because typically in a web two framework, you control the entire stack, you have control over the servers, you have a back end service that you query. But in this case, you don't have control over the models, you don't have control over the endpoints. What you have to do is be able to write a mechanism which allows validation in an automated way so that you can actually get the miners to produce the content you want. So really the question is, can you come and build us? And we're not looking for anything, we're not asking for investments. What we're really wanting people to do is build. We want people to come and build the subnets, come and participate in the ecosystem and incentivize compute and to build a more robust AI ecosystem. So I'm going to not take any more time and thank you very much.
00:04:28.390 - 00:04:58.522, Speaker B: Yeah, go ahead. So how I'm understanding subnets on Bittensor is essentially they are decentralized, incentivized digital commodity markets, right? Yes, the idea is awesome, but we are really in the early innings of the crossover between AI and crypto. They are definitely bound to be exploits, people gaming the subnets. What are some of the early observations that you guys are seeing, how people are exploiting that and how do you guys address that?
00:04:58.576 - 00:05:48.890, Speaker A: Yeah, it's an adversarial environment. And I think this is the thing that's going to be very challenging for people that are not familiar with this kind of really cybersecurity model. Because if you're coming as from a research perspective, if you're coming from a web two perspective, you have complete control over all of those servers, the endpoints, whatever you have. One thing that we're noticing is that people really need to understand security models. And so it takes teams of people to understand how to actually combat these common exploit problems. Like for example, don't write an RCE into your code, remote code execution. So there's simple things like that where maybe a researcher would overlook some of those things because they're used to being able to just pickle objects and send them across the wire.
00:05:48.890 - 00:07:08.878, Speaker A: But those are the kinds of, I think, things that we are working with the community to kind of provide best practices to say, here's how you can be more secure, here's how you can write good code in this kind of adversarial environment. I'll give you an example. So when you have a very binary deterministic process, it's very easy to verify. So do you have a piece of data? Do you not have a piece of data? It's like a binary choice, but when you start getting into LLM imprints, how do you determine whether or not one particular output is better than another? One of the things I could share is there's an old model for what was called subnet one. It's now completely different text prompting. One of the common exploit vectors was actually exploiting patterns in the reward models so that you have like a Roberta or some of these maybe mid sized GPTJ style models, that then you can find preferences in those models and then tune prompts, do prompt injection attacks to be able to extract high rewards without actually contributing to the tasks that you were assigned. And so one of the ways to get around this is to inject determinism as much as you can.
00:07:08.878 - 00:08:09.402, Speaker A: In other words, have random seeds in which you're able to verify. Is this the output that I expect based on the pseudorandomness that I've injected into this process? Another way to get around it is to have external sources of truth. I think the new subnet one model is doing this by essentially indexing data, sourcing it from different parts of the web to essentially correlate the data points. So that you're not just saying, well, what's this Roberta model say about giving me a numerical score? One of the things that's really interesting about subnet four manifold labs that they're doing that I really think is innovative in the sense is they're injecting determinism by saying, you have to run this particular model, you have to use this particular seed, and we expect to get this inference output. And if you deviate from it, we know that you are not faithfully participating in the ecosystem. They're doing quite a lot of things. They're civil, they're very, I think, forward looking.
00:08:09.402 - 00:08:46.514, Speaker A: What they're doing is right now essentially inference index vector search. There's quite a lot, I think, coming out of Subnet four, which is going to be very interesting, but they're, I think, leading this in a sense of understanding. How do you actually shore up the mechanism so that you're less prone to exploits. And this is your open research problems. So I think there will be a blend of people who are coming into the space from an AI research perspective that then have to adapt to an adversarial kind of cryptographic environment. And it's growing pains for everybody, but.
00:08:46.552 - 00:09:06.502, Speaker B: It'S something about, is mostly on the security layer. What about the incentive layer? So people might be able to be both the miners and the validators in the same subnet, and because the validators are the ones verifying the work being done by the miners.
00:09:06.566 - 00:09:07.180, Speaker A: Right.
00:09:08.350 - 00:09:10.730, Speaker B: They have the incentives to cheat.
00:09:11.230 - 00:09:53.574, Speaker A: That's what the stake weighted mechanism is for. I mean, that is really the point of Yuma. Consensus is so that let's say you're a colluding validator with a miner, and let's say you have x percent of the stake if you are not faithfully participating. And let's say you favor particular miners that are not exactly doing a good job. The other validators who are seeing the same thing disagree and have a difference of opinion. That difference of opinion is factored into the consensus mechanism and actually lowers the trust score for that offending validator. And so those validators are essentially punished by having reduced dividends.
00:09:53.574 - 00:10:33.698, Speaker A: And so there's a financial disincentive to cheat because of the way that the human consensus mechanism works. So over time you will earn less money. So it's the same reason how bitcoin works with the game theoretic Nash equilibrium, because the idea is to make it economically unsustainable to attack the network rather than just faithfully, essentially faithfully execute and reproduce the history of the chain. So it essentially makes double spending civil attacks kind of unfeasible financially. It's a similar idea, but through the disincentive of reducing your emissions.
00:10:33.794 - 00:10:35.462, Speaker B: Okay, cool, thanks.
00:10:35.516 - 00:10:38.774, Speaker A: Yeah, of course. I'm sorry.
00:10:38.812 - 00:10:40.798, Speaker B: Are you the core team headquarters?
00:10:40.834 - 00:11:14.846, Speaker A: Yes. Thanks, man. Anybody else? Any questions in the back? Just curious. In terms of the current scalability of network, we do millions of AI generations. So the nice thing about bittensor is there's decoupling of the chain itself and off chain work. So the chain only really needs to handle the weight setting mechanism, which is how the incentives are determined. So let's say you write it in python.
00:11:14.846 - 00:11:53.840, Speaker A: You're building a subnet, you have some incentive mechanism, and this is kind of, to your point, the creator of the subnet, it's their job to write the incentive mechanism and the reward structure so that they create a proper reward landscape to get the work that you want done. Let's say you've done this. All of that work happens off chain. What gets set to the chain are the weights which determine the miners incentives, how much they get paid out based on block rewards. So the validator agreement can be all worked out in python, off chain or in go or in rust or whatever language you want to use. We're completely agnostic. It's just Python is the most common language people are using.
00:11:53.840 - 00:12:42.990, Speaker A: So as long as you're able to interface with the chain, putting numbers to it, typically around 100, 200 blocks, people are setting weights. So if there are 2040 validators on your subnet and each of them are setting weights every 100 blocks, you're really looking at a very small subset of weight set calls, which is essentially a vector in this case. Many subnets have 256 Uids and they're un eight values. And so this very small amount of data is essentially metadata that's posted to the chain, which then the Wasm runtime, which is written in substrate runs on chain to run the Yuma consensus mechanism, which then translates into how much admission is actually paid out to the miners and the validators.
00:12:44.310 - 00:12:47.970, Speaker B: How do you guys verify that compute was done correctly?
00:12:49.190 - 00:13:17.890, Speaker A: That's the reward mechanism. That's up to the subnet owner. So this is what I mean by agnostic. We're completely agnostic to. Bittenzer is really a platform to build these bespoke digital commodity markets on top of. Bittensor doesn't directly deal with the security model other than the consensus mechanism and the security of the chain itself. It's the subnet owner's job to write the logic that will verify the work properly.
00:13:17.890 - 00:13:30.460, Speaker A: And as long as that's done, every else is taken care of. Yeah, of course. Anybody else? All right, thank you very much. Thank.
