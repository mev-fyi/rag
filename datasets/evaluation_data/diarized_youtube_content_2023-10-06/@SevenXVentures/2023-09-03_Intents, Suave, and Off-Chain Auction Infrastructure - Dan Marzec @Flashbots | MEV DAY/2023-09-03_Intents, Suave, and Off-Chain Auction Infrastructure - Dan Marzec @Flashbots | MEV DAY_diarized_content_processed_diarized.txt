00:00:00.410 - 00:00:25.720, Speaker A: A little bit of a shitpost on intents. I'll also give like what I think are the good parts about intents and then eventually I'll get into how you can use Swab as like intent infrastructure. That's like the rough arc. The theme is largely inspired by this meme I made. If you're familiar with this format of like, stop doing XYZ, you know the main points.
00:00:26.970 - 00:00:27.430, Speaker B: Yeah.
00:00:27.500 - 00:00:35.240, Speaker A: Years of meta transactions. We have nothing but limit orders. That's sort of like the edge of intents right now.
00:00:37.290 - 00:00:38.040, Speaker B: Yeah.
00:00:39.050 - 00:00:41.606, Speaker A: What else is here? Yeah, that's about it.
00:00:41.628 - 00:00:41.946, Speaker B: Oh yeah.
00:00:41.968 - 00:00:58.960, Speaker A: And then, hello, I'd like an intent to not be front run. I think that's also a little bit of a spoiler for the rest of the talk is that front running is still very possible with intents. It doesn't totally solve that. It can move it in a meaningful direction, but yeah. Cool.
00:00:59.890 - 00:01:00.206, Speaker B: Yeah.
00:01:00.228 - 00:01:30.550, Speaker A: So this is the rough arc. Intenser psyop. Intents are probably the right abstraction. Audit your intents and then yeah, suave as intent infrastructure. Cool. So yeah, the Bear case, this is how I would say intents aren't really that crazy or anything substantially new. There's been like 30 years of UX research in Web Two and we're suddenly bringing that now to web Three with intents is sort of my argument.
00:01:30.710 - 00:01:31.034, Speaker B: Yeah.
00:01:31.072 - 00:01:50.240, Speaker A: So EIP 712 metatransactions, those have been around for a while. If you've ever used openc those use metatransactions under the hood and those don't really specify a specific execution path. So you sort of just say, oh, I have an NFT and I want around this much. And that's sort of what you get.
00:01:51.890 - 00:01:52.640, Speaker B: Yeah.
00:01:53.570 - 00:02:30.426, Speaker A: Giving users, users giving more optionality to their executors, I think. Yeah, that would be the other part of the Bear case is like, is that really where the bottleneck is right now? Are all of our UX issues in web3 suddenly solved if we're like, oh, now a searcher has way more options for how to execute my stuff. No, probably not. A lot of it is like users are confused wallets, like cross chain interaction, things like that. And then yeah, cowswap is also already live. That's an intent platform as well. You don't really specify your execution path.
00:02:30.426 - 00:02:40.030, Speaker A: You sort of just get thrown into a batch auction with a bunch of other people and then your intent is satisfied or your desire.
00:02:41.170 - 00:02:41.486, Speaker B: Yeah.
00:02:41.508 - 00:03:12.600, Speaker A: And then lastly for the Bear case would be like it still reduces down to a market structure issue. And so the intent language can have an effect on the market structure. If your intent obstructs a certain party from being able to solve your intent, then that could potentially cut off parts of the market that you maybe do want or maybe your intent and structure intent structure could incentivize other market participants to come in and solve it.
00:03:13.290 - 00:03:13.654, Speaker B: Yeah.
00:03:13.692 - 00:03:37.202, Speaker A: So that's like the Bear case. And then I'll quickly go through what I see as intense the progression of them. So this is sort of like abstract. I wouldn't look into this too much, but this is how I think about it. I have some token, A, and I want B. I tried to do this on an X and Y graph, but it ended up looking too much like an AMM, and I didn't want to confuse. So, yeah, this is like uni v two or maybe V one.
00:03:37.202 - 00:04:00.730, Speaker A: Like no router. You have one exact path. Like, I need to go through this pool, and I can only satisfy x times Y equals k for that single pool. And then yeah, okay, maybe this is like v two plus the router. The router gives you multiple different paths you can go to now. And that's like a huge improvement because now you can maybe go through multiple pools that you didn't specify.
00:04:01.950 - 00:04:02.266, Speaker B: Yeah.
00:04:02.288 - 00:04:40.070, Speaker A: And then I would say this is more what intents look like. You just specify this entire space as a set of constraints, and anyone can satisfy those constraints. And so that's like a single person intent right. For a single token. But a lot of intent infrastructure or solver networks, what they do is they take this and then they combine it with a bunch of other people's intents right. All in this one little box. So, yeah, I think the Intent infrastructure starter pack, it's like an ability to aggregate all of these sets of constraints into one cohesive unit.
00:04:40.070 - 00:05:03.760, Speaker A: And then yeah, you sprinkle in some crypto like DKG, perhaps you encrypt your set of constraints to, I don't know, some public key that the network creates and rotates around. I think, like, Furbio is an example of this DKG infrastructure on, I think, Osmosis. It's live right now.
00:05:04.930 - 00:05:05.246, Speaker B: Yeah.
00:05:05.268 - 00:05:23.890, Speaker A: And then decentralization of compute and storage. We don't really get anywhere. If you just encrypt your intent constraint into my phone, that's not really the goal here. We want a marketplace of solvers competing for different execution on different constraints.
00:05:25.190 - 00:05:25.566, Speaker B: Yeah.
00:05:25.608 - 00:06:05.854, Speaker A: So that's what I would view as the bare necessity. And how you actually encode these constraints into a way that a user can specify, I think, is where all of the intent work is. So if anyone's working on intents would love to talk about that. But yeah, again, the language you specify to your user is going to determine the constraints that they create. I think there's a really big argument as well that users don't know what they want. So a really good example, I think, is like Google Flights. If anyone's used that I use that to book here, I sort of say where I want to end up in a date.
00:06:05.854 - 00:06:51.694, Speaker A: And you could imagine that as constraints. And then it sort of comes to a bunch of solutions. For me, what's interesting is the Google Flight search. What they'll do is they'll actually show you the cheapest, and then after that, I believe they show you the yeah, they show the cheapest first, and then after that they show you the shortest flight and the cheapest, and then I think they have some other priority ranking for what they show you. So I think there's a lot of room for platforms to choose these preferences for the users because I don't really want to think about what my ordering of preferences are. Typically, 99% of the cases, the cheapest one is what I want to go with, and then, oh, maybe it's 20 hours versus ten. Like, all right, cool.
00:06:51.694 - 00:07:10.520, Speaker A: I'll go to the second one. That's a good example. And this goes back to the Bear case of too much. Say I expose 100 parameters to a user. That really doesn't solve any of crypto's UX issues. Cool.
00:07:12.090 - 00:07:12.406, Speaker B: Yeah.
00:07:12.428 - 00:07:49.620, Speaker A: So the bullcase yeah, so it expands the discourse to include a user's behavior and motivation. That's sort of what I was talking about before. Cross domain intents are also something that's really interesting that you can expose. If a user simply specifies these end states, then if I can provide some type of proof that I did the required action on one chain and then bridged it back, then that's super fair game. And so that's really awesome that we can sort of use this abstraction to move to a world where the actual chain you're on doesn't matter as much.
00:07:51.030 - 00:07:51.394, Speaker B: Yeah.
00:07:51.432 - 00:08:30.350, Speaker A: Other builder superpowers, I sort of refer to this like, cross domain ability as like, a builder superpower. That's like a very ETH centric thing if you're not on the ETH world. Sorry about that. But yeah, you could do things like multi transaction flash loans is like, one builder superpower you could enable. So right now, if you do a flash loan, you have to return the liquidity by the end of your transaction execution. But if you're the builder and you're in control of the entire block, and you're even in control of another block on another chain, you can do very interesting things. You can maybe even mix in signals from domains that aren't even on a chain.
00:08:30.350 - 00:08:38.850, Speaker A: It's a little unclear how you verify and then show that information to a user. But all awesome possibilities.
00:08:39.830 - 00:08:40.146, Speaker B: Yeah.
00:08:40.168 - 00:09:07.642, Speaker A: And then this is the strongest one for me. It's way more marketable than invariants. I think a lot of intents are really just invariants. I think even like slippage is sort of an invariant. I think we do have some basic things like this right now, but yeah, no one wants to say my invariants are XYZ, but my intent is to get a token way more marketable. Cool.
00:09:07.696 - 00:09:07.866, Speaker B: Yeah.
00:09:07.888 - 00:10:04.430, Speaker A: So that's like roughly yeah, those are my Baron bull cases for intents. I think it's unclear where intents will go, whether these will actually be some type of someone will design some domain specific language that everyone uses, or maybe certain actions will have intents that become very standardized and then you could use them across every single application. Or, like, a couple of them. If you imagine your phone, you probably have hundreds of apps, and so do we. Imagine each one of those is going to have their own domain specific language for getting things in and out that you want. No, probably a lot of apps you transact and so a very basic pattern is like what you're giving and what you want. I think this is like the anoma intent language and structure is based off of this.
00:10:04.430 - 00:11:05.974, Speaker A: So you're on Instagram or like TikTok or something and you want to buy something, you specify how much you're willing to put in and then you specify how much you're willing to get out and yeah, it really doesn't matter. And so that's what gets segues into my next point, which is you specify how much you're willing to pay in basic versions of intents. But if these intents are public then we're actually just in the same exact place we are with the transaction supply chain and mev. Because if I'm willing to pay 100 for 100 USDC for one coin, no one's going to be like, oh, let me just give you 90 for one coin. Actually no, searchers, executors, whatever you call them, solvers are going to push you right up to the limits that you express. And so this reduces back to the Med supply chain is my opinion. And this is sort of where I get eventually back go more into swab and less on intense.
00:11:05.974 - 00:11:13.780, Speaker A: So yeah, the state of mev. This is like a rough transaction supply chain, intent supply chain now it's new.
00:11:15.350 - 00:11:15.714, Speaker B: Yeah.
00:11:15.752 - 00:12:20.330, Speaker A: So yeah, when users transact they generate more value sometimes than they generate value that's internal or external to the system that they don't even realize. Being able to combine multiple different orders can maybe move a price in a different direction that you didn't expect. Yeah, so right now this value is mostly captured by searchers and validators. Originally the network sort of captured it in a sense with Priority Gas Wars. But then Flashbots, we introduced a way for you to privately express these preferences and then now with PBS proposer builder separation like sort of the design philosophy that validators and maintainers of the network's consensus shouldn't be the ones responsible for building blocks. With PBS I think it's like 90% of the value now ends up with validators and that's because of the market structure where the PBS design is basically a first price auction. So it just incentivizes everyone to sort of bid max until they win the auction.
00:12:20.330 - 00:13:11.420, Speaker A: Yeah, and then users can be negatively impacted by some strategies that's like front running and as I mentioned before, intents, you can still get sandwiched with an intent depending on how you structure it. Yeah, so that's the state of mev. So yeah, with these private channels we protect the chain from negative externalities. We don't have Priority Gas Wars, but we don't internalize any of the value. And that's the really interesting thing. It's actually really similar if you think about restaurant reservations, I think that's another example of somewhere that actually could maybe potentially internalize this demand, where, let's say a restaurant only has like, ten reservations in a day and all of them get booked for free. Or maybe there's some minimum cost you have to stake, which is like cyber resistance, in a way.
00:13:11.420 - 00:13:23.630, Speaker A: You could actually have secondary market trading on that, and none of that value goes to the restaurant, even though it's like their actual spots that are generating this contention for usage.
00:13:24.210 - 00:13:24.526, Speaker B: Yeah.
00:13:24.548 - 00:13:27.040, Speaker A: So that's a big issue. Don't internalize value.
00:13:28.130 - 00:13:28.542, Speaker B: Yeah.
00:13:28.596 - 00:13:41.540, Speaker A: So we have private channels that's like the main approach. There are smart contract approaches which are really interesting, and I think intents will allow more expression into how smart contracts can internalize this value.
00:13:42.310 - 00:13:42.674, Speaker B: Yeah.
00:13:42.712 - 00:14:06.860, Speaker A: Some quick examples are, like liquidations in the maker auction, or the maker Dutch liquidations maker chose like a Dutch auction to sort of remove some of the negative externalities of everyone just know, sending in tons of bids. Now with the Dutch auction, it's just like, oh, that's the price I want, I'm taking it like auction over depending on if you can get on the chain, which Max had a lot about.
00:14:07.630 - 00:14:08.042, Speaker B: Yeah.
00:14:08.096 - 00:14:12.154, Speaker A: NFTs gradual Dutch auctions, that's like another approach. Art gobblers used it.
00:14:12.352 - 00:14:12.666, Speaker B: Yeah.
00:14:12.688 - 00:14:23.070, Speaker A: And then AMM's like order flow discrimination has like, mixed effects if Alex ends here. Yeah, that seems to be like one approach as well, to internalize some of this demand.
00:14:23.810 - 00:14:24.174, Speaker B: Yeah.
00:14:24.212 - 00:15:21.010, Speaker A: So those are current solutions, but they're not really good enough is what our view is. So we introduced and have been working on Suave, which is a system to handle all of these things. And so at a very high level, this is like the different users of Suave and how they would specifically interact with it. But you can think of it as like I'll start with a concrete example. So like Mev Blocker or Mevshare, if you guys are familiar, it's sort of like you can submit a transaction and then so with Mev Share, we will release a subset of the information that searchers can then search on and send a transaction back in, which will backrun it. Medblocker does something similar, except they just reveal the full information and then in order to stop Probabilistic Sandwiching, they introduce fake transactions. That's their approach.
00:15:21.010 - 00:16:19.510, Speaker A: So with Swab, what you can actually do is you can encode that logic for your order flow auction as a smart contract. You can then deploy it onto Swab, and then the key here is that the user will then encrypt their transaction to the Swab network and then they'll send it into a Swab node. And then what happens is anyone can now run the auction and so you have a verified program that they're running on top of confidential bids. And so the other cool thing that smart contract enabled ofas give you is that you can actually control the privacy model. So if you want to leak some of the information as in Mev Share, you can actually choose to do that. And the user specifically allows certain contracts that they send their bids to. So I can write some contract that will just leak all of your information and give you nothing.
00:16:19.510 - 00:17:28.038, Speaker A: And as the user you're free to click on that and use it. But we think also you can also submit to some really shitty AMM as well. And people don't do that right now because there's various network of trust types of scenarios. People verifying that's basically it. And then we also envision people, searchers builders, et cetera, running a lot of these nodes and so they're incentivized to try and get as much order flow. Another cool thing that this solves in the builder markets that I had personally experienced working on another builder is a lot of the iteration on block building mechanisms is most heavily constrained based on the order flow that you have. If you only have 50% of the order flow and say you want to compete with bundle merging with Jared from Subway or something, the infamous sandwicher, you can't really meaningfully iterate there if you don't have their flow.
00:17:28.038 - 00:17:53.300, Speaker A: And so this stops a lot of builders from being able to iterate. And so we hope that in the base case, swab will allow lower the barriers to entry of the markets to be a block builder because you can sort of like based on some tenuous trust constraints in the beginning, you can get access to the entire order flow of everyone submitting through Suave. Cool.
00:17:54.550 - 00:17:54.914, Speaker B: Yeah.
00:17:54.952 - 00:18:50.326, Speaker A: So these are the takeaways if none of that made sense, replace trust and operators with Tes maybe eventually, like Threshold, NPCs, some type of cryptography. I think if we had the exact same block building infrastructure as we have today, but it's on Tes, I think we're in a radically better place. This isn't the five to ten year timeline of what this market will actually look like, but we think it's way better than you just trusting some random server that says they won't leak your data or something like that. And then many people have opinions on Tes. We have a lot of approaches and very experienced SGX engineers on how to mitigate exploits and things of that nature. I think the quick answer is if there is an exploit and three blocks are unbundled, that's really bad. Yes, but typically it's not as bad as Ethereum going down.
00:18:50.326 - 00:19:04.380, Speaker A: And on top of that, a lot of the people finding these exploits are very sophisticated labs, like doing it for academic clout. They're not necessarily like some 16 year old in their bedroom, which you could that would also be cool.
00:19:05.870 - 00:19:06.282, Speaker B: Yeah.
00:19:06.336 - 00:20:18.622, Speaker A: Make the operation of the service decentralized geographically and administratively. Ideally one person shouldn't be able to shut down the system and then geographic decentralization is like a much harder concern and that's a little bit longer term and then yeah, user programmable based on smart contracts. Yeah, the real vision is like a marketplace for mechanism. Like any Dgen sort of AMM designer or smart contract dev should be able to just read a tutorial, deploy their own Ofa on top of Uniswap and you could actually meaningfully compete with flow and you don't need to be associated with Uniswap or anyone. And then okay, these next few slides are a little technical. If anyone's familiar with how an ethereum node works, you have the EVM, you have the state, DB is the main place you store things and then some configs and contexts over here is all traditional EVM. And so yeah, you have this runtime which ends up at the interpreter, which is what translates your bytecode and actually runs the execution.
00:20:18.622 - 00:21:11.362, Speaker A: All that the mevm is is it's a new runtime. We call it like the Swab off chain back end and it just plugs right into the interpreter. And so now at execution time, your code has access to these fields, one of which is misspelled. And so yeah, you get a confidential back end that your execution gets access to and then as well this off chain ETH back end. So you can sort of call functionality that's used in traditional block building such as simulate a bundle or build a block. You get access to all of those inside of your smart contract, which is really awesome. So you can deploy a program that will take in a transaction, simulate it, do something with it based on the results of the simulation, maybe route it to another smart contract and you can kind of stack these things.
00:21:11.362 - 00:22:15.160, Speaker A: So you could imagine multiple layers of ofa contracts and then maybe multiple layers of block building contracts and then multiple layers of relay contracts and they all can sort of plug and play. And the point is not to be prescriptive about what the right route through the supply chain is. It's again, allow anyone to propose new ways that these mechanisms can interact and operate and then just let the market win for which one's the best. Yeah, so what are the differences in terms of UX on using Swab? So this is like the transaction supply chain. Before you go from user looking at the UX to a wallet, they send it to an RPC. That RPC will somehow end up at a block builder. If it's an Ofa, then it'll forward, it sometimes you could view like infura right here who sends it to a mem pool and that's know, the public broadcast to all the block builders and then yeah, block builder sends a relay and the relay sends the proposer that's sort of like the PBS part.
00:22:15.160 - 00:22:54.530, Speaker A: So yeah, the main differences here yeah, so Suave does not make any types of opinionated claims about this portion. That is for anyone to sort of go out and design like an intent framework that can operate here and then yeah. So what are the differences from there? We have a new transaction type called an off chain transaction type. It basically is like a regular Ethereum transaction except the call data is for a function call on Suave. And then there's an additional field called confidential input which is like your encrypted bundle, but other than that exactly the same. Like one or two field differences as well. You also specify which contracts are allowed to execute over your transaction.
00:22:55.430 - 00:22:55.746, Speaker B: Yeah.
00:22:55.768 - 00:23:32.078, Speaker A: So the RPC is also slightly modified. Sendraw transaction just takes this new off chain transaction type how the RPC and the block builder communicate, that is also different. Now they communicate through the confidential data store. So your Ofa can output a combination of the user's bundle with whatever transaction the Ofa might have inserted. So in Mev share that's like a refund transaction. And the way they communicate that is just by passing it again through Swab internally and then yeah, as well block building. The way it communicates with the relay is through this confidential data store as well.
00:23:32.078 - 00:23:59.420, Speaker A: And typically these two have been like http like you just do a post request so we think that's cool. And then yeah, this portion will probably stay the same for a while. The relay to proposer no proposers are native to Suave so will definitely always be the last mile. We hope that there will be some cool peer to peer network standards that will come out so that we could just broadcast these commitments to proposers and then they could accept. But that's probably a long way to go.
00:24:01.390 - 00:24:01.754, Speaker B: Yeah.
00:24:01.792 - 00:24:37.858, Speaker A: So there's intent infrastructure on just like many different domains being worked on PBS. Like you can view as sort of like the last mile intent delivery if the guarantees we have with PBS aren't satisfied. If a builder's block is able to be unbundled is an attack. We saw in Ethereum where a malicious proposer basically said they were going to propose a block that came out of the Mev boost auction, but then they didn't. And then once they received the block they took out all the transactions. Just sandwiched everyone, made like 20 mil and then just left. And they of course got a slash on the Ethereum network because that's an Equivocation.
00:24:37.858 - 00:24:47.830, Speaker A: But I think they made like a couple of mil and the slashing penalty is like 20,000 or something. So it was nowhere comparable or incentive compatible.
00:24:48.510 - 00:24:48.874, Speaker B: Yeah.
00:24:48.912 - 00:25:15.202, Speaker A: 4337 is also approaching probably the earlier part, like maybe intent propagation and then yeah, Ofas as well. All Ofas right now take transactions just like regular transactions. I think if someone just made a partial transaction like Ofa similar as Mebshare, like literally just fork like, I think that would be a super cool thing that people might use. Cool.
00:25:15.256 - 00:25:15.522, Speaker B: Yeah.
00:25:15.576 - 00:25:53.678, Speaker A: So last, what's possible with Swabgeth? So yeah, you can build an Ofa in solidity deployed on Swab. You can build a builder dex aggregators. You could also build them there. Dex aggregators are really awesome today and I think if you want the best deal, you probably go to one inch or like cowswap as well. So, yeah, you can do all of that same logic except just on swab where, you know, the computation is guaranteed to be what you allowed. And then as well, you know that your data is private up to the amount that you specified. So, yeah, same exact experience.
00:25:53.678 - 00:26:01.950, Speaker A: Maybe a little bit slower in the beginning because of some of the additional stuff we have, but in the limit these things will be very comparable latency wise.
00:26:02.610 - 00:26:02.974, Speaker B: Yeah.
00:26:03.012 - 00:26:36.554, Speaker A: RFQs sort of similar thing that might even be a repeat of Dex aggregators in some way. Validity conditions. You can specify like very arbitrary conditions that your transaction is allowed to be included on chain. So like, one example is a refund. Like I am only going to allow my transaction on chain if I am sent half of the mev extracted back. So you can encode that in a smart contract and it just won't even give your bundle to a builder unless that condition is satisfied. Yeah, read your distribution, same thing.
00:26:36.554 - 00:26:47.840, Speaker A: So, yeah, intents and quotes anyone could build. If you create one of these languages to express intents, then you can easily create an auction for it on swab as well.
00:26:48.370 - 00:26:48.734, Speaker B: Yeah.
00:26:48.772 - 00:27:21.334, Speaker A: Proposer builder commitments. You could imagine much more advanced commitments than what we have now. I think the talk after this probably is going to touch on that you could do private voting. That's not really a use case where it's sort of like focused on but you have privacy and you have very cheap computations. So you could in theory and then this is the last fun one as well, if anyone wants to work on this. 4844 Blob merging. Right now, the way 4844 is structured, you pay like an upfront amount even if you don't use the entire Blob gas.
00:27:21.334 - 00:27:39.390, Speaker A: So people are talking about so you can imagine roll ups that only need like a third of the Blob gas in a specific transaction and then because of the properties of the underlying cryptography, you can actually combine these transactions into one and it'll still satisfy everyone's original intent.
00:27:40.850 - 00:27:41.214, Speaker B: Yeah.
00:27:41.252 - 00:27:55.220, Speaker A: So you could design something on swab which would like merge these. I don't know if you need privacy for that case, but you would get the decentralized aspect of running that service. Cool. Any questions?
00:27:56.230 - 00:28:11.450, Speaker C: Yeah, I'm wondering, have you done any research or have any thoughts on state drift and effect on, say, solars and builders that are doing something in central example on a chain that has faster block times, like 12 seconds, where state changes a lot quicker.
00:28:12.430 - 00:28:14.438, Speaker A: And what was it you said? State drift?
00:28:14.534 - 00:28:21.210, Speaker C: Yeah, state drift. So obviously on ethereum state will change out every 12 seconds. Let's say you're supporting something that's 0.5 seconds.
00:28:22.130 - 00:28:22.986, Speaker A: Do you have a comment.
00:28:23.018 - 00:28:23.600, Speaker B: Yeah.
00:28:26.050 - 00:29:06.330, Speaker D: I'm not sure if Diego is going to talk about it, but there's an interesting use case around using the PEPC as an external commitment to cater for situations like state drift where you have a fast chains like swap that is running like bundling blocks at a lot faster rate than like 12 seconds. But then how are you going to get commitments for that? Things that you just bundled that's finished maybe like a few seconds ago? Well that way to get that commitment they can use something like PEPC to say, okay, I'm going to use PEPC to commit to this. Let's say something that's created from swap such that even though it's like many seconds delay, that later on can still get published.
00:29:08.910 - 00:29:42.120, Speaker A: Yeah, and to add to that further, I think one of the things I'm working on personally, I'm calling it like swab subnets right now. Yeah, no more terms. The idea is like okay, so we have programmable privacy, the swab chain is much faster, but if it's one to 3 seconds, that's still not fast enough for some applications. Like traditional finance is whatever in the nanoseconds. So that's where we need to end up in the ten year timeline maybe.
00:29:43.130 - 00:29:43.446, Speaker B: Yeah.
00:29:43.468 - 00:30:42.540, Speaker A: So one thing I'm playing around with is whether a smart contract could actually specify the DA guarantees that it provides. So you could do something like have only a subset of nodes run like the Unix auction perhaps, and they could do that ofa however it's designed could maybe specify 200 millisecond rounds. And so those nodes have to come to agreement on which transactions are available to all of them and that can be used as input to the auction. That's like one idea but it's certainly like an open question and it gets into the idea that if the main swap chain is like this global bulletin board, one application doesn't really care about whether or not another application's data is available. If you're the block builder, it does, but if you're like cowswap, it doesn't really matter what Uniswap is doing. So yeah, we're playing around with that. Yes.
00:30:44.590 - 00:31:12.290, Speaker D: Actually just a quick question for something I noticed. So you mentioned about the multi transaction flash or the block flash as part of the possible intent use cases. I was thinking specifically for that. How are you trying to integrate intent aspect to that multi transaction flash loan?
00:31:14.230 - 00:31:29.800, Speaker A: We're not really working on that. That's just sort of just like an idea. Yes, but yeah, I mean it is funny because I think if you combine multiple intents into one transaction you might not even need a multi transaction flashland because it's like technically one. But yeah.
00:31:33.210 - 00:31:37.190, Speaker C: You mentioned wanting to use SGX, have you thought about using like Oram?
00:31:37.530 - 00:31:54.030, Speaker A: Oh yeah, totally. Yes, we're looking to that. Oram is just like really slow as all these solutions are. We have some people working on it though. I think we saw like a 30%. Improvement in benchmarks with a recent paper that came out from a flashbots researcher. So we do think yeah.
00:31:54.030 - 00:31:57.500, Speaker A: Over. Yeah. That's, like, a very interesting use case. Yeah.
