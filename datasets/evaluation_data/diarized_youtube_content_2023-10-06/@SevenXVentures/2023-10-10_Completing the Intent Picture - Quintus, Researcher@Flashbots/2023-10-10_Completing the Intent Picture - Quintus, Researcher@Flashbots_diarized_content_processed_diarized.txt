00:00:03.370 - 00:00:37.800, Speaker A: Cool. Hello, everyone. My name is Quintess. I'm from the Flashports research team. And today I'll be discussing intents. And in particular, I'll be arguing that intents are sort of a social phenomenon that we've seen come up and they don't represent technical advances, but rather are emblematic of a shift in the way that the blockchain community has come to think about blockchains and the kind of problems we face. And I'll try and make explicit why we've come to speak about intents and roughly what they are or what people take them to be.
00:00:37.800 - 00:01:08.366, Speaker A: And then I'll sort of complete, I think, what is the discussion around them? Because I often feel that there are parts of the discussion which are missing. And really what I'll be arguing is that intents are part of a larger discussion which represents sort of a balance we have to strike. And intense represent one side of this. The other side is not that often discussed, and I'll get to that in a second. But it's important that we strike this balance. But first, let's just discuss the one side of it. Intense.
00:01:08.366 - 00:02:36.640, Speaker A: Right. And sort of more metaphor I could put here letting go and it'll become clear why I call intense that in a second but before I can make my case it's easier for me to just establish a basic model of the blockchain. So the blockchain is a state machine. You can think of Ethereum as a good example of this it has an operator usually it has multiple validators but for the sake of the example today thinking of a single operator is fine and this operator requires permissions to transition the state machine. If we think of the state machine as a graph or where states are nodes and edges are valid transitions then these permissions which are messages from users cryptographically signed messages permit the operator to transition along certain edges. The other aspect of the model is that agents here being users and the operator have their utility depending on the state of the blockchain and of the world. An example of this is I might care how much ETH I have in the next Ethereum block but I also care how much that ETH is worth on Binance around the same time what is an example of some of the permissions I was mentioning earlier? Transactions by far is the most common example of this.
00:02:36.640 - 00:03:31.790, Speaker A: Generally, transactions are transition functions from one state of the blockchain to another. And so if we come back to this graph view of things, transactions are permission for the operator to transition along a set of edges, the different edges depending on which state is being fed as an input to the transaction. You can view it like that. Now, another thing that can be done with transactions is that they can be combined. Generally, transactions aren't processed individually by the blockchain, but they're processed in batches, they're aggregated into batches. And the way they're applied basically is just through chaining. So if we apply many transactions in sequence, effectively we have one large transaction and so we can view it as one large state transition.
00:03:31.790 - 00:04:30.798, Speaker A: The key point of the slide here is that there are two activities which can be done with permissions these messages so they can be executed, which means transitioning the state machine, or they can be aggregated in this specific setting we're talking about chaining them. This is where intents come into the picture. I think the sort of core concept around intents is that we are thinking about other forms of message aggregation. What do I mean by this? Well, in particular, I think we've realized that chaining doesn't need to be the only form of message aggregation. There are more interesting ways of aggregating messages and we'll get to why they're more interesting in a second. So intense, loosely and again it's a social concept and so there's no rigorous definition, no strict definition, but I think this is relatively uncontroversial. Intents are messages which need not be executable in isolation.
00:04:30.798 - 00:05:39.966, Speaker A: A transaction you can apply to Ethereum state and you know exactly what state you're getting, but an intent you apply and it's not exactly clear what the next state will be. So you might have to combine these messages with other messages and process these messages further into say for example, a transaction which can be applied to the state machine. The implication of this is that intensive messages which may require aggregation to be executed and in general we think of them as messages which do require aggregation. And here aggregation, I mean combinations of the messages into a transaction. So I think if there's one takeaway from today's talk, it should be this picture. I think really what intents are about is about shifting our mental model to one in which instead of users just directly interacting with the operator of the blockchain, there's this intermediate layer of aggregation. This is this layer of intermediaries which users rely on to combine their messages, to aggregate their messages before they're applied to the blockchain.
00:05:39.966 - 00:06:22.038, Speaker A: This has been the case for a while. There have been many sort of intermediaries off chain services offered to users. We can think of RPC nodes as a very basic example, but we've come to think of them a lot more now because I think we've come to realize that these intermediaries can address some of the issues which users face. Let me justify that. So why do we care about intents? Why aggregation? Because aggregation solves a bunch of our problems. What are these problems? Well, if we look at the user's challenges today abstractly, I would say it's these kinds of things. So one is preference impitation and mapping this to the message space.
00:06:22.038 - 00:07:20.426, Speaker A: Users have very complex preferences or they can have very complex preferences about what the next state of Ethereum they'd like to see or sort of what the utility is for many different states. And first they have to become aware of these preferences and then they have to map these to the messages which they have available to them and in this case it's transactions or generally it's transactions. Earlier I was saying that usually our utility depends on the state of the blockchain but also the state of the world. And generally because users face latency delays they have some uncertainty about what the state of the world will be when the next ethereum block is produced. They also have strategic uncertainty which is to say users don't know what other agents are doing and because it's interaction between user messages which are being applied to the blockchain this impacts the outcomes and therefore users are uncertain. A specific case of this is adversarial behavior. Other agents reacting to my information.
00:07:20.426 - 00:08:19.610, Speaker A: A very clear example illustrating strategic uncertainty and adversarial behavior is slippage limits. In AMM swaps users don't know if other users will be trading against the same asset pair in the same block and so they allow some tolerance for the price they end up getting in the form of a slippage limit. The downside to this is that you now open yourself up to sandwiching which would be adversarial behavior. Then you also have technical uncertainty. If you knew exactly what all the other users were doing and you knew what the price of finance will be in the future you might still have some uncertainty if the way that messages are processed is stochastic. So for example ethereum today there are two to the end different kinds of orderings in which end transactions can be ordered and it's impossible to sort of check each of those and decide deterministically. And so generally there's some uncertainty as to in what order transactions will be applied.
00:08:19.610 - 00:09:56.538, Speaker A: Another challenge is costs. Many of these problems can be addressed somewhat by doing more computation on the blockchain. The problem is that this is expensive as I guess we all know and so my claim is that intents address these and if we think back to the picture I was showing earlier intents addressed these by leveraging an aggregation layer a layer of intermediaries between the users and the blockchain. But let's go through each of these challenges and see why that's the case. So if we remember that we were saying intents or loosen the restrictions on the kinds of messages that users can send to the operator we now see that users with complex preferences can now map these onto messages which more closely resemble their preferences. If messages like transactions or mappings from one state of the blockchain to another this might not exactly reflect the user's preferences which may depend on other kinds of information, right? So the input of the function isn't only the ethereum state but users also don't really reason in terms of ethereum state and abstracting the message space or allowing different kinds of messages moves away from this problem. The other problem is fundamental uncertainty so just like I was saying, we could change the messages from being functions that map from state to state.
00:09:56.538 - 00:10:51.760, Speaker A: We can change these to take into account some information about the external world. And in this case it would be the intermediaries that provide these kinds of information to the user's messages. For example, about binance price. Again, another input that could be given into these messages is information about what other users are doing. A really good example of this is like cowswap or any kind of uniform clearing batch auction in which multiple user messages in some sense are conditioned on each other. And so the message executes based on information about other user messages, reducing strategic uncertainty, technical uncertainty. An easy way of addressing this is by creating message formats so that again, the batch auction is a really good example.
00:10:51.760 - 00:11:43.646, Speaker A: The price at which users are executed is only determined by the behavior of other agents and there's no sort of stochastic uncertainty in the system built into the system costs. Roll ups are a really good example from the perspective of the L one, especially if the assets are on the L one. And I realize there's some nuance here. Roll ups are basically ways of taking a different kind of message format the roll up transactions, processing these and then executing them on the I should say aggregating these and executing them on the L one in a much more cost efficient way. So that's the one side of the balance. What's the other side? And the other side, I think, is generally mev. But it's regaining control.
00:11:43.646 - 00:13:14.422, Speaker A: If intents were about sort of giving freedoms, reducing frictions for intermediaries that aggregate messages from users, the mev side or the other side of the discussion should be about controlling these entities so that they don't run amok. So what are the problems? What are these abuses of freedom that can happen, right? So one thing we want from these intermediaries is we want integrity. So if they promise I'll do a certain kind of computation, then we want to know that at least if there's some output produced by the intermediary, they have some valid input to this output. A good example is that if a block builder is constructing blocks, then the blocks that they are constructing haven't unbundled users input. So usually users input bundles to blocks and these bundles will be sequences of transactions and the user will express a rule saying, hey, these transactions must be executed in this specific sequence. But of course, right now on Ethereum there's no way of enforcing that the blocks which are executed actually obey these rules from the users. So in some sense the integrity of the computation has been violated.
00:13:14.422 - 00:14:34.174, Speaker A: A good example of this is the low carb crusader attacks which happened a couple of months ago. Another example is like avoiding an incorrect state resolution function. The output of a roll up computation is a new state for the roll up and this must come from the correct application or at least you should have the roller transactions that lead to the output state of the roll up. Another property we want from these intermediaries is the provision of information, right? And here I mean provision of information to the messages, to the computation, right? So really what we mean is correct input. And so if we think about the cal swap example I was giving earlier, we want not only that the batch that is executed clears the orders which were presented as the input, but we want the input to represent all orders which were contenders to be executed. Or in the case of a roll up, we don't want the roll up operator to censor user transactions. Another example is we want the intermediaries to provide up to date price information when they execute user orders.
00:14:34.174 - 00:16:24.840, Speaker A: If they're supposed to be executing these orders based on external world prices, then if we can guarantee that we have the correct input and we guarantee that the output which is presented actually maps to this input. The other thing we care about is privacy, which is to say that the the use of the information of the inputs of the computation and the output of the computation is restricted to its intended use, right? So if I, for example, send my orders to a batch auction executor, I both want them to execute the batch auction correctly, to not censor any of my counterparties and to clear me at a uniform price, but also to not front run the batch, perhaps sort of moving prices against or sort of giving me worse execution. And so that was the other side of the balance. But what can we say about these two sort of components, about Intense and mev together? How do they combine? What are the challenges of finding this balance? One challenge is that latency overhead reintroduces uncertainty. Remember I was saying that one of the benefits of intents is that they can reduce uncertainty for users. If the way we restrain intermediaries, the way we restrain the aggregation layer is through mechanisms which introduce latency, we are undoing some of these goods. And so what are examples of this proof computation time.
00:16:24.840 - 00:17:14.200, Speaker A: If we require ZK proofs of these kinds of things to guarantee the correctness of computation, this introduces latency. Another example is DA consensus. So if we're running some blockchain to some consensus protocol to prevent any individual party from censoring input to, for example, a batch auction, this also introduces latency. Tee overhead is another example. Another problem is that too much privacy kills counterparty discovery. So for example, you can't have a fully private order flow auction, or maybe you can, but it's likely not that efficient. Usually a counterparty needs to know some information in order to match an order.
00:17:14.200 - 00:18:03.960, Speaker A: I guess it depends on the market you're running. Another example is that the intermediaries face denial of service risk. And this is, I guess, a little bit different from the other two issues, which is to say intermediaries can't accept arbitrary messages because denial of service resistance generally relies on the intermediary being able to very cheaply verify that some computation they're doing is going to be valuable. And so this restricts the kinds of messages which users can send to intermediaries. Yes. I won't say too much more about that. So that's the end of my talk.
00:18:03.960 - 00:18:36.660, Speaker A: I hope that made sense. I was sort of brief for the sake of time and so there's a couple of things I didn't cover. I just wanted to be explicit about those. One thing is I didn't really give too many examples of intermediaries we see today. Or I guess I mentioned batch auctions roll ups. These are examples I didn't explain why reliance on trust and intermediaries is bad. I guess to some degree this is somewhat obvious, especially to a blockchain crowd, but I think there's a bit more of an argument to be made here.
00:18:36.660 - 00:19:12.160, Speaker A: And then finally, I didn't really explain how Flashbots is thinking about these issues. But this kind of discussion and the challenges which I listed before are certainly things we're thinking about. And so I hope I've sort of shed some light on the intense discussion, or at least given my opinion. And I really hope that people sort of keep in mind the concerns and the risks that come with introducing this layer of intermediaries, even if it does present better quality execution for users. Thanks.
