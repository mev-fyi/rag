00:00:00.170 - 00:00:17.082, Speaker A: Okay. Hi, there. My name is Anil Kumar. Sorry, my voice is a little close. I'll try my best. So my name is ANU Kumar. Me and my friend Yauchi who are sitting there, we work in project called All Fair and today we're going to present this idea of ZK fault proofs.
00:00:17.082 - 00:00:46.218, Speaker A: As you can imagine it's a mix of the or the fusion of the manetti proof idea that you see in ZK roll ups and the fault proof that you see in Optimistic robots. Well, this is a joint work with Risero team and so thank you very much to them for making a lot of truth available. Also working with us, with us before a little bit of marketing I suppose. So I told the station started with as a role for service providers we make it easier for people to deploy roll ups because we believe that there.
00:00:46.224 - 00:00:48.438, Speaker B: Will be hundreds more roll ups designed.
00:00:48.454 - 00:01:43.278, Speaker A: For different application use cases. And so our goal is to make it possible that even a marketing team member or business team member should be able to go and deploy a roll up by just a few clicks and buttons. We support many different tech stacks including popular out there in the market, but also other services like availability, interoperability and other services out there for roll ups to use. What we do beyond Ras is also interesting because we believe that once we have these roll ups they will need some other services. For example they would need interrog, they would need for example a fast financial layer and multiple effects. So we also try to make it easier for people to deploy or use some of those services that are not out there in the market. And so one thing that we do is basically we build what we call a map, which is basically a fast point layer which starts to mechanism to make it easier for people to have a better finality than what you can tell there.
00:01:43.278 - 00:02:48.426, Speaker A: But today's talk is going to be about this work originally was titled the OD couple ZK and optimistic roll ups but a scalability. If you want to read a full version of this presentation you can head over to Guest Zero's blog post now. So bit of background context, we all know that by now that Moral Exchange, Consensus and AA they are not very scalable. Over the last year or so we have seen quite a bit of push on modernizing the different components and the stack that forms the blockchain. So one thing that DA is quite high, but one thing that has really seen quite a bit of traction and quite a bit of develop activity is the extension component in the form of different roll ups that you see in the market. And because the extension moved out of EVM or Ethereum, you can imagine different other things that you can do with roll up that are CK based IoT proof model or roll up that are optimistic roll ups of fault proofs. You could imagine different runtimes because you're no longer limited by the underlying EVM.
00:02:48.426 - 00:03:14.170, Speaker A: You could imagine based roll ups and so on. You could start with general purpose teams. You could start with something like arbitrary from optimism. You can sing this call. But you could also boil down to a more pigeonholed scenario where you could say, hey, I want to go and build my own app specific chain, or I want to build a chain or wallet that's basically hemorrhoid so it doesn't stay for long, and I only want to use this word for a short while. And after that I would shut down the system. You could do that simply because you're moving the execution out of the base chain.
00:03:14.170 - 00:03:56.680, Speaker A: And so today's talk is going to be focused on the first component, which is you have these two flavors out there, which is the secret roll ups that variety proofs. And then you have optimistic roll ups that use four proofs. And the idea is, can we get the best of both worlds of it? And so very quickly, Zeke roll ups, as you may know, basically you have this sequencer aggregator proof or whatever you call it. In some case they are combined, some cases separate. They basically execute all the actions and they produce a proof for validity. And that proof goes back to the l one. On the optimistic side, slightly different, where basically everything's supposed to be correct.
00:03:56.680 - 00:04:43.042, Speaker A: And so the roll up sequencer basically puts transaction data on the L1. And then if someone feels like the state committed by the roll up is not valid, then you can raise challenges. And then you go to a passage where you basically prove that the malicious and the state is not valid. And so there are different pros and cons for both models. There are different trade offs that both roll ups make. For example in case of Tk roll up these are based on cryptographic proofs. You don't make any assumption a direct assumption on the honesty in the network while you have assumes that there's some party that is watching the network and that can go and challenge if the network commits a certain secure ropes generally have quite beating edge.
00:04:43.042 - 00:05:53.260, Speaker A: In some cases, people have actually brought and developed their own primitives to make these loops quite efficient, while the optimistic groups are much more classical. All you're doing is basically doing a bisection over the just so it's much easier to understand, much easier to implement compared to something. However, on the secret side, completion can be quite heavy, the food generation is quite intensive and so in some cases can take over a little while to basically go and generate these and so you tend to basically wait for a while and prove a generate your proofs for a passive. On the other hand, fault proof is basically communication heavy. So in the sense that when you do fault proving you want these challenges sequences to be basically online time for each transaction to be changed between these two and therefore that also results in withdrawal period. So Z capital is much shorter address while in case of optimistic make sure that these parties who are engaging in the bucket protocol they actually are live. So the idea is yes, both systems have certain pros and cons but they can be somehow combined these two systems into one physical system.
00:05:53.260 - 00:06:54.850, Speaker A: That's the idea of the stuff. So basically we are going to present you a construction which combines ZK proofs and porn proofs in what we call ZK four proofs. So the basic idea, high level idea of ZK four proofs is that look, in pure ZK rollups you basically generate proofs for every single transaction. Not really every single, but basically an idea is to for a batch of transactions you generate proof. But what if we don't do that for every single transaction? We do generate proof only when it's required. So it becomes much more on demand model so it becomes an on demand model where the proof is generated only when there's a challenger who says that look, I found something wrong, can you generate a proof for the last so just to clarify, it is not CKDM, it's not a CK value proof model. It's a model where you're asking a sequencer or asking the people to generate proof only when you think that the system has generated or the product has generated or balanced.
00:06:54.850 - 00:07:57.330, Speaker A: So there are two variants that you could use and implement this idea. So one is where you make minimal changes to the existing roll up design. So imagine you are starting with an optimistic roll up where you have sequencer and the challenger they do this off chain Bisection protocol and what you do is in a normal optimistic roll up the challenger basically comes with challenge and sequencer comes with one single instruction that both parties disagree on. So the sequencer says that this instruction has been executed correctly while the challenger says no, it has not been executed correctly. So basically that single instruction then gets executed. Now instead in this DK for prevailing you say hey, we have come up with this single instruction that you both disagree on. Instead of running this on chain, can we just generate a ZK proof for this single instruction and then the sequencer or the proverb behind that will produce a ZK proof for we generate a ZK proof for this single instruction and that proof gets verified on chain.
00:07:57.330 - 00:08:39.070, Speaker A: The second model would be slightly more involved where you don't do Bisection at all. Bisection is completely taken out and the challenger basically comes and says hey, this last state commitment that you made on the L1 seems to be invalid. Can you give me approved for this last state commitment? Note that sequence is not generating proof for every single problem. It is basically just operating in the optimistic model. So just sending transactions, committing the state. Only when the challenger puts a claim and says hey, something looks wrong here, can you generate me the proof. At that point the sequence of all the proof behind it will basically generate the proof of identity and that will commit badasses.
00:08:39.070 - 00:09:21.680, Speaker A: So this is basically replacing the entire matrix protocol by an on demand Zkv proof. And the demand basically comes from the challenge. So there are pros and cons to both variants. Obviously one is in the variant one. If you are building or you already have an optimistic protocol that's already live and running, you kind of have to do very little changes to support something like the variant one. So all you have to do is you can keep your bicycle intact, your contract that basically emulates the VM that will go away and now we will be running is verifying instead of running the instruction or chain. So it requires normal changes, somewhat backward compatible in that sense.
00:09:21.680 - 00:10:29.234, Speaker A: The good thing in this model is that now you're not limited by the runtime of ethereum. So for example, you could say hey, previously if you're looking at obstac for example, optimism, they have basically emulated an EVM system or insolidity on Ethereum. You don't have to do any of that because all you have to do now is basically verify approved on chain and this also gives you more flexibility in terms of expanding to other EVMs as well. So you could for example build based roll up and still have Ethereum basically verify the pool. However, the performance benefit is quite limited as you can imagine, because you're still doing the Bisection protocol and so it's not ideal because circulation is still heavy. And so this is where variant two kind of shines and does better the problem variant two is that you have to basically overall the entire design, your machine, entire architecture or how system works and so a little bit more intrusive to an optimistic role of Azure Life. You don't have to be live for the bisexual protocol to finish.
00:10:29.234 - 00:10:36.706, Speaker A: So basically all these parties are basically offline and the challenger is the only one basically watching the network. And if something seems to be incorrect.
00:10:36.738 - 00:10:38.710, Speaker C: Then the challenger will basically ask the.
00:10:38.860 - 00:11:15.566, Speaker A: Approver to post again, similar to the way you want, you can basically allow different kind of runtimes. So you're not no longer listening to EVM anymore and you can potentially reduce the withdrawal period. We have done implementation thanks to risk zero. So we started with an optimist role of implementation that is in Rust, which did fall through over WASM and it runs spotNICK VM in Rust and it has basically compiled EVM WASM instructions.
00:11:15.598 - 00:11:16.930, Speaker B: And then we have a wise.
00:11:18.790 - 00:12:28.650, Speaker A: For ZK proof, even though his zero now has most of the things that is now open source. We actually use the Bonsai service which is basically a remote service proving service where basically you can send your transaction and what you want to prove and then the bonus returns. You approve of that so that I think your proof is done over WASM and behind the scenes they use the VF which basically compiles everything Rust code to basically risk five and then they prove over risk five. So to conclude this talk, I want to highlight that the system, even if you go for this, this is still optimistic. It's not a ZK ruler, still optimistic nature one, because we still want party or challenger to be watching the network, they still want at least one honest party to make sure that the sequence is not misbehaving in terms of proving time. It's still, as you know, ZK roads are still quite expensive depending on the time perspective. So it takes about 15 20 minutes for the proof to be generated.
00:12:28.650 - 00:13:34.520, Speaker A: So it's still somewhat faster than a longer seven day drop here, but still substantial. Having discussed the caveats around what happens when a challenger basically keeps bugging the sequence and say hey, I found this invalid state, can you give it me approved even though the state was actually valid. So you have to have some mechanism of staking slashing mechanism where a challenger is incentivized to only ask for proof when there is an invalid state because otherwise it will basically turn into a ZK, which we don't want. Our current compilation pipeline is not very efficient. So we start with Helium, which is basically Rasp. We compiled them and then behind the scenes, again, risk deload of this risk pipe conversion. An ideal model would be take basically take your EVM and compile onto and then the idea would be you could integrate that with Op stack roll ups.
00:13:34.520 - 00:13:50.070, Speaker A: It becomes available to anyone who wants to spin up an app specific roll up using any OS. Well, that's it. If you have any questions, if you want to challenge us, we are here.
00:13:51.240 - 00:13:58.340, Speaker B: Thank you. Any challenges?
00:14:00.040 - 00:14:08.600, Speaker D: So, can you tell me a little about what implementation that made you the decision of converting it to vASm first.
00:14:08.670 - 00:14:11.816, Speaker E: And then the reason simply was that.
00:14:11.838 - 00:14:15.752, Speaker A: We had an implementation that was in Rust, so we went with that.
00:14:15.806 - 00:14:17.996, Speaker E: But as I said so you had.
00:14:18.018 - 00:14:20.990, Speaker D: The implementation for compiling it to WASM first.
00:14:21.360 - 00:14:24.748, Speaker A: We had an optimistic roll up. It's kind of like if you look.
00:14:24.754 - 00:14:27.068, Speaker E: At optimism today, I mean, like you.
00:14:27.074 - 00:14:33.472, Speaker D: Have the EVM in Rust and then you have a middle layer for RASM first, right?
00:14:33.526 - 00:14:34.032, Speaker A: Yes.
00:14:34.166 - 00:14:37.020, Speaker D: So why you are not directly compiling it to risk?
00:14:37.100 - 00:14:38.848, Speaker A: Yeah, this is exactly that we have to do, right?
00:14:38.934 - 00:14:39.570, Speaker D: Yeah.
00:14:40.260 - 00:14:42.556, Speaker E: Why did you no, because this risk.
00:14:42.588 - 00:15:06.510, Speaker A: Side is not we are doing it, this comes from risk zero. So behind the scenes, risk zero basically takes a Rust code and compiles down to risk five. That's what they do behind the scenes. What I'm saying that if they are only doing on risk five, why not they basically take EVM risk five and then becomes a little bit more efficient. So we are not doing that but this would be a better model to go for.
00:15:11.600 - 00:15:21.280, Speaker B: I have a question like can I understand it's more about reduce the fraud costarian two is more about the short term challenge?
00:15:22.020 - 00:15:33.252, Speaker A: Absolutely, yes. Because you're still doing Bisection, you can't really withdraw challenge. Beyond that you still have the liveness requirement for your road.
00:15:33.306 - 00:15:39.780, Speaker B: Any sizing are there any more test data about this performance?
00:15:41.640 - 00:16:26.070, Speaker A: I would say this is the most obvious improvement that I can think of. The other thing is of course on the proving side, right? So the better the proverb gets and by the way, this 15, 20 minutes, I can't recall the exact hardware, it's still a very performant hardware that phones are using behind the scenes. So imagine I don't know how many GPU is behind the scenes running. So if you do it on a normal COVID laptop so one obvious is that as the proverb becomes much more efficient, as you can run much more efficient proofs much more efficiently, you'll have much more faster. I would say that's of course, main bottleneck. Yes, it's good to have that. But this is not the main bottleneck, this is the part that dominates the cost.
00:16:26.760 - 00:17:17.280, Speaker C: So another point for the best section and instruction repetition, right? So if you use the variance one, if you do the best action and basically identify the instruction which can be sort of wrong, right? The tool for that one is super fast. It's like within 2 seconds. So there is a big balance because we provide sort of the rollout for different application capital for games and a lot of social applications. We couldn't afford prover cost. So every month roughly like $10,000 just for the proverb cost. So in that case, that's why we come up with this cannot be done. So try to shorten the fraud proof or fall proof.
00:17:17.280 - 00:17:28.490, Speaker C: Basically we because once you have the decay proof right, you don't really do the very lengthy Bisection. It's basically a balance between the cost.
00:17:30.380 - 00:17:31.370, Speaker A: And also.
00:17:35.580 - 00:17:36.810, Speaker B: Any more questions?
00:17:39.520 - 00:17:46.536, Speaker E: Is the verification cost the same for the instruction based dissection and the full transaction?
00:17:46.728 - 00:17:56.768, Speaker C: This one is for a full block. So for full block, typically less than 1 hour, it's like from 15 minutes to 40 or 50 minutes.
00:17:56.854 - 00:17:57.536, Speaker A: Okay. Yeah.
00:17:57.558 - 00:18:05.980, Speaker C: But for one instruction, if you finish the best action for one instruction, one instruction is very, very fast, it's within like I think 4 seconds or three.
00:18:06.070 - 00:18:06.324, Speaker A: Yeah.
00:18:06.362 - 00:18:08.692, Speaker E: So the Verifier is on chain, right?
00:18:08.826 - 00:18:10.304, Speaker A: Yes. Verification on chain.
00:18:10.352 - 00:18:13.604, Speaker E: Is there a gas cost difference between.
00:18:13.722 - 00:18:16.504, Speaker A: The because all you're doing a proof, right?
00:18:16.542 - 00:18:19.656, Speaker E: The proof is the same Verifier, right?
00:18:19.758 - 00:18:20.264, Speaker A: Yes.
00:18:20.382 - 00:18:37.520, Speaker C: So another tricky part for risk five die risa zero die is basically all the proof first in Stark and then the bound size manage to convert Stark to Snark and then you do the verification on chain.
00:18:39.300 - 00:18:40.656, Speaker A: Verification so you can.
00:18:40.678 - 00:19:01.670, Speaker C: See right it's not a direct EVM one to five it's just another dark to Snark and verification on ethereum for Op stack actually the ongoing work we already support the op stack proof we are trying to do more optimization on that.
00:19:04.700 - 00:19:19.464, Speaker F: Quick question for the fourth part so you said apart from the splashing for preventing unnecessary groups to have the sequence of producer group yeah, you could just.
00:19:19.502 - 00:19:24.444, Speaker A: Like then you are basically becoming is.
00:19:24.482 - 00:19:25.870, Speaker E: That also part of this.
00:19:30.640 - 00:19:34.712, Speaker A: Sequencer can produce approved because any proof gets verified on chain yes.
00:19:34.866 - 00:19:36.464, Speaker E: So like what inputs would you take.
00:19:36.502 - 00:19:37.650, Speaker F: From the other one?
00:19:38.980 - 00:19:59.450, Speaker A: Because if sequencer puts the proof sequencer pays for the proof verification on chain and so there's already kind of spam prevention built in for proof of stuff because one it has to spend a lot of time to generate the proof why do all the work when it's not needed? I think the main problem is on the challenger side there's a challenge that basically can spam you and say hey, give me this, give me this, give me this.
00:20:02.220 - 00:20:10.108, Speaker F: But if there's enough incentive, the sequencer can also be provided enough incentive of the time that was very proof you.
00:20:10.114 - 00:20:48.090, Speaker A: Can still yeah, you could do. And actually the other thing is, which I didn't mention, which is it depends on how let's say, for example, optimism or artifact from you commit state after a certain period of time, if that's very, very long. Let's add one day to let's say, for example, in something, because it's an app specific context, you could say I'm going to post commitment every five days or so. In that case when the challenger said hey, your last one week transactions are all invalid, then it becomes more complicated. So you have to also take into account the duration and the length of how far back it will go.
00:20:50.300 - 00:20:53.640, Speaker B: Okay, one more question.
00:20:53.710 - 00:21:07.710, Speaker D: Okay, so I think last month we have a decay like cloud proof mechanism on testnet like for obvious tag. I think it's overlaps right? I'll give it.
00:21:14.740 - 00:22:00.060, Speaker G: Risk zero. Solutions are different from this where you can think of this as you do some bisection or some argument on chain first offer what needs to be proven and then you come with a ZK proof to finish it. What they're doing is basically just like a complete ZK roll up replacing the proof entirely with the ZK proof. And then the beautiful thing there is that what risk zero and one maps can do is they can take the same definition of the staking session that the pop proofs proof and use that same definition and proof and verify virtual machine. So you don't have to draw a lot of custom code just to prove something from a one map.
00:22:02.720 - 00:22:03.820, Speaker A: Presentation.
00:22:06.960 - 00:22:07.676, Speaker B: Thank you.
00:22:07.778 - 00:22:09.652, Speaker A: Thank you very much around.
00:22:09.706 - 00:22:15.410, Speaker B: If you have any thoughts yeah, we can discuss more after. Okay?
