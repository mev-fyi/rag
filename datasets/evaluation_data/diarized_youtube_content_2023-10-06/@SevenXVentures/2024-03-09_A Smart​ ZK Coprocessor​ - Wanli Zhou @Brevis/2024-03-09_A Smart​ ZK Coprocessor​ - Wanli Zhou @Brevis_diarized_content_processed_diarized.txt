00:00:00.250 - 00:01:26.466, Speaker A: I'm Juan Lee from Brevis, and today I'm going to introduce you to Brevis, our ZK coprocessor for data driven Dapps and user experiences. So we are all familiar with Ethereum and its various scaling solutions like alternative L1s or L2 roll ups. Whether it's optimism or arbitrary or different kinds of ZK rollups, we think these efforts and attempts are great, but we still feel like these improvements are not enough in that these are still blockchains that rely on distributed consensus, meaning that they are going to be generally bad at data rich or complex computation. And you may wonder, what is data rich or complex computation and why does it matter to blockchain? So I'm going to walk you through a simple example of a trader loyalty program. So imagine you're trying to build a trader loyalty feature for an onchain protocol like uniswap so that a user can verify through Uniswap that they have completed over 10,000 trades in the past 30 days for a total volume of over $30 million worth of value. So that uniswap will then grant the user a VIP status, and then the user is then able to enjoy 50% off for future trading fees. So such a feature is very common in web two centralized exchanges.
00:01:26.466 - 00:02:43.786, Speaker A: Usually like we see VIP fee tiers associated with a user's past trading volume. It encourages trading activities because the more you trade, the better discount you are going to get, but it also increases user stickiness to a specific platform or service. So it's natural for us to want to have something similar for web3. But the reality is if we want to keep everything decentralized and trust free, we're going to see very high cost and a long time for verifying a single user's VIP status. Actually, we did an estimate and it would take 4 hours of computation time on chain as well as 20,000 in gas fees. You may be surprised by the result, but the reason why the onchain computation to verify a user's status is so costly and time consuming is because if we're trying to keep everything decentralized, if we're relying solely on the consensus of layer one, we're trying to implement such a feature and run the program on chain in smart contracts. That would require the smart contract to firstly remember the state roots of all of the users past relevant transactions, and then we'll have the smart contract to calculate over 10,000 merkle proofs of inclusion on chain.
00:02:43.786 - 00:04:05.642, Speaker A: And thirdly, we'll need to decode each transaction to retrieve the value of each user trade that's relevant, and finally, aggregate those values to come up with a sum of the user's trade volume, and use that volume to compare it against the criteria that we set up for a VIP user. So from this example, we can basically see the several major limitations for onchain computation. So firstly, smart contracts are generally just they don't have trust free access to all historical on chain data, although it sounds very counterintuitive, but that's the reality. Secondly, smart contracts don't have trust free access to data on other blockchains, so you cannot access trust freely access data from BNB chain while you are deploying smart contracts on Ethereum. And thirdly, smart contracts are generally bad at data rich or complex computation. So the thing is, for web two applications, the reason why there are a lot of unique features or tailored user experiences in web two applications is that they really care about data. And there are a lot of data driven user experiences built in centralized exchanges or game projects in web two.
00:04:05.642 - 00:04:57.610, Speaker A: But if we're trying to also have such data driven experiences in Web three, we really need to alter how we think about processing or computation. So that's why we think Ethereum needs a coprocessor, so that the blockchain itself can focus on transactional computations, while the coprocessor can then focus on data rich and complex computations. The blockchain is going to offload computation requests or data, I mean tasks, to the coprocessor. And after computation, the coprocessor can then return the results back to the blockchain for verification and use. And all of this needs to be designed and implemented in a way without compromising the trust free nature of blockchain. So without compromising distribution. That's why we built brevis.
00:04:57.610 - 00:05:57.230, Speaker A: This is kind of tricky. So Brevis can run arbitrarily complex computation on any historical on chain data and then generate an easy to verify attestation for the computation result. And all of this is done through the use of zero knowledge proofs. Usually when developers are trying to utilize zero knowledge proofs to build something, they'll need to get familiar with how to write arithmetic circuits. And this is usually a long on renting process because of a lot of learning. And that's the reason we think for zero notch proofs to be adopted widely, we'll need to have something easy for developers and for us. We have built an SDK that's written in goal, so that developers without much knowledge in circuits or zero notch proofs can easily on Ran and build data driven dapps.
00:05:57.230 - 00:07:04.180, Speaker A: So with our SDK, you'll have customizable access to on chain historical data. You'll also be able to build customizable computation logic and most importantly, no circuit knowledge required. So for a developer to use Brevis to build your data driven user experiences, to build your data driven d apps, essentially there are three steps involved. The first step is read. So Brevis allows smart contracts to read from the full history of on chain data, including states, transactions, events in our data access module. In our SDK, developers will be able to specify what type of specific data is required for their computation logic. So in a code example here, this code block essentially is trying to basically retrieve all of the swap events of a single recipient or user address on a pool, uni USDC Eve pools from Uniswap V three.
00:07:04.180 - 00:08:17.594, Speaker A: And the second step is compute. So basically, based on the data specified in the earlier step, developers can then build their computation logic, run their computation logic in an app circuit. So the app circuit is named a circuit, but actually abstracts away the implementation details of a circuit so that developers can easily basically onboard to brevis. And in the code example here, this app circuit specifically is doing a sum of the different trade values from our previously specified swap events. And in this entire process there will be 20 knowledge proofs generated. The first one is generated through Brevis, the ZK coprocessor, to prove that the data retrieved from the swap events, or any kind of specified data actually exists in the history of blockchain. And the second proof, the second ZKP is generated through the app circuit to prove that the computation, the sum volume computation on top of the swap events actually is correct.
00:08:17.594 - 00:09:25.200, Speaker A: And then in the final step, these two ZKPs are going to be combined into one single ZKP to be submitted back on chain for the Bravis smart contract. And then after verification, the Bravis smart contract is going to send some volume output from the ZK circuit to the uniswap trader loyalty contract so that the trader loyalty contract can then verify the result, I mean not verified because it's already verified, but use the result directly and confirm if a user is eligible for certain trading discounts. So, to illustrate how these steps, these three steps read, compute and verify, actually work in action, we have worked with Uniswap foundation to build a uniswap V four VIP discount hook so that the hook will check basically before a user trades, whether the user, the trader is eligible for certain VIP tiers or discounts. And here is a short demo of how it works in action.
00:09:27.080 - 00:10:19.940, Speaker B: Complete a trade to activate your VIP status. Once the trade is confirmed on chain, you can activate the silver VIP status to get a 20% discount on trading fees. To activate the silver VIP status, the VIP discount hook queries a zero knowledge proof from Brevis Brevis will compute your WBTC USDC trades for the past 30 days and generate a succinct zero knowledge proof of your total trade volume. After the sum volume proof is generated, you can then submit it on chain for the hook contract to verify. You can also view the result of your zk proof verification on chain. As you can see, we have successfully verified our uniswap sum volume proof in the hood contract. Once verified, you can trade with a 20% silver VIP discount.
00:10:27.880 - 00:11:59.860, Speaker A: Yeah, so this is not the only type of data driven experiences that you can build with Brevis support. Because Brevis supports multi blockchain data access and verification, developers can actually build their unified user experience across multiple chains using powerful computation. And that means for DeFi protocols in general, DeFi protocols will be able to adjust key parameters in their protocols, including trading fees or liquidity incentives to improve user retention, user loyalty and capital efficiency. And all of this is based on dynamic on chain data input and for gamify projects. Gamify projects, I mean video games in web two usually rely heavily on users past activities to segment the user groups and then build unique user journeys based on top of their specific groups. So if we have data driven features on chain, we can also have gamify projects build unique onboarding or liveops events features based on users segments. And for identity protocols, they can use Brevis to attest user to user or user to protocol connections so that they can have the user confirm whether they're eligible for campaigns, referral programs, and also they can build zero knowledge proof of humanity or anti sibo solutions.
00:11:59.860 - 00:12:55.110, Speaker A: And without relying on external validation models, you can also use Brevis to build zero knowledge bridges. You can add risk management directly in your smart contracts. Also you can build social recovery wallets. So to further enable developers to create data driven experiences with lower cost and also with faster finality on chain, we are launching a new upgrade for brevis called the brevis coaching. It's going to combine crypto economics as well as zero knowledge proofs, and I'm going to share a little bit more on how it's combined later. But essentially the goal of Ravisco chain is to improve cost efficiency of computation of zero knowledge computation. And also it will support further use cases like proof of non existence, which is hard to do with zero knowledge proofs only.
00:12:55.110 - 00:14:13.176, Speaker A: So with this new architecture of bravisco chain, essentially the core component in this architecture is Bravis coaching. It's a proof of stake chain with on Ethereum staking and slashing. And it basically is a model that uses a proposed challenge optimistic roll up like model, and it will optimistically generate a POS result for coprocessing request from the blockchain. And these results, these POS results are going to be subject to challenge by zero knowledge proofs. So how it actually works with a simple flow example is that let's say there is an app contract on chain and the app contract is trying to validate something or prove something. It's going to send the core processing request firstly to Brevis and the proof of stake chain in Brevis code chain will then do a simple consensus quickly and then send the POS result back on chain to the smart contract as a temporary result that's subject to challenge. And once the result is submitted to the smart contract, it will actually start an application specified challenge window.
00:14:13.176 - 00:15:22.790, Speaker A: So the length of the window is specified by the deployer of the smart contract. So the developer you can determine how long you want the challenge window to be. But during the challenge window, any interested party or challengers can initiate a challenge computation period. So they can basically say I want to send a challenge claim on chain to start this computation period using the Bravis ZK code processor. So while they submit the challenge claim, the challengers will also need to submit on chain an honesty bond so that we don't just allow some random malicious factors challengers to extend the co processing time. And then during this challenge zk period, the challenge computation period, the Bravis ZK coprocessor will then do the computation on the same coprocessing request and generate a zk proofed result for the same request and send it back on chain. And this result, since it's supported by zero knowledge proofs, will see it as the correct result in this proposed challenge model.
00:15:22.790 - 00:16:29.800, Speaker A: When the result, I mean the ZKP result is submitted back on chain, it's going to be compared against the previous proof of stake result. And if it contradicts the proof of stake result, it means that there is some error in the proof of stake result and the proposer the proof of stake chain is going to be slashed and the challenger is definitely going to receive the rewards. But if the two results are the same. It means the proof of stake result was originally correct. That means the challenges just randomly started, an unnecessary challenge, or their honesty bond is going to be slashed just to disincentivize some random challenges. So there are cases when during the application specify window, there are no challenges initiated, either because the window is very short or challengers are not interested because of lack of incentives. But still on top of that, there's going to be an overarching cold chain slashing window that's usually longer than the application specified window.
00:16:29.800 - 00:17:38.912, Speaker A: And during the cold chain slashing window, still, even for already confirmed and finalized results on chain from the POS results, challengers interested can still initiate a challenge claim so that they can rectify the previous faulty results to prevent further use of the previous faulty results. So the goal of this design, the aim of this design is to combine the timeliness of crypto economics or namely proof of stake chain, as well as the soundness and completeness of zero knowledge proofs so that developers will have the liberty to basically decide what's the best balance between latency and security. So yeah, we're generally very interested in new use cases that can be built on top of brevis. There are just so many different verticals in the blockchain that we can work with. Brevis can work with. So if you're interested, definitely feel free to follow us on Twitter at brevis underscore zK. And if you have any ideas or questions on our SDK, definitely feel free to reach out to us.
00:17:38.912 - 00:17:47.010, Speaker A: Thank you. Yeah, feel free to share thoughts or if you have any questions.
00:17:47.380 - 00:17:59.776, Speaker C: Yeah, so you mentioned that using beverage you can create account recoveries, like account recovery wallets. Can you talk a bit more about that? How do you do that? A reward around social recovery wallets.
00:17:59.888 - 00:19:27.490, Speaker A: Oh yeah. So the idea is just a model that can be built on top of Revis, but we don't have an implementation design for how this actually works. But our idea is basically like in web two financial services, sometimes when you forget your password, you can use other means to verify you are the owner of your account. So how that works usually is sometimes asking you about your historical transactions, like what has happened at what time, and sometimes in certain regions of the world, they would ask you to verify through your connections to other people. So the idea is if we can have like a private way to prove that you do have these connections and you do know your historical transaction and these people, your connections can prove for you that you are the owner of your account without exposing that they are individually your connections because of privacy issues, then it would be really nice. So through zero knowledge proofs you can hide that details but still verify through these connections that you are the owner of the account. So that mostly kind of uses the zero knowledge portion of zero knowledge proofs, but also is trying to touch on the trustlessness of that technology.
00:19:27.490 - 00:20:10.050, Speaker A: Has barons tried to experiment with LVR related hooks? With what? LVR related hooks? Sorry. LVR. LvR try to figure out the toxic flow. Yeah, I haven't done much research into that, but yeah, if it is like a good use case and if it requires privacy, requires large amount of computation on chain and you want to keep decentralized station as the focus, then definitely revis is targeting those use cases. So complicated computation, very complicated logic, or a large amount of transactions.
00:20:13.270 - 00:20:28.838, Speaker D: Sure. You mentioned an example where with the VIP program verification without Brevis, it took 4 hours and $20,000 an estimate of what it would take, how long and how much it would cost with.
00:20:29.004 - 00:20:55.920, Speaker A: Yeah, so our recent benchmark is around several minutes for several dollars, like covering the onchain gas cost. So several dollars to verify a single user's VIP status covering on chain gas cost for a couple of minutes. But the specifics are still like on the go because we are constantly exploring new ways to improve the cost aspect as well as the time aspect. Yeah, thank you for the question.
00:20:57.170 - 00:21:01.694, Speaker C: How do you build a loyalty model which is, let's say, spanning across chains with Brevis?
00:21:01.822 - 00:21:47.390, Speaker A: Yeah, it is possible, let's say like for uniswap, because they're launching on multiple chains all the time. Not all the time, but they do launch on multiple chains. It's very common for such Dexes to want to want to basically incentivize users or LPs on these different supported chains with their protocol token, which originates from just one single chain. Yeah. So how that works is, for example, it's likely to use brevis to basically say we want to keep reward claiming still on one chain. Let's say it's on Ethereum for uniswap. However, while LPs are farming, they are farming on these different chains.
00:21:47.390 - 00:22:23.126, Speaker A: But the farming results or details can be sent back in a message through brevis to the original node chain to Ethereum. So LPs are farming on these different chains, but they are not actually claiming the reward tokens on these chains, but they are claiming the rewards on the source chain on Ethereum. But all of these crosschain message passing can be supported through zero knowledge proof through Brevis so that will minimize the risk or will limit new trust assumptions.
00:22:23.238 - 00:22:34.810, Speaker C: But what if, let's say as uniswap, I want to reward users for the 30K transaction volume across all chains? For example, loyalty status of 30K volume across all the chains, irrespective of where I have that?
00:22:34.900 - 00:22:59.734, Speaker A: Yeah, that's doable too. Essentially just passing messages across the different chains and then using one chain to kind of aggregate those transactions and send rewards to users. Thank you. Any more questions? Sorry, say it again.
00:22:59.772 - 00:23:01.566, Speaker C: How is the coaching going to be secured?
00:23:01.698 - 00:24:13.230, Speaker A: Yeah, so it's a combination, it's more like an optimistic roll up model, but not really a roll up. So it's a combination of a proof of stake chain, the coaching itself, which is basically going to be covering low value transactions. Like it's very likely for a developer to want to only rely on a proof of stake chain or set a very small application challenge window for low value transactions because they care more about latency, they care more about fast finality. So the proof of stake chain is going to most likely be used for lower value transactions, but for larger value transactions if security matters more, then definitely developers can prolong that application specified window and to utilize more the zero knowledge coprocessor to cover computation. So that's the idea of the proposer being the proof of stake chain and zero knowledge proofs being the challenger. Okay, no more questions about CK co processor. Yeah, definitely follow us on Twitter and shoot us messages.
