00:00:00.410 - 00:00:37.400, Speaker A: Perfect. So, hi everyone. So what I'm going to present is what we've been working on at one app, which is a TKPM for the mix architecture and particularly for the optimism. For optimism. So I'm going to dive into the implementation of the TKVM and the different choices that we made technically, and the cryptographic component. So it's the same that I'm going to present in three days. It's going to be the same as.
00:00:37.400 - 00:01:22.626, Speaker A: So quick introduction. So I'm Daniel Naps from Olnaps, I'm a cryptography engineer. So what's OMAP? So one maps has been founded in 2019. So we incubated the MinAP protocol and we continue developing it, but we do not focus only on MiNAP. So we still continue to develop Mina protocol, but we focus more broadly on research and development around geolis technologies. So to introduce very quickly a stack. So we've got different components in our stack that we use, and it's going to be related to the CKPN.
00:01:22.626 - 00:02:26.070, Speaker A: So we've got first kimchi, which is a rust library to prove the correct execution of programs. So it's ground based, it has custom gates and also some lookup arguments, and also it's recursive friendly and it's very modular. Also, quite important to mention that is because it help us to integrate the work for optimism for the people's groups. On top of that we've got Chicos, which is our recursive here. So it's the Okama framework to write smart circuits as inductive tools. So we use hello tool as a protocol version, and on top of that, so that's more low level. But we want to bring also Zksnock to the web developers.
00:02:26.070 - 00:04:12.406, Speaker A: And so we developed a library of framework in typeScript, which uses kimchi and pickles that helps web developer with a nice interface to write ZK Snark in a web. Now what we are just adding is ZigavM for the mix architecture and in particular for optimism for the optic stack. So yeah, I'm not sure I can mention that, but I'm going to go through this anyway. So what's optimism for the DK? Dad? Sorry, I'm going to go very quickly. It's a L2 scalability solutions for Ethereum based on optimistic roll up, full EVM compatible and optimistic means that the state conditions, therefore the transactions are accepted without any verification. So the L two state commitments are published on the L1, and there is a challenge window where the states can be refuted and there is the Op program, which is an implementation of four proof program that can be run in a MIPs VM that's called canon to prove false in claims about the air, to state on the air one. Why I'm mentioning that is because we had already some ideas and maybe some code to write the ZKBM.
00:04:12.406 - 00:04:44.342, Speaker A: And optimism came with this RFP to smartify, let's say the oP. So let's go into the ZKvm. A better name is pronounced at the moment. So what's the ZkVM? Zkvm. So that's a joke that's on the website. I really love it, by the way, guys. So it's rust code.
00:04:44.342 - 00:05:24.850, Speaker A: That's because that will be linked with ocaml code, because that will be compiled into WASM and JavaScript. O one Js binding. They will have a typescript interface. O one Js I'm lying on this tree for designation. We're not going to use that, but again, just for the joke that's going to be originally go code, so they miss VM arithmetizing a mixed machine. So that's what I'm going to describe after running compiled go code. So Joki program and jokey program runs a part of the gap code.
00:05:24.850 - 00:06:03.814, Speaker A: So the Ethereum node and that was running compile go code that runs an EB. So that was just for the truth. So the mixed architecture that we've got to support is a very specific one. So we've got 32 registers plus two other registers that I use for integral rectification application. There is a memory of bitch size of 4K. There is no floating point arithmetic to support at the moment. And external data can be read using system cores.
00:06:03.814 - 00:07:08.630, Speaker A: So when we said external data is the blocks, the LP blocks that is used as data to run the instruction to run on some data, and it's done using the system. So I'm going to describe the cryptographic choices that you made. So it's most specifically for cryptographer hypothetical. So yeah, so the structure of the ZK VM. So when you think about a VM, when you've got to arithmetize in a circuit, what you've got to do is to describe the instructions that are going to be executed. And therefore a VM is just a transaction, a transition from one state to another. So an initial state and a final state.
00:07:08.630 - 00:08:08.810, Speaker A: So we first commit to the initial and the final state of the memory and the registers. And what's very important in the DPM is how you going to read and write from the memory and the registers. So the instructions can read and write registers and memories. So in the CK world, we use what we call arguments. So we use a variance of mvlookup multivariate lookup that we call Ram lookup. So it's a work that we started before the RSP. How it works is we do a vector lookup on the memory index, the value, and also the last time that we read and write into the memory and the registers.
00:08:08.810 - 00:09:05.094, Speaker A: Also we do a range lookup on the left read and write index for history. And also multiple polynomials are used for the different lookups that we do. That is instruction. So one instruction is one word, and we can fetch multiple times the memory and the registers, and read and write multiple times. So we represent that by using multiple pre nodes. So for the instructions, they encoded as selectors in the circuit. And when we were implementing the TKVM, we needed a way to represent the internal state that an instruction uses.
00:09:05.094 - 00:09:47.720, Speaker A: So an instruction is going to fetch some memory, and some registers is going to perform some operations, and we've got to represent the ZKVN. So for that we use a certain number of columns. It's 25 at the moment. Let's see if we increase or not. As optimism is compatible with Ethereum, it's primarily developed for Ethereum. We have to have a way to be compatible with Ethereum. So we decided to use polynomial commitment scheme KZG and with the curve PN 254.
00:09:47.720 - 00:11:31.500, Speaker A: It was not the case initially in kimchi, but thanks to the modular kingsheet, the Modular Kimchi library, the modular aspect of the Kingshee library, we could integrate it very quickly. And when you've got a program, you can have very long execution trace. And we decided to use a folding scheme that is based on Nova, which consists of reducing each polynomial to a degree two, because Nova only works on degree two, and as far as we know if it's recorded, but we think that it's the first Nova implementation with custom gate and lookup support. And as the Nova audit scheme requires a cycle of curve, we had to have another curve that is, so we didn't find it from. And also the DOP program is going to fetch some external data. And so we decided to implement also an integrity check. So to be sure that the Canon implementation, at the moment when there is a pre image key, the external data are not hashed to verify in the VM that the data corresponds to the hash that the program asks for.
00:11:31.500 - 00:12:51.090, Speaker A: And so we decided to implement an optimalized version of ketchack which uses a sparse representation of 16 bits for the booleans and also the X operations operate on this 16. On the, on the expansion we expand on 64 bits, the 16 bit for these booleans also I don't give the number at the moment, but we think it's also close to the state of the art or even the state of the art in circuit and it's done to read the external data using. So that was quick presentation of the different components of the ZKVM. We don't want to only have this first PoC for the ZKVM. For the op stack we think that we can trick and optimize the current implementation, especially for folding. We have an off site and we had a very good, we had some ideas to improve the folding implementation. We want to also test with other programs and the stack.
00:12:51.090 - 00:13:44.020, Speaker A: We also think about extending to modern instruction set architecture. It's just IDs at the moment. It's not committing to anything. And we investigate also new research in the space of ZKVM and also MCC, which stands for memory consistent check, which starts to be quite trendy at the moment. So amazing work. Thank you. We've got to chat up with some questions.
00:13:44.020 - 00:14:05.530, Speaker A: How long is the proof gen? How long is the proof generation? I don't know at the moment I cannot give numbers, but we give numbers on the group. I think it's two weeks or two weeks we give an update. I'm not responsible for that. Sorry, I cannot commit.
00:14:08.910 - 00:14:33.042, Speaker B: Confused about the DK tool architecture. In the first few slides you mentioned that you are using Halo and then in the end you mentioned Nova. So as far as I know, Nova is like concept replace improvement with halo replace. Which one is a very good question.
00:14:33.096 - 00:14:45.330, Speaker A: For the zkvn we use nova. So I mentioned hello two, because it's our current stack. So it's the one we use for the Mina protocol and it was the first version of the recursive layer.
00:14:45.410 - 00:14:50.294, Speaker B: And by Nova you mentioned that you have custom gates and also I think lookup tables.
00:14:50.342 - 00:14:50.940, Speaker A: Correct.
00:14:51.550 - 00:14:55.900, Speaker B: By that do you mean like supernova and hypernova or you mean like your own thing?
00:14:56.590 - 00:15:01.374, Speaker A: I would like to refer the papers to say if it's equivalent because in.
00:15:01.412 - 00:15:14.640, Speaker B: Supernova their main contribution was having multiple circuits in each step after recursion and in hypernova they use lookup tables, I think. Is that the same thing?
00:15:16.150 - 00:16:08.602, Speaker A: I would like to read first to be sure that I can say sorry if I cannot, don't have enough time. Yeah, so already have implementation of Nova integrated. No it's integrated in there is to go with Nova or your. Yes. So the interface is quite clean. So you just give, let me try to remember the interface, but you just give two instances and you can fold. And I don't remember the API, but we want to have this intention.
00:16:08.602 - 00:17:09.160, Speaker A: Yes, correct. There is an initial PR called routing. So during the implementation is there any incompatibility with the existing token code or EIP. So the first goal is to run DOP program. We still are dealing with some construction so I don't think so. There was something that we would be nice to have is the C scores can only read and write four bytes at a time, which is annoying because we've got big amounts of data with hundreds of bytes. So that would be nice.
00:17:09.160 - 00:18:21.920, Speaker A: Every instruction to be as small as possible because the best action already helps you reduce it to a single instruction. So the smaller instruction better, whereas with the Zika proof you have to running through all the instructions anyway. Better to have less instructions that are larger than have many instructions that are small. I spent a lot of time in training, I'm sure we can find. I was responsible for the difficult quick question on the agile implementation. So compared to Halo, I don't understand the link. No, I know you use the electric out of the box, not the system itself.
00:18:21.920 - 00:19:08.620, Speaker A: The halo two repository, they've got a K shack implementation. I have a benchmark with it. I only check aztec. We had a first check with Aztec and apparently they use also programming how you want to call it. So we have to bench it. But first side we have a more efficient issue. You can check the repository to be sure that we don't like.
00:19:14.870 - 00:19:25.600, Speaker C: For any more questions. If no, we will have a ten minute break. Next we have more from so to talk about map when MVP and we also have such.
