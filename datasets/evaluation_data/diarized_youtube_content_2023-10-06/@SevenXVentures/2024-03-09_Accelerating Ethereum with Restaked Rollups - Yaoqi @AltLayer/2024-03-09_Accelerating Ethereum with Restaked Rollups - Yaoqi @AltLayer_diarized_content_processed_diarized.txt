00:00:00.570 - 00:01:04.510, Speaker A: Yeah, so roughly about earlier, as you know, at earlier we are building this rollab as service platform. But at the same time we're also developing some new advanced features for rollabs, mostly based on the requests and demands from our customers. That's why since last year, closely working with Eigen layer we started to build is a bunch of sites new features for roll ups we call restate roll ups. And today roughly, I will just explain what's restate roll up and why we need it and how we build the restate roll ups. So the further thing, I believe for most of the audience here, you're quite familiar with the roll apps, right? So basically for the past, I would say past two years, the entire roll up space, especially roll up stack, are becoming very mature. Started with op Stack and then it's Arbitram, Orbit and Aphrodite. We also have Polygon, CDK for ZKebM and also rollapse.
00:01:04.510 - 00:01:42.122, Speaker A: And right now we also have ZK sync. The ZK stack. Yeah. Fortunately on our side, we are the official partners for all of them. So we are helping them to push the rollap stacks to help a lot of projects to launch rollabs, especially for gaming industry. We are working with a lot of gaming studios with very big ips from Bandai, Ubisoft, Saiga and also social applications and some new Defi protocol like per protocols. So the idea that right now, compared to a few years ago, I've been in this space a long time.
00:01:42.122 - 00:02:33.722, Speaker A: I started my research back in 2012 mainly on consensus protocol. And then luckily I called a trend of scaling solutions around sharding back in 2017. Also at that time, near plasma, after the ideas, there was this trend on app chains, right? Cosmos, IDK and also Polkadot substrate. After like, as I mentioned for the past two years, roll up are really becoming popular. Now. One thing I want to mention, right, I suggest apart from the roll up stacks becoming more mature, right, a lot of roll up service providers like us, and also there are a bunch of some other projects or companies just make spin off roll up as easy as you spin off a node on AWS. So in that case, as you can see right now, if you want to deploy a roll up, it's much easier.
00:02:33.722 - 00:03:48.678, Speaker A: And basically it's as simple as you deploy smart contracts. And sometimes it's even much simpler than deploy a smart contract because typical, you don't need actual tokens for deploy the roll up. And based on our experience, somehow by the end of this year, we can see roughly we will have at least 1000 roll ups, either publicly or in private. Right now, most of the services are quite mature and it's just like very straightforward for developers to deploy the roll ups. And the issue is, at least on our side, I believe most of you use this l two frequently, right, either op arbitrary or different ZK roll ups to do tradings and also to use various apps on top of it. But based on our experience, when we talk to the customers and clients, when they reach out to us, there are all different requests and demands, and some of them just beyond our crypto native developer or company's expectation. For example, some companies want this zero gas and subsecond latency for either roll up or whatever blockchain system.
00:03:48.678 - 00:04:40.022, Speaker A: And some of them they couldn't accept they are just one sequencer. Because regarding to their law, if they just have one sequencer, then it's a custody. So that's why as I listed here, right, we have all the midnights for the existing rollout, right? Op arbitrum, we have like billions of dollars TVL and it's quite successful. At the same time, it really served the demands from our crypto native users. But at the same time, as I just mentioned, people may complain about, okay, for all the existing rollups and also existing roll up stacks, they are just a single sequencer. For big names like Op Arbitrum or even Coinbase, it's fun. We know they have big backers, but for some new ones, for example, we are launching a new roll up called like seven x hacker horse or something.
00:04:40.022 - 00:05:56.090, Speaker A: Then for people they may not understand, who's a backer, probably is anonymous guy, or it's launched by Lewis or Grace or Aries. But in that case even we say okay, it's secure by fraud proof or the ZK proof. But in the end, we all know that it's sort of a single sequencer with a single prover, basically all controlled either by the anonymous provider or by the anonymous project owner. So in that case, we somehow, we want extra verifications to make sure for these all new roll ups, right? Apart from this, by default, this fraud proof or Ziki proof, by least you have a separate network to ensure the security guarantee and also this verification stuff. And beyond that, if we really have dozens of roll up, I believe probably yesterday Mark master mentioned about this liquidity fragmentation. So the thing like we have so many roll ups, and by default we have the native bridge to Ethereum or to the settlement layer. But at the same time, when we build the DeFi protocols on the roll up, everyone wants to have the bridge or interoperability across all different roll ups.
00:05:56.090 - 00:06:38.838, Speaker A: So in that case if we really have 1000 roll ups or chains, right, it's always very challenging. That's why OpE has super chain and sort of this polygon just released their agri layer to try to solve this problem, at least for their own test deck. So these are roughly the issues we are encountering. And our solution is basically to work with Eigenair and build a bunch of services. And we call risk roll up. And there are a bunch of things or the misunderstanding we have around restate roll up sort of here. So first, it's not a new roll up stack.
00:06:38.838 - 00:07:08.578, Speaker A: So the risky rollout features are basically complementary to all the existing rollout stacks. For example, we don't change any code of op stack, arbitram, orbit, polygon, CDK or ZK sync ZK stack. And the second thing, we are not launching our own l two because some project reach out to us. Okay, what's all here is l two. We want to deploy a smart contract. So it's definitely a misunderstanding. So we are not building a new roll up stack.
00:07:08.578 - 00:07:54.094, Speaker A: We are not a roll up. And at the same time the roll up security guarantee is still from their own security mechanism. It's not like we are providing extra sort of security guarantee for that. For example, if you are optimistic roll up, then your security guarantee is still from the fraud proof. Is that like how you design the fraud proof? How you make it permissionless? If it's a ZK roll up, right. You always have your own ZK proof to secure it. And remember that these are not the sort of the risky rollout we provide, but at the same time what we are offering just to address the existing issues we have for all the existing roll up stack, basically based on the request from our customers and clients.
00:07:54.094 - 00:08:31.978, Speaker A: The further thing, as I mentioned, it's very important is compatibility. And we don't really change all the existing stacks, but at the same time we make our features and also these services plug and play. Beyond that. Later I can show you more why we offer better decentralization, security and also faster finality. So as I just mentioned, right, as a risk roller, basically it's a bunch of features. So far we are providing three features. One is vital we call decentralized verification.
00:08:31.978 - 00:08:53.366, Speaker A: The second one is mark. It's on top of vital. Like based on the decentralized verification we provide, it's a faster finality. And a separate thing is squat. It's a decentralized sequencing. Later I will explain why it's a decentralized sequencing and we are still working together with our partner express on the shared sequencing. So there are some difference.
00:08:53.366 - 00:09:47.014, Speaker A: But I can explain why we need it and at the same time why they are important for the existing roll up stacks. And I believe most of you since we are at is a risking house, right? I believe you know the basics about the Eigen layer and also the ABs. So roughly for all the Avs we borrow the security from the east from the Eigen layer side. In my opinion, Eigen layer is really like a shared security layer. Similar to Cosmos Hub and similar to Polkadot religion. Basically it's a layer like you have shared security and there are different ways. And later for the sort of protocols we call abs and they can borrow this security guarantee to empower some of the products here.
00:09:47.014 - 00:10:18.382, Speaker A: The products are vital mark and squad. But they are not the products for customers. Their target customers are roll ups. Okay, for the first one, the vital, right, we all know, as I mentioned. So if we know basically for the existing roll apps, either for the general purpose ones or the new ones, we launch for games or social applications. By default it's a single sequencer. No matter for OPSt, orbit or Polygon CDK.
00:10:18.382 - 00:10:57.838, Speaker A: It's perfect fun. And a lot of our customers, they enjoy the single sequencer. They know that it's the most performant way to really handle the transactions and all the activities for them, especially for games. They just want one sequencer. If you provide more, they don't like it because they want the low latency. But at the same time, as I mentioned at the beginning, right, for the big names, it's a perfect fund because we know that they won't really behave maliciously like op arbitrum or base or the big names. But for the new ones, for example, we are helping some companies, they are big in web two, but in web three, no one know them.
00:10:57.838 - 00:11:56.206, Speaker A: And also for some new project, right, they are grassroots developers. If they launch the rollout, right, even they claim, okay, we are secure by fraud proof or ZK proof. But still people don't really trust them because they don't have the reputation there. So that's why, as I mentioned, we need a network of nodes to do this extra verification or reexecution or transaction, just to make sure, okay, if people don't trust this single sequencer, right? But at least you have a third party like neutral, decentralized verification network to make sure these blocks or transactions precise by the sequencer are sort of secure. Of course there are some other details like how we implemented the algorithm. But in general, as I mentioned, we leverage the Eigen layer. So later on the Eigen layers stake is either LST or LRT.
00:11:56.206 - 00:13:04.210, Speaker A: So basically we can allow these stakeholders to delegate their sort of ease into this group of nodes, and group of nodes are the operators. And in that case these group of nodes, they run different softwares. Like for example for Opstack, they need to run sort of the dedicated verification software for Opstack, and then there's dedicated verification software for orbit and also for Polygon CDK. So in that case you treat it as sort of a dedicated verification network for this roll up and basically secure by Eigen layer. So in that case, roughly, instead of blindly trust the RPC result from the single sequencer, you can directly get the result from this vital network. So it provides a much better security guarantee, at least for the rollap itself. On top of it, we also have the mark that's also directly from some requests and demands from our partners, especially Defi protocols, bridges, and also some exchanges.
00:13:04.210 - 00:14:09.654, Speaker A: We all know that there are different definitions for finality and also confirmation for optimistic roll up, right? There are some very important sort of concepts there. One is the seven day challenge period. If you really want everything to be super secure, you probably need to wait for seven days. But at the same time there is a finality by default for optimistic roll up or for ZK roll up. When we say there is a finality for block typical, we mean either the sequencer or proposer post the l two block into Ethereum, and on Ethereum by default the block time is 12 seconds. And if you want to finalize, you still need to have roughly, I forgot, but roughly around twelve and 13 minutes. So in that case, when we say, if you want to say like sort of l two finality, right? We tap, you say it's the block posted by the proposer or sequencer to the l one, like steel, hash, whatever, and then confirmed by the Ethereum's finality.
00:14:09.654 - 00:14:54.966, Speaker A: So in that case it's roughly around a few minutes by the same time for a lot of DeFi protocols, right? We want sort of much faster finality. Like for example, if we are building bridge, we want to bridge asset from one rollout to another rollout. Probably we want the user to get their asset on the other rollout within a few seconds. In that case, there are multiple ways. One, you can have these ZK lite clients for different roll ups, or you can run the full nodes. But as I mentioned, in the future we may have dozens of roll apps and for some defile bridge protocols, the best way probably just leverage. As I just mentioned, this vital on top of it, we have the mark for this protocol.
00:14:54.966 - 00:16:15.518, Speaker A: They can request sort of the verification for different blocks. So within a few seconds they can quickly have a better sort of a finality compared to the steel wave for all the blocks posted to the l one. Another example is the bridge, right? As I just mentioned, sometimes for the existing roll ups, especially optimistic roll up, we have this liquidity based bridge, the bridge provider, they have their liquidity on the roll up example, op or arbitron. And if your user directly withdraw or sort of bridge from this roll up to another chain, right, the bridge provider itself will just provide the liquidity immediately. But for themselves needing to withdraw sort of the asset from the native bridge, waiting for seven day challenge period and for ZK roll up, right? It's not like that instant. A lot of people feel like okay, Zk roll up, it must be super fast and don't need to wait for seven days. But the reality like ZK sync intentionally enable like 24 hours delay.
00:16:15.518 - 00:17:05.330, Speaker A: When you withdraw like asset from ZK sync, you need to wait for one day and normally for some other ZK rollout, right? Like polygon, ZkVM or something. We are running an approver for some of the rollups. The thing like they need to wait for minimum, like one or 2 hours generates the proof. So also not that instant. So that's why for faster finite, especially for defi protocols, there are a lot of demands and definitely this kind of feature welcome by a lot of these bridges and also protocols. The thing like for us, we don't directly build these bridges, we are still working with our partners and together they provide the liquidity and all things. But for us we are providing sort of like infrastructure.
00:17:05.330 - 00:18:08.958, Speaker A: Another thing is squad. So this is not like something like in this normal discussion about this decentralized sequencing or the shared sequencing. We had a lot of discussions in research or in Twitter, right? We definitely need share sequencing because as I just mentioned, for the interoperability issue, share sequencer is very neat and a smart way to help to bridge assets across different rollabs. But here it's from another perspective. It's basically from the request from our client, as I mentioned, right? In some countries, if you just run one node legally, basically the government will treat you as custody. So in that case you have to run multiple nodes and probably have a network to make it as decentralized. Their request is not to do this interoperability but just to make sure they run multiple nodes.
00:18:08.958 - 00:18:58.140, Speaker A: It's a decentralized network. I know sometimes for us, right, the idea is a little bit crazy why you have such a request, but in reality that's something at least we are guiding. So that's why the main focus for us is just to make it decentralized. Another thing is just to make it very fast, because they want relatively decentralization, but at the same time they also want it to be very fast, like subsecond or something. Yeah. And beyond that, this is just a normal structure, as I mentioned at the beginning. So later on you need to stake or delegate the LSTLRT to these operators and these operators to basically run these services like mark.
00:18:58.140 - 00:19:51.318, Speaker A: I'm not sure how much time I have. I will just quickly go through the multiple modes for the mark, because as we know, for the verification, like at a design level, it's quite straightforward. Basically just say you can re execute the transactions or compose the MPT trade. Right. But when we go to the details, if you look at for our team, the good thing, like half of our team members are from this research background. So we literally look at every roll up project source code and we try to understand and sort of the implementation. The pros and cons, apparently we found out for most of the project, right, they don't really follow the implementation of the Go Ethereum's MPT tree implementation.
00:19:51.318 - 00:20:44.326, Speaker A: So that's exactly correct for all the ZK rollout projects. Because one thing, to make it compatible with the existing ZK proof, they basically implement their own sort of MPD tree. All these are called ZK tree or whatever. Basically reimplement that part to make it much easier to generate ZK proof. Almost everyone. And the good thing, we really respect this kind of implementation, right, because it makes ZK proof ZKe EVM possible right now. But at the same time it make it very difficult for us or for some other project to unify the interfaces for all the different roll apps.
00:20:44.326 - 00:21:33.910, Speaker A: So if you really look at the source code, right for optimism, Arbitron, Polygon, Ziki, sync, Scroll, tyco, I can give you a very long list. Everyone is different. So basically we really admire that everyone spent a few years time into it, but at the same time it creates a lot of difficulty for us to unify the interface for the verification and then back to the point. So in that case, as I mentioned, for this mark, or the vital, the decentralized verification system. So we have to create our own software, the verification software, for different sort of stacks to make it very lightweight. Right. We create our own sort of stateless client.
00:21:33.910 - 00:22:22.106, Speaker A: So basically the software client can just execute transaction and regenerate the MPD tree or zk tree to make sure it's exactly the same as the correctly executed block. So in that case for some of the projects, because these kind of software by development takes time. So we split into multiple modes. The one mode is like sort of the permissive mode, right. It's very straightforward. So basically you run the funos and reexcute funnel itself, will reexecute all the transactions and then you can basically have a network of funos. The drawback as you can see, right.
00:22:22.106 - 00:22:56.902, Speaker A: It's very heavy. So for optimism, arbitram run funnel. You need several terabytes data for your disk and at the same time to sync with the existing sort of sequencer, right. It takes you a few days, even months to really make sure all the states synced to the latest block. That's very challenging I would say. And the second one is something like we call optimistic mode. So basically we assume all the execution should be correct.
00:22:56.902 - 00:23:36.174, Speaker A: And when something sort of malicious happened, right. We have this typical fraud proof system, basically doing the challenge. If something wrong, there's a challenger submit, sort of this assert. After that we have this bad section protocol to identify which part is wrong. The cool thing like we are working closely with some ZK teams, especially risk zero. As I mentioned, there's a staleless client on top of it. We are developing brand new sort of ZK proof for this stales client.
00:23:36.174 - 00:24:41.030, Speaker A: So in that case, together we build something called on demand ZK proof. So it's sort of like we optimize the fraud proof. For fraud proof you only have the best action protocol and to identify which instruction is wrong, right? But here we still do this on demand or fraud proof like proof system, right? But in the end we replace this kind of bisection protocol into ZK proof. So in that like you don't really need to do a very lengthy multi step sort of proof stuff, but instead you can quickly generate ZK proof and do the verification on chain to make sure the things are correct. And then there's a validity mode basically as I mentioned, right, there's a one way, like you make it on demand, if something wrong, you generate ZK proof. The validity proof more like it's more similar to the normal ZK VM and ZK roll up way. It's regularly just do generate ZK proof, it's more costly, but at the same time you get the best sort of like security guarantee.
00:24:41.030 - 00:25:29.622, Speaker A: Yeah, this is like due to the time limit, I just share all the brief ideas about these main features we are building for risky roll up, as you can see. Right. We are not building a new roll up stack or new dedicated roll up, or basically building a new sort of proof system for the existing rollout. Right. It's just like based on all the requests and demands from the real customers and partners, we are building this set of new features, leveraging Eigen layer's shared security to basically to do this decentralized verification, faster finality, and also this decentralized sequencing stuff. Yeah. So great to share all these new progress with you guys.
00:25:29.622 - 00:25:51.120, Speaker A: And for the next two months, we are releasing a bunch of new projects using this risky roll up. And you can see how it runs at that time. And if you have any questions, feel free to reach out to me. And always happy to exchange ideas. Thank you.
00:25:55.010 - 00:26:00.110, Speaker B: Thank you. Any questions or any comments from Espresso?
00:26:00.690 - 00:26:03.970, Speaker A: Oh, they are our partners. We are working on the share sequencer.
00:26:07.350 - 00:26:09.550, Speaker B: Did you mention map protection?
00:26:09.710 - 00:26:10.322, Speaker A: Which one?
00:26:10.376 - 00:26:10.846, Speaker B: Mac.
00:26:10.958 - 00:26:11.378, Speaker A: Yeah.
00:26:11.464 - 00:26:14.286, Speaker B: Map mitigation scheme in the Mac.
00:26:14.398 - 00:26:15.406, Speaker A: Mev.
00:26:15.598 - 00:26:16.340, Speaker B: Yeah.
00:26:17.350 - 00:27:44.320, Speaker A: So the thing is for Mev, because for us, right, when we talk about Mev, typical, we see on the sequencer side, but when we go deep into the source code and various implementation for all the different rollab stacks, right, we found out, okay, sequencer is important, but actually the prover for ZK rollab and also the verifier for optimistic roller, very important, because these are the sort of roles to post the data to the l one. So that's why we say for the distributed verification part, right. They can also somehow it's like a post execution to make sure you don't really have some reordering happening on the sequencing side. But this kind of concept is very subtle at this stage, because people still think, okay, for roll up, everything together is a sequencer. But in reality, typically for each roll up stack, we split into three to five different modules. And for each module, actually, you can always apply different policies to make sure there's no front running or there's no reordering. But I think granularly, once all these module apps come out, right, when people spend more time on the implementation side, people will see that there's not just that straightforward to you.
00:27:44.320 - 00:28:03.650, Speaker A: Do this like fair ordering on sequencing, and then you can solve problem. But actually there's multiple roles, can also have the impact on these ev, all these ordering of the transactions. Yeah. Oh yeah. It's.
