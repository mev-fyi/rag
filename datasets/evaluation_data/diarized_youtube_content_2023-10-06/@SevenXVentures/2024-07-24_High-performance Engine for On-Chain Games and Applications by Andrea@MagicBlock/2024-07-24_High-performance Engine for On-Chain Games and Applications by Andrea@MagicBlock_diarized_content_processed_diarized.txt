00:00:00.200 - 00:00:25.838, Speaker A: Cool. So, hi everyone, my name is Andrea. I'm the CEO, co founder of Magicblog. Magicblock is a decentralized. Well, this is the kind of agenda for today. I'm gonna give you a quick overview about what we do. Go into ephemeral rollups, which is our solution to achieve composability, low latency, and then kind of explain how the whole magic engine works with the trust assumption of our system.
00:00:25.838 - 00:01:07.848, Speaker A: Measurebook is essentially a decentralized and high performance engine for entirely on chain games and applications. We built this for on chain games, but we can support, obviously a bunch of other use cases. And it is essentially a network built on top of Solana. So we're using the SVM to give developers this property. We give them real time performances while maintaining the composability of device layer. And at the same time, we give them the ability to customize the runtime on which their apps are being executed with more DP's on demand whenever they may need it. So this is an example of what the engine is capable of.
00:01:07.848 - 00:01:34.870, Speaker A: This is a fully onchain game. It's entirely deployed on Solana Mainnet. But you see, so every interaction is a transaction. You see that transaction are coming through blazingly fast. And these are two clients playing side by side with basically no lag. So this real time gameplay entirely on chain. And not only the engine is high performance, but it's also 100% composable with sonar.
00:01:34.870 - 00:02:14.716, Speaker A: By grabbing the gem, we are triggering a mint on sonar maintenance based on the position of the player. The coordinates are in the metadata of the convenient. And this again is happening on Solana minutes. So not only the engine is hyper performant, but it's also 100% composable with so on. And we go through how this whole system works. But the backstory for building this is basically, we didn't want to build on the roll up. In terms of existing fragmentation, roll ups are really not making a great job in maintaining access to state and allowing demand enable developers to give their users really small UI sauces are non fungible.
00:02:14.716 - 00:03:11.434, Speaker A: There might be different runtimes, different frameworks, but Solana, to be honest, has its own fair share programs as well. Solana, it's an atomic state machine, single state machine that set up globally at the speed of 400 milliseconds. But when it comes to being able to customize the runtime on which your upworkings are operating on Orlando, being able to own your blog space and customize, for example, the fees that the user are paying, obviously you cannot do that because it's a general purpose runtime. So we came up with this idea of ephemeral rollouts. We published a paper at the end of last year and ephemeral rollouts are basically a way to scale the SBM with these asean specific instances that are spun up on demand. And they are basically very, very fast. The famine roll up that we have is a Solana alligator that we wrote from scratch.
00:03:11.434 - 00:03:32.240, Speaker A: We remove all the crates of the 1.17 Solana client and we added one by one, only the stuff that we needed. So we don't have gossip, we don't have voting. And the overhead on the validator itself is between four and ten milliseconds, plus the network latency, of course. But you can call them all close.
00:03:32.280 - 00:03:33.752, Speaker B: To the users and achieve the kind.
00:03:33.776 - 00:04:30.722, Speaker A: Of result that I demoed before in terms of composability of the state. The smart contracts are deployed on Solana itself, so they're not deployed on a different ecosystem. And we see how that is possible. And essentially it's a way to spin up these customized random because we can have customization at the binator level on demand whenever the developer need this extra block space. And of course, if they need more DP's, they can just have multiple ephemeral roll up session and run them in parallel. So it's just a great way to achieve all of these properties and basically get to solve the problems that we wanted to solve in terms of maintaining the same composability across the ecosystem without fragmentation, maintaining ux, and avoid bridging as much as we can. So before digging into how the system works, just keep in mind these two basic concepts of how Solana works.
00:04:30.722 - 00:04:55.866, Speaker A: Solana has this notion of accounts where logic and state is separated natively. So everything is an account. Accounts are data buckets. Basically you've got executable accounts and non executable accounts. Non executable accounts for the state. Executable accounts are the logic. And the other concept that you have to keep in mind is that everything has an owner, it's a program owner.
00:04:55.866 - 00:06:03.142, Speaker A: And you have these program derived addresses which are basically account derived by the programs and can hold data themselves. So basically there is this concept of ownership where a PDA is owned by a program. And that program can, you know, change that PDA based on the transactions that are being specified. So with these two ideas in mind, what happens in the system is that the developers can lock an account, just the account in example of the video, just the position of account of that player and delegate the authority over that account, the ownership of that account into the delegation program. The delegation program now has the control over that state position, and that account is loaded into an ephemeral roll up session. So the SBM operator sends this request and spin up the ephemeral roll up. So the smart contracts, the logic of the accounts are lazy.
00:06:03.142 - 00:06:30.214, Speaker A: Loaded into the. So they're basically cloned into the SVM runtime. And now we can change the state very, very fast into the ephemera rule session. So again, the latency here is basically very, very slow because the node can be customized and really optimized and they're not mounted by consensus. So it's between four and ten milliseconds plus the network latency. But of course we collocate the nodes.
00:06:30.262 - 00:06:31.174, Speaker B: Close to the user.
00:06:31.222 - 00:07:21.414, Speaker A: So in the case of a game, the Singapore young player will play in the inbuq ephemeral roll up session. And if the player is accessing from New York, they will be playing in the US ephemeral roll up session. And this goes for every other use cases. And it's very generalized to any son accounts. You can do multiple accounts into the affirmative role obsession as well. So many times it's time to commit back and basically to undelegate that account and send that information back to Solana, the active node operator set a state commitment of this, of the state of that account. And now we have to verify the integrity of the composition, right? So obviously, like there are two main models, there's validity proof and there's fraud proof.
00:07:21.414 - 00:08:09.320, Speaker A: In terms of validity proof, you are relying on cryptographic security. For now, there's. For now, this is still too slow for what we want to do because we have potentially hundreds of thousands of transactions into the notes. As you saw, if you're changing the player state position that quickly, we easily run into hundreds of thousands of transactions that we have proven at that point. It's very commoditization intensive and time consuming. And so in terms of fraud proof, my kind of mental model to make sense of the security assumption of fraud proof is that it's a crypto economic security where there's some sort of probability of catching fraud. And that probability is a function of how long the window period is.
00:08:09.320 - 00:09:17.120, Speaker A: There's a bon size that basically incentivizes stakeholders in the network to raise the challenge. And at the same time you have to have certain number of actors that are actively monitoring and challenging if there is a Ford proof, because you can have a window of time of seven days. But if there's no one actively watching the session, then nobody's raising the challenge, then your system is insecure. So with this kind of assumption in mind, what we foresee as a good security mechanism for this and what we're implementing is basically that there is a challenge window and anybody can raise a challenge during that period of time. The challenge, if the challenge is raised, of course we need to run a dispute game to solve that incorrect state. But the challenge window can be expanded if there's no nos that sign off that state commitment. So basically the developers can specify a number of nodes that has to sign off that state commitment before it gets finalized to the chain.
00:09:17.120 - 00:10:21.496, Speaker A: If that doesn't happen, the fraud proof window gets extended. And basically there's an extended period of time where you are waiting for someone to act as challenger and say, look, this state is all right. If that doesn't happen, you just keep increasing your front probe window because it means that nobody's actually checking on your state. But on the flip side, this gives you the ability to really be aggressive with your fraud proof window because you can have a very restrictive period of time. And the extreme case of that is just a few blocks where you basically specify the window of time and you have the sign off of those nodes that are watching the session. They're basically saying, I checked that the computation is correct, it's good to go, it's good to be finalized. And also an optimization that we can do with this is that you can have live clients that are basically verifying without having to recompute one by one the exact computation in the ephemer world.
00:10:21.496 - 00:11:18.832, Speaker A: So you can be smart on how, you know, basically reduce the load on these nodes and they can just be sampling transaction. And it's up to you to specify the number of guidelines that you want to be watching your session, or even the length of the window, the challenge window. So this what happens, basically there's this network of nodes that sign off, that stay committed, and if they hold sign off, that's a commitment. And we time expired at that point, and only at that point the sleep becomes final. So the position is updated. On Solana the program is undelegated and then you can trigger a conditional operation based on the information in the firmware roll up, like the token that we saw before. So these are basically the scenario in the case of the challenge window, you know, it's still being running.
00:11:18.832 - 00:12:23.336, Speaker A: Basically you have to wait. And even if you have enough lifelines or full nodes that are signed off that state div, you still have to wait until the end of the window, the challenge window. But at that point you can finalize this state. If there's no sign off, even if the challenge period expires, then you basically have to extend, because your assumption is that there's no one that is checking on the validity of your site. And the other interesting idea behind this model is that you're basically running your application in parallel between one or multiple ephemeral obsession with Solana. So you can maintain on Solana NFT USDC payment liquidity you don't need to bridge, and you run indie ephemer rollouts on the computation that you need to run faster or that you need to run with some sort of customization at the runtime level. So obviously I showed you a game, but in terms of use cases, this is a generally applicable design.
00:12:23.336 - 00:13:15.068, Speaker A: So we already have sort of high stakes games that are with us. We have projects that are considered running an off chain order book. So they're keeping the liquidity on chain and they're running your debug off chain, and then they basically verify the matching engine and settling the liquidity on Solana. Or you could build something like causal where basically you are running these bundles auction bundles off chain, and then you're selling on Solana, ensuring that everyone get the same settlement price and basically reducing me and reducing information asymmetry between different parties. So these are all kind of possible use case with this infrastructure. And that's it. So if you want to keep in touch or handle this magic blog, that is my telegram.
00:13:15.068 - 00:13:21.200, Speaker A: Thank you so much. Sorry for holding you back from going to lunch and thanks for having me.
00:13:26.790 - 00:13:46.302, Speaker C: Here first. Like megafam Monad, they kind of are in different execution environment like SVM. I don't know if this stack is applicable to them or like we still need the execution layer to have state, like state assess model similar to SVM.
00:13:46.486 - 00:14:29.810, Speaker A: Yeah, this is heavily based on SBM because of the notion of locking the account and delegating the ownership to the delegation program. And also in terms of the execution environment, the validator is SVM based. So I'm not really sure how you could have, you know, you could build a new execution environment. But the problem is that in EVM you cannot log just one state and then clone the logic on demand in the, in that router. So I wouldn't know how you could do it on EVM unless you have this separation between logic and state at the level of the router.
00:14:30.710 - 00:14:46.070, Speaker C: Yeah, makes sense. And also curious, like if there are some projects that want to use this scaling solution. Is it like you need to do customization one on one base while it's open that everyone can just make their customization?
00:14:46.690 - 00:15:39.658, Speaker A: So we want to open source the stack. We will do it probably soon. At the moment, the customization that we have in the pipeline are one ticking so clock that is internal to the validator. That is very helpful for our use case on chain games. But there is already conversation to potentially have a sequencing mechanism because obviously for indicators of exchanges that they might want to extract me or they might want to have more granular control over the sequencing right now is first come, first serve. So the cool idea behind this is that you have these kind of application specific in a way instances. And so you really can add this customization at the runtime level for different use cases, but then still accessing to the same security mechanism.
00:15:39.658 - 00:15:52.870, Speaker A: Because the security Council, the security committee, there are basically the watchtowers that look at the state before it gets committed, can be the same and can be shared across these different use cases as well.
00:15:53.690 - 00:15:54.066, Speaker C: Cool.
00:15:54.098 - 00:15:54.290, Speaker A: Yeah.
00:15:54.330 - 00:15:58.670, Speaker C: Any more questions from the audience? Yeah.
00:16:00.740 - 00:16:42.252, Speaker B: Hey, thank you for the talk. I just wanted to make sure you've understood properly the roll ups. So basically this network of nodes that are Solana nodes, but actually forked in such a way that they can handle computation for your purpose. So what happens is that like there is the creation of an account and the authority of writing of on that account is sent to the delegation program. Right. But then like what's the connection between the delegation program and the SBM operators? Because those are the guys who are handling compilation.
00:16:42.316 - 00:16:42.540, Speaker A: Right.
00:16:42.580 - 00:16:48.236, Speaker B: And eventually we return a final state that is written on the council.
00:16:48.348 - 00:16:48.932, Speaker A: Right.
00:16:49.076 - 00:17:05.914, Speaker B: And so is there any competition between these EZ VM operators in delivering like the best data to delegation program? And so what's that bound in that sense?
00:17:06.082 - 00:17:44.666, Speaker A: Yeah. So in terms of orchestration of the nodes, one, the model that we're envisioning is that studios or projects can run their own nodes. And so they will be basically the providers for their own session and for their review, their own users. And that is because they might want to either abstract the fees for them or maybe they want to extract some fees for them. And they can do that if they run their own sessions, a fibrolla session. Or the other option is that if you don't want to run nodes, you just tap into the capacity of the network. And at that point we have to basically come up with a way to provision these nodes.
00:17:44.666 - 00:18:27.888, Speaker A: And the most basic example of provisioning is you collocate the node, close to the user. So you look at the IP address and you collocate the node, you speed up that session closer to the user because that is going to give them the lowest latency. But that might not be the only option. Right. We already saw in the case of a decentralized casino, for example, they want to shark users not based gerovtion, but based on tokens because they have peer to pool mechanism. And so at the moment they basically want to botch users based on what currency they're using to play their games. And so there's different way that we can provision these nodes.
00:18:27.888 - 00:19:05.010, Speaker A: It's not necessarily like a waste condition or like it really depends on the use case. But generally speaking, these are kind of the two models. One is the project running their own session, the other one is coming up with some heuristic, or they're based on the use case, on how to smartly provision the nodes and activate the femoral obsession. And the same goes for shutting them down because you can, you know, keep running or, you know, once there's no use for the node, you can close it down. So that is sort of an object that we have to do on the provisioning side.
00:19:06.550 - 00:19:11.734, Speaker B: So there will be like several FMR rollouts in this sense.
00:19:11.822 - 00:19:12.182, Speaker A: Yeah.
00:19:12.246 - 00:19:26.590, Speaker B: And you characterize an FMR roll up with the delegation program and the SVM operators. But there is like the unique delegation program which dispatches around the different SVM.
00:19:26.630 - 00:19:57.960, Speaker A: Programs, one entry point which is the delegation program. But then there's multiple FML instances. And in terms of users, you can have multiple users for different use cases into a single ephemeral obsession, or you can have multiple ephemeral obsession for a single use cases as well. So it's very general, it depends on what you want to achieve. But the delegation program is one and it's single entry point to the system.
00:19:58.420 - 00:19:59.360, Speaker B: Thank you.
00:20:04.220 - 00:20:05.520, Speaker C: Thank you so much.
00:20:05.860 - 00:20:06.540, Speaker A: Appreciate it.
