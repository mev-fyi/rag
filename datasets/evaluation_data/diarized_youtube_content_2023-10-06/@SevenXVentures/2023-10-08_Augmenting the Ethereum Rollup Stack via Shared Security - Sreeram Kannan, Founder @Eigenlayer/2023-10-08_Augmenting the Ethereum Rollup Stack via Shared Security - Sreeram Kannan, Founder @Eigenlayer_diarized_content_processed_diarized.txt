00:00:00.570 - 00:00:25.560, Speaker A: Good evening, everybody. I'm Sriram. Pleasure to be here. Thanks to the seven X team for inviting me here and thanks to you all for staying late in the evening to listen to this talk. So, a brief introduction. I'm Sriram, founder of Eigen Layer, having a professor at the University of Washington, Seattle where I run the UW blockchain research lab. Today I'm going to talk about how we can use Eigen Layer to augment the Ethereum rollup stack back.
00:00:25.560 - 00:01:06.124, Speaker A: Awesome. So we know a bit about roll ups, right? Roll ups augment move execution off chain and move computation and memory off chain. And this is a scaling strategy for Ethereum. But there still remains many roadblocks in order to get L2s and roll ups to the end state. What are they? The first one is the data bandwidth of Ethereum is very, very low 83 kb/second. That's the data bandwidth of the entire Ethereum blockchain. If you don't use Ethereum for any computation, just write data to Ethereum.
00:01:06.124 - 00:01:48.290, Speaker A: And this is a very important function that roll ups do because roll ups still need to publish the inputs or outputs of their computation onto the Ethereum blockchain. The finalization time is very slow. Twelve minutes to finality. And finality is very important because if I want to move information from one roll up to another roll up the rollup needs to finalize. On Ethereum. Roll ups still rely on single node sequences, a single node which orders transactions in order to get fast censorship resistance. The bridging experience inside rollups as well as between ethereum rollups and outside chains leaves much to be.
00:01:48.290 - 00:03:01.604, Speaker A: Do we how do we utilize the altering freedom called mev or minor extractable value or maximal extractable value? How do we manage this properly so that users get maximal benefit? So how we view this is eigen Layer provides a comprehensive base layer solution to go and augment the Ethereum roadmap. So any of these problems can then be built on top of Ethereum shad security. How do we get to Ethereum shad security? Ethereum security occurs because stakers stake ETH deposit it into the ethereum contracts and then promise that they will validate Ethereum correctly. What happens with Eigen Layer is we enhance the functionality from just staking where you take your stake and then lock it up onto Ethereum to now expand it to promise any other protocol building on top, be it an oracle, data availability, a bridge, mev management, any of these things. We call these actively validated services. Anything that requires active validation and decentralized service. You basically can build them on top of Eigen Layer.
00:03:01.604 - 00:03:54.680, Speaker A: What you do is, as a staker, you promise that you not only promise your ETH that you will validate the Ethereum blocks correctly, but you also promise that you validate all these other systems correctly. Otherwise you may be liable to lose your ETH. So when you're building an Avs, an actively validated service, any one of these things an oracle, a bridge or any of these things. What you're building is an off chain container which basically lets you run any arbitrary program and an on chain contract which basically does some of the core management registration payments and slashing. So that's what Eigen layer is. It's a system of contracts on Ethereum, but it broadens who the stakers can supply their security to instead of only the core protocol. Now, any other protocol which is restaked can also obtain the security from each staking.
00:03:54.680 - 00:04:47.348, Speaker A: So what can you do with this? You can actually go and build new modules which then address the problems that I laid out earlier. For example, the data availability problem. You can build a Data availability service on Eigen layer which then solves this problem. We are ourselves building Eigenda, a Data availability service which actually has very high throughput and provides data availability guarantees. You can start building Mev management solutions or super fast settlement solutions where a lot of stake underwrites your settlement guarantees or decentralized sequencing, or low latency bridging any of these different kinds of features on top of Eigen layer. It doesn't mean we will build all these things, we won't. We want other people and we are partnering with a lot of different projects to be building all these different kinds of services on Eigen layer.
00:04:47.348 - 00:05:28.692, Speaker A: Okay, so in the next few minutes, what I'll do is give a quick overview of Eigenda, which is our Data Availability service, and then hint a little bit about what other services are being built on Eigen layer. So when you're thinking about a Data availability layer, first I want to lay out what properties do we want from a Data availability layer? We want high bandwidth. When I talk about high bandwidth, we call it Hyperscale. Hyperscale means if there are N nodes, each of them have a certain bandwidth. You want to be almost as performant as N times C. If each node has C bandwidth, low cost you don't want. Right now the cost of Data availability is every node has to download and store data.
00:05:28.692 - 00:06:03.536, Speaker A: This is really, really expensive. In Ethereum there are 500,000 virtual nodes. So this can become very very expensive. What you want is actually to be almost similar to one node downloading and storing data. That's what would be low cost, low latency should be very similar to. Like when you send an AWS query, goes to the server, comes back two times, or the round trip latency, you want it to be verifiable when the system's running outside nodes should be able to check that the system is working correctly. This is the property that many other data availability system exclusively focus on.
00:06:03.536 - 00:06:54.256, Speaker A: And finally customizability. Customizability means the Data Availability layer should be adaptable to different nodes which want different safety, liveness trade offs, different staking tokens, different kinds of erasure codes, all kinds of different things. Eigenda is a Data availability system which achieves all these properties. How does it work? Here are the ethereum restakers who opt into Eigen layer and opt into Eigenda on top of Eigen layer. What do they do when a sequencer for a rollup? Remember that Eigenda is a data availability service that rollups naturally use. Rollups have a node called a sequencer, which orders all the transactions and then writes some state to Ethereum. And when they write the state to Ethereum, what they do in addition now is they create an erasure code using the package that we give them.
00:06:54.256 - 00:07:28.184, Speaker A: And this erasure code is built on KZG polynomial cryptography, which is what underpins Dank Sharding, which is on the Ethereum roadmap. And they take a data blob, and they take this blob and then encode it into many small chunks. Each chunk here in the picture is much smaller than the data blob, and that's precisely how the data is encoded. Each of them send these chunks to each of these nodes. Each node downloads something which is roughly one Nth. If there are N nodes the size of the whole data. So that's what each node downloads.
00:07:28.184 - 00:08:08.804, Speaker A: They sign off on this thing saying that, yes, I downloaded and received the right chunk. They get a proof that they got the right chunk through the KZG encoding, they send these signatures back to the sequencer. The sequencer aggregates all these signatures and then sends it to the Eigenda contracts on Ethereum. So what's happening is, on Ethereum, there is a record that data corresponding to this data commitment has been stored on Eigenda and certified. And there is an incentive mechanism which keeps the nodes honest. Okay? So that's the high level of how Eigenda works. And I'll give you a little bit of insight into how we designed Eigenda.
00:08:08.804 - 00:08:48.452, Speaker A: It's designed to optimize the cost basis of operation. And if you think about the cost basis of a system like Eigenda, there are many contributors to it. So there's capital cost, which is you have to stake. So if you're staking $1 billion, you have to give the users a 10% Apr on this $1 billion, that's $100 million. So how do you optimize capital cost? How do you optimize operating cost? Every node has to download and store data. How do we optimize that? How do you optimize congestion cost? Every system today is priced on congestion. If you know Ethereum EIP 1559, the block price increases based on if there is congestion or not.
00:08:48.452 - 00:09:25.104, Speaker A: So congestion is a significant cost and an uncertainty to a roll up. If you're a roll up, you don't know what the price is going to be tomorrow, because maybe Yuga Labs does a board Ape drop and then now you're congested significant problems in the landscape, and I canda solves all these problems all at one go. How do we do it? The capital cost is solved by shared security restaking you're using the same stake across many applications. Common stake reduces the capital costs. Operating costs, I explained in the last slide, the data. Every node doesn't download and store all the data. Every node downloads a little bit of data.
00:09:25.104 - 00:10:00.940, Speaker A: Together they download all the data. The cost basis is very very low of operating the system. And finally, to reduce the congestion cost, if you increase the throughput, then you reduce the congestion cost. Not only that, on Eigenda there is a mechanism to reserve the amount of space that you want. If you're building a roll up, a gaming roll up, maybe you can come and reserve I need 20 Kb/second just for my roll up for the next year. And you pay a much cheaper fee than buying on the spot market because you're reserving a whole bunch of data. So that's how eigenda works.
00:10:00.940 - 00:10:46.520, Speaker A: It shaves every single cost basis so that we can actually move to an economy where we can start thinking about moving the cloud traffic on chain. That's the goal that we have for eigenda. And just to give a quick glimpse of numbers, eigenda is right now on our private testnet, will be soon on public testnet at ten megabytes per second. This is much greater than Ethereum right now. And Dank Sharding, which is three years down in the Ethereum roadmap. And we have a roadmap to scale this another thousand x in the coming four years. We are doing this not by adopting the salana roadmap of actually having each node download and store a lot, we're actually doing this achieving this high throughput without each node requiring to have a high node bandwidth requirement.
00:10:46.520 - 00:11:24.836, Speaker A: So you have very low node requirement, but very high throughput and a lot of customizability. I'll check the time to make sure three minutes okay. So I think what I'll do in the remaining three minutes is just point out how Eigen layer can be used for various other things to solve. For example, the sequencing problem. Instead of having one sequencer, we can have many sequencers run through the Eigen layer staking mechanism. Espresso is actually already building a protocol like this on Eigen layer. You can start building fast settlement layer.
00:11:24.836 - 00:12:16.484, Speaker A: Instead of waiting for the twelve minutes on Ethereum, or waiting for several hours that STARTnet waits today, you can actually write proofs into an Eigen layer service which verifies your proofs and then certifies that you've done it correctly. You can start building bridges, many bridges we are in partnerships with, which are building fast bridges to move data across various L2s and layer threes. You can start building very sophisticated mev management where you don't have to only do auctions, you can do event driven actions, you can do partial block auctions, you can do threshold cryptography, you can do block space futures. All of this on Eigen layer. Going back to the starting point, I pointed out many limitations on the Ethereum modular roadmap data bandwidth is low. We can solve it by building something like Eigenda. Finalization time is too slow.
00:12:16.484 - 00:12:47.804, Speaker A: You can take a fast consensus protocol and throw it on Eigen Layer and you can get super fast. Finality, you can move from centralized sequences to decentralized sequences using Eigen Layer. You can build very high quality bridges with very high economic security. And finally, you can build modules for doing sophisticated mev management on Eigen Layer. Eigen Layer. I just want to summarize that. Eigen Layer is a great complement to the modular Ethereum roadmap where any significant features which are missing from Ethereum can be provided by permissionless.
00:12:47.804 - 00:13:32.768, Speaker A: Innovation. Any of us, any of you here coming up with a new idea for how to build this can actually come and patch that particular problem for Ethereum. Our vision is that just like AWS enabled a plethora of software as a service tools to be built and any end user application then concatenates these SaaS services. Eigen Layer enables a decentralized SaaS economy where you can build new decentralized SaaS services and end user applications can just simply concatenate all of these to build users on Ethereum. I think with that I'll conclude this talk. If you're interested, please follow us on our Eigen Layer Twitter handle and on our website. Thank you so much to the Soundx team for organizing this.
00:13:32.768 - 00:13:33.390, Speaker A: Thank you.
