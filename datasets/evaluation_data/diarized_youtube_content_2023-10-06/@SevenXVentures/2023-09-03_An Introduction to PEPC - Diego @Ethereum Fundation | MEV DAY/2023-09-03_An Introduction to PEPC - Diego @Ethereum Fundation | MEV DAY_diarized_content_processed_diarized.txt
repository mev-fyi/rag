00:00:00.810 - 00:00:31.026, Speaker A: Okay. So hello everyone. Thanks for coming. First off, so today I'm going to be talking a little bit kind of at the introductory level but really emphasizing the intuition behind PEPC. So yeah, PEPC, we're going to take a kind of an agent based approach to starting to think about PEPC. So we have Alice and she's and we also have another person which is Bob. And Bob is a transaction originator.
00:00:31.026 - 00:01:21.990, Speaker A: So he's a person that makes a transaction that is going to try to enter a contract with Alice. So basically they agree on this contract and what the contract says is that Alice commits to including Bob's transaction in the next block she proposes. So that's a commitment that she's making about a particular property that her next block is going to have. And then at the same time she also commits to including Bob's transaction as the first in the block. So we have here another property that she's committing to about this block. And kind of the idea here is to say that we can go really granular in terms of what we are committing to. So it's not just including the transaction but also about the particular ordering of that transaction, the particular place in the block.
00:01:21.990 - 00:02:19.650, Speaker A: And then we have that Bob commits to paying Alice if and only if she does both things. So we have that Bob sends the payment if Alice fulfills her whole side of the contract. So now we have that some time goes by and eventually we get to Alice's turn to propose a block. And what happens here is something really weird which is that the block includes Bob's transaction but it does not include the transaction as the first one in Duloc. And this is really interesting because we have that she basically fulfilled the first kind of part of the commitment but she failed to fulfill the second part. So we have here that the contract failed. So Alice basically didn't fully fulfill her side of the contract and consequently she doesn't get paid by Bob.
00:02:19.650 - 00:03:22.622, Speaker A: But at the same time the issue here is that that does not change the fact that she violated the contract. So in other words, we have that the payment didn't go through but the block that violated the commitment still was made canonical. And this is really the core of PEPC that for example, in the case where you want to have contracts with the proposer and this proposer is defining a commitment about some block they're going to propose in the future. Even if you establish some form of punishment, you still have that a block that violated the commitment still was made canonical and you may want to avoid that in every situation. And at the same time we have that these things are going to happen in the real world because very often due to mev rewards and there may be a greater payoff from violating the commitment than actually following through. Okay, basically this is what I'm explaining now. So what just happened? And we have that Alice violated the contract and we couldn't do anything about it.
00:03:22.622 - 00:04:07.034, Speaker A: So we couldn't avoid Alice from violating her contract. And the reason for this is that consensus neither enforced nor recognized the commitment that she had entered into. So in an ideal world we would have had that the block was rejected, was rejected by the network. So the block did not ever even become canonical. And in this case we have that that's not possible because the protocol is not even aware in the first place that these commitments existed. And so even if it can enforce something, it's not going to enforce this. And so in this case, Alice has to be trusted to follow through with her side and she will not do so if the payoff from cheating is greater than Bob's payment.
00:04:07.034 - 00:04:58.246, Speaker A: And so the consequences of that is that they're going to be high contracting costs. What that means is that basically the costs from the contract are going to be higher. So parties are going to be less incentivized from entering into this contract in the first place because they only get so much utility. But if the costs are high due to these issues, then it just defeats the point. And so in this case that happens because the contract fails to bind Alice to a particular course of action. So unlike with Bob who can escrow the payment with a smart contract, in the case of Alice there's fundamental uncertainty about whether she's going to follow through or not. And so what do we do about this? So this is kind of the guiding question, right? What do we do about this? And one possibility is to base the chain's validity off the contract.
00:04:58.246 - 00:05:41.722, Speaker A: So in other words, the block or the chain itself is not valid if it violates a commitment. And what this essentially leads to is that commitments are not violated in the first place because the chain is going to keep on growing. We're going to have that if, for example, a block is invalid, it's just going to be ignored and at that slot it will be as if no block had been proposed. And so this is kind of the gist of the idea conditioning block validity. So Alice's commitment to a block must be consistent with Alice's existing commitments. So in other words, we have that she cannot commit to a block that violates a commitment she made. Or in other words, committing to the block is effectively inconsistent with previous commitments that Alice had entered into.
00:05:41.722 - 00:06:35.790, Speaker A: And so what we can do is that we enforce this. And the alternative, which is if we get an invalid block, is that we just ignore it. And this effectively means that commitment invalid. Blocks are never even made canonical and they're not gossiped by honest nodes. So if I'm an honest node and I receive a block and that block turns out to be invalid, I don't gossip it farther and so this effectively cuts the flow, let's say of invalid blocks at the earliest point of discovery that it was an invalid commitment, invalid block. Before I talk about the general idea in more detail do you guys have any questions? Okay, perfect. So the general idea so we have that Alice and Bob write commitments to the EVM.
00:06:35.790 - 00:07:48.810, Speaker A: So the idea here is that we use the EVM as a source of truth, really, in the sense that the commitment is stored in the EVM, and therefore we take it as if it had become common knowledge. And so they write to the EVM to a smart contract at a standardized address, which means that the same place they write to is going to be the source from the wider community. Due to this kind of a standard that we're assuming, and so in this case, we have that Bob deposits payment amount with an escrow, so that effectively removes the counterparty risk for Alice. And then we also have to define a limit for the gas used to evaluate the commitment. Basically. I'm going to talk more about this later, but the idea here is that there can be a fundamental gas grief in vector if we allow commitments to be arbitrarily complex because basically third parties are going to evaluate this commitment and the person that had made the commitment in the first place does not born does not bear the computational cost that it causes on the wider community. But anyway, so we have that after this we wait for these writing operations to become finalized.
00:07:48.810 - 00:09:19.590, Speaker A: At that point we take it as the commitments having become common knowledge and after that we wait for Alice's turn to propose a block and we have that Alice produces and gossips assigned beacon block. So I'm using assigned beacon block because that's basically the type of gossip blocks in a so you know, it's obviously way more consistent but also highlights the fact that she really does make a commitment here. She does sign a block and then we have to validate it and in that validation is when we not just check for the block being valid based on the default rules but additionally we check for all the commitments that Alice had entered into. So here we have that recipients call a function in DBM and pass the sign become block and we have that the function terminates successfully if and only if signed become block satisfies the proposer commitments. So in other words we can define the commitment as a set of assertions that we're defining in some function in the EVM and these assertions fail if the block violates that particular commitment. And we have here that if the function reverts then the sign become block is rejected and not gossiped. So this is kind of the most basic intuition around this and so now I'm going to talk about implementations and a way of implementing this in ethereum consensus with no changes to the protocol.
00:09:19.590 - 00:10:29.306, Speaker A: So I'm going to talk now about this idea. Protocol commitments with no changes to consensus. So in other words, PEPC, without requiring some kind of hard fork or anything, just leveraging the existing infrastructure. So the basis of this idea is that we use distributed validator technology to enforce commitments on whatever thing that validator is signing. So basically we have that Alice's validator is controlled by an aggregate BLS key and then this key is distributed using Xiaomi secret sharing algorithm to basically a group of external nodes. And these nodes, what they do is they only provide their signatures and only if whatever thing they're providing their signature for is consistent with the commitments of Alice. So we have here that Alice makes up half of the signature and the rest is controlled by a set of nodes and these nodes reach consensus about this.
00:10:29.306 - 00:11:35.550, Speaker A: So nodes provide their necessary size of a signature if and only if the data in question is consistent with. So basically we have here two cases that are possible from the end of the notes that kind of provide this service, which is that the data that they have to sign is consistent with Alice's commitments. And in that case the nodes provide their signature and the signature necessary for consensus to recognize the validator is successfully produced. And we have that consensus effectively recognizes the data and the rest of the protocol follows through normally. So basically here we have that the protocol just recognizes the block and everything follows through normally. And then the second case is that the data is not consistent with Alice's commitments. And this is the really tricky case, right? And this is kind of the worst case scenario, sort of, which is that in this case the nodes do not provide their signature and the signature necessary for consensus to recognize the validator is not produced.
00:11:35.550 - 00:12:51.660, Speaker A: And so what happens here is that consensus does not even recognize the signature and the protocol gracefully ignores the block. And so this is effectively kind of leveraging distributed validator technology in the sense that we kind of build a threshold signature and the threshold is only met if the nodes agree that in question is consistent. And then here is a really interesting idea which is commitment enforcement as a service, which is effectively what these nodes would be doing. So they're providing their signature. So basically their signature is conditioned in a way that reflects kind of commitment enforcement. And that also means that nodes should probably be paid for their service and they can simultaneously not enforce a choice onto the validator because Alice, remember, that controls half of the signature. So this is really important and kind of what I mean here is that, yeah, you can make a service that is probably not exploitative of Alice in the sense that there's no easy way in which this thing kind of breaks down.
00:12:51.660 - 00:13:44.982, Speaker A: And here is kind of an extra idea, which is commitments for ERC 4337 accounts. And basically here, instead of enforcing this using threshold signatures, we have simply a solidity contract. And in this contract, which is we have a function. So basically in ERC 4337 there are signature aggregators. And these signature aggregators can implement arbitrary logic. And so what they can do is they can implement the logic to screen user operations for them being consistent with commitments of the author of the operation. And basically you can have accounts in account abstraction be only able to make basically to kind of execute operations if and only if they're consistent with their commitments using just the existing infrastructure.
00:13:44.982 - 00:13:57.600, Speaker A: So it's a really neat way of implementing commitments for ERC four, three, seven accounts. And that's about it, guys. I hope you liked it. And if you have any questions, I'm happy to go over them. Thanks.
00:14:01.090 - 00:14:11.154, Speaker B: One kind of question in the situation where the block does not satisfy commitment, is it like alternative block proposed or just like an empty block or what happens?
00:14:11.272 - 00:14:23.650, Speaker A: Yeah, so that would be an empty block. Yeah, because the proposal at that block is effectively already decided and we simply have that at that slot. No block is recognized from that proposer, so the slot remains empty.
00:14:23.810 - 00:14:26.726, Speaker B: And what's the incentive for Alice to opt into the system?
00:14:26.828 - 00:15:34.830, Speaker A: Does she get bribed from the that's a great question. So it kind of hints at the base of why do people choose to contract in the first place? And the reason is that sometimes there's more utility from future interactions, from contracting, than there is from, say, scamming the person in the short term. So that effectively means that there are contracts for which Alice has a greater incentive to follow through than not. And what we can just do is one explanation for why people choose to contract is that if you have a contract which is enforced by a third party, then you can use this to fix incentive incompatibility issues. And so the idea here is that, for example, people can transact with or can enter into contracts with Alice, having certainty that Alice will follow through if the contract is enforced. And sometimes there's a really high utility for doing that from the perspective of Alice. So I guess that's why just one last question, but did you have any idea what did you want to ask?
00:15:34.900 - 00:15:50.306, Speaker B: Oh, basically I was kind of curious also what the incentive of the other nodes to hold parts of Alice's keys are to validate? But I guess if it's like rotating between them, then they have basically there's some offline consensus or option consensus going.
00:15:50.328 - 00:16:24.238, Speaker A: On with those security companies happening totally. So in that case, you would need to have some way of minimizing the principal agent problem, which is that the nodes act in the way they're expected to act honestly. And so you can do that either by putting incentives or maybe even like a punishment scheme where you have that notes have to report and the ones that do not align with the majority perhaps get punished in some way. In a way, this is, I feel like the, uma, B three Oracle a little bit, but yeah. Do you have any questions?
00:16:24.324 - 00:16:25.694, Speaker C: So Alice and Bob were able to.
00:16:25.732 - 00:16:27.742, Speaker A: Write commitments about things that are outside.
00:16:27.796 - 00:16:29.938, Speaker D: Of EVM and if they're inconsistent as.
00:16:29.944 - 00:17:31.220, Speaker A: Well, that's a great question. So in this case, I'm using kind of solidity I'm defining commitments in the EVM because it's a great way of kind of treating this as a common software or like a common way of execution. So it's really easy for nodes or third parties to know what code to run in what way. So first question is what are the limits of that? That's a good question. I don't know the answer to, but I would say since the EVM is incomplete, you can definitely do a lot of things. And then the other question is you can only do so much as you have, say, data in the EVM. So there's a question of the data availability question of you can perhaps only enforce constraints or commitments on things that you can have the data for in the EVM for the program to be able to run on, to enforce on.
00:17:31.220 - 00:17:50.060, Speaker A: To answer that, perhaps you can get a lot of data on the EVM. So maybe the question is how can you reliably get data from the outside world to be able to enforce commitments on? And perhaps it's an oracle problem. Exactly. Yes.
00:17:51.070 - 00:18:14.446, Speaker D: So one of the questions I was thinking was depending on the conditions that the contract sets so, as Maz had asked, the boundary of the conditions can be, let's say, constrained within EVM, but then within like, the accessible range of data, for example, it varies across the board. And also, as you mentioned, there's oracle.
00:18:14.478 - 00:18:16.500, Speaker A: Issues as well as a gas limit. Right.
00:18:18.070 - 00:18:33.078, Speaker D: Then that becomes another question, which is like, how much latency are we looking at depending on the types of contract that we enter? Because I can imagine that some contract that we enter has a lot more latency constraints than others. So what would that kind of a.
00:18:33.084 - 00:19:38.190, Speaker A: Comparison yeah, so that's a really interesting question because it touches basically kind of resource management within the scope of commitments. Basically, this implementation is kind of a synchronous enforcement of commitment because we have that the validity conditions are atomically enforced in whatever operation we're trying to make. So, for example, in the case of account abstraction, we have that there's a modifier that checks the commitments and so that atomically enforces the execution of the user operation with the checking of the conditions. So I don't think there's a latency problem there, but there's a question of, I guess, analog gustle, which is about the gas usage of this. I would say with barnabet. That's a question that we've discussed quite a bit. And I think obviously here you have that issue in which the person that defines the commitments is not the one that verifies them.
00:19:38.190 - 00:20:30.480, Speaker A: And so the cost of verification is bore by third parties, and you have this issue where the person has perhaps not internalized the externality that they're generating. So one way is taxing. So for example, you can have that, say, you reduce from the balance the gas used from the validity checks of the commitments every time that the network has to validate something. And so in that case, you have that the person would internalize alice would internalize the cost. Or another option is to just set a fixed total cost and have it be spread across all the commitments to check and all the complexity of them. So the second is the one that I went for in a prototype that I'm going to publish soon. So hopefully that will become more clear.
00:20:32.530 - 00:20:49.182, Speaker B: So if you have these types of proposer commitments, then the builders who are constructing the blocks need to construct blocks that satisfy those. And if the commitments are on an individual proposer level, then every single block there's new criteria for what you need to build a block to satisfy.
00:20:49.246 - 00:20:49.666, Speaker A: Yes.
00:20:49.768 - 00:20:56.422, Speaker B: And so have you thought about how this changes the block building meta? It seems like it makes the task of being a block builder significantly more difficult.
00:20:56.556 - 00:21:47.286, Speaker A: Totally. I think that's a great point and one that I have personally not thought much about. I think you're going to have definitely the case where builders simulate the block to see if it violates any commitments. But definitely. So if you view commitments kind of or you see block proposing as a constraint satisfaction problem, which is basically problems where you have a set of constraints and you're looking for some assignment that is compatible with constraints, the process of trying to find this data is called basically search, like constraint satisfaction problem search. And there are some algorithms from academia. So hopefully we can mirror the dynamics of block proposing in terms of constraint satisfaction problems.
00:21:47.286 - 00:21:52.520, Speaker A: And that would make it more clear about which algorithms should builders run.
00:21:53.850 - 00:21:55.782, Speaker D: Could you have relays have a list.
00:21:55.836 - 00:21:57.514, Speaker C: Of commitments with that team?
00:21:57.632 - 00:22:23.300, Speaker A: Yeah, the implementation that I was thinking is you have kind of a single tone smart contract, which is at an agreed upon address, and then anyone can call a function in this contract that kind of retrieves all the commitments of some users. So you can definitely have relays use kind of this registry. Okay.
00:22:24.310 - 00:22:30.690, Speaker C: Given checking whether the commitment is consistent with previous commitments constraints, that's a problem.
00:22:30.760 - 00:22:33.422, Speaker A: Perhaps we can ask Alice to propose.
00:22:33.486 - 00:22:35.400, Speaker C: A decay group every country.
00:22:36.250 - 00:23:00.538, Speaker A: Absolutely. In fact, Anoma, they just published a work about kind of framing intents in terms of constraint satisfaction problems, and they built infrastructure using Hello Two to effectively create proofs for intents. So that basically empirically confirms, I guess, that idea. So, yeah, you can definitely use proofs for this. Yes. Okay.
00:23:00.624 - 00:23:22.770, Speaker C: You this collusion risk increase with basically the reward you replace. I mean, the transaction could replace this transaction, contrary transaction could replace weak MVP transaction that could send reward back to the validator. Right. And I guess that could cause collusion incentive for the validators.
00:23:23.290 - 00:23:24.040, Speaker A: Okay.
00:23:24.730 - 00:23:34.120, Speaker C: And I'm just wondering if the payment for the one that's doing the contract depends on basically the upscale value of the.
00:23:36.030 - 00:23:52.274, Speaker A: Wait, I'm curious about the connection between or like okay, you have that there's a payment conditional, like a payment condition on, say, the transaction to be included and how that connects to the collusion. Would you perhaps explain me further?
00:23:52.422 - 00:23:55.146, Speaker C: I mean, I guess you need to incentivize validator to not collude.
00:23:55.178 - 00:23:55.760, Speaker A: Right.
00:23:56.610 - 00:24:03.946, Speaker C: And the more NV that's extracted, the more it can be paid to the validator, more you need to incentivize the validator not to collude.
00:24:03.978 - 00:24:04.222, Speaker A: Okay.
00:24:04.276 - 00:24:09.220, Speaker C: Otherwise the validator could just say, oh, I'm going to pay you this extra money because I'm going to get it anyway.
00:24:10.310 - 00:24:14.920, Speaker A: Yeah. So it's a good question. I don't know the answer, to be honest. I will need to think about it more.
00:24:16.250 - 00:24:19.922, Speaker E: Sorry, last question, because we still have two speakers.
00:24:20.066 - 00:24:20.838, Speaker A: Okay, cool.
00:24:20.924 - 00:24:27.866, Speaker E: So if they have more questions, you can come to Diago one by one. So then let's ask the question.
00:24:28.048 - 00:24:31.130, Speaker A: Okay. Final question. Do you want to ask a question?
00:24:31.200 - 00:24:34.762, Speaker B: Yeah, I was going to ask.
00:24:34.816 - 00:24:35.034, Speaker A: Okay.
00:24:35.072 - 00:24:54.270, Speaker B: So I was just curious. I don't think this is solvable or anything, but how you think about this. It seems like you could make commitments that are really detrimental to the network, like censor uniswap or something, and then that affects the next validators. So curious how you think about that trade off or how proposers.
00:24:54.350 - 00:25:41.090, Speaker A: Yeah, so that's a really good point. And you see that those same issues coming, say, between, say, in the case of contracting between AI agents where you can have AI agents commit to doing really bad things. And so I think that that's definitely possible. At the same time, I guess a counterargument is that validators will simply validators would probably have done it anyway out of protocol. So in this case, it's just making explicit something that had the incentives been right, they would have done anyways. So I guess a counterpoint to that would be that at the same time, this perhaps will reduce the costs of contracting for even those detrimental cases. So in that case, it will effectively make them have a greater utility.
00:25:41.090 - 00:26:10.200, Speaker A: So I guess I'm in no position perhaps to like, or rather perhaps it's a question of like, to what extent can we constrain the way people contract? And to be honest, I think that maybe it's too hard of a problem. Maybe the case is to let them contract for anything, even for bad things, just to preserve that freedom to contract however they want. Yeah.
00:26:11.290 - 00:26:24.170, Speaker E: Thank you. And we don't have a rest between Yuki and Diego because Yuki has something to do in the evening. So let's welcome Yuki.
