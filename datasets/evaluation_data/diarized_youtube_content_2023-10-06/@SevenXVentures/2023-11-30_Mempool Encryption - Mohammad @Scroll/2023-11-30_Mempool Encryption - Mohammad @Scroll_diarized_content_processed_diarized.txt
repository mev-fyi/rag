00:00:00.410 - 00:00:16.320, Speaker A: Please stop. Don't tag. Hello everyone, this is Mo. I'm from scroll. I'm going to give a few other types this week. Most of them are about what we are actually doing at the scroll right now. This one is not.
00:00:16.320 - 00:00:58.282, Speaker A: So at the scroll we are. I'm mostly working on data compression for data availability or data solution and a ZK core processor for decompression and also designing the decentralized score protocol. Decentralized proof generation market or something like that. You can catch me talking about loads of stuff during the week. But this is a research I've been doing with the university collaborators. It's funded by Ethereum Academy grants. The reason I want to plug this one in here is that recently the censorship situation in Ethereum is getting worse and worse.
00:00:58.282 - 00:01:48.910, Speaker A: So I want to do my part in encouraging the conversation about censorship, resistance tooling and technology for Ethereum band blockchain technology. So the title of talk is mutual encryption. But I want you to think about this as a censorship resistant and credible sequencing technology which fits in the modular narratives. Okay, so basic stuff, so vanilla follow up transactions in Ethereum, we have Alice as a transaction, sends it to the mempool and everyone can see stuff in the mempool and Bob makes the plug. And done. And the important thing here is the inclusion and execution of transactions happen at the same time. It's like an atomic.
00:01:48.910 - 00:02:27.740, Speaker A: But what can go wrong? Front running. Like Evie is watching the mempool, she is a searcher, she sees an opportunity, she front run Alice. And Alice gets worse deal on the uniswap swap or whatever. The more serious problem is censorship. So Alice is sending a transaction, maybe Alice is on OFAC list or Alice is dealing with the OFAC sanctioned smart contract or whatever. So Bob is not comfortable with including Alice transaction. So Alice transaction out and Bob is a builder here.
00:02:27.740 - 00:03:17.026, Speaker A: Okay. The other problem is when we have this kind of situation, it's more profitable for Alice and Bob to be the same person or for Alice and Bob to closely cooperate. So there is incentive for centralization. And remember, this is pre proposal builder separation. Kind of. So it encourage people to delegate their money to ones who are running, builders that are very profitable and them doing the proposing and building. The other problem is this kind of incentives creates consensus in a stability.
00:03:17.026 - 00:04:01.030, Speaker A: In what sense? So say Bob finds a block and there are juicy MEP transactions there and Eve is the next proposer and she can just pretend that she didn't see Bob's block. And I mean, if she has enough incentive, she can bribe others or whatever to make this happen. And we have a reorg, basically, it increases the incentive for reords. Okay. Now that we reviewed all this stuff that you know better than me what has been done so far. So proposal builder separation is one of the things that has been done. The idea is we separate the role of proposer and builder.
00:04:01.030 - 00:04:41.758, Speaker A: It helps proposers to be light and stop the centralization force. To some extent, the people who are capable of extracting these opportunities are builders. They offer proposers some money and take the right to propose the block and at the same time extract some value, which is nice and solves a few of those issues. But it's basically embracing Mev, that's first and second. Builders can be centralized. So if builders start censoring people, we are kind of in a big gun. These are the stuff that I wrote.
00:04:41.758 - 00:05:38.530, Speaker A: So there are some ideas how to stop this censoring force from builders, like censorship, resistance list and stuff like that. The idea is proposers make some portion of the block, but builders make the rest of the block. And because we have so many proposers, maybe not all of them start censoring people. So if you have a transaction, it eventually gets included, at least in this way, but it's not implemented yet. And reality is we have builders and we have few builders that do most building, and most of them are complying with OFAC. And that's bad news, because what if OFAC tomorrow starts putting more people on the list, or, I don't know, maybe put uniswap on the list or something like that. And besides mean, it's in deep conflict with decentralization ethos and stuff like that.
00:05:38.530 - 00:06:34.790, Speaker A: We don't like this app. So to describe what's happening, if I make a transaction and I'm an OFX sanctioned address, or if I'm dealing with the OPAC sanctioned contract, these builders won't include my transaction. The red ones won't include my transaction, and red ones consist, like, more than 70% of the building power, meaning that if you look at the last two weeks of ethereum blocks, 70% of those blocks were built by these red ones, and they don't include OPAC sanctioned transactions. And you can imagine, like other regulatory budgets, start sanctioning other addresses and whatnot, and they start complying, because these are businesses, these are entities who you can find and locate and punish. Okay. I mean, we can't expect them to not be OPAC compliant. Okay, what are the solutions? So, one obvious solution is we encourage self building.
00:06:34.790 - 00:07:06.640, Speaker A: Like, we encourage people to the proposers to build their own plugs. So effectively, we're asking them to give away like a few percentage of reward and just be altruistic. It is not going to really happen. Like, I'm running a node in my home because I think it's cool, but not that many people will do that. And I propose a block, maybe a few times a year. That's not it. The other solution is to somehow fundamentally change this direct.
00:07:06.640 - 00:07:35.180, Speaker A: So there are a few proposals to do. The first proposal is we do some sort, and some of these proposals solve censorship. Some of them attempt to solve MEP only. Okay, I will go through this. So the first class is fair order. This one doesn't really try to solve censorship. It mostly tries to solve MEP, in the sense that it says, okay, we have a list of transactions, we have to order them.
00:07:35.180 - 00:08:24.186, Speaker A: And we don't want to let somebody to react to a transaction. Like, we don't want this scenario to happen, that I publish a transaction, everybody hears about it, and suddenly somebody in the crowd reacts to it, and sandwiches or whatnot. Okay, so the idea is, if we put the transactions that are propagated earlier, sooner in the lease, they can't get front run or effectively sandwiched. So this is, in my view, purely theoretic and very easy to gain. The security proofs in the paper. There are tons of papers, like at least ten paper in the last three years about this one. The security proofs mostly have unrealistic assumptions, and there is no real implementation of this one.
00:08:24.186 - 00:09:02.406, Speaker A: So this one is a still work in progress. And this one doesn't solve censorship resistance. The way it could help with censorship is it eliminates the need for builders. So we have more proposers that are following these rules. So it indirectly may solve censorship somehow, but it doesn't attempt to directly do that. Second idea is, okay, we order transactions randomly, like every block is just a set of transactions, and the order in which those transactions are going to be executed is random. And where does that randomness come from? That's a question.
00:09:02.406 - 00:09:45.490, Speaker A: Like, if you want to hash the transactions and take that as random seed, and then order, permute the transaction with that random seed and then execute them. Okay, the block builder or block proposer can put transactions or same transactions, something kind of like a proof of work situation, and impose a certain permutation. So that's up. What if we use rand? Randao is not totally bias proof, and the list goes on. It's a nice idea because it's very simple, but it has its own shortcoming too. And again, it doesn't stop censorship resistance. Like if you see an Opax action transaction, you just put it aside.
00:09:45.490 - 00:10:23.546, Speaker A: Okay, the other idea is credible. This is based on, we define a rule, a sequencing rule, and we ask the proposers or builders to follow this sequencing rule. And the idea is this rule will eliminate any sort of mev extraction. Like this move is supposedly detecting mev extraction happening and says there is mev extraction. Not valid. But the assumption here is we can detect mav extraction, which is not always true or easy. And also there is this conference called stock, I think it's symposium of theoretical computer science.
00:10:23.546 - 00:11:09.486, Speaker A: Something recently this year was a very interesting paper in a stock proving impossibility result for credible under some fair notion of credible sequencing that doesn't allow memory fraction from just Uniswap v. Two Texas early research shows that this direction is a little bit hard to do because we have impossibility. And again, none of these approaches provide censorship resistance. Okay. The other class of ideas is inclusion execution separation. So this is something that I guess, I'm not too sure this is something that Fairblocks does. Taiman from Fairblux is back there.
00:11:09.486 - 00:12:03.242, Speaker A: So the idea is we separate these two things. Like at first I mentioned when Bob makes a transaction, I mean, makes a block, what's happening is he's including some transaction and executing them at the same time. But what if we can split these two in two stages, like include transactions at one time and execute them at a later time, with the goal that when we include transactions, transactions are encrypted and at a later time, they become decrypted somehow, and then they get executed. So at the time of inclusion, we don't know what's inside. We just include the threshold encryption approach, is that we have a committee of people, they have some public key. We encrypt to the public key, and they have shares of a private key that they can come together and decrypt the encrypted transactions. And we should trust this committee to do the decryption.
00:12:03.242 - 00:12:46.190, Speaker A: Like we have a heavy trust assumption on this committee to be live and honest and stuff like that, which is not something that we can do on ethereum, obviously. The other approach is timelap puzzle. So you probably heard of time like puzle. Time like Puzle is a cryptographic primitive that allows you to put a message inside the puzzle. The puzzle can be opened if you know the secret of the puzzle, but if you don't, it's fine. You can start working on it and grind, and it will be opened after a delay. So timelock puzzles are kind of like encryption methods, with the difference that when you don't have a decryption key for some encryption scheme, you can't decrypt what's inside.
00:12:46.190 - 00:13:39.298, Speaker A: But for timelap puzzle, you can. It's just delayed. Okay, so the idea is we put every transaction inside the timelap puzzle and post it, and chain transactions get included. The puzle transactions get included. And maybe a few blocks later, everybody can see what's inside because they start working on the puzzles and then they get the click. The problem with this one is timeline puzzles are inherently sequential. Like, the whole idea of time like puzzles is that the construction should be designed so that if I have more computational power, more cores of cpu, it shouldn't be really helpful for me to accelerate opening the puzle, right? So if I have 100 transactions, like a typical Ethereum block may have 70 transactions, right? If I have 70 transactions that I want to open, and all of them are inside puzzles, I need 70 cpu boards.
00:13:39.298 - 00:14:04.518, Speaker A: That's unacceptable. And if the wait time is like two, three blocks interval, this is two, three times 70, which is a lot of cores, prohibitively hard. So this one won't work. So the final idea is delay encryption. So there are a few different notions called delay encryption. So bear with me. You may have something else as delay encryption, but this is what I will use here.
00:14:04.518 - 00:14:27.582, Speaker A: So the idea of lay encryption is we have a public key, private key pair. Okay? The public key is in the clear. Everybody can see public key. The private key is inside a puzle, a time vector. And after some time, it will be open, like, maybe after like 15 seconds, 22nd. Right. So if you want to encrypt something for the future, you encrypt it to the public key.
00:14:27.582 - 00:14:57.730, Speaker A: And after 1020 seconds, the private key is available for everybody. They can decrypt the messages that were encrypted to the public. Right. It's very interesting because it can replace the timeline puzzle here. And everybody encrypts to the same public key. And all the transactions of a block can be decrypted only if this private key that everybody is encrypting to becomes available. So everybody just has to solve one puzzle per block, which solves the issue that I discussed.
00:14:57.730 - 00:15:40.826, Speaker A: But the problem is who is going to make this pair and put the private key puzzle. That's the whole problem, which we are going to solve in this work. Okay? So to give you a pictorial view of what we are going to do, this is our construction. So as I mentioned this was sponsored by Ethereum academic grant. So this is focused on Ethereum, but we can think of this being applied in other scenarios or not necessarily this something similar to this. So we tried hard to fit it in the current Ethereum model. So the way we work is we have attestation aggregators in Ethereum consensus protocol, right? And they already have some role.
00:15:40.826 - 00:16:19.678, Speaker A: We are going to assign them an extra role. What's that? At each slot, assessation aggregators are going to aggregate a number of attestations from their peers and publish it. We ask them to do one more thing as well. And that thing is they create a pair of public key, pk zero here for the first assessator and puzzle. Private key ek zero. And everybody makes one of these pairs and they know what's the secret to this puzzle. So everybody knows their own private key, but you have this aggregation phase that aggregates all these private keys.
00:16:19.678 - 00:17:05.690, Speaker A: Essentially what's happening is everybody is contributing some randomness and these randomnesses get combined and we get a key and the key is a public key in clear and a private key inside the puzle. So our contribution here is we found a way for these private keys to be aggregated inside puzzles, homomorphic. Right? And then we have this public key in clear and the locked secret key or private key. And everybody who wants to make a transaction for a few blocks or maybe, or maybe for the next block has to encrypt to this private key. Sorry, public key. And their transactions are distributed in encrypted form. Right.
00:17:05.690 - 00:17:42.342, Speaker A: So nobody can see inside. In the mempool, transactions are encrypted and the future block proposers, they include the encrypted transactions. So what happens is like this, every block has a number of transactions from past, like transactions from the past. Like maybe in block n minus D, we included a few encrypted transactions at block n. And D is a delay parameter. At block n those things are decrypted and now executed here. So each block has two parts.
00:17:42.342 - 00:18:16.486, Speaker A: One part is transactions that are going to be executed later. And the first part is the transactions that have been included before and are executed now. So we are incurring a delay, the finality and execution. And everything is incurring a D delay. But this d doesn't have to be big, that's the point. Like if we disseminate a block, maybe every few seconds, which could be the case for many modern blockchains, this d can be like two or three times that. But for ethereum, if that block generation times is twelve.
00:18:16.486 - 00:18:45.770, Speaker A: It's two or three times twelve. It's not that bad. It's a trade off. Ambulance. There are a few things that are curious here. For instance, if the transaction is encrypted, who is paying for the transaction fee? Like how do I know as the sequencer or miner or whatever, that this person has some money inside the account? So we split the fee into two parts. One is inclusion fee and one is execution fee.
00:18:45.770 - 00:19:40.494, Speaker A: When you're included, you just pay for the data availability cost that you are going to be available for d blocks. So you have to pay that price, which is going to be very small, like it's just being available for a very short time. Right? And also you might think, okay, if I am submitting this transaction with my own address and all, I can still get like ofac sanctioned and people want to include me and stuff like that. So the way it works is that we introduced this concept of transaction carrying transactions, like block carrying transactions that are carrying other transactions. So you can initiate a transaction from some other account, maybe in burner wallet or whatever. That includes your real transaction. So it's not clear the inner transaction.
00:19:40.494 - 00:20:13.718, Speaker A: What's the address of the inner transaction from the. Okay, how much time do I have? Perfect. So I'm going to show you the construction. Before that, I will just talk about the foundation of time lap puzzles. Just to give you, for the audience that didn't know this before, just to give you some hint of what this looked like. And for those of you who have seen it, just to review it. So time like puzles were introduced a long time ago, like 2030 years ago.
00:20:13.718 - 00:20:55.958, Speaker A: And the initial construction was based off RSA Modulus. So it's very easy. Suppose you have an RSA modulus, which is multiplication of two big primes, PQ. And then it says, okay, say you want to put a message m inside the puzle. Okay, what you do is you find a secret key k. Like you draw a random secret key k, and you use your favorite symmetric encryption algorithm, maybe rc five or whatever. This is some old symmetric encryption algorithm, okay, so you're encrypting your message m with some key k, okay? And then you want to put k inside the puzzle.
00:20:55.958 - 00:21:45.178, Speaker A: That's not really happening. So the way it works is you add some number a to the power two to the t, where t is our delay parameter. To this k mod this modulus m. Okay, where does a come from? A is just some random number you take and you put all these things together and this tuple, this big tuple is your puzle. So it includes the modulus, includes a, includes the delay parameter, the encrypted kind of secret key, and also encrypted message. If you want to open this, what you have to do is to raise a to the power two to the t and subtract that from ck to get k, and then you can decrypt the n. So it hinges on this fact.
00:21:45.178 - 00:22:21.960, Speaker A: The security hinges on this assumption. If you want to calculate a to the power two to the t, you have to go through t steps of computation. That's the whole idea. And you can't do it faster than that. This assumption, theoretically, is proven in a strong algebraic group model. In practice, people have found ways to accelerate this a little bit in practical scenarios, but there are ways to combat that. But bear with me, let's not get too deep in the bit.
00:22:21.960 - 00:22:52.150, Speaker A: Okay, so what I want to do now, this is not what we're doing. What we want to do is something that's similar to this. I just wanted to show you that timelap puzzles are not that complicated. What I want really and need is a linearly homomorphic timelap puzzle. The construction I show you is not linearly homomorphic. The reason is, if I sum up two different vms, they are not homophobic. It's just gibberish.
00:22:52.150 - 00:23:26.354, Speaker A: I don't get m one plus m two inside some other encrypted thing. I want this property. I want, if I have a puzzle that keeps a inside and another puzzle that keeps b inside. If I add these two, I want to get another puzzle that has a plus b linearly homophobic. So, our work is based on a very recent construction. It came out, I guess, 2022, that introduced a linear homomorphic comeback puzzle. So it kind of looks something like this, I think.
00:23:26.354 - 00:24:06.750, Speaker A: I can't go into the details, but it has a few nice properties. So, this is the construction of the puzzle. And if you look closely and if you have more time, you could see that it hinges on the same assumption that the RSW female puzzle has, but it has a few extra things. For instance, it's aggregateable, meaning that it's linearly homomorphic. If I have two puzzles, like puzzle. So each puzzle is a pair u zero v zero, and u one v one. I can just sum them up with multiplying parts.
00:24:06.750 - 00:24:44.460, Speaker A: And one important thing here is, the first part of the problem is some generator g to the power r mod n. And the second part. And the second part hides the secret s here in the exponent. Okay, this is going to be important in a second. Another cool property of this is that it's verifiable, meaning that if I give you a pair, you can verify it's a valid puzzle. You can verify that you and me have this relationship. Like, you can't solve the puzzle immediately, but you can immediately tell that they have this relationship.
00:24:44.460 - 00:25:53.246, Speaker A: And this is important for us, again, to be sure that the stuff that you are aggregating are not wrong. Okay, so what we do is that we take this, which is somebody else's work, and we say, what if we replace this random Sr. Sorry, with this s, which is what's the content of the puzzle, with the randomness r for the same puzle. What if we do that, we get an lgano public key for the first thing, u here for the secret key, s that's in the second part. So if you think about it, u is a public key and v is a puzzle that holds the secret key corresponding to this lgaml public key. So lgaml's public key are like this, like sum g to the r mod n, where r would be the private key, right? So if we set s and r equal to the same thing, it means that what's inside the puzzle is equal to the randomness of the puzle. This is kind of what we try to do.
00:25:53.246 - 00:26:24.140, Speaker A: And when we started the project, this was our goal. But it turns out this won't work. And we did a lot of ugly math to make it work. But the resulting thing is you don't have a noise couple like this. You have a few other things tagging a launch, because the security proofs will break down if we do this right away. But this is what we get, essentially. Essentially we get the LGMl public key with private key in the second piece of.
00:26:24.140 - 00:27:26.060, Speaker A: Now that we have this primitive cryptographic primitive that mostly my collaborators built, and I'm talking about now just the protocol level stuff goes like this. So the attestation aggregators, I remind you what they are. So each validator gets to be attestator once in an epoch, okay? And some of those people who have attestation duty get to be aggregators, meaning that there are groups of 64 attestators, up to 64 attestators. They make attestations. Somebody aggregate those attestations. The goal is we don't want everybody's attestation flooding in the p two p network so that we want to reduce that. So somebody aggregates it in some top p two p thing and then disseminate it.
00:27:26.060 - 00:27:54.674, Speaker A: That doesn't really matter. The only thing that matters is that they are part of the protocol. And what we want to do is that we ask them to create one of these puzles at each time. They want to make attestation with some random r, okay. And distribute that. So we change the consensus rules a little bit. The contributed puzzles must be valid.
00:27:54.674 - 00:28:36.498, Speaker A: Otherwise the assessation aggregator will be a slash and they will be a slash because they signed that puzle. So they can't cheat in that sense. And also the people who are building the blocks, if they don't include the puzzles in the block, they can't include the attestation either. Like, if I'm making a blog and I want to be, I'm a little bit confused myself. Let me move from this one. Okay. I talked about inclusion fee and execution fee.
00:28:36.498 - 00:29:21.090, Speaker A: I think this one is pretty straightforward. The idea is we want to somehow deal with the metadata leaking problem. If you do transaction encryption, one problem is always, if you encrypt everything and you don't leak any metadata, then it's hard to tell whether you have funds to cover the fees and such. So people propose you can use Zksnar proofs that, look, the encrypted thing and attest to this person having enough funds to cover whatever amount of gas they are offering. But that's too complicated. And if you have many transactions, maybe some of them are included for free. Like if I make four transactions, each of them on their own can pay for themselves, but all of them together can't.
00:29:21.090 - 00:29:56.254, Speaker A: So it's just a simple way to deal with that. Transactions carrying other transactions. We have a few open problems in this work, and that's why this is not like an EIP already. And the first problem is, the way we're dealing with metadata maybe is not optimal. We have to think it through maybe a little bit. The second is, we don't really know what's the minimum viable delay. It depends exactly on the best time a hardware can open these puzzles and the delay of network distributing the puzzles and such.
00:29:56.254 - 00:31:02.340, Speaker A: So one thing that I hit under the rock is that when transactions get encrypted, the size of transactions blow up quite a bit, like six to ten times, because we have to have very big keys to get reasonable securities in our scheme. So for that reason, we are not sure what's going to be a reasonable block propagation time and stuff like that. So for that reason, we don't know what's the minimum viable delay. We have to run a simulation or proper test net to figure that out. And finally, our construction relies on this safe prime RSA modulus thing, and we have to run a trusted setup for that. And there are not that many works to do a trusted setup without a trusted entity like decentralized trusted setup for this kind of RSA measures. I mean, there are obvious ways to do it with snark and so on, but yeah, it still has to be explored first.
00:31:02.340 - 00:31:46.974, Speaker A: Thank you. You mentioned that the transaction obviously size blows up. Yeah, interview that also impacts users fee as well, because that will become much higher compared to a normal. Very good question. So if you remember, I mentioned that these transactions get included in the encrypted form first, and at that time they pay the data availability cost of them being carried over for d blocks, right? Or maybe a little bit more than that. So obviously they have to pay for it. And the transactions are much bigger, maybe five to ten times bigger.
00:31:46.974 - 00:32:11.820, Speaker A: But remember, these transactions are not that big to begin with, and this interval is not that long either. So I suspect that data availability cost, the effective data availability cost that they have to pay, that's the additional cost. Real additional cost here is not that much. It doesn't make the thing unpractical right away.
00:32:14.110 - 00:32:20.300, Speaker B: My question is, why not use functional pressure versus the.
00:32:23.170 - 00:32:43.362, Speaker A: Very good question. So another approach is. So if I understand correctly, the verifiable delay function can be used to randomly previous transactions in a block. But other than that you can also.
00:32:43.416 - 00:32:59.990, Speaker B: Like for example, I can encode. They basically have a private key, but it has to be decoded for some time after some repeatedly, basically modular situations.
00:33:02.590 - 00:33:07.260, Speaker A: Each person who makes a transaction has to make one of those.
00:33:08.270 - 00:33:24.178, Speaker B: Yes, but just like I think it can be also able to also using similar public and then roofing, recalculate so.
00:33:24.184 - 00:33:26.594, Speaker A: That you will have return your same.
00:33:26.792 - 00:33:29.890, Speaker B: Calculate values for every transaction.
00:33:30.390 - 00:34:16.722, Speaker A: To be honest, I'm not completely familiar with that. One reason is, again, one reason is I've done this work in collaboration with other people and they took care of most of the hard parts. But the way I understand it, if we want to do anything like this for each transaction on its own, and we can't somehow aggregate these puzzles or verifiable functions or whatever, if we can't aggregate them, it's impractical because it's impossible to do for every transaction we need a lot of independent ports. But if we can batch these operations, it doesn't matter. Like it's just one primitive to do this. I'm going to ask them. There are other primitives to do this.
00:34:16.722 - 00:34:26.340, Speaker A: In the paper there is a preprint. There is some comparisons, but I'm not too sure. Maybe we can talk.
00:34:29.450 - 00:35:00.526, Speaker B: About the inclusion fee. So one idea about this inclusion fee that just for installation can partially hide how the fields in a transaction, for example, the destination address and also the core data. And while we can reveal all the rest of data, like the transaction fee of gas price, so that we can exactly calculate the inclusion fee when transaction just completed. But while we have no idea what eventually the transaction will complete.
00:35:00.628 - 00:35:16.526, Speaker A: Yeah. In our scheme, inclusion fee just corresponds to the size of transactions like bitcoin transactions. Right. We can calculate it and it's easy, but obviously the RS will also improve.
00:35:16.558 - 00:35:17.966, Speaker B: Valid proof of transaction.
00:35:17.998 - 00:35:22.738, Speaker A: Yeah, make sure it can be failed.
00:35:22.754 - 00:35:24.502, Speaker B: But it's valid, right?
00:35:24.556 - 00:35:56.642, Speaker A: Maybe like there's a signature that shows us. Yeah. The big problem is this leakage of metadata. Like, people can see my address, and if I'm open sanctioned, this transaction doesn't get to a block right away. So that's the biggest. But that could work in some scenarios to get blocked. I'm curious about the usage of RSA group.
00:35:56.642 - 00:37:21.150, Speaker A: Is it possible to use things on curve based construction instead of RSA group? Is there any particular properties of the RSA group? Because potentially the curve base can have smaller size under the same mixing. The main issue is there is no construction like time like puzzle construction over curves that is also homomorphic, like linear morphic. In the literature, there are only RSA based time lap puzzles that are linearly homomorphic too. And this property of being linearly homomorphic is very critical for us to aggregate and not have one person contributing their analysis. It forces a time lost puzle part, but gamma, right? What do you think about the performance with this change? Because the block space is being reduced and each transaction has to be included almost twice, right? Yeah, it takes a toll on the network infrastructure, but other than that, and also it introduces some delay. Like definitely there is a cost to pay here. And probably this is far from being efficient.
00:37:21.150 - 00:38:14.954, Speaker A: That's something that I like to improve too. But also I see that at block end, the block reporter still has a chance to censor some transactions. They can just ignore a transaction saying that it cannot execute. No, the fourth choice rule goes as false. This block will be considered invalid if it doesn't include all of this puzle transaction here. That's one. And if it includes one of this transaction and just doesn't execute it and says, oops, it's wrong, it's kind of like you execute a transaction incorrectly and people will ignore your doc, right? The same goes for, I mean you could ignore transaction but you're deviating from protocol.
00:38:14.954 - 00:38:18.480, Speaker A: So if you have an honest majority, people will ignore you and so on.
00:38:20.370 - 00:38:23.200, Speaker B: Is it compulsory to include that?
00:38:23.650 - 00:38:36.710, Speaker A: Yes. How do you post that? That's going to be new protocols, like it's an l one level design or if you want to include it on any chain, it's based protocol.
00:38:38.730 - 00:39:09.630, Speaker C: How do you respond to criticism that Ethereum just keep putting more responsibilities into the committees that already exist? Yeah, because right now you're telling the aggregator to not only validate the transactions are valid before inclusion, but also have a key share protocol among them and encrypt them and then decrypt them. Would you say that's like a lot more responsibility for the aggregator than just simply do some bi signature aggregation?
00:39:10.690 - 00:39:29.398, Speaker A: Yeah, that's a fair question. So we benchmark the load that we add to the validators for decrypting this transit. So validators have one big more responsibility, like the computationally intensive responsibility that's introduced here. It's decrypting transactions. Okay. Yeah, that's the big one.
00:39:29.564 - 00:39:32.790, Speaker C: Is that for the proposer validator or the aggregator?
00:39:33.930 - 00:40:02.080, Speaker A: So there are a few entities. One is attestation aggregators. They are already doing something that's much harder than what we ask them to do. They are like attesting that they saw a blog and the blog is valid and something like that. So they already have some rule in the consensus. Okay. And what we ask them to do now is very simple, like they just have to take a random number and make a page and disseminate that.
00:40:02.080 - 00:40:25.906, Speaker A: I think it's acceptable. Maybe it's just making the protocol too complex. That's another issue. But the load is not really that bad. But for validators, they have to decrypt these transactions and make sure these are matching this one here. And this can introduce a lot of work. We have some benchmarks.
00:40:25.906 - 00:41:01.570, Speaker A: It seems like it's doable. And normal validator nodes like this knock inter. But that's a fair criticism. It eventually somehow increases the cost of running the whole protocol because people are putting more resources into this. So somebody has to compensate them. Yeah, but I don't think if it encourages centralization like it won't make running validators impossible or something for regular jobs.
00:41:02.710 - 00:41:12.098, Speaker D: Does it actually solve the censorship OFAC censorship problem? Because at the end of the day you should include the fee outside the future bundle.
00:41:12.194 - 00:41:12.840, Speaker A: Right.
00:41:13.210 - 00:41:18.366, Speaker D: And then it's coming from your address and already listed as OPAC and that is yours.
00:41:18.418 - 00:41:49.246, Speaker A: And that's the idea. I thought I had a slide about this one. So that's the idea about this transaction, carrying transactions. The idea is. The idea is we introduce this new transaction type that carries an inner transaction inside itself. Right. So you can make this transaction outer transaction from some other wallet that includes your transaction from the actual wallet.
00:41:49.246 - 00:41:50.686, Speaker A: That's over sanctioned.
00:41:50.878 - 00:41:56.114, Speaker D: Yeah, but the problem is that they will be essentially locked because of the amount.
00:41:56.232 - 00:41:56.562, Speaker A: Right.
00:41:56.616 - 00:42:22.162, Speaker D: Because you wait for whatever time that the transaction is trying to be executed. So when you sign your transaction, they will not correct. And then if you take that and put it with the signature inside another transaction, they should wait. Your valid will be locked by the time that e block.
00:42:22.326 - 00:42:38.626, Speaker A: That's a fair question. Yeah, I haven't thought about that. Okay, sorry, last question. Yeah. Okay.
00:42:38.728 - 00:42:50.402, Speaker E: It might be related to what you just said, but I'm curious about the builders. When they don't include transactions that they censor is because they need to be OCAC reply.
00:42:50.466 - 00:42:50.934, Speaker A: Right.
00:42:51.052 - 00:42:54.130, Speaker E: So they shouldn't include these types of transactions.
00:42:54.290 - 00:42:55.560, Speaker A: That's a good question.
00:42:56.810 - 00:43:18.830, Speaker E: My point is that even if the member is encrypted and they don't know actually what is happening, and so which transaction they're including, they will still need to be looked at. So they could potentially have some problems where they said, oh, but I included it, I didn't know. But after, you're going to be able to see, okay, this builder.
00:43:19.810 - 00:43:49.302, Speaker A: And even though they didn't know, it's still not two things about what Feyman said. So this design can be implemented on a roll up or some other execution environment. I don't know. If it's not account based, then we don't have that problem. But to be honest, I didn't talk about this problem. Thank you. Your question? I think there are two scenarios.
00:43:49.302 - 00:44:33.200, Speaker A: Either law enforcement comes and said, if you are running this protocol at all, or participating in this protocol at all, you are in trouble because you can't tell if this is OPAC sanctioned or not. So just shut down the node altogether. Or the alternative is they just cool with it. I guess the end game is they try to shut down the whole protocol. And I would say that's a better future than having a protocol that's being effectively central with OPAC. Like, what's the whole point of running this thing? We could use bank. Thank you.
