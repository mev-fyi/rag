00:00:00.410 - 00:00:05.482, Speaker A: Okay, so, hi everyone, my name is Remy, I'm the founder of Inco and this is Amori.
00:00:05.546 - 00:00:06.014, Speaker B: Hi.
00:00:06.132 - 00:00:26.066, Speaker A: So today we'll talk about two things. So one is what is Inko? And the second part is kind of like our explosion with dual staking. So like to share some insights, also some learnings. So we are in the confidentiality space. We are a modular confidential computing network. But first of why confidentiality?
00:00:26.098 - 00:00:26.246, Speaker C: Right?
00:00:26.268 - 00:01:04.042, Speaker A: Why does it matter? So there are a couple of reasons. First, it is a fundamental human right. If we want to use blockchain as a value layer for all of us, then we need a minimum confidentiality. Second, for institutions enterprise to adopt crypto, there also needs to be confidentiality for either regulations. But also if you want to keep your competitive edge, you need some confidentiality. And lastly, we think a lot of the use cases are not feasible today because everything is transparent on public blockchain. So today when you come to crypto, you will quickly realize that you can only build use cases that make sense on a transparent database.
00:01:04.042 - 00:01:38.310, Speaker A: But this is not how web two works. What if you want to build, let's say a poker game or a private voting? This is just not feasible. So the way we bring confidentiality to crypto is through fully homomorphic encryption. So fhe. So what is fhe? Fhe is a cryptography that allows you to encrypt data, but also do operations on top of it without having to decrypt. And so for folks who don't know how to code or don't know programming, imagine you have a cat picture and you were to encrypt it. You can still manipulate the RGB values using Fhe by adding, dividing, multiplying.
00:01:38.310 - 00:02:17.730, Speaker A: And when you decrypt, now you have a filter right on top of the cat picture. So this is really the magic of fhe. It is a cryptography meant to do operations in a confidential manner. Now, for folks who are more familiar with ZK privacy, the difference with fhe here is really the idea that when you apply fhe to blockchain, it's going to be more composable because you can directly do state transition on top of this encrypted states. With ZK, it's more meant as a proof of compute. So if you want to do any state transition, it has to be over plain text and not encrypted data. So this is where if you have a multiparty use case, you could be leaking information to decentralized coordinator or prover.
00:02:17.730 - 00:03:04.802, Speaker A: Because it's not meant to do stage transition on top of encrypted data. So we applied fhe into an EDM called FHDM so you can build your use cases in solidity. We have an encrypted type called Euint where it's encrypted integers. So for ERC 20, it's a mapping of address to un. If we do an ERC 20 transfer, you can basically do an FHE addition or subtraction directly on top of the encrypted data on top of it. We can also generate a hidden random integer that can be quite useful for gaming, like poker, because this value is hidden. And we really think that FhE is the endgame for coffee alley because it doesn't require any secure enclaves, doesn't require to write any complex circuits.
00:03:04.802 - 00:03:29.630, Speaker A: Also it doesn't require any centralized off chain coordination. So what is Ingo? Inco is two things. One, we are a modular l one blockchain that leverages fhe. Second, we are a universal confidentiality layer of web. Three. So what does this mean? So public blockchains cannot support confidential states. And we want to extend this feature to existing blockchains to enable novel use cases.
00:03:29.630 - 00:04:01.690, Speaker A: So we are a cosmos based blockchain. From a high level. There is an EVM with some precompiles that can compute basically these encrypted states. We also have a NPC network where you can use this to decrypt all these encrypted states. But because it's NPC based, none of the values have the entire private key. Whenever you need to decrypt you have to do a partial mesh assigning, do an aggregation and then reveal the plain text. Now getting more into the eigen side of things.
00:04:01.690 - 00:04:39.446, Speaker A: So we are integrated to Eigen layer. We'll dive deeper into this part on the second part. But the idea is this, right? We want to extend confidentiality to existing l ones and l two s. The idea is you could build an application, let's say on avalanche or base, and just store the hidden confidential states on ego. Kind of like an extension. So the way we provide this is through three means, basically one is through IBC because we are cosmos based. The other way is through a native bridging that we can also share more information down the line.
00:04:39.446 - 00:05:15.780, Speaker A: And the lastly is through an external bridging. So hyperlane wormhole layer zero. So we think we can log quite a bit of novel use cases, especially around gaming, deFi, enterprise and some other tools in gaming. The reason why we think we can be game changing is because today all the games are basically very simplistic because you cannot hide any information, right? If you cannot hide information, there's no challenge. So for us, we can unlock novel game mechanics like bluffing. You can sabotage, you can spy, you can conceal resources. These are the actual game mechanics that makes a game fun.
00:05:15.780 - 00:06:00.926, Speaker A: In DFI, we simply can enable novel primitives like dart pools, blind auctions, private amms, enterprise payroll. We think confidential payment could also be very impactful because today, if you were to pay employees in stablecoin, it's all public, right? And this is a known bad practice in web two already, you shouldn't be sharing everyone's salary within a company. So for us, when you do an ERC 20 transfer, you're just hiding the amounts being transferred and not the recipient and the sender. So we think it's also a little bit more traceable and likely to be more compliant. And then other use cases include private voting, also real time predictions. We can all predict the price of bitcoin in a hidden manner, but still compute the average using fhe. This is just an example of the game that we built.
00:06:00.926 - 00:06:32.098, Speaker A: It's a fully on chain mafia game where you could be the doctor killer or the detective. It's just an un eight role within a struct. And we also generate this fully on chain. So this is just a really good example of a novel experience you could have on chain. We can also build fun speculative games because we have the onchain randomness. And again here, the randomness, because it's hidden by defaults. It's a little bit more novel because if you were to use, let's say, something like Chainlink, that randomness is actually in plain text.
00:06:32.098 - 00:07:03.794, Speaker A: So you wouldn't be able to build a game like poker, for example. And the way the randomness is generated is actually based on FHG. So in the public key of the FHE, there's entropy that's hidden at the genesis. And every block you can generate more hidden values based on this initial entropy, essentially. And so the way we extend confidentiality to existing projects is, like I said earlier, so you could build your game on, let's say, base Polygon. Just store the hidden values on Inko, kind of like as an extension. And.
00:07:03.794 - 00:07:06.580, Speaker A: Yeah, on the second part, I'll let amore take over.
00:07:07.030 - 00:07:38.398, Speaker B: Yeah. So Remy explained pretty well what Inko is. I'm going to tap into more. Why do we need Eigen? Why did we decide to integrate with Eigen? So, as Remy said, we're l one. We're built on Cosmos SDK and the first reason is that for Cosmos SDK chains and new l ones, it's pretty hard to bootstrap liquidity and security. The token value is pretty low. The token might be volatile at the beginning, so using Eigen would provide the first very important part, which is a sustainable economic model for security.
00:07:38.398 - 00:08:16.854, Speaker B: We have at least a baseline of e security on our inco chain. So that's the first part. The second part, on top of the security, is to reduce the emission rates of our inco tokens. So we're talking about your dual tokens on our chain, where we have our inco native token, and also the east token, where if we only had inco. The way current Cosmos chains work is that they offer very high apys. We're talking like 30, 50%, even more, just to motivate and incentivize people and stakers to come on our chain. If we have ETh from Eigen layer, then we can have a more healthy apy for the inco token and all the rewards.
00:08:16.854 - 00:09:16.714, Speaker B: And the third one is that we really want to enhance Ethereum natively by offering this native confidentiality to Ethereum. And everything that goes back to Ethereum will be safeguarded again by the operators leveraging Eth. So we were at that point where, okay, we want to use ETH. We had an open slate on how we could integrate Eigen EtH on an encode chain on a comet BFT, which is a cosmos SDK chain. How can we do that? So at that point, it was really like at the beginning of our exploration, there was a lot of research going on. And following the block from Eigen layer from November of last year, we tried to direct our research into four avenues, the modular, the finality, the native door staking, and finally, using ethos, who's going to present right after us. So I'm going to quickly go through the four of them just to see the pros and cons and which one we're still exploring.
00:09:16.714 - 00:10:11.710, Speaker B: So the first one is the modular staking. So here we'll have the white little dots which represent ETH validators. So the Eigen operators, they are ETH backed, so they have e security, they bring EC security, and then the blue ones are the validators that bring inco security. With inco tokens, oftentimes we can have the same validator, say, like course one running both of them, but it might be easier to think of them as separate validators. And for the modular dust taking, it's like at each production of the block, we only accept the block if both inco and ETH quorum are attained. So it's kind of like an independent one, where the block would be accepted if both separate quorums agree on them. So that's a pretty good pro, because each block that's produced will also be backed by both securities.
00:10:11.710 - 00:11:08.270, Speaker B: And then we were thinking to see that the big con is that, what if they disagree? We kind of maybe need a third kind of meta consensus that say, okay, if those two quorums disagree, who should we listen to? Do we discard the block or what do we do? So this third meta consensus was kind of hard. And this is the reason we actually didn't continue exploring the modular dual staking. The second one is the finality dual staking. This is maybe a bit easier to understand, because Comet BFT, it's a consensus mechanism that produces blocks every 5 seconds. Once it's produced, it's finalized, there's no reworks allowed. It's there. So what we're thinking is that we take this finalization from Comet BFT, which is backed by Inco, but we add another finality gadget on top of the cometbft consensus.
00:11:08.270 - 00:12:02.894, Speaker B: And that finality gadget would be backed by the Eigen operators and backed by ETH security. So it's somehow like the chain will go on, and then the ETH operators will put a stamp of approval to each of the blocks that they agree on. So this is also pretty good in terms of security, because all the blocks that are produced are also approved by ETH. But the con is that we kind of need to fork comet BFD in ways that are not compatible with the other ecosystem to especially allow reors. Because if the ETH quorum doesn't agree on a block, then the comet consensus needs to revert back a couple of blocks to go back to the last finalized block and propose some other chain. And for this big reason, we actually didn't also continue exploring the finality door staking, thinking I didn't suit the cosmos model. And the third one that we're experiencing is called native door staking.
00:12:02.894 - 00:12:30.674, Speaker B: So, native door staking, we have our inco validators who will directly interact with the Eigen contract. They will listen to the eigen operators voting powers. Take that info and put it natively inside the. We have like on the inco side, we have two stake tables and want to merge them. We want to aggregate them with some kind of function. This function could be based on price. It's basically the price of the ETH, plus the price of Inco.
00:12:30.674 - 00:13:09.734, Speaker B: Or we can think about some other weighted mechanism to aggregate these two voting powers. So then each block that's produced with this model will have basically as voting power, the aggregation of those. And this also works. And this is something we're still exploring because it's pretty promising. And then the fourth one, it's using replicated or mesh security using a project called ethos, who will present right after us. So ethos, they're interfacing with Eigen layer and providing the Eigen operators and us. From an inko perspective, what we can do is use something called IBC.
00:13:09.734 - 00:13:51.620, Speaker B: IBC, it's a bridge technology that's cheap, fast, well better tested. In terms of bridge, it's pretty secure, like kind of the gold standard of bridging. So if we can have this easy IBC connection with ethos, maybe we can have a lot of info from migrant operators inside Inco using IBC. So that's also something we're exploring. And then this final slide, just summarize a bit of the trade offs. I won't go too much into details, but just to give you an idea what we're know, do we have a dual token model using mesh security? We might not. And replicated we might.
00:13:51.620 - 00:14:19.950, Speaker B: So these maybe are details that ethos will go more into, like slashing implementation costs. How difficult is it to recruit ETH security? How difficult would be down the line to scale our number of validators from ten to 20 to 50? These are all the questions we're thinking. We're trying to find the different trade off points. I think these three avenues are pretty promising. I'm pretty excited to continue exploring and to see how we can integrate a fagan.
00:14:23.110 - 00:14:38.142, Speaker A: Lastly, yeah, if you want to find more information about Inco, here are details. But yeah, thank you for having us. I guess questions or doing questions or.
00:14:38.296 - 00:14:43.030, Speaker C: Are there any comparison data between fhe and ZKML?
00:14:45.930 - 00:15:15.140, Speaker A: Zkml. I would say fhe here is more focused on confidentiality. Specifically with ZKE, you can do some privacy. You can also do a lot of scaling, also do Zkml. I think fundamentally here, fhe solves one problem really well, which is confidentiality. And the way we see this, the reason why fhe is very well suited for blockchain is you can have encrypted state on chain and do state transition directly on chain in a verifiable manner. Right.
00:15:15.140 - 00:15:49.274, Speaker A: So we actually think the reason why blockchains today, the public blockchains have transparent states. It's more of a bug because what you need in blockchain is the ability to verify computational integrity. Right. But now we have Fhe, which is another cryptography that actually does have computational integrity. So you can actually use fhe as the confidential layer for. Yeah. How does fhe compare to ZK technology provides use cases? Yeah.
00:15:49.274 - 00:16:18.054, Speaker A: I think the biggest thing between FHe and ZK for confidentiality is really on the idea of composability. Right. So with ZK, everything happens off chain from the data you're trying to hide to the circuits to approver. So what if you want to build an application that involves multiple parties? If everyone's hiding their own data, how do you compose? Right. The answer is you need some kind of prover that collects everyone's hidden information over plain text. Because ZK cannot do state transition over encrypted data. It has to be over in plain text.
00:16:18.054 - 00:16:35.160, Speaker A: That itself could leak information if that prover is not trusted. Right. Fhe here, because it is meant to compose, the blockchain, can act as the shared private state or the shared layer and directly do state transition. So I think that's the major difference.
00:16:38.250 - 00:16:40.540, Speaker C: Thank you. And then we are going have our final.
