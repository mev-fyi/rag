00:00:01.050 - 00:01:10.430, Speaker A: My name is Shumo, I'm founder of Nibra ZKP and today I'm going to talk about us, of course, but the vision here is that we're actually building a shared statement layer short for SSL for the future Internet. So a little bit background, right? I think at least we think, I think most people in the room maybe think the blockchain l one has been converged, right? So I think after the ten years we finally build decentralized and censorship resistant ledger and it support coded which means touring complete settlement. I think this is Ethereum, right? I think there are many, many aspects of a system can work. For example, you cannot just compare speed with one ledger to another. For example, ethereum has six different kind of client, which means there is one single client goes wrong and the others can back up. Right? We finally have done that. There are still some major improvements in the layer one, but it's pretty much settled.
00:01:10.430 - 00:02:02.206, Speaker A: And the question to ask here is what's next? And there are just like many people thinking hey, we're going to building L2s, layer threes, layer fours and maybe we're going to build like Nair infinity, right? Is that the way we're going to building things? We don't know but it seems that. So this is a picture from the north meath, the ygg dreffel, the word tree, right? So I think ethereum is going to be the rune layer of the word tree. But what's next? But we know that there's one thing certain. I do think the proofs are going to power the next ten years like development of ethereum centric blockchains. So for example, we have many kind of proofs. We have proofs to settle like to scale for example Scroll, Zksync, polygon, ninja. We have the privacy preserving proofs.
00:02:02.206 - 00:02:36.400, Speaker A: For example Summerfor, Macy, Aztec and Wordcoin. We recently just started a collaboration with Wordcoin. I guess maybe a few people know about them. I mean many people know about them but maybe very few people actually know Z actually settle like 1 million proof per month. And probably the biggest proof settlement ever happens in Ethereum ecosystem. And then we have different kind of oracles and other people call it coprocessors. I'm not going to get a name word here, but that's my slide so I call it whatever I want.
00:02:36.400 - 00:03:46.274, Speaker A: For example like ZkP two, P Brevis and Lagrange, right? So I think a big problems here is that the cost of verifying single proof is very high. So I have to update the slides every single time I talk for two reasons. First, east price goes up, and second, the network getting more congested. So the gas fee also spiked, right? So for example, today, roughly, if you want to verify gross 18 proofs, you need about like $22.5. And if you want to verify a halo two KgG proof, you need like $36. And if you verify a stark proof, costs you more than $100. So this is what Vitalik feminine said, right? Do I want to pay $20 to add privacy for my transactions to buy coffee? Probably just use as a gimmick, but so think about how much the coffee, right? I know here we're in Colorado, right? The most expensive coffee I've bought is actually in Colorado.
00:03:46.274 - 00:04:14.030, Speaker A: It's in Aston. It's like $25 a single espresso. That's insane. And to make it worse, it's kind of mediocre. Yeah, I think very few people want to pay $20 to adding privacy or doing whatever zk things you are doing. So that's why we're here, right? So a simple first, how we're going to making zk cheaper on chain. And the answer here is using ZK.
00:04:14.030 - 00:05:03.922, Speaker A: Basically we're using zk itself to make zk cheaper. So first I'm going to talk about the core technology component we're building called Nibar UPA, which short for the universal proof aggregator. And this is like a high level overview of Nibarupa. The very, very high level idea here is that we take multiple proofs and we call universal here because these proofs can come in from different circuits. So for example, some can be zkdid, some can be zk EVM, some can be brevis proofs, whatever. And we can aggregate multiple proofs into a single proof and put the single aggregated proof on chain. So as a result, the VK verification cost getting amortized.
00:05:03.922 - 00:05:52.426, Speaker A: So our current number here is that we can down the proof cost to 40K in terms of gas fees from like two hundred K. And as we develop better and better, like zk technologies, and also with potential hardware acceleration, the cost can be even cheaper with a larger batch size. So here is kind of a very simplified protocol. How does NIBAR works? Right, so we first have an onchain component, which means it's actually extremely easy to use us. You just need to send your proofs to our smart contract. And then we're going to deploy all the major L1 and L two EVMs, and some potentially non EVMs like Starknet. So then once we receive your proofs.
00:05:52.426 - 00:06:27.438, Speaker A: Your proof is going to send a distributed proving network. So we have a coordinators and then we have distributed provers and powered by GPU machines. There are three major characteristics of this protocol. The first is permissionless, which means we're not a SaaS company and we basically are protocol. And you can send your proof to us and then we aggregate the proof and then you get notification and you pay your fees on chain. And second is censorship resistance. So we have a very very similar design to L two s, kind of like similar to false inclusion, if you are familiar with the L two land.
00:06:27.438 - 00:07:46.598, Speaker A: And then third is that we are going to be progressively decentralizable, which means first we are going to run kind of like a semi centralized but distributed approver, also very similar to the state of art of Altus. And then we're going to have run a decentralized approving networks in the next step. That's about the protocol, right? Then the next question is how are you going to use us again? Like I leaked before, it's very very simple. On the left hand side is how you are going to verify approved. Today on Ethereum, you deploy your ZK contract, right? And also you deploy a verifier contract. Normally people name that a verifier, so, and it contains the cost to the EVM precompile of the pairing, the BN 256 pairing precompile, and now switching using Nibra, you just call us, right? So we have a fixed deployment address on different chains and you just remember our address, call our smart contract and then that's it, right? So I will show you the links to register our workshop at East Denver. So we're going to do a real time demo and also you can actually use our testnet in our workshop.
00:07:46.598 - 00:08:47.682, Speaker A: And if you actually send the first ZK transactions on us, you will get a little bit surprised with a lice gift. But that's it, right? Really nothing to say. And let me give you a little bit like technical overview here, right? So NibAR protocol is going to be progressively being built. The test network launching right now is called NibaR UPA V one. So it actually using like a two plus layers recursion using Halo two KZG, right? And because we have a lot of in house cryptographers and mathematicians, we're actually using the chinese remainder theorem based field simulation with lookup. So don't scared by the terms, but as a result we have the best non native arithmetic performance over the industry, actually better than PSEs and axioms. And then under hood we're running a pipeline and distributed proving serving architecture.
00:08:47.682 - 00:09:17.526, Speaker A: So there are two keywords here, right? First, distributed, which means we can have multiple GPU workers. Actually, we can spawn any number of GPU workers. And the second keyword is pipeline. Pipeline basic means the proof batches are overlapping each other. So this is try to increase the throughput and lower latency. And each single ones are using like, GPU acceleration. So I guess a little sneak peek to Nibra Upa v.
00:09:17.526 - 00:09:44.554, Speaker A: .2. What we're going to build next is a proof aggregation va. Right. The biggest theme here is that we're going to support multiple proof systems. And there are some key technical permit we're going to use. First is the cyclical curves for even less, like non native arithmetics mix. Right? So this is very similar to, I guess, Aztec's goblin plunk design, but we have different requirements.
00:09:44.554 - 00:10:18.970, Speaker A: We design in a slightly different way. And also we're going to have more efficient polynomial commitment schemes to design, to optimize the recursion overhead, and also more efficient lookups. And we are going to review more things about 2.0 later. So my analogy here is that Nibar UPA is a very, very powerful technology, right? So I'm a spacefy spacefund. So my analogy here is that we just build a Raptor engine, right? A very, very powerful rocket engine. But that's not a whole story.
00:10:18.970 - 00:11:26.510, Speaker A: We need to build a rocket. So where is the rocket? Basically, if you're using Nibra UPA's analogy of the Raptor engine, the Nibra SL is a rocket, right? So now I will show you the rocket. So I think what Nibra UPA actually enabled is what we call shared settlement layer. Like, what is this? So let's first look at the problems, right? So despite l two s are great, l two s are great because it actually reduce the friction and fragmentations of the entire blockchain space. So everyone doesn't have to build yet another alternative l ones to kind of building these independent kingdoms and is really insecure to talk to each other. But l two is great just to a certain extent, right? The biggest problems here is that if you look at this table, right? So I just did a little bit like categorization here, right? So l two is great. If you are moving l one native asset from l one to l two, in any other cases, there are still a lot of security issues.
00:11:26.510 - 00:12:13.038, Speaker A: Right? Now, for example, if you're moving l one native asset from l one back to l two, it's usually very slow, or you have some secure risk and things getting worse if you are moving l two native asset from between different l two s, right? So this is a big problem. Basically we think we can come and solve these silo problems of l two blockchains. And this is actually we're not coming up with this concept first. Right. I think Vitali has famous coming with this idea called proof singularity for a while. Right. The basic idea here is that you should use proof aggregation to gapping the silos between different l two s.
00:12:13.038 - 00:13:25.810, Speaker A: And let me talk a little bit about how exactly we're going to do here. Right? So what we're actually building here, we call it co sediment. Basically the idea here is that one single proof multiple sediment. So the high level idea here is that you have a validity proof from different L2s or layer threes, whatever, right? So we are going to aggregate these proofs into a single nibrate UPA aggregator proof. And also we bring this proof settlement to multiple places, for example like polygons. Gross darknet and me, maybe I can talk about a little bit detail here, right? So the automated reason we can do that is that there is no upper bound of how many proofs you can aggregate in a single proof. It's purely a matter of hardware acceleration and how much latency you tolerate, right? So the better the ZKP technology going, which is still going very fast, the better hardware and giving a fixed latency you can aggregate more proofs.
00:13:25.810 - 00:14:18.370, Speaker A: Right. And then after we have the aggregated proofs on each single places, for example, score, you can do a selectively opening of these proofs which means you can only open the portion of proof you care. And because that's extremely efficient because a single proof is very, very small. Right. And what this really brings is we call it async composability carried by proof to the entire blockchain space. And so this is still kind of in the early resource stage but we are actually committed to building this like a shared settlement layer to the entire space. And I think if you want to hear about more about Nibra, first about the technical details and second about our testnet and API interface and please come to these two events.
00:14:18.370 - 00:14:56.478, Speaker A: So we have an event tomorrow colocated with the d infra summit. So there are NIBA workshop and I know they are closed registration because of Foo, but if you say hey, refer by Nibra, you'll get a pass. And the second one is March 1, which is our proof singularity Denver. We are going to have a lot of stoked speakers. For example like Zach from Aztec, Robert, he's the co founder of Polkadot. And we're going to host a heated debate. Basically we're going to debate when you should use programmable cryptography and when you should use programmable trust or like Eigen layer Babylon style resaking.
00:14:56.478 - 00:15:20.778, Speaker A: Right. It's going to be very spicy, so please come. So I'll stop here for. Well, and last but not least, this is a team effort. This is our team. And please follow our team members on X if you want to listen to high quality cryptographic gigabring content. Follow our team members.
00:15:20.778 - 00:15:57.974, Speaker A: If you want shit post, follow me. Yeah, I think that's end of talk. Thank you. Any questions? What do you think of the Polygon AG layer? Because we are also talking about the aggregation layer as well as the silo problem between l two s. I think the AG layer is trying to bridge the silos but within the polygon ecosystem and we are more general. So basically I think, I guess didn't show in the details. Right.
00:15:57.974 - 00:16:50.950, Speaker A: So our scope is just much wider in several sense. First is that we're going to bridge across different ecosystem and secondly we're actually bridging between applications and infrastructures. For example, let's say you have a proof from Wordcoin, right? Wordcoin's proof can be co settled with a validity proof where that polygons doesn't support. And I guess thirdly, most importantly, if you go back to the co settlement designs, the polygon is just like have an aggregated proof set on Ethereum and we're doing the co settlement on every single chain that brings the interoperabilities between different chains. Right. So I think the proof aggregation technique we're using is despite there are like specific proof system differences, but from high level it's quite similar. And I guess the other thing here, we can talk about that.
00:16:50.950 - 00:17:20.798, Speaker A: We are production ready now and we actually run a little bit stress test our systems. I think last December we aggregated 1 million proofs, only takes like 36 hours, which give you about ten proof per second. And we actually burn like 3500 sepolia east to be able to run the experiment. Right. And I think our code audit is already start. So we'll be kind of a midnight soon. Yeah.
00:17:20.798 - 00:17:22.860, Speaker A: Great, thank you. Thanks.
