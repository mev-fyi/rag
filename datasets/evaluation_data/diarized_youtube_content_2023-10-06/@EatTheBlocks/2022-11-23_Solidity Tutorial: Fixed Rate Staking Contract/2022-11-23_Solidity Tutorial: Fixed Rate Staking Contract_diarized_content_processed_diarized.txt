00:00:00.730 - 00:00:27.922, Speaker A: The staking of tokens plays a massive part in the current DFI ecosystem. In this solidity tutorial, we're going to be going through how to build a fixed rate staking contract. This allow us to stake one token, our own token, and earn rewards on that at a fixed rate. For example, we'll be using one reward per token staked per year. So if you stake a token after six months, you earn zero, five rewards. My name is James Petuni, an honest channel. I create content about blockchain development and decentralized finance.
00:00:27.922 - 00:00:31.890, Speaker A: If you're interested in learning more, then subscribe to the channel and hit like button for the YouTube algorithm.
00:00:32.050 - 00:00:49.420, Speaker B: Hey, this is Julian. Just popping up here for a second this year has been rough, but it's never been better to comment a six figure job. The average salary of a blockchain developer is 120k. We have a very special Black Friday offer coming soon to teach you just that. Join the waitlist down below.
00:00:55.470 - 00:01:12.478, Speaker A: You. Okay, so I'm going to be working in remix here. This is at remix ethereum.org. Anyone can use this. If you go to that website, you'll be loaded to a page like this. You can go into the file section and we can go into contracts and create a new file. I'm going to create a new contract called fixtaking.
00:01:12.478 - 00:01:44.494, Speaker A: Sol is a solidity file extension and the first thing I'm going to do is paste in a fairly standard ERC 20 token. So we're using an identifier here for the MIT license and then a solidity compiler version above zero 8.15. That's a very latest version. And then we're using the open Zeppelin library for the ERC 20 standard token. We're then going to then create the contract which we're going to call fixed staking and give it a constructor function. A constructor function is something that runs just the first time you deploy the contract. It can't be run after that.
00:01:44.494 - 00:02:24.342, Speaker A: And we pass through a name for the token and a token ticker symbol and then we use the internal mint function which is an internal function within this contract library. And we are basically minting the person that deployed the contract with a whole load of tokens. So this is a bog standard ERC 20 token, which we can then expand on to create our staking functionality. The first thing we'll do is create a couple of mappings and these are for the amount of tokens staked. So this is going to be from an address to a Un two, five, six unsigned integer and then a mapping from address. Un two, five, six again. And this is going to be for a timestamp.
00:02:24.342 - 00:03:10.334, Speaker A: So it's going to be basically from when the user staked their tokens. Now let's go ahead and create a staking function and we're going to pass through an amount, so the amount of tokens staked. And then we've got a couple of required statements, these like sanity checks to make sure the amount is greater than zero and the user actually has a balance greater than the amount they're trying to stake. And then we're going to basically use the internal transfer function to transfer them funds from the sender to the contract address. This is quite a tidy way of doing it because it means that the user doesn't have to approve the transaction, do two transactions. They can do this within a single transaction using the internal function rather than the external transfer from. We then go ahead and update the staking.
00:03:10.334 - 00:03:38.882, Speaker A: So if the users already stake tokens, then they're going to claim them first. This makes sure that the rewards are up to date. And then we're going to update the staked timestamp. So it's going to log when the user staked their tokens and we're going to add the amount that they've staked to the mapping here, which is kind of the amount of tokens that they've got staked and they're owed. We then want an unstake function. This is going to be very similar. It's going to be an external function.
00:03:38.882 - 00:04:12.118, Speaker A: We're passing in an amount. Again, got a couple of similar sanities, checks where we need to make sure the amount is greater than zero and the staked message sender is greater than amount. So the amount that they're trying to unstake is greater or equal to the amount that they've staked already. And then we're going to claim any rewards and then update the staked variable before finally transferring out from the contract address to the message sender the amount that they're trying to unstake. All fairly straightforward so far. And the final thing we need to do is work on this claim function. This is running internally, but we want it to run externally as well.
00:04:12.118 - 00:04:43.634, Speaker A: So we're going to make this a public function and we're going to require that the staked amount is greater than zero. So the user actually does have some funds staked. Then we're going to work out the seconds that they stake them for. So we're going to take away the current block timestamp. This is the current time basically since all amount of seconds that have passed since January 1, 1970 from the time when we logged it. And then we're going to calculate the rewards. So to work out that, we're going to work out how much they staked multiplied by the second staked.
00:04:43.634 - 00:05:06.510, Speaker A: So basically if they staked one token for 1 second, then that will equal one. And then we're going to divide that by the number of seconds in a year. This 3.15 just means it's got seven decimals, so it's basically 31 million. This next line will probably be different from project to project. Here we're going to mint the same token. So the rewards token is same as the token at stake, so we're increasing the supply.
00:05:06.510 - 00:05:44.954, Speaker A: You could actually distribute a third party token via this method as well. If you had the contract owning that token, they could just transfer out the token as the staking rewards become due. And that is going to mint to the person that claimed the tokens the amount of rewards. And then finally we're going to update the state from timestamp to the current block timestamp so it can't be unstaked twice. Now this code is only for demonstration purposes. If you're going to put this into production environment, you probably want some kind of reenterest in your guard on this claim function, especially if the contract was more complex and you had other things going on at the same time. Let's go ahead and deploy this now.
00:05:44.954 - 00:06:07.060, Speaker A: If we go to compile, there's no issues. Let's go ahead and deploy this to a local vm running in a browser. Change it to fixed staking. This is fine. Let's deploy that. Expand this out. If we copy our contract address here.
00:06:07.060 - 00:07:06.962, Speaker A: So if we copy our user address here and then check our balance, we've got the initial amount of tokens that we sent ourselves. We can do all the common things we can do within an ERC 20 contract. For example, let's copy that address and then send them some tokens so we can do transfer and send them a load of tokens that's gone through. Then if we check the balance of that address, we should see they've got a smaller amount of tokens. Let's swap into that account now and let's try staking that amount so that's gone through. If we give it a few seconds and then we claim the rewards and we check our balance again, you can see our balance has decreased. This is because we've actually transferred our original tokens to the staking contracts we don't have them anymore, we've only got the ones that we've claimed the rewards.
00:07:06.962 - 00:07:44.878, Speaker A: So if we now go ahead and unstake the original amount we can check balance of you can see that's gone up again. So we've got the original tokens plus all the rewards we've previously claimed plus the new rewards. And from a tokenomics perspective this would be quite interesting because it encourages people to stake and lock up their tokens. You could quite easily put a vesting period within this so users have to lock their tokens for amount of time or expand it a load of different ways which is so common within DeFi protocols today. Hope you found this solidity tutorial useful. There's more information in the blog post linked in the description. The full code is in there as well.
00:07:44.878 - 00:07:51.580, Speaker A: If you want to learn more about blockchain development and decentralized finance and subscribe to our channel, please hit the like button to use your algorithm and thank you for watching.
