00:00:00.250 - 00:00:45.414, Speaker A: Hey, this is julian and you are on idoblogs. And in this video I'm going to show you how you can create smart contract from a smart contract. So a typical scenario is when you have a factory contract that creates some child smart contract. So in the example here, so we have a system to create loan on the blockchain. So you have a factory to create loan and each loan itself is represented by another smart contract. And the reason why you would want to do this is you want to isolate the risk. So by splitting the code into different smart contract, if there is a security vulnerability in the factory contract, then it's less likely to affect all the individual loan contract that were created.
00:00:45.414 - 00:01:23.314, Speaker A: Also, it's a good way to split the responsibility of the different contract instead of putting everything in a single smart contract. So first I will show you how you can create a child contract from a smart contract. Then we'll see how we can store the address of the child contract. Then we'll see how we can cast a contract pointer to an address. Then we'll see how we can call the function of the child smart contract that we created. And finally, I'll show you a caveat to be aware when the admin of a child contract is itself a contract. All right, so let's start by the beginning so how we can create a child contract.
00:01:23.314 - 00:01:50.538, Speaker A: So here we have a factory contract that create loan smart contract. And this is done inside this create loan function. First we need to declare a pointer to a loan contract. So this is going to be a pointer of type loan. So here this work because we define the contract loan in the same file, but otherwise you need to import this. I show you this in a previous video of this series already. Then we give the name of the pointer so loan.
00:01:50.538 - 00:02:37.290, Speaker A: Then we use the new keyword. So that's how you actually create a new contract. Then we use the loan uppercase this time, and between parentheses we give argument to the constructor of the loan contract, if there is any. So in this case we're going to give 100, for example. And with this you deploy a new loan smart contract and you'll be able to manipulate this contract with this loan variable. So after you've created a new smart contract, you need to store a reference to this new contract because otherwise after you finish to execute this create loan function, then the address of this new contract is just lost in the blockchain and we can't interact with it anymore. So it's not very useful.
00:02:37.290 - 00:03:13.942, Speaker A: So you might think that we could do something like returning the address of this new loan smart contract. But if we want to use the return keyword then our function need to be of type view. However, we cannot create new smart contract inside view function because new smart contract modify the blockchain. And every time you modify the blockchain you need to use a transaction. And transaction are not compatible with view function. So here we cannot have this view keyword. So also we cannot return the address of the new smart contract.
00:03:13.942 - 00:03:59.030, Speaker A: So how are we going to do? Well, we need to store the address of this new smart contract inside our loan factory here. And actually we probably call this create loan function a couple of times. So we will create an array of pointer to loan smart contract. So above our create loan function we create an array of loan pointer and we call this loans. And inside our create loan function then we're going to push to this array. So we push the new loan. And this way after we finish to execute the create loan function, we can still access pointer to all this loan smart contract by using our array here.
00:03:59.030 - 00:04:44.802, Speaker A: So actually if you don't need to interact with this loan smart contract from the loan factory contract, but you just want to store the address instead of storing pointer, what you could do instead is to cast this loan pointer to an address by using this notation. So address of loan and this is going to convert this into an address. So next I'd like to show you how we can call the function of our child smart contract. So here with the loan variable we have a pointer to our new smart contract. So in previous video I already showed you how we can call a function of a smart contract from a smart contract. Well, in this case, this is exactly the same thing. This loan variable is a pointer to this contract.
00:04:44.802 - 00:05:23.982, Speaker A: So we only have to use the dot notation to call all its function. So for example, if we have a function that, let's say we call it reimburse, so that's the end of the loan. Then if this function exists, then we can access this here reimburse. And if we have any argument we'll pass it here. And that's how we can call a function of our loan from our loan factory. All right. And lastly, I'd like to tell you a bit about a caveat that can happen when you create a smart contract from a smart contract.
00:05:23.982 - 00:06:18.754, Speaker A: So let's say that in our loan smart contract we have an admin mechanism. So inside the constructor function we're going to set the admin of the smart contract to the sender of the transaction that create the smart contract. So here we create a variable of type admin. And let's say that we have a sort of security function, for example, withdraw, that can be called only by an admin. And inside we can withdraw the ether. And so who will be the admin here? Well, the admin will be the loan factory. But in your loan factory, if you don't create a function to specifically call the withdraw function of your loan.
00:06:18.754 - 00:07:05.570, Speaker A: So like loan withdraw, if you don't create this function here, then the reservoir function of your loan smart contract will be locked forever because the admin is a smart contract, but it's not a regular address, so you cannot call it directly. So keep this caveat in mind when you create a smart contract from a smart contract. And there is an admin mechanism. By the way, I created a free email course to teach you how I got my first remote blockchain job, paid $100,000 a year. So if you want to learn all my secrets, you just have to sign up at this URL. All right, that's it for this video. In the next video, I'll show you what are the error handling mechanism in solidity with required revert, et cetera.
00:07:05.570 - 00:07:07.540, Speaker A: Thanks for watching. See you for the next video.
