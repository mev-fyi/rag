00:00:00.250 - 00:00:34.082, Speaker A: Let's learn about bitwise operators available in solidity. We'll go over the basics of and or xor, not shift left and shift right. Let's start with and the and operator takes two numbers. In binary notation, these two numbers will be a sequence of zeros and ones. The output is also a number, a sequence of zeros and ones, where it is a one if both the inputs are one and zero. Otherwise, let's take a look at an example. For example, let's say that x is equal to 14 and y is equal to eleven.
00:00:34.082 - 00:01:08.050, Speaker A: In binary representation, we can represent x as one 10. This is equal to eight plus four plus two plus zero, which is equal to 14. Likewise for y, y can be represented as 1011. Now, the bitwise and operator looks at each bit for the inputs and returns a one if both of them are one. Otherwise it returns a zero. So for example, the leftmost bit for x and y are both one, so this will return a one. Next we have one and zero, so the result will be a zero.
00:01:08.050 - 00:01:44.110, Speaker A: Next we have one and one, so that will be a one. And last we have zero and one, so the result will be a zero. This is equal to eight plus zero plus two plus zero, so this will be equal to a ten. In solidity, we can write this and operator as return x and Y. So that is the bitwise and operator. Let's move on to the or operator. In the and operator, we took two numbers and for each bits we returned a one if both the bits were one and it returned zero.
00:01:44.110 - 00:02:14.918, Speaker A: Otherwise for the or operator it will return a one if either of the bit is a one. Let's take a look at an example. For example, let's say x is equal to twelve and y is equal to nine. We can write twelve as 1100 and we can write nine as 1001. So what would be the result of x or Y? We said that or returns a one if either of the bit is a one. So for example, starting with the left, we have a one and a one. So we turn a one.
00:02:14.918 - 00:02:49.810, Speaker A: For the next bit we have a one and a zero. The or operator returns a one if either of the bit is a one. So here we return a one. In the next position we have a zero and a zero, so this will return a zero. And for the last bit we have a zero and a one. So the or operator will return a one and this will be equal to eight plus four plus zero plus one, and this is equal to 13. In solidity, the or operator is a vertical pipe, so for example, we'll say return x or y.
00:02:49.810 - 00:03:23.002, Speaker A: So that's the or operator. Let's move on and talk about the Xor operator exclusive. Or the Xor operator returns a one only if one of the bit is equal to a one. So if either the first bit is a one and the second bit is a zero, or the other way around, the first bit is a zero and the second bit is a one, then it will return a one. Otherwise it will return a zero. This is unlike the or operator where it returns a one if either the first bit or the second bit is a one. Let's take a look at an example.
00:03:23.002 - 00:03:49.334, Speaker A: For example, let's say that the first input x is a twelve and the second input y is a 512. We can write it as 1100 and five. We can write it as what is xxor y? X. Xor y is equal to. The Xor operator returns a one only if one of the bit is equal to a one. Starting from the left, we have a one and a zero. So the Xor of one and zero is a one.
00:03:49.334 - 00:04:18.654, Speaker A: Next we have a one and a one. Xor returns a one only if one of the bit is a one. In this case we have both of them being a one. So this will return a zero. The next bit is a zero and a zero, so it will return a zero. And lastly, the last bit is zero and a one. So the xor returns a one and this is equal to eight plus zero plus zero plus one, which is equal to nine.
00:04:18.654 - 00:04:41.846, Speaker A: In solidity we will use this character for the XO operator. So I'll type return X this weird symbol y. Okay, let's move on and talk about the not operator. This is a simple operator. It flips the bits. So if the bit is a one, then it turns it into a zero. And if it was a zero, then it turns it into a one.
00:04:41.846 - 00:05:31.154, Speaker A: For example, let's say that X is equal to twelve and we'll represent this as eight bits. So here we have a sequence of eight zeros and ones. Using the not operator, we will flip a zero to a one and one to a zero. So this will be eleven 110011 and this will be equal to 128 plus 64 plus 32 plus 16 plus zero plus zero plus two plus one. And using my calculator, this is equal to 243. In solidity we can use the not operator by typing return tilde x. Okay, next let's talk about shift left and shift right operator.
00:05:31.154 - 00:06:10.514, Speaker A: And we'll start with shift left. The shift operators shifts the bit either to the left or to the right. For example, if we shift 10 times, then this is one. We shift it to the left zero times, so it will still be equal to one. If we shift one one time to the left, then the resulting number will be moving this one once over to the left. So the resulting number is and this is equal to two. Likewise, if we shift one over to the left twice, then the resulting number is 0100 and this is equal to four.
00:06:10.514 - 00:06:58.158, Speaker A: Likewise, if we shift one three times, then we get eight. How about if we shift three to the left two times? What does this equal to? Well, first let's write three in binary notation. In binary notation, this will be equal to eleven and we are going to shift the bits twice to the left. So we're moving these two numbers eleven to the left twice. So this will be 1100 and this is equal to eight plus 412. To use the shift left operator in solidity, we will put this arrow looking thing so say return x less than less than bits. Okay, let's move on and talk about shift right operator.
00:06:58.158 - 00:07:27.066, Speaker A: The shift left operator moves the bits to the left. On the other hand, the shift right operator moves the bits to the right. Let's take a look at some simple examples. Starting from rate. If we do zero shift rights, then we're not moving any bits to the right, so the resulting number is an eight. If we do a shift right one time, then we are moving this one over to the right once. So the resulting number is and it is equal to four.
00:07:27.066 - 00:08:09.318, Speaker A: Likewise starting from eight, if we do a shift right twice, then we're moving the one twice to the right. So the resulting number is and this is equal to a two. If we do it three times, then the resulting number is and this is equal to a one. How about starting from a we do a shift right four times. We'll notice that if we do a shift right three times, then we get one. So if we do it one more time, then this one will disappear and the resulting number is equal to zero. To use this operator in solidity, we would use the greater than greater than character.
00:08:09.318 - 00:08:43.938, Speaker A: So for example, type return X greater than greater than bits. Let's compile this contract, then go through these examples. I'll hit Ctrl s to compile a contract and then deploy on remix. So hit deploy, scroll down and then open the contract. Let's start with and so if we do 14 and eleven, we should get a ten back. So here I'll type 14 and ten and then hit and we get a ten back. Okay, let's move on and try the or example for twelve and nine.
00:08:43.938 - 00:09:04.550, Speaker A: So here I'll type twelve and nine for the or and then click on or and it returns a 13 as expected. Xor. I'll put in a twelve and a five. Xor, put a twelve and a five and it should return a nine back. And it does. Okay, moving on. Let's try not operator.
00:09:04.550 - 00:09:44.806, Speaker A: Now notice that here I put in a un eight, because if we were to use un 256 and we put in a small number for x, when we flip the bits, it will be a very large number. So that is why I'm using un eight here, to keep the example small. So for the example of not what number did we put? We put in twelve and we should get back 243. Put in twelve and we get 243 back. Okay, let's move on. What is the next example? The next example will be shift left. For this example, we'll put in three and then shift it left two times.
00:09:44.806 - 00:10:24.290, Speaker A: So shift left three twice, shift left and we get a twelve back. Okay, moving on. For the shift right example, I'll put in twelve and one, and we should get back a six. So shift right twelve one and we get back a six. Okay, so that was a simple example of bitwise operators available in solidity. Now, as a challenge for you, using the bitwise operators, implement the function get vast n bits. This function will take in two inputs, un x and un n, and it would return the last n bits from x.
00:10:24.290 - 00:10:56.126, Speaker A: For example, if x is equal to 1101 in binary notation, and let's say n is equal to three, then this function will return the last three bits. So it will return 10 one and the output will be 0101. This is in binary notation. So when it returns, it will return a number. Pause the video here to think about this problem. And in a few moments I'll go over the answer. Okay, let's now go over the answer.
00:10:56.126 - 00:11:32.918, Speaker A: The bitwise operators that we will be using is shift left and the and operator what we'll do is create n ones. For example, if n is equal to three, then we'll create three ones and then use the and operator to return the last n bits. For example, let's say x is equal to 1101 and we want to return the last three bits. The first thing that we'll do is create a sequence of three ones. I'll name this mask. So this will be equal to zero, one one. Next, we'll do an and operation on x and mask to return the last three bits.
00:11:32.918 - 00:12:09.974, Speaker A: So x and mask, this will be equal to one, and zero is equal to zero. One and one is equal to 10, and one is equal to zero. And one and one is equal to one. And notice that we have returned the last three bits from the input X. Let's write this in solidity. Un mask is equal to how will we create a sequence of ones? Well, the trick here is to shift one n times and then minus one. Shift one n times and then minus one.
00:12:09.974 - 00:12:40.846, Speaker A: This will create a sequence of ones. Let me show you an example with n equals three. So if we shift one three times, then this will be equal to one. Shift it once, then will be 10, shift it twice, then will be equal to 10 zero, and shift it three times. It will be equal to 10 zero. And then from this we do minus one. If we minus one, the first bit will be a zero, and the rest of the bits will be a one.
00:12:40.846 - 00:13:25.386, Speaker A: So we have three ones, and that is how we create a mask, a sequence of n ones. Okay, once we have a mask, we can return x and mask to return the last m bit. So I'll type return X and mask, and that is how you return the last m bits. Okay, let's compile a contract and look at an example. So I'll hit ctrl s and then we'll deploy this contract again. So I'll clear the old one and then deploy the new one, open the contract, and then we'll go over this example. 1101 is equal to 13, so 13, and we want to return the last three bits.
00:13:25.386 - 00:13:59.890, Speaker A: So I'll put in three, then get bast m bits. The output should be equal to five, and we get a five back. Now, as a bonus, there's another way to return the last ten bits using the mod operator. So let's take a look. Now, I won't go deep into the math, but the way we would do it is take x mod two to the n bits. For example, return x mod two to the n. Now, two to the n is the same as shifting one n times.
00:13:59.890 - 00:14:27.340, Speaker A: So here we'll use the shift left operator. And to show you this example, I'll compile the contract and redeploy this contract. Clear the old one, deploy the new one, and then we'll call the function, get last embeds using mod. For the previous example we passed in 13, and for the bits we passed in three, and we got a five back. Let's see what we get back here. And we get the same answer. Five.
