00:00:00.170 - 00:00:33.410, Speaker A: 40 million USD. It's how much a blockchain developer made for one week of work. Not a bad holly rate, right? And this is not science fiction. I'm talking of Chef Nomi, the developer of Sushiswap. In order to make that kind of money, Chef Nomi had to create his own decentralized exchange by forking Uniswap. So forking a decentralized exchange like Uniswap can obviously pay off massively financially. And beside this, this is also a great starting point if you want to create your own decentralized exchange and add new features on top of Uniswap.
00:00:33.410 - 00:01:14.338, Speaker A: And going forward, a folking defi project is probably going to be a big trend. So it's really important to understand how it works. So in this video, I'm going to give you step by step instruction to fork Uniswap. You're gonna see how to copy and paste the code of Uniswap and deploy it on the blockchain. We're also gonna learn how we can do evampire Tyke by taking the liquidity of an exchange and bringing it to our own exchange. And before we continue, if you don't already know how Uniswap works, I recommend to first watch another of my video on my channel where I introduce Uniswap. If you don't know me, I'm Julian and on my channel, idoblocks, I teach D five blockchain development and how to find your first blockchain job.
00:01:14.338 - 00:01:54.330, Speaker A: And very briefly, quick mention to my two free training. First, if you want to learn how you can become a professional blockchain developer and make $100,000 a year, you'll find a free training below. Also, if you want to learn how you can make profitable flash loan, you'll find another free training. With software and blockchain, a fork can mean very different things. So let's clear this up. First, we have a blockchain fork, for example, when bitcoin cash forked off the main chain of bitcoin. So this happened because a part of the bitcoin community disagreed with the future evolution of the bitcoin protocol.
00:01:54.330 - 00:02:42.250, Speaker A: So a part of the bitcoin community decided to create their own version of the bitcoin software. So that means from a certain block in the futures, the miners of this new blockchain will run a different version of bitcoin called Bitcoin Cash. If you send a transaction created for bitcoin cash, it will only work in the branch of bitcoin cash. And same thing for the mention of bitcoin on Ethereum, we also had a fork when Ethereum classic and Ethereum decided to separate. You can also have folks in blockchain because of technical issues, but this is usually temporary and resolve itself pretty quickly. Another kind of fork in the world of software is when you fork a project on GitHub. So GitHub is a collaborative platform where developers work together to build software, including blockchain projects.
00:02:42.250 - 00:03:18.086, Speaker A: If you go on GitHub, each project is organized in what we call a repo. And for each repo it's possible to create a fork. When you create a fork on GitHub, it means you create a copy of the original repo on another repo that you control. This way you can make any modifications you want, create your own project independently of the original project. This is also the workflow that is used when you want to make a contribution to a project as an open source contributor. So this kind of fork is all about code, nothing about blockchain. And finally we have Defi forks, like when Sushiswap decided to fork uniswap.
00:03:18.086 - 00:03:56.774, Speaker A: So this happened when some people like an existing Defi project, but want to make some modification that are not accepted by the community of the original project. So in this case you say, all right, I'll just do my own version of your defi project. So in this case you need to do a couple of things. You need to copy paste the code of the original Defi project. Then you customize the spot contract and the front end. Then you deploy the modified spot contract and front end. The last step, if you want to bootstrap liquidity on your Defi project, you can create an incentive to steal some liquidity from the first Defi project.
00:03:56.774 - 00:04:35.358, Speaker A: And we will see how to do this later in this video. Okay, so now you understand the different kind of forks in software and blockchain. So next we are going to fork the smart contracts of Uniswap. The first smart contract we need is the factory. So this is used to create markets for different pairs like dither, USDC, ether, et cetera. This smart contract is located in the Uniswap V two core repo in the organization of Uniswap on GitHub. We could use the folk feature of GitHub, but this is mainly used for open source contribution.
00:04:35.358 - 00:05:19.966, Speaker A: In our case, we just need to copy this once, and after we'll have our own version. So it's more simple to just download this repo. If you don't have git installed, you can download the code by clicking here, but I prefer to use git, it's more clean. So I've created a folder for this project and inside I'm going to download the repo with the git clone command and I copy paste the URL of the repo on GitHub. Once you have the code locally, you can do your customization. So here we can go in the Uniswap V, two core folder contracts. And here you see the spot contract of Uniswap, including the factory.
00:05:19.966 - 00:05:51.630, Speaker A: So you probably at least want to change the name of the spot contract for your project. But for our tutorial we are going to keep things simple and we will not change the smart contract of Uniswap. So beside the factory contract, there is another contract that we need from Uniswap. It's the router. So with the router smart contract you can use the ecosystem of Uniswap more easily. So we're going in the organization of Uniswap and there is another repo called periphery. So that's the one that we need.
00:05:51.630 - 00:06:40.102, Speaker A: So I'm going to copy the URL back to my project folder and at the root I'm going to git clone this other repo. And in this other repo we also have a smart contract inside the contract directory. Okay, so we have forked the smart contract of Uniswap. The next step is to deploy them to the blockchain. If you look at the code we downloaded from GitHub, there is nothing to deploy the smart contracts. But because we are smart and lazy, like good programmers always are, we will not build a deployment system from scratch. We will use the deployment system of truffle, which is the most popular framework for writing solidity.
00:06:40.102 - 00:06:49.790, Speaker A: Smart contract truffle is written in node JS. So you need to install node js first. And after you need to install truffle with this command.
00:06:50.530 - 00:07:46.766, Speaker B: And after we create a new folder for the core smart contract of Uniswap. And inside we're going to initialize a new truffle project. So now we have these files inside and we are supposed to put all our smart contract in the contracts folder. So we are going to copy paste the spot contract of the core repo of Uniswap. So now if we check what we have in contracts, then we can see all the contracts of Uniswap. And after that we need to create a migration file to tell truffle how to deploy the spot contract of Uniswap. So for that we create new file here let's open this and as a template we can use what we have in the initial migration file.
00:07:46.766 - 00:08:20.330, Speaker B: So that's something that is used internally by truffle. So let's paste this in our new file. Then we need to change what we import here. So we import Uniswap v two factory sol. So we call this factory and here we deploy this factory. And we also need to give an argument to the constructor. So for that we can check out the constructor of the factory.
00:08:20.330 - 00:08:52.546, Speaker B: So here this is an address and that's the address that receive the payment for the trading fees. So we are going to choose the address used by the deployment. So here there is a parameter network that we're not going to use. But after there is an array of addresses that is available to us and by default the first one is going to be used for the deployment. So we pass this to the constructor.
00:08:52.658 - 00:09:39.794, Speaker A: So next we want to deploy a market so that people can trade on our fork of Uniswap. So for that first we need to have a reference to the factory contract. So we need to await this. And here we need to make this async so that we are able to use the await keyword. And after to have a reference to the factory we going to use factory deployed. So it's always a bit confusing that we have to do these two things to have a reference to a smart contract. That's because the first statement send the transaction for the deployment and the second statement wait for this transaction to be mined.
00:09:39.794 - 00:10:16.238, Speaker A: And finally we have our reference. And when we have this then we can execute function on the smart contract. So we want to execute create pair. So here it's going to take two arguments, the addresses of the two token of this market. So here we're going to have two cases. So if we are doing the deployment to main net, let's remove this underscore here. In this case the tokens will already be deployed.
00:10:16.238 - 00:10:27.240, Speaker A: So token one address equal something, token two address another one. So it depends of which market you want to create.
00:10:30.490 - 00:11:34.060, Speaker B: But if we are not deploying to main net, for example if we deploy to a local development blockchain with ganache, or if we deploy to a public testnet like Covid, in this case we will deploy ourselves the ES 20 token for this market. And for that we will need to create smart contracts. So let's go back to the command line and first at the root of the project we're going to initialize NPM project. So after we're going to install open Zeppelin, which is a very popular library for solidity, we're going to specify a specific version, because we're going to be using solidity 0.5 to be compatible with the smart contract of Uniswap. So we want version 2.5.1. And after we're going to create two smart contract token one, Sol token two.
00:11:34.060 - 00:12:26.454, Speaker B: All right, so now we're going to create these contracts. So for the version of solidity, we're going to use 0.5.16, which is the same used by Uniswap. And we're going to import a contract from open Zeppelin. We want ES 20 detail, and we also need another contract called ERC 20. And after we're going to inherit from these two contract, and we create a constructor, and we also trigger the constructor of ES 20 detailed. You're going to pass it three parameters.
00:12:26.454 - 00:13:16.060, Speaker B: First the name of the token, then the ticker, then the number of decimal. So if you check the code of open Zeppelin on the master branch, you will see the latest version of open Zeppelin, which is different than what I'm showing you here. So this is the old way of creating an s 20 token with Open Zeplink, and we're going to do the same thing for the other token. So let's copy this, let's open the other file for token two. Now we're just going to change here the argument. So token two, token two. All right, so now we're going to open the migration file and we're going to import this two token and token two.
00:13:16.060 - 00:13:57.666, Speaker B: So if we are not deploying to Mainnet, we're going to deploy these two tokens. Then we're going to get a reference to this token. And then we save the address. Token one, address, same for token two. We pass this to create pair. Okay, and we good for the deployment script. And we still need to change a configuration of truffle in Truffleconfig Js.
00:13:57.666 - 00:14:33.378, Speaker B: So we go at the bottom of the config and we're going to specify the correct version of solidity that is used by the smart contract of Uniswap 0.5.16. Okay, so now we will be able to deploy our contract. So going to exit this. So we are going to deploy to a local development blockchain on our computer. So that's the best when you are developing. And for that we're going to use a software called Ganache. So Ganache run an ethereum blockchain locally, totally isolated from main net.
00:14:33.378 - 00:14:35.486, Speaker B: So you can play around, make mistakes.
00:14:35.518 - 00:14:36.478, Speaker A: It doesn't matter at all.
00:14:36.504 - 00:15:11.230, Speaker B: And ganache also generates ten addresses prefunded with ten fake ether. So that's very convenient to send all your transactions. So in order to install ganache you can do it very easily with NPM. Install global Ganache ClI. And after you can start ganache with Ganache Cli. Okay, so now it's running at localhost port 85 45. So now I create a new terminal and actually we still have a configuration to do in truffle config if you want to connect to this ganache blockchain.
00:15:11.230 - 00:15:46.902, Speaker B: So we scroll down in the configuration and at some point you will see comment that a configuration for a network called development. So that's the one we want. So host, this is localhost port 85 45. Yeah, so this is correct. All right. And I'm going to create another terminal. So now we can run the deployment script with trough migrate reset and by default it's going to choose the network development.
00:15:46.902 - 00:16:09.860, Speaker B: But you don't need to specify this, this is the default. Okay so we have an error here. So you cannot find token two. So probably there is a mistake in the import pass. Token two, so the import pass is correct. Probably the name of the contract. Let me see.
00:16:09.860 - 00:16:31.942, Speaker B: Token. Okay yeah, so here we haven't changed, this should be token two. All right, so let's try again. And this time it does work. Great. So if we scroll we can see the address of the Uniswap factory. Great.
00:16:31.942 - 00:16:36.054, Speaker B: So next we're going to deploy the router smart contract.
00:16:36.182 - 00:17:17.190, Speaker A: Okay so let me enlarge my terminal here. And we going in and we are going to create a folder for the periphery code exactly like we did for core. And we're going to create another truffle project inside. So we have to separate core and periphery contracts because they use a different version of solidity and there is no way to deal with this easily in a single truffle project. So truffle in it. And after let's copy over the contract. So we copy from the repo that we got from GitHub contracts.
00:17:17.190 - 00:18:01.720, Speaker A: We put everything in the contracts folder of our truffle project. So now here we can see the Uniswap contract including the router and this smart contract have some import paths that reference some NPM packages. So we need to install these NPM packages. So first we init NPM project and after we're going to install uniswaplib and Uniswap V two core. Okay. And next we need to change the version of solidity. So the router contract uses solidity 0.6.6.
00:18:04.170 - 00:18:39.886, Speaker B: Okay. And after that we need to create a wrap ether smart contract. So why we need this? Because in Uniswap when you create a market, Uniswap doesn't use ether, but it uses wrap ether, which is an S 20 token version of ether to deploy factory or pair contract. You don't need about this wrap ether token. However for the router contract, it make use of this wrap ether contract. So we need it. So let's create this in a contracts folder.
00:18:39.886 - 00:19:16.478, Speaker B: And after for the code we going to ether scan. So on ether scan we search for wrap ether. Okay, this one. So just a side note, so it's a bit dangerous to do like I'm doing searching something on ether scan and taking the code from there because anybody can deploy contract that I call wrap ether. So you have to verify in the documentation of Uniswap that this address is correct. But here I can see that they have many, many address a lot of ether in it. So it's probably the correct one.
00:19:16.478 - 00:19:45.878, Speaker B: And I click on contract. Contract. And here I can see the code. So we're going to copy the code and paste it in our file. So we're going to change the version of solidity to three t 0.6. So let's see if we have to make some changes to make it work. So in three t 0.6,
00:19:45.878 - 00:20:26.470, Speaker B: when you emit an event, you need to have the emit keyword. So we need to add, this should be fine. So now let's try to compile everything to make sure that it works. Oh yeah. The way fallback function I declare is different in three t 0.6 we need to use the receive keyword. So let's go back in the contract here, call this receive.
00:20:26.470 - 00:21:02.510, Speaker B: Okay, so now it should be fine. And now we need to replace this by address this. Okay, so let's do this. It's a little bit annoying, but when you have code from different places, you need to harmonize the version of solidity sometime. So where do we have this here? Address this. Let's try to compile it again. Okay, and finally the receive function must be declare external.
00:21:02.510 - 00:21:19.320, Speaker B: So annoying. But we're almost there. Okay, so here, external. Come on sweetie, give me a break. Tell me it compile this time. Yeah, finally.
00:21:20.170 - 00:21:20.630, Speaker A: Awesome.
00:21:20.700 - 00:21:31.514, Speaker B: Oh, last thing, I actually don't want this contract to be called with nine, but just with normal, this is cleaner like this. All right.
00:21:31.712 - 00:21:35.414, Speaker A: Okay, so next we need to write the migration file.
00:21:35.542 - 00:21:43.950, Speaker B: So the migration folder, we create file called deploycontracts js.
00:21:46.450 - 00:22:13.750, Speaker A: And like we did before, we're going to copy a template from initial migration. And after we're going to import the router contract of Uniswap. So this is called Uniswap v two, router two Sol. We're also going to import wrap ether.
00:22:17.390 - 00:22:51.220, Speaker B: Okay. We make this function async because going to use the await keyword inside. So we define a variable to point to wrap ether. And also we define a constant for the address of the factory. Okay, so for that we're going to go to the terminal output of ganache. And when we deploy the factory we add the contract address here. Let's copy this.
00:22:51.220 - 00:23:32.110, Speaker B: Okay. And after, if we are deploying on main net, then in this case we don't need to deploy wrap ether. It already exists. So we're just going to connect to the deployed version. We need to have the network argument here. So in this case the pointer to wrap ether is going to point to the contract to get the address. Let's go back to ether scan where we search wrap ether.
00:23:32.110 - 00:24:04.810, Speaker B: And here we have the address. We're just going to copy this to the clipboard and back to our code. And if this is not main net, then we need to deploy the wrap ether. So in that case deploy it. First we wait for the transaction to be mine and we get a pointer to this contract. And once we have this we can finally deploy the router. Deploy, deploy.
00:24:04.810 - 00:24:58.582, Speaker B: And the first argument of the constructor is the address of the factory and after the address of wrap ether. And oh yeah, we also need to define in truffle config the development network so that we deploy on the same network as just before. Oops, this was before development here. Okay. And so now we go into the periphery folder. When we run truffle migrate reset, it's going to connect to the same ganache instance that we started before. Even though we started this instance from another folder.
00:24:58.582 - 00:25:16.542, Speaker B: It doesn't matter where you started from. What matters is the port. The port 85 45. We're connecting to the same port here. Now we deploy our router and we have an error and it says, did the deployment run out of gas?
00:25:16.606 - 00:25:17.682, Speaker A: Oh yeah, I know why.
00:25:17.736 - 00:25:51.178, Speaker B: So there is a problem with the contract of Uniswap, the router. For some reason it seems it's actually too big. So in order to make it work I had to comment as part of the contract. So we going to do the same thing. Let me scroll down. Yeah. So all these functions swap exact token for tokens supporting fee on transfer tokens.
00:25:51.178 - 00:26:35.290, Speaker B: It's a function that is rarely used, so we can comment out a lot of this. So let's comment out everything up to here. At this point library function that are important, we need to keep them. Okay, so all this block is commanded at. Okay, so now we are going to run the migration command again, and normally it should work this time. So now it complains because basically we are inheriting from an interface here and we don't implement all the functions of this interface. So in order to solve this problem, we're going to comment at some function of the interface.
00:26:35.290 - 00:27:18.338, Speaker B: And here we're going to comment at that one swap exact token supporting field, blah blah blah, like super long function name. Okay, so now let's run the migration again. Wow, that wasn't easy, but we made it. So one of the big difficulty in forking Uniswap is that in the repo of the smart contract of Uniswap, they don't put any code to deploy the smart contract. So we need to manage this ourselves with truffle. Another issue is that they separate the smart contract into different repo. And for each smart contract they use different version of router, use three DT 0.6.6,
00:27:18.338 - 00:27:52.938, Speaker B: and the core smart contract use three t 0.5.16. So that forces us to have two separate truffle project. So I show you how to deploy to a local development blockchain. But if you want to deploy to a public testnet like Covan, or if you want to deploy to Mainnet, the procedure is very similar. You only have to make a few changes in truffle config and connect to infira. And I already have a video where I explain this. So in the description of this video, I'm going to link to the other video where you can learn how to do a deployment to mainet or public testnet.
00:27:52.938 - 00:28:06.900, Speaker B: But we are not done yet because we still need to bootstrap the liquidity of our exchange. So I'm going to show you how you can attack the liquidity of another exchange exactly like Sushiswap did.
00:28:10.870 - 00:28:42.186, Speaker A: Okay, so now that we have a full uniswap, it's time to bootstrap our liquidity. And we are going to do a liquidity attack by taking some liquidity out of Uniswap into our exchange, exactly like Sushiswap did. So I'm going to explain you how it works. It has two steps. So first you need to get the liquidity provider token. So these are the token you get when you provide liquidity to the Uniswap exchange. And in order to get this LP token from investor, you need to give some incentives.
00:28:42.186 - 00:29:31.214, Speaker A: So we are going to create a migration contract that gives out some bonus token to anyone who invests its Uniswap LP tokens. And also of course any LP token invested in this migration contract will be redeemable against LP token of our fork of Uniswap. So in the end investor will be able to recover the underlying tokens they invested initially in Uniswap. And the second step, once you have attracted enough LP token in your migration contract, is to actually do the liquidity migration. So for that you are going to send all the LP tokens from the migration contract to Uniswap. So you're going to redeem these LP tokens and in exchange you're going to get all the underlying tokens. So token zero and token one.
00:29:31.214 - 00:30:07.818, Speaker A: So these are specific for each market. For example, for Dai wrap ether, token Zero is going to be Dai and token one is going to be wrap ether. And after you're going to forward these tokens into your pair contract of your Uniswap fork. So in exchange you're going to get the LP token of your Uniswap fork and you are going to distribute this LP token to all the investors who send the LP token to the migration contract. Okay, so that's the plan. So next we're going to implement this with code. Okay, so we're going to go at the root of our project.
00:30:07.818 - 00:31:03.002, Speaker A: We're going to create a new directory called Migrator, step into it, initial a truffle project. And after we're going to initialize an NPM project because you're going to need to install a couple of NPM package. So first uniswap v two Perry ferry to use the router smart contract and also open zeppelin contracts because we're going to manipulate some as 20 tokens. Okay, so let's install this. Oops, that was a typo here. Okay, let's try again. Okay, so next we are going to change the configuration of our project to use solidity 0.6.6,
00:31:03.002 - 00:31:43.082, Speaker A: so the same version as the router of Uniswap. All right, so next we're going to create the bonus token that we're going to give as a bonus to anyone who stake the LP token in our migration smart contract. We're going to call this bonus token saw. All right, so let's open this and this is going to be for 3d open six. And we're going to import Erc 20 token from open Zeplink. So this time it's going to be the latest version of open zeplink that we install. So it's a little bit more simple.
00:31:43.082 - 00:32:07.662, Speaker A: That's what we did before. Yes, 20 saw. That's all we need to import bonus token is. Yes, 20. So we inherit from it. And after, in the constructor, we're going to trigger the constructor of ES 20. We give it two argument.
00:32:07.662 - 00:32:28.760, Speaker A: The name and a symbol. So the name is bonus token. And the symbol is going to be, for example, BTK for bonus token. Okay, make this public. And inside we're going to save the deployment address. We're going to call this admin. It's going to be useful after.
00:32:28.760 - 00:33:03.890, Speaker A: And after we're going to have another function to set the liquidator. So this would be useful to mint new token. So address liquidator. And only the admin can send the liquidator. Otherwise, this is security risk. And so the liquidator is going to be what we pass as arguments. We also need to save this address in the state of the smart contract.
00:33:03.890 - 00:33:37.386, Speaker A: Okay, and after that, we need to create another function to mint bonus token. Every time someone send their lp token. So we want to know the recipient and the amount. And only the liquidator can call this function. Okay, and after that, we're going to call the underscore mint function. That is provided by open zeplink. Remember that here we inerate it from Es 20.
00:33:37.386 - 00:34:15.910, Speaker A: So we inherit from a bunch of function, including underscore mint. And here we just forward the argument we receive. And boom. That's how you can give your bonus to the investor. Okay, after we need to import an interface for the pair of Uniswap. So we're going to call this I Uniswap, Uniswap V two pair sol. And we go in the repo of Uniswap core contracts interfaces.
00:34:15.910 - 00:35:00.802, Speaker A: And here you will see iuniswap V two pair. We're going to copy this. And the only reason why we do this and not take it directly from the NPM package of Uniswap is because we need to change the solidity version here. So back in our code, we paste this, and then we replace here by solidity 0.6.6. So I think it's going to be all right like this. And we don't need to change anything. And after that, we're going to create another smart contract called liquidity migrator.
00:35:00.802 - 00:35:51.810, Speaker A: So that's where all the action is going to take place. Okay, so let's open this. So that's solid 0.6.6. So first we need to import a couple of stuff like the interface of open z playing for yas 20 token. So we need to manipulate the bonus token. That's why right after we need to import an interface from Uniswap. So Perry contracts interfaces, we need the interface of the router, Uniswap v two router, two cell.
00:35:51.810 - 00:36:59.710, Speaker A: All right, we also need to import the interface of Uniswap pair that we just created before. And we also need to import the bonus token. Okay, so now we define our contract. So we're going to define a couple of pointers. So first to the router of Uniswap, then to the pair of Uniswap, then to the router of our fork. So we're going to call this router fork, then to the pair of our fork, then to pointer to the bonus token. Then we need to know the address of the admin, then we need to know the balances of people who invested the LP token in the contract.
00:36:59.710 - 00:38:20.550, Speaker A: So it's going to map the address of the investor to the balance of LP token they initially invested so that we can give them the equivalent amount of LP token, but for our folk and claim balances, and then a boolean value that just tell us if the migration was done. So after we're going to have a constructor to initialize a couple of variables. So first the address of the router of the pair of the router fork, of the pair fork, and of the bonus token. After, we're just going to initialize all this pointer. Same thing for the fork, same thing for the token. Okay, and finally also we need to save the address of the admin so that we can protect some function. Okay, so the first step is to deposit LP token to the liquidity contract.
00:38:20.550 - 00:39:20.700, Speaker A: So here we need to indicate how much we want to deposit. So we need to make sure that the migration was not done before. After we are going to transfer the LP token, and for that we use the pair contract of uniswap and we can use the transfer from function. So of course that means before you call deposit, you need to call the approve function with the address of the migration contract. So we're going to transfer from the sender to our contract, and for the amount that was specified. And after we need to give the bonus token to the sender as a reward for sending its LP token. So we're going to give as many bonus token as LP token to make it simple.
00:39:20.700 - 00:40:15.150, Speaker A: And we're going to increment the unclaimed balance mapping for the sender increment of the amount. Okay, so all the investors are going to send the LP token. And finally when we have enough LP token, we're going to proceed to the actual migration. So we're going to call this migrate and only the admin can do this. And it can only be done when the migration was not done before. And we need to have a pointer to the two underlying tokens of our market. So for that we can call the token zero function of the uniswap pair to get the address of the first and second token.
00:40:15.150 - 00:41:18.980, Speaker A: We also need to know what's the LP token balance of our smart contract. For that we can use the pair pointer and balance of function for our address. And once we know this then we can withdraw everything. So for that we're going to use router remove liquidity, we're going to pass a couple of function like the address of the two token, the total balance of LP token we want to withdraw the minimum amount of token zero and token one we want. So here I make it simple, but it's actually possible to specify a minimum amount and then for the recipient of the underlying token. So that's going to be our smart contract and for the limit date for this action. So that's going to be now.
00:41:18.980 - 00:42:21.990, Speaker A: Okay, so with this we remove the liquidity from Uniswap to our smart contract. And next we're going to forward the underlying tokens to our fork of Uniswap. So now we need to know what's our balance in the two underlying token, token zero and token one. So for that we define new variable token zero balance, and we can get the balance of our contract like this, same thing for the other token. And after we are going to approve our Uniswap folk to spend this token on our behalf. So we can approve the router fork for the token zero balance, same thing for the other token. And now we can call routerfolk add liquidity.
00:42:21.990 - 00:43:07.070, Speaker A: So we pass the two address, let's copy this. And for the two balances of tokens. So that's token zero balance, token one balance. You can also specify a minimum amount for these two tokens. So we're going to put the same one and it's going to be credited to the address of our smart contract. And the limit for this action is now. And after that we change the flag for migration done to true and with this, the liquidity is sent to our folk of Uniswap.
00:43:07.070 - 00:43:51.730, Speaker A: So next, once this is done, all the LP tokens are credited to the address of our smart contract. But we need to allocate this to the different investor so they can redeem this new LP token. So the investor will have individually to call a function called claim LP token. And the reason why we don't do this allocation outset here in the migrate function is because we can have a very large number of addresses where we need to send all this LP token. And this can have a very high gas cost. So we want to avoid this. So here first we're going to require that the caller of this function actually has some Token.
00:43:51.730 - 00:44:43.650, Speaker A: We call this no unclaim balance. If there is an arrow, then we want the migration to be done. Migration done equal true. And the error message is migration not done yet. Okay, then we need to save the amount to send because we're going to set this to zero after unclaim balances of MSG sender. And after that the unclaimed balances of the sender is going to switch to be set to zero. And finally, using our pair fork, we are going to transfer the LP token so to the sender of the transaction.
00:44:43.650 - 00:45:29.940, Speaker A: And the amount to send is this. And so now our investor owns the LP tokens and can redeem them against the underlying tokens. And on top of it he also has received the bonus tokens. Okay, so let's exit this and let's try to compile all of this just to make sure that there is no compilation error. Okay, so line 21 compilation error here. All right, so now is it fine. Okay, so pragma solidity, I forgot in uniswap v two pair I forgot, here is.
00:45:29.940 - 00:46:07.660, Speaker A: Okay, let's try to compile again. Yes, it's working great. So the last thing we need to do is to write the migration script. So let's do this. Deploy contracts. All right, let's copy paste from the template of migration. First we are going to import bonus token artifact require bonustoken sol.
00:46:07.660 - 00:46:50.700, Speaker A: Then we also need to import liquidity migrator. All right, we make this as sync. First we're going to deploy our token. And after we need to have a reference to this. Okay, and after we're going to define the different address router address pair address. So these are supposed to be the address of uniswap waterfork address. So this is what you deploy yourself.
00:46:50.700 - 00:47:19.810, Speaker A: Pair fork address after we're going to deploy the migrator. So first we specify liquidity migrator and we're going to pass a bunch of addresses. So basically all these addresses here. All right, let's get rid of this. Don't need this. Donate this. Donate this.
00:47:19.810 - 00:47:22.210, Speaker A: Okay, let's put some comma everywhere.
00:47:22.870 - 00:47:23.282, Speaker B: Okay.
00:47:23.336 - 00:47:36.170, Speaker A: And we also need to put the address of the bonus token that was deployed just before. And now we need to have a reference to the liquidity migrator.
00:47:39.470 - 00:47:39.978, Speaker B: Okay.
00:47:40.064 - 00:48:26.826, Speaker A: And finally, we need to call the set liquidator on the bonus token so that the liquidity migrator is allowed to mint token on bonus token liquidity migrator address. All right, and we pretty much done. So what's next? Are you going to create the next sushiswap? So just to be clear, I don't recommend to just copy paste the code of Uniswap with some minor modification like chef Nomi did for Sushiswap. Think of forking like a quick way to get some foundations. But after you get this foundation, you actually really need to bring some added value. Otherwise there is no point. Another idea I haven't mentioned.
00:48:26.826 - 00:48:43.640, Speaker A: If you just want to experiment with forking DeFi protocol, and you don't want to hurt the Uniswap project, what you can do is you can fork some Uniswap fork like sushiswap. And if you want to keep watching some other tutorials about cool defi project, check out these videos on my channel. I'll see you there.
