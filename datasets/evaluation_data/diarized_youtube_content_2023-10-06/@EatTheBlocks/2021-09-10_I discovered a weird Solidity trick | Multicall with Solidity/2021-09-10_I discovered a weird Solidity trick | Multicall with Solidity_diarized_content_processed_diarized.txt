00:00:00.250 - 00:00:26.114, Speaker A: I just found something really weird. In solidity you can use a smart contract without deploying it. This is super strange, but also super useful. And in this video I will explain how it works and what are the typical use cases. If you don't know me, I'm julian, and on ether blocks I teach blockchain development. So here's a story. I was just trying to find ideas for my next tutorial and I stumbled upon this concept of multicol.
00:00:26.114 - 00:00:57.870, Speaker A: A multicolored smart contract allow you with one call to call the functions of several smart contracts. A typical use case is if you want to read the token balances of several tokens. Normally you will have to make a lot of separate calls, but this is slow and you can quickly hit the usage limit of the API you are using. With this multi call smart contract, you avoid this problem. As I was going through this smart contract, I found out about this whale solidity trick I mentioned before. So next I will first explain how the multi call smart contract works, and after I will explain this wheel solidity trick.
00:00:59.970 - 00:01:08.626, Speaker B: All right, so this is the code of our multiple spot contracts. This is a truffle project and actually took the code from a project called.
00:01:08.728 - 00:01:11.618, Speaker A: Index finance, and I copied it in.
00:01:11.624 - 00:01:43.862, Speaker B: The contracts directory, multicolored cell. So here all the code is inside the constructor. So I'm not going to explain now why this is a constructor. And for now let's assume that this is a function, and I'll come back to the constructor in the next section. So when you call this function, you're going to give it an array of addresses. So this is the address, these are the smart contract that you want to call, and an array of arguments. So this array for each entry, specify which function to call on the target and with which argument.
00:01:43.862 - 00:02:16.278, Speaker B: And the data type for this is an array of bytes. If you never heard of bytes in solit, this is a data type that is used for arbitrary data. So this data type is more flexible, but it's also more dangerous and more difficult to manipulate. So we only use it when we have no other choice, which is the case. And after we extract the length of the target array, and we are going to compare the length of the two array. So the ax array and the target array, they need to have the same length. Otherwise we stop the execution here.
00:02:16.278 - 00:03:00.280, Speaker B: And after we declare a new variable, this is an array of bytes, and this is going to store the return value of all the function call. And after in a for loop, we are going to do all our function calls. So first we extract the address of the smart contract that we are going to call. We extract the arguments and then we do the call. So this is notation to do a low level call in solidity, the address of the smart contract call and you pass the argument. So this will contain the name of the function and the argument. And in return we're going to have two value, a boolean value that tell us if the call was successful, and a bytes variable with the data that was returned from the function.
00:03:00.280 - 00:03:40.482, Speaker B: So if the boolean value here is not true, that means the call was not successful. And in this case we are going to populate our written data array with an empty bytes here. And after we need to flatten this written data array. So we do this with AbI encode and we're also going to add a block number at the beginning. So I'm not too sure why they did this. In the implementation of index finance, what we mostly care about is this. And so here we return the data in assembly and we need to specify a pointer to our data, and for that we're going to add 30 byte to the first memory slot of data.
00:03:40.482 - 00:04:14.730, Speaker B: And I believe that's because the first memory slot of data contains the length of the bytes variable. But we're not interested in this, we're only interested in the payload. And after I'm not sure why, we repeat data, but the point is that we're actually going to return the data here. And so that's it for the multicolored smart contract. So next I've created some tests. So here in the test folder, multicol Js. Okay, so this is our test file.
00:04:14.730 - 00:05:02.154, Speaker B: And so first we have a couple of imports. So first we import ether, which is a library to communicate with the Ethereum blockchain, and this is required by the JavaScript Library of Index Finance. So index finance here, this is the DeFi project that provided the implementation for the multicolored. So we both have the implementation of the smart contract and they also provided a JavaScript library, so this one to interact with the smart contract, so we also need it. And we also import the ABI of our token. Oh yeah, so before I forgot to mention a token, but basically I created two Es 20 token, and this is just for the test. And we are going to get the balance of an address on these two smart contracts.
00:05:02.154 - 00:05:03.520, Speaker B: That's for the demo.
00:05:04.370 - 00:05:05.982, Speaker A: Then we have our test here.
00:05:06.036 - 00:06:08.606, Speaker B: So first we define a couple of provider, a pointer to token one and token two, also the ethers provider. This represents the connection to the blockchain also we extract the first address of the accounts provided by truffle. So that's our admin address, and before we run our test, so we're going to execute this, so we deploy your two token, token one, token two. And after we are going to convert a webster provider to an ethers provider. Because the multiple JavaScript library needs an ethers provider, it's not compatible with Webstery, so it's how you do the conversion. And after here, this is where we have our test. So first we instantiate the multiple JavaScript object and we pass it the provider, and after we define an array where each entry will tell the multiple smart contract which function call we want to do, and for each entry we specify the address of the smart contract, the name of the function we're going to call, and an array of arguments.
00:06:08.606 - 00:06:39.686, Speaker B: So in our case we only have one entry, that's the address of the admin, and after we do the actual call here, so by using the multicol library, and so we pass it the array call params as well as the ABI of ERC 20. So actually this is a limitation of the multicolored library because you can only do multiple of smart contracts that have the same API, but you might want to do multiple on totally different smart contracts.
00:06:39.718 - 00:06:41.846, Speaker A: So actually on the smart contract side.
00:06:41.888 - 00:07:26.540, Speaker B: It'S possible, but it's not possible for the multiple library. So if you want to do this you need to customize the multiple JavaScript library. And after we get our results in token data here, and so this is an array and the actual payload is in the second entry. So here this is in token data one. And so we have a nested array and so the first entry will be the call for the token balance for token one and after the token balance for token two, and each of them is supposed to be equal to 1000. So to check that everything is working fine, I'm going to run the test in my terminal. So truffle test, and normally it should pass.
00:07:26.540 - 00:07:42.160, Speaker B: Let's wait a few moments. Okay, it's running the test, compiling the contract, running the test, and yes, our test is passing, should read the two token balances, everything is fine. Great.
00:07:45.090 - 00:07:59.430, Speaker A: In the multiple smart contract the code is inside the constructor, but that's very strange because that would mean the smart contract could be only used once, which isn't very useful. And on top of it we didn't even deploy the contract in our test and it still works.
00:07:59.500 - 00:08:00.246, Speaker B: What happened?
00:08:00.348 - 00:08:25.726, Speaker A: In our test we use a multiple JavaScript library of index finance for this you need to understand the two main APIs for Ethereum smart contract when you want to read values from a smart contract, use an API called it call. It doesn't cost you anything, but it also cannot change the state of the blockchain. And when you want to write values to a smart contract, use an API called ETH send transaction. This API costs money that we pay in gas and it can change the.
00:08:25.748 - 00:08:27.114, Speaker B: State of the blockchain.
00:08:27.242 - 00:09:06.506, Speaker A: Now what I've just said is for the most common situations, but what most people don't know is that it's possible to call APIs for the opposite use case they were initially designed. You can call a read only function with ETH send transaction and there is no point in doing this, but technically it's possible. And you can also call a function that modify the state in the blockchain with east call. This can be useful for function that return a value. Normally with east send transaction you cannot read this written value, but I hadn't realized you could also use the escal API to deploy a spot contract. And when you do this you don't actually deploy the spot contract. Remember, with escal you cannot persist any state change.
00:09:06.506 - 00:09:21.838, Speaker A: Everything you do inside this call is just temporary. In the case of the multi call smart contract, we deploy it with the Isco API, which means we don't really deploy it and it doesn't cost anything. But the code inside the constructor is still executed and we have access to the return value.
00:09:21.924 - 00:09:25.198, Speaker B: So that's a really cool trick and I hope you learned something new.
00:09:25.284 - 00:09:42.130, Speaker A: And when you start to be really good in solidity, one of the best way to monetize your skill is to become a smart contract auditor. Smart contract auditors can make up to $300,000 a year and are in very high demand. If you're interested in this, check out this video. I will see you there. Bye.
