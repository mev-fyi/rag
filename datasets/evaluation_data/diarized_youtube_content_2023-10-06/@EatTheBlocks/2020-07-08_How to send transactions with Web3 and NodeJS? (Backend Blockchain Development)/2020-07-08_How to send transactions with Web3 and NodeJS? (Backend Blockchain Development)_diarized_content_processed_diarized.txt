00:00:00.330 - 00:00:49.814, Speaker A: If you want to send a transaction on a smart contract on the Ethereum blockchain, you need to use a JavaScript library like webstery. You can use Webstery on the backend or on the front end. However, the way you use Webstery on the back end and on the front end is a bit different. On the front end you have access to wallets such as Metamask, but on the back end that's not the case. Also on the back end, usually you connect directly to services like Inferra who require to be sent transactions that are already sent, but you don't have any wallet. To do this, you have to sign this transaction yourself. So in this video I'm going to show you how you can send transaction to Ethereum smart contract on the back end by using web3 and node js.
00:00:49.814 - 00:01:25.720, Speaker A: I'm going to show you three method, starting from a more difficult method where we're going to see all the low level details of creating a transaction. And after I'm going to show you some other methods that are a little bit easier, that are a little bit higher level, and that allow you to go a little bit faster. If you don't know me, I'm Julian, and on my channel I teach blockchain development. And before we continue, make sure to register for my free training on how to become a professional blockchain developer and find your first blockchain job link just below.
00:01:30.190 - 00:02:08.018, Speaker B: So first we are going to send a transaction with Webstery and node JS by using a hard method. And the reason we do this is to understand well what's happening behind the hood. So for my demonstration, I've set up a simple truffle project and I have a very simple spot contract in the contracts folder, and we're going to write our code in script JS. And if you want to have access to the finished code, you can check the link in the description. So let's see a little bit what we have in our spot contract.
00:02:08.194 - 00:02:10.562, Speaker A: So that's a super simple spot contract.
00:02:10.626 - 00:02:39.230, Speaker B: Where you have an integer variable and a setter function. So because here I have the public keyword, that means I also have a gator, so I can read the value of data and I can modify the value of data. Super simple. And after in script js. So that's where we are going to write our code. So first we require Webstery. That's the library we're going to use to select transaction.
00:02:39.230 - 00:03:21.914, Speaker B: Then we import the contract artifact of truffle. So this is a JSON document with a couple of info about the contract, such as the API and the address. This is produced when you compile a smart contract or when you deploy it to the blockchain. Then here I have my sending address as well as the private key. So I generated this address and private key by using this website vanity eth. So you scroll down, you click on generate, click to reveal, and you can create as many address and private key as you want. And so we're going to send our transaction on the Rinkobe public testnet.
00:03:21.914 - 00:04:23.918, Speaker B: And so in order to get some testnet ether, then what you need to do is you can use this faucet, but for that on your social media it can be twitter, Facebook. You create a post with the address that you just created and then you copy paste the link of this post, you put it here, you click on give me ether and it's going to give you some test ether. So that's how I set up my address and my testnet ether. And after that I also here set up my infura URL. So infura is a service to easily access the Ethereum network. You don't strictly need to use inferra if you want to send a transaction to Ethereum, but it's very complicated to run an Ethereum node. So with inferra they run ethereum node for you and you create a free account and you can access a URL that you can use to connect to the blockchain.
00:04:23.918 - 00:05:15.778, Speaker B: So inside my dashboard I go to Ethereum, I created a new project, and after you go to settings, you're going to get a couple of endpoints. So I chose the one for Rinkobee and I copy pasted this in my code. And so after we going to put all our deployment logic inside this function in it one. Oh, by the way, I realized that I didn't install Webster. Let me fix this. So first I init Npm project and after I install web3. Okay, so back to our code.
00:05:15.778 - 00:05:42.486, Speaker B: So we are going to create a web3 instance. So here you know that the way I import web3 is with uppercase w. But here when I create the instance is with a lowercase w. That's super important. We pass the infrared URL to Webstery and after. Second, we need to create a Webster contract instance. So that's a Javascript object that can communicate with our smart contract.
00:05:42.486 - 00:06:38.330, Speaker B: So for that, first we need to know the network id. So that's an integer that represents the Ethereum network we want to send a transaction to. So for that we going to use a function of web3, web3 eth net getid. And after that we're going to create our contract instance with new webstered eth contract with an uppercase, we pass the ABI and the address of our contract. So for that we use the my contract object we imported above. And this is going to be in ABI and for the address, this is going to be mycontract address. What am I saying? No, this is wrong.
00:06:38.330 - 00:07:20.314, Speaker B: This is in networks and after network id and address. Okay, so after we're going to create a transaction object with our contract instance. So mycontract method set data, we're going to put one as argument. So if you are used to integrating web3 with metamask, you probably know that at this stage we do use the send method here. But actually in this case this is not an error. We're not going to use send. This is going to be a little bit different.
00:07:20.314 - 00:08:22.138, Speaker B: So with this transaction object, we going to estimate the gas. Just to be clear, I'm talking of the gas limit here, transaction estimate gas, and we're going to pass for an object with the from parameter for the sending address. So that's going to be address. This is the address that we defined before and that we use to get some rink b ether. And we're also going to get the current gas price, this time with web3 east get gas price. After that we're going to get the encoded API of our function call. So that's a hexadecimal string that basically will tell our spot contract which function we want to call and with which argument.
00:08:22.138 - 00:09:10.354, Speaker B: So for that we use the encode ABI function after we need the nons. So the nons is an integer that is incremented after each transaction. And this is used to avoid to send twice the same transaction. So we're going to use Webster eth, get transaction count, and we pass the address that we want. Okay, so after we need to sign our transaction. So this is going to be an async operation, Webster east account sign transaction, and here we're going to pass the detail of our transaction. First the recipient.
00:09:10.354 - 00:10:02.282, Speaker B: So that's going to be the spot contract bycontract option address, then data. Well, we already defined data here, gas, gas price nons if you are not super experienced in JavaScript. Basically this notation here, this is equivalent to this et cetera. That's a shorthand notation. And we need to specify the chain id to know on which blockchain network we want to deploy. And you don't actually need to specify all of these parameters. Some of them have some default.
00:10:02.282 - 00:10:52.240, Speaker B: But I just wanted to show you under the hood how it works. You can also specify a value parameter if you want to send some ether here. And this will be in the way. So here is not 100 ether, but this is 100 way. If you want 100 ether, this is going to be 100 times ten power 18. Okay, and after that we need to pass the private key so that web3 knows how to sign this transaction. Okay, and after we are going to console log the old value of data in our spot contract so that we can compare before and after old data value.
00:10:52.240 - 00:11:49.402, Speaker B: And we're going to call the data method. So mycontract method data call close this. And after we're going to finally send our transaction, we're going to get a receipt. So for that we use Webster eth send transaction and we pass signtransaction row transaction. So that's going to be what they call a RLP encoded string. So that's a special format for ethereum that is used for signed transaction. After we console log the transaction hash so that we can look it up on a blockchain explorer.
00:11:49.402 - 00:12:22.634, Speaker B: So for Rinkob, you can go to Rinkob etherscan.com. For Mainnet, this is just etherscan.com. And here this is going to be receipt transaction hash. And then we print the new value. Okay, so now we can test our script. So first we need to deploy our smart contract. So here in the truffle configuration, I've already prepared something.
00:12:22.634 - 00:12:44.678, Speaker B: So here we use another package called truffle wallet provider. I pasted my address and private key. We build this provider object. And here in the network spot, we define a new network. Rink B. We pass the provider we just created. Network id is four for rink B, but for mainnet this is one for each testnet.
00:12:44.678 - 00:13:23.678, Speaker B: This is different. By the way, I need to install this truffle wallet provider. Okay, NPM install truffle HD wallet provider. All right, and so now we'll be able to deploy our smart contract. So truffle migrate network ring b. I specify reset here. All right.
00:13:23.678 - 00:13:52.630, Speaker B: And now we can run our script. Oh damn. There is an error. Okay, so let me see, what's the problem? Okay, so this is not send transaction, but this is send sign transaction. Okay, so let's try again. Yes, this is working. We can see the old value is zero.
00:13:52.630 - 00:14:28.418, Speaker B: Then our transaction hash, we can look it up on ether scan and after new data value. So everything is working perfectly. So let's just have a quick look for this transaction hash. From here I am at Rinkobee Etherscan IO I past my transaction hash. Yeah, I can see that. It happened 43 2nd ago. And from the address I created to the spot contract I deployed, this is working great.
00:14:28.418 - 00:15:25.220, Speaker B: So it was a little bit cumbersome to sign your transaction and send it after. Can we send a transaction with a more simple way? Yes, we can. So we're going to be back in our code editor, and now we're going to create another function that's going to be very similar to this one. So I'm going to copy past unit one into unit two. First we are going to add our private key to the wallet of Webstery with Webstery eth account. Well, that's a lot of nesting level add. And here we pass the private key.
00:15:25.220 - 00:16:02.574, Speaker B: So that's an internal in memory wallet of web3 that we're going to be able to use after. So we're not going to use the sign transaction method here, but we still need to define an object. We're going to call this transaction data. And this time we need a from parameter. So that's our address. And this time we don't have a chain id parameter, but just chain. And this is a string this time.
00:16:02.574 - 00:16:35.500, Speaker B: So specify rink B. By default this is main net and we also need to specify the hard fork. So the latest one is Tom pool. If you want to target main. Net. Actually you can ignore these two parameters and by default it will be the correct one for Mainnet. Then after we're going to use the method send transaction and we pass the transaction data.
00:16:35.500 - 00:17:25.850, Speaker B: And here since send transaction will see that for the from field we have an address of the wallet. Then send transaction will sign the transaction locally and send it to Infira. It's very important that we add the private key to the wallet of Webster because otherwise send transaction will not know how to sign this transaction and it's not going to work. Okay, so here we're going to execute unit two this time. Oh, by the way, I forgot something. So this time we're going to set data to two so we can make the difference with the previous step. And we're going to run the script again.
00:17:25.850 - 00:18:08.902, Speaker B: And so this time the data value should go from one to two, old data value, transaction hash and a new data value two. Yeah, that's great. Okay, so we've made some progress. Now we can send a transaction with web3 and node js with a more simple method. But still I finding a little bit cumbersome and this is still quite different from what we do in the front end. So can we make it even more simple? Yes, we can. So the third method I'm going to show you is actually very similar to what we do in the front end.
00:18:08.902 - 00:18:52.662, Speaker B: So if you send transaction in the front end before, it's going to feel very familiar. So first of all, we're going to copy init two because we still have a lot of common code. So it's going to be unit three. All right, at the top of the file, we will need to import hd wallet provider of truffle. Truffle HD wallet provider. Okay, we scroll down this time. No need to add the private key, but we're going to instantiate Webstery in a different way.
00:18:52.662 - 00:19:37.346, Speaker B: So first we instantiate a new provider with a private key. So there are different way to pass this first parameter. If you have a single private key, you can do it that way. If you have several, you can use an array. If you have a mnemonic phrase, you can put the mnemonic phrase here. And after we're going to put the infra URL and this thing provider, when combined with web3, it will allow us to sign our transaction really easily. So here, instead of intra URL, we going to use this provider.
00:19:37.346 - 00:20:22.082, Speaker B: So provider are always something a little bit difficult to beginner in blockchain. So basically, when you instantiate Webster with a provider object like this, the Webster object that you get in return is a sort of modify web3 object because the provider object is going to intercept some method call of web3. And so for example, for the send method call, it's going to intercept this and sign the transaction before sending them. But everything is done transparently. It's also going to set different parameter like gas, gas price, et cetera. So actually we don't have to do any of this. This is much more simple.
00:20:22.082 - 00:21:04.286, Speaker B: All we have to do is we use my contract method set data. So here we're going to put three send here from our address, and the provider is going to intercept this method call and sign it with the private key that we have here. So that's super convenient. So here we change init three, init two to any three, and we go.
00:21:04.308 - 00:21:06.146, Speaker A: Back to a terminal, we execute the.
00:21:06.168 - 00:21:50.570, Speaker B: Script and everything is working fine. We can see the old value, the transaction hash and the new value. Great. So now you not only understand how things work under the hood to send a transaction with Webster node js, but you also know an easy method that you can use if you want to go faster. So sending transaction from the back end with Webster and node js. That's something important, but actually, in most cases, you probably want to use web3, be in the front end of your decentralized application. And for this you need to integrate it with wallets like metamask.
00:21:50.570 - 00:22:02.080, Speaker B: And it also comes with its own set of challenges. So if you want to learn how you can integrate Webstery with Metamask, check out this video. I'll see you there.
