00:00:00.330 - 00:00:59.520, Speaker A: Hey, this is julian and you are on idoblocks. Recently solidity released a new version that's Solidity Zero Six, and it introduced a couple of breaking changes as well as new features. So in this video we're gonna go over the main changes and see how this work. So let's go to remix and we're gonna change the setting of the solidity compiler to use the correct version it. Then in our smart contract we use the pragmat statement for solidity 0.6. So the first breaking change is that now if you want to remove an element from an array, you have to use the pop function instead of decreasing the length property. So before, for example, if you had an array of integer and if you wanted to decrease the size of this array, then you had to decrement length property like this.
00:00:59.520 - 00:01:41.820, Speaker A: But now if you want to remove the last element, then you use the pop function. Next, there are three new keywords related to function, interface and function overloading. So let's see how this work. So let's say that you have another contract that has an unimplemented function. For example, you have a function foo here, but you don't declare its body, and in a contract that inerrate from the smart contract then you can implement the foo function. So here, for example, you could provide the implementation like this do stuff. Okay, but in solidity 0.6
00:01:41.820 - 00:02:25.608, Speaker A: it's not going to let you do this. In the parent smart contract, if you have any unimplemented function, you need to add the abstract keyword to your contract. Second, for the function itself that is not implemented, you need to add the virtual keyword. And finally, for the function that actually implement the interface, then you need to add the override keyword. Next, it's not possible to shadow a state variable in a smart contract that inerrate from another one. So for example, here in the parent smart contract, we declare this integer a variable. Before it was possible to shadow this variable like this in a child smart contract, but now this is disallowed.
00:02:25.608 - 00:02:57.460, Speaker A: Next, the fallback function has been split into two different functions, so you cannot use this notation anymore. Instead, you have two function. Now, the first one is receive and the other one is fallback. So both of these function have to be declared with the external keyword. They cannot accept any argument and they can't return anything. And the receive function has to be payable. Fallback function can optionally be payable.
00:02:57.460 - 00:03:48.072, Speaker A: So here is how it works. The receive function will be executed if you send a transaction to the smart contract without calling any of its function, and you can optionally send some ether in your transaction. However, if you call a function that does not exist and you have a fallback function, then the fallback function will be executed. And if you don't have a receive function but only a fullback function that is payable, it will not only receive transaction that target function that do not exist, but it will also receive the transaction that were previously handled by receive. So the receive function is good to process. Incoming ether transfer and fallback function can be interesting in proxy smart contract, for example. All right, so these were the breaking changes.
00:03:48.072 - 00:04:36.572, Speaker A: And next we're going to see the new feature of solidity 0.6. Now it's possible to define struct or enums outside any smart contract. For example, I can define a user struct here and I can use it here in my smart contract or in any other smart contract in my file. So that's very convenient if you want to share some data structure across different smart contract. For example, you could have a file where you define all the struct and you import this file in a different smart contract that need to use this struct. So this way you have the definition of your data structure in a single file. Next, it's now possible to return some struct from function and also arrays of arrays.
00:04:36.572 - 00:05:26.048, Speaker A: So for example, now you can do this, can define a function that returns a struct before it wasn't possible and you had to destructure all the field of your struct. So that was quite annoying. So actually in three, DT 0.5 there was a hack to enable this feature, and that was the ABI encoder V two pragmas statement. So you needed to use this pragmas statement, but that was considered experimental and not production ready. In studio T zero six, if you want to return struct or arrays of arrays, you still have to use this pragma statement. But this is a bit misleading because even though we still have this experimental word, this is actually production ready and not experimental anymore.
00:05:26.048 - 00:06:13.008, Speaker A: Next, it's not possible to convert an address into an address payable. So here, if you have your address a and you want to cast this into an address payable, then you can do so with the payable keyword and you pass it your address before in three DT 0.5 there was a hack to do the same thing, but it was more complicated. So now by using a language keyword, we can do this very simply. Next, it's now possible to recover from errors in smart contract with try catch. So it works only if an error happened in another smart contract that you are calling from your smart contract. So here I have my main smart contract, my contract and it's calling another smart contract and it's calling the function foo.
00:06:13.008 - 00:07:03.856, Speaker A: And maybe that this function foo is going to throw an error. So before in 30 t 0.5 when this happened, the whole transaction fail, but now it's possible to catch this error. So here in my main smart contract I'm calling this function foo and I put it inside a try catch block. So if no error happened, then the return value will be assigned to the v variable here and this branch will be executed. If an error happened because of a require statement, then this branch will be executed and for other error, for example triggered by a revert, then this branch here will be executed. So after all these changes, I use solidity zero six to recompile some old contract written with solidity zero five and in most cases there was no problem.
00:07:03.856 - 00:07:11.540, Speaker A: If you want to get better at solidity, check out my full course on Sri tea on YouTube where I cover all the aspects of the language.
