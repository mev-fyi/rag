00:00:00.250 - 00:01:04.010, Speaker A: If you know a little bit about smart contract, especially in solidity, you certainly have noticed that it is possible to specify to your smart contract how a variable or function can be accessed. The functions and data you store in your smart contract can either be external, internal, public, or private. And today we're going to focus on the data that you deemed private by marking it like so, thinking nobody can. You can see it, perhaps while in reality it's not that simple. If you're new here, I'm Stefan and on eat the blocks we help the web two developers get into web3 before we jump in a quick mention regarding the three months web3 mentoring program, you can enroll right now and start your journey into blockchain with a mentor. Amongst other things, you'll learn how to build a portfolio of web3 projects, how to create your online presence as an expert, and how to access a network of like minded developers. So what private in the context of a smart contract mean? Private is one of solidity's visibility specifier.
00:01:04.010 - 00:01:34.218, Speaker A: As I mentioned earlier, there are four of them, external, internal, public, and private. An external contract can be called from other contracts and via transaction. Anything that is internal can only be accessed from within the current contract or contracts deriving from it. They cannot be accessed externally. If it's public, it means it can be called internally or via message calls, and private means that it can only be accessed from within the current contract. And that's it. Derived contract cannot access it.
00:01:34.218 - 00:02:12.178, Speaker A: But just like solidity warns, making something private or internal only prevents other contracts from reading or modifying the information. But it will still be visible to the whole world outside of the blockchain. There you go. Now let's see how that works. For the code, we're going to use an example from solidity. By example, smart contract programmer on YouTube made a video of it using the robstand network and JavaScript. And since then things have changed a little bit with the Ethereum merge, with most Ethereum testnets getting deprecated, for example, infura has only kept Goli and added a new one, sepolia.
00:02:12.178 - 00:02:51.220, Speaker A: But anyway, what we're going to do, we're going to deploy that contract to Goli and we'll use Python to communicate with our contract. And if you don't have Python installed, don't worry, we're going to use an online Python notebook. So relax. Okay, let's have a quick peek at the contract before we do the setup. What we're going to do here is accessing and reading the content of a specific memory slot of the smart contract. So first we've got a few public state variables, just so we can highlight how memory is allocated. So for the first one, a uint is a 32 bytes state variable that takes the whole space of the memory slot zero.
00:02:51.220 - 00:03:29.178, Speaker A: In the next slot we can write an address plus a boolean plus a UN 16 which will take 23 bytes of storage. So you still have nine bytes free in this location. Then we've got a private byte 32 which take the whole slot number. Two constants are not written in storage. Next we've got an array of bytes 32 where each element takes one slot memory. So for an array of three elements we'll have slots three, four and five taken. Then we've got an object user that can contain a unint ID and a bytes 32 password and we're going to use that with the array users.
00:03:29.178 - 00:04:01.958, Speaker A: Okay, so far slots zero to five are taken. The length of the array users is stored in slot six. But the user data itself is not here. It's not in slot six or seven. There is a formula to find when the data is located, and it is the ketchup 256 of the slot number plus the index times the element size. In our case, if we look at struct user, the element size is one unit plus one by 32, so two. Each struct takes up two slots of memory.
00:04:01.958 - 00:04:43.314, Speaker A: Therefore user one data, for example, will be located over there at kchak 256 of six plus zero times two. User two data would be located over there at kchak 256 of six plus one times two extra. Now speaking of indexes, in solidity you can't iterate through arrays. You can't say hey, show me what's inside users index number two like you would do in Python or JavaScript. So the usual way to solve that is to complement a dynamic array with a mapping. And that's what we have here. One index number refers to a particular user data location, and even though the mapping is private, we can still locate a user data from the outside if we know where the mapping is stored.
00:04:43.314 - 00:05:11.422, Speaker A: In this case, we know it's been stored in slot seven. For a mapping, all we need to do is the ketchup to 56 of the key with the memory slot. For example, ketchup to 56 117. Next, the constructor sets the private state variable password. During deployment we've got a function to add some users into the array and the mapping. Finally, we've got two helper functions to compute the slots of our private dynamic array and mapping. But I'll also show you how to use the web3 library to do that.
00:05:11.422 - 00:05:42.378, Speaker A: All right, time for the setup. So we're going to need a few things right off the bat. A goalie endpoint. We'll use infuria, some ETH from a gorely faucet, a bat 32 hex converter, and to call the contract, we'll use a notebook from Google Collab, just because I like notebooks. All right, so if it's not already done, go to Infura, create an account, and create a new key. We'll use Ethereum, so choose web3 API and name your project. Then go to manage key for this particular project.
00:05:42.378 - 00:06:19.100, Speaker A: And under Ethereum instead of Mainnet, choose goalie. Next, let's get some test ETH. The faucet I use is@goaliefosset.com just enter your metamask address and the test ETH should arrive after a few minutes. Now, if you don't see the goalie test network in your metamask, open metamask, go to your icon settings advanced, scroll down, and you should see show test networks. Turn that on. To convert our password to byte 32, I'm going to use web3 type converter.
00:06:19.100 - 00:06:55.924, Speaker A: Next, open your browser and type Google Collab. Connect with a Gmail account. Next, you should be able to open notebook from your Google Drive, a GitHub repo, or upload it. I'll put the link of the repository in the description of this video. Now, I think if you don't have a Gmail account, you can simply go to file open notebook and you can pass the GitHub link right away. And finally, remix. We can copy this contract and in remix, create a new file, pass the code, and we're good.
00:06:55.924 - 00:07:33.358, Speaker A: Let's compile it. Everything's fine. Next, for the environment on the top left, inject metamask and connect your metamask. Now let's create our byte 32 password. Go to web3 type converter, type a word. Next, choose to convert into byte 32, and very important, apply the padding. Now, why are we doing that if you're new to that? In a nutshell, one unique space of memory is 32 bytes.
00:07:33.358 - 00:08:10.190, Speaker A: One byte contains eight bits and can range from eight zeros to eight ones in binary notation, or from zero x to zero Xff in exadecimals. Okay, it's the same thing. Now, discard the prefix zero X, which is just here to indicate that a number is written in exit decimals. Discard that, and we are left with two characters from zero zero to FF. And that's for one byte. Therefore 32 bytes is 64 characters. And that's why we applied the padding, so remix doesn't yell at us.
00:08:10.190 - 00:09:19.942, Speaker A: Anyway. Now I can copy my bytes 32 password and I passed it right here and I can deploy and there you go, our contract is deployed. Now let's just add one or two users, create a new password. Now I can add my first user. Now do the same thing for user two. Okay, we're almost finished with the setup. We need to add the access point to collab.
00:09:19.942 - 00:10:06.934, Speaker A: So go to your infura network endpoint page and copy your Goli URL. And then in google Collab under connect infura right here, you can add the URL like so. Lastly, we need our contract Abi and address. So back to remix, copy the contract address right here and past it right here. Right there for the AbI back to remix again under compiler you can see right here Abi, you can copy that. Now if I pass directly this AbI to my notebook, it's going to take a hundred lines. So I'm just going to reformat it with jsonformatter.org
00:10:06.934 - 00:10:44.530, Speaker A: for example. And now if you pass your Abi right here, and then you compact it, you minify it, and you can copy this right here, you can copy this. And when you go back to Colab under Abi right here, everything should hold in one line and we are all set. It is now time to execute each cell of the notebook. So, to run a web3 on Google Colab, we need to do a few installations. I've already done it, so it's going to be pretty fast for me. Once that's done, you're going to need to restart your runtime.
00:10:44.530 - 00:11:05.030, Speaker A: Okay, so you go to runtime and restart runtime. Then you can run the second cell. It's just for visual purposes. Next, connect to infura. Let's connect to the smart contract. And now let's call the contract. Let's access the memory slots.
00:11:05.030 - 00:11:37.618, Speaker A: For the first slot, slot zero, we use the function getstorage at. With the contract address and memory location, we get the result in exadecimals. And if we convert seven B to decimals, we get 123. Same thing with slot number one. We can see the un right here, we can see the boolean right here, and the rest is my address. But all of that were public. Let's see how we work with a private state variable.
00:11:37.618 - 00:12:09.300, Speaker A: So for slot two, I'll show you two options to get the password. So option one, I can get the data location with getstorage at right here. Then I can isolate the hex value from the hex byte with the hex function right here. In this case, I did both operations at the same time. And then I just use a function that converts that value into a string. Or option two, I use a built in python function to convert the hex bytes straight to a string. So let's run the cell and see how it looks like.
00:12:09.300 - 00:12:51.988, Speaker A: Here's option one with our custom function right here. And here's option two with the built in python function and we get the password. Option two is much faster, so I'll use that for the rest of the notebook. Let's jump straight to slot six. Remember what I mentioned earlier about the formula to find where the data of a dynamic array is located? It is the catch act to 56 of the slot number plus the index times the element size. And slot six only contains the length of that array. So let's see how many users have been stored and we get two users.
00:12:51.988 - 00:13:18.464, Speaker A: Let's get the data of the first user of this dynamic array. So first let's find user one location where it starts. So you can use the helper function from the smart contract. So if you remember in the smart contract there is a helper function called get a relocation. So you can use that. Or we can use directly a method from web3 which is called solidity shut three. It's going to do the exact same thing.
00:13:18.464 - 00:13:56.400, Speaker A: So let's run this cell. Okay, so we can see that it starts at this location. The user one data starts at this location right here. Now for the password, if you look at the struct, the password is right next to the Id. So by incrementing the hash of the ID by one, we should get the location of the password. Okay, so here we just get the Id of the first user zero. But for what I just said, if we increment the hash by one, so in this case three f incremented by one becomes 40 and that's the location of the password for user one.
00:13:56.400 - 00:14:34.610, Speaker A: And so next we're going to do exactly like we did before. We're going to use the function getstoritat with that new hash and we get the user one password. Same thing for user two. If you increment the hash of the user by one, you will get the user two ID location. And here's the id. We increment the hash by one. To get the password hash location, we convert it to a string and here's the user two password.
00:14:34.610 - 00:15:07.760, Speaker A: Next, where's the mapping slot? Seven is empty. That's not where the data is stored. Entries of the mapping are located, like we said before, at the k track, 256 of the map key and the slot number. So let's see if we can get something for user number two, the last one. So to compute those location, we've got our helper function in the smart contract, the getmap location function right here. Or again, we can directly use solidity sha three from web3. So let's run that.
00:15:07.760 - 00:15:35.286, Speaker A: And there you go. Here's user two location. Okay, let's run the next cell. And so, just like before, the first element is the ID of the user, and by incrementing the hash by 128 becomes 29. And if we convert that hash, we get the user two password. There you go. So as you saw, even though those values were private, we could easily access them.
00:15:35.286 - 00:16:13.178, Speaker A: Okay, so how do you prevent from this? The best advice is simply to not store anything sensitive in your smart contract. Store that off chain and make your smart contract access it using a solid oracle like chain link, for example. Before I end this video, a quick mention again about the three months Web three mentoring program. With this program, you get a weekly technical call, a weekly nontechnical call as well. When you can get advice on your career, social media presence, et cetera. You also get one weekly one on one call with your mentor. You get access to the private discord chat, as well as the lifetime access to all video courses and future updates.
00:16:13.178 - 00:16:22.420, Speaker A: Register now@eattheblocks.com. Web three mentoring program thank you for watching. You can watch more videos about security right here. See you in the next one.
