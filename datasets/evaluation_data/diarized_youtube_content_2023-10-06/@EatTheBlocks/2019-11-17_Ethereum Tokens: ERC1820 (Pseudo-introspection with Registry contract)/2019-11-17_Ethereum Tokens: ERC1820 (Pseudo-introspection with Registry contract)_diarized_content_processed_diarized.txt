00:00:00.330 - 00:00:49.126, Speaker A: Hey, this is Julian and you are on idoblox. In this video I'm going to introduce you ERC 1820. This standard simplifies contract interaction by allowing smart contract to discover which function other smart contract implements. So that's similar to ERC one six five that I've described in the last video. However, in the case of ERC 1820, there is a separate smart contract to store all the function interfaces. But what is really interesting is that a smart contract that declare a certain interface does not have to implement this interface itself, but it can delegate the implementation to another smart contract. And this has a big benefit because now not only smart contract can have function interfaces, but also regular ethereum addresses.
00:00:49.126 - 00:01:22.386, Speaker A: All right, so let's see how this work in detail. So I'm going to scroll down in a specification of ERC 1820. So first we have an implementation and I'm going to explain how it works later. But first we're going to see the deployment method of the registry smart contract. So this is called the keyless deployment method. So with this deployment method we can know in advance the address of the registry contract, and it's going to be exactly the same on each network. So Mainnet, Rapstan, et cetera.
00:01:22.386 - 00:01:51.978, Speaker A: So that means that there will be only one registry smart contract per network. Also, nobody will know the private key of the address that deployed the contract. If you want to know the detail of how it works, you can read the ERC 1820 specification. But what I just said is the most important to understand. All right, so let's see what are the different roles in this system. So first you have the target address. So that's the contract that will declare interfaces.
00:01:51.978 - 00:02:30.566, Speaker A: So this can be an address or a smart contract. So the manager is going to declare to the registry which address implement a specific interface for a target contract. So by default, alt target contract are their own manager, but they can make another address the manager. Then there is the implementer. So that's a smart contract that implement an interface on behalf of another address, or it can be the target contract itself that is also the implementer. Then we have the registry. So that's really the central point of this system.
00:02:30.566 - 00:03:11.034, Speaker A: This contract will be able to tell you what is the address of the implementor of a specific interface for a specific target address. And finally we have the user address. So the user address wants to call a specific function on the target smart contract. So it wants to know what is the implementer for the function that is trying to call. And for this it's going to first ask the registry contract. Okay, so now that we know what are the different roles, let's see what kind of action they can take. So first a target contract can transfer his role of manager to an other address and this other address.
00:03:11.034 - 00:03:45.446, Speaker A: And this manager will be able to set the implementer address of a specific interface for a target contract. And finally, a user contract can query the registry to know what is the implemental address for a specific address for a specific target contract. So this is a high level description of how the system worked. So now let's see the official implementation. So I've copied the official implementation in remix. So first here we have an interface. So implemental address.
00:03:45.446 - 00:04:22.730, Speaker A: If they are different from the target, then they have to implement this function here can implement interface for address. So then we have the registry contract itself. So let's scroll down and here we have this get interface implementer. So user contract will call this function to know what is the implementer of a specific interface. Then we have another function set interface implementer. So this will be called by the manager of a specific target contract. And then we have this function setmanager.
00:04:22.730 - 00:04:57.242, Speaker A: So the manager of an address can transfer the manager role to another address with this function. Then you can also get the manager of any address. And here we have this function to create an interface name. So that's basically the hash of the interface name. So if your interface is a known standard like Yasi 20, then you should use the official name of the interface. Otherwise you decide your interface name. It's also possible to use the convention of Yasi 165.
00:04:57.242 - 00:05:41.506, Speaker A: So if you don't know what is Yasi 165, check out the previous video in this series. If you decide to use ERC 165 to name your interface, make sure that the implemental smart contract also implement ERC 165. Because the registry is going to forward the call to the implemental contract to check which interface it implements. And after you also have some function related to ESC 165, including some caching. But I'm not going to explain this, this is a little bit advanced. By the way, I know that there is really a lot of information to digest about Ethereum tokens. So I have prepared a very compact cheat sheet with all the most important information about Ethereum tokens.
00:05:41.506 - 00:06:05.614, Speaker A: You have all the standard like yes 27, 20, 111, 55, et cetera. So to get it for free, all you have to do is to follow the link in the description. Description. All right, so that's pretty much it for ERC 1820. You can check out the official documentation if you want to know more about it. And in the next video, I'll introduce ERC triple seven, which is an improved version of ERC 20. And ERC two two three.
00:06:05.614 - 00:06:10.666, Speaker A: So make sure to watch this video. Thanks for watching and see you for the next video. Bye.
