00:00:08.880 - 00:00:52.694, Speaker A: And we are live. Welcome for this live stream where you will learn solidity by building seven smart contracts. This will be beginner level smart contracts, so you don't need to have any prerequisite. This is completely for beginners and you won't have to install anything because we will do everything in your browser, so it's very easy to get started. We will use the programming language called Solidity, which is for spot contract on the Ethereum blockchain. This is the most in demand skill in the blockchain industry. So if you are new here, my name is Julian and I've been a blockchain developer since 2017.
00:00:52.694 - 00:01:31.734, Speaker A: And on it, the blocks help you to become a solidity pro. And talking of solidity Pro, actually we have a solidity bootcamp that is starting 1 July. So basically in one month you will become a solidity developer at a professional level. So we will go much deeper than what we will do in this video. So we have 30 seats total. I think we already have one third that is gone. So if you want to register, basically you go to this website, idoblox.com
00:01:31.734 - 00:01:52.654, Speaker A: bootcamp. You register and we start together on July 1. All right, so back to this tutorial. So yeah, first of all, welcome everybody. In the chat. I see a few people here. Doc evn Chen Isan.
00:01:52.654 - 00:02:40.074, Speaker A: Good morning. Good morning. Okay, so before we talk of smart contract, we need to talk very briefly of the blockchain and of Ethereum because you need to have just a few basics. Don't worry, it's just going to be a few minutes. So what is a blockchain? So blockchain is a network of computers that are interconnected. So each computer that run the software of the blockchain, we call this a node, and this is a public network, permissionless, meaning that everybody can participate. All you have to do is download a software and run it and you will automatically connect to the other nodes on the network.
00:02:40.074 - 00:03:16.504, Speaker A: And this is something that is really everywhere that is running everywhere in the world. So you have some nodes here in Asia, you have some node in Europe, in America. It's really global. And so what this node do is that they maintain a database, but a distributed database that is composed of unit called blocks. That is the primary unit of the blockchain. You know, blockchain, chain of blockchain. And all those blocks are related to each other.
00:03:16.504 - 00:03:59.108, Speaker A: And in each of these block, if we zoom in, a block has two category of data. One category is metadata. So some metadata about the block. For example, the timestamp there's also a link to the previous block so that all the blocks are connected. And then we have another category which is much bigger, which is all the transactions. So block, basically the whole purpose of a block is to contain transactions. And transaction is basically a sign data package where users of the blockchain will describe what they want to do.
00:03:59.108 - 00:04:46.314, Speaker A: And so the basic action of a blockchain is basically to send money to someone. So typically you have someone like Bob, who sent a transaction to Alice, where in a transaction he says, hey, I want to send some money to Alice. He will also sign these transactions that we can make sure that Bob really wanted to do this. So it's basically like a digital transfer of money. And so the blockchain is full of these transactions. Okay, so that's the, that's the basics of the data structure of the blockchain. So what are the main blockchains out there? So you have bitcoins, where basically most of the transaction are just simple bitcoin transfer.
00:04:46.314 - 00:05:20.804, Speaker A: Then you have Ethereum, which is a little bit more interesting because you have a different kind of transaction. We can go much further than just sending money. And then you have many other blockchains, but really the most important one is Ethereum, because many, many blockchains are actually based on the technology of Ethereum. So this is why we focus on that. So on Ethereum, you have the basic transaction that I mentioned before. So Bob is going to send some money to Alice. You can do this on Ethereum, no problem.
00:05:20.804 - 00:06:04.882, Speaker A: But on top of it, you have another kind of transaction which is a little bit more advanced, where basically you are going to interact with a smart contract, and the message of your transaction will be, I want to execute this program. So basically this smart contract with these parameters. So you specify which function you want to call and which parameter to pass to these functions. And so when we program smart contract, this is for this type of transaction. All right, so a smart contract, that's a small program that exists inside the Ethereum blockchain. It has different component. The first one is an address.
00:06:04.882 - 00:06:42.774, Speaker A: So that's basically an id that is going to uniquely identify a smart contract. It's start by zero, x plus a series of number. It's like an id for smart contract, a postal address for smart contract, if you want, or like, like a domain name for websites. A smart contract can transfer money. So that's a big difference with a normal web two program. With a web two program, there is no built in ability to transfer money. You need to connect to the API of stripe, for example, or PayPal if you want to do this.
00:06:42.774 - 00:07:28.314, Speaker A: But with smart contract, it's at the smart contract level, there is no need to interface with any sort of API built in. Okay? So that's why smart contract are so powerful. And another thing that you can do with smart contract is attach data to it so you can store data in a smart contract. And ultimately all of this will be stored permanently in the blockchain. And the last thing and a smart contract has is some code. So you basically deploy smart contract, it has a certain code and this code can never be modified. Okay? That is what we call immutable.
00:07:28.314 - 00:08:06.846, Speaker A: And so it's why smart contracts are so powerful, because basically once you deploy them, it's never possible to censor them. They are just deployed and they are basically waiting for transaction to activate them. So they are a little bit like Ethereum lessener if you want. There is no need to to start them or stop them, you just deploy them and they are on all the time. Nothing happen by default. But when you set a transaction, they will respond to this. Okay, so really that's the overview of a smart contract.
00:08:06.846 - 00:08:51.885, Speaker A: And so now let's talk of programming language. But first let me get some water. Excellent. Some nice fresh water because it's really, really hot here in Taiwan. So the programming language for smart contract is called solidity, okay? And so as you can see, it's, the syntax looks similar to JavaScript, but it's actually quite different. And so today this is this programming language that we are going to cover. Um, and yeah, and so that's, that's basically it for the, the base, uh, the theoretical knowledge that you need before starting smart contracts.
00:08:51.885 - 00:09:19.602, Speaker A: Okay? So you know, it just took a few minutes. And so with this, now we can, we can start the coding part. So you can find, go load a website that is called remix, ethereum.org. i will put the link in the chat. This is what we called a, an online code editor for smart contracts. So that's free to use. There's nothing to install.
00:09:19.602 - 00:09:55.732, Speaker A: You just load the website and you can use it directly. So it's really awesome. And the way it works is that, so on the left you have the menu bar here. Here you have a contextual menu that is going to change based on which menu is selected by default. This is the file Explorer, which is how you can manage your files. And then here the central part, this is where we are going to code. So let's go on the file explorer and we create a new file.
00:09:55.732 - 00:10:17.176, Speaker A: So create new file. And we're gonna call this, for example, my, my contract. My contract. Dot cell. Okay, so here the file extension for smart contract is dot. So. And here in this part we are going to write our code.
00:10:17.176 - 00:10:45.174, Speaker A: So I'm going to increase the font size because I think it's a little bit small for you guys. All right, let's see, increase this. Yes, probably better now. Okay. Okay, amazing. So for the first smart contract we are going to do something really, really simple. Oh, by the way, I forgot something, one important detail.
00:10:45.174 - 00:11:21.400, Speaker A: So let's go to the solidity compiler here. And that's how you can choose which version of solidity you are going to use. So you click here on this drop down and you can see different version. So by default always use the latest version. So now it's zero 8.26, but it might be another version in the future. And here, make sure that you have ticked auto compile because what it's going to do is every time you change something in your smart contract it's going to compile it again and it's going to show you if there is any error or any warning.
00:11:21.400 - 00:12:06.238, Speaker A: Okay, and so compilation, what is this? So basically smart contracts in solidity, they need to be transformed into a, another language that is a little bit lower level so that Ethereum can understand it, because Ethereum doesn't understand solidity. So you need to translate solidity into another language that what we call the EVM bytecodes. No need to get into the detail, but basically some elementary instruction that can be understood by the blockchain. And for this we need the solidity compiler. Okay, so here we have auto compile selected. Okay, so let's go back to the file Explorer. And now we're going to start our first smart contract.
00:12:06.238 - 00:13:08.772, Speaker A: All right, so the first thing you need to do is to write Pragma Solidity 0.8, point the version you are using and you terminate this by a semicolon. Here all the statement in solidity are terminated by semicolon. So what, why are we doing this? Because we've already selected the compiler that we want here. So the reason why we need to add this statement is basically to, to tell the solidity compiler that this smart contract is meant to be compiled by this version. So if in the future by mistake you select another compiler and you try to compile this smart contract, for example, let's say you select an earlier version, okay? And in this earlier version maybe that there are some stuff that do not exist yet. So if you try to compile a smart contract there will be some error, but because of this now the compiler will know that there's a problem.
00:13:08.772 - 00:13:28.544, Speaker A: It will tell you hey man, here you say that you want zero 8.26, but me, I'm just zero 8.10 for example. So there is an error. So it's just to make sure you use the right compiler. So once you've done that you need to define a smart contract. So you do this with the contract keyword.
00:13:28.544 - 00:14:19.658, Speaker A: And by the way, here is number one, hello world. And so you call this hello world, okay? And you open the curly braces. So this is like an object, okay? And inside we're going to have some data and we're going to have some function to interact with these data. So either modify data or read it. And in the same file you can have different smart contract if you want. And usually the convention is to have the smart contract to have it the same name as the file. So here our file is mycontract Sol, so let's call it the same way.
00:14:19.658 - 00:14:56.994, Speaker A: You don't have to do it, but this is a good, good practice. Okay, so next what we're going to do is to define a function. So this is going to be a very simple smart contract that just returns a string. Okay, so here let's define a functions with the function keyword. So everything in, in blue is a keyword of the three dt language. So that means that this is spatial and you cannot use it for, for naming. So here the name of our function is hello and between parentheses here.
00:14:56.994 - 00:15:25.792, Speaker A: So this is where you would specify argument if you want to pass some data to this function. But in our case there's nothing. After we need to use a few special keywords. So one of them is called external. External means that this function can be called from outside of the contract. So some function can be internal only, can only be called from inside the smart contract. But that's not the case here.
00:15:25.792 - 00:16:01.424, Speaker A: Pure, that means that we are going to return, this is a read only function, it doesn't modify the blockchain. This is what pure means. Then we need to specify the type that is returned, because solidity is what we called an explicitly typed language, meaning that you need to define the types that you use. So this is different from JavaScript. For example, in JavaScript you don't define any type. You know, there are types, but JavaScript is smart enough to figure it out by himself, by itself. Sorry.
00:16:01.424 - 00:16:46.330, Speaker A: So now let's define the type of our return variable here. So it's a string, and then we need to use the memory keyword. So you know what, this is your first smart contract. So I don't want to get too much into some specific detail with the memory. So just remember that when you declare the type of a string, it's string memory, not just string. All right? So now let's open the curly braces here and everything inside will be inside the function. Okay? So if I code here for example, that's, that's outside the function but here that's inside the function.
00:16:46.330 - 00:17:16.110, Speaker A: Okay? So now this is going to be a very simple function. So we use the written keyword to say that this function is going to finish and it's going to return some data here. Very important detail. This return doesn't have an s, but this return here has an s. Okay, so different, different keywords. Now between double quotes we're going to put hello world. Okay, so terminated by semicolon.
00:17:16.110 - 00:17:51.524, Speaker A: Alright, so now what we're going to do is we're going to deploy this contract. So we go in the deploy and run transactions tab here. So you see that this menu is going to change. So we're going to deploy our smart contract on Remix VM Cancun. So what does this mean? Remix VM means that it's a local blockchain that only runs on your computer. So it's not the real blockchain of Ethereum. It is like a safe playground that you can use just to get started.
00:17:51.524 - 00:18:24.190, Speaker A: Cancun is just to target the latest version of Ethereum. So it's deep different from the version of solidity. It's a different concept, but by default this is the one that will be selected. So you don't need to do anything. Now below we have another, another input here where we can select the deploying account. So an account that's basically, that's identified by what we call an address. This thing here, zero x five b, etcetera.
00:18:24.190 - 00:19:00.996, Speaker A: It's like a bank account number. Okay? So anybody can create an account. You can create as many as you want. And each of these account will have some ether. You will need to buy it of course, but it can store some ether and you can also send a transaction because it has, it is associated to a secret that we call a private key. So what is good in remix is that you don't have to manage any of this, okay? You just click here and you have those accounts that are already created for you. The private key, you don't need to manage them.
00:19:00.996 - 00:19:23.914, Speaker A: It's managed by remix and each of them is pre funded by 100 ether. So of course this is not real money. Okay. This is because we are on this local development blockchain. So we can do anything we want, including creating some fake ether. And that is just for development. So you can just leave the first one selected.
00:19:23.914 - 00:19:55.798, Speaker A: That's perfectly fine. Now gas limit. So gas, that's basically related to the concept of transaction fee. So when we send a transaction to the blockchain, we need to pay so that this transaction is included in the blockchain. And this is measured with an abstract unit called gas. But I don't want to waste too much time on this today because you can get started with solidity without really understanding gas. So just leave the default.
00:19:55.798 - 00:20:25.730, Speaker A: It's just going to, it's going to be fine. Then value, you can specify how much ether you want to send. In this transaction here you have different units, but we're not going to send anything for this one. And here you select which contract to deploy. And now if you click on deploy, it's going to deploy. It makes sense, right. And in this part of your screen you're going to see this new contract appear.
00:20:25.730 - 00:20:52.584, Speaker A: So originally it's like this is folded so you have to unfold it. So you have the address of the smart contract. If you click here, you can see that this is the different from the deploying address. And every time you deploy a new contract, it's going to have a different address. Okay. And after that what we can, so you can see the balance of the contract. Now it's zero.
00:20:52.584 - 00:21:19.878, Speaker A: And here we have a button to interact with our function. Hello. Okay, so if we click on hello, we're going to execute this function and we see in return hello world. Okay, so that is working. And now if you, if you open, if you extend that, you can see the, that you've called. So you can see two things here. First, the deployment transaction.
00:21:19.878 - 00:22:10.324, Speaker A: You can expand that. So it tells you transaction mine and executed a few transaction hash. So that's an id that you can use to identify this transaction. However, because this is not on the real Ethereum blockchain, if you try to search this in what we call a blockchain explorer, you will not find it. So there is something called Etherscan, that's a blockchain explorer. That is, this is basically a way to explore the transactions on the blockchain. Okay? But here if you, if you copy paste this thing, this transaction hash, you will not find it because we've deployed it on this local blockchain.
00:22:10.324 - 00:22:39.912, Speaker A: This is not deployed on the real Ethereum blockchain but that's fine because we don't need the real Ethereum blockchain just for learning. You can see the contract address here that was created zero XDC, something that's same as here. You can see the deploying address. Zero x five b. So it is indeed zero x five b. Then you can see gas. So all of this, this is related to the transaction fee.
00:22:39.912 - 00:23:04.640, Speaker A: But as I said before, we're not going to spend too much time on this. And yes, so that was for the deployment transaction. And by the way, this is green, meaning that it was a success. Now what about the other one? The other one is not a transaction. This is a call. So a call doesn't cost money. A call is when you execute a read only function so you don't modify the blockchain.
00:23:04.640 - 00:23:32.512, Speaker A: You just read something and once again you can see who triggered this call. You can see the function that was called and that's it. So yeah, that's basically the first smart contract that we did. So you know what, I'm going to copy paste this in the chat. Let me see if. Yeah, so copy paste this. Okay.
00:23:32.512 - 00:24:02.798, Speaker A: Go to remix and play with it. Okay, so create a new file, copy paste this. And oh by the way, you missed the pragma statement. You will need this as well. Okay, let me, let me copy paste it again. Alright, so copy paste it in a file then deploy it with this tab. Deploy and run transaction, click on deploy, click on hello and verify that you can get hello world.
00:24:02.798 - 00:25:04.864, Speaker A: All right, so you know what, I'm going to wait 1 minute here. Okay? So to let you guys do it because I want to show you that really everybody can create their first smart contract. Okay, so you understand what you need to do. You copy paste this in remix and you deploy it and you execute to the hello, the hello function. Alright? So I'm going to leave you 1 minute to do it. It. Do you guys understand what you need to do? No news.
00:25:04.864 - 00:25:55.882, Speaker A: No news is good news. All right, well I hope you guys managed to do it. We're going to continue with the next smart contract. So this is the hello world smart contract. It's basically the most simple kind of smart contract you can have. That's a good, it's good to begin, but we need something a little bit more advanced if you want to learn. So now second example is simple storage, right? So simple storage, what is that? That's a contract where we're going to store, we're going to define some data inside and we are going to create some function to interact with this data.
00:25:55.882 - 00:26:31.194, Speaker A: So how we define data in a smart contract with the uint. So you need to declare it at this level outside of any function. First you declare the type of the variable. So if it's an integer we use the uint type public. That means that this data can be read from outside the blockchain. So here when we will deploy the smart contract, you will see a data button here. So we finish this by semicolon.
00:26:31.194 - 00:27:26.006, Speaker A: So now we have a data, data variable defined in our contract and this is going to be stored in the blockchain. Okay, so next we are going to define a function to interact with this data. Okay, so function, and then we're going to call this set, so that function to update the value of, to update the value of the data. And it's going to receive an argument, underscore data, okay. And external, so we can call it from outside. And now we're going to update the data variable. So super simple, okay, and now let's create another function to read the value of data.
00:27:26.006 - 00:28:07.174, Speaker A: So we actually don't need it because data here is public. We can already read it, but just for the sake of the exercise, let's just do it. So external, since this is read only, you might be tempted to put pure like we did previously. But in this case it's not going to be pure, it's going to be view because we are going to read from the blockchain from, from a, from a variable here. If we don't read from a variable, if we return something like a static string or a static number, then it's going to be pure. Now we read from a variable, so that's view. And then we specify the returns type.
00:28:07.174 - 00:28:48.846, Speaker A: Okay, so then you int, so this is the type that we have in return. And now what we do is we use the return keyword data. Okay, and that's it. So now we go to the deploy and run tab and we're going to deploy that. Let's clear the previous contract we had deployed. Okay, let's click on deployed. And if we click on get, so we have the default value of data, which is zero because that's the default value for the uint type.
00:28:48.846 - 00:29:15.386, Speaker A: Now if you go to set, so you can see this is a button with a different color because that's a function that actually modified the blockchain. Let's pass it ten. For example, you type the argument here, click on set. So you can see here the transaction was mine. You can see it in the console. And now if you click on get, you see that this is ten. So this is working.
00:29:15.386 - 00:29:55.894, Speaker A: And by the way, you can also read the value from the data button here. It also gives you ten. Okay, so this is working. So that was a contract slightly more complex. So now let's do another contract a little bit more advanced. So that's just going to be a counter contract that can count. So once again we define a variable that we call count this time, and with a function that we call increment.
00:29:55.894 - 00:30:53.364, Speaker A: Okay, and we are going to increment it. So here it's going to take, it is the same thing as if you do count, equal count plus one. So you read the previous value of count, you add one, and you store everything into count. Okay, first you evaluate the right side, the right side part, and then you put everything on the left. Okay, and so we can increment with this. Now how about decrementing? So let's try to decrement same, same function signature here, external. And for count we have the other operator, which is the same thing as can't equal count minus one.
00:30:53.364 - 00:31:56.814, Speaker A: Okay, so now the problem is, what happened if we try to decrement when you int, when the count is already equal to zero. The thing is, with uint you only have positive integers, so 0123 etcetera. But we don't, if you already had zero, we cannot, we don't want to, actually, we cannot go to minus one. So we should throw an error here. And for that we can use a required statement, which is, which allow you to define a condition. So here we want to make sure that count is strictly superior to zero. And if that is not the case, then we're going to show an error with this description, count is already at zero, okay, and then after that function get count.
00:31:56.814 - 00:32:48.540, Speaker A: So this one will be to read the data of the count variable. So we actually don't need it also because this is public here. So we already can read this directly. But for the sake of the exercise, let's just do it. So here this is an external function view, because this is read only returns uint, and we're going to return count, okay, and after that we, let's deploy it. So let's clear here the previous contract, we deploy it and so the initial count is zero, okay, so let's increment, now it's one, let's increment again, now it's two, let's decrement, now it's one, let's decrement again. Now it's zero.
00:32:48.540 - 00:33:13.364, Speaker A: And finally, if we do it again, now, we're already at zero. Then we should see an error. And here, yes, you can see the error. The, you can see the Red Cross and it tell you revert. No, no, no reason provided by the contract. That's basically the error message count is already at zero. That's what we have here.
00:33:13.364 - 00:33:48.344, Speaker A: Okay, so now we know how to do something a little bit more sophisticated. Are you guys following here? I see someone. Helen, looks like you have some skills that I could use. Awesome. So let's do our next contract. And now we are going to learn how we can transfer money because, you know, transferring money, that's really one of the main use case of smart contract. So this contract is going to be called a time lock.
00:33:48.344 - 00:34:27.794, Speaker A: So time lock allow you to lock some money in a smart contract for a certain time. Why is it useful? Well, you can use this as a saving account. Let's say that you are struggling with saving. You cannot really discipline yourself. You always spend money. So with a smart contract you can send money to it and with code you lock the money inside and you are sure 100% that this money will never, you will not be able to take this money out before certain time. So let's define the variable that we need.
00:34:27.794 - 00:35:06.008, Speaker A: So first we're going to have an unlock. Unlock time. So in solidity the time is basically represented by Uint because this is what we call a timestamp. So that's a, the number of seconds since 1 January 1970. So that's a convention in computer science, not just in solidity. You can get the current timestamp. For example, here you go in this website, current timestamp, you can see it here, here.
00:35:06.008 - 00:35:51.364, Speaker A: And it keeps moving all the time. So it's going to be, it's going to be a large number like this? Yeah, something like this. Okay, so next thing we do is declare the address of the, the owner of this time lock. So there will be someone own this contract and only this person can restore because otherwise everybody can steal from you. Then we're going to declare special function call a constructor. So this is called only once when you deploy the smart contract. So we're going to pass it an argument, unlock offset.
00:35:51.364 - 00:36:35.382, Speaker A: So that's number of second that we need to wait before we can, we can restrap. And we're going to make this constructor payable, meaning that we can send money to this country, to this constructor. So when we deploy the contract at the same time we will deploy money, send it money. If you don't have this keyword, you won't be able to send money. Okay, and after inside, let's initialize unlock time. So we are going to read the current timestamp and we can get it from a special variable called block timestamp. Okay, so it's going to be this be a big number like this, but that represents the current time.
00:36:35.382 - 00:37:04.324, Speaker A: And we're going to add our offset. Unlock offset. Okay, and now let's, let's define the owner and we're going to read another special variable called MSG sender. This represents the address that deployed this contract. So in our case, this is going to be what we have here. In remix five something. It's going to be this basically.
00:37:04.324 - 00:37:49.116, Speaker A: And so now we need to deploy a define a withdrawal function. All right. And in this withdrawal function we need to do a few check. So remember before I told you we can do this check with the, with the require statement. First we need to make sure that we are after the time lock. So let's read the current block timestamp and it needs to be superior to unlock time that we define in a constructor. And if that is not the case then the error message would be funds are locked.
00:37:49.116 - 00:38:29.044, Speaker A: Okay, and what else after that? Let's define another required to make sure that it's the owner that is calling this. So MSG sender, you know, same special keyword we used before, that's the sender of the transaction. And let's, let's compare it to the owner. So here, two equal sign, meaning that's a comparison. Hey, is MSG sender equal to owner? If yes, that's okay. And if not, let's show this error message. Only owner can withdraw.
00:38:29.044 - 00:39:03.966, Speaker A: I see a question in the chat, I will answer, but first let's finish this contract. And okay, after we need to send money to the owner. So how we do this? Owner dot call. And after we use curly braces value. And after we need to specify how much we want to send. So everything we have in this contract. So address this, that's the address of the contract.
00:39:03.966 - 00:39:29.950, Speaker A: Dot balance. That's how much ether there is inside. And finally here parenthesis with double quote and nothing inside. So if you are calling a function. So here, this owner is not a smart contract. It's what we call an EOA externally owned account. So basically a simple address or a non smart contract if you you want.
00:39:29.950 - 00:39:55.470, Speaker A: But it could be a smart contract. If it was a smart contract, then we can call a function on it and we specify this function here. But in this case there is no function. So here it's empty. And there are a few things that we need to do. So we need to transform owner into a payable address. So you have two type of address in ethereum, in solidity.
00:39:55.470 - 00:40:21.342, Speaker A: One is just address and the other one is address payable. And you can only send money to address payable. Okay, so that's why we need to do this. And we also need to check that the call was successful. So let's read the return value. It's going to return two value, but we just need one. So that's why we have this weird notation here.
00:40:21.342 - 00:41:00.698, Speaker A: And so the first value is going to be a boolean value. So be basically true or false and it will tell you if that was successful or not. And now we require that sent is true by the end, the error message is transfer failed. So I'm sure you guys wonder why, why the transfer might not work. Well, under certain conditions, it's possible, possible to, to reject to. It's possible to reject an incoming transfer. Not if this is an EOA.
00:41:00.698 - 00:41:26.318, Speaker A: So if this is an address like this, that is not a smart contract. It's just not possible to refuse it. Okay, so now smart contract is good, no error. So let's deploy it. Let's see, remove this, let's deploy it again. So here the button is red because that's a constructor where we can send money. So deploy, unlock, offset.
00:41:26.318 - 00:41:46.674, Speaker A: It's going to be ten second value. So let's put here one ether. Here you can see we have 99.9 before the deployment. So let's do, let's do, let's do ten ether. Actually it's going to be more clear. So ten ether, ten second.
00:41:46.674 - 00:42:23.206, Speaker A: And let's click on deploy. Okay, so now we can see the owner is zero five b if we try to withdraw. Sorry, I went a little bit fast here because I wanted to make sure we have an error. So zero x x five b, this is our address here. The owner unlock time. So we can see basically the timestamp when we can unlock and when we try to withdraw a little bit too fast. We had this error message and it tell us fonts are locked because it's too soon.
00:42:23.206 - 00:42:51.296, Speaker A: Okay, and now you can see in the address we have 89 ether. So you can see the ten ether were taken from that. And you can see the balance of the contract is ten ether here. So now if we click on withdraw, the 10 seconds are passed. And now it's going to work. So now you can see this transaction with the green check. And now the transaction worked.
00:42:51.296 - 00:43:18.414, Speaker A: So we have no money left in the smart contract and the money is backed in our address. So everything worked. Let me see the question in the chat. So hello chin, looks like you have some. Not that adding external to the function make the function orange. No, the function will be orange. If this is so it needs to be either external or public.
00:43:18.414 - 00:43:55.278, Speaker A: First of all it needs to be callable from outside the blockchain. But the second thing is it needs to not have a pure of view. If it doesn't have neither pure of you then this is a transaction function and it will be orange. Era of data. I want to become a blockchain dev, where do I start? With your guide? I would say with my guide so you can check out this guy. Ewoks.com roadmap all right, back to our topic.
00:43:55.278 - 00:44:28.414, Speaker A: So yeah, that's basically this time lock contract. So is there any question about this? So this contract is a little bit more complex compared to what we did before. But it's also more interesting because now we start to manipulate money. That's the whole point of smart contract. So let me see Michael, is your rise draw function secure? Afraid there should be some more code to be more secure. Okay, so it's actually exactly the contrary. Okay.
00:44:28.414 - 00:45:08.574, Speaker A: The more code you know there is a, there is a famous joke among developer like junior developers are happy when they add some code and senior developer are happy when we, when they remove code. And this is even more true for smart contract because any extra line of code is potentially a mistake. A bug that you introduce in the contract. So don't measure the security based on the number, the size of the contract is actually even. It's exactly the country. The bigger the contract, the more chance that there is a bug here. It's short, is simple.
00:45:08.574 - 00:45:49.340, Speaker A: Look, we can have another look, but I don't see what can happen here. So first of all, require, require block timestamp. We cannot remove it, call it before the end. This is the critical part, make sure the sender is the owner, then we send some money. We basically send all the money of the contract to the owner. It's also not possible to change the owner, it's only defined once in the constructor and that's it. So no, this function is perfectly secure.
00:45:49.340 - 00:46:42.304, Speaker A: Okay, so now let's move on to the next, next smart contract. So now we will do a wallet that does donation. So wallet, wallet plus donation. Alright, so basically this will be a smart contract that can hold your money and every time you send it some money, it's going to make a small donation to whatever address you want. Okay, so let's define an owner. Let's define a bene beneficiary. So that's the address that received your donation.
00:46:42.304 - 00:47:09.800, Speaker A: Now in the constructor. So that's executed when we deploy the contract. Let's specify who is this beneficiary. And here let's instantiate initialize the owner. So that's the deployer of the contract. Basically MSG sender. And then the beneficiary is going to be what we put in argument.
00:47:09.800 - 00:47:54.908, Speaker A: So we choose who this person is. And after, let's define a function to update the beneficiary. So maybe after deployment you want to change that. So let's do this beneficiary and so function that takes another address as argument. And this is very simple. So first of all, very important security first here, let's make sure that the sender is the, the owner because otherwise anybody can call this function and put themselves as beneficiary. Only owner can update bene fishery.
00:47:54.908 - 00:48:32.268, Speaker A: Okay, then the beneficiary is equal, the new beneficiary. Okay, and after that a function to deposit some ether. So let's make it external and let's make it payable, meaning that we can send ether to it. And what we're going to do is right away we're going to do automation. So let's first calculate here we define a local variable. So it's not going to be persistent. It's only temporary when we execute this function, but after it's going to be deleted.
00:48:32.268 - 00:49:19.508, Speaker A: So donation amount and it is going to be equal to the amount of ether that we send. So here in this built in variable, MsG value, you can know how much ether was sent to this function and we're going to take 1%. So we cannot do this. This is not possible because we don't have, we, we don't have decimal number in solidity. We only have integer. So how we can do a fraction? Well, we can basically multiply it by 1%, like this time one divided by 100. And after we are going to send this to the beneficiary.
00:49:19.508 - 00:50:03.726, Speaker A: So beneficiary dot call and value is going to be donation amount. Here we don't execute any function. So this here, this spot is going to be empty. And let's make sure that the transfer was successful. So we read the return a boolean value and let's make sure that this was true. So otherwise we show an error message transfer failed. So now we can deposit money.
00:50:03.726 - 00:50:33.038, Speaker A: And every time we're going to do a small donation. Yeah, someone asked which id I'm using. This is remix. Remix dot ethereum.org. okay, so sorry. So next we need to create a function to withdraw this. Okay, so withdraw address recipient so we don't have to send to ourselves.
00:50:33.038 - 00:51:22.608, Speaker A: You know, we can choose to restrain with someone else and how much we want to restraw. So two argument here, recipient and the amount. And everything is external. And now we need to do a few checks. So first let's make sure that is the sender. So here, let's copy paste this require msg. Sender is owner only owner can withdraw and after that let's do so if someone else try to steal our money, this is not possible because of this line, let's make sure we have enough money.
00:51:22.608 - 00:52:05.356, Speaker A: So address this dot balance superior to the amount to withdraw and amount to big. Okay, and after, let's do the transfer. So let's copy paste these two lines above, right. So here beneficiary, it's not going to be beneficiary, it's going to be recipient. We specify the argument it's not going to be donation amount, but it's going to be just the amount. Okay. We need to make the recipient payable.
00:52:05.356 - 00:52:57.618, Speaker A: So otherwise the solidity is not going to be happy. And here's Samsung payable because only address payable can receive ether. Okay, so, and the last thing, the final touch. What if, what if we want to receive, receive money directly? So basically, what if we send some money directly to the receive function? So this receive function, this is function that is called if you send ether directly to the contract without calling any function. Okay. Because it's possible to do this, you can just say, hey, transfer some ether to this contract and that's it. But I don't want to call any function.
00:52:57.618 - 00:53:34.682, Speaker A: But unless you have this receive function, it's going to reject the transfer. So let's define it. We need to make it payable. And, and actually here we need to, we need to copy paste this. So here we could do some refactoring, meaning that we can avoid the duplication of code. But you know, for this tutorial we're going to keep it that way. Okay, so now we have everything defined.
00:53:34.682 - 00:53:55.424, Speaker A: So let's try to do it. So for, let's choose the beneficiary. So we're going to choose the second address of remix here. Let's go back to the first one. Okay, so we put the beneficiary here. So that's for the donation. Let's click on deploy.
00:53:55.424 - 00:54:14.624, Speaker A: And now we have. We can see all of our functions. So the owner, zero x five B. That's our current address. The beneficiary is zero x. Absolutely. Basically the second account here.
00:54:14.624 - 00:54:40.898, Speaker A: And now we need to deposit. So let's deposit, for example, ten ether. And so we should have 0.1 ether that is sent to the other contract, which is this one here. So deposit. Let's. Sorry.
00:54:40.898 - 00:55:03.326, Speaker A: Yeah. Ten ether deposit. Okay. And now if we go back in our account here, we can see that the second account has 100.1 ether. So the donation worked, and we can see how ten ether were deducted. And now if we want to withdraw it, basically we can withdraw to ourselves.
00:55:03.326 - 00:55:28.738, Speaker A: So let's copy our own address. We put it to withdraw and click on to withdraw. The transaction worked. And basically. Oh, no, no, no, we. Okay, we forgot to specify how much we want to restore. Okay, so there is 9.9
00:55:28.738 - 00:55:52.246, Speaker A: ether. So here, basically we want to specify 9.9, but if we just. We cannot do 9.9 because ether is specified actually in a very small unit called Wei. So one ether equal ten power, 18 wei. Okay, so let me write it here.
00:55:52.246 - 00:56:24.192, Speaker A: One ether equal ten power, 18 way. Okay, it's like, it's like a very small cent, if you want. So 9.9 power, basically nine with many zero. Okay, so nine. Nine, that's 1234-5678 910, 1112, 13. 1415, 1618.
00:56:24.192 - 00:56:57.184, Speaker A: Okay, I hope I didn't get it wrong. Okay, so let's copy this as a second argument here. Restro Tata. And it tells me what's the. What's the problem here, my friend? Ah, okay. Okay, here. That's real problem.
00:56:57.184 - 00:57:13.784, Speaker A: Okay, let's fix this. Let's call again. Withdraw. And now. Okay, I think I miss. Okay, I miss ten. So let me check.
00:57:13.784 - 00:57:42.804, Speaker A: Let me fix this. So here, now we have eight, nine, one. Let's add a zero. Okay, let's do it again. Withdraw. Okay, now we see all the money was removed. And if we go back to our account now, we can see most of the money is back except the donation amount.
00:57:42.804 - 00:58:16.936, Speaker A: Okay, so let me see if there is any question about this, this spot contract. So the first sign this means you won't get sandwich attacked here. This contract is not vulnerable because we don't. So a sandwich attack is a complex type of hack that can happen when you use a decentralized exchange. But we don't use any decentralized exchange here. So it's much more simple. There is no opportunity at all to.
00:58:16.936 - 00:58:49.920, Speaker A: To be sandwich attacked. Okay, so now that was a more advanced contract. Okay, so if you're still following, congratulations, that's good. So for the next contract we're going to chill a little bit. It's going to be a little bit easier. Okay, so, so we are going to do a name registry, okay, so what is that? If you want to buy a domain name, like I don't know, abc.com for example on the net.
00:58:49.920 - 00:59:39.648, Speaker A: So you go to a domain name registry. So you buy your domain name maybe like 1215 bucks and for one year, two years, etcetera. But we can do, we can have the same principle, the same id for the blockchain. We can associate human readable strings, string of character to addresses. So for example here our address is not really convenient. Like if I ask you to send me some money so I can give you this address and you copy paste it, but it's not really convenient. Like what if I give you better thing like say hey, send some money to Julian ETB, Julian, eat the blocks now dot east for example.
00:59:39.648 - 01:00:32.964, Speaker A: Now it's much more, much more readable. And we actually turn out that we can do it with a system called Ens. So let me show you ethereum name service. So that's basically a domain name registry. But for the blockchain, for example if my crypto address, so this one is actually associated to a domain name. So let me see, I think here in the app we can read it so it, the blocks dot it registered, okay, so here you can see this is my address. Zero x 739 is the same thing, zero x seven, three, nine.
01:00:32.964 - 01:01:37.080, Speaker A: So we can imp, let's implement same system as, as ens but ourselves. Okay? So for that what we need is first let's define a mapping. We're gonna map. So mapping, this is basically a key value store, okay? So in JavaScript we have object like this. So where you have like some, some key value in instead. So for example can be, I don't know, one is associated to, I don't know, like name, hey, user id, one is julian, user id, two is, I don't know, marry, etc. So in JavaScript we have object like this, well turns out in JavaScript in three DT we have the same thing.
01:01:37.080 - 01:02:12.564, Speaker A: So mapping, exactly. That's like a, an array of mapping, okay, so that's mean, it's like if we have a container like this where we have several objects. So first object here, second object here with different value, etcetera. So a container of object, you can, this is the proper way to define a mapping. So let's define. So we need to define the keys. So the keys will be strings and the associated value will be addresses.
01:02:12.564 - 01:02:57.540, Speaker A: And let's call this name so plural because there will be several entry. And then let's define, let's define an owner and let's define a function to register a name. So memory name, okay, let's make it payable because we need to pay to use the registry. So we're going to make it more simple than the real ens. We just pay one time and you register for life basically. So let's make sure that nothing is already registered. So we access the mapping.
01:02:57.540 - 01:03:39.656, Speaker A: And this is how we can read from a mapping. You use the square bracket notation here. It means give me the entry that, that correspond to this name. Okay, and if it has an entry, then so you will see an address, the associated address. And we want to make sure that the associated address is not zero. Why is that so? Solidity is quite counterintuitive, quite spatial. With mapping, you can access any mapping that you want, including mapping, including entries that do not exist.
01:03:39.656 - 01:04:25.796, Speaker A: So here, if we try to read an entry that does not exist, we can still read it, but the address that we're going to get is the default value of the address type, which is the null address. So address zero, that's better. Basically zero x 000000, et cetera. So if we have this, it means basically we don't have this entry. And if that's the case then that, and if, if here, if that is not empty, that means the name is already taken. Okay, so we want to make sure it's empty. All right, why, let me see, why is it not happy here? No visibility.
01:04:25.796 - 01:04:48.534, Speaker A: Specify. Okay, so here's external. My bad. Okay, so now that we have this required statement, let's make sure that we send enough money because this is a pet service. So let's see, let's say that we need to pay 0.1 ether. And in solidity you can specify an ether quantity like this.
01:04:48.534 - 01:05:41.154, Speaker A: So I told you that we cannot do, we cannot have a decimal number, but there is an exception when you specify an ether amount. And the error message is not enough money. Okay. Okay then let's send money to the owner. So basically that's the registration fee and that is MSG value. Okay. And as usual, let's check that the transfer was successful.
01:05:41.154 - 01:06:25.260, Speaker A: Require sent. True transfer failed. Okay, and finally after we have all of this, we're going to do the registration. So now we update the mapping. So to read a mapping and to update it, that's basically the same notation here. And now the new, the owner of this name is the address that call register name. And now what about, what about to get the address of for a specific name.
01:06:25.260 - 01:06:56.144, Speaker A: So this mapping here is public. So actually if you call names, you can already get the address for a specific name. But just for the sake of the exercise, let's do the function. So let's specify the name that we want to get. View read only returns an address. Let's return, we read from the mapping. Okay.
01:06:56.144 - 01:07:15.774, Speaker A: Like this. Right. So let's see, no error here. Seems like it's fine. So let's deploy this contract. Deploy. And now we need to register a name.
01:07:15.774 - 01:07:49.014, Speaker A: So let's register, I don't know ETB either blocks. Okay, and we're going to register. Okay, you know what, let's select the other, another address because zero x five b will be the owner. So let's simulate a user. You know, that's a different address. So second address, zero x absomething. It's going to be the owner of either blocks.
01:07:49.014 - 01:08:16.714, Speaker A: And we, so let's try to register it without sending money. Let's see, let's see what happened. Register name. And here there is an error. Not enough money. Okay, so what if we send not the right amount. So let me see here.
01:08:16.714 - 01:08:44.682, Speaker A: If we send just one way, for example. Okay, one way register name. Also not enough money. Okay, so now let's specify just, just enough. Okay, so in ether. So basically it's going to be, so we cannot specify 0.1 ether here, unfortunately.
01:08:44.682 - 01:09:04.634, Speaker A: So let's do it in way. It's going to be ten power 17. So one, one, two. You know what? Let's, let's use a converter. So way to ether converter. It's going to be easier like this. I don't want to make a mistake.
01:09:04.634 - 01:09:19.826, Speaker A: 0.1 ether. And now this is this value in a way. Okay, so now we go. Got it. Let's go back to remix and let's click on register name. And now this is working.
01:09:19.826 - 01:09:47.998, Speaker A: So if we, let's get the address for, actually it should be get owner. Well anyway, doesn't matter. It's going to work. Get address. And now we can see that the address is zero x absomething. Okay, so, so yeah, so it is working. And here the, the owner.
01:09:47.998 - 01:10:00.014, Speaker A: Let me see. Did we forget something? Oh, okay, my bad. We actually forgot an important part. Okay. I forgot to instantiate the owner. My bad. So how you do that? It's very easy.
01:10:00.014 - 01:10:33.668, Speaker A: You define a constructor. The owner is going to be MSG sender. So whoever deployed this contract. Okay, little mistake here. But anyway the registration function works. We also able to read the address associated to a string. So here, just to be sure, let's try to read another string and we should see the null address here we can see the null address meaning that nobody registered this address, this domain name yet.
01:10:33.668 - 01:10:54.704, Speaker A: So now let's try to do a last thing. Let's try to register in the blocks again, but from another address. And we should have a mistake because there is already an owner. Okay, register. And now we have an error name already taken. Okay, so our smart contract is working. Okay, great.
01:10:54.704 - 01:11:27.734, Speaker A: So let me see the question for sun. You've mentioned that lessons in your bootcamp are recorded and could be seen at any time. Do you offer these videos separately? No, you have to take the bootcamp. But once you, when you take the bootcamp, basically you can watch, you have access to the material forever after. So if you want, you can watch this video during the bootcamp. But, but you don't have to. You can wait if you want or rewatch them.
01:11:27.734 - 01:12:17.714, Speaker A: That's fine. Gtendra, how to deploy smart contract in a real project we're not going to do this today because today this is mostly about solidity. But yeah, deployment, I could do a whole livestream on this. So in a real project, basically key management is very important. So you, you don't want to, you don't want to have the key on your laptop because it's easier to get hacked. So ideally you use an external wallet like a hard drive, a hardware wallet like ledger, and you do the deployment from this address. That's the best practice.
01:12:17.714 - 01:13:01.100, Speaker A: Let me see. Gtendre, can you create an example over Chandnika? Not today, it's more complex. How can I find a first remote job as a smart contract developer? Well, yeah, so good question. So basically depends on your level. But if you are a complete beginner, it really depends on your situation. So if you already are a web two developer with at least a couple of years of experience, you can try to find a full time job in blockchain. This will probably work.
01:13:01.100 - 01:13:54.870, Speaker A: So the usual stuff, follow a course, build your portfolio and start to play on your strengths. For example, if you're a front end dev, maybe you can apply for front end position for a web3 company. But if you don't have a long experience as a software dev and you're pretty new, it's easier to start with freelance. And so you go on website like upwork and you do some very, very specific project, like creating tokens, creation of token. That's something that is super, very, very demanded. And you do a couple of jobs like this and little by little you level up. And once you do this for a couple of months now you're in a much better position to get a full time job in the bootcamp.
01:13:54.870 - 01:14:22.438, Speaker A: We actually train you to start your career as a freelance blockchain dev. This is exactly what we do. So if you guys are interested in that, you want to start in blockchain. Basically in one month we can turn you into a pro and, and you will be ready to get your first freelance gig. So eitherblocks.com bootcamp, helcin saying, I have a job for you to deploy. Contract.
01:14:22.438 - 01:14:52.914, Speaker A: Amazing. You see, you find your first job. Okay, so back to our contract. Now we're going to do our last smart contract. Okay? So let's remove that. And the last contract of today is going to be so the most advanced but the most interesting. If you can understand this contract, it's amazing, means that you followed really well.
01:14:52.914 - 01:15:18.248, Speaker A: So we're going to do a crowdfunding contract a little bit like Kickstarter. So let's say you have a project but you need some money. So you are looking, you want to find some investors. So you can do this with a smart contract. So let's define an owner. That's basically the person that is going to receive the money. Then the goal.
01:15:18.248 - 01:15:58.644, Speaker A: So a financial goal that we need to reach. Then we want to deadline. So a time limit when, when the fundraising is going to stop. And then we want to know how much money was raised. Okay, so now let's, let's define contribution. So that's a mapping of address to integer. And with this we can know which address contributed how much.
01:15:58.644 - 01:16:35.736, Speaker A: Okay, so now in the constructor, let's define few things. What's the goal? What's the duration? Okay, let's minimize this. Okay, so goal, equal goal, not too difficult. Oh, first let's define the owner. So basically the deployer of the contract. And finally the duration. Okay, let me see.
01:16:35.736 - 01:16:53.174, Speaker A: No duration. No, no, no, this isn't right. Deadline. Deadline. And we take the current timestamp and we add the duration of the crowdfunding. So this is second. Now let's create a function to contribute.
01:16:53.174 - 01:17:51.524, Speaker A: Okay, so this is for investors who want to invest in this contract. We need to make it payable so that they can send their ether. Let's make sure that this is not too late. Okay, so the timestamp needs to be inferred to the deadline campaign is over. Okay, now second thing, we need to make sure that you send at least a non value zero, so you can choose which contribution you want to make, but it needs to be above zero contribution. No, contribution must be great greater than zero. Okay? And after that let's, now let's update the contribution mapping.
01:17:51.524 - 01:18:33.200, Speaker A: So we are going. So here there is a typical mistake. What if you do this? Well, if you do this, the problem is that if the same contributor calls contribute function again, then his latest contribution is going to overwrite the previous one. So instead of an equal, we need to do an increment. So we take the previous contribution for this sender and we add the new contribution so you can call several time contribute is going to work. And then fun raised. Let's just add the what was sent.
01:18:33.200 - 01:19:21.490, Speaker A: Okay, so now let's get, let's create a function to withdraw our money. So that's for the owner, MsG sender. So only the owner can restore the money can restore funds. Okay, then let's make sure that the deadline, basically we are over the deadline. After the deadline campaign is not over yet. Okay. And let's make sure also that we reach our financial goal.
01:19:21.490 - 01:20:23.960, Speaker A: So France raised above the goal and otherwise funding goal not reached. Okay. And now we are going to pay the owner, okay, so we basically send everything that we have in this contract in and then we check that the transfer worked as usual. So let's make sure it's true, otherwise transfer failed. Okay, so now we can restrain the fonts. And finally we need a function to get a refund. So what if the campaign is over, but we did not reach the financial goal.
01:20:23.960 - 01:20:51.424, Speaker A: And so in this case we need to reimburse the different contributor. So first of all, let's make sure the campaign is over. Actually let's copy this two, because this is going to be similar. So require that the block timestamp is after the deadline. So the company needs to be over. Then this time the goal needs to be not reached. So we change this comparison.
01:20:51.424 - 01:21:37.698, Speaker A: Funding goal was reached. That's the error message. Then let's get the contribution of the, the person, the address that call this function. So we define a local variable amount and let's read the array contributions of MSG sender. Okay, and after that let's do, let's make sure that this contribution is not zero. Okay, so no contribution found. And after that we're going to send the money to this contributor.
01:21:37.698 - 01:22:26.504, Speaker A: So let's copy paste here the transfer, the money transfer, so payable of here msg sender, whoever called this function. And the amount we're going to send is not all in the smart contract, but just the amount that was contributed. Okay. And we still, there is a little problem here. Do you have any idea what's the problem here? If we leave it like this, there is a very easy way to hack this contract. Basically you can call get refund once and then you can call it again because this mapping was not updated. Okay.
01:22:26.504 - 01:22:53.344, Speaker A: It still has the same value. So we need to set it to zero here. So contribution sender equal zero. Okay. And now if you try to call it again, it's going to fail at this line. Extremely important. So in solidity, security is just so important that that's an example of how solidity is very misleading.
01:22:53.344 - 01:23:30.854, Speaker A: Like a lot of people think that three DT is easy, but you actually need to be also good at security. And this is one of the elements that we cover in our bootcamp. Okay, so now maybe we can try to test this. So what should be our goal in way? Let's, let's say 100 way. Okay. And the duration should be, I don't know, 22nd. Okay, so let's select the first address.
01:23:30.854 - 01:23:52.678, Speaker A: Okay, so deployment. All right. Tic tac, tic Tac. We have 22nd to contribute. Fast, fast, fast. So first guy here, let's do 50 way for the first guy and the c second guy. Okay, let's wait, let's wait.
01:23:52.678 - 01:24:22.652, Speaker A: And now let's try to withdraw funds. But we haven't reached the end. So we haven't reached the goal. So we're going to get a refund. So let's select the first address. And what about fundraiser? So we have raised 50 way, but the goal was 100. What if we try to withdraw the funds and then we'll see funding goal not reach.
01:24:22.652 - 01:24:53.096, Speaker A: Okay, so now we can get a refund from the second address. So get refund. All right, so it has worked. And now if I click on get refund again now let me increase the console here. Now I have an error, no contribution fund. So basically we try to get refund twice. Okay, so we try to cheat the system, but our contract prevented us from doing that.
01:24:53.096 - 01:25:24.246, Speaker A: Alright, so now let's do another try where this time this is going to work. So let's, let's have 30 seconds because it was a little bit rushed with just 20 seconds. So. All right, let's deploy this. Now, first contribution here will be 50 way. Okay. And second contribution is also going to be 50 way.
01:25:24.246 - 01:25:41.234, Speaker A: Okay. And can we, do we have the time for third contribution. Yes. Okay. So actually we can get more money than the goal. Okay, we have at least the goal, but we can have more. And now let's try to do another contribution.
01:25:41.234 - 01:26:06.194, Speaker A: But this time. So here, this time it will be after the deadline. So it's not going to work and the campaign is over. Yeah, it's too late now. And now let's select the first account and let's try to withdraw. And it has worked. We have withdraw and now we have nothing in a contract.
01:26:06.194 - 01:26:54.044, Speaker A: And if we try to get a refund, for example, it doesn't work because the funding goal was reached. Okay, so now you know how to create seven simple, smart contracts. So it was a basic introduction to solidity, if you wanna, if you wanna get further. Basically, there is much more to learn in solidity before you can work professionally. So, meaning that either you're employed full time or you work as a freelancer or working on your own project. But this is just the beginning. And in one month, we can turn you into a pro, either blocks.com
01:26:54.044 - 01:27:24.794, Speaker A: bootcamp so the next cohort start July 1. So it's in about ten days. There are 30 seats total. There is one third already taken. So I recommend to book your seat as soon as possible because once this is full, it's full. Let me see if there's any last question here. Where you use email address to test and deploy ERC 20 contract.
01:27:24.794 - 01:27:55.768, Speaker A: Okay, there is no, I'm not sure what you mean. You don't need email address to deploy smart contract. Do you mean like, do you want to hire me to help you to do some coding? We do. So actually we do some small projects. So for that you can send an email to eat the blocks julianeblocks.com. so the link is in the chat. Okay.
01:27:55.768 - 01:28:08.384, Speaker A: So I think that that's the end of today. I don't see any other questions. So yeah, thanks for following today and I will see you for another stream. All right, bye, everybody.
