00:00:07.600 - 00:00:38.159, Speaker A: And we are live. Welcome everybody for this live stream on how to create a clone of Pump Fun. That's a very popular apps in Defi right now. They are making a ton of money and so I'm going to show you how we can do a clone. So if you are new here, I'm Julian and Indoblocks. I help you to become blockchain developer. So sorry for the wait but we're still gonna do the live.
00:00:38.159 - 00:01:11.519, Speaker A: No worry. So hi everybody in the chat, Mr. Ice Freeze. Deepak somebody. Where are you guys from? Let me know in the chat. So I hope that you are excited to create this clone because I haven't seen this yet on YouTube so this is really the first time. And just before we continue, very quickly, quick advertisement on about my Solidity Boot Camp.
00:01:11.519 - 00:01:52.459, Speaker A: So next week we are starting the next cohort of the Solidity Bootcamp. And so we have just one seat left. So basically this is a great opportunity to become a Solidity Pro. In one month and the last week of the Bootcamp we are going to teach you everything about token creation so that you can confidently take your first freelance gig. And so that's basically how you get your foot in the door. And really the idea is that in the next month or even the next few weeks after the bootcamp, you are able to get your first gig. And so you more than repay for the investment of the Bootcamp.
00:01:52.459 - 00:02:30.213, Speaker A: This is how I started in the space really for beginners. I think this is really the best way to do it. You start with a few freelance gig like this and after it gets much easier to get your first full time job. All right, so I see that some activity in the chat. Deepak, are you going to use Solidity? Yes, absolutely. We have THX tonight. I'm trapped in the matrix mist of Ice Freeze.
00:02:30.213 - 00:02:58.375, Speaker A: Damn. How comes man? What did you do? Greeting Cal from Chicago. All right, so yeah, another question. Am I going to use Solidity? Of course. Yeah. So actually, you know, today when I prepared this tutorial, I realized this is a pretty big app and I think the most important thing is solidity. So I'm not sure we're going to do the front end.
00:02:58.375 - 00:03:26.655, Speaker A: We're going to focus on Solidity because really that's, that's where all the difficulty is. So what is, what is Pump Fun? Okay, so Pump Fun is a website. You know, when you look at it, you know that's crazy because it looks like it's a kid who did it. Okay. It's so crazy. It feels like it's Going to give you epilepsy right away. And I think everything is on purpose.
00:03:26.655 - 00:04:02.325, Speaker A: So this is what we call a launchpad for meme coin on Solana. Okay, so let's unpack this launchpad means that this is basically a no code tool that anybody can use. You don't need to be a developer, even non developer can use it. You just need to click to use it and you can create your coin with just a few clicks. So you go here, you click on start a coin, you give it a name, a ticker description, an image. You click the cost to deploy 0.02 SOL.
00:04:02.325 - 00:05:14.275, Speaker A: So here I think they don't mean that the transaction cost, but this is the fee that they are taking. And they also take a small percentage of the coin that I created. You click on Create coin and after that basically you are going to start a sort of mini ICO and everybody will be able to buy your coin. So that's on the Solana blockchain, not Ethereum. And so there is a target. Okay, so people, they have a target of I don't know exactly how many sold, but I think it's depending on the price of Solana, it's between somewhere between 60,000 to $100,000 target in terms of how many SOL. And when we reach this target, then basically a part of the token and part and most of the Solana that was invested is used as for to create a liquidity pool on radium, which is basically the biggest decentralized exchange on Solana.
00:05:14.275 - 00:05:51.745, Speaker A: And so yes, we take, I think they take a 20% of the. So by default Bitcoin has a 1 billion token supply. 80% of this is for in the ICO phase and other 20% this is used for the liquidity pool as well as the collateral that was provided. And in terms of the fee of pump debt funds. So they take the 0.02 SOL at the beginning, but they also take a small cut of the total supply. So I think it's something like 1% or something very small.
00:05:51.745 - 00:06:44.679, Speaker A: And so technically this is not an ICO in the sense that nobody actually keep the money except the small part that is paid to pump fun but yourself, if you create this coin, you're not going to be privileged because you're the one who created when you create it, basically you don't have any coin, it's just out there. Now you need to buy your own coin. So since you are the first one who buy the coin, you still going to get an advantage because the price is not the same. Same at the beginning and at the end, basically keeps increasing. This is an exponential, this is what we call a bonding curve. And we're going to spend a lot of time on that because that's basically the most difficult in this project is to do the bonding curve. Okay.
00:06:44.679 - 00:07:22.075, Speaker A: All the rest. Well, as you can see, you don't need to be very good at UI ux. And so once you've created this coin, let's click on a coin that already exists, like this one. So actually in this sort of mini ico or we call this in this case a fair ico, there is some trading involved. So basically people are able to buy and sell the token before we, before we reach the target. Okay. So that means on this bonded curve you can go up, but you can also go down if people decide to sell it.
00:07:22.075 - 00:08:00.409, Speaker A: And this is because of this we have all sort of scams because basically a lot of people, what they do, they create coin and then they use different wallet to make you feel like there is a lot of interest. And so they buy, you start to pump. Then a lot of people buy again and then they sell before we reach the target. So it doesn't even reach Raydium and they dump everything on you. And there are some tools actually to help you monitor, monitor and avoid those scams. But this is tough because there is really a high amount of scam there. Okay.
00:08:00.409 - 00:08:43.357, Speaker A: And so here for example, you can see the bonding curve progress. So it was just at 4% and now it went back to 1%. So maybe that's a scam or maybe this is just someone trying to do some trading. And here, king of the hill progress. So basically the first person that reaches a certain amount of ownership in the coin as a sort of reward and then holder distribution. So yeah, it shows you basically the different holder. Here you can see, you can use this service called Bubble Map to see the distribution of these coins.
00:08:43.357 - 00:09:19.513, Speaker A: But you have to be careful because this is very easy to create different addresses and make it look like there are many different people, even though this is the same person. Okay, so this is not really impressive here. I guess we don't have enough data and yeah, and so this has become really, really popular. So here you can see the revenue of pump fund. So it only started a few months ago in March and now for the biggest day they had up to $1.5 million in revenue. So that's really insane.
00:09:19.513 - 00:09:54.895, Speaker A: So now you can see that the trend has stabilized because we start to have some competitors that pop up because people started to see to Smell the opportunities. For example, Dexscreener, which is a famous analytics tool for tokens, just released their own version of Pump Fun, which is called Moonshot. I think so, yeah. So they will start to have some competition. Also keep in mind that the revenue you see here, so that's gross revenue. Okay. But this is not the money they get in their pocket.
00:09:54.895 - 00:10:46.137, Speaker A: Okay, so total here they've made more than $30 million of revenue, but it's not in their pocket because they all only have a small fraction of that. So in terms of the actual profit they've made, it's any. I've read a couple of different report, but people think it's between 500,000 to $1,000,000. So which is really nice, you know, See and it's just been a couple, a couple of months, but it's not 30 million. But still it has a lot of potential because this is just on Solana. But what if you did the same thing but on other chain? Okay, so you have ton of EVM blockchain, you have the base blockchain. So basically now it's going to be the race of who deploy the next clone on a blockchain that hasn't been used yet.
00:10:46.137 - 00:11:40.397, Speaker A: So there is a ton of potential and if you build your clone now, you really have a good chance of being successful. So let's start the coding, but first, no, no, not going to start the coding because I still have something to show you. So we're going to talk technical architecture here. So how does it work? So we're going to do our own version of Pump Fun but on Ethereum with solidity. So the key to our system is going to be the token factory smart contract. Okay, so we have two kind of people who interact with our smart contract is the creator and the investor. So the creator, they're going to create a new meme coin and when the token factory receives this transaction, it's going to create a new token.
00:11:40.397 - 00:12:40.185, Speaker A: Okay, but at this stage the token has a supply of a supply, a supply of, I mean, I mean doesn't have any holder. It's just a smart contract that is created, but there is no holder, nobody bought the supply. And then once a token is created, you're going to have investors that buy the token. So they participate in the fair ico. And once we reach the target, the token factory. So once the last investor makes his purchase and we reach the target, then the same transaction is going to deploy a liquidity pool in a decentralized exchange and it's going to seat it with some initial liquidity. So by using all the collateral that was sent to token factory and from there all the investor will be able to trade on this liquidity pool.
00:12:40.185 - 00:13:14.917, Speaker A: Okay, so is it clear so far? Okay, so let me see the chart a little bit. So Michael from Minnesota justice, can I just start learning solidity without Web2exc experience? Yes you can, Mr. Ice Freeze. Really give us a 4chan vibe. Yes, this is what I was thinking. Deepak Meme coin deployment. Deepak like pump was making around 100k a day in terms of profit.
00:13:14.917 - 00:13:45.051, Speaker A: This is possible. Yeah. Deepak. No, no, no. Is there a version of pub done fun in base? Michael says yes, but you have to keep in mind that now everybody is trying to do this very fast. So probably that a lot of these clone will be really shitty. So there will be some opportunity to do to improve on whatever you see.
00:13:45.051 - 00:14:22.121, Speaker A: Okay. So don't give up. And also it's not just about deploying on a new blockchain, but it's also about innovating. And maybe you're going to spot some flows in the existing launchpad. For example, I mentioned that pump fund, they have a lot of scam with all those people dumping on investor after them. So for example, the question is, well, is it a good idea to allow trading when you do the ico? Well, maybe not. Maybe you can do a clone where there is no trading.
00:14:22.121 - 00:15:07.633, Speaker A: So the probability of a scam is lower. All right. So now my friends, we are going to talk of something very important. Sorry. We're going to talk of the bonding curve. So the bonding curve, this is a function of the token price in terms of the token supply. And why do we even bother with this? Why don't we just do the same price? So we just say, okay, you know, we're trying to sell 1 billion token and the price of the token is, I don't know, 0.1
00:15:07.633 - 00:15:34.641, Speaker A: ether per token or I mean nice. It would be super expensive. I mean just basically a fixed price and it just, it doesn't move. But the problem is that we want to give some incentive for people who buy first because they take more risk. So in order to do that, we have to make it cheaper at the beginning. So there are different kind of bonding curve. But the point is that it has to go up.
00:15:34.641 - 00:16:25.293, Speaker A: Okay. The more token supply, basically the less risk people take because the more it has a chance to actually reach the goal and end up traded on the market. So a form of bonding curve that you see a lot is a shape of exponential. So that's something that goes up. But the problem of that is that in terms of smart contract, when you write the code, it actually make it a little bit harder with an exponential. So for this tutorial we are going to keep a linear function. And but you will see that already a linear function is actually not as easy as you think because what we need to do is an integral.
00:16:25.293 - 00:16:55.311, Speaker A: Okay, so here let's say that we start from a token supply and we buy a certain amount. Okay? So that is going to take us to a higher token supply. And the big question is, well, what should be the price, the total price to buy all these token. And this is not a simple answer. If that was a straight line, yes, it's a simple answer. It's the same price. So you just multiply the price by the number of token and that's it.
00:16:55.311 - 00:17:29.010, Speaker A: But here the price is going to be different for each new token that you buy. So maybe the next token is, I don't know, $1, then token after that is 1.2, then 1.3, etc. So how can you make this calculation? Well, with mathematics, this is the concept of integral. Okay, so if you remember in high school in his math classes, so with the integral you can measure the area under a function. And so here, this is what we are going to do.
00:17:29.010 - 00:18:23.767, Speaker A: So here the yellow area, this is going to be the, basically the token price. But in terms of, it's going to tell you how many token you need to provide to get to buy those tokens. Okay, so now after we need to, we need to write down the equation and in a way that, in a simple way, because now we need to implement this equation in our smart contract. So already with a linear function you will see that there is not so trivial. But with an exponential it would be even more complex. All right, so we are going to do this. So let me see.
00:18:23.767 - 00:18:48.695, Speaker A: This is the bonding curve. So let's talk. Okay, you know what, we are going to do the hot part right now. Okay, so let's, let's do that. So I'm going to explain everything here. Let me scroll up. Zoom in a little bit.
00:18:48.695 - 00:19:23.151, Speaker A: Okay, so what is this? So let me explain to you what we're doing. So the total in our clone, the total for each launch, the goal is to raise 30 ether. Okay? So here, this is what we call token collateral. So when we reach this goal, we're going to deploy to a decentralized exchange. The total supply of a token will be 1 billion tokens. So for each token, this is going to be the same token supply. So we're not going to allow people to customize this.
00:19:23.151 - 00:19:55.875, Speaker A: And if you see on Pump Fun, that's the same. They don't give you the choice to customize this. And actually most people, they don't even care about this. They just want to make a coin that is successful. And also in order to make a marketplace that is simple to understand. It's also in terms of product design, it's a good idea to reduce the number of parameters because each extra parameter, it's a moving part in your system and it just makes the system more difficult to understand. So 1 billion token.
00:19:55.875 - 00:20:37.135, Speaker A: By the way, in terms of tokenomics, it's also a good idea to have a really high number of tokens because people, because the price of the token is going to be very low. You know, this is, it just makes sense. You know, if you have a lot of tokens, it's mathematically the price per token is going to be lower. And so it makes people feel like the token is cheap, which make them want to invest. Now we're not going to sell everything. We're only going to sell a part of this 80% because we're going to keep 20% for the liquidity pool. Okay? And this liquidity pool, basically this 20% will be backed by this 30 ether.
00:20:37.135 - 00:21:17.975, Speaker A: And so here in terms of, so the average price, so we divide 8, we divide 30 ether by the 800,000 tokens. And so we have this very small amount. So that's an amount in terms of ether per token. Okay? So for each token you need a very, very small amount of ether. And so with, and you will see, you will see after why this is important, why we calculate this. Okay, so now let's calculate the integral. Okay, so I want to show you something first.
00:21:17.975 - 00:22:12.555, Speaker A: Integral, integral, what's that? Linear function. Okay, so yeah, so basically, so an integral, this is something like this if you remember in high school. And so there are different rules. Okay, so this is not the one I wanted to find. So integral wiki. Okay, so yeah, here basically there are different rules to calculate integral. And so let me see if they give some example.
00:22:12.555 - 00:22:58.217, Speaker A: So basically it can be quite complex, okay? But for linear function it's a bit more simple. But the absolute most simple thing that we have is this thing trapeze, trapeze method. Trapezo, Trapezo, Trapezoidal rule. Okay, so this is what we call a numerical calculation. So this is an approximation that we can use to calculate integral with a computer. Because the problem Is that the computer doesn't know how to calculate all the mathematical concepts. So we need some simplification.
00:22:58.217 - 00:23:31.447, Speaker A: And this is one of them. And so the base of it is that is this formula here. To calculate the integral between two points, you need this thing, this formula, okay? B minus A. So here, let's say we try to calculate the integral between these two points. So B, this is the point A, this point. So you calculate this difference, then you multiply by half function of A. So basically this point here, function of B, this point here, and then everything divided by two.
00:23:31.447 - 00:24:04.815, Speaker A: Okay? And it turns out that actually in case of a linear function, this is not at all an approximation. This is perfectly correct. So we're going to use this formula, okay? And it's going to be very, very simple. Okay, so let's pause a second and see some question here. Michael, what is this bubble site to deploy? Just bubble. It's just a tool to analyze addresses. But this is not a part of Pump Fun.
00:24:04.815 - 00:24:58.149, Speaker A: It's just an analytics tool, Forex. How do I use this to crush dogecoin? You use this to create your own dodge coin. That's the point. Then what else? What else? So where exactly is the liquidity coming from when creating the token? So the liquidity is coming from some supply that we will create. So out of this 1 billion token, we will keep 20% to create the liquidity and then the collateral will be the money that people invested. All right, so are we allowed to use calculators? This is not an examination. Yes.
00:24:58.149 - 00:25:41.085, Speaker A: So here, let's see the formula. So here, this is the trapezoidal function I just show you. Okay, so basically our challenge is that we want to find a function here that when you do the integral of all of this, it's going to be equal to 30 ether. Okay, so we kind of work it backward. We say, okay, well we think that probably for most coin we should be able to reach this target, which is so 30 ether. Right now this is roughly $100,000. Okay, so this is kind of, it's not crazy that we could reach this for each coin.
00:25:41.085 - 00:26:26.635, Speaker A: So now we need to determine what are the parameter of this function. So basically, you know, there are two parameters. So one is basically the shape of this is going to be this k time. So x, let's say this is the axis at the bottom. Okay? So the shape here, this can be described with this equation. So k, that's basically it's going to give you how steep is the curve and offset is going to tell you what's the offset relative to zero. Okay, so we need to find on those two number offset and K.
00:26:26.635 - 00:26:55.225, Speaker A: And so for this we're gonna pose, we gonna solve this, we're gonna use this equation. So the integral of this function here, this is equal to our total collateral. All right? So now let's rearrange this. So F function of A. Let's replace it. So this is A times. So basically the.
00:26:55.225 - 00:27:15.797, Speaker A: When. This is the supply number here. A and B. This is the supply number. So A times K. So basically how steep is the curve plus the offset plus F of B is here B times K. So B the total supply timescale plus offset.
00:27:15.797 - 00:27:44.043, Speaker A: Okay, so now we've made some progress. So let's. Let me see, what did I do here? Okay, so yeah, let's rearrange here. So here we have factor. We group A and B together times K. Okay? Because basically this is K and offset that we are looking for. So trying to isolate those two, then we.
00:27:44.043 - 00:28:18.845, Speaker A: So B1. Now this is on the other side of the equation, okay? So that's divided, if you don't remember how we can move one term from one side to the other. You have to go back to your math class of high school, basically. And now next step. Now we -2 dot offset. So we switch this to the other side of the equation. Because actually this offset, I will show you, this is not an unknown.
00:28:18.845 - 00:28:42.095, Speaker A: We can set it. So now we are isolating K here. So let's keep going. So now we have completely isolated K on the left. And then we have all the known terms on the right. Okay? And so now we're going to be able to do some replacement. Okay, so 30.
00:28:42.095 - 00:29:01.511, Speaker A: This is the total collateral. Okay? So now B minus one. So total, we're gonna sell 800 million tokens. Sorry. So 800 million minus zero. Okay? Because at the beginning the supply is zero. Now minus two times offset.
00:29:01.511 - 00:29:38.825, Speaker A: Okay? So here, why did I choose this number? Because here, let's say this is our average prices, this thing here. So that means if we are doing a linear function, the price at the beginning, basically it's going to be the. So the average. Basically in a linear function, that's the average of the value at the beginning and the value at the end, right? So here for the minimum price, that's just the average time. Two for the maximum price. That's the average. Sorry, minimum price is average.
00:29:38.825 - 00:30:20.823, Speaker A: I'm getting confused. Minimum price. Let's do it again. Minimum price. You take the average price and you divide it by two. Okay? And for the max price, this is the average times two the country. So now our offset we know that this is basically the minimum price because at the beginning in your linear function the only thing that will give you some non zero value is this offset because X basically X is equal total supply is equal to zero so here in our equation this term is going to be equal to zero so we only have the offset so let's take this for the minimum price in our equation.
00:30:20.823 - 00:32:01.411, Speaker A: So that's this number here okay and finally a plus b so that's the two total supply zero plus 800,000 okay so let's remove about the zero and at the end it give us this very small Number for the 4k for the offset we already have it then for the function so then we can check that our function is our numbers actually working. Okay, so let's use this formula to make sure that everything checks out. So using our number let's calculate what's the number how much ether you need to pay for the first token this one how much ether you need to pay for the last token this number of ether here and so now what you are going to do is we're going to use this formula the trapezoidal function B minus A that's 800,000 plus basically the first price of the price of the first token the price of the last token divided by 2 and that's equal to 30 so this is working the integral of our linear function is equal to the our target basically 30 ether. Alright, so I'm sure. Let me see how many people are watching. Oh, half the people left. No, I'm joking actually everybody stayed.
00:32:01.411 - 00:33:21.321, Speaker A: Okay, so congratulation are you guys following what's happening here? I mean I'm sure like when you first see the first time, maybe it doesn't, it seems a little bit over your head but just keep in mind this is just a linear bonding curve okay if we get into the exponential that's, that's more complex so let me know if you are still present in the chat okay? If some of you understand, let me know so that I don't feel alone in this world. All right, Nobody react. No news, good news. So now let's start to implement this. So we are going to use Solidity, the programming language for Smart Contract. Okay so this is the dominant language for Ethereum Smart Contract we are going to use the Forge Foundry blockchain We are going to use Foundry, which is a framework for writing Smart Contract test and typically for complex Smart Contract like this you have to write Test. Okay.
00:33:21.321 - 00:33:43.121, Speaker A: You, you basically have no choice. Okay. And we are going also to use another tool. So that's new. So let me see. Soldier. So that's Soldier, I think it was released a couple of months ago by the team of Fundry.
00:33:43.121 - 00:34:09.501, Speaker A: So that's a package manager for Fundry. So in Foundry we're going to need some dependencies, we're going to install some other code and Soldier is going to help us. So this is like an NPM but for smart contract, basically. Okay, so let's go to the command line. I see some people still here. Whativa Forex business. Awesome guys.
00:34:09.501 - 00:34:55.565, Speaker A: Congratulations. So I already have Foundry installed, so I can just initialize the project with forge in it. Let me see. Forge init and actually let's create a project first project folder. So mkd or no, actually we can forge in it create the folder. Right. So forge init and let's call this Pump Pump function Clone clone tutorial and yeah.
00:34:55.565 - 00:35:25.463, Speaker A: All right. All right, so let's go inside. And now let's open. We're going to open Visual Studio code. All right, so let's open this up so everybody can see clearly. Let's zoom in a little bit. Okay.
00:35:25.463 - 00:35:58.471, Speaker A: So here by default we have a couple of folders that are created. We have this smart contract that was created by the initialize comment. Also a test, but we won't going to need this. So let's rename counter sol here, we're going to rename this by token factory. Okay. And here let's use a more recent version of solidity. Let's do 0.8.26.
00:35:58.471 - 00:36:28.715, Speaker A: Okay, let's call this token Token Factory. Okay. And one of the first thing we want to do is to create a function that is going to create a token. Okay. So let's do that. Create token. So when someone create a new token, it's going to call this, this function.
00:36:28.715 - 00:37:26.571, Speaker A: And how are we going to identify this function here? Let me see. So let's give it a name. Okay. And let's give it a ticker as well. Okay. And we make it external and it's going to return the address of token. Yeah.
00:37:26.571 - 00:38:01.891, Speaker A: Okay, so after that let's create that. So here we want to create a new token. So we want to create a template actually for this token first. So we need to create a new smart contract. So let's do this, let's call this token.sol. let's do some copy paste here. Okay.
00:38:01.891 - 00:38:26.693, Speaker A: Now and we want to use open Ziplink because. So open Ziplink. That's a Library to. Let's search it here. Open Zeppelin contracts. So that's a library for solidity. Here you can see the repository and gives you a lot, a lot of standard implementation.
00:38:26.693 - 00:39:01.329, Speaker A: So you go to contracts, you go to token ERC20. So for our meme coin, basically we're going to use ERC20, the fungible token and ERC SOL. And so here we have a standard implementation of a token. And so that's perfect for meme coins. So here you can scroll and you can see a couple of parameters. So the two parameters that are passed to the constructor. So that's what the function that is called when we first deploy the contract, the name of the contract and the symbol.
00:39:01.329 - 00:39:52.085, Speaker A: The symbol is like a ticker, it's like a, an abbreviation of the token that is used on a decentralized exchange to identify them. So the two important parameter and then it has other functions like total supply function key to give you the balance function to transfer tokens. So those are really the most important. But we want to use this, this framework, this library. So how are we going to do this? We're going to install it with this tool soldier. So let's copy this here, let's go back to the terminal here, let's paste this forge soldier, install, blah blah blah. Right, so let's do this.
00:39:52.085 - 00:40:45.525, Speaker A: Okay, so it says install everything. And now if you see in dependencies, it has, let me see, dependencies. Yeah, dependency Open Zeppelin contracts and then you have token ERC20 ERC20. Okay, and so this is this, we want to import it from this pass. Okay, so let's note the pass here. So at open Zeppelin 502 token ERC20. Okay, so now we go back to our token and we do import at open Zeppelin.
00:40:45.525 - 00:41:22.435, Speaker A: And was it. Yeah, I think that was contracts. And so after. No, you don't need contracts, it was token ERC20erc20.sol. Okay, and actually so I did this initially, but this was wrong because you have this hyphen with the version here. So you need to add this 502. Okay, so let's do this.
00:41:22.435 - 00:42:13.255, Speaker A: 5, 02. Okay, very good. Now we need to inherit from this and now let's define our token. So constructor string memory name string memory ticker. Now we're going to forward those arguments to the parent contract. So name ticker. Okay, and what else? We also want the initial to meet to do some initial minting.
00:42:13.255 - 00:43:03.939, Speaker A: Okay, so that's the minting that we are going to use for basically when we create the liquidity Pool we're going to use 20% of the total liquidity. So let's mint this initial mint and now we can use a function provided by YAS20 which is underscore mint and so we can check the code to if we don't know the argument. Okay, so let's scroll up here. Mint, mint, mint. Where is it? Mint. Okay, here. So first we need to pass the recipient and after the value so how much we want to mint.
00:43:03.939 - 00:44:10.943, Speaker A: Okay, got it. So the recipient is going to be the sender of the basically the address that called this function and it's going to be token factory, the sender in this case. So token factory is going to keep this initial minting and initial mint and here typo show mint. Okay so with this, now we are going to import token. Okay so now some people ask me if I have GitHub for this project. So as I mentioned before, I'm thinking of creating a pet community for people who follow this channel. And one of the perks of the community will be access to the source code of the live stream.
00:44:10.943 - 00:45:03.855, Speaker A: So I will give you more information when I put this in place. So here, create token. So how are we going to create this token? So we need to use this notation new token and let's pass it the few parameter that we need. Hey, I have some mistake here. Token name ticker. Okay, what else, what else we need? Name ticker, initial mint. Okay so okay, how are we going to define the initial mint? So let's define first the max supply.
00:45:03.855 - 00:45:51.965, Speaker A: So uint, constant public and max supply. So this is 1 billion tokens. So this is going to be 10 power 9 and then we multiply this by the number of decimals. So decimal this is basically some small fraction of token and so you can see this as a sort of cent of a token, but it's actually much smaller. So in most cases this is equal to 18 and this why 18? Because that's the same convention as for Ethereum. So you know, we want to keep it simple. Most smart contract expect this number.
00:45:51.965 - 00:46:23.765, Speaker A: So let's just make it simple. Some ERC20 don't have 18 like USDC. So it's quite tricky. So max supply, this is 1 billion. And now let's define the initial mint as a proportion of that. So public initial mint. And now we can do max supply and so we want 20%.
00:46:23.765 - 00:47:06.601, Speaker A: So it's not possible to do this in solidity. Okay you don't have access to decimal number. So the way you do it is that you multiply by 20 and then you divide by 100 and now you're good. Okay, so 20% of the max supply. And now what are we going to do with this token? Well, let's put it somewhere. Okay, so first let's put it in a variable. And after what we're going to do is we going to have a mapping because we want to have a place where we know which contract we have.
00:47:06.601 - 00:47:32.425, Speaker A: Okay. Okay. So how are we going to. Let me, let me think about it. How we going to identify. How are we going to identify this thing? So there are different ways we can go about it. Yeah, different.
00:47:32.425 - 00:47:58.475, Speaker A: Different ways we could go about it. Let's. Okay, let's just do something simple now. Just gonna have an address of mapping to boolean value. Okay. And it just tell us if a token exists. Okay, so let's call this tokens and let's make it public.
00:47:58.475 - 00:48:32.955, Speaker A: Okay, and now let's convert the token pointer to an address with this notation. Okay? So here we are referring to the token just above. Okay. Not the container with the S. And now let's set this to true. Okay? And let's return the address of the token. Okay, and now we have done that.
00:48:32.955 - 00:48:57.521, Speaker A: Let's write a test. Okay, so testing is super important, especially in this contract that will be quite complex. Okay, so basically you, we go here in the test that is already written. So that's the. When we created the repo is a. The forge command, it created this. This is a boilerplate code.
00:48:57.521 - 00:49:21.445, Speaker A: So let's use it. So let's rename this to token factory.t.sol that's the convention for test here. So EDT 26. So it does some import, some utility for test, and then it imports the smart contract for testing. So let's change that. Token factory.
00:49:21.445 - 00:49:42.377, Speaker A: Token factory, test. Token, factory, token. Okay, a lot of boilerplate code here. All right, so we're gonna have this pointer. Sorry, not a token, not factory. And we're gonna use this to. In all our tests.
00:49:42.377 - 00:50:04.185, Speaker A: So set up. This is a function that is called before any test. So here you can create as many tests as you want. You just have to prefix them with test and then the name of the test. Each of these tests is independent, which is great. And before each of them is run, setup is going to be run. So here, let's run.
00:50:04.185 - 00:50:27.915, Speaker A: Let's create a new token factory. Let's call it factory. Okay? And see here we refer to this variable here. Let's remove that. Okay, let's remove this bold plate code. Let's remove this and so our first test, we are going to call it create token. Okay.
00:50:27.915 - 00:51:28.475, Speaker A: So okay, now what are we, how are we going to structure this test? So we're going to call factory dot create token and we need to pass it the name, the ticker and what else we need. I think that's pretty much it. Right, so let's define this above string memory name, my awesome token. Then the ticker memory name. So no, sorry, ticker. So my awesome token Mac. Okay, and what else? Okay, so we create a token.
00:51:28.475 - 00:52:22.225, Speaker A: After that, what we're going to do, we are going to verify that it actually exists. So here we're going to get an address here, token. Let's call this token address. Okay. And then let's, let's make sure that, let's make sure that it exists. So how are we going to do this? Okay, so first of all, okay, I know what we're gonna do. First of all we want to check that on the mapping of the factory we have this token that is created.
00:52:22.225 - 00:53:06.603, Speaker A: So tokens of token address. So this is going to be here. Token, token address. Okay, so here we have a conflict of name token address on factory. Well, it's a bit ugly, but it's the way it is. And let's make an assertion. So how are we going to.
00:53:06.603 - 00:53:37.965, Speaker A: So assert equal. So that's a utility that is provided by the Foundry framework to do some, some test and we want to make sure that actually we don't even have to. Let's. Yeah, I guess we can make our test a little bit more concise like this. And this is supposed to be true? Yeah, supposed to be true. Okay. Supposed to exist.
00:53:37.965 - 00:54:09.805, Speaker A: Okay. So it's easier like that. And second thing, we also want to check the total supply. Okay, so total supply of the token should be 200,000. Let me see. So we need to instantiate a pointer to the token. Okay.
00:54:09.805 - 00:54:40.395, Speaker A: We need to import the token contract for that. Okay. And then let's called. Okay, now first, first things first. Guys, let's not get ahead of ourselves. First thing first, and once we have the token, we do total supply. Okay.
00:54:40.395 - 00:55:28.397, Speaker A: And we put it in a variable uint, total supply or actually we can run an assertion directly. And this should be equal to what should be equal to factory, dot, dot, initial mint and here between parenthesis. So initial mint. This is a public constant. So actually we're going to get a getter function. So this is why we can do this. And we also, what else? Balance off.
00:55:28.397 - 00:56:04.305, Speaker A: So let's check out the balance of the contract. Okay, so of the factory. And this should be also the initial mint. Okay so with this should have everything. So am I good here or am I missing something? Let me see. So here's not happy why I'm missing. I'm probably missing a semicolon.
00:56:04.305 - 00:56:36.463, Speaker A: Let's save this. So all right, so now let's see if the test is passing forge. So in our terminal forge test and then match path. Okay then test then what is this Token factory. Okay, so. Oh, I don't know. Fine, fine.
00:56:36.463 - 00:56:53.481, Speaker A: I thought, I thought there wasn't any factory created. Okay, let's run this. And the test is successful. No computation error. Test is successful. So amazing. Here we can see it passing green.
00:56:53.481 - 00:57:20.299, Speaker A: Amazing. Okay, so that is working. Let me see, let me see the question Baloom Rugan. How did you find F mean have to be substituted to the mean value which is in that equation. Okay, I will go back to. I will go back to the equation. When we create the function on solidity.
00:57:20.299 - 00:58:01.271, Speaker A: That's a very, very important equation. Okay Mr. Ryan, I gotta stop using truffle. Foundry is awesome. Yeah, so I was pretty reluctant to use foundry at the beginning but you know when you start to get to know it, it's really, really very powerful and the team that runs this. So I think there's a lot of people of paradigm which is this VC, a web3VC but with very smart people. You know you have a lot of different type of VC and so the way paradigm try to be different from what I understand is that they're really involved in the tooling they don't have.
00:58:01.271 - 00:58:47.365, Speaker A: They are not just investors but they are also technologists, developers. So yeah, it really shows and we all. I can leverage their work, take advantage of their work. I mean. Okay, so now let's go back to the factory. So we have our token in next we need to, we need a function to buy to buy to let investor buy the token. Okay so do this buy and let's specify the address of the token.
00:58:47.365 - 00:59:34.021, Speaker A: Okay with how much amount and also we're going to make it payable because people will pay us with ether. So we need to make the function payable. And the first thing is let's check that the function actually exists. Okay so tokens, let me see tokens of token. Actually I don't. Let's put it underscore here. Or we're going to put a token address.
00:59:34.021 - 01:00:16.285, Speaker A: This is maybe better like this token address. Okay so and this must be equal to true. Otherwise this is token that doesn't exist. So token doesn't Exist. And we also. Let's. What else, what else are we going to do here? Then we need to get.
01:00:16.285 - 01:00:52.325, Speaker A: We need to make sure that we have enough. Okay. Because maybe if this is towards the end and we've already and everything has been bought, it's basically too late. So how we going to do this? Okay, let's calculate the available supply. Available supply. So we're going to take the max supply. Okay.
01:00:52.325 - 01:01:17.445, Speaker A: And let's remove the initial mint. Okay. And now let's remove the total supply of the token because every time we call the mint function this is going to increase the total supply. Okay. And so now we need to create this pointer. So let's do this. Token.
01:01:17.445 - 01:01:44.699, Speaker A: Token address. Let me make sure we've imported token here. Yes, that's correct. Right. And now this needs to be superior to the available supply. So the amount needs to be below that. Below or equal.
01:01:44.699 - 01:02:19.505, Speaker A: Okay. Not enough available supply. Okay, then once we have this, Once we have this, we want to calculate the price. Okay. So calculate. Not to calculate the price. Sorry.
01:02:19.505 - 01:03:11.181, Speaker A: Calculate amount amount of east in order to calculate amount of ease to buy. Okay so calculate amount of ease to buy. So how are we going to do this? We are going to create a function for that. Calculate. Calculate. How are we gonna call this? Calculate require if. Okay, well maybe there is a better name.
01:03:11.181 - 01:03:43.615, Speaker A: You know, like it's always super hard to find good name. Calculate required if. Can you guys find a better name than this in the chat? I need some brainstorming guys. Calculate required if. Is it good? And as argument what it's going to have. So let's we're going to give it the, the address of the token because each token is going to have a different. It's going to be in a different spot on the bonding curve.
01:03:43.615 - 01:04:17.285, Speaker A: Okay. And we need to know the amount that they want to buy. Okay. And after we're gonna have required eth and then we're gonna make sure that basically they sent enough. Okay, so let me see. Calculate required eth. Okay, so now let's do this.
01:04:17.285 - 01:04:50.385, Speaker A: Calculate required eth. Forex. Can I get an airdrop? Yeah, I sent you a virtual airdrop. So it exists in our dream only. Diego, why do we need to force the soldier debt? You don't need to force anything. There are different ways to manage your dependency. But this is a new thing and I think it's pretty nice.
01:04:50.385 - 01:05:32.507, Speaker A: Okay, so address, token, address, uint amount internal. Well, I'm not sure if. Is it just going to be an internal function? Maybe we can. That would be nice. To it would be nice also to have this outside, I mean on the front end. I'm sure it would be very useful to be able to call this function so that when someone want to participate, we can show them say, hey, you need to send this much. Okay, so returns a uint.
01:05:32.507 - 01:06:11.781, Speaker A: Okay, and so now let's amount eth. So by the way, let me see, is it the amount of eth or is it the price of eth? I think this is the amount, but I want to check with my calculation. So basically with my calculation here, it was the amount. Okay. Okay. Yeah, it's fine, it's fine, it's fine. So let's, let's copy this amount.
01:06:11.781 - 01:06:46.685, Speaker A: If equal. This is this formula. Okay, so let's, we need to implement this formula. Okay, so first of all, let's get a pointer to the token here. Token, token. And what else we need? No token address. Sorry.
01:06:46.685 - 01:07:43.021, Speaker A: Then let's define B. Okay, so B, that's basically a total supply token, total supply plus the amount that they want to, that they want to mint. Okay, so basically the total supply once we, once we finish this purchase, then what about A? Well, that's the total supply before. So just total supply like this. Okay, then let's define function of A. So what's the price? The price of the next token starting from the current total supply. That's, that's what it means.
01:07:43.021 - 01:08:43.900, Speaker A: So for that we need the coefficient K that we have already calculated. So we actually need to define it times A that we just computed plus offset. We also need to define this. Then what about B K time B plus offset. Okay, and now let's return. So now we're going to do the, the whole formula, okay, B minus A time F A plus F B and divide it by two. And now we need to define K K and offset.
01:08:43.900 - 01:09:42.383, Speaker A: Okay, so how are we going to do that here? Okay, and offset. And so here we're going to have a little problem. So because we have those numbers. So can I do copy and can I do this? Well, unfortunately we cannot do this because there is no decimal number in solidity. So we're gonna use a trick for that and we're gonna represent the number in a scale in a scale form, meaning that we will need to do. It's like we're gonna, it's like if we multiply this by a very big number, okay, so it's not going to be this, it's going to be this basically. And then we're going to, we need to save what is the scaling factor because after we need to divide it by this.
01:09:42.383 - 01:09:58.053, Speaker A: Okay. So for that I did some operation here. So here, K, this is this number. So we can. Let's keep this number as integer. So 4 6, 8, 7 5. So 4, 6, 8.
01:09:58.053 - 01:10:35.863, Speaker A: 75. And we need to find the scaling factor. So multiply by 10, minus 21 and that give us that give us the right number. So here, let's make sure that this is right. Okay, so let's calculate the difference. Is it correct? Yes, that's correct. And for the other one, the scaling factor is so is minus 11.
01:10:35.863 - 01:11:11.885, Speaker A: But you know, it would be better if we had. If we had the same scaling factor. Okay. Because otherwise it's going to make it way more complex in our operation. So let's. Here we need to basically find what is the number that if we use the same scaling factor matches the other number. Okay, so here is two is too small.
01:11:11.885 - 01:11:52.295, Speaker A: Okay, so we need one more zero. Let me see. One more zero. One more zero. And is it one more zero? Now let me see. Okay, so 1, 2, 3, 4, 4, 5, 6, 7. 1, 2, 3, 4th, 5, 6.
01:11:52.295 - 01:12:11.691, Speaker A: Maybe one more. No, no, sorry, sorry. I'm going to write. Wrong direction Night seems to be correct. 1, 2, 3, 4, 5, 6, 7. Okay, so now this is the same. Okay.
01:12:11.691 - 01:12:37.853, Speaker A: The same scaling factor. Okay, so now we have our two number. So this one first. That's for K. Yes, already the correct one. And what about, what about the offset? So the offset is this one. Okay, cool.
01:12:37.853 - 01:13:07.559, Speaker A: And now what is our scaling factor? Constant public scaling factor. And that's 10 power 21. Okay. He. No, no, let me see, let me see. JP Perina. Good videos, man.
01:13:07.559 - 01:13:24.767, Speaker A: Learn a lot. Keep up the good work. Thank you. Forex business. Can I work for you? Assistant unpaid internship. Yeah, man, why not? But I. I'm not hiring at the moment, but yeah, I will.
01:13:24.767 - 01:13:46.745, Speaker A: I might need some help at some point. So. Yeah, why not? Hi. Thanks for the proposal. He's not reading the chat. Yes, I am. Okay, okay, so let's do this.
01:13:46.745 - 01:14:10.355, Speaker A: So let's go back to, to our code here, to the. This function. Because let me see. When we need to use the scaling factor. Okay, so let's think, guys, we need to think. So here we are doing some multiplication where with the FA and fb. Both of them, they are scaled by the same, the same amount.
01:14:10.355 - 01:14:47.707, Speaker A: Okay? K and offset. Both of them needs to be divided, okay. By the scaling factor. So and the scaling factor, basically you want to apply it at the last time possible because you want the numerator what is on the numerator? You want it. You want this to be as big as possible because when you're going to apply the scaling factor it's gonna. It's going to make the resulting number is going to be much smaller. But here the big danger is if the resulting number is less than 1.
01:14:47.707 - 01:15:14.207, Speaker A: So basically it's gonna. It's not gonna be an integer division but you're gonna have like a decimal number. Decimal number are not allowed in solidity. So solidity is going to run the number to the nearest. To the nearest inter integers and this is when you run into issue. So that's why you want to avoid this as much as possible. And the way you avoid this is you do the division at the end when the num.
01:15:14.207 - 01:15:47.175, Speaker A: When the numerator is as big as possible. So here, let's apply the scaling factor at this. Here, this part. Okay. Forex business. I took a screenshot is not sharing the link I guess find all sort of tricks. It's very smart.
01:15:47.175 - 01:16:23.847, Speaker A: No, but seriously guys, I will let you know when I release this community with access to the source code button. But basically it's really going to worth it because if you check out all the live stream that we did, I think since the beginning of this year we did at least like 15. So it's going to be a gold mine. The gold mine is going to open. All right, so the scaling factor. So what do we do here? I think. You know what I think we should do? I think we should test calculate required if.
01:16:23.847 - 01:17:05.835, Speaker A: Because if this function is wrong, all the rest is also not going to work. Okay. So I think we absolutely need to test that function. Okay, so how are we going to do this? I have some idea. So let's go in the test test file in here. Let's do test and calculate is required. Okay, so let's create a token.
01:17:05.835 - 01:17:47.105, Speaker A: Let's do some copy pasting. So when you do some copy pasting this is a sign that you should probably refactor. But you know what? We are not at this stage yet. So we can do something quick and dirty Refactoring. That's at the end once everything is working, all the test are working. So we create a token and next thing we want to do is to calculate the required is so factory calculate required if in let's. Let's make a simple test.
01:17:47.105 - 01:18:14.947, Speaker A: What if I want to buy. We're at the beginning, okay. And I want to buy 30. I want to buy 200 800,000 token. Okay. So it should be equal to 30 ETH. Right? So for that, what we are going to do, let's define maybe.
01:18:14.947 - 01:18:55.799, Speaker A: Maybe we can define some. Oh, I know what we're going to do. So first one is the address, right? So token address. And second one, let me see. Oh, I know, I know you int. Total available. Total.
01:18:55.799 - 01:19:27.795, Speaker A: How are we going to call this? Total viable supply. Can we call this like this? So it's going to be factory dot, max supply. Okay. Minus factory dot initial mint. Okay, so it's going to be 800 billion. So you want to. As much as possible, you want to avoid rewriting numbers that already exist, because if you change something in one file, then you're going to be.
01:19:27.795 - 01:20:02.375, Speaker A: Chances are you're going to forget to change it somewhere else. So with something like this is much better than just writing 800,800 million. So now it's total buyable supply. And now let's do required eth. Okay. And now assert equal. Okay, assert equal.
01:20:02.375 - 01:20:46.329, Speaker A: Required if. And it should be 30 time 10 power 18. Because if as 18 decimal. Okay, so guys, I think this is all we need for this test. But I have to tell you, I'm terrified. I'm terrified because the logic is really complex and I really don't want to waste time to have to debug this because I feel like especially this is a live stream. I have some added pressure.
01:20:46.329 - 01:21:07.179, Speaker A: So I don't feel like it's gonna go well if I have to debug this. So let's pray. Okay, let's pray with me that going to work. So let's run the test here. All right. All right already. Problem, problem, problem.
01:21:07.179 - 01:21:25.287, Speaker A: So what do you have? Compilation, Calculate. Required. If not found. Mm. Ah. Calculate required. If not is required.
01:21:25.287 - 01:21:44.915, Speaker A: Required eth. Okay, false start. False start. Let's do it again. Calculate. Ah. What do you have now? Calculate required if.
01:21:44.915 - 01:22:09.925, Speaker A: What's the problem? Maybe, Maybe haven't saved this file, so. Probably haven't saved it. It's public. Okay. So you should be callable from outside. Test file here. So let me copy the exact name from.
01:22:09.925 - 01:22:33.659, Speaker A: So otherwise I'm going to become crazy. Calculate required if. Okay, that's the same thing. Come on, let's go. Okay, Compile link and. No, we have. No, no, no.
01:22:33.659 - 01:23:05.835, Speaker A: That is not. That is not the same number at all. Okay. Okay, guys, so we have this giant number. So we have this giant number. That is really ridiculous, I have to say. Very, very ridiculous.
01:23:05.835 - 01:23:42.695, Speaker A: Why? Why? This is not not working. So we have this. Let's. Let's put it here. We have this Giant number. But what we should have is this one. What we receive, what we should have.
01:23:42.695 - 01:24:18.575, Speaker A: So if I buy the whole supply, it should cost me 30 ether. That's how we define everything. But we know this formula is working because here we've checked it with all the parameter and, and this is working. But the little problem we have is with the, with the scaling factor. Okay? So because we cannot have a decimal number, so we need to. Basically we. We need to find a way.
01:24:18.575 - 01:24:32.641, Speaker A: We. We need to represent the number differently in a smart contract. And so there might be some error here in the logic. So you know what I. I want to make. Okay, let's. Let's redo it.
01:24:32.641 - 01:24:58.279, Speaker A: 1. Because the promise if we try to compute the difference here to see if those are the same number. Okay, you know what? I don't trust this difference. Yes, because sometime it's not actually accurate. It does some approximation. I don't want to go into the detail, but so here, let's paste spatial value only. Okay, what about this one? Copy.
01:24:58.279 - 01:25:25.753, Speaker A: Paste spatial value only. Okay, so that's. That's correct, right? That's exactly the same. So this one 10 power minus 21. Okay. Okay. So next, what about this one? So maybe the problem comes from here.
01:25:25.753 - 01:25:50.515, Speaker A: So special value copy. I pray that it comes from here because otherwise. No, no, no. So those two numbers are correct. Ok? K and offset. Okay, let's go back. Let's go back.
01:25:50.515 - 01:26:16.875, Speaker A: Token factory. Okay. And offset. Is it exactly the same? Yes, yes, yes, yes. Okay. Scaling factor 10 power 21. Yes, that's correct.
01:26:16.875 - 01:26:39.685, Speaker A: Yeah, it's 10 power 21. So now let's go back to our formula. B minus 1 if A. If B divided by 2 equal the amount of eth. That's absolutely true. So B. Guys, I.
01:26:39.685 - 01:26:59.165, Speaker A: I think. Okay, okay, okay, okay. Okay. I think I know the problem. Okay. Okay. I think this is because we actually, we're not starting from zero, but we've already minted.
01:26:59.165 - 01:27:27.927, Speaker A: We've already minted something. Okay. We've already minted. Yeah. Okay, let's remove. We need to remove the initial mint because basically we already. The fact we've already minted for our contract, we are further on the bonding curve.
01:27:27.927 - 01:28:19.905, Speaker A: But it shouldn't count because basically, yeah, it shouldn't count because this initial mint is not part of the ICO process. So either we do the initial mint at the end, so it will not be the initial mint, or we need to deduct this like this. Okay, so that's. Try it again. Okay, so seems like we are making progress. It's smaller but still not correct what we receive. So let me see.
01:28:19.905 - 01:29:16.735, Speaker A: Okay, so it's smaller but still it's not there. Okay, so let's go back why this is not working. Total supply minus initial mint. So minus initial mint plus the amount that we want to mint. Okay, so here basically this thing should be zero. Okay, zero plus the amount. I mean if this is the first time we are calling this function, this should be zero.
01:29:16.735 - 01:29:44.745, Speaker A: This one. Yeah, zero as well. K minus K minus one. No, no, plus offset. K time B plus offset. Okay, so this is. This is correct.
01:29:44.745 - 01:30:58.435, Speaker A: B minus one time this F A and M B two time scaling factor. I don't see an error with the. Do you guys see any error here? What is the error? Let's test again. No, I'm sure this is coming from here. From this. Okay, what if we don't do it? What if we don't do it here? So, okay, so now it's even bigger. Okay, so.
01:30:58.435 - 01:31:36.737, Speaker A: But it's not just a problem of scaling, I think is also a problem with the actual number. So the computation also has some issue. All right, so I guess for this part we're gonna have to leave it here. I'm gonna tell you after maybe on Twitter once I figure this out. But basically here I'm unable to find what's the problem with this. Okay. Because here the computation is right on Excel.
01:31:36.737 - 01:32:45.395, Speaker A: It's the implementation that poses problem. Yeah, it's too bad, it's too bad. Okay, so let's keep going because we still have some work to do. So maybe we're going to get back to it later once we have some more inspiration. Okay, so all right, so once we have the required if that we need to buy, then what else are we going to do? So we, we need to make sure that we have enough. Okay, so message value superior, equal to required if otherwise not enough if. Okay, and after that, what else, what else we need to do? We need to actually mint the token.
01:32:45.395 - 01:33:24.385, Speaker A: So how we're going to do this Token dot So token dot. Oh, first of all, I would like to have a mapping that tell us the different. Basically something where we. We can know what is the total contribution for a token. So let's call this collateral token address. Okay. And let's do, let's increment here.
01:33:24.385 - 01:34:12.119, Speaker A: Okay, so just required if. And then the anything extra. Basically this is. This will be in the contract and later we will be able to withdraw it as a profit. So if people send too much, basically that's their problem. Required if and so let's create a mapping above. Let's call this address to UINT and basically this is the amount of ETH raised received for a token.
01:34:12.119 - 01:35:13.145, Speaker A: Okay, so let's go back once we have this, what else do we want? We are going to. We need a mapping to store the balance of token for each user because basically we're not going to send the token to the actual user yet because we don't want user to create a liquidity pool. Because as soon as just one user has just one token, basically they can create a liquidity pool somewhere and mess up the price. So we want to have a control on that because we will be the first one who set the first liquidity pool. So and we will release the token at the very end. So we all the token we mint, we're going to mint it to ourself and then after people will be able to withdraw them. So token address and then sender and then this amount.
01:35:13.145 - 01:36:04.975, Speaker A: So let's create this mapping the address of the token, the address of the holders. This is a nested mapping. And finally how much they have. Okay, how are we going to call this token balances for people who bad tokens. Not this, not this, not withdrawn, not released yet. Okay. Okay, let me see what we have in the chat.
01:36:04.975 - 01:37:00.405, Speaker A: Kyle Grogman I have something similar I made last year, but I like to fiddle around with this one. Yes, very interesting project bonding curve, but this is also quite hot. Is it the same if I make it on base chain? Yeah, but probably you'll have to adjust what is the goal in terms of eth because you know eth on Ethereum that means ether, but if you deploy on base it doesn't mean it means the native currency of base. So maybe 30 ETH makes sense on Ether, but on base if you put 30 eth it doesn't mean the same thing. So you need to adjust this per chain. Okay, so after that once we have uploaded our mapping, what do we do? We are going to mint some tokens. So let me see.
01:37:00.405 - 01:37:35.259, Speaker A: I don't think we have. We need to instantiate a. Let me see. Oh no, we already have a token here. So token dot how are we going to call that mint? We don't have a mint function so we need to create it and the recipient will be this smart. Contract the amount. Okay.
01:37:35.259 - 01:39:03.515, Speaker A: And now let's go create a mint function on mint in the amount after. So let's do underscore mint to amount and we need to restrict this function to an admin and let's define this admin in the constructor. Okay, so that will be basically the token factory, the administration. Okay, sorry, here. Okay, so we mint the token and finally if we reach the goal. Okay, if we reach the goal, what are we going to do? If we reach the goal, we need to create the liquidity pool. Create the liquidity do everything bas.
01:39:03.515 - 01:40:37.845, Speaker A: So collateral, let me see if we have accumulated the goal. So what would be the goal? Let's call this funding goal then Create liquidity pool. What else we need to do? Create liquidity pool, provide liquidity and burn LP token. Okay, we need to do those three things. So let's define funding goal. Funding goal will be equal to 30 ether. Okay, so first thing you know, I think it's going to be a big function.
01:40:37.845 - 01:41:21.021, Speaker A: So maybe, maybe this should be separate functions. Let me see. Okay, let's do a separate function maybe to understand them better. So here, let's call this Create liquidity pool. And we want the address of the token. Okay, so let's create a pointer as usual. So yeah, the downside is when you split into function like this, there are things that you need to recreate.
01:41:21.021 - 01:42:05.841, Speaker A: So sometimes it can be not efficient in terms of gas consumption. But you know, one thing at a time now just trying to write nice code and we will see for the gas optimization is really after. So to create a liquidity pool we will need to use a dex. So there are different decentralized exchange. But basically the one that you need to do first is Uniswap because that's the biggest one and a lot of other decks are based on the technology of Uniswap. So once you do it with Uniswap, you can do it with many others. So we need to study how is it going to work.
01:42:05.841 - 01:42:54.533, Speaker A: And for that let's go check at Uniswap. Uniswap Factory V2. So we're going to use Uniswap V2 even though this is not the most recent version, but that's the easiest to get started. Okay, so I highly recommend to get started there. So this is the GitHub repo of the one of the smart contract of Uniswap factory and factory allow you to create some new liquidity pool. So liquidity pool, this is a smart contract that allow you to trade the two tokens here this is what we call V2 Pair. And so if you have a token, you want this token to be bought and sold.
01:42:54.533 - 01:43:27.435, Speaker A: You need to create this liquidity pool. And so for that you're going to execute the Factory smart contract. And they have this function called create pair. This is what you need and you need to provide the address for the two token. Okay, so the address for the first token A here, will be our token and token B will be wrapped ether. So wrap ether. That's basically an ERC20 version of ether and a lot of liquidity pool.
01:43:27.435 - 01:43:45.363, Speaker A: Use this token for their. For the other token. We call this the base token, basically. But it could be a stable coin as well. Okay, so and here we can see that. Just take these two addresses. That's it.
01:43:45.363 - 01:44:19.997, Speaker A: So we need to execute this function, but first we need a pointer to the factory contract. And for that let's go back to the. Let's go back to Soldier, which is the package manager for Foundry. And so now we're going to search Uniswap Uniswap core here. Okay. And let's copy the instruction to install this. So let's forge solder install this.
01:44:19.997 - 01:44:43.275, Speaker A: Okay, let's go. So it's gonna installed. It's gonna install a smart contract in dependency. Here you can see Uniswap V2 contracts. And we need to adjust the interface. Let's expand this the interface for the factory. Okay.
01:44:43.275 - 01:45:22.983, Speaker A: And Uniswap V2 core 1,01. Okay, so let's import this. You need swap V2 core 101 slash contracts slash. I think it was interface. Let me see. Interfaces, contracts, interfaces. And then I uniswap v2 factory.sol
01:45:22.983 - 01:46:02.489, Speaker A: I have the IntelliSense here. Okay, awesome. And so now we need this thing. Yeah, the Factory. Okay, so now let's call this the factory and I you niswap. So this is the same thing here. Let's pass it the address of Uniswap.
01:46:02.489 - 01:46:41.393, Speaker A: So we're going to define this in a. In a var in a constant somewhere. Uniswap v2 factory. Okay, we're gonna find it easily. Just one google search away u in constant public uniswap v2 factory. So what is this factory address? V2 deployment. So always make sure that you use the actual address of the dock of Uniswap because otherwise it's easy to scam you.
01:46:41.393 - 01:47:22.555, Speaker A: So factory uniswap v2 for mainnet is this one okay. By the way, since we added, we will also need the address of the router after. So let's do it right away. So it's done. And for the router is this one. Okay, so let's go back to creating the liquidity pool here. Okay, we have the factory contract.
01:47:22.555 - 01:48:15.827, Speaker A: And then let's create our pair. So factory dot create pair. And now for the token eight. It's going to be a token address and the second one is going to be the wrap ether. The address of wrap ether and actually we have this on the router. So the router this is another contract that we're going to use in more detail after allows to add liquidity and buy and sell but it also has the address of wrap ether. Okay so we need to define a new pointer to this router router and I.
01:48:15.827 - 01:49:03.795, Speaker A: I'm not sure what's the name of the interface. So we actually need to install another package for this. So let's go back to soldier. Where is soldier? Soldier is here. So That's Uniswap Periphery V2 Periphery. Okay, let's copy the install command here. Okay so now we have this new package Uniswap V2 periphery 1, 1, 0 let me see Contract Interfaces.
01:49:03.795 - 01:50:22.401, Speaker A: Interfaces Router. So the router is what we want Router v2 Uniswap v2 Periphery 110 Beta 0 case is bit complex. So let's try to remember this import. Uniswap V2 Perry Ferry 1, 10 and what was beta? I think it was beta what 1, 10 beta 0 okay very long name Interfaces and then it was I uniswap router 02. Okay so we're going to need this. Okay now we have the. We have the pair and we're going to get the address of the pair just after.
01:50:22.401 - 01:51:08.019, Speaker A: So let's see this and what else, what else do we need? So once we have this actually let's. Let's just return return the pair. Okay, the address of the pair. So here let's do returns address. Okay so now we have the liquidity pool that is created and now let's, let's call this function so create liquidity pool and the token address is. Yeah, just token address. Okay so good suggestion.
01:51:08.019 - 01:51:42.605, Speaker A: And I'm not even using GitHub copilot so I'm guessing this is VS code that configure it by itself. So yeah, it's getting pretty smart. So now provide liquidity. So we need. This one will be more tricky defunct. So let's go in function Provide liquidity. So we need the address of the token.
01:51:42.605 - 01:52:20.599, Speaker A: We need the. We do we need the address of the pair. I'm not. Not sure why would we need this? No, I don't think this is useful. Then we need how much we want to provide. Okay, think token Token amount. And what about, what about for the amount of ether that we want to provide.
01:52:20.599 - 01:52:57.569, Speaker A: So it's always going to be the same, right? It's going to be the goal, which is 30 ether. Okay, but this should match what we have in the mapping. So here in the collateral, here in this number uint, this is the total that we have raised for a specific topic. Okay, but let's say there is some mistake in our code and basically we don't have the 30 ether somehow. So I don't want to use the money of other tokens. So I want to read from the collateral. Okay, so I'm not going to assume that it's 30 ETH.
01:52:57.569 - 01:53:59.505, Speaker A: I'm just going to take whatever is in this mapping. So token amount and the second thing will be eth amount. Okay, so now we need to do different things. So we need to first let's get a token as usual token pointer. Then what else do we need? Let's get a pointer to the router. Okay, and now I want to, let's inspect what we have in the router. Okay, so let me see this router.
01:53:59.505 - 01:54:36.815, Speaker A: Uniswap v2. Okay, GitHub, we have it here. And what we want is add liquidity. This function so takes, it takes a few, let me see. Actually not add liquidity, but add liquidity eth. Because we're going one, we're going to provide the token and we also on the other sides we're going to provide eth. So add liquidity without eth.
01:54:36.815 - 01:55:08.445, Speaker A: This is when you provide two tokens at the same time. But in our case one will be a token, the other one will be, would be ethical. But internally it's going to change eth into wrapped eth. Okay. And so here when we create a liquidity pool, what happened is that when you provide liquidity. Sorry, so we need to provide an equal value of the two tokens. So let's say you provide, I don't know, 1 million token and then 10 ETH.
01:55:08.445 - 01:56:02.595, Speaker A: You are basically telling the Uniswap that these two things have the same value. So the 10 ETH have the same value as the 1 million token. And so from that you can derive the price, the price of the token relative to eth. So in our case it's going to be easy. We're going to take all the, all the east that we have raised for this token which is 30 ETH, and we're going to take the 200 million allocation that we did at the beginning and this is what we're going to send to the liquidity pool. Okay, so let's, let's copy here all the, all those things, all those parameters, because this is what we need to, this is what we need to, to, to execute. So router dot add liquidity and let's provide all those things.
01:56:02.595 - 01:56:51.479, Speaker A: So the deadline, this one, this, in this case, okay, this is important. If this is a liquidity pool that already exists. And so you want to make sure that the parameter that you specify, I are only valid for a certain time. But in our case there is no problem because no risk at all because we just created the pool, okay? So the next thing we do is that we provide the liquidity. So there is absolutely, at this stage there is zero liquidity in the pool. We are the one who provide the initial liquidity because everything is within the same transaction. Those two actions are, we call this atomic.
01:56:51.479 - 01:57:16.149, Speaker A: They happen either both of them or not at all. So for this we can just put the current timestamp. This is fine. Nobody care. Okay, so for the token, now this is the token address. Now for the amount desired. So that's how many token we will provide.
01:57:16.149 - 01:57:51.755, Speaker A: So that's token amount and for token mean. So that's related to the notion of slippage. Also same thing as with block timestamp. This is only interesting if liquidity pool already exists and you're trying to get a transaction mine from outside of blockchain. But in this case, again, there will not be any problem because basically we know we are the first one to set the price. So there is no price action, no other traders involved. We are the only one.
01:57:51.755 - 01:58:34.477, Speaker A: We control everything. So zero tolerance for slippage. Exactly the same thing for the amount eth mean. So this is eth amount and we need to so address 2 who is going to get the liquidity the LP token. So when you provide liquidity like this, you're going to receive in exchange what's called LP token. And that, that is a proof that you actually provided liquidity. And so with this LP token in the future you can redeem them and get back your liquidity.
01:58:34.477 - 01:59:42.563, Speaker A: So here, let's put our address, okay? Because the LP token will be. We want the LP token, okay? And here we actually need to send some ether. So if you just do this like this, it doesn't work, okay? Because you actually don't send any ether. But to send ether you need this special notation with curly brass braces. Value if is amount, right? And now what else? You also need to approve your token to be spent because what happened is add liquidity is going to try to transfer Your token by using the transfer from function, which is delegated transfer. So with when you transfer an ERC20 token to a smart contract, it's not the same the same direction as with ether. With ether here we are pushing, okay, me, I'm the sender and I'm pushing ether to you.
01:59:42.563 - 02:00:11.429, Speaker A: But when you do a transfer of yes, 20, this is what we call delegated transfer. So first you allow a spender. So in this case it's the router and it is this spender that will use transfer from. So it will pull the ether to it. But it only works if you have allowed it first. So for that we need to allow this spender. So token approve.
02:00:11.429 - 02:00:41.025, Speaker A: So first, who are we going to approve? That's the router. Okay. Uniswap V2 router. And then for how much? Well, for token amount. Okay. And. Yeah, okay.
02:00:41.025 - 02:01:11.069, Speaker A: And with this, with this it should work here we're gonna get. So once we add the liquidity is we're gonna get some, some data back including the number of LP token. Okay, so let me see here. Add liquidity is returns. It returns all of that. So let's read those things. Let's capture those things.
02:01:11.069 - 02:02:04.185, Speaker A: So how much ether it actually, let me see how much it's basically it tells you how much token it took, how much ether it took, and how much liquidity it returned. But we actually don't care about these two because we know it's going to take everything because that's we are the first provider of liquidity. So there won't be any discrepancy. However, the liquidity we do care. And what we do here is like we return the liquidity to whoever is calling this function. So let's do internal returns uint. Okay, so now let's go back here.
02:02:04.185 - 02:02:53.485, Speaker A: Provide liquidity. And the first thing was the token address. Then for the token amount, what do we do? I think for the token amount, we said that it was collateral token address, right? No, that was the token amount first. So for the token amount, it is the initial mint. Let me see. And you know what, let's be safe once again. So whatever is the balance of.
02:02:53.485 - 02:03:21.875, Speaker A: Oh no, it doesn't work. No, no, because the balance of this contract is the initial mint plus plus the tokens of all the people who bought it. So we don't want to steal the token. Okay, so it's actually, let's just use initial mint here. Okay. And here how much money we raised. So collateral of token address.
02:03:21.875 - 02:04:08.697, Speaker A: Okay. And provide liquidity. Actually, I realized maybe we don't care about the return argument of provide liquidity because when we burn the LP token, we actually can get this as well. Let me see. So burn LP tokens. I actually realized we don't, we don't get the here the liquidity pool. We.
02:04:08.697 - 02:04:42.105, Speaker A: No, no, we need to save the address of the liquidity pool because we need it after. Okay, so address liquidity. How are we going to call this pool? Okay, let's just dress up the pool. Let's save all the return arguments. So you int liquidity. Okay, and finally burn LP token. So I want the address of the pool and I want how much should be burnt.
02:04:42.105 - 02:05:27.049, Speaker A: Okay, burn LP token. Burn LP tokens. So address of pool address. And what else do we have the amount to burn you int amount. Okay, and so now we need to get a pointer to the pair. So the liquidity pool. Let me see if we have it here.
02:05:27.049 - 02:05:53.315, Speaker A: So no, we don't have it. So we need to import the correct interface. Okay, so let me see, in the import in the dependencies interfaces, is it in periphery? No, it's in core. It's in core. And then we go to contracts interfaces. And that's the pair. Okay, yeah, that's this one.
02:05:53.315 - 02:07:03.163, Speaker A: That's this one. So yeah, let's duplicate one of them. This one. It's not the factory we need this time. Okay, it's this guy here. Okay, so let's copy this and let's get the pair. Okay, and so how are we going to burn this LP token? So first of all, why we need to burn it? Because basically if we keep it, well, if in the code of our smart contract we never do anything with this LP token, this is as good as burn because the smart contract can only do what is inside its code.
02:07:03.163 - 02:07:48.663, Speaker A: So if the code doesn't do anything with them, well, same thing, we never are going to be able to do a rug pull. A rug pull is basically when you redeem your liquidity. So you redeem your LP token, you get back the liquidity. And what happened after that is like basically this is you will make the price, you will take a lot of the collateral that is that was backing the value of the token on the exchange. And then after that, the price of the token can be very easily manipulated because there is no collateral at all. So anybody who sell it at this point can make the price of the token go really, really low. And so that's basically a scam.
02:07:48.663 - 02:08:25.411, Speaker A: It's called a rec pool. And in order to avoid this, it's good to burn your LP token, meaning that you send this LP token at an address that you do not control. And so you are sure that nobody will be able to do a rug pool. And so all we need to do is to transfer this LP token to an address we don't control. And it turns out that the LP token, they are at the same address as the liquidity pool. Okay, so we can actually see this. Let's go in V2 core contracts.
02:08:25.411 - 02:08:55.841, Speaker A: Let's go to V2 pair, okay? And Uniswap V2 ERC. Okay, that's the interesting part here. So let's see this. Uniswap V2erc. And here you can see that the liquidity pool is also ERC20 token. Okay? So the logic of the trading and the logic of the LP token are actually in the same contract. So let me see here.
02:08:55.841 - 02:09:23.439, Speaker A: Approve transfer, all the function of ERC20. You find them here. And then the one that is very important here is transfer. So we are going to use that. So pool transfer. And so the recipient address is going to be an address that nobody controls. So this one, for example, address zero, address zero.
02:09:23.439 - 02:09:59.615, Speaker A: It's basically 0x0000, etc. In and second the amount. So that's the amount of LP token to burn. That's all our LP token actually pull transfer. And yes, so with this we've actually burned our LP token. Okay, so now we need to call this, I think we call it already. Okay, yes.
02:09:59.615 - 02:10:54.305, Speaker A: So, okay, are we missing anything here? So we create the liquidity pool, we provide the liquidity, okay. And then we burn the LP token. What else, what else do we need to do? I guess we, I think in provide liquidity, we should probably update the collateral mapping because at this time we've already spent the collateral that was allocated to this token. Right? So we want to keep the state up to date. Right? So provide liquidity. Okay. And here, let's do collateral.
02:10:54.305 - 02:11:48.805, Speaker A: What is that? Token address. Right? And now this is equal to zero. Okay? And finally the last thing we need to do is a function, a function to withdraw, to allow people to withdraw their token. So once, basically once the liquidity pool has been created, we will allow people to withdraw their token. And now they can trade using our liquidity pool or doing whatever they want. But otherwise the token are still in our SMART contract. So let's, let's create a function withdraw in.
02:11:48.805 - 02:12:19.465, Speaker A: Well, it doesn't make sense to let them specify the amount. They're just gonna withdraw everything, right? Why would they want to withdraw just a part of it doesn't make sense. So first of all, let's check out how much. Okay. Now they need to specify which token. So token address. And is this a token that actually exists? Okay, so token tokens.
02:12:19.465 - 02:12:56.177, Speaker A: Token address and needs to be different from the null address. So token doesn't exist. Okay. And second, we need to know what is their balance. So balances of this. So token address for this sender. And they need to have a positive balance.
02:12:56.177 - 02:13:20.695, Speaker A: Okay, so needs to be superior to zero. No token to withdraw. And now we're going to update the balance to zero. Okay. Because we don't want them to try to withdraw again and steal the money of other people. Right. So we do it here.
02:13:20.695 - 02:13:41.105, Speaker A: And finally we're going to do the transfer. So as usual, we initialize the token address. Okay. The token pointer. Sorry. And not token transfer. So two.
02:13:41.105 - 02:14:11.885, Speaker A: Well, actually, maybe they can specify the recipient because maybe they want to send it to someone else. Right. So token dress and the recipient so can be themselves, but it can be someone else. So more flexibility and for how much? Well, basically they're balanced. So everything they have. Okay. And now they can restraw.
02:14:11.885 - 02:14:40.485, Speaker A: Let me see if we forgot to update anything. So this one. Well, doesn't make sense to change it because historically we want to keep a trace that. Yeah, we did create this token, even though it's not there anymore. The collateral, well, now it's set to zero. So if it's set to zero, it means that. Let me see, there's a little problem here because.
02:14:40.485 - 02:15:18.579, Speaker A: Because now people can. It's gonna be a little bit messy, right? Yeah, it's gonna be. It's gonna be messy because when we actually change the collateral. Let me see. Okay. It's not. It's not great because when we change the collateral now, it means that if people try to contribute to buy this token again, they will.
02:15:18.579 - 02:15:49.605, Speaker A: They will be able to do it. So ideally, I would like to keep a trace of the state of the token. I like a variable that says, hey, this token has been distributed. So how can we do this? We could create a mapping. Let me see. Token. We could create a map, a struct.
02:15:49.605 - 02:16:19.015, Speaker A: We could create a struct for token state. Struct, token state. Let me see. So first, boolean exists. So by default, no exist. No, no, no, no. Sorry, sorry.
02:16:19.015 - 02:16:37.851, Speaker A: Maybe. Maybe not a struct, but a. What's the name of that? A. I have it on the. On the tip of my tongue. An enum. Enum.
02:16:37.851 - 02:17:07.705, Speaker A: Because we want to track the state. So first of all, the initial state is. What is the initial state of a token is? It doesn't exist, actually. Yeah, I actually don't remember the how to write this. So enum. Solidity. Let me cheat a little bit.
02:17:07.705 - 02:17:35.515, Speaker A: All right, so enum status pending. Ship. Okay, so this will be the default status. Not exist. Exist. Not created. Yeah, not created.
02:17:35.515 - 02:18:05.575, Speaker A: Then are we going to call this ICO when people are raising money? ICO and trading. Trading means that it was sent. Okay, so not. Yeah. Okay, and what's the. I think I have a syntax error here. So, okay, it doesn't have a semicolon.
02:18:05.575 - 02:18:33.605, Speaker A: Okay. So now it's not going to be boolean value, but it's going to be token state. Okay, let me see in here. Token. Token state. And now it's going to be ico. Okay.
02:18:33.605 - 02:19:02.379, Speaker A: And what else? Buy. So now it's going to be token state. Actually, I think people in general do they. Do they. Is it uppercase? So, okay, I thought. I thought by default it was. Everything was uppercase.
02:19:02.379 - 02:19:23.715, Speaker A: No, whatever. It's a detail. Yeah, it can be quite petty sometime. Token state. Dot. What are we going to call this? Token state dot. So here actually we want the token.
02:19:23.715 - 02:20:11.917, Speaker A: Token doesn't exist or not available for ico. Okay. And withdraw. So now is going to be token address, equal, token state, dot trading. And now it's going to be. Token doesn't exist or isn't or hasn't reached funding goal yet. Okay.
02:20:11.917 - 02:20:46.065, Speaker A: So now that we are tracking the state of the token, it's actually way easier because, you know, a smart contract is a state machine, so it really makes sense to have some states inside. Okay. And so now we don't want to remove the collateral to reset the collateral to zero. So let me see, at some point we were doing this. Yeah, yeah, let's remove that. We don't want that. Okay.
02:20:46.065 - 02:21:06.911, Speaker A: I think we made a lot of progress. So let me see if some people have some idea why we have the bug for. Why we had the bug before in the test. So, tsx. I did some research on Pump. Fun. Cool.
02:21:06.911 - 02:21:30.183, Speaker A: What did you find? Thx. Diego. B minus A. Diego, you think there's a problem with the parenthesis? Let me see. Yeah. So for those who are just joining. So everything was going well up to the moment where we try to import.
02:21:30.183 - 02:21:59.649, Speaker A: Implement the. We try to implement this. We try to implement the bonding curve in solidity. So it was working with our calculation on Excel, but unfortunately didn't work with solidity. So let me see. B minus A. No, it's.
02:21:59.649 - 02:22:22.811, Speaker A: It's really? B minus A times the rest. Let me. Let me go back on our calculation. So if we can solve this, that'd be freaking awesome because we, we could. We could move on in a test, but now we're a little bit locked. Because if this is wrong, then all the rest will be wrong as well. B minus A time.
02:22:22.811 - 02:22:43.575, Speaker A: This is the formula, right? I'm not. Not inventing it. B minus A times F A plus F B divided by two. That should be equal to the whole collateral. And. Yeah, we can see it here too. B minus A1.
02:22:43.575 - 02:23:22.627, Speaker A: Yeah. Times. Yeah, so let's go back here. B minus A times. What if I add a parenthesis here? I don't think this is going to change much. Let's try last time. So I think this test might be broken because we added the token state.
02:23:22.627 - 02:23:59.835, Speaker A: So yeah, let's not run it for now. Let's try the test again. Okay, so now a little problem is not compiling. Uniswap V2 periphery 110 beta 0. I think I'm missing contracts. Okay, I'm missing Contracts. Let's try again.
02:23:59.835 - 02:25:15.869, Speaker A: Not found. Okay, so Uniswap V2 periphery. What's the problem? Uniswap V2 periphery 1110 contracts interfaces. What's the problem, referee? 110-beta-0. 1110-beta-0, beta zero. What's wrong? Contracts, Interfaces. It's too bad there isn't a way to.
02:25:15.869 - 02:25:47.903, Speaker A: Let me see if there's a way to copy the pass. But I think it's kind of stupid that we cannot copy the pass. Like maybe you can do it here. Copy past. It's not stupid. Okay, so let's see exactly where is the problem? Okay, so 110 contracts. This is exactly the same.
02:25:47.903 - 02:26:36.497, Speaker A: No. Do you guys see any difference? Uniswap V2 periphery 110. I'm becoming crazy now. This is exactly the same thing. Save, save, save, save. Let's try again. Token Factory 7 import source not found Someone is asking if we are working on Solana.
02:26:36.497 - 02:27:07.249, Speaker A: No, we're working on. We're working on Ethereum because we're getting a clone of Pump Fun. But on Ethereum right now we have some compilation problem. So basically they're driving me insane because it's telling me that you cannot, cannot find. Ah. Okay, okay, okay, okay, okay. So I'm so freaking stupid, guys.
02:27:07.249 - 02:27:28.883, Speaker A: Okay, here. Dot, dot, forward, slash. It's not that, okay. It's directly Uniswap. Okay? So freaking stupid. Ah, finally got it. Okay, so now we have a little undeclared okay, this one should be easy to fix.
02:27:28.883 - 02:27:51.195, Speaker A: Line 45 create liquidity pool. So 3, 8. Liquidity pool. What's the problem? Ah, because I made it external. Stupid me. Yes. Okay, let's go again.
02:27:51.195 - 02:28:12.345, Speaker A: The router. Ah, okay, here's 76. So okay, here is absolutely my fault. It's the wrong type. So let's fix this. This is not type factory. This is typewriter.
02:28:12.345 - 02:28:37.975, Speaker A: Okay, cool. Okay, so let's do one step at a time. Okay. Okay, let's maybe take the first one. Type. Address is not. Ah, it's my fault.
02:28:37.975 - 02:29:01.755, Speaker A: It's my fault. Yeah, it's not the right type here. So here, this is an address here. This is an address. Okay, so let's go again. Scroll up. So 82, type.
02:29:01.755 - 02:29:30.041, Speaker A: Okay, again, it's a mismatch between the type of the variable and what I instantiated it with. So here. Am I trying to do a router? Yes, I'm trying to do a router. So the type should be router also makes sense. Just some little, little mistake. Okay, so now we have just one. Let me see 84.
02:29:30.041 - 02:29:59.363, Speaker A: What's your problem? Callable expression before call option. Let me see 84. What's your problem? So, ah, okay, okay, got it. It's not, it's not the right place to put it. It's over there. Yeah. Okay.
02:29:59.363 - 02:30:30.325, Speaker A: Once you specify the function, then you specify how much value you send. Mm. Okay, so so now we. So we have no compilation error, but we are back to the same problem. So yeah, still this problem of computation in our integral, basically the implementation of the bonding curve is wrong. And I don't think I'm going to be able to figure it out now. So I would prefer to solve it off stream.
02:30:30.325 - 02:31:15.359, Speaker A: But basically just to recap for people who are just joining here. So the really tricky part in Pump Fun is to implement this bonding curve. So you need to make it more and more expensive to buy the token as the token supply progresses, increases. So you have different way to do that. In Pump Fun, they have an exponential, but you can also do it with just a linear function that goes up. So the more token supply, the more you have to pay. And basically what's tricky is to figure out, okay, well, how much.
02:31:15.359 - 02:31:53.583, Speaker A: What is the amount of token that you need to pay in order to get this extra token supply? And the answer is with the integral. So you have this curve, this linear function and you need to compute the area in yellow. So that's, that's the integral. And how we do this, we use this formula so that's the, this, this, the trapezoidal rule. So that's a numerical method to compute integral. And this is this formula here. Okay.
02:31:53.583 - 02:32:52.767, Speaker A: B minus A F of A F of B. And so what we did in this calculation is that we, we wanted to find the parameter of a function of A of a bonding curve so that at the end we distribute 30 ether. Okay, so here we our goal and I think I've put it so. Yeah, we, here we have a linear function with the parameter K and the parameter offset. And we want to find this parameter so that all this, the area below it, when we supply, when we finish the token supply in Exchange we get 30 ether. That's, that's the, our funding goal. And so here, thanks to this equation, we find the parameter of K and offset and we were able to verify mathematically that our calculation is actually working, which is pretty awesome.
02:32:52.767 - 02:33:41.835, Speaker A: But then the problem was when we try to implement the bounding curve function in solidity, we cannot figure out why it doesn't work. And it may come from these two parameter K and offset because we cannot represent decimal number and solidity. So we had to find a trick with a so called scaling factor. And I think there's a problem in the logic here somewhere. Okay, so what I'm going to do is I'm going to do some research myself and if I find a solution, I'm going to let you know on Twitter. But in any case, I think we've made a lot of progress. You know, you have a really solid base and now you understand the basics of Pump Fun.
02:33:41.835 - 02:34:15.567, Speaker A: So one thing we haven't done is how to sell a token. So now we can only buy but on Pump Fun before you reach the goal, it's also possible to sell the token. So the bonding curve can go on the right, but also on the left. So that is left to you. But I mean maybe you can do a clone of Pump Fun that doesn't do it. Also because, you know, because of this function you have a lot of scams also so may not be the best idea. And then once, once you finish your smart contract.
02:34:15.567 - 02:34:55.315, Speaker A: So you need to test everything because that is just so, that is so critical. You know, you manipulate a lot of money so you need to test it and then you need to implement the front end. So as you can see with spam Fun you don't need to do anything crazy. It's, it's, you're not going to be rewarded on the beauty of your design. You're going to be rewarded with the if your smart contract works well and has no mistakes and if you are able to if you also able to make some noise on Twitter and on social media. Okay. Of course the source code of Pump Fun is not available publicly.
02:34:55.315 - 02:35:34.705, Speaker A: The source code of this of what I did. So once I fix it I will make it available in the future to a private community. I will let you know for those who are on my email list when you guys can sign up. But yes, is it, is it any last question here? No. Okay. Oh yeah, by the way guys for those who have just joined so we are doing a solidity boot camp next week. We are starting okay July 1st so in one month you're going to become a solidity pro.
02:35:34.705 - 02:35:46.905, Speaker A: Then there is just one seat left so this is now or never. Okay thanks everybody for following. I will see you for another stream. Okay bye.
