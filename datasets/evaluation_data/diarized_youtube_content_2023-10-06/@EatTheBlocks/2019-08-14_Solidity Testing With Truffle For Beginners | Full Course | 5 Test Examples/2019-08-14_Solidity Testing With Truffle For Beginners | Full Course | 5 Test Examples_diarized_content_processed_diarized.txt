00:00:00.330 - 00:00:47.446, Speaker A: In this video we are going to test five solidity smart contracts with the truffle framework. The tests we will be doing are quite simple, but it's better if you are a bit familiar with the truffle framework. You can check out my other video for an introduction to truffle. If you need a refresher on this, the link is in the description. Once you deploy a smart contract to the Ethereum blockchain, its code is immutable and nobody can change it. That's great to build a decentralized, trustless system, but that also means that if there is any security vulnerability found later, there is absolutely no way of fixing the code. Because of this, before we deploy a smart contract to the Ethereum blockchain, we absolutely need to make sure that there are no bugs and the best way to do this is by writing tests.
00:00:47.446 - 00:01:25.010, Speaker A: By the way, this is an extract of a full course on solidity smart contract testing on Edwox Pro, where we test 30 solidity smart contracts. It starts with very simple smart contracts and goes all the way up to advanced levels. If you want to access the source code of this tutorial, go to the website of idoblocks and create a free account. You also get access to the source code of all the other tutorials of idoblocks. With this being said, let's start with our first test. So in this test we're going to test a very simple smart contract and we're going to see what are the basic of testing a smart contract. With the truffle framework.
00:01:25.010 - 00:02:14.918, Speaker A: I've downloaded to my computer the git repo of ether blocks and I went inside the folder. Day one simple smart contract subfolder start and I'm going to copy this to a local folder. Okay, let me step into it. And this is a very standard truffle project with all the usual folders and file. So in the contracts we have all our smart contract, including the one that we're going to test in a migration folder. I've already prepared the migration for our smart contract here and we're going to write the test inside the test directory that is empty. Now, if you are curious how I created this project, I just used the Truffle init command and after that I created my smart contract in a contract directory and my migration and that's it.
00:02:14.918 - 00:02:46.062, Speaker A: So in a code editor, let's have a look at our smart contract simple storage. Wow, this is so empty. This is the most simple smart contract that you can ever create. So it just has a name. It has an empty body, no function, no variable. And why I'm doing this because in this episode I want to focus on the mechanism of testing a smart contract with truffle. So once you have your smart contract and your migration, what you need to do is to create a test file.
00:02:46.062 - 00:03:26.426, Speaker A: So let's create a test file in the test directory, and usually we're going to create a test file per smart contract. So let's call it simple smart contract js. So in truffle you can have test in JavaScript and in solidity, but most people write test in JavaScript. Test in solidity are useful if you are developing a library smart contract, for example. But if you want to test interaction from the outside role with your smart contract, then you need to write a JavaScript test. So that's what we're going to do. In terms of naming your test file, it's best to take the same name as your smart contract, but in camel case, which means that the beginning of your name must be lowercase, and for each word it's going to be uppercase.
00:03:26.426 - 00:04:08.614, Speaker A: So simple lowercase smart uppercase contract uppercase. This is just a little detail, but it's better to respect the convention. So let's open this file. So the first thing that we need to do in a test file is to import the truffle contract artifact. The contract artifact is an object provided by the truffle framework to manipulate your smart contract. So let's define a variable that we're going to call simple smart contract with an uppercase s this time, and we're going to use the artifacts object that is injected by the truffle framework inside this test file. And this object has a method called require that allow you to import this contract artifact.
00:04:08.614 - 00:04:52.150, Speaker A: And here you're going to give it the name of your smart contracts simple storage contract. So he has to be exactly the name that you have in your solidity file. So here let me go back in my solidity file, and I'm really talking of what we see here, simple smart contract. So even if you call your file with an other name, what really matters is the name that you give to your smart contract here. So let's go back to our test file, and once you've done that, you need to define a contract block. So under the hood, truffle uses the mocha framework, which is a very popular testing library for JavaScript. And when you write a contract block, this is equivalent to the describe block of mocha.
00:04:52.150 - 00:05:41.430, Speaker A: So inside your contract block you will have access to all the function that you can use inside a describe block, like the before hook for example, or eat for defining test, et cetera, et cetera. You can check out all this thing in the documentation of Mocap. So we write our contract block and the first thing is a description of this contract block. So let's put the name of our smart contract, storage contract, and after that we're going to define a callback. By the way, this callback can be async if you use any async await feature inside this callback. So here callback and inside this callback we're going to define all our tests. Every time you define a contract block, solidity is going to deploy a new instance of your smart contract.
00:05:41.430 - 00:06:14.766, Speaker A: So if you write some test in one contract block and some other tests in another contract blocks, basically these tests are independent. They are talking to two different instances of your smart contract. So that's very important to know. So let's get rid of this. And inside our contract block we're going to define each test with an IT statement. So it is a function that accepts a first argument which is a description of the test. So let's define our first test, which will be should deploy smart contract properly.
00:06:14.766 - 00:06:50.030, Speaker A: Okay? And we're going to give it a callback. And this callback is going to be async because inside I want to use the await notation. So let's create a callback. And generally the first thing that you want to do in your test is to grab a contract instance. So a contract instance is an object that point to the deployed smart contract on the ethereum blockchain. So let's define this variable and usually we use the same name as a smart contract, but this time with a lowercase for the first letter. So simple smart contract.
00:06:50.030 - 00:07:29.082, Speaker A: And here we use the await keyword because we're going to execute a method that return a promise. And then we use the simple smart contract artifact. That's what we imported just before. And this object has a deploy method that's going to return you the deploy instance of your smart contract. You are able to interact with your smart contract and execute all its functions. So since our smart contract doesn't have any function, I won't be able to show you how to execute the function in this test. But in the next test we're going to see how to do this.
00:07:29.082 - 00:08:10.390, Speaker A: So in this test what we're going to do is we're only going to console log the address of the smart contract. So simple smart contract address. And we're also going to run an assertion. For the test to pass, need to pass an assertion, which is usually a comparison. So here I want to compare that the simple smart contract address is not an empty string, because if it's empty, it means that it wasn't deployed. So this test is not very useful in itself. But this is just because this is the first test that we do together.
00:08:10.390 - 00:08:49.000, Speaker A: So it has to be really, really simple. So let's save this file and let's open another terminal window. And at the root of the project, run the truffle test command and there is an error. Let's go back to a test file and maybe that we misspelled our contract name. So simple smart contract, simple storage contract. Here it's not storage contract, it's simple smart contract. Okay, so let's save this, let's go back to our other terminal and let's run the test command again.
00:08:49.000 - 00:09:14.810, Speaker A: And this time it is working. So here you can see like so on my screen. Unfortunately the contrast is not good, but basically for each it block, it's going to print the name of the test. And if it passes, then you're going to see this arrow here. If it doesn't pass, then it's going to show you a red cross. So here it says should deploy smart contract properly. That's how you can see that the test passes.
00:09:14.810 - 00:09:35.182, Speaker A: And just above also we can see that it prints what we have in our console log. So it works. So let's just come back to our test and let's remove the console log. Usually you don't want to leave this. Just when you're developing can be useful. But what we want is this assert statement. In each it block you need to have at least one asset statement.
00:09:35.182 - 00:09:54.698, Speaker A: So that was it for our first test with the truffle framework. Congratulations. In the next test that we'll do together, our smart contract will be more interesting. Don't worry. In this video we are going to test a very simple hello world smart contract. We are going to learn how to test read only function in a smart contract. First, let's have a look at the smart contract that we're going to test.
00:09:54.698 - 00:10:22.702, Speaker A: And for this first we're going to copy the project folder from the repo of etherblocks pro. So in the repo the folder is day two, hello world, and we want the start subfolder. And I'm going to copy this to another folder. All right, let's step into our folder. And this is a standard truffle project. So let's have a look at what we have in the contracts folder. So we have the hello world smart contract.
00:10:22.702 - 00:10:50.490, Speaker A: That's what we're going to test. So this is a very simple smart contract with a single hello function that is read only. And this function very simply return a static string. So let's create a test file. So in a test directory we're going to create a file called hello World js. And let's go back to our editor and open our test file. So first thing we need to import the contract artifact of the hello world smart contract.
00:10:50.490 - 00:11:07.982, Speaker A: So let's define a variable for that hello world with an uppercase h. And here we use the injected artifact object, so that's injected by the truffle framework. And on this object we can use the require method and then we pass it the name of the smart contract.
00:11:08.046 - 00:11:09.714, Speaker B: So hello world.
00:11:09.832 - 00:11:39.638, Speaker A: So these need to be exactly the same name as your smart contracts, not the name of the solidity file, but the name of the smart contract itself. Just to make myself clear, I'm talking about this thing here needs to be exactly the same. Okay, so back to our test. Once we have this, then we need to define our contract block. So here we pass the name of the smart contract that we are testing, hello world. And after we give it a callback.
00:11:39.734 - 00:11:46.602, Speaker B: Oops, forgot to close the string here. So we define our callback, and inside.
00:11:46.656 - 00:12:08.230, Speaker A: A callback we will create one test with the it function. And we define this test, and it is very simply should return hello world. Okay, and comma. And then we give it a callback. And this time we make this callback async because we're going to use the await keyword.
00:12:09.610 - 00:12:14.310, Speaker B: So here we define this callback.
00:12:14.890 - 00:12:47.806, Speaker A: And first we need a pointer to the hello world smart contract. So let's define this pointer. Hello world equals hello world deployed. And we also want the await keyword in front of it because the deploy method is going to return a promise. So just to avoid any confusion. So here, this hello world object represent the truffle artifact. And this hello world variable here with a lowercase h point to a contract instance.
00:12:47.806 - 00:13:29.066, Speaker A: And it uses the truffle contract library for this. So it's a little bit similar to Webstery, but this is not exactly the same thing. So in your test, make sure not to be confused between the contract artifact that by convention use uppercase and the contract instance use a lowercase. And once we have done that, then we need to actually execute the method that we are testing. So we're going to put the result in a variable called result here on hello world. We execute the hello method doesn't take any argument. We also need the await keyword.
00:13:29.066 - 00:13:46.706, Speaker A: And once we've got the result then we can actually run our assertion using the assert function. And we're going to assert that result equal hello world. Okay, and that's it for our test.
00:13:46.808 - 00:13:48.194, Speaker B: Just to give you a quick recap.
00:13:48.242 - 00:14:24.930, Speaker A: So first we got the contract artifact, then we define our contract block, then we define our only test with the it function. Then we got our contract instance, then we execute the function that we are testing. We store the result in the result variable, and finally we do our assertion. And if this assertion passes, then our test pass. Otherwise our test is going to fail. So we open a new terminal window and we execute the truffle test command. So it has to be exactly in the same folder and it tell us that our test is failing.
00:14:24.930 - 00:14:27.890, Speaker A: Let's go back to our smart contract.
00:14:28.710 - 00:14:30.642, Speaker B: So the string that we are supposed.
00:14:30.696 - 00:14:54.102, Speaker A: To get back is hello world with uppercase h and uppercase world. Okay, let's see if it is what we put. No, we put lowercase H. So let's fix this, okay, and let's save our test and rerun truffle test in another terminal window. And our test passes. Woohoo. So that's it for our test of the hello world smart contract.
00:14:54.102 - 00:15:23.998, Speaker A: That was a very simple test. We learned how to test solidity smart contract and especially readonly function using the truffle framework. In this video we are going to test a simple storage smart contract. In the last video we tested a readonly solidity function. And in this video we are going to learn how to test a solidity function that can actually write to the blockchain. So that is not just read only, you can actually modify the storage of your smart contract. So let's copy over the project folder in our local directory.
00:15:23.998 - 00:16:02.330, Speaker A: So in the git repo of AWox pro you need to check out the testing smart contract 30 directory. Then the day three simple storage folder and inside you have a start subfolder and we're going to copy everything into another directory locally. Okay, so let's create this up. So once again, this is a standard truffle project and let's have a quick look at the smart contract that we're going to test. So in the contract directory, that's the simple storage smart contract. So this smart contract has a single state variable. So that's this string here that is called data and it has two functions.
00:16:02.330 - 00:16:41.870, Speaker A: The first function here is called set and has a single argument it can modify the value of our data string. And the other function is a get function just to return the current value of the data variable. So very simple smart contract. So let's go back to our terminal and we're going to create a test file. So in the test folder, let's create a file called simplestorage js. Okay, let's go back to our editor and we're going to open this file, okay, and first we're going to grab the contract artifact of our smart contract. So const simple storage.
00:16:41.870 - 00:17:31.242, Speaker A: Here we use artifact object of truffle. We use the required method, specify the name of the smart contract. Okay, then we define our contract block and we give it a name, simple storage. And here we define a callback, okay, and we define our first test in an it block. And the test will be called should set the value of data variable, because we are going to test the set function. So we create the callback, which will be an async callback. Okay, as you know, the first thing is to get a pointer to the contract instance.
00:17:31.242 - 00:18:00.354, Speaker A: So let's define this and we call this simple storage with a lowercase s. Here we use the await keyword and we use the simple storage contract artifact on which we call the deploy method. So that's going to return a pointer to the contract instance. Then we're going to execute the set function of our smart contract. So let's go to the next line. So await. And here we use the simple storage contract instance.
00:18:00.354 - 00:18:39.426, Speaker A: We execute the set function and it takes a single argument, which is the new value of the data variable. So here, let's just put this for example. Okay, so after this line, the value of the data variable should have changed to this. And now we need to check that the smart contract has actually changed this value. So let's define a variable to get the result of the get function. We use the weight keyword simplestorage. Get doesn't take any argument, so not result should be equal to this.
00:18:39.426 - 00:18:42.114, Speaker A: And so we're going to assert this.
00:18:42.152 - 00:18:46.360, Speaker B: So result equal, equal this.
00:18:47.290 - 00:19:20.634, Speaker A: Okay, let's save this. Let's open another terminal window and run truffle test. And it is working. So, as you can see, testing a function that can write to the blockchain is very similar to testing a readonly function. The difference is that in general you want to call this function that can write to the blockchain, and usually after you want to call another function to check that the value of a variable has changed as you were expecting. So that's usually you have two steps. All right, so we've made some progress.
00:19:20.634 - 00:19:55.958, Speaker A: That's it for this video. In this video we are going to test an advent storage smart contract. This contract will be similar to the one we tested in the previous video, but this time we will deal with arrays. First, let's copy over the truffle project. The folder is called day four advanced storage and you need to go into the start subdirectory. So let's copy this and let's step into our directory and let's see what we have inside our smart contract. So in this smart contract we are storing an array of integer and we have a few function to manipulate this array.
00:19:55.958 - 00:20:25.410, Speaker A: So first we have a function to add to this array. Then we have another function to get any element of this array, then another function to get all the elements of the array. And finally a function to return the length of the array. Quite simple. So we're going to test all this function in our test file. So let's go back to the command line and let's create a test file. We call this advancestorage js and we open it in our editor.
00:20:25.410 - 00:21:03.214, Speaker A: All right, as usual, we start by importing our contract artifact. We define a variable that is called advanced storage and we use the artifact object and then we call the require method on it. And here we give it advanced storage contract. So that's the name of our smart contract. Okay, then we define our contracts blocked. So it's equivalent to describe in mocha contract.
00:21:03.342 - 00:21:04.994, Speaker B: And we give it a name.
00:21:05.032 - 00:21:29.260, Speaker A: So the name of our smart contract usually. And then we define a callback. Okay, and then we need to define our first test. So for this we use the it function and we give it a name. So the first function that we're going to test. So let's go back to the smart contract. So we're going to test this add function.
00:21:29.260 - 00:21:51.914, Speaker A: So let's go back to our test and the name of this is, should add an element to ids array. And we're going to define an async callback because we're going to use the await keyword inside. Okay. Oops, this is not a square bracket.
00:21:51.962 - 00:21:53.646, Speaker B: This is a curly bracket.
00:21:53.838 - 00:23:00.866, Speaker A: Okay, so first thing is we need to grab a contract instance. So let's define a variable called advanced storage with a lowercase a. And here we use the contract artifact, advanced storage, and we use the deployed method, okay, then we going to use this advance storage variable and we're going to call the add method on the smart contract like this. And let's say that we want to add ten, so like this, and before this we use the await keyword because this return a promise and we need to wait for it to be completed. Next we need to read the value of the entry of the ids array that we just created with the add function. So let's have a look at the smart contract to see how we can do this. So here in the ids array we define this as a public variable, which means that automatically solidity create a getter function which is called ids.
00:23:00.866 - 00:23:51.878, Speaker A: And this getter function takes a single argument which is the index of the element that we want to read. So let's go back to our test and we're going to call this function. So use advanced storage ids and we pass the element of the array. So we want to read the first element and we store the result into a variable called result, and we await all of this. And finally we can run our assertion, so assertion of result equal ten. So if we do this, it's not going to work, because in truffle test when you deal with integer you don't get a Javascript number. Instead you get an instance of a big number object.
00:23:51.878 - 00:24:43.222, Speaker A: Big number is a JavaScript library to deal with very large number. In JavaScript you can only deal with number equal to this value, two power 53 minus one, which is equal to this huge number. And even though this is a huge number, actually very often in a solidity smart contract we will deal with number much greater than this, because for example, when we transfer ether, we have to deal with the way unit, and a way is something very small is ten power -18 ether. So for example, if you transfer one ether, then the number that you're going to specify in your solidity smart contract, just for one ether will be much bigger than this number and Javascript will not be able to deal with this number. So we need this big number library. By the way, just a word of caution. Webster used to use another library for big number.
00:24:43.222 - 00:25:23.122, Speaker A: It has a similar API, but it's not exactly the same. If you want to check out the documentation of the big number library that is used, make sure to go to the correct GitHub repo. We are talking of this library instead. All right, so back to our code editor, and here when we do our assertion, instead of comparing directly the result object with stent, we're going to call the two number method of the big number object to transform this object into a regular JavaScript object. And once we do this we can do our comparison and our assertion should pass. Okay, so that's it for our first test. So now let's go back to our smart contract and let's see what is the next function that we need to test.
00:25:23.122 - 00:26:06.830, Speaker A: So next we need to test the get function. So the get function returns an element of the ids array. So you might think that it is actually redundant with the public getter ids already created by solidity. And you would be right, I just created this get function to be more explicit, but actually this is not strictly required in our smart contract. With this being said, let's go back to our smart contract. We're going to copy our previous test because our next text will be very very similar. Instead of it should add an element, going to say it should get an element of the ids array.
00:26:06.830 - 00:26:57.858, Speaker A: So we get our advanced storage pointer and then we're going to create another entry in the array, we're going to add 20 and instead of calling ids and advanced storage we're going to call get and instead of getting the first element we're going to get the second element and instead of comparing to ten we're going to compare to 20. All right, so let's go back to our smart contract and see what is the next function to test. So we're going to test the get all function that returns the ids array. So back to our test. So let me copy the previous test because the it block, the structure is always the same. So should get the ids array. So let's remove the rest here.
00:26:57.858 - 00:27:58.920, Speaker A: Okay, so the first thing we still need to get our advanced storage contract instance and after it's going to change a little bit. So let's get rid of this, we're going to call get all, we don't pass it any argument and what we get here, instead of the result we're going to call this row ids. So we're going to have an array of big number here and I want to transform this array of big number into an array of regular JavaScript objects so that I can do an assertion easily after. So let's define another variable called ids, which will be this array of Javascript number. And here with row ids we use the map function to do our transformation. This map function is going to receive an id for each element and on this id we're going to call the two number method of big number. So it's going to transform our whole array into an array of regular JavaScript number.
00:27:58.920 - 00:29:06.038, Speaker A: And finally in our assertion we going to compare that this number is equal to the array ten and 20 because ten and 20 are the two numbers that we've added in our test. So here we add ten and here we add 20. Okay, but if we do this it's not going to work because in JavaScript when you compare arrays like this, it actually tells you if this is exactly the same array, but it doesn't tell you if it just has the same element. In order for this comparison to be truth, it has to be exactly the same object. We need to use another method and the assert object here has a method that is called deep equal. And in this case instead of this comparison here, it's going to receive two argument and in this case we'll be able to do our comparison even though these two arrays here are different. Javascript is going to be smart in this case and it's going to compare the elements of this array, not their identity.
00:29:06.038 - 00:29:47.394, Speaker A: So that's exactly what we want. All right, and finally, what is the last function that we need to test? The length function that returned the length of the array. So this one will be very easy. So back to our smart contract. Let's put some space here and let's copy the last it test. Okay, and instead of should get the ids array, it should be should get the length of the ids array. Okay, so we get our advanced storage contract instance and we're going to call length here.
00:29:47.394 - 00:30:48.890, Speaker A: So here instead of row id we get the length and let's delete this line. And here we're going to have a simple assert statement length equal equal two, because we have two elements in our array. Okay? And the last thing I would like to do in this test is to do a little bit of refactoring because as you can see there is a lot of code repetition in all the tests. We do the same thing when we grab a contract instance here, here, et cetera. So we're going to take advantage of the before hook of mocha. So don't forget that this contract function actually is a wrapper around the describe function of mocha because under the hood it uses mocha and the mocha framework exposes a hook called before that can run once before all the other tests. So if you need to do any sort of setup then it's a really good place to do this.
00:30:48.890 - 00:31:39.770, Speaker A: So first we're going to define a variable called advanced storage and we're not going to use const but we're going to use let because we're going to reassign it. So advanced storage and we give it an initial value of null. And here we create a before function and it's going to receive an async callback because we're going to use the rate keyword inside and we're going to move this advanced storage assignment. So let's remove the const here because we want to refer to this advanced storage variable here. And then let's get rid of the other advanced storage statement that are relevant. Okay, so now it should be fine. Let's open another terminal window and run the truffle test command.
00:31:39.770 - 00:32:03.630, Speaker A: And it almost worked, but the last test doesn't pass. Let's go back to our test and let's see why. Okay, it's because we forgot to call the two number method. I need to convert the big number object into a regular Javascript object. So let's go back to our terminal and let's run the truffle test command again. And this time it should pass. Okay, our test passes.
00:32:03.630 - 00:32:25.114, Speaker A: So in this video you learn how to test a storage contract that is a little bit more advanced than what we've seen so far. Now you know not only how to test read only function, but also function that can run transaction and actually modify the blockchain. And as a bonus, you also learn how to refactor your test by cleaning up the common code into the before hook of mocha. In this video we are going to.
00:32:25.152 - 00:32:40.894, Speaker B: Test a crude smart contract. So crude is an acronym for create, read, update and delete. This is the four most common operation you can do on any data, and that's a really good exercise to test a smart contract like this.
00:32:41.012 - 00:32:42.766, Speaker A: We are going to reuse what we.
00:32:42.788 - 00:33:28.730, Speaker B: Learned in previous video. And on top of it we will also learn how we can test when there are some errors in smart contract. When you do some testing, you not only want to test when things works well, but you also want to make sure that you test when you're expecting some errors. So it's very important to follow this video. First I'm going to copy over the bootstrap code from the git repo of eddoblocks. So you go inside the day five crude folder and after you need to grab the start subfolder and you copy this to another directory. All right, so we have our standard truffle project here, and let's look at our smart contract in the contracts folder.
00:33:28.730 - 00:33:30.638, Speaker B: That's crude. Sol.
00:33:30.804 - 00:33:32.754, Speaker A: So in this smart contract we have.
00:33:32.792 - 00:34:29.218, Speaker B: This user struct here with two field an integer id and a string name. And we have this array of user struct and basically our function will manipulate this array. So we have our create function to add an entry to this user array, read function to read an entry, the update function to update an entry, and the destroy function to delete an entry inside this user array. And finally we have this find function, but this is an internal function so we're not going to test it directly. We are going to test this four function here, create, read, update and destroy. By the way, note that we start our next id at one. So when we are going to read a new entry in the array, we're going to start with id one, not zero.
00:34:29.218 - 00:34:52.918, Speaker B: Next I'm going to open the test file. So this time I've already prepared it in the bootstrap code. So this is inside the test directory and the file is called crude js. So in my editor I'm going to open it side by side with the code of the smart contract so that we can see both at the same time. So here I import the crude artifact.
00:34:53.014 - 00:34:54.314, Speaker A: So that's what we need in order.
00:34:54.352 - 00:35:26.018, Speaker B: To interact with the smart contract. And after I define a contract block. So that's where we're going to put all our test. Before we start our test, we want to grab a pointer to the deployed instance of the crude spot contract on the blockchain. We're going to need this pointer in all our test. If you remember in the last video, what we did is we took advantage of the before hook of the testing framework of truffle to define only once this pointer. Otherwise we have to define this pointer in each test.
00:35:26.018 - 00:35:44.854, Speaker B: And it's a little bit annoying to do this. So we're going to use the same technique in this video. So here let's define a variable that we call crud. And first it's going to be null. And then we define a before hook.
00:35:44.982 - 00:35:47.002, Speaker A: So that's going to be executed before.
00:35:47.056 - 00:36:16.002, Speaker B: All the tests run and only once. And we're going to define an async callback. Okay. And inside this async callback, we're going to assign a value to our crude variable. So crude equal await. Crude deployed. All right, so now with this crude variable we will be able to actually do our test.
00:36:16.002 - 00:36:59.906, Speaker B: So let's start with our first test for the create function. And we're going to make sure that this create function actually create a new user in the user's array. So let's define our first test with the it function. And we give it a name, so should create a new user. And then we define its async callback. So async, because we're going to need the await keyword inside this function, okay? And the first thing we're going to do is we're going to call the create function of the smart contract. So we use the crude pointer that points to the deploy instance of the smart contract and we call the create function.
00:36:59.906 - 00:38:00.082, Speaker B: And this create function is going to take a single argument which is the name of the user. So let's call our first user Frank, all right? And we're going to wait this, otherwise the next line is going to be executed before we finish creating this frank user. And now we want to make sure that this user has been created. So for this we are going to call the read function of the smart contract and we're going to give it one as an argument because the first user id is one in our contract and we're going to await this and store the result in a variable that we call user. And finally we are going to do our assertion. So this user variable should be an array with two fields. So if we check in a smart contract at the definition of the read function, we are going to return the two field of the user struct.
00:38:00.082 - 00:38:49.350, Speaker B: So first the id and then the name. So in JavaScript we're going to see this as an array. So let's assert that the first entry of this array that we convert to a normal JavaScript number. So remember in a previous video I told you that truffle uses the big js library in order to deal with number, and we need to call this two number method in order to actually work with this number in JavaScript. Otherwise what we get is an object and we cannot really work with it. And we're going to assert that this is equal to one and we're going to do another assertion for the other field of our struct. So the second entry of the array and this time it should be equal to frank.
00:38:49.350 - 00:39:35.170, Speaker B: Okay, so we are done with testing our create function. So the next function to test in our smart contract is the read function. However, in the test of our create function we also tested the read function here. So we're not going to do another test just for read, it's already done. So next we have the update function to update an entry, a user entry in our smart contract. So we're going to create a test for this function. So in our test file let's create another test with the it function and we call this test should update a user and we define the async callback.
00:39:35.170 - 00:40:09.840, Speaker B: Okay, so we are going to call the update function. And the update function takes two arguments. So the first argument is the id of the user to update, and the second argument is the new name of the user. So back to our test file. So we're going to wait, crude update. So first argument, the id of the user. So that's one because we're going to update Frank that we created just before and the new name is going to be frank but with two k this time.
00:40:09.840 - 00:40:50.550, Speaker B: Okay, and once we do this we are going to read the value of Frank and this time it should change with Frank with two k. So you know what, we can just copy paste the code that we have above. So read and assert. So let's paste this. So we read the first entry and then the id should be one. And this time the name of Frank should be frank with two k. Okay, so are we done with testing the update function? You may think that yes, but actually we don't.
00:40:50.550 - 00:41:33.766, Speaker B: So if we go to the code of the smart contracts, I'm going to scroll down a bit. So we see that in the update function we execute a find function to find the id of the entry to update. And if we scroll down to the find function we can see that in this find function we have a revert statement. And this revert basically is going to throw an error if we cannot find the user in our user's id. Basically if we try to update a nonexisting user then this function is going to throw an error and our transaction is going to fail. So we also need to test this. So back to our test file.
00:41:33.766 - 00:42:37.614, Speaker B: We're going to define a new test and we're going to call it should not update a non existing user. And we define our async callback. And inside our callback we're going to try to update a nonexisting user. So we're going to update crud update and we're going to pass an id of two so we know that this user does not exist. And let's try to update this to, I don't know, to frank with three k. And if we just do this, actually this test is going to fail because when we have an error in our smart contract then truffle is going to pass the error to our test and our test runner is going to interpret this as a test failure. So we want to actually catch the javascript error that will be thrown here.
00:42:37.614 - 00:43:32.782, Speaker B: And the way we do this is by using a try catch block. So try is the way you catch error in JavaScript. So this is very similar to many other language. So everything that throw error inside a try block will be caught by the Javascript engine and will not make the process crash so we can recover from it. And after you need to catch the error in a catch block, and so here you define a variable that will receive the error. So in our case it's e, and here we're going to run an assertion, and inside our error we have a field. So error, it's an object and this object has a message field and this message field.
00:43:32.782 - 00:44:03.466, Speaker B: So this is going to be a string and we're going to use the includes method of JavaScript to test for a specific string. And we want this error message to be user does not exist with exclamation point and we close this. And how do I know that we need this error message? Well, if you look inside the smart contract, so in the find function in the revert statement, you can see that.
00:44:03.648 - 00:44:05.526, Speaker A: We are going to display this error.
00:44:05.558 - 00:44:50.106, Speaker B: Message, user does not exist. Okay, and here I need to close a parenthesis. All right, if we do this, are we done? No, because let's say that our update function does not throw an error. So that means that we have a problem in our smart contract. So in this case this catch block here is not going to be executed and the test is going to pass, although there is an error. So what I want to do is basically once the error is thrown inside the try block, so the execution is going to go inside the catch block. I want my assertion to pass, and after I'm going to return, so the execution is going to stop.
00:44:50.106 - 00:45:39.882, Speaker B: And outside the try catch block I'm going to have another assertion that will always fail. So the way you do this is by asserting that something is false and this will only be reached if here when I try to update the nonexisting user. If there is no error that is thrown, then I will never go inside the catch block. And instead I'm going to go outside the try catch block and I'm going to run this assertion and this is going to fail. So that's how I know that something is wrong in our smart contract. So what I show you in this test is how you can test errors in smart contract. All right, so now that we are done with the update function, the next function to test is the destroy function.
00:45:39.882 - 00:46:48.522, Speaker B: The destroy function delete an entry inside the user array of the smart contract. So let's go back to our test and we're going to define a new test for that, and we're going to call it should destroy a user. And then we define our async call pack and then we're going to execute the destroy method. So I'm going to wait crude destroy and let's destroy a user that exists. We know that the user with id one exists, okay? And once this user has been destroyed, if I try to read it then I should have an error. But just above we'll learn how we can test an error so we can leverage this in order to complete our test. So we are going to try to read a nonexisting user and this is going to throw an error and we're going to catch this error.
00:46:48.522 - 00:47:48.450, Speaker B: So let's define a try catch block like we did before and we are going to await that crude read finish executing and we're going to try to read the user with id one. So this is going to throw an error because we just destroyed this user so it doesn't exist anymore. And we're going to catch the error. And here we going to assert that the user does not exist. So I'm going to copy the line from the test just above and I'm going to paste it, all right, and I'm going to return and finally I'm going to assert false. So we're going to reach here only if there is a problem with our test. And that means that the crude read line here doesn't throw and we continue the execution until here, which mean we have a problem because the destroy function should have deleted this user.
00:47:48.450 - 00:48:44.050, Speaker B: Okay, so we are done with our test of the destroy function. So that's what we call the happy path of the test. But there is also an unhappy path if we give a bad argument to destroy. So what happened if you try to destroy a user that does not exist and in this case an error will be thrown and we need to test this. So let's define this test as well. So let's define another test and we call it should not destroy a nonexisting user and we define an async callback, okay, and so we're going to try to delete a user that does not exist. So await crude destroy, for example, ten.
00:48:44.050 - 00:49:25.770, Speaker B: So we know that this user does not exist. So we want to catch this because this is going to throw an error and here we're going to catch the error and put it in the e variable and let's copy this assertion in the test above. User does not exist because we're going to have the same error. So back to our test. We're going to paste this. And as usual we have our return statement here and assert false because we never supposed to reach this stage in the execution. And that's how we test the unhappy pass of the destroy function.
00:49:25.770 - 00:49:50.838, Speaker B: All right, so that's it with this test. Now we need to run the test and make sure that everything works. So I'm going to open a new terminal window and I'm going to run the truffle test command and all. My test pass. Yeah, so everything is working fine. So the major thing that you learn in this video is how you can test when error has run inside your smart contract.
00:49:50.934 - 00:49:52.506, Speaker A: And you test this by using a.
00:49:52.528 - 00:50:51.162, Speaker B: Combination of try, catch, block and assert statement in your Javascript test file. So I really hope that you learn a lot on smart contract testing using solidity and truffle. Watching this video. If you want to keep learning and really go to next level and learn how to test advanced smart contract and learn some really very advanced pattern for testing, then check out my full course on a smart contract testing on in the blocks Pro. It covers 30 smart contracts, so you can see all the smart contract in the class curriculum. So it really ranges from very simple smart contract like the one we did, so beginner level. So all the way to intermediate and even to advance where we test smart contract like Yasi 20 token Ico, Yasi 721, cryptokitties game, Twitter, eBay, et cetera, cetera, et cetera.
00:50:51.162 - 00:50:58.460, Speaker B: So that's really a great way to become expert in smart contract testing. Thanks for watching and see you in my next video.
