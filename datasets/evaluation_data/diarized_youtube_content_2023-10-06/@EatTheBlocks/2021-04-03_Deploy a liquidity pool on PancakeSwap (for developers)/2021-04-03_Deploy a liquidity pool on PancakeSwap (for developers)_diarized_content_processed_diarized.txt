00:00:00.250 - 00:00:16.554, Speaker A: If you want to give some value to your token, you need to have a market with buyers and sellers. In DeFi, we call this a liquidity pool. You can create a liquidity pool on any decentralized exchange. It's permissionless. And I would recommend to start with Pancakeswap, one of the most popular decks.
00:00:16.602 - 00:00:18.122, Speaker B: On the binance smart chain.
00:00:18.186 - 00:00:24.058, Speaker A: So our challenge in this video is to deploy a liquidity pool on Pancakeswap by using node js.
00:00:24.154 - 00:00:25.254, Speaker B: If you don't know me, I I'm.
00:00:25.292 - 00:00:28.870, Speaker A: Julian, and on the blocks at each blockchain development.
00:00:32.890 - 00:01:05.002, Speaker B: It'S possible to create a liquidity pool just by using your mouse. No coding required. You go to the interface of Pancakeswap. You do as if you were adding liquidity to an existing pool, except that you copy paste the address of your tokens in the widget. You submit the form and pancake swap will automatically create the new pool for you and add the liquidity at the same time. It's easy, too easy. But we are programmers, and why making it easy when we can make it complicated? We want to deploy our liquidity pool.
00:01:05.066 - 00:01:07.778, Speaker C: With code, otherwise it's not fun.
00:01:07.944 - 00:01:09.826, Speaker B: But jokes aside, being able to do.
00:01:09.848 - 00:01:32.838, Speaker C: It with code is much more powerful than just using the interface, as you can automate the deployment of new pools based on the logic of your application. To deploy a pool on Pancakeswap, we will call the factory contract. That's a smart contract that creates new pools and keep a list of all the pools created after we will have a new pair contract deployed. Each pool has its own pair contract.
00:01:32.934 - 00:01:34.742, Speaker B: At this point, there was no liquidity.
00:01:34.806 - 00:02:01.470, Speaker C: In the pool, which means nobody can buy and sell tokens. It's better to supply the initial liquidity yourself so that you can set the initial price. For that, we will use another contract called the router contract. There is one router contract for all pools. We rarely interact directly with a pair contract because there are some caveats and if you're not careful, you can lose some tokens. Instead, we will use the router contract to interact with the pair contract.
00:02:01.550 - 00:02:02.946, Speaker B: It's easier that way.
00:02:03.048 - 00:02:05.330, Speaker C: Okay, so next we're going to start the coding.
00:02:08.970 - 00:02:47.790, Speaker B: So this is a truffle project that I created in the GitHub repo of it, the blocks, and we're going to go in the contracts directory. And so here are a couple of contracts I created to interact with pancake swap. So we're going to start with factory. So we're not going to deploy this contract. It already exists. I only created this code so that we can have the ABI which will be used to interact with this contract. So this contract in reality it has many more function, but we will only need the create pair function where we pass the address of the two token of our pool.
00:02:47.790 - 00:03:26.346, Speaker B: Next we have the router contract. So once again it has many more function in reality, but we only need the add liquidity function. So I just copy paste the function signature with no implementation. So here we can see the different parameters. So we need the address of the two tokens, then the amount of each token that we provide. Because when you add liquidity, you need to add the same value for the two token. And you also need to provide some flexibility because depending on the current price of the liquidity pool, you can only get a certain ratio for the two token.
00:03:26.346 - 00:04:13.022, Speaker B: For example, let's say that when you call this function, the two token have exactly the same value. So for example here you could put 101 hundred, but maybe that when your transaction will reach the smart contract, the price will have changed a bit. So if you put 100 of token a, you can only get 90 of token b. So in amount a mean and amount b mean, that's where you express what is your flexibility. So in return, you're going to receive an LP token that you can redeem at any time to get your initial token back, plus the trading fee. So you have to put the address where the LP token will be sent, and also you have to specify a deadline. So that's a timestamp in second.
00:04:13.022 - 00:05:02.346, Speaker B: So this is to protect you if your transaction gets stuck in the memory pool and only is executed a few days later when the market is completely different, in which case the amount you specify for amount a min and amount b min won't be good anymore. So you need this deadline to protect you. All right, so that's it for this smart contract. Next we have the pair contract. So we're only going to need the balance function to check that we got the LP token after we add liquidity, and then also created two token. So these are the token that will be deployed for our pool. So these are some simple yes, 20 token, and we're going to mint some token to the address that deploy this contract.
00:05:02.346 - 00:05:43.686, Speaker B: And this is the same thing for token two. All right, so after we're going to write the code to deploy our liquidity pool. Okay, so I've created a script to deploy our pool. So in the scripts folder deploypool js. So first of all, I import the truffle contract artifact for all the contract we need to interact with factory router pair and two tokens of our pool. And after we export a function. So that's what you need to do for truffle script.
00:05:43.686 - 00:06:22.914, Speaker B: So truffle is going to inject an instance of web three in our file. So that's why we can use webstery here without importing it first. So first we're going to get a list of the accounts that are available to sign transactions. So we only care about the first address, that's the admin address. Then here we going to get pointers to existing contract on the binance smart chain. So here you can do this by using the contract artifact. So here factory and you use the add function and you specify the address of your contract.
00:06:22.914 - 00:06:58.846, Speaker B: So I use the address of the factory and the router on the testnet of binance smart chain, but you can update this with the address on mainnet if you want. After here, we deploy the two tokens of our pool. So maybe that in your case the tokens are already deployed so you might not need this part. And after we are going to create our liquidity pool by calling the create pair function on the factory smart contract. So the first call to the create pair function. Here we will not send a transaction. We will call this function in read only mode.
00:06:58.846 - 00:07:37.194, Speaker B: So that's something that few people know. But even though you have some function that are meant to be called in a transaction, it's still possible to call this function in readonly mode. So that's the case of create pair. We use an internal library of truffle, called truffle contract to interact with smart contract. And the way you force truffle contract to execute a function in a readonly mode is with this notation. So the name of the function call and then you specify the argument. So you give the address of the two tokens and in return it's going to give you the address of the pair.
00:07:37.194 - 00:08:31.626, Speaker B: So at this point, the pair has not been deployed yet, but internally, the factory contract uses the create two opcode that allows to deploy smart contract in a deterministic way where you can know the address before deployment. So here we already know this address before the deployment, and we're going to use this later in our script. And after we call the create pair function in the standard way by sending a transaction, and we provide the two argument and we receive a transaction object. And so at this point, the pair smart contract was deployed. One thing that is very important to note is that the address of the two token token one and token two one thing that is very important to note is that the order of the two tokens is not important. You can specify token two first and token one first is going to result in exactly the same pay address. Okay, so at this point our liquidity pool is deployed.
00:08:31.626 - 00:09:11.066, Speaker B: The next step is to provide the initial liquidity. Once you have deployed your liquidity pool, it's very important to provide the initial liquidity because this allow you to set the initial price. So before you call add liquidity on the router smart contract, you need to approve your two tokens to be spent by the router. So that's what we do here. And after we're going to call the add liquidity function. So we pass it the address of the two token, then we specify the amount of the two token we're going to send. So 10,010 thousand.
00:09:11.066 - 00:09:47.560, Speaker B: So this implies a price of one. But if you wanted to make token two more expensive relative to token one, then you could put less of token two, for example. And after we also need to specify the minimum amount of token one and token two that we are willing to accept. So in our case, because we provide the initial liquidity, we are the one who set the price. What we put here for these two parameters is exactly what we're going to get. So here for the amount minimum, we put exactly the same thing. And after the recipient for the LP token it's going to be the admin address.
00:09:47.560 - 00:10:19.294, Speaker B: And for the deadline we use data of JavaScript. This gives us the timestamp in millisecond. But for the smart contract we need a timestamp in second. So we divide by 1000 and then we add 10 minutes. And after that we create a pointer to the per smart contract of our liquidity pool and we call balance off with the address of the admin. And then after it it's going to give us the balance of LP token that we get. So there are two caveats.
00:10:19.294 - 00:11:02.958, Speaker B: First, when I tried to call add liquidity the first time for the amount of token I put 1000 and it didn't work. I had a look at the pair contract of pancake swap. I went to the mint function, which is the function called when you provide some liquidity. So first you call add liquidity of router and the router contract called this mint function on the pair contract. And there is something interesting here. So if the total supply is zero, which is the case when we provide liquidity for the first time, there is this variable that is calculated liquidity. So here we calculate some number, and after we subtract this minimum liquidity thing.
00:11:02.958 - 00:11:46.478, Speaker B: And below we require that this liquidity is superior to zero, otherwise this is going to throw an error. So then I went above to see what is the value for this minimum liquidity, and that is 1000. So that means if we don't add enough liquidity when we call add liquidity function, it's going to fail. So I increase the amount of token that I initially provide to 10,000 and logically it should solve the problem. But when I tried again to run this grid, I had another error and the transfer of token was failing. And at first I couldn't find a solution. I knew that I'd approve enough token 10,000.
00:11:46.478 - 00:12:32.758, Speaker B: Then we transferred 10,000 token here, so should be fine. So what I did to debug this is that I console log the number of token that is owned by the admin address just before we call add liquidity, and I found that it was 1000, not 10,000. But that's weird because in the contracts folder here in token one and token two, we mint much more than 1000, so it should be fine. But then I realized another thing. Initially when I first created token one and token two, I only minted 1000. But when you execute truffle script, it does not recompile your smart contract. So that means it was still deploying the old version of my token where we only mint 1000.
00:12:32.758 - 00:13:09.798, Speaker B: So when we were trying to transfer 10,000, it didn't work. So I had to manually run the truffle compile command, and then I was able to run my script successfully. Okay, so that's it for the explanation of the code of our script. Next we are going to run our script. So we are going to run our script on the testnet of binance smart chain, but you can also run it on binance smart chain mainnet. So first you have to define a new network in truffle config. So here you have to copy paste yobnemonic.
00:13:09.798 - 00:13:56.882, Speaker B: And after in networks I define a new network for the testnet of binance smart chain. So this URL is given by the documentation of binance smart chain and network id as well. And we also pass the mnemonic that we defined before so that we can sign transaction. I also went to the faucet for the testnet of binance machine to get some testnet BNB token, and after went to the root of the project, you have to install the dependency with NPM install. Then we're going to run script with truffle exec and we give the path to the script. So script deploy pool and we have to specify the network. So that's finance smart chain testnet.
00:13:56.882 - 00:14:15.306, Speaker B: All right, let's run this. And it worked. And at the end we can see that we have 9000 lp tokens. So even though we sent 10,000 token, we only have 9000. That's because when you first provide liquidity, there are 1000 token that are burned by the pair.
00:14:15.338 - 00:14:16.378, Speaker C: Smart contract.
00:14:16.554 - 00:14:43.380, Speaker A: That's great. We won our challenge, which was to deploy a liquidity pool on the pancake swap on the binance smart chain. Since pancake swap is a fork of Uniswap, you can reuse the same method to deploy new pools on Uniswap, as well as on any other fork of Uniswap like sushi swap or bakery swap. If you want to learn more about how Pancakeswap work, check out this video about Uniswap. It works exactly the same as for Pancakeswap. I will see you there.
