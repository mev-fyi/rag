00:00:00.170 - 00:00:37.646, Speaker A: In your smart contract projects, if you want to represent fungible asset, the token standard you need to choose is ESC 20. Instead of writing your own implementation of the ESC 20 token standard, it's safer and faster to use the implementation of open zeppelin. So in this video I'm going to show you how you can create an ESC 20 token with open ziplim. Hey, I'm Julian and on my channel eat the blocks, I teach how to become a blockchain developer and get your first blockchain job. So this is a truffle project. I've already installed open zeppelin with NPM. And next I'm going to create a file for my ERC 20 token.
00:00:37.646 - 00:01:19.750, Speaker A: Let's open our new file. I specify the version of solidity, then I import the ESC 20 smart contract from open zeppelin. Then I create a smart contract for my token and I'm going to inerate from the ESC 20 contract of open zeppelin. And that's all I need to do. Now you can call all the function of the ES 20 token standard on my smart contract because it inherited from the ES 20 token of open zeppelin. Next, you probably want to attach some metadata to your token. So for that we can use another contract of open zeppelin which is ERC 20 detailed.
00:01:19.750 - 00:01:58.050, Speaker A: And the way you're going to combine this with what we've imported previously is by also inheriting from this contract. So in solidity it's possible to inherit from several smart contract and for that you need to use a comma. So here we specify our second contract. By the way, the order of declaration is important. Here you need to first inherit from ES 20 and after ES 20 detail. And once you've done that, then you need to define a constructor. So the constructor is what's going to be called when your token is deployed.
00:01:58.050 - 00:02:52.446, Speaker A: So our constructor doesn't take any argument. However, we can call the constructor of one of the parent smart contract. So in our case we're going to call the constructor of YeS 20 detailed and we're going to give it three value. The first one is the name of our token. So this is a string, so for example my token, then the symbol of the token, so for example iMTN and finally the number of decimal of our token. So in most cases we want to do like for ether, that is 18. By the way, if you are not clear of how Yas 20 token works and what is this decimal thing, then you can check out this video of my series on Ethereum tokens.
00:02:52.446 - 00:03:40.414, Speaker A: So now with all this metadata attached, it's possible to call three new function on your token, the name function, the symbol function and the decimals function. Next, if you want to make your token burnable, that means that it's possible to destroy some coin. Then you can use another contract of open zeplinks. That's Yas 20 burnable. So in this case you're going to add this Yasi burnable. And now you have access to a new function which is burn. And you have to pass the number of token that you want to burn, and it's going to burn the token for the sender of this transaction.
00:03:40.414 - 00:04:12.830, Speaker A: Next, you probably want your token to be mintable. So that means that at any time you can create a new coin. So for that there is another token called ErC mintable. And so now you have a new function defined on your smart contract. So that's the mint function. And the first argument is the address that will receive the new mine coin. And the second argument is how many token you want to create.
00:04:12.830 - 00:05:04.190, Speaker A: So of course not everybody can call this function because otherwise that will be too easy. Anybody could create as many coin as they want. So only the address that deploy your token will be able to call this function. Or if you want to delegate this responsibility to another address, you also have access to a function called add minter. And so here you can pass the address of the minter like this. And after once the administrator of your contract, so that means the first person who deployed the contract added a minter, then this minter is able to call the mint function. Next, maybe that you want to allow new token to be minted but up to a maximum value.
00:05:04.190 - 00:05:51.702, Speaker A: So in other words, you want to cap the amount of token that can be created. There is another smart contract of open zeppelin that can help you and that is called ERC 20 capped. So in this case you're going to also inherit from it. And we also need to call the constructor of this smart contract. So you can actually call several constructor. So after the first constructor here of Yas 20 detail, then we specify that we want to call the constructor of Yas 20 capped and we're going to pass the maximum amount of token that we want to mint. So for example, if I pass 1000 here, I can only mint up to 1000 token.
00:05:51.702 - 00:06:40.780, Speaker A: If I try to mint more token than this, then it's going to throw an error. Next, you might want to implement a post feature in your token. So with a post feature, when your contract is post, it's not possible to transfer token or to change the allowance for a specific spender. So for that you need to import ERC 20 possible and you inerate from it. And then we have some extra function defined on this contract. So you have the pose function, you can also unpose. It's also possible to know if the contract is posed or not with the posed function.
00:06:40.780 - 00:07:24.422, Speaker A: And of course in order to call this to function, pose and unpose, you need to have special privilege. So if you are the address that deployed the contract, you have this privilege. Otherwise you need to get granted this privilege. So the admin of the contract or another poser can call the add poser function, and here you specify the address of the poser. There is also an alternative implementation of ERC 20 which is called safe ERC 20. So actually the way it works is first you import safe ERC 20. So here I'm going to create another token.
00:07:24.422 - 00:08:19.820, Speaker A: My token two is safe ERC 20. So it works the same way as the ERC 20 token, except that when you do a transfer of token, it makes sure that the recipient, if this is a smart contract, it needs to know how to handle token. Because sometimes people send token to other smart contract that don't know how to handle token and then the tokens are locked in this contract. So with safe es 20, then you will not have this issue. Another thing that can be interesting to do is to interact with another smart contract with another token from your token. So for that what you could do is import the interface of Yas 20. So that's called IeS 20.
00:08:19.820 - 00:09:04.550, Speaker A: And then in your Yas 20. So let's create a function foo here. If you want to interact with another Yas 20 token, then you use the interface of the Yas 20 token. Then you pass the address. So CRx whatever, and then you can call all the function of this other token like transfer, et cetera. So if you wonder how comes I know all these tricks, I've actually looked inside the git repo of open Zeppelin at this address. So if you want more info, you can check it out.
00:09:04.550 - 00:09:21.340, Speaker A: So with ERC 20 tokens you can represent a fungible asset. But there are many assets that are actually nonfungible, and for that you need to use the ERC 721 tokens. And in the next video of this series, I'll show you how you can create an ERC 721 token with open Zeppelin. I'll see you there.
