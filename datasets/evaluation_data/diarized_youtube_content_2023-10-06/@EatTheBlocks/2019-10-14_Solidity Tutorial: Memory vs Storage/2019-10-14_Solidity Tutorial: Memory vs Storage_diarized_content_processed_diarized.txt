00:00:00.410 - 00:00:31.426, Speaker A: Hey, hey. This is Julian and you are on idoblox. And in this video I'm going to explain you the different memory location in solidity. By the way, I created a free email course to teach you how I got my first remote blockchain job. Paid $100,000 a year. So if you want to learn all my secrets, you just have to sign up at this URL. If you remember, in the previous videos, when manipulate arrays, sometimes we use the memory keyword and some other times the call data keywords.
00:00:31.426 - 00:01:02.618, Speaker A: So these are actually memory location and there are four of them. We have storage, memory stack and call data. So let's start with storage. Storage mean that you store a variable inside the blockchain. This is persistent, so you can still read the value of your variable in the future. It's not going to be stored just at the moment when you invoke a function in solidity. Later you can still find this value.
00:01:02.618 - 00:02:07.186, Speaker A: So when you declare a state variable, so a variable which is outside function, like for example if we declare a variable uint a like this, this is a state variable and this will have as a memory location storage. So when you want to declare a storage variable, you don't have to specify the storage keyword. The mere fact that it is outside a function already makes it a storage variable. We still need to use the storage keyword when we want to create pointer to deeply nested data inside the storage. So let me give you an example. So first we're going to create a struct user and it's going to have a single field name. And after that let's create an array of user, so user array like this and call this users, okay? And so now inside a function we want to create a pointer to a specific user instance.
00:02:07.186 - 00:02:44.878, Speaker A: So let me show you this. So we have our function here. So we want to manipulate one of the users. So what we could do is for example, we could reference specific users like this user one, and then we could access its name field. But if you have a deeply nested data, this might not be very readable. So instead what you might want to do is define a pointer. So first you define the type of the pointer, then you specify the memory location.
00:02:44.878 - 00:03:30.602, Speaker A: So here we point to the storage. Then you give a name to your pointer, so user. And then you specify the array and you specify the index. And so now if you want to manipulate a specific user struct in storage, you just use the user pointers, username equal, whatever you want. Then we have the memory data location so contrary to storage with memory, this is not stored inside the blockchain. This is not persistent, but this is just short term. It's only kept in memory during the execution of your function and after it is destroyed.
00:03:30.602 - 00:04:26.130, Speaker A: So for example, inside our foo function, if we wanted to make a copy of the user, then instead of storage we could replace this by memory. So that means that below when we change the username, it does not affect the users that are stored inside this users array here, but it just affect what we have in memory. And after the function stop, then all the changes are lost. Another thing you might want to do with a memory variable is pass it to another function. So let's say that we have another function that we call bar, and this is going to accept a user's truck coming from memory. So how can we specify such an argument? Well, first we specify the user type, then we specify the memory location. And finally we specify the argument name so user.
00:04:26.130 - 00:05:03.120, Speaker A: And let's say that it is an internal function. So this can only be called from inside the smart contract. Well in this case in the foo function, then you can call the bar function by passing the user variable. And this is how you will pass a memory variable from one function to the other. Next we have the stack memory location. So stack is basically every simple variable that you declare inside a function. So let me get rid of everything.
00:05:03.120 - 00:05:40.294, Speaker A: So let's say that I declare a variable inside my foo function b, for example integer b. So this is placed on the stack. This is a memory location that is only available to the foo function and its lifetime is the same as the functions. When the function starts, then this is accessible. When the function stop, then this is lost. You don't have to do anything to declare or manipulate a stack variable. You just have to declare your simple variable type inside function and automatically they will have the memory location stack.
00:05:40.294 - 00:06:39.858, Speaker A: The only thing you need to know is that in some cases in solidity you can have an error because you declare too many variable inside your function. So in the error message it will say something like too many stack variable stack size exceeded. So if you see this, that means you need to remove some of the variable declaration inside your function. Okay, and finally we have the call data memory location. So this memory location is only available for function that are either external or public because it reference complex data in transaction. So let's say that you call the foo function and one of the argument is an array of user, for example, so user array and here if directly. So if you try to give it a name then solidity complains because he wants a memory location.
00:06:39.858 - 00:07:30.890, Speaker A: So you might think oh, okay, well the argument might be the more relocation, right? No, solidity is not happy because this is an external function. Solidity knows that only transaction can call this function and the complex data that you put in transaction do not have the memory location but they have the call data location. And that was actually a bad example because array of three dt struct are not supported without the ABI pragma statement. So bear with me. Okay, well instead of an array of user, let's say we have an array of integer. Well, okay, so this time it works. Remember when you accept an array coming from a transaction in your function then the memory location is called data, not memory.
00:07:30.890 - 00:07:39.020, Speaker A: All right, that's it for this video. In the next video I'm going to talk of how you can deal with events in solidity. Thanks for watching it.
