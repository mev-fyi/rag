00:00:00.250 - 00:00:58.750, Speaker A: In your smart contract, if you need to represent a nonfungible asset, which is an asset that cannot be exchanged against another one, you need to use the ERC 721 token standard instead of creating your own implementation of ERC 721. It's faster and safer to use the implementation of open ziplim. In this video, I'm going to show you how you can create an ERC 721 token with open zeppelin. Hey, I'm Julian and on my channel idoblocks I will teach you how you can become a blockchain developer and get your first blockchain job. For the demonstration, I'm going to use a truffle project. If you don't know what is truffle, you can check out this introductory video. I've also already installed the NPM package of open Zeppelin, so I'm going to create a smart contract called MyToken Sol and I'm going to start with the pragma statement of solidity.
00:00:58.750 - 00:01:57.586, Speaker A: Then I'm going to import the ERC 721 token of open zeppelin. And after I'm going to create my token smart contract that's going to inherit from the ERC 721 token of open zeppelin. And that's it. I have my token, so you can just publish your smart contract like this, but chances are you want actually more stuff in it. So fortunately for us, Openzeplim also provides some other options that we can add to our token. So let's have a look to the repo of open Zeppelin and in the contracts directory we're going to find the token directory, then ERT 721 and we will see the different option. So one option that you will want almost for sure is the metadata option.
00:01:57.586 - 00:02:50.686, Speaker A: So the metadata option will give you some additional function. So first of all your token will have a name, then it will have a symbol, so like for ER 721 and you will also have a URL for each of the token that you're going to create. So that's what you see here in the token URI. So there's actually a mapping of the token id to the URL, to the string URL of the token. So you have a base URL and a suffix for each. So these two things form the full URL basically. So if you scroll down then you see that once you use this option, you need to use this constructor here with the name and the symbol.
00:02:50.686 - 00:03:18.170, Speaker A: Then you'll have this function, name, symbol and also token Uri to have the token URL of a specific token. So in order to use this how we're going to do. So let's scroll up. So the name is ER 721 metadata. All right so let's go back to our smart contract. We're going to import this. So yeah 721 metadata.
00:03:18.170 - 00:04:22.122, Speaker A: And we're going to inerate from it yas 721 metadata. And this time we need to declare our constructor and after we're going to execute the constructor of Yash 721 metadata. And the first argument is the name of our token. So for example my super token and second one is the symbol so I don't know my super token. All right another extension that you might be interested in is the enumeration extension that allow you to enumerate all the tokens that a specific address possess. So let's go back to the repo of open zeppelin and let's see where we have this extension. So ER 721 enumerable.
00:04:22.122 - 00:05:11.520, Speaker A: So let's click on this and let's see what this offer, let's scroll down. First we see that there is a constructor. So that means we'll need to call this constructor in our token. And then we see a couple of functions. So token of owner by index, so token of owner by index which will give you the token id for a specific address and a specific index. So let's say that this address has let's say ten token. So that means that you will be able to call this function with the address here and for the index it's going to be zero, one, two et cetera up to nine.
00:05:11.520 - 00:05:55.390, Speaker A: And after when you will try to call this with index equal ten then this require statement here is going to fail. So if you want to enumerate all the token of a specific address then you call this function with the correct address. You start with zero and you increment it until you have an address, until you have an error. Then we have two other functions. So total supply, so that will give you the number of token that were created on this smart contract and token by index that will give you the token id for a specific index. So first you call the total supply function. So let's say it tells you that on this contract you have ten token.
00:05:55.390 - 00:06:32.582, Speaker A: Then you'll be able to call token by index from zero to nine. So you'll enumerate all the token of the contract regardless of who is the owner. And after if you go out of bounds then this requires statement here it's going to fail. So with this three function. So with this one here you can list all the token of a specific address. And with these two function, you can list all the token of the whole smart contract regardless of the address. So if we want to use this in our smart contract.
00:06:32.582 - 00:07:32.990, Speaker A: So let's see how this work. So here I import, and I'm also going to call its constructor, even though it doesn't require any argument, Yasi 721. All right, so actually this is super common that we want the enumerable extension and the metadata extension of the ERC 721 standup. So that's why Openziplink has already created a contract for that that is called ERC 721 full. So if we look into it, we can see that it's already configured to work with ERC 721 enumerable and metadata. So if we want to use this, then in this case, it's much more simple. We don't need to import metadata, we don't need to import enumerable.
00:07:32.990 - 00:08:08.950, Speaker A: All we need to do is to import even, eh, 721 full. And here we replace this by full. And here 721 full. And we still pass this argument here we don't need any variable. And that's it. So next we're going to see how we can make our token burnable. So let's go back to the repo of open zeppelin, and here we can see that we have a burnable extension.
00:08:08.950 - 00:08:36.340, Speaker A: So there is no constructor. So we don't need to put this in our constructor. Okay? And this will give you this burn function. So we provide the token id and it's going to burn the token. And of course, only the owner or someone that has been approved is able to burn a token. So the name of this is Yasi 721 burnable. All right? So let's import this.
00:08:36.340 - 00:09:22.650, Speaker A: By the way, let's re import our normal yacht 721. All right? And here we want ERC 721 burnable. Okay? And we remove all of this. Cool. So if we want our contract to be burnable, we probably also want it to be mintable so that we can create new token dynamically. So let's see what openzepling has in store for us. So the openzepling, do you have any mintable option? Yes, you do.
00:09:22.650 - 00:10:16.750, Speaker A: So here we have a first mintable option that will give us a mint function. So we can see that we can specify the recipient address and the token id. Only the minter can call this. So by default, the minter is the address that created the token. All right? And there is another version of this extension, which is, yeah, 721 metadata mintable. So you inerate from the metadata extension. But plus you have this function mint with token URi, you can mint token, so you specify the recipient address token id, and you also specify what is the URL for this token.
00:10:16.750 - 00:10:57.454, Speaker A: So this URL will return you a JSON document that gives you some info about this specific token. If you want to know more about the structure of this JSON document, then check out the official specification of Yash 721. They detail everything, right? We can also use the posable extension. So posable is also very easy to use. You just inerate from it and it will overload the approve and set approval function. And this will only work if the contract is not post. So you'll be able to post this contract by using the post function.
00:10:57.454 - 00:12:11.346, Speaker A: So p iuse you also have the other function unpose, and only the address that created the smart contract can code these functions. If you want to interact with another ERC 721 token that is already deployed, then you can use this thing, the interface of ERC 721. So in this case it will work like this. So let's import this interface. Okay, so here I will have my other contract, my other contract, and let's have my function foo in which I want to interact with 721. So in this case you do like this to create a pointer to the other contract. So you need to know the address of the token, whatever, and then you can call any function that you want on the Yas 721, like transfer, transfer from et cetera.
00:12:11.346 - 00:13:23.546, Speaker A: And there is another thing that is important to know. So if you want a smart contract to be a recipient of EH 721 token, it needs to implement a certain interface. It needs to implement this function here on ER 721 received, and it needs to return this magic value. So you can actually make your contract EF 721 compatible very easily by just inheriting from this contract. Here Ef 721 holder so let's create another contract contract my Yasi 721 holder and here YASC 721 holder is all I need to do. I also need to import it Yasi 721 holder and that way when your Yas 721 contract send a token to your holder, then it will work. Otherwise the transfer will produce an error.
00:13:23.546 - 00:13:42.780, Speaker A: So far in this series on open ziplin, I show you how you can create an ERC 20 token, an ERC 721, and probably that by now you are curious about how we can actually do an ICO. Well, open Ziplink also allow for this, and I'm going to show you this in the next video. I'll see you there.
