00:00:00.330 - 00:00:34.070, Speaker A: It. To say that Salana is a high performance blockchain would be an understatement. The network can handle 50,000 transactions per second, and it has block times measured in microseconds. Today I'm going to demonstrate how to write, build, and deploy smart contracts on Salana. But first, let's look at what makes Salana unique and how smart contracts are stored and executed. Whereas an Ethereum smart contract can store data internally, a Solana smart contract is stateless or read only once deployed. Third party accounts can interact with that smart contract and store data locally on their account.
00:00:34.070 - 00:01:05.886, Speaker A: This data storage space is rented out using the SOL token. This means we can deploy smart contract code to the network and get a public key for where that code is stored. This is known as the program Id. A second account can then be created to interact with that smart contract code and store application based data. So you'd have one key pair for the smart contract and another for the application itself. When developing smart contracts on Salana, we need to be careful and plan out how we're going to store data. For example, if we were to store 232 bit integers, these would take up four bytes of space each.
00:01:05.886 - 00:01:47.950, Speaker A: We have to allocate eight bytes of storage data into our app account and then map out the first four bytes to the first number and the second four to the second number. This low level data management needs to be considered by the smart contract creator, and that's somewhat challenging. So before we get stuck into that, let's look at a library built for storing JSON data on the Solana blockchain. So here we can do an NPM run test and deploy a contract to Solana. We're going to create a new user and then request an airdrop to get some SOL tokens to use on the testnet. So on the left here you can see we've got methods to set up a connection, create user, load a user and fund user. The fund user is going to request them testnet tokens.
00:01:47.950 - 00:02:21.238, Speaker A: Now we get to the load program stage and what we're going to do here is set up a second account for the program contract. We're going to upload the pre compiled code to the Solana blockchain and then store that contract code in an account. We'll then get the public key for that account which will store in the program id variable. Once that's gone through, we'll create a third account for the app account. We'll then transfer some tokens to that account to rent the space for the application data. Then once that's deployed, what we have are two functions to push JSON and pull JSON from the blockchain. Now bear in mind there's some limitations with this.
00:02:21.238 - 00:02:45.060, Speaker A: There's no security mechanisms in place, so anyone can edit this data. There's also a limit of 996 characters in the text data. If you want to change any of this, you'd have to edit and then rebuild the smart contract. So let's dive into that now. So let's walk through this rust application. At the top we've got some fairly standard includes. We're then using Borsch serialize to pack and unpack data.
00:02:45.060 - 00:03:13.450, Speaker A: We've got a data structure here. We're storing a string in the text value. We then declare a entry point, which is going to be our entry function. And here we can see that entry function. The program id is the public key where this data is stored. The account info is the account that's interacting with that data. And then we got some instruction data where we're going to send the text string to store the program.
00:03:13.450 - 00:03:44.530, Speaker A: Result is where the magic happens. The first thing we're going to do is iterate through the account to get the account that's interacting with the contract. We're then going to borrow the mutable data. What this means is we're going to extract the data that's currently stored in the blockchain, and we're going to put that into a mutable data fit variable. We're going to unpack that data using the bull serialized functions we declared earlier. Then we're going to set the text value of that unpacked data as the string that's been passed through to us. We're going to repack it and finalize the contract.
00:03:44.530 - 00:04:17.434, Speaker A: Reading through the code like this probably seems quite daunting at first glance, especially if you're not used to coding in rust. But there's some excellent examples of rust contracts for Solana on the Solana Labs GitHub repository. I'd recommend you check them out and use them as a base to build your own contracts on. I was never able to get the build environment working on Windows, so what I did was I set up the Windows subsystem for Linux on a Windows machine. So I had a virtual machine which was running Linux to build and compile the smart contracts. You can see that here. I installed the latest version of Ubuntu.
00:04:17.434 - 00:04:57.878, Speaker A: Then I ran the following commands to create a dev environment, upgrade and update the app repositories, then install node js npm python. I then used this curl command to install the latest rust distribution that's from the rust website, and then the latest Solana SDK as well. Export some paths and then we can fire up a Solana client to test it. What that leaves us with is an environment where we can take a. Rs file and we can compile that to a so file, which we can then later deploy to the Solana blockchain. To do that we just type cargo, build BPf, and as you can see, the smart contract has been built to this file here. We can then take this file.
00:04:57.878 - 00:05:45.970, Speaker A: We can then use a node JS script similar to what we used earlier to deploy the JSON contract to deploy this new contract using the so file we just built. If all that works, then we can use the Solana JavaScript API to interact with that application via a Dapp frontend, for example. So if you're coming from a solidity based background, the main differences when coding with Solana is that you have to manage the data. You're going to spend more time doing low level data storage and encoding and packing and unpacking type work. Admittedly that's not much fun, but the benefit is that you get to work with this really high performance, low latency blockchain and with the backing of the Alameda group. If you build something great, then you can grow with the defi ecosystem that they're building. I hope that you found this useful.
00:05:45.970 - 00:05:59.340, Speaker A: Hit the like button for the YouTube algorithm and check out the blog post linked in the description, which includes it's all the code samples we looked at today and includes a more in depth look at how the code works and deploying and building contracts on the Solana network. Thank you for watching.
