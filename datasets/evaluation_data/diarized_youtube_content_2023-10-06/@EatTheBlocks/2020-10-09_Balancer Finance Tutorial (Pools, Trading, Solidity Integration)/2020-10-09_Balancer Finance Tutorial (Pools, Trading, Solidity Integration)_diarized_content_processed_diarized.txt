00:00:00.410 - 00:00:46.246, Speaker A: In this video I will introduce Balancer, an up and coming defi project. I will explain how Balancer work and how to do the integration with balancer smart contract in solidity one part of Balancer is an on chain portfolio manager and another part is a decentralized exchange with an automated market maker similar to Uniswap. The total log value in balancer is still small compared to other projects like Uniswap or Aave. However, it's a very underrated project and smart people already know that. As we can see with the $2 million, Balancer has received invisive funding. That's why you should start to study balancer now, so that when it finally blows up, you will be ready to work with it before everybody else. And if you don't know me, I'm Julian and on my channel idoblocks.
00:00:46.246 - 00:00:57.086, Speaker A: I teach D five blockchain development and how to find your first blockchain job. And if you want to learn how you can become a professional blockchain developer and make $100,000 a year, check out.
00:00:57.108 - 00:00:58.640, Speaker B: My free training down below.
00:01:02.790 - 00:01:37.462, Speaker A: We are going to start our exploration with balancer pools. Balancer pools provide the two main features of balancer, a portfolio manager and an automated market maker. Similar to Uniswap, there is a smart contract for each pool. In each pool you have a combination of two to eight, yes, 20 tokens. That's different from Uniswap where you can only have two tokens per pool. Another difference is that in Uniswap, the two tokens must have an equal weight, but in balancer, it can be any weight. The first step in the pool lifecycle is to create a pool.
00:01:37.462 - 00:02:05.326, Speaker A: Anybody can create a pool by using the b factory contract. When you create a new pool, it creates a new spot contract and register its address in the b factory contract. It also register the address that initiated the transaction. That's the controller of the pool, and it has some spatial rights. After a pool has been created, it's in a state called not finalized. The controller is the only address that can interact with the pool not finalized. It's a private pool.
00:02:05.326 - 00:02:50.286, Speaker A: During this state, the controller can change the parameters of the pool, the tokens and the weights of the pool. The trading fee this trading fee will be given to liquidity providers for every trade and the ability for others to trade with the pool. In the not finalized state, it's possible to stay in its finalized state forever. For example, if the control of the pool is a smart contract, you can adjust the tokens, weight and trading fees as many times as desired during the lifecycle of the pool. That's what we call a smart pool. Another possibility is to set the state of the pool to finalized. After you do this, it's not possible anymore to change the parameters of the pool, and any address is able to trade with the pool, it becomes a public pool.
00:02:50.286 - 00:03:18.906, Speaker A: Before trading, we need liquidity. Adding liquidity works similarly to Uniswap. So you deposit the tokens and you get some BLP tokens or balancer liquidity provider tokens. While your tokens are locked into the pool, you earn some trading fees. When you provide liquidity, you can either send only one of the tokens of the pool or all of the tokens, but in this case, you have to respect the weight of the pool. This is different from Uniswap, where you can only provide the two tokens of.
00:03:18.928 - 00:03:20.854, Speaker B: The pool with equal proportions.
00:03:20.982 - 00:04:03.446, Speaker A: Once you have liquidity, you can trade. To trade, you provide a token of the pool as input and you get another token of the pool as output. For example, if there are three tokens in the pool, dai, MKR and wrap ether, and you want to buy dai, you can provide either MKR or wrap ether as input. The price is determined by a pricing formula in the smart contract of the pool. That's a generalization of the constant project formula of Uniswap. If you pay with a token whose reserves are below the target proportion of the pool, the price will be lower to incentivize traders to provide this token and rebalance the pool. Otherwise, if you pay with the token whose reserves are above the target proportion.
00:04:03.478 - 00:04:04.966, Speaker B: Of the pool, that's the opposite.
00:04:04.998 - 00:04:40.738, Speaker A: The price will be higher. To deincentivize traders, a consequence of your trading operation is that the pool is rebalanced closer to the target weight. In other words, the trader pays the pool to rebalance it and play the role of a portfolio manager. That's exactly the opposite of an investment fund, where we pay a portfolio manager to keep the fund balanced. A last important part of balancer is liquidity mining, which is an incentive program for liquidity providers. Balancer has a governance token, the bow token. Bow tokens can be used to vote on proposals to update the protocol.
00:04:40.738 - 00:05:40.570, Speaker A: It has a total supply of 100 million token 35 million bow tokens were initially allocated to funders, investors and the Balancer Ecosystem Fund, a fund to help project that helps the balancer ecosystem. The remaining 65 million tokens are intended to be distributed to liquidity providers over the next few years. Every week, 145,000 BaL tokens are distributed to liquidity providers. Tokens are distributed proportionally to the amount of liquidity each address contributed relative to the total liquidity on balancer. There is also a fee factor apply to reward more pools with lower trading fees because they contribute more to protocol usage. Only certain tokens are eligible to receive BaL rewards and you can find the list in a GitHub repo of Balancer. Next, we're finally going to start to interact with the smart contract of balancer from solidity.
00:05:44.670 - 00:06:21.282, Speaker B: In this section I will show you how to trade on balancer in a solidity smart contract on the Covan testnet. At this URL you can see the list of balancer pools on covan. So we are going to pick this pool that has wrap ether, dai and mega token because it has a high enough liquidity and no trading fees. So that's good for testing. So we need to copy paste several addresses. First the address of the pool so you have it in the URL, then the address of the DAI token. So if you open this link in a new tab you will be back at the homepage.
00:06:21.282 - 00:06:53.258, Speaker B: I think this is a bug, but in the URL you will see a query string with the token address and same thing for wrap ether. And you make sure to save all these addresses somewhere because we're going to need them after. So in this pool we'll buy die by spending wrap ether. If you never heard of wrap ether before, that's ether that is wrapped in an ES 20 token. It was created for convenience so that we only deal with ES 20 tokens in smart contract. The idea is pretty simple. When you want to get some wrap tokens, you send it some ether.
00:06:53.258 - 00:07:36.440, Speaker B: And when you want to get back your ether, you just send back your wrap token to the contract. Okay, so the next step is to go to remix the online ide for solidity. That's where we will write our smart contract. So first we need to make sure that we have the correct version of solidity 0.7.3. Then we'll create a first file for the interface of wrap ether. So we call this I wrap ether and we're going to go to this repo of mechodao on GitHub. That's where we can find the implementation of wrap ether.
00:07:36.440 - 00:07:54.220, Speaker B: We're going to copy a couple of functions. So deposit, withdraw, approve. After we're going to create an interface.
00:07:57.860 - 00:08:01.040, Speaker C: And we only need the function signatures.
00:08:10.400 - 00:08:45.380, Speaker B: And we also need the function signature of balance off and we need to make a few changes here. So instead 0.7 in interface. You cannot have public function, only external function. Okay, so we are good for the interface of wrap ether. So next we're going to create another file for the interface of the pool smart contract. So we're going to call this ib pool.
00:08:51.970 - 00:09:54.200, Speaker C: And we're going to go to this GitHub repo of balancer going inside the contracts directory inside bpool solve. That's the smart contract for balancer pool. And we're going to copy two function first get spot price and then swap the exact amount out. Actually, we just need the function signature. All right, so now we define our interface and we just want the function signature. Okay, same thing for the other functional. Now we have our two interfaces.
00:09:54.200 - 00:10:13.380, Speaker C: Next we're going to create our main smart contract where we're going to do the trading with the balancer pool. And we need to import a few things. First, we need to import the interface of S 20 token from open ziplin, which is a library for solidity.
00:10:13.460 - 00:10:15.156, Speaker B: So we go to the GitHub repo.
00:10:15.188 - 00:10:51.460, Speaker C: Of open zeppelin and we're going to pick a specific version because we want to use solidity 0.7 and that's not available in the master branch, we need to specify a specific release. So we go in tags, select this tag. So now this smart contract will be compatible with three t 0.7. So then we go to contracts token ERC is 20. Here you can see three t 0.7 and you're going to copy the URL.
00:10:51.460 - 00:11:49.480, Speaker C: We're going to paste it here in the import path. Okay, next we're going to import our two interface IB pool and wrap ether. And next we create our smart contract and we're going to define three variable first, a pointer to the pool contract of balancer. Then we need references to the two tokens we're going to manipulate. So die and wrap ether. So die, this is an ERC 20, and the other one wrap ether. We need a constructor to pass the addresses for these tokens and we instantiate all of this pointer.
00:12:00.930 - 00:12:47.802, Speaker B: And after we're going to create a function to buy die with ether. So we're going to call this swap eth for die and it's going to receive as argument the amount of die that we want to buy. And we'll make this x null and payable because we're going to send it some ether. And so the first thing is to convert our ether to wrap ether because in our balancer pool it accept wrap ether, not directly ether. So for that we're going to use the deposit function of the wrap ether contract. And in order to send you some ether, we're going to use the new notation of MsG. Value is the amount of ether that was sent to the contract.
00:12:47.802 - 00:13:21.194, Speaker B: And we execute this function. Doesn't take any argument. And after, we need to get the current price for the die token. So for that we use a function of the balance support which is called get spot price. And we need to pass it the two tokens. First the token that is used for the purchase, and then the token that we want to buy. So wrap ether for purchasing and die, that's what we want.
00:13:21.194 - 00:14:08.602, Speaker B: And actually this price will be used as the max price parameter when we'll do our trade. So what we get here is the spot price and that's the price if you want to buy only one die. But if you want to buy more than one die, then at some point you're going to have some slippage. That means that the average price is going to be a little bit worse than the spot price. So we need some level of flexibility here. So let's say that we are willing to pay up to 10% more than this price. So here, in order to specify this, we're going to multiply here by 110 and then divide by 100, because this is not possible in solidity to multiply with a decimal number directly, like we can do like 1.1
00:14:08.602 - 00:14:39.780, Speaker B: for example. So we use this trick. Then we also need to calculate the maximum amount of wrap ether that we are willing to pay. So for that we multiply the price by the amount of die. Then we are going to approve our wrap ether to be spent by the spot contract of balancer. So that's the address of bpool. The amount to be spent is wrap ether amount.
00:14:39.780 - 00:15:09.514, Speaker B: And after that we're finally going to do the trade. So on bpool, there is a function called swap exact amount out. So that means we specify a specific amount that we want to get as output, any input. We're going to specify a maximum amount that we are willing to spend. So first we need to specify the currency used for buying. So that's wrap ether. Then the maximum amount that we are willing to spend.
00:15:09.514 - 00:15:34.754, Speaker B: So that's this variable. Then the currency that we buy. So that's die. Then the amount of die that we want. So this is not a maximum or minimum amount, this is the exact amount. And finally the maximum price that we need to pay. So actually, I don't really understand why we have to specify the maximum price and also the maximum amount of wrap ether in input because for me that's redundant.
00:15:34.882 - 00:15:37.382, Speaker A: And after we are supposed to get.
00:15:37.436 - 00:16:56.990, Speaker B: The die in the contract, so we transfer this die to the center of the transaction. And if there is any excess ether that was sent to the smart contract and unused for the purchase, we need to return it. So for that we need to get the balance of wrap ether of the contract. And if this balance is positive, then we're going to return it with wrap ether, withdraw, it's going to convert these tokens into ether and we transfer the ether balance of the contract to the sender of the transaction. Actually, I don't know why, but here when we execute the withdrawal function, when we send the transaction, it doesn't work. So we're going to comment it out and we're also going to create another function to get the spot price so that we know how much ether to send to swap eth for die function. So this is a view only function, doesn't modify the data of the blockchain.
00:16:56.990 - 00:17:31.414, Speaker B: It's going to be very simple. We're just going to call get spot price for our two tokens. So wrap ether and die. Okay, so now we are ready to test our smart contract. So for that you will need to install metamask, which is an Ethereum wallet distributed as a chrome extension. And once you have this wallet installed, you need to select the Covan network and you copy your first address. Then you go to a faucet for Covan.
00:17:31.414 - 00:18:08.818, Speaker B: So faucet allow you to get some free ether for public testnet like Covan. So you log in with your GitHub account, you enter your Ethereum address and it's going to give you some fake ether from Covan. Then back to remix. We're going to go to the deployment tab, and for the environment you're going to select injected web3. So that's how you connect it to metamask. Then here for the address, it should be the same as for Metamask. Then we're going to select my contract and you'll see next to the deployment button, we can specify the argument for the constructor of our smart contract.
00:18:08.818 - 00:18:29.500, Speaker B: So you basically need to provide the three addresses of the pool, dai and wrap ether. First pool, then comma, then second address. So these needs to be in the right order. And third, address.
00:18:36.060 - 00:18:36.676, Speaker C: It.
00:18:36.798 - 00:19:09.784, Speaker B: All right, so now you click on deploy and you're going to get the confirmation pop up of metamask. You confirm. Okay, so we get the transaction hash here, and if you scroll down, you will see your deploy contract appearing here you expand it, and then we can execute the get spot price function. So here we can see how many ether we need to buy one die. So keep in mind that everything is expressed in terms of weigh here. So actually this is less than one ether. And after we're going to call the swap ether for die function.
00:19:09.784 - 00:19:44.268, Speaker B: So we need to specify a die amount. So let's say that we want to buy one die. We're going to specify one time ten power 18, because we specify everything in terms of way 1234-5678 910, 11, 12, 13, 14, 15, 16, 17, 18. So that's one die. And after we need to specify how much ether we are willing to pay. So we're going to select Fina here. So that's basically ten power minus three ethers.
00:19:44.268 - 00:20:09.640, Speaker B: One fina is. So that means if you specify 100 fina, that's 1.0 ether, for example. So here the price is 36.3 fina. So we're going to put 37 to be safe. Okay, then we execute the transaction.
00:20:09.640 - 00:20:21.240, Speaker B: Click on confirm. And the transaction was successful. Yes. So we managed to buy Dai with ether by using the spot contract of balancer.
00:20:21.320 - 00:20:21.900, Speaker A: Great.
00:20:22.050 - 00:20:59.336, Speaker B: And you can also inspect your transaction on ether scan. So here you expand the transaction info and you can copy the transaction hash. And after you go to covan ether scan, you pass your transaction hash and you can see the detail. So now what's next? First, it can be dangerous to rely on prices inside a smart contract. An attacker can manipulate the market and make you lose a lot of money. The idea is to sandwich your transaction with two transactions. The first transaction of the attacker buy or sell a lot, which make the market move a lot.
00:20:59.336 - 00:21:47.704, Speaker B: Then your transaction is executed and you trade at a bad price which benefit the attacker. Then the attacker follows up your transaction by another transaction where he closes his initial position with a big trade in the other direction and the market is back at a normal level. So it's best to remove the call to getspot price outside of the smart contract. You can call this function from outside the blockchain using webstery or ether, and pass the price to the smart contract. Nothing you can try is to create a smart pool. When you have a smart pool, a smart contract is the controller of the pool and the pool stays in not finalized state. This is useful for advanced use case like if you want to do a pool that does string trading, you can increase and decrease the trading fees at certain times to incentivize rebalancing by traders only at certain times.
00:21:47.704 - 00:22:37.060, Speaker B: Another use case is for bootstrapping the liquidity of a pool. For that you can use a smart pool to do a reversed dirt auction by starting with a high proportion of your tokens relative to the reserve token, and you progressively increase the weight of your token until the end of the liquidity bootstrapping period. A big advantage is that you don't need to hold a lot of reserve token to start a pool for your token. Another interesting to know about balancer is their smart order router feature called soar. They are working on a solution to minimize the execution price for large orders. By spreading your order across different balancing pools, you can reduce your slippage. It's still been worked on, but at the end it will have two components, a JavaScript library that calculate the best trading parameters and a smart contract part that actually execute the trade.
00:22:37.060 - 00:22:46.630, Speaker B: Next, if you want to keep learning about Defi project, I recommend my introduction to Uniswap, which is really a must know if you want to be a Defi developer. I'll see you there.
