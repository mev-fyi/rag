00:00:00.330 - 00:00:36.882, Speaker A: In 2016, on Ethereum, the DaO smart contract got stolen. Hundreds of millions of ether hackers use a technique called a reentrancy attack. If you're a smart contract developer, that's very important to understand how it works. So in this video, I'm going to explain you what is a reentrancy attack and how you can protect against it using the open Zeplink framework. Hey, I'm julian, and on my channel blocks, I teach how to become a blockchain developer and get your first blockchain job. First, let's understand how this work. So here we have two smart contract.
00:00:36.882 - 00:01:28.530, Speaker A: First, the victim, smart contract, that's my contract. And the attacker, smart contract that is going to perform the attack. So let's say that my contract holds some token on behalf of some other addresses, and it's possible to withdraw this token with the withdrawal function. So you call the withdrawal function, you specify the amount of token that you want to withdraw, and then they're going to be some logic to make sure that your balance of token is enough. Then it's going to send you the amount of token that you want to withdraw. Then it's going to call a function on the receiving address, and then it's going to decrease the internal balance of token. So here is the problem when we call on receive.
00:01:28.530 - 00:02:12.806, Speaker A: So here we're going to go to the attacker spot contract. So here there is an internal variable to make sure that we limit the number of attack we do. So here we enter the if statement, we increment this can variable, and we're going to call again the reservoir function of my contract. So here the execution is going to come back to the residual function. And now the check for the token balance is going to work because at this stage of the execution, we haven't executed the part of the logic that decreased the balance. So this is going to work. We're going to send again the same amount of token, even though this address might not have enough token to restraw all of this.
00:02:12.806 - 00:02:29.658, Speaker A: And we're going to call again on receive. So, on receive, it's going to be executed again. And again. We're going to call withdraw, et cetera, and we're going to do it until the count variable reach nine. Oh, by the way, here, this is not time. This is count. Sorry.
00:02:29.658 - 00:03:14.380, Speaker A: And at the very end, this part here will be executed, decrease the balance. But at this time, it will be too late because the attacker will have already withdrawn a lot of token from my contract, even though he doesn't own all of these tokens. So we need to find a way to prevent the attacker smart contract to call back inside the same function restraw. And actually we can do this easily with the Openzeplink framework. So here is the GitHub repo of Openzeplink. So we're going to go inside the contracts directory, then inside the utils directory, and the spot contract we want is re entrance God. So let's click in it.
00:03:14.380 - 00:04:01.062, Speaker A: And so a reentrancy God can protect us against the vulnerability I just explained. So you need to inerate from it. Then there is a constructor. So you need to call this constructor, and then there is a modifier that you need to attach to each function that you want to protect against any reintroduce attack. And so this modifier uses a boolean variable to make sure that this function wasn't already called. If you've ever done some low level programming like Cr C plus plus in particular, if you've done any multithreading programming, that kind of logic is also used to coordinate between different threads. Anyway, that's just the details, so let's see how we can use this in our smart contract.
00:04:01.062 - 00:04:29.230, Speaker A: So first let's note down the past contract utils. Return CG. I'm going to copy this. Then here I'm going to import this smart contract. By the way, I've already installed open ziplink in this project. If you don't know how to install openzipling, check out my video on the topic on this playlist about open zeppelin. So we're going to import open zeppelin contracts utils.
00:04:29.230 - 00:05:12.270, Speaker A: And then what's the name of the contract already? Oh yeah, reentrancy God. Okay, and now we're going to inerate from it. In my contract is reentrancy God. And since it has a constructor, we need to call this constructor. So here we're going to declare a constructor, and we call the constructor of reentrancy, like this. Then make our constructor public and there is nothing in the body. And after we can attach the modifier to the restraint function, so that is called nonre.
00:05:12.270 - 00:05:28.690, Speaker A: And with this you're protected. If you want to keep learning how the open ziplink framework can help you to write your solidity smart contract faster and safer, you can. And check out this playlist. I'll see you there. Bye.
