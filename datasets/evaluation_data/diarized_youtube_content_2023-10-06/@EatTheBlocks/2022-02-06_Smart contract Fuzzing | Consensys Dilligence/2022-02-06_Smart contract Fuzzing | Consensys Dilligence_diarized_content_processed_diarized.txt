00:00:00.490 - 00:00:43.446, Speaker A: Okay, developers, welcome back. In this video, we've got a pretty serious topic, and that is the security of your code. That's why today we'll be looking at consensus, diligence, and their state of the art fuzzing platform for thorough smart contract testing. If you're new here, I'm Calvin, and at eat the blocks, we help web two developers transition into web3, you. In June 2016, $50 million was drained from the Dow using a reentrancy attack. This attack actually had the Ethereum foundation roll back the hack. And this led to the fork of Ethereum classic and Ethereum being able to repeatedly call a function while it's still computing.
00:00:43.446 - 00:01:40.490, Speaker A: The last call can cause it to interact in a destructive way. In this example, we can see the user balance is not set to zero until the very end of the function, and the second call will still go through and withdraw the balance over and over, which is really bad. And then we have other known attacks, including oracle manipulation, front running integer overflow and underflow timestamp dependence threats, insufficient gas briefing, and so many more. With so many ways to attack smart contracts, it feels like an impossible task to cover all bases and write all the tests. But with fuzzing, we might not need to write as many tests as we think we do. So what exactly is fuzzing? It's a term that came from the cybersecurity industry and originated in the mid 90s. There was a team looking at the reliability of top computer systems at the time, and they noticed something kind of interesting.
00:01:40.490 - 00:02:25.850, Speaker A: When they gave applications a bunch of random inputs, they could cause about a third of them to crash, and this is a pretty big number. Now, the whole idea behind fuzzing is to try and find edge cases in a code base. We can use it to make sure that all of the passing that we do, acceptance of data, storing of data, and reading of data, doesn't cause any bugs. And malicious hackers don't want us to test nonstandard input because it's a great way to find a weak point in code that we might not have accounted for. They can use these weaknesses to steal our data or repeatedly crash your application or servers. Now, on the blockchain, they're not crashing servers. They're stealing millions of dollars in cryptocurrency, which makes the testing of our smart contracts even more important.
00:02:25.850 - 00:03:22.310, Speaker A: Obviously, we are writing tests for our smart contracts, but how many hundreds of ways can we imagine the randomness that could be introduced to our code that could break it? And that's where fuzzing comes to the rescue. Diligence fuzzing is the easiest way for smart contract devs to find weak points in their code. Not all of us are smart contract security experts, but with this fuzzing as a service, we get state of the art fuzzing techniques, automated testing, and all the checks for our business logic. The process to use the fuzzing platform looks pretty easy. Using their annotation language, we first define the specifications for our contract. So, for example, the expected output of a function should be a positive integer. Then, once our code is fully annotated, the contracts are sent to consensus diligence, who runs them through their Harvey fuzzer? And then we get back a series of reports.
00:03:22.310 - 00:04:15.562, Speaker A: Now the fuzzer will try millions of input combinations, all of the possible ways to mess with your contract that you wouldn't have thought of, just to see if it can get one of your functions to return something you didn't expect. We can then inspect the reports for any property errors and fix the code. Then we just rinse and repeat. So it looks like with this service, any of us can quickly find holes in our smart contracts and repair them, which is pretty cool. But in order for us to use the fuzzing platform, we need to learn about the annotation language scribble. It's able to translate high level specifications into solidity code, and it's also based on the same syntax, which makes it easier for us to get started with. What's really nice is that we can annotate the actual smart contract rather than writing annotations in a separate file.
00:04:15.562 - 00:05:09.114, Speaker A: Once we're done, scribble transforms these annotations into concrete assertions that verify our specifications. We can then use tools like diligence fuzzing to automatically test smart contracts and make sure everything is working just as we planned. Once our smart contract is enabled with scribble annotations, any security tool that works by checking assertions can be used for verification, including fuzz testers, symbolic analyzers, and even solidity's own built in SMT checker. So this language allows us to write smart contract properties that can be automatically tested using fuzzing. But it feels like we need a little bit of a mindset shift to get started. Most of us are familiar with unit testing, where we write a small test case and then we check for expected behavior. The format is usually arrange, act, and then assert.
00:05:09.114 - 00:05:50.154, Speaker A: So let's take a look at this extremely simple example of a test case. If we send in one and two, we'll get three if we send in zero and one, we get one, but 101 hundred are equal. So we'll hit the if statement and receive 201. This type of unit test is not ideal for smart contracts. We need to test for much more complicated edge cases, and it becomes difficult to think of every possible case. So now let's do the same test with scribble. So we already have our three test cases, but how can we automatically test millions of cases to make sure that our function is bulletproof? Because scribble lets us write properties, we don't have to think up every single case.
00:05:50.154 - 00:06:33.990, Speaker A: Instead, we can just focus on deciding what the output of our functions are supposed to be. We can write the specifications using scribble and let the fuzzing platform think up all of the various inputs for us. This is a massive time saver. Unit tests still have their place. They set a great baseline and they're good for things like triaging and validating a fix. We should be thinking of things like scribble as a complementary tool alongside unit testing to rigorously test our contracts in ways that we couldn't even imagine. Okay, so let's look at our old friends the ERC 20 token, and see how we can get this set up and ready for fuzzing using scribble.
00:06:33.990 - 00:07:10.178, Speaker A: So we write our annotations and that tells the fuzzer what to look for in our contracts. There's also a helpful gist created by one of the team that shows us the 16 annotations we need to fully set up an ERC 20 contract for fuzzing. Now, first up we have contract annotations. These cover the overall behavior of the contract, and in this example we're looking at token supply. This annotation is going to make sure that our mapping to record balances aligns with the total supply of tokens. The next annotation checks. The supply of tokens never changes except for when the contract is initialized.
00:07:10.178 - 00:08:01.762, Speaker A: These two annotations get added to the top of the contract as contract level annotations. Now let's move into the contract and write some precondition annotations for our functions. We're going to quickly look at the most important function on the ERC 20, the transfer function. The first annotation is acting as a precondition which we want to set at the beginning of the function. What we're basically saying here is that the function can only succeed if at the beginning of the transaction, the balance of message sender is greater than or equal to the value that is being transferred. So in this situation, the sender of the funds is going to have the amount of, for example, one eth less after this transaction, and the receiver of the funds is going to have that same amount as a balance. So now that our ERC 20 has a few annotations and we figured out what we need to do, we want to get them checked.
00:08:01.762 - 00:08:59.090, Speaker A: We can then use analysis methods like fuzzing to automatically find weak points in our code and search for bugs. But before sending our contracts off to the fuzzing platform, we need to create the seed state. We can view this file as a deployment script or a test fixture, and it's used to execute the tests we've written using scribble. In this example, we just deploy our token and we're all done now to send it off to the consensus fuzzing platform. Then you'll get a report like this with a campaign name, number of cases per second, test coverage and duration I've only recently been introduced to the idea of fuzzing, and I am pleasantly surprised. The idea of one of my bugs getting on chain and causing people to lose their funds gives me nightmares. I'm also not 100% confident that I can think up enough test cases to cover every angle of my code, even with the known attacks.
00:08:59.090 - 00:09:23.900, Speaker A: Just having a platform that can programmatically attack my contracts with hundreds of thousands of inputs and then tell me what failed is kind of a blessing. And if your next DAP is going to be dealing with considerable amounts of funds or customer assets, we really think you should check out the tools over at consensus diligence. We'll leave a link in the description below. That's all for this video. Thanks for watching and we'll see you in the future.
