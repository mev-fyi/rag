00:00:00.250 - 00:00:37.222, Speaker A: Today I'll show you how to do a swap on uniswap b three using solidity. Now, Uniswap allows you to do either a single hop or a multi hop trade. A single hop is a trade where it trades from one token to another token, for example, from Eth to Dai. A multi hop trade involves several tokens, for example from ETH to Dai and then from Dai to USDC. In this video, I'll show you how how to do a single hop trade. I'll be following the official documentation, so let's get started. So the first thing that we need to do is set up the project.
00:00:37.222 - 00:01:18.918, Speaker A: So I'll scroll down then looks like we'll need to do an NPM init. I've created an empty folder called unib three and we'll initialize an NPm package by typing npm init y. This will create a package json and we're now ready to install some NPM packages. What are the packages that we need to install? Back inside the documentation, I'll scroll down and we'll need to install hardhat. I'll copy this command and then back inside the terminal I'll paste the command. This will install hard hat into this project. Once hardhat is installed, let's go back to the documentation to see what the next step is.
00:01:18.918 - 00:01:51.390, Speaker A: After installing hardhat, the next step is to install the unisoft b three periphery npm package. This will contain the unisoft b three interfaces so that we can write solidity to interact with it. So I'll copy the command, and then back inside the terminal I'll paste the command to install the unison b three library. Okay, that's done. Let's move on. The next step is to initialize a hard hat project. I'll do that by typing inside my terminal mpx hard hat.
00:01:51.390 - 00:02:24.042, Speaker A: And then we'll initialize a simple hard hat project. So I'll hit enter, enter, hit yes, and then hit yes again. The hard hat project is initialized. Let's move on and see what the next step is. So back inside the Unisop official documentation, it says to set the solidity version to 0.7.6. This is because Unisop B three is written in 0.7.6 and the Unisop interface that we just installed over here is also solidity 0.7.6.
00:02:24.042 - 00:02:59.598, Speaker A: So we'll initialize our project to be solidity 0.7.6. Back inside my code editor, I'll open hardhat config JS and then paste the solidity version to be 0.7.6 and remove the default 0.8.4. Now let's try compiling the contract. So the first thing that I'll do is change the compiler version for the default contract. So I'll change this to 0.7.6 and let's try compiling the contract.
00:02:59.598 - 00:03:41.426, Speaker A: So I'll open the terminal, then type MpX hard hat compile. Okay, the contract compiled successfully. So let's move on for the next step. We'll copy the code from the official documentation on their single swaps, and we'll try out the two functions. Swap exact input single and swap exact output single. So I'll scroll all the way down to copy this contract. Copy it and inside my contracts folder I'll create a new solidity file called swap examples sol and then paste the code that we just copied and we'll change some of the code.
00:03:41.426 - 00:04:18.106, Speaker A: So first I know where the address of the swap router is. So I'll change this from immutable to a constant. Back inside the uniswap documentation, I'll click on the navigator and scroll down and look for a submenu called deployment addresses. And I'm looking for the address of swap router. I'll scroll down actually I'll hit ctrl f and then search for router. And I'm going to copy this address. Swap router now don't copy the address of swap router two because this has a different interface from swap router.
00:04:18.106 - 00:05:03.142, Speaker A: So the example will only work for swap router and not swap router two. So copy the address of swap router back inside the code. We will make iswap router a constant and it will be equal to swap router iswaprouter at the address that we just copied and then we'll remove this constructor. Okay, next let's take a look at the example slap exact input single. This function will take in all of the amount of token that we specify for the input amount in and then swapped it to another token. Now, the default example of the documentation swaps from Dai to ETH. But for our purpose we'll swap from EF to Dai.
00:05:03.142 - 00:05:45.914, Speaker A: And I do this because when we initialize accounts inside the test, we already have some free e, whereas die we don't. So to make our example simple, we'll swap from e to die. So the first thing that I'll do is change safe transfer from die to wef nine. If I scroll up, wef nine is defined over here. So we'll transfer wef nine into this contract, and then we'll approve wef nine to be spent by uniswap b three. So next we'll need to prepare our input to be passed to uniswap b three. The default example takes in die as token in and wef nine as token out.
00:05:45.914 - 00:06:20.166, Speaker A: But for this example we will be swapping from wef to die. So we'll switch things around. Token in will be wef nine and token out will be die, and the rest of the parameters are the same. Now notice that we have this mysterious setting called square price limit x 96. When we do a trade on unisop, it pushes the price up of the token that we're buying. So this setting allows you to set the limit for the price. But for this example we'll keep it simple and just disable this by setting square price limit to zero.
00:06:20.166 - 00:06:53.562, Speaker A: And then lastly we'll call exact input single passing in the parameter that we just prepared and then calling the uniswap b three router. So this is the part of the code that does the actual trade. Okay, let's try running this function. When we call this, it will swap from wef to die. So first thing that I'll do is open my terminal and try compiling contract by typing mpex hard hat compile. Okay, the contract compiled successfully. So the next thing that we'll do is write the test that will execute this function on the main net fork.
00:06:53.562 - 00:07:38.958, Speaker A: So the first thing that I'll do is configure hard hat config to run on main net fork. So I'll paste this configuration network hard hat forking and URL set to this URL that you can copy from alchemyapi IO. To get your own API key, log in or sign up to alchemyapi IO. And once you're in, create a new project and then click on view key. And this is the URL that I copied. So once we configured hirehat test to run on the main network, the next thing that we'll do is write the test. So I'll open my file navigators and inside test I'll rename sample test js to swap test js and then open it.
00:07:38.958 - 00:08:21.786, Speaker A: Now so far we have a default test for the greeter contract and we'll modify this to test our first example. Swap exact input single. So first I'll change the titles of the test. So I'll call this swap examples and this test I'll rename it to swap exact input single. Then I'll remove this part of the test and we'll name the contract that we're going to be deploying from greeter to swap examples. The constructor of swap example takes a null constructor argument. So I'll remove this constructor argument and then rename the greeter contract to.
00:08:21.786 - 00:09:10.730, Speaker A: So once the contract is deployed, the first thing that we'll do is get the accounts that will be testing the functions. So I'll say const accounts is equal to awaite ethers get signers. By calling this function we'll get some accounts which will be able to call the functions on the swap example contract and it will have also some e so we can easily test the trade from eth to die. Now if you go back to the contract, you can see that we are pulling in wef nine and then getting die back. So back inside our test file, let's initialize wef and die. To do that, we'll first copy the addresses of wef die. I'll copy the addresses and then paste it in the test file and change the solidity code to javascript code.
00:09:10.730 - 00:09:50.986, Speaker A: Once we have the addresses for the contract, die and wef, we'll initialize these contracts. To initialize these contracts, I'm going to need an interface for die and with nine. The interface for IERC 20 is included in the unisoft package that we installed. So the only thing that you'll have to do is declare an interface for wefknife. So I'll open the file navigator contracts, and then I'll create a new folder called interfaces. And then inside here I'll declare a new interface called iwf soul, and then I'll copy this interface that I got from the Internet. Wef nine extends IERc 20.
00:09:50.986 - 00:11:06.994, Speaker A: So these are all functions from ERc 20, and on top of that wef nine has a function called deposit which is payable, and a function called withdrawal. Okay, so back inside the test we'll initialize die and weft nine. So I'll say const die is equal to awaite ethers get contract at the name of the interface that we're going to be loading IERC 20 and then followed by the address this will be die, which we defined over here we'll do something similar for WEF as well. So say const wef a weight ethers get contract at if, which we've defined over here, and then the address of wef will be wef nine. These two command will load wef and die at these contract addresses we deploy the swap contract and we're now ready to call the function swap exact input single. We're going to be trading wef for die, so we'll need to convert our e into wef. Let's say that we're going to put one e, so I'll say const amount in is equal to ten to the n times 18 to the n.
00:11:06.994 - 00:12:13.382, Speaker A: Now, Javascript doesn't support big numbers, but however it can support big numbers. It's called big int by appending the n to the numbers. So we'll say amount in is ten to the n raised to the power of 18 to the n. We'll deposit e by typing await wef deposit and then pass in the amount of e to deposit by doing curly braces. Value amount in. Next, we'll approve this contract to be able to pull our one e into the contract by typing await wef approve the contract that we're approving is swap examples address further amount in and just to be clear that we're calling these two functions from account one I'll say connect accounts zero dot and then call the rest of the function. This connect means we're calling the deposit function from account zero, and likewise we're calling approve function from account zero.
00:12:13.382 - 00:13:05.314, Speaker A: The next step is to execute swap exact input single so I'll type await swap examples swap exact input single. The amount of eth that we're trading is amount in and after the trade is done we'll console log the amount of die that we got back. By typing console log. I'll say die balance of will be of account zero. So I'll type die await die balance of account zero address. Again, we're trading from e to die by first converting our e to wef and then putting our wef to be converted into die. Before the tray we have zero die, but after the tray we should have some die.
00:13:05.314 - 00:13:53.170, Speaker A: Let's run the test. So I'll open my terminal and then I'll clear the logs, and then I'll run the test by typing mpx hard hat test swap test js and the test executed successfully and you can see that our die balance is something greater than zero. The account has zero die. After the trade we have some die. For the next example, I'll show you how to call the function swap exact output single this is an example where it tries to get the exact amount out specified in the input amount out, and the maximum amount in that it will take in is amount in maximum. In other words, it would try to sell the minimum amount of token in to get amount out again. The default code example, swaps from die to wef.
00:13:53.170 - 00:14:47.170, Speaker A: But for our example, we'll swap from weft to die. So we'll first pull in wef and then we'll approve wef to be spent by the uniswap b three router. So token in will be wef and token out will be die. Sorry, weft nine, wef nine, and wef nine over here. Once the parameters are prepared, we can call the function swap router exact output single passing in the params, this function will return the amount of token in that was spent to get the amount out of token out. But notice that over here we transferred amount in maximum. So if the amount in is less than amount in maximum that is locked inside the contract, we'll need to refund the difference back to message sender.
00:14:47.170 - 00:15:30.338, Speaker A: We pulled in Wef, so the first thing that we'll do is reset the approval on uniswap b three router. So I'll change die to wef nine. This code over here is resetting the approval for wef nine on swap router to the zero, and then we'll refund the difference to message sender. Change this to weft nine. Let's try compiling this contract. Open the terminal and then type mpx hard hat compile and the code compiles. So let's now write a test and try executing the function swap exact output single back in the test file.
00:15:30.338 - 00:16:05.746, Speaker A: I'll copy this and then paste it here. We'll rename this to swap exact output single and notice that we have some redundant code from here and over here. So I'll remove some of the repeated code. We'll move this part of the code to the initialization process before we execute these two tests. So I'll copy this. Actually, I'll just cop the code out and then paste the code inside the before block. So I'll type before async and then paste the code.
00:16:05.746 - 00:16:56.810, Speaker A: We'll declare the variables accounts with and die, and then reassign the variables inside the before block. This before block is some initialization code that runs before any of the test runs. Then we also declare the swap contract that swap examples and then instead of using const, we'll reassign it to this variable that we declared over here. And now we can remove this part of the code. For this example of calling swap exact output single, we'll do a trade where we will send one e and we'll try to get 100 die. So one e will be sent that will be converted to 100 die and whatever weft that was not spent will be refunded back to us. So I'll rename amount in to wef amount in max.
00:16:56.810 - 00:17:36.320, Speaker A: This is the amount of weft that we will be sending to swap examples, and it will be the maximum amount of weft that will be used by uniswap. B three how much die are we trying to buy? We'll say we'll try to buy 100 die. So I'll say const die amount out is equal to 100 n times ten to the n to the power of 18 to the n. We'll deposit the e and then convert it to wef. So say wef amount in max. Wef amount in max. And the function that we're calling is swap exact output single.
00:17:36.320 - 00:18:14.886, Speaker A: The function swap exact, output single, takes in two parameters, the amount of die that we want and the amount of eth that we're willing to spend. So two parameters, amount of die we want, die amount out. This will be 100 die, maximum amount of e that we're willing to spend. That will be one e with amount in max. And that's the after the trade we should have 100 die in this account. Now, before we run test, I know that this test passed, so for this example, I'll just comment it out and then run this example. Swap exact, output single.
00:18:14.886 - 00:18:34.650, Speaker A: Let's run the test, open the terminal and then we'll run the test again. It and our test passed and noticed that we got 100 die backup.
