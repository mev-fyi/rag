00:00:00.250 - 00:00:31.782, Speaker A: Foundry is a framework for testing, debugging and deploying solidity smart contracts. It's a command line tool built on rust with faster execution than competing products such as truffle or hardhat. In this tutorial, I'll be looking at the benefits of using foundry, how to get it set up, testing with solidity, completing a security challenge, deploying and interacting with contracts. And finally, I'll talk about my experiences of using foundry and how it compares to other frameworks. My name is James Boccini. On this channel I create content about digital assets and blockchain development. If you're interested in learning more, then consider subscribing to the channel.
00:00:31.782 - 00:00:32.886, Speaker A: And don't forget to hit like button.
00:00:32.908 - 00:00:41.260, Speaker B: For YouTube, algorithm Lisk is organizing the second edition of Blockchain Day, which will be one of the official events during Berlin blockchain week.
00:00:48.190 - 00:01:28.806, Speaker A: In the past, when developers wanted to compile, test, and deploy smart contracts, they generally used JavaScript frameworks such as truffle or Hardhat. Bodies are great, and they provide a very clean scripting environment. Foundry aims to improve on it. It's built on rust, so it executes tests a lot faster. It also streamlines the process of unit testing because the unit tests are written in the solidity, the same code that you're deploying the contract in. So whereas with hard hat you'd write the code in solidity and then you test it in JavaScript in foundry, you're actually writing the code and the unit test both in solidity. For me, I think that foundry really excels at testing and auditing either third party or your own code, either from a security perspective or just kind of doing them initial tests to make sure everything's working as it should.
00:01:28.806 - 00:02:09.206, Speaker A: That's not to say that it's not great for developers who just want to deploy a simple contract as well, because there's command line tools to do whatever you want to do. There's things like ether scan verification, mainnet forking, all the common tasks that you would need to do as a blockchain developer, you can do from the command line with foundry. I think the two main reasons why foundry is growing so quickly and it's being used more and more in blockchain development is because of the solidity unit tests and the speed at which they are executed. So the first step is to get this installed. We can do this for there's commands for Linux, Macs, Windows or docker. You do need rust installed, which you can get from Rustup Rs. I'm going to install this on Windows.
00:02:09.206 - 00:02:44.950, Speaker A: So I'm going to be using Powershell and we can just right click in a directory and go to open Powershell window here, paste in that command, hit enter, and that will install the repository. I've already got it installed, so we're ready to go. There's two main commands that the foundry package comes with. This is Forge and cast. Forge is kind of the bread and butter of what you'll be using most of the time. Then cast is a little bit like truffle console, which you can execute functions from smart contracts from the command line. So we're going to be using forge here, and we're going to do forgenet, which will create the foundry repository.
00:02:44.950 - 00:03:11.060, Speaker A: In our directory, you can see we've created a bunch of files. There's actually a git set up already. And we've got source, which is where we put our smart contracts and test, which is where we put our test suites. The contract we've got is just a blank contract. Notice that the test is actually named the same with just t sol. And then these function names are important as well. We'll go for them in a second.
00:03:11.060 - 00:03:46.086, Speaker A: But let's go ahead and build our smart contracts so we can use forge build, which is the equivalent of compile. So actually compiling the smart contracts here all successful. And then we can run the tests with forge test, and you can see how fast that has done. And you've got a single test, which is this one test example. There's nothing in setup. All we're doing is asserting that true equals true. And the test result is okay, one has passed.
00:03:46.086 - 00:04:14.420, Speaker A: It cost 279 gas, roughly, and it finished in 1.54 milliseconds. Next I want to show you is how we can use foundry to do more extensive testing. Let's open up the original contract file, which is in source contract. And this is currently just a blank contract. So we're going to add some functions in here. I'm going to do un, two, five, six count equals zero.
00:04:14.420 - 00:04:53.886, Speaker A: Six public count equals zero. And then I'm going to add another function. Function plus public one. Let's save this and then go back and do forge build. That's compiling, it's compiled. And then if we go into the test suite, we can run some tests. Let's add another function in here.
00:04:53.886 - 00:05:42.078, Speaker A: We're going to do this function, test count. We're going to be a public, and all we want to do here is assert equal count equals zero to start with. And we're going to also import our contract, which is just called contract and let's try building this. Now, if we do forge test, we got two tests and they both passed. Now let's test the plus function. All we're doing here is adding one to our count. So we got this count variable and we're adding one to it, and we just want to check that works.
00:05:42.078 - 00:06:29.370, Speaker A: So let's copy and paste this, call the function test plus. And then we're going to do just call a function plus and assert equal count is equal to one. Forge test, compile him. And we got three examples where the tests are passed. If we change this to two now, we should get a fail. And as you expect, one of the tests has failed because count is not equal to two. If we add another plus function in, we're going to add two to the variable and that should pass again.
00:06:29.370 - 00:07:43.500, Speaker A: Okay, so what we can do now is if we add, we're going to pass a variable to the plus function and that is going to add to the count. So we can now reduce this to a single function, add two on, and see if that works. We got three passes. What I want to show you here is how we use fuzzing. So fuzzing is when you can throw random amounts of data, not random, but kind of lots of different variables at a function. And because foundry executes so quickly, we can kind of brute force it to see if there's any situations where the function will revert. So if we add a variable to this test function, so we're going to add un, two, five, six, fuzzy, and then we're going to add fuzzy to this function.
00:07:43.500 - 00:08:33.562, Speaker A: And this will quite quickly fail because it's going to be testing lots of different amounts of data. So you can see the cool data is here that it failed on. And by throwing random amounts of data at this, so it'll throw really big numbers, really small numbers, anything else it can think of to try and break the contract, basically. And that's a really good way to brute force test functions. If we go in here and put count equals fuzzy, what we can do now is check that whatever we're throwing at that function is actually working out and the count is equal to whatever we're putting into it. So let's test that. Be quite interesting.
00:08:33.562 - 00:09:38.280, Speaker A: It should pass. Yeah, we got free passes. Six tests on this function has tried 256 different amounts of data, and they've all passed. If we add a single track that see if we can break it, and you can see here we've got an arithmetic overflow, because we have basically overflown the UN two, five, six variable by adding in a massive amount of data to that Un two, five, six, the number is basically too big to do it twice and that's actually failing on one use case. So that's a good example of how we can use foundry and the test suite and the fuzzing to kind of brute force our way and look at different edge cases and make our smart contracts more robust before we deploy them to Mainnet. So next I'm going to look at is completing a security challenge for this. I'm going to be using damn vulnerable DFI.
00:09:38.280 - 00:10:52.430, Speaker A: And this is a set of challenges which are written in solidity where you kind of have to find exploits within smart contracts. This was originally written in hard Hat, but someone called Nicholas Garcia two on four has migrated it all across the foundry. So it's a really good way to not only learn kind of smart contract security, but also get used to using forge to kind of poke around and inspect the security of smart contracts and do some kind of amateur auditing. So what we're going to do here is we're going to copy this git URL and I'm going to do git clone and paste that in. Okay, let's move into that directory and try forge test. Let's try to shortcut. So I'm just going to copy and paste the commands from the dambrunnable d five foundry installation instructions and yarn install should be up and running.
00:10:52.430 - 00:11:27.840, Speaker A: That might actually take a while. Okay, so we need the name of the test and a name of the contract. So let's have a look at these. Let's do the first one. Unstoppable. So open up these files which are the smart contracts which we need to find the exploit for. If we go into test levels.
00:11:27.840 - 00:11:49.540, Speaker A: Unstoppable. This is where I think we will be creating our exploit. We got, yeah, literally. Exploit start, exploit end. So this is where we need to code our exploit to try and break things. Let's just run this once to make sure we got, it's working. Contract forge, test, match, test, match, contract.
00:11:49.540 - 00:12:28.460, Speaker A: So for test, let's try. So call did not revert as expected. So that's working. Let's clear this and go and try to write an exploit. So I've done this before and spoiler alert, you just have to send some of the DBT tokens to the lender balance, I think it is. So we're going to use a cheat code to change our account. We're going to do VM start prank and we're going to be the attacker.
00:12:28.460 - 00:13:15.640, Speaker A: So this is going to change the account, which is executing a command to the attacker. And let's put in VM stop prank as well. And then in the middle of that, we're going to execute a transfer from our own account, the attacker's account, to the unstoppable lender, which is the contract here. So we can basically send this contract some DVT tokens that will basically render it useless and we should pass the test, hopefully. There we go. Test. Exploit gas to use 45,000 and prepared to break things.
00:13:15.640 - 00:13:55.182, Speaker A: So there's another eleven tests there, which is a really good way to kind of get more up to speed with forge and solidity. Smart contract security. Okay, the final thing I want to demonstrate here is deploying and interacting with a smart contract. So we're going to deploy this plus contract or the count contract we looked at earlier to the Rinkbee testnet. So what I'm going to do here is I've actually generated a private key public key pair using ether's vanity address. And this is the public key here. So I'm going to send some rinkby ether.
00:13:55.182 - 00:14:35.778, Speaker A: This is testnet ether. It's not worth anything, which is why I'm sharing the private key here. I'm not using this account for anything else other than this video. Let's send zero two e to that address. This is the command we want to adjust. And let's add the RPC URL in as rinkpot infuria copy the private key that I created, which is this one here. My contract.
00:14:35.778 - 00:15:23.770, Speaker A: Contract. Name of the contract is just contract solo contract. There's no constructor arguments here. So let's see if this workshop. And there we go. We've deployed to this contract address. Let's go ahead and have a look at this in rinkby E for scan that contract in.
00:15:23.770 - 00:15:58.310, Speaker A: And now we can use the other command as part of the foundry package cast to interact with this contract. I'm going to put the contract address in here. Total supply. What I'm going to call is count. And then I want the RPC URL to be the same as before. Let's clear this. Let's paste that in.
00:15:58.310 - 00:16:31.920, Speaker A: Now we get zero. Now let's try sending a transaction. So we're going to do a similar thing. We're just going to put cast send instead of cast call. We're going to plus no value in here. RPC URL is rank B again. And then the private key is this one.
00:16:31.920 - 00:17:08.716, Speaker A: The reason we have to use a private key here is because we're adjusting the state of blockchain. So we need to pay a gas fee or a transaction fee for that. And that looks like it's gone through. So if we call the original command now to check what the value of count is, it should return one. And it has. We've actually stored that data and manipulated on a blockchain, and we've done that via the cast command in foundry. So one thing I didn't mention there was that if you're kind of doing this on mainnet and using any real funds, you should almost certainly not put your private key into a command line.
00:17:08.716 - 00:17:54.440, Speaker A: You should use an environmental variables or even connect up a ledger hardware wallet. So who is foundry for and where does it really excel? For me, I think that foundry is great for testing and digging into smart contracts, whereas something like hard hat might be better for deploying more complex contracts, because that kind of JavaScript scripting environment is very powerful. You can kind of deploy one contract here, you can deploy across multiple chains. Well, you could all do that in foundry as well. I don't think it's particularly kind of suited or built for that specific purpose. There's absolutely no reason at all why you can't use foundry and heart hat together. So something I'll be doing in the future is using hard hat to kind of write basic kind of unit tests and kind of deployment scripts.
00:17:54.440 - 00:18:38.632, Speaker A: And then once I want to dig into a contract, maybe before kind of going into a production environment, then I'll be using foundry to kind of do some fuzzing and poking around within a smart contract. Also, if I want to kind of test someone else's code, then I'd probably use foundry for that, because I really like the way that you can write the test code in solidity. It feels like it's really well suited to testing other people's smart contracts and poking around and testing edge cases and things like that. For blockchain developers and solidity coders, it's one of the most powerful tools to have in your tool chest. I think it's well worth taking some time, get familiar with it, and find out how you can use it to make your code more robust before you deploy it. I hope you've enjoyed this tutorial and you found it informative. Please hit like button for the user algorithm.
00:18:38.632 - 00:18:42.990, Speaker A: Consider subscribing if you're interested in learning more about blockchain development. And thank you for watching.
00:18:43.760 - 00:19:20.960, Speaker B: Lisk is organizing the second edition of Blockchain Day, which will be one of the official events during Berlin Blockchain Week. Everybody is invited. Come and share your passion for developing blockchain applications. Blockchain Day is a special event for both developers and web three enthusiasts when they can learn more about the space and discover the most exciting insights from the industry. The event takes place on Wednesday, September 14 at the Lisk center in Berlin. Expect panel discussions on interperability with web three professionals, get insights from blockchain enthusiasts and learn from investors background. Plus, get ready for an exciting dive into Lisk SDK.
00:19:20.960 - 00:19:36.650, Speaker B: Join an evening filled with blockchain knowledge sharing and networking combined with some food and refreshments. It's a free event. To participate, you just need to register on the meetup page. Link in the description. Don't wait. Take this opportunity to join the Berlin blockchain scene on Blockchain Day.
