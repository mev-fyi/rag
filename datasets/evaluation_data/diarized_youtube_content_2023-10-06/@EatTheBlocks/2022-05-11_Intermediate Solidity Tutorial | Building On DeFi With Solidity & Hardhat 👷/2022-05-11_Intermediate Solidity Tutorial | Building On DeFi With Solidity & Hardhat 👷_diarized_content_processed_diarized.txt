00:00:00.570 - 00:00:54.038, Speaker A: In this solidity tutorial we're going to be building our own product on top of the Lego bricks of DFI. We'll be interacting with external contracts such as chain link, price feeds and uniswap version free to create a vault the purpose of the vault is to manage a 60 40 portfolio where 60% of the portfolio is held in cryptocurrency and 40% of the portfolio is held in stablecoins. This is an intermediate tutorial, so I'm going to be going quite fast and glossing over some of the basics. There's an introduction the solidity link to above. I'm going to be focusing more on the tooling that can be used to test and create solidity contracts and interact with external contracts to build real world products. I'm going to be using hard Hat, which is a framework for building and testing and deploying smart contracts on Ethereum and other EVM compatible blockchains. I'm a big fan of truffle, but I feel that hard hat is more expansive and the scripting language is really hard to beat.
00:00:54.038 - 00:01:22.514, Speaker A: It also has some great features, like being able to fork the main net or one of the testnets locally. We'll get more into that when we get to the test inspection. To run this, you're also going to need a JavaScript runtime environment which is called Node js. Most of you should be familiar with that, and then we're going to need an Alchemy API key. This is free for basic usage, and it's kind of if you're coming from a truffle environment, it's the same as an Infuria API key. It gives you access to a node on the Ethereum network. All the code that I write here is going to be open source.
00:01:22.514 - 00:01:47.226, Speaker A: It's available in a link on the description. There's also a blog post which goes into more details. Bear in mind that this code is for demonstration purposes only. It was written for the purpose of this tutorial, and it shouldn't be used on mainnet for real financial transactions. So if you want, you can go ahead and clone the GitHub repository and you can work for the files locally. We're going to move it into the repository and run NPM install, which will install all the dependencies, including hardhat. Now let's have a look at the hard hat configuration file.
00:01:47.226 - 00:02:12.514, Speaker A: This is a hardhat config js and I've got a couple of requirements here. We'll import effers and I'm importing a credentials file. We can see this example file here. We've got room for an alchemy API key, a private key, and an address for the account. You can get this from Metamask, or you might want to generate your own, just for testing purposes. We've got an ether scan API key which is used for verifying that contract. We then got some exports.
00:02:12.514 - 00:02:41.550, Speaker A: We've got two networks. We've got the Coven network, which is a test network on ethereum. We've got the private key imported from the credentials. And then we've also got a local network which is just a local host. The computer that I'm running this on, on port 8545, we'll be running hard hat node here to start up our own local node later on when we're testing. Finally, we've got an export for the e for scan API key, all pretty straightforward. So let's move on to the vault.
00:02:41.550 - 00:03:27.306, Speaker A: So I'm not going to embarrass myself by live coding here, but I'm going to go through each section and talk about the design decisions I made when writing this contract. So first we're doing this in a GPL license identifier, then we're using a pragma solidity 0.8. This is significant because in version zero eight the core solidity team introduced some fixes which prevented integrate overflows and underflows. This somewhat removed the need for Safemap, and I won't be using the Safemath library in this contract. I haven't actually tested this much myself yet. If I was going to put this into production, and I'd want to do some pretty robust testing of those native safety features, we then got some standard comments, the title, license, author, and anosis. We're importing the hard hack console, which lets us do things like console log inside the contract when we're running it locally.
00:03:27.306 - 00:03:57.106, Speaker A: We're going to import some open zeppelin libraries for ERC 20 interfaces and safe ERC 20 for doing safe transfer and things like that. We're also going to be using some Uniswap v three contracts, IsOP router and ISOP quota. The router is what we use to actually carry out swaps or trades on Uniswap v three, and a quota is going to be used as a price. Oracle to get the price directly from the exchange. We also got a custom interface here which is just used for the chain link. Oracle we've got an additional function on the ISOP brute interface, which is refund e function. We just called it the end of a swap.
00:03:57.106 - 00:04:27.970, Speaker A: And then finally we've got a depositable ERC 20. And this is for WEF. So, with wrapped ethereum, or Wef, what happens is it's a standard ERC 20 contract, because etH, on its own, a standard native token of ethereum, isn't actually ERC 20 token. So we can't use it in the same way as an ERC 20. So what we do is we deposit eth to the WeF ERC 20 contract, and it has this custom deposit function, which allows us to do that. It also has a withdrawal function, which we're not going to be using. So basically, all we need is a standard ERC 20 with this extra deposit function.
00:04:27.970 - 00:05:04.346, Speaker A: For that, let's take a quick look at how we can kind of find these functions and create these interfaces so that we can interact with external contracts. So if we take the WEf contract address here, these are the coven addresses. Let's go to ether scan. I actually want coven Etherscan for the coven testnet. Zoom in right here so you can see. Let's paste that contract address in. If we go to contract, we've got this little tick box, which means it's verified, and we can go to write contract.
00:05:04.346 - 00:05:33.394, Speaker A: We can see we've got some of the standard ERC 20 functions, like approve transfer from. We've also got these deposit and withdrawal functions, and we can actually interact with this contract directly from metamask. So if we open this up, sign into metamask, connect web3. Okay, we're connected. Now let's deposit zero point. Let's make sure we're on the testnet for sure. I do something silly.
00:05:33.394 - 00:06:00.618, Speaker A: Got Covid, testnet. We got a little bit of funds here. So let's deposit zero, zero, one eth into this ERC 20 contract. And what that's going to do is it's going to send us weft back. Now, what we can also do is go and have a look at the code. If we scroll down, we can see we've got this function, deposit public payable function here. And that gives us the framework for our interface.
00:06:00.618 - 00:06:30.742, Speaker A: So we go back to the code, we can see that this is pretty much the same as this. The only difference is, with an interface, you have to use external rather than public. But you can see that this top line here, which forms the instructions for how to use an external contract within our solidity code, is very, very similar to this top line of the function here. If you take a look at some of these open zeppelin contracts, these guys are the experts on how to create these interfaces. They've been audited by just about everyone in the industry. Okay, so scrolling back down, let's get into the contract. So we're declaring my vault as a contract.
00:06:30.742 - 00:06:58.530, Speaker A: Now we're going to create a version number which is version one. And then we're going to create a list of hard coded coven addresses. I'm not going to be deploying this to Mainnet. I'm only going to be using the covenant testnet. You could potentially put these into the deployment configuration and you could pass them into the constructor function. That's a better way to do it if you're going to be deploying to multiple separate networks here. I'm only really going to be using coven, so I'm just going to hard code the addresses in.
00:06:58.530 - 00:07:32.282, Speaker A: So I've got the DAI address which is a us dollar stablecoin wef which is wrapped Ethereum. I've got a uniswap quota address and the Uniswap router address. These are the interfaces for Uniswap that we declared earlier. I've got a chainlink e USD address. I'll just pop this into ether scan as well so you can take a look at this contract. And if we go to contract, just go to read and get the latest answer. What it basically does is give us a price for Ethereum.
00:07:32.282 - 00:08:08.746, Speaker A: It's that simple. This is on testnet, so the price won't be accurate. If we go to forward slash docs, Ethereum hyphen addresses, you can see there's different price points for lots and lots and lots and lots and lots of different markets. And Chainlink provides these data price feeds as an oracle service. If we go to any one of these, we can go to the contract, read contract and get the latest answer. Bear in mind these aren't live prices and it's always a good idea to check the latest timestamp as well. Once we declared our external addresses, we're also going to declare some state variables.
00:08:08.746 - 00:08:35.026, Speaker A: We've got the ETH price, which is currently set to zero. This will be updated by Oracles. We've got USD target percentage just as a custom variable. I've got it set to 40. So I'm going to have 60% of the portfolio in Ethereum and 40% of the die stablecoin, the USD dividend percentage. So I've got this set to 25% which is basically you can draw down 10% of the overall portfolio period. The period I've got is currently 3 minutes for testing.
00:08:35.026 - 00:09:06.366, Speaker A: You probably want to change this to maybe once a year so you could draw down 10% a year from the contract. This would be useful if you want to sell something like a perpetual fund for your kids or a charity or something like that. We've got a next dividend time stamp that's set in the constructor. And we got an owner address which is also the address that deployed the contract where you're going to need some funds to pay for the gas fees to deploy the contracts. And that's the owner address which actually owns this contract. We're using safe ERC 20 library for both the standard ERC 20 interface and the depositable ERC 20 interface. Then we're declaring our actual tokens.
00:09:06.366 - 00:09:51.754, Speaker A: So the die token is just a standard ERC 20 and then the weft token is a depositable ERC 20. Then we're also going to declare the quota variable to be the Uniswap quota and then the Uniswap router to be the Uniswap router interface. Then we're going to use a pretty ugly event log which is just an example of how to use events. And we're going to declare that Myvault log takes a string and a reference and that we log to ether scan and other tools which can log those transaction events. The construction function, as I'm sure you already know, it's only run once when you deployed a contract. And all we're doing here is we're setting the variables for the next dividend timestamp to be the block timestamp, which is the Unix timestamp or the number of seconds since January 1970, plus the dividend frequency which is a number of seconds in 3 minutes. And then we're also going to set the owner to the message sender.
00:09:51.754 - 00:10:18.886, Speaker A: So the owner address is set to the deployer of the contracts. We then got two functions here, which might be a bit overkill, but we're just basically getting the die balance and getting the weft balance. These return the balance of those ERC 20 tokens. Now we've got the get total balance which is a public view function which returns an unsigned integer. We've got our first example of a require statement here. And this requires that the Ethereum price is set to above zero. Remember, we set this if price value as zero in the state variable.
00:10:18.886 - 00:10:56.034, Speaker A: This basically checks if we've actually run an oracle service yet to update the Ethereum price. We could take this a step further and kind of check the timestamp that we updated that and logged that if we want to have a more recent price and ensure that the price has been updated recently for the purpose of this tutorial. That's fine. We've also got a string or a piece of text here which if this requires statement isn't met then the whole transaction will fail and that string will be logged. We're using the functions here to get the die balance and get the weft balance. We're then calculating the US dollar value of that wrapped ethereum. So we're taking the weft balance multiplied by the Ethereum price.
00:10:56.034 - 00:11:32.638, Speaker A: Bear in mind this assumes that both assets have 18 decimals, which they do. If you want to swap this out for another stablecoin for example, or another cryptocurrency, you'd want to check that it has 18 decimals. Or this isn't going to add it up correctly because the total return includes the 18 decimals. We're then adding the weft us dollar balance to the die balance and returning the total balance. Next we're going to look at updating that price feed and we've got two different functions here. There's a reason for that and that is that on testnet no one kind of arbitrages the prices. So what we've got is we're getting a price from the Uniswap decentralized exchange and a chain link price.
00:11:32.638 - 00:12:23.166, Speaker A: These prices would be totally separate and that's quite useful for testing because you can kind of adjust the price and see how that affects your portfolio. So we've got update eth price on uniswap we've got the quote exact output single function which is a function of the Uniswap contract and that basically just gives us a quote for our transaction. The Chainlink oracle function is very similar just using this EAC aggregator proxy function to get the latest answer, which is what we basically done with ether scan earlier. The only complexity here is we're outputting a signed integer from the Chainlink price feed. We've got to change that to an unsigned integer so that it matches the Uniswap function. Next we have a function to carry out a pretty standard uniswap transaction. So buy wef and what we want to do with this function is take a die amount and purchase wef with those tokens.
00:12:23.166 - 00:12:53.194, Speaker A: So we've got a deadline which is the block stamp plus 15 seconds. We've got a fee of 3000 and that translates to zero 3% which is the standard pool size. We've got a recipient address as ourselves. We got the amount in is the amount in us dollars, which is passed through to the variable which includes the 18 decimals we spoke about earlier. Got the amount out minimum. We've got this set to zero, so that would open up to slippage and front running if we were using this for large transactions in Mainnet. No one's front running in testnet, so that's fine.
00:12:53.194 - 00:13:24.802, Speaker A: We've also got a square root price limit is also set to zero. We've got an example here of the emit event where we're going to use that my vault log event to emit the text amount in and then the value for amount in. This is pretty standard. It'll just create a transaction log where we can go in and see how much has been passed to this variable. It's quite useful for debugging more than anything. With ERC 20 tokens, we actually have to approve the spend of the token by the uniswap router. So we're going to do that by using the die token approve function.
00:13:24.802 - 00:14:08.526, Speaker A: And this is a function of the ERC 20 token itself. I'm going to pass through the Uniswap router address and for the total of the amount in this basically says go ahead uniswap. You can spend these tokens as and when you see fit. We then use the iswap router interface and we call the exact input single function down here with the parameters that we've already spoken about. Finally, we execute this refund eth which returns any eth to our account. So how can we actually come up with these functions to interact with these contracts? One of the things that's really useful is we can take the function name which we can find from etherscan and the contract address, and then we can go to GitHub. There's lots of examples where contracts arbitrage.
00:14:08.526 - 00:14:39.810, Speaker A: Have a quick look at this one where there's already people using Uniswap v three and there's existing code to do this type of thing. Obviously this code might not be secure and this might not be audited, but we'll give you an idea of how to use these functions and what other people are doing to interact with external contracts. We then have a very similar function called sellwife. The only difference here, instead of exact input single, we're using exact output single. So we're declaring the amount out in us dollars. Then we got this rebalance function. This is going to form the bread and butter of our contract.
00:14:39.810 - 00:15:10.646, Speaker A: This is going to be the rebalancing that kind of takes whatever kind of percentage we've got in our portfolio. So if we kind of deposit 100% stablecoins, it will sell off some of them stablecoins into cryptocurrency and vice versa. So we can run this whenever we want and it will rebalance the portfolio back to a 60 40 strategy. So let's have a look at this. We've got a required message sender equals owner. Only the owner can rebalance their account. So this is a personal vault that only the owner who deployed the contract can use.
00:15:10.646 - 00:15:43.614, Speaker A: It's not a great example for how DeFi should work, but it does keep it simple. For the purposes of this tutorial, we've got a US dollar balance which is just the dai balance, and then a total balance which is using the get total balance function we declared earlier. We can then work out the balance percentage. It's a strange way to be calculated percentage, because normally you do the US dollar balance divided by total balance times 100. We're actually using 101st. We're doing the multiplication first, which is a little bit unusual. But the reason we're doing that is because we're working with integers here, and if we went down to decimals or fractions, it wouldn't actually work as a calculation.
00:15:43.614 - 00:16:25.040, Speaker A: We're then going to use the event log to output that percentage. We've then got a symbol if else statement, whereas the US dollar balance is less than the target percentage. Then we need to sell some WEF, otherwise we need to buy some. There's a required statement in both of these just to make sure that there's something to sell or buy, then executes the functions that we looked at earlier to buy or sell the WEF on uniswap v three the next function we have is for the annual dividend, so I've called it annual dividend. It's actually set a free minute time period. Currently we've got the required a message as a sender. We've also got the required the block time or the block timestamp is greater than the next dividend timestamp, which was set during the constructor argument function.
00:16:25.040 - 00:17:11.626, Speaker A: We then get a balance, which is the die stablecoin balance, and we take our dividend percentage, then use a safe transfer function which is part of that safe ERC 20 open Zeppelin library to transfer the owner of the contract, who is ourselves. The amount that we've calculated they are due. We then set the next dividend timestamp to be blockdoc's timestamp plus the dividend frequency. There could be a little security vulnerability here, where we should probably set the next dividend timestamp before we call an external function. We've then got a close account function, and this could be optional. Obviously it kind of reduces the usefulness of having an annual dividend. But for testing purposes, this basically just lets us remove the entire die and weft balances from the accounts.
00:17:11.626 - 00:17:47.206, Speaker A: We're using safe transfer again here to send that owner the complete amount. We then got a receive external payable function. This is a default function that does absolutely nothing except it allows us to receive ethereum to the contract address. So we can essentially send Ethereum to the contract address and it will be stored in the contract. We're not doing anything within this function, because if we've done anything, it would actually break the transaction. Metamask uses a quite tight gas fee for sending transactions, and that doesn't allow us to do much within the function. The final function we've got is a function to wrap that ethereum.
00:17:47.206 - 00:18:22.840, Speaker A: So we'd have to call this after we sent the transaction. It basically takes the Ethereum balance and it uses the west token deposit function, which we declared earlier, using the value of the balance to wrap that ethereum so that we can use it within the portfolio. Let's move on to testing. And I'm not going to bore you with writing unit tests for all these functions. I want to go through three examples of how you can use hard hat to create really robust testing systems. The first thing we have here is a basic test program. We're going to deploy the contract so we get a fresh variation of the contract before each test.
00:18:22.840 - 00:18:46.306, Speaker A: We're simply using hard hat and chi here. Chi assert. We're going to import the hard hat runtime environment, and we're going to compile the contract, we're going to deploy the contract, and then once it's deployed, we're going to get an address. Then we're going to start running our tests. The first test is it should return the correct version. There was a state variable. We just said version equals one in the contract.
00:18:46.306 - 00:19:18.370, Speaker A: So if this doesn't go right, then there's something very, very wrong. Let's do MPX hard hat test, and pretty straightforward. We can see that our assert equals version equals one is correct. Now let's move on to something a little bit more interesting. Having issues straight away here, because it should return a zero die balance. We actually have to connect to an external contract for the die token for this to work. We don't have that on our local testnet.
00:19:18.370 - 00:20:06.226, Speaker A: So what I'm going to do is I'm going to create a fork of the state of the local testnet. I'm using hard hat node and alchemy to create this fork running on a local node. So I'm basically going to take a copy of the Coven Testnet and run it locally. So to run this we're going to use MPX hard hat node fork. Then the URL for the alchemy API note it's got ethn coven as the subdomain. Then your API key goes here we hit enter and we get a bunch of highly insecure accounts and private keys that is actually running now. So if we open up our test script and we do NPX hard test and then network equals local, that's going to connect to our local node which is running this Covid fork.
00:20:06.226 - 00:20:36.826, Speaker A: We can see actually we've got some functions coming up here. The first test passed, the second test didn't run because I didn't save the document. That's why I get paid the big bucks. Let's run that again. And we can see that both of these tests have executed well. Right now we're going to get into a really complex example, which I think shows just what you can do with the hard hat test environment. So what we're going to do is we're going to take the accounts that hard hat provides.
00:20:36.826 - 00:21:03.080, Speaker A: I think maybe we've got a thousand Ethereum minimum or something. Then we're going to send a transaction, we're going to send some ethereum over from the owner account to the contract itself once it's been deployed. We're then going to start calling some functions. We're going to call wrap eth. So we're going to wrap that Ethereum that we just sent and then we're going to update the ethereum price on uniswap and then we're going to rebalance it. Then we're going to check again that our dai balance is above zero. So let's save the file and run this again.
00:21:03.080 - 00:21:36.100, Speaker A: Again, we're going to run it on a local network, which is a falk of the COVID network because we're using external functions here, quite a lot of external functions. You can see we're going to transfer the Ethereum from the owner address. It's quite nice that you can use console log as well, both in the solidity contract and in your scripting. There you go, we've got free passes. I think that demonstrates how useful this test environment is. You can create really complex testing scripts, you can kind of almost create fuzzers and stuff like that. It executes quite fast and you can really use that to improve the confidence in your own code.
00:21:36.100 - 00:22:22.146, Speaker A: Now let's talk a little bit about security and auditing. So obviously the absolute best thing you can do is get an audit by a third party. There's nothing more valuable than having a second pair of eyes look over your contract, particularly from a security perspective, and see the things you've missed and kind of go through complex situations which you might not have considered when you were developing the contract. Having said that, if that's not possible, or the funds aren't available, there's some things and some tools that we can use as well. One of my favorites is sliver. I found it's quite complex to set up and I could only get it working in Linux, so I'm using Windows subsystem for Linux, and let's see if I can make this a little bit bigger. There's some instructions on my blog for how I set this up and how I installed it.
00:22:22.146 - 00:23:20.130, Speaker A: Let's move into the directory, which is cdmount, C share Doc Myvault. I just could do sliver. Let's have a look at the options. There's a lot of options, I won't go through all of them, there's pretty solid documentation here, but basically it's a little bit like Eslint, where we can do sliver dots. This will compile the contract and it's going to give you a load of errors, both on your dependencies and also on your own contract code. I think it's a little bit like Eslint as well, where kind of a lot of the things you're going to disagree with about code quality and that kind of thing, there's a lot of false positives and then maybe a year later you actually decide that they were right all along. But it's a great tool, it's quick and easy to use, and it gives you a first indication of the real stupid stuff that you might have got wrong in your contract.
00:23:20.130 - 00:24:24.840, Speaker A: There's things like my vault is not loving my use of capital letters, which is fair enough, but not really a security vulnerability. We scroll up, we'll see the yellow and red ones really is a lot because I got this zoomed in so much, it's not formatted very well. We can see there's things like we're ignoring the return value of the Uniswap ruser. There are some reentrancy type bug warnings as well, which would be worth looking into for sure. Although these are on the open Zeppelin contract, so more than likely they're just false positives. Like I said, if you're going to be deployed to mainnet using real funds, you want to do everything you can to make sure the code is robust and secure as possible. Obviously, once it's been deployed, you can't change it.
00:24:24.840 - 00:25:16.164, Speaker A: If you've got funds available, they're going to be targeted by hackers. There's also fuzzers available, like a shedna, where you can kind of fuzz the inputs to different functions and send weird data and integrate overflows and stuff like that to try and kind of create problems, and they're great as well. These are kind of the low hanging fruit, if you like, of solidity smart contract security. Having said all that, I reiterate that if you're going to be using contracts for real finances, then there's nothing quite as valuable as a third party audit. So once we created all our unit tests and we've looked at the security of our contract and we're confident in the code quality, we start thinking about deploying our contracts to the remote testnets and main nets. So for this we use a deploy script. Again, this is quite similar to the test script we're going to be importing the hard hat runtime environment.
00:25:16.164 - 00:25:42.720, Speaker A: We're also importing file systems for node js and the main function here we're going to give it a contract name. We're going to compile the contract from within the deployment script. A lot of people have this as a separate function, but I like to do it to make sure that the code is compiled every time I make changes. I'm going to deploy the contract. I'm going to write the artifacts to a external file. This is useful for once we get into kind of web free and front end stuff. The artifacts contain things like the ABI and some deployment details.
00:25:42.720 - 00:26:17.930, Speaker A: Finally, from within this deployment script, I'm actually going to verify the contract on Etherscan. This is probably my favorite functionality of all time because it means that once it's deployed, you can go straight into Etherscan and start interacting with the contract using metamask. So let's look at how this works. I'm going to go MpX, hardhat, run scripts, hyphen deploy. I'm going to set the network to Covim. Let's see if this works first time. Looks like the vault's been successfully deployed to this contract address.
00:26:17.930 - 00:26:59.650, Speaker A: Now the final thing is the e scan verification, and we successfully submit the source of the contract just wait on e for scan to verify result and it should pop out a URL which we can visit. Look at that. That is a thing of absolute beauty. Let's copy that, go into our web browser, paste this in here, and here's our contract. Let's have a little play around with it. Let's go to write contract. Actually need to send some funds first.
00:26:59.650 - 00:27:37.060, Speaker A: Let's send it some funds. I'll send it some ethereum. Ethereum can confirm that transaction that's gone through. If we refresh this, we should see this. Balance updates zero one. So we sent the contract zero one ethereum. We can then connect our wallet to ether scan and then wrap that ethereum.
00:27:37.060 - 00:28:09.260, Speaker A: Note that the wallet address in metamask needs to be the same wallet address that you've got in your credentials file. That's confirmed. And this will go back to zero now because we've actually got a balance of ERC 20 tokens. Let's reconnect our wallet. So we've wrapped our Ethereum. Now let's update the price on uniswap. So we're going to use Uniswap quota as an oracle service to get that data feed.
00:28:09.260 - 00:28:47.084, Speaker A: If we go into read contract, get the ETH price, it's already updated. That's great. We can get our die balance here is zero. But now if we go into write contract and we rebalance the portfolio, we have 100% of our portfolio currently in WEF. Once we've executed this transaction, if it goes through successfully, if we go back into our die balance once that transaction has gone through, this should increase dive balance. There we go. There we go.
00:28:47.084 - 00:29:21.700, Speaker A: It's not going to be perfect because the pricing on the Ethereum testnet or the COVID testnet isn't accurate at all on the decentralized exchanges. If we look here, we've got a price of $17,000 for ETH and it's only 2021. That all seems to be working. Let's have a look now and see if we can take our annual dividend. It must have been gone 3 minutes since we executed the contract or deployed the contract. Sorry. Let's take our annual dividend confirm.
00:29:21.700 - 00:29:45.020, Speaker A: We should see this Dai balance decrease if we put the Dai token balance into our wallet in a second. That will do that. Now we wait for that to go through. Let's just grab the token address from our contract, which was die address. This one here. This is the ERC 20 die address. Let's add that as an asset in Metamask.
00:29:45.020 - 00:30:01.470, Speaker A: So we've rebalanced our portfolio and we've taken 10% out of the portfolio. We now have to wait for a set period, 3 minutes in this case before we can take any more funds out. Or we can just close our account. I'll leave this contract up if anyone wants to have a look at it. I'll put a link to it in the blog post.
