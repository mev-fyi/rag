00:00:11.760 - 00:00:35.314, Speaker A: And we are live. Welcome everybody, for this live stream. Today we are going to do a full course for solidity. This is going to be for complete beginners. So there is zero prerequisite. So let me know if you, where you are from in the chat. I see some people already.
00:00:35.314 - 00:01:21.516, Speaker A: I see Patrick, I see Raul, said Miguel, Michael. Well, seems like we have many people today. Aba, Manu, Roland, Delta five. Amazing. So, briefly, if you are a complete newbie. So I'm going to do a little advertisement here, but this is going to be fast. So we do a full, solid bootcamp on either blocks to turn you into a complete solidity pro in one month.
00:01:21.516 - 00:01:53.398, Speaker A: So the next bootcamp is going to start May 20. So this is roughly one week. And yeah, so this one is for complete beginner. And the goal is that at the end you will be able to get your first freelance gig that will basically more than pay back for the boot camp. So enrollment is open until Friday. So you have one day and a half left. And, yeah, so we have 30 people per cohort.
00:01:53.398 - 00:02:36.552, Speaker A: So I just posted the link in the chat. All right, so if you are new here and you don't know who I am, so I'm Julian, the founder of eat the blocks, and I've been a blockchain developer since 2017. And so I've worked with this technology on a day to day basis. I've worked for a couple of big projects in the space as a full time employee, as a freelancer, and I've taught more than 15,000 students blockchain development, especially solidity. So that's, that's it for myself. Intro. And so next, let's start with this course on solidity.
00:02:36.552 - 00:03:06.940, Speaker A: All right, so what is, what is this thing? Solidity. So here, this is the homepage of the solidity website. So we on the blockchain, on the Ethereum blockchain, we have smart contracts. Smart contract. There are this small program that run on the blockchain. Okay. And they are written in a programming language called Solidity.
00:03:06.940 - 00:03:45.820, Speaker A: They don't have to be in solidity, they are other programming language, but most of them are in this programming language. And so this programming language look like JavaScript, but not exactly the same. So it's actually quite tricky. It looks easy on the surface, but you have to go a little bit deeper if you really want to be a good solidity developer. So what I want to, what I want to show you is a real life spot, smart contract. And by the way, I see some question in the chat already. Some people are asking if we need to learn another programming language before that, like JavaScript.
00:03:45.820 - 00:04:10.310, Speaker A: No, that's not necessary. So let's go on ether scan. Okay. And ether scan is what we call a blockchain explorer. So you can see, you can search smart contract by their address, or also you can search them by keywords. For example, USDC. That's a stable coin that's basically like another version of the dollar but on the blockchain.
00:04:10.310 - 00:04:31.810, Speaker A: So one USDC always equal $1 and USDC. So this is a smart contract. And so we can see the address. So if you click here, we can see the address of USDC. Actually, I'm going to zoom in a little bit. Let me see. Yeah, I think it's a little bit better like this.
00:04:31.810 - 00:05:09.468, Speaker A: So here we can see the address of USBC. So you can see this as a, this is an id basically to identify the smart contract. So smart contract can have a balance of ether. So it's like a bank account, basically it tells you how much money it has. And here if you go here, you click on contract and you can see the source code of the smart contract. So don't worry, at this stage you're not expected to understand how it works. But basically here we can read the code of the smart contract.
00:05:09.468 - 00:05:52.458, Speaker A: So solidity looks like this. And on Etherscania you can basically read the code of each smart contract like this. So I mentioned that solidity is for Ethereum smart contract. But actually there are many other blockchain that where you can use solidity. So you go on this website, Chennai's dot, and you can see all the blockchain where you can use solidity as well as all the development tool for ethereum. So you have Ethereum, of course, but you have other one like BNB, smart chain, base, polygon, etc. And that's because under the hood, even though those are other blockchain, they actually use the tech of Ethereum.
00:05:52.458 - 00:06:38.968, Speaker A: Ethereum including solidity. So very, very important to know one little detail about solidity is that even though this is a programming language for Ethereum, actually technically it's not part of the Ethereum blockchain. This is a high level language and we need to compile this language, meaning we need to translate this language into a low level dialect. And this is this dialect that the Ethereum blockchain understand. And so you can actually see this EVM code. Let me see. So here on this website, EVM codes, you can see the list of this low level dialect I mentioned.
00:06:38.968 - 00:07:15.780, Speaker A: This is what we call EVM bytecode. So this is a series of elementary instruction like this, stop, add, multiply, etcetera. And so it's not really readable for us. So it's readable for computer but not, not for programmers. So this is why we program in this high level language, solidity. And then it's going to be translated to this low level language that will actually run on the blockchain. Okay, so we are going to start our 1st, 1st smart contract.
00:07:15.780 - 00:07:42.154, Speaker A: Okay, so for that you guys going to go on a website called remix dot ethereum.org dot. So I'm going to paste this in the chat. Let me see, just 1 second. I see someone in the chat that just bought a course of in the blocks. Awesome, man. Welcome.
00:07:42.154 - 00:08:21.094, Speaker A: So remix dot ethereum.org comma, you go on this website and that's basically an online ide so you can use it to code in solidity. And that's amazing because really you have nothing to install. This is just a website, so it's really easy. And so we are going to do our first smart contract so that you can understand that you too, you can do a smart contract, something too complicated. So you go, you have different, different places in remix. So here you click here, this is the file explorer and you click here.
00:08:21.094 - 00:08:48.124, Speaker A: And here you click the name, you type the name of your smart contract. Helloworld.com dot what I'm saying this is not a website. Sol s o l. So that's the file extension of solidity. And, and we are going to type after what we call the pragma statement. So in this area, this is the coding editor.
00:08:48.124 - 00:09:23.024, Speaker A: And the pragma statement is going to give us. It's going to specify which version of solidity we are going to use. So we're going to use zero 8.25. So that's the latest version. If you see some existing smart contract on the blockchain, you will see that they may have different versions. For example here, USDC, you can see that its version is much older, zero 424. So that means if you check this contract, maybe the syntax will be slightly different because the rules were not exactly the same.
00:09:23.024 - 00:10:11.768, Speaker A: But when you start a new smart contract, you always want to use the latest version. All right, so here, I'm gonna go very fast here because I just want to show you quickly how you can do your first math contract. So we're gonna do a simple function that return the fixed string, okay? So pure it's going to return just a string. And I will explain after. But now I just want to show you an example, hello world. Okay, so here seems like everything is fine. So now we go on the deploy tab.
00:10:11.768 - 00:11:03.150, Speaker A: This is this menu here we click on deploy. So you may wonder where this is going to deploy our contract, because is it going to the real blockchain, what we call Mainnet? Well, it turns out it's possible to have different network, so we have the real network where we spend real money. But the problem is it's not really great if you just want to learn, okay? Because every time you send a transaction, you need to pay real money, so you don't want to have to pay for every time you're learning something. So that's why in remix there is a really great feature where you, you can just deploy to what we call a local blockchain. And it's completely isolated from Mainnet, so you can make any mistake that you want. It's like a playground that you can use. And so here we can select this playground.
00:11:03.150 - 00:11:34.498, Speaker A: If we go to environment, we see remix VM. That's basically this local blockchain I'm talking about. And so we click on deploy and we see our contract appearing on the lower left corner here, Tata tat. And we can see our function. Hello. So this is this button here. So if you click on hello, we see here this string appearing hello world.
00:11:34.498 - 00:12:15.654, Speaker A: So it's probably not very clear on my screen, but if you do it on your laptop, you will see hello world appearing. With this, basically you've deployed your first smart contract. So you see that wasn't so difficult. So now I'm going to go back to the code editor and I'm going to expand a little bit more in detail. So our smart contract, they are defined by this keyword here. Contract. Everything that you see in blue, this is a special syntax keyword, okay? So you cannot use this, this word yourself.
00:12:15.654 - 00:12:52.174, Speaker A: This is, for example, if I want to call a contract, contract. Solidity will not be happy with this. Okay? And you can see this, we have this underline here, the syntax highlighter in red that tell us you can see here it's not happy. So when you see this exclamation mark in red, it means you have a problem. And you can also see it here here in the solidity compiler compilation failed, so we don't have the right to use those blue keywords. So contract. And then the name of the contract, you can use any name that you want except the forbidden keyword.
00:12:52.174 - 00:13:22.754, Speaker A: So I call this just my contract. And then you open the curly braces and everything that you put inside is going to belong to this contract. So it's a little bit like when you have an object, you can put things inside this object. And for example, if we were to define another contract here, my contract too. So those are two completely different contract. Okay. Everything that is inside here is independent from everything that is inside here.
00:13:22.754 - 00:14:13.578, Speaker A: All right? So you know, the basic layout and what we're going to have in a contract is basically two kind, two kind of things really. So we're going to declare variables here, exactly what we call state variable. So those are basically saved in the blockchain. And after we going to have our functions. So state variable, this is basically your data, right? And the function, this is how you can read or modify the data. Okay, so that's, that's the logic. So here when we define a function, we have the function keyword and then we have the name of the function.
00:14:13.578 - 00:14:47.522, Speaker A: Then we have parentheses like this, and so we can have arguments in the parenthesis. We will see this after, and then we have a bunch of keywords here. So I'm going to explain this step by step. So external means that you can call this function from outside the blockchain. Pure means that, pure means that you can, you are going to return, this is going to be a read only function, so it doesn't modify anything. So here we can see it's just returned this. That's it.
00:14:47.522 - 00:15:33.990, Speaker A: And after the returns keywords is going to give you the nature of the variable that we return. So that's because in solidity this is what we call a type language. So we always need to specify the type of the variables that we manipulate contrary to Python or JavaScript. In Python, JavaScript, for example, you can do something like JavaScript, you can do cost, I don't know, my variable equal ten or something like this. But in solidity you cannot do this because we don't know here what is, if we don't instantiate this with ten, basically this variable could be anything. But in solidity you cannot do this. You have to specify the type of the variable before.
00:15:33.990 - 00:16:19.284, Speaker A: And this type is, is not flexible. Once you've decided the variable is of a certain type, you cannot change it anymore. So big, big difference with dynamic languages here. And so the type of the return in the function is a string, so that string, and then we have this memory keyword. So I'm just going to, not going to get too much into the detail for the memory keyword, but basically fostering is always string and memory most of the time. Okay, so, and then after we have the return keyword hello world. And so here, if we, if we change something in hello world.
00:16:19.284 - 00:16:48.294, Speaker A: So for example, put several h here. So let's, let's deploy again. And if we click on hello, now we can see the string is different. Okay, so I told you about some keyword here, like external. What if it's not external? Let's try hello, I don't know, hello another one. And this one's going to be internal, okay. And it's not going to do anything.
00:16:48.294 - 00:17:22.614, Speaker A: So what's going to happen? Let's click on deploy. And now we can only see hello even though we actually have hello. Also we have two functions, but we just see one of them. The other one is not visible from outside of the blockchain. So we can call Hela from inside a contract. For example here we could do hela like this, but cannot call it from outside. Right? So this is really, really basic function.
00:17:22.614 - 00:17:57.760, Speaker A: And now we're gonna start to talk of state variable because you know, this is just a pure read only function. It just return the strings. Not really interesting. So what we want to do is interact with data, right? So there are different kind of variables, but the one you're going to manipulate the most is uint. So that's unsigned integer, that's basically 0123, etc. So we don't have decimal number in solidity. So you don't have 1.5,
00:17:57.760 - 00:18:30.414, Speaker A: for example, is not possible. It has to be integer. And it goes up to a very big number, which is two power 256 minus one. So we have our uint here and then we define if we can read this un from outside the blockchain. So if you put public, that's yes, if you put private, that's no. So let's try it public. Var one right in.
00:18:30.414 - 00:19:09.838, Speaker A: Okay, let's remove the function here you inv one and then you int var two. All right, and so the second one, we want to make it private. So I want to show you the difference. So we deploy in here, va one, we, it's available, but VaR two, we don't see it because that's private. And actually we can read the value of VaR one. And so we see the default value of integer, which is zero. But if we instantiate it to something like ten, that's going to have a default different initial value.
00:19:09.838 - 00:20:06.084, Speaker A: So now it's going to be ten. Okay, so we have, we have those state variable, and now let's do something a little bit more difficult. Let's try to read the value of one of these variable with a function for example va two, we, we don't have, we don't, we do not sit outside of the blockchain, but we can create a function for that. So we can create a function called get va two. Right. And this time we're not going to use the pure keyword, but we're going to use view. So pure is when you return a static piece of data, like a string for example, static string, but view is when you read from a variable and here returns so uint this time.
00:20:06.084 - 00:20:45.760, Speaker A: And here we're just going to do return var two, right, so should, yes, it's fine. So let's deploy again. And here we see two functions, so var one. That's because this is a public variable. So automatically it create a getter function with the same name. So here it's ten and get va two. So it's going to return zero and yes, so now it's a bit more interesting.
00:20:45.760 - 00:21:52.844, Speaker A: We can declare variable and we can also create a function to read them. So so far we've just read variable, but on the blockchain we want to read and also modify variable. So that's why we are going to do a counter. So let's, let's do a counter. And when I call this data, for example in, we're going to call this increment. So now we're going to do is data equal data plus one, alright, and we're going to return remove view because this time this is not going to be a read only function, but we're actually going to modify the blockchain and you're going to read, move, return because we're not returning anything. Alright, so data equal data plus one.
00:21:52.844 - 00:22:35.108, Speaker A: And we can also have a function that decremented, so decrement data equal data minus one. Right. So let's deploy again. And now we see three functions. So data give us the initial value zero increment. So now we see that something is happening here at the bottom of the screen. So this is, this is like, this tells you that we just sent a transaction and it gives you the detail of this transaction.
00:22:35.108 - 00:23:03.968, Speaker A: So let me pull this up and let's open this. Okay, so here, this is a little bit small. I don't know if you can see it clearly. I'm gonna try to. So we see different information. So it tells you that it's a transaction. Mine execution succeed we have the transaction hash.
00:23:03.968 - 00:23:49.966, Speaker A: So that's an id that, that we can use to identify the transaction. So we can use the blockchain explorer, like if the scan to actually search for this transaction hash. In this case, it's not going to work because we have the, we're using the virtual, the local blockchain of remix. But if we were doing a transaction in on the public blockchain, we would be able to use this blockchain explorer. Then we can see the blockchain hash. So basically where in the blockchain this transaction was mined block number, few detail. And here.
00:23:49.966 - 00:24:30.014, Speaker A: So from the sending address, zero x five b, something. And if you scroll up, you can see that this matches what we have in the account field here. Zero x five b, etcetera. So if you select another address here, you will see the from field that is going to change two. So it tells you which contract he called with the function. And then we have some field about transaction cost. So the thing is on the blockchain, when you modify data, you send this transaction that I mentioned.
00:24:30.014 - 00:25:15.094, Speaker A: And this costs money. This costs money because the miners so also called validators. So these are entity a computer basically that will charge you money to run your transaction because it costs them money to actually do it. So we need to pay them and we pay them with ether. But it's where it gets a little bit complex. We actually use another unit to measure this transaction cost that is called gas. So I don't want to spend too much time on gas, but basically from high at this point, just remember that it means how much money you paid for this transaction.
00:25:15.094 - 00:25:58.344, Speaker A: And here, the field that tells you how much money you actually paid was 43,000. So this one transaction cost, basically you have another one called execution cost. So that was the cost of running the solidity code. But on top of it, there is also a fixed cost per transaction, which is 21,000 gas. So no matter what you do, if you send ether, if you execute a contract, etcetera, you always pay 20,000. And then on top of it, you also pay per for each extra action that you do. So like running a smart contract function.
00:25:58.344 - 00:26:23.244, Speaker A: And the more complex it is, the more it's going to cost you. All right, so here we. Yeah, that was our transaction. And if you look at other things, let me see. So for example, this one, this one here was different. This one was a call. Okay, so when you see vm here, it means that was a transaction.
00:26:23.244 - 00:26:53.156, Speaker A: But when you see call, it means that was just a call. So when you call a read only function, this is just a call. This is not a transaction and it costs you zero. It's free to read data from the blockchain. It only costs you money if you modified. Okay, so, so, so that's it for, okay, let's, let's lower this. Let's lower this.
00:26:53.156 - 00:27:39.734, Speaker A: Okay, so let's go back to, yeah, to hear our different mosquito. Almost got it. So here in green, in dark green you have the read only function data and in orange you have the function that actually modify the blockchain like increment or decrement. Okay, so that was a very, very simple contract. So now I want to show you some other, some other data structure, some other type of variable. So you int, this is the one you're going to use the most. And after you int, another one that is very useful is address.
00:27:39.734 - 00:28:18.884, Speaker A: Like for example here. So an address basically identifies smart contract on the blockchain, but also wallets. So you have two kind of addresses. One is called, okay, so let me remove that. One is called an EOA address and one is called basically a contract address. So an example of a contract address would be for example here we can see our deploy smart contract. So we can copy it here.
00:28:18.884 - 00:28:54.944, Speaker A: This is a contract address, the address of this contract and the EOA address will be the deployment address. So here in account you click here. And the big difference is that the EOA address is going to be associated to a private key. So basically like a secret password if you want. And you can use this private key to send transaction on behalf of this EOA address. Okay, so if you own some ether, for example, you have wallet like metamask. This is an EOA address.
00:28:54.944 - 00:29:31.208, Speaker A: So most of the EOA addresses are controlled by human, but you can also be controlled by code. For example, if you have a backend somewhere and it has a private key, then this is going to be an EOA address. And then you have this smart contract address that identifies smart contract. So they don't have a private key. Okay, so you cannot control a smart contract with a private key. A smart contract, all you can do with it is you can deploy it and then it's basically waiting for incoming transactions. So it has this function and you need to execute its function, but it's just passive.
00:29:31.208 - 00:30:25.226, Speaker A: There is no way for the smart contract to, you cannot use the private key of the smart contract to control it. This does not exist. So big, big difference. And so in this variable type address we can store the two type of address, right? So yeah, so this is address. Another type of variable is a boolean value. So for example, I don't know, like a boolean flag, like to say something started and has started. So Boolean, yes, so you int, addresses boolean, and apart from that, so you have strings.
00:30:25.226 - 00:31:17.552, Speaker A: We talked about it before, but it's a slightly more complex type. So strings installed, they are not very used because they are not really gas efficient and to manipulate them, we don't really have all the function we have in JavaScript or python. So in general we just avoid the string. Okay, it's mostly un and addresses really. Okay, so this is for the, for basically the simple, the simple variable, the I talk of the simple variable type. And now after we talk of the more advanced variable type. But first maybe, maybe that we can do a spot contract a little bit slightly more complex.
00:31:17.552 - 00:32:23.102, Speaker A: Okay, so let's do a calculator so that you can see the different operation we can do. So public data. Okay, so let's do an additional, actually let's, we don't even need this one. So let's do an addition uint, right? And then here what we're going to do is return a plus b. Okay, so you can do additions here. It's going to be pure, returns you int. Okay, so we can do additional, we can do subtraction here, we can do division, we can do multiplication and we can, okay, let's change the name.
00:32:23.102 - 00:33:24.510, Speaker A: So add, sub, divide, multiply, and we can do power as well. So for power, yeah, this one, right, so seems correct. So let's remove the previous, destroy the previous contract, click on deploy. Right. So let's check it. One, two equals three. All right, division, ten, five equal to, but if the division doesn't have, if the division, basically, if the result is a decimal number, you see that they're going to be some rounding.
00:33:24.510 - 00:34:08.960, Speaker A: So ten divided by four, for example. Yeah, it's two. It's. So that's why we have some issue with division in solidity. So we avoid to do any division that doesn't give you an integer as a result, if it gives you a decimal number, that, that's not good. So the way we do this is that we make, make sure that at the numerator we are dealing with really big numbers so that the division is always, always whole. Okay, so multiplication, two times two equal four, then power.
00:34:08.960 - 00:34:40.566, Speaker A: So two, power, two four as well. And sub ten minus two equal eight. Alright, so everything is working alright. Let me look at the chat a little bit. So what do we have here? So someone say, hey Julian, in 2020 I took the DAB 30 course from you. Now I'm in a middle developer. Amazing.
00:34:40.566 - 00:35:05.319, Speaker A: Thank you for bringing knowledge to the people. Awesome. Tarek Ahmed, I'm a software engineer working at a company which stock price went down 70%, on the verge of getting let off. Is it a good time to learn blockchain? Yeah. So we are in the middle. So make sucks for your company. But the good news is that right now we're at the middle of the bull market.
00:35:05.319 - 00:35:37.478, Speaker A: So if you see all the blockchain recruiters, they're really bullish, they have a lot of jobs. So, yeah, good time. Okay, so now we have our simple smart contract, but we know how to do arithmetic. So. So, so what are we going to do next? I want to show you some more advanced data structure. So let me see. No, first of all, I want to show you how to move money, okay? Because money is super important.
00:35:37.478 - 00:36:45.114, Speaker A: So, okay, let's say, let's say that we have a function here that we call this deposit, okay? We make it external and we make it payable. And payable means that now it's possible to send money to this function. And I'm going to show you how just after, and we can also, we can also restrain money. So withdraw you put what is the amount? So for example, you want to send it to who? Okay, you want to send it to this guy and I want this amount. Okay, it's. So what you're gonna do is, so here, address this. So basically this is how you target this smart contract.
00:36:45.114 - 00:37:18.478, Speaker A: And we also hear the notation to send ether is a bit ugly, but it is what it is. So call curly brackets, value. Here, amount. And then between parentheses and here, empty quote. Okay, what am I doing? No, no, Julian, that is not right. That is not right. You.
00:37:18.478 - 00:37:40.546, Speaker A: It's not hard work. Two, okay, two here, the recipient of the ether call. And then here it tells me it's not happy. And let me see. So we forgot something here. So we forgot to make it payable. Yeah.
00:37:40.546 - 00:38:04.410, Speaker A: So because you have two variable type insolidity, address and address payable. And to receive money, it actually has to be to be payable. So don't be confused here. This is the address payable keyword, address variable type. Sorry. And here is a payable keyword for the function. So this means two different things.
00:38:04.410 - 00:38:21.936, Speaker A: The first one means you can send money to this function. And second one means you can send money to this address. Okay? So let's try to use this. Let's deploy this contract. And here we can see this is a red function. Deposit. Red means you can send money.
00:38:21.936 - 00:38:52.958, Speaker A: So deposit. And it turns out with the address generated by remix, we have about 100 ether. Of course, this is not real. Ether, but we can send some of these ether. And here you can see the value field. So let's send one ether. Okay, so if we click on deploy now, we can see that the balance show you one ether and we can see the balance of our account that decreased by one ether.
00:38:52.958 - 00:39:39.284, Speaker A: But we can get it back if we click on withdraw. So let's click on here withdraw. And here we are going to specify how much ether we want to send. So here there is a confusion with the way ether is transferred on the blockchain. So when we talk of amount here, what do you think? If amount equal one, does it mean we send one ether? No, no, no, it means we send one wei. So Wei is a very, very small unit of ether. This is like a tiny fraction.
00:39:39.284 - 00:40:32.202, Speaker A: One ether is equal to ten power, ten power, 18 way. Okay, so that's one with many zero. So what we need to do, if we want to get, if we want to get our ether back, we just, we need much more than one way. Okay, so let's do 1234-5678 910 11 12 13, 14, 15, 16, 17, 18 okay, should be fine. So let's click on withdraw. And now the balance is zero. And we can see that our ether came back.
00:40:32.202 - 00:41:15.060, Speaker A: Okay, so we don't have exactly the same amount as in the beginning because we needed to pay for the transaction fee. But this is almost the same thing. Okay, so now you know how to manipulate ether. So to send ether to a smart contract and send it to another address. Okay, so after we are going to study the data type that are a little bit more complex because, you know, in any programming language we need to deal with collection of data. So we need container. We can put data inside.
00:41:15.060 - 00:42:00.660, Speaker A: So the first kind of container that we have is an array. So you int in here with a square bracket, specify this is an array. And for example, balances. And so that is an array. So how you manipulate this array? So we're going to see this, for example, add. Yeah. So the way you're going to add something to this array is bindsys print, push in, let's say here with element.
00:42:00.660 - 00:42:35.860, Speaker A: And we're going to push an element in the array like this. Right? It's not possible to push two different data types. So in JavaScript, for example, if you have an array, you do whatever you want. You can put an integer, the next element can be a string, whatever, it doesn't matter. Here in solidity, all the elements will have the same type. Now it's possible to read a value. So read value and you have to specify the index, okay.
00:42:35.860 - 00:43:05.964, Speaker A: And view return uint, okay. And return read. And between square brackets specify the sorry balances. Specify the index. And so the index start at zero. Okay, so here when you do push is going to be push this element index zero. Then if you call it a second time it's going to be one x programming language.
00:43:05.964 - 00:43:52.404, Speaker A: Okay, then we can do another function to update, right. So to update we gonna have value here. So balances I and here we're going to replace what we had before, okay, like this. And it's also possible to delete an element. So let me see, delete. So actually doesn't like this. Delete is a forbidden keyword so we need to find something else.
00:43:52.404 - 00:44:48.106, Speaker A: Let's say we want to delete this element and it's going to, let me see delete. It's basically going to reset it to its default value and yeah, so this is most of the operation you can do is an array. So let's test this deploy. Okay, so here let's add, I don't know, okay, ten. Now let's add 20. Okay, so now let's read the first one. The first one is ten, second one is 20.
00:44:48.106 - 00:45:06.210, Speaker A: Okay, it's working. Then let's update. So the first one is not going to be ten but it's going to be 100. Okay, so now let's read the first one. Now this is 100. All right, now let's try to delete the first one. So delete.
00:45:06.210 - 00:45:45.934, Speaker A: And now if we try to read the first one then it's reset to its default value which is zero. Okay, awesome. So now you know how to deal with arrays. Congrats. So next I'm going to show you another container that is very used and this is a mapping, right. But first of all pose water. Okay, so second type is mapping, so mapping.
00:45:45.934 - 00:47:06.252, Speaker A: And in the mapping this is basically like a key value store. So you know in JavaScript you have key value stores, something like this, right? Like my key, my value, my, my key to my, my value to etc. Right? So the equivalent here will be a mapping and first you specify the type of the key and then the type of, of the value. So one thing we can like a type of mapping we see a lot is balances. So the key will be an address and then the value will be a uint and we make it public and yeah, call this balances and yeah, so now how are you going to manipulate this mapping? So gonna see this function. And first of all let's, let's add something. So add an address balance.
00:47:06.252 - 00:48:46.314, Speaker A: Okay, now you do balances of address equal balance, right? And so what if you want to update an existing entry? Well this actually exactly the same function. So you will just call this, and basically it will overwrite whatever was initially in this, at this slot. That's it. Then we can read a mapping. So read, read this address and this time it's going to be viewed, returns a uint and we return the balances of this address. Okay, so, okay so and what else we can do, we can also remove an entry, so delete element and we can use the delete keyword. Alright, so now we have everything.
00:48:46.314 - 00:49:37.674, Speaker A: Let's delete the contract, let's deploy and let's play around. So first of all, let's add something. So, okay, let's select like another address here. First off, for the second, this address, I'm going to add ten for example, right? Then if I try to read, so I can read the entry for this address, I click on balances and I have ten. Now I can update this value. So if instead of ten I put 100, it's basically going to override what we had before. So now we click on balance and now we have 100.
00:49:37.674 - 00:50:11.990, Speaker A: And what if we delete this? Delete it. So now if we read it, it's going to be reset at its default value, which is zero. But there's something really strange. Let's say we want to read this, another address that we never set this address and we, so let's try to read this. No, sorry, balances and we can read it. It's zero. Even though we never initialize it, it doesn't give us any, any error.
00:50:11.990 - 00:51:11.862, Speaker A: And that's a big difference between this and an array. If you try to read a non existing value of an array, it will give you a mistake. But for mapping you can read any entry of any mapping, it always going to return you something which is the default value of the type, basically. All right, so now you know mapping and what else, what else we are going to do tonight? So let me see. All right, so now I want to show you modifier and access control. So basically oftentimes in smart contract you need to verify the access. So maybe someone want to do some action, but maybe they are not allowed to do it.
00:51:11.862 - 00:51:50.170, Speaker A: So we need to, to make sure that they are not going to steal money or something like this. So let's declare here a variable. We call this owner and we're going to use a special function I never mentioned before. This is called a constructor. So that's basically a function that is executed only once when you deploy the smart contract. So that's where you put the initialization code basically. And here in this owner, you are going to initialize it.
00:51:50.170 - 00:52:51.464, Speaker A: So there are a couple of built in keywords in solidity and one of them is MSG sender. Okay? So every time you have some solidity code, you can read this, this variable, this is populated automatically by solidity. So here, that means that whoever deployed this smart contract, this address going to be assigned to the owner. Okay, so now what we do with this owner? Well, let's say we have a sensitive function like, I don't know, withdraw money. Okay, withdraw and we can spot, specify, I don't know how much we want, for example, so external, let's say we restore to MHT sender, call value, amount. This is how you send money. I show you this before.
00:52:51.464 - 00:53:20.496, Speaker A: So this is how you would send money to yourself. And here let's make it payable. So this is how you transform a non payable address to a payable address. Okay, but if, if you do this, anybody can call this function. And this is a huge security vulnerability. And you know, for smart contract, security is really big deal. We need to make sure that our contract are secure.
00:53:20.496 - 00:54:04.532, Speaker A: So to prevent this, what we can do is we can use what's called a require statement. So yeah, there are different way to do access control, but that's the most simple way, require. And then you're going to put a test inside. So MSG sender, and we want the sender to be the owner. Okay, and if this is true, if this test is true, so here you can see that they are two equal, okay, this is not one, very different. One means assignment two equal test. And if this is true, the execution is just going to continue.
00:54:04.532 - 00:54:45.934, Speaker A: But otherwise, if it's not true, it's going to trigger an error and we're going to see it. So only owner, right? What's the problem here? Okay, it's fine. This is so here when you see something in orange, but it's not in red, it's just mean. This is a warning. So warning, you can still deploy your smart contract, but not if it's an error, which is red. Okay, so now let's try this deployment. So who is the owner? The owner, zero x five B, which is our address here.
00:54:45.934 - 00:55:23.288, Speaker A: Okay, so if we try to withdraw, for example, zero ether. So let's see if it works. Yeah, it works. But now if we try to withdraw zero ether, but from another address, let's see if this work? And no, it doesn't work. You have the error here. You can see the red icon, it tells you revert. The transaction has been reverted to the initial state.
00:55:23.288 - 00:56:23.632, Speaker A: So that means that any change that was made during this transaction, everything is canceled. Okay, so let's say that here you try to steal money, modify variable, etcetera, everything that you do before and everything you do after everything is cancelled. Okay, it's back to square one, back before to the state, before the transaction, remove all of this and it tells you the reason why, why we reverted. So it's because this is only owner, okay, so in here it matches our string. Okay, so you can see that this is, this is working. Alright, so let me check the chat a little bit. Do we have any question NASA? Hey, I'm a Java developer with five years of experience.
00:56:23.632 - 00:57:07.598, Speaker A: Will it be easy for me to switch to solidity and master it in a short time? Yeah, yeah, I mean it's, you don't need any prior experience in programming, but if you do that's even better. So yeah, absolutely. Billy, thanks for this class. Thanks man. Miguel, why don't you use two transfer? So that's because the transfer function was the old way of transferring money, but it has been depreciated because there was a security vulnerability. And the new way is to use the call function. So technically call, this is what we call a low level call.
00:57:07.598 - 00:57:52.886, Speaker A: This is actually quite old school. This call function was present since the beginning of solidity and then they tried to do a more recent version with transfer, but they figured out there was a bug in transfer. We, we went back to the old version. That's the story. Okay, so what else, what else we're going to do? I'm going to show you how we can create struct. So custom data structure basically. So let's say that we want to have an object and in this object we want to have custom field.
00:57:52.886 - 00:58:42.820, Speaker A: So for that we're going to use a struct and we can call it like we want, like user for example. And then we're going to give it a couple of fields. So user can have balance, for example, can have a name, I don't know, like join, add everything you want. And the way you're going to create this user, so create user, you're going to specify all its fields. So balance, name and uint. Actually no need for that. I'll show you another built in variable.
00:58:42.820 - 00:59:21.994, Speaker A: So here what we're going to do, and usually what we do is that this struct, we usually put them in mapping or in container at least. So let's say the key will be the address. Usually the way you track user on the blockchain is wizard dress. Okay. And here, what are you going to do? So create user. Actually we need its address. So users here its address and we're going to credit the user like this.
00:59:21.994 - 01:00:10.474, Speaker A: So balance name. And for join at, we can use a special variable called block timestamp that will give you the date at which the smart contract, the transaction was sent. So if you don't know what is a timestamp? That's basically an integer, looks something like this or like a big number. And that's the number of seconds since 1 January 1970, probably UTC some the green rich meridian. And you can see the current timestamp. So if you go to this website, it'll tell you, hey, timestamps this 156 and you can see that every second. It's, it's incremented.
01:00:10.474 - 01:01:00.364, Speaker A: So this is this number that you're going to have access to. Right. Create user. And then if you want to, to read a user, then it's also possible. So for example, get user and here address dress and external view returns. And we can, we can specify the different, basically we can specify we want a user memory, but that wasn't necessary because we already here, if the users, if this is public, we can already read from this. But I just want to show you another way.
01:01:00.364 - 01:01:35.744, Speaker A: All right, so we're fine. Let's redeploy. Boom, redeploy from here. And users. So we're going to create a user. Let's try to create a user for ourselves, for example. So create user this address, the balance, I don't know, maybe zero and name, Bob.
01:01:35.744 - 01:01:57.384, Speaker A: Right. So credit user now Getuser. So let's put our address, Getuser in here. It gives us the results. It's not super readable, but zero the balance. Bob the name and then the timestamp. So one seven, one something.
01:01:57.384 - 01:02:37.380, Speaker A: And that's basically, that's close to what we, that's close to the current timestamp. Okay, so now you know how to define a custom data structure. Okay, guys, so it was pretty much everything that I wanted to show you today. So that was a crash course. So, you know, I don't want to give you, we're not, we're not going to cover everything in solidity. You still have a lot of different things that you can do, but with what I showed you, you can already do a couple of things and. Yeah, so this is a good beginning.
01:02:37.380 - 01:03:33.850, Speaker A: So as I mentioned at the beginning, we have our solidity bootcamp that is starting next week. So in one month we're going to turn you into a solidity pro. So of course we're going to go much further compared to what we did today. We're going to cover advanced solidity testing yield, which is a low level dialect of solidity. We're going to cover security, we're going to cover gas optimization. And the last week we're going to teach you everything that you need to know if you want to create a token as a freelancer. So not the basic tutorial that you find on YouTube, but the complete sequence, absolutely everything you need to do, like customization of the token deployment, management of the private key, all the little detail that you need.
01:03:33.850 - 01:04:14.824, Speaker A: And so thanks to this module, you can then go on a website like upwork and find very easily your first freelance gig. And this is how you get your foot in the door. And once you have this first pet mission, the pet gig, then everything else becomes so much more simple. But you need to have this foot in the door. And so this is what we do in this bootcamp. So if you want to check out the program and register, I put the link in the chat. So the registration are going to close on Friday, so you have but one day and a half left if you want to register.
01:04:14.824 - 01:04:39.314, Speaker A: Okay guys, so let me see if we have any last question in the chat. So I don't see anything. Okay, so I hope that that was interesting. I hope you learned something today and I will see you next week on the channel. Alright, thanks everybody, have a good day. Bye.
