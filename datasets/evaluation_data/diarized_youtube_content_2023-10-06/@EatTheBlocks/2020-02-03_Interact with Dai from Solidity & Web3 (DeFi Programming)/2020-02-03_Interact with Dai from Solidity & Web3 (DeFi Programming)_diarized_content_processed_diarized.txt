00:00:00.250 - 00:00:36.646, Speaker A: If you are building a decentralized application, you probably need to accept some payment, and for that you need a currency. The problem with ether is that it's way too volatile. Fortunately we have an alternative with the DAi stablecoin. So Dai is a token on the Ethereum blockchain that always keep the same value. Here on this chart you can see that there are some small fluctuation, but these are quickly corrected it. However, the Dai ecosystem is quite complex, but you don't need to actually deep to dig into this. And there is an easy way to integrate Dai in your defi project.
00:00:36.646 - 00:01:18.574, Speaker A: So in this video I'm going to show you how you can transfer Dai from solidity and also from outside the blockchain using Webster. Hey, I'm Julian and on my channel idoblocks, I teach blockchain development and how to become a blockchain developer. There are different kind of people that interact with the Dai system. So first you have end users, so people like you and me who have die token and who want to do certain operation with the token. Then you have smart contract and defi projects, then you have what we call keepers, so they are there to ensure the stability of the token. And I'll explain this just after. And then you have MKR token holders.
00:01:18.574 - 00:02:02.046, Speaker A: So actually there are two tokens in the system of Dai. You have the Dai token itself and you have another token that is called MKR and that is here for governance. What is very important to understand is that the only people that really need a deep knowledge of the Dai ecosystem are the keeper and the owner of MKR tokens. If you are end user or you're building a DeFi project that interacts with DAi, you only need to understand how to interact with the Dai token. So this is a very simple representation of what happened when we create a new Dai token. So first you have a user that wants to create a new DAi token. So that user is going to send some ether to the die factory smart contract.
00:02:02.046 - 00:02:59.478, Speaker A: So the ether is going to be locked, and after that the die factory contract is going to create a token by calling the smart contract of the dai token. So that's another smart contract and his new die token will be sent to the user. The user has actually a debt in Dai at any time. The user can get back his collateral, but for that he has to give back the dai tokens at any time. If the value of the ether collateral falls below 150% of the value of die token that were created, then a process of liquidation is going to happen. So in this process of liquidation, the die debt of the user will be canceled, but the ether collateral is going to be sold to cover for the die token that were already created, and if there is any remainder, it's going to be sent back to the user. Because this is impossible to have smart contract auto execute in the future.
00:02:59.478 - 00:04:03.110, Speaker A: In order for this liquidation process to work, we need to have users who continuously monitor the value of ether and who activate a certain function in the Dai smart contract. This is the role of keepers, and for this to work we also need to have smart contract oracle on the blockchain who report the price of ether. Another important thing to note is that the liquidation process only affect people who created a dai position by creating a dai debt and sending some ether. But if you buy Dai, for example at some decentralized exchange, you don't have to worry about liquidation if you do some research about die. There is a caveat actually there are two versions of Dai, single collateral Dai, also referred to as v one sometime, and multicolateral die. So with single collateral die, the only collateral acceptable was ether. But with multicolateral Dai, any ethereum token can be used as a collateral as long as it has been approved by the community of Dai.
00:04:03.110 - 00:04:43.410, Speaker A: So the older dai token has been renamed to Psi and the new dai token is just called dai. Another change introduced by multilateral dai was that from now on there is something called the daily saving rate or DSR. So anybody who holds some dai is entitled to receive some interest. So be careful. Whenever you check some documentation or you check some info on ether scan, you want to use the latest version of Dai which is just referred as Dai, not PSi. So now let's focus on the die token. So this smart contract is responsible for managing the ownership of die token and also transfers.
00:04:43.410 - 00:05:15.670, Speaker A: This is an ERC 20 token, so it respect all the standard interface of YAS 20. If you don't know what is in Yas 20 token, check out this video. So here, this is the official documentation of the Dai token in the GitHub repo of Dai. So if you scroll down, so here it tells you the basic. Like for example here it's always pegged to $1. Let's scroll down. Then it gives you the addresses of the token on main net and also on the Covan testnet.
00:05:15.670 - 00:05:59.946, Speaker A: Then it also gives you a couple of info for the metadata of the token, the symbol, the name, and a number of decimals. I will explain the decimals after. Then you can have some info on you can have some statistics on the token here, so you can see Dai stats, for example, so you can see the total number of Dai size. So this is the old version of the Dai token. So let's scroll down and here he talk of the smart contract, and he mentioned this, seeing the DS token. So DS token is an implementation of ERC 20 that uses the DapSis framework. So Dapsis is a framework for solidity smart contract.
00:05:59.946 - 00:06:55.022, Speaker A: And if you keep scrolling down, they will give you some instruction to manipulate this DS token using this dappsys framework. So you will need to install the ClI of Dappsys framework in order to execute this. But I don't really recommend to spend too much time learning this framework because this is nowhere as popular as truffle and I don't find it so intuitive. So the most important thing to understand is that this token is a nest 20 token. So we can use any implementation of ERC 20 token, and it should allow us to represent this token as well. So in the coding section just after that, instead of using DS token and Dapsys, we're going to use the YAS 20 implementation of open ziplin. And for the spot contract framework, we're going to use truffle.
00:06:55.022 - 00:07:29.450, Speaker A: Next I'm going to show you how you can transfer Dai from solidity. So for that you will need to have install on your computer node js as well as NPM. So visit the website of node js. If you don't have it on your computer, you will also need to have installed truffle. So you can install truffle like this. This is the most used framework for three DT smart contract, and after that you can use the truffle Cli. So we're going to create a truffle project with the truffle in it command.
00:07:29.450 - 00:08:00.680, Speaker A: And then you should see all these files in your folder. So we're going to work mainly in the contracts folder. But first we need to install NPm dependency. So we need to use the ESC 20 contract of open Zeplink. So open Zeppelin is a library for solidity that has a lot of common token implementation. So to model the die token, we need the As 20. So we're going to install open Zeppelin like this.
00:08:00.680 - 00:08:26.942, Speaker A: Oops, I forgot to init the project with NPm first. So you should initiate it first like this. NPm y. All right, let me reinstall open Zeplink, and this time it's going to save it into package JSon. Yes. So we have it here. Okay, cool.
00:08:26.942 - 00:09:12.074, Speaker A: So next we're going to create a couple of smart contract inside the contract directory. So first we need to create a mock for the DAi token. So in programming a mock represents some other entity that usually we can access during development but we still need to interact with this entity. So for example we use mock a lot when we want to interact with some API. But when we are doing local development we can always hit this API. So here since we are working on a local development blockchain with truffle we can interact with the real smart contract of Dai on main net or even on a public testnet. So we need to mock this token locally.
00:09:12.074 - 00:09:56.326, Speaker A: So we're going to do this. So in contract we're going to create a smart contract that we're going to call die Sol. All right, so let's open this up. So here we going to create an ERC 20 token that will represent the die token. So we start with the usual pragmas statement of Solidity and after we need to import the ERc 20 token of open zeppelin. So let's have a look in the GitHub repo of open Zeplane because I don't remember by heart the token we need. So we'll go inside the contracts folder.
00:09:56.326 - 00:10:50.300, Speaker A: Then we have a token folder here then as 20 and the one we want is Es 20 detailed here. So it has some metadata about the token and it has a constructor where you have to give it the name, the symbol and the number of decimals of the token. Okay and the pass is this thing here. All right so let's copy paste this. So we need to import from open zepling then contract then you give it the full pass. We also need to import the base contract of ERC 20. So that's just ERC 20 like this.
00:10:50.300 - 00:11:40.930, Speaker A: Okay and then we're going to create our die token like this. So it's going to inerate from ES 20 and ES 20 detailed. And after that we're going to create a constructor and it's going to call the constructor of just 20 detail. So we need to provide the name, the symbol and a number of decimals. So how can we know what are the correct value? Well for that we're going to etherscan IO which is a famous blockchain explorer for Ethereum so that allow you to inspect some smart contract. And here we're going to search for the Dai token. So we type dai, dai stablecoin.
00:11:40.930 - 00:12:11.094, Speaker A: Okay so that should be this one, okay so let's scroll down and here you can find this menu here read contract. So let's click on that. And with read contract we can read some info from the smart contract. So we're going to find the name here. So the name is di stablecoin. So let's paste this. Then the symbol should be, oh yeah.
00:12:11.094 - 00:12:51.890, Speaker A: So we have the number of decimal here, 18. So that's the third argument here. And for the symbol here is Dai, uppercase. Okay, so Dai. All right, so with that we have our mock token. So now we need to deploy it in a migration folder. So migrations, and I'm going to call this deploy contracts sol here.
00:12:51.890 - 00:13:18.042, Speaker A: I never remember by hot what we need to put here. So I basically always copy paste from the initial migration that is provided by truffle. This contract is a contract used internally by truffle. So you can just ignore it, but the fact is you can just copy this and I call this file solve. It should be js. My bad. That's a typical mistake I sometimes do.
00:13:18.042 - 00:13:55.350, Speaker A: So let's rename, this should be JS. Okay, so now let's rename everything. So migration should be renamed to die token, just die. All right, so with this I'm going to try to deploy this. So in another terminal I'm going to launch truffle develop. Right, let's try it. Migrate reset just to make sure there is no mistake.
00:13:55.350 - 00:14:35.490, Speaker A: And yes, it's working. Okay, so now back to our code. So now I'm going to create another smart contract that's going to represent our defi project. So this Defi project smart contract is going to call the Dai contract to do some operation like transferring token. So let's create our smart contract and I'm going to call it my defi project saw. Okay, pragma so ut 0.5.0 contract.
00:14:35.490 - 00:15:15.250, Speaker A: My defi project. So first we're going to need to inject the address of die inside our contract. So for that we're going to do this in the constructor so address. And here it's going to be di address. And then we're going to store this address somehow. Store address but before. So we need to import the interface of yas 20 token.
00:15:15.250 - 00:15:53.760, Speaker A: So let's do this. Open ziplin contracts and then should be token and then I believe it's ERC 20 and then IRC 20. You know what, let's check on the repo of open ziplink. So ERC 20 and here IERC 20. Okay, so this is the correct pass. Let's copy this. Do I have the correct one contract token? Yes, this is correct.
00:15:53.760 - 00:16:44.830, Speaker A: Okay, so now in my constructor I'm going to create a pointer to the die token and we pass it the address like this. And we're going to store this into a state variable called die. So we're going to define this variable before. So the type of this variable is of the interface of Yas 20. All right. So with that, after the smart contract is deployed and we can use this dive variable to interact with our die smart contract. So for example, if we create another function foo.
00:16:44.830 - 00:17:34.270, Speaker A: And so in this function, foo, we're going to do some stuff, do some stuff. And after that at some point we want to do a transfer of die. So we're going to do something like this, for example, transfer. So we specified the address of the recipient and the amount, for example, MST sender. And here transfer 100 elementary unit of die. So here it's important to understand that this doesn't mean that we're going to transfer 100 die because die works exactly like ether. So it has 18 decimal.
00:17:34.270 - 00:18:25.966, Speaker A: So if you wanted to actually transfer a full die, then that means that that's one with 180 afters, 123123, et cetera. But otherwise, if you don't do this, if you just do like 100 like I did here, it's like 100 cents of dies. So that's a very, very small unit. So in any case, with this line here, we're going to transfer 100 cents of dies to the address that called alphu function. And if you want to do a delegated transfer, then we will use the transfer from function. So as specified in Yas 20 standard. All right, next we're going to deploy our smart contract and make sure that when we call the full function, the diet transfer actually work.
00:18:25.966 - 00:19:29.074, Speaker A: So we're going to go to our migration file and we're going to import our smart contract, my defi project. So when we deploy my defi project, we need to pass it the address of Dai. So that means we need to wait for Dai to be deployed. So here we're going to make this an async function so that we can use the await keyword. And here we're going to get a pointer to the deploy instance of die. And after that we're going to deploy our smart contract and pass the address of die so we can pass an argument to the constructor like this di address. Right.
00:19:29.074 - 00:20:06.618, Speaker A: So let's save this. So let's go back to our truffle console and make sure everything works fine. Okay. It's working fine. Next, we're going to get a pointer to our project, to our smart contract, my defi project. And after that we're going to call our foo function and see what's going to happen. Let's go back to traffic console migrate and boom, we have an arrow.
00:20:06.618 - 00:20:46.678, Speaker A: Oh no, what happened? The problem is that the sending address doesn't have any die token, so we need to give it some die before we execute all of this. And for that we need to use the concept of faucet. So if you use some public testnet before like Robston or Covan, you probably use this already. If not, basically a faucet is a way to get some free token. So since we are creating a mock for the dysmart contract, then we can very easily create a function for that. So go back to your die smart contract. You're going to create a function called fosset.
00:20:46.678 - 00:21:33.270, Speaker A: It's going to accept two arguments. First, the recipient of the token and then the amount of token that we want to create. And after that we're going to use the mint function provided by the ES 20 implementation of truffle that we inherit here. So we have access to this function, underscore mint. First it takes the recipient address and then the amount and it's going to create this amount of token for this address. Very simple. Actually, I like to revisit also the foo function for my defi project because I want it to be a bit more flexible.
00:21:33.270 - 00:22:26.886, Speaker A: So same thing here, recipient and amount. And we're just going to forward this to this function. Okay, and now we're going in the migration file. And before we call the foo function, first we're going to call the foset. So await diphoset. So the recipient should be the smart, my defy project smart contract and we want to create 100 token, okay, and after in the full function, so the recipient should be another address. So for example, the second address generated by ganache.
00:22:26.886 - 00:23:03.670, Speaker A: If you don't know what is ganache? It's a local development blockchain and that is what is used behind the hood by truffle. We're going to send 100 token to this address. Oh yeah, I forgot to mention. So actually I've added also these two arguments here to the callback. So network can ignore it, but accounts, this is the list of addresses generated by ganache. So we need it because here we reference it, okay, so we generate the faucet, we send it to our smart contract. Then we call the full function of the smart contract which is going to transfer 100 cents of die to this address.
00:23:03.670 - 00:23:46.840, Speaker A: And finally I like to check the die balance for both here the smart contract and this address to make sure that everything is correct. So let's do this balance equal. So here we execute the balance of function of the die token because this is an es 20 token. So we also have access to this function. So we want the balance of this address. And after we also want the balance of this address. The first one should be zero because it sent the token already and the second one should be 100.
00:23:46.840 - 00:24:31.598, Speaker A: Should be fine. So now let's go back to the truffle console. And yes, it has worked here we can see that first balance has zero and the second address has 100 die. Yeah, so all of this is cool, but we are just dealing with a mock die token on our local development blockchain. But how could we interact with the real die token on Mainnet, or at least on a public testnet? So I'll explain you the process for testnet and for Mainnet. This is almost exactly the same thing. So the die token is deployed on the Covan testnet.
00:24:31.598 - 00:25:12.794, Speaker A: So you cannot use umock die token. You have to use their version of the diet token which is already deployed. So I'm going to describe all the step you need to do. So first you're going to use the Covan faucet to get some covan ether to any address you want. So with this address you're going to get some Dai using the oasis interface of Makerdao. So basically you're going to send your Covan ether and they're going to send you some Covan Dai. Then in your migration script you're going to deploy your smart contracts.
00:25:12.794 - 00:26:00.890, Speaker A: So that's basically what I called my defi project in my example. So this time you will need the address of the Dai token already deployed on Covan. You can find this at this URL and that is regularly updated. Then you're going to send this smart contract, some die from the address that receive it. Before then you can execute the foo function of your smart contract and it's going to work. And of course you also have to modify your migration script for deploying to Covan. So that means probably using a service like inferra.
00:26:00.890 - 00:26:53.950, Speaker A: You also need to probably use the NPM dependency HD wallet provider to manage your private key inside your truffle config. And if you don't know how to do this, you can check out one of the link in the description point to a video where I explain this. So so far I showed you how to interact with the DAI token using solidity in a smart contract. But sometime we want to interact with DAi from outside the blockchain from the front end of a decentralized application using Webstree. So let's see an example of that. So I'm not going to create a full front end application to show you this, but I'm going to create a script file with the code for Webstery and after you can copy paste this web three code into your front end. So let's create this script script js.
00:26:53.950 - 00:28:01.480, Speaker A: So first you need to instantiate webstery, so it's going to be something like this new web three and then the link the URL to your organash instance. So often it's going to be localhost 95 45. Then once you have this you're going to get the list of addresses like this. Then you're going to get a web three contract instance. Here you'll pass the API after the address of the contract, and after that you'll be able to interact directly with the DAI token like this. For example, if you want to transfer some token, it's going to be die methods transfer. Then you're gonna pass the recipient the amount and here from address.
00:28:01.480 - 00:28:59.682, Speaker A: So of course in your code you need to replace the different variables like the ABI, the address recipient amount and from address. This way of interacting with the diet token is very low level and simple, but if you want to have more sophisticated interaction with the DAI ecosystem, actually I recommend to check out the official Javascript client of DAI. So that's an NPM package that is called Slash Dai. And so here you have a good documentation on the NPM homepage and with some example. But one thing that I found lacking is that here on the homepage they don't explain how to connect to a specific network. So actually you need to go to the wiki for that. Next in this series on DeFi programming, I'm going to show you how to interact with Uniswap, a decentralized exchange for ERC 20 token.
00:28:59.682 - 00:29:00.340, Speaker A: I'll see you there.
