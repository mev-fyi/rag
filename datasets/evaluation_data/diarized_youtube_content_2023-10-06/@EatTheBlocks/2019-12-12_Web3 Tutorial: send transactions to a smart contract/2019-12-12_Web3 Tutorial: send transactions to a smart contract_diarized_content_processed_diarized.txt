00:00:00.170 - 00:00:34.994, Speaker A: Hey, this is Julian and you are on idoblox. In this video I'm going to show you how you can send transaction with Webster. So if you haven't followed the previous videos of this series, here is a quick reminder of the two main APIs of Ethereum to interact with a smart contract. With the first API call you can read data from a smart contract, and with the second API transaction you can actually modify data in your smart contract. So it's the second API guy that we're going to study in this video. All right, let's see how it works with some code. So this is the same project that I've used in the previous videos of this series.
00:00:34.994 - 00:01:22.246, Speaker A: So this is a simple truffle project, and I have my smart contract here, mycontract Sol. So that's very simple. There is a single integer variable, a function to get the value of this variable and another function to change its value. So I'm going to open my script file where I instantiate web3, then instantiate a contract instance. If you don't understand this, watch the previous videos of this series, and after that we're going to send a transaction. So the syntax to send a transaction is very similar to when we want to call a readonly function. So we use our contract instance, then method, then we type the name of the function we want to call, so the set data function.
00:01:22.246 - 00:02:20.366, Speaker A: Then if there is any argument, then we pass it to this function. So for example, we want our variable integer variable to be equal to ten, and after that we don't use the call method, but this time we use the send method and then we can pass it an object to customize the transaction. So one very important parameter is the from address, because when we send a transaction we need to sign it. So here, actually we don't have any address in our code, so we're going to fix this. So just above let me get all the addresses of our wallets. So in this case this is going to be the ten unlocked account of ganache. But when you connect to metamask, this is going to be the addresses of the user web ease getaccounts.
00:02:20.366 - 00:02:57.326, Speaker A: So this is going to return an array of all our addresses. So let's take the first one, and after that you can pass some other parameter to your transaction object. For example, you can specify the gas limit. So just to be clear, this is the gas limit, but the name of the parameter is just gas. Next, you can also specify the gas price. In any case, be aware that even if you specify some value here, the user will still be able to override this value with his or her wallet. So generally I don't set gas price and gas.
00:02:57.326 - 00:03:29.870, Speaker A: And what Webster does is if you don't provide a value for this parameter, it's going to estimate the gas necessary to run your transaction and put it as a gas limit. So in most cases you don't have to put this value. But if you notice that your transaction run out of gas, then you can customize this. All right, let's close everything. By the way, there is still another parameter to send some ether in a transaction, but we will see this in the next video. All right, so this is going to return a promise. So we need to await it.
00:03:29.870 - 00:04:09.754, Speaker A: So it's going to mine the transaction on the blockchain. So because we are using our local development blockchain, the mining process is going to be immediate. But in a real case scenario on a public testnet or on a main net, you will need to wait for your transaction to be mined. And typically it will last about 15 seconds. So when we will reach the next line of execution, it doesn't mean that the transaction was actually mined. It just mean that the transaction was broadcasted to the ethereum blockchain. But at this stage it doesn't mean that the transaction is mined already.
00:04:09.754 - 00:05:00.910, Speaker A: As I said before, because we are using ganache for local development, then this is going to be immediate. So just after we can check the value of our data, and I'm going to prove to you that it has changed. So let's call the function get data, web3 eth, get data and let's console log this and we should see our new value. All right, so in my other terminal I'm going to start a ganache instance with the truffle Develop command and I'm going to deploy my smart contract with migrate reset. Oops, I actually forgot the await keyword here. Oops, there is another error. Here is contract method.
00:05:00.910 - 00:05:43.142, Speaker A: Get data. Okay, we can run our script and yes, we can see that now we have changed the value of the integer in the smart contract. So everything is working. All right. So next I'm going to show you what is a transaction receipt. So when you send a transaction to the blockchain, as I said before, it's not mined right away, but what you get instead is a receipt, which is a sort of confirmation that the transaction was received by the blockchain and is being processed. So this receipt, you get it when the promise of your transaction resolved.
00:05:43.142 - 00:06:34.518, Speaker A: So we're going to console, log this receipt and see what is inside. All right, so it's a big object, so let's go through it. So first you have the transaction hash. So that's an exodecima string that uniquely identify your transaction on the blockchain. For example, you can use this to build a link to a blockchain explorer like etherscan with the value of the transaction hash so that the end user can have a confirmation on ether scan that his transaction was mined. Then you have other information like the hash of the block in which the transaction was mined. Then some information about the block again, then the address that signed transaction, the recipient of this transaction.
00:06:34.518 - 00:07:20.810, Speaker A: So in our case it's the address of the smart contract. How much gas was used? This you can ignore it. Vrsds are parameters related to your signature, so in most cases you don't need to deal with them and events, they happen. If you use the event feature of solidity in smart contract, then you will see your event appearing here and we will see this later in this series on webstery. All right, so let's go back to our script. So what I show you so far is just one way to send transaction, but there are other ways. So instead of using the await keyword, then you could await the promise in another way.
00:07:20.810 - 00:08:14.220, Speaker A: So with the old way you basically use the then function and here you will receive a receipt and you do whatever you want with it. So here it's really important to understand that you need to put the rest of your code inside the then here if you put some code just after, then it doesn't mean that the promise will have resolved. So you can execute this and then right away the execution continue to this. But actually the transaction wasn't even acknowledged by the network. So it's really important to understand where to put your code in async operation like this. And it's also possible that your transaction fail because when it execute on the smart contract then solidity is going to throw an error or there are some other problem. So in this case you can catch the error like this.
00:08:14.220 - 00:09:07.926, Speaker A: So next, there are still other ways to execute a transaction. So so far we have used the promise based API of web3, but there is also the event emitter API. So in this case you do on and then the name of the event. So the equivalent of what we did before is on received and it's going to give you the receipt object and then you pass it a callback and then you do whatever you want inside. Then there is another event which is on confirmation. So this is going to give you two arguments to your callback. So the confirmation number and the receipt, and then you do whatever you want in your callback.
00:09:07.926 - 00:10:00.254, Speaker A: So if you don't know what is a transaction confirmation, that's basically the number of block that were mined on top of the block. Where is your transaction? So the more confirmation you have, the more sure you are that your transaction is going to be included in the blockchain. And actually I've done another video where I talk more in detail of transaction confirmation, so check it out if you're not clear on that. And finally, the last event which is useful is on error. And this is going to give you the error object and the receipt of the transaction. And there is still another way to execute transaction. So that's the callback way.
00:10:00.254 - 00:10:58.030, Speaker A: So with the callback way, basically you provide a callback function as a second argument to the send function and it's going to be given a receipt argument and then you do what you want with the receipt. So out of all these ways of executing transaction, my preferred way is using promises with the await keyword. But if you need to have more fine grained information about the transaction, then you might want to use the event emitter API by using the on confirmation event. By the way, if you want to easily memorize everything you need to know about Webster as blockchain developer I've prepared a short cheat sheet with all the relevant information. You can get it for free by following the link in the description. In the next video I'll show you how you can send ether to a smart contract or a regular ethereum addresses. If you have any question, ask them in the comments down below.
00:10:58.030 - 00:10:59.530, Speaker A: Thanks for watching, bye.
