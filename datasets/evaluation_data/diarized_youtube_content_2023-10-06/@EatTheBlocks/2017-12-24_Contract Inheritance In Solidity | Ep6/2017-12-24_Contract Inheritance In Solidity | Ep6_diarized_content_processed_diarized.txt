00:00:04.410 - 00:00:29.160, Speaker A: Hi guys, and welcome to the 6th episode of Edwox. Today we're going to study contract inheritance in the solidity programming language. So for those of you who already know some popular programming language, you probably know what is a class. So in solidity, we have contracts. Contracts are a little bit like classes. They can inherit from parent classes and access their method and variables. So let's see this in detail.
00:00:29.160 - 00:00:57.706, Speaker A: So first, jump to your console, and we're going to initialize a new truffle project. So if you follow the previous episode, you've already installed the Truffle global NPM package. So if that's not the case, then you need to install it like this. NPM install global truffle. Once this is done, you can use Truffle command line. So, truffle. And here the command we're going to use is the INIC command.
00:00:57.706 - 00:01:45.694, Speaker A: So I'm going to press enter and it's going to create a new folder in my project folder. So now if I ls this, I see that I have those three folders, contract migration test. I already talked about those in previous episodes, so have a look if you don't know, what are those? And then, so I'm going to clear my screen and I'm going to create a new contract. So, truffle create contract. And our contract will be my contract this time. So let's switch over to our text editor and let's open the solidity contract that we just created. So truffle created all this contract for me.
00:01:45.694 - 00:02:11.654, Speaker A: So first line, we have our pragma statement. Then line three, we have our contract statement with inside a constructor function. So we're going to get rid of this contraction function. We don't need it. So this, my contract here is going to be the contract that inherit from our base contract. So our base contract is another contract that we need to create. So let's do this.
00:02:11.654 - 00:02:53.058, Speaker A: So, contract, and we're going to call it my base contract. And it's going to be empty for the moment. So to tell solidity that my contract inherits from my base contract, we need to use the ease keyword. So here we're going to say my contract is my base contract. So mentally, you can replace, this is by inherit from. So it means my contract inherit from my base contract. That's what it means.
00:02:53.058 - 00:03:36.340, Speaker A: Okay, so now we're going to fill our mybase contract. So for this, I'm going to copy over what I've prepared before. So here have a variable and a function. So I'm going to copy everything. Okay, so first here, line four, we have this inner valve, which is basically an integer that I'm going to, which I'm going to assign the value 100. And the line below I have a function that I call inner add ten. And basically this function is going to receive an argument val and it's going to add ten to this argument and return it.
00:03:36.340 - 00:04:28.450, Speaker A: And here, line five, you note that I added the constant keyword to this function, which basically tells the three dt compiler that this function is not going to modify the blockchain, it's read only function. Okay, so we have those two things, the variable here and the function in my base contract. And now in my contract I want to access those. So how do you do this? So let's copy over those two function and let's copy them inside my contract. Okay, so the first function here, outer at ten. So basically what it does, it references my base contract that we inherit from. And it called the method inner at ten.
00:04:28.450 - 00:05:06.030, Speaker A: And it passed the val variable that we got as argument above. So it's basically as if we delegate the function call to our base contract. So with this function we're going to test how to call function from base contract. And with the second function here, get innervail. We're going to reference my base contract as we did before. But this time we're not going to call a function, but we're going to read directly a variable. So our variable is called inner val.
00:05:06.030 - 00:05:35.640, Speaker A: So if we scroll up and we look up in my base contract here, line four, we see that we can see this variable. So now let's switch back to our console. And what we're going to do is to create a migration file. So for this we can also use a truffle command. So we're going to type truffle migration, sorry, truffle create migration. And name of the migration is same name as my contract. So going to press enter.
00:05:35.640 - 00:06:14.894, Speaker A: Okay, so back to our text editor. And now we're going to access this new migration. So migration here is the migration of my contract that was just created. And since I don't remember exactly how to write a migration, I'm going to check the migration file that is already provided by truffle. When you use the truffle, any command. So I'm just going to copy paste this and use it here. So first line, we have artifact require migration.
00:06:14.894 - 00:06:56.402, Speaker A: Sol. So in our case it's going to be my contract, sol here the variable will be my contract. And here. So in this file we're going to export this function and we're going to deploy my contract here and not migration. So my contract, cool. So we wrote our three DT smart contract and we also wrote our migration file. So we are ready to start our local testnet and to call the method on our smart contract just before there is still a missing step.
00:06:56.402 - 00:07:45.010, Speaker A: So we need to compile our smart contract. So for this we're going to use the common truffle compile and it's going to create a build directory with some JSON file that represent our smart contracts. Okay, so I'm going to clear my screen and now I'm going to start the local testnet with the truffle develop command. So those who follow the previous episode must feel at ease with this command because it's pretty much the same thing as we did before. So we see the ten accounts that unlocked. We see that the local testnet was started at localhost port 95 45. And at the bottom of my screen I can see an interactive prompt.
00:07:45.010 - 00:08:29.310, Speaker A: So this is something created by truffle and this is very handy because it allow us to interact very easily with our smart contract. So after we run those commands we have our local testnet running. But still our smart contracts aren't deployed yet on our local testnet so we still need to run the command migrate. So let's do this. Okay, so our migration runs successfully. So now we're going to use a variable called my contract which has been injected by truffle directly. My contract represents our smart contract.
00:08:29.310 - 00:09:10.330, Speaker A: Okay. So we can see that if we inspect this variable that it's filled. So as in the previous episode, the first thing we need to do is to have a variable that points to our smart contract instance on our testnet. So for this we're going to define a first variable which is called inst. And once we have this variable we're going to use this my contract variable. Then we're going to call the deploy method and then it's going to return a promise. And then this promise is going to give us the instance and we're going to assign this instance to our inst variable.
00:09:10.330 - 00:09:53.498, Speaker A: Okay. And we're going to close the parentheses here. Okay, so now we can use our int variable. And on this int variable we can reference the method of our smart contract. So our first method was outer add ten. And on this method we're going to call this function. So call, and this function is going to take us argument, the argument that's going to be passed to outer at ten.
00:09:53.498 - 00:10:42.266, Speaker A: So in our case, let's just say that we want to pass 30 so we're expecting to have 40 and we're going to console log the result, okay. And we have been returned this big number thing and here in this big number object we can see that we have 40. So it has worked as expected. So we are able to call a function from a derived contract. We're able to call a method from our base contract. So we happy it's what we wanted. And now the second thing we're going to try is to call the second method of our derived class.
00:10:42.266 - 00:11:25.762, Speaker A: So the second method was, let's see, what was our second method. Get innerval okay, inst get inner val and I'm going to call this method but this time I don't need to pass any argument and once again I'm going to console log the result and we expecting 100. Let's see if it works. And it works. We have 100 here. Congratulations, you made it to the end of this episode. So today we studied what is contract inheritance in solidity.
00:11:25.762 - 00:11:57.306, Speaker A: So for this we define two contracts, a base contract and a derived contract. The derived contract inerrate from the base contract with the east keyword inside the derived contract. We define two method. One of this method call a method of the base contract and the other method access a variable of the base contract. We tested this on a local testnet and we got the result that we were expecting. Next episode we're going to study what is multiple inheritance. If you like this show, please subscribe.
00:11:57.306 - 00:12:00.666, Speaker A: Give me a like or share. See you next time. Bye.
