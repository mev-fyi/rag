00:00:00.410 - 00:00:31.480, Speaker A: Uniswap V three was just released. There are tons of new feature, including the socalled concentrated liquidity. Given the huge influence of Uniswap in the dFI ecosystem, as a blockchain developer, you have to understand this new version. In this video I will walk you through the code of the smart contracts of Uniswap V three. If you don't know me, I'm Julian and on the blocks I teach blockchain development. Quick note on the Academy of itoblocks, there will be a live training on Uniswap V three. More details on this at the end of this video.
00:00:35.370 - 00:01:17.134, Speaker B: So we're going to start in the GitHub repo of Uniswap and we're going to start with Uniswap V three course that's where you have the most important spot contract. So we go in the contracts folder and first we have the factory contract. That's the smart contract that creates the different liquidity pool. So let's scroll down. So it's a small smart contract, not too complex. And here the important function is create pool is when you want to create a new liquidity pool, you specify the address of the two token and the trading fee. So here we have a few sanity checks.
00:01:17.134 - 00:01:40.434, Speaker B: It requires that the two token are different. Then it's going to order the two token. So it doesn't matter if you specify first token a or token b. The order here is going to be the same. Another sanity check will make sure that we don't have the null address. Then here we have a calculation for the tick spacing. So this is related to the concept of concentrated liquidity.
00:01:40.434 - 00:02:25.286, Speaker B: So in Uniswap v three, when you provide liquidity, you have to specify a price range. And for this to work we need a parameter called the tick spacing. And after here, what's important is the call to this function, deploy. That's where we will deploy the liquidity pool to specify the address of the factory, the address of the two token, the trading fee and the tick spacing. And then we have the address of the pool and we save this in internal mapping. And at the end we emit an event. And after we have a couple of admin functions so you can set the owner and you can enable different pair of trading fee with the associated tick spacing.
00:02:25.286 - 00:03:15.530, Speaker B: And here what's interesting is the deploy function. So if we scroll up, we can see an import to uniswap v three pool deployer. So let's have a look at this pull deployer here and so that's where we're going to have the deploy function. And so inside this deploy function, we build a parameter struct with the different argument that we received. Then here, that's where we deploy the liquidity pool, and we pass a single parameter which is a hash of all the parameter. Okay, so that's for the creation of the liquidity pool, and after for the liquidity pool itself, this is uniswap v three pool. So in uniswap v two, this used to be called the pair smart contract.
00:03:15.530 - 00:03:57.234, Speaker B: All right, so let's scroll down. So here we can see we have a lot of import, and we can see this is a huge file, I think it has almost 1000 lines. So yeah, it's more complicated compared to the per smart contract of v two. So our smart contract start here. So here, what's important are these state variable here. So the address of the factory contract, the address of the two token, the trading fee, and all of these are immutable, so we cannot change them after the initial instantiation. Also have the tick spacing for the concentrated liquidity, max liquidity per tick.
00:03:57.234 - 00:04:34.318, Speaker B: So let's scroll down, scroll down. So there is really a lot of code in the smart contracts. We're not going to see everything, we're only going to focus on the most important thing. So here in the constructor, we are going to instantiate a couple of variables. It's quite interesting because we don't pass this value as argument of the constructor, but we actually call the factory contract that just deployed this smart contract, and we call the parameters function. So I'm not sure why we're doing it like this. Maybe this is a gas optimization.
00:04:34.318 - 00:05:10.714, Speaker B: And then we calculate another parameter for the concentrated liquidity. So max liquidity per tick. So after that, let's keep scrolling down. So here I have two function to check the token balance of the contract. So the reason why it's so complicated is because there is a gas optimization. So this function seems a bit complex, we're going to skip it, this one as well, initialize. So I'm guessing we have to call this function after we deploy the liquidity pool.
00:05:10.714 - 00:05:43.050, Speaker B: And when you see name like this, like x 96, it probably mean you have to provide a number in a stone format. So here you can see is uint 160, the default is uint 256. It's probably somewhere in the documentation of Unisoft that explain what is the format of this number. But apart from this, I have to admit I don't know what is this parameter unfortunately. Let's keep scrolling down. Let's see if we can find something interesting. Keep scrolling down.
00:05:43.050 - 00:06:22.118, Speaker B: Okay, so, mint, so this is a function that is used when you want to provide liquidity to uniswap. So you provide the address of the recipients. That means you can create a position for another address than yourself. Then you have to specify the two limit of your price range. For example, if you want to provide liquidity on the pool ether die, you could say, okay, the lower tick is going to be $1,500 and the higher tick will be $2,500. So that means you only earn the trading fees while it's trading within this range. And you can readjust these two value.
00:06:22.118 - 00:06:57.460, Speaker B: After you initially mint your position, you also have to specify the amount of your position and you can also pass some arbitrary data. So here we check that the amount is zero. And after we calculate the two amount of token that you need to provide here for this function. Modify position. So I believe it's where it actually creates your position. And your position is going to be represented by ERC 721 token. So after we're going to check this function, because I think this is interesting.
00:06:57.460 - 00:07:29.866, Speaker B: And after here, what's interesting is that we are calling back the address that called a mint function. So we are expecting this function on this address and we pass it the amount of token of the two token plus the arbitrary data argument. And after a few sanity check and we emit an event. And at this point your position was created. So here what's interesting is the modify position function. Modify position. Okay, line 306.
00:07:29.866 - 00:08:20.262, Speaker B: Apparently it's the same function that is used to create a position and to modify it. So it's here that we actually create the position update position. And here, depending if the current price is within the range that was given, the calculation for the amount of token you need to provide is different. So here, if the current tick is below the pass range, we have one way to calculate amount zero. Otherwise, if the current tick is inside the pass range, there are other way to calculate this two amount. And if the current price is above the range that we pass, this is still another calculation. So the point of this function is to create your position and also calculate this amount zero and amount one that you will need to provide.
00:08:20.262 - 00:08:46.546, Speaker B: Okay, so let's go back to the mint function. That's where we were initially. All right, and then let's keep going. We have the collect function here. I don't know what it does. This is an external function, so it's called directly by other smart contract and burn. So this is when you want to withdraw your liquidity.
00:08:46.546 - 00:09:29.780, Speaker B: You specify what's the price range that you want to withdraw from and the amount. And here, interestingly we also use the modify position function, but this time what will be different is the liquidity delta. So it will be negative. So it's how the modify position function will know that this time we want to withdraw liquidity. And after we emit a burn event and that's it, we have withdrawn our liquidity. After, what do we have? Okay, so two struck that I probably use when we want to do a swap of token. Another struck here use for the swap, I guess.
00:09:29.780 - 00:10:11.182, Speaker B: Then we have the swap function, so that is used when we want to trade. For example, you have some ether and you want to sell them against some dai. So you specify the recipients once again you can initiate a swap for another address for the recipient. This boolean parameter, I don't know what it is used for, the amount specifies, so I don't know if this is the amount in input or output. And this is probably square root price limit. So you can also specify a price limit, but you specify the square root of it. And also you can have some arbitrary data first it does some sanity check here.
00:10:11.182 - 00:10:38.994, Speaker B: And after it initiates this swap cache struct. And after here we specify this another struct swap state. And I think this is used to progressively fill your order. So here we can see amount specified remaining. So there's probably an algorithm that runs and progressively fill your order. And we keep track of this here and here. Yes, so we can see we have a while loop.
00:10:38.994 - 00:11:21.318, Speaker B: So we are going to iterate until we fill your order completely. So it's a little bit similar to what we have for order book. And so we're going to keep iterating while we still have some amount to swap. So here there is a lot of math we don't need to understand everything but just the high level height work. And so for each tick we are going to compute how much token we can swap, including what's the fee. And after we are going to update the swap state struct. So here we can see the amount specified remaining will go down at each step.
00:11:21.318 - 00:11:57.554, Speaker B: Here we also update the fee part of the swap state. So let's keep going down. Okay, so after it gets even more complicated, but from what I understand is when we are going to go to the next tick. So let's keep going down. Apparently we also write to an oracle smart contract for every iteration of the while loop. Let's keep going down, keep going down. And here we have something very important.
00:11:57.554 - 00:12:47.806, Speaker B: So we actually do the token transfer at this line or this one, depending where you are in the if branch. And here you call a callback function on the sender with the amount that were traded and also the arbitrary data that was passed. Wow, that was pretty intense. This is not an easy function, so I wish I could have explained a little bit better, but I hope you get the gift of it. We have the flash function, so I'm guessing this is the function to do flash loan basically, and it's a little bit less complex than the previous swap function. And here function to change the fee. And this can only be called by the factory smart contract.
00:12:47.806 - 00:13:25.610, Speaker B: And then the collect protocol function. So this is probably to collect the trading fee that are paid to the Uniswap protocol itself. And here you can see we have some token transfer going on. All right, so that was pretty intense. But I show you really the main smart contract of uniswap v three core. So factory, the deployer that is actually imported in the factory contract and then the pool smart contract. And another repo that is important is uniswap v three periphery.
00:13:25.610 - 00:13:55.670, Speaker B: Let's provide some utility smart contract that I use to easily interact with the core smart contract. So if you use Uniswap v two before, you probably remember that we also had this concept of the periphery smart contract for v two. So let's go in the contracts folder. And here let's go to swap router. So when you want to do some trade, you will call this function. Okay, so contract router. So we have a lot of inheritance here.
00:13:55.670 - 00:14:21.200, Speaker B: Let's scroll down. Okay, so here uniswap v three swap callback. So if you remember in the swap function of the call contract, at some point we call this callback. So once the swap is finished, we go here. And what's interesting to note here is this pay function. So that's where this smart contract is going to forward the output token. Okay, so let's keep scrolling down.
00:14:21.200 - 00:14:58.550, Speaker B: Exact input internal, but this is private function so we don't call it from outside. Let's keep going down. And here, exact input single and this one is external. So when you want to swap a token against another one, then you're going to call this function and you need to provide this struct, exact input single param. So I don't think this is defined in this smart contract. Think this is in one of the import, but you can see the parameter of this struct here. So specify the amount in the recipient address, the price limit.
00:14:58.550 - 00:15:23.794, Speaker B: We specify the address of the two token that we want to trade token in, token out. And I don't know why we have to specify a fee. I thought that this fee was predetermined. And we also have the address of the sender of the transaction. And so when we call exact input internal, that's where we're going to do the swap. So exact input internal. Let's go up.
00:15:23.794 - 00:16:05.310, Speaker B: Yeah, that's where everything happened. Okay, so here is some sanity check. And first we get the address of the liquidity pool based on the two token and based on the fee. So it seems like in uniswap v three, a pool is defined not only by the two token, but also by the level of fee. And so after we have our pointer to the liquidity pool smart contract, and we call the swap function and we pass it all the different parameter, and after that the swap is done. And let's keep scrolling down. And we have another function that we can call from the outside of the smart contract, exact input.
00:16:05.310 - 00:16:42.762, Speaker B: So it's probably, if you want to specify a trading pass with multiple token. So here we have a while loop. It's probably for swaps that are more complex with several liquidity pool. And after, let's keep scrolling down exact output. So here it's if you're going to do a swap, but in this case you want to specify exactly the amount of token that you're going to get as output. So in uniswap V two, we already had something similar. Okay, so that's for the main smart contract in the periphery.
00:16:42.762 - 00:17:17.346, Speaker B: So let's see the others migrators. So this is to migrate liquidity from v two to v three. And here the most interesting is probably non fungible position manager. So let's go there. And this probably allow you to provide liquidity to uniswap V three. So here we can see a reference to EF 721. So that's because a position is represented as an ER 721 in uniswap V three because you have to specify your price range.
00:17:17.346 - 00:17:43.220, Speaker B: So that makes the position quite unique. And so here we have a struct to represent a position and it includes your price range here. All right, so let's keep scrolling down. So here we have a function called positions. And you specify your token id of your position. It basically allow you to get data about your position. This is a view function.
00:17:43.220 - 00:18:13.290, Speaker B: Okay, so let's keep scrolling down. And mint. So this is to add liquidity to uniswap v three. So you have to pass a min param struct here. And here we are going to call the add liquidity function and underscore mint. Okay, so we're going to need to do some research. What are these two function and after you're going to update an internal mapping.
00:18:13.290 - 00:18:47.142, Speaker B: Okay, so let's keep scrolling down. Where do we have add liquidity? Let's keep scrolling down. Okay, so we had underscore mint. Okay, it's probably in one of the imports. And how about add liquidity and let's go in the import, try to see if we can see this library. Base liquidity management. I have a feeling that we need to go there.
00:18:47.142 - 00:19:07.226, Speaker B: So let's do this. Base liquidity management. Let me see. Okay, so first of all, we have a callback function here. So if you remember when we called the min function on the liquidity pool contract, at some point we call back this function. So this is going to be called. Oh yes.
00:19:07.226 - 00:19:36.006, Speaker B: And so add liquidity is here. So here we get a reference to the liquidity pool of our token. And let's scroll down. And here we are going to call the mint function and we pass the different parameter. Okay, so we cover the most important contracts in the periphery. So now let's keep checking out the other repo of uniswap for uniswap v three. So we have uniswap v.
00:19:36.006 - 00:20:02.234, Speaker B: Three SDK. This is a typescript Javascript library to interact with the Uniswap v three protocol. Then we have another repo. So that's the subgraph for uniswap v. Three. So if you want to easily read data from Uniswap and you don't want to bother with solidity, it can be useful to invest your time in this. Then we have uniswap v three info.
00:20:02.234 - 00:20:39.026, Speaker B: So that's a website that gives you some data analytics about uniswap V three. We already had the same thing for uniswap v. Two and we have uniswap v. Three, core optimism. So that's the same as the core smart contract, but that was modified to be deployed on the optimism l two chain and we'll also have the same thing for the periphery contract. So I check it in the contracts folder and I didn't see much difference with the periphery for ethereum l one. So I don't know what's really different for optimism.
00:20:39.026 - 00:20:48.570, Speaker B: And finally, last report I wanted to show you is a Uniswap V three staker and it allow you to create a liquidity mining program using Uniswap V three.
00:20:48.720 - 00:21:00.414, Speaker A: What have we learned from this code walkthrough? Clearly, the code of Uniswap v three is more complex than V two because of the new system called concentrated liquidity. The math and the algorithm are more.
00:21:00.452 - 00:21:02.222, Speaker B: Complex, but here is the key.
00:21:02.276 - 00:21:31.286, Speaker A: You don't need to understand in details how it works inside. As a blockchain developer, you need mostly to interact with Uniswap. Next week on June 6 on the Edoblock academy, we will have a live training on Uniswap V three. We will teach you how you can interact with Uniswap v three. This will be done by Nilu Ravi, a very experienced blockchain developer who has already created many courses. If you want to book your seat for this training, there is a link in the description and even after the date of the live event, you can.
00:21:31.308 - 00:21:32.806, Speaker B: Still take the course because there will.
00:21:32.828 - 00:21:37.570, Speaker A: Be a recording uploaded. That's it for today. I will see you for the live training on Uniswap. Bye.
