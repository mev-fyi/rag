00:00:00.330 - 00:00:42.122, Speaker A: Uniswap is exploding. Its trading volume is growing exponentially and it's already larger than a couple of big centralized exchanges. So if you are a blockchain developer, you need to become familiar with Uniswap. So in this video I will explain what is Uniswap, how it works and how to interact with it in JavaScript using the Uniswap K, and also how to interact with Uniswap from a spot contract using solidity. And I will focus on Uniswap V two, the latest version. So this video is up to date. If you don't know me, I'm Julian and on my channel eatoblocks, I teach blockchain development and how to find your first blockchain job.
00:00:42.122 - 00:01:19.298, Speaker A: And before we continue, quick announcement. I'm working on a new course on advanced solidity. So that's a great way to specialize yourself and stand out from other blockchain developers. If you want to get informed when it comes out and receive some exclusive preview, register with the link down below. So what is Uniswap and how does it work? So Uniswap is a decentralized exchange for Es 20 tokens. You can buy and sell ES 20 tokens in a decentralized way using a smart contract on Ethereum. This is not the first decentralized exchange.
00:01:19.298 - 00:02:00.686, Speaker A: And what is different with Uniswap is that under the hood it uses a liquidity pool. So that means you don't trade directly with any specific trader, but instead you go through this sort of intermediary concept of the liquidity pool. And that's a mechanism that significantly improved the liquidity of the exchange. So we're going to see the different smart contract of Uniswap. So first we have the factory. So the role of the factory is to create the different market of Uniswap and act as a registry for all these different markets. Each market is represented by another smart contract that we call the pair smart contract.
00:02:00.686 - 00:02:34.186, Speaker A: And so in each pair you have two tokens, for example dai and wrap ether, or USDC and wrap ether. Then you have the router smart contract, which is a utility that help you to use Uniswap in a most simple way. And finally, there are all the different Es 20 smart contract that are manipulated by Uniswap. But these aren't strictly part of Uniswap. Uniswap just interact with all these tokens. So now we're going to see how the smart contract interact with each other. So first, as I said before, the factory can create different pair smart contract.
00:02:34.186 - 00:02:37.722, Speaker A: So we can have pair smart contract with any combination.
00:02:37.786 - 00:02:39.614, Speaker B: So it can be two token, like.
00:02:39.652 - 00:02:53.026, Speaker A: For example at an SNX, or it can be a token and wrap ether. So if you never heard of wrap ether, that is basically an ERC 20 token version of ether. So that's a token where inside that.
00:02:53.048 - 00:02:54.142, Speaker B: Is backed by ether.
00:02:54.206 - 00:03:20.954, Speaker A: So one wrap ether token equal one ether. So in Uniswap V one, we were able to create some market with ether, but in V two we can only create pair. With wrap ether, anybody can create a new pair. This is a permissionless system. All you have to do is to call the factory spot contract with the correct parameter. So next, I'm going to explain how we can interact with a pair spot contract. So one kind of actor is called a liquidity provider.
00:03:20.954 - 00:04:16.154, Speaker A: So a liquidity provider can be anybody who has some tokens and who want to act as a market maker for a specific market. So as a liquidity provider, you will send a combination of the two token of the pair. So for example, if the pair is dai and wrap ether, so you will send the same value of dai and wrap ether to the smart contract. And in exchange you get what is called a liquidity provider token. And at any time in the future, you can redeem your liquidity provider token against the dai and wrap ether token that you initially provided. Plus you're also going to get the trading fee that were earned by the spare spot contract in the meantime. So next, if you are a trader and you want to buy some wrap ether with this pair spot contract, what you're going to do is you're going to send some wrap ether to the spot contract of the pair plus the trading fee.
00:04:16.154 - 00:05:02.406, Speaker A: And in exchange you're going to get the dai tokens. So it can be a bit tricky to interact directly with a pair smart contract. So that's why the team of Uniswap created another smart contract called a router, that can be used as a convenience in order to interact with the pair contract. So if you are building your own system around Uniswap, it's recommended that you use the router spot contract instead of directly interfacing with pair contracts. But in some rare cases, if you really need more flexibility, that's when you would directly interact with the pair contract. Another advantage of using a router contract is that you can have some complex trading. For example, let's say that we have two pairs, so Daiwap ether and USDC wrap ether.
00:05:02.406 - 00:05:44.042, Speaker A: But what we want to do is to trade between DAI and USDC. But in the system you can see that we don't have this market. Well, we can specify a route to the router smart contract. So in the route we will first use the Daiwap ether pair and then the USDC wrap ether pair. And so that way we can synthetically create the Dai USDC market. And another advantage of using the router is that you can use ether in order to trade on Uniswap, and the router will automatically convert back and forth between ether and wrap ether. Otherwise, if you trade directly with the pair, you have to take care of yourself of wrapping your ether into a wrap ether token first.
00:05:44.042 - 00:06:27.926, Speaker A: Okay, so that's it for the high level overview of Uniswap. Next I'm going to show you how you can use javascript to interact with the Uniswap smart contract using the Uniswap SDK. So in this section I'm going to show you how you can interact with Uniswap with JavaScript using the Uniswap SDK, which is a JavaScript library created by Uniswap. So this is what we call an isomorphic library. That means you can use it on the front end in web browser or on the back end with node JS. So there is one thing a little bit confusing, even though this is for Uniswap V two. Actually the version of the library is Uniswap SDK V three.
00:06:27.926 - 00:07:01.570, Speaker A: So I'm going to show you how you can use it from node JS, but it's very similar if you want to use it from the front end. So here I am in my terminal, I'm going to initiate an NPM project like this, and after I'm going to install the Uniswap SDK like this at Uniswap SDK. So now if you check out what we have in package JSON and in dependency, we have Uniswap SDK here.
00:07:01.640 - 00:07:54.206, Speaker B: All right, so create a file. So we need to import a couple of stuff from Uniswap. So first we're going to import the chain id to identify which blockchain we want to interact with, and then an object called the fetcher. I'm going to show you how it works after and require this from Uniswap SDK. So for the front end you need to change the syntax with import from as you would do with any es six module. So next we're going to define the chain id. We're going to select main net and after for the token address we're going to take the address of DAi.
00:07:54.206 - 00:08:48.854, Speaker B: So I already copy pasted it from ether scan. And after I'm going to create a pointer to the DAi token. So for this you need to use the await keyword. And by the way, if we use the await keyword we need to wrap everything into a function, otherwise node JS is not going to be super happy. All right, now with the fetcher object, we're going to fetch the token data and we specify the chain id and the token address. And now with this object we can represent the DAi token in Uniswap. There is another way to initialize token object without using this fetcher object, but this is a little bit more verbal, so I prefer this way.
00:08:48.854 - 00:09:24.830, Speaker B: Also by default when you use this notation here, it's going to use the default provider defined by etherjs. So in other terms it's going to connect to mainnet, but you can change this by passing it a ether JS provider. So next we're going to create a pair object. Pair object allows to interact with a specific market. So with a specific market we're going to need two tokens. So we have die already. And for the other one we're going to choose wrap ether.
00:09:24.830 - 00:10:06.682, Speaker B: So we can actually get this from the Uniswap SDK here. So let's do it. And after we need to select the right network. So wrap ether of genid. And after we're going to define a pair object like this. Once again we're going to use the fetcher object, fetch pair data, and we give it the two token we want die and wrap ether. So here the order doesn't have any importance.
00:10:06.682 - 00:10:41.190, Speaker B: Could be wrap ether, die or die wrap ether. This is the same pair, and close this. And now we can interact with this pair. So like before it's also possible to instantiate this pair object in a more manual way without using fetcher, but this is a little bit more of a bose, so I prefer this way. And next we're going to create a rot object. And with this rot object we'll finally be able to do something interesting. We create a new route object like this new route.
00:10:41.190 - 00:11:24.600, Speaker B: By the way, I have to import it here and we're going to pass an array with the different pair that we want to use in our route. So in our case we just want to use a single pair. But if you want to access markets that don't directly exist, like I explained in the previous section, then you will pass several elements in this array. And after you will put here the input token. So for us that's going to be wrap ether. So now we're going to be able to get the mid price. So console log route mid price.
00:11:24.600 - 00:12:12.022, Speaker B: So this is going to return a tokenoman object. So this is a custom object created by Uniswap, but under the hood it uses JSBI, which is Javascript library to manipulate big number. And so one method we can use is two significant this is going to transform this into an actual number we can represent. Actually this is going to be a string to be exact. So we want six significant digit rate in, we're going to get the number of diet token that we can get with one wrap ether. But if you want the opposite price, what you can do is use the invert method here. All right, and I just realized there is a typo here.
00:12:12.022 - 00:12:47.198, Speaker B: Let me remove the d. All right, save this and let's try to run this. It cannot find this module. Okay, so let's try to fix this by installing NPM install ethers. So this is probably a peer dependency that I had to install. All right, so now node index and this time is it going to work? Yes. Currently for one ether we can get 411 die.
00:12:47.198 - 00:13:00.360, Speaker B: And here we have the invert price. So this is working well. So the missing instruction in the documentation of Uniswap SDK was that I had to install ether like this.
00:13:00.970 - 00:13:24.286, Speaker A: Okay, so we're going to return to our script. And so the price I show you here is the mid price. So that's a theoretical price that you will actually never get if you buy or if you sell the token, what you'll actually get is the execution price. So to get this execution price we need something else. So to get this execution price we.
00:13:24.308 - 00:13:26.250, Speaker B: Need to build a trade.
00:13:26.330 - 00:13:28.094, Speaker A: And for that, first we need to.
00:13:28.132 - 00:13:34.194, Speaker B: Import a few extra stuff. So first import a trade object, a.
00:13:34.232 - 00:13:38.050, Speaker A: Token amount and a trade type.
00:13:38.200 - 00:14:21.758, Speaker B: Okay, now after here we're going to create this trade, new trade. We going to pass it the route we defined before. And we need to specify a token amount that we want to trade. So here first we pass a pointer to the token. So wrap token and let's say that we want to provide 100 ether in input. So we specify this here as a string, so 100 and then we need 15. 012-34-5678 910 1112 13 1415.
00:14:21.758 - 00:15:19.282, Speaker B: Okay, then we specify the trade type exact input. So that means that we provide exactly this amount in input and we want to get as much possible die as output. That's probably the trade type that you're going to use the most often. And so after we're going to console log trade execution price to significant, we can also print the next mid price after this trade. So just to be clear here, we're not actually sending any transaction to the Ethereum blockchain. We're just asking Uniswap. Hey, Uniswap, if I trade this amount of token, what would be the execution price and what would be the next mid price? That's it.
00:15:19.282 - 00:15:51.542, Speaker B: I think we have a problem of parentheses here. We are missing apprentices here. Okay, so let's save this, let's run the script. And we can see that the execution price will be slightly worse than the mid price. And also after the trade, the mid price is going down. So that's normal. So next, how can we actually send this transaction to the Ethereum blockchain? So for that, we're going to have a look at the solidity code of the router contract of Uniswap.
00:15:51.542 - 00:16:26.294, Speaker B: And we need to provide a couple of arguments. So first we need to provide the minimum amount of output token that we want. Then an array of the addresses for the different token we're going to go through. So in our case it's going to be wrap ether and die, then the recipient address, and finally the deadline, after which the trade order is not valid anymore. So we are going to prepare all these parameters. So let's go back to our script. So first we're going to import another object from Uniswap that's called person.
00:16:26.294 - 00:17:05.006, Speaker B: That's going to allow us to define a tolerance for our trade that's going to be useful for specifying how much tokens we want in output. So let's define this parameter here. Sleep h to lay runs. So let's say that our tolerance is half a percent. So that means compared to the price, the execution price we got from the trade, we are willing to tolerate a price that is up to 0.5% worst. So we express this like this, 50 and here 10,000.
00:17:05.006 - 00:17:32.400, Speaker B: So this is going to be 50 bips. So bips is a unit that is commonly used in finance. One bip equal 0.1%. So 50 bip, that's basically zero point 50. So that's 0.5%. You can also specify percent directly if you want. Like if you wanted to do 1%, then you would specify like this.
00:17:32.400 - 00:18:17.930, Speaker B: But here, since we want to do less than 1%, then we need to have a bigger number here. So now we can define the minimum amount as output and we can use the trade object that we built before. So minimum amount out and we pass our sleepage tolerance and this is going to give us a token amount, but this is not the format that we want. We want the raw format, that's going to be a string. Next we need to specify the path of the trait. That's going to be an array of addresses. So first the address of wrap ether and then the address of die.
00:18:17.930 - 00:18:49.158, Speaker B: So then the address of the recipient. That should be checksum. Then we need the deadline. So this is a timestamp in second. So we divide this by 1000 because date now give us a timestamp but in millisecond. And after that we're going to add for example 20 minutes. But it's up to you here to define what's your tolerance here.
00:18:49.158 - 00:19:22.454, Speaker B: Basically the longer you wait, the more the market will move in a certain direction and the more the price that you specify might be wrong. So it becomes more risky. And after we're going to specify how much ether we are willing to send. So that's going to be trade, input, amount, row. And now we need to create this transaction. So the Uniswap SDK only allow you to read data from Uniswap but not to send transactions. So we're going to need another library and we're going to use ethers.
00:19:22.454 - 00:20:03.626, Speaker B: So we've already installed ethers before so we can require it directly. And then below we're going to create an ethers provider. So that represents a connection to the Ethereum blockchain get default provider. So we specify we want Mainnet. Then we're going to specify the connection string on Inferra. So we're not going to run an Ethereum node ourself, that's too difficult. We're going to use the Inferra service.
00:20:03.626 - 00:20:42.842, Speaker B: So you go to the website of Inferra, you create a free account. You log in after you go to your Ethereum dashboard and you click on create new project. So I've already reached the maximum for free account, but after you will see your project appearing here. So you click on it and in settings then you will take the HTTPs URL. You make sure you are on main net. Then you specify your URL here. After you're going to create a signer object, new ethers wallet with an uppercase w.
00:20:42.842 - 00:21:31.814, Speaker B: And so here you're going to specify your private key and after you're going to connect the provider to the signer like this. So with this you'll be able to send a transaction. And after you need to build an object that represents the smart contract of Uniswap ethers contract with an uppercase C. And after you're going to need the address and the AbI of the router. Smart contract. So for that you go to the website of Uniswap, you go to the doc, click on smart contract, router two. So that's this address back to the terminal.
00:21:31.814 - 00:22:12.070, Speaker B: This is the first parameter here. And after you need the Abi and after I don't find the Abi here, but that's okay because we can do something more simple with ether. So what we need is swap exact eth for tokens. Yeah, that's the function that this one swap exact eth for token. So we copy this and after we're going to pass an array with the different function we want to use. So in our case we just want to use a single one. Let me put everything on the same line.
00:22:12.070 - 00:22:57.714, Speaker B: So ethers has something very nice which is called human readable Abi. So you can basically pass an array like this and you can build the Abi yourself very easily. Let's remove this. Okay, so now we have the AbI and finally we're going to pass the account. So now with the Uniswap object we can send transaction to the Ethereum blockchain. So now you're going to send a transaction like this Uniswap send exact eth for tokens. So here we have the uniswap.
00:22:57.714 - 00:23:31.134, Speaker B: There's a typo here. So first we need amount out mean, then the path, then the recipient address, then the dead line. And after that we're going to configure the transaction. So we going to pass this value of ether. Well actually with modern version of Javascript you don't need to repeat the key and the value. So we can use this notation instead. That's the same thing and we need to specify the gas price.
00:23:31.134 - 00:24:17.162, Speaker B: So for example 20 gray, this is probably not going to be enough, but you can check out eastgastation info. Otherwise there is also a method with ethers to have this programmatically. Okay, so at this point the transaction was not mine, it was just sent to the network. So here you can console log the transaction hash if you want it. And after, if you want to wait for the transaction to be mine, you're going to wait for the receipt. You use the transaction action object we got from before. And now you can know in which block it was mine.
00:24:17.162 - 00:24:56.026, Speaker B: Transaction was mine in block receipt, block number. Okay, great. So now you know how to interact with uniswap using Javascript and the Uniswap SDK. And you even know how to send a transaction by combining Uniswap SDK and ethers. So in the next section I'm going to show you how you can interact with Uniswap, but from a smart contract in solidity. So in this section I'm going to.
00:24:56.048 - 00:25:26.150, Speaker A: Show you how we can interact with Uniswap from a smart contract in solidity. We're going to build a function that allow us to buy some ether with tokens. Here I'm in remix the online id for solidity. I'm going to create a new file. I'm going to call this my defi project. I'm using solidity 0.7. So I'm going to start with the pragma statement as usual.
00:25:26.150 - 00:25:34.870, Speaker A: And first I'm going to define an interface for the router contract of Uniswap.
00:25:36.170 - 00:25:37.894, Speaker B: So for that I'm going to the.
00:25:37.932 - 00:26:02.106, Speaker A: GitHub repo of Uniswap in Uniswap V two, periphery. That's where we're going to find the router smart contract. It's important to note that this is a different repo from the repo, where you will find the pair smart contract. The pair contract in another repo called core. So periphery is different. Then we go in contracts. Then here we'll see the router.
00:26:02.106 - 00:26:17.400, Speaker A: So we'll go in router two and we're not going to copy everything because we only need one function. So we need the function swap exact tokens for ether here.
00:26:18.090 - 00:26:20.934, Speaker B: So we're going to copy this, go.
00:26:20.972 - 00:26:25.078, Speaker A: Back to remix and we're going to.
00:26:25.164 - 00:26:30.966, Speaker B: Copy this, going to format it a little bit so that it's a little bit more readable.
00:26:31.158 - 00:26:43.654, Speaker A: So in the previous section we used a similar function, but that was the country, that was swap exact eth for token. So here the parameters are very, very similar to what we had before.
00:26:43.792 - 00:26:47.134, Speaker B: But this time we also have to specify the amount in.
00:26:47.172 - 00:27:05.070, Speaker A: So that's the amount of token we're going to send. So let me clean up here the function signature, because we don't need everything. Okay? And we're going to go back to the GitHub repo of Uniswap because we need another thing in.
00:27:05.240 - 00:27:43.540, Speaker B: We're going to need another function signature here in router one. That's this function here. It returned the address of wrap ether. Okay, so next we need another interface for ERC 20 Token. So we're going to take the one of open ziplink. So that's a very popular library for solidity. I'm in the GitHub repo, I go in contracts token, yes, 20.
00:27:43.540 - 00:28:28.000, Speaker B: And we're going to copy transfer from here. Okay, so now we're good with the interfaces and now we're going to create our smart contract, my defi project. So we're going to create a pointer to Uniswap. With Iuniswap we call this Uniswap, and then in a constructor we are going to pass it the address of the router of Uniswap. So this is three DT 0.7. So we don't need the public keyword here. That was only up to three DT 0.6.
00:28:28.000 - 00:29:29.140, Speaker B: So here we initialize our pointer very easily like this. We pass it the address. Okay, and after we're going to create our main function to swap tokens for ETh. First we define the address of the token, and after the amount of token that we're going to provide in input, then the amount of ether that the minimum amount of ether that we want, and then the deadline after which the trade is not valid anymore. So first we need to move the tokens from the sending address to the spot contract. So for that we create a pointer to the token. Then we use a transfer from function.
00:29:29.140 - 00:30:13.410, Speaker B: We transfer it from the sender to the address of this contract and for the amount that's going to be amount in. So that means that before you call this function with this msg sender, you need to call approve on the ES 20 token that you want to send. Then we need to build the arguments for the swap exact token for ETH. So here, first we're going to build this pass. That's the two tokens that we want to trade. So that's an array of addresses of length two, that's the country. Okay, like this.
00:30:13.410 - 00:31:00.762, Speaker B: Now for the first element of the past, that's our token. The second element is wrap ether. So here we can use the Uniswap contract. It's going to return us the address of wrap ether like this. And now we can call the function of Uniswap swap the exact token for ETh. So the first argument is the amount of token we're going to provide. So amount in, then amount out mean, so that's the minimum amount of ethers as output, then the path, then the sender, the recipient.
00:31:00.762 - 00:31:12.670, Speaker B: So that's going to be MSG sender. So the ether is going to be sent directly to the sender of the transaction. It's not going to stay on our contract and the deadline.
00:31:12.830 - 00:31:15.106, Speaker A: And I realized that I forgot an.
00:31:15.128 - 00:32:05.570, Speaker B: Operation here because before we call the swap exact token function from Uniswap, we need to approve Uniswap to spend our token, because at this stage the token are inside our contract and Uniswap is going to try to pull the token to his contract, but it's not going to work unless we approve it. So for that we're going to need an extra line of code. So here we're going to approve the address of Uniswap to spend amount in. And here we will need to add this function to the signature of our interface here. So I'm back in the interface of open zeppelin. Let's scroll up, I'm going to copy this function. Approve.
00:32:05.570 - 00:33:02.322, Speaker B: Okay, so now we are able to exchange tokens against Ethereum by using Uniswap. How can you decide all these different parameters? Well, for the tokens, that's the token that you want to spend, so that's up to you. The deadline, that's basically your total runs for how long you want to keep, basically the implied price that you give with these two parameters. So for this parameter, that's basically how much ether you want to buy and amount in. That's how much token you're willing to spend to buy this ether. So you can reuse the example that I gave in the previous section with Uniswap SDK in order to calculate these parameters. It's also important to know that it's quite dangerous to try to evaluate the current price inside our function here in solidity, because it's very easy for someone to manipulate the price on chain.
00:33:02.322 - 00:33:48.342, Speaker B: So you really need to evaluate the correct market price off chain by using the Uniswap SDK. And if you really can do it off chain, but you have to do it on chain, then you need to build your own oracle smart contract that cannot be manipulated by other people. Basically, at the end of each block you will update this oracle smart contract with the price of Uniswap at the end of the previous block. So there are many variation of this function here. Exact tokens against ease, exact east against token. You have exact tokens against tokens. And if you want to have the full list, then you go to the official documentation of Uniswap in router two, and here you will see all the different version of this swap function.
00:33:48.342 - 00:34:00.134, Speaker B: There are also some other cool stuff that you can do with Uniswap, such as flash loans. They call this flash swap. So I probably will cover this in another video.
00:34:00.252 - 00:34:41.700, Speaker A: So now you became familiar with Uniswap. You know how it works, you know how to interact with it from Javascript and also from s three t smart contract. So what do you do with this knowledge? Well, one thing you could try is build a dashboard that shows the price of the different market of Uniswap. Another idea is to combine your knowledge of Uniswap with flashloan to try to do some arbitrage between Uniswap and other decentralized exchanges. And if you're interested in this, I have a full playlist on Flashloan on my channel. And also if you want to keep learning about other defi protocol on Ethereum, I also have a series on this. I'll see you there.
