00:00:00.250 - 00:00:36.822, Speaker A: In this video you are going to learn solidity in ten minutes. Solidity is the most popular language for smart contracts. You can use it for Ethereum and for other major blockchains like Polygon and arbitrage. This tutorial is for total beginners. Everybody can follow if you are new here, I'm Julian and on in the blocks. I help you to become a webster developer and if you want to learn how you can get started in the industry, check out my free masterclass. I will give you a full roadmap about what you need to learn and how to get your first six figure job in the space.
00:00:36.822 - 00:01:09.086, Speaker A: All right, to get started what is a smart contract? A smart contract is a small program that live on a blockchain. Once a smart contract is deployed, it cannot be stopped and it cannot be censored. The data stored in variables in the smart contract can be updated, but the code of the smart contract cannot be updated. Usually a smart contract is much smaller in size compared to other program maximum. We are talking of a few thousands of line of codes. However, this is very sensitive code because it manipulates money. The data that is stored in the smart contract is public.
00:01:09.086 - 00:01:40.550, Speaker A: Everybody can access it. A smart contract is permissionless. Everybody can use it. There is no need to ask for permission. Smart contract can interact with each other, which means that if you deploy your own smart contract, it can call the function of any other smart contract. There are many real life examples of smart contracts such as Uniswap, a decentralized exchange that allow you to buy and sell token or combine, a decentralized lending market where anybody can lend or borrow crypto. There are different languages for smart contracts, but solidity is the dominant language.
00:01:40.550 - 00:02:20.930, Speaker A: It was originally built for Ethereum, but because many of the blockchain are based on the Ethereum technology, you can also use solidity in all these other blockchain. So I'm talking of blockchains like Polygon, Arbitrum, and there are many other as long as the blockchain is based on the Ethereum virtual machine, you can use solidity in it. So investing in solidity is worth it. All right, so we're going to start the coding and for that you are going to open up your browser and load the remix ide. So that's an online ide for solidity development. It's very convenient. All you have to do is visit this URL and you can start coding in solidity.
00:02:20.930 - 00:03:08.822, Speaker A: So the first thing to do is to go here on the left and make sure that you are using the latest version of solidity, you also make sure that you activate it autocompile. It's going to give you live feedback and then you go in the file explorer and you are going to create a new three DT file. So here we're going to call it mycontract Sol. That's the extension for three DT. And here we are going to specify the version of three DT that we use. So that's to make sure that we are not trying to compile three Dt with the wrong version of the compiler. And after we specify our smart contract, my contract, we open the square brackets and then we start to code.
00:03:08.822 - 00:03:49.654, Speaker A: And so to get started we're going to do a very simple smart contract that allow you to read and update data. So in a smart contract we have a variable and function. So here we declare a variable of type U in, so that's a positive integer. And after that we're going to create a function to update its value. So here we specify an argument in our function. We make it external, which mean that we can call this function from outside the smart contract because there are also some other function that you can only call from inside the smart contract. And we are going to update our smart contract, our variable like this.
00:03:49.654 - 00:04:30.658, Speaker A: And so after you execute this function, the value of underscore a is going to be persisted in a and a is going to be stored in the blockchain. And after that we're going to create another function that allow to read the value of a. So here we call this get and we use the view keyword and we also indicate what we are going to type that we are going to return. So that's an integer, and here we use the return keyword. So here you have two return keywords. This one returns with the s that's in a function signature and the other one that is in the function body. And here we have a very fundamental difference in these two function.
00:04:30.658 - 00:05:18.142, Speaker A: The update function allow you to modify the state of the blockchain, and the get function only allow you to read data from the blockchain. So this is why we have the view function here. So it's free to call the get function. You don't need to pay anything. However, every time you will execute the update function, this is going to be a transaction and you need to pay for transaction and you will pay with your balance of ether. All right, so that was your first example of smart contract. So next I'm going to show you a special kind of function that is called the constructor, and the constructor is a special function that is executed only once when you deploy your smart contract and you're going to use it to initialize some variables.
00:05:18.142 - 00:06:01.646, Speaker A: So typical pattern is if you want to declare an owner of the contract that has a special right, then you can do something like this in the constructor here, you pass this as an argument. And next I'm going to tell you about another kind of variable in solidity. So that's the address type, and that's very useful because we often manipulate money. So when we manipulate money, we need to know the sender and the recipient, and for that we need addresses. So addresses start with zero, x. There are two type of addresses. There are what we call EOA addresses, and these are generated by wallets outside of the blockchain and they are controlled by a private key.
00:06:01.646 - 00:06:44.690, Speaker A: And then we have smart contract addresses. So whenever you deploy a smart contract on the blockchain, it's associated to an address. And the fundamental difference is that a smart contract can only react when you call its functions. So next, I'm going to show you how you can transfer ether because that's something that we do very often in smart contract. So first, let's try to see how we can send ether to this smart contract. So we have to make the function payable, otherwise it will not receive ether. And here from your wallet you will be able to send ether to this function and then the ether will be locked inside the smart contract.
00:06:44.690 - 00:07:18.246, Speaker A: So you also need to create another function to move this ether because otherwise it's locked forever. We are going to create this function, send ether. And so here we need to specify a recipient and also an amount. Here, actually we need to make the recipient a payable address. So there's a difference between a regular address and a payable address. You cannot send ether to a regular address, you have to make it payable. And here we make this external so that we can call it from outside the contract.
00:07:18.246 - 00:07:43.658, Speaker A: All right, let's make our code editor bigger. It's easier to see it that way. And so here we are going to send ether by using the call function. And here we're going to use a special notation. By using curly braces. We're going to specify the value that we going to send. So here, this is the amount that we specify in the function argument.
00:07:43.658 - 00:08:15.642, Speaker A: And after we need to use this notation. So this looks a bit weird like this. That's actually because this is a low level function call. And here when you do a low level function call, you are supposed to specify which function you are calling on the recipient and with which argument. But in our case we are not calling a smart contract, we are just sending ethers. So here we don't need to provide anything, we only care about this part. All right? And after that we're going to get in return two things.
00:08:15.642 - 00:08:48.962, Speaker A: So first, a Boolean value that tells you if the ether transfer worked. So if you send it to an EOA address, it's always going to work. However, if you send it to a smart contract, in some cases it can be refused. The other thing that we're going to receive is some data and that's used only to indicate why there was a failure. And here we terminate our statement with a semicolon like all statement in solidity. All right, so here remix tells us we have an error. All right, so that's because payable is not payable.
00:08:48.962 - 00:09:08.150, Speaker A: Address is address payable. All right, and now we're good. And obviously here it's not secure. Everybody can call this function and steal your ether. And there are ways that we can implement access control. And I'm going to show you this after. All right, so next let's see how we can call another smart contract.
00:09:08.150 - 00:09:33.806, Speaker A: So one of the capabilities of smart contract is to be able to call each other. We have composability that's very powerful. So let's see how this works. We're going to define the interface of another contract, I other contract. And inside we're going to define the function signature. So let's make it easy. Let's just say there is just single function, external view just returns an integer.
00:09:33.806 - 00:10:11.278, Speaker A: That's how you define an interface in solidity. And after that you are going to define a function here. And from this function we are going to call the other smart contract and we're going to store the result in this variable. So you have to use the interface and you're going to pass it the address of the smart contract. So let's say that this is this address and after that we call the bar function and that's it. So next I'm going to show you a couple of built in variable in solidity. So we use this built in variable inside function.
00:10:11.278 - 00:10:38.198, Speaker A: So first there is Msg senders. That's the address that called the function. Then we have Msg value. So that's the amount of ether that was sent in a transaction and it can be equal to zero. Then we have block timestamp. So that gives you the timestamp in second of the block that contains the transaction that was mined. That's very useful if you want to have any logic where you have some constraints around time.
00:10:38.198 - 00:11:09.070, Speaker A: For example, in ico you can only sell the token up to a certain point. And another important built in variable is this can let you access things off your smart contract. And very often we cast this into an address. And so this gives you the address of the smart contract. And once you have this you can get the balance of the smart contract in Ether by doing this. All right, so next I'm going to show you two containers that we often use. So the first one is an array.
00:11:09.070 - 00:11:37.340, Speaker A: So let's declare this. Let's say we want an array of integer. So here you notice that compared to other languages like JavaScript or Python, in an array in solidity we can only have data of the same type. So here it can only be an array with only integer, but we cannot mix integer with other things. So let's do a couple of function to manipulate this array. So let's say that we want to add something to this array. We have our value.
00:11:37.340 - 00:12:12.454, Speaker A: To add something we can use the push function. So it's going to add this value at the end of the array. Then we can update an element of the array. So specify the index and we specify the new value, make it external. And my array here we're going to access the correct index, the correct value like this. You have to make sure that this index exists because otherwise it's going to trigger an error. It's also possible to delete a value.
00:12:12.454 - 00:12:56.178, Speaker A: So here, specify the index and you can delete these values. And if you do this in the middle of the array, it's going to leave a hole in the array. So you will still be able to access this element, but it's going to go back to the default value for this type here actually cannot use this keyword, so you'll need to use destroy. And you can also remove the last element. Remove last value, you'll do my array pop like you would do in JavaScript. All right, so this is how you manipulate an array. There is another container that is even more useful in solidity and that's a mapping and so you can see it as a key value store.
00:12:56.178 - 00:13:31.706, Speaker A: So in a mapping you're going to define the type of the key. And the very common case is when you want to track balances is that you'll have keys that have addresses and for the value this will be integer. And so let's call this balances. And here let's see how we can do the common operation. So the most common operation here will be to update an entry. You'll have the address, and after the new value, the new amount. Let's say what you would do is balances.
00:13:31.706 - 00:14:09.690, Speaker A: And here with square bracket, you reference the owner and you have the new amount and that's it. And in most cases, this is how you will interact with an array. It's also possible to delete an entry for an array. So here we do delete balances owner. But here there is something very surprising in Sugi T, because you can access any entry in a mapping, even the entry that you never initialize. So here if you try to access balances of an address that don't have the key three DT will still return you something. It's going to be the default value of the type for the associated data, in this case going to be zero.
00:14:09.690 - 00:14:41.058, Speaker A: And another thing that is a bit special is that you cannot iterate over mapping in solidity. So that means you cannot do a for loop where you iterate over this and you want to know the total balances of everybody. All right? And the last thing is how to deal with errors. And so here let's call foos with error. You have two ways to deal with this. So first, you have a required statement and it's often used for access control. Let's say that you have an address that is the owner and you define this in your constructor.
00:14:41.058 - 00:15:10.506, Speaker A: So owner equal, for example, the address that deploy this smart contract. It's how you do it. So here you can make sure that the caller of this function is the owner. And if that's not the case, then you have error message, not the owner. And so everything stops here. Or another way to trigger error is something that was introduced more recently is with solidity custom error. And the advantage is that you will spend less gas to use the custom error.
00:15:10.506 - 00:15:50.474, Speaker A: You would do error unauthorized, for example, the name of the error. And here, instead of that, if sender of the transaction is not the owner, we are going to trigger the error with revert and the name of the arrow unauthorized. And that's it. So in this video I covered the basics of solidity. You still have a lot to learn, especially when it comes to smart contract security. In smart contracts we often manipulate money and we also cannot modify the code of a smart contract. So that means that if there is a bug or a security vulnerability in our smart contract, it's a real faster.
00:15:50.474 - 00:16:10.570, Speaker A: We absolutely need to make sure that everything works fine. So security is very important. And next, if you want to know what you need to learn in order to become a professional web3 developer, make sure to watch my free web3 masterclass. The link is down below. Thanks for watching. Bye.
