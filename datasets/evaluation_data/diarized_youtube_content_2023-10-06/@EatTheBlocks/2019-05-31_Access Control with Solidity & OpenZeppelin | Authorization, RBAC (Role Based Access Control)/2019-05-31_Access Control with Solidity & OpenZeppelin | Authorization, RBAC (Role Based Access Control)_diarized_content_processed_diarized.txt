00:00:00.250 - 00:00:49.862, Speaker A: In a solidity smart contract you have access to people money, so security is really key. The Ethereum blockchain provide you with strong security out of the box by handling user authentication on your behalf. However, that's not enough to implement a complete access control system and we need some solidity code to allow or disallow users to perform certain actions. In this video I will explain you the different concept of access control. I will also show you what parts are covered by the Ethereum blockchain and which parts aren't. And finally, I will give you a full recipe to implement full access control in your smart contract, ranging from very simple permission system to a sophisticated role based permission system using the Openzepling library. First we are going to see the difference between authentication and authorization.
00:00:49.862 - 00:01:35.654, Speaker A: This is not specific to smart contract, but this is something that you also find in application in general. Then we will see how to implement basic access control in solidity. Then we will see how to implement the ownable pattern using the Openzepling smart contract library. Then we will also see how to implement access control between smart contract using the secondary pattern of Openzepling. And finally we will see a sophisticated RBAC role based access control pattern also with Openzeplin. By the way, if you want to access the source code of this episode and all the other episode of it, the blocks go to the website of itoblocks Pro, my screencast for Ethereum and solidity developer, and create a free account by clicking on enroll. Now, it doesn't cost any money and it will give you access to the git repo of etherblocks.
00:01:35.654 - 00:02:19.862, Speaker A: And as a bonus, I will also send you the ebook how to become a blockchain developer, which is a complete step by step guide on what you need to do in order to become a blockchain developer. So let's start with the difference between authentication and authorization. Authentication is when you verify that somebody is the person they claim to be and not someone who tried to impersonate a user. In web application. This happened when you have to provide your username and password. There are other methods for authentication like the of protocol where a third party application authenticate users in an Ethereum DAP, we use a public private key cryptography for authentication. Users create messages called transactions where they describe the action they want to do on the smart contract.
00:02:19.862 - 00:02:55.166, Speaker A: More practically, this transaction defines a function call on the smart contract along with call arguments. This whole message is signed by the private key of the user. Beside its payload. The transaction also has a signature and the public key of the user the signing process is done. Client side using the user wallet when the smart contract receives the transaction, the Ethereum blockchain verifies that the transaction signature matches the public key of the transaction. If it doesn't, the whole transaction fails and nothing is executed. If it succeeds, the address of the user, which is derived from its public key is put aside.
00:02:55.166 - 00:03:39.598, Speaker A: The MSG sender variable of the smart contract there are two important points to understand. First, the smart contract does not need to do any authentication itself. The Ethereum blockchain takes care of that. The smart contract can confidently assume that the sender of the transaction is identified by the address stored inside the MSG sender variable. And second, the private key of the user is not stored on the blockchain, but instead is stored on the user wallet client side. If a hacker hacks the user wallet, only his or her private keys are compromised, but other users are totally fine. This is very, very different from a regular web application where a hack of a centralized database can result in compromising all user accounts.
00:03:39.598 - 00:04:24.698, Speaker A: All right, so that's it for authentication. And what's the difference between web application and Ethereum? Dapps now we're going to see what is authorization. So authentication is a good first step, but this is not enough. An authenticated user can still try to do things that are not allowed. For example, if, let's say that I have a WordPress blog, you can have writers that are just allowed to write articles but that are not allowed to publish articles. So how can we prevent these unauthorized actions? With an authorization mechanism in place, we associate roles to each user and we would associate authorized action to each role. Every time a user try to perform some action, we grab the role of the user and we make sure that this role has the right to perform this action.
00:04:24.698 - 00:05:10.750, Speaker A: If we take the example of our WordPress blog, we would have two roles, publisher and writers, and we will have two actions, publish and save. The publisher role would have the publish and save actions, whereas the writer role would only have the save action. In the rest of this tutorial, I will show you what are the different ways to do authorization in solidity. So that's it for authentication versus authorization. Next, let's see how to implement a basic access control in a solidity smart contract. So let's load our remix editor and let's make sure that we select the solidity version 0.5.8 and we're going to create a new file that we're going to call basic access control Sol okay, and after we're going to put the pragmat statement.
00:05:10.750 - 00:05:49.814, Speaker A: Okay, so let's define our smart contract, basic access control. Okay, so in this smart contract I'm going to define a few function and some of this function will be public. So we have no need to implement any sort of access control. But all the function are private and we only want a very specific user to be able to execute them. So first we are going to create an address variable that's going to be public and we're going to call this admin. So that's a state variable which is stored inside the blockchain. Then in our constructor which is executed.
00:05:49.814 - 00:06:24.440, Speaker A: When we deploy the smart contract we are going to give an initial value to this admin variable. So let's define our constructor and we make it public. And here we're going to assign to admin the address of the sender of the transaction. So basically the address that deploys the smart contract will be the admin of the smart contract. So then we're going to create a public function. So public function, it doesn't take any argument. Let's make it callable from outside the smart contract and it doesn't do anything.
00:06:24.440 - 00:07:08.898, Speaker A: So everybody can access this function. So we don't implement access control. Now we want to create some other function with access control. So how are we going to do this? So let's create a function, private function, one for example, doesn't take any argument and make it external also, and we don't define anything inside. So if you just do like this, everybody can call our function. But what we want to do is to restrict the access. So inside the body of our function here we use a required statement and what we want to check is that msg sender is basically the admin.
00:07:08.898 - 00:07:50.930, Speaker A: And if that is the case, then this required statement will pass and we'll be able to execute whatever is below here. But if this is not the case, then the transaction will revert and will stop here basically and will display this error message. So here we can just say only admin and here we terminate by a semicolon. So with this in place, that's how we implement basic access control in solidity. Now if we want to do another private function, all we have to do is to do exactly the same thing. So we copy and paste this. So let's say we have another function, private function two, so that is also protected.
00:07:50.930 - 00:08:21.142, Speaker A: However, the problem if we do this is that we have some code repetition. So the traditional way to solve this problem in solidity is to use a function modifier. So here we define a modifier that we call only admin. So a function modifier, if you never heard about this before, it is basically a way, a sort of piece of code that we can attach to other function before they are executed. So let's see how this works. So a function modifier can take some arguments. So in our case we don't need any argument.
00:08:21.142 - 00:09:14.000, Speaker A: A function modifier doesn't take any function visibility like public or external because by default a modifier can only be called by the smart contract where it defined, or any other smart contract that inerit from this smart contract. So we don't need to specify any function visibility. Okay? So we define a body of a modifier and what we do here is that we copy and paste this required statement, okay? And then we use the underscore placeholder. So this represents the function that will be attached to this modifier. So here, for example, in private function after external we put only admin. So you can do like this if you want, and non put any parentheses, but it's better to put parentheses to make it more clear that it's a function modifier. And also, if you have to pass some argument to your modifier, then you will pass your argument like this.
00:09:14.000 - 00:09:54.886, Speaker A: Okay, and so now that we've attached this modifier here, we don't need the require statement anymore. So let's get rid of this. And here in private function one, let's also get rid of the required statement. And let's also attach the only admin modifier. So with this thing, private function one and private function two can only be called by the address that is stored in the admin variable, which is basically the address that deployed the smart contract. So if you've been reading some solidity code, it's quite likely that you already saw these patterns. So this is something very very common in solidity.
00:09:54.886 - 00:10:41.018, Speaker A: This is the most simple way of implementing access control in a smart contract. Next, let's see how to implement the honorable pattern with open zeppelin. So the honorable pattern will allow you to do exactly the same thing that we just did with pure solidity. But in this case we are going to use an open source framework from smart contract and we will also have some extra feature. The advantage of this is that you will avoid some code repetition across your different project, and also will have some extra functionality by using openzepling. Openzepling is the most popular open source framework for solidity smart contract. It has a public GitHub repository and it's regularly audited for security vulnerabilities so all the smart contracts that are inside this repo, you can use all of them and you can be really confident that they are really safe to use.
00:10:41.018 - 00:11:18.082, Speaker A: So let's go to the GitHub repo and let's scroll down. And let's click in the contracts folder. And let's scroll down and we will see two folders that are interesting to the first one is access and the second one is ownership. So ownership is the old way of implementing access control. In open Zeppelin and access folder we have some newer stuff. So in this video I'm going to show you both, but we are going to start in the ownership for this section. So let's click on ownership, and the smart contract that I will show you now is the ownable Sol smart contract.
00:11:18.082 - 00:11:48.586, Speaker A: So let's click on it and let's scroll down. Let's keep scrolling down. Okay, so with this smart contract you can implement exactly the same pattern as we implemented before. So basically you define an owner of your contract just before we call this admin. But it doesn't matter. You can call this however you want. And by using the public modifier only owner here you can basically restrict access of some function to only the owner of the smart contract.
00:11:48.586 - 00:12:26.938, Speaker A: So you have this modifier, but you also have other functions. For example, you have the owner function that returns you the address of the owner of the current smart contract. And let's scroll down. And we also have some other function like ease owner, for example. So in your function you can make use of this function and based on that, make some decisions that can be useful in if statement, for example. Then there is another interesting function which is called renounce ownership. So if you do this, that means that all the function to which you attach the only owner modifier will basically stop functioning because the previous owner is replaced by the null address.
00:12:26.938 - 00:13:00.386, Speaker A: And there is absolutely no way of setting up a new owner. You can also transfer the ownership with a transfer ownership function. So that's it for the tour of the ownable soul smart contract. So now let's go to remix and we'll see how we can make use of it. So first let's create a new smart contract and let's call it own contract. And we'll start by the pragma statement and the name of the contract. All right, so I just said before that we are going to use this smart contract in the Openzeppelin framework.
00:13:00.386 - 00:13:30.474, Speaker A: So how are we going to do this? So the first thing we need to do is to import this smart contract. So just above the contract keyword, let's use the import statement. And after the import statement we will specify the path to the smart contract that we want to import. So I'm going to paste the whole thing. Okay, so here we have the import statement. And so notice carefully how I specify the URL. So I didn't specify any protocol like HTP or HTPs.
00:13:30.474 - 00:14:06.170, Speaker A: I directly specified the domain name. So GitHub.com, then the organization name openzepling, then the name of the repo openzepling solidity, and after I specify the path to the smart contract. So contract ownershipownable, solved, and basically remix is smart enough to figure it out. So depending on the environment that you use to compile your solidity smart contract, you might have to use a different way of importing other smart contract. Okay, so next let's make use of this honorable smart contract. So inside our contract we're going to define a constructor.
00:14:06.170 - 00:14:45.586, Speaker A: We make this constructor public, and here we need to call the constructor of the honorable smart contract, and we need to use the name of the ancestral smart contract. So here we do honorable and we put parentheses and that's going to call the constructor of honorable. And if we wanted to pass some argument then we would pass some argument like this. But in our case there is no argument to the constructor of honorable. So there is nothing here. And we define an empty body for our constructor. By the way, I actually forgotten the most important, which is to inerit from honorable.
00:14:45.586 - 00:15:50.534, Speaker A: So after the definition of our smart contract, owned contract, we use the Es keyword to inerit, and we specify that we want to inerate from honorable. And now we can reference its constructor in a constructor like this. So if you know JavaScript, this is equivalent to calling super in JavaScript when you do inheritance. And in other programming language the super keyword is also used, but in solidity that's how you call the constructor of an ancestral smart contract. And now we're going to create some public and private function and see how we can use the audible contract. So first we're going to create a public function, so public function, it's an external function and it doesn't do anything, so everybody can call it, and then we're going to create a private function. So no argument, this is also external and we will be able to use the only owner modifier of the ownable contract.
00:15:50.534 - 00:16:20.374, Speaker A: So as you can see, we do not define this anywhere inside our smart contract, but we can still use it because we inherit from the ownable smart contract. And after we define the body of our function. So now in case it's nothing, but in real example, then you will have some code here. So as you can see, this is less code than what we had previously. And this is exactly the same functionality. And on top of it, in bonus, we also have access to a couple of extra function. For example, we have access to the owner function.
00:16:20.374 - 00:17:00.290, Speaker A: So the owner function will return what is the current owner of the smart contract. And there are also some other function like renounce ownership. So if you do this, then it's going to set the owner to the null address and the private function will be impossible to call basically. So if we want to use one of the function in read it by ownable, we need to define another function. So let's call our function renounce and external. And we got it with the only owner modifier. Okay, so we open the curly braces and inside we call renounce ownership.
00:17:00.290 - 00:17:40.458, Speaker A: Okay, so now you know what guys, actually let's deploy our contract and play around a bit. So I've set my compiler yes to 0.5.8, it's fine autocompile. But let's go to the run tab, let's expand this a little bit and let's click on deploy. Okay, actually I wanted to deploy with the first address. Let's delete this, let's deploy again. Okay, and so now I expand my contract instance so everybody can call the public function, even if I select another address which is not the admin.
00:17:40.458 - 00:18:10.714, Speaker A: So everybody can execute this. This is normal. Now how about the private function? So I'm trying to call the private function from the second address of Ganesh, but this is not an owner. So let's see what's going to happen. So, VM error, ownable caller is not the owner, so it works our access control prevent us from calling this function. So let's scroll up and let's try with the actual owner, the first address. So now let's click on private function again.
00:18:10.714 - 00:18:35.470, Speaker A: And now we can call it cool. Okay, so now let's renounce the ownership. By the way, actually we didn't need to create a wrapper function. Renounce because renounce ownership and transfer ownership are external function. And so from the moment that you inherit them, it's as if you define them in your smart contract. So actually there was no need for a renounce function. So let's try to renounce ownership.
00:18:35.470 - 00:19:00.406, Speaker A: And let's try to renounce ownership from the second address. So it should fail because I'm not the owner. So it doesn't make sense that I renounce the ownership. So VM error, honorable color is not the owner. Okay, so let's scroll up now let's select the first address and I'm going to click on renounce ownership. So this time it has worked. And now if I try to execute the private function, it shouldn't work anymore.
00:19:00.406 - 00:19:25.906, Speaker A: So let's click on private function and this time you see that it fails. Ownable color is not the owner. So after you've done that, this is finished forever. You will never be able to call this function again. So just make sure that you're really aware of that. All right, so that's it for the honorable pattern with the Openzepling library. I recommend you to use this whenever you want to implement a basic access control and not to roll out your own system for access control.
00:19:25.906 - 00:20:10.810, Speaker A: So next we are going to see the secondary pattern with open Zeppelin that allow you to implement access control between two smart contracts. So let's go back to remix and let's clean up a little bit. Our editor okay, and we are going to create two file. The first one will be storagefactory Sol and second one will be basicstorage solve. So this smart contract will create other smart contracts. So that's what I call basicstorage Sol. And all this contract, basicstorage Sol, some of their function will only be callable by the storage factory.
00:20:10.810 - 00:20:44.620, Speaker A: So that's an access control, but between smart contract. So first we are going to define our basic storage contract. So it's going to be a very simple contract that can just store a variable. So we define a pragma statement and we define the contract, basic storage. And inside we define a string that we make public that we call data. And we define a function to set the value of these variables. Function set data.
00:20:44.620 - 00:21:08.610, Speaker A: The type is string, the memory location is called data, and we call this underscore data. And we make this external. Okay. And inside we just set the value of data based on the argument. So a very, very simple smart contract. Now let's go to the storage factory. Actually, you know what, let's copy the pragma statement, it's faster.
00:21:08.610 - 00:21:45.546, Speaker A: And let's define this contract. Storage factory and this contract will be able to create some basic storage smart contract. So first we need to import basic storage smart contract because we're going to need it. So import in here we need to specify the path. So here is browser because every file that we create in remix is put inside the browser folder here inside this browser folder. Then the path is just basicstorage saw. Okay, so now we can reference this smart contract inside our storage factory.
00:21:45.546 - 00:22:26.966, Speaker A: In this smart contract, we are going to create two functions. The first function will create a basic storage smart contract, and the second function will allow to call the set data function of the basic storage smart contract. So let's start with the first function that creates basic storage instances. So we're going to call it create storage and it doesn't take any argument. And this is an external function. And the way that we create a new smart contract in solidity is with the new keyword and we reference the basic storage smart contract and we specify parentheses. And then we want to store the address of this new smart contract in a variable.
00:22:26.966 - 00:23:27.230, Speaker A: So we define a variable of type address and we call this basic storage address. And if we do this, so DT is not going to be happy because new basic storage is going to return a pointer to the basic storage smart contract. But we just want the address. So here we're going to cast this into an address like this, and we want to store this address in an array of address so that later with the other function, when we call the set data function on each of this basic storage smart contract, we can reference the correct contract. So we're going to define a state variable here. So that's an array of address, and we're going to call this basic storage addresses and we're going to make it public. And next, in the create storage function, we need to push the basic storage address in our array of address basic storage addresses.
00:23:27.230 - 00:24:08.454, Speaker A: So let's reference the basic storage addresses array and we call the push method on it, and we pass it the variable which is defined before. Okay, so now that we store the address of the basic storage smart contract, we will be able to call a function on it. Let's put a space here. Okay, so now we're going to create our second function that allow to call the set data function on each of the basic storage smart contract. So let's create this function and we're going to call this set data. And it's going to take two argument. First argument is the index of the basic storage contract in the basic storage addresses array.
00:24:08.454 - 00:24:59.782, Speaker A: So that's an integer and we call this underscore index. And the second is the string that we are going to pass to the basic storage set data function. So let's type this argument so string of type called data. And we're going to call this underscore data and we make this external. And first we need to require that the index that we pass here actually exists in the basic storage addresses array here. So require that index is strictly inferior to the length of this basic storage addresses array. Because remember that insert DT arrays has zero index, so the maximum index is always offset of one compared to the length of an array.
00:24:59.782 - 00:25:53.182, Speaker A: And the error message is this index does not exist. And next we need to create a pointer to the basic storage smart contract. So below let's define a variable of type basic storage. Then we create the name of this pointer, so basic storage, but this time with a lowercase p. And now we use basic storage with an uppercase this time and we pass it the address of the smart contract. And we use the basic storage addresses array at the index. That is given as argument because before in the create storage function we store the address of all the basic storage smart contract that we created before and after.
00:25:53.182 - 00:26:51.642, Speaker A: Oops, here it's not a lowercase, it's uppercase, okay, and after we make use of this pointer basic storage and we call set data on it and we pass underscore data that we got as an argument and it's going to call this function on this smart contract. So if we just leave things like this, actually we haven't implemented any sort of access control because if you go to the basic storage smart contract, there is nothing that prevents any other external entity to call this function. So we need to make use of the secondary contract of openzepling. So the first thing is to import it. Here I'm going to paste the import statement, so import plus the path to the smart contract. So GitHub openzepling, open zeppelin, solidity contracts, ownership and in the ownership directories there is another smart contract called secondary. Then we need to make our basic storage smart contract inerate from secondary.
00:26:51.642 - 00:27:36.990, Speaker A: So is secondary. Then we need to call the constructor of the secondary smart contract. So let's define a constructor in our basic storage smart contract, and after we make it public and we call the constructor of secondary like this, and we define an empty body. So the only reason why we have a constructor in our basic storage smart contract is because we want to call the constructor of secondary. That's it. And once we have this, then we can access a modifier that comes from the secondary smart contract. And this modifier is called only primary, and it basically sets the address that deployed this smart contract as the admin of this smart contract.
00:27:36.990 - 00:28:25.790, Speaker A: So if we attach this modifier only primary, the only address that will be able to call this set data function is the address that deploy this smart contract, which in our case is the storage factory smart contract. So this way, we're going to implement access control between two smart contracts. And finally, let's see how we can implement role based access control with Openzeplinks, which is the most sophisticated form of access control that we can have with smart contract. So let's go to the GitHub repo of Openzeplink. I'm going to first give you a quick tour of the role smart contract of Openzeplink. So let's scroll down on the homepage, let's click on the contracts directory. And this time we're not going to go in the ownership directory, but we're going to go in the access directory.
00:28:25.790 - 00:29:01.562, Speaker A: And the main smart contract here is the role smart contract that define the whole role logic. And inside the roles directory, you will find example of how to use this role smart contract for some very specific application related to Crowdsell and ICO. So we're not going to use this smart contract. We are going to directly use the role smart contract and figure out ourselves how to use it. But if you are in search of inspiration, after this video, you can check what is inside this rose directory. So let's quickly have a look at the rose smart contract here. So let's go down.
00:29:01.562 - 00:29:35.890, Speaker A: So first, you'll notice that this is a library. This is not actually a contract. So in solidity, library and smart contract are a little bit different. So a library cannot be deployed on its own, so it cannot have an address. A library is always something that is used inside a smart contract. So it's basically like a block of code that you will embed in another smart contract. So the basic idea of this smart contract is that you define some role, and with this role, you can add addresses to it with the add function, and you can also remove addresses from it with a remove function.
00:29:35.890 - 00:30:24.958, Speaker A: And you can also check that an address has a certain role with the has function. So just to give you more detail, in this library, they define a role struct, which is a mapping of address to Boolean. So with this mapping, we're going to give him some address and we're going to have a boolean value in return that tell us if this address has this role or not. So you might wonder how comes we have this role struct and inside we define a field which is mapping of address to Boolean. This is a bit weird, isn't it? So actually, each instance of this role struct will define a specific role. So for example, you're going to create an instance for the admin role, another instance for the user role, and this mapping here will act as a sort of registry for this role. There won't be any container that hold all the different role struct that will be up to you in your solidity code to manipulate these different roles.
00:30:24.958 - 00:31:19.382, Speaker A: But the point is by combining this mapping inside a role, basically we simplify everything because we don't need a field that says something like name of the role or idea of the role, the instance of the role, and the way we're going to name this role in our code like admin or user. This is enough to identify this role in our code. All right, so with this being said, the last remark about this role struck is that it's going to be used throughout the code of this library in all the functions. So if we scroll down in the add function, then it accept role, same thing for remove and same thing for the hash function. That's it for the quick tour of the role smart contract. So now we're going to see how we can use it in our own smart contract. All right, so now let's go back to the remix editor and let's do some cleanup here and let's create a new file that we're going to call rbags or rolepayaxiscontrol Sol and we're going to make use of this role smart contract that just show you.
00:31:19.382 - 00:32:22.634, Speaker A: So first we start with a pragma statement, okay? And then we have import to the role smart contracts and we're going to paste the path to it. So import GitHub and then the open Zeppelin repo and then the contracts folder and then the access folder. And after the role smart contract. And after we specify the name of the contract that we call rbaC, then we'll define two function that will have a restricted access based on the role of the user that is calling the function. So first we're going to create a function that is called user protected function. And this is a very simple function that just doesn't do anything, but we just use it as an example and we're going to attach to it a modifier that we'll create just after this is called only user and it doesn't have anybody. And after that we're going to create another function.
00:32:22.634 - 00:33:07.746, Speaker A: This time this will be admin protected function and same thing, it doesn't do anything and we attach to it another modifier that we call only admin. Okay? And then we need to define these modifiers. So modifier only user. And at the moment it doesn't do much. And then another modifier that is called only admin. Okay, then we're going to define two roles using the roles truck of the roles library. So at the top of your contract, let's reference the roles library.
00:33:07.746 - 00:33:53.090, Speaker A: Roles role. So roles here is name of the library and role is name of the struct, just to be clear. And we make it private so that outside entity cannot easily read the content of our role. And we're going to call this users. And the other role will be admin, role role private admin. And you notice that in both cases, I use the plural to give the names of this role because although there is one role, there will be several member for each of this role. And then we need to use some of the function of the roles library to actually implement our modifier only user and only admin using the two roles that we have defined.
00:33:53.090 - 00:34:29.426, Speaker A: So let's have a look at the code of the roles library to see which function we can use. There is one function inside the roles library that is interesting, which is the has function. It check if an account has a role. So the first argument is the role, and the second argument is the address that we want to check. So let's go back to our smart contract, and we need to find a way how we can use the functions of our roles library. And in solidity, there is a pattern that is often used in order to use library that is using the using keyword. So let's see how this works.
00:34:29.426 - 00:35:30.582, Speaker A: So in solidity, you can use this thing using a four b. So I'll just give you a general example, and after we're going to modify it for our example. So using a four b means that I want to attach the a library to the b type. So to make it a little bit concrete, let's say that instead of b type, we have something like integer, for example. So if I do this, that means that any integer in my smart contract will be able to call all the function of the a library. So if the a library has a function that is called, I don't know, foo, for example, and then this function has an argument, we're going to call this bas. Okay, that means that inside any of my smart contract function, for example, user function or admin protected function, I could do something like this.
00:35:30.582 - 00:36:13.870, Speaker A: So I define an integer like my int, and then with my int I will be able to call the full function of my library. Because thanks to this statement, using a for b, I attached all the function of the a library to all the variable that have the integer type in my smart contract. And this function foo as a first argument will be passed my int. So you don't need to do something like myint Foo. And after you repass my int, it's already assumed that this will be the first argument. So here bas will have the value of my int. And if you have a second argument, let's say another integer.
00:36:13.870 - 00:36:45.486, Speaker A: So you int here, when I call my foo function, I put two, then this two here will be what we have in bar. So, although here I specify only one argument, actually the foo function will be called with two argument. So that's a general way that we use a library in solidity with the using keyword. So let's get rid of our example here. And also let's get rid of this. That was just to show you guys. So we're going to do something a bit different.
00:36:45.486 - 00:37:37.520, Speaker A: So we want to attach the roles library. So that's going to be using roles, and then we want to attach it to what we want to attach it to the role struct. So for roles role. So I understand that this sounds a little bit more complex than what I just show you, but the trick here is that actually both the library and the type that we want to attach it to, both of these things, they are in the library. So you can take a type that is defined in a library and attach the function of this library to this type. And so the function that is interesting for us is the has function that makes sure that an address is inside a role. So here, if we go inside user, what we can do is we use the user's role and then we can call the has function.
00:37:37.520 - 00:38:08.230, Speaker A: So the first argument will be the user's role. So we don't need to specify again. And the second argument that's going to be actually our first argument here will be the sender of the transaction. And the sender of the transaction is Msg sender. And we want to require that this is true because this is going to return a boolean value. So here, want to make sure that this is true. And if that is not the case, the error message is must have user role.
00:38:08.230 - 00:38:45.038, Speaker A: Okay. And so now that you know this, then you're probably guessing what we will have in only admin. It will be almost exactly the same thing. So let's copy this, let's paste it, and it's going to be instead of users has, it's going to be admins has. And then we replace the error message must have admin role. Okay, and next, we also want to have a way to manage these roles. So we want to be able to add users or add admins, but also remove user or remove admins.
00:38:45.038 - 00:39:13.046, Speaker A: So we're going to create four new functions for this. So first, let's create a function to add new user. So we're going to call this add user. It takes a single argument, which is the address of the new user. So address, underscore new user and make it external. And we got it with the only admin modifier. Otherwise, anybody can just make new user.
00:39:13.046 - 00:39:47.320, Speaker A: And so our whole role based access control system just fails basically. And here we're going to use the user's role and we're going to use another function, which is the add function also defined in the roles library. And this function takes two arguments. First argument is the user, but it's already given by the library. And the second argument is the address of the new user. So new user, and that's it. And to add a new admin, it's going to be almost the same thing.
00:39:47.320 - 00:40:28.630, Speaker A: So we replace add user by add admin. And here, you guessed it, it's not your user, it's new admin. Still, I got it by only admin. And instead of users, this is going to be admin, add new admin, very simple, admin with S. Okay, and to remove user and admins, it's going to be very simple, very similar. So let's copy this and let's paste this, and let's replace by remove user and remove admin. So same thing.
00:40:28.630 - 00:40:56.446, Speaker A: The remove user takes a single argument. So instead of new user, that's old user. And here we replace add by remove, a new user by old user. And in remove admin, same thing. So new admin becomes old admin, and instead of add is remove. And instead of new admin, it's old admin. So now we can add user and admin and also remove them.
00:40:56.446 - 00:41:49.834, Speaker A: And the last thing we need to do is to create an initial admin. Because if we just leave the contract like this, then basically there won't be any user, any admin because at the beginning we don't have any admin. So at least we need to begin with to have one admin so that we can start to add user and add admin. So in order to do this, let's create a constructor function. This is going to be a public constructor and we're going to add an initial admin. So admin, add, and we add the creator of this contract, basically that's our initial admin, and now our role based access smart control is finished. So as you can see, with this system, you can implement a much more sophisticated access control system for your smart contract.
00:41:49.834 - 00:42:36.938, Speaker A: And as a bonus, you make use of the open Zeppelin library, which is always better than rolling out your own access control system. So in this video, we actually learn a lot about access control in solidity. So let's have a quick recap of what we learn. So first I explain you what is the difference between authentication and authorization? And especially I compare this with web application. So in web application we do authentication with username and password in general, whereas in blockchain, and especially in solidity, the way we do this is we use the private key of users. And the Ethereum blockchain already guarantee you that the address inside the MSG sender variable is the sender of the transaction. You as the programmer of a smart contract, you don't have to do anything for doing authentication.
00:42:36.938 - 00:43:09.026, Speaker A: Ethereum blockchain already takes care of it. So that's a big, big win compared to traditional web application, and that is way more safe. Then you still have to do authorization. So authorization is after a user has been authentified, you still need to make sure that this user has the right to perform the action that he wants to do. And in order to do authorization, I gave you four recipes. So these are these four things that we saw after in the video. First we saw how to do basic access control in solidity.
00:43:09.026 - 00:43:52.026, Speaker A: So that's where you define only admin modifier and you compare the sender of the transaction with what you have in the admin variable. So that's the most basic way of implementing basic access control in solidity. And if you look at smart contract for a while, you've probably used that already. Then you have the ownable pattern with openzepling, which is almost the same thing as the basic access control, except that in this case you use the smart contract of openzepling. And also thanks to the ownable smart contract, you can use some extra function. Then we saw the secondary pattern also with open zeppelin. So this is to implement access control between two smart contracts.
00:43:52.026 - 00:44:42.194, Speaker A: So typically you'll have a factory smart contract that creates some child contract, and each of this child contract is only, some of their function are only callable by the factory contract. So you can use the secondary contract of openzepling to implement this really easily. And finally, what we just saw is how to implement a role based access control also with openzepling. So that's really the most sophisticated way of doing access controls. So you define a couple of roles, then you use the roles library, and then you can have a really fine grained control where you have some function that are allowed for a certain category of user and other function that are allowed for other category of users. There is a last thing that I like to tell you about how to integrate access control in solidity. If you already have an access control system outside of the blockchain.
00:44:42.194 - 00:45:24.762, Speaker A: So let's say you already have a database with username and password and you also want to use solidity in your application. So how you can do this. So what you could do is in your centralized database you can basically have a table where you associate Ethereum addresses to username. And so in your centralized application you keep identifying your user with username and password, but on the blockchain you use the ethereum address. Alternatively, you could get rid of the password altogether. And in your centralized application, when you ask your user to log in, you can basically ask them to sign a message with their private key. If they are able to successfully sign this message, then it means that they're actually the owner of this private key and so you let them access some protected resources.
00:45:24.762 - 00:45:31.170, Speaker A: But that's something really, really advanced. I hope that you guys learned a lot in this video and we're going to stop here. Thanks for watching. Bye.
