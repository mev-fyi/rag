00:00:00.330 - 00:00:23.694, Speaker A: Who is going to win the US election? Is it going to be the orange man or sleepy Joe? The blockchain will tell us in this video. I'm going to give you a full tutorial to code a prediction market for the US election by using the Ethereum blockchain. A prediction market allow you to bet on future events. By using the relative amounts that were bet, you can estimate the probability that.
00:00:23.732 - 00:00:25.798, Speaker B: A certain outcome will happen or not.
00:00:25.884 - 00:00:58.154, Speaker A: With our prediction market, you will be able to bet that either Trump or Biden will win the US election. Our prediction market will be implemented as a smart contract on the Ethereum blockchain in a decentralized way. Once our prediction market is deployed, nobody can stop it. It will run forever on the blockchain. The results of the election will be reported to the spot contract by an external entity that we call an oracle. We are going to code the spot contract, write the test, and code the front end. For smart contracts we are going to use solidity and truffle.
00:00:58.154 - 00:01:53.706, Speaker A: For the front end we are going to use react and bootstrap. It's better if you have some basic understanding of web development and how Ethereum work, but even if you don't, you can still probably follow along. If you don't know me, I'm julian and on my channel eat the blocks. I teach DFI and blockchain development and if you want to learn how to become a professional blockchain developer who makes $100,000 a year, register for my free training down below. So let's see what is the architecture of our application. So our prediction market will have a single smart contract deployed on the Ethereum blockchain. At the beginning of the process, gamblers will bet on a candidate, Biden or Trump by sending some ether to the prediction market smart contract each gambler can pick any arbitrary amount of ether to gamble.
00:01:53.706 - 00:02:39.998, Speaker A: The more you gamble, the more you will win. If your candidate wins. After the election, an oracle will report the result of the election to the prediction market smart contract, which will send against to the winning gamblers. If your candidate wins, you get back your initial stake plus a share of the stakes of the loser pool proportionally to your ether investment in the winner pool. As for gamblers who lost, they don't get anything back. For the Oracle, this is just an address that sends a transaction to the prediction market smart contract and on top of the prediction market smart contract, we will also have a web front end so that end user can easily interact with our smart contract. Okay, so that's it for the architecture of our prediction market.
00:02:39.998 - 00:03:14.806, Speaker A: So next we are going to start coding smart contract. So in order to code our smart contract, you need to install a couple of development tools. So first you need to install node JS. So you go to the website of node JS and you install the LTS version. Then you need to install truffle. Truffle allow you to develop solidity smart contract very easily. It comes with a local development blockchain that you can use to develop and test your smart contract in safe sandbox totally isolated from Mainnet.
00:03:14.806 - 00:03:59.542, Speaker A: So in order to install truffle, you go to your command line and you can install it with the NPM package manager that was already installed when you installed node JS before. So you install truffle globally like this. And after that you can initialize a truffle project like this in your project folder. So we're going to have a look at the different files and folder that were created. So in the contracts folder you will have all your sodt smart contract. In the migration folder you will write migration file that will explain truffle how to deploy your smart contract to the blockchain in the test folder. That's where we will write our test for our smart contract.
00:03:59.542 - 00:04:15.470, Speaker A: And finally in truffle config, that's where we will configure our truffle project. And next we are going to open the configuration file and we're going to scroll down and we're going to change.
00:04:15.540 - 00:04:17.934, Speaker B: The version of three DT that is used.
00:04:18.052 - 00:04:56.730, Speaker A: So we're going to use three DT 0.7.3, that's the latest version of three DT at the time of recording this video. So after we are going to create our prediction market smart contract in the contracts folder. So we create a new file called Predictionmarket Sol and we start with the pragma statement to tell CDT which version we want to use. 0.7.3 after we create a smart contract with the contract keyword.
00:04:58.990 - 00:05:37.518, Speaker B: So first we are going to define the address of the spot contract. After we're going to declare the constructors. That's the function that is executed when the spot contract is first deployed. And as an argument of the constructor, we're going to pass the address of the oracle. And after we are going to create another function to create a bet. So we're going to specify which side we want to bet on, Biden or Trump. So for that we going to create what we call an enum.
00:05:37.518 - 00:06:19.106, Speaker B: So it's basically like an option that can have different value. So it's going to have two possible value, Biden and Trump. And after we make this external and payable, because we going to pay for our bet in ether. So first, we want to make sure that the election is finished. So in order to do this, we're going to have a state variable boolean that tell us if the election is finished. And here we're going to require that the election is finished. The election is not finished, sorry.
00:06:19.106 - 00:06:54.590, Speaker B: And the error message is election is finished. If you try to place a bet after the election, it's not possible. And after we going to save the value of the bet. So we need to keep track of the bet at two levels. So first, we need to keep track of the bet globally and also per gambler. So let's start with the global bets mapping. So this is going to be a mapping that maps each side, biden or Trump, to the total amount of ether that was bet on that candidate.
00:06:54.590 - 00:07:20.614, Speaker B: And we call this bets. And we also have another mapping for each gambler. So it maps the address of the gambler, map this to a nested mapping for each gambler. We know which side he has bet on. And this maps to the amount that was bet public. We call this bets per gambler. And after we'll be able to update these two values.
00:07:20.614 - 00:08:07.974, Speaker B: So first, the global bets mapping, we increment the total element that was bet on that, and as well as the bets per gambler. Okay, so now we can place a bet. So next, we need another function to restraw the gain after the bet is finished. So we call this restrain, make this external. So it's going to be called individually by each gambler. We could have had another mechanism where when the smart contract received the result of the election, it just distributed the fund to all the gamblers. But the problem of this is that it doesn't scale well in terms of.
00:08:08.012 - 00:08:09.174, Speaker A: Gas, because if you have a very.
00:08:09.212 - 00:08:52.310, Speaker B: Large number of gambler, it's going to make the execution of the function really expensive. So instead, each gambler will have the responsibility to call this withdrawal function to withdraw his or her own gain. So first we need to extract the bet of the gambler who is calling this function. So, bets per gambler. We use this mapping, we reference the calling address, and after we're going to reference the winner of the election. So in order to do this, we need to have another variable. So first, we're going to define a struct result with the winner and the loser.
00:08:52.310 - 00:09:40.626, Speaker B: You can have an NM inside a struct in solidity as you can see after, we're going to have an instance of this truck that we call result scroll down and here, so rereference the winner. So in order for this function to be executed, we need to have a winning bet. So gambler bet. Here is the winning bet. Here we have selected the winner of the election. So we want the gambler bet to be superior to zero. Otherwise the error message is you do not have any winning bet and we also need the election to be finished.
00:09:40.626 - 00:10:17.790, Speaker B: Election finished true. And the error message is election not finished. And after we're going to calculate the gain of the gambler. So first the gambler is going to get back his initial stake. So that's gambler bet. Plus he is going to have a share of the pool of the loser proportionally to his stake in the winning pool. So for that we select the loser pool result loser.
00:10:17.790 - 00:10:52.480, Speaker B: And then we need to multiply this by the share of the gambler in the winner pool. So for that gambler bet divided by the winner pool. And after we're going to update bets per gambler to zero so that it's not possible to withdraw again several times. Otherwise you can cheat the system. Let's put this Q value to zero.
00:10:54.050 - 00:10:56.990, Speaker A: And finally we transfer the winning.
00:10:57.330 - 00:11:31.260, Speaker B: So we use the gain variable that we just computed before and that's how you can restrain your gain. And next, we also need to create a function to report the result of the election. So that's the oracle address that's going to call this function. So we call this report result. It's going to report the winner and the loser. So first we need to make sure that only the oracle can report the result. Otherwise anybody can cheat the system.
00:11:31.260 - 00:12:14.150, Speaker B: And in the result struct, we're going to update the winner and the loser, and the election is finished. Okay. And we can also add a condition that in order to report the result, the election must not be finished. We cannot report twice selection finish equal false. And the error message is election is already erection is finished. So let's make sure that everything compile. Truffle compile an error.
00:12:14.150 - 00:12:38.590, Speaker B: Okay, there is a typo election finished here. Okay, let's try to compile again. Truffle compile. And it works great. So this is all you need for our prediction. Smart contract. And next we're going to write the test for our contract.
00:12:42.850 - 00:13:31.130, Speaker A: Next we are going to write the test for our smart contract. So it's very important to test your smart contract because once you deploy to the Ethereum blockchain, there is absolutely no way to update it. So if there is any bug, there is no way to fix it. So in order to write our test, we will create a test file inside the test folder. So we're going to write a test with the same name as our smart contracts predictionmarket Js because this is going to be written in node JS and not in solidity. The first step is to import what we call a contract artifact. So a contract artifact is an object that is created by the truffle framework that can help you to test and interact with a smart contract.
00:13:31.130 - 00:14:38.698, Speaker A: So we're going to call this contract artifact prediction market and we can get it from artifacts require and after we pass the name of our smart contract predictionmarket Sol and this artifact object is injected by truffle in our test file. After that we're going to create a contract function. So that's how you wrap all your test and you give it the name of your smart contract prediction market and it's going to accept a callback. And this callback is going to receive as argument a list of addresses. So this list of addresses, these are all the addresses that are generated by the local development blockchain used in the truffle test. So these ten addresses each have 100 fake ether in them. And we'll be able to use any of this address in order to send our transaction.
00:14:38.698 - 00:15:16.526, Speaker A: So that's very, very convenient. So we are going to extract a couple of these addresses. So the first one is the admin, then Oracle, then we're going to have four gambler gambler 1234. And for the rest we're going to ignore it. And we're going to extract everything from this addresses array. Okay, so after that we are going to write our test. So in a contract block you can have several tests.
00:15:16.526 - 00:15:42.730, Speaker A: And each test is inside a it block. And in it block, first you need to specify the name of the test. So here we're just going to have a single it block. So I'm just going to write should work. And after it's going to have a callback. So I make the callback async so that inside I can use the await keyword for asynchronous operation. And that's where we will write our test.
00:15:42.730 - 00:16:33.050, Speaker A: So the first step is to deploy an instance of our prediction market contract. So we going to do this with the prediction market artifact we created here. So the way we're going to deploy this, we use predictionmarket new and we need to pass the argument of the constructor. So that's the address of the oracle. So here, just to be clear, so this prediction market has an uppercase p, but here our variable has a lowercase p. So with this truffle artifact, we can create new instance of our smart contract. And in our other variable here, prediction market with a lowercase p, that's a single instance of our smart contract.
00:16:33.050 - 00:17:35.018, Speaker A: And after that with this variable, we can interact with our smart contract. So we are going to place some bet. So prediction marketplace bet, and it's going to take two argument the side of the bet, so Biden or trump, and then we're going to specify some other parameter for the transaction. So we're going to create a variable to help us for the side. So create a JavaScript object. So if this is for Biden, the value is zero, and for Trump this is one. And after we use this in our function here, so we're going to place a prediction bet for Biden, and after we customize the transaction, so we can customize the sending address, so we send it from the first gambler, and we also need to send some ether.
00:17:35.018 - 00:18:28.510, Speaker A: So for that we use the value key. So in ethereum, we don't specify ether, just with the unit of ether directly like this, but instead we use a unit called way. So one ether equal ten power 18 ways, basically a lot of zero. So one way is like a sort of very small cent of ether. And so in order to easily manipulate this, we can use Webster utils two way, and it's going to convert an ether value into way. So here if we put one, actually this is going to be ten power 18, it's going to be 123-12-3123, et cetera, with 180 total. So that's how you send one ether to the place bet function.
00:18:28.510 - 00:18:57.270, Speaker A: And once we have this, we're going to place all the bet for other gambler. So we're going to have gambler two, then gambler three. Gambler three is also for Biden and it's going to send to ether. Finally, we're going to have gambler four, and gambler four is going to be.
00:18:57.340 - 00:18:58.460, Speaker B: For Trump.
00:19:00.590 - 00:19:42.914, Speaker A: And it's going to send for ether, okay? And after that the oracle is going to report the result. So prediction market report result. And so first the winner. So for example, we can say Biden, the loser trump, after we customize the transaction. And the sending address is the oracle. If we try to report the result with another address, it's going to fail because we have added a required condition in our smart contract.
00:19:43.042 - 00:20:27.334, Speaker B: And after we are going to withdraw again for all the gamblers. So we have to do this four time. So we're going to use a trick to reduce the line of code we need to write. So for that we can do await promise all. So that's a way to do several asynchronous operation in parallel. And so we need to define an array of all the asynchronous operation we want to send. So we create an array with all our gambler up to gambler three, so only the gambler that have actually won something, so gambler four have lost, so you won't get any money.
00:20:27.334 - 00:21:04.894, Speaker B: And for each of this value, we're going to execute a function. So here, map basically iterates through the array, and for each of this value it's going to execute a function. So this function is going to receive the current gambler. So for the first iteration it's going to be gambler one, then gambler two, then gambler three, and then we're going to define the function we want to execute. I don't want curly brace, actually, I want parentheses. So basically when you do this, this is a shorthand notation. It's as if you have a written statement directly.
00:21:04.894 - 00:21:55.140, Speaker B: So anything I put here, this is going to be returned by the callback function. And we're going to call the withdraw gain function, predictionmarket withdraw gain. And the sending address is the gambler. And after that we need to verify that the winner have received their money and that the loser actually lost their money. So for that we are going to compare the ether balance of these gamblers after and before they withdraw their game. So first the balances before balances before this is going to be an array of all the balances of all the gambler. And we also going to use promise all.
00:21:55.140 - 00:22:45.210, Speaker B: And so inside we're going to have another array with all the gambler 1234. Okay. And after that, once again, we use the map function for each gambler. We're going to execute this callback function and this is going to return this statement. Webster get balance this is a function to get the ether balance for any address and we pass the gambler. So I think before I haven't introduced Webster. So Webstery is a JavaScript library that you can use to interact with the Ethereum blockchain, and this is automatically injected in our test file by the truffle framework.
00:22:45.210 - 00:23:29.694, Speaker B: So here for the balances before variable, this is going to be an array of all the ether balance of all the gambler. But there is something you need to know about numbers in Ethereum so when you return number from Ethereum, these numbers can actually be bigger than the biggest number that you can represent in JavaScript. So in order to solve this problem, the Webster library return this number as string. So here we're going to have a balance of string, not a balance of number, but we will need to do some operation on these numbers. But if we keep it as string it's not going to be easy. So we need to transform these strings into another representation. So we cannot transfer them into JavaScript number because this is going to be too big.
00:23:29.694 - 00:24:24.346, Speaker B: So instead we're going to use the BN JS library, which is a JavaScript library, to represent big number in JavaScript. And this is provided in Webstery. So for each result. So here actually we've forgotten a weight keyword. So we wrap everything into a parentheses and we're going to iterate through all these strings and transfer them into BN Js. So balance here we're going to transform this with Webstery utils to BN, and now we're going to have an array of BNJs instead of an array of string, and we're going to do the same for the balance after. So balance is after okay, and after that we're going to run our assertions.
00:24:24.346 - 00:25:02.170, Speaker B: Assertions are really the core of our test. So these are condition that you check, and if the condition is true then your test passes. Otherwise, if the condition is false then the test fails. So what we want is to make sure that the winner have received their money first. So balances after zero. So that's basically gambler one, and we want to subtract this with the balances before. So where does this sub function come from? So this comes from the BN JS library.
00:25:02.170 - 00:25:55.262, Speaker B: This is this library that we are using to represent our number. And after this subtraction we convert this to a string. So this is going to be a big string and we're going to take the first three digit, and this should be equal to one nine. Nine. So this gambler must have received two ether, so why is that so? Originally we sent one ether with this gambler, so he's going to get his initial stake back plus his share of the loser pool. So the loser pool is four ether in total, and the weight of the first gambler in the winner pool. So that's one over four total.
00:25:55.262 - 00:26:41.214, Speaker B: So that's 25%, so 25% of four, this is one. So initial stake plus one ether coming from here, this is equal to two ether, but not so fast, because in order to withdraw its gain, this gambler also had to spend some gas for the transaction fee. So he won't have received exactly two ether. But it's going to be slightly less, it's going to be two ether minus the transaction fee. So that's why we have one nine nine here for the beginning and not you. So basically this little trick that you see here, this is to accommodate for the gas fee, okay? And after we're going to also run assertion for the other two winner. So gambler two.
00:26:41.214 - 00:27:20.854, Speaker B: So this also should have received two ether. Gambler three, should have received four ether. So that's three nine nine when you adjust for gas fee. And finally, we need to make sure that the loser hasn't received anything. So he basically lost all his stake. So balances after three, sub balances before three, two, string. Oh no, we don't need to convert to string.
00:27:20.854 - 00:27:49.170, Speaker B: We can use a function of the dnjest library to make sure that this is zero. So this is zero. Okay. Oops, I realized that my index in here is completely off. So balances before of zero here, this is one. Okay, so now we going to run our test. So we open the terminal and we run truffle test.
00:27:49.170 - 00:28:32.602, Speaker B: And normally everything should work fine. And yes, it works great. So now thanks to our successful test, we know that our smart contract works like it's supposed to. In the next section we are going to build the front end for our prediction market so that end user can easily interact with our smart contract. So now we're going to start to code the front end. So let me close the terminal and close here this file. In order to do our front end, we need to pick a framework.
00:28:32.602 - 00:29:10.002, Speaker B: So we're going to choose react because that's the most popular front end framework and that's very demanded on the job market. So that's very useful too. So it can be a little bit difficult to set up a react project. So we're going to use another project called Create React app. That's basically a way to quickly set up a react project without wasting too much time with the detail of bolloplate code. So you need to install create react app first. For that you open your terminal and you can install create react app with NPM.
00:29:10.002 - 00:30:01.498, Speaker B: So install global create react app. And after you can create your react application very easily with create react app and you give it the name of the folder. Okay, so now you can see that we have a new folder front end. So that's our react project and all our front end code will be in the SRC directory. But before we need to change a configuration in truffle. So in our front end we will need to import a json document about our smart contract. So currently that's in build contracts folder.
00:30:01.498 - 00:30:46.858, Speaker B: So we're going to need to import this predictionmarket JSON. But react doesn't let you import some files that are outside of its folder. So we need to change the configuration where truffle output buildcontract. So to do this you go to Truffleconfig, let me close the terminal and truffle config. You scroll up and at the top we will add our configuration. So contracts build directory and this is going to be front end SRC contracts. Okay, here comma, okay, very good.
00:30:46.858 - 00:31:24.882, Speaker B: So after we're going to install a couple of front end dependencies. So you open the terminal and we go in front end. And first we are going to install bootstrap. So Bootstrap is a CSS framework to make your front end nicer. And this is especially useful for developers who don't want to spend too much time in improving the design. So we're going to install it with NPM install bootstrap and we're also going to install ethers, which is a JavaScript library to interact with the Ethereum blockchain. So this is different from Webstery.
00:31:24.882 - 00:32:20.582, Speaker B: So Webster and ethers have the same functionalities, but ether is a more modern alternative and it's gaining way more traction in the community. So let's install these two packages. Okay, so we are done with this. So next we're going to do some cleanup in front end src. So there are a lot of things that we actually don't need. So logo SVG service worker setup test index CSS app test JS app CSS okay, so now you just have index CSS and app Js. So let's open index Js.
00:32:20.582 - 00:33:06.678, Speaker B: So we donate this part here with the service worker must donate the CSS file donate service worker so we need to import bootstrap here. So we're going to do this like this bootstrap. And inside the folder, this CSS, there is a file called Bootstrap min CSS. So that's how you import the framework. Okay, and after in app Js we're going to remove this thing. Let me remove everything here. Hello.
00:33:06.678 - 00:33:50.370, Speaker B: Okay, so we have finished our cleanup so we can finally start the actual coding. So first we need to handle the connection with the Ethereum blockchain. So for that we're going to create a new file in the SRC directory. We're going to call this ethereum Js. So first we're going to import the ether's library. There's also an object called contract from this library we're going to use, and we're also going to import a json document that's going to give us some info about our prediction market. We're going to need it to interact with the prediction market spot contract.
00:33:50.370 - 00:34:55.494, Speaker B: So this is in contracts predictionmarket JSON. And the reason why this is located in this path is because if you remember just before we made some change in truffle config to output this json document at this location. And after we're going to create a function, get blockchain, that's going to give us what we need from the blockchain. We're going to export this function, get blockchain. So it's going to return a new promise. So a promise is a JavaScript object to handle asynchronous event, and it has a callback function with two method resolve and reject. And inside your callback, basically you need to call resolve when you have grabbed everything you need from the network or if there was an error, then you call reject.
00:34:55.494 - 00:35:44.278, Speaker B: And after we say that this promise, resolve and whatever code was waiting for, this promise can finally be executed. So first we need to wait that everything has been loaded in your web browser. So we wait for the load event, and after that we're going to execute this callback function. And we want to test if metamask was injected. So if you never heard of metamask. So that's basically an Ethereum wallet that is distributed as a chrome extension. That's where user will keep their private keys in their browser and they will use metamask to sign transactions.
00:35:44.278 - 00:36:50.910, Speaker B: So when metamask is installed, it injects an object called Window Ethereum. And first we need to wait for metamask to approve our decentralized application. So you will see a pop up of metamask that say hey, do you want to allow this application to access your wallet? And once we have the approval of the user, then we can finally instantiate what we call a provider. So that represents a connection to the Ethereum blockchain. So we do this with ether providers, Webster provider, and we pass it window Ethereum. And after we're going to need a signer object so we can get this with provider get signer. So this is something that is specific to the ethers library and we're also going to need the address of the signer.
00:36:50.910 - 00:37:32.790, Speaker B: So signer, get address. And after we are going to instantiate an ethers contract object. So that's a JavaScript object that is used to interact with the prediction market contract. So for that we use the contract object from ether. And it's going to take a couple of arguments. First, it needs to know the address of the prediction market on the blockchain. So for this we use the json document, we import it from here predictionmarket networks, and we need to reference the current network.
00:37:32.790 - 00:38:19.450, Speaker B: So you have different network on Ethereum, you have main net, that's basically the real Ethereum network, but you also have a local development blockchain, public testnet, et cetera. And each of them have an identifier and we can find it in window Ethereum network version. And after that we need to grab the address in the json document. Okay, next, still using this JSON document we need to grab the ABI. So ABI is a description of the interface of our smart contract. So the interface is the set of solidity function that you can call from outside the smart contract. So basically all the public and external function.
00:38:19.450 - 00:39:00.474, Speaker B: And finally we need to pass this signer object here. With this prediction market object we'll be able to read data, but also send transaction to this smart contract. And after we are going to resolve the promise. So we pass in an object signer address prediction market. Okay, so we save this and we come back to app JS. So at the top we'll need to import a couple of stuff. Use state, use effect.
00:39:00.474 - 00:39:35.922, Speaker B: I'll explain after how it works. We're going to import get blockchain from the Ethereum file that we just created. Okay? So after I'm going to give a very quick explainer of how a react application work. So in react, you can divide your UI into different components and each component is associated to a function here. These components are actually hierarchical. So you have a parent component. So that's the one that you see here.
00:39:35.922 - 00:40:13.220, Speaker B: And this parent component itself can have some child component and this child component can also have some child component, et cetera. In our case it's going to be a simple react application. So it's only going to have a parent component here, single parent component. So in this function, in your written statement, that's where you will render the HTML and before the written statement that's how you are going to manage your data. So in a react component we can have some states. So state is basically data that is associated with this component. So we need to define this state.
00:40:13.220 - 00:40:53.274, Speaker B: So part of our state is going to be our prediction market smart contract. So that's what we created in Ethereum Js and here we I'm going to explain what is this array. So set prediction market. So when you define a state, you use the use state function of react and you give it an initial value. So initially this is undefined. So this thing here, prediction market, this is undefined. And here in this array, the second thing that you name, this is a function.
00:40:53.274 - 00:41:46.714, Speaker B: So that is created by use state and this is used to modify the value of this. So anywhere in your function when you want to modify prediction market, you do set prediction market with your new object here. And after that your component is going to be reloaded and the prediction market here is going to have this new value and your HTML here is going to be rerendered. So you have this system of state that is managed by react and that you can update at any time and that trigger a rerender of everything. Oh, here it's prediction. Okay, so we have another state which is the bets that were done by the current address. So we're going to call these my bets and then set my bets.
00:41:46.714 - 00:42:38.266, Speaker B: By the way, these two things here, you can name them however you want, but it's a good convention for the setter function to prefix it by set. And again we use use state and initial value is undefined. Okay, so now we need to execute the get blockchain function. So we want to execute this function only once when our component is first loaded in our web browser. And in order to do this we use use effect. So use effect as a callback as well as an array of states. For example here, if you put my bets, it means that every time the state my bets is updated, then it's going to run what is inside your use effect callback.
00:42:38.266 - 00:43:35.490, Speaker B: But if you want to run use effects only once when the component first load here you give an empty array. If you have used the old API of react, it's basically like component did mount. Okay, so after that we going to define an async function and call it right away. So the reason we have to do this indirection and we cannot directly have an async callback is because basically use effect does not accept an async callback. So yeah, that makes the code a little bit more convoluted but there is no choice. So after we're going to execute the get blockchain function and we're going to get signer address and prediction market. So we call it get blockchain.
00:43:35.490 - 00:44:19.598, Speaker B: So we get these two things back from get blockchain and we need to construct my bets. So this is going to be an array with the two bets of the current address. So the bets for Biden and the bets for Trump. So for that we use promise all because we're going to do two call at the same time. So we use the prediction market pointer and we call bets per gambler. So that's a function of our smart contract. So to be exact, we did not define this function, but we have a mapping of the same name, which is public.
00:44:19.598 - 00:44:44.310, Speaker B: And when you have a public variable in solidity, it automatically creates a getter function. And so here, since this is a nested mapping, our getter function will have two arguments. The first one for the outermost key and the second one for the innermost key. So the outer key is the address. So here, this is a signer address. And second, this is the side. So Biden or Trump.
00:44:44.310 - 00:45:41.386, Speaker B: So let's define an object helper object. Here, Biden, the value is zero and trump, the value is one. Okay, so here, side biden, not comma and after same thing, but for Trump, side trump. Okay, and so now we have our bets. So we're going to save prediction market and my bets into the state. So first set prediction market, prediction market, and after set my bets and my bets. Okay, so after, now we have our state.
00:45:41.386 - 00:46:39.062, Speaker B: We need to make sure that we're not going to render our application if we don't have all our state loaded. So for that we can use an if statement. And if type of prediction market is undefined, or if the type of my bets is undefined, then we just return loading. Okay, so next we'll be able to start our HTML. So here we going to put a class of container. So this class, this is because of bootstraps. That will allow us to set up a good layout.
00:46:39.062 - 00:47:15.080, Speaker B: So bootstrap you have container, then you have row. This is a grid system and in this row you have column. So we want a column that span the whole width of the row. So let's call on SM twelve. So there are actually twelve column in the grid system of bootstrapped. And we going to have a title. So we center it and call this prediction market.
00:47:15.080 - 00:48:05.094, Speaker B: And after the title we're going to have an element called a jumbotron. So that's a class also that is given by bootstrap that allow you to do a nice header or jumbotron here with the B. And inside this jumbotron we're going to have another title. So here I've just basically copy pasted some code from bootstrap example on their website. And here this is going to be who will win the US election. Okay, so now we have our headers. So after we're going to create two button to place a bet on Biden or on trump.
00:48:05.094 - 00:48:40.446, Speaker B: So there is really a lot of HTML code and it would really take forever to type myself. So I'm going to copy paste from the GitHub repo of ewlocks. So this is the URL of the GitHub repo. You go in screencast and this episode is 244. And we go in front end src app Js. Let's scroll down. Okay, so let's copy here this path.
00:48:40.446 - 00:49:09.930, Speaker B: So this is basically just below the header we just did. So let's paste this. Okay, so let me explain what's happening here. So we have a bootstrap row, bootstrap column. So this time this is a bootstrap column of six because we're going to have two columns, one for trump, one for Biden, after we have a bootstrap card. So this will give you a nice formatting. After I put an image of Trump.
00:49:09.930 - 00:49:52.790, Speaker B: So you'll find the image in the GitHub repo, after we have the body of the card, that's where you will find the button to place a bet. So here I define an HTML form and this is an inline form so that we can have the button next to the input. So here we need an input to specify what is the amount of ether that we want to bet. And after a button to actually place the bet. And when we click on this button, it's going to call the unsubmit, it's going to trigger the unsubmit event. And after it's going to call this function place bet. And this function is going to actually place the bet on our smart contract.
00:49:52.790 - 00:50:25.218, Speaker B: So we need to create this function. So I scroll up here, we define this function place bet. It has two argument, the size of the bet and the event. So first we need to prevent the form from the HTML form of being submitted. Otherwise we're going to have a full page reload. We don't want that. After we are going to call the place bet function on the prediction market object.
00:50:25.218 - 00:51:03.762, Speaker B: So place bet. And it wants to know the side of the bet. And when it comes to the value of ether, then we can use the input of our form. So e target. Basically this is the event object that is written by the react framework and we can access all the input with elements. And this is the first of the array and we want the value attribute. Okay, so with that we are able to place a bet.
00:51:03.762 - 00:51:45.470, Speaker B: So next we're going to grab the HTML code. So here we have done the bet for Trump, but we also need the same for Biden. So we go back to GitHub and below what we have copied, we'll find the HTML for Biden. Okay, so here it's going to be easy to be confused with the HTML. So this row here, it ends here. Okay, so here we pest Biden. Okay, let me indent this properly.
00:51:45.470 - 00:52:27.230, Speaker B: All right. Okay, now we have our HTML for Biden. And oh, here we don't have the on submit code. So let me copy this. Okay. On submit inside Biden. Okay, well let me scroll up and I think we are missing a closing div here.
00:52:27.230 - 00:53:02.810, Speaker B: Yeah, this indent are so confusing. Div, div call. Yes, actually this one needs to be indented on the left. Yeah, this is really the thing I hate with HTML, like playing around with the indentation of HTML. Okay, so I fixed my HTML. Okay, so now we can bet on Trump or Biden. So next we need to show the bet that we're done with the current address.
00:53:02.810 - 00:53:50.790, Speaker B: So we're going to have a new row and we're going to call this your bets. And this is going to be a list and we're going to show the bet for Biden and Trump. So Biden first. So we go in my bets and we transform this into a string. So the first element of the array is for Biden. And this is in ether, but in terms of way then need to close this and same thing for Trump. My bets one.
00:53:50.790 - 00:54:37.040, Speaker B: Okay, so now we can see our bets. And after that we need to create a UI in order to withdraw again once we know the election result. So this is going to be another div, another row and we're going to call this claim your gains, if any, after the election. So this is going to be a simple button, nothing fancy. Here, call this submit. So it's going to have a cop of argument of attributes. So type of button is submit class names.
00:54:37.040 - 00:55:03.810, Speaker B: So this is going to be the class name from bootstrap. Button primary. So you have button. Secondary, you have different type of button. This gives you different color. And this is MB's margin, bottom two. And when we click this button, we're going to call a function called resin and we're going to call, going to create this function.
00:55:03.810 - 00:55:52.584, Speaker B: So let's scroll up below here, create this function. Redraw again, make it async wage prediction market res draw again. So here, this is very easy, there are no arguments. Okay, so this is pretty good already. And the last touch is I like to show where the proportion of money that was bet on Biden or on Trump. So that's basically the core of the prediction market because based on that you will know what's the most expected outcome. For that we'll need a pie chart.
00:55:52.632 - 00:55:54.396, Speaker A: So we can use a library that.
00:55:54.418 - 00:56:33.180, Speaker B: Is called chart Js. So they have many charts available that you can do in JavaScript and one of them is pie chart. And since we are using react, we're actually going to use what we call a react binding. So that's basically a thin wrapper above the chart Js library that allow you to easily use chart JS library in a react application. So this is the GitHub page of this wrapper I just mentioned. So we scroll down and here we can see installation instruction for NPM. So I'm going to copy this and back to my code editor.
00:56:33.180 - 00:57:27.980, Speaker B: I open the terminal and in the front end folder I'm going to execute this NPM install instruction. Okay, so back to our code. And now we need to first fetch the current bets in the use effect callback. So for that we're going to use a promise because there are two sides. So the bets for Trump and the bet for Biden. So prediction market and we can call the bets function. So bets is a mapping, but exactly like for bets per gambler, since this is a public mapping, there is a getter function that was automatically created by solidity.
00:57:27.980 - 00:58:10.120, Speaker B: We just need to give it which side we want. So Biden and Trump. And after we need to format this data in a format that is suitable for the react JS library that we're going to use. And so I prefer to copy paste from my GitHub repo because this is a little bit tricky. So yeah, you go in front end src app Js, so same file. And here you will see this object bet prediction I'm going to explain. Okay, so this is this object.
00:58:10.120 - 00:58:39.028, Speaker B: So you define the labels of your pie charts or Trump and Biden. Then for the data set. So you need to define the data. So we take the result from our smart contract here. We transform this into a string and we specify also the background color. And at the end we're going to save this. So we're going to call this bet prediction and we need to define the state as well.
00:58:39.028 - 00:59:31.430, Speaker B: Bet prediction. So above here, let's copy paste this bet prediction and set bet predictions. Okay, so let's scroll down. And here we need to add a condition for loading. Also want to wait for bet prediction to be different from undefined. And we also need to import PI object from chart JS. So import PI from react chart Js two.
00:59:31.430 - 01:00:11.328, Speaker B: Okay, so now we can use this PI component very easily. So we scroll down and below here in the jumbo tron, we're going to create a paragraph for the current odds. This is the class of bootstrap text center current odds. In a div we render the PI for the data attribute. We pass bet prediction. Okay, and we close it.
01:00:11.494 - 01:00:54.860, Speaker A: Okay, so now our front end is finished. The next step is to deploy our smart contract to the blockchain. So in this section we're going to deploy our smart contract to the Ethereum blockchain. So we're not going to deploy to Mainnet, the real Ethereum blockchain, but instead we are going to deploy our smart contract to a local development blockchain similar to what was used when we run the test for our smart contract. So the first step is to write a migration file to tell truffle how to deploy our smart contract. So we're going to exit the front end inside migration. We're going to create a new file.
01:00:54.860 - 01:01:42.716, Speaker A: We're going to call this deploy contracts JS. And so first we're going to import the contract artifact of prediction market exactly like we did in the test before. So artifacts require prediction market saw. Okay, we're also going to define the different constant for Trump and Biden like we did before. Biden zero Trump, one rate. And after we're going to export a function that tells how to deploy our smart contract. We'll make it async we need to use await inside.
01:01:42.716 - 01:02:22.220, Speaker A: So it's going to receive an object deployer that we're going to use to deploy our smart contract. Then second argument network, we can ignore it. And then we're going to have an array of addresses that is available to us in the local development blockchain. This is exactly the same thing as for the test before. So once again we're going to extract a couple of addresses. So Gambler one, gambler two, gambler three, gambler four, the rest we ignore it. And all of this from addresses.
01:02:22.220 - 01:03:01.464, Speaker A: Okay, next we are going to deploy the prediction market. So we use the deployer object prediction market. And the first argument to the constructor, we give it after. So that's the address of the oracle. Then for the prediction market we going to wait that is actually deployed. So it's a bit confusing when you run this command deployer, deploy it, just start the deployment. But we need to wait for the.
01:03:01.502 - 01:03:02.724, Speaker B: Transaction to be finished.
01:03:02.772 - 01:03:54.120, Speaker A: So for that we do predictionmarket deployed. We do this in two step. And after we are going to place a couple of dates in the prediction market so that visually after when we're going to see the front end, we have something in the interface already. So here we want for example a bet from Biden, value one ether, okay, same thing for Gambler two, three, four. Then another gamble for Biden from gambler two. Then gambler three. It's going to be two ether.
01:03:54.120 - 01:04:42.152, Speaker A: Finally, Gambler four is going to be for trump one ether. Okay? And that's all we need to do. So after that we're going to open our terminal and let's go in the root folder of our truffle project. And we're going to run the truffle develop command. So it's going to start a local development blockchain and attach a console to it. Okay, and after we're going to execute the migrate reset command and it's going to execute our migration file just above. Okay, so our contract was deployed here.
01:04:42.152 - 01:04:49.296, Speaker A: We can see the log deploying prediction market and we can see the address of the smart contract.
01:04:49.428 - 01:05:34.244, Speaker B: So now that our smart contract is deployed, the next step is to try out our application in the front end. Okay, so to try our application in the front end, first we will have to install metamask. So metamask, as I explained before, this is an Ethereum wallet that is distributed as a chrome extension and users need this on the front end to use your decentralized application. So you go to the Chrome web store and you search for metamask and here you install the extension and after you will have to synchronize metamask with your local development blockchain.
01:05:34.292 - 01:05:36.056, Speaker A: So in your local development blockchain you.
01:05:36.078 - 01:06:30.864, Speaker B: Have ten addresses that are pre funded with some fake ether. And so we want to be able to use these addresses from metamask, otherwise we won't be able to send any transactions. So in order to synchronize metamask and your local development blockchain, you need to import the seed phrase of your local development blockchain into metamask. So the seed phrase, this is a series of words that were used in order to generate all the different addresses. So here this is cut off on my screen, but below the unlock button there is a link that said import using account seat phrase. So you click on that. And after you go back to your terminal and you scroll up and when you started the truffle develop command, at some point it gave you the mnemonic phrase.
01:06:30.864 - 01:07:00.892, Speaker B: So that's all the same thing as the seed phrase. So you copy this and you paste it here. So it might be a different seed phrase for you. Then you create a password restore. Okay, so next you need to connect metamask to the correct network. So here you click on custom RPC so you can give whatever name you want. And for the RPC URLs you can see this in your terminal.
01:07:00.892 - 01:07:38.850, Speaker B: So the terminal, you scroll up and here you can see the URL. So you copy this URL here and after the rest is optional, you click on save. So me, I've already have it. This is the Ganache network. And here you will see that you have close to 100 ether in your account. So in our deployment the first account was the admin, the second was Oracle, and the third one was the first gambler. So we're going to switch to the third one.
01:07:38.850 - 01:08:21.032, Speaker B: So for that you're going to need to create new account. So this is the oracle and we create another one. This is going to be the first gambler. Okay, and after you need to go in settings advanced and you need to click on reset accounts. So every time you start a new local development blockchain, do this operation reset. Otherwise metamask going to have some problem of synchronization. Okay, so now we have synchronized the local development blockchain with metamask.
01:08:21.032 - 01:08:54.596, Speaker B: So the next step is to start the server for the front end. So we're going to create a new terminal and we're going to go in the front end and we're going to run NPM start. Okay, so I have a typo in index Js. So here this is bootstrap. Then if you go to your front end, you're going to see this notification of metamask.
01:08:54.628 - 01:08:56.932, Speaker A: So if you remember in Ethereum Js.
01:08:56.996 - 01:08:58.932, Speaker B: At some point we call a method.
01:08:58.996 - 01:09:01.400, Speaker A: Called window Ethereum enable.
01:09:01.480 - 01:09:21.632, Speaker B: So this trigger, this pop up. So Metamask asks us if we want to give access to this account for this decentralized application. So we agree you can only view the addresses of your permitted account connect. And you should see this.
01:09:21.766 - 01:09:22.400, Speaker A: Beautiful.
01:09:22.550 - 01:09:58.440, Speaker B: So here you can see our pie chart where we use chart Js. So the majority of the better predicted that Biden is going to be elected and minority for Trump. And after we have our two button Trump and Biden. And actually the image is broken here. So I'm going to show you how you can fix this. So you go to my repo, you go to front end and you go in a public in IMG. And here, this is these two images.
01:09:58.440 - 01:10:36.640, Speaker B: Actually I want to show you how it looks. It's beautiful. So we're going to fix this. I'm going to go in front end in public, we're going to create an image folder and I'm going to copy paste these two images in my folder. Now if I reload everything. Yeah. So let me adjust a little bit the width.
01:10:36.640 - 01:11:23.852, Speaker B: There is probably some CSs to improve here because the image is a little bit deformed, but you can see how it looks like. So if you want to bet on Trump, then here you put the amount that you want to bet here. This is a mistake. This is not in ether, but this is in way, for example 100 way which is very small. You click on submit and here you have the confirmation of metamask and you click on confirm and below you can see your bets. And after when the election is finished and the result have been reported to the smart contract, you can claim your gain here by clicking on submit.
01:11:23.996 - 01:11:48.100, Speaker A: Congrats for following up to here. It's a pretty nice app we've built together. Now you know how you can implement a prediction market on Ethereum using solidity. Smart contract. You know not only the smart contract part, but also the test and how to integrate a web frontend. What to do next? In our implementation, we have to manually send the results of the election to the smart contract. That's not ideal.
01:11:48.100 - 01:12:29.470, Speaker A: It would be better if we had a script for doing this instead. I haven't found an API that gave the result of the US election, but one trick would be to pass the Twitter profile of Joe Biden after the election and see if it says president of the United States. For that, you will need to hit an endpoint of the API of Twitter and use what we call a regular expression to pass the Twitter profile of Biden. Another thing you can do is add a commission for every bet in the smart contract so that you can make some money with this project. If you want to keep building all the project in Defi, I have a whole playlist with tutorials for Defi apps. I'll see you there.
