00:00:00.250 - 00:00:30.758, Speaker A: Okay, developers, welcome back. Now, nobody likes to fail, but sometimes bad things just happen. In this video, we're going to look at some coding patterns that are going to allow us to fail gracefully when things do go wrong with our contracts. If you're new here, I'm Calvin Torah, and on eat the blocks, we help web two developers transition into web three. So let's get right into it. The first one is circuit breakers. These stop the execution if certain conditions are met.
00:00:30.758 - 00:01:05.710, Speaker A: In this example, we have a fake contract and we have a boolean that is like an on off switch or a circuit breaker. Then we have the owner that has admin rights. We set up the admin modifier so that they can perform special actions on the contract. We then have a function that allows us to toggle the on off switch. The admin modifier is applied so only one person can trigger this function. Then we have two more modifiers, stop in emergency and only in emergency when we use these as modifiers. The first one allows us to continue with our code as long as the Boolean stopped is false.
00:01:05.710 - 00:01:36.918, Speaker A: Nothing has been stopped, so let's keep going then. Only in emergency allows us to execute code only if the Boolean stopped is set to true. If we discover something wrong with our contract, the owner can trigger the circuit breaker and block any more deposits from being made. The same goes for the withdrawal function. If everything has gone wrong and we need to get the funds out of a stopped contract, we can only pass through this modifier if the boolean stopped is set to true. Next up, we have speed bumps. This pattern slows down the actions of a contract.
00:01:36.918 - 00:02:10.402, Speaker A: If someone figures out how to manipulate our contract, we can give ourselves a certain amount of time before other actions are triggered, and as long as we have backup plans built in, we'd have time to execute them. In this example, we have a struct request withdrawal. It saves an amount of funds and an amount of time. We track user balances in a mapping and requested withdrawals in another. We also set withdrawal period as an amount of time. In our first function, we're making the user request a withdrawal in advance. They won't be able to extract their funds until the time we set above has elapsed.
00:02:10.402 - 00:02:53.390, Speaker A: We'll check if they have a positive balance, save that to a variable, then decrease their balance in storage. We'll then create a requested withdrawal struct with the amount and time of the request. Next, we'll have the actual withdrawal function. We check the user's amount in. Our mapping has a positive balance and if the time at which they have requested the withdrawal plus our notice period is greater than right now. So, for example, has 28 days passed since they asked for their funds? If everything here is okay, we grab the amount they requested, update their balance in storage, and send out their funds. This way, if we notice anything suspicious or any errors, we have 28 days to take action before the attacker can actually withdraw those funds.
00:02:53.390 - 00:03:24.990, Speaker A: Next, we have rate limiting. Just like the ATM. At the bank, there is a limit on how much you can take out at once. If you want more, you have to go inside the bank, provide some ID, and get the approval of somebody else. Now this is to protect you in case somebody has your card and they're trying to take out all of your cash from the ATM. So here we have a set period of time, a limit of funds, an end period, and an amount that has been withdrawn in the current time period. We deploy the contract with these numbers in place and set the time that this period will end.
00:03:24.990 - 00:03:47.202, Speaker A: In our withdraw function. We're calling the update period function, which we'll get to in a second. Then we check if the user is trying to take out more than they're allowed to right now. We make our updates and then we send out the funds. Otherwise, we revert using the require statement. Now the update period function checks the current period end is less than the current block number. If it is, let's move on.
00:03:47.202 - 00:04:26.542, Speaker A: We update the next end date and set the current period amount to zero. Lastly, we have automatic deprecation. This one is pretty cool, but it's simple. When deploying contracts, it's a good idea to test them thoroughly on chain, not just on Testnet, but on Mainnet as a beta with limits to the amount of risk involved. Once you're done testing your contract, you can set up automatic deprecation so nobody can interact with your contract after a certain amount of time or once the beta period is over. In this example, we just have a simple modifier called is active, which requires that the current block number is less than the one that you have specified already. If it is, then the functions allow us to move through them.
00:04:26.542 - 00:04:54.930, Speaker A: If it's not, we can no longer deposit funds to the contract. However, we have a withdrawal function which will be the only one that we can use once deprecation is in effect. That's all I have for this video. I hope you found these little tips and tricks useful to stay safer and also plan for failure. Thank you for watching and I'll speak to you sooner.
