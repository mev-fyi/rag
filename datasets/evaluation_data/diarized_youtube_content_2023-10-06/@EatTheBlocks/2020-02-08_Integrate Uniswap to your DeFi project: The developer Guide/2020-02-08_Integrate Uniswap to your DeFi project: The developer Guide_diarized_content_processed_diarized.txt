00:00:00.330 - 00:00:53.834, Speaker A: Uniswap is a decentralized exchange for as 20 tokens. With Uniswap, you can buy and sell as 20 tokens in a decentralized way by using its smart contract on the Ethereum blockchain. It has currently more than a $50 million worth of asset and it is growing quickly. If you are building a defi project or any decentralized application, Uniswap can help you in two ways ways. First, you can very easily buy or sell ES 20 tokens using the smart contract of Uniswap. And second, you can very easily earn interest on any ES 20 token that you own by becoming a liquidity provider of Uniswap. So in this video I'm going to explain how Uniswap work and how to interact with it from a smart contract in solidity and from the front end of your decentralized application with JavaScript.
00:00:53.834 - 00:01:29.682, Speaker A: And at the end of the video, I will tell you about a caveat that you absolutely have to know when you are trading with Uniswap. Hey, I'm Julian and on my channel etherblocks I teach blockchain development and how to become a blockchain developer. So Uniswap is a decentralized exchange, but it's not the first one. There were many other before like ether delta. In a decentralized exchange like ether delta, there is an element called an order book. Typically you have one order book for each pair of assets traded. An order book is a collection of all the orders that have not been fulfilled yet.
00:01:29.682 - 00:02:05.710, Speaker A: Typically an order book look like this. On one side you have buyers and on the other side you have sellers. On the horizontal axis you can see order prices and on the vertical axis you can see order volumes. The more you approach the center, the less liquidity you have. For Uniswap you don't have order book, but instead you have a liquidity pools for each pair of assets. So let's see how we can trade tokens with this liquidity pools. A category of user called liquidity providers need to send an equal value of ether and ERC 20 token to a specific pool.
00:02:05.710 - 00:02:52.882, Speaker A: In exchange, they are given liquidity tokens that represent the asset they brought to the pool. At any time, they can redeem these liquidity tokens against their assets in the pool. Once there are some assets in a liquidity pools, traders are able to buy or sell the Yas 20 token of that specific pool. For example, if a trader wants to buy the yas 20 token, he will send some ether to the liquidity pool, and he will receive some yas 20 token in exchange. He will also pay a transaction fee that will be given to the liquidity provider when they withdraw the asset. What's really important to understand is that at no point the trader trade directly with the liquidity providers. They trade with the liquidity pool only.
00:02:52.882 - 00:03:38.338, Speaker A: What about the price of the ES 20 token? It is set automatically by the smart contract of Uniswap to keep the same value of ether and ESC 20 token in the liquidity pool. For example, if someone buys some ESC 20 token, the liquidity pool is unbalanced with less ES 20 token and more ether. In this case, the smart contract of Uniswap will increase the price of the Yas 20 token to incentivize traders to sell tokens, which will rebalance the liquidity pool. So let's dive into the smart contract. There are two parts, the factory and the exchanges. There is one exchange smart contract per pair of assets. That's where the liquidity pools are and where the trading actually happened.
00:03:38.338 - 00:04:24.082, Speaker A: However, there is only one factory smart contract. The responsibilities of the factory is to create the exchanges smart contract and act as a registry for these exchanges. All these smart contracts are written with Viper. Viper is an alternative smart contract language that has a syntax closer to python and focuses on security. Most other blockchain projects use solidity for the smart contract, so that's a bit unusual. To interact with the smart contract of Uniswap, you just need to interact with the interface of these Viper smart contracts, which means you need to understand the function signatures, but not the implementation. So if you don't know Viper, it doesn't matter too much.
00:04:24.082 - 00:05:22.462, Speaker A: And to make it even easier for other smart contract developers to integrate with Uniswap, the team of Uniswap even created an interface written in solidity, and that's what we're going to use. All right, so let's see some code. So there are two ways of developing with Uniswap. The first way is to deploy the smart contract of Uniswap on a local development blockchain, for example, using truffle and ganache. And second way is by using the smart contract of Uniswap that are already deployed on a public testnet like Robston. So I tried the first way with truffle and Ganache, and theoretically it should work because truffle is able to manage both solidity and Viper, and the smart contract of Uniswap are written with Viper. However, it's not possible yet to configure the exap version of Viper in truffle and Uniswap needed a very specific version, so the compilation failed.
00:05:22.462 - 00:06:10.942, Speaker A: So that's why I'm going to show you the second way, which is by interacting with the smart contract of Uniswap on Robston. So here I've created a smart contract that represents your defi project and this smart contract will interact with Uniswap. So you can see that I'm using three t 0.5.0. So first we need to copy paste the smart contract interface of Uniswap. So here I'm going to say it one more time, but the actual smart contract of Uniswap is written in Viper, but in order to interact with it we can use an interface in solidity. The Ethereum blockchain doesn't care if you use Viper or solidity, it only cares about the compile bytecode. So that's why we can operate easily Viper and solidity.
00:06:10.942 - 00:06:44.542, Speaker A: There are two smart contracts, the factory interface and the exchange interface. So first I'm going to copy the Uniswap factory interface and after I'm going to scroll down and copy the interface of Uniswap exchange. Okay. By the way, the reason why I use three t 0.5 and not three t 0.6 is because these two interface here only support. But if you want to have fun you can update them to three t 0.6.
00:06:44.542 - 00:07:38.282, Speaker A: So after you can update this pragma statement here. So first we need a pointer to the factory of Uniswap. So we're going to declare a variable Uniswap factory interface and we're going to call this Uniswap factory. We're going to create a setup function for this. So we're going to give it the address of the factory and after we instantiate our pointer like this, so now we can interact with the Uniswap factory by using this variable. So next we're going to create another function to create new exchanges. So anybody is free to create new exchanges for ES 20 token that is not covered yet by Uniswap.
00:07:38.282 - 00:08:19.158, Speaker A: So let's create a function called create exchange. It's going to receive the address of the ESC 20 token that we want to add. And here we use Uniswap factory variable and there is a function which is called create exchange and we just pass it the address of the token. And after that we have a new exchange with a new liquidity pool. So that means you don't need to create your own decentralized exchange. If your project use an ERC 20 token, you just need to call this function once. And after everybody can trade your token on Uniswap.
00:08:19.158 - 00:09:00.090, Speaker A: After that we're going to create another function to buy a token from one of the liquidity pool. So basically you'll be able to do some trading. So let's create this function, call it buy. It's going to take two arguments. First is the address of the token that we want to trade, and after the amount of token that we want to trade, token address. Okay, and we need to make this function payable because we're going to buy the token with some ether. So we need to be able to receive some ether.
00:09:00.090 - 00:10:10.890, Speaker A: So first we need a pointer to the exchange spot contract that deal with this token and the spot contract that can tell us what is the correct address is the Uniswap factory. And it has a function that is called get exchange and it returns the address of the exchange that we want. Uniswap factory get exchange of token address. And this is going to return an address, but we want a pointer. So we're going to pass this to Uniswap exchange interface and we need to declare this variable Uniswap exchange interface. Let's call this Uniswap interface. Okay, and after, if we want to buy this token, we're going to use Uniswap exchange eth to token transfer input and we need to send it some ether.
00:10:10.890 - 00:10:54.602, Speaker A: So we can do this with this, the value here function, and we can just forward everything that was sent msg value. And after that we're going to need to pass the argument of east two token transfer input. So I know this is a bit confusing, these notations. This means send all this ether. And after the second set of parentheses is for specifying the argument of the function. So the first argument is the minimum amount of tokens that we want to receive. So with Uniswap you don't specify directly the price that you want, but you specify both the input and the output of the transaction.
00:10:54.602 - 00:12:00.814, Speaker A: So implicitly that set a price. So the problem is that we don't know what should be the price of the token. So actually before calling this function, you need to call another one uniswap exchange get eth to token input price. So you pass it the amount of ether that you want to send and it's going to tell you how much token you can get. Okay, and actually here, I didn't mean to give this argument, so let's remove it. So here you get the price, you get the amount of token, and then you can forward this to your function. So what you can do here, before calling this function to actually trade, you can actually compare the price of Uniswap with the price of other exchanges.
00:12:00.814 - 00:12:27.974, Speaker A: You can also use oracles if you want to compare with centralized exchanges outside the blockchain. And if you don't like the price, then you don't do the trade. But if you like the price, then you do the trade. Then you need to put the deadline so the order will be valid only up to a certain time. So for example, can be for 2 minutes. So now plus 122nd. And finally you specify the address of the recipient.
00:12:27.974 - 00:13:29.790, Speaker A: So it could be the address of the spot contract or the sender. So for example, we want to send it to the sender. Oops, here I'm missing a two here I meant to call this Uniswap exchange and we good. And the last function we're going to create is to add liquidity. So why would you do this? Well, you would do this because you want to earn interest on your assets. So by becoming a liquidity provider on Uniswap, then you will earn the trading fees of all the traders who participate into the liquidity pool. So let's create this function, add liquidity so it accept as argument the address of token that we want to add liquidity for external and also payable because in order to add liquidity we need to send the same value of ether and token to uniswap.
00:13:29.790 - 00:14:20.318, Speaker A: Okay, so like for buy we need a pointer to the uniswap exchange. So let's do this. Then we need to know what's the price of the token because we need to calculate this amount compared to the amount of ether that we send to the function. So we also need to call the same function here, get east to token output price. Okay, so we're going to send this token amount. Next we're going to transfer the token from the address of the sender to the smart contract. By the way, I assume that the color of this function already call the approved function on the token for our smart contract, otherwise it's not going to work.
00:14:20.318 - 00:15:17.298, Speaker A: So we need the interface of ERC 20 token. So for that let's go to the repo of open zeppelin and I'm going to copy the URL. So here in open zeppelin contracts, contracts token, yes, 20. And what we want is ies 20 sol, that's the interface of es 20. So let's scroll up and at the very top, let's import this. Okay, so remix knows how to resolve this and after that we can use what is inside. So here we pass it the token address and we're going to transfer from the message sender and from the sender to our smart contract and for the token amount.
00:15:17.298 - 00:16:09.220, Speaker A: So now we have the ether and we also have the token. Okay, and finally we can call the add liquidity function uniswap exchange add liquidity. First we need to send the ether. So we're going to just forward all the ether that was sent and then we're going to pass a couple of parameter, so the first one is a parameter called min liquidity. Okay, so this one, I have to be honest with you guys, I look at the doc and I didn't understand. So I think that miniquidity needs to be token amount here. If you want to read more about it, there is some explanation at this address.
00:16:09.220 - 00:17:00.382, Speaker A: The second parameter is the maximum amount of token that you want to receive. So I'll put token amount also and finally the deadline, so we can do now plus 120. So that means that's going to be in two minute maximum. So this add liquidity function actually can be very convenient if you are building a sort of decentralized sage. And when people send you their asset like their token or ether, then you want to earn some interest from this asset. So in this case then you can add liquidity to the Uniswap exchange. And when your user want to withdraw the asset from your decentralized exchange, then you're going to call another function from Uniswap which is remove liquidity.
00:17:00.382 - 00:18:00.850, Speaker A: And so you're going to get the asset back and then you can forward all of this to the actual owner of these assets. Okay, so I've shown you how to interact with Uniswap from solidity, but maybe that you want to interact with Uniswap not from a spot contract, but from the front end in JavaScript. So in this case you have several possibilities. If you want to do some simple interaction, then you can use Webstery. So you instantiate Webstery as you would for any other decentralized project. Then you instantiate a contract instance to Uniswap and you call the different function that I show you in solidity, but from Webstery, if you don't know how to use Webstery, you can check out this Siri, you can check out this tutorial series, and if you want to do things that are a little bit more advanced and start to be a little bit more complex with Webster, and you don't want to get too much in the detail of Uniswap. In this case you can check out a library which is called the Uniswap SDKs.
00:18:00.850 - 00:18:40.542, Speaker A: So that's a typescript library that allow you to interact with the uniswap ecosystem. And it has different kind of modules here. So you can fetch some data from Uniswap, can do some computation, you can format some data, and the most interesting is the orchestration. So orchestration allow you to do some high level operation that would require to call different function. For example, you can swap an ESC 20 token for another one. So you can check out the documentation for this library at this address. So now there is something very important that you have to know when you use Uniswap.
00:18:40.542 - 00:19:14.846, Speaker A: So when we interacted with Uniswap, there was a parameter to set a deadline for the order. So that means your order was not valid after a certain point. And we also set some parameter to constrain the price that will actually be used when trading. And there are two reasons for this. The first reason is because market can move quickly. So when you send a transaction, if it takes time to be executed, then the price at which it's executed can be very different from the price that you see when you send a transaction. But the second reason is because of something called front running.
00:19:14.846 - 00:20:22.378, Speaker A: So front running is when in a trading system there is someone that can see the orders coming from other traders. So typically that's a broker, so that's an intermediary. And so when that person see the other order coming, then they will block this trade and they will first execute their own trades. For example, if I'm a broker and I know that a big bank like Goldman Sachs is going to buy for 100 million of share of Microsoft, I know that they know something that I don't know. So what I will do is I will buy the share of Microsoft first for myself, then the price will go up, then I will forward their order to the market, but they will pay more because my order already shifted the market. And after I'm able to sell and I make the profit, but they will pay a higher price. So in ethereum, the people who can do front running are miners, because they are the one who see all the incoming transaction.
00:20:22.378 - 00:20:38.820, Speaker A: And by constraining the price for your order, you protect yourself against front running. In the next video I'll introduce another super cool defi project which is called compound. Compound allow you to borrow and lend Ethereum token in a smart contract. I'll see you there.
