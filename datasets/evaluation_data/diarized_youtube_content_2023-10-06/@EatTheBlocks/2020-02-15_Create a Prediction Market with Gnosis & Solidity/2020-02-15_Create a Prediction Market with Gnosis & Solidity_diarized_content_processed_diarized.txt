00:00:00.250 - 00:00:49.914, Speaker A: Kunosis is a DeFi project for prediction markets. It allows to bet on any real world event on the blockchain in a decentralized way without any intermediary. Kunosis is a very powerful Defi project with a very interesting smart contract mechanics. And if you want to become an advanced blockchain developer, it's a very good idea to become familiar with goodnosis. In this video I will explain the basics of how gnosis work and we will do a coding tutorial in solidity for creating a bet on gnosis. Hey, I'm julian and on my channel idovlogs I teach blockchain development and how to find your first blockchain job. Gnosis work with three smart contracts, the smart contract of gnosis, an oracle and your defi project.
00:00:49.914 - 00:01:26.386, Speaker A: The only part that is specified by gnosis is the gnosis smart contract. All the rest is left to you. All the logic of the betting mechanism is inside the gnosis smart contract. The oracle is here to report the outcome of a certain bet, and then you have the smart contract of your defi project. From this smart contract, you will need to interact with the Gnosis smart contract in order to create new bets and receive the payouts of bet when the outcome has been reported by the oracle. So let's see the full process. So the first step is to create a bet on the smart contract of gnosis.
00:01:26.386 - 00:02:08.930, Speaker A: So you'll specify the name of the bet, the address of the oracle that is going to report the outcome, and you will also send some token to gnosis, and this token will be used for the payout of the bet. And in exchange, Gnosis is going to send you conditional tokens. These conditional tokens represent the different outcome of the bet. So for example, for some soccer game, let's say that you have three different outcomes. It can be team a win, team B win, or a nil game. Then you will have three different conditional token. Where it gets really interesting is that you can create conditional token out of conditional token.
00:02:08.930 - 00:03:01.062, Speaker A: So for each of these basic outcome that I've just mentioned, then you can subdivide them and you can create even some more fine grab outcome. For example, if the team a win a and it win by more than two goals, then it's going to be a subconditional token. Then another case if it wins by more than four goal, et cetera, et cetera. So with this you can really create some very, very sophisticated bet. The next step is to distribute these conditional tokens because at this point all the conditional tokens belong to the smart contract of your defi project. But in order to make your system useful, you need to have different gambler that own these conditional tokens. So the way you're going to distribute these tokens to different gamblers really depends on you.
00:03:01.062 - 00:03:49.830, Speaker A: So probably that you want to receive some ether in exchange of these tokens. So if you know how to estimate the probability of different outcome, then you can decide yourself on what should be the price of these different tokens, or you can put them for sale at some decentralized exchange. And actually there is a decentralized exchange technology developed by gnosis, which is called Dutchx. And this tech is particularly good for tokens that have a low liquidity, which is the case of conditional tokens. So I'm not going to go over Dutchx because this is a bit outside of the scope of this tutorial. But if you're interested you can check it out at this address. The next step is to report the outcome of the bet.
00:03:49.830 - 00:04:42.498, Speaker A: So in our example with the soccer game, after the soccer game is over, then the API of the oracle, so that's going to be outside the blockchain, is going to send a transaction to the smart contract of an oracle on chain with the outcome of the soccer games. For example, team a one. And this oracle smart contract is going to forward these results to the smart contract of knosis. One thing that is important to note is that there is only one Oracle smart contract that is able to report the result for this bet. Because when we initially created the bet, we specify the address of the oracle that is allowed to report the outcome. Otherwise anybody could report the result and that will be absolutely unsafe. And the last step is to redeem the conditional token.
00:04:42.498 - 00:05:33.746, Speaker A: So each gambler is going to send back the conditional token to the gnosis smart contract. And based on the outcome of this bet, gnosis is going to send back some of the token that were initially sent to gnosis. Okay, so now we will finally start to write some code. I will show you how to create a bet on gnosis in solidity. So here I am in my remix editor and I will create a new file. So we will start by the interface of ES 20 token because we will need this in other smart contract. So I'm going to call this is 20 sol, and after I'm going to copy the interface of ES 20 from the GitHub repo of open zeppelin.
00:05:33.746 - 00:06:24.514, Speaker A: So open zeppelin, which is a very popular solve duty library. If you don't know what it is, check out this series on open Zeppelin. So in a repo I'll go in the contracts folder, then I'll go inside token yes 20 and here you will see I yes 20 solve. So you open this file and you copy everything. Then you're going to paste this here in your remix editor. So we're going to change the pragma statement to three DT 0.5. And the reason is because otherwise this is going to be incompatible with other solidity code that we need, in particular the smart contract of gnosis with solidity 0.5.
00:06:24.514 - 00:07:23.400, Speaker A: Next we need to create an interface for the ERC 1155 token. And we need this because the conditional tokens of NoSIs implement the ERC 1155 interface. If you don't know what is ERC 1155, that's a token standard that is a mix of ES 20 and ES 721. Basically, in a single smart contract you can represent fungible asset and a non fungible asset. If you don't know how it work, you can check out this video. So first let's create IAC 1155 and after we're going to go to the GitHub repo of Nosis at this address. So here we'll go in contracts, then ERC 1155 and here we'll go inside I ERC 1155.
00:07:23.400 - 00:08:14.486, Speaker A: So we'll copy this, we'll paste it and actually we don't need this import here to open ziplim. So let's get rid of it, okay, and let's go back to the GitHub repo of gnosis. Let's go back in the directory and we also need another interface for the token receiver. So let's scroll down and copy everything. Let's paste this. Okay, so now we have the two interface, the interface for the YAS 1155 token itself and then for the receiver. Oh, by the way, we also donate this here and you will see after how we use these two contract here.
00:08:14.486 - 00:08:57.630, Speaker A: And after we need to create the interface for the conditional tokens of gnosis. So we're going to create a new file. We're going to call this iconal tokens Sol pragma statement is solidity 0.5.0. And then you're going to go back to the git repo, the GitHub repo of gnosis. So go back to the contracts folder and here you will go in conditional tokens. So unfortunately gnosis does not provide the interface of its conditional smart contract. So we will need to credit ourselves.
00:08:57.630 - 00:09:28.198, Speaker A: So the way we're going to do this is, so we're going to copy everything here in this file. Let's copy this. Let's go back to remix. We paste everything. And so first we're going to need a few imports. So we're going to import the interface of ERC 20 that we just created. And we're also going to import the interface of ERC 1155.
00:09:28.198 - 00:10:16.282, Speaker A: Let's call this iconitional token and implement the interface of IC 55 and after. So we're going to do some cleanup. So can remove all the event, you can remove all the state variable here, all the comment basically we're going to remove all the implementation. We don't need it. And you're going to remove, let me resize my screen and you're going to remove all the curly braces and put a semicolon instead. You're going to do this for every function here, report payout, same thing. So I'm going to let you do this and I'm going to forward to when I finish to do the whole process.
00:10:16.282 - 00:10:57.738, Speaker A: All right, so this is my finished file here. So you can see that we just have the function signature but no implementation. And that's all we need in order to interact with the conditional smart contract of gnosis. So next we're going to start the smart contract of our D five project from which we're going to interact with gnosis. So let's create a new file and we're going to call our file mydfyproject solution. So we still use three t 0.5. We call our contract my defy project and we need to import a few things.
00:10:57.738 - 00:11:49.110, Speaker A: So first we need to import the interface of Yasi 20. Then we also need to import the interface of Yasi 1155 and we need to import the interface of the conditional token of hypnotis. So next we're going to define the state variable of our smart contract. So first we need to manipulate some ES 20 tokens. So basically we're going to use the die stable coin as a collateral for gnosis. So we're going to send some die to gnosis and that's going to be the payout for the winner of the bet. So here let's define a variable of type ERC 20 and we call this die.
00:11:49.110 - 00:12:50.320, Speaker A: Then we're also going to interact with gnosis. So we need a variable for that. We're going to call this conditional tokens and we also need to store the address of the oracle that's going to report the outcome of the bet. So that's an address type. We call this oracle and we're going to set all of these variable in our constructor to first the address of die, then the address of conditional tokens, and then the address of the oracle. So first we instantiate the pointer to die like this, then for conditional tokens that's similar. And finally we store the oracle address.
00:12:50.320 - 00:13:24.360, Speaker A: So next we're going to build a function to create a new bet on gnosis. So we're going to call this function create bet. And it's going to take two arguments. The first argument is the name of the bet. So this is going to be an argument of type bytes 32. So if you don't know what this is, basically this is like a sort of hash which is 32 bytes long. And we're going to call this question ID because that is the naming that is used by gnosis to identify a bet.
00:13:24.360 - 00:14:22.250, Speaker A: And then we're going to have another argument for the amount of collateral token that we're going to provide for this bet and we make this external. So first we need to create the bet on the conditional token spot contract of gnosis. And there is a function called prepare condition and this takes three arguments. So the first argument is the question id that identified the bet, then the address of the oracle smart contract. So only this address is allowed to report the outcome of the bet. So that is for security reason, otherwise any address could report any outcome, including false outcome, so want to be protected. And finally, the last argument is an integer that is the number of outcome of this bet.
00:14:22.250 - 00:15:15.390, Speaker A: So for example, if this is a soccer game, so case A is the team a win, case B the team B win, and case C, this is a nil game. So in this case there will be three outcome oops, that's the other way around. Oracle first and then the question id. Okay, so at this stage we have just declared to gnosis that we want to create this bet, but this is not enough. We need to also create the conditional token. So I mentioned what are conditional tokens? So that's basically a token that will be redeemable against the collateral that we send to nosis depending on the outcome of the bet. So in order to create this conditional token, first we need to get a parameter which is called the condition id.
00:15:15.390 - 00:16:17.238, Speaker A: So the condition id is based on the combination of oracle question id and here the number of outcome. So we're going to get this parameter by calling another function of agnosis. So that's a byte 32 variable condition id, conditional token, get condition ID and we're going to pass it the same parameter that we did before. So next, before we create the conditional tokens, we need to approve the spark contract of goodnosis to transfer our die token because this is the collateral that we're going to provide. So in order to do this, what we're going to do is use the pointer to die and call the approve function. And the first argument is the address of diagnosis. And second the amount that we want to approve.
00:16:17.238 - 00:17:02.318, Speaker A: So we just forward what was provided as an argument here. And after that we're going to call a function that is called split position. And this function is going to transfer the die token to gnosis and give us back in exchange some conditional token that represent position in our bet. So the first argument is the address of die. So our pointer will be casted automatically to an address. Then there is something that is called the parent collection id. So I will explain this after, but for now just accept that it's going to be bytes 32 of zero.
00:17:02.318 - 00:17:49.834, Speaker A: Then the condition id that we calculated before, then something called partition. So I will explain this just after and the amount of die that we want to send as collateral. Okay, so partition is an array of outcome collection. So what is this? So we've said that for the example, this is a soccer game with three outcome, team a win, team B win, or there is a Neil game. So ABC, we have three outcome. So you would think that, well in this case we'll have three conditional token, one for A, one for B, one for C. But actually with gnosis we can create some more sophisticated bets.
00:17:49.834 - 00:18:34.330, Speaker A: So we can have a token that represent if the outcome a happened. But we can have another token if for the outcome b or c or any other combination. So what we're going to provide here for the partition variable. So this is an array with the combination, the different split for all the outcome that we want. The only constraint in when you build this array is that this different group here needs to be disjointed. So for example, you can have a and b or C or a because A is already contained here. So need to make sure that there is no overlap between the different combination that you do.
00:18:34.330 - 00:19:08.130, Speaker A: So the way we're going to express this is a bit special and for that we're going to use something that is called a bitmap vector. So for a it's going to be in binary. This is going to be the number one. Then for b this is number two. So in binary this is represented like this, and for c this is number three. So this is represented like this. And if you want to express some group for example b or C, then you're going to add these in binaries.
00:19:08.130 - 00:19:54.520, Speaker A: So here, for example, if you add these two numbers, 00:10 and 100 here, so two and three in decimal. So that's going to be one 10. So we're going to build an array where first element is one and the second one is three. Okay, so let's build this array. This is an array of length two. So here let's call this partition and give it a length of two. So for the first element of partition this is going to be one, and for second element this is going to be three.
00:19:54.520 - 00:20:48.054, Speaker A: Let me get rid of this. So what about this parent collection id that I mentioned before? So actually with nosis you can create several level of conditional token where subtoken depends on higher level tokens that allow you to create complex bet. For example for our token a, so it represents if team a won. But you can subdivide this in different category to bet. Well, by which margin team a won, did it win by more than one goal, two goals, three goal, et cetera. But if you want to create this subtoken, then you need to reference what is the parent token and for that you need this parent collection id parameter. So if you just do a simple bet like what we are doing in this example, then the root parent collection id is just byte 32 of zero like I show you in the code.
00:20:48.054 - 00:21:39.762, Speaker A: Otherwise you need to use a function that is called getcollectionid and you can check out the documentation of gnosis for more info on that. So if I wanted to create subtoken, then here I would call prepare condition again with another question id, probably a different parameter here. Then I would get a new condition id again. Then I would call the function getcollection id that I mentioned just before. Then I will create another partition and I will call again split position, but this time for the parent collection id. Then I would mention the higher level token that I depend on. In any case, you need to create the higher level token first, and after you work your way down next we're going to update an internal ledger to know what is our balance of conditional token.
00:21:39.762 - 00:22:26.802, Speaker A: And the way we're going to identify a conditional token is with the question ID and also with the index here in the partition array. So first we're going to create a mapping here. So that's going to be a mapping of by 32. So that's for the question ID to an internal mapping of integers. That's the index in the outcome collection array. And here integer is the amount. Let me call this token balance, okay, and after here token balance we reference the question ID and then so zero for the first position in the partition array.
00:22:26.802 - 00:23:24.066, Speaker A: So we're going to receive this amount of conditional token and the same for the other part of the outcome. So here we have a problem, because in order to receive this conditional token we need to implement the interface of the ERC 1155 receiver, and currently we don't implement this interface. So the incoming transfer of conditional token is going to be rejected. So here if we go inside this file, then we're going to copy this. So here you can see this comment like return blah blah blah blah. So copy from here up to the bottom. So here we just have the function signature but not the implementation.
00:23:24.066 - 00:24:40.826, Speaker A: Let's go back to my defy project and we're going to implement this function, okay, so here we're going to return this thing, okay, and below we're going to return this, okay, so now we implement the ERC 1155 token receiver interface. Next we're going to create a function to transfer our conditional tokens to anyone who want to bet. So let's do this transfer tokens. It's going to receive a couple of arguments. The first one is the question id so that we can identify the bet. Then the second one is. Second argument is an integer that is the outcome collection you want.
00:24:40.826 - 00:25:38.804, Speaker A: So here it's going to be zero or one, then the recipient of the conditional token and finally the amount. So first, only the admin of the contract is able to send this token. By the way, I'm not even sure we define admin. Okay, so let's do it here. So here we're going to define an admin when we create the smart contract. Okay, so here we require that the sender of this transaction is the admin. And the reason why we do this is because basically before someone call this transfer token function, we're going to assume that outside this smart contract some gambler bought the conditional tokens.
00:25:38.804 - 00:26:13.990, Speaker A: Maybe on some decentralized exchange that person sent some token to acquire a conditional that represent a certain bet. But first we need to receive the money. Next we need to make sure that we have enough token balance. So for that we're going to use the token balance mapping question ID. And here we reference the index set. So that's how we can reference a specific conditional token. And this needs to be superior or equal to the amount that we want to transfer.
00:26:13.990 - 00:26:49.964, Speaker A: Not enough token, that's the error message. And after that we're going to call conditionaltoken safe transfer from, transfer from the address of this contract. Then the recipient is two. Then we need an argument. It's called position ID. So I'm going to explain after how many conditional token we want to transfer and after we can pass some arbitrary bytes. So here we're going to pass something empty.
00:26:49.964 - 00:28:06.792, Speaker A: So here this position Id basically uniquely identify a conditional token. By the way, in our bet this is very simple, we just have one level of conditional token. So I use this combination here of question ID and index set to identify a conditional token. But actually if you want to make it more exact, in particular if you have several level of conditional token, then in this case you will need to use the position ID in order to identify conditional token. So here we can get the position id, which is an integer, by calling conditionaltoken get position ID and we're going to pass it the address of the collateral plus something called collection id. So now we're going to work our way backward because we don't have this collection id. So here we're going to get it, we can get it with get position id, sorry, get collection id.
00:28:06.792 - 00:29:15.328, Speaker A: So the first argument is the parent collection ID. So since our conditional token is at the first level, then the root parent collection id is just bytes 32 of zero, then we need to pass the condition id that we don't have yet, then we need to pass the index set that we got as an argument. So finally we need to get this condition id. So conditional token, get condition ID. So this is going to be oracle, then question ID, then number of outcomes, so we know that there are three in total, okay? And with this then we are able to transfer our conditional token. Oh, by the way, I forgot to mention one thing, but here this need to implement the ERC 1155 token receiver interface. If that is the address of a smart contract, if that's just an address controlled by a private key, then you don't need to care about this.
00:29:15.328 - 00:30:10.160, Speaker A: So next we're going to create another smart contract that will be a sort of smart wallet for our conditional tokens. Because once the outcome of the bet has been reported, then some of these conditional token will be worth something and we'll be able to redeem them against the die that was sent as a collateral. But the process of redeeming this token is not really easy. So if we can put some of the logic in a spot contract that can make it easier for end users. So we're going to create a new file that we're going to call conditional tokens wallet. Okay, so pragma solidity 0.5. Let's create a contract.
00:30:10.160 - 00:31:02.320, Speaker A: So we're going to need the same import as for my defy project. So let's copy this import here. Then the constructor will be similar also. So let's copy this quickly my defi project and paste this in conditional token wallet. So in order for this smart contract to be able to receive the conditional token, as I mentioned, it needs to implement the interface of Yas 1155 token receiver. So here first we declare that it implement this interface 1155 token receiver. Let me make sure that I spell it that way.
00:31:02.320 - 00:31:43.890, Speaker A: Oh no, spell it that way. Okay, and after we need to implement this interface. So again we're going to copy from my D five project, we're going to copy these two things on ERC 55 received and batch received. Okay, so now we can receive this token. So next we're going to create a function to redeem our conditional token. So we're going to call this redeem tokens. It's going to receive two argument.
00:31:43.890 - 00:32:27.134, Speaker A: First we want to know what is the condition ID? And then we're going to want an array of all the outcome collection indices. You know, it's what I call index set before, but in this case we're going to have several. So that's going to be an array of integer. And after we're going to call conditional token redeem position. Oops, with the s, first we specify what is the collateral, then the parent collection iD. So here we just have one level, so we know that this is the root parent collection iD. Then we specify the condition ID, and finally the index sets.
00:32:27.134 - 00:33:13.860, Speaker A: For example, if I know that I only have conditional token for the first outcome collection. So this is going to be an array like this, sorry, like this, if I have also conditional token for the second collection outcome group, then it's going to be this array. Okay, so we're going to call this redeem token function. So we're going to send the conditional token to gnosis and it's going to send us back the die token. And after we need the function to transfer this dai token somewhere. So here let's create a function called transfer dai. So the address of the recipient and the amount.
00:33:13.860 - 00:34:10.722, Speaker A: And here we reference the smart contract of Dai and we transfer our token to wherever we want. And by the way, we want to protect this function, otherwise everybody can steal our token. So we want to make sure that the sender of this transaction is the admin of the smart contract. So here, one note is that when we call the redeem tokens function there is still quite some lot of information we need to know, like the condition id, the index sets. So we could make this function more simple by doing the following thing. So when we receive the conditional tokens, this function here is going to be called on ERC 1155. And there is this optional data argument here.
00:34:10.722 - 00:35:10.102, Speaker A: So if we go back to my defy project here, that's what we specify in this argument. So if we wanted, we could specify some data that identified the conditional token here with assembly. So you need to pass this byte with assembly, with an assembly block need to pass it and after that, once you've passed it, then you can save this data somewhere in your smart contract. And so when you redeem token then you can use this metadata about all the conditional tokens that is owned by this address. And so you will need to provide less data here. You will make your smart wallet smarter in a way. By the way, there is another smart wallet implementation that is provided by gnosis and that is called the gnosis safe, so you can have a look if you're interested.
00:35:10.102 - 00:35:54.158, Speaker A: So when I explained the whole mechanism of gnosis, I also mentioned that there is an oracle smart contract. But actually if you want to make your system simple then you don't need to have smart contract for the oracle. You can just have the oracle be just an ectno API that send some transaction to gnosis to report the payout after the outcome has happened. So that means for example for the soccer game, after the soccer game was played. And so the function you will need to call on the conditional token smart contract is report payout. So you need to provide the question id as well as an array of the payout for the different outcome. So in our case we had three outcome ABC.
00:35:54.158 - 00:36:32.920, Speaker A: So for example, if this is the outcome a, then your array will be 10 zero. If this is outcome B, then it's going to be zero 10, and if it is outcome C then it's going to be. It's also possible to divide the payout between the different outcomes. So for example, if your payout vector is one 10, that means that half the payout will go for the conditional token attached to the first outcome and the other half for the conditional token attached to the other outcome, the second outcome. If you want to learn how you can integrate solidity smart contract with other super codified project, you can check out this playlist. I'll see you there.
