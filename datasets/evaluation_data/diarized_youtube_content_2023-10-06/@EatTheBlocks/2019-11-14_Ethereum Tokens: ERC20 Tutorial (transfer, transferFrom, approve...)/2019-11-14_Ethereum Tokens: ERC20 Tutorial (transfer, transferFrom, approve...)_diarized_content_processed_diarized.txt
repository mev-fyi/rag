00:00:00.410 - 00:00:29.862, Speaker A: Hey, this is Julian and you are on it. The blocks. And in this video I'm going to show you the ERC 20 token standard. So in this video I'm going to go over the specification and explain you the function of the standard. After that you will know how you can interact with an ERC 20 token. So ESC 20 was really the first token standard created on Ethereum, and that was widely used in icos in 2017 and 2018. And to this date it's still the most popular token standard.
00:00:29.862 - 00:00:55.278, Speaker A: So ERC 20 tokens can represent fungible asset. Fungible assets are assets that can be exchanged for one another. For example, if you have a $1 bill, you can exchange it against any other $1 bill. It doesn't really matter. There are many other assets like this, such as stocks. For example, if you own one stock of Microsoft, then you really don't care which stock it is. They are all the same.
00:00:55.278 - 00:01:33.798, Speaker A: All right, so that's it for the general introduction of as 20 token. So now we're going to start exploring the token standard. So you'll find the token standard at this address. And so first you have a meta description of the standard with the author, the status, the name when it was created. And if you scroll down then you will find a simple description of what it does in the abstract, the motivation. And if you keep scrolling down, then the most interesting is the specification for the function. The specification is a description of the interface of your smart contract.
00:01:33.798 - 00:02:21.562, Speaker A: So in other words, it describe the function signatures, but it does not define the function implementation. So that means that anybody is free to have his or her own implementation of this standard. The only important thing is that you respect the function signature and the behavior of the function that is specified. And the last general remark is that there can be a mismatch between the function signature in your implementation and the specification if you target different version of solidity. So the ES 20 standard was written at a time when solidity was still at 0.4. But if you look at the implementation of open zeppelin, it targets solidity 0.5. So you will see some small differences in function signature, but that is okay.
00:02:21.562 - 00:03:00.674, Speaker A: All right, so let's start to explore the function of ERC 20. So the first function is called name, and you can see that this is optional. So that means that any implementation of this standard does not have to implement this function, but for the name function, actually most token implement it because this is very useful. So the name function returns you a string that describe the token. This is supposed to be a human friendly description. For example for the dai token, the name is dai stablecoin. Then another optional function is symbol.
00:03:00.674 - 00:03:32.174, Speaker A: So symbol also return a string that is a description of the token. But contrary to the name, this is more for trading. When you want to trade and it has 20 token, you don't use its full name to identify it because it's a little bit too long. But instead you use what is called a tickers. A ticker is typically three or four character long and identify a yes 20 token. So next there is the decimals function. And this is the last optional function of the standard.
00:03:32.174 - 00:04:15.018, Speaker A: All the other function are required. So decimal returns an integer that describe the granularity of the token. So what is this? So you probably know that for ether, when we manipulate ether in a smart contract, we don't manipulate a whole ether, but we manipulate a fraction of an ether called a way one way equals ten powers -18 ether. And I've done another video on this topic link in the description. And for token we have the same thing. We don't manipulate whole tokens, but we manipulate fraction of token. But we need to know what's the relationship between this fraction of token and whole token.
00:04:15.018 - 00:04:51.126, Speaker A: And that's exactly what the decimals function does. So for example, if the decimals function return 1000, it means that a cent of a token is one thousandths of a token. But in order to make things easy, usually most ERC 20 token use the same granularity than ether. So in other words, decimal is going to return ten power 18. For example, for die is the granularity they use. And I recommend you do the same thing. It's really important to understand that the smart contract actually doesn't care about this parameter.
00:04:51.126 - 00:05:37.640, Speaker A: It's only something that is used by external wallet to display to user how much token they have. So next we have the total supply function and it returns an integer which is the total number of tokens. So keeps in mind that this is given in the elementary unit of the token. So if you want to know how many tokens there are, you need to divide this by the number returned by the decimals function. So if my total supply is 1000 and decimal is 1000, then actually I only have one token in circulation. All right, so let's scroll down and then we have the balance of function. So that gives us the token balance of a specific address.
00:05:37.640 - 00:06:11.118, Speaker A: So for es 20 token balances are public. So anybody can inspect the balance of any address. So next we have the transfer function. So that's one of the most important function in the ES 20 token standard. So with the transfer function, you can transfer your token to an other address. So you specify first the recipient, then you specify how many tokens you want to transfer. So again, we are talking of elementary unit of token.
00:06:11.118 - 00:06:47.614, Speaker A: So if you want to transfer one whole token, but the granularity of your contract is 1000, here you will specify 1000. So in order for this transfer function to succeed, the caller must be the owner of the token and must have enough token in its balance. Of course. And if the transfer is successful, a transfer event is going to be emitted. And this is very convenient. For example, if you are building a wallet in the front end, you can listen to the transfer event and show all the transfer that are relevant for a specific address. All right, so let's scroll down.
00:06:47.614 - 00:07:32.122, Speaker A: And the next function is transfer from. So transfer from also allow you to transfer token, but the difference is that this time it can do delegated transfer. So in a delegated transfer, there are three addresses to consider. So one, there is the owner, second, there is the spender, and third, there is the Es 20 token. So what happened is the spender is going to transfer some token on behalf of the owner. So the ERC 20 token needs to know if a spender is allowed to spend token on behalf of someone else. And for this, actually there is another function called approve.
00:07:32.122 - 00:08:41.566, Speaker A: So the owner of a token need to first call this approve function and he will specify the address of the spender and how many token the spender is allowed to spend. So if I allow a spender to spend 1000 token, then once this spender has spent all this 1000 token, then his allowance is zero and he cannot do delegated transfer on my behalf anymore. And at any time, if you want to know the allowance of a combination of owner and spender, then you can call the allowance function. And every time you call the approve function, he's going to emit an approval event. And if you want to revoke the allowance of a specific spender, then you can call the approve function again with the same spender, but this time you can change the value to zero. So one typical use case of this is for decentralized exchange. So before you're able to trade on a decentralized exchange, you need to first send your token to this exchange.
00:08:41.566 - 00:09:35.314, Speaker A: The problem is that if you transfer your token directly to the exchange, the exchange has no way of knowing where the tokens are coming from. So internally they cannot maintain a ledger that says, okay, well, among all the tokens we have, then this much belong to this address. So to solve this problem, we use this delegated transfer pattern. So first trader will approve the decentralized exchange to transfer token on their behalf. And just after the decentralized exchange will call the transfer from function and for the from address they will specify the address of the trader. But this time, because they are the one who initiate the transfer, then in their internal ledger they will be able to increment the balance of the trader. So this pattern is a bit complex and more recent token stand out a lot.
00:09:35.314 - 00:10:23.966, Speaker A: To simplify this by introducing a hook function that is called on the recipient smart contract when you transfer token. And I will show you this later in this series. So studying ethereum tokens can be a little bit overwhelming. So that's why I've prepared this cheat sheet where you have all the important information in a compact format. So this is totally free and if you want to get it, you just have to follow the link in the description. So Yasi 20 tokens are great, but they have some flows like the possibility of sending a token to a smart contract that don't know how to handle it, in which case you would just lose this token and it will just be locked in the recipient contract. So to avoid this, there are some solution like ERC two two three.
00:10:23.966 - 00:10:28.500, Speaker A: And that's what I'm going to show you in the next video. Thanks for watching, see you next time.
