00:00:00.330 - 00:00:40.694, Speaker A: When you build an Ethereum DAP in order to communicate with your smart contract, you need to use Webstery. One of the most difficult part of configuring Webstery is to import the ABI and the address of your smart contract into the front end of your DAP. In this video, I will give you an introduction of what is the ABI of a smart contract and how you can import it to your DAP frontend using four different methods. First we will see what is the ABI. Then I will show you how to produce the ABI of a solidity smart contract. Then I will show you how to import the ABI using four different methods. First we will use a simple copy paste.
00:00:40.694 - 00:01:17.218, Speaker A: Then we will serve the ABI as a static file from a backend server. Then we will import the ABI with a custom webpack configuration during the build process. Then we will do the same thing using a specialized webpack loader called truffle solidity loader. After that, I will show you how to reduce the size of your ABI. And finally, we will compare the cons and pros of the different methods to import the ABI to the frontend. This is a free episode of Edoblocks Pro. If you want to access the source code of this tutorial, go to Edoblox Pro and create a free account by clicking on this button.
00:01:17.218 - 00:02:08.930, Speaker A: Enroll now if you want to get access to even more video about Ethereum and solidity programming, you can also purchase a subscription to Idoblox Pro, and you'll get access to more than 100 video. All right, so let's get started with what is the ABI? The ABI is a json file that defines the interface of your smart contract. You will find a description of all the function that can be called from outside the smart contract, which include the public function and the external function. For each function, you'll have a description of the arguments, if there are any, and you also have the written type of each function. This json document allows external libraries like Webstree to interface with our smart contract and understand how to interact with it. This json document is produced by the solidity compiler. You don't have to produce it yourself.
00:02:08.930 - 00:02:51.982, Speaker A: You don't really need to understand the format of this document, but all you need to know is that this document must be imported in the front end of your DAP in order to configure Webstery. And that's what we're going to see in this video. If you want to know more about what is an ABI and what is its format? You can check out the official documentation of solidity using this link. All right, next we are going to see how to produce the ABI of a solidity smart contract. The solidity compiler is able to produce the ABI of a solidity smart contract. So you will need to first install solidity on your computer, and you'll get access to a utility called C. And using the ABI flag, then you will be able to produce the ABI of a smart contract.
00:02:51.982 - 00:03:27.434, Speaker A: However, most people don't do like this. Instead, what most people do is that they use truffle, the framework for solidity smart contract. This is not a video about truffle, so I'm going to assume that you're already familiar with it. This is the layout of a standard truffle project. Although you might be already familiar with truffle, you might not know that every time you compile your smart contract, it also produced the Abi of your smart contract. This happened when you run either the truffle compile command or the truffle migrate command. In both cases, it's going to produce the Abi in the build directory.
00:03:27.434 - 00:03:57.302, Speaker A: So if you ls what you have in build contracts, then you will find what is a contract artifact. So that's a concept that belongs to truffle. And inside this contract artifact, you will find your Abi. So if we check what we have in storage JSon, then we'll find our Abi. So let's check it out. So here in our contract artifact, we find our Abi. Here, the contract artifact does not only have the ABI, it also has other stuff, like for example, the contract name.
00:03:57.302 - 00:04:43.560, Speaker A: Or if you scroll down, you'll see other stuff like the bytecode, the source map, et cetera, et cetera. In this video, we are only going to be interested in the Abi of this contract artifact and also in the address. So just to finish on this section, the point is, you don't have to produce the ABI yourself, you just use truffle. And when you migrate your smart contract, the ABI will be automatically created in the contract artifact in the build folder. So next we're going to move on to how to import the ABI to the front end. And the first method that I'd like to show you is the very simple copy and paste. So this is the code of this video, and I've made a folder for each of the method that I want to show you for importing the API to the front end.
00:04:43.560 - 00:05:31.026, Speaker A: So I'm going to go in a copy and paste folder. So this is a standard truffle project. And inside I've created a very simple smart contract that is called storage JSON. This smart contract is able to store a string variable called data and it has a set of function to change the value of this variable. It also has two getter function, a public getter function that is accessible from outside the smart contract, and a private getter function only accessible from inside the smart contract. So the reason why I've made a public and a private getter is only to show you that in the ABI we will only find the public getter and not the private getter. There is no point in putting the signature of a function in ABI if it cannot be called from outside the smart contract.
00:05:31.026 - 00:06:01.342, Speaker A: This ABi is intended to be used by consumer outside the Ethereum blockchain. So if you want to check that what I say is true, then you go back to your command line and you execute truffle compile. It's going to create a build folder and a subfolder contract. And then in the file storage json then you can check the ABI. So here we have the set function and below we have the public get function. And that's it. We don't have the private get function.
00:06:01.342 - 00:06:32.358, Speaker A: So our goal is to import this file into the front end of our DAP. So let's go back to the command line and actually there is a folder called app. So this folder is supposed to host the source code for the front end of your DAP. So in my case, I've only created a single file called Ethereum Js whose job is to import the ABI. So let's open this file. All right, so in this file we are going to instantiate Webster here. So first we need to give to Webstery the URL to our Ethereum blockchain.
00:06:32.358 - 00:07:06.834, Speaker A: And then we need to instantiate a contract instance. And with this contract instance after, we will be able to interact with our smart contract. So this is the API of Webstery. If you are not familiar with this, check out the doc of Webster. But the point is that Webster has a method called contract. And this method takes two arguments, the API of the smart contract and the address of the smart contract on the Ethereum blockchain. So just above I've defined these two variable and what we are going to do is very simply to just copy paste this value from the contract artifact that I showed you just before.
00:07:06.834 - 00:07:29.002, Speaker A: So let's go back to the contract artifact. And first we are going to select the ABI key. And then I'm going to go back to the Ethereum Js file and I'm gonna paste all of this. So here you need to arrange a little bit. So you need to get rid of the Abi key. And we double click, going to give it this array. And let's scroll down.
00:07:29.002 - 00:07:56.286, Speaker A: And here, let's get rid of this comma. All right, and here, give it a semicolon. All right, so now our Abi variable contains the actual AbI of our smart contract. Next, we need to also take care of this address variable. So how are we going to find this address variable? Well, I told you just before that in the contract artifact, we also have it. So let's check it out. So the address key should be at the very bottom of our file.
00:07:56.286 - 00:08:23.994, Speaker A: So let's go to the bottom and we don't see anything. Is it normal? Yes, it's normal because we haven't deployed yet our smart contract. So we're going to open a new terminal window and let's start a truffle console. So truffle develop. So your output after you enter truffle develop might be slightly different for mine. In my case, I already have another truffle develop station started in another project. So that's why it says connected to existing truffle develop station.
00:08:23.994 - 00:08:58.038, Speaker A: But you can just ignore this, it will just work exactly the same. So let's deploy our smart contract. So migrate reset. Okay. And after the output of truffle will give us the address of our smart contract in our Ethereum blockchain. So I'm just going to copy this and I'm going to go back to Ethereum Js and here I'm going to populate the address variable and that's all I need to do. So now the contract method of Webstery has all the required information, the ABI and the address.
00:08:58.038 - 00:09:39.674, Speaker A: So this is a very simple method, but as you can see, it's not very convenient because every time you make a change to the smart contract, you need to manually do a lot of copy pasting. And in our case, we actually have a very simple smart contract. So the ABI is quite short, it's quite simple. But in many cases, your smart contract will be much bigger than this and the ABI can be much bigger and so it can be even more troublesome to copy it and it's even more error prone. So I would only recommend this method. So I would not really recommend this method, but it's good to know that it exists and it actually show you in a simple way what's going on behind the scenes. Alright, so we are done with the copy paste method.
00:09:39.674 - 00:10:15.034, Speaker A: Next we're going to see how we can serve the ABI as a static file in a backend server. So in our terminal we're going to go to the parent directory of copy paste and we're going to go to this directory backend server. So this is exactly the same truffle project with the same smart contract and it also has an app directory. So let's go to the app directory because that's where all the action happened. So in this app directory we have an Ethereum JS file. So this is exactly the same file as I just showed you before. And we also have a server.
00:10:15.034 - 00:11:01.882, Speaker A: So this is an express server. And this server only has a static middleware to serve static file and it is configured to serve the content of the build contracts directory in the parent folder. So this is basically the contract artifact produced by Truffle. So let's run this server and let's go to a browser and we are going to load localhost 3000 storage JSON and we can see that it served the contract artifact. So that means that from the front end I can get the contract artifact, which means that I can also get the ABI and also the address of the smart contract. All right, so let's go back to our code editor in the Ethereum JS file. And so now from this file we need to query our backend to get the storage json file.
00:11:01.882 - 00:11:40.086, Speaker A: We're going to be able to get the ABI and the address. So we are going to use the fetch method of web browser. So fetch. And here we're going to give it the URL of our endpoint. So that's HTTP localhost 3000 and we want to get storage JSon. And fetch is going to return a promise. So we need to call then and we're going to call the result res and then in order to get the file that is returned in this response, then we need to execute on the rest object, the text method.
00:11:40.086 - 00:12:23.270, Speaker A: So here we're going to return another promise rest text and we need to call then again, and this time we will have the json file that we are looking for. So here we'll call this JSON. We open the curly braces and we need to actually pass this JSON because what is written is a string. So here JSon, pass JSon and we're going to call this contract artifact. And if we want to get the AbI, this is basically contract artifact, Abi. And if we want the address, it's slightly more complex. So we're going to check out what we have in the storage json file.
00:12:23.270 - 00:12:55.330, Speaker A: So let's go back up one directory, and in the build directory contract we're going to access the storage json file. So let's go at the bottom and we'll find a key that says networks. And it's where you're going to find the deployed address of your smart contract. This number here that you see is the number of the deployment, so you can just ignore it. And what we care about is this address field. So let's go back to Ethereum Js. So now we need to extract this address from the contract artifact.
00:12:55.330 - 00:13:35.530, Speaker A: So let's reference contract artifact after we need the networks key and after we need to reference the number of the deployment. So in our case it's five, seven, seven. And finally we want to access the address field and we assign all of this to the address variable. Oh, by the way, there is a typo just above RT. Okay. So if we do like this, it's going to work, but our code will be a little bit fragile because this deployment number, 5777 is totally arbitrary and it can change at any time. So we need another method.
00:13:35.530 - 00:14:23.662, Speaker A: So what we're going to do is we're going to get an array of all the keys in network. And in this array we're going to select the last deployment. So let's define a deployment variable. And here we use object keys method of JavaScript and we give it contract rtfact networks. So that's going to be our list of deployment. Deployment with s actually and in order to get our address, what we are going to do is to reference contract artifact networks. This time we don't give it a fixed string, but instead we use the deployments array and we're going to choose the latest entry of this array.
00:14:23.662 - 00:14:58.566, Speaker A: So for this is deployment and minus one. So we close our square brackets and semicolum and we. Good, and let's get rid of this address here. Okay, so with this you're guaranteed to always have the latest address of this smart contract if you do multiple deployments. So now for the code which is outside our then basically we're going to get rid of this and we're going to move this inside the then. So let's reformat this. So we are done with this section.
00:14:58.566 - 00:15:38.246, Speaker A: So next we're going to see how we can package the API in the front end using webpack this time. So it's going to be a little bit more modern and probably closer to what you're going to use for your development, and especially if you're using react. Okay, so let's go back to our terminal and we're going to go to the parent folder, and after we'll go to the folder three custom webpack. Okay, so this is almost exactly the same thing as before. So we have a truffle project with the same smart contract with an app folder. So let's go inside our app folder. So let's see what we have in this app folder.
00:15:38.246 - 00:16:15.954, Speaker A: So we still have our file Ethereum Js, where we're going to import our contract artifact and we have a package JSON. So this time we don't have express anymore, we don't have the backend server anymore, but we have webpack. So Webpack is going to allow us to import very simply the json file of the contract artifact. So let's open our Ethereum Js file. Okay, so that's what we had in the previous section where we were fetching the contract artifact from the back end. But this time it will be much more simple. We're going to use webpack.
00:16:15.954 - 00:17:06.242, Speaker A: So let's get rid of all this fetch stuff that we don't need anymore. So let's do some reformatting. All right, so we don't need this line anymore because this time what we're going to do is we're going to import our contract artifact from, and here we're going to give it the path to our build folder in our truffle project. So we need to go up one level and then it's in the build folder contract storage JSOn. Okay, and so Webpack is able to import our json file directly with this statement. And for the rest of the code we don't need to change anything. It's exactly the same thing.
00:17:06.242 - 00:17:50.590, Speaker A: So one thing that is important to understand is after we run our webpack command, it's going to basically copy paste this json file into our front end code. So when we will load this JavaScript file in the front end, you will not need to fetch the contract artifact from the back end, it's already loaded in the front end. So if you have a build process, for example, then you will run your webpack command. And so your contract artifact will be integrated to the front end during the build process. So that's very different from the previous method. So once you've done that, then you need to run the webpack CLI to produce your JavaScript bundle. So let's go back to the command line, and after we're going to execute the webpack command.
00:17:50.590 - 00:18:33.530, Speaker A: So if you have webpack installed globally, you can just execute webpack like this. But the safe way is to use the version that we've installed for our project. So you go to node modules and then in the bin directory and then webpack, and then you give it the path to the file that you want to transpile. So in our case it's ethereum JS. And after, if you want to see the output, then you need to check in the disk directory and you have a file that is called men JS. And here you have the results of the transpolation of webpack. So in most cases when you're using webpack, you also have a webpack configuration file.
00:18:33.530 - 00:19:12.246, Speaker A: So the method I show you will just work. It does not require any special configuration. Webpack by default knows how to import json file. This method is my favorite method for providing the ABI to the DAP frontend. All right, so we are done with this section. So next I'm going to show you the last method to provide the ABI to the front end, and this time we'll still use webpack, but we will use a specialized webpack loader that is called truffle solidity loader. So what I really like about this webpack loader is that you can run your webpack in watch mode and webpack will watch your solidity files.
00:19:12.246 - 00:20:05.870, Speaker A: And every time your smart contract changes, then truffle solidity loader will run automatically and recompile your smart contract. So it will produce the contract artifact and it will be updated in the bundle that is produced by Webpack. So with the previous method, every time we make a change in a smart contract, we had to manually recompile the smart contract. Otherwise the bundle will not be updated with the latest version of the smart contract. So basically what you get with Strafo's solidity loader is an extra level of automation, and it does not only compile your smart contract, but it's also able to automatically run migration to the blockchain every time you change your solidity contract. So let's see how it works. So here in our terminal, let's go back to the parent directory of this episode, and we're going to step in the folder of truffle solidity loader.
00:20:05.870 - 00:20:51.134, Speaker A: So here we have the same truffle project with the same smart contract. However, there is a small change in the configuration file of truffle so by default, the configuration file for Truffle 5.0 is Truffleconfig JS, but I rename it to Truffle JS. So the reason why I did this renaming is because truffle solidity loader still expect Truffle JS if you are not running on Windows. So this webpack loader has not been updated to the latest version of Truffle. So you need to change the name of the configuration file of truffle in order to make it work. So let's scroll down in this configuration file and I'll show you what I changes also inside.
00:20:51.134 - 00:21:26.530, Speaker A: So here you have module export, and here you have your network key where you can define custom network. And I've defined the develop network, and this is basically the network when you run truffle develop. So the port is 95 45. And so I gave all the parameters of this network because I want truffle solidity loader to run migration on this network. So next I started a truffle console with truffle develop. So with this in place, I'm ready to show you how it works. So let's see what we have in the app folder.
00:21:26.530 - 00:22:13.314, Speaker A: So we still have our Ethereum Js file where we're going to import our three DT smart contract. And this time we have a configuration for webpack because truffle solidity loader needs to be configured in order to work. So let's go to the app directory, and I also want to show you what I have in package JSON. So in my package JSON, I still have the two dependency to webpack, but also have a dependency to truffle solidity loader. And I also have these two things, JSON Loader and truffle legacy system. So this is a little bit tricky because in order to make truffle solidity loader work, you also need these two other dependencies. However, this is not specified in the readme of truffle solidity loader.
00:22:13.314 - 00:23:27.130, Speaker A: So make sure to install these two dependencies, otherwise you're going to have a problem. All right, so now that I show you what we have in package JSON, let's open Ethereum Js. So app Ethereum Js. So this is what we had in the previous section when we were using just webpack, and we only need to make a small change in order to use Trefo solidity loader. So let's go to the import path of our contract artifact. And instead of importing the contract artifact, we're going to import directly the solidity file. So we get rid of the build folder here and we're going to fetch our solidity contract in contract storage Sol and actually this notation is a little bit misleading because the solidity file is not going to be actually imported in contract artifact because this is not what we need when a truffle solidity loader see this import to a solidity file behind the scene, it's going to compile this smart contract, do the migration on blockchain, and what's going to be imported is the contract abstraction, the json file in build contracts.
00:23:27.130 - 00:23:59.010, Speaker A: So that means that the rest of the code will keep working exactly like before. So that's the only modification that we need to do in Ethereum Js. And let's also have a look at the webpack configuration. So it's in app webpack config JS. So here we define our entry point, so Ethereum JS, but in your application it's going to be probably index Js. We also define our output where we want to produce our bundle. And after we define a loader for solidity file.
00:23:59.010 - 00:24:30.206, Speaker A: So first you need to apply json loader. That's why we install this in package JSON. And after you apply truffle solidity loader and this loader, take a set of option. In this set of option you need to specify which network you want to deploy your smart contract to. So this name needs to match what you have in your truffle configuration. So that's why we define a developed network in Truffle JS. And then if your migration folder and your contract build directory are not at the same level of this webpack config, then you need to define a path.
00:24:30.206 - 00:25:15.526, Speaker A: So that's it for the webpack configuration of truffle solidity loader. And in another terminal window we are going to execute the webpack process. So we're going to find webpack in the node modules directory and then inside the bin subdirectory and here webpack and we're going to pass in the watch flag. So that means that webpack is not going to do just one compilation, but it's going to keep watching our file, including the solidity file. And then we specify which file we want transpile. So that's ethereum Js and we press enter. And after you see the output of webpack, and contrary to the previous section, in this section actually we have some extra output.
00:25:15.526 - 00:25:45.958, Speaker A: So that is coming from truffle solidity loader. So in my case I've actually already compiled. So it tells me that there is nothing to do. But if my build directory was empty, then it will compile my smart contract and deploy them to the blockchain. So if I do any change to my solidity smart contract or to Ethereum Js, everything is going to rerun automatically. So let me stop this. And actually if we check what we have in this directory, then we have this bundle JS file.
00:25:45.958 - 00:26:16.894, Speaker A: And so that is what was produced by webpack. So that's all you need to do in order to use truffle solidity loader. This can be a significant improvement to your workflow. However, there are some caveat and in particular the package is not really maintained and doesn't really keep track with the latest version of truffle. So you need to do a few adjustments as I show you. And sometimes it's also a little bit buggy. So if you're getting frustrated with this method, then you can just use the previous method by just using webpack.
00:26:16.894 - 00:27:05.838, Speaker A: And this will work in a reliable way. Okay, so we are done with this section. So next I'm going to show you how you can reduce the size of the ABI in the front end. So why we need to do this? Well, actually, when you use truffle to import the ABI, you don't just import the ABI, but you import the whole contract artifact, which is this used json file with a lot of things that you don't need, like the contract bytecode for example, and a lot of other output that come from the solidity compiler. For web application performance is really important and we need to make sure that our front end bundle is as small as possible so that the loading time of our website is really fast. So I'm going to show you how you can reduce the size of this. It's basically when I mean reduce the size of the ABI, I actually mean to reduce the size of the contract artifact.
00:27:05.838 - 00:27:54.322, Speaker A: As a side note, be aware that when you use webpack in production mode, then webpack uses something that is called tree shaking to optimize the size of your front end bundle and what tree shaking does. It basically get rids of all the code and all the piece of data that you don't use. And this also works for json file. So that means that even though the contract artifact, json file is huge, then since we are not using most of it, then webpack is going to discard almost everything and it will only keep what we use, which is the ABI and the address. So if you are using webpack for your build process. All you need to do is to make sure that for production you activate the production mode in your webpack configuration, and Webpack will take care of optimizing the size of your front end bundle. You don't need to do anything.
00:27:54.322 - 00:28:32.958, Speaker A: The technique I will show you does not rely on webpack and allow you to produce ABi regardless on whether you are using webpack or not. All right, so let's go to a terminal window, and let's go to the root folder of our truffle project. And what I will show you now require you to install the solidity compiler. So you have two ways for installing the solidity compiler. The first way is by going to the official repo of solidity, and you need to follow the instruction to compile the compiler on your computer. And after you're going to have access to the compiler. The other way, which is most simple, is to use a NPM package called Sol C.
00:28:32.958 - 00:29:12.374, Speaker A: So you need to install it globally with NPM install G Sol C, and once this is done then you'll have access to a command called Sol C. So in my case, let's see which version of solidity do I have. So, solidity version and I have solidity 0.5.2. Okay, in order to compile a solidity smart contract, you need to use Sol C, and then you need to give it the pass to your smart contract. So in our case it's contract storage sol. In our case we are just interested in something very specific. We just want the ABI.
00:29:12.374 - 00:29:46.470, Speaker A: So in this case we need to pass a flag to the solidity compiler. So let's go back at the beginning of our command, and here we're going to specify Abi and let's press enter and see what happened. So here you can see that the ABI has been produced by the solidity compiler, so it's been outputted directly to std out. So that's why you see it on your terminal. So that means that it's not saved anywhere. So that's good if you just want to try things out. But in our case we want to store this into a file, so you can't specify an output directory with sauce C.
00:29:46.470 - 00:30:06.378, Speaker A: So let's see how we can do this. So we're going to add to our previous command the flag o, and let's call our output directory. Just output. All right, so now what we have in output. So ls output. Okay, so we have a file storage API. So let's see what we have in this file.
00:30:06.378 - 00:30:37.266, Speaker A: All right, so it's looking good to me. However, the problem is that this file has a real name, storage Abi. So ideally I would like this output file to end with a JSON extension. Unfortunately, it's not possible to specify this as an option to the solidity compiler. That's why we need to result to some Linux trickery here. Unfortunately for you, I figure out how to do it. So let's see our previous command with the sod compiler and let's get rid of the output.
00:30:37.266 - 00:31:13.182, Speaker A: And what we're going to do is pipe the result of this first command and we're going to feed this to a Linux utility called tail. So tail is a utility that allow you to extract the last line of a file or of a stream of text. So you can specify, for example, that you want the last ten lines. So it'd be something like this. But in our case we don't want the last ten line, but we want everything except the header of the output. So we can use a special notation that tells tails listen, I want everything from the end except the first four line. Then we're going to send everything to a json file.
00:31:13.182 - 00:32:00.898, Speaker A: So we're going to call this output JSON. All right, so now let's check out what we have in output JSON. Okay, so our json file has exactly the content that we want and it has the proper extension. All right, so next we are going to see what are the pros and cons of the different method I explained you for importing the ABI to the front end of your DAP first. The copy paste method requires no setup at all, so if you are just getting started it might be the best solution. However, you will soon find it very annoying to repeat this copy and paste every time you make a change to your smart contract, and it's also quite error prone, so it's not really a good long term solution then. Serving the ABI from a backend server is a first good step for automating the process.
00:32:00.898 - 00:32:37.626, Speaker A: It's also interesting if you don't want to use any front end packaging solution like webpack and want to keep it very simple. However, it's a bit annoying to set up and it adds a dependency to a backend for your DAP. So if you are fine using webpack or another frontend packaging library, I would not recommend this method. Then I show you how to import the API using webpack. This is a great solution because it integrates nicely with modern build processes for frontend application. It will work very nicely with frontend frameworks like React angular or VUE, for example. The only downside I see is that you need to use webpack.
00:32:37.626 - 00:33:13.874, Speaker A: But if you use project like create react application, this is already configured for you and all you have to do in your frontend application is to use the import syntax to import the json file of the ABI. No knowledge of webpack is required. And finally, I show you how to use a custom webpack loader called truffle solidity loader. The advantage is that you don't have to recompile and redeploy your smart contract every time you make a change. This webpack loader does it for you. It's a really nice extra automation. However, the downsides are that this webpack loader is not very well maintained and sometimes it can be a bit buggy.
00:33:13.874 - 00:33:28.460, Speaker A: So as a conclusion, I would recommend you to use the third method, which is to load the API as a json file using webpack. That's it for this video. Now you know everything about loading the API to the front end of your DaP. Thanks for watching.
