00:00:00.490 - 00:00:32.440, Speaker A: Welcome back everyone. This video is brought to you by consensus, a market leading blockchain technology company. Today we're going to be talking about one of their newest projects called Diligence Scribble. With new hacks happening around the web three world every day, it is becoming extremely important to test your smart contracts and make sure they have no vulnerabilities. I'll explain how you can use scribble along with mythril to create better tests for your smart contract tracks and lower the possibility of an attack. If you're new here, I'm jack and on eat the blocks. We help developers get into web three.
00:00:32.440 - 00:01:01.966, Speaker A: Do you know if your token contracts are secure? Even when you inherit your contracts from open zeppelin, small modifications can leave security vulnerabilities. Here's an example of an ERC 20 contract. If you want a challenge, I suggest you pause the video and see if you can find a flaw. It can be hard to notice flaws while just reading the code. So now we're going to use scribble and mithril to test this code out. Before we start, make sure you have the following dependencies installed. Next, install eth, scribble and mithril and we're ready to go.
00:01:01.966 - 00:01:39.206, Speaker A: We'll start off by creating a folder for this testing and then creating a solidity file with the ERC 20 code I showed earlier. I'll leave a link in the description with all the files we use in this video. Once you have that, go ahead and open it in your favorite text editor. I happen to already know that the flaw is in the transfer function, so for the tutorial's sake, we're going to start off by adding a property for that function. When you're making tests for your smart contracts, the goal is to create custom properties that show how the contract should act. Here are some examples from the scribble docs to get an idea to make these custom properties, we need to use function annotations in our contract. These annotations are doc string comments that are placed above contract functions and variables.
00:01:39.206 - 00:02:07.234, Speaker A: I'll start with an if exceeds property, which will be checked after a function successfully executes and it isn't stopped by a revert or other function guards. The next part is a message describing what you're checking. This is going to help you identify what goes wrong while you're debugging. The last part is a boolean expression. You can use any variables and function arguments here. This is where you write properties that describe how the state should look before and after the function execution. Okay, so let's delete that and make an actual function annotation for this transfer function.
00:02:07.234 - 00:02:37.290, Speaker A: This function will check to make sure that the sum of the to and from addresses is the same before and after the function is ran. If this is the case, we know no tokens were accidentally created or deleted. Here is the boolean equation. When you use the old function, you are stating that you are checking values before the function is ran. When there is no old function, the values are being checked after the function is ran. Okay, so we have our function annotation. Now we need to run the annotated code through scribble and create an instrumented version like we see in this flowchart.
00:02:37.290 - 00:03:10.322, Speaker A: Once we have the instrumented solidity file, we can use any of the tools on the right side out of these four. We're going to be using mythrule today. To instrument this file, run scribble on the file name with the following parameters. The output mode specifies that we want to output an instrumented file. The next parameter here specifies the name of the metadata JSON file that we want to use to create, and it'll keep track of arming and disarming for us, which brings us to the last parameter, which is arm. When working with scribble, we'll arm our contracts with annotations and test them. This will overwrite our solidity file with one that has extra instrumentations.
00:03:10.322 - 00:03:44.734, Speaker A: Once armed, we can see that three files were created. These are all for bookkeeping. As a user, you don't really need to know exactly how these files work, but you can learn more in the docs if you want to. When you want to undo these changes, you can simply use the disarm flag, which we will see later. All right, so now's the time to run our tests. You can use the command myth analyze filename t one executiontimeout 60 after 60 seconds, you should see that you got two violations, an assertion violation and a user assertion violation. We can see the first violation has the readable text from our function annotation.
00:03:44.734 - 00:04:10.858, Speaker A: If we were to decode this transaction data, we would see that the recipient of the transfer is the address from the from account. So the failure occurs when you send money to yourself. Let's now disarm. To edit and fix the code, we will use the same command as before, but with the disarm flag instead. You will notice the extra files are now gone back in the code. Let's look at this transfer function the way the code works right now, we are setting both new balances. First and then actually updating them.
00:04:10.858 - 00:04:39.606, Speaker A: The problem here is that we are then setting the same address's balance twice, or effectively just setting the person's balance to the new balance two variable. Let's fix this so that the function will update the address one at a time. Okay, that's all we needed. Now it's time to go and arm the contract. We're going to do this the same way we did it before, and then after that, we're going to run the myth test. That's the workflow for scribble, and it's actually really easy. After the myth test is done, we can see that all tests have passed and the vulnerability is now gone.
00:04:39.606 - 00:05:04.618, Speaker A: Perfect. Okay, so now we've seen how standard token contracts can be made insecurely. Let's look at another popular contract type. Here is a very basic ownable contract. We're going to say that the other contracts want to extend this one so that they can have an owner for whatever contract they want. To illustrate this, we're going to have to make an even simpler contract called message. All this contract will do is allow the owner to set a status message, and then anyone can view that message.
00:05:04.618 - 00:05:32.866, Speaker A: When we're working with multiple contracts, we need to make sure our files are inside of a truffle project. You don't need to run the truffle project to perform tests, so I won't go over that here. If you want to learn how to run your project as well, then we also have videos covering Ganache and truffle deployment. First, make sure truffle is installed along with scribble and mithril, which we installed earlier. Create a new folder and run truffle init. Inside the contracts folder created, we will add our two contracts. These files will be in the GitHub repo in the description.
00:05:32.866 - 00:06:07.050, Speaker A: Now we can annotate the ownable contract to make sure it's secure. The main things we want to check for here are going to be in the transfer ownership function. First, let's create a function annotation to make sure that the owner is the new owner after the function is ran. Then let's also make sure that if the function succeeds, the person to run the function was the old owner. All right, let's go back to the contracts folder now and run the command we did before. This time, we don't need to specify the metadata file as scribble will find the truffle project and automatically place it in the root. The project will see that message Sol extends from ownable Sol and check for annotations in the ownable file.
00:06:07.050 - 00:06:33.638, Speaker A: Let's run myth analyze on the newly instrumented file. Now, when it gets done running, you can see that the tests pass, but we still have a big security flaw. You may have noticed that the owner is not a private variable. This means that it can be accessed by derived contracts. In fact, we can see that message sold does exactly this. The contract maliciously creates the new update owner function that can change the owner without any permission needed. To test for things like this, we can use another type of annotation called an if updated.
00:06:33.638 - 00:07:10.770, Speaker A: You can place this annotation above a variable and it will run when the variable gets changed. Here we are testing to make sure that if owner is updated, the message sender was the old owner or the constructor function. Let's arm up the instrumented file again and then run the myth analysis on it. This time we see that the assert is thrown and the error message tells us that somehow the owner variable was changed by someone other than the owner or zero address. Go ahead and disarm the function and then add private to the owner variable. Now arm the instrumented file again and run myth analysis. This time the analysis fails to run as the private variable no longer exists inside of message soul.
00:07:10.770 - 00:07:39.422, Speaker A: All right, that's all for the tutorial. These were some simple examples, but once your contracts start to get more complex, using a tool like scribble becomes necessary. As you know, we use Mithril to test our instrumented scribble code. This works well, but you can level up your testing with consensus fuzzing. Right now, they are letting people sign up to gain early access to the tool. With fuzzing, you'll be able to submit your instrumented code to their website and get an entire dashboard of the fuzz report ran on your project. The feature should be really useful, so I recommend you checking it out.
00:07:39.422 - 00:07:43.420, Speaker A: All right, well, that brings us to the conclusion of this video. Thanks for watching, and I'll see you later.
