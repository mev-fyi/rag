00:00:00.170 - 00:00:30.386, Speaker A: Hey, this is julian and you are on it. The blocks in this video I'm going to explain you solidity libraries. By the way, if you want to know my most useful solidity tips, check this free email series link in the description. Libraries are very useful when you want to reuse some code. For example, if you have two smart contracts with the same code, then you can extract the common code into a library and you avoid code duplication. So let's see a simple example. So the way you declare a library is with the library keyword.
00:00:30.386 - 00:01:25.222, Speaker A: Then you give a name to your library and inside you can define variables and function like a smart contract. So let's define a simple function that adds ten to an integer. So we call this function add ten and it takes a single argument, make it a public function and it's going to return an integer and just going to add ten to our argument. So now if we want to use this function in our smart contract, we'll reference the library and the function. So let's see how it works. So we're going to create function inside our smart contract and we reference the library. And then we use the dot notation, then the name of the function that we want to call.
00:01:25.222 - 00:02:03.058, Speaker A: Then we specify the argument and we store the result in a variable. So this is a simple use case. But there is a more advanced use case where inside a function of your library you can manipulate storage variable of the calling smart contract. And that's really where a library become really powerful. If you're interested in the low level details behind the hood solidity, actually use an EVM opcode that is called delay gate call. And with this opcode a smart contract can call another contract in its own context. Okay, so let's see an example of how this works.
00:02:03.058 - 00:02:37.950, Speaker A: So for that we are going to define a struct in my library. So for example, we can define a player and this player. It's going to have a single field called score. And we're going to define a function to manipulate this struct. So for example, we can increment the score and the first argument received will be the struct. So the player struct and the memory allocation will be storage. And this will reference a player struct inside my contract.
00:02:37.950 - 00:03:15.542, Speaker A: And the second argument will be the number by which we want to increment the score points. For example. Okay, we make this public. So inside we're going to reference our player argument and the score is going to equal the old score plus the number of points that we passed. Okay, so now let's see how we can call this function from my contract. So let me clean up a little bit here and here too. Okay, so actually in my contract we're going to define a container for the struct.
00:03:15.542 - 00:03:58.162, Speaker A: So for example a mapping of integer to playerstruct. So here we reference mylibrary player and we call this players with S. So if you want to call increments, call and pass the first player. So we reference the library, then the name of the function, then we reference our container players. And for example we want to select the first one, that's the first argument. And if we want to increment from ten point, then we do like this, easy. So here, what's interesting in that we didn't even have to define the struct inside our contract.
00:03:58.162 - 00:04:33.886, Speaker A: The struct was also defined in the library. And actually there is an even better syntax. And this is using for, so with using for, you can attach your library to a specific type. So let me show you how this works. So in your smart contract you specify using then the name of the library, we use the for keyword, and finally the name of the type that we want to attach. And this type itself can also be defined in the library, like in our case. So we want to attach my library to mylibrary player.
00:04:33.886 - 00:05:12.218, Speaker A: And now we can simplify a little bit, the call to increment store. So instead of passing the player struct like this, we going to pass only the second argument. And here we replace my library by the player struct. And so when you do like this here in this increments call function, the first argument will not be what you see here, but it will be this thing here. So now you can call increments, call directly on your type. So that's a little bit more readable. Okay, so now you know the two use cases of library.
00:05:12.218 - 00:06:05.646, Speaker A: And last thing I'd like to tell you about is the difference between deploy and embedded libraries. So there are two ways libraries can be deployed. So if all your function have a type of public, then when you deploy the library, it's going to have its own address on the blockchain. So if you have smart contract A and B, a can call the library and the library is going to manipulate the variable of a. But later when smart contract B called the library, this time the library is going to manipulate the variables of B. So a single library can service multiple smart contracts and the other kind of library is embedded. And this happened when all your function have a type of internal and so in this case, when you deploy the library and the calling smart contract, both of them are going to live inside the same ethereum address.
00:06:05.646 - 00:06:59.914, Speaker A: So if you've been following this tutorial series since the beginning, you probably know quite a bit of solidity now. So congratulations for following up to here. And the next step is really to put in practice your theoretical knowledge. So you need to write real life smart contract. And actually I've built a huge course where we built 30 smart contract and decentralized application. So it start with really, really simple smart contract and then it gets more and more difficult as we progress through the series. And at some point we're going to start to do some advanced smart contract, like for example some Dao, we're going to do some games, also some lottery, FOMO, 3D, rock, paper, Caesar, and after it's going to continue with Yash 20 token, ICO, ERC 721, Twitter, eBay, Tinder, we're going to see the oracle pattern and some advanced assembly.
00:06:59.914 - 00:07:28.150, Speaker A: So this is a very, very advanced course for solidity. So if you really want to become a pro, check out the curriculum at this address. And finally you can check out the official documentation of solidity at this address. So this is the end of the tutorial series on solidity. And in the next video I'm going to start another series on gas. Gas is a very important concept for smart contracts, so make sure you check out this series. Thanks for watching and see you for my next video.
00:07:28.150 - 00:07:28.450, Speaker A: Bye.
