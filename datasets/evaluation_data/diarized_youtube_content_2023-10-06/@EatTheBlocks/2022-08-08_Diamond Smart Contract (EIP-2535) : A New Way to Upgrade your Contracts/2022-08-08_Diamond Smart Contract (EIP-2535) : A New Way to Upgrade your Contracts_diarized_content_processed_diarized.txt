00:00:00.250 - 00:00:17.054, Speaker A: Okay, developers, welcome back. Today we'll be looking at the diamond smart contract, aka EIP 2535, and how it helps to upgrade your smart contracts. This video is produced by Tebow, made by Alex and voiced by me, Joel and on eat the blocks we help web two developers get into web3.
00:00:17.172 - 00:00:46.614, Speaker B: Hey, sorry to interrupt. Just a quick update. I wanted to let you know that if you ever need a smart contract audit, we can help. I know that quite a among you have created custom tokens, decentralized exchanges and other types of dapps. Now, the next step is to make sure to identify all possible smart contract vulnerabilities and make sure that your code works as intended. You want to bring peace of mind to both your users and your partners. The solution we offer you leverage one of the most famous brands in the blockchain space, unblock labs by eat the blocks.
00:00:46.614 - 00:01:00.286, Speaker B: You will have your code reviewed by our team of experts and even by Julian himself. So, how to get started? It's super simple. Just click on get in touch, send us a link to your contracts and a brief explanation of what your project is about. We'll get back to you real soon.
00:01:00.468 - 00:01:53.390, Speaker A: The EIP 2535 standard has several projects already using it, most notably Derivodex, Barnbridge and Cyber. What is it and should we use it instead of the commonly used proxy upgrade pattern? A diamond refers to a smart contract system where functionality and storage are split up into separate contracts. In short, to fix the problem of smart contracts not being upgradable due to their immutability, a proxy pattern deploys two contracts. A proxy contract is what the user interacts with and which holds the data. This contract is the immutable part, but it contains a fallback function which will catch any function call and use delegate call to forward it to a second logic contract. In other words, we can have our logic defined separately from our data. This allows us to change the logic contract without changing the underlying data.
00:01:53.390 - 00:02:37.402, Speaker A: All you need to do is change the address of the logic contract defined in our proxy, usually done via governance or at a minimum, controlled using a multisig wallet. With this proxy pattern, we can effectively have upgradability for smart contracts. But it comes with some limitations. What if you want to upgrade only a small part of a complex contract? You'll still need to upgrade to a completely new logic contract. Reusability of logic contracts by multiple proxies is possible, but it's not very practical. There's no way to combine logic contracts or use only parts of one. You cannot have a modular permission system which for example would allow some entities to only upgrade a subset of existing functions.
00:02:37.402 - 00:03:15.622, Speaker A: Instead. It's an all or nothing approach. One must also take special care when assessing data within the logic contract after upgrades, because the data in the proxy contract never changes with upgrades. That means if you were to stop using a state variable in the logic contract, you would still need to keep it in the variable definitions, and when you add state variables, you may only append them to the end of the definitions. On top of that, logic contracts can easily reach the 24 kilobyte max contract size limit as well. So this is where the diamonds come in. The core idea is identical to the proxy pattern, but with the difference that you can have multiple logic contracts.
00:03:15.622 - 00:04:01.000, Speaker A: There are currently three ways to integrate a diamond diamond one hard hat, diamond two hard hat, and diamond three hard hat. Which one should you choose? They all do the same thing, so it doesn't matter too much. If you plan to do many upgrades and care about gas costs, consider going with diamond two. Otherwise, diamond one is probably a better choice since the code is much more readable. This is the core logic of diamond one for adding and removing functions, with some checks removed for better readability. Now, with all that said, which one is better? Proxy upgrade patterns or diamonds? Let's look at the pros and cons. Diamond pattern allows facet reusability, modular upgradability, modular permission system, storage slot management, and avoiding max contract size issues.
00:04:01.000 - 00:04:28.090, Speaker A: However, it is more complex and harder to maintain with not many big real life projects yet. It's also not supported by tools like Etherscan, but alternatives to Etherscan do exist, which is called Looper. Hence, would you consider implementing diamond pattern to your decentralized applications? If you'd like to learn more about upgradable contracts, feel free to check out this video made by us that talks about proxy contracts. I'll see you guys again next time. Bye.
