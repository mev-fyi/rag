00:00:00.330 - 00:00:26.934, Speaker A: Have you ever dreamed of creating your own cryptocurrency? If you try to fork bitcoin or ethereum, it's gonna be really hard. But with ERC 20 tokens, you can create your own virtual currency. It's way easier. Anybody can do it. In this video we are going to code an ES 20 token step by step on the Ethereum blockchain. This is a beginner level project. We're going to use a simple tool and you don't need to install anything on your computer if you don't know me.
00:00:26.934 - 00:01:01.102, Speaker A: I'm Julian and on idoblocks I teach blockchain development. Quick service announcement there is only one way to contact me. It's by using my email in the description. Don't be fooled by scammers who try to impersonate me in the comments. An ES 20 token is a virtual currency that lives on the Ethereum blockchain. Contrary to the native coin of Ethereum ether, anybody can create his or her own ES 20 token. When you create your token, you can allocate as many units to yourself.
00:01:01.102 - 00:01:38.090, Speaker A: Each token lives in its own smart contract. If you never heard of smart contracts, these are the small programs that run on the Ethereum blockchain. ERC 20 is a standard for tokens. In theory, you could create a token that does not respect the ERC 20 standard, but if you do so, no exchanges will be able to deal with your token. That's why it's best to stick to the ERC 20 standard. This is the ERC 20 standard. The basic idea of ERC 20 is that each address has a balance of tokens, and each address can transfer its tokens to another address.
00:01:38.090 - 00:02:18.374, Speaker A: The standard of ERC 20 describes the functions that need to exist in the smart contract of your token. If you never heard of functions, you can think of them as a way to read or write data to a smart contract. There are three functions related to the metadata of your token. So that's the name of the token, the symbol which is an abbreviation to identify your token. On exchanges, we sometimes call this the ticker, and we also have the decimals function. Decimals define how many fractions of a whole token can exist. For example, if the US dollars was an as 20 token, the decimals parameter would be two.
00:02:18.374 - 00:02:53.598, Speaker A: If ether was an as 20 token, the decimals parameter would be 18. And most tokens also use this convention for their decimals parameter. This is only used by wallets to display the correct number of token that you own. But the other functions on the smart contract do not use the decimals parameter. Then we have the total supply function that gives us the total number of tokens. Then we have the balance of function which gives us the amount of token owned by an address. Then we have functions to transfer tokens.
00:02:53.598 - 00:03:39.294, Speaker A: The most simple is just transfer. You specify the recipient address and the amount of token. The other function to transfer tokens is called transfer from. This is what we call a delegated transfer, which means the owner of an address can allow another address to spend tokens on his behalf. It's similar to when you allow a credit card to spend the money of your bank account, except that for es 20 tokens, each spender has a maximum spending limit, after which it's not possible to spend anymore. When you call transfer from, you first specify the from address, the recipient address, and the amount. Then we have the approved function where the owner of tokens can allow a spender to spend some tokens on his behalf.
00:03:39.294 - 00:04:23.218, Speaker A: Then we have the allowance function that tells us how much tokens were approved to be spent for a combination of owner and spender, and after that we have events. But these are less important. There are different languages for creating smart contracts on Ethereum. The most popular one is called solidity, and I recommend to use this one. The syntax of solidity looks like JavaScript, but it's very misleading because solidity works very differently from JavaScript. First of all, solidity is a compile language, whereas JavaScript is interpreted. This means that you can run JavaScript directly, whereas for solidity there is a compilation step.
00:04:23.218 - 00:05:00.710, Speaker A: Another big difference is that solidity is a statically typed language, whereas JavaScript is dynamically typed. What does it mean? In any programming language we represent data by using variables. Each variable has a specific type. For example, in JavaScript we can represent a text by using the string type, and we can represent a number by using the number type. Even though we have types in JavaScript, this is quite transparent to the programmer because we don't have to specify which type we use for each variable. The JavaScript compiler is smart enough to figure it out. In the case of solidity, we have to specify the type of each variable.
00:05:00.710 - 00:05:34.146, Speaker A: For example, if you declare a variable of type number, you have to explicitly declare that this variable is going to be a number. It takes a bit more effort than in JavaScript. Another big difference between the two languages is that solidity is much more limited. In solidity, we execute our code on the blockchain and we have to pay for each transaction. That's why we try to keep our code, simple and solidity as much less features and built in function compared to JavaScript. Another big difference is that with solidity we can transfer money. This is a built in feature.
00:05:34.146 - 00:06:15.618, Speaker A: In JavaScript we can do it too, but this is not a built in feature. We have to use an API like stripe or PayPal, which means we rely on their permission to use the API. In solidity we can move money freely, no need for permission. Talking about permission another difference between solidity and JavaScript is that in solidity you can interact with any smart contract deployed on Ethereum. You don't need any permission. This property of smart contracts is called composability in comparison with JavaScript. It's not possible to interact with some JavaScript code running on another server unless it has an API and it lets you access it.
00:06:15.618 - 00:06:56.482, Speaker A: Last big difference between solidity and JavaScript is that with solidity, once you deploy smart contract to Ethereum, you cannot update your code anymore. If there is any bug, any security vulnerability, this is too late. That's why testing and security are very important in solidity. In this section we are going to code our ERC 20 token, so for that we will go to remix. Remix is an online code editor for solidity, the programming language for smart contracts. Remix is very easy to use. You just have to load this URL in your browser and that's it.
00:06:56.482 - 00:07:37.818, Speaker A: You are ready to create smart contract in solidity on Ethereum. The first thing we'll do is to go to the compilation tab here and we will select the latest version of solidity by default. You always want to start with the latest version because that's the one with the latest feature and all the bug fixes. So we're going to select 0.8.5 and we make sure that we have autocompile activated. This is very important because every time you make a mistake in your contract, you're going to have real time feedback. Then we are going to the file Explorer here, so you may have to create a new workspace if this is the first time that you use remix.
00:07:37.818 - 00:08:17.590, Speaker A: And after we are going to create a new file with this icon here, we're going to call this mytoken soul. So this is the extension for three DT file, and we're going to start with what we call the pragmat statement. You have this in every three t file, and here we specify the version of three DT that we are going to use. 0.8.5. This matches what we've selected before in the compilation tab. After we are going to define our spot contract with the contract keyword. And we specify the name of our token.
00:08:17.590 - 00:09:00.982, Speaker A: So here it's a good practice to choose the same name as your file, my token. And after that we could code from scratch all the function and all the variables in our smart contract. But if you do this, it's really easy to make a mistake and introduce a security vulnerability instead. It's a way better idea to take a standard implementation that has been reviewed and audited many times by the community. There are several standard implementation, and the most popular one is the implementation of Open Ziplink, a popular library for solidity. This is the GitHub repo of Openzepling. So we go there and we go in the contracts folder.
00:09:00.982 - 00:09:45.298, Speaker A: So they have many smart contracts that you can use in your project, and we're interested in what they have in token. And we're going to go in ERC 20. Then in ERC 20 sol here we have the standard implementation of ES 20 by open zeplink. So they define the name of the contract. They define some variable here and here we can see some function that we saw in the YaS 20 standard, like name, symbol, decimals, et cetera. So let's scroll up in the constructor. And so we need to pass it the name and the symbol in the constructor.
00:09:45.298 - 00:10:36.050, Speaker A: So what we're going to do is we're going to copy this URL, then back to remix, and we are going to import the URL that we just copied. So here between single quote, let's give the full URL to our smart contract. And here, this is cut off on the video, but I'm going to end the import statement by a single quote and a semicolon. All right, so now we have imported the ES 20 implementation, and next we are going to make our token inerit from ESC 20 of open ziplin. And for that we use the ease keyword. Then we specify ERC 20. And so now all the functions and all the variable that were defined in ERC 20 of open zeppelin are available in my token.
00:10:36.050 - 00:11:01.658, Speaker A: So transfer, transfer from et cetera. We can access all of this. We don't need to redefine them. This being said, we do need to define a constructor. So this is a function that will be called only once when we deploy our token and when we call our constructor. We can also call the constructor of Es 20 of open zeppelin. And there are two things to specify the name of our token.
00:11:01.658 - 00:11:31.886, Speaker A: So for example, let's do my token and then the symbol. So usually the symbol is three letters, so it can be my empty n. And then we're going to define an empty body between curly braces for the moment. So just to be clear here, when you deploy my tokens, constructor is executed. Then ERC 20 constructor is executed as well. We pass these two argument, mytoken and mtn. So we go in the GitHub repo of open zeppelin.
00:11:31.886 - 00:12:18.266, Speaker A: And so my token here is going to be in name and mtn is going to be here. And after it's going to be assigned internally to name and Siebel. So if you do this, you will have your token, but you're not going to do much with it because nobody won't have any token. So usually after deployment you want to create all the tokens and send them to yourself. And for that we can use another function which is called underscore mint. So let's scroll down, let's scroll down where we have this underscore mint and we have to specify the account that received the token and the amount. So what's interesting here is that we don't need to really understand what's going on inside.
00:12:18.266 - 00:12:44.450, Speaker A: We just need to understand the function signature. That's it. So let's copy this, let's go back to our code, and in the constructor we paste this underscore mint. And so for the account we going to specify the address that has deployed a contract. So that's MSG sender. This is a built in variable in solidity. And for the amount, well that's up to you.
00:12:44.450 - 00:13:27.742, Speaker A: You have to decide what's the total supply of your token. So for example, it can be 10,000 and usually for the decimals parameter we want to use ten power 18 like most of the YaS 20 token. So here we're going to multiply this by ten power 18 and we finish this statement with a semicolon. And so now we're going to have 10,000 token that are mintane to MsG sender. I know that this decimals parameter that I specify here is very confusing for people. So you really decide what you want to do. If you want, you can just say, okay, you know what, my decimals number is one.
00:13:27.742 - 00:14:01.250, Speaker A: And so in this case, I mean 10,000 token and that's fine. But you might run into problem if you want to transfer some small quantity of token. So usually we just leave this to ten power 18. All right, so this is a very simple token and it would work. So you as the creator of the token, you will have all the tokens, and then it's up to you to distribute them in an ICO, in an airdrop. And then people will be able to use all the functions defined in ERS 20. So transfer, transfer from et cetera.
00:14:01.250 - 00:14:38.150, Speaker A: But it's possible that you want to do something a little bit more sophisticated. So maybe you want to be able to mint more token after. So that means you don't have a fixed supply. So in this case you can create another function called mint. And you're going to specify the recipient and the amount, make this external so that we can call it from outside smart contract. And then we're going to call again underscore mint and we're going to mint, we're going to forward the two parameter that we received. But if you do this, it's very dangerous because there is no access control.
00:14:38.150 - 00:15:22.158, Speaker A: Anybody can call this function and basically it's going to create a huge inflation and depreciate the value of the other holders and depreciate the value of the already existing tokens. So to put some access control in place, first we will need to define an admin. So for that you will need to define a variable here. So address public admin. And here in the constructor we'll set the admin to the deployer of the smart contract. And inside the mint function you can require that the sender of this transaction is the admin. Otherwise the arrow message is only admin.
00:15:22.158 - 00:16:19.134, Speaker A: And if someone else try to call this function, this request statement is going to fail and the transaction is going to be canceled. So it's how you do access control for minting your token. And if you want, you can have another function to allow people to burn their token. So here, let's create this burn and we specify the amount. And this time is not going to be only the admin, but anybody can call this function, but they can only burn their own token. So for example, if the admin has a lot of token and is willing to burn his own to make all the other more valuable, so that would be possible. And so here we're going to specify Msg sender and we specify the amount and so underscore burn.
00:16:19.134 - 00:17:00.180, Speaker A: Just to be clear, it's also defined in the 20 implementation of open zeppelin. So this underscore burn function. Underscore means this is not part of the ES 20 standard, it's just specific to the implementation of open zeppelin. And if you want to do more customization, then you can inspect the code of Es 20 of open ziplink and see if there are other function that you want to use. And also what you can do is you go to ES 20, you go to extensions and you will see some example, for example ESC 20 burnable. So here this is another wedge to the burn. You also have a burn from.
00:17:00.180 - 00:17:50.146, Speaker A: What else do we have? You have, yes, 20 capped. So I think for a maximum total supply I think you can mint up to a certain amount. Yeah, here there is a required statement in the mint function. Next, let's go back to remix and I'm going to show you how you can deploy this. So we go to the deploy tab, and first you want to deploy this on a local development blockchain which is completely independent from main net, the real network of Ethereum. So for that you select Javascript VM and it's going to create a couple of addresses with 100 fake ether for each of them. Gas limits, you don't touch it.
00:17:50.146 - 00:18:22.638, Speaker A: Here we see our contract. Mytoken saw we click on deploy and after you will see here your contract. So let's scroll down, deploy contract. And here we can see all the function of ES 20. Even though we did not define all of them, we can still access them. For example transfer from, we never defined them and we still have access to them. So the orange button are the function that allow you to modify data and the blue one are the function to read data.
00:18:22.638 - 00:19:05.660, Speaker A: So for example, let's try to get our balance. So we go up, we select, we copy our address here, let's go down, balance off, let's paste this, okay, let's click on balance off. And we can see that we have 10,000 tokens. So the reason why you see a huge number, it's because you see the number of decimals, which is ten power 18. And so let's try to, let's copy this and we're going to transfer some of our token to someone else. For example, let's transfer all of our token to the second address. So okay, let's copy the second address.
00:19:05.660 - 00:19:35.814, Speaker A: I select back the first address because this is going to be the sender of the transaction. Of course you cannot send a token of someone else unless they call the approve function before. So here let's go back to transfer. And after the comma we past the second address, okay, we click on transfer, okay. And we have an error, error encoding argument. Invalid address. Why you are not happy, my friend? Oh, I know why.
00:19:35.814 - 00:19:56.620, Speaker A: It's because the address needs to be the first argument. So the address first. Then let's copy here this number. So all of our token. We're going to send all of our token to this address transfer. Okay, so here you can see the green check mark. So the transaction worked.
00:19:56.620 - 00:20:47.110, Speaker A: So now if you try to see the balance of the first address. So let's copy this. Balance of, let me see, balance of the first address, you should see now zero. And now if you see the address of the balance of the second address. So let's copy this. Now you should see 10,000 balance off. Okay, that's after you can keep playing around with all these functions and when you want to deploy your smart contract to the main net of Ethereum, well the first thing you need to do is to install metamask which is a chrome extension that is a wallet for Ethereum.
00:20:47.110 - 00:21:18.050, Speaker A: You create an address there, you send some ether to pay for the transaction fee. Then here in environment you will choose injected provider. Then you will see a pop up of metamask that asks you to connect your metamask to remix. Then you select the correct account. Here you click on deploy and then you will see a pop up of metamask. You click on confirm and it's going to send a transaction and deploy your smart contract for real. In this video I'll show you how to create an arc 20 token on Ethereum.
00:21:18.050 - 00:22:06.100, Speaker A: Everything you learn in this video is also applicable to Bep 20 tokens on the binance smart chain. Binance smart chain uses the same technology as Ethereum and Bep 20 is just another name for ES 20. In this video we used remix. Remix is great for learning and testing new features of solidity, but this is also quite limited and if you are serious about your es 20 token, at some point you will need to switch to a more robust tool like truffle. Truffle is a framework for creating smart contracts on Ethereum or binance smart chain and a good follow up to this video is to try to recreate your ES 20 token using the truffle framework. And for this you can watch this tutorial on Truffle on my channel channel. I will see you there.
