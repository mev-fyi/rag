00:00:00.330 - 00:00:01.886, Speaker A: In this video, you're gonna learn how.
00:00:01.908 - 00:00:10.490, Speaker B: To code a solidity smart contract on the Ethereum blockchain by building a game with virtual zombies.
00:00:10.650 - 00:00:12.894, Speaker A: This is a tutorial for beginners, so.
00:00:12.932 - 00:00:22.046, Speaker B: You don't need to know anything about Ethereum, solidity or even web development. You're gonna do all the coding in your web browser, so you don't need.
00:00:22.068 - 00:00:24.078, Speaker A: To install anything on your computer.
00:00:24.164 - 00:00:53.934, Speaker B: You're gonna learn a. It's going to be easy to follow and fun. Let's get started. For those of you who don't know me, my name is Julian, and on my channel eat the blogs, I teach blockchain development and how to find your first blockchain job. So you go to this URL, then you click on get started. And we're going to start with the first course, which is making the zombie factory. All right, so let's click here.
00:00:53.934 - 00:01:12.302, Speaker B: Chapter one. So we're going to build a zombie factory to build an army of zombies. So our factory will maintain a database of all the zombies of our army. Our factory will have a function for creating new zombies. And each zombie will have a random and unique appearance. So each zombie will have a DNA.
00:01:12.446 - 00:01:14.926, Speaker A: And the way this DNA works, it's.
00:01:14.958 - 00:01:44.970, Speaker B: Going to be a 16 digit integer like this one, like for human DNA. Each number here will have some real impact on our zombie. For example, the first two digit map to the type of the head of the zombie. The second two digits, the zombie eyes, et cetera. So you know what? Let's play around with the sliders here and see how it modifies the DNA and the appearance of our zombies. I can modify the head here, the eyes. I like this one shirt.
00:01:44.970 - 00:02:00.478, Speaker B: That's pretty cool. Skin color, eye color. And after, when you're done, you click on next. So this is on the bottom right corner. It's not visible on my screen. So now we're going to start coding solidity.
00:02:00.574 - 00:02:03.314, Speaker A: So the code of solidity live inside.
00:02:03.432 - 00:02:33.934, Speaker B: What we call a smart contract. And we put smart contract in a single file. And the first element in this file is the version of solidity that we're going to use. So here, the tutorial tells you that we're going to use this pragma statement. That means we want a version of solidity which is compatible with solidity 0.5 but incompatible with three DT 0.6. So at the time of recording this video, three DT is already at 0.6.
00:02:33.934 - 00:03:04.130, Speaker B: But in this tutorial for crypto zombies, we're going to stick to three DT 0.5. There aren't too many differences between six and five. So everything that you learn in this tutorial will still apply to six. And we need to terminate this statement by a semicolon like everything in solidity. So next we're going to declare our smart contract with the contract keyword and we define the name of our smart contract with hello world. We open the parentheses.
00:03:04.290 - 00:03:08.230, Speaker A: So actually our contract will be called zombie factory.
00:03:08.310 - 00:03:34.078, Speaker B: So let's rename this zombie factory. All right, so then you can click on check answer. So we can't see it on my screen, but that's below and here. Victory. So now I have the right to click on next. Next we're going to see what are state variables. State variables allow you to store data in the blockchain.
00:03:34.078 - 00:03:56.626, Speaker B: For example, you can store numbers or string of characters. So for this lesson we're going to focus on integer. So there are two type of integer. In solidity. There are unsigned integers, so these can only be positive. So one, two, three, et cetera. And you also have sine integer.
00:03:56.626 - 00:04:41.880, Speaker B: This one can be negative or positive, but in most cases you will want to use unsigned integer. So actually unsigned integer can have different size. So when you just write unsigned integer like this, this is an alias for unsigned integer 256, which means you have a huge number of 256 bits. So that means the biggest number you can represent is two power 256 minus one, which is really a huge number. So you probably never need to store as big of a number. So you can also store integer that are smallest, for example, u int eight. So in this case the bigger number is two power eight minus one.
00:04:41.880 - 00:05:15.742, Speaker B: Then you have 16. 326-4128 so if you know in advance that your numbers will be smaller than in order to save some space, then you can use this specialized type. But we're going to stick to uint. We're going to use the Un type to create a variable to store our zombie DNA. So on my screen it's get off. But you should see here the name of the variable dna digits. So dna digits.
00:05:15.742 - 00:05:40.066, Speaker B: And it's going to have an initial value of 16. All right, so let's click on check answer. Yes. Okay, so now let's click on next. So now we're going to do some math in our smart contract. So in solidity, we can do all the basic arithmetic operation. So we can add two variables.
00:05:40.066 - 00:06:39.018, Speaker B: So here if I have uint a, uint b, then I can do a plus b. I can also do subtraction a minus b multiplication division. And I can also do a modular division with the percentage sign. So the modulo operator gives you the remainder of a division. So for example, if that's ten modulo five, then this will be equal to zero because we can divide ten by five, so five times two and this is the exact result. But if for example we do ten modulo three, then three times three equal nine, so the remainder will be one. So this operation will be equal to one.
00:06:39.018 - 00:06:58.078, Speaker B: And actually we're going to use this property because we want to make sure that the dna of our zombies is exactly 16 characters long. And for that we can use the modular operator. So actually if you scroll down then you will see instruction to create a variable called DNA modulus.
00:06:58.174 - 00:06:59.746, Speaker A: This is cut off on my screen.
00:06:59.848 - 00:07:36.560, Speaker B: But let me remove this so uint DNA modulus and it's going to be equal to ten power. So power operator is this one DNA digits all right? Yes. So let's click on next. Sometime in solidity you need to represent complex data structure and for this you need to use struct. So to define a struct you use the struct keyword. Then you name your struct and inside you can define all the different fields of your struct. Each field has a type and name it.
00:07:36.560 - 00:08:06.358, Speaker B: So in our case we are going to create a struct name zombie. So let's do this. Struct zombie. It's going to have two field. First one is a name, so that's going to be of type string and the second one is an integer and its name is DNA. All right, so let's check the answer. Yes, this is correct.
00:08:06.358 - 00:08:43.150, Speaker B: Okay, so let's click on next. So very often in smart contract you need to represent collection of data and for that you can use arrays. So arrays in solidity, contrary to other programming language, can only contain the same elements. For example in Javascript you can have an array where the first element is an integer, the second is a string, the third is maybe another object. In solidity this is not possible. All the elements of the array needs to have the same type. So you can create arrays that have some simple type like arrays of integer, or you can also create array of struct.
00:08:43.150 - 00:09:22.202, Speaker B: So in our case we're going to need an array of zombie struct. So way we're going to declare this is first you declare the type of the array, then you put two square bracket. Then we're going to use the public keyword. So the public keyword will allow us to access this collection of data from outside the smart contract. And then we write the name of the arrays, zombies. So here you will note that when I define my struct, I use an uppercase. But here in my collection, my array of zombies.
00:09:22.202 - 00:09:40.918, Speaker B: Here, this is lowercase. This is just a convention. Okay, so let's check the answer. Yes, this is correct. Let's click on next. So next we're going to see function. So in solidity, function are really where things are happening, where you can manipulate data.
00:09:40.918 - 00:10:18.654, Speaker B: So first you define a function with the function keyword. Then you name the function and then you can give some arguments to the function. So this is data you're going to pass to the function as input. And after you can add some other keyword to your function to describe it. So we can make our function public, which means they can be called from outside the smart contract. Otherwise they can only be called from inside the smart contract. We're going to create a public function called create zombie, and it's going to have two parameter a string and an integer.
00:10:18.654 - 00:10:52.970, Speaker B: So let's do this function, create zombie. So here this is going to be a string. Here we're going to specify that it is a memory string. So I'm going to explain this later. And here we define the name of the parameter. And after that we're going to pass the DNA argument and we make this public. And then we open curly braces.
00:10:52.970 - 00:11:27.894, Speaker B: And after we're going to fill what's inside. But for now we're just going to stop here. So what is this memory thing? Well, there are two ways you can pass parameters in solidity. The first one is passed by value. So this is for simple types like integer, but for complex type like string or arrays. Want to avoid copying all the data because that will take more computational power. So instead we're going to use a reference to the complex type and we do this by specifying memory here.
00:11:27.894 - 00:11:50.160, Speaker B: All right, so let's click on check answer. Okay, so this is not happy. Why? I think this is because of formatting. Okay, let's put this on. One line directory. Doesn't make any change for the compiler of solidity, but this is just for the crypto zombie games. Oops, I forgot the underscore here.
00:11:50.160 - 00:11:59.700, Speaker B: All right, it's working. Let's click on next. So next we're going to write the code inside our create zombie function.
00:12:00.070 - 00:12:02.210, Speaker A: And what we're going to do is.
00:12:02.280 - 00:12:37.450, Speaker B: Add some zombie to our zombies array. So first we create a new zombie. So we declare a variable of type zombie. So we specify the memory location. So we want this zombie to be temporary and then we give it a name and then we create the zombie like this. We pass the argument, so name and DNA. And then we're going to add the zombie to our array.
00:12:37.450 - 00:13:12.074, Speaker B: So we reference the zombies array, we use the push method and we pass our zombie and that's it. And so now our zombies array has a length of one and has the zombie that we just put into it. So let's check the answer. All right, so why he's not happy. Okay. Because we can also do it in a way which is a little bit faster. So instead of doing upgrading this variable here, what we can do is just push it directly like this.
00:13:12.074 - 00:13:45.134, Speaker B: Okay, let's close the parenthes. And now if we check the answer now it's working. All right, let's click on Next. So previously I mentioned that when we create a function here, we can specify a public keyword. That means this function can be called by anyone outside the smart contract. So that means currently anybody can create a zombie. But we don't want this, we want to make this function only callable from inside the smart contract.
00:13:45.134 - 00:14:20.494, Speaker B: So that means if I create another function in my smart contract, I will be able to call this create zombie function. So the first step is to change this into private. And as a naming convention, we're going to add an underscore to the name of the function. So just to be clear, this is just a convention. Solidity doesn't actually care about this. But you're doing this because you want to signal to yourself and to other programmer that the intent of this function is to be private, but this is not strictly required. All right, let's check the answer.
00:14:20.494 - 00:14:46.102, Speaker B: And yes, this is correct. So now let's click on next three. Dt function can modify data inside the blockchain. That's the case of a create zombie function. But they can also just read value from the blockchain. And in this case we need to declare them a little bit differently. So first we need to add this returns keyword here.
00:14:46.102 - 00:15:15.250, Speaker B: Then we need to add the type of the value that we return. And finally we need to use the return keyword. So let's scroll down and let's see what is our task. So we need to create a private function called generate random DNA. All right, so let's do this scroll down function generate random DNA. It's going to take one parameter called underscore str. And this is a string.
00:15:15.250 - 00:15:45.420, Speaker B: Okay, so memory location is memory. We call this STR and we make it private. And in order to declare that this is a read only function. It doesn't modify data. We need to use the view keyword and then the returns keyword to describe which type we return. And it's going to return an integer. And for now we will not write the body.
00:15:45.420 - 00:16:13.138, Speaker B: This will be in the next lesson. So let's check the answer. Yes. All right, so now we need to implement the body of the generate random DNA functions. We basically need to generate a random number by using this string here as input. So for that we're going to use a solid function called kchak 256. So that is a hashing function.
00:16:13.138 - 00:17:20.434, Speaker B: So if you don't know what is hashing function, that's basically a mathematical function that accepts some input and that produces an output of a fixed size. But this output will be very, very different if you change just one tiny bit of the input. So this is used a lot in cryptography, on the web and in computer in general, and we're going to make use of that. So ketchak 256 in input, it accepts a data type called bytes, but this is different from the string that we have. So we're going to use another solidity function to transform our string into a byte that's ABi encode packed. So I know that's a bit cryptic, but all you have to understand is that we need to transform the input data type so that it suits what ketchup 256 is expecting. And next, ketchup 256 is not going to produce the output we want because we want an integer as output.
00:17:20.434 - 00:18:13.980, Speaker B: And for that we're going to use another feature of solidity that is called typecasting. So, typecasting allow you to take a data type, which is a certain type and transform it into another type. So for example, here in the example they show you how you can cast something into a uint eight. So all you have to do is you use the name of the type, then you put parentheses and you pass the variable that you want to cast. So next, our task is to implement the generate random DnF function. So first we're going to create a variable called rand and that's going to be kshack 256, to which we're going to pass the string. But first, need to use AbI encode pact of str.
00:18:13.980 - 00:19:01.222, Speaker B: And we need to cast this into an integer. All right? And after we're going to return random modulo DNA modulus. So here why we need to do this, because we want our random number to be 16 digits at most. So here this variable is going to be 32 digits. It's going to be a huge number like this, but with a lot of digits, 32. But then this dna modulus, this is basically ten power 16. So that's going to be a huge number 16.
00:19:01.222 - 00:19:39.860, Speaker B: So by doing the modular division of this number by this one, then we know that the remainder, it's going to be 16 digit. So that's how you can generate a random number in solidity. Generating random number in a safe way is a very difficult topic, but for the sake of this tutorial, we're going to keep things simple. All right, so the solution worked. Let's go to the next lesson. So now we're going to combine the two private function that we created before, and we're going to create a public function to create zombies. So let's see how this work.
00:19:39.860 - 00:20:11.194, Speaker B: So we're going to create a function here called create random zombie. And it's going to take a single argument, it's going to be a string. So that's the name of the zombie. We call this underscore name. We make it public because we want these to be callable by outside the spot contract. So here we're going to do two steps. First, we're going to generate a random dna number, and after we're going to call create zombie.
00:20:11.194 - 00:20:13.860, Speaker B: So let's do the first step.
00:20:15.830 - 00:20:16.782, Speaker A: Generate.
00:20:16.926 - 00:20:56.638, Speaker B: Random dna and we pass it what we have as an argument, the name. And after we call create zombie, first argument must be the name, and second argument must be the random number that we just generated. So let's check the answer. All right, I just need to change this to rand DNA, the right script. Zombie is not happy. Yes, try again. And yes, it works.
00:20:56.638 - 00:21:47.034, Speaker B: All right, let's click on next. So now we're going to emit an event when we create a zombie. So events in solidity allow you to communicate with outside entities like web page, who listen to event coming from a smart contract. So this outside entity can show you in real time what's happening in a smart contract. So one difference between event and a normal variable is that you can subscribe to an event from outside smart contract. And another difference is that a smart contract can only create an event, but when it's been created, it cannot be read from the smart contract and it also cannot modify this event. So it's good when you want to create some data that is only for outside consumers.
00:21:47.034 - 00:22:24.438, Speaker B: When you want to use an event, there are two steps. First, you need to declare an event with the event keyword. Then you declare the name of the event, then which field will be inside the event. Then somewhere in a function you need to emit an event with the Emit keyword, you reference the name of the event and then you pass the value. So in our case, we're going to scroll down to the create zombie function and we're going to fire our event here. So let's scroll down because there are some specific instruction. So first we need to declare our event new zombie.
00:22:24.438 - 00:22:52.222, Speaker B: So let's do this here event new zombie. Then we use parentheses. So it's going to have a first field, which is the zombie id. That's a uint. Then we have a name. So that's a string, string name. And finally a field for the dna.
00:22:52.222 - 00:23:33.262, Speaker B: So that's also an integer dna and semicolon here. All right, and now let's scroll down to create zombie. So we're going to emit our new zombie event like this new zombie. So for the id, I'll explain you just after for the name, it's going to be name DNA. Easy. Okay, but what about id? Well, when we execute the push method, it's going to return the new length of the array. So the id will be the index of the zombie in the array.
00:23:33.262 - 00:24:07.766, Speaker B: So to have the index, what we do is we get the new length of the array and remove one because array at zero index it and here pass the id. So now should be fine. Okay, it has worked. So now let's click on next. So so far we have done the solidity path. That's what live on the blockchain. But our end users will not directly interact with our smart contract because that's not very user friendly.
00:24:07.766 - 00:24:41.430, Speaker B: They need to use the command line. So that's not what we want. Instead we want to offer a nice web interface for our users. So a website that can communicate with our smart contract. So for that we're going to use JavaScript and a library that is called Webster Js. Later in this tutorial we will go in more detail about how to use webstery, but here I'm going to give you a very quick explanation. So here we have the snippet that we would use in a real life application with web3.
00:24:41.430 - 00:25:20.450, Speaker B: So first we define Abi. So Abi, this is basically a JSON document that describe the interface of a smart contract. Then here, so we use the web3 object and we create what we call a contract instance. So that's an object that allows to interact with our smart contract. So here we need to have this reference to the Abi of the contract. We define the Ethereum address of the contract on the blockchain because each smart contract is identified by an Ethereum address. We pass this address to our object and actually with zombie factory we can interact with our smart contract.
00:25:20.450 - 00:26:06.002, Speaker B: So here we select an HTML element or a button and we listen to the click event. And when this is clicked then we get the value that was inputted. So here, that's the text box that you see here. We get the name and then we execute the create random Zobi function on smart contract and we pass it the name and we scroll down. So once again we use our zombie factory object and we listen to the new zombie event with new zombie function here. And every time we get a new event then we pass the detail of the event to our function generate zombie. And so this is going to basically update our image on the front end.
00:26:06.002 - 00:26:35.754, Speaker B: So it's going to receive the id name, the DNA. So here we adapt the data. It's not very interesting. And here we build an object with the different parameter of our zombie. So here we're going to pass the DNA string and we know that different part DNA means different things. So the first part means the head, the second part mean I choice, then share choice, et cetera, et cetera. And then there is some code that is not shown here.
00:26:35.754 - 00:26:54.850, Speaker B: But basically depending on which number you have here, we have to map these numbers to different picture. And so in the end we can display this. So let's play around and let's try to create zombie. For example, I don't know, for my random string ab. Wow, cool.
00:26:54.920 - 00:26:55.250, Speaker A: Okay.
00:26:55.320 - 00:27:17.586, Speaker B: What about c? Oh wow, totally different. D. E. So you can see that if you change just a little bit the input, then the zombie becomes really completely different. So yeah, that's pretty cool. So let's click on next. And yes, we have completed the first lesson of crypto zombies.
00:27:17.586 - 00:27:53.758, Speaker B: Now you can even show off and show your crypto zombie to your friend here. Click here and you can share this everywhere. Cool. And after scroll down and we're going to click on proceed to next lesson. So so far we can create zombie and we can see them on the front end and that's pretty cool. But there isn't any gameplay, anything that really we can do with our zombies. So in the next lesson of crypto zombie, we're going to add a new feature to our smart contract which is zombies will be able to attack their victim.
00:27:53.758 - 00:28:25.402, Speaker B: So let's start this. So in this lesson, zombies will be able to create other zombie by feeding on humans. The dna of the newly created zombie will depend on the dna of the zombie that first beat them. So here you can try to click on some human and see what happened. So it creates a new zombie. All right, so let's click on next. So in this lesson we will see mapping and addresses.
00:28:25.402 - 00:29:14.938, Speaker B: So in order to make our game multiplayer, we need to associate an ownership for its zombie credit. And for this we're going to use mappings and addresses. So mappings are a way to store collection of data in solidity. So the way that mappings work, it basically associates a key to a value. So first you use the mapping keyword, then you declare the type of the key, then an arrow key, then the type of the value, then declare if it's public or private, then finally the name of the mapping. And the other thing that we're going to use is Ethereum addresses. So as I mentioned previously, smart contract have addresses, but they aren't the only thing that can have addresses.
00:29:14.938 - 00:29:50.442, Speaker B: So people can also have ethereum addresses. These are series of characters like this and that uniquely identify an account on the blockchain. So let's scroll down and so let's see the instruction. So first we need to create a mapping zombie to owner. So to know which owner own which zombie. So the key will be the zombie id and the value will be the address of the owner. All right, so let's see in the code where we have our comment here.
00:29:50.442 - 00:30:19.970, Speaker B: Declare mapping here. All right, so we're going to declare our mapping like this. So the key is of type u int and then the value of type address. That's public and we call this zombie to owner. All right, and then it's cut off on my screen. But the other mapping we need to create owner zombie count. So that basically give us how many zombie owner has.
00:30:19.970 - 00:30:48.266, Speaker B: So mapping and the key is an address and then the value is a u int. How many zombie the owner has. It's not public and owner zombie count. All right, let's check the answer. Yes, this is correct. So let's go to the next lesson. So we have created our mappings but we're not making use of them.
00:30:48.266 - 00:31:34.314, Speaker B: So now we need to associate an owner to a zombie when we create new zombie. And for that we're going to use a special variable in solidity that is called msg sender. So msg sender is the ethereum address that called the function. So what is really cool with solidity smart contract is that you are sure with the security of the blockchain that nobody can hack this MHD standard variable. Every time you call a function on ethereum you need to sign your function call with the private key associated to your ethereum address. So it's absolutely impossible to force this msg standard variable. All right, so let's scroll down to the create zombie function.
00:31:34.314 - 00:32:16.646, Speaker B: And first we're going to update the zombie to owner mapping zombie to owner. So the id is this variable id and here the address is msg sender. Okay, and after that owner zombie count. So here we reference the sender of the transaction and we can increment a number in three t with the plus plus operator. Okay, so let's verify. And yes, it works. Okay, so let's click on next.
00:32:16.646 - 00:33:01.842, Speaker B: So in three t, another thing that you're going to use often is require. So rewire statement. You can basically test that a certain condition is true and if this is true, then the execution is just going to continue. However, if this is not true, it's going to throw an error and the whole transaction is going to be canceled. That means that any data change that were made before will be canceled and the rest of the function will not be executed. So let's scroll down and see the instruction. So we're going to use a required statement to allow player to create a single zombie.
00:33:01.842 - 00:33:48.582, Speaker B: And after, once they create the zombie, then they can have other zombie by feeding on humans, but initially they can only create one zombie. So let's scroll down to create random zombie. And here we use a require statement. And the way we're going to do this is we use the mapping of owner zombie count. We reference MSG sender and this needs to be equal to zero. So we can compare this with the double equal operator here. Okay, let's check the answer and yes, this is correct.
00:33:48.582 - 00:34:42.434, Speaker B: Okay, let's go to the next lesson. So in solidity, sometime when a smart contract starts to become too big, then we want to split the code into several smart contract and for that we can use inheritance. So with inheritance you have a base contract and then you have a child contract that inherit from the base contract. And basically any function or any variable that you have in the base contract can also be used in the child contract. One thing to understand though is if you deploy this parent contract and this child contract, then they will have two different Ethereum addresses. But if you just deploy the shell contract, it doesn't mean that you'll have two different ethereum addresses, you'll just have one ethereum addresses. It's just that this smart contract will have not only the code that you see here, but also the code of the parent contract.
00:34:42.434 - 00:35:13.982, Speaker B: All right, so let's scroll down and what we have to do is to create a smart contract called zombie feeding. So let's do this. Scroll down and we create this contract. Zombie feeding. And in order to inherit from the previous smart contract, we use the ease keyword. And our previous contract is zombie factory. After we open the curly braces and that's all we do.
00:35:13.982 - 00:35:41.222, Speaker B: Okay, so it should be fine. And yes, this is correct. All right, so now we separated the two smart contract into different tabs. So here is zombie feeding and the other one is zombie factory. We're going to use a solidity feature that is called import that allow you to import some solidity code that is not in the same file. So if you try to compile the smart contract like this, it's going to fail because it doesn't know where is this thing. Zombie factory.
00:35:41.222 - 00:36:10.734, Speaker B: Fortunately with the import keyword we're going to import it very easily. So we reference the path to the file. So that's zombiefactory saw. And after anything that you define in this file will be accessible in our contract. Crypto zombie is not happy because here it wants double quotes. Okay, let's fix this. Actually, the 3d compiler doesn't care if you use single or double quote.
00:36:10.734 - 00:36:27.122, Speaker B: You just have to be consistent. If you start with a single quote, you have to finish with a single quote. Start with a double quote. Have to finish with a double quote. All right, so let's verify the answer. Yes, this is correct. So this lesson is about the difference between the data location, storage and memory.
00:36:27.122 - 00:37:06.582, Speaker B: So when you create a pointer to a complex data structure like an array or a mapping, it can reference two different memory location. So storage, this is basically what we defined before as state variables. So these are variables that you define outside any function. So these are actually stored on the blockchain. And memory is when you want to copy a variable in a temporary memory location. So you use this typically inside a function and after the function finished to execute the variable with the memory location, stop to exist. So let's scroll down and see what we have to do.
00:37:06.582 - 00:37:43.920, Speaker B: So we're going to create a function, feed and multiply. So this function will be called when we want our zombie to feed on a human. So we're going to create this function here, function, feed and multiply. And it's going to have two parameters. First, an integer, which is the zombie id, and second, a target DNA. That's also an integer, target DNA. And that's public.
00:37:43.920 - 00:38:18.294, Speaker B: All right, so we want to make sure that the only person who can call this function is the owner of a zombie. So remember before we saw what is a required statement. So we're going to use this. So we make sure that Msg sender is. And here we're going to use a mapping that we defined before. And since we inherit from zombie factory, we have access to all the variable inside. So let's go quickly in zombie factory and here we have zombie to owner variable.
00:38:18.294 - 00:38:42.190, Speaker B: So let's copy this. So we're going to reference this with the zombie id. So only the owner of a zombie can feed on a human. That makes sense. And after we're going to need to get this zombie DNA. So we want a pointer to this zombie. So here we create a pointer of type zombie.
00:38:42.190 - 00:39:06.650, Speaker B: Then we specify the memory location. So it's going to refer to one of the zombie that you store on the blockchain. So we reference the storage location, then we call this zombie. Then we're going to reference another mapping array. Sorry. So let's go into zombie factories. And here we have our array of zombies.
00:39:06.650 - 00:39:49.740, Speaker B: So zombies. And here the zombie id is the index in the array. All right, so let's go to the next lesson. So now we need to finish the feed and multiply function by taking the target DNA that was here given as an argument, combine it with the DNA of the parent zombie and create a new zombie as a result. So let's scroll down to see the exact instruction. So first we need to make sure that target DNA is not longer than 16 digits. So we're going to normalize this number.
00:39:49.740 - 00:40:45.850, Speaker B: So target DNA equal target DNA and modulo DNA modulus. So this way we are sure that the target DNA is the right size. And then we're going to define the new DNA, which is the average of the target DNA and the DNA of the zombie. So let's call this new DNA and it's going to be equal to target DNA plus my zombie DNA. So here it's how you access a field on a struck with a dot notation. And we divide this by two. And finally we're going to create the zombie by calling the create zombie function.
00:40:45.850 - 00:41:20.262, Speaker B: So this is available also because we inherit from zombie factory. So create zombie and I forget the order of the parameters. So let's go into zombie factory. So first the name and after the DNA. So for the name in the instruction that tells you that for now we're going to put no name and we can always write a function later to change the zombie name and then new dna. And that's it. All right, so just have to invert these two things.
00:41:20.262 - 00:41:57.118, Speaker B: Otherwise crypto zombie is not happy. All right, so now let's go to the next lesson. So if you try to compile this smart contract, you'll find that we'll have an error. And that's because one of the function that we declare in the zombie factory has a private visibility, but we use it in the zombie feeding smart contract that inerate from the zombie factory. And here we call this create zombie function. So let's go inside the zombie factory. Here we can see the private visibility.
00:41:57.118 - 00:42:28.650, Speaker B: And that means this can only be used in the same smart contract, but not even in child smart contract and inherit from it. So if we change this to internal, that means that it still cannot be called from outside of smart contract. It needs to be called from inside a smart contract or a smart contract, then inerate from it like zombie feeding. So that's all the change that we need to do. So let's check that everything is right. Yes. Okay.
00:42:28.650 - 00:43:05.202, Speaker B: And so now we'll go to the next level. Next we'll deal with interaction with other smart contracts. So our crypto zombies can eat some crypto kitties. If you don't know what cryptokitties are, they are basically little cat that live on the blockchain. So virtual cat, and you can collect this cat and breed them. And this is one of the most popular game on Ethereum. And so we will need to interact with the smart contract of cryptokitties.
00:43:05.202 - 00:43:37.330, Speaker B: So in order to do this, we need to understand what's an interface. So here's an example. So we have a very simple smart contract with two functions. And if we want to create an interface of this smart contract. So that could be this, for example. So we define a contract, we call it interface, and then we define the function that we want to interact with. For example, get new, we copy the function signature.
00:43:37.330 - 00:44:21.934, Speaker B: So the function signature is everything except the body. So here you can see that we have a semicolum here, but we don't have the curly braces that we have in the real implementation, and we don't have anything inside. So to build an interface, that's very easy, you just declare a smart contract and put the function signature. Okay, so let's scroll down and see our task. So in the smart contract of hello kitty, there is this function getkitty with this function signature and this implementation. So we will need to build the interface of this function here. So let's see exactly how we need to call this.
00:44:21.934 - 00:44:55.542, Speaker B: First, we're going to define an interface called kitty interface. So first let's go to the zombie feeding spot contract, and we'll create our interface here. So contract kitty interface. By the way, there is another keyword in solidity which is interface. So if you want to define interface, you can either choose the contract keyword or the interface. The difference is that the interface keyword is more limited. So you cannot inherit an interface.
00:44:55.542 - 00:45:29.246, Speaker B: But it seems like in this exercise crypto zombies want us to use the contract keyword. So we'll use this. Then we will copy past the function signature of function kitty here. Okay, so let's paste this and we will put a semicolum here and we don't define the implementation. And that's all we need. So with this we pass this lesson. So now we're going to use this interface.
00:45:29.246 - 00:45:55.422, Speaker B: So here you have an example that show you how to use an interface. So here, this is your interface here, this is the smart contract where you use it. So you define a variable where, you know where you assign the address of the other smart contract. Then you're going to define a pointer to this other smart contract. So you declare a variable of type interface here. Then the name of an arbitrary name. This doesn't really matter.
00:45:55.422 - 00:46:36.570, Speaker B: Then you use the name of the interface again, and between parentheses you put the address of this contract. Then inside any function, if you want to interact with your smart contract, you use the variable of the pointer and then you call the function directly and you pass function. So now they tell you that they've saved the address of the cryptokitties and they're a variable called CK address. We're going to create a kitty interface. Okay, so here we can see this address. So we're going to create a pointer to our cryptokitty smart contract. So kitty interface.
00:46:36.570 - 00:47:18.836, Speaker B: Then we're going to call this kitty contract and we instantiate this kitty interface and we pass the address of hello kitty ck address. All right? And we pass this level. Cool. So now we're going to use this interface and actually call the cryptokitties smart contract. So here you have an example that show you how to handle multiple return. So here you call this function that return multiple value. And if you want to receive all this value, then you use this notation here.
00:47:18.836 - 00:48:01.540, Speaker B: So you define your variable before and after use parentheses. So in our task we need to first create a function called Feedon kitty that will call cryptokitties. So let's do this feed on kitty. Then it takes two un parameter, the zombie id and the kitty id. And this is a public function. All right, so first we declare a unint called kittydna and then we're going to call the cryptokitty smart contract. So kitty contract.
00:48:01.540 - 00:48:37.836, Speaker B: And then the function we want is getkitty. And getkitty takes a couple of argument. So let me see, getkitty, just take one argument in the id of the kitty. So just pass the argument here. And this is going to return a lot of variable. So in total I think there are ten argument 1234-5678 910. But we only care about the last one, the genes.
00:48:37.836 - 00:49:11.336, Speaker B: So here the way we're going to ignore the other one is with comma so 1234-5678 and nine gene. And then we're going to call feed and multiply that we defined before and we're going to pass it zombie id and kitty dna. Oops. Here. No d. All right. Yeah, we pass this level.
00:49:11.336 - 00:50:03.752, Speaker B: So next, when a crypto zombie is created from eating a crypto kitty in the dna, we want to add this information so that we can make the difference with crypto zombies that are created normally when a player first entered the game. So in order to do this in the dna of cryptozombie, we're currently using the first twelve digits, but in total we have 16 digits. So we can use the last two unused digits to handle this information. So we'll say that the crypto zombies created by eating cat that will have 99 in the last two digit. For that we're going to use an if statement. So if statement are exactly like in other programming language, if then between parenthes the condition and then it has a body. So let's see the exact instruction.
00:50:03.752 - 00:51:03.352, Speaker B: So first we need to change the function definition for feed and multiply so that it's going to accept a third argument, this string. So let's scroll to feed and multiply and add this argument string. Location is memory and we're going to call this spaces. Okay. Then after we calculate the dna, then here, once we've calculated the dna, we're going to test if this is a zombie script from a cat. So in order to do this, we're going to hash the spacey kchak 256 Abi encode pack. This is because we need to transform the string into byte so that it's accepted by kchak 256 so spaces.
00:51:03.352 - 00:51:52.140, Speaker B: And we're going to compare this with the hash of kshak 256 Abi encode packed here compared to kitty. So you might wonder why we do all these things to compare these two string. Can't we compare directly spaces to kitty. Well, in solidity actually string are not very easy to manipulate and we can't do comparison of string with this operator. So in order to solve this problem, we calculate the hash of these two string. Then inside the if statement we can replace the last two digits of the DNA. So in order to do this, we're going to use some modular operation.
00:51:52.140 - 00:52:41.070, Speaker B: So basically calculate the modular division of the new DNA by 100 and we add a 99 and then we subtract to the new DNA. So if you've done some bitwise operation, this should sound familiar, otherwise I'm just going to skip the mathematical explanation. That's a bit boring, but it works. And then we need to change the way we call feed and multiply here. So let's get rid of this here we add the last argument. Okay, so there is a typo here and we are also missing a parentheses here. And now we're good.
00:52:41.070 - 00:53:00.124, Speaker B: So now it's time to see the front end. So let's first play one a little bit. So this is our cryptokitty here. So our crypto zombie. So let's click on a cryptokitty to attack. So this one for example, cool. We created a new cat zombie.
00:53:00.124 - 00:53:29.944, Speaker B: Yoohoo. All right, how does this work with Webster, the Javascript library to interact with smart contract. So here we define the ABI. So the interface to the smart contract and the address of the smart contract. Then here we define a pointer to the smart contract. We use the contract address here we define these two variable here we can get an image of a specific cryptokitties by using the API of cryptokitty. That's very simple API.
00:53:29.944 - 00:54:20.920, Speaker B: You just add the kitty id at the end, and then when we click on a kitty image, then we call the function feed on kitty of our smart contract. And so we pass the zombie id and the kitty id. And then here when our new zombie is created, then we're going to call the generate zombie function. I already explained this before in this tutorial. So congratulations, you've added a really, really new cool feature to our smart contract. So the next course in the curriculum is advanced solidity concepts. So we haven't mentioned a really key aspect of smart contract.
00:54:20.920 - 00:55:19.388, Speaker B: That's the immutability of their code. So that means that once you deploy a smart contract to the blockchain, you are sure that the blockchain is going to execute exactly the code that you wrote before deploying it. So in a way smart contract is like low, it's always going to execute the same way. So that's a very desirable property of smart contract, but it can pose certain problem. For example, if we hard code the Ethereum address of some contract. So in our case here, a smart contract zombie feeding it interact with the smart contract of cryptokitties. But what if the contract of cryptokitties start to have a bug in the future? And so hacker was able to steal all the money or all the kitty from the smart contract.
00:55:19.388 - 00:55:46.120, Speaker B: In this case, we want to change the address of cryptokitty in our smart contract. So instead of hardcoding smart contract addresses, we want to create a function to make this dynamic. So we're going to do this. So let's see the instruction here. So we're going to delete the line of code where we outcoded address here. So let's do this. And here we're not going to instantiate this pointer, okay.
00:55:46.120 - 00:56:32.792, Speaker B: And we're going to add a function called set kitty contract address. And it's going to take one argument, address, address, put it address, underscore address, make it external. So we haven't seen external so far. Basically external, it's like public, except it's more restrictive. So public you can call the function from outside the smart contract and from inside, but external you can only call it from outside. In general, it's better to be more as restrictive as you can be with this keyword and inside function. We're going to instantiate the pointer here.
00:56:32.792 - 00:57:23.392, Speaker B: So kitty contract equal kitty interface, we pass it the address. All right, so next lesson. So the problem we have with set kitty contract address is that everybody can collect. There's actually a very big security hole because a hacker can put whatever address it wants here and it will not point to the actual cryptokitty smart contract, but to smart contract of the hacker, which can do bad things. So we want to restrict the access to set contract to this function. So actually there is a smart contract that can help us. This is the ownable contract of open Zeppelin.
00:57:23.392 - 00:58:13.220, Speaker B: So open zeppelin is the most popular solidity library that's available open source on GitHub, and it has many smart contracts that are used by a lot of smart contract project. So the contract ownerable of openzepling has a couple of stuff so we can ignore here the event. What's important is the address of the owner. So here the constructor, we haven't seen this before. So a constructor is a function that is called only once when the smart contract is first deployed. So when the smart contract is deployed, we set the value of owner to the sender of the transaction and we emit an event, but we don't care about that. And then we have something that we call a modifier.
00:58:13.220 - 00:59:00.040, Speaker B: So a modifier is a special function that you can attach to another one. So when this function is attached to another one, it is executed first. For example, if I have function foo and I attach only owner to foo, then only owner is executed first. And if everything works fine here, then what you have here, as the underscore is the function it is attached to here. We will require with this modifier that only the owner can call this. So if someone else tried to call a function with this modifier and is not the owner, then he's going to throw an error and everything's going to be reverted. So you are protected.
00:59:00.040 - 00:59:39.748, Speaker B: So after you have a couple of functions for the management of who is the owner. But we don't need to get into so much detail. So let's see what will be our task. So we need to import the content of honorable because we're going to use it in our smart contract. So let's do this. So first we'll go to the zombie factory function smart contract. So we import honorable Sol and after that we're going to inherit from it here.
00:59:39.748 - 01:00:09.630, Speaker B: So is honorable. Here we can see the name of the contract. Okay, and that's it. Now, next lesson. So importing this honorable smart contract is not enough and we need to actually make use of it. So here in this lesson, they explain a little bit function modifier. Well, I just explained this before, so I'm not going to repeat this.
01:00:09.630 - 01:00:39.750, Speaker B: They also explain a bit more how you can renounce the ownership. Yeah, that's a bit too much detail here. Let's add the modifier to set kitty contract address here, only owner. So the way we're going to attach the modifier is like this. So some people don't put the parentheses, but this is a bad convention. It's better to do it that way. All right.
01:00:39.750 - 01:01:14.636, Speaker B: Actually, the way they do it in crypto zombie is without the parentheses. That is actually a bad convention. Anyway, if this is what they want. All right, let's go to next chapter. So we haven't talked of a very important concept in solidity, smart contract. And that is gas. So whenever you send a transaction to a smart contract, so that means you call a function that can modify data, you need to pay some gas.
01:01:14.636 - 01:02:22.936, Speaker B: So first of all, why do you have to pay something when you send a transaction? Well, if you don't have to pay anything, it would be very easy to attack the Ethereum network by sending some bullshit transaction, or even empty transaction that don't do anything but just clog the network. So we use the same approach as, as the spam for email. So spamming people with email is expensive because actually you have to pay a little bit for each email. So that's the same id for gas and transaction, you have to pay something to modify data on the blockchain. However, we don't pay directly in ether, because basically we want to pay proportionally to the computational difficulty of our smart contract. So if this is an operation that doesn't take too much computational power, we should pay less. Otherwise we should pay more.
01:02:22.936 - 01:03:14.276, Speaker B: However, we don't want to set a price for each operation based on a fixed amount of ether, because the value of ether can fluctuate a lot. When Ethereum was launched, ether was probably like, I don't know the initial price of ether, but I think there was like five or $10, something very small. And so in the meantime, it became a much bigger. So if we had used the ether for the transaction cost, now transaction be really expensive. So instead of that, we create a unit called gas, and different operation on the blockchain cost a different amount of gas. But what's important is the relative value of this different operation. Maybe operation a is equal to 1000 gas and operation b is equal to 2000 gas.
01:03:14.276 - 01:04:03.320, Speaker B: So that means operation b is twice as computationally intensive as operation a. And after that we establish an equivalence between this gas unit and ether. So that's what we call the gas price. That's a parameter of each transaction that you send to the blockchain, and you are totally free to set this parameter as the sender of the transaction. This being said, usually there is a market price for this gas price. So you can check a website called ETh gas station to check out what is the current gas price. But usually each user do this on their own, and this is managed automatically by wallet like metamask.
01:04:03.320 - 01:04:47.380, Speaker B: But in any case, as a smart contract developer, you have to make sure that your smart contract does not consume too much gas. So you need to do some gas optimization. After your smart contracts works well, then you start to optimize for gas. There are different technique for this. So if we scroll down, then one technique for example, would be to order the, the variable in a correct way. So in the memory of ethereum, for example, an integer, take a slot of 256 bit. So here we have three slot of memory ABC.
01:04:47.380 - 01:05:34.400, Speaker B: But here actually, if we specify that this is a unit 32, that means it doesn't take the entire slot of 256 bits. So in this case, solidity, when it see this, it's smart enough to put these two variable in a single slot of 256. So this will be one slot and another slot. But if you don't put these two variable here that can fit in a single slot next to each other, then solidity won't be able to do this optimization. So doing an optimal ordering of variable can help a little bit for gas costs. But there are many other technique. We're going to add two fields to a zombie struct.
01:05:34.400 - 01:06:12.016, Speaker B: So we're going to go here in zombie factory and here we're going to add new fields. So the first one is the level of a zombie. So uint level. And the second one is, sorry, this is uint 32. And the second one is also a uint 32 ready time. For example, in this case three DT will be able to pack these two variable in a single slot because they fit in a single 256 bit slot. Okay, so let's check the answer.
01:06:12.016 - 01:06:13.536, Speaker B: Yes, this is correct.
01:06:13.718 - 01:06:44.116, Speaker A: Next we're going to see the time units in solidity. So the way time units work in solidity is with unique timestamps. So unique timestamp is basically the number of second since January 1, 1970. So here on this website I can see what is the current timestamp. So here you can see this big number. And if I reload, then you can see that this is increasing. So the unique timestamp of the current time is always increasing.
01:06:44.116 - 01:07:19.984, Speaker A: So in 3d we're going to store this timestamp in integer. So the uint variable type. And we have a couple of helper to create this timestamp. So for example here, if you use now, it's going to give you the current timestamp. And also if you want some duration. So you have seconds, minutes, house, et cetera. So for example, if you use 1 minute, that's going to be convert to 60 for 62nd, 1 hour is going to be 3600 because that's the number of second in an hour, one day into 86,400, et cetera, et cetera.
01:07:19.984 - 01:07:59.080, Speaker A: And for our business logic, what we're going to use is this fill here ready time of the zombie struck that we've just added before. So this ready time is a number of seconds that you need to wait before you can feed or attack again with a zombie. And we implement this rule because otherwise the game will be too easy. We'll be able to multiply 1000 times per day with your zombie. And that's not really a very fun game. So let's see the instruction for this step. So first we're going to define a variable called cool downtime.
01:07:59.080 - 01:08:35.384, Speaker A: So that's what we need to wait in order before we can use our zombie again. So here, let's do this uint cool down time. It's going to be equal to one days. So internally that means that's going to be 6400. And after that we need to update a line of code. So let's scroll down. So yeah, here, when we create a zombie, we also need to add the two field that we added previously in our struct.
01:08:35.384 - 01:09:04.632, Speaker A: So level and ready time. So for the level, so we're going to start at one when we create a new zombie. And for the ready time. So it's going to be now plus cool done time. And actually we're going to cast this into a uint 32 because we don't need to use a u into 56. That's too big. Right.
01:09:04.632 - 01:09:38.400, Speaker A: So that means we're going to be able to use our zombie at this timestamp here, not plus cool don time. Let's check the answer. And yes, that's correct. Okay, next chapter. So in this chapter we're going to focus on zombiefeeding saw and more specifically on the feed and multiply function so that when we call this function we update the cooldown time. And also it's not possible to call this function before the end of the cooldown period. So there are a couple of stuff to do in order to implement this business logic.
01:09:38.400 - 01:10:21.504, Speaker A: And so in this chapter we're going to focus on two helper function. So let's see exactly what we have to do. So first we're going to create a function called trigger cooldown and it's going to update the cooldown time of the kitty. So let's scroll down. And here we're going to define our first function, trig function trigger cool down as an argument. It's going to take a storage pointer to a specific zombie. So with a storage pointer we can pass a reference to a specific struct instance between different function.
01:10:21.504 - 01:11:08.296, Speaker A: So first you need to specify the type of the struct, then you specify the storage location, and after you give the name of the argument. And so this is going to be an internal function. So that means that it can only be called from the same smart contract or smart contract, then inerit from this contract and here without zombie. So it has a ready time member. And here we're going to reuse exactly the same logic as we did in the chapter just before. So this is going to be equal to now plus cool downtime. Cool downtime.
01:11:08.296 - 01:11:45.980, Speaker A: That's a variable that we defined in zomifactory just before. Okay, and the next function we're going to define is the ease ready function. So this function will tell us if the zombie can multiply again. So that means if we are after the cooldown period, so is ready. And it's also going to take a storage pointer so we can copy paste this. And this is an internal function and then it uses the view keyword. So with the view keyword you can create read only function.
01:11:45.980 - 01:12:09.476, Speaker A: So this function cannot modify the blockchain and it's going to return a boolean. So here we specify return bool. Okay. And so here we're going to make a comparison. So we're going to check that the ready time is inferior or equal to now. So now is the current timestamp. All right.
01:12:09.476 - 01:12:38.920, Speaker A: And so this is going to give us a boolean. So true or false? So with this we have passed this chapter. So let's go to the next chapter. So in this chapter we going to fix the security of feed and multiply. So let's scroll down. And so here for the feed and multiply function. The problem is that anybody can call it any arbitrary dna here and any spaces string.
01:12:38.920 - 01:13:09.670, Speaker A: So we don't want this. And actually this function only needs to be called by feedon kitty by this function here. So it doesn't need to be public. So we're going to fix this and replace it by internal. That's the first thing. So when you write a smart contract you should be as restrictive as possible. And if you have a public function that can be internal or private then you should make sure to change this.
01:13:09.670 - 01:13:53.920, Speaker A: And next in our function we need to make sure that the cooldown period that we are after the cooldown period. So for that we're going to make use of the require statement. So that's to check that a condition is true. So we're going to call is ready and we pass the myzombi pointer that we built just before. And if this is true then the execution will continue. Otherwise if this is false then the whole execution of the function is going to stop here and any state change will be reverted. And we also need to update the cooldown period after we feed and multiply.
01:13:53.920 - 01:14:37.324, Speaker A: So for this we're going to call trigger cool down. So let's do this underscore and it takes as an argument my zombie. Okay. And we pass this chapter. So next we created a new file called Zombiehelper saw and we're going to extract some code in this new contract so that help us to keep our code well organized. And we're going to add a modifier function in this file. So this time we're going to use a function modifier with arguments.
01:14:37.324 - 01:15:12.556, Speaker A: So before we already saw what are function modifier, but they can also take some arguments. So here you can see a code snippet to give you an example. So here you have your modifier. You have the body of your modifier, the underscore that represent the function it is attached to, but it can also receive some argument here and inside your modifier you can make use of this argument. So we're going to create a modifier called above level. So let's do this. And it's going to receive some argument modifier above level.
01:15:12.556 - 01:15:59.788, Speaker A: It's going to take two arguments. First, a uint that is called level. And after another uint for the zombie iD, we're going to require that the level of the zombie is greater than or equal to the level. So let's do this with require and we use the zombies mapping. We reference the zombie id level and it has to be superior equal to level. And after, you should not forget the underscore to represent the function it is attached to. And that's correct.
01:15:59.788 - 01:16:32.000, Speaker A: All right, next chapter. So now we're going to make use of this modifier we just created. And we're going to create some function to change our zombies. So for zombies who have a level two or higher, there will be a function to change the name of the zombie. And if your zombie has a level 20 or higher, you can also change the custom DNA. So the higher the level of use zombie, the more stuff you can do. So let's see the exact instructions.
01:16:32.000 - 01:16:55.504, Speaker A: So first we're going to create a function change name. So let's do this here. Change name. It's going to take two argument the zombie iD. After that we want the new name. So that's an argument of type string. Then for the memory location we call this call data.
01:16:55.504 - 01:17:38.508, Speaker A: So we haven't seen the call data memory location. But basically when you have a function of type external, which is the case here, then you don't have the memory location. Instead this is called call data. And then we're going to call this new name. And so this is supposed to be attached to the modifier we just created above level. So we're going to attach it like this and we need to pass two arguments, the level and the zombie id. So for the level, this is two because we want to make this function only executable if your zombie has a level two or higher.
01:17:38.508 - 01:18:11.076, Speaker A: And for the zombie id, this is the zombie iD. All right. And so inside we're going to first verify that the sender of this transaction is the owner of the zombie. So for that we're going to require that Msg sender is zombie to owner. And here we reference the zombie id. Okay. After that we are going to update the name of the zombie.
01:18:11.076 - 01:18:31.304, Speaker A: So zombies, zombieid name. And it's going to equal to new name. Okay. And then we're going to create another function called change DNA. So let's do this. Change DNA. It's going to take two arguments.
01:18:31.304 - 01:18:59.030, Speaker A: The first one is zombie id and the second one is the new DNA. And it is also going to be an external function. We also attach the modify above level. So this time for the level, this is 20. And follow the zombie id. This is zombie id. All right.
01:18:59.030 - 01:19:38.052, Speaker A: So we also check that first this is the owner of the zombie that called this function. And then we're going to change the dna of the zombie. So here, DNA, this is going to be new DNA. Okay, this is correct. So next chapter. So we're going to create a function to return all the zombies of a specific owner. And for that we're going to use a view function.
01:19:38.052 - 01:20:06.700, Speaker A: So that is read only. So here it gives you an explanation, saving gas with view function. It tells you that view function are used to save gas. But I really disagree with the explanation they give. So view function I use to return data, not to save gas. So let's scroll down and let's see what we have to do. So we're going to create a function called get zombies by owner.
01:20:06.700 - 01:20:18.080, Speaker A: Okay, so get zombies by owner. All right. It takes one argument, an address called owner.
01:20:19.300 - 01:20:20.636, Speaker B: Owner.
01:20:20.828 - 01:20:41.240, Speaker A: Spell it right, Julian. Okay, let's make it external so that it can only be called from outside the smart contract. And this is a view function. So this is read only and doesn't consume any gas. And then it's going to return an array of integer. So that's how we declare it. We make this memory.
01:20:41.240 - 01:21:17.920, Speaker A: Okay, and this is empty for now. And that's correct. Let's go to the next chapter. So one thing that is important to understand as a smart contract developer is that when you store data onto blockchain, this is expensive. So if possible we avoid to do it. So in our function here, get zombies by owner instead of storing an array of zombies by indexed by the owner on the blockchain. We're going to dynamically build this array.
01:21:17.920 - 01:21:49.800, Speaker A: And so the memory location we'll use for that array is not storage, but it's called memory. So that just exists when you execute the function and after this is deleted. So we're going to declare an array in memory. And here we have an example of the syntax. So first you need to declare the type of the array. Then you declare that this is an array with the square brackets. Then you use the memory keyword, the name of the variable.
01:21:49.800 - 01:22:17.492, Speaker A: Then you use the new keyword. Again, you declare the type of the array. So that's a bit redundant with this, but we have to do it. And after use parentheses to specify the length of the array. So this is a big difference with a storage array because with memory arrays you need to know in advance what is the length of the array. And this is a fixed size. This is not possible to change this after and after.
01:22:17.492 - 01:23:09.752, Speaker A: Here you have the way you access each element of the array is with a square bracket notation. And you also don't have access to the push method contrary to storage array because you can add dynamically new element. Okay, so let's see what are the instructions? So in our function getzombies by owner, we need to declare an integer array called result. So let's do this uint memory and we call this result. And this is going to be an integer array. And the length of the array should be how many zombie the owner owns. And so we can have this by using this mapping, owner zombie count.
01:23:09.752 - 01:23:34.530, Speaker A: And we use the owner variable. So let's do this new uint. And between parentheses we specify the length of the array. Owner zombie count. And here we specify the owner. Right. And for now we're just going to return the result.
01:23:34.530 - 01:24:06.328, Speaker A: This is going to be an empty array, but in the next chapter we're going to fill it. So this is fine. I pass this chapter. So now we're going to fill our array with a for loop. So first let's see what is how a for loop work. The way you declare a for loop is that you first use the for keyword. Then you initialize a counter here.
01:24:06.328 - 01:24:33.890, Speaker A: Then you specify the stopping condition. Then you increment your counter. And after in your for loop, then you write whatever code you want to run and what's inside is running run until we hit the stopping condition. Here, let's start the code. So let's scroll down. So here first we need to declare a counter variable to keep track of the index in the result array. So let's do this.
01:24:33.890 - 01:25:10.280, Speaker A: And we set it initially to zero. Well, actually you don't strictly need to do this because the default value of an integer is zero. But they ask us to be more explicit. Okay, so now we're going to declare our for loop. So it's going to start from zero. And the stopping condition is until we hit the length of the zombies array and we increment I for each pass inside we going to compare that the owner of the current zombie is the owner. That was passed as an argument.
01:25:10.280 - 01:25:37.510, Speaker A: So here zombie to owner of I. And this must be equal to owner. And if that is the case, then we increment our result array. So result here we reference. Oops, sorry, I didn't mean to call this result. I meant to call this counter. My bad.
01:25:37.510 - 01:26:14.848, Speaker A: And this is equal to the zombie id. And after that we increment the counter variable so that the next time that we added zombie id to the result array, we don't overwrite the previous entry. And after we need to close the if statement. Okay. And at the end, once we finish the loop, then we return the result. So we could have done something more simple. If we stored in storage an array of orders don't be id for each address.
01:26:14.848 - 01:27:03.970, Speaker A: For example, for each address here we will have a mapping that point to an array of integer for all the zombie id of this owner. So I don't know, three, 5912, et cetera. But the prime of this approach is that first it consume more gas because now we have to store this in storage. And second, every time we transfer the ownership of a zombie between two different owners, we also have to update this array of zombie ids. And so it makes our code more complicated and it also make us spend more gas. So that's why we don't choose this approach. And instead we dynamically build this array every time.
01:27:03.970 - 01:27:47.570, Speaker A: Okay, so we're good. And let's go to the next chapter. So let's wrap up what we've learned in this lesson. So first we added a way to update our cryptokitties contract so that allow us to deal with spot contract update. Then we've learned how we can protect our function with the only owner modifier. Then we learn about what is gas and how we can optimize for gas consumption in our spot contract. Then we added the concept of cool down for our zombies so that we have to wait before our zombie can multiply again.
01:27:47.570 - 01:28:30.764, Speaker A: And we've also added a function to update a zombie name and DNA but this is only after your zombie get up to a certain level. And finally we can return an array of holder zombie id for a specific address. All right, so let's click on next and let's go to the next lesson. Right, zombie battle system. Right, let's start this. So in this chapter we're going to see a new function modifier called payable. But first let's have a quick recap of all the function modifier we already saw together.
01:28:30.764 - 01:29:10.330, Speaker A: So first we saw the private function modifier and that is used to make your function only callable from inside your spat contract so that make it more secure. Then we have internal, so that's slightly less restrictive than private. So with internal you can call your function from inside the spot contract and also from spot contract that inherit from the smart contract. Then with ectanol the function can only be called from outside spot contract. And finally we have public where it can be called from anywhere. That's the most permissive function visibility. But usually we want to avoid this if possible.
01:29:10.330 - 01:29:50.016, Speaker A: Then we have what we call state modifier. So that's the view and peel keyword. So with this modifier you tell three dt that your function is only going to read data and not modify any data on the blockchain. So this function will be read only. And the difference between view and pure is that with view you read data from the blockchain, but with pure you return some data but that is not read from the blockchain. For example, if you want to do an addition or a multiplication, but that does not depend on any data from the blockchain. And then we have custom modifiers.
01:29:50.016 - 01:30:30.196, Speaker A: So we saw this in the previous lesson with the only owner modifier and above level. So these are basically snippets of code that you will execute before executing a function. And we often use them to restrict access to some function. So you can attach multiple custom modifier to any function. So only owner here, another modifier, et cetera, et cetera. And then in this chapter we're going to see the payable modifier. So payable modifier specified that you can send some ether to a function.
01:30:30.196 - 01:31:09.520, Speaker A: So I know that this is a little bit confusing, but with an ethereum smart contract, when you execute a function on top of executing the function, you can also send some ether to this function. So you really do two things at the same time. If you don't have this payable modifier on a solid function, you cannot send ether to this function. It will be rejected. So let's look at an example. So here let's say you have this function and you want to make it able to receive some ether. So you add the payable function modifier here.
01:31:09.520 - 01:31:45.832, Speaker A: And inside here you have an example of how we can access the current ether value that is stored inside the spot contract. And so here with this msg value you can know how much ether was sent to the function. And here you can see that you can make some comparison by using the ether keyword. So here for example, I want to execute this function only if exactly 0.1 ether was sent. So you can see that it reads really nicely. That sounds really intuitive.
01:31:45.832 - 01:32:28.980, Speaker A: And so if you want to know in the front end when you use the Webster Javascript library, how you can specify that you also want to send some ether. Well, when you call the function, so you specify the sending address and you specify another parameter here, value. And here you give it the value in the way. So you use this helper function to convert to way as a reminder. That's the elementary unit when you manipulate ether. So way is a very small fraction of an ether, that's ten power -18 so it's like zero point with 180. So here for example, if you understand the equivalent of 0.1
01:32:28.980 - 01:32:58.392, Speaker A: ether. So you need to use these two way function so that it's going to convert this into a big number with many zero. And yeah, that's basically how payable works. So now we're going to start the coding part. So first we're going to define an integer called a level up. So we're going to implement a function that allow to increase the level of our zombie. But in order to call this function we need to send some ether.
01:32:58.392 - 01:33:27.470, Speaker A: So first we're going to define what's the level up fee. So here we're going to define a variable of type integer level up fee. And we set it to 0.1 ether. All right? And then after we're going to create the level up function just right here. So let's do that function level up, level up. And it's going to take one parameter, the zombie id.
01:33:27.470 - 01:33:51.456, Speaker A: Zombie id. And we make it external. So we can only be called from outside the spot contract and it's payable, right. And its function first is going to make sure that we send enough ether. So we're going to require that MsG value. So that's the amount that was sent in a transaction. And this should be equal to the level up fee.
01:33:51.456 - 01:34:28.370, Speaker A: All right? And after that it's going to increment the zombie of the owner. So zombie id zone. Then we reference the level field and we increment it like this. All right? And we're good. So let's go to the next chapter. So previously we created a function to level up our zombies. And we also need to send some ether in order to call this function.
01:34:28.370 - 01:35:11.048, Speaker A: But the operator of this smart contract will also want to redraw this ether from time to time. And if you don't create any function for that, then your ether is going to be locked inside your spot contract. So we need to create this reservoir function. So here you have an example of how it work. So basically the way you transfer ether in a spot contract is first you need to know what is the recipient address. So here with this function owner, we're going to have the address of the owner of the smart contract. So that's basically the admin.
01:35:11.048 - 01:35:44.772, Speaker A: If you wonder where does this function come from? It comes from the ownable smart contract here. And the problem is that this address is of type address. But in solidity there is another type of address which is called address payable. And if you want to send some ether, it needs to be address payable, not just address. So we need to cast this address type to a payable address type. And there is no easy way to do it with solidity 0.5. So we have to use these tricks.
01:35:44.772 - 01:36:25.300, Speaker A: First we cast the address into an integer 160 bit. Then we cast this into an address payable like this. And after, once we have our address payable owner, then we can call the transfer method on it. And then we specify the amount that we want to withdraw. So in this case we're going to withdraw all the ether of the smart contract. So we use this keyword, we cast this into an address and then we can access the balance of this variable. So this will withdraw everything in the smart contract.
01:36:25.300 - 01:36:48.750, Speaker A: So that's how it works. So let's scroll down and let's see the exact coding instructions. So create a withdrawal function in our contract. Actually, let's say it should be identical to the example above. So you know what, actually let's copy paste this. It's going to be faster. All right.
01:36:48.750 - 01:37:22.012, Speaker A: And so I forgot to mention that it's protected by this modifier here, only owner. So this is super important. Otherwise anybody can call this function and just take all the money away. That's not what we want. So in the next instruction they tell you about a potential problem that may occur. So let's say that in the future the price of ether change a lot. So the level up fee that we set up in the previous chapter might become very expensive all of a sudden.
01:37:22.012 - 01:37:49.212, Speaker A: So we need to be able to adjust this fee. So that's why we're going to create a function to do this. So we're going to create a function called set level up fee. Let's do this. And it's going to take one argument, which is the new fee. So that's going to be an integer. And then we make this external and we also protect this by only owner.
01:37:49.212 - 01:38:20.484, Speaker A: Otherwise anyone can call this function and can set the fee to zero and can level up as much as they want. So that's not what we want. And all we want here is just to level up fee. We're going to update this to the new fee. That's it. We finished this chapter. So now we're going to start to implement the functionality to actually have battles between the different zombie.
01:38:20.484 - 01:39:14.350, Speaker A: And so like we did in the previous lessons, we're going to extract all this functionality in a single file. So we created this file zombieattack saw. So we need to initialize the code of this file. So first we need a pragma statement, pragma solidity, and it needs to be above or equal to 50, but inferior to 0.6. Okay, then we're going to import the zombie helper file that we created before. So import and then we put the path to zombiehelper. Okay.
01:39:14.350 - 01:39:50.472, Speaker A: Then we need to declare a new contract called zombie attack and have it inerate from zombie helper. So contract zombie attack and make it ineric from zombie helper. Okay. And this is correct. So in any good games there is some randomness. So we need to be able to generate randomness in our smart contract. So how can we do this? Well, let's see here.
01:39:50.472 - 01:40:26.908, Speaker A: We have a code snippet for some inspiration. So we need some source of randomness in our spot contract. So we're going to use the timestamp that is used for mining the transaction. We're also going to use the address of the sender of the transaction, also what we call n non. So that's going to be an integer that we increment every time we generate our random number. So we're going to concatenate all of this variable here and we're going to use the hashing function of solidity to have a hash of all of this. And then we're going to cast this into an integer.
01:40:26.908 - 01:41:23.792, Speaker A: But that's not enough because if we do this, the integer can be anything. So we want to generate a random number between one and 100 here. So for that we're going to use the modular operator and we're going to have our random number that belongs to a specific range. So the problem of this method is that this is actually not secure because if you have a dishonest minor, there is a way that this minor manipulates the element of randomness provided to the smart contract and so the miner can have an influence on the random number that is generated. So we don't want this. Is there a way to generate a random number in a safe way in ethereum? Well there is, but it's a bit outside the scope of this tutorial. So if you want a hint you basically have to use oracle.
01:41:23.792 - 01:42:03.340, Speaker A: So these are outside API that will feed the smart contract with some source of randomness. But this is really more complex. So we're going to stick to the simple solution. So first we're going to give our contact a contract, a new variable called renknowns. So we're going to do this here, uint Rennons and we're going to set it to zero. So then we're going to create a function called ran mode. So it's going to generate our random number and it's going to accept an argument.
01:42:03.340 - 01:42:19.556, Speaker A: So that's an integer called module that's going to help us to define a range for our random number. It's going to be an internal function. It returns an integer. So the first thing this function is going to do is to increment the.
01:42:19.578 - 01:42:20.420, Speaker B: Nons.
01:42:22.120 - 01:43:18.170, Speaker A: And after that we going to combine different source of randomness. So Abi encode pact of now. So that's the current timestamp, then the address of the sender of the transaction and finally the nonce. Then we're going to ash this. So with Kshack 256 then we're going to transform this into an integer and we're going to divide this by using the modular operator. We're going to divide this by the modulus variable that we receive as an argument and we're going to return this. And let's not forget the semicolon at the end.
01:43:18.170 - 01:43:48.368, Speaker A: And let's check the answer. And yes, this is correct. Okay, let's go to the next lesson in this chapter. We will start to implement the logic for fighting between different zombies. So there will be a couple of rules for the fighting. So you choose one of your zombie and you choose a zombie of one of your opponent and you can attack it. So if you are the attacking zombie, your probability of winning is 70%.
01:43:48.368 - 01:44:25.352, Speaker A: If you are the defending zombies, your probability are just 30%. So all the zombies will have two new variable, win count and a loss count to count the number of win and of loss. So if the attacking zombie wins, it's going to level up and it's going to spawn a new zombie. And if it loses then nothing happened except that its loss count will be incremented and no matter if it wins or lose, the cooldown time will be triggered. So that will prevent you from attacking every time. So we going to start to implement this. So there is a lot of logic.
01:44:25.352 - 01:45:09.116, Speaker A: So we're going to do this across several chapter, but in this chapter we have to first create a variable for the attack victory probability. So that's going to be an integer and we're going to set it to 70. And after that we're going to create a function called attack. It's going to take two parameters. First a zombie id and second a target id. So zombie id is the zombie you want to use for the attack and target id is the other zombie you want to attack. And we make it external and that's empty for now.
01:45:09.116 - 01:45:40.436, Speaker A: Okay. So that's correct. So now next chapter. So next step is to make sure that the zombie you want to use to attack is a zombie we actually own. And we actually already implemented this in other functions. So instead of doing the same check in different function, we're going to refactor everything by using a modifier. So here, I'm talking of this line of code here, require msg sender equals zombie to owner, blah blah blah.
01:45:40.436 - 01:46:05.872, Speaker A: So that's what we're going to put inside the modifier. So let's create a modifier called owner off. Let's scroll down. Okay. So we're going to create it here, modifier, owner off. It's going to take single argument, the zombie id and we're going to do a require. So, okay, let me scroll up.
01:46:05.872 - 01:46:44.604, Speaker A: We're just going to copy paste this line here, require msg sender. Okay. And after we execute the function with the underscore. All right, and after we need to attach this modifier to this function, feed and multiply. So here we don't need this anymore. And instead we can add the modifier here, owner off and we need to pass it the zombie iD. And that's correct.
01:46:44.604 - 01:47:17.876, Speaker A: Next chapter. So we'll continue with refactoring by reusing the owner of modifier. And we'll do this in change name and change DNF function. So let's scroll down and here when we check that the color is the owner of the zombie. We can also make use of this owner of modifier. So let's do this owner off and we pass the zombie iD. Okay.
01:47:17.876 - 01:47:37.884, Speaker A: And let's do this also here in change DNA. Let's get rid of this. Now our code is cleaner. Let's check the answer. Yes. All right, so enough with refactoring. And now we're going to keep implementing our attack function.
01:47:37.884 - 01:48:17.000, Speaker A: So first we're going to attach the owner off modifier to the attach function. So here, let's do this owner of and we're going to pass the zombie iD. Okay. And next we need to create two storage pointer to the two zombies. So our zombies and the zombie that we want to attack. So we're going to start with our zombie. First we define a pointer of type zombie, then make it a storage pointer and we call it my zombie.
01:48:17.000 - 01:48:51.284, Speaker A: And we reference the zombies mapping. And here we use the zombie id we provided as argument. And after that we're going to define another pointer for the other zombie. We're going to call it enemy zone b. And here, this is target id. Okay. And the last instructions we need to create a random number between zero and 99.
01:48:51.284 - 01:49:16.744, Speaker A: So we're going to declare an integer called rand and we're going to use the rand mode function to generate this random integer. And we pass it 100. And that's it. Oops, I forgot. Semicolon here. Yes, this is correct. All right, next chapter.
01:49:16.744 - 01:49:57.144, Speaker A: So in this chapter we want to keep track of how many battle each zombie has won, all lost. And for that we're going to add a couple of fields to our zombie struct. We're going to add win count and loss count. So we're going to go to zombiefactory. So we're going to add this true property here. So we're going to use a uint 16 for inch for each win count, uint 16 for loss count. So how can we choose what kind of uint we want? Well, if we want to take the largest uint, we don't put everything and it's like uint 256.
01:49:57.144 - 01:50:23.488, Speaker A: So that's probably way too big for our need. The smallest uint we can find is un eight. So if our zombie win every day, then it will overflow this integer in less than a year. But if we put uint 16, then in this case it's going to overflow after 65,000 something. So our players will need to play and win every day for 179 years.
01:50:23.574 - 01:50:26.688, Speaker B: So we are probably okay with that.
01:50:26.854 - 01:50:54.884, Speaker A: And the next thing, we want to change our function, create zombie, because now we have to populate the initial value for wind count or loss count. So here in create zombie, we're going to modify this. When we create a zombie, we're going to add two field. So zero win count and zero loss count. Okay. And we're good. Next chapter.
01:50:54.884 - 01:51:42.670, Speaker A: So now that we have created a win count and a loss count, then we need to update them every time there is a battle between two different zombies, depending on who won the battle. So let's scroll down to the attack function. And first we're going to test here if the random number we generated is less than or equal to attack victory probability. So that's something that we defined before. If that's the case, then that means that our zombie win. So we're going to increment our win count, my zombie win count plus. We're also going to level up, so my zombie level plus, plus.
01:51:42.670 - 01:52:20.900, Speaker A: And now we need to increment the loss count of the enemy zombie. So loss count plus, plus. And since we won, then we're going to get a new zombie. So for that we're going to execute feed and multiply. So we're going to go in zombie feeding because I don't remember what are the arguments of fit and multiply. So zombie feeding here in fit and multiply, so the zombie id is r zombie. Then for target dna, that's the dna of the enemy.
01:52:20.900 - 01:52:43.710, Speaker A: And here the spacey that tell us to put the zombie string. So back to zombie attack. Okay. So here, zombie id, then enemy zombie dna. And finally the string zombies. All right. And we good.
01:52:43.710 - 01:53:24.990, Speaker A: So in this chapter, we're going to tackle the case when our zombie lost the battle. So we're going to add an else statement in the attack function. So here, this is the branch where if we win, but if we lose, we also have to take this into consideration. So in this case, we're going to increment the loss count on our zombie. So myzombie loss count plus. Then we're going to increment the win count of the enemy zombie win count. And we also going to trigger the cooldown period so that we cannot attack for a certain time.
01:53:24.990 - 01:53:28.252, Speaker A: So let me see, what's the exact.
01:53:28.306 - 01:53:29.420, Speaker B: Name of the function?
01:53:29.570 - 01:53:31.790, Speaker A: Trigger cool down.
01:53:32.640 - 01:53:33.390, Speaker B: Okay.
01:53:35.060 - 01:53:41.010, Speaker A: And we're going to pass my zone b. Okay.
01:53:41.700 - 01:53:43.104, Speaker B: And we're good.
01:53:43.302 - 01:54:00.664, Speaker A: So we are finished for the coding of this lesson. And now we're going to test that everything works fine. So we're going to attack another zombie. Yes, we will. After we can see the updated fields of our zombie. Cool. So let's click on next.
01:54:00.664 - 01:54:40.180, Speaker A: Let's proceed to the next lesson, ERC 721 and collectibles. Okay, so let's start this lesson. So in this chapter we're going to talk about token. So if you've been in the Ethereum space for a while, you've probably heard about token. Token are basically smart contract that represent assets but on the blockchain. And you probably heard of ERC 20. So the problem with token is that we want to make them easily tradable for exchanges.
01:54:40.180 - 01:55:31.696, Speaker A: But if each token has its own custom logic, it's going to be very difficult for these exchanges to add new tokens. So that's why we created exchanges like yes, 20 tokens. So without going into the detail, yes, 20 token specifications specify a set of function that all the YaS 20 token have to implement like transfer from, for example, that allow you to do a delegated transfer. And internally the spot contract is going to maintain a mapping of address to integer and that's how it can know the balance of the different address. So Yash 20 is cool, but this is for what we call fungible assets. So for example like a dollar. So $1 is equal to any other dollar.
01:55:31.696 - 01:56:07.088, Speaker A: We don't really care. But in our case, our zombies, they are what we call non fungible. One zombie cannot be exchanged against another one because each zombie has its own specificity. So we cannot use the ERC 20 token. Instead we're going to use another standard that we call ERC 721. So Yash 721 is a token standard for non fungible assets like our zombie. So we are not going to dive into all the detail of Yashi 721 now, but we're going to do it step by step.
01:56:07.088 - 01:56:41.156, Speaker A: So in this chapter we're going to start our coding. So here we have a new file, zombie ownership saw. So that's the file of our token. And this token will represent our zombie. So first we're going to declare the pragma statement. So for that we can just copy paste from other files, okay, and then we're going to import zombie attack. And then we're going to declare the spot contract of our token that we're going to call zombie owner ship.
01:56:41.156 - 01:57:06.880, Speaker A: And this is going to be is zombie attack. Okay, so it's going to inerate from the zombie attack. Smart contract. And for now we're going to leave the body empty. Okay, so we pass this chapter. So here is the set of function that we need to implement in our smart contracts, balance off, owner off, et cetera. This is part of the Yasi 721 standard.
01:57:06.880 - 01:57:45.932, Speaker A: So I know that it seems a little bit overwhelming, but we're going to implement this function one by one. So don't worry. So this is an interface. It actually doesn't define the function themselves. It's just define a function signature. So we're going to Inrek from this contract, and for anybody who read the code, they will understand right away that our smart contract is an ERC 721 token. First we're going to import the interface of ERc 20 like this ERC 721 sol, and after that we're going to inerate from it like this ERC 721.
01:57:45.932 - 01:58:14.536, Speaker A: Actually, let's see how they define it. 721, all in uppercase. Okay, so here you can note that in solit we can have multiple inheritance. So here zombie ownership inherit not only from zombie attack, but also from ERC 721. And that's all we need to do now. So let's check the answer and yes, that's correct. So in this chapter we're going to implement two function balance off and owner off.
01:58:14.536 - 01:58:52.208, Speaker A: So for the balance of function, it takes as an argument an address, and it return the balance of token of this address. So for example, if an address has ten token and this function is going to return ten, and another function owner of it takes as an argument a token id. So in our case it will actually be a zombie id and it will return the address that owns this zombie. Actually, we already have a mapping that store this information. So it's going to be really straightforward. So here let's see the exact instruction. So for balance of, there is a mapping that we already defined before that's.
01:58:52.224 - 01:58:52.932, Speaker B: Going to help us.
01:58:52.986 - 01:59:56.708, Speaker A: That's owner zombie count and that's indexed by address. So here we just put the owner we got as an argument and we return this. And for owner off we have another mapping that's zombie to owner. And we're going to pass the Token ID and we're going to return this and we check the answer and yes, we're good. So we have a problem, my friend, because we created a function owner of that has the same name of a modifier that we created before, and this is not allowed in solidity. So can we just change the name of the owner of function we just created? This is not possible because in the standard of Yasi 721, we expect a function called owner off, and we have to respect that. So instead we're going to change our modifier.
01:59:56.708 - 02:00:40.752, Speaker A: So let's scroll down and see exactly the instructions. So we're going to go in zombie feeding and we're going to change the name of our modifier from owner off to only owner off. So let's do this. So only owner off. And after in feed and multiply we're going to change here the call to this modifier only owner of. Okay, so in this chapter we're going to implement the token transfer logic. So in er, 721 we have a function called transfer from to transfer token.
02:00:40.752 - 02:01:18.900, Speaker A: But there are actually two way to call this function. So the first way, if the sender of the transaction put his own address here for the from argument, then this is basically the person that owned the token that decide to transfer it. So this is the most simple case. And the second case is what we call delegated transfer. So that means that a person a can approve a person b to transfer token on his behalf. So that means that the owner of the token first need to call the approve function to approve the other address and after the other address can call transfer from. So we need to implement this.
02:01:18.900 - 02:02:05.890, Speaker A: But you will notice that both of these function actually they will reuse the same part of the logic that transfer token. For this common logic, we're going to create a function called underscore transfer. So first we're going to define this function underscore transfer. So let's do this. Let's scroll down and we're going to define a new function here, function transfer. And it's going to take three arguments. So first address from then address to and you int 256 for the Token ID.
02:02:05.890 - 02:02:58.128, Speaker A: And it should be a private function. So when the ownership changes, there are two mapping to change. First, the owner zombie count and the zombie to owner that keep track of who owns what. So first we going to update the owner zombie count for the person receiving the zombies owner zombie count of two and we increment this. And next we need to decrease owners on behalf for the sender, so owners on behalf of from. So we're going to decrease this and after we're going to update zombie to owner. So zombie to owner zombie id.
02:02:58.128 - 02:03:32.750, Speaker A: And so now it's going to point to the new owner. So that's underscore two. And finally we need to fire a transfer event that's part of the Yash 721 specification. So we're going to use the emit keyword for that. And after we're going to emit this transfer event. So let's go inside Yash 721 to see what we have inside so the address from. Okay, you know what? Let's copy everything, otherwise we're going to forget some stuff.
02:03:32.750 - 02:03:54.230, Speaker A: So the address from. Well, we already have it. From the argument the address to we already have it. And the token id. Yes, we also have it. Okay, oops, here I made a mistake. That's not zombie id, but that's token id.
02:03:54.230 - 02:04:13.176, Speaker A: Okay, so now we're good. So we've done the difficult part. Now it's going to be easier to implement transfer from. So first we want to make sure that when we do a delegated transfers, that means when another person try to transfer token on behalf of someone else.
02:04:13.198 - 02:04:14.424, Speaker B: We want to make sure that this.
02:04:14.462 - 02:05:04.920, Speaker A: Person is actually approved. So for that we need to define a new mapping that we will call zombie approvals. So we're going to define this here. So that's going to be a mapping of you in so that's going to be the zombie id to an address. So we're going to call this zombie approvals. And after that in the transfer from function we're going to add a required statement transfer from. So first let's check that it's either the owner of the zombie, so zombie to owner of a token id and this should be the sender of the transaction.
02:05:04.920 - 02:05:56.792, Speaker A: Or the other possibility if this is a delegated transfer. So for that it's going to be zombie approvals of the token id and this should be the sender of the transaction. And after that if this requires statement pass, then we can call the transfer function. We just forward the argument from to an token id and we're good. That's how you do a transfer with ERC 21. So now we're going to implement the approve function. So as a reminder, the way you do delegated transfer is first the owner of a token called the approve function by specifying which address will be approved to move a specific token.
02:05:56.792 - 02:06:40.888, Speaker A: And after the address that's been approved is able to call transfer from to do the transfer. So let's implement this. So let's go to the approve function. So first of all, we want to protect this function because only the owner should be able to approve someone. So let's add this only owner of an token id. Okay, and after for the body of the function, we need to update zombie approval. Zombie approval, token id and this is equal to approved and we're good.
02:06:40.888 - 02:07:05.756, Speaker A: There is still one more thing to do in the approved function and that's to fire the approval event. So let's do this here. We're going to fire this event. So we use the emit keyword, then approval. Then I don't remember the parameters. So let's go in the yacht 721 specification, let's copy all of this parameter here and let's populate this. So for the owner.
02:07:05.756 - 02:07:32.956, Speaker A: So that's msg sender, the sender of the transaction then for approve. Well, we provide this as an argument to the function and for the token id also, and we're good. So in this chapter we're going to fix a bug of overflow. Underflow. So in solidity, when you define a variable of a certain type, so let's say for example u int eight, so.
02:07:32.978 - 02:07:33.790, Speaker B: That means.
02:07:35.520 - 02:08:36.988, Speaker A: This integer maximum can be equal to 256. So what happened if, let's say you declare uint a here and that's equal to 256 and you increment a, is it going to become 257? No, in this case it's going to overflow and it's going to wrap around the range. So instead of becoming 257, the behavior is that it will go back at the beginning of the range. And so now it's going to be equal to zero and it's totally different from what you want, and you have exactly the same problem on the other side of the range. So if a here start at zero and now you decrement it, then it's not going to become minus one, but instead it's going to become 256. So that's a big issue and we want to prevent this because otherwise the logic of our smart contract is totally broken. So before in this video I mentioned a solidity library that is called open ziplink.
02:08:36.988 - 02:09:07.640, Speaker A: And open ziplink can help us to prevent underflow and overflow bug by using something that is called safe math. So we've already imported safe math. Here you see this weird keyword that is called library. So it's a special kind of smart contract that doesn't have its own address. So we use library when we want to share some code between different smart contracts. We're going to use this safemass thing. So first we need to import it.
02:09:07.640 - 02:09:53.020, Speaker A: So we're going to import it here, import safemath. So and after we need to use a special declaration. So let me scroll down and here we can see this declaration using safemath for uint. Where is this thing? So this notation allows to attach all the function that are defined in safemath to the type u into 56. And so after, once we've done that, then we can have this notation here. So a add a multiply. So we will not use this notation the plus and multiply will not use this, and instead we'll execute the method of safe math.
02:09:53.020 - 02:10:13.112, Speaker A: And the reason why we can access this method is because we've used this notation here using Safemath for uint. That's it for this chapter we're good. So let's go to the next chapter. So in this chapter we're going to make use of safe math that we've imported in the previous chapter. So here's the code of safe math. Safe math. It looks a bit complicated.
02:10:13.112 - 02:10:46.516, Speaker A: You don't need to understand everything. But the point is that you can see like we have a couple of assert here, assert, assert. If this condition is not respected, then it's going to throw an error and the whole transaction is going to be canceled. So if you have an overflow underflow, this is going to be triggered and that's what we want. So let's see what we have to do exactly. Using safemass in our code. So we need to replace all the increment operator with a safe mass method.
02:10:46.516 - 02:11:39.752, Speaker A: So let's go to zombie ownership and let's scroll down here. We use the increment operator, but we don't want this. Instead we're going to use safe mass like this to add one here. This is the contrary, we want to remove owners on bacon sub, in this case sub one, and that's it, we're good. So we're going to keep making use of safe mass in this chapter because there are still some other places where we could have underflow or overflow here, for example, with this increment operator. However, the problem is the way we define this field, they are not uint 256, but we've attached safe mass to un two. And so if you try to use safe mass on a u in eight or 16, for example, it's not going to work.
02:11:39.752 - 02:12:18.228, Speaker A: So we need to have other using safe mass statement here. So one for uint 32 and one for uint 16. So let's do this here, uint 32 and the other one uint 16. And now that we've defined this, then we can use safe mass for these two types. So let's scroll down and see where we need this. So here we replace this increment by safe mass version, add one. Okay.
02:12:18.228 - 02:12:40.284, Speaker A: Do we have any other place where we need to do this? No, and actually I think I've made a mistake here. It's another version of safe mass for 32. So this safe mass 32 safe mass 16. Okay. And we. Good. Okay, so now we're going to finish the refactor with safe mass.
02:12:40.284 - 02:13:14.570, Speaker A: So we still have a couple of places where we have to use safe mass. So for example here Reynolds. Okay, so let's scroll down. Okay, so here we have three. That's a bit annoying. Add one here level. Add one loss count.
02:13:14.570 - 02:13:26.956, Speaker A: Add one, another two. Oh my God, are you going to.
02:13:27.058 - 02:13:28.670, Speaker B: Get done with this?
02:13:31.440 - 02:13:52.288, Speaker A: Okay, win count. Please tell me this is the last one. All right, and we good. So in this chapter we're going to add some comment to our code. So when you write SDG, smart contract.
02:13:52.384 - 02:13:53.716, Speaker B: Actually you might think that you write.
02:13:53.738 - 02:14:25.612, Speaker A: The smart contract for the blockchain for Ethereum, but that's partly true. But most importantly, you write it for yourself or any other programmer that's going to read the code of your spat contract in the future. And that's very important to make it readable. And one great way to make it readable is to add some comments. So there are different kind of comments. So here with a double forward slash, this is for single line comment. Then you have multiple line comment with this notation.
02:14:25.612 - 02:14:47.028, Speaker A: This is exactly like in Javascript. And there is also something which is called Nat spec. So with three forward slash here you will use some predefined way of commenting your code. So like title author, what are the different parameter? And it's easier for other programmer to.
02:14:47.114 - 02:14:48.324, Speaker B: Understand what's going on.
02:14:48.362 - 02:15:28.260, Speaker A: And you also have some tools that can extract these comments and build automatically some nice documentation. So let's see, how are we going to comment our code exactly. So we're going to add some Nat spec command to zombie ownership. So first a title. So here let's do this title. For example a contract that manage zombie ownership. Okay then the author, so I'll put my name, but you can put yours Julian.
02:15:28.260 - 02:15:47.652, Speaker A: And after we have the dev tag so that explain what the function does. So in our case that's going to be compliant with open zipping implementation of ERC 721. And we okay for comments. So we finish for the smart contract of this lesson.
02:15:47.716 - 02:15:48.852, Speaker B: Woohoo. Congrats.
02:15:48.916 - 02:16:12.530, Speaker A: So let's have a quick recap at what we've done. So first I've introduced the ERC 721 standard that we use to represent zombie on the blockchain. Then we've created an implementation for ERC 721. Then to prevent overflow and underflow file integer we use the Safemass library of open Zeppelin. And after we learn how we can comment our solidity code.
02:16:16.340 - 02:16:18.004, Speaker B: So there is still another lesson of.
02:16:18.042 - 02:16:22.852, Speaker A: Crypto zombies on Webster. Webstery is a Javascript library to connect.
02:16:22.906 - 02:16:25.412, Speaker B: Your smart contract to a web front end.
02:16:25.466 - 02:16:33.464, Speaker A: But the problem is that this lesson is really outdated, so I prefer not to waste time on it and instead.
02:16:33.582 - 02:16:37.770, Speaker B: Check out my playlist on Webster, which is up to date.
02:16:38.300 - 02:16:55.424, Speaker A: Another problem with everything we learn in this video is that we use solidity 0.5, but the latest version of solidity is 0.6, so there isn't too much difference between solidity 0.5 and 0.6.
02:16:55.542 - 02:17:38.920, Speaker B: Solidity 0.5 is mostly compatible with solidity 0.6, but if you are learning solidity you still need to know the differences. And for that I also have a video on this topic. So the next question is how you are going to monetize your skill, how you can become a professional blockchain developer blockchain developers are very well paid. On average they earn 20% to 30% more than web developers. As a blockchain developer, you could totally earn $100,000 a year, and you could also get a remote job way more easily than if you were a web developer.
02:17:39.000 - 02:17:40.524, Speaker A: So that's why I created a free.
02:17:40.562 - 02:17:46.460, Speaker B: Training on how to become a blockchain developer and it's all based on my own experience.
02:17:46.610 - 02:17:49.068, Speaker A: When I find my first blockchain job.
02:17:49.154 - 02:17:52.264, Speaker B: Paid one hundred k a year and remote.
02:17:52.312 - 02:17:54.316, Speaker A: So you will learn things that are.
02:17:54.338 - 02:17:55.788, Speaker B: Based on my own experience.
02:17:55.874 - 02:17:57.876, Speaker A: This is not just something that I.
02:17:57.898 - 02:18:14.480, Speaker B: Just copy pasted from who know where on the Internet. And you'll find a link to this training in the description below. I'll see you there's.
