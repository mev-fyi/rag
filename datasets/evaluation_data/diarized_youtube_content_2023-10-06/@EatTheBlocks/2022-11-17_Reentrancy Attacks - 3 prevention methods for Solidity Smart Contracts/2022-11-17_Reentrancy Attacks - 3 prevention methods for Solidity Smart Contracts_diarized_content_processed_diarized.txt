00:00:00.170 - 00:00:31.174, Speaker A: Reentrancy attacks are one of the worst nightmares for blockchain developers. These attacks wreak havoc in the Defi and DAO communities because they expose major vulnerabilities to the code base. If you want to become a blockchain developer, then it's critical that you understand this attack. When developing secure smart contracts at eat the blocks, we teach developers how to protect themselves and their code to these types of attacks. Check out some of our courses online today. I'll go over three methods to prevent a reentrancy attack for solidity smart contracts. Let's get into it.
00:00:31.174 - 00:01:26.562, Speaker A: Hey, my name is Anthony at eat the blocks we help teach web three development the first prevention method is implementing gas limitations setting gas limits by using certain functions within solidity. Gas limits can help prevent reentrancy attacks, but they are not a silver bullet. Gas limits work best when they are used with other code prevention methods. Understanding how gas works on the Ethereum blockchain is important when attempting to implement them as a security feature to your code. The transfer and send functions within solidity have gas limits assigned to them of 2300 units. This makes them useful when adding dot transfer and dot send, such as this code example shows. Using these functions should help prevent a reentrancy attack to a certain level because 2300 units of gas is not enough to recursively call back into this function in an attempt to exploit any funds from the smart contract.
00:01:26.562 - 00:02:11.670, Speaker A: Setting gas limits should be used with other prevention methods, as I mentioned, because it's almost like a layer of security that complements other hard coded examples, which I'll get into next. A second prevention method is to update state variables, updating your state variables before making any external calls to other contracts. Take a look at this smart contract. Do you immediately see anything wrong with this code? If you notice this line of code to be a vulnerability, then you're absolutely right. We need to move this line up here, and I'll explain why. By moving this line of code, we are making changes to the state variables before we call to another contract. This prevents a reentercy attack because the first call to send ether will be triggering our fallback function.
00:02:11.670 - 00:02:58.834, Speaker A: The fallback function will call back to the withdrawal function and it will check the balance of this contract. Since we updated the balance before we sent the ether, the balance will return to the updated balance after any withdrawals occur in this contract. If there's not enough ether in the balance, then the withdrawal function will just fail. Moral of the story is update this code before making any external calls to this contract. The third prevention method includes using reentrancy guard modifiers. Locking a smart contract while a function is being executed is a tremendous way to prevent reentrancy attacks. For example, only allowing a single function at a time to be executed will slow down any reentgency attempts.
00:02:58.834 - 00:03:43.810, Speaker A: Modifier functions can help secure smart contracts in this way. Adding an internal state variable will be needed for locking our smart contract. Inside of the prevent reentrancy modifier function, we'll first check that the state variable locked is not locked. Then we'll set locked equal to true. Execute the function with this underscore, and then after execution, it's important to set locked equal to false. We also have to call the prevent reentrancy modifier on this withdrawal function. This prevents a reentrancy attack because if an attacker calls the withdrawal function in an attempt to drain any funds within the smart contract, the prevent reentrancy function modifier will be called and then set locked equal to true.
00:03:43.810 - 00:04:08.950, Speaker A: It will then execute the desired withdrawal function, but only once at a time. If the attacker tries to recursively call the withdrawal function a second time, it will actually fail because it's locked in that moment. This will result in a failed transaction and an unsuccessful withdrawal attempt from the attacker's point of view, and those are three methods on how to prevent reentercy tax for solidity smart contracts.
