00:00:00.410 - 00:00:09.130, Speaker A: Solidity zero Eight just came out with a bunch of new feature and breaking changes. So in this video I'm going to show you all of these updates.
00:00:09.210 - 00:00:13.006, Speaker B: As a blockchain developer, it's extremely important.
00:00:13.108 - 00:00:14.734, Speaker A: To stay up to date with the.
00:00:14.772 - 00:00:44.326, Speaker B: Latest updates of solidity. So you absolutely have to watch this video until the end. And if you don't know me, I'm julian and on my channel it the blocks I teach blockchain development. I just released a new course on defi development. If you are a blockchain developer, it's a great way to specialize yourself in this niche and get even better job opportunities. And it's also very useful for entrepreneurs who want to launch their own D five project. You will find the link in the description.
00:00:44.326 - 00:01:27.270, Speaker B: Okay, let's get started. So the best way to experiment with three D zero point eight is to use remix the online IDE for solidity. So first we'll go in the solidity compiler section and change it to 0.8.0. Then we are going to create a new smart contract. Then you're going to use the solidity version of 0.8.0 for the Pragmas statement. So we define our contract and we're going to play around with the new feature.
00:01:27.270 - 00:02:21.754, Speaker B: So let me create a function here. So the biggest difference is that now for arithmetic operation, it automatically throw an error if there is an underflow or overflow. So with solidity in a Uint variable, you can store number going from zero to two power 256 minus one. But in previous version of solidity, what happened is that when you go on either side of the range, it wrapped the numbers. For example, if you try to store minus one in a Uint, it will actually be transformed in two power 256 minus one. And conversely, if you try to store two power 256 minus one plus one. So it's going to wrap around on the other side, it's going to be transformed to zero.
00:02:21.754 - 00:03:10.914, Speaker B: So we absolutely don't want this behavior. So to protect against this open zeplink, which is a solute library, created the Safemye library. So safemice is used in most smart contract that use arithmetic operation. But now this is built in in the language. So now with the new behavior of solidity, if you try to store a number that is outside of the range for you in, it's not going to do an overflow or an underfloor, but it's going to throw an error. So no need for safe mass anymore. Then another change is if you divide by zero, it's going to throw an error with a revert operation, whereas before it was creating an invalid opcode.
00:03:10.914 - 00:04:00.778, Speaker B: So why this is important? Because with a revert you're consuming gas just up to the point of the revert. So for example, if you do a bunch of stuff before, then you consume all the guys up to here. But before when it was throwing an invalid opcode, it basically consumed all the gas allocation for your whole transaction. So with this that allow you to save some gas and we have the same behavior for underflow overflow. Okay, so next change. So now we don't need to use pragma experimental AbI encoder v two. So in previous version of 3D we needed to use this weird notation when we want to accept a struct here as an argument of a function.
00:04:00.778 - 00:04:35.640, Speaker B: But now it's activated by default so we don't need to use it. So it's a simplification. Then another change is that the types bytes has been removed, so now we need to use bytes one instead. Next we have a couple of changes for addresses. So before address literal. So these are address that you type like this, like zero, x, et cetera, et cetera. So the type of these addresses before was address payable, but now it's just address.
00:04:35.640 - 00:05:33.990, Speaker B: So if you want to send some ether to this address now, then you have to cast this to an address payable with this notation like this. Same thing for msg sender, which is a built in variable that's the address of the sender of the transaction. Before it was address payable, now it's just address. So if you want to send some ether to msg sender, now you have to first cast this into an address payable after you call the transfer method, and here you specify your amount in way and next thing with address. So you can still convert a contract to an address like this, but now it's going to convert to an address only. So if you want to send some ether to this smart contract now it's slightly more complicated. You need to do two conversion first to an address and then to an address payable like this.
00:05:33.990 - 00:06:03.180, Speaker B: So what's next? In this video I just show you the updates of Solidity 0.8. But if you don't know much of solidity, you have to start from the basics. And for this you can check out my series on solidity with a ton of small videos on very specific concepts. After you go through this theory, you will feel much more comfortable in solidity. It covers three, DT, zero, five, but most of the concept I show in this series still apply to three DT zero eight. Check it out.
