00:00:00.170 - 00:00:55.534, Speaker A: Are you a developer who want to level up in solidity? One of the best way to become better at solidity is to practice gas optimization, and that's because it will allow you to better understand the Ethereum virtual machine. And once you become an EVM master, it's much easier to get a highly paid job in Webstree. So in this video I will show you five advanced techniques that you can use to do gas optimization in your smart contracts. If you are new here, I'm julian, and on either blogs I help you to become a webster expert so that you can make more money, get more freedom, and work on projects that you love. And first, let's talk of what is gas saving. And for that we need to first talk of solidity and the Ethereum virtual machine. So after you write a solidity smart contract, you have to compile it.
00:00:55.534 - 00:01:36.650, Speaker A: And when you compile it, it's translated into what we call EVM opcodes. EVM opcodes are elementary instructions that run on the Ethereum virtual machine. The Ethereum virtual machine is the part of Ethereum that runs your smart contract. Each of this opcode has an associated gas cost, and when you change your solidity code, it's going to produce different opcodes. So when you do gas optimization, there are different objectives. One objective is to optimize for the deployment cost, and the other objective is to optimize for execution cost. When a user execute the smart contract, and often when you optimize for one, it de optimize for the other.
00:01:36.650 - 00:02:09.310, Speaker A: So you often have to make some compromises. There are different approaches. One approach is to think at a high level about the design of your application and especially about which data you are going to store in a smart contract and how you are going to organize your data. Another approach is to optimize the solidity code, and the last approach is to use a different language to implement your smart contract. For example, solidity assembly, YoL, huff or Viper. These languages produce different opcodes. They offer you more or less control about the generation of EVM opcodes.
00:02:09.310 - 00:02:55.602, Speaker A: And for low level languages, even though they give you more power, they are also more risky because it's easier to make a mistake. The first tip for gas saving is about smart contract deployment. When you create smart contracts, you sometimes have to deploy the same smart contract multiple times, but with different initialization data. For example, if you create a separate wallet for each user, the deployment cost is proportional to the size of the code. The smaller the code, the cheaper the deployment cost. To minimize deployment cost of identical contracts, there is a technique called EIP 1167, also called minimal proxy. This technique looks a bit scary because it involves some solidity assembly, which is low level EVM coding, but the code is already written for you, you just have to use it.
00:02:55.602 - 00:03:36.590, Speaker A: So here is how it works. First you have to deploy your implementation contract. It's like a template. Then you have to deploy a factory contract, and after every time you want to deploy a new copy, you call the factory contract. It doesn't redeploy the implementation contract, but instead it just deploys a very minimally smart contract called a proxy. When a user wants to interact with their instance of the smart contract, they call their proxy, which forward the call to the implementation contract. But the call happened in the context of the proxy contract, which means any data change will be done at the address of the proxy contract, but not at the address of the implementation contract.
00:03:36.590 - 00:04:21.930, Speaker A: And this is possible thanks to a spatial opcode called delegate call. The second tip for gas saving is about arrays as arguments. So when you pass an array to an external function, you can either declare it call data, which means it's taken directly from the transaction payload, which is immutable, or memory, which means that you can manipulate the array in your code, but it takes more gas because the EVM has first to copy your code from call data to memory. If you are just going to read this array after and don't need to manipulate it, use core data. It will cost less gas. My next gas optimization tip is about modifiers. When you use a modifier, the whole code of the modifier is repeated every time it's used to minimize the deployment cost of your contract.
00:04:21.930 - 00:05:11.898, Speaker A: Instead, you can create an internal function with the code of the modifier and call it from the other functions who need it. The only small downside is that it adds a jump upcode when you execute each function, but it's a negligible gas cost. My next tip for gas optimization is about the immutable keyword. This was introduced in solidity zero six five, and it allowed to declare contract level variables which get stored in the code rather than storage. However, contrary to a standard variable, it's not possible to change its value later with a standard storage variable every time you read it, you have to call the s load upcode, which costs 2100 gas. However, when you read an immutable variable, it just reads a constant from the stack. That is done using the push 32 opcode, which only cost three gas.
00:05:11.898 - 00:05:47.862, Speaker A: So if you have a storage variable that is not going to change, use the immutable keyword. My next gas optimization tip is called variable packing. When you declare variables at the smart contract level, they get stored in the EVM storage. Each storage slot in the EVM takes up 256 bits. For example, here, if you declare this five variable, it will take five storage slot, but there are variable types that takes less than 256 bits. For example, this type takes only 32 bits. If you have some variables that don't need 256 bits, you should use these smaller variable types.
00:05:47.862 - 00:06:35.778, Speaker A: For example, for timestamps. If you use a UN 32, you can represent timestamps until the year 2106, which is more than enough for many smart contracts. So with the UN 32 type, these four variables will only take 128 bits, which is half a storage slot, instead of four storage slots before. And for this variable, if instead of a standard uint which takes 256 bits, you only need 128 bits, you can redeclare this variable with the smaller type. And now you have 128 bits plus 128 bits. And now in total, all these variables take up only 256 bits, and they will get packed in a single storage slot instead of five before. And thanks to this, you will save gas both on storing and reading these variables.
00:06:35.778 - 00:06:53.530, Speaker A: Interactions with the storage are among the most expensive upcodes of the EVM, so variable packing is a very important technique. And next, if you want to have a full roadmap for how to get a Webster job during this bear market, check out my free masterclass. The link is down below. That's it for today. Bye.
