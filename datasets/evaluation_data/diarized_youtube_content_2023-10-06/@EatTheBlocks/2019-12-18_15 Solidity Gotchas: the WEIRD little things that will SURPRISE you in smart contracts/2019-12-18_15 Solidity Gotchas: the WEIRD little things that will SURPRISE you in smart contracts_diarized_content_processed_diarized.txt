00:00:00.250 - 00:00:37.954, Speaker A: Hey hey. This is julian and you are on idoblox. In this video I'm gonna give you a list of 15 gutshots for solidity. These godshots are willow things that can really surprise you, especially when you already have a background from another programming language like JavaScript or Python. So instead of wasting time and try to figure out everything by yourself, do yourself a favor, watch this video. By the way, if at any time you're a bit lost when I mention a solidity gotcha, then you can check out my series on solidity where I dive into every aspect of the language. This is very very comprehensive.
00:00:37.954 - 00:01:11.502, Speaker A: So the first gotcha is that solidity change a lot between three T 0.4 and three t 0.5. So you'll find a lot of outdated tutorial for the old version of solidity. So be careful. When you read online tutorial, make sure that these are for three T 0.5. The second gotcha is that in solidity private variables are not so private. So when you define a private variable, actually it's only private for other smart contract.
00:01:11.502 - 00:01:56.942, Speaker A: That means the other smart contract will not be able to read the value of this variable. But if you are outside the blockchain, you will still see this variable inside the blockchain. Because the Ethereum blockchain is a public blockchain. So anything that is in the blockchain is absolutely publicly accessible. So granted it will not be super easy for someone to read this variable because you will need to use some blockchain analysis tool, but it's totally doable. The next gotcha is about strings. So in solidity we do have a string type, but it's actually not so easy to manipulate and especially if you use two language like JavaScript.
00:01:56.942 - 00:02:46.398, Speaker A: For example, you cannot do string concatenation very easily in three DT. For example, if you have two string like name plus surname, then you cannot concatenate the two string like this. You also cannot get the length of the string. And there are many other very common operation with strings that we can usually do with other programming language that we just can't do easily in solidity. So because of all this limitation, in a lot of cases we actually avoid to use strings in solidity and instead we use bytes or byte 32. The next gotcha has to do with memory location. In solidity, when you define a variable, it has a specific memory location, and compared to other programming language this is actually more complex.
00:02:46.398 - 00:03:45.942, Speaker A: For example, if you define an integer here, it will have the storage memory location. That means that it's going to be stored inside the blockchain. But if you define a variable in a function instead like this, then it's going to have the stack memory location, which means after the function execute it's going to be destroyed, it's not going to be persisted in the blockchain, and in total there are four different memory location in solidity. So if you're not clear on this, check out this video where I explain everything. So the next gotcha has to do with mapping. So mapping in solidity are a little bit like object in JavaScript, but not entirely. With the mapping you can associate some keys with some value and this is widely used in smart contract, but they are not so intuitive to use.
00:03:45.942 - 00:04:46.546, Speaker A: For example, it's not possible to instantiate a mapping here. You cannot do something like mapping of address to integer balances and say okay, I'm going to do like JavaScript and I'm going to have, I don't know, this address and this value and this other address, this other value. If you do this it's not going to work. Instead you can only reference mapping that have already been declared in a storage memory location and you're going to assign to a value to them like this. Another weird thing with mapping is that it's not possible to list all the keys. So in JavaScript you can do object keys and it's going to give you an array of all the keys of this object, but you cannot do the same thing in solidity. So you need to track yourself all the different keys.
00:04:46.546 - 00:05:37.854, Speaker A: So either it's going to be external user of the smart contract who know the keys of your mapping, or you will need to store all these keys in an array yourself. And the last thing I find really weird about mapping is that by default all the keys exist. So that means that if you try to read the value of a keys that hasn't been created yet, like I don't know, some random address here for example, this has absolutely a value, and so by default that's the default value of the type that it maps to. So in this case this is going to be zero. So you always be able to access any keys of any mapping. The next gotcha has to do with arrays. So in solidity we do have arrays like in JavaScript, but they work a bit differently.
00:05:37.854 - 00:06:26.098, Speaker A: So for example here I can define an array of integer and in a function I can manipulate these arrays. For example here I can add any value to this array. So we say that this is a dynamic size array, I don't need to specify the size and I can add as many entry as I want. But it's also possible to define an array in memory like this. But in this case I need to specify the size of the array. Here, this is going to be an array of size of length ten. So it's not possible to have a dynamic size array that is in memory, it's only for storage array.
00:06:26.098 - 00:07:10.454, Speaker A: So here if I try to use the push method, then they're going to be an error. There is no push method for that kind of array, so that's a bit annoying. And that means that every time you declare an array of in memory, you need to know in advance what's going to be the length of the array. The next gotcha has to do with what you can return from external function. So external function, a function that can only be called from outside the smart contract, and you can return some data from this function. For example, you can return an integer, so here I can return one. But if I try to return an array of string like this, then this is not possible.
00:07:10.454 - 00:08:07.826, Speaker A: And if you want to know the reason, it's because behind the hood a string is an array itself. So this is an array of array, and this is also not possible to return array of array in solidity. You can do it if you add an experimental pragma statement. So pragma experimental, I don't remember the exact syntax, but basically the solidity compiler will tell you exactly what you need to add it. But it's not really recommended to use this pragmas statement in production because these features might be removed in future version of solidity. It's also not possible to return a struct from a smart contract. So here, if you define a struct a with a couple of field inside, then yeah, you just can do this unless you put the experimental pragma statement.
00:08:07.826 - 00:08:55.826, Speaker A: So instead, if you want to return a struggle, you need to return a tuple of all its fields. So for example, here we have a single field, so I'm going to return only one integer, but if we had two then I would return two integer, et cetera, et cetera. The next gotcha has to do with the number of variable that you declare in a function. So here if you have a function and you declare too many variable inside, et cetera, et cetera. So if you have many, many variable, at some point you will hit the limit of solidity and you will receive the error message stack to dip. And actually this limit is not very high. I think it start to trigger around 15 or 16 variables.
00:08:55.826 - 00:09:27.538, Speaker A: So this can be quite annoying. And when you see this, you have no choice but to find a way to decrease the number of variables. The next gotcha is related to events. So in solidity you can emit some data for outside consumer by using events. So first you need to define an event. Then your event will have a couple of fields. It can be integer, it can be string and any other solidity type.
00:09:27.538 - 00:10:12.762, Speaker A: And after in a function you can emit this event. Like this, emit my event and you pass in all the string one. Hey, and then outside consumer like the front end of decentralized application can listen to these events. The thing is, once a smart contract has emitted an event, there is absolutely no way for the smart contract to read or modify this event. This is just something that the smart contract create for outside consumer. But the smart contract itself is unable to access this event after it was emitted. The next gotcha has to do with ether transfers.
00:10:12.762 - 00:10:56.126, Speaker A: So a smart contract can send or receive some ether. And the way you send ether to a smart contract is by calling one of its function. And that's not super intuitive. So for example, if I want to send some ether to this smart contract, I will need to declare a function and make it payable. If you don't make it payable, it's not possible to call this function and send some ether. The other solution is to use what we call the fallback function. So that's an unnamed function that is called when someone send ether to this contract, but without mentioning any specific function.
00:10:56.126 - 00:11:41.738, Speaker A: In the end, a function will still be executed if it exists. And that's the fallback function and you also need to make it payable. And lastly, if you try to send some ether to a smart contract without calling any of its function, and this smart contract does not have a fallback function, then your ether transfer will be rejected. The next gotcha has to do with locking some ether or some Es 20 token inside a smart contract. So let's say that you have a smart contract that can receive some ether. So it has a fallback function like this. So you send some ether to the smart contract, but beside this fallback function, you don't have any other function.
00:11:41.738 - 00:12:32.762, Speaker A: Well you know what, my friend? Congratulations. Because you just locked all the ether in the smart contract. Because now there is absolutely no way to spend this ether. If you want to be able to spend this ether, you need to have another function. For example, you call it send and then probably that you'll do some check like you require that the sending address is an administrator that you defined before. And here in your argument on your function, you're going to define maybe the recipient of the transaction and then the amount, and then you're going to send the ether to this address like this. And so with this function then you are safe because now you can send your ether after that was sent to the smart contract.
00:12:32.762 - 00:13:13.050, Speaker A: And the same thing also applied to Yas 20 tokens. So whenever a smart contract receives some ether or some Yas 20 token, make sure to create a function to transfer this asset later. So the next gotcha had to do with manipulating integer variable. So let's give an example. So let's say that we have an integer variable here, and here we accept another integer as an argument. And here I'm going to add A and b. A can represent integer up to a certain value.
00:13:13.050 - 00:14:05.766, Speaker A: So that's a very high value. But if here a is already equal to the maximum value and you keep adding to it, then what's going to happen is an overflow. So because the type cannot represent any number that is bigger than that, it's going to loop back to the beginning of the range. So C is going to equal zero instead of a very, very high number. Underflow is the same mechanism, but it happened on the other side of the range. If you keep decreasing an integer up to the minimum value, then it's going to wrap around and become very, very big. So in particular, if you do some ether transfer and you base your ether transfer on addition or subtraction that you have vulnerable to overflow or underflow.
00:14:05.766 - 00:14:55.658, Speaker A: So to prevent against this, you can use a library that is called safe math. With safe math, every time you want to do some arithmetic, then you use the library instead of using the operator of solidity. The next gotcha is what we call a reentrancy attack. So, let's see how this can happen. So here I have my full function, and this foo function is going to call the function of another smart contract. So smart contract B, I'm going to call, I don't know, bar. It's possible for this other smart contract b to call back inside my foo function, and by doing so it can create some really nasty effect.
00:14:55.658 - 00:15:48.458, Speaker A: That's how the infamous hack of the DAO happened in 2016, and how the DAO smart contract lost all of its ether. To prevent against this, you have several solution. One solution is to limit the amount of gas that is forwarded to the bar function in the called smart contract so that it doesn't have enough gas to call you back another defense is to have a locking mechanism and the open ziplink framework show you how to do this. The next gutsha is spending too much gas. So when you execute a transaction on a smart contract, you have to spend some ether and that is measured in a unit called gas. By the way, if you have no idea what is gas, check out my series on gas on this channel. So you have to be careful because the more computationally intensive your code is, the more gas you're going to spend.
00:15:48.458 - 00:16:48.346, Speaker A: For example, if you have some for loop, then this can potentially can make you spend a lot of gas. Also, if you use some hashing function like ketchak 256, this is also very gas intensive. So this is very different from a traditional programming language like a JavaScript where computation are very cheap. In solidity computation are very expensive, so we really try to minimize the gas consumption. The next gotcha is that it's not possible to call external APIs from a solidity smart contract. So here in your full function, for example, if you want to call the API of Twitter and get all the tweets of a specific user, then it's not possible to do it. What's possible to do though is to import outside data inside the blockchain and then your smart contract will be able to consume this data and for that you use the oracle pattern.
00:16:48.346 - 00:17:13.490, Speaker A: By the way, if you want to receive my five most useful solidity tips, make sure to register by following the link in the description. That's totally free. That's it for this list of solidity gotchas. If you have any question, or if there are any other gotchas that haven't mentioned, then please let me know in the comments down below. Thanks for watching and see you for another video on solidity and Ethereum programming. Bye.
