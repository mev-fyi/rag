00:00:00.490 - 00:00:35.510, Speaker A: The dream of every entrepreneur is to have a recurring income. If you sell a subscription with fiat money, you can already use services like stripe. But for crypto we don't have any equivalent service. Well, it doesn't matter because we are developers and on the blockchain we can create our own tools. In this video we are going to create a solidity smart contract that can accept recurring payments in crypto. What I'm going to show you can be used on any VM compatible blockchain, Ethereum of course, but also Binance, smart chain and Polygon. If you don't know me, I'm julian and on etherblocks I teach blockchain development.
00:00:39.850 - 00:01:13.966, Speaker B: Alright, so let's see how subscription system will work. So we will start with our merchant. That's the person who will accept the recurring payment. And at the center of our system we'll have a payment smart contract. So the merchant will have to create a new subscription plan. By calling a function on this payment contract, the merchant will specify the frequency of the payment and the amount. Later a buyer will subscribe to this plan and we are going to assume that the payment will be done with an ES 20 token.
00:01:13.966 - 00:01:55.898, Speaker B: For that, the buyer will need to call the approve function on the smart contract of the token so that the payment smart contract is able to spend tokens on behalf of the buyer. So here you have different solution. Either the buyer approve a small amount to cover the first few payments and later as we advance in time, the buyer called the approve function again so that all the subsequent payments can be made, or the other approach is to call the approved function with the infinite number for the amount, which means that the payment smart contract can spend all the token that belongs to the buyer. It's more dangerous because if there is a flow in the payment smart contract, the buyer can lose all of its token.
00:01:55.994 - 00:01:58.158, Speaker A: But in terms of user experience, it's.
00:01:58.174 - 00:02:46.858, Speaker B: Also easier because in this case you just need to call the approved function only once. After that, the buyer will call the subscribe function of the payment contract. The buyer will specify which plan it subscribed to and the first payment will be made instantly and a merchant will receive it. And for the next payments anyone can trigger them by calling a function of the payment contract and the payment contract is going to check that the next payment is due. So for example, if the next payment is due in 30 day, but you try to trigger the next payment, the 29th day is not going to work. So it doesn't matter that anyone can call this function because this is secure at the smart contract level with the code. So for example, if we are the 31st day, the next payment is going to be triggered and it's going to be sent to the merchant.
00:02:46.858 - 00:03:21.260, Speaker B: And every time we do a payment, we recalculate the date of the next payment so that if someone is trying to do toe payment for the same period, it's not going to work. Okay, so that's it for the overview of the smart contract. Next we're going to do the coding. All right, so we're going to do the coding. So this is the GitHub repo of it, the blocks, and this is a folder for this project. So here this is a truffle project and we have our smart contracts in a contracts folder. So here we'll go in payment.
00:03:21.260 - 00:03:45.106, Speaker B: All right, so first we have our import to the interface of yes, 20. Because we are going to manipulate this token. We define the payment contract. Here we define a variable for the next plan ID. For each plan it's going to have a unique ID. Then we define a couple of structs. So first we start for each subscription plan.
00:03:45.106 - 00:04:33.278, Speaker B: So we're going to have the address of the merchant, the address of the token, the amount that need to be paid for each payment, and the frequency of payments in days. Then we're going to have a struck for the subscriptions. So we're going to have a field for the subscriber, a date for the start of the subscription and a date for the next payment. This is going to be recalculated every time you receive a payment. Then we're going to have two mapping, a mapping to hold the subscription plans and this is indexed by the plan IDs and a second mapping for the subscription. So this is going to be indexed first by the address of the subscribers and after by the plan IDs. After we have a couple of events here for the different actions of smart contract.
00:04:33.278 - 00:05:03.750, Speaker B: After we have a function to create plan. So this is going to be called by merchant. So when you call this function, you specify the token of the payment, the amount for each payment, and the frequency of payments in days. So here we do a few minutes check. We check that the address of the token is not the null address. The amount needs to be superior to zero, and the frequency also needs to be superior to zero. Then here we are going to instantiate a plan struct.
00:05:03.750 - 00:05:42.986, Speaker B: So we give it the address of the merchant, the address of the token, the amount to be paid, and the frequency. By the way, I made a mistake before. I told you the frequency is in days. This is actually a timestamp in second and after we increment the next plan ID integer so that the next time we call the create plan function, we do not override our plan. And so our new plan is going to be stored in the plans mapping index by its plan id here. After we have the subscribe function, this is going to be called by buyers. So it has a single argument for the plan ID.
00:05:42.986 - 00:06:24.134, Speaker B: So first we create a pointer to the token of the plan, then a pointer for the plan. We require that the plan actually exists by checking that the merchant address is not a null address. Then we transfer the token from the buyer to the merchant for the amount. So this is the first payment of the subscription. Then we emit an event, and after we instantiate a subscription struct, specify the buyer, the stop date of a subscription and the date of the next payment. So this is the current timestamp plus the frequency of the plan. And after we emit an event.
00:06:24.134 - 00:07:00.066, Speaker B: Okay, and after we have the cancel function that can be called by buyers to cancel a subscription. So we specify the plan that we want to cancel. Here we create a pointer to the subscription. Here we check that this subscription actually exists. And after we are going to delete the record in the subscriptions mapping, we emit an event. And so next time someone tried to trigger a payment for this subscription, it's not going to work because it's not in the subscription mapping anymore. And finally, we have the pay function.
00:07:00.066 - 00:07:28.346, Speaker B: This function can be called by anyone to trigger a payment. So we specify the address of the subscriber and the ID of the plan. And these two things will identify a subscription here. So here we get a pointer to the subscription, a pointer to the plan, a pointer to the token for the payment. We check that a subscription exists. We check also that a payment is due. So we need to be after the date of the next payment.
00:07:28.346 - 00:08:24.430, Speaker B: We do the actual token transfer here, we emit an event for the payment and we recalculate the date of the next payment by adding the plan frequency here. And so what happened if we are a little bit late? So let's say that we have a payment every 30 day and we call this function the 31st day. So we are one day late. But it doesn't matter for the next payment date because we calculate the next payment date based on the next payment field that was stored. So this is 30 day after the beginning of the subscription. So that means here for the new next payment, in this case it will be 60 day and what happened if you miss sub payment? For example, if you don't call this function for 61 day, well you will call the pay function once and you will pay for the first installment of 30 day. So after the next payment it will calculate 60 day.
00:08:24.430 - 00:09:05.606, Speaker B: And so just after your first call to pay you can call it again and this time it will pay the second missing payment, et cetera, until you catch up with all the due payments. Okay, so now we are going to see the test. So we go in the test folder in payment Js and first we import a couple of things from openzepling test helper. So this is a testing library for smart contract expect revert. This allow you to test failure case constant. So this defines some useful constant. And time this object allow you to manipulate the time of the blockchain.
00:09:05.606 - 00:10:00.714, Speaker B: And this is going to come in quite handy to test the future payments. And we also import the contract artifact for the payment and the token. By the way, the token contract here, this is a mock token. We just created this solidity contract just for testing. Here we define two variables, so 30 days and 60 days in second and we use the time constant of open Zeppelin test helper to do this very easily. And after we define our contract block and here we're going to define a couple of address, the address of the merchant of the subscriber, define also two variable for the pointer to the payment contract and to the token contract. And before each test we are going to redeploy the payment contract, the token, we are going to transfer 1000 token to the subscriber and we are going to approve all this token to be spent by the payment contract.
00:10:00.714 - 00:10:53.822, Speaker B: Here we specify that this is done by the subscriber. And here we have a first test, so it should create a plan. So here we create a plan with a different parameter, the address of the token, the amount to be paid for each payment, the frequency of payment, and here the sender is the merchant. And then we're going to check that the plan was created as it should and so the plan ID is zero. And here we're going to test the different fields. So the token should be the address of the token, the amount of each payment should be 100 and the frequency of payment should be 30 days. And then we try to create a second plan and with different parameter, and we make sure that all the fields are correct after we need to test the unhappy pass.
00:10:53.822 - 00:11:23.446, Speaker B: So when the required statement are triggered. So here if we try to create a plan with the zero address for the token, we're going to have this error message. Here we try to create a plan where the payment amount is zero. So we're going to have another error. And finally here the frequency is zero, so it's going to be yet another error. Okay, so after we are going to test that the subscription creation works well. So we create a plan.
00:11:23.446 - 00:12:03.490, Speaker B: We try to subscribe from the subscriber and to test one of the field we need to know what is the current timestamp of the blockchain. So for that we're going to use the Webster library to get the latest block and the timestamp will be on this object. We also get the subscription that was created. So for the address of the subscriber and for the plan ID, which is zero. So here we test all the field, the subscriber, the start date, so it should equal to the timestamp of the last block and for the next payment field. So we add 30 days to the timestamp of the block. Okay, that's it for this test.
00:12:03.490 - 00:12:43.086, Speaker B: Then we test the unhappy pass for the creation of a subscription. So try to subscribe to a plan that does not exist and it should be the error message. After we're going to do a test a little bit more complex. So we're going to test that the different payment work. So here we create a plan from the merchant and we subscribe from the subscriber and we're going to test that the first payment was sent. So we get the balance of token for the merchant and the subscriber. And so the merchant should have received 100 and the subscriber had 1000 token initially, so he should have 900 now.
00:12:43.086 - 00:13:11.014, Speaker B: Then we are going to artificially increase the time of the blockchain with a time increase function. This was an object that we got from the open Zeppelin test Helpers library. So we're going to increase by 30 days plus 1 second. So we should be able to trigger the next payment. So we call the pay function. We specify this is for the subscriber, for the plan ID, zero. And again we are going to test the token by land.
00:13:11.014 - 00:13:32.302, Speaker B: So this time the merchant should have received 100 extra tokens. We should have 200. And for the subscriber this is the opposite. He has 100 less. So 800 now. And we do last payment. And so this time the merchant should have 300 token and the subscriber 700 only after we're going to try the unhappy pass for the payment.
00:13:32.302 - 00:14:16.154, Speaker B: So we create a plan. We subscribe with our subscriber. We increase the time 30 days, but -1 second. So it's still too early and we try to trigger the payment, but it's too early, so we should see this error message after we are going to try to cancel the subscription. So we create a plan. We subscribe, we cancel, and after we try to read the subscription object and to make sure that it was deleted, the subscriber field should be the zero address. And our final test is if we try to cancel the subscription, but it failed and this happened if we try to cancel a subscription that does not exist.
00:14:16.154 - 00:14:22.686, Speaker B: So we're going to have this error message and that's it for our test. There are still a few improvements you.
00:14:22.708 - 00:14:38.354, Speaker A: Can add to our smart contract. For example, you could automatically cancel a subscription after a few missed payments. You could also add an incentive system so that anybody can hit the pay function and get a reward when a payment is done. And of course, you can also add.
00:14:38.392 - 00:14:39.906, Speaker B: A front end so that people can.
00:14:39.928 - 00:15:06.940, Speaker A: Buy subscription for a product you offer. In terms of strategy, you could use this project in two ways. You can either use it for your own use if you sell some subscriptions product, or you could build a service like stripe for crypto where you offer a tool for merchants. In this video, we did a lot of testing. Testing is very important for smart contracts and if you need a refresher on how to test smart contract with truffle, you can watch this video on my channel. I will see you there.
