00:00:00.330 - 00:01:01.594, Speaker A: In this video I'm going to show you how you can write dry code in solidity. And before we continue, make sure to join the Facebook group of blocks where you can discuss blockchain with me and other members of the blocks. So first, what is dry code? Dry means don't repeat yourself, and that's a principle that you must follow in any programming language. The reason why we want to avoid this is, is because first of all, when you repeat yourself, it makes it more likely to create some bug. Because in the future when you want to update your code because some feature changes, then you need to change your code in different places and you forget one change and then there is a bug and it's not good. And another reason which is specific to solidity smart contract is that we want to minimize the size of the code because the larger the code, the more expensive it will be to deploy to the ethereum blockchain. So you have all the reasons enrolled to make your smart contract code dry.
00:01:01.594 - 00:02:33.370, Speaker A: So how can we do this? Well, first let's assume that we have this situation. So here I have my smart contract, I have two function, A and B. And in this two function at some point I'm doing something that is similar, like for example, I don't know, msg sender send 100. Then I'm going to update a variable so balances of msg sender here. So I'm going to decrease this of 100 and I do this also in B. So what you could do in this case is create an internal function that you will call, I don't know, transfer ether and you will prefix it of an underscore because this is a good practice to do this for internal function and you will move this inside your internal function. And now you just need to call transfer ether in B and A and you make your code more dry.
00:02:33.370 - 00:03:21.242, Speaker A: Another way you can make your code dry is by using modifier. So maybe that you have two function where for example you require that the sender for example is the admin. So the admin that you define in another variable you could do an internal function like we did here. But when you do some access control it's more typical in solidity to use a modifier. So here you create your modifier only admin and you will move here your required statement inside here the underscore to specify that to represent the function the modifier is attached to. And here you attached your modifier wherever you need it. And now your code is more dry.
00:03:21.242 - 00:04:12.720, Speaker A: Another possibility is that you have the same code in different smart contracts. For example, here we have my contract two, maybe that, let's say the function a is exactly the same, do this, do that, et cetera. Same thing in, let me get rid of this same thing in a and that's not very good to have this. So that's a typical use case when you want to use inheritance. So in this case you're going to create a parent smart contract where you're going to have the common functionality. Let me copy paste this. This is called parent.
00:04:12.720 - 00:05:00.798, Speaker A: And now you don't need to redefine a in my contract one and two, but all you need to do is to import the parent smart contract and you make it inerate from parent. And now you have access to a inside your smart contract. So that's very, very convenient. And the same thing applies if you define the same data structure in my contract and my contract too. For example, let's say you're going to use a struct. So I don't know, struct trade with an ID, maybe an amount, a date. So now if you define your struct in a parent, then same thing.
00:05:00.798 - 00:05:14.540, Speaker A: You can reuse this truck in here, my contract two and my contract. So running drive smart contract is very important. And if you want to learn even more tricks for solidity, check out this series. I'll see you there.
