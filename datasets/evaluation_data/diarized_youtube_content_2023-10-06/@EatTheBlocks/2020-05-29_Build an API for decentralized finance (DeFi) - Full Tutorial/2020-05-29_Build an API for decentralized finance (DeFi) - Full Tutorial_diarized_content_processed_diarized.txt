00:00:00.170 - 00:00:34.390, Speaker A: If you are into blockchain, you probably stumble upon the word deFi. DeFi or decentralized finance is all about reinventing finance. But on the blockchain, DeFi is growing fast and it's happening on the Ethereum blockchain. If you are a blockchain developer, you need to get on the DeFi train. That's where you will find most job opportunities. DeFi is really cool, but it's not easy to get started as a developer because you have to interact with the smart contracts of all these DeFi protocols. It's not easy.
00:00:34.390 - 00:01:20.050, Speaker A: What if you could use a rest API to interact with this DeFi project? You would send simple HTTP requests. That's it. That would be much easier. Well, in this video we are going to build our own node JS API for decentralized finance by interfacing with the compound protocol and on top of it it will show you a good example of what is backend blockchain development. If you don't know me, I'm Julian and on my channel idoblocks, I teach blockchain development and how to find your first blockchain job. The DeFi project we will cover is called compound, one of the most popular D five projects. Compound is a lending protocol.
00:01:20.050 - 00:02:07.506, Speaker A: It allow you to borrow or lend ES 20 token on the Ethereum blockchain and you can also earn some interest by providing some liquidity. Loans are secured by collateral provided by borrowers, so you don't need any credit score. But on the other hand, you can only borrow if you already have some assets. There is much more to compound than what I just said, but for our API, this explanation is enough. Next, let's see what's the architecture of our API. We will interface with compan by building an API that runs on a node JS server. We will be able to hit this API from any client, could be from another server, a browser or a mobile app.
00:02:07.506 - 00:02:54.962, Speaker A: We will send HTP request from the client to our API. Then the API will forward this request to the smart contract of compound on the blockchain by using a JavaScript library called Webstream. Then the smart contract of compound will send a response to the API and will finally be able to send a response to the client. Okay, enough talking. Now we can start the coding and first we need to make sure that you have installed all the tools necessary for our API. We're going to use node JS for our API, so you need to install node JS on your computer. If you don't have it, just go to the website of node JS and install the LTS version which is at V twelve at the moment.
00:02:54.962 - 00:04:00.022, Speaker A: You should also have access to a bash terminal if you are on Linux or macOS, that's already the case, but if you are on Windows, you might want to have a look at Windows subsystem for Linux, or a bash emulation like Ming W 64 which you can get by downloading git for Windows. I'll let you make sure that you have everything installed and after you can move on to the next section where we will create the HTTP server for our API. The basic component of our API is an HTTP server that listen to external requests and expose different endpoints. We can create an HTTP server directly with node JS, but that's easier to use a framework. Exprs is super popular for creating servers, but I don't like that. We cannot use async await easily with Express, so we're going to use another framework called Koa. KoA is a lightweight alternative to exprs that supports async await with a simple API.
00:04:00.022 - 00:04:52.250, Speaker A: So next, go to your terminal and create a folder for the project. And then we're going to initiate an NPM project with NPM init. Yes, so that we don't have to answer any question. Okay, so now we have a package JSON file and we're going to install CoA as well as the router package of CoA software. We're going to create a new file server JS. So first we require the co op framework and we instantiate an app instance. And next we're going to import the co op router.
00:04:52.250 - 00:05:52.634, Speaker A: We also have to instantiate a router instance and we're going to define our first route router get so here you specify the URL of the route. Then you have to give it a callback function. And the first argument of this callback is a context object where you'll be able to access details about the request that was received and you'll also be able to stop the response. So in order to answer then you have to populate the body object inside context. And after that you need to inject this router in the app. So for that you do app use router routes. Finally you start the server with app lesson and you give it the port 3000.
00:05:52.634 - 00:06:22.262, Speaker A: Okay then in package Json we're going to create a command to start the server. So we're going to call this start. And after in another terminal you run NpM start. And if you open another terminal you should be able to test your server. So curl HTP localhost 3000 and I can see my hello world. Cool. This is working.
00:06:22.262 - 00:06:43.514, Speaker A: And for the next step we are going to connect to the Ethereum blockchain. There are different Ethereum networks. The real one that we call main net and other ones that we call testnets. We are going to connect to the main. Net. To connect to main. Net we need an Ethereum node synchronized to Mainnet.
00:06:43.514 - 00:07:38.458, Speaker A: We need more than 135 gigabyte of storage. It can take days to synchronize to Mainnet and it uses a lot of cpu. Clearly that's not just a development tool that you can run in the background of your laptop. To save us the trouble of running our own Ethereum node connected to Mainnet, we can use a service called Infura. Infura runs some Ethereum nodes connected to Mainnet and let us access these nodes. We only need to create an infura account and we'll get an API key and they have a feature which is enough to get started. So we are going to the website of Infira, we create an account and inside your dashboard you go to the Ethereum network and you create a new project and you scroll down and you will see an endpoint for Mainnet.
00:07:38.458 - 00:08:24.880, Speaker A: It's better to keep this URL private, but it's not a disaster if you don't. The worst than people can do with this endpoint is just to use your quota with Inferra. But nobody can do something really bad like forging somebody's signature and stealing your ether. So you copy the URL with HTTPs, you go back to your terminal and we're going to create a file called amp. Let's open this file and we are going to pass our URL. Next we are going to install an NPM package called Don M. This is a package to easily use secrets in your node JS application.
00:08:24.880 - 00:09:09.254, Speaker A: We're going to need that to read the infra URL. It first reads a text file with your secrets and then populates environment variables with these values. By default it reads mtext file, but we still need to tell it when to initialize itself. So open server js and we're going to initialize mv like this. Now we can access the infra URL in process n infra. Next we are going to instantiate a connection to the blockchain with Webstery. Webstery is a library to easily interact with spot contract on Ethereum.
00:09:09.254 - 00:10:23.380, Speaker A: We will need it for interacting with a spot contract of compound. So we're going to create a new file called router JS. That's where we will define all of our endpoints and that's where we will also instantiate web three. So we go in this new file and we require web three and we instantiate it like this by using its constructor and using the infra URL. And we're also going to move the route from server to the router file. So let's go back to server and let's cut this and paste this in router js and we export this back to server JS. Now we're going to import the router and so now we are going to restart the server and see if everything works fine.
00:10:23.380 - 00:11:14.622, Speaker A: And yes, we can still see our hello world. So now the connection to the Ethereum blockchain work and the next step is to create what we call web three contract instances to point to the spot contract of compound. To create a web three contract instance, we need two things. The API or application binary interface. That's a JSON document that describe the interface of the spot contract and the address of the spot contract. We can find these two things in the documentation of compound. So you go to the website of compounds, you go to the documentation inside the networks menu and here you will find the address and the ABI for each spot contract for all the different networks where they deploy their contract.
00:11:14.622 - 00:12:06.040, Speaker A: So we are interested in mainnet spot contract and we're interested in CBAT and CDI. In compound we have one spot contract per ers 20 token that we can borrow. CDAI and CbAT are the contracts for the die and bat tokens respectively. But to make it even more simple for you, I already took the pain of copy pasting the API and addresses inside the repo of etherblocks. So you go to the repo of etherblocks on GitHub inside the folder of this tutorial and you go inside config JSon and you copy everything. Then you go back to your terminal and we're going to create a new file called Config JSON. Then we open this file and we paste everything.
00:12:06.040 - 00:12:52.130, Speaker A: So now we have the address and the ABI. So the ABI for these two token is the same. Let's see, token Abi here. And I also put the ABI of the 20 token because we also going to need it later. So now we're going to the router file and we're going to create these two web three contract instance, one for CDI and one for CBAT. First we're going to import the config then we're going to define our Webster contract instances in an object called c tokens. It's going to have two entry, one for CBAT and another one for CDI.
00:12:52.130 - 00:13:42.638, Speaker A: So we create a new webstery instance. So we create a new webstery contract instance with new Webstery e contract with an uppercase C. And after we're going to pass the ABI and the address. So config C tokenabi config CPAT address. Actually this is almost the same for CDI just here, this is CDI address instead of CBAT. And now we have our two web three contract instance. So we are ready to interact with the compound protocol.
00:13:42.638 - 00:14:21.850, Speaker A: And the next step is to create our first endpoint. For our first endpoint, we will return the token balance for a specific address in compound. In compound, if you want to lend a token, you're going to send your token to a C token contract. For example, if you want to lend Dai, you are going to send your DAi to the CDI contract. If you want to lend bat tokens, you are going to send your bat to the CBAT contract, et cetera. At any time you can know what is your token balance in the C token contract. This will not just give you the amount of tokens you initially sent, but it will also include the interest you earn.
00:14:21.850 - 00:15:05.034, Speaker A: So let's start with this endpoint. So Roger get, then we need to figure out what's the route here. So we're going to call this token balance and it's going to have two parameters. First the name of the C token, so CDI or CbAT, and then the address of the owner, and then we're going to give it an async callback. So we use the async keyword because inside we're going to use the weight keyword. By the way, we can get rid of that endpoint. So first we need to extract the correct web three contract instance.
00:15:05.034 - 00:16:09.806, Speaker A: So let's define C token variable, and here we're going to reference the parameter of the URL with Ctx params Ctoken. So that's something that is given to you by the Coa framework. And it's possible that someone tried to call this endpoint with a c token that we don't have. So we need to check for that. So if type of C token is undefined, that means our endpoint wasn't called properly. Then we're going to return a 400 HTTP response, which means this is an error coming from the client. And then in the body we're going to return a JSON document that says error c token ttx params c token.
00:16:09.806 - 00:17:37.790, Speaker A: So here we use template literal to easily create our string does not exist and return because we want to continue in the callback that was our error case. And after we're going to call the spot control of compound for our balance. So we're going to store the result in token balance and this is an async operation. So we use the await keyword and we reference the C token variable method and the function is balance of underlying and we're going to pass what we got as a parameter in the URL. So Ctx params address and after that we need to execute the call method and then we need to send a JSON response. So we specify what's the c token and then we specify the address and finally the token balance. So here when you want to assign a value with a variable who has the same name as the key, actually you don't need to do that in Javascript.
00:17:37.790 - 00:18:35.866, Speaker A: You can just use this notation and Javascript is going to figure it out. So it's possible that they're going to be a problem with the blockchain when you try to read this value and it might return an error. So we need to wrap this call in a try catch block and if we have an error then we're going to log the error. So in production you probably want to save this error in a log for further analysis. And then for the response the status is 500. It means there was an error in the server, so that's not the client fault and we can send a Json that explained a little bit what happened. Error interner server error okay, so our endpoint is complete.
00:18:35.866 - 00:19:14.814, Speaker A: So we're going to restart the server and try out the endpoint. So we're going to try this endpoint for the DAi token. That means we need to find an address in mainnet that has interacted with the CDI contract of compan. So I've already done the work for you. And so in the repo of etherblocks, in the folder of this project here, I find this address that has some CDI. So I'm going to copy this URL and in my terminal I'm going to try out this command. Yes it works.
00:19:14.814 - 00:19:54.310, Speaker A: So here I can see that there is a token balance. So keep in mind that this is scaled by ten power 18 exactly like for ether. So if you want to have the amount in die, you need to divide this by ten power 18. Okay, so that's great. We created our first endpoint and the next step is to create another endpoint to have the balance in C token this time. So what is this C token thing? So let's take the example of Cdive. So if you have some DAi and you want to lend your Dai to the compound protocol, you send your DAi to the CDI contract.
00:19:54.310 - 00:20:37.734, Speaker A: So your DAi will be locked in the CDI contract and in exchange you will get some CDI tokens. This CDI token represent the DAi that you send to compound. And at any time you can use the CDI to redeem the die that you initially invested plus the interest you earn. So the balance in Dai is a different thing than the balance in CDI. So we're going to build an endpoint for these C tokens. So back to our code and we are going to duplicate the token balance endpoint because the new endpoint is very very similar. So we're going to call this C token balance and it takes the same parameters, the C token and the address.
00:20:37.734 - 00:21:18.438, Speaker A: So first we check if the C token exists. So this is exactly the same. And here this is going to be a little bit different. So here we're going to get the c token balance. We're still going to call the c token contract, but this time we're going to call balance of actually c tokens are es 20 tokens and they respect the interface of Es 20. So they have all the method of es 20 token like balance of transfer, et cetera. So we get our c token balance and we respond by the name of the C token, the address that we are checking the balance for.
00:21:18.438 - 00:21:50.462, Speaker A: And here instead of token balance, it's just going to be a c token balance. And this is exactly the same. So as you can see, very few changes. So now let's make sure that it works. So let's restart the server below. I'm going to check the C token balance of the same address as before, but we need to change here token balance to c token balance. Yes, it works.
00:21:50.462 - 00:22:30.858, Speaker A: We can see some C token balance here. So far I've only showed you endpoints that allow to read value from compound. But what's really interesting is when you can send transaction and actually modify the data of the blockchain. And that's what I'm going to show you in the next part. In this part we're going to create an endpoint to mint new C tokens. For example, in the case of DAi, if you want to invest your DAi in the compound system, when you send your DAi to the CDI contract, this is called minting CDI because in exchange you're going to get some CDI because this is an Ethereum transaction. We need to sign it with our private key.
00:22:30.858 - 00:23:39.810, Speaker A: So for that we need to create an address. And for that I'm going to a website called Vanity eth that allow you to generate an address very easily. So of course I do it like this for the demo. But when you create your own system for production, of course you want to use something a little bit more secure. So I click on generate, click on reveal the private key, go back to my code editor and I'm going to open am where I store my secret. And below the infra URL I'm going to create another secret private key, save this and back to router js and I go to the very top and I'm going to add my private key to Webstery. So Webstery e account wallet add and our private key will be in process amp private key and we also want to extract the address from this private key because we're going to need it to sign our transaction.
00:23:39.810 - 00:24:11.180, Speaker A: We're going to call this admin address. It's going to be Webstery Eth accounts wallet. And here we take the first entry. All right, so now we all set to create our endpoint. So I'm going to copy the first endpoint. It's going to be our template. I'm going to go to the bottom of our code.
00:24:11.180 - 00:24:56.490, Speaker A: Let's paste this, let's paste this. So this time this is not going to be a get route, but this is going to be a post route because with HTTP verb you use get only when you read data and post when you want to modify data. And we're going to call this mint and we're going to keep the c token param. But instead of the address here, this is going to be an amount param. So that's how much c token we want to create. Then this check here is still the same. And after we are going to get the address of the ERC 20 token.
00:24:56.490 - 00:25:56.906, Speaker A: So let's store this in token address and for that we can ask our c token smart contract. And there is a method called underlying and use the call method forgot methods here. And after we want to create a web three contract instance that can point to this yas 20 tokens. First the API of yas 20 token that we have in the config object. And for the address, well we just got it from c token and now we need to approve the c token to spend our token. So for that we use the approve method and we're going to pass it. Two argument.
00:25:56.906 - 00:26:39.594, Speaker A: First, the address that we want to approve. So that's going to be in c token option address. And for the amount we got it as a parameter to the context. And we send this with the send method. And for the sending address, that's going to be the admin address. Now we've done all the prep work and we can finally send our token to the C token contract. So here, let's remove this.
00:26:39.594 - 00:27:31.926, Speaker A: And this time we're going to call mint and we're going to pass it the amount parameter. And this is not a call, but this is send because we send a transaction this time and the sending address is again admin address. So we're going to return the name of C token, then the address that we minted C token for. So that's admin address. And finally the amount that was minted. So this is what we got in the param and for the catch block, this is unchanged. Let me save this and restart the server, make sure that we don't have any error.
00:27:31.926 - 00:28:11.914, Speaker A: Okay, so you'll notice that there is a huge security hole in this endpoint because anybody can call this endpoint and spend all the dai that you have in the admin address and send everything to compound. So it doesn't mean that you lost your dai. You can always get them back because you still own the CDI. But you might not want to invest everything in compound. So you probably need to implement some sort of access control system or maybe that you manage the private keys on behalf of users and instead of using the admin address to execute the mint function, then you use the private key of users. But this is a bit outside the scope of this tutorial. So that's really cool.
00:28:11.914 - 00:29:05.642, Speaker A: We know how to invest our token in compounds, but now we want to do the opposite operation which is to redeem our c token for the original tokens. And that's what we're going to do in the next endpoint. So we're going to create a new endpoint for the redeem operation, which is the country of minting. So you send your C token to compound and in exchange it's going to send you back the underlying token. So if for example you have some CDI and you redeem with CDI, then you're going to get back your DAi. So I'm going to copy paste the endpoint for minting because this is going to be a little bit similar but more simple. So we're going to call this redeem and in accept the same parameters, C token and amount.
00:29:05.642 - 00:29:55.750, Speaker A: So we first check if the c token exists, then we don't need to approve anything here. And then in a try catch block, this time we're going to redeem and we pass the amount that we want to redeem. So this amount is different than the amount of underlying that we use in the mint endpoint. This is the amount of C token that we want to redeem. So for example, if you redeem ten c token, it doesn't mean you're going to get back ten die. It depends on the exchange rate between die and CDAI. And it's also important to understand that you're not going to get just the die that you initially invested, but you're also going to get the interest you earned for lending your die.
00:29:55.750 - 00:30:28.226, Speaker A: And in the response this is not amount mint, but amount redeemed. Okay, so let's restart the API. No error. So this is working great. So now we have four endpoints, two for reading and two for sending transactions. And in the next part we are going to deploy our API to Heroku. Heroku is a platform to very easily deploy your applications.
00:30:28.226 - 00:30:52.346, Speaker A: You can deploy APIs, react applications. This is much more lightweight and simple than something like AWS. And for simple applications this is enough. They have a free chair. However, it gets expensive quite quickly. But for our tutorial it will be perfect. So back in my code editor, I'm going to go in package JSon and I need to add a configuration for Heroku.
00:30:52.346 - 00:31:34.822, Speaker A: So I need to specify what's the version of node JS that I use. So he specified this in the engines property. Specify node twelve point x. Okay, and by default Heroku is going to start the server with the start script. So we have one that's perfect. However, we need to do a small modification in server JS, because we need to bind to the port that is specified by Heroku in process amp port, and to also make it work without local development. We're going to put all condition.
00:31:34.822 - 00:32:06.162, Speaker A: So if we deploy to Heroku, this is going to be defined, and if we just run this locally, this is going to be undefined. So in this case, by default we're going to use port 3000. Next I go back to the command line and I'm going to initialize a git repo because this is the way you deploy it to Heroku. Then we're going to create a git ignore file. We're going to ignore a couple of stuff. So node module. So that's a dependency of NPM.
00:32:06.162 - 00:32:23.580, Speaker A: We don't want to commit this to git. We also don't want to commit our secret. Oops, here there is no s. Let's exit this then. If you do git status, then we don't see any ignore file. So that's okay. So let's add everything.
00:32:23.580 - 00:33:09.318, Speaker A: We call this initial commit and after we are going to log into Heroku. So before you need to create an Heroku account and install the Heroku Cli so you can install it very easily on Os with brew Linux we have another method with snap, and for windows they have an installer. So back in my terminal I'm going to do Heroku logging. Then you're going to see the screen in your browser. So after I'm going to create a new application with Heroku create. Oh damn. I have to delete some of my app because I'm using the free tier.
00:33:09.318 - 00:33:51.650, Speaker A: All right, I've done it. So now I try again. Yes, it works. Next, we need to set environment variables for our secret because we did not commit our secret file amp. So let me open the amp file and first I'm going to copy infra URL. I can create an environment variable with Heroku config column set. Then the name of the environment variables infra URL, then equal then the value that you want to assign.
00:33:51.650 - 00:34:44.802, Speaker A: Okay, and I'm going to do the same thing for the private key. So same command Heroku config set. But this time we're going to call this private key. So finally we are ready to push our application to Heroku with git. Push Heroku master and I'm going to do curl. Then I go to the repo of either blocks and I'm going to copy the pass of the first endpoint here. Damn.
00:34:44.802 - 00:35:23.378, Speaker A: We have an error. Oh, and it seems like I forgot to put web three in package JSon. So let's do this. Okay, so now I should see this in package JSon dependency. Okay, I'm going to commit this change, add web three. And by the way, if you wonder how comes I figure out what was the error, it's because in the dashboard of hello crew, if you click on more you can view the log. And so here I scroll through the log and then I found the error message.
00:35:23.378 - 00:35:56.282, Speaker A: Okay, so I'm going to push everything to heroku again and try our endpoint one last time. Okay, so let's try the endpoint. Yeah, this time it works. I hope you are super happy with what we built. It's pretty cool, but you shouldn't stop here. We can make our API even better. Currently we don't cover all the function of the spat contract of compound.
00:35:56.282 - 00:36:24.820, Speaker A: You could add all the endpoint for the missing functions. You could also add endpoint for other Defi protocols like Uniswap or Maker Dao. And to do that, you need to first have a good understanding of these defi protocols. I actually have a full series on DeFi programming where I explain the main Defi protocols like Uniswap, maker Dao, and more. And if you want to continue your journey in Defi as a blockchain developer, go watch this series. I'll see you there.
