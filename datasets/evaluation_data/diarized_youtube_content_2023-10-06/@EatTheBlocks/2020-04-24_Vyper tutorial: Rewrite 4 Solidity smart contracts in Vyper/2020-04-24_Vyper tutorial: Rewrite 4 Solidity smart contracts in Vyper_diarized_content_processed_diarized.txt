00:00:00.410 - 00:00:42.794, Speaker A: This video is a coding tutorial for Viper. Viper is a programming language for Ethereum smart contract and the way we're gonna learn Viper is by rewriting four smart contract written in solidity, and we're gonna rewrite this smart contract in Viper. If you don't know me, I'm julian, and on my channel eat the blogs, I teach blockchain development. This is not a video for total beginner. I'm going to assume that you already have some basic skills in solidity. If that's not the case, check out this series on solidity. The syntax of Viper is very similar to Python, so if you're already familiar with Python, it's going to help you a lot.
00:00:42.794 - 00:01:41.162, Speaker A: Another thing to know about Viper is that it focuses on security and simplicity, and it makes the code of a Viper smart contract more auditable. Compared to solidity, Viper is not as popular for Ethereum smart contract. However, there are some projects that use it, such as uniswap. Something very important to know about Viper is that it's entirely compatible with the truffle framework, so you can reuse a lot of the tools that you already use for solidity smart contract. All right, so without further ado, we're going to start the coding and for that we're going to use remix, the online IDE for solidity, but it also work with Viper. So you need to click on the Viper button in order to configure remix for Viper. Then you're going to be taken to this page where you need to configure the Viper compiler.
00:01:41.162 - 00:02:11.970, Speaker A: So if you want, you can use a compiler installed locally, but the most simple solution is to use the remote Viper compiler of remix. So that's a bit less secure. But for our tutorial it will be okay. So we're going to choose that option. You'll notice that there is no way to activate autocompile contrary to solidity. So we'll have to manually compile our Viper smart contract every time we finish to write the code. So that's a bit annoying, but there is no other choice.
00:02:11.970 - 00:02:46.654, Speaker A: So let's go to the file Explorer and we're going to create a new file for our first Viper smart contract. So we're going to give it a name. Hello World VI. So Vi is the file extension for Viper smart contract and we're gonna go to this file. So the first thing to notice is that contrary to solidity smart contract for Viper, you only have one smart contract per file. So because of that you don't need to use any contract keyword. We're just going to assume that all the code inside this file belong to a single smart contract.
00:02:46.654 - 00:03:28.122, Speaker A: So let's have a look at the spot contract in solidity, and we'll have to convert this code to Viper here. So here in our solidity smart contract we have a single function hello that just return a static string hello world. So that's going to be easy. So let's go to the spot contract in Viper. First we need to declare the function visibility with this notation. Public function in viper are a bit different than public function in solidity because they can only be called from outside the smart contract in viper. So that's equivalent to external function in solidity.
00:03:28.122 - 00:04:10.982, Speaker A: And in viper we also have private function that can only be called from within the same smart contract. So it's a bit more simple than in solidity you have many different type of function. You have like public, private, internal and external. In viper you just have two public and private. And after in order to indicate that it's readily we're going to use the constant keyword and after to define the function. Like in Python we're going to use the dev keyword, then the name of the function, then parentheses, and then we're going to indicate the return type. So we're going to return a string.
00:04:10.982 - 00:04:45.110, Speaker A: But in viper, contrary to solidity, you cannot have arbitrary size string, but you need to know in advance what will be the size. Just to be safe, we're going to give a size that is a little bit too big for our string. So for example 100 and we terminate the function signature with the column. And you go to the next line and you notice that automatically remix is going to indent your code. So indentation in viper is very important. This is exactly the same as python. It is used to separate the function signature from the function body.
00:04:45.110 - 00:05:30.146, Speaker A: So in order to return something from a function in viper, use the return keyword. And then we use a single quote to specify a literal string. And here we just put our hello world and you notice that we don't terminate our statement with a semicolon contrary to solidity. Again, this is consistent with what we do with Python. Okay, so now I'm going to go inside the compile tab and I'm going to compile my code. So you might need to wait a bit because this needs to do a request on the network. And after, when you see this output here, it means it's been compiled.
00:05:30.146 - 00:05:57.022, Speaker A: And also you see this green checkbox. That means there was no compilation error. And now we're going to go to the deploy tab. And here this is exactly what you do with a serditi smart contract. You click on the deploy button and then you see your contract appearing here. You expand it, and then you can see a button for each function. You click on hello to execute this function, and boom, you see hello world.
00:05:57.022 - 00:06:43.360, Speaker A: So you see, very similar to what we have with solidity. So let's go back to our file explorer, and this time we're going to create our second viper smart contract, simple storage. So let's do this. Simple storage vi vy sorry. Okay, so now let's go in simplestorage saw and see what we have to convert. So first we need to declare a state variable data, and then two function, a function to change its value and a function to get its value. All right, that shouldn't be too difficult.
00:06:43.360 - 00:07:18.886, Speaker A: So let's go in our new file. So first let's define this data variable, then column, then we define the type, and once again we need to define a length. We cannot have an arbitrarily size string in viper. And after that we're going to define the set function. So we make it public like this, then set, then underscore data column. So that's the name of the argument. It's going to be a string of the same length, then column.
00:07:18.886 - 00:07:47.234, Speaker A: Then we're just going to assign the argument, underscore data to the storage variable data. So in order to reference a storage variable data, we do self data. So it's very important here that you use the safe keyword. If you just do data, it's not going to work. Self dot data equals underscore data. Okay, so now we're going to create the second function. So that's a getter function.
00:07:47.234 - 00:08:18.874, Speaker A: So that's going to be a public function and that's read only. So that's constant def. The name of the function is get. There is no argument. It return a string of length 100 column and it return self dot data. Okay, and so now we're going to go to the compiler, let's click on compile, and it's green so it has compile. So we're going to deploy it.
00:08:18.874 - 00:09:02.934, Speaker A: So let me get rid of this. Okay, let's deploy this and we're going to set our variable data to, I don't know, high. Okay, let's set this and after let's get it, and boom, we have a high. It works great. Okay, so let's go to the file explorer and we'll do our next contract. So now next contract is advancetorage sol. So we have an array of integer and we have different function to manipulate this array so we can add to this array, get any element of the array, get all the element of the array and also get the length of the array.
00:09:02.934 - 00:09:45.986, Speaker A: So we're going to convert this to viper. So let's create the viper file advance storage vy. First we're going to create the array of integers, so Ids, then column. Then we're going to use the public keyword to automatically create a get a function. So that will mean that viper will create automatically a function with the same name of the variable that will return the value of the variable. So that's exactly like in solidity. And if you don't use this public keyword, by default the variable will be private, which means you can only access it from inside the smart contract.
00:09:45.986 - 00:10:34.098, Speaker A: Here we give parentheses, and inside the parentheses we're going to define the type. So for integer like in solidity we have u int, so unsigned integer and sign integer with int and also for each of this type then we have different variants. So if you don't specify anything, by default this is going to be a uint or int of 256 bit, but you can specify smaller integer, for example int 128 if you need less space and you want to save some gas. And in order to specify that you want an array here you will use the bracket notation. And in viper there are no dynamic arrays. This is very similar to string, so you also have to specify a size. So that's a bit annoying.
00:10:34.098 - 00:11:18.642, Speaker A: It's a limitation of the language, but they took this decision to make it easier to audit the code. So here we're going to give it an arbitrary size of 100 element, for example. And we're also going to create another variable called it index to track the length of the array. So in solidity this is easy, you can just do array length and you have the length, but this is not the case in Viper. So let's create this and it's going to be integer 128. So first we're going to create the function to add an element to this array. So is this going to be public? And we're going to call this add and we name our argument.
00:11:18.642 - 00:12:04.034, Speaker A: ID type is integer 128. So we're going to reference the IDs array. And there are no push method in Viper because it doesn't have dynamic array, but instead you have to reference directly at the location that you want to access. So here we're going to reference the last index of the array. So that's ID index, self dot ID index and we assign what we got as argument. And then we also need to increment the ID index so that the next time that we call the add function we don't override the previous entry. By the way, we cannot call this add.
00:12:04.034 - 00:12:28.522, Speaker A: That's one of the reserve keyword in Viper. So let's change this to add element. Then we're going to create a getter function to return a specific element of the array. So we make it public constant. Then we call this get. Then we specify the index that we want to get. So that's an integer 128.
00:12:28.522 - 00:12:58.994, Speaker A: It's going to return an integer 128. And here this is quite simple. Release return keyword, return IDs. And here we reference the element we want. We need the self keyword here. After we're going to create a function to return the whole array. So we're going to call this get all, doesn't take any argument and it returns an array.
00:12:58.994 - 00:13:41.330, Speaker A: So we specify the array type like this and an array of 100 element. Here we return self dot IDs. And finally we're going to create a function to return the length of the array. So that's going to be a function called index. Doesn't take any argument. It returned an integer and it returned self dot ID index. Okay, so now we're going to go to the compile tab and we're going to compile this smart contract.
00:13:41.330 - 00:14:01.722, Speaker A: And the compilation was successful. So now we're going to deploy it. So let's get rid of the previous one. Let's deploy it. Okay, so let's add an element. So for example ten, let's add another 120. So if I get the first element, I should get ten.
00:14:01.722 - 00:14:28.900, Speaker A: If I get the element, after I get 20, okay, then get all. Yeah, so here we can see our array 1020 and then a series of zero. So total we have 100 element. And if we want to know what's the index of the, sorry, what's the length of the array? Actually I should have called this length, not index. So here we can see that this is two. Yeah, let me rename this to length. It makes more sense.
00:14:28.900 - 00:15:09.754, Speaker A: Okay, so our smart contracts works well. And so now we're going to create our last smart contract, crude sol. So let's see the solidity contract. So here we define a struct in solidity with two member ID and name. Then we have an array of user struct and we have a couple of function to manipulate this collection of user so we can create a new user, read a user, update a user and destroy a user. And here we also have an internal helper function. So we're going to rewrite this in viper.
00:15:09.754 - 00:16:25.414, Speaker A: So let's create this smart contract crude vy. So in viper like in solidity you can define struct if you want to define custom data structure. And for that you use the struct keyword. Then you define the name of your struct. Then you use colon and you define each field of your struct. So we define name of the field, then the type of the field after we have the name field and that's a string, so we're going to give it a length of 100, and after that we'll have an array of users. So first we're going to define the name of our array, then we make it public, and then we specify that this is an array of user like this, so name of the struct, then square brackets, then you need to specify the length of the array and we also need to specify a variable to hold the next Id, so that when we add an entry to this user's array then we know which id to use for this truck here.
00:16:25.414 - 00:17:17.298, Speaker A: So next Id, and this is going to be an integer 128. And after we're going to create a function to create new user struct. So this is going to be a public function, we call it create user and it's going to take a single argument which is the name of the user and the length is 100. So first we need to check that the name provided is not empty. So in solidity you can use require statement for that. So you test the condition, and if the condition isn't true solidity, throw an error and the whole transaction is reverted. But in viper we don't have required, but instead we have assert statement.
00:17:17.298 - 00:18:13.270, Speaker A: So it works like this. Use the asset keyword, then you specify what you want to be tested. So there is a built in function called Len for length that can give you the length of an array. So we pass it the argument and we just want this to be different from zero. And after that we can add our users struct. So we reference the user's array at the correct position. So we have this with self next id, and we create a new struct like this parentheses, and after we use the curly braces and we're going to pass the two parameter like this next id, that's self next id, and for the name that's the name argument.
00:18:13.270 - 00:19:04.966, Speaker A: And after that we still need to increment the next id variable. So that the next time we call this create user function, we don't overwrite the user we already created. So for that it's very easy, self next id, and we can use the increment operator exactly like in solidity. Next we're going to create a function to read a specific user. So this is going to be public and read only. So we make it constant, we call it read. And it's going to take a single argument that's the ID of the user and it's not going to return the struct directly because this is not possible to do this in viper contrary to solidity, but instead it's going to return a tuple of the individual field of the struct.
00:19:04.966 - 00:19:41.990, Speaker A: So the id field and a name field. So we specify this between parentheses, integer 128, and then string 100. Okay, and so first we're going to run an assertion. We want to make sure that this user actually exists. So that means the id needs to be strictly inferred to the next id variable. So let's do this. Self next id and after that we can use the return statement and we're going to return a tuple of two variable like this.
00:19:41.990 - 00:20:18.846, Speaker A: So self dot users here reference the id id and then the name field and we're good for this function. Then we're going to create a function to update a user. So that's going to be a public function. We call it update. It's going to take two argument, the id of the user and then the new name of the user. So that's a string. So first we want to make sure that the user exists.
00:20:18.846 - 00:21:09.554, Speaker A: So here id needs to be inferred to self nextid, and after that we can do the updateself users user id name equal name. And next we're going to create a function to destroy a specific user. So let's call this destroy. It takes a single argument, the id of the user. And first we need to make sure that this user exists. And then, so it would be a little bit complicated to remove the user totally from the array. So we're going to make it simple and we're just going to set the name to nothing.
00:21:09.554 - 00:21:54.450, Speaker A: So self users name equal nothing but that actually break our two function here because for example, it's possible to call the update function on a user that has been destroyed before. So we need an additional check. In this assert we're going to check that the name is not nothing. So user id name needs to be different, the length of this needs to be different from zero and we're going to add this also here. Okay, so now let's go to the compile tab. Let's try to compile it. And yes, it works.
00:21:54.450 - 00:22:28.970, Speaker A: Okay, so now we're going to try to deploy it. So let's deploy that and we're going to create a user, let's call it, I don't know, James, create this user. Then I'm going to try to read the user gems. So yes, zero, this is gems. Okay, I'm going to update the name of James. So for example, James is actually, I don't know, James Green. Let's update now let's read James again.
00:22:28.970 - 00:22:57.994, Speaker A: And now is James Green. And now let's try to destroy gems. So destroy this. Okay, now if I try to read James then I can see that the string of the name is null. So everything worked fine. So one thing that I forgot to tell you in this tutorial is that when you use the remote compiler of remix, if there is a compilation error. So here you're going to see a red cross.
00:22:57.994 - 00:23:32.490, Speaker A: For example here let's do a compilation error just to show you how it works. So you see this, but it doesn't show you the error message anywhere. So that's not very convenient to debug this. So if you use a local compiler, I haven't used it, but probably that you can see the error message on your local console. So that's probably a better way to do it. But just if you want to try out Viper quickly then the remote compiler is enough. So everything I show you is a subset of everything you can do with the Viper language.
00:23:32.490 - 00:24:04.200, Speaker A: So you can check out the official documentation at this address. And if you want to develop a full decentralized application then you can use the truffle framework. You just need to do a small configuration and you can use Viper. This is not very complicated. This being said, keep in mind that Viper is really not the standard for developing smart contract. This is a little bit more experimental than solidity, so it's interesting for your own knowledge to learn it. But for production project I'm not sure I would use it myself.
00:24:04.200 - 00:24:16.940, Speaker A: And if you want to keep learning about solidity, so the main programming language for smart contract, I actually have a full series on it, so check it out and I'll see you there.
