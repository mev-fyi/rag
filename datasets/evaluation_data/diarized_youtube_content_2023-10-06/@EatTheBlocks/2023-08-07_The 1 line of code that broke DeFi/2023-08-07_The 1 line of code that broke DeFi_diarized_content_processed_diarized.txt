00:00:00.250 - 00:00:24.978, Speaker A: It was impossible, but it still happened. A hack of $50 million because of an extremely rare bug. In this video, I'm going to explain the bug, how it was exploited by hackers, and how it puts at risk the entire crypto ecosystem. On July 30, weird activities were detected on Ethereum. And no, it wasn't aliens or ufos. Curve, a leading decentralized exchange, was hacked. 50 million suddenly disappeared.
00:00:24.978 - 00:00:57.850, Speaker A: It what happened? Let's take it one step at a time. First, let's focus on curve. Curve is a crypto app to trade tokens in a decentralized way on the blockchain. It's one of the most trusted decentralized exchange, and that's because it uses a special programming language called Viper. Viper was specifically designed to prevent security bugs. In the past, billions of dollars were stolen from crypto projects. That's why in crypto, security is a really big deal, and Viper is considered one of the safest programming language for smart contracts.
00:00:57.850 - 00:01:38.102, Speaker A: Smart contracts, these are the small programs that run on a blockchain. This is where crypto apps put their most sensitive code, like curve. So if Curve used Viper for its smart contract, we shouldn't have any security vulnerabilities, right? It's not as simple. Viper only helps you to write saved smart contract code, but it doesn't provide any guarantee. For example, if you didn't take my two smart contract security courses, you probably suck at smart contract programming and you will have bugs in your code. But that's not a topic of today, because, you see, there was no problem with the code of the smart contract of curve. So how the hell curve was hacked, it happened because of the very rare bug.
00:01:38.102 - 00:02:18.598, Speaker A: And to understand this bug, you need to understand how Viper is executed. The Ethereum virtual machine, or just EVM, is where smart contracts are executed, and it doesn't understand Viper. Surprising, right? The EVM only understands some basic instruction called EVM opcodes. So before deploying a Viper smart contract, you need to transform the viper code into EVM opcodes. And you do this by using the viper compiler. You can see the compiler as a translator, and the viper compiler is itself a program coded in python. But what if there was a bug in the compiler? That would mean that the evm code generated doesn't match the viper code.
00:02:18.598 - 00:02:36.010, Speaker A: This could be extremely dangerous. This is why the code of a compiler is critical. It has to be 100% right. And most of the time it is. People who write compilers are very smart, like me. But in some rare cases, some bugs slips through. And unfortunately this happened to viper.
00:02:36.010 - 00:02:55.790, Speaker A: This is the buggy code. To understand the problem, we need to understand reentrancy attacks. Let's take an example with a victim and an attacker. Smart contract. The victim smart contract is a wallet that keeps some ether for different addresses. There is a function to allow the owners to withdraw their ether. First, we check that the owner has enough ether.
00:02:55.790 - 00:03:42.670, Speaker A: Then we send the ether. Then we decrease the ether balance so it doesn't look like there is any problem, right? Wrong. There is a big problem. When we send the ether to another address, this other address can be another smart contract. And this other smart contract can react to the incoming transfer with a special function called fallback. This fallback function can call the reservoir function again. But at this point of the execution, even though the ether was set, we haven't decreased the balance yet, which means this check is going to pass, which means we can transfer ether a second time, even though our balance might already be zero, which take you to the fallback function again, and we can continue this cycle a couple of times until the victim's smart contract is completely drained.
00:03:42.670 - 00:04:00.482, Speaker A: Any function that send ether to another address is vulnerable. I know the first time I heard about this, it blew my mind. It's basically like abusing recursion. And it's not just theoretical. Tons of hacks happen because of this problem. The solution, reentrancy gods. With reentrancy gods, you define a boolean variable.
00:04:00.482 - 00:04:26.498, Speaker A: At the smart contract level, the lock. This lock will be equal to true during the whole execution of the vulnerable function. In the vulnerable function, you first make sure that the lock is not activated. Then you activate the lock. Then the rest of the function executes, including the ether transfer, and at the end, you deactivate the lock. If an attacker tries to do a reentrancy attack, it's not going to work because of this required statement. So we are safe, right? Not so fast.
00:04:26.498 - 00:04:52.442, Speaker A: Okay, so now you know what is a reentrancy attack and how to avoid them with reentrancy gods. But how does this relate to viper? Good question. A critical bug was found in the reentrancy God of Viper. So here's how it's supposed to work to make your life easier. Viper has a built in way to create reentrancy guards. To create a reentrancy guard with viper, all you have to do is use an annotation next to a function and give it a name. Very easy.
00:04:52.442 - 00:05:29.810, Speaker A: And you can also reuse the same reentrancy guard in another function. So with this, you can get protected against complex reentrancy attacks where the reentrance call is in another function. Yes, this is getting complex, but we have to do whatever it takes to avoid hacks. So now we are finally ready to explain the critical bug that was found in Viper. This is the code of the viper compiler that implements the reentrancy guard. So what's wrong here? In this for loop, we iterate over all the reentrancy guard annotations. For each annotation, we create a reentrancy guard with its own log variable, and we store the log variables in the storage of the smart contract.
00:05:29.810 - 00:06:07.150, Speaker A: And to avoid overriding the same lock, we increment the storage location. For each new reentrancy guard. The storage slot zero will have the first reentrancy guard, then storage slot one will have the second one, et cetera. But what if we use the same reentrancy God in two different functions? In this case, what was meant to be the same reentrancy God will occupy two different storage slots, which means it's actually two different reentrancy guards. And this introduces a huge security vulnerability. If a hacker figures this out, they can do a lot of damage. And what is really frustrating is that we almost avoided the disaster.
00:06:07.150 - 00:06:37.798, Speaker A: This bug was discovered and fixed by the team of Viper. The fix was pretty simple. They just had to modify the logic of the increment for the storage slot. But unfortunately, when it was fixed, another mistake was made. At that time, the team of Viper didn't realize the severity of the bug. It wrongly categorized the bug as semantic, meaning something not very important, which means that the crypto project that used the buggy version of Viper didn't realize the problem either. And one of this project was curve finance.
00:06:37.798 - 00:06:58.782, Speaker A: Curve is a decentralized exchange. You can use it to trade tokens on the Ethereum blockchain. Curve is huge. At the time of this recording, it was the 7th biggest project on Ethereum, with $2.2 billion of total value locked on. Curve trading is organized by liquidity pools. There is one liquidity pool per pair of assets.
00:06:58.782 - 00:07:33.978, Speaker A: So for example, the ETH USDT pool is the pool where you can buy or sell ether against tether. For a long time, Curve worked pretty well. And because it's a big project with a lot of money, it's a honeypot for hackers. Many hackers tried to find a vulnerability, but they didn't find anything. The vulnerability was hidden deep inside the code of viper, and it was just a matter of time before someone poked their nose there. On July 30, 2023, a hacker managed to hack curve after uncovering the bug of viper. What happened? The liquidity pool that was attacked was pe is a derivative of ether.
00:07:33.978 - 00:07:52.926, Speaker A: Its price is supposed to follow closely the price of ether. First, the hacker deployed their smart contract. This is used to coordinate the attack. Then the hacker started the attack. First, they borrowed a lot of money from another smart contract using a flash loan. With a flash loan, you can borrow money on the blockchain. No collateral or application form is required.
00:07:52.926 - 00:08:09.250, Speaker A: Everybody can get a flash loan, even your grandma. It works with code only. No humans are involved. But don't get any ideas. It's completely impossible to not reimburse a flash loan. You borrow and reimburse the money in the same transaction. And if you don't do it, the whole operation is canceled.
00:08:09.250 - 00:08:29.022, Speaker A: And there is no concept of loan duration. Everything is instant. The technical term for that is atomic transaction. And no, it's not radioactive. So what's the use of this? It's used mainly for arbitrage and also for hacks. So back to Ashkeema. The attacker took the flashlone money and sent half of it to curve by calling the add liquidity function.
00:08:29.022 - 00:08:54.658, Speaker A: And in return, it received some liquidity provider tokens. Liquidity provider, another concept to learn. But don't worry, it's very simple. A liquidity provider is someone that provides capital to a decentralized exchange. This allows traders to use this liquidity to buy and sell tokens, and in exchange, the liquidity provider earns trading fees. But our attacker wasn't interested in that. They had bigger ambitions.
00:08:54.658 - 00:09:24.250, Speaker A: After the call to add liquidity, the next step was to call the remove liquidity function. The remove liquidity function does the contrary of add liquidity. You send your lp tokens and in return you get back your initial liquidity. But what's the point of calling successively add liquidity and remove liquidity? It seems like we are going full circle, right? In theory, yes. But because of the bug of viper, this sequence has a vulnerability. This is the code of the remove liquidity function. It shares the same reentrancy guard as add liquidity.
00:09:24.250 - 00:10:04.910, Speaker A: And in the body of remove liquidity, at some point it sends the ether back to the calling address, which is the smart contract of the attacker. Remember I told you before that in a smart contract, whenever we send ether to an address, we are at risk of a reentrancy attack. And normally we are protected against this with a reentrancy guard. But because of the viper bug, the reentrancy guard will only work in the remove liquidity function. There is no synchronization with the reentrancy guard of the add liquidity function, so we can still do a reentrancy attack on add liquidity. And this is exactly what the attacker did. After the money was received, a reentrant attack was triggered on the add liquidity function.
00:10:04.910 - 00:10:38.386, Speaker A: And in this call, the remaining flash loan money was sent. And once the call to add liquidity completed, the execution resumed at the remove liquidity function. Whoa, that's crazy. So we had this call to remove liquidity that was interrupted by the call to add liquidity, and then resume to remove liquidity, and it somehow made money for the hacker. Why is that? Here's the problem. When you call the add liquidity function, it will give you some liquidity provider tokens, or just LP tokens. The number of LP tokens that is given to you depends on several factors.
00:10:38.386 - 00:11:22.898, Speaker A: How much money you provide, and the relative reserve of the two assets of the liquidity pool. But when the hacker did the rengency attack on add liquidity, the smart contract was in an inconsistent state. Remember, just before remove liquidity started but didn't finish? And because of that, the attacker was given too many LP tokens in add liquidity. Which means that later, when the attacker called remove liquidity again, they got back more liquidity than what they were supposed to get. Okay, so I know that's a lot to take in, but we are almost done. The two remove liquidity call returned not only east, but also PE. The PE was sold into east, and with all the east remaining, it was enough to repay the flash loan and also to keep a nice profit.
00:11:22.898 - 00:11:57.038, Speaker A: In the end, the attacker repeated the same attack on several liquidity pools of curve by reusing the same vulnerability. In total, $50 million was stolen from curve. But the damage didn't stop there. This hack also tanked the governance token of curve CRV. This in turn propagated to Ave, which is another big crypto project. And that's because the founder of curve took a huge loan of 100 million dollar on Ave by using CRV as a collateral. And with the collapse of CRV, this loan could get underwater and threaten the whole ave ecosystem.
00:11:57.038 - 00:12:32.346, Speaker A: And for your information, the loan was used for a giant mansion, coke and hookers. Thanks God, at least the money was well spent. Okay, but is it the end of it? Almost the same Viper vulnerability was exploded on other protocols and other blockchains. So it was really a shock to the whole crypto community, because Viper was considered a very safe smart contract language. And the big question is, who is to blame? First of all, you have to realize that it must have been very difficult to find this bug. The hacker must have spent a lot of time on this. It might even be a whole team.
00:12:32.346 - 00:13:17.106, Speaker A: And second, while it's tempting to blame the Viper developers, keep in mind that it's very difficult to build a compiler. There are very few developers in role that can do that, and even supercoders can make mistakes. The real question is, is there enough money that goes into auditing smart contract languages? Lot of money goes into smart contract auditing, which is good, but all of this is useless if the foundation is shaky. In any case, smart contract code is very sensitive and this is why there is such a high demand for smart contract developers. And yes, even during the bear market there is still a demand for smart contract devs. As long as you are competent, of course. And if you want to learn how you can become a smart contract developer and get your first job, check out my free masterclass.
00:13:17.106 - 00:13:19.410, Speaker A: The link is down below. Thanks for watching. Bye.
