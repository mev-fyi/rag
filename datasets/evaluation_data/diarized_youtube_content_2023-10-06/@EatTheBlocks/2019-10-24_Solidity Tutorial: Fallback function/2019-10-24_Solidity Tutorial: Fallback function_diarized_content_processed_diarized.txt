00:00:00.250 - 00:00:29.894, Speaker A: Hey, hey, this is julian, and you are on idoblox. In this video I'm going to explain you what is a fallback function in solidity. Two main use cases for fallback function. First, it's to receive some ether, so you can send some ether to a smart contract without specifying any function. And the second use case is the fallback. So if you try to call a function that does not exist, then the fallback function is going to be triggered. So these are the two main use cases for this fallback function.
00:00:29.894 - 00:01:01.450, Speaker A: So now let's see how we can declare a fallback function. So here I have my smart contract. And to declare my fallback function, all I have to do is to use the function keyword, specify the external keyword, open curly braces, and that's it. I have my fallback function. So what are the differences with regular function? So, first, a fallback function does not have any name. I just use the function keyword, and then that's it. Second, you can only have one fallback function in a smart contract.
00:01:01.450 - 00:01:29.254, Speaker A: So here if you try to define another fallback function, three dt is not going to like it. Then you cannot have any argument in the fallback function. Here, if I try to define an argument again, three dt is not happy. This does not mean that you cannot pass any data to a fallback function. Actually, I'm going to show you this just after. Another difference is that the only visibility allowed is external. So these are the main differences with regular function.
00:01:29.254 - 00:02:06.302, Speaker A: So now let's see how we can send some data to a fallback function. So I just told you before that we cannot accept argument in its fallback function. But it's still possible to access some data sent to this function by using the msg databuilting variable. The type of this data is bytes. So you probably need to use what we call assembly in order to pass this data into solidity. Type like u in Boolean, et cetera. So I'll show you in the next video what is assembly actually? All right, so next, let's see how we can send some ether.
00:02:06.302 - 00:02:32.930, Speaker A: So, actually sending some ether to a fallback function is its most common use. So it's very important to understand this. So in order to accept ether, all we need to do is to add the payable keyword to our fallback function. That's it. Next, there is what we call a gas stipend. So as I mentioned a couple of times, I will explain in detail what is gas in another series. But basically it's something that you have to spend when you call function in smart contract.
00:02:32.930 - 00:03:30.510, Speaker A: And if you call this fallback function from another smart contract, then in some cases you have a restriction on the number of gas that you can spend into it. So in another smart contract, if you call this fallback function by sending ether with the transfer method or the send method, then the gas limit in this case is 2300. This restriction only applies when you call a fallback function from a smart contract using one of these two method. Next, let's see how we can reject incoming calls. So it's possible that you want to define a fallback function but still reject the incoming calls in certain case. So if you want to reject all incoming calls, then you're going to revert like this and nobody can call your fallback function successfully. Now, if you want to be more selective, for example, you only want to reject calls if we send some data, for example.
00:03:30.510 - 00:04:33.902, Speaker A: So in this case you can do if msg data length superior to zero, then revert. And if you want to reject ether transfer, then all you have to do is just to remove the payable keyword and nobody can send ether to your fallback function. All right, so now let's see a couple of practical examples. So I'm going to define another smart contract b, and I'm going to call the fallback function in different way. So first let's see how does it work when we call a function that does not exist. So we're going to create a function here, and I'm going to create a smart contract a. So new a, and then how can I call a function that does not exist? Because if I try to do something like this function that does not exist, then solidity will not even let me compile the smart contract.
00:04:33.902 - 00:05:15.774, Speaker A: But actually it's still possible to call this function that does not exist. For example, interface a. And I define a function that does not exist. Does not exist. Okay, so I only define the function signature here, and then I'm going to use this interface. So interface a and I cast my a pointer into an address, and then I'll be able to call my does not exist function does not exist. So I will be calling the address of the smart contract a, but with a wrong interface.
00:05:15.774 - 00:05:56.538, Speaker A: And so I'm going to call this method. Then actually this fallback function is going to be executed then another way is to send ether from a regular address. So here in remix, if I try to deploy the s smart contract, then I can see that I have my fallback function represented like this. So if I wanted to send ether, then here I would put some value and I will click on fallback. And finally I can also send ether from a smart contract. So inside our smart contract b, first we need to cast the a pointer into a payable address. So address payable.
00:05:56.538 - 00:06:41.020, Speaker A: And here I'm going to use some trick in order to cast our address to an address payable. So what you need to do is to first you cast the initial pointer into an address, then you turn it into uint 160 because there is 160 bit in an address. And then you recast it again in an address, but this time you define an address payable. So a payable. And when you do all this magic, you're going to be able to cast your initial contract pointer to an address payable. By the way, this does not work. If you try to do something like this address of a, this does not work.
00:06:41.020 - 00:07:13.060, Speaker A: So if I have my a payable here, then what I could do is to execute the transfer method and send some ether. And in this case here, the fallback function will be executed. All right, that was it for this video. If you want to receive even more tips for solidity, then check out this mini course that I've prepared. Link in the description encryption and in the next video I'm going to explain you what is assembly in solidity. Thanks for watching, see you next time.
