00:00:00.330 - 00:00:02.606, Speaker A: Ethereum is a great project, but currently.
00:00:02.708 - 00:00:04.826, Speaker B: Transaction fees are very expensive.
00:00:04.938 - 00:00:11.002, Speaker A: There are many alternative blockchains with lower transaction fees. One of these blockchain is Polygon.
00:00:11.066 - 00:00:13.902, Speaker B: Polygon uses the same development tools as.
00:00:13.956 - 00:00:16.906, Speaker A: Ethereum like solidity, web three, etc.
00:00:17.018 - 00:00:20.974, Speaker B: And on top of it it's connected to the Ethereum network, which means you.
00:00:21.012 - 00:00:26.166, Speaker A: Still benefit from the network. Effect of Ethereum is getting a lot.
00:00:26.188 - 00:00:27.718, Speaker B: Of traction and if you are a.
00:00:27.724 - 00:00:30.758, Speaker A: Blockchain developer, you need to understand how it works.
00:00:30.844 - 00:00:33.062, Speaker B: This video is a full course on.
00:00:33.116 - 00:00:34.834, Speaker A: Polygon if you don't know me, I'm.
00:00:34.882 - 00:00:38.866, Speaker B: Julian and on eitherblocks I teach blockchain development.
00:00:38.978 - 00:00:54.890, Speaker A: In the first part of this course you will learn about the Polygon ecosystem. Then you will learn Matic Js, the Javascript library of Polygon that makes it easy to interact with the Polygon network. Then you will learn how to move tokens between Ethereum and Polygon by using a token bridge.
00:00:54.970 - 00:00:56.542, Speaker B: Then you will learn how to create.
00:00:56.596 - 00:01:07.138, Speaker A: And deploy a smart contract on polygon. After that you will learn how to send transactions without paying for gas by using metatransaction. And finally you will learn how to.
00:01:07.144 - 00:01:10.994, Speaker B: Use Chainlink oracles on Polygon to access off chain data.
00:01:11.112 - 00:01:20.850, Speaker A: For this course we have selected two amazing instructors. First there is droving Parik, an expert in Polygon who already taught a course on edoblox.
00:01:20.930 - 00:01:26.034, Speaker B: And after we have Patrick Collins, a developer advocate who works at Chainlink.
00:01:26.082 - 00:01:37.660, Speaker A: Quick note, if you want to test your knowledge with Q a test, you can also watch this course on the edoblox Academy. This course is free, you just need to register. I put the link in the description. Let's get started.
00:01:41.890 - 00:03:00.326, Speaker B: Hello and welcome to the Polygon course developed by eat the blocks. My name is Dhruvin Parikh and I am going to be your instructor for this course. So today we will be covering the most exciting and innovative platform that is used for building the blockchain applications, which is the Polygon blockchain. And you know that blockchain technology is post revolutionalize, the way the digital world handles data and does the business. So in this course you will be enabled to be the part of this revolution and you will get a head start with the decentralized application development on the polygon. So this course is going to act as a guide into the polygon ecosystem and you will find lots of useful contents throughout this course. You will find lot of useful resources in this course which will be enough to get you started building applications on polygon and particularly blockchain in general.
00:03:00.326 - 00:04:43.830, Speaker B: So the topic for this particular lesson includes the Polygon's hybrid security model, polygon blockchain Explorer and the Polygon gas station. So we will be starting this lesson with the very first topic, which is Polygon's hybrid security model, which is a combination of proof of stake, which is popularly known as PoS, as well as plasma. So we will be looking into the basics of polygon network, which includes the Polygon architecture and its security models. So polygon brings you a trustless two way transaction channel between polygon and the Ethereum by introducing a cross chain bridge, right, with plasma and PoS security. So using this bridge, the user can transfer the tokens across polygon without incurring third party risk and market liquidity limitations. And for your information, plasma and PoS bridge both are available on Mainnet as well as Testnet of the polygon. The testnet of the polygon is popularly known as the Mumbai Testnet and Polygon Mainnet is known by its same name as the Polygon Mainnet.
00:04:43.830 - 00:06:13.780, Speaker B: So why are we meeting today? Why do we need to learn polygon? The reason is the Polygon bridge provides a scaling solution which is nearly instant low cost and it's quite flexible. Right? And the fact that Polygon uses the dual consensus architecture which we talked in the previous slide, which is a combination of plasma and proof of state platform that basically optimizes the speed as well as decentralization. Right? So the architecture of the polygon system is developed to support arbitrary state transitions on the side change. And the good news are the polygon ecosystem or the polygon chain is EVM enabled chain. Right. Another fact to know is there is not going to be any change to the circulating supply of the token when it is going to cross the bridge, right? Which means that the token that leave the ethereum network are locked and the same number of tokens will be minted on the polygon. As the bagging of the token is one is to one.
00:06:13.780 - 00:07:56.838, Speaker B: So to move the tokens back to the ethereum network, the tokens will be burned on the Polygon network and unlock on the Ethereum network during the process. Right? And we will be talking this process in depth in a bit. So what is the difference between proof of stake and a plasma? So if we talk about proof of stake to describe, in short, about the proof of stake, a depth developer who is looking for flexibility and faster withdrawals, proof of stake is an option. And a debt developer who is looking for increased security with the guarantees is going to opt for plasma exit mechanism. So polygon has basically extracted the salient features of both Pos as well as plasma to create its own dual consensus architecture, to create its consensus layer, which they call it as dual consensus architecture. Right? There are some trade offs when you deposit Ethereum from Ethereum mainnet to polygon, which is known as Ethereum to Matic, just to let you know that polygon was previously known as Matic network, and now it is known as polygon. Right? So the deposit of assets, for example, from ether to Matic, takes like three to five minutes.
00:07:56.838 - 00:10:24.590, Speaker B: However, if you want to withdraw the assets from matic back into the Ethereum main net, then that is a whole process that involves checkpoints and it has got its own procedure, which we will be taking a look in coming slides. Right? So as far as the security of proof of stake system goes, the security is basically provided by the external validators in proof of work chains like Ethereum, we call this validators as miners, because they have to basically do the work in order to validate a block, which is a group of transactions before it is brought to the main chain. Whereas in proof of stake, it basically validates a particular transaction and hence those are termed as validators. Right, and what is plasma in terms of security? Basically, they have got plasma contract which are deployed on the Ethereum network, and that's how the security is being provided. The asset standards which are supported by proof of stake, includes all the popular token standards like ERC 20, which is a fungible token standard, ERC 721, which is a non fungible token standard, ERC 1155, which is multitoken standard, and of course ETH. However, in the plasma bridge, as of now, the standards which are supported includes ETH, ERC 20, fungible token standard, and ERC 721, non fungible token standard. Right? So let's do a deep dive into the Polygon architecture, right? So, Polygon network, as you know that it's a blockchain application platform that basically provides hybrid proof of stake and plasma enabled side chains.
00:10:24.590 - 00:12:09.734, Speaker B: Having said that, the beauty of polygon is in its elegant design, which features a generic validation layer which is separated from varying execution environments like plasma enabled chains, full blown EVM side chains. And in the future, there will be other layer, two approaches, such as optimistic roll ups, which is being promised by the Polygon team. As of now, like, as I'm saying, the developers can use the plasma for specific state transitions for which the plasma predicates have been written. For assets like ERC 20, ERC 721, there are predicates which are being written for asset swaps and other custom predicates are there, which are available on the Polygon documentation. So for arbitrary state transitions they can use proof of stake or both, which has made Polygon's hybrid construction a reality. So in order to enable the proof of stake mechanism on polygon's platform, there is a set of staking management contracts deployed on Ethereum, as well as there is a set of incentivized validators running Hemdale and Boronotes. We will be talking about Hemdell and Bohrnodes in a bit.
00:12:09.734 - 00:13:29.946, Speaker B: So we know that Ethereum is going to be the first base chain which is supported by Polygon. However, Polygon also intends to offer the support for additional base chains which comes from the community contribution and community suggestions and of course according to the consensus of the community, so that polygon could be a medium for interoperable decentralized layer to blockchain platforms. Having said that, the Polygon architecture is a three layered architecture which includes staking and plasma smart contracts. On Ethereum, the proof of stake layer is known as Hamdell and the block producer layer, which is the actual polygon chain, previously known as Matic chain, is the bohr. Right? And that is what is also known as a side chain. Right. So let's talk about all the three layers in depth.
00:13:29.946 - 00:15:46.294, Speaker B: So as you can see in this architecture, the main net is the Ethereum where the polygon smart contracts are deployed, right? Which means that the polygon is going to maintain a set of smart contracts on Ethereum and that are going to in turn handle the staking management for this layer, which is the proof of stake layer. Then the delegation management which includes the validator shares and the plasma contracts, that includes the checkpoints and the snapshots of the side chain state, right? Which means that if you are doing a transaction on the Matic or on the polygon side chain every 20 minutes or every 3 hours or every x amount of time, there is a state sync mechanism that basically does a snapshotting to the Ethereum main net via a proof of stake layer. And this proof of stake layer is basically run by a group of validators. And that proof of stake validation layer is what we call it as Hemdell, which we looked into the previous slide. Okay, so Hemdell is nothing but a proof of stake validation node which works in consonance with the staking contracts on Ethereum to enable the proof of stake mechanism on polygon. So polygon have already implemented this on the top of tendermint consensus engine and that changes the signature scheme and various data structures. And that is responsible for the block validation, block producer committee selection, also checkpointing, representation of the side chain, I mean the blocks of the side chain through the ethereum in the architecture.
00:15:46.294 - 00:17:38.430, Speaker B: And there are various other responsibilities that are held with Hemdel, which means that the Hemdel layer is going to handle the aggregation of the blocks produced by the Bohr into a Merkel tree and then publishing the Merkel root periodically to the root chain, which is the Ethereum mainnet. So this periodic publishing are nothing but the checkpoints, right? For every few blocks on a board, like a validator is going to validate all the blocks since the last checkpoint, it is also going to create a merkle tree of the block hashes and it is going to publish the Merkel root to the main chain. There are some reasons where these checkpoints are important, right? Because it provides a finality to the root chain and also it provides a proof of burn in withdrawal of the assets. Now, when we will be talking about proof of stake breach, we will be taking a look into the process of depositing and withdrawal. That's when we will get to know about why do we need to have a proof of burn while withdrawing the assets. So in a nutshell, the process is something like you can think of a subset of active validators from a pool are selected which are going to act as block producers for a span, right? The selection of each span will also be consented by at least two third in power. And these block producers are responsible for creating the blocks and broadcasting it to the remaining of the network.
00:17:38.430 - 00:19:49.510, Speaker B: So basically this checkpoint is going to include the root of all the blocks that created during the given interval. And it also has all the nodes to validate the same and attach the signature to it. And also what happens is the selected proposer from the validator set is responsible for collecting all the signatures for a particular checkpoint and committing the same on the main chain, right? So the responsibility of creating the blocks and also proposing the checkpoints is variably dependent on validator stake ratio in the overall protocol. And then we have Bohr, which is the block producer layer, right? So Boer is, what is the polygon's block producer layer? It is an entity which is responsible for aggregating transactions into the blocks, right? So block producers are basically periodically shuffled via committee selection on Hemdel, which is the proof of stake validation layer, which is in durations, termed as a span in polygon, and the blocks which are produced at the Bohr nodes, and the side chain Vm, which is EVM compatible. Right? So the blocks produced on the bore will also be validated periodically by the hem del nodes and a checkpoint consisting of the mercultry hash of a block on bore is committed to the ethereum periodically. So what is the flow of a set in the plasma bridge? Right, so as you can see here, it starts with a deposit step. So as you can see in this diagram, it shows the asset flow in a plasma bridge.
00:19:49.510 - 00:21:35.670, Speaker B: So what happens here is the first step is the depositing of the crypto assets into the polygon contract by the user. So once the assets or the tokens are deposited and when it gets confirmed on the main chain, the corresponding tokens will get reflected on the polygon chain, right? So the user will be able to now transfer the token to anyone they want instantly with negligible fees, right? So the polygon chain has faster blocks. That way the transfer is going to know instantly. Once the user is ready, then they can withdraw the remaining tokens from the main chain and the withdrawal of the funds is initiated by the plasma side chain. So checkpoint interval of five minute is set where all the blocks on the polygon block layer are validated since the last checkpoint. And once the checkpoint is submitted to the main chain ethereum contract, an exit NFT token is created of equivalent value and user will have to wait for seven day challenge period. So once the challenge period is complete, the withdrawn funds can be claimed back to your Ethereum account from the main chain contract using process exit procedure, right, where the user can also get fast exit via zero, x or dharma.
00:21:35.670 - 00:23:18.166, Speaker B: So let's break down the deposit and withdraw steps in much more detail right now. Before we start the deposit and withdrawal step, there are some assumptions which we need to know. So the root token and the child token are actually mapped on the proof of stake bridge, right? Which means that I have a token on polygon and I need to map that token onto the Ethereum mainnet, which means that I have a version of USDC on Ethereum and then I have a version of USDC on Polygon, which means that my root token is on Ethereum, which is the USDC on Ethereum, and I have a child token on Polygon, which is known as USDC POS, let's put it that way. Which means that the token contract on the root chain and the token contract on the side chain have to maintain a connection or mapping in order to transfer the assets between them. And by the way, Polygon has a structured way of submitting mapping request, but once the mapping is done, you can use Matic JS SDK, which we will be learning in future classes. You can use Matic JS SDK to interact with the contracts. Or what you can do is you can also interact with the contract without using the SDK.
00:23:18.166 - 00:25:26.950, Speaker B: However, the Matic JS SDK is actually designed in a very user friendly way to make the asset transfer mechanism very easy to integrate with any application. So basically the complete cycle of transferring the assets from Ethereum to Polygon and then back to the Ethereum is what explained in this slide. And in this slide, right? So what happens is how the things start is the owner of the asset, which means when I say asset, it could be an ERC 20, ERC 721 or it could be ERC 1155 token will have to approve a specific contract on the proof of stake bridge in order to spend the amount of tokens to be transferred, right? So this particular contract which needs to be approved as a spender is known as the predicate contract. And each asset type have their own predicate contract deployed on the Ethereum main net. Now the main functionality of this predicate contract is to log the amount of tokens that needs to be deposited. So once the approval is given, the next step is to deposit the asset by making a function call to the root chain manager contract, which in turn is going to trigger the child chain manager contract on the polygon chain, right? And this basically happens through a state sync mechanism, right? And that we will be covering in our future classes. So what happens internally is the child chain manager is going to call the deposit function on the child token.
00:25:26.950 - 00:27:12.166, Speaker B: And by the way, this child token deposit function can only be accessed by the child chain manager contract where it is going to mint the corresponding amount of asset tokens to the user's account, right? It is very important here to note that the child chain manager has the access to the deposit function, right? So deposit is protected basically here. Now once the user is going to get the token, you can basically transfer the token instantly with some negligible fees on the polygon chain, right? So that's basically the procedure involved for depositing of the token. Next we have is withdrawing of the assets. So this withdrawing of the assets back to Ethereum involves first burning of the token on the polygon chain, and then you can use the proof of this burnt transaction which needs to be submitted on the Ethereum chain. So that is a high level procedure involved for the withdrawal. So what happens is it's going to take like 20 minutes to 3 hours for the burn transaction to be checkpointed into the Ethereum chain, which is done by the proof of stake validators, which we call it as Hamedell. Right.
00:27:12.166 - 00:28:48.230, Speaker B: So what happens here is once the transaction have been submitted to the checkpoint, then a proof of the burn transaction will be submitted on the root chain manager contract on Ethereum by calling the exit function. Now this function call is going to verify the checkpoint inclusion course and then it is going to trigger the predicate contract. Now this predicate contract has locked the asset tokens, if you remember, when the tokens were initially deposited. Now when a function call is made in order to verify the checkpoint inclusion, the predicate contract are going to release the then locked tokens and it is going to refund the user's account on ethereum. So how can you see the blocks? Right, how can you see the blocks produced on the Polygon side chain is through the Polygon scan block Explorer which is used for exploring searching the Polygon network for transactions, addresses, tokens, prices and other activities taking place on polygon. So this is how the page of the Polygon scan blockchain Explorer looks like. So I will be walking you through the homepage which shows what is the price of Matic token in us dollar as well as in BTC.
00:28:48.230 - 00:30:42.902, Speaker B: What is the trends, how much is the price up or down? What is the market cap of Matic on is, which is the latest block and how many transactions have been happened so far? And you can see here that it updates every five minutes. As of now, in a second, 91.4 transactions are possible, right? And this graph shows the trend for the transactions that have been happening since August 23 to September 6 as and when the block gets produced by the block producer layer of the Polygon network, this latest block section will get updated with the latest block, right? This is the latest transactions section in which you will be able to see the transactions which are done on the proof of stake chain. So this is a search bar where you can basically search on the blockchain through a contract address, an EOA, a transaction hash, a block number, or you can also search a token. For example, if I would like to search Dai, then I just have to type Dai Dai in the search bar and you can see a pop up is going to get appeared, right? So basically this dai is mapped with its root dai in Ethereum mainnet. If you remember, that's what we were talking about a few minutes ago. So this is what is the homepage of the Polygon scan.
00:30:42.902 - 00:31:41.558, Speaker B: Next is the list of transactions, right? So in order to see the list of transactions. You can go to the polygon scan and you can basically click on the block. Right. The block is going to show you the details of a block which includes the block height, the timestamp at which the block was validated. Who validated this? So this is the EOA, who validated it 2 seconds ago. How many transactions are packed within this block is here? What was the reward that was there in the block? What is the difficulty? What was the total difficulty so far? What is the size of this block? How much is gas utilized? What is the limit of this block? This is the block hash. What is the parent hash? Which means that, what was the previous block hash.
00:31:41.558 - 00:32:46.898, Speaker B: This is Shah three uncle's hash and this is the nons. Right. Now if you want to see the transactions in a block, you need to click here where you will be seeing a list of all the transactions. So there are several columns which you see here followed starting with transaction hash block number. How old was this transaction being mined? Who was a sender? Who was a recipient? How much value of matic was involved in this transaction and what was the transaction fee? So transaction fee can never be zero because there is going to be some finite value of the gas fee which is going to involve for making this transaction possible. Now here you can see a tag called sell, which means that this transaction was taken place within the same account. So if I click here, can see that the from and to address which is the sender's and recipient's address are the same.
00:32:46.898 - 00:33:42.882, Speaker B: So this polygon scan UI basically marks it as it tags it with a self keyword. So when we talk about transactions, there are three type of transactions. Starting with a transaction that is going to transfer the fund from an EOA to another EOA. Then we have got a transaction that deploys a smart contract and we have got another transaction which is executing a function on a smart contract. So starting with the first type of transaction in which they are transferring the funds from one account to another account, you can see that this transaction took place like 22 hours ago on this block number and it was successful with this transaction hash. And the value was 24.61 matic, which is worth $33.29.
00:33:42.882 - 00:35:23.710, Speaker B: Right. If you click here to see more, then you're going to see what was the gas used by the transaction, what was the gas limit and at what gas price was this transaction mined. This nons is basically the number of transactions that are being performed by this address, right? So this is an example of fund transfer transaction. Next we have is the contract deployment, right? So whenever you deploy a contract that creates another transaction. So you can see here that this input data is nothing but the compiled bytecode of your contract, right? Whether you write your contract in solidity or wiper, it gets compiled to the bytecode and you're going to see the same here as a part of the data. And in two, you can see that it shows that the contract was deployed and created at this address, right? Okay, next we have is the contract interaction, right? So in this type of transaction, what happens is it called a confirm function on a contract from this particular account at this block. And it basically also did a token transfer of USDC from the contract to another address, right? So this is a type of transaction where it is calling basically a function on a contract.
00:35:23.710 - 00:36:38.650, Speaker B: Now, this UI provides a facility to decode your input data, or else you will be able to see this kind of raw data, right? But this polygon scan is having a decoder logic to basically show you what is the ABI of this particular function. You can also see the values for each of the parameter if you click on decode input data button, right? So this is basically the types of transactions and how polygon scan UI displays it. Next we have is the contract activity. So what are the transactions that are being going on on a particular contract is what you can see here. So all you have to go is to just go to a contract and just go to transactions. So here you will be able to see that what are the activities happening on this contract. So for example, if I click here, you can see that again a confirm function was called and it again did transfer the tokens from this address to this address.
00:36:38.650 - 00:37:35.226, Speaker B: If you go to logs here, you will be able to see what are the events that were emitted, right? So here, one of the event that got emitted is lock transfer confirmed, and this is the value for the same. So this is how the transaction details are displayed. And if you click on the transaction, this is how you'll be able to see what are the activities going on with this particular contract. You can also see the contract code if it's verified on Polygon scan, right? And you will be able to see all the read functions as well as the write functions. Okay, if there are any ERC 20 token transaction happening with this contract, you will be also able to see the same. And same goes for ERC 721. So this is what is being provided by the polygon scan as far as the contract activity is concerned.
00:37:35.226 - 00:38:38.660, Speaker B: The next UI component that we have on the Polygon scan is the tokens navigation menu which will help you to navigate through ERC 20 tokens as well as ERC 721 tokens based on the market cap and the popularity. So all you have to do is just go to polygonscan.com and just hover your mouse on the tokens and just click on ERC 20 tokens by market cap. So you will be able to see the ERC 20 tokens by market cap on Polygon scan organized in an ascending order. Apart from that you can also view what are the top ERC 721 token, right? So the top token right now is Simba, right, followed by terra virtual NFT and so on and so forth. So we looked into ERC 20 token tracker and the link for that is polygonscan.com tokens, which we just now took a look.
00:38:38.660 - 00:39:47.874, Speaker B: We also took a look into an NFT token tracker, polygonscan.com slash tokens NFT and you can basically use the API key of Polygonscan as well to get all the data which we just now manually saw. Right. So for that what you need to do is you will have to go and sign up to the polygonscan.com. Once you sign up here, you can basically go to API keys. So you will have to create your account, you will get verification link to your email, and once you verify you will be able to go to API keys where you can basically click on add which is going to create a new API key token basically. And using this API key token you can make a call and use the Polygon scans API service.
00:39:47.874 - 00:41:00.926, Speaker B: Right. So we have some code for you to play around which uses Polygon as well as Polygon scans API services. So this is a high level view of what are the API services that are available on Polygon that starts with the API for the blocks transaction API account API contract API and tokens API. So what I'm going to do is I'm going to go and open up my visual studio code and we're going to make our hands dirty for accessing this blocks transaction account contract and tokens API. Right? So let's start with the block API. So one of the API for the block is you can submit a timestamp and you're going to get the block number at that particular timestamp. So this is a timestamp and this is the API link which you can use in order to grab the block number.
00:41:00.926 - 00:42:16.246, Speaker B: Okay, now before that, I just wanted to walk you through what is the setup for this project? Right, so if we go to the readme, you can see here that you need to have node JS installed. What you could do is you can just download this particular repository and make sure you are having NPM package and node installed. I'm using yarn, so you need to run this command for installing yarn globally. And as I showed you, you need to get the polygon scan API key because we are going to use that in order to get the data from the chain and in order to install all the dependencies that we are going to use in this particular scripts. You will have to run yarn to install all the dependencies. And we are going to store all the secrets in env file. And you can basically copy env example and create env file to have the polygon scan API key.
00:42:16.246 - 00:43:11.962, Speaker B: Right. And then these are other instructions which you can go through and which we will be going through of course in order to run the scripts. And we'll also be going through the scripts individually. So the dependencies that I'm using here is env helps me to read the secrets from env file. Axios helps me to make an HTTP post and get calls big number js helps me to do big number mathematics. So starting with block number by block timestamp, I'm making an Xios get request to this URL and I'm mentioning the timestamp as well as the API key, right. So these are all the path parameters which you need to mention.
00:43:11.962 - 00:43:55.510, Speaker B: It's available in the documentation of polygon scan API. The response type I know is going to be JSoN. So whenever this promise gets resolved, the result will get assigned to response. And then I'm making sure that the response is successful by asserting it to okay. And once it's okay then I can print that the block number at timestamp. This is this, right? So whatever result that you are going to get will be accessed through response data result. So in order to run this script you need to open up a terminal.
00:43:55.510 - 00:45:10.942, Speaker B: You can open up a bash terminal or a terminal which is available natively inside the vs code just like I am doing here. And you can just run the script prefixing it with a node. So node I will have to give the path which is get block number by timestamp js. And once I run you can see that I got the output right. Next is I can also check the status of a transaction through the polygon scan API. So this is a transaction hash and I'm making another get HTP call to this particular URL that is going to help me grab the transaction receipt status by providing the transaction hash and of course the polygon scan API key. So here you can see that I'm creating an instance of axios as well as I am importing env so that it is going to read the secrets and then I will be able to access it through process env object.
00:45:10.942 - 00:46:09.650, Speaker B: So here I am again checking whether the call was successful using line number ten. And then I'm printing that the transaction receipt status of the transaction hash is either success or failed. So if the status value is one, it's success, if it's zero, then it's failed. So again, use node and run this command and you can see that the status of this particular transaction hash is a success. Right, next we can also check the balance and EOA EOA is nothing but an externally owned account. Here I am importing big number js library in order to make some mathematical calculations. So what I'm doing is I said that the result is going to be available via response data result which is going to be in way.
00:46:09.650 - 00:47:21.366, Speaker B: So I need to convert that into matic. So in order to convert that into matic, I will be dividing it by ten to the power 18 because Matic has 18 decibels. This is the API URL that I will have to use in order to get the balance of matic in this guy's account. Once everything is fine, this line will get printed. So I'm going to run get matic balance JS. So you can see that this particular account has this much amount of balance at current block. Next I am going to get the total supply of ERC 20 tokens, right? So here what I'm doing is I got the contract address of USDC coin on the polygon network and this is API URL to get the total supply of the tokens, right? And again, I'm using big number js in order to display in a human readable format and also to have ease in mathematics.
00:47:21.366 - 00:48:36.642, Speaker B: So I'm again making axios get request and I'm basically checking if the response data is going to be successful or not. If everything goes well, I'm going to do math and I'm going to divide the result by ten to the power six because USDC has six decimals. So the token supply of USDC will get printed. So currently this is the total supply of the USDC token on polygon. We are going to take a look into the gas stations, right? So gas station, polygon, gas station basically recommends the dev developers about the gas prices. So these are some of the shortcut ways to grab the gas price through the code snippets in Python, Javascript and CuRl, which means that you can make a call to this particular URL and you will be able to get a response in JSoN. So the response includes this kind of a JSON object which has safe flow standard fast, fastest block time and block number.
00:48:36.642 - 00:50:03.946, Speaker B: So the safe flow standard fast and fastest are the gas prices in gway. The block time is the average block time of network in seconds, and this block number is basically the last block that was mined. Okay, now I'm going to show you the code that can help you to fetch the gas price. So I have created a get recommended gas price function here. I am using axios again to make a gat call to this URL which is gas station mainnet meteor network. The response type is going to be in JSON and whatever the response is there gets assigned to this response argument which is a callback and I am checking whether this call was success or not by assigning response status to be equal to 200, right? So once everything goes well, I'm printing line number nine which is the recommended guess price and the result is going to be there on the data key of the response object. So I'm going to have this script run which is prefix with node getrecommendedcastprice js.
00:50:03.946 - 00:50:53.962, Speaker B: So currently if you would like to make your transaction to be get validated fastest, then you will have to spend 2280 g way, right? The block time is 4 seconds and this is the current block number. That's all folks. Thank you so much for the introduction to polygon lesson. I'll see you in the next lesson. Hello everyone, welcome to another lesson of this course. My name is Dhruvind Parik and I am going to walk you through the polygon SDK. So in this lesson I am going to introduce you to the Polygon SDK.
00:50:53.962 - 00:51:59.780, Speaker B: This is a library built using JavaScript that you can easily install in your application in order to interact with the Polygon network. So in the last lesson we took a look. That Polygon network consists of three layer architecture, right? The first layer is the main net which is the ethereum main net. The second layer is the proof of stake validation layer and the third layer is the side chain which is the block production layer. So in order to interact with those layers we need to make NRPC calls. One of the way to interact with those layers is through raw HTTP post requests and get requests. However that will create a lot of code base in your application.
00:51:59.780 - 00:54:02.774, Speaker B: So the Polygon team is kind enough to provide a convenient library which is popularly known as Matic Js and it is also known as the Polygon SDK. So in this lesson we will study how to use the Polygon SDK or matic JS library, and we will also take a look into the examples where you will be doing your hands dirty accessing the functions which is exposed by this library which are related to ERC 20 and ERC 721. In this lesson we will be taking a look into some of the functionalities, and not all, just to get you acquainted to how to use this SDK and how to access the functions which are exposed by this SDK. All right, so let's take a look into how you can install the polygon SDK and how you can access the functionality of the SDK by importing it into your application. So if you want to install the Polygon SDK, then you will have to run yarn add at the ratematic networkmaticjs. So if you run this command in your node project, then it is going to install this as a dependency, right? Once you install it, there are two clients which are exposed by this SDK because we know that we are having a plasma bridge as well as we are having a proof of stake bridge. So we need a sort of a client that will help us to access the functions.
00:54:02.774 - 00:55:28.482, Speaker B: So there are two clients that you can import it. One is the plasma client for accessing the smart contracts on the plasma chain, and then we have the POS client for accessing the contracts on the proof of stake validation layer, right? One of the client which is the plasma client, has a default export, whereas the POS client has a named export. Right? So if you will go and take a look into the implementation of this library on GitHub, then you will get to know about how this is working behind the scenes. However, the reason that we don't want to go into the complexity of how it works, that's why. And in order to develop the application faster with a very little code base, that's the reason we are using this abstraction layer, popularly known as Matic Js. Right. So before we jump into the code, I just want you to walk through the options that you need to pass while creating an object for both the plasma client as well as the POS client.
00:55:28.482 - 00:56:58.174, Speaker B: And using this object, you will be able to access the API functions which are in turn exposed in the class independently. So this is how you can initialize a plasma client as it is a class we need to append the keyword new and you know that if you append a keyword new to a class, then it constructs an object and all the public methods which are declared within this class can be accessed using that object. Okay, so we will take a look into some of the methods for the sake of examples in order to understand how this library works. So the plasma client has couple of options and they can be passed in the form of a JSON object, right? So starting with network, now you know that blockchain needs development. And in order to have the development environment set up each blockchain or all of the popular blockchains, they will have that testnet. Similarly, Polygon also has a testnet with the name mobile. So in this network key we will be declaring the name or the type of the network.
00:56:58.174 - 00:58:15.414, Speaker B: If you want to interact with the main net, you can specify main net or you can specify testnet, right? If you are specifying testnet, then the version is going to be Mumbai. If you are specifying main net, then the version that you need to specify is v one. Then we need a provider, which is a provider object that will basically allow you to access that chain. So we know that Polygon network has a parent chain and a child chain. So we need a parent provider and a child provider, right? So parent provider will be an EVM based chain or any of the Ethereum testnet. So in our example we will be taking go early as the parent provider just because the Mumbai testnet by polygon syncs the state with go early and our matic provider is the child provider, which is the Mumbai testnet. Then we need to specify the default options for the parent as well as the matic, for example who is going to sign the transaction.
00:58:15.414 - 00:59:14.510, Speaker B: So we will be passing the address in the from key as shown here. Then we need to specify the root chain, address the register as address, deposit manager, withdraw manager, child chain, contract addresses here. Right? So this is how you can initialize a plasma client. And of course don't forget to execute initialize function on this object. Okay, so just assume that this matic object is what you get when you assign this expression, right? So this is how you can initialize a plasma client. Now the addresses is something that you can get from the documentation website of Matic. So just head over to docs metic network.
00:59:14.510 - 01:00:23.762, Speaker B: You can click on this develop tag and just expand this network details, right? So the network details, you will be able to see all the information that is required to access the polygon network, right? So the parent chain to polygon is Ethereum and same way they have set up for the testnet as well, where the parent chain is corely and their network is known as the Mumbai testnet, right. And these are the RPC providers which you can use. In our case I will be using infura. If you like alchemy you can go and grab the node provider from there. And same goes for know chainstack and stuff like that. By the way, chainstack is a paid service. You need chainstack if you have an application to query the historical data.
01:00:23.762 - 01:01:01.280, Speaker B: But again that's not something which we're going to do. And then we have the mapped tokens, right? So that this is how the mapping of the token is done on the main. Net. And then we have the same thing on the basement, right? So all of this contract addresses are available. So you can just consult this documentation website in order to get all the contract addresses deployed, right? So this is the list on the main. Net. And similarly you will be able to get the same thing on the taste net as well.
01:01:01.280 - 01:02:27.130, Speaker B: So that's about initializing a plasma client. Similarly you can initialize proof of stake client as well, providing with network version parent provider, Matic provider and it has got its own set of smart contracts that includes the root chain manager ERC 20 predicate, seven to one predicate one one five predicate. So you can specify the contract addresses and we will take a look into what is the best way to handle lot of contract addresses and to make your code look cleaner. So we will be also taking a look into that as well, right, because blockchain applications are complicated. All right, so I'm going to go and open my vs code where I'll be walking you through how this initialization process happens. So I'm using env dependency which will help me to read the environment variables from env file, right? So my env file looks exactly similar to env example. So I have added a private key as well as I have added coerly RPC URL.
01:02:27.130 - 01:03:34.770, Speaker B: I grabbed it from infura. You can grab it from any node provider that you like. Once you are done with that we are using a couple of dependencies, so you just have to run yarn and then it's going to install all the dependencies. We talked about installing Matic js, so in order to install matic js all you have to do is just run yarn, add matic networkmaticjs and it is going to install it. We are using Truffle HD provider as child and parent provider and we're using big number js and bn js for our mathematics and displaying of the correct value and a readable value on the console. Right? So that's basically what our packet JSOn looks like. Then this is our main entry point that gives us the matic plasma client as well as the matic PoS client.
01:03:34.770 - 01:04:26.494, Speaker B: Now here you can see it's the same code. However, we are grabbing the network instance by passing the name of the network and the version to this network class so that we can use it in our application wherever we want to use it. And then we are initializing the plasma client with network version parent provider. So here you can see that I'm passing private key as well as the parent RPC to parent provider. For the matic provider, I'm passing child RPC as well as the same private key. So all this configuration is organized in a file called Config js. And in the documentation I showed you the list of all the contract addresses.
01:04:26.494 - 01:05:11.978, Speaker B: So I just grabbed the contract addresses from there and I segregated in plasma and pos, right? So plasma will have its parent contracts as well as child contracts. So when you see parent, they are the contracts on the parent chain. When you see child they are the contracts on the child chain, right? Similarly goes for pos, proof of stake on parent chain and proof of stake contracts on child chain. Right. We also need RPC to access parent chain and child chain. So here I'm using go early RpC URL, which is my parent chain. And this RPC is provided by matic.
01:05:11.978 - 01:06:27.174, Speaker B: So you can just copy this and just use it as your child chain RPC. These are some extra information which is provided by the matic documentation website where you can find the synchro URL as well as the watcher URL. So these are basically the backend services for syncing up all the data with some centralized db so that it can have very ease in querying the data. Then we have the watcher URL, so that basically syncs the matic plasma contract event on ethereum main chain to mysql database for the faster query, right? So all these are the convenience URLs. Then we can specify the user. So here we are specifying the user account details. So for user one I need to specify the private key which is coming from my env file and its corresponding contract address, right? So whenever you declare the private key, don't forget to append it with zero x.
01:06:27.174 - 01:07:18.700, Speaker B: And this is user two because I just want to do some transfer and all that stuff. So I need another account address. So that's where I am passing that to user two. Okay, so that's my configuration and I can pick as and when required by importing the config on line number four. I also imported hd wallet provider. I imported plasma client PoS client and this is the scaling factor which I'm declaring just because the tokens that we will be playing around with will has 18 decimals, right? So we are just declaring it in order to scale it and display it in more human readable format. So I'm declaring the private key by grabbing it from the config as well as the user address.
01:07:18.700 - 01:08:49.826, Speaker B: So this will be my signer for all the transactions that I'll be doing. And similarly we have the Matic POS client, so it includes all of the details shown above, but it has a different set of options as far as the contracts goes, which means that it has root chain manager ERC 20 predicate, seven to one predicate, and then we need ERC 1155 predicate. So all these are optional, and they are only required if you are working with this standard tokens basically. Right? And then we are exporting it, which we declare it here using module exports. So we are exporting the proof of stake config the plasma, config the child config the parent config private key recipient, which is two pos client, plasma client as well as the scaling factor. Right? So that's basically how you can use Matic Js to get plasma client as well as proof of stake client. Okay, all right, so next thing is we are going to use this declarations or this initializations, which we did in order to retrieve the balance of ERC 20 token from the proof of stake as well as plasma bridges.
01:08:49.826 - 01:09:39.378, Speaker B: We'll be retrieving the balance of ERC seven to one token from the same POS and plasma bridges. And we will use a function to basically transfer ERC 20 tokens on the plasma bridge. Now in order to play around with this API library, we need some fake tokens. So for that you can head over to Faucet polygon technology to get the fake tokens. So let me show you how you can get it using the polygon faucet. So this is already opened up here, which is faucet polygon technology, and I have choose the network mobile. Okay, now I'm trying to get say matic token.
01:09:39.378 - 01:10:19.534, Speaker B: So just open your metamask, grab the account address from here, and just click on submit. Okay, so it will give you 0.1 matic token. Just don't worry if it is failing. Just try again and just wait until the transaction is mined and then we can see that on the polygon chain. So this is the block explorer for Mumbai testnet. The same way we looked into the mainnet explorer, this is for the Mumbai testnet.
01:10:19.534 - 01:10:54.874, Speaker B: Right? So now if I will go and check my wallet, I'll see that my balance is now increased. So I got some matic in my wallet I needed in order to do transactions. Okay, next is I would like to grab a taste Erc 20 token from the plasma bridge. So I need to get some in my wallet. So I do have zero point 99 tst. Let me grab some more. So again, just get your wallet address, click on confirm.
01:10:54.874 - 01:11:27.726, Speaker B: Don't worry if it's failing, just try. And then it will take through just view on polygon. So you will see the transaction details. Just wait until it gets mined and you can see that it is mined. So now just go and check the balance. And you can see that from zero point 98 increased to zero point 99 tst. Now I will show you how you can add token to your wallet.
01:11:27.726 - 01:11:53.650, Speaker B: Okay. All right, so what you have to do is just copy this contract address and go to add token and paste a contract address here. Next. And this is how you can add the token. Right. Okay, next I am going to grab test ERc 20 proof of stake token. So just click on submit.
01:11:53.650 - 01:12:18.154, Speaker B: This time I will be getting two tokens. So just click on confirm. So the transfer is in progress. Just wait until the transaction gets mined. And there you go, the transaction is mined. I'm going to copy this contract address because this is an ERC 20 token. So I'm going to go here and next.
01:12:18.154 - 01:13:05.030, Speaker B: And you can see that now I have four DrC 20 token because I did use the faucet before. So I'm having two more tokens basically. So that's how you can get the tokens from the faucet. So this is required in order to play around with Polygon. All right, so once you are done, we can go and play around with the code here. So in order to get the balance on the plasma bridge, you will have to get the matic plasma client. And then we have a method called balance of ERC 20 where you can specify the from address.
01:13:05.030 - 01:13:34.450, Speaker B: From is the address in which we basically got the token. And it is a child contract on plasma. So I can access address using plasma child ERC 20. It's a promise. Once it's get resolved, then we will be able to see the balance. So let us run ERC 20 plasma balance. So you can see that it shows that it is having 1.99
01:13:34.450 - 01:14:37.154, Speaker B: TST, right? Okay, next is let us check the balance of POS ERC 20 token. So it's the same thing, but here you will have to use PoS client and then you can access balance of ERC 20 by passing the from address and the ERC 20 token address of the POS child. Do the math by dividing it with the scaling factor. And then once your promise is resolved on line number seven, line number 13 will be executed and you will be able to see the balance of ERC 20 token, which is on proof of stake bridge. Okay, let's wait for some time until it is able to resolve the promise. If it takes like some time, just stop using control c and run this script again. Okay, if this happens, don't worry, just rerun the script.
01:14:37.154 - 01:15:21.700, Speaker B: And now you can see that this is the same address where I opted for the faucet and then I have the token which is equal to four. All right. Now similarly, you can also check the balance of ERC 71 on the plasma bridge as well as ERC seven to one on the proof of stake bridge. So similarly here you will have to access a function called balance of eh, seven to one using the plasma client. And similarly you can access balance of ERG seven to one using proof of stake client. Right? So ERC seven to one proof of stake. Let me run one more time.
01:15:21.700 - 01:16:11.700, Speaker B: As such, I don't have any balance of ERC seven to one right now, so it should just print zero. This is basically the error coming from the server side, so it has nothing to do with the code. So just try a couple of times and it should work. Sometimes the server is having some issues and it is not able to respond on time. But anyway, can just try to ping more time so you can see it's zero because I don't have any balance on proof of stake. Similarly, I don't have balance on the plasma as well. So let me just correct the name and let me run one more time.
01:16:11.700 - 01:17:09.960, Speaker B: Okay, so for proof of stake, I do have zero balance of ERC seven to one token, so it printed zero. Now we took a look into the balance API for ERC 20 and ERC seven to one on plasma and PoS both. Now what if you want to transfer your ERC 20 token on the plasma chain, right? So you need a plasma client object, this is matic. And then you can access transfer ERC 20 tokens where you need to specify the token address recipient, the amount of token that you want to send and from which account you want to send. Right? So if you are doing this transaction on main net, then you have to keep the parent to be true, right. If the transfer is going to be done on the main net. Right now we are just doing it on the plasma, so we can just keep this option as well.
01:17:09.960 - 01:17:50.930, Speaker B: All right, so once this transaction is success, we are printing the transaction hash. So this transaction hash will tell us whether the transaction was successful or not. Okay, so let us now make a transaction. So the script that I'll be running is ERC 20 plasmatransfer js. As this is a transaction, it's going to take a bit of a time compared to the get calls, which we did. All right? So don't worry. Let us try one more time.
01:17:50.930 - 01:18:45.342, Speaker B: It's just the issue related to the provider. Okay, so once the transaction is successful, you will be able to see the transaction receipt and all you have to check is what was the status of the transaction. So the status is true, which means that this transaction was successful. Right. So if I will go and check the balance of the recipient, which is my two, then I should be able to see this amount of TST tokens there. Okay, so what I'm going to do is I'm going to go to plasma balance js and I'm going to check that is the sender's balance got reduced or not. So that's how we can make sure that the transfer of tokens actually happened.
01:18:45.342 - 01:19:19.022, Speaker B: So I'm going to run this balance JS script. Just see that I'm passing the sender's address, which is from. So let's wait until the promise gets resolved and it will print the balance. Okay, let us try one more time. Okay, so now you can see that we made a transfer of 0.1 TST, and it shows 0.1 TST less, which is fine, and which is correct, which shows that we were able to make a transfer.
01:19:19.022 - 01:19:49.530, Speaker B: Okay, now if we go and check the recipient's balance, it should be increased. Right. So we are just replacing the from with two. Okay, because that was the recipient in our transfer script. So now I'm again going to run the script in order to check the balance of the recipient. So yeah, you can see here that earlier the balance was 0.1, now it increased to 0.2.
01:19:49.530 - 01:20:21.566, Speaker B: So one 0.1 TST got transferred on the plasma bridge to this guy. Right. So that's basically the usage of the matic Js library. There are other uses as well where it helps you to transfer the token from ether to matic and back. But that is being taken care in the next lesson. So see you all in the next lesson.
01:20:21.566 - 01:21:13.934, Speaker B: Thank you so much for listening to this lesson. Hello folks, welcome back to another lesson for Polygon assets bridge. In the last lesson we did an introduction to matic JS library. In this lesson, we will be using that knowledge in order to transfer the assets from Ethereum to matic and back. So again, my name is Dhruvin and I am going to be your instructor for this lesson. So in this lesson, we will be covering the configuration for the metamask that is required to basically make the metamask compatible with matic chain. We will need some test faucet in order to do the demo for which we will be taking the help of polygon and coral faucet.
01:21:13.934 - 01:22:30.582, Speaker B: Next, we will need a library that is going to facilitate our DAP to connect to the metamask. And finally, we will be writing a code that is going to make the transfer of assets from the polygon proof of stake and plasma bridges to the matic chain and back to the main chain. So let us take a look into how we can configure the metamask by adding the polygon test network. So this is the details which you need to fill up and you can head over to metamask. So I'll just give you a quick demo on how you can add a network. All you need to do is just click on this account symbol, go to settings, go to network, click on add network and you need to fill up the details as shown in the slide. So once you fill up the detail, you will be able to see something like the one which you can see here, right? So right now I have already saved, but however, whenever you'll be filling up the form, this button will get enabled and you'll be able to actually save the network to metamask.
01:22:30.582 - 01:23:32.910, Speaker B: Once you are done filling that up and saving the metamask, you will be able to see the network in the list as I can see here, so you can select it, and in your case, you will be able to see zero Matic. I have filled up my account with some Matic tokens, so I am able to see some finite value. However, in the next slide, we will be taking a look into how we can fill up our metamask wallet with some fake ethers, fake matic and fake ESC 20 and other assets. You will have to head over to faucet polygon technology and there you will be able to get some test tokens from their faucet. So head over to faucet polygon technology. Whichever account that you will be using for transaction, just copy that address. And for example, if I want to fill my account with Matic token, I'm going to paste the address here.
01:23:32.910 - 01:24:06.410, Speaker B: Submit. I will be getting 0.1 matic token, so confirm. And once the transaction is confirmed, I should be able to see increase in my balance, right? So you can see from zero one. Now it's zero two. Okay, if you have not yet added the token, you can just click on add token to metamask and that is going to basically add the token, right? So you can do like this. Now for our demo, you will be requiring other test tokens as well.
01:24:06.410 - 01:25:02.586, Speaker B: So what you can do is you can also grab test ERC 20 plasma token, right? Now, that token will be available in your Matic network. So let's do this. Let's click on submit, confirm, and let's wait until the faucet is filled, right? So this test ERC 20 token will be reflected in your account in the matic when you are selecting the Matic Mumbai testnet, right, you can also add the token to metamask if you haven't added yet. So the token name is TST. So I can just add it here. Now if you open up again, you will be able to see that I have zero point 98 TST token. Next is add test ERC 20 token for proof of stake.
01:25:02.586 - 01:25:39.830, Speaker B: So again, click on submit. You will be getting two tokens which you can see here. Confirm and wait until the transaction is successful. And you should be able to see the increase in your balance. So all you need to do is just add the token. And you can see that earlier I had four, now I have six ERC 20 token, right, which are of the proof of stake token on the child chain. Okay, next we need to grab the test ERC 1155 proof of stake token.
01:25:39.830 - 01:26:09.266, Speaker B: So click on submit. Again, you will be receiving two tokens. Confirm and let us wait until the transaction is successful. Once the transaction is successful, you'll be able to see the transaction on the polygon chain. So this is the token address and you can also manually add the token. Just click on add token and can just have zero decimal. And this is proof of stake ERC 1155.
01:26:09.266 - 01:27:09.962, Speaker B: Okay, and this is the token on the child chain. All right. Now once you are done filling up the faucet in your Mumbai testnet, next step is to fill up your faucet with some tokens. In the coral test network, right? So go to gorely and you can get some Matic tokens. You can also head over to the Corley faucet if you don't have the tokens, right, so the URL for grabbing the gorely ether is gorely faucet slock id. So here you just have to paste your address and request this much amount of ether. Follow the on screen instructions and you will be able to see that your go early testnet has some fake ethers.
01:27:09.962 - 01:27:55.246, Speaker B: I already have, so I'll not be claiming again. Next, you need matic token, so just click on submit. You will be getting one matic token on your quarterly testnet. So confirm you need to do this couple of times because of the network concession. But don't worry, you will be able to just in case. If it's not doing after a couple of tries, just try again after some time. Or as per the documentation from the Polygon team, you can just reach out to them and you can just connect with them via Discord channel and you will be able to get it fixed.
01:27:55.246 - 01:28:42.722, Speaker B: Okay, so now that we have the matic token added to our Corely wallet in our metamask, I can just add the token to metamask here. So I'll just say add token. So here you can see that I have one matic token which is an ESC 20 token available in my metamask wallet in the coraly test network. Next, we need test ERC 20 token of the plasma bridge on the Coerly chain. So again, I will request some. So I'm going to get one. So let me just confirm because of the concession, it may fail, but just try a couple of times and it should just work.
01:28:42.722 - 01:29:34.350, Speaker B: If not again, as I said, we can just try again later. Okay, so let us wait until the transaction gets mined. Once the transaction is mined, you will be able to see the balance of the test ERC 20 plasma token in your metamask wallet. So now I can just add the token to metamask and I have two. TST, right? Okay then we need a proof of stake version of ERC 20 token on the main chain, which is our coral. So I am again going to do the claim and just wait until the transaction gets mined. So comparatively, the transaction mining on coral takes more time than its counterpart, which is the Mumbai testnet.
01:29:34.350 - 01:30:07.582, Speaker B: That's the reason. That's the difference between a proof of work and a proof of stake consensus technology. So I'm again going to add the token to metamask, which is named with DErC 20. So you can say that it's a dummy ERC 20 token. So I can just add the token and I have some balance available in my wallet. Next is I need some ERC seven to one proof of stake. So again I'm going to submit this time this amount is nothing but the token id.
01:30:07.582 - 01:30:49.210, Speaker B: So when they are showing that this is the amount, this is actually the token id, right? Because ERC 20 has unique tokens, they are not identical unlike ERC 20. Hence we call it as it, hence we call it as a non fungible token standard. So I'm going to again to confirm, wait until the transaction gets mined. I can see on ether scan, wait until the transaction gets mined. Now this is a contract editor, so I'm going to copy this contract and I'm going to add the token again. So just token. Now if you already added token, then you will be able to see this message.
01:30:49.210 - 01:31:24.470, Speaker B: So I have already added a token. So I have basically added three tokens with different token ids. So you can see here that currently the token ID which got added is 660. So you can see in the transaction details page of the coraly Etherscan IO block Explorer. And here they basically called save transfer from on the token contract. So now the two address is my wallet address, which is this guy. So I just got this token id transferred under my ownership, which you can see in the metamask wallet.
01:31:24.470 - 01:32:16.962, Speaker B: All right, so once you are done with ERC 721 on the main net, which is the proof of stake version of the token, then you can get ERC 1155 proof of stake version on the main net. Again, click on submit. So here you are going to receive one copy of token id. So click on confirm. So the difference between until this gets progressed, let's talk about the difference between seven to one and one one five. So if you are a painter, you can create unique pieces of your painting, so that can be seven to one. However, if you are writer, so you can write unique books, however, a book will have multiple copies.
01:32:16.962 - 01:33:03.640, Speaker B: So that's where ERC 1155 is inspired from. So ERC 721 is a non fungible token standard, whereas ERC 1155 is popularly known as multi token standard. Right. So if you can see this on the ether scan, you will be able to see that the transaction is still getting mined. Once the transaction is mined, you can basically see the token here. So let us wait until the transaction gets mined. Once the transaction is mined, you got two tokens with token id 123.
01:33:03.640 - 01:33:51.042, Speaker B: So that's what is the difference between 71 and 1155. In 71, each token is a unique token, whereas in ERC 1155, each token is a unique token. At the same time, a token unique token can have a number of copies. All right, so this basically gets you ready with your metamask being set up for our demo. All right, so let's get to our slide and let's see what's next. So the very first thing that we need is to set up the metamask wallet within our DAP. So for that we will be using maticnetworkwalletConnect provider library and we will be using web three JS library.
01:33:51.042 - 01:34:36.510, Speaker B: So you just need to spin up a react app using NPX create react app, the name that you want to, and add this to dependencies and rest is what we would be doing in our demo. If you take a look into the project structure, this is a simple react application and it comes up with some inbuilt code and you can start working, you can start editing the code. So this is app JS. As I said, I'm using react. I have added web three. I have also added wallet connect provider. Once you are done with that, you need to start initializing your application to connect it with metamask.
01:34:36.510 - 01:35:30.738, Speaker B: So the first thing we're going to do is load web three. So in the use effect hook, the first call will be made to the load function which is here. So we need to check whether your browser is enabled with DAP or not. If it has metamask installed then this line will get executed. If you are using a legacy version of web three then this code will get executed. If your browser is not DAP enabled then you will be getting this alert message. So once you are done with the checking whether your browser has web three or not, we are initializing the web three object here using web three JS library and passing Ethereum object of metamask.
01:35:30.738 - 01:36:31.574, Speaker B: After that we are loading the blockchain data so that this load blockchain data function is basically going to initialize matic provider and Ethereum provider using the wallet Connect provider library. So for that we need matic RPC and we need ethereum RPC. So all you need to do is you have to just create env file as per env example file and grab corley Rpc URL from any node providers that you like. I have got this provider from Infura. If you like any other provider like Okemi, you can just go and from there. So once that is done, it will be available here and that will basically help you to initialize your provider for both matic and Ethereum network. Right? Then we are having some callbacks when your wallet connect provider gets connected and disconnected.
01:36:31.574 - 01:37:47.534, Speaker B: So we are just doing a console log and inspect window and then we are setting the state for the matic provider and Ethereum provider both. And we are grabbing the accounts that will basically useful for signing of the transactions network iD based on which we will be making some manipulations on the UI. And once we are able to grab the chain id for both matic or ethereum then we will no more be requiring to be in the loading state. And basically this state basically draws the UI controls which we'll be taking a look in a bit. This is what we need as an initial setup. If you would like to take a look into what should be the client configurations required, you can head over to this link for the testnet configuration or for mainnet you can head over to this link. Right, so I got into the testnet, I got the testnet configuration and I created config js here where I'm exporting the assets addresses both on child chain as well as the root chain which is ethereum and matic for both proof of stake and plasma.
01:37:47.534 - 01:38:40.994, Speaker B: And this is my matic RPC URL. It's available so you can use it and Forlerpc URL you can grab it from any of the node providers. I'm using infura, this is the version. So I'm doing the demo on the Mumbai testnet so you can just use this configuration. The chain id of Matic is 8001 and the Ethereum chain id which is the quarterly has chain id five. So you can just skip the configuration which is selected in brew as shown. However if you are missing out on anything just head over to the weedme and there are all the instructions available to how to get started, how you can do the configuration in config JS and what are the sources and how you can basically operate the DAP as well, which we are going to do in a bit.
01:38:40.994 - 01:39:59.174, Speaker B: So after you get all the configuration done, we need to set up the POS client for parent and child and same goes for plasma. So we are using Matic POS client from this Matic JS library which we of course got a chance to look into our previous lesson. So we are using network version Matic provider parent provider some of the default option for parent and Matic and we are getting the configuration from the config js which is imported bow in this file and then this configuration object which is matic POS client has been returned. Similarly, in order to facilitate the burning of the tokens on the matic chain, we need the matic POS client for the child. It takes the same configuration and then we need the plasma client parent for burning of the tokens on the matic chain. And this is the configuration. The object which is being exposed by Maticjs library is what we are naming it as Matic.
01:39:59.174 - 01:40:56.426, Speaker B: And here is our network and version coming from the arguments we have parent provider, Matic provider and the default configuration for parent and Matic. And then don't forget to call the initialize function on this object and then we can basically return matic and network from here. Similarly, we need to create an object for the plasma child that facilitates some of the operations like approve, reposit, confirm, withdraw and access. So similarly it takes network version, parent provider and matic provider as well. And we need the parent default options and matic default options where we are just using the current account of the metamask. And of course don't forget to call matic initialize. That basically sets up your dap with all the configuration required.
01:40:56.426 - 01:41:42.022, Speaker B: Now let us take a look into how the bridge works for proof of stake. So we already covered this in the first lesson, but however we can just revise the concept again in this lesson before we jump into the hands on. So a bridge is basically a set of the contracts that help moving the assets from root chain to the child chain. And there are two bridges to move the assets between Ethereum and Polygon. First one is the plasma bridge and the second one is called proof of stake bridge. So first here in this slide we will be talking about the steps for deposit used in the proof stake bridge. So what happens is there is a root token and there is a child token and that needs to be mapped on the proof of stake bridge.
01:41:42.022 - 01:42:56.774, Speaker B: In the next lesson we will be learning about how the mapping of tokens can happen using the Polygon UI, which means that the token contract on the root chain and the token contract on the child chain have to maintain a connection or a mapping in order to transfer assets between that. So once you have done the mapping, you can use nomadic JS SDK to interact with the contracts or you can do the same without SDK as well. However, nomadic JS SDK is designed in a very user friendly way to make the asset transfer mechanism easy to integrate with any application. So basically the complete cycle of transferring the assets from Ethereum to Polygon and then back to Ethereum can be explained as two separate steps for deposit as well as withdraw. So what happens is the owner of the asset, and when I say the owner of the asset, it could be ERC 27 to one. On ERC 1155, they basically have to approve a specific contract on proof of stake bridge to spend the tokens of the tokens to spend amount of the tokens to be transferred. And this particular contract address contract is known as the predicate contract which is deployed on the Ethereum main net.
01:42:56.774 - 01:43:49.190, Speaker B: Right. And that contract is going to lock the tokens. That contract is going to lock the amount of tokens which needs to be deposited. Right. But before that you need to give the approval and then the next step is to deposit the asset, basically. So a function call will have to be made on the root chain manager contract, which in turn triggers the child chain manager contract on the polygon chain and the triggering on the child chain manager contract on the polygon chain is basically happening through state sync mechanism. Now what happens is this child chain manager now will call the deposit function of the child token contract and the corresponding amount of the asset tokens will be minted to the user's account.
01:43:49.190 - 01:44:54.650, Speaker B: However, it is important to note that only the child chain manager will be able to access the deposit function on the child token contract. So once the user gets this token, they can be almost instantly transferred with negligible fees on the polygon chain. Now let's take a look into how the withdrawal of the assets happen. So withdrawing of the asset can basically happen by just making like two calls, right? So the first, the token has to be burned on the polygon chain and then this proof of burnt token has to be submitted on the Ethereum main chain. However, it takes 20 minutes to 3 hours for the burnt transactions to be checkpointed on the Ethereum chain. And this is basically done by the proof of stake validators. So once the transaction has been added to the checkpoint, a proof of the burn transaction can be submitted to the root chain manager contract on Ethereum chain by calling the exit function.
01:44:54.650 - 01:46:18.374, Speaker B: Now this function call is going to verify the checkpoint inclusion and then it will trigger the predicate contract which has locked asset tokens and when the assets were deposited initially. And finally, the predicate contract is going to release the lock tokens and refund it to the user's account on the Ethereum network. Which means that if you want to transfer Ethereum to the matic chain, then using the Matic JS library you can just call deposit ether for user and you will need to specify the signer's account address and the amount of ether that you would like to spend. You have to basically specify the recipient's account address and the amount of ether that you would like to send to the same counterpart on the matic chain. And this extra options, you need to specify where from is the signer's address and the gas price that you are willing to pay. Right. So this is exactly what we're doing here, where in order to deposit the ether, we are grabbing the client proof of stake, client, parent, object, and then we are calling deposit ether for user to the recipient address and the amount, right.
01:46:18.374 - 01:47:06.626, Speaker B: So the amount will be entered in ethers. However, we need to convert that into ways. So we are just multiplying this with the 18 decimals. So let us run this app using yarn start and just wait until this app is opened. If you are getting a metamask pop up, please allow Metamask to access this app for more clarification. Let us open console as well, because there are some things which we are printing on the console and you will be able to understand it better. Make sure you are selected quarterly test network.
01:47:06.626 - 01:47:22.860, Speaker B: Now all I'm going to do is let me deposit some ether here. So I can just say I want to deposit one ether, right? And I can say, okay, deposit. And it will be deposited to.
01:47:24.670 - 01:47:24.986, Speaker A: The.
01:47:25.008 - 01:48:30.350, Speaker B: Proof of stake contract on the borelitest network. And let us wait until the transaction is mined. Right? Okay, so once this transaction will get mined, you can change your metamask to the Matic Mumbai network, and you will be able to see that you got some wet tokens in your wallet in the Matic Mumbai testnet when your network is Matic Mumbai testnet. Right? So when you transfer the ether, they are basically going to get reflected as vat tokens, which is an ERC 20 token. Now, this process of deposits from ethereum to polygon happens using the state sync mechanism. And that is going to take about five to seven minutes. So you have to wait for that time interval.
01:48:30.350 - 01:49:12.542, Speaker B: And after that, you can just add this token to your metamask wallet and just check whether the balance of the token increases or not. Right. So that is one way to check. Another way to check is using Matic Js or web three js library. So basically the explorer is going to show the balance only if at least one asset transfer has happened on the child chain, basically. So let us wait for some more time until we see the balance here. Okay.
01:49:12.542 - 01:50:07.674, Speaker B: Until this checkpointing happens, let us go and see the code. Okay, so this is the deposit ether function. Now that was called when I clicked on the deposit button, right? So this is basically I am just handling what are the controls which needs to be hidden and what are the controls that needs to be disabled based on the network id and the chain id. Right. So when we added some value to this input control, we added one ether. So one ether was basically assigned to input value state variable. And when we clicked on deposit, it called the deposit ether function and it got multiplied with 18.
01:50:07.674 - 01:50:59.710, Speaker B: So it is going to create one into ten risk to 18 way. So that was assigned to this function which is deposit ether for user. And that's actually the function which we are calling for transferring eth to matic. So once this is mined, we need to give some time until the state syncing happens. So once the state syncing happens, we should be able to see that our matic wallet gets some vath tokens here. So the token that we will be getting is available in config js and that is nothing but pos child. So I can copy this and I'll just add it here.
01:50:59.710 - 01:51:37.580, Speaker B: So this is how you can add it. So just go to add token here. So I have already added the token, but what I can do is I can just remove this now I can just add the token here. Now you can see that earlier I had 0.7002 bat, now I have 1.7002 bat because I deposited one ether right now, which means that my ether balance in the quarterly test network gone down to 97 from 98. Right.
01:51:37.580 - 01:52:45.182, Speaker B: Now how do I get back this? So in order to get back this, we need to withdraw the eth from matic back into the Ethereum testnet, which is our core league. So it requires two steps. First is we have to burn the token on our matic chain and then whatever transaction we get, we have to present that as a proof to the Ethereum main chain, which is the core latest network. Right? So all you need to do here is go to your DAP, select your network to matic, mumbai, testnet, refresh the page. And now I would like to burn one ether, right? So I'm going to enter one ether here, make sure you select proof of stake and ether. Now just click on burn. So what burn does is it is going to call withdraw function of this matic wet token contract.
01:52:45.182 - 01:53:35.962, Speaker B: And this contract will be burning the token. So since the ether is actually an ESC 20 token on the polygon chain, we can use this burn ERC 20 token function on the polygon pos client because it anyway exposes the same. So let us do a transaction and whatever transaction hash that we will be getting, we are going to store it somewhere as a proof of bond. So let us wait until this transaction got mined. Now the transaction is mined. This is a proof of burn, so you just need to copy it. Now we have to present this burn proof to the root manager.
01:53:35.962 - 01:55:11.934, Speaker B: So once the checkpoint has been submitted for the block containing burn transactions, the user will be calling the exit function of the root chain manager contract and then submit the proof of burn. So once you submit a proof of burn, the tokens are transferred to the user. And the good news are the polygon Pos client exposes exit ERC 20 method to make this call internally, right? So this function can only be called after the checkpoint is included in the main chain. All right, so I'm going to copy this transaction hash. Now I need to present this proof into the Goreli test network, right? So what I can do is I can now refresh this page and I'm going to click on exit because I will be presenting, I'll be calling exit function of the root chain manager. So once click on exit now, unless and until the burn transaction hasn't been checkpointed, you basically will not be able to make a transaction which is basically a feature of Matic JS. So not only Matic JS calls exit function on the root chain manager, however, it will also check whether this bond transaction hash has been checkpointed or not.
01:55:11.934 - 01:56:31.366, Speaker B: So again, this checkpointing is going to take some five to seven minutes. So let us go through the code base in the meantime for rest of the assets. So similarly, if you want to deposit ERC 20 token from ethereum to matic, then you need to call first of all approve ERC 20 for deposit, which is going to approve the ERC 20 predicate contract to spend the tokens that you have deposited, and then you can deposit the ERC 20 token for the user and that will be reflected in your matic chain. So as far as the UI goes, you can just select ERC 20 from here and you can fill up the tokens that you would like to send to the matic chain. So instead of the burn hash, you can basically specify the token. Now we need to let us check again whether one transaction has been checkpointed or not. So it's still not checkpointed.
01:56:31.366 - 01:57:22.054, Speaker B: So anyway, let us store this token somewhere here and we'll get back to it soon. All right. Now similarly for ethers, it is similar to ERC 20 where you can specify the tokens here, but these are the calls that you need to make. Now if you would like to bring your tokens back from matic to main chain, then you have to do two steps. First is call burning ERC 20 token on the polygon chain and that burning is going to happen on the child PosCRC 20 token contract. You can pass the amount and the signer's address. And once you have the bond transaction hash can pass this to exit ERC 20 token which is going to call the exit function on the root chain manager which submits approve for the bond transaction.
01:57:22.054 - 01:58:08.600, Speaker B: So that is what we're doing in our code here. So deposit ERC 20 for supple approves the predicate contract to spend the ERC 20 token. So again it's an 18 decimals of the token as 18 decimals. So we are multiplying it by ten to the power of 18. So basically whenever you click on deposit when ERC 20 is selected, you will see two pop ups. One is approving predicate contract and second is actually depositing the ERC 20 token to the metic chain. Now similarly when you do the deposit flow, it is going to take like five to seven minutes because of the state syncing mechanism that is in place.
01:58:08.600 - 01:59:08.170, Speaker B: And once you would like to burn your token on the matic chain, then you can basically call burn ERC 20 token function by passing the PoS child ERC 20 token and amount of token that you would like to burn. So once you burn this token, you have to present the proof to the main chain by passing the transaction hash. So you can input that and that will basically bring back the tokens into your ethereum main chain. So let us circle back to our DAP and just check if our transaction has been checkpointed or not. It's not yet, nor is however the functionality for ERC 721 is also very similar to ERC 20. So let's take a look here. So for ERC 721 flow of deposit, you first have to deposit ERC seven.
01:59:08.170 - 01:59:55.270, Speaker B: You first have to approve your token to be operated by ERC seven to one predicate contract by calling approved ERC seven to one for deposit and then you can deposit the ERC seven to one for user which is going to transfer it to the matic chain. Again, this involves state syncing mechanism as well. So that's going to take like five to seven minutes. So once you are done depositing, the next step is how you can bring back assets from your matic to the ethereum. So for that you will have to do two steps. First is burn get a burn transaction hash and then pass this one transaction hash to XDH seven to one. So that is going to be calling exit function on the root chain manager.
01:59:55.270 - 02:00:39.914, Speaker B: But between these two, you have to make sure that the checkpointing has happened, otherwise you will be receiving this error. I'm just going to clear the console and give it a shot one more time. Looks like it will take some more time. So again, this is another good feature of Maddox Js where it clearly shows the message that why you cannot call exit ERC 20 function. Basically. All right, so same way we have 1155 as well. So 1155 requires token id of course, as well as it also requires amount, whereas our ess seven to one just requires token id.
02:00:39.914 - 02:01:30.506, Speaker B: Right. So 1155 has another feature where you can basically deposit single or you can deposit in batch based on your requirement. However, they are going to make a call of deposit for on the root chain manager. But again, when it comes to ERC 1155, again you will have to approve that your token to be operated by ERC one five five predicate contract. So once you follow these two steps, this will make your ERC one one five token reflected in the Matic network. And if you would like to bring back your token on matic network to the ethereum chain, then you have to call burn single ERC one one five. Or you can call burn batch if it's more than one tokens with its amount.
02:01:30.506 - 02:02:45.198, Speaker B: So when you supply the area of token ids and amount, the length needs to be same and they has to be corresponding to each other. So here we need to specify the root token id, root token contract address, token id and the number of copies, which is an amount. So we do have that thing in place when you just select PS 1155. So here if you are depositing, then you need to specify the token id here in this box and then the amount which is the value of tokens that you are going to mint or you are going to deposit. Right, so this is the first step of burning and then you have to again supply the burn transaction hash to this function, which is exit single ERC one one five. Or if you burned a batch of ERC one one five tokens, then you have to call exit batch ERC 1155. Okay, in the meantime, before we start the plasma bridge, let us go and again check whether our transaction hash is checkpointed or not.
02:02:45.198 - 02:03:57.750, Speaker B: It's again not. Sometimes it can take like half an hour or it can take like five to seven minutes as well. Based on the network concession. All right, so let's start with the plasma bridge. So basically this plasma bridge also has set of contracts which help you to move the assets from the root chain to the child chain, right? However, whenever it comes to the plasma bridge, there are certain restrictions on the child token and there has to be a seven day withdrawal period associated with all the exits withdraw from the polygon to Ethereum on the plasma bridge. However, the proof of stake bridge is more flexible and that features faster withdrawal. So here in this slide, it is going to act as a step by step process in order to understand how the plasma bridge uses Matic JS library, which is the easiest way to interact with plasma bridge on the Polygon network.
02:03:57.750 - 02:05:30.082, Speaker B: So the first thing is the user will deposit the crypto assets in the polygon smart contract, which are there on the main chain, in our case, corally. So once the deposited tokens are confirmed on the main chain, the corresponding tokens are going to get reflected onto the polygon chain, where on the polygon chain the user can transfer the tokens to anyone they want to instantly with negligible fees. And polygon chain has faster blocks approximately like 1 second, and that way the transfer will done almost instantly. So once a user is ready, then they can withdraw the remaining tokens from the main chain. Withdrawal of the funds is initiated from the plasma side chain and there is again a checkpoint interval of five minutes, which is set where all the blocks on the polygon block rear are validated since the last checkpoint. So once the checkpoint is submitted to the main ethereum contract and exit NFT token contract is created of equivalent value and then user has to wait for a period of seven day, which is a challenge period where anybody can come and challenge the authenticity or the genuineness of the transactions. So once the challenge period is completed, the withdrawal funds can be claimed back to your Ethereum account from the main chain contract using a process exit procedure.
02:05:30.082 - 02:06:30.954, Speaker B: So user can also get a fast exit via zero x or derma. So okay, let us go to our DAP and just check whether this is pointed or not, right? It still says it's still not yet checkpointed. Okay, so what's going to happen if it's checkpointed? So once it is checkpointed, you will be actually able to see that your ether balance on goalie testnet increases, right? You already bundled token on the matic chain. So you go here, you had this weth token which was 1.7, now it's 0.7, which means the token is punt and we're waiting for that token to convert again into the ETH. However, there is a bridge that does the checkpointing stuff and we need to wait for some time.
02:06:30.954 - 02:07:15.714, Speaker B: So let us wait for some more time. Okay. Anyway, let us go to the plasma bridge. So the high level flow for the plasma bridge is the deposit function will be invoked where the tokens get deposited to the Polygon contract and they will be available for the use in Polygon network. So if you want to transfer the ETH on Polygon network. So once you have the fund on Polygon network, you will be able to use those funds to send to others instantly. So the deposit function will get invoked here using the deposit ether.
02:07:15.714 - 02:07:58.738, Speaker B: So if we take a look into our code base, this is a deposit ether plasma. So on the UI, whenever you all have to do is in order to make order to interact with plasma, you just have to select plasma and then select the assets available. So here you can basically deposit the amount. Then once you deposit the amount, basically what you have to do on the matic chain is to burn. So you can just burn the value that you would like to burn. Right. All the instructions to follow for other assets are basically there in the readme file.
02:07:58.738 - 02:09:10.874, Speaker B: So you can go to the readme file and just follow the steps and you will be able to see the assets literally flowing between the two chains. So here you can see we are calling deposit ether with the amount of ethers that we would like to deposit from our main chain to matic. All right, so let's just go back to our slide. So this is a function to call to deposit ether from Ethereum mainnet to the matic chain. Next is once you have the ether available in your matic network, you can then transfer to others, which can be done instantly once you would like to burn and bring back your ether into the main network. This is a three step procedure which you have to follow where force you have to burn by calling the withdraw function of Getty accident token child contract. And this is going to burn the tokens and the Matic JS library exposes start withdraw function, which is the plasma client's start withdraw function.
02:09:10.874 - 02:10:36.482, Speaker B: That matter can be called in order to burn the tokens. Next is we need to confirm the withdraw by calling matic withdraw where the user will be calling start exit with burn tokens function of ERC 20 predicate contract and this token will be burning the tokens. Now the polygon plasma client exposes the withdrawal method to make this call. And this function call can only be made after the checkpoint is included in the main chain, the checkpoint inclusion can be tracked using the nomadic JS library and then we have the exit. So in this exit process, the challenge period has been passed for the transaction present in the and users should basically call the process exits on the process exits function on the withdraw manager contract and then they have to submit the proof of the burn. So once they have submitted the proof of the valid tokens to the user and that can be done using basically the polygon plasma client process exits method to make the call. So here we need to pass the Matic wet token contract address and if you take a look here, when you burn you need to pass the plasma wet token contract address on the child chain.
02:10:36.482 - 02:12:22.490, Speaker B: Then you will be receiving the transaction hash which you need to pass it to the withdrawal function. And once after the seven day period you can then exit from this process by calling the process exit function by passing the root chain with token contract address and that will basically reflect the ethers into your metamask wallet. So similar procedure is there for ERC 20 token as well, but for ERC 20 we need to approve the plasma predicate contract to act as a spender. So basically in terms of plasma bridge they are known as deposit manager contract and they basically need to call transfer from function on this plasma route erc. So that is what is being done when you call this approve es ready token and then deposit function is going to basically transfer the ES ready token to your matic plasma bridge. And then for burning again you need to pass the child es 20 token with the amount that you want to burn. Once you are burned, the transaction hash can be useful to present it to the main chain which is basically the plasma contracts deployed on the main chain where it basically calls the start exit with withdraw bunt tokens function of the ERC 20 predicate contract and this will basically burn the token.
02:12:22.490 - 02:13:28.862, Speaker B: And that can be done using withdraw function which is exposed by the plasma client. However, you can only call this function if there is a checkpointing done after you call this function. And then finally once the challenge period has been passed for the transaction present in the checkpoint, user will have to call the process exit function of the vitro manager contract and submit the proof of burn. So upon submitting the valid proof of tokens transferred to the user, and that can be done using process exits function which is again being exposed by the plasma client and that internally is going to make the call. And similarly we do have the bridge between it to plasma matic for seven to one tokens as seven to one tokens all right, let's circle back to here. I'm going to select proof of stake. The bond transaction proof needs to be sent to the coralitis net.
02:13:28.862 - 02:14:02.230, Speaker B: So I have to select it and just refresh the page. Now let me again check whether. Okay, now it looks like the checkpointing was. Checkpointing was done. And if you remember, we need to call the exit function. Right, and this exit function will be called on the root chain manager contract, which is there on the main chain. So I will confirm this transaction and just wait until the transaction got mined.
02:14:02.230 - 02:14:23.662, Speaker B: Once this is mined, you will be able to see that the balance of eth is increasing. Right. So we got our eth back, basically. Okay. So the moment transaction got mined, we can see that we got our balance back. So that is an example of how it can be transferred from Ethereum to Matic. And from Matic, we brought it back to Ethereum.
02:14:23.662 - 02:15:03.506, Speaker B: Right? So that was for ERC 20. And similarly, you can do it for other assets on both Pos and plasma bridge. This displays the ERC 20 deposit flow on plasma. And once you have ERC 20 available on the matic chain, you can then transfer it to others with very less amount of gas fees. Then we have the withdrawal flow for ERC 20. That requires to call three functions which is exposed by matic plasma client. Then we have deposit flow for ERC 721.
02:15:03.506 - 02:15:55.354, Speaker B: And this is the withdrawal flow for ERC 721. Everything is mentioned in this readme, and it has similar steps which we did for ETH. If you want to transfer ERC 20 from Ethereum network to magnetic Pos, you need to follow the steps. And for withdraw, you can follow the steps. And similarly, we have for seven to one and one one five on Pos. And then we have the same steps available for plasma Bridge for etherC 20 and ERC 720. If you would like to know more about the deposit and checkpointing event tracking, you can just open up this link and you will be able to see this code here in the documentation.
02:15:55.354 - 02:16:30.966, Speaker B: All right, so that's all, folks, for the asset bridge lesson. I will see you in the next class. Thank you for listening to me. Hello folks, welcome to another lesson of l one and l two communication. So in this lesson, we are going to study about how Ethereum and polygon chain can communicate with itself. I am Drovin, and I'm going to be your instructor for this lesson. Now, the topics that we will be covering in this lesson are states, transfer the Fx portal.
02:16:30.966 - 02:17:48.590, Speaker B: What is the comparison of FX portal with the POS portal, which is the proof of stake and we will be taking a look into its use cases. We will also do a demo of arbitrary state transfer where I will be showing you how the method passing happens between Ethereum and polygon chain using smart contracts and bridges. So in the state transfer, we will be taking a look into the state sync mechanism and we will take a look into how the state transfer happens between Ethereum and polygon chain by inheriting FX based root tunnel and FX based child tunnel contracts. The polygon validators continuously monitor a contract on the Ethereum chain, which is known as a state sender contract. And each time a registered contract on an Ethereum chain is going to call this contract, then it is going to admit an event called state synced. Now using this event, the polygon validator is going to relay the data to another contract on the polygon chain. So this is a state sync mechanism which is used to send the data from Ethereum to polygon.
02:17:48.590 - 02:18:51.810, Speaker B: Now, the polygon validators are also periodically submitting a hash of all the transactions on the polygon chain to the Ethereum chain. And this is kind of a checkpoint that can be used to verify any transaction that is going to happen on the polygon chain. So once a transaction is verified to have happened on the polygon chain, the action can be taken accordingly on the ethereum. Right, so there are basically two mechanisms that can be used together to enable two way transfer between Ethereum and polygon. And we will be taking a look into it in our future slides. So basically what happens in the state sync mechanism is it is actually a native mechanism to read the ethereum data from the matic evm chain. Now the validators on the Hamdel layer are going to pick up the state synced event and they will be passing it into the bore layer.
02:18:51.810 - 02:20:07.230, Speaker B: And basically this contract inherits an istate receiver contract. And this contract basically has on state receive function which will get called. And basically this flow involves the state sender contract which is deployed on the Ethereum main chain that is going to emit an event called state synced that has counter id the receiver contract address and the data. So all the validators on the Himdel chain are going to receive this event. And one of them, whoever wishes to get the transaction fees for the state sync, is going to send the transaction to the Hemdell, right? So once the state sync mechanism transaction on the Hemdell has been included in a block, it is added to the pending state sync list. And after, like every sprint, the boar or the boar nodes fetches the pending state sync events from Himdel via an API call. And the receiver contract on the boar is going to inherit iste receiver interface.
02:20:07.230 - 02:21:03.680, Speaker B: And the custom logic of decoding the data bytes and performing any action is basically implemented in a function known as on state receive function. So these are all the genesis contract of the polygon network. So basically how this state sync works. So what happens is this state management is going to send the state from Ethereum chain to the Bohr chain and that is what is known as the state sync. So the state transfer from the ethereum to boar is going to happen through the system call. And if I can explain you through an example, for example say a user deposits USDC to the deposit manager on ethereum, then these validators are going to listen to those events and they will be validating and storing them in the Himdell state. And the boar is going to get the latest sync records and is going to update the boar state.
02:21:03.680 - 02:22:25.226, Speaker B: For example mins equal to amount of USDC on the boar using a system call. So in the state sender, the contract called the sync state is going to get called and internally it emits the state sync event. And then we have the receiver contract which must be present on the child chain. So this is the receiver contract that is going to receive the data once the process is complete. And the sync state is going to emit sync state event on ethereum, right? So once this event is emitted on the state sender contract on the Ethereum chain, the Haimdell is going to listen to those events and is going to add to the Hamedell state after two third or more than two third validators agree on this. So after every sprint there are currently like 64 blocks on board. The board is going to fetch new state sync record and is going to update the state using a system call, right? So what happens during the commit state is the board is going to execute on state receive with state id and data arguments on the target contract, right? So when we talk about the system call, so there are like only system addresses which is two raised to the power.
02:22:25.226 - 02:23:05.510, Speaker B: 160 minus two is going to allow making a system call. So Bohr calls it internally with the system address as method sender. So it changes a contract state and updates the state root for a particular block. And basically the system call is helpful to change the state to the contract without making any of the transactions. So this event emitted by the system calls are handled in a different way than the normal log. So board produces a new transaction received just for the client and includes all the log for the state sync in it. So the transaction hash is derived from the block number and the block hash which is the last block at that sprint.
02:23:05.510 - 02:24:02.534, Speaker B: So this is not going to change any consensus logic, only the client changes. So the get block number, get transaction receipt, and get locks. RPC call includes all the state sync lock which are derived. Now the bloomfinder on the block doesn't include the inclusion of this state sync, or it also doesn't include deroud transaction in the transaction route or the receipt route. Basically. So basically you need to implement fx based root tunnel contract that has this virtual functions like process message from child, send message to child, and receive message, right? So let us take a look into the implementation of the contract. So this is the implementation for the FX based root tunnel contract which is present in the tunnel directory.
02:24:02.534 - 02:25:03.434, Speaker B: So it basically is an abstract contract with a setter for child tunnel. Then we have a function which is send message to child. And the function which we need to implement is process message from child, right? And receive message and send message to child. So here this is a simple contract for our state which is basically implementing the Fx page root tunnel contract. And once the root contract receives the data, then we just need to query this variable in order to get it. If you want to send the data to the child contract, then you can pass any arbitrary random data to this function call. And after the state sync mechanism happens, we can basically check the child contract with the method that we passed.
02:25:03.434 - 02:26:23.910, Speaker B: So after developing the root tunnel contract, the next thing that we need to develop is the child tunnel contract. So child tunnel contract basically implements the Fx based child tunnel contract, and there we need to implement process message from the root and send message to the root. Now this process message from the root is basically a virtual function which is going to handle the logic. To handle the message sent from the root tunnel and send message to root is a function which is called internally to send any byte method to the root tunnel contract. So basically, if I want to send a message from child to the root chain, which is ethereum, then I will have to call this function from the child chain, which is matic, and then I can query the root chain latest data state variable to see the data which is received. So that's basically the implementation of fx based child tunnel and fx based root tunnel contract for transferring the state from one chain to another chain. Now we have fx portal.
02:26:23.910 - 02:27:51.650, Speaker B: So the Fx portal is basically a meta bridge that allows state syncing without any mapping. What this means is this fx portal or an fx breach. Basically FX stands for flexible the reason that it's a flexible portal is there is no requirement of mapping and hence it can provide seamless communication with the Ethereum network. Right? So it is very powerful but simple implementation of the polygon state sync mechanism and basically polygon proof of state bridge is actually based on it, right? So in short, FX portal is a meta bridge and this bridge allows any state syncs without any mapping. And the usual mechanism to natively read the Ethereum data from the polygon chain is using the state sync, which means that it enables the transfer of arbitrary data from Ethereum to polygon. However, this approach also requires a mapping of the root and child contract if the default interface cannot be used. So that's where Fx portal is going to offer an alternative, where ERC standard tokens can be deployed without any mapping involved and simply using the deployed base Fx portal contracts.
02:27:51.650 - 02:29:02.170, Speaker B: So this polygon PoS bridge is actually built on the same architecture. So how does it basically work is we have got Fx child and Fx root contracts which are the main contract on which this Fx portal works. So it calls and passes the data to the user defined method on the other chain without any mapping using the state sync mechanism. So in order to use this deployed contracts, you can implement FX portal's base contract in the smart contract that you deploy, which are the Fx base root tunnel and Fx base child tunnel. So if you build on this contract, then your deployed contract will be able to communicate with each other using the data tunnel mechanism. Or you can choose to map your tokens with already deployed tunnel contracts. Right, so which means that Fx portal or the flexible portal focuses on the permissionlessness, whereas the POS just works for the ERC standards.
02:29:02.170 - 02:30:47.542, Speaker B: Sorry. And another thing is the proof of stake portal is more developer friendly and it allows customization without much of a headache. Whereas on the other side for the FX portal, a developer will end up writing a lot of code, but at the same time it has a benefit of customization. There is a requirement of mapping on the proof of stake portal, however there is no on the flexible portal. So some of the use cases for the FX bridge is we can create a bridge for arbitrary state transfer, we can create a bridge for ERC 20 token standard, ERC 20 token generator transfer, then ERC 721 and ERC 1155 token transfer. Right? So in this lesson we will be doing an arbitrary state transfer and for that these are the contracts which are already deployed by the Polygon team on Go early and Mumbai testnet with these addresses. So that is going to serve us to basically run the developed contracts which we did, implementing the FX root child tunnel and FX base tunnel and FX based child tunnel and FX based root tunnel contract.
02:30:47.542 - 02:31:30.282, Speaker B: Right? So in order to get started you can follow the readme file. It's a simple node project that has the dependencies of remixd because we will be using remix Ide for deploying the contract and interacting with it. We are using Env dependency for our secrets. So the secret that we will be using here is private key, the quarterly RPC URL. Now we need this in order to generate a proof which we'll be talking in a bit. So all I'm going to do is just create, just host this project on the remix. So let us do that.
02:31:30.282 - 02:31:59.934, Speaker B: Now I'm going to go to the browser here and I can go to remix alpha ethereum.org. All right. Now I can connect it to the localhost. Okay, so this is my root tunnel contract. So what I can do is I can first of all deploy this contract. Now this is a root tunnel contract. So root tunnel contract needs to be deployed on the coral testnet.
02:31:59.934 - 02:32:44.366, Speaker B: So I'm going to select injected web three and I'm going to check imnan metamask whether it is corely or not. So this is already a coral testnet. And just make sure your contract is compiled. And then we need to deploy this contract with the checkpoint manager and FX root. So let's go to our slide and check here. So basically, FX based root tunnel contract is a root tunnel on Ethereum and this child tunnel contract will be deployed on the metic network. So when we deploy the root contract, we need to pass the address of root chain proxy as a checkpoint manager and Fx root as an underscore FX root.
02:32:44.366 - 02:33:35.842, Speaker B: So we will be using this address. So let us copy the Fx root here and you can paste it and then we can use the root chain proxy as a checkpoint manager. Right. So after that you can transact and deploy the contract. So let us form it. So on Gorely, the contract deployment takes more time and we have our contract deployed here. Now the next step we need to do is we just have to query whether the checkpoint manager and FX root is the same as we said.
02:33:35.842 - 02:34:21.166, Speaker B: All right, next step is we will have to basically call the SetFX style channel on deployed root tunnel and SetFX root tunnel on deployed child tunnel contract. Right. So now we will be deploying the child tunnel contract on the matic network. So I'm going to open up this file and let us compile, go to deploy, and I'm going to select this guy. We need to make sure that our metamask is connected to Mumbai. And I'm going to pass FX child contract address, which we can get it from here. All right, let us deploy this.
02:34:21.166 - 02:34:52.346, Speaker B: So make sure this is on matic Mumbai testnet. Now, what we are going to do here is we will be setting the FX root tunnel contract. So I'm going to copy the contract address from here. Make sure you see this pop up, and I'm going to paste it. Let us make a transaction on the Mumbai testnet. Okay, so once again, once you receive the confirmation, just hit this guy. Just check whether you are able to receive the address that you set here.
02:34:52.346 - 02:35:24.786, Speaker B: So it will take some time. Okay, so now you can read it. Now, similarly, you have to copy this address and set the child tunnel. And just call SetFX child tunnel in the root tunnel. Now, whenever you are interacting with the root tunnel contract, you have to basically change the network to the go early testnet. And then you can call SetFX child tunnel contract. So make sure it's on go early.
02:35:24.786 - 02:36:13.022, Speaker B: And in the data, you can see SetFX child tunnel. And this basically contract address should match this FX state child tunnel contract address. It starts with D 89 and we have the same. So let's transact it, and then we will query FX child tunnel state variable, and we will make sure that we are able to get the same address. Okay, so this is like initial setup for our contracts of child and on child chain and on the root chain. And that is where our message passing will be happening. All right, next we need to do is now we need to pass the message from ethereum to Polygon chain.
02:36:13.022 - 02:36:56.222, Speaker B: So on the ethereum, we will be calling set message to child. And then we're going to wait until the state sync mechanism happens. And then in our child contract, we are already implementing the process message from root function. And this basically will make sure that the data that we pass from ethereum to polygon chain is actually available in the polygon chain. So this is a simple message that we can pass. It can be any message. So right now, I am going to select quarterly and I'm going to pass a message to the child chain.
02:36:56.222 - 02:37:44.978, Speaker B: So I'm going to paste that random data here and hit on transact. All right, so just click on confirm and wait until the transaction is mined. So this transaction is mined and we can go ahead and see in the quarterly block explorer. So we need to wait for a couple of minutes until we see the data here. So that basically happens through a state sync mechanism which we discussed few minutes ago. So you can see that we called send message to child function and this was our message. So that transaction is a success.
02:37:44.978 - 02:39:09.862, Speaker B: Now we will keep on querying the latest data on our FX state child tunnel, but make sure before you query you are on the right chain. So our chain is going to be thematic Mumbai testnet and this is the child contract that we initialized during the deployment. And this is the root tunnel contract which is addressed on the Ethereum main chain. Now when you will be querying the latest data, the state sync mechanism will make sure that it is going to call process message from root and that will basically make some data assigned to latest state id, then latest root message sender and latest data. So the latest data will be the same data that we sent which is equal to this message. Okay, so let us query one more time and see. So when you are passing the message from the root tunnel to the child tunnel contract, then it will basically receive by calling process message from root which is being called internally from the FX based child tunnel contract.
02:39:09.862 - 02:40:12.414, Speaker B: So it happens automatically through the state sync mechanism. So as I said, it takes like five to seven minutes or it's like 64 blocks. So basically this process message from root is being called from a function called process message from root which is an external function and this function can only be called by fxchild. Right? And if you remember, this was the address that we set when we deployed the fx state childanal contract and it internally calls process message from root which we are implementing in our Fx state child tunnel contract. Right. And it just validates the sender and it assigns state id, latest root message sender and latest data. So let's make a query to latest data.
02:40:12.414 - 02:41:08.078, Speaker B: So now you can see that the state sync mechanism has already happened. And this is the same data that we sent from the go early testnet and now it's available in the matic chain. And this is the address of the root message sender and this is the state id chase 20 zero 63. So similarly we can also send a message from polygon back to ethereum. So for that we will have to send message to root from the child chain. So for that we can use the same data, for example, and we can call send message to root. Okay, make sure you are on the Mumbai testnet.
02:41:08.078 - 02:41:58.862, Speaker B: So I'm going to make a transaction and you can see here that it's a contract interaction on the Mumbai testnet. Just click on confirm. Now the way that message passing from the child chain to the root chain work is little bit different than its counterpart. So what we're going to do is we need a transaction hash in order to generate approved. So now we called send message to root. Now just grab the transaction hash and we will use a transaction hash and send message event signature to generate a proof by using MaticJs library. So let's go to our vs code and go into the script proof js.
02:41:58.862 - 02:42:53.038, Speaker B: So here we are basically initializing matic pos client using maticjs library and we are passing the matic provider and the parent provider. Our matic provider is going to be the Mumbai testnet Rpc URL and parent provider will be the corley RPC URL. I'm using infura URL. You can use any node provider which you like. Then in order to generate a proof we need to basically call Pos root manager function and pass a custom payload of the transaction hash as well as the send message event signature. Now this you can get it from our root tunnel contract and just query the send message event signature. Now it's showing zero because we are on the wrong network.
02:42:53.038 - 02:43:59.042, Speaker B: We have to change the network to now Coerley. Okay and let us query again. So we need to go ahead and copy this signature and this is the transaction hash that we get it from the transaction that we did on the matic Mumbai network for when we call send message to root on the child anal contract. So this is the same transaction ash, just copy it and paste it here and then we can use node to run this script. I am having env config so that I will be able to access the environment variable. So let me run this script, let us go into the correct path. Okay, so again, as I said in the beginning that whenever you pass a message from the root chain, from the child chain to the root chain, then there is a checkpointing which happens.
02:43:59.042 - 02:44:46.518, Speaker B: And after the checkpointing will happen that's when we will be able to generate the proof. So this is again going to take a little bit of time to happen. So once the checkpointing will happen, that's when we will be able to get the proof printed on the console. So here if you read the error, it says that the burnt transaction has not been checkpointed yet. So we will be waiting until the checkpointing is done. We will be able to get the proof. And then once we have the proof we will make sure our metamask is connected to a coral testnet and then we will be calling the receive message function by passing the proof as an input data.
02:44:46.518 - 02:45:50.322, Speaker B: So I'm going to show you here. So it's inheriting FX based root tunnel contract. Now if we go and check the FX base root tunnel contract, it has receive message function which is here. And that is going to process the message which we got from the child contract using this function here. So process message from child is already implemented here and then what we're going to get is the data. So from the FX based router contract internally this will be called and the data will be assigned to the latest data. So similarly, whenever we'll be get the proof, we will make this transaction and then we will query this latest data state variable and again make sure that your network is coral now because we are receiving the message from the child chain.
02:45:50.322 - 02:46:32.854, Speaker B: All right, let us try to generate again. So it's still not checkpointed. It's going to take a while, so let's wait. Okay, so this basically generated the proof. So we can copy this proof now. And all we need to do is just go and paste this proof in the receive message function and make sure you are selected to the coral network and you can just do resume message, send the transaction and make sure it's actually calling the resume message function in the data tab of your metamask. Again, check here if it's coraly and then hit confirm.
02:46:32.854 - 02:47:20.586, Speaker B: So once your transaction is mined, you will be able to, whenever you will be querying the latest data, you will be able to see that message here. All right, so that is basically passing the message from polygon to the main chain, which is coral testnet, from Mumbai to the Corely testnet. And yeah, that's everything for this lesson. See you in the next lesson. Hello guys, welcome back to another lesson of the Polygon course. In this lesson, we are going to learn about how we can deploy the smart contracts to the polygon chain. So in order to deploy the contracts, we need some sort of an IDE.
02:47:20.586 - 02:48:09.530, Speaker B: IDE is an integration development environment. So mainly in this lesson, we will be using three ides for deploying and interacting with the smart contracts on the polygon chain. So the ides that we are going to use will be remix, hardhat and truffle. So let's get started with the IDE called remix. So in order to use remix, you will have to navigate to remixalpha ethereum.org. In the last lesson we learnt about setting up metamask with the Mumbai testnet. So make sure your metamask is selected with the same.
02:48:09.530 - 02:49:01.722, Speaker B: Now what we are going to do is you need to create a repository just like I have created and I called it as remix. Now once you have created the repository, you are requested to add the dependency which is selected in blue. It will be a developer dependency. So you can write a command yan add d remix project remixd and you can download the latest version of the repository. Now this dependency is required in order to host your local file system to the remix ide. So for that you can use NPX remixd. You need an absolute path to your project directory which is shown here.
02:49:01.722 - 02:49:45.330, Speaker B: So there are two options which will be using s is the source. So the source includes absolute path and the ide URL. My ide URL is remixalpha ethereum.org. I'm going to run this command so you will get this error if your path is not correct. Now let us correct the path and then run rerun this command. Okay, so now my local file system is now available on the remix ide. So I'm going to go to remix ide and below the workspaces I'm going to select connect to localhost.
02:49:45.330 - 02:50:31.558, Speaker B: Now they are asking to make sure that the remixd version is the latest which we have it. So I'm going to click on connect. After a brief loading interval you will be able to see the same file system available here. So under the contracts folder I created a contract called greeting. Now the good news are polygon supports same smart contracts that are supported on Ethereum because polygon is an EVM based chain. So you can write your contracts in solidity, compile it, and then you can deploy it on the polygon mainnet and testnet. So this is a simple greeter contract that accepts a greeting message where you can set the greeting and you can greeting message.
02:50:31.558 - 02:51:25.138, Speaker B: Now in another step we are going to click on the deploy and run transaction plugin. If in case your IDE doesn't come with a plugin, just click on this block symbol and just search for compile and then click on activate. Then search for deploy can click on deploy and you will be able to see that the plugins that start swift t will be available here. So this is required if you cannot see the plugins which I am having in my browser. So go to deploy and run transaction under the environment. Change it to injected web three. Now the moment you change to injected web three the metamask window will pop up and you will have to give the access to your metamask wallet.
02:51:25.138 - 02:52:02.914, Speaker B: So just click on next. And now remix has an access to metamask wallet so it will be helpful in deploying and interacting with the smart contracts. Now what we're going to do is we're going to compile this contract. And now once our contracts are compiled, we are going to deploy the contract. So for that you can see here we have a message to pass in the constructor. So you can fill up this form and click on deploy. You will be able to see a window popping up, which means that here new contract means there is a contract deployment transaction happening.
02:52:02.914 - 02:52:53.438, Speaker B: So click on confirm and just wait until the transaction got mined. And once it gets mined you will see the deploy contract section. So just expand this contract and query grit. Now you can see that we initialize the greeting state variable using hello world, right? So let us give a brief moment until the transaction is bind on the polygon chain. Or I can say the transaction is validated on the polygon chain and then you can see that hello world is what we can read when we click on the greet. Similarly, if you want to change the greeting hello etb, I can execute set greeting function. Now that will open up a pop up of metamask.
02:52:53.438 - 02:53:42.654, Speaker B: This is a transaction because it is going to change the state of the contract. So I can just click on confirm and just wait for a brief period of time and you can see that the transaction is mined. And once you query greet, you can see that, you can see here it's hello ETB. So that's how you can basically deploy and interact with your smart contracts using remix. Now in the next part we are going to interact, we are going to deploy and interact with the smart contracts using hard hat IDE. So I'm going to stop this server running and I will navigate to another directory here. Now as you can see in this directory, I have initialized this repository with node js.
02:53:42.654 - 02:54:29.806, Speaker B: So just run npmy init or yarn y in it and that will spin our packet json we need these dependencies in order to use hard hat and all you can do is run NPX hardhat in it and you will be able to see this kind of a folder structure. So once you are able to see this kind of a folder structure under contracts, you can write greeter contract. It's the same contract that we did in remix. Now you know that hardhat provides console locks natively. So you can import this library and you will be able to see console locks happening. However, this console locks can't happen. You won't be able to see the console locks on the polygon chain.
02:54:29.806 - 02:55:35.842, Speaker B: It is only possible to see it within the hard hat network. So in order to configure the hard hat with the polygon chain under the networks key, we're going to create a polygon entry and we will specify URLs and accounts, right, which means that you need to follow env example and you will have to create similar file with the name env with your own private key. Once you have created that, this is the RPC URL which you need to fix, then you can basically open up a console. So I'm going to open up a hard hat console with the network polygon. And next is I'm going to deploy and interact the greeter contract using hard hat. So all I need to do is I first of all need to get the factory. So for that I will say hre ethers get contract factory and I will specify the name of the contract.
02:55:35.842 - 02:56:12.878, Speaker B: Now your name should match with whatever is specified in the contract. Now I got the factory. Now another thing that I will have to do is I'll have to deploy this factory variable. For that I'll say a bit factory deploy. Now you can see that we are getting this issue just because it expects some argument to the constructor. So I can again say hello world and let us wait until the transaction gets mined. Now you can see that here there is a transaction receipt and then this is where the contract got deployed.
02:56:12.878 - 02:56:39.114, Speaker B: So this is the contract address. Now I need to get the instance of a contract. So I'm going to name the instructor of instance of a contract as creator. And I'll use hre ethers get contract at greeting. And here I'm going to specify the address of the contract. So the name of the contract is greeter. So we need to specify the same name.
02:56:39.114 - 02:57:08.178, Speaker B: Now once you have the greeter instance, you can basically read the value of the greeting variable through the function greet. So this is a promise. So you will have to append it with await. So you can see that we initialize with hello world and you can see here that it's hello world. Next is we can also set the greeting. So I'm going to say hello ETB. We need to wait until the transaction gets mined.
02:57:08.178 - 02:57:52.830, Speaker B: Once the transaction is mined, you will be able to see that hello ETB is displayed. So that is how you can deploy and interact with the contract using hard hat on polygon. One thing that you need to make sure is just get the test matic tokens from the polygon faucet that is being shown in the last lesson. So tune in into last lesson again, if you don't know how to get the test tokens. Right now I'm going to exit this console. So you need to press Ctrl C and that is how you can exit from the console. Now, next topic is how you can use truffle to interact with the polygon chain.
02:57:52.830 - 02:58:43.678, Speaker B: So let's look into its configuration. So for that again, under the networks we can create a key called polygon where we can provide a provider with using new hd wallet provider where we can provide mnemonics as well as the RPC endpoint of polygon. Mumbai testnet is a network id confirmations, timer blocks and we are skipping the dry run. So using this configuration let us do using console using truffle. So again, you can initialize a directory with npm y in it or yarn y in it. And for truffle you need to install these dependencies. The truffle SD wallet provided the truffle Ide NPM package itself and env file.
02:58:43.678 - 02:59:30.690, Speaker B: Right now, in order to get the mnemonic, you need to create env file as shown here. So just copy env example and just rename it to env. Get your mnemonic from metamask and just paste it here. And truffle config is created when you run px truffle unbox metacoin. So that will give you this kind of a project structure. And under the contracts you can see here, there is a metacoin contract creator that basically mints some token to the deployer of the contract. And then you can basically transfer the token from one address to another address.
02:59:30.690 - 03:00:21.282, Speaker B: You can also check the balance and the balance in eat. Also you can see here that we have a convert library that basically converts the amount of, the amount of tokens into its equivalent eat value. So that is a simple contract. And now in order to deploy this contract, we need to create a migration. So under migrations, you can see that we are here deploying the contracts. And this truffle, when this migration is run using truffle, you can get the deployer object, which can be useful for deploying the contracts, as well as linking the libraries to the contract, right? So when you basically deploy the contract, truffle calls it as migration. So now what we can do is we can.
03:00:21.282 - 03:01:03.758, Speaker B: Similarly, in hardhead we did using console truffle, we can do using console as well. Right now, if you want to check what are the accounts which are available, you can use it. Just do web three e getaccounts and you'll be able to see the list of ten accounts that are derived from your mnemonic. Now there is a command called migrate that will basically deploy the contract. So when you run migrate, it is going to basically run the script. So all the scripts which are under the migrations directory will be run. The first thing is it will deploy the migrations contract and then it is going to deploy the contract, the contract specified in this file.
03:01:03.758 - 03:01:58.106, Speaker B: Now in order to deploy the contract, you will have to run migrate in the truffle console. So I'm going to run this command and in the meantime let us take a look into the truffle config so you can get the mnemonic from process env mnemonic. Now this is available because I am importing Env in the beginning of this file and this hd wallet provider will help me to initialize the provider for Polygon. Now the cool part about truffle is if you have previously deployed the contracts, then it will not redeploy it. So what I'll do is I'll delete the build folder and I'll try to run the migrate again. So every time you run migrate, the contracts will be compiled. The default version that truffle provides as of date is so.
03:01:58.106 - 03:02:47.022, Speaker B: .5.16 if you want to change the version of your truffle Ide, then, or if you want to change the version of the solid decompiler in a truffle ide, then you can go to the documentation of truffle and tweak your config accordingly. So in the meantime, you can see here that there are transactions happening for the contract deployment. In the meantime, if you want, you can also go through the readme file that specifies all the instructions which I'm showing you in this lesson. So we are in the truffle console. We first did the migration. Second, after the contract deployment is done, what we're going to do is we are going to interact with the deployed contract using the console.
03:02:47.022 - 03:03:38.126, Speaker B: So in order to interact with the contract, I need a contract instance which I can get using metacoin deployed so I can directly use the name of the contract and deployed will get me the deployed contract instance. Now I want to grab the account using which the deployment was happened. So by default it will be always the first account which is going to be acting as a signer. So now I'll just say web three, eat getaccounts. And it's an array. So I'll just grab the first element and that will be my account one. So I'll just say account one equals this guy count two equals sky.
03:03:38.126 - 03:04:05.702, Speaker B: And now we deployed the contract. So let us check balance of account one. So account one. So this is a promise. Let me just append it with a weight. So account one has 10,000 tokens. Now if I want to transfer this token to say account two and I want to transfer 2500 tokens.
03:04:05.702 - 03:04:44.470, Speaker B: So this is a transaction we'll have to wait and then we're going to check the balance of account one. So account one will have a deduction of 2500 and those 2500 will be reflected in account two. Similarly, you can also check the balance in eat for account two and for account one as well. So this is everything about using different ides for deploying and interacting the smart contracts on the polygon chain. So that's everything in this lesson. See you in another lesson.
03:04:46.010 - 03:06:06.958, Speaker C: Hello everyone, welcome to another lesson on the polygon course. Today we are going to learn about mapping the assets using proof of stake breach on the polygon. So so far we have seen that in order to transfer the assets from the main chain to the polygon chain, and from polygon chain to main chain, there is some sort of mapping that happens. So the tokens that we used for the demo in our previous chapters were already mapped by the polygon team. So we use basically that token. However, in this lesson we'll be deploying our own asset contracts and we will be submitting a mapping request to the Polygon team and it will get mapped and that's how we'll be using our own asset contracts deployed and make the asset transfers between the two chains. So basically we need a mapping in order to transfer the assets from Ethereum and polygon.
03:06:06.958 - 03:07:34.650, Speaker C: So for that we need the root chain, the child chain where the root chain refers to either gorely or Ethereum mainnet and the child chain basically refers to either polygon Mumbai or the polygon mainnet. So basically, if you already have your token contract deployed on the root chain, and if you want to move it to the child chain, then basically you should follow this lesson. Or if you are intending to deploy the contract on polygon main net first, mint the tokens on the child chain first and then you can move back them to the root chain. Then you basically need to follow the tide that we'll be talking in while looking into the polygon asset mapping UI. Which means that coming back to the topics, the topics that we will be covering in this lesson are we'll be learning how to use the polygon asset mapping UI. And using that, we're going to map the assets using the proof of stake bridge. And we also are going to use the polygon mintable asset contracts in order to map the mintable contract tokens.
03:07:34.650 - 03:09:05.174, Speaker C: So let's take a look into the asset mapping UI where it basically lists the map assets as well as it is useful for submitting the mapping request to the Polygon team. So if you head over to mapper matic today slash map, then you'll be seeing the UI which is shown here. So let's navigate to the UI. So when you go to mapper Matic today, then you'll be able to see the list of all the map tokens that is shown between the Ethereum address and the polygon address. Which means that the column which says Ethereum address are all the assets that are deployed on Ethereum, whereas the one that you see in the polygon address are all the one that are deployed on polygon. If you want to check the network on which they are deployed, you can switch from this drop down which is choose network type. So if I want to see the one that are deployed on the Corley testnet to the Mumbai testnet, then you can select accordingly.
03:09:05.174 - 03:09:57.846, Speaker C: So these are the assets which are mapped on proof of stake bridge. Similarly you can also check the same for our plasma bridge, right? So here you can see that if you want to map a new token, if you want to create a new request, then you actually have to click on the map new token. Make sure you are choosing the correct bridge type. In our case, we'll be using the proof of stake bridge and you can select any of the token type which is displayed here in the tabs. We're going to do ERC 20 on the network. You can basically select the network which you would like to do the map request for. So we'll be doing on the testnet which is Corley to Mumbai.
03:09:57.846 - 03:11:21.160, Speaker C: So select that and then whatever root token asset contract that you have deployed on your root chain, you can get the ethereum address of the same. You can paste it here and if you want your own version of root token and child token to be mapped, you can also specify the same in the polygon token address field. It is optional because you can leave this blank. In this case, the polygon is going to auto deploy the child token contract on the root chain. Right after you are done filling up, you will have to specify your email address. This is basically required from the Polygon team so that they can notify you via their email when the mapping request is done or if they would like to reach out for anything in future, there are basically two types of tokens available. One is about mintable and non mintable, which means that when you ask to deploy a mintable token contract, it will be having a function to mint it, whereas in non mintable it is basically not having the function to mint it.
03:11:21.160 - 03:12:27.798, Speaker C: So we'll take a look into both mintable and non mintable polygon assets categorically in our future slides. So that's basically about how the mapping can be done using the polygon token mapper UI. So we look into how the form looks like, and now let's take a look into how to map the assets using the proof of stake bridge. So here we're going to map the root assets to the standard child token, as well as we'll also take a look into how we can develop custom child token contract. So the standard child token contracts are available on the Matic network's GitHub page. The repository is known as posal. You can follow this link in order to get the code for each of the asset.
03:12:27.798 - 03:13:49.590, Speaker C: So as far as the demo goes, we will take a look into how to map ERC 20 standard child token using the mapper using the polygons token Mapper UI. So head over to mapper matic today map and you'll be seeing this UI. Now in order to deploy a child, a standard child token, we basically need to have our Ethereum token address. So for that we need to basically create an ERC 20 token, deploy it verified, and once the token is successful on the Ethereum chain, then we can come back here and we can submit the request to the polygon team to map it. So let's do that. So I'm going to head over vs code and I'm going to show you how the code for the root token looks like. So if you can see here, this is a very simple ERC 20 token contract starting with an ERC 20 interface.
03:13:49.590 - 03:14:48.550, Speaker C: Then we are implementing the ERC 20 interface to create a standard token that has all the transfer from and all the mandatory functions that are required in order to make a contract to be ERC 20 compliant. After that we are naming a token as human standard token that is again implementing the standard token. However, here we need to basically initialize all the parameters, namely we need to mint some tokens. In the beginning we need to assign the total supply name decimals symbol. So once we are done with that, the next step that we're going to do is we need to basically deploy this contract. Now we can use remix to deploy the contract. So let's go to the repository.
03:14:48.550 - 03:15:53.850, Speaker C: As far as the dependency goes, we're using remix project remixd dependencies so that will be useful for us in order to host the contracts directory to the remix. So as far as the command goes, you have to type Yan remix T. Please specify the correct path of the repository. So the repository's correct path is one which is shown here. So once you are done with this it is going to open up let's go to our Google chrome and I'm going to open up remixalpha theorem.org so let it open and I'm going to go and connect it to the local host. So once it's connected to the local host we'll be able to deploy our root token contract.
03:15:53.850 - 03:16:32.014, Speaker C: So once again it uses 0.8.0 solidity version and it's a pretty basic ERC 20 token contract. So let's compile it making sure that it's 0.8.0. Once the compiling is done we need to go and deploy it. So I'll be selecting injected web three. We are going to deploy the root token contract into the coraly testnet. So in your metamask do check that it displays the coraly testnet.
03:16:32.014 - 03:17:28.138, Speaker C: After that we are going to create an initial supply of 100 tokens. So I'm going to just give 18 decimals. The token name is my proof of stake token and I'm going to name it my proof of stake token MPT and just adding 18 zeros. So once you are done with filling up all the initial values that will be supplied to the constructor, let's deploy the contract. Let's make all the on screen instructions and let's wait until the contract is deployed. So go here and just check the ether scan. Looks like the contract is deployed as we have the green checkmark here.
03:17:28.138 - 03:18:18.822, Speaker C: Go to the polygon token mapper and just paste your contract address here and you'll be able to see the token symbol, the token name and you need to specify your email id here. So I'm giving my email id and let's just submit the request. So this will be the confirmation screen that is useful to verify the details. So this is our address of the token deployed on Corley decimals are 18. This is my email id. Then our network is coraly, it's not mintable. MBT is a symbol and my POS token into the brackets.
03:18:18.822 - 03:19:12.670, Speaker C: Pos will be the token name on the child chain whenever it will get deployed. So once we're done with that the request will be submitted can close it. So it's going to take a while until the request is processed by the Polygon team. So basically once your request is processed, you'll be able to see the token mapped along with the address. So let's go and check our testnet. So once it is done, you should be able to see something like this with your token name, Ethereum address and the Polygon address. So this polygon address is basically deployed by the Polygon team.
03:19:12.670 - 03:20:14.690, Speaker C: So for example, say we have this as an ethereum address and this is our polygon address, right? So now how do we use it for our set transfers? So in the previous lesson we took a look into how we can use matic JS library for transferring the assets. So we're going to use the same library for transferring the assets that we created. So for example, this is an asset that I created previously. However, as it's going to take a while, let's just use this asset, right. So all you need to do is just copy here. So you can just copy the ethereum address. And we're going to go and open up our breach code base, go to SRC, go to config js and just modify the root ERC 20 token contract address.
03:20:14.690 - 03:20:52.638, Speaker C: So this is the root ERC 20 token contract address and you can see the decimals are four which was previously mapped. And then we have our polygon address. So that's our POS child ERC 20. Right. So I'm going to split the screen and I'll be going to the four. It's the third lesson which is breach code base. And in order to start the UI, I'm going to say yarn start.
03:20:52.638 - 03:21:28.170, Speaker C: So let us wait until the UI is up. So let's open up the UI here. Now one thing that you need to make sure while deploying the root token contract is it should be verified because that is a requirement from the polygon team. If it is not verified. Please do verify. Please go to ether scan and you will see here verify and publish instead of the UI that you are seeing here. So you can just follow the on screen instructions in order to verify and publish.
03:21:28.170 - 03:22:38.942, Speaker C: So now we'll be using the same UI that we use, but right now we'll be using this token that we just deployed using the polygon token Mapper UI. Now we're going to do a demo of transferring ERC 20 tokens between Ethereum and polygon and polygon and Ethereum. So we're going to need to do a small tweak in the code where whenever we are transferring ERC 20, we need to make sure that we are matching the decimals. So there are four decimals which we're using. So here I'm just going to make that change so that there is no issues in the calculation. So this deposit ERC 20 is for depositing to the child chain and burning ERC 20 is burning the tokens on the child chain and depositing it back to our main chain. So all I'm going to do is I'm going to select proof of stake ERC 20 and say, for example, I want to send 0.3
03:22:38.942 - 03:23:20.090, Speaker C: tokens to the child chain, right? So before that what I'm going to do is I'll be going and adding this token into my Corely testnet in the metamask. So go to add token and add token. So I already have one sapari token. So let's go and click on deposit. So first it will ask you to approve. So we're going to approve the ERC 20 predicate proxy contract. So let's do that once that is mined.
03:23:20.090 - 03:24:08.774, Speaker C: So once that transaction is mined, another transaction will be to call the deposit for function. So we can just do that and confirm. So let's wait until that transaction is mined and in the meantime, once it gets mined can go to Matic Mumbai testnet, go to assets and we can add our child to token contract here and add. All right, so let's go to the Coraly testnet and it looks like we are having 0.7 superi tokens. That is a result after depositing 0.3 superi tokens to the child chain.
03:24:08.774 - 03:25:20.500, Speaker C: So we'll be able to see that we have some 0.3 superi tokens available in our account of the Mumbai net. So let's wait until it appears. So next, what we are going to take a look into is what if you need a custom child token? So this was the token contract that is provided as a standard ERC 20 token by the Polygon team. So the next topic that we will be taking a look into creating an custom child token contract which has some additional functions to the standard functions of ERC 20. And then we can deploy the token contract on the child chain and submit a mapping request on the polygon's token mapper Ui. There are some functions that are mandatory to have in your custom child token contract, so we're going to take a look into that.
03:25:20.500 - 03:26:28.454, Speaker C: And there are some restrictions that we have while creating custom child token contract. So we'll be taking a look into that as well, so basically in the meantime, let's take a look and see if we have got some superi tokens. It looks like still the update has not happened, so let's wait some more time. So in the meantime, let's just circle back to this UI in a bit. So now that we are able to transfer the tokens that are mapped using the token mapper UI, the requirement could be to have a custom child token contract. So let's go to. All right, so now here you can see that we mapped this token and it's now available on our Polygon token Mapper Ui.
03:26:28.454 - 03:27:05.086, Speaker C: Right? So we can use this token as well. So instead of using the one that was deployed previously, let's just use this. So I'm going to copy it to the root token and this is my polygon address. Okay. And now these are all 18 decimals. So we will have to make a small change here. So looks like this is 18 decimals and we're going to update this guy as well.
03:27:05.086 - 03:27:50.078, Speaker C: And let's go to config, copy this and just add this token to our early testnet here. So this account has 100 amputee tokens. So let's go and select ERC 20. Let's do a refresh ERC 20. I want to submit 20 tokens to the child chain. So I'm going to click on deposit and let us withdraw. Let us approve it to get spent by the predicate proxy contract.
03:27:50.078 - 03:28:29.280, Speaker C: Once the approval is done, we'll be able to call deposit for the function. So this is another transaction which we need to basically allow. So I'm going to click on confirm. All right, so let's check the balance up over a set. So it should be 80 after the transaction is mined. So looks like the transaction is mined, sending 20 my PoS token and the balance should be 80. Right.
03:28:29.280 - 03:29:17.360, Speaker C: So next we're going to do is just copy this and select the Matic Mumbai testnet. And now you can see that we are having 0.3 superior reflected in the child change. Similarly, we should also get the 20 mbd tokens here, basically. All right, so now that it's going to take a while to reflect, what we could do is we can take a look into the custom child ERC 20 token. So so far we looked into the standard ERC 20 child token. So there are some restrictions and there are some rules that we need to follow.
03:29:17.360 - 03:30:09.310, Speaker C: For example, we need to have a deposit method and we have to make sure the deposit method can only be called by the child chain manager proxy contract. Whenever a deposit is initiated from the root chain, then the deposit should have a logic so that it internally means token on the child chain. We do not have to mint the token in the constructor should have withdraw function which can be called to burn the tokens on the child chain. And burning is a four step of withdrawal process. So withdraw is going to internally burn the token on the child chain. And this is a child chain manager proxy contract deployed on the Mumbai net. So let's take a look into how to implement the custom ERC 20 child contract.
03:30:09.310 - 03:31:08.850, Speaker C: So if you take a look into the code of the child token contract, we're implementing deposit function and the withdraw function. So deposit function basically comes from an interface called ichildoken and that has user and the deposit data as arguments. So we need to basically implement that in our token contract. We know that it can only be called by the child chain manager proxy. We need to make that change accordingly. And here we are minting the tokens as per the rules. So which means that we are increasing the total supply and we are also adding that amount to the users.
03:31:08.850 - 03:32:12.242, Speaker C: And then we are amiding transfer event that shows that it's being minted because the origin address is zero x. Then we are having withdraw function that is used for burning your assets on the child chain. And this is the implementation for the same. Having said that, now we can start deploying the contracts. So the very first thing we need to do is we need to deploy the root asset contract. So what we could do is get root token contract, compile it, and let's say hundred is the token and it's going to have 18 decimals. Token name is my custom pos and then we can say MCPs as a token symbol.
03:32:12.242 - 03:32:55.490, Speaker C: So let's deploy this contract. All right. So the next step that we can do is deploying the child token contract. Let's wait until the root token contract gets deployed and next we can go and select the Mumbai testnet and we can compile the child token contract. Now as per the rules, we can't have minting done within the child token contract. So there is no initial supply which is here. Right, because the minting is already done from the main chain.
03:32:55.490 - 03:33:35.646, Speaker C: So we can have the token symbol as mcps and we can say this is on proof of stake, decimal units and this should be actually here, my custom pos. Pos. Let's check the name of the root token. Oh, we don't get because we have not selected the correct address. It's Mumbai. We are deployed on Gorely. All right, again, deploy this contract.
03:33:35.646 - 03:34:15.280, Speaker C: So this is on matic Mumbai testnet. Just make sure that that's the same and let's wait until the contract gets deployed so it's deployed and I can go ahead and I can do mapping now. So go to the token mapping UI map, new token, and this is my theorem token address. They are saying that the token is not verified. So we need to go and verify the token on the Gorely network. Right. Let's go to.
03:34:15.280 - 03:34:53.562, Speaker C: Yeah, actually we were getting this issue because we are using the wrong network. Okay, so this looks fine. And then we can get our polygon address. Looks like this is not verified. Let's go and check and make sure and we'll see how it can get verified. So go to the transaction. This is our contract address.
03:34:53.562 - 03:35:21.090, Speaker C: And yeah, it's not verified. So our compiler type is single version is 0.8.0, it's unlicensed. Let's double check from here. We can continue and can grab the code here. Make sure you do all the checks. Let us wait until the contract gets verified on ether scan.
03:35:21.090 - 03:35:55.630, Speaker C: So the contract is verified. Now we can copy this and paste it here. And let's give the email id and submit. So we already verified on the polygon Mumbai explorer. We have deposit and withdraw functions on the child token contract. Yes, only the child chain manager proxy has right to call the deposit function. Now we didn't do that.
03:35:55.630 - 03:36:38.940, Speaker C: So what we can do is we can just copy this address. We can go to our remix and make sure your network is the Mumbai testnet and we can just say that update child chain manager to this address. So we did this check and once the transaction is mined, let's just check that it's the same address, which means that we passed this check as well. Mint function is an internal function. So let's check in our contract. So internally we are minting in the deposit function. Right? So that is true.
03:36:38.940 - 03:37:37.134, Speaker C: So now we can submit the request. And basically once your request is accepted, then you're going to receive an email from the Polygon team and you will also be able to see your token mapped. So you can technically test your custom deployments the same way that we are testing the standard deployments minus the custom functions, basically. So let's go back to our UI and check whether our Mumbai testnet received some tokens. So now you have 20 mpd tokens. Now all you need to do is let's refresh the page. ERC 20.
03:37:37.134 - 03:38:35.950, Speaker C: Now I want to burn ten tokens. So ten tokens back to the main chain. I'll click on burn and calls withdraw. So let's wait for the burn transaction hash so that we can use the same hash in order to present the burn proof. However, in the meantime, until we are able to get the bond thing done, let's go and explore our next topic. So here we going to take a look into the polygon mintable assets and in that we will be taking a look into the requirements for deploying mintable assets on polygon. So in order to deploy the polygon mintable tokens.
03:38:35.950 - 03:39:33.902, Speaker C: So what happens is basically the assets can be transferred to and from across Ethereum and polygon chain using the proof of stake bridge. Now this basically asset include ERC 20, ERC 721, ERC 1155 and there are many other token standards. So most of these assets are preexisting on the Ethereum chain. However, you can also create new assets on polygon chain and you can move it back to Ethereum chain as and when you require. So this can save a lot of gas, lot of time which is spent on the token minting on Ethereum. So the creation of the assets on polygon chain is basically much easier and that's basically a recommended approach as well. And these assets can be moved to Ethereum chain when required.
03:39:33.902 - 03:40:25.910, Speaker C: So such type of assets are the polygon mintable assets. So in case of polygon mintable assets, the assets are created on polygon. When a polygon minted asset has to be moved to Ethereum, the asset has to be burned first and then a proof of this burn transaction has to be submitted on the Ethereum chain. And the root chain manager contract is going to call special predicate contract internally. And this predicate contract directly calls the mint function of the set contract on Ethereum and the tokens are minted to the user's address. So this is a spatial predicate and it is also known as mintable asset predicate. So you need to satisfy some of the requirements.
03:40:25.910 - 03:41:30.854, Speaker C: And the requirements includes contract deployed on the polygon chain and then we need to deploy contract on the Ethereum chain. So you can either deploy mintable token contracts on polygon chain or you can use the polygon token mapper UI to request a mintable token contract which can be auto deployed on the polygon chain and you can use the same UI with the same link which we did previously. However, we can also deploy a contract by ourselves by having the child contract that have deposit, withdraw and mint function. And it should look very much similar to the one shown in this link. As far as the demo goes, we'll take a demo of ERC 20 token and the similar requirement we have for Ethereum chain.
03:41:30.902 - 03:41:31.162, Speaker B: Right?
03:41:31.216 - 03:42:16.520, Speaker C: So a token contract which is deployed on Ethereum chain should also have the contract similar to the one shown in slinks. The most important part is the mintable asset proxy contract deployed on Ethereum should be given the minter role in the set contract deployed on Ethereum. And only this predicate proxy address should have the rights to mint the tokens on Ethereum. Right? So these are the addresses on the goverly for the asset predicate proxy contracts, and can use this to assign a minter role to the mint function.
03:42:18.410 - 03:42:18.822, Speaker B: Of.
03:42:18.876 - 03:43:03.270, Speaker C: Your main of your root asset contract. Basically. So in the meantime, let's go and check the UI and we have the transaction. Hopefully the checkpointing should have been done. So what we could do is we can switch network to Coralie and just copy the transaction hash, refresh it, and supply our transaction hash here. Click on exit. It looks like the burned transaction has not been checkpointed yet, so let's give it some time until it gets checkpointed.
03:43:03.270 - 03:44:00.780, Speaker C: So let's take a look into the contract for the polygon mintable assets. So here we're going to go to our token code base, pos mintable ERC 20. So this is our root token contract. It's very similar to the one that we deployed. However, we are having a mint function because it is a mintable asset. What we did is in our basic implementation, we added a mint function, and this mint function is calling the mint function, which is implemented in our standard token contract. This mint function does nothing but adds some more tokens to the total supply and the same amount of tokens to the account that holds that amount.
03:44:00.780 - 03:45:14.754, Speaker C: And then we are emitting a transfer event. And you can see here that it can only be called by ERC 20 predicate proxy. That is one of the rules that we're following. So you can deploy it similarly, and you can use our bridge code base to test the transfer of assets. The next part that we have is the custom root token contract. So in the custom root token contract, as I said, the custom root token contract's mint function can only be useful by the mintable ERC 20 predicate proxy. So once you deploy your custom root token contract, you can go ahead and change the mintable ERC 20 proxy address, and you can use the UI tool to map it with the same way that we did it in the POS ERC 20 token with the custom child token and root token as well as just a root token and child token deployed by the Polygon team.
03:45:14.754 - 03:46:31.926, Speaker C: And then we have the child token contract that should have mint function withdraw and deposit. Withdraw function should basically burn the tokens and deposit function is the one that should basically mint the tokens, but it can only be called by the child chain manager proxy. So basically we need is, we need the deposit function in order to transfer the minted tokens from the child chain to the root chain, right, and it follows the same approach that we are doing in this application. So we need to get the burn proof and then we can call the exit and that will be appearing in our ethereum's main net. So I'm trying to call exit again and this time it looks like the checkpointing is done. So I'm going to click on confirm and I should see increase in my asset value in my asset amount after the transaction is mined. So I burned ten tokens.
03:46:31.926 - 03:47:47.890, Speaker C: So I should be able to see 90 tokens here, which I am seeing, which means that the token mapping UI is working. So that's basically the contracts that you need to deploy on the Ethereum chain, and the same contracts and the similar contracts displayed here, you need to deploy on the polygon chain. Observing all of these rules, you can refer the contracts in the code base and make sure that your deposit function is only callable by the mintable asset predicate proxy. The asset means CRC 27 to one and 1155. The contract addresses are available here. If you want to get the list of all the addresses, just head over to. You can basically head over to can go to static Matic, network, network, testnet, Mumbai, JSON and you'll be able to see all the contract addresses here.
03:47:47.890 - 03:49:04.710, Speaker C: Alright, that's all folks in this lesson. See you in the next lesson. Hello everyone, my name is Drovin and I'm going to be your instructor for this lesson for the Polygon course, which is metatransactions. So metatransactions are also known as gasless transactions, right? It basically allows the users to interact with the D apps who only has access to public private key pairs, which means that it is basically a way to enable or to onboard a user who has the assets, but who does not have the gas to pay for that assets. Of course there has to be a gas which needs to be paid in order to change the state of a smart contract and in turn change the state of the chain. But that shouldn't block the user to use the D apps just because of the gas. So basically a user with an account can craft a transaction in a very similar way how the normal transaction is created.
03:49:04.710 - 03:50:07.470, Speaker C: They can sign with their own private key, but instead of sending it to on chain, they'll be sending it to a so called relayer, or that relayer is the actual sender. So basically we'll create a DAP on polygon network to integrate it with the meta transactions. And we're going to use a platform called biconomy to serve to power our DAP with a metatransaction. So there are a couple of solutions available. One of them being biconomy is what we'll be using in this lesson. So if we talk about biconomy, biconomy is actually a scalable transaction relayer infrastructure. It can pay the blockchain transactions gas fee for the DAP user.
03:50:07.470 - 03:51:42.282, Speaker C: Also while it is collecting the fee from you on monthly basis, it can be in the form of some stable tokens. So it seeks to abstract way in which the complexity of the blockchain for customers are handled by enabling gasless transactions. So basically if you have some 2030 dies, and if you want to pay to somebody, then you don't really need to have ETH for that, because of course if you want to call a transfer function on ERC 20 token, you need to pay for the gas. So basically you can pay in your favorite ERC 20 token irrespective of the native coin to be pay, and in the gas price optimizations as well. So let's take look into the introduction to metatransactions. So what happens here is we have got couple of actors in this sequence diagram where a transaction signer is an entity that signs and sends to the request to the gas relay. Then we have got the gas relay that receives a signed request off chain from the transaction signer and it pays to turn it into a valid transaction that goes through the trusted forwarder.
03:51:42.282 - 03:53:00.834, Speaker C: Then another actor in the sequence diagram is the trusted forwarder. That's a contract that is trusted by the recipient to correctly verify nature and nuns before forwarding the request from the transaction signer. Then we have got the recipient contract which can securely accept the metatransaction through a trusted forwarder by being compliant with this standard. Right? So the trusted forwarder is responsible for calling the recipient contract and it must append address of the transaction signer, which is 20 bytes of the data that should be appended to the end of the call data. And then we can have the recipient contract extracting the transaction signer address. By performing that the forwarder is trusted and is this implemented? Is out of scope. Right now the implementation is out of scope of this lesson.
03:53:00.834 - 03:54:30.370, Speaker C: However, what happens in another step is extracting the transaction signer's address from the last 20 bytes of the call data, and then we can use that as original sender of the transaction instead of message sender, which means that if message sender is not a trusted forwarder, then return the original message sender as is. So this is basically the workflow for metatransactions where we have the cache relay network that is responsible for signing and sending the request to the trusted forwarder contract, which in turn calls the recipient contract's intended function. So next we're going to take a look into biconomy. So we know that biconomy is very scalable transaction relayer infrastructure. It can pay basically your blockchain transaction fee for all of your DAP users. So before going into the meta transactions, let's see how we can develop a contract which is metatransaction compliant. So here I created a react application with this remixd as a dependency.
03:54:30.370 - 03:55:14.640, Speaker C: And then there are a couple of dependencies, one of them being biconomy maxa. And we are also using web three. We're using material UI for beautifying the UI, and then these are commonly used react libraries. So the very first thing is we're going to open up and see how the contract looks like. So go to Remixalpha or ethereum.org, connect your remix to the project repository. I have created a contract directory and the contract that I'm going to show is named as code.
03:55:14.640 - 03:56:21.010, Speaker C: So what we have here is a simple example where you can set a quote and then you can get the quote basically. So we need to basically have like key ip seven one two domain structure that includes the code itself, the version chain id and the verifying contract. Then our meta transaction will have non send from address sender's address and the sequence. And then we're having quote and owner as a public state variable. And then we are basically incrementing the nuns per the user using this nons mapping. Then we are having eap seven one two domain type hash, metatransaction type hash, and then we're having domain separator. This is required just in order to make sure that your metatransaction or your sign message in Ethereum cannot be replicated in polygon, right? So we need to make sure that each sign is unique to a chain.
03:56:21.010 - 03:57:12.040, Speaker C: For example, for Mumbai, our chain Id is eight triple zero one. So we to make it as a part of domain separator. So this is version one so we can specify it. Having said that, we need to make sure that while sending the message on the client side, we need to take care of the similar things. This is the name is quote and once we are done with setting up the domain separator, we'll be expecting that the same domain separator is being used by the client and then we'll be extracting our signer's address accordingly. So basically what we're going to do is I'm going to create a meta transaction object. I'm going to reconstruct the message that was signed off chain using the smart contracts, get checked to physics function.
03:57:12.040 - 03:58:17.260, Speaker C: And once I get that, then what I'm going to do is I'll be making sure that this user address is the same user who signed RSnv, which is a breakdown of the signature. So this is an ecover inbuilt function in solidity where you can pass the message and the signature that is going to extract the user's account address. So we're going to make sure that this is the same user. If it's the same user, then we can definitely assign the new quote passed here to the quote public state variable. And then we can assign the owner, we can increment the nuns of the user who called it. And then this is a simple getter function. So first we can deploy this contract using injected web three.
03:58:17.260 - 03:59:19.280, Speaker C: So go to environment and select injected web three. We will be using the matic network. So go and select matic Mumbai testnet. And all we need to do is click on deploy, select your contract which is code and deploy. So once the contract is deployed we need to grab the contract address, go to Src config js and then we need to paste that contract address here. And next thing we need to do is we need to grab the ABI. So I'm just going to go and copy the ABI and I can paste the ABI here because we need it basically to sign the message and also to send to the relayer of the byconomy that which function to call basically.
03:59:19.280 - 04:00:19.570, Speaker C: So once we are done with that, that's pretty much what we need from the smart contract deployment side. I'm going to stop posting my project to Rem X. Now I'm going to do yarn start to spin up the front end. Before that we need to do a couple of things. So let's take a look into next slides. So basically this is an architecture of how the biconomy works, where the user signs a message and using the metamask and your private key user does not have to have any sort of balance. Then what happens is once you sign the message using metamask, it then makes a post call to the relayer of pyconomy.
04:00:19.570 - 04:01:49.760, Speaker C: And those are the relayers that receive the signature messages and accordingly they're going to go and call the biconomy relay hub smart contract that basically makes a call to the user contract wallet and that user contract wallet has some gas that will execute your smart contract deployed on the medic chain. So which means that the relayer should be filled with gas which is off chain from your main contract because the relayer sends a signed transaction to the blockchain and it is going to pay for the transaction fee as well. And then it's going to figure out from your user wallet whether user wallet has some balance and it can basically pay. So before relayer spending for the gas, it is going to make sure that the user contract wallet has enough gas to pay. Once that check is done, then the relayer will make a transaction and it will indirectly call the contract. So there is a procedure that you need to follow on byconomy if you want your DAP to be registered there and you want to enable your DAP to be metatransaction ready. So let's take a look into that.
04:01:49.760 - 04:02:35.470, Speaker C: So the first thing that we need to do is we need to go and register our DAp. So for that head over to dashboard biconomy IO you will be asked to sign up. If you have already signed up, just click on your email id and just fill up your email id and password. If you have not, then you need to sign up. Make sure you verify from your email id. Once you are done with that and you can log in, the next step is to register adapt. So just click on register.
04:02:35.470 - 04:03:45.670, Speaker C: The DAP name that is I'm going to give is test meta transaction network. We're going to use is matic testnet and click on create. So now you got the API key and that we can go and in our application just replace this key with the new API key and we'll be taking a look into the code in a bit. But let's follow the step. Now all we need to do is we need to add a contract, right? So the contract name is code and let's go and grab our contract address, this guy and the contract binary interface. So this is our application binary interface and we're going to keep metatransaction type as custom, then we can add. So now our code contract is added.
04:03:45.670 - 04:04:48.280, Speaker C: Next we gonna go and manage the API. So which means that we will be making a meta transaction call to set quote meta and this is going to set the quote and we are enabling the meta transaction for this function. So we can now click on add. So that's basically what we need to do as far as registering the DAP on biconomy dashboard goes. Next is we need to start integrating the biconomy's maxa dashboard. So for that we need to install biconomy max dependency which can help us to create a web three provider object that has biconomy in it. And we'll be able to communicate with the registered DAP on biconomy dashboard using this API key.
04:04:48.280 - 04:05:29.670, Speaker C: So whenever the biconomy is ready we can basically have all the initialization logic of the DAP here. If there is an error we can handle it accordingly. So let's take a look into the code. So if we start from app we are declaring a couple of state. So our app starts from here. First it's going to check whether there is a metamask available or not through landmark 48. And then we need to create a biconomy object by passing the metamask web three object as well as API key as an option.
04:05:29.670 - 04:06:52.320, Speaker C: And then we can initialize web three object with biconomy object passing through the web three constructor. So whenever the biconomy is ready we can ask the user to grant an access to this DAP and we can create a contract instance that has the ABI of quote and address of the quote contract. Then we can start the application by calling the gat quote and also by setting the current quote and current owner which we are going to display it in the front end. So if we take a look into how the front end looks like, this is our front end looks like there is no default quote set, there is no default owner because we haven't make any interaction with the deployed contract yet and we have the nons which can get us the nons of the user. So we'll be passing the selected metamask address. We need this in order to sign the data. So we need the domain type, the metatransaction type domain data and we need the message, right? So the message includes from and ons basically.
04:06:52.320 - 04:08:03.746, Speaker C: So we are signing the message and then once the signature is available we are destructuring into RSNV. Once we have that we are making a call to set Metacota but that is making an HTP post request to biconomy and biconomy's relayer and relay hub contract smart contract wallet altogether makes a call to set quota meta, set quote meta and that makes a transaction layer. We're waiting for transaction hash and confirmations. Once this promise is resolved we are printing accordingly on our console locks. If there is an error, we are showing error message as well. In order to show the pop ups on our website we are using react notification library that manages our notifications and then we are having some handler functions for error message, success message and info message. So here we are displaying the quote, then we are displaying the new quote.
04:08:03.746 - 04:08:53.960, Speaker C: This is a submit button so that's what our UI looks like. Now let's go and give it a shot. So I'm going to open up the console just to make sure that everything is working fine. There are no issues. Also I'm going to make sure that matic Mumbai testnet is selected and let's try to get things ready and let me set my first quote. I'll say life is a sport. So I'll be asked to sign a message and non zero of course, because it's my very first transaction that I'm making from this account.
04:08:53.960 - 04:09:45.554, Speaker C: So I'm going to sign it and then they are basically asking me to do a transaction. This is the first time that is required, not always. And once the transaction is successful, you should be able to see the quote here. So we are able to read the quote and this is the owner's account address. Now let me change to another account which has zero matic and it should be able to make a transaction without paying any gas. So let me disconnect this account and I'm going to select this account. Okay, so let me say hello world submit.
04:09:45.554 - 04:10:40.140, Speaker C: So I'll be signing a message. Now this is another user, so that users nonz one, this user is doing the first time the transaction with this contract. So I'm going to sign it and you can see here that it shows that it has got insufficient points basically. So now in order to make sure that it's able to communicate, we need to add this URL to the biconomy dashboard, which we didn't do it. So let's go to view DaP and let's go to configuration. We need to add the URL so it's registered. Let's refresh it.
04:10:40.140 - 04:11:38.970, Speaker C: So currently the owner is this address and this is a current code. Let me run this hello world. Okay so which means that we need to add it the limit which we didn't do it. So go to dapps view DAP and let us add it limit here. So I want number of metatransactions to be like 100 per DAP or we can have it per user per DAP and save it close. Okay let's try to do the transaction again. I'm going to refresh the page and let's give it a shot.
04:11:38.970 - 04:12:24.460, Speaker C: So that's how we can sign message. Okay so let's change the account, connect it. Hello world. So now we can see that the nons is one because this address already made a transaction before. So let's sign the message. So if you're able to see the transaction here, which means that you haven't yet registered your DAP properly, right? So in order to make sure that you can do a meta transaction, you need to register your DAP properly. So let us check.
04:12:24.460 - 04:13:28.640, Speaker C: So this is the API key which is fine, the configuration is also fine and we just have an issue with limit. So let me increase my matic, 200 can save it and number of, I can also change number of meta transaction today to say 10,000 and I can save it. Okay let's try one more time. It shouldn't show us this message again. Okay so make sure account one is selected and let's get the old API. It's the same API. There is only some more details added like whether the function is payable or not.
04:13:28.640 - 04:14:11.470, Speaker C: That basically is required in order to create proper biconomy contract instance. So I'm going to give it a shot one more time. So let's go and check. Let's try to create another DAP instance. So I'm deleting this and I can register another DAP on the matic chain on Mumbai. Let's create it and let's click on view Dap. Let's add the configuration.
04:14:11.470 - 04:15:01.680, Speaker C: The configuration is localhost 4002. Now we can go and add a contract code and let's go and grab contract address from here. This is AbI. So the contract has been added. Now we can manage the API. So this is set quote meta method is right, then we can add it, save it and you can see set quote meta has been saved. We can copy this API key and just replace it here.
04:15:01.680 - 04:15:59.760, Speaker C: And let's try to call this submit and sign. Okay so basically I didn't made any transaction, I just signed it and has now changed a message to hello world which means that even if I have zero matic I can call set quote. So I'm going to disconnect this account which has some matic and I'm going to connect this. So let's see, let's refresh and I'm going to say greek grapes and this is going to be my account address. So let me go and submit it. So again, zero, none. Correct.
04:15:59.760 - 04:16:47.600, Speaker C: So there's a transaction hash. So if you go to Mumbai etherscan.com, this was a transaction hash that is done by the relayer hub of biconomy. So you can see that it's already been changed. Let's wait until this transaction is available. So if you see here set quote meta wasn't transaction that was directly called by the user account, however it was called by this account which is the myconomies relay hub account. So that's basically what a meta transaction is.
04:16:47.600 - 04:17:49.342, Speaker C: Thank you in this lesson and see you in the next lesson. Hello everyone, welcome to another lesson of the Polygon course. My name is Dhruvin Parikh and I am going to be your instructor for this lesson for the Polygon validator node. In this lesson we'll be studying about what is a validator that will include the responsibilities of a validator. We'll be looking into the machine requirements for setting up a validator node, followed by what are the files to download and how to configure it. Then we'll be starting a node and then we'll be following with checking off the locks. So what is a validator? So validator is a participant in the network that locks up the tokens in the network and run the validator nodes.
04:17:49.342 - 04:18:55.650, Speaker C: That basically helped to run the network. So network has a validator which has got some responsibilities and it basically works on the principle of mechanism design, which means that the bad actors are going to get punished and the good actors will get rewarded. Similar principles are applied here. If you want to know more about that principles, you can look into mechanism design and game theory. So the staked network tokens run the validator nodes and they going to join the system as a validator. Once they are staking the tokens they will be earning the staking rewards when they validate the state transitions happening on the blockchain. If they are not behaving fine, they will be facing penalties or they may undergo slashing from the network.
04:18:55.650 - 04:19:54.890, Speaker C: Slashing is an action where a validator is kicked out of the network and the reason could be double signing, validator downtime, et cetera. So let's take a look into setting up a node. So in order to set up a node, there are some minimum technical requirements set by the polygon team. That requires you to have eight gb of ram, 100 gb of SSD and two virtual cpus, each of 2.0 ghz cpu clock cycle. So to start with we will be downloading this repository and we'll be making some configurations to the network in order to run the validator node systems. So let's open up a terminal.
04:19:54.890 - 04:21:01.230, Speaker C: So in this terminal we'll be doing a clone of node ansible repository. So let's clone it. Second, we will be going inside the node ansible repository, right and next step that we going to do is open up inventory YML and we'll be adding the host here. Make sure this host is a separate instance of Linux than the instance in which we are operating. So I'm going to grab the host URL and I'm going to go and insert that URL here. Specify the port as 22. So we are configuring the sentry host and validator host.
04:21:01.230 - 04:22:24.170, Speaker C: Okay, next step is to check whether we are able to communicate with the instance given the host ip address that we just now configured in the inventory YML. So for that you need to run ansible sentry amp ping. So this is a success message. Now if you are getting an error then just make sure that you are adding your secret key, running this command ssh add and then after that you can run SSH agent. So if you are spinning up a Linux instance in the cloud, mostly it will be spinned up with a secret key. So just grab that secret key, grab the path of secret key here and just paste it after ssh add command run Ssh agent and then when you will be checking ansible sentry you'll be able to get a success message. Next step is installing the dependencies.
04:22:24.170 - 04:22:41.150, Speaker C: So all the dependencies are there inside the playbook so we can install all those dependencies, the command for which is available here. So let's just paste this command.
04:22:45.270 - 04:22:45.586, Speaker B: So.
04:22:45.608 - 04:23:49.080, Speaker C: This is a command and can run it. So it's going to take a while until the dependencies gets installed in your remote instance. If you have installed go, then just take care of that part before you run this command. So all you have to do is uninstall go and then run this command. Otherwise you will be running into the issues as per the recommendation from the Polygon team. Let us go inside the sentry node and run pseudo service himdeld start. After that we will be running pseudo service mdeld rest server start.
04:23:49.080 - 04:25:33.750, Speaker C: All right, after that if we want to check the logs then we'll have to run journal ctl umdeld service fake a note that it's going to take a lot of time if you want to sync full of your board node. As per the polygon team, Hemdel usually takes several days to sync to the latest block. So this is how you will be able to see the locks. The way to start the boar node requires this command so you can say pseudo service boar start and let's again run the Himdeld service to watch the locks. So this is how you can basically watch the locks. If you will be keeping on running, you'll be able to see all the updates that happens on the proof of stake validator node network. So that's all about setting up the Polygon validator node.
04:25:33.750 - 04:25:43.610, Speaker C: Thank you for listening to this lesson and we will be seeing you in the next lesson.
04:25:45.230 - 04:26:21.094, Speaker A: Hello all, my name is Patrick Collins and I'm a developer advocate on the Chainlink project. I'm here to talk to you about oracles on Polygon and how to make incredibly powerful hybrid smart contracts. Keep in mind that we are the pioneers of this new world, of this new technology, and it's going to be us and you, the developers, learning about all these tools. Who will be the one to usher in this new age of these smart contracts and these amazing blockchains. So really excited to be talking to everybody today about Chainlink on the polygon network. So let's jump into it. Here's what we're going to be talking about today.
04:26:21.094 - 04:27:41.230, Speaker A: We're going to be talking about the purpose of smart contracts, the oracle problem, Chainlink features. And then we'll start going into some specific examples here. So in order for us to really understand Chainlink and really understand the offering, we first need to understand the purpose of smart contracts. And I know a lot of you already know what smart contracts are for, but we're going to do a little refresher here, because in order to understand Chainlink, we need to say, what is a smart contract? Why are these so important? Why do we care about what these do? And in order to really understand smart contracts, we first want to take a look at traditional agreements or traditional contracts, right? Because smart contracts are exactly what it says in the name, right? They are smart contracts. They are a new iteration of contracts and of agreements. If we look at traditional agreements, typically in these traditional agreements that are written in pen and paper, there is some party that owns the terms of this agreement, of this contract, right? Some institution, some single centralized entity, and often they actually have conflicting interest. For example, if you're an insurance company and you have a contract with a group of people that says if they get hit by a bus or if something happens to them, you're going to pay them out.
04:27:41.230 - 04:28:54.054, Speaker A: But as the group, as the company, you obviously don't want to do that, right? Because you're not in the business of giving out free money. So they have this conflict of interest where they don't actually want to fulfill their end of the bargain. And this has led many times in the past to groups not fulfilling what they said they're going to do. A group or an entity making some promise, making some agreement, and then not delivering. So we have this huge trust, this huge conflict of interest issue. Smart contracts, however, rely on cryptography. They rely on math, right? They allow us to enable, engage in cryptographic agreements where instead of having to rely on the other entity doing the right thing and being honest, all we need to do is rely that math works, right? That our code works, that our code is written in a way that makes sense and that will execute the way that we expect, right? And it will execute the way we expect, because if we write in a contract, one plus one equals two, we don't have to trust that some human being or some entity is going to do the math, right? We can trust that the cryptography of the system, the decentrality of the system will make it so.
04:28:54.054 - 04:30:07.834, Speaker A: So these are incredibly, incredibly powerful agreements, and they really kind of cultivate to this one major idea where we get rid of this counterparty risk, right? We no longer have to worry about these brand based guarantees, these paper guarantees. If you rely or work with some service and they make you all these promises and say, hey, we're going to do this, we're going to do that, and they end up not doing those services in the traditional agreement world, all we can really do is waltz down the street to the next service or the next entity who's going to make the exact same promises. And we have to trust that, okay, well, hopefully these people will actually fulfill the promises versus with smart contracts, we engage in a world of cryptographic guarantees, of math based agreements. We no longer have to trust someone's going to behave honestly. We just know that, okay, one plus one equals two. The code is written to say if this, then that we can trust that the cryptography works and that the math works, and that is much, much easier to rely on than centralized human beings and centralized entities. And we've seen a perfect example of this happen very recently with Robinhood.
04:30:07.834 - 04:30:55.870, Speaker A: Depending on when you're watching this video, of course, Robinhood painted this picture saying, hey, come use our platform. We are democratizing finance. We're allowing anybody to engage in this platform. But they held a centralized key where when push came to shove, if you engaged in finance in a way that they didn't really like, whether or not it was right or wrong, they had the ability to turn off your access to those markets. So they painted this huge picture. They made all these promises, they made all these agreements and what push came to shove, they could not deliver. And so this is a major issue, especially with finance, where if you're using an entity that has this power, you're essentially saying, well, you have control over my ability to engage in finance, to engage in markets.
04:30:55.870 - 04:31:44.158, Speaker A: So not only that, smart contracts obviously have other improvements over traditional agreements like security, guaranteed execution, transparency, this trust minimization piece that we just talked about, and efficiency. So they're amazing. They're an improvement on the current ecosystem of agreements and contracts for a ton of reasons here. But that's kind of the basic gist of it, right? They are this massive, massive improvement over on reliability, accountability in our agreement world now, however. So these smart contracts are fantastic, but they come with a fatal flaw. They come with an issue, right? And this issue is known as the oracle problem. So what is the oracle problem? What's up with these smart contracts? What's the issue? We just found out that they're these amazing things.
04:31:44.158 - 04:32:55.634, Speaker A: So what could possibly be wrong? Well, these smart contracts and these blockchains, these smart contracts, they run on the blockchain, obviously, and the blockchains have these issues, though. Blockchains themselves are deterministic, meaning they can't reach out to the real world, they can't connect to the real world. They can't use any variable nondeterministic data inside their systems. Now this is obviously a huge issue because if we want these smart contracts to be these superior agreements, then how are they going to do that if they don't even know what's going on in the real world? How are you supposed to create an agreement that doesn't care about the real world? How are you going to create an agreement that's supposed to affect the real world when it knows nothing about it? Right? So that's obviously a, a massive issue. And one of the questions that gets asked a lot is, okay, well, why can't they just make an API call? Why can't they just connect to the real world? What's the deal? And again, the issue here is that they are deterministic right. Variable data can't work, can't live in these deterministic systems. It'll break consensus if you ask one node, hey, can you make an API call to some random API? All the nodes will go, yeah, sure, we can do that.
04:32:55.634 - 04:33:41.886, Speaker A: One node will make the call and maybe another node gets rate limited, maybe another node gets a different answer because they called it a second or a half or a millisecond later and the answer changed. Or maybe you want some random number and each node is going to have a different idea of what a random number is. They're never going to be able to reach consensus with nondeterministic data. So blockchains by design are deterministic, and it's one of the major security properties of these smart contracts and of these blockchains. Excuse me. So how do we solve this? How do we get around this? And the answer is with a blockchain oracle. So a blockchain oracle is going to be any device that interacts with the off chain world to provide external data and computation to our smart contracts.
04:33:41.886 - 04:34:33.060, Speaker A: Okay, great, we solved it, right? We did it. We have these blockchain oracles, case dismissed, right? Not quite. That's not quite the whole story. So a centralized oracle is going to be a single point of failure for your smart contract, for your application. You've done all this work. If you've built a decentralized protocol on polygon to make this logic layer truly decentralized, and then you have a single centralized node or a single centralized data source, you've essentially done a ton of work to remove that centralized key away from a party, and then you just reintroduced it by adding this centralized node or a centralized layer. So having a single node or a single data point reintroduces this centralized piece and is no bueno, it's no good, right.
04:34:33.060 - 04:35:24.210, Speaker A: We want to make sure both our logic layer, our on chain settlement layer, and our off chain data and external computation layer are both truly decentralized. And that's why a centralized node is going to be no good here. So this all comes down to the solution here, which is going to be Chainlink, which is a decentralized oracle network. Chainlink is a modular framework which allows users to build networks and work with external data and external computation in a truly decentralized fashion. So you can get data, you can do event based triggers, you can get random numbers, you can do all these. Fantastic. You can kind of have all the feature richness that traditional agreements and traditional web applications have in the context of a decentralized smart contract.
04:35:24.210 - 04:36:50.640, Speaker A: And this gives rise to something called a hybrid smart contract, where you have a contract that has some off chain component, whether that's working with external data, enterprise system, traditional payments or what have you, and then your on chain contracts, which again, here is going to be on polygon to enable us to once again engage in the censorship resistant decentralized finance, nfts, gaming, death, et cetera. Some examples are going to be, for example, weather insurance or insurance here. In order for you to build an insurance contract, which there are plenty of those in the real world, you're going to need to get the data on whatever you're insuring, right? So if you're insuring crop insurance, for example, you're going to need the rainfall, the temperature, any other product evaluators. That's going to need to go through a decentralized network of chainlink nodes to go to some on chain contract, which then you can build an insurance protocol out of that deFi, obviously massive. A vast majority of these protocols you see here are using chainlink in some capacity to price underlying collateral or do some type of computation or get some type of data NFTs gaming. I mean, the use cases go on and on and on. Maybe you want a random number to create some really verifiable NFT, or you want to do some random attack stat for some character, but the use cases go on and on and on.
04:36:50.640 - 04:38:03.030, Speaker A: So with that being said, let's talk about some of these out of the box solutions, right? So Chainlink is a technology that is completely customizable, right? And we can take it and we can do whatever we want with it. But there are some features that are pretty much ready to go out of the box, where it takes almost no configuration. From our end, we can hit a button that says go, and we can get our smart contract set up with some of these incredibly powerful features that we just talked about. One of the main ones, one of the biggest ones, one of the most powerful ones is going to be the chainlink data feeds, or the chainlink price feeds. And these are currently powering over $50 billion. In the decentralized world, they're currently helping secure more than $50 billion, which is absolutely insane. What are these? So these price feeds? These data feeds are using off chain data in a decentralized context from many different exchanges, many different data providers, sending them through a network of chainlink nodes, each also, again, decentralized, putting them onto some price reference contract or some reference feed that allows these protocols to read this data, to read this pricing information for their protocols.
04:38:03.030 - 04:39:03.450, Speaker A: Here's a visualization of what the current, most up to date version of these data feeds look like, which is called off chain reporting, where as you can see here, all the different nodes are going, they're making these API calls, they're reaching out to these data providers, these high quality exchanges and et cetera, getting the price of some asset, like maybe FuSD or Matic USD for example, and they're reaching a consensus off chain. And then they send in a transaction with all the nodes having signed their data to a smart contract for other smart contracts to read and to pull from. And here's a visualization here. We can even go to data chain link here and we can see if we click on one of these. This is on ethereum, but let's go to Polygon actually. So let's do matic USD. We can see a group of nodes here that are delivering this data.
04:39:03.450 - 04:39:52.006, Speaker A: Each one of these nodes is a different entity and they're pulling this data from the real world, delivering it on chain so your applications can use the data for whatever you want. And these data feeds are being used by some of the largest defi protocols in this space. Synthetics for example, for pricing underlying collateral sushiswap for doing margin trading, compound again, underlying collateral aave for depositing and lending. And I think some of these numbers will probably be outdated by the time you watch this and be a lot higher. So these are really battle tested, pricey, battle tested data that you can use to empower your smart contracts. And at the end of this session, towards the end, we're going to do some examples, like I said. So don't worry, hold tight.
04:39:52.006 - 04:40:20.174, Speaker A: We're getting there. But the documentation in DocstartChain link has a wonderful one click option where you can just click a button and go right into a remix ide. We'll also go into hardhat as well. Stay tuned for that. But documentation is absolutely plentiful if you're looking how to work with these price feeds. So that's the first one. That by itself is already incredibly powerful.
04:40:20.174 - 04:40:51.222, Speaker A: But there's more. Yes, I know, crazy. There's more. Chainlink vRf or chainlink verifiable randomness function is absolutely massive. Chainlink VRF enables provably fair selection processes, provably fair random numbers. As you know, as we've talked about, these blockchains are deterministic and by definition a deterministic system can't have a random number, right? It just doesn't work out. How can you have a random number when you already know what that number is going to be, it's not possible.
04:40:51.222 - 04:42:00.642, Speaker A: So in order for us to get a truly random number in our blockchain applications, we do have to look outside the blockchain. Once again, Chainlink has a process of delivering a cryptographically proven random number into our smart contracts so we can use this randomness to power whatever we want. So for a lot of you who are learning solidity, oftentimes what people will do is they'll use some pseudo random number, pseudo random generator where they hash maybe the block difficulty or the timestamp and all those numbers. Anything on chain can be influenced by miners, can be hacked, can be adapted, and so it's not going to work if you want any type of secure randomness. So Chainlink VRF gives us that provably secure randomness, that proven scarcity, those truly, truly random numbers. And if you want, you can check out the GitHub where you can check out the on chain contracts that go through the verification process of proving cryptographically that a number is truly random. And this chainlink VRF is being used by a number of protocols pool together, being one to give out this decentralized random winner for their defi project.
04:42:00.642 - 04:42:32.542, Speaker A: Tons and tons of nfTs, Avagochi, zxe, Infinity, ether cards, Pokemon are all using this chainlink VRF to get provably random stats for their nfts. Provably random drops, provably random giveaways, raffles, et cetera. And again, one click documentation again, we'll head over to those at the end of this. But really fantastic docs and everything you want to know to use them. You can jump right in the docs there. Next. Oh man, there's more.
04:42:32.542 - 04:43:17.962, Speaker A: I know, crazy, right? Chainlink keepers or the Chainlink keepers network for decentralized event driven executions. As we know, smart contracts actually can't trigger themselves. When we want a smart contract to do something, we or somebody has to initiate some transaction, right? You need to pay some gas to make a state change on the blockchain. Somebody has to do this. Now, we could of course have some cron job or some server off chain doing this, but again, guess what you're introducing when you do that? A single centralized point of failure. If your server goes down, if their server goes down, you've now ruined the decentrality of the application. Or maybe somebody's malicious and doesn't want to trigger your server, you've ruined the decentrality of your system.
04:43:17.962 - 04:44:15.114, Speaker A: So smart contracts can't trigger themselves in a decentralized context until now. So Chainlink keepers allows us to have smart contract applications that trigger that do some type of decentralized event based computation. So on any trigger you can think of, maybe it's a timestamp every ten minutes run this function, maybe it's changing liquidity. Once a price of an asset reaches a certain price, maybe you sell it for a short sell or a stop loss or to rebalance a portfolio, whatever you want to do, Chainlink keepers can trigger that event in a decentralized context, which is absolutely insane. And similarly, there are some fantastic docs on this. This is kind of a really nice GIF walkthrough of working through the user interface to add yourself to what's called the registry contract. This is the contract that all the chainlink nodes are listening to off chain.
04:44:15.114 - 04:44:59.446, Speaker A: They're listening for any new upkeeps to happen, right? They're waiting for those events to trigger. Once the smart contract is registered with this registry, all the keeper nodes will be watching this keeper registry. And this is an easy way for you to connect to that registry. And then last but not least, Chainlink API calls for unlimited customization. So as we know, like I said, those three first ones are kind of the out of the box, ready to go, already decentralized, good to go applications. But like I said, you can really do anything with Chainlink. You can really empower and elevate your smart contracts to have any type of functionality, any type of customization.
04:44:59.446 - 04:45:56.718, Speaker A: And to do that, you can do that with the Chainlink API calls. So this will connect your smart contract to all the traditional APIs and services that the web uses today. So you can configure your chainlink nodes to work with the real world. Now this application does take a little bit more work in order to be truly decentralized, because again, a single node configured to make these API calls isn't necessarily sufficiently decentralized. So there is some extra work that goes into this to have to work with other nodes, to collaborate. But 100% this feature enables you to customize your smart contract in really any way that you want with a little extra legwork. And that's really the end to end reliability of smart contracts and of what the Chainlink protocol is all about, taking these smart contracts and elevating, heightening them to the next level to enable them to do anything that they want to do.
04:45:56.718 - 04:46:44.526, Speaker A: And if you have some really cool ideas on how to elevate it, you can always get a grant, you can always jump into the Chainlink discord to the chainlink networks and reach out and contribute or build something really cool. Now, we are going to go into these remix and hard hat demonstrations. But before we do that, I do want to talk a little bit about where you can go to learn where you can go to participate in the chainlink network. And then we'll jump right into those remix and hard hat examples and show you how to build some of these incredibly powerful billion dollar defi protocols and billion dollar NFT projects, et cetera. So the first place that everyone should know about is docs chain link. This has everything that you're going to ever need to know about Chainlink, about documentation, how to work with literally everything. Next blog chain link.
04:46:44.526 - 04:47:22.154, Speaker A: Tons of fantastic blogs, tons of fantastic tutorials, how to do option trading, how to set up with hard hat, how to do dynamic know. The list goes on and on and on. The chainlink, YouTube, Chainlink engineering tutorials and developer workshops. Those are the two main playlists. You can watch us literally step by step, go through a lot of these processes and work with a lot of these tools. Solidity and smart contract starter kits. If you're getting into the framework world with brownie, hardhat, truffle, et cetera, we already have some boilerplates built for you that you can take and that are good to go and ready to just be forked and worked with.
04:47:22.154 - 04:47:54.514, Speaker A: And again, we're going to be working with hardhead today. But if you're familiar with brownie and truffle, you can absolutely use those as well. And then absolutely 100%, you can always join the community. You can jump in, have conversations, reach out and talk to people. So some of the best places to get technical support are going to be on stack overflow or stack exchange. Ethereum asking a question, tagging it chain link, that will give more site to pretty much the whole community with your question. And anybody who's helpful can jump in and help you out there.
04:47:54.514 - 04:48:31.214, Speaker A: The Chainlink discord. You can jump in for kind of more spitballing, theorizing, and chatting with other members of the community. Of course, there is the GitHub with starter kits that you can kind of just fork from and get going and learn more. And again, if you have an idea of how to contribute, Chainlink grants is there, and the chainlink labs will actually pay you to build some really cool advancement or feature that you want to work on. And then, of course, the documentation, which is just absolutely massive. So with that, thank you very much, and let's jump right into those examples. All right.
04:48:31.214 - 04:49:10.410, Speaker A: So let's go ahead and get started building some of these hybrid smart contracts on the polygon blockchain. Now, we are going to do some integration tests where we actually simulate running one of these smart contracts on a real polygon mainnet by using what's called a testnet or a fake blockchain. Now, in order to use this fake blockchain, we need a wallet to interface with this blockchain. And the wallet that we're going to be using is going to be metamask. So if you don't have metamask, you want to head over and download it here. We are going to be working with Testnet, Ethereum, Testnet, Polygon, Testnet, Chainlink. So no real money will be in this wallet.
04:49:10.410 - 04:49:44.230, Speaker A: A quick wallet tip. Once you do get this set up, absolutely don't send any real money to this. Whenever you're developing and whenever you're testing, you want to be testing with a wallet that doesn't have any real funds in it. So you can come to the metamask site to get metamask set up. Once you do, you should see a little fox icon right up in your browser. And this will be the wallet that we're going to interact with and work with, to work with the polygon chain and work with Chainlink and different testnets. Now, to get started, though, we're going to be working with the coven test network.
04:49:44.230 - 04:50:25.858, Speaker A: All the code that we work with here is going to be exactly the same as if we're working on Polygon, except for some configuration differences. So we're just going to be working with Coven Testnet here. But after we go through a couple of these demos, I'll show you how to go ahead and get metamask set up with polygon so you could deploy these smart contracts to the polygon mainnet, to the polygon main chain. So with that being said, let's jump into some of these out of the box applications here with chainlink. Again, everything that you need to know about working with these contracts and about getting started is going to be docs chain link. This is your starting ground. This is ground zero here.
04:50:25.858 - 04:51:05.342, Speaker A: And the first thing that we're going to look at is actually working with these data feeds. But if you want to play around and you want to see some of these other tutorials, for example, the basics tutorial, there's a video along with it, will help you get set up with metamask. We'll help you deploy your first smart contracts. We'll help you really just get started with this entire space. If you want to learn more about how Chainlink works about the different models, the basic request off chain reporting, you can check it out here as well. But like I said, we're just going to jump into learning about getting the latest price here. So if we come to getting the latest price, we'll learn a little bit of information about what this code looks like, what this code is doing.
04:51:05.342 - 04:52:21.098, Speaker A: And if we scroll down we'll see this exact code here, which is everything that we're going to need to actually work with one of these data feeds and get the price of a real world asset into our smart contracts. We can absolutely copy paste this into whatever editor we want or we can go ahead and come down, we can click this deploy button, this remix button which will pop us into remix with this code already populated over here. And if you don't see it on the side, on the left here, you should see something like docs chain link, you click it, samples price feeds will be here and price consumer v three sol will be what you're looking for. Now let's go through what this code is actually doing, what's going on here? So at the top of course, we have our solidity version. We're importing the chainlink aggregator code here which is going to allow us to have the interface to work with these price feeds where we have our contract name here we have a variable called price feed of type aggregated v three interface which again is just the data feed. We have our constructor which here is some really important pieces, right? And this is really the only piece that we'll ever have to change. When we switch networks on each network, these data feeds live at a different address.
04:52:21.098 - 04:53:07.154, Speaker A: So if we're on the coven testnet, if we're looking for the Ethereum USD price feed, this is the address of that data feed. Now we can come here, come to our documentation, go to contract addresses under the data feed section and we can see data feeds across different blockchains. Again. Since we're going to be working with Polygon, we could scroll down here and we come and grab any of these addresses on the polygon chain and use it in our smart contract. And if we click one of these addresses, it'll even bring us to the explorer and it'll bring us to the exact contract that those feeds are being updated on, which is incredibly exciting. So if we wanted to change addresses we would come here again. We're going to be working with COVID just for this testnet demonstration.
04:53:07.154 - 04:53:58.466, Speaker A: So we're going to leave the address as is. Then we have a function get the latest price, which all we're really doing here is we're getting this int price value here, which is going to be the price of Ethereum in terms of USD. So all we have to do is compile or hit command s, control s or whatever save is. We can come down to deploy, we'll switch to injected web three and this will inject our metamask as our wallet provider. Now to work with this again, you do have to be on the coven chain and you do need some testnet Ethereum here. If you don't have any coven testnet Ethereum, what you can always do is in the chainlink docs, you can go to the link token contracts page which is right here, and you can scroll down to whatever testnet you're working with, for example Covid. And there's usually a link to the most up to date faucet.
04:53:58.466 - 04:54:22.480, Speaker A: So if you need some test on Ethereum, you can click the test on Ethereum button, it'll bring you here. This one actually gives us both link and eth, which is great. We're going to copy our address, we're going to place it in here. I'm not a robot, those are taxis. Send request. And what's going to happen is we're actually going to get funded ten testnet link and 0.1 testnet eth to our account.
04:54:22.480 - 04:55:02.134, Speaker A: We will have to wait a little bit as the blockchain goes ahead and validates our request. But once it's done, it'll say it's all done. And if we look into our wallets, this number and this number will be increased, right? So if you don't have the link token already in your wallet, you can scroll to the bottom, hit add token and we'll just need this link token address again. They're going to be different across different test nets. So for Covid it's going to be this address here. So we'll go into metamask, we'll hit add token, paste that address in. I've already added it, but if you haven't, you hit next and then it'll show up right here in your metamask.
04:55:02.134 - 04:55:34.742, Speaker A: So you should have some testnet eth. You don't need testnet link for this specific demo, but in the next ones you absolutely will. So now that we have some testnet eth, we have the gas we need to pay to deploy this contract. What we can do then scroll down, change to the price consumer and go ahead and deploy this contract. So this is going to deploy it to a real coven testnet, right? We're simulating as if we're deploying to a real main net, right. The difference here is that this is fake eth, this is fake money. There's no actual value here.
04:55:34.742 - 04:56:23.174, Speaker A: But then we can go ahead and hit get latest price and we get a response. Now you might be saying, oh, why is that such a weird number? Why is it so weird? And this is because, as you know, solidity doesn't work with decimals so well. So this number actually gets multiplied by a large number. And we know that this one actually has eight decimal places. And you can see both in the documentation. And there's a function called decimals that you can call to get the number of decimals each one of these feeds has. So for example, if we go to Ethereum data feeds, we look for FUSD, we can see that it has eight decimal places, so that we know that this number is actually 3597 here.
04:56:23.174 - 04:56:23.734, Speaker A: And.
04:56:23.772 - 04:56:24.070, Speaker B: Perfect.
04:56:24.140 - 04:56:57.840, Speaker A: That's exactly how you did this. Now, if you wanted to deploy this to the polygon main net, you absolutely could. This code will work on the polygon main net the exact same way. I'm not going to actually do that here, because again, I don't want anybody who's watching this to use real funds with a wallet that they're just testing with, just in case you accidentally do something silly with the wallet here. But what you would do is you'd come to your metamask. Let's go ahead and we'll do expand view so we can see everything a little bit nicer. We'll go ahead and leave remix here.
04:56:57.840 - 04:57:25.100, Speaker A: And what we do is we'd come to our networks and we'd hit custom RPC. This is how you add a new network to your metamask. So we'll add polygon in here for a polygon URL. We can actually find that in the polygon documentation. Whoopsie daisy. Add network. There we go.
04:57:25.100 - 04:57:56.850, Speaker A: Polygon. We can come to the docs, polygon technology. We can come to the docs and we can get all the information that we need to actually get this set up here. We can do polygonrpc.com. The chain id is going to be 137, currency symbol is going to be matic. Block Explorer is going to be polygonscan.com. And then we'd go ahead and hit save.
04:57:56.850 - 04:58:46.120, Speaker A: I already have this network up under Polygon, parentheses matic. But this is how you would get it set up. Once you have this set up, you should be able to see in your metamask here, you should be able to scroll down and have this polygon account. Again, you won't have anything in here. There won't be a faucet for this because this is real money, this is real polygon, but it should be in your wallets. Once you have that, we can actually just roll back over to deploying this with remix. And all we would need to do is switch our address, right? So if we're working with the polygonmatic data feeds and we want to do, let's say matic USD, we would grab this address here, copy it, and in remix, all we would do is we would change this.
04:58:46.120 - 04:59:29.618, Speaker A: We would say polygon in our comment here, polygon, this would be matic USD and we paste the address here and that's it. And then we could compile, we could deploy this injected web three. Again, I'm not actually going to because I don't have any matic to actually deploy with, but this is how you would go ahead and deploy to the polygon chain for working with a data feed. So next, let's go on to chainlink VRF. So I'm not going to show you how to set up polygon for each one of these ones moving forward, but the process is going to be the same for all of these. So Chainlink VRF is actually a two transaction process. Again, there's a whole bunch of notes here.
04:59:29.618 - 05:00:14.702, Speaker A: We're just going to go ahead and scroll down to the remix button that we can go ahead and click and get started right in here. Docs of chain to link samples VRF random number consumer sol that's what we're going to be using. And this is a two transaction process, like I said. And let's actually just flip back to Covid because for this example, we're just going to use Covid again. So for this one you will need testnet eth and testnet link. So be sure to follow along those instructions I gave before of going to the chainlink docs, going to the link token contracts page and grabbing that coven faucet and getting both link and eth into your metamask here. So eth link testnet.
05:00:14.702 - 05:00:59.578, Speaker A: Awesome. So let's talk about what's going on here. So we have our version, we're importing some chainlink code from the chainlink GitHub and we're inheriting this VRF consumer base bit. So this VRF consumer base bit allows us to define two really important addresses. Right, because when working with the chainlink VRF, there's a contract on chain that's actually going to do the verification of our random number. And right in our constructor, right afterwards we add those addresses, we say, all right, constructor of the VRF consumer base is going to use the VRF coordinator, and this is the address of the contract that does that verification. Again, it's going to be different on different chains.
05:00:59.578 - 05:01:53.962, Speaker A: And then the address of the link token. Now, similarly to transaction gas that we pay whenever we make a transaction, when making a request to a chainlink node, we pay a little bit of oracle gas or link token. Now, the reason that we pay for the chainlink VRF and we weren't paying for the price feeds is that the chainlink VRF, we're actually directly requesting the data. The price feeds are actually supported and sponsored by a number of projects who are paying a lot of the request data. So if we scroll to the bottom of something like data chain to link, all these protocols here are paying to help support these different price feeds. So that's kind of the difference here. So we're doing a direct request to a chainlink oracle to say, hey, can I get a random number please? Then we also define a key hash which uniquely identifies one of these oracles and the fee of the chainlink VRF.
05:01:53.962 - 05:02:19.962, Speaker A: It varies by network. You can find all this information if you go to using randomness contract addresses. And you can find all the information here. Polygon is right at the top. You can find the link token address, vrf coordinator key hash, and the fee that goes along with requesting the service. Now for the moment of truth, get random number. This is the function that we call to request a random number.
05:02:19.962 - 05:03:02.422, Speaker A: And all we do is we call this request randomness function. Well, first we just make sure we have link in the contract, but then we just make sure we have enough link to pay the chain link node. But after we do that, we call this request randomness function. Now, you'll not see it defined anywhere, and that's because we're actually inheriting it through the VR of consumer base. But what this will do, and we pass it the key hash and fee. What this will do is it'll ask a chainlink node to give us a random number. So in one transaction we're going to call this function, and then in a second transaction, the chainlink node itself is actually going to call fulfill randomness and give us a random number called random result.
05:03:02.422 - 05:03:20.570, Speaker A: So same thing. We can go ahead and compile this, we'll go ahead and deploy this. We'll move to injector web three. We want to be on coven. We'll need both eth and link in our wallet. We'll scroll down to random consumer, we'll deploy. Metamask will be like, hey, you sure you want to deploy? We'll say, we absolutely would love to deploy.
05:03:20.570 - 05:04:04.682, Speaker A: And then we'll scroll down and we have our contract here. Now if we hit random result right now, it's going to be zero, right? And this makes sense because we haven't requested a random number yet. However, if we hit get random number now, we'll actually get this gas estimation failed error. And the reason for this is that this contract doesn't have any link token to pay the oracles. So the contract has to have the link token, not the user who's calling the function. So what we need to do is we need to copy this address with that little copy button, come into our metamask, hit send, paste the address of the contract, scroll down to link, and then send this some link. We're going to send it one whole link.
05:04:04.682 - 05:04:44.470, Speaker A: That's definitely overkill, but why not? So we're going to send this contract one link. And again, you're starting to see why doing a lot of this in hard hat is going to be a lot nicer, because it'll automate that whole funding process. And once that goes through, we can then call this get random number function. And metamask does indeed pop up this time. So now we're going to go ahead and confirm, and again, before we actually send it, the price is going to be zero. Now we actually have to wait two transactions. So even though you might see remix, say, hey, that transaction has gone through.
05:04:44.470 - 05:05:21.682, Speaker A: That's just the requesting transaction. This is following what's called the basic request model of working with Chainlink. In a single transaction, we request some data, and then in a second transaction, we get the return of that data or computation. In this case, it's data and or computation, depending on how you look at getting a random number. But what will happen is after a couple minutes or maybe a few seconds, we'll see this random result update after we press it. So we do have to wait a little bit. And as you can see now we've got a return here of a truly provably random number.
05:05:21.682 - 05:05:57.600, Speaker A: And that's how you work with Chainlink VRF. Now, we're not going to go over Chainlink keepers because Chainlink keepers isn't on the polygon chain yet. However, I'm sure if you stay posted. Maybe that'll change soon. You can, of course, like I said, configure your chainlink nodes to work with any API and any URL that you'd like to work with. And if you want to do that, this is the code here on how to do that. Now let's go ahead and jump over to working with hardhat in our text editors here.
05:05:57.600 - 05:06:50.040, Speaker A: So in order for us to work here first, the text editor that I'm using is called visual Studio code, and you can download it from code Visualstudio.com. Just please note, this is different than visual studio. This is visual studio code. It looks like this, it's a little bit different. And this is the text editor that I'm going to be working with. You can work with what's called a terminal right here to work with all of our code and everything that we're going to be working with here. Additionally, you'll need Node js, node js installed and also yarn yarn install.
05:06:50.040 - 05:07:34.542, Speaker A: You can see if those are installed correctly by doing node version and yarn version. If you have both of those installed, you should be good to go. So what we're going to do though is we're going to create a new folder for our project here. I've already created a new folder called Polygon ETB, but if you want to create a new folder, you can do Mkdir, Polygon ETB, or whatever you want to call it. And we're going to clone our starter repo. So we can actually just google Chainlink hard hat starter kit and it actually just popped right up. Or you can just come right to the smart contract kit GitHub and it'll be a pinned repository.
05:07:34.542 - 05:08:08.398, Speaker A: There are a couple in here like the Chainlink repo itself hard hat starter kit, a full python blockchain course, external adapters, the truffle starter kit, and the brownie starter kit. So what we can do is we can grab this URL and we're going to go ahead and get clone it. Actually, I forgot to mention that you also need to download git. If you don't have git, you can download git with this right here, and you'll know you have it installed if you do git version. So once you have it installed, we can do git clone paste it in.
05:08:08.404 - 05:08:08.960, Speaker C: Here.
05:08:11.090 - 05:08:55.134, Speaker A: And this will go ahead and download everything in the hardhat starter kit for us. And if you're working with visual studio code, you can go ahead and open this up and see it in our little sidebar here. What you'll do is you'll go file open and wherever this folder is you can just go ahead and hit open and vs code will go ahead and pop right up and start and open this up for you. Great. So let's do a quick walkthrough of what is in this repository. What's with this code? So our contract section has all the contracts that we need. It has our API calls, price feeds, random numbers, anything we want to work with there.
05:08:55.134 - 05:09:28.086, Speaker A: It has a deploy tab which allows us to deploy our contracts and specify how we want to deploy them. It has some tasks which we can call which we want to get the balance of something we want to withdraw, some link we want to read a price feed, et cetera. And then we have our tests as well. Additionally we have a sample env which we'll talk about in a minute. We have some linting folders. You can ignore these git ones for now. It has this cute, adorable little logo.
05:09:28.086 - 05:10:08.834, Speaker A: And then it has some important files called the Hardhat config and the hardhat helper config which we'll talk about in a second package. Json and yarn lock. So the first thing we're going to want to do here is we're going to want to install all the dependencies for this code with a yarn or a yarn install. Or if you prefer NPM, you can also do NPM install. Awesome. Now that we have everything installed, we can actually go ahead and start testing and working with a fake, a faster blockchain called the hardhat runtime environment. This is a way for us to test our code and test our contracts in a custom setting.
05:10:08.834 - 05:10:54.974, Speaker A: So what we're going to do is we're going to do MPX hardhat node. And what this will do is it'll start up a fake blockchain running on our computer, running in our terminal right here. And it runs through what's called the deploy scripts. So everything in our deploy scripts here it sets up for us and it runs through all these scripts that are in here. So the first thing that it does is it actually deploys what's called mock contracts to our fake blockchain here. So this is how it deploys the mocks. But when we're working with a testnet, there are price feeds, there are VRF coordinators, there are oracle contracts, but when we spin up a fake blockchain, those don't exist.
05:10:54.974 - 05:12:14.094, Speaker A: So this deploy mocks contract deploys a fake price feed, a fake VRF coordinator of mock a fake oracle contract so that we can actually work with them and pretend that we're actually working with a real blockchain. So once we have those mocks deployed, we actually go ahead and deploy a price feed contract, which this is the script that does that. We also deploy an API consumer, we also deploy a random number consumer. And then we do this setup contracts script in JavaScript which will fund our VRF and our API calls with link so that we can actually make those API calls. We can do that basic request model functionality. And in the output of running this node, running this fake blockchain, there's actually some commands, right? It actually runs through all those scripts and has all the print outputs here. So for example, if we wanted to read from this fake chainlink price feed, we go ahead and run Mpx hardhat, read price feed, the contract address and the network and I can even copy this, open up a new terminal with that little plus button, paste this command in here and exactly like if we hit that read price button in remix, we get the output here, right? Price is 2000 or whatever this number is, right.
05:12:14.094 - 05:12:56.714, Speaker A: And again, because this is a mock price feed, this is a price that we've actually gone ahead and set. Now this is incredibly powerful because it means we can test our chainlink smart contracts much quicker, right? We don't have to wait for transactions to go through. We don't have to wait for chainlink nodes to respond. Everything is happening locally right in front of our eyes if we have our fake networks spun up here. So that's going to be a huge, huge advantage for running these. And it makes running your tests a lot easier because what we can do if we look at our tests here is we can work with these mocks and run our tests without having to actually, again, wait for transactions to go through and wait for everything to go through. So really incredibly powerful here.
05:12:56.714 - 05:13:46.230, Speaker A: And I'm going to go ahead and quit it with control c and we're going to go ahead and close this. So we just have one terminal. Now if we do want to deploy these to a real testnet, right, if we want to deploy them to a real testnet or a real main net, we can absolutely do that as well. And that's where our hardhat helper configs come into play. So there's a lot of stuff in here, I know, but right at the top, this is where we have a lot of the main pieces, a lot of the main components that we're going to be working with. So if we want to deploy to coven, we need a coven RPC environment, variable and we have this line of code here says required env config, which means it's going to pull from a env file. Now, this is an example of a env file.
05:13:46.230 - 05:14:33.210, Speaker A: So it's env example. But what we'd want to do to actually deploy something is we'd go ahead, we'd make a new file called env. We'd want to paste it in here, and we'd want to change some of this, right? So if we wanted to work with COVID we would get a coven RPC URL from infuria or from alchemy, whatever we want to do. So if we wanted to get it from alchemy, we go to alchemy. We could log, right? Log in, sign up, and you'll get an API key that looks just like this, right? And so for coven RPCRL, you'll just paste that in right there. We're not going to work with mainnet for the time being. And then for our private key, this is where you'd come to your metamask.
05:14:33.210 - 05:15:22.026, Speaker A: You'd go to account details, export private key. You'd put your password, and then you'd grab that private key that it gives you and you'd paste it in here. Now, just to note, metamask typically doesn't add the ox at the start, so you'd want to add a zero x at the start and then the rest of your private key. Once you have these in a env, remember, the private key gives whoever has that private key access to your wallet. So this is why I always say, don't use a wallet for testing and for developing that has real funds in it. Make sure that you're very careful and you don't push these up to GitHub, et cetera. In our git ignore file, there's a env.
05:15:22.026 - 05:15:54.114, Speaker A: So this folder should help protect you from accidentally pushing this up to a GitHub here. Now, you can use your private key or your mnemonic. And your mnemonic is actually going to be, if we go in here, we'll go to account settings, security and privacy reveal secret phase. That's going to be your mnemonic. Or you can just do the private key like we just said. But if you want to do your monarch, you could add that in here. We're going to be working with the private key for this demo.
05:15:54.114 - 05:16:36.286, Speaker A: And to work with the private key, we actually have to come to our hardhat config js, scroll down to Covid, and we're going to swap out this accounts section. So we're going to actually comment out all this part and uncomment this part. So we want our accounts to be coming for our private key instead of our mnemonic. And this is the syntax for how to do that. But once we have these two environment variables, your coven RPCRL and your private key, we can actually go ahead and deploy and work with and deploy to a real testnet or a real main net if we want to deploy all these contracts. Right. Our API consumer, our price fee consumer, our random number consumer to the coven network.
05:16:36.286 - 05:17:23.514, Speaker A: What we'll do is deploy network coven, and this again, it'll run through all of our deploy scripts and it'll deploy everything. Now it also, and this is where a hardhead is. So fantastic as this is deploying here in our config, in our helper config, excuse me, there is a fundamental parameter for each network, and Covid is on 42. So for fundament, for the VRF and the API calls, it's going to automatically fund it with this much link. That seems like a lot, but it's in way, so don't worry. This is actually 1234-5678-1234-5678-9 ten. This is actually one link per contract.
05:17:23.514 - 05:17:26.526, Speaker A: So it's going to fund with one link. Right from your metamask.
05:17:26.558 - 05:17:26.706, Speaker B: Right.
05:17:26.728 - 05:18:27.730, Speaker A: And again, remember, you need to have both ETH and link in your metamask so that you can actually deploy here. And it knows to use this fund amount because again, in our deploy scripts here, for example, for random number consumer, we have a little bit in here because in our setup contracts, again, we have this auto fund check which checks to see if we should fund this contract with link. And we do want to fund at least the random consumer. For example, with link, once you've run this script, you can actually scroll up and you can see again a whole bunch of these other scripts to help us interact with these contracts. For example, if we wanted to read a price feed, we copy this MPX hardhead, read price feed, contract, blah blah, network, coven, paste it in. Boom. Price is right here, the exact same as if we were pressing that price feed button if we wanted to request a random number, copy paste MPX request random number contract, blah blah blah, network, Covid.
05:18:27.730 - 05:19:15.806, Speaker A: And this will go ahead and it'll hit that request randomness button similar to what we did in remix. Now, again, it gives us a little output here saying, okay, great, you've gone ahead and requested this. Now in order to read that random number back here's the function that you're going to call. And if we call it now, it probably won't have responded by now, right? It hasn't responded by now because again, we do need to wait for those transactions to go through. But this is how we can actually interact with all of our contracts and interact with everything. But now that I've waited for it to go through, we can now see random number is and then this huge, massive random number. And this is all kind of in this deploys and in these tasks that we've created for this hardhead starter kit.
05:19:15.806 - 05:20:18.694, Speaker A: So this is a way we can build our test suites, do everything that we need to do in a text editor that we are familiar with. We can also run all of our tests, our entire test suite on one of these stake blockchains on this hard hat runtime environment by just doing NPX hard hat test, and it'll show you the output of running your tests. So this is how you can test all your smart contracts that are using chainlink locally. And finally, of course, if we want to deploy all these to the polygon chain, we're going to have to go into our configs to add these different pieces. If we go to our hardhat config js, you'll see that there's already some polygon pieces in here, right? There's a polygon mainnet RPC URL variable. So if we go to our env the exact same way we made the coven RPC URL, we would copy and paste this, we would add a polygon mainnet RPCrl. We'd scroll down, we can see the name of this network is actually polygon.
05:20:18.694 - 05:21:13.782, Speaker A: So when we're doing our network flags, we do network polygon. We can see this one's already using the private key and this one has that RPC URL for polygon mainet RPC URL right here. So we would add that, we'd add a private key or mnemonic or whatever else we wanted in this env. And then the other main thing that we do is we'd actually come into our hard hat helper config and we'd add a new network. Again, polygon is already added in here, right, but we have all these environment variables like the link token, FUSD, price feed key hash, et cetera. And this is where we would add those different addresses. So when we deploy a price feed, if we go to our deploy price feed consumer, what it does is on this line right here, it says it's going to deploy the FUSD price feed, which is grabbed from what's called the network config Chinad.
05:21:13.782 - 05:22:00.966, Speaker A: FUSD price feed. The network config is this file right here. Chinad for polygon is 137, and then FUSD price feed. This is the address right here. And again, you can find that from the Chainlink documentation. So if you'd want to go ahead and deploy all this, once you have this env set up, you would just run NPX hardhat, deploy network polygon again, I'm not going to actually run it here because I don't have any matic in my metamask right now, but this is how you would do it. So, with that being said, I hope you all learned a ton about building these insanely powerful smart contracts and these insanely powerful hybrid smart contracts that are going to elevate your solidity and your programming skills on the polygon chain to the next level.
05:22:00.966 - 05:22:02.740, Speaker A: Best of luck, and I hope to see you around.
