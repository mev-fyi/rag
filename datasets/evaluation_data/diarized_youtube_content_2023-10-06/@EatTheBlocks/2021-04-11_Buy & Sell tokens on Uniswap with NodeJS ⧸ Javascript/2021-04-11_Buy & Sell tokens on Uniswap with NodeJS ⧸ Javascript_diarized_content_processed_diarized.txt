00:00:00.250 - 00:00:42.454, Speaker A: Trading on Uniswap is very different from trading on a centralized exchange like binance. On Uniswap there is no order book, limit orders or market order. Instead, Uniswap uses a unique system called automated market maker. In this video I will show you how to buy and sell tokens on Uniswap using node JS. And as a bonus, everything you will learn in this video also applies to all the clones of Uniswap app like Sushiswap, Pancakeswap, etc. If you are new here, I'm Julian and at the blocks I teach blockchain development. Uniswap is an improvement over centralized exchanges such as binance.
00:00:42.454 - 00:01:15.378, Speaker A: Before we dive into Uniswap, we need to understand how these centralized exchanges work. What I'm about to explain applies not only to centralized crypto exchanges, but also to any kind of financial markets outside of defi, like the New York Stock Exchange. In a centralized exchange, there are two kinds of market participants, market makers and traders. Market makers are usually big companies. They have a lot of capital and they want to use it to make more money. To do that, they provide liquidity. At any time they are willing to buy or sell crypto at a certain price.
00:01:15.378 - 00:01:47.722, Speaker A: For example, if a market maker has $100 million, it can set aside 50 million in cash so that it can buy from traders. For the other 50 million, it will use the cash to buy some crypto and make this crypto available for selling. Market makers make money with the beta spread. They constantly buy at a lower price and sell at a higher price. The other kind of market participant are traders. Traders can be companies or individuals. Traders want to buy or sell some crypto, and to do so they will use the liquidity provided by the market makers.
00:01:47.722 - 00:02:31.210, Speaker A: In centralized exchanges, there are two kind of orders, limit orders and market orders. Limit orders are used by market makers. In a limit order, you specify which crypto you want to trade, the amount, the direction of the trade, so buy or sell and the limit price. For example, a limit buy order for one bitcoin with a limit price of $60,000 means that you are willing to buy one bitcoin at most at $60,000. So if the market goes in your direction, you might only pay $59,000 for your bitcoin or less. But in any case, you are sure that you will not pay more than $60,000. Other example, with a limit sell order of one bitcoin with a limit price of $70,000.
00:02:31.210 - 00:03:29.754, Speaker A: So in this case it means you are willing to sell one bitcoin for $70,000. If the market goes in your direction, you might sell your bitcoin at a higher price, but in any case, you are sure that you will not sell your bitcoin for less than $70,000. This model works well for centralized exchanges with a limited number of markets, but on the blockchain we have many more assets to trade and this model doesn't work well. The main reason is that to be a market maker you need to have a lot of capital and a lot of technical expertise, as you need to constantly readjust your limit orders in order to not lose money when the price changes. That's why we need something more efficient for the blockchain and that's when the automated market maker comes in. The concept of automated market maker was created by Uniswap. With an automated market maker, everybody can be a market maker, even with a small capital and no trading expertise.
00:03:29.754 - 00:04:09.862, Speaker A: Thanks to this model, all markets are able to get some liquidity, even for the small coins that would otherwise be too small for the big market makers of centralized exchanges. With an automated market maker, we have two kind of market participants, liquidity providers. That's what we call market maker in centralized exchanges, and the other kind of market participant are traders. When you are a liquidity provider, to make money, you just have to send your token to a decentralized exchange. You wait a bit and later you can withdraw your initial capital plus some profit. Very easy. When you send your tokens as a liquidity provider, you have to provide the same value in the two assets of the pair.
00:04:09.862 - 00:04:52.390, Speaker A: For example, if you are trading on an ETH die pair and the current price of ether is 2000 die, you could provide one ether and 2000 die as a liquid provider, and in exchange you get some IOU tokens called lp tokens. You can redeem these tokens at any time against your initial capital plus subtrading fees. Now let's see how it works for traders. When a trader wants to trade, there is no concept of a buy or sell order on an automated market maker. Instead, a trader can swap tokens. As a trader, you provide some tokens in input and you get some tokens in output. You specify how much token are provided in input and the minimum amount of tokens you are willing to receive as output.
00:04:52.390 - 00:05:43.862, Speaker A: You notice that at no point liquidity providers or traders specify any price. It's because the price is determined by the algorithm of the automated market maker in the code of the smart contract. This uses what we call the constant product formula with this formula, the product of the reserves of the two assets of the pair must always be equal to the same value. For example, if there is ten ether and 20,000 die in reserve before trading, the product is equal to 200,000 after trading, the product must be the same. If a trader wants to buy one ether after the trade, we will have nine ether left in the reserve. So the equation we have to solve is nine times die reserve after equal 200,000. So we can rearrange this to get the value for the die provided by the trader and we find 2222 die.
00:05:43.862 - 00:06:28.770, Speaker A: So even though the initial price of ether was 2000 die, the trader ends up paying 2222 die for his one eth. The difference is what we call slippage. The more a trader uses the liquidity of a pair, the bigger the slippage and the worse the price. If a trader really wants to trade a very large amount, the slippage becomes exponential, which will act as a deterrent and guarantees that nobody uses too much of the liquidity. So let's come back to the trader. When he specify his token swap, he has to specify the minimum amount of token in output. But why do we even need to specify this quantity? Since before trading we can use the constant product formula to determine what will be our slippage and how much tokens we will receive in output.
00:06:28.770 - 00:07:11.986, Speaker A: Actually no, you cannot know exactly in advance what will be your slippage. This is because you don't know exactly when your transaction will be mine. When your transaction is mine, maybe that the market will have moved, which means both the initial price and the slippage will be different, which means you will get a different amount of tokens as output. So you do need to specify what is your tolerance compared to the current market situation. To sum up, I prepare this comparison between centralized exchanges and automated market makers. On centralized exchanges, if you provide liquidity you are called a market maker, but on Amm you are called a liquidity provider. When you consume liquidity on a centralized exchange you are called a trader.
00:07:11.986 - 00:07:54.610, Speaker A: And that's the same for amm. For trading. On a centralized exchange we are talking of order, whereas on Amm we are talking of swap. Limit order are used by market makers on centralized exchanges. On Amm we don't have exactly the same concept, but when a trader does a swap on Amm he specified the minimum amount of token as output, which implicitly is a limit price. Then when it comes to market order on centralized exchanges they are used mainly by traders. But on Amm, even though we don't have exactly the same concept, when a liquidity provider provides liquidity, it's similar to a market order because basically the liquidity provider is willing to sell his liquidity at any price.
00:07:54.610 - 00:08:25.050, Speaker A: Then on centralized exchanges we talk about a market, for example ether dai, but on Amm we are talking of liquidity pool or a pair. And finally, for prices on centralized exchanges they are determined by participant, but on Amm they are determined by an algorithm. Okay, so that's it for the overview of how Amm work. Next, we are going to do some coding. So we are going to buy some die with ether.
00:08:25.210 - 00:09:03.190, Speaker B: And I put all the code on the GitHub repo of the blocks. So this is a standard truffle project. And first we're going to have a look at all the smart contracts. So I created a couple of interfaces that we're going to use to interact with all these contracts. First, a simple interface for the Dai stablecoin, then another interface for wrap ether. So on uniswap you cannot use ether directly, but instead you use wrap ether. If you never heard of wrap ether, that's basically an ES 20 token that has ether as a collateral.
00:09:03.190 - 00:09:35.838, Speaker B: So it's very simple. For example, you send it one ether and in exchange it gives you one wrap ether. And you can also do the other operation to get back your initial ether. And there are a couple of defi project that use wrap ether instead of ether. Because ether and Es 20 have different APIs. And by just having to deal with one kind of API, Es 20 tokens, it simplified the coding. Okay, so going back in the contracts directory, the other important contract is the router.
00:09:35.838 - 00:10:07.226, Speaker B: That's the contract of Uniswap that we are going to use for our trading. And it has two important function. First, get amounts out. So it tells you how much token you're going to have as output for a certain number of token in input. And also when you want to do your swap, you are going to call this function swap exact tokens for tokens. So in argument you pass it the amount of token in input. So in our case it is going to be the amount of wrap ether.
00:10:07.226 - 00:10:41.890, Speaker B: Then you specify the minimum amount of token that you're going to accept in output. So in our case, this is going to be the amount of die, then an array of addresses to specify your trading path. So in our case, we're going to trade from wrap ether to Dai. So the first address is going to be the address of wrap ether. Second address, the address of DAi, then the recipient of the output token. So in our case, this is going to be the same address that sends the transaction and then the deadline. So this is a timestamp in Segan that specify up to when the transaction is valid.
00:10:41.890 - 00:11:05.966, Speaker B: So if you send a transaction at a certain time, you want amount outmin to be valid only for a certain time. For example, it can be a couple of minutes. So that's how you specify this. Okay, so then we're going to go at the root folder. So in truffle config, I've configured a new network. Oh yeah. So first need to specify your mnemonic.
00:11:05.966 - 00:11:28.778, Speaker B: So that's for the sending address. Then also in inferra. So you create an account on infra, you create an ethereum project, and you copy paste the Rinkob URL. So we're going to do it on Rinkobe, but you can also reapply this on a main net, of course, and then in network. So I added a network for Rinkob. This is the configuration here. Okay.
00:11:28.778 - 00:12:03.022, Speaker B: And then I created a script here to do the trading. So let's go there. So here we import the interface of the different smart contract we're going to interact with. Then here we define the address of the different smart contract. So for the router address, you're going to find this in the documentation of Uniswap. For the address of wrap ether and die, I found this on ether scan for rink B. Then amount in, so that's the amount of wrap ether that we're going to provide in input.
00:12:03.022 - 00:12:27.398, Speaker B: So 0.1 ether. Then we export a function. So that's what's going to be executed. So first we get the address that's going to send the transaction. Then we create javascript object that points to our different smart contract. Then here we're going to deal with wrap ether.
00:12:27.398 - 00:13:04.658, Speaker B: So the first line we're going to get some wrap ether by sending some real ether. Then we're going to approve the router of uniswap to spend our wrap ether. Then we're going to estimate how much die token we're going to get as output. So for that we use the router contract of uniswap. Then we estimate how much die token we're going to get as output by using the router contract and the get amounts out function. So we pass it how much wrap ether we're going to provide in input. And we also provide a trading path from wrap ether to die.
00:13:04.658 - 00:13:31.818, Speaker B: And then we're going to get an array. And we are interested in the second element of this array. That's the amount of die we're going to get as output. And with this value we're going to calculate amount out mean. So this value amounts at one that's valid at the time that we call get amounts out. But by the time we send our transaction maybe that we're going to get a slightly different number of token. So we need to specify our tolerance.
00:13:31.818 - 00:14:13.040, Speaker B: And so here our maximum tolerance is going to be 10% less than amounts out, or in other words amount out mean it's going to be 90% of amount out that we initially got. So here, since amount out is an instance of bnjs, so that's a JavaScript library to deal with a big number. The way we calculate 90% is slightly more complex. That's why I use these two function here. You cannot just directly use the Javascript operator to multiply by 90 and divide by 100. It will not work. Then just after we get the balance of die, just before the transaction, so that we can compare after.
00:14:13.040 - 00:15:02.906, Speaker B: Then we finally do the trade here by using swap exact tokens for tokens function. So we pass the amount of wrap ether in input, the minimum amount of die in output, then the trading pass, then the recipient or transaction, then the deadline. So this is a timestamp in second. So I use date now of JavaScript that give us the current timestamp but in milliseconds. So we need to transform this into second by dividing by 1000, but it's going to give you a decimal number. So we need to transform this into an integer with math floor. Then we add 10 minutes, then a transaction is sent and after we get the balance of die after and after we're going to measure our execution performance.
00:15:02.906 - 00:15:43.186, Speaker B: So what's the difference between the number of die we actually got and what was our initial estimation here? So here balance die after minus balance die before. So that's the amount of die we receive and we divide this by the initial estimation and we want this number to be as close as possible from one. All right, so now we're going to do a demo. So first need to run NPM install, then truffle compile. So it's going to create the Abis for the different smart contract we're going to interact with. And this is required by our script. And after we're going to run our script.
00:15:43.186 - 00:16:18.590, Speaker B: So for that we're going to use truffle exec. Then we specify the network. So that's rink B in our truffle config. And after we specify the path to our script scripts trade js all right, let's launch this. All right. So the trade worked, and we can see the execution performance here is one, which means that we got exactly the same amount of diet token that the initial estimation. And that's because we are doing the trade with the deployment of Uniswap on rink B.
00:16:18.590 - 00:16:31.830, Speaker B: So there is almost no trading. But if you do this on Mainnet, it's almost impossible that you're going to get an execution performance of one, because people are constantly trading on Uniswap on Mainnet. So you're going to have a figure.
00:16:31.900 - 00:16:33.158, Speaker A: Lower than one here.
00:16:33.244 - 00:16:34.406, Speaker B: Once you know how to buy and.
00:16:34.428 - 00:16:46.078, Speaker A: Sell tokens on Uniswap, you can move on to more advanced stuff, such as building a trading boat for Uniswap. It's fun, and you can make money. And for that, you can check out this video.
00:16:46.164 - 00:16:46.860, Speaker B: I'll see you there.
