00:00:00.330 - 00:01:19.042, Speaker A: Hey, hey, this is julian and you're on in the blogs. And in this video we're going to talk of a gas optimization installability smart contract, and I'm going to give you a couple of tips to reduce the gas consumption in your smart contract. It's very important to understand how to do this because if it costs too much money to execute the function of your smart contract, less users will be willing to run your decentralized application before you start to optimize for gas consumption in your smart contract, it's important to understand that it's not possible to optimize for all the gas consumption in all your smart contract. But you can only optimize in a specific part in your smart contract because usually when you start to optimize for a specific function, it's going to make another function actually worse. One example of this is if you try to optimize for deployment cost, so your deployment cost goes down, but probably that the consumption of some other function will go up. So you need to be really clear on what is your objective for your gas optimization and what kind of trade off you want. For example, maybe that there are a couple of function in your smart contract that are used very often by users, so this should be the absolute priority.
00:01:19.042 - 00:02:02.782, Speaker A: But maybe that there are also some other admin function that are rarely used. So it's okay if by optimizing the function used by user you de optimize the admin function. Tip number one, minimize onchain data. So when you design a decentralized application, you don't put 100% of your data and of your logic inside your smart contract. But usually you also have part of your system also on a centralized server. So how do you decide which data goes where? Any critical data needs to go inside the smart contract. For example, everything that has to do with the economy of your smart contract or any data that absolutely must not be censored.
00:02:02.782 - 00:02:48.158, Speaker A: And for all the noncritical data like metadata or file, this can safely go to a centralized server. Tip number two, use libraries. So if you have several smart contract that reuse the same sort of functionality, you can extract this common functionality into a single library and then you're going to deploy this library just once and all your smart contract will point to this library to execute the shared functionality. So there is a caveat here because there are two kind of library. There are embedded library and deploy library. So you want the second kind, the deploy library. In order to have a deploy library, you need to make sure that all the function in your library are external.
00:02:48.158 - 00:03:41.854, Speaker A: Tip number three, use ERC 1167 if you need to deploy the same smart contract many times. So with ERC 1167 it uses a system of proxy smart contract where you only have to deploy the actual code of your smart contract once and for subsequent deployment. It's only going to point to the already deployed code logic, but each smart contract will have its own data on its own storage on the blockchain. I've done an entire video on this topic, so check it out. Tip number four, turn on the optimizer of the solidity compiler. So there is a special mode in the solidity compiler that allows to produce some more efficient bytecode that consume less gas. So when you are compiling your smart contract before a deployment to the actual blockchain, make sure to turn on this setting in truffle.
00:03:41.854 - 00:04:28.686, Speaker A: You can do it very easily in your truffle config by using this snippet. So you might wonder how comes this is not turned on by default. Well, when this is turned on, it actually takes more time for the solidity compiler to compile your smart contract. So this is not really ideal in development where you want to optimize for a very fast compilation time, so you only turn it on before a deployment. Tip number five use events. So if you have any data that only needs to be created once, but after it doesn't need to be updated, and it also doesn't need to be read from the smart contract, then this is a good candidate for event events consume less gas than a normal solidity variable. So if your data qualify for an event, then make sure to use this instead of a normal solidity variable.
00:04:28.686 - 00:05:11.642, Speaker A: Tip number six use literal values instead of computed one. So sometime when you write the code of your smart contract, you already know some data that you will store inside. That's the case of hashes, for example. However, I've seen many people that compute hashes in the smart contract even though they already know the final value of the hash. So if that is your case, compute the hash outside the smart contract and you directly with a static string, you instantiate your variable with the final hash. Don't waste gas by computing this value on the blockchain. Tip number seven avoid to copy arrays in memory.
00:05:11.642 - 00:06:08.990, Speaker A: So if you have some arrays that are stored in the storage location of your smart contract and you want to manipulate this array, then a very easy way to do so is to create a storage pointer to this array in your smart contract, and you don't need to copy this array at all. Tip number eight avoid to create for loop over dynamic ranges. So let's consider the following scenario. So you have your smart contract where inside a function you have a for loop, and this for loop iterate over a value that is dynamic. So when just you deploy your smart contract for the first time, maybe that the first week is going to iterate ten times, but maybe that one month after that you're going to have more data in your smart contract. And so now your follow up is going to iterate 100 time and as more time goes by then you have more and more iteration. So the gas cost is increasing and at some point in the future it's going to be actually super expensive.
00:06:08.990 - 00:07:20.646, Speaker A: So before you deploy a smart contract, you need to anticipate that sort of thing. Tip number nine optimize the order of your variable declaration so the Ethereum virtual machine store the data of a smart contract in memory slot of 256 bits. So for the elementary type such as integer they can fit in one single slot, but for other type that actually spans several slots. But if you have several elementary type that can fit in a single 256 slot, then solidity is going to do some optimization and put these two variable in a single 256 bit slot. But in order for solidity to do this, your variables need to be declared next to each other. For example, if you have a Uint 128 next to another UIT 128 then solidity is able to figure out that they can be put together in a single 256 bit slot. But if you have a UN 128 then you have a UN 256, then a Uni 128 then solidity won't be able to do the optimization and in this case these three variable are going to occupy three slot of memory instead of just two.
00:07:20.646 - 00:07:59.940, Speaker A: Tip number ten use NPM package called eat gas reporter and it shows you the gas consumption of all your function every time you run a test for your smart contract. So this is very important to monitor the report of this NPM package and as soon as you find the gas consumption is getting too high then you can focus on optimizing this function. If you need a refresher on what is gas in solidity, you can check out my full series on the topic on my channel and if you also need to brush up on your solidity skills, I have a full series read on my channel where I cover all the aspect of the language, so I'll see you again for this video.
