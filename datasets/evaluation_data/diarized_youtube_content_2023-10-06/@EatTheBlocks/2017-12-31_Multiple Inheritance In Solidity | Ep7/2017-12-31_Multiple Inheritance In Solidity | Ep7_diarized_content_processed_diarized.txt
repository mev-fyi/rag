00:00:00.410 - 00:00:02.078, Speaker A: You. Hi guys.
00:00:02.164 - 00:00:24.490, Speaker B: Welcome to the 7th episode of Idablocks. Today we're going to study what is multiple inheritance in solidity. With multiple inheritance, one contract can inherit from several contracts. For the last episode, we already studied inheritance, but it was single inheritance. So in our case it's going to be slightly more complicated. We're not going to study what is polymorphism. It's going to be the topic of the next episode.
00:00:24.570 - 00:01:05.550, Speaker A: Okay, so switch to your terminal and inside your project folder, we're going to use the truffle command line to initiate our project. So as usual, it's truffle in it. And once you've run this command, you should see those directories and those files. The next thing we're going to do is to launch the comment to create our smart contract. So for this is truffle, create contract, and then the name of the contract, my contract. And then in your contract directory you should see that you have a new file. So in this case you can see here mycontract Sol.
00:01:05.550 - 00:01:39.340, Speaker A: So now open your text editor and open mycontract Sol. And you should see this code that has been created by truffle. So we don't need this constructor here. Okay, so we have a contract called my contract. So this is the contract that is going to inherit the other contracts. So let's create two other contracts. So the first one will be contract kid one, and the second contract will be contract kid two.
00:01:39.340 - 00:02:31.294, Speaker A: And after that we're going to use the is keyword to make my contract inerate from kid one and kid two. So we're going to say is kid one. And to make my contract also inerrate from kid two, we're going to use a comma here, so comma, and then I can continue to add other contracts. So for example, if I had a kid three contract, I could make my contract also inherit from kid three by just adding kid three like this. But in our case we just have kid one and kid two. So next we're going to create variable in each of those contracts. So first in kid one, we're going to create a string variable that we're going to call kid one VAR.
00:02:31.294 - 00:02:59.300, Speaker A: And very simply it will just contain exactly the same thing. So kid one VAR equals kin one VAR, very easy. And we're going to copy this line and paste it in the kit two contract. Oops. Okay, I'm just going to write it again. So kit two VAR equals kit to VAR. Okay.
00:02:59.300 - 00:04:11.040, Speaker A: And then in my contract here, we're going to create also another variable that we're going to call my contract VAR and it's going to be equal to my contract VAR very simply. Okay, and now inside this contract we're going to create three function to read each of those variables. So the first function will be to read my contract VAR. So function get my contract VAR and it's going to be a constant function, meaning that it's a read only function, doesn't modify the data, and it's going to return a string. So we need to use the keyword returns here with the s. And then we're going to very simply just return my contract VAR. Make sure that here when you use this return keyword doesn't contain an s, which is different from here when you specify the return type.
00:04:11.040 - 00:04:39.880, Speaker A: Okay, and we also need two other function to return kid one VAR and kid two VAR. So they're going to be very similar. So we're just going to copy this over. Okay, and here I'm going to replace this by kid one VAR, and here it's going to be kid two VAR.
00:04:43.450 - 00:04:45.462, Speaker C: Okay, so this is just a little.
00:04:45.516 - 00:05:29.270, Speaker A: Bit different that in the previous episode because in the previous episode what I did differently is I prefixed this with the name of the contract. So here I did the equivalent of this kid one, kid one VAR, but actually you don't need it because we inherit from this contract so we can read those variables. Okay, one last thing we need to do is to modify the name of those two functions. So here it's get kid one VAR and here is get kid two VAR. Okay, so in our console now we need to start the truffle develop command. It's going to start the local testnet. Okay, now we need to run our migration.
00:05:29.270 - 00:06:12.366, Speaker A: One thing I didn't specify is that I've already wrote the migration file because it's exactly the same as the last episode. So you can find this on the GitHub of this episode I will put the link in the episode description. So here I'll type the migrate command. Okay, so now our smart contract is deployed on our local testnet so we can interact with it. So as before we will cross create variable. Then we will use truffle abstraction. So our contract is called my contract, so we can just use this variable, my contract, and we want the instance that was just deployed.
00:06:12.366 - 00:06:51.102, Speaker A: And then we're going to have a promise, and this promise is going to return the instance and we're going to assign this instance to our inst variable. So that's what we're doing here. And we're going to execute this, okay. And now we're going to call the method of ask my contract. So first is get my contract VAR, and here press enter. Okay. And I have my contract VAR.
00:06:51.102 - 00:07:34.366, Speaker A: Okay, here, just to note, so in the previous episode we didn't do like this. In a previous episode when we call a function of our smart contract, what we did was we wrote the name of the function like this. Then we added a call like this, and then we had a promise and we console log the result of the promise. But there are two simplification that we can add. So first, in the truffle console, every time there is an expression that return a promise, it is evaluated, sorry, it is resolved for you. And so you don't need actually to do this. Then console log truffle would do it for you.
00:07:34.366 - 00:07:58.498, Speaker A: And second, in the case of a function call, so it is different from transaction, we don't actually need to use this call syntax here. We can directly call the method like this. And because in solidity we added the constant keyword, a truffle will know that it's a call and it's not a transaction.
00:07:58.594 - 00:08:00.920, Speaker C: So that's why we're able to do this.
00:08:02.490 - 00:08:36.862, Speaker A: Oops, I don't know what is wrong here. Okay, it's because I forgot I didn't spell correctly the name of the function. Anyway, it works. So now we're going to call the other functions. So the other one is kid one VAR, and we have kid one VAR here as a string. So that's what we were expecting. And now we're going to call the other function kid two VAR.
00:08:36.862 - 00:09:29.970, Speaker A: And we also have kit two VAR. Okay, so so far it's not very different from the previous episode, but I just wanted to show you that accessing variable that are defined in inherited contract is exactly the same if you inherit from one or several contract. Okay, so now back to our text editor, and we're going to add a new contract that I'm going to call parent. So parent that I will define here. And again, we will define a variable inside parents. So it will be parent VAR equals parent VAR. And now we're going to try to access this variable inside our, my contract here.
00:09:29.970 - 00:10:18.510, Speaker A: So let's add another method and it will be get parent VAR. And again it's going to be a constant function that returns a string. So return parent VAR. And my syntax highlighter tells me that there is a problem. So we can see it in red. So let's see undeclared identifier. Okay, so basically the problem is like this contract here, parents, it's absolutely not related to either kid one, kid two, or my contract.
00:10:18.510 - 00:10:28.870, Speaker A: So one way that we could solve this problem is for example making my contract in a rit fund parent.
00:10:29.020 - 00:10:31.030, Speaker C: So we could do it like this.
00:10:31.100 - 00:11:08.530, Speaker A: And if I scroll down now I can see that my syntax highlighter removed the red line. So now it's fine. But it's not what I wanted to show you. So I'm going to remove this and we're going to have the problem again. What I want is to have one of the kid to inerit from this parent. So here for example, I will add kid one is parent. And when I do this, basically it will make parent enter the inheritance chain.
00:11:08.530 - 00:11:40.682, Speaker A: And because my contract inherit from my kid one, from kid one, but kid one also inherit from parents. Inside my contract I can also access the variable of parent. So if I scroll down and I have a look at my get parent valve function here, I can see that my syntax highlighter doesn't complain about this line. So it should work. So now we're just going to switch to our terminal and execute this function to see that if we can access this variable.
00:11:40.746 - 00:11:42.080, Speaker C: So let's do this.
00:11:43.010 - 00:12:03.970, Speaker A: So first we need to run the migration again because our contract has changed. So that's how you reset. If you don't add the reset flag here, it's going to redeploy the smart contract but it's going to redeploy the previous version of your contract. So it's not what you want here we also want to recompile.
00:12:04.550 - 00:12:06.680, Speaker C: Okay, so let's do this.
00:12:07.530 - 00:12:50.850, Speaker A: Okay, so now we need to have a variable that point to our updated smart contract instance. So we need to redo this operation again. So here my contract deployed and then we're going to call then and we're going to assign this to inst. Okay. And now we're going to call our new method so inst and it's going to be get parent VAR and let's see what we have. And we have parent VAR. Okay, that's great.
00:12:50.850 - 00:13:19.660, Speaker A: That's what we wanted. Okay, so back to our text editor again. So I'm going to do a little change and I'm going to make kit two also inerit from parent. And let's see if the syntax highlighter complained about anything. So let's scroll down and. No, it seems to be working. So why it's working and there is no problem here because we inherit from parent two time.
00:13:19.660 - 00:14:13.802, Speaker A: So when this happened, basically only one instance of parent will be created when you compile this contract. So it means that this variable here, parent VAR, will just exist at one location. So when you try to access it in get parent VAR function here, there is absolutely no ambiguity. Okay, and just before we finish this episode, I'm going to talk about a problem that can arise. So now if I make my contract also inerate from parent here, you will see that the syntax highlighter is going to complain here. So it means that there is a problem. So I'm not going to hover over this line because this is a challenge that I want you to solve for the next episode.
00:14:13.802 - 00:14:26.538, Speaker A: So why do we have this problem? Why can't we have this? I'm going to give you a hint. It's related to what we call polymorphism and it's going to be the topic of the next episode.
00:14:26.634 - 00:14:50.178, Speaker B: That's it for today. I hope that not multiple inheritance in solidity is a little bit more clear for you. Don't forget about the challenge I mentioned, because it's going to lead you to the next episode, which is polymorphism in solidity, and it is closely related with multiple inheritance. If you like this channel, you can subscribe, you can give me a like, or you can share. Thank you guys and see you next time. Bye.
