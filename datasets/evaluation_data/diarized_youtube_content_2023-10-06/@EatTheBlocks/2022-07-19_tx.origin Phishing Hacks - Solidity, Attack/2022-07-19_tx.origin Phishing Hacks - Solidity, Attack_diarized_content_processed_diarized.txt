00:00:00.410 - 00:00:41.418, Speaker A: Okay, developers, welcome back. In this video, we're going to be looking at transaction origin attacks and just how easy it is to be the victim of a phishing hack. If you're new here, I'm Calvin Torah, and on eat the blocks, we help web two developers transition into web3. Now, TX Origin is a global variable in solidity. It returns the address of the account that sent a transaction. Some developers, for example, use this to confirm that the origin of a transaction came from the owner of the contract. But as we'll see, this can be vulnerable to phishing attacks and even the best of us can get caught out.
00:00:41.418 - 00:01:11.010, Speaker A: Let's have a look at a simple example. We'll have two people in our scenario, a contract owner, who is the victim, and an attacker. We'll start with the victim's smart contract. We'll call their contract safe house. We have an address that is public. As owner inside our constructor, we'll assign the owner to message sender, which is the one that deploys the contract. We'll then create a function called transfer that takes an address for the recipient and the amount we want to send and make this public.
00:01:11.010 - 00:01:50.410, Speaker A: We'll then have a require statement that makes sure that only the owner of the contract can call this function. By verifying that the origin of the transaction is the same as the owner's address. We'll send the funds and return the boolean on success and then require that everything went through. We'll also add a get balance function to get the balance of this contract. Now, the attacker hangs around on social networks. They start piecing things together from messages on discord and Twitter, and they figure out exactly who is the owner of the contract that is holding a lot of funds. Let's look at how they would write their contract to crack the safe house funds.
00:01:50.410 - 00:02:31.498, Speaker A: We'll start with the owner that is payable and save a pointer to the victim's contract address as safe house. The constructor takes in the address of the safe house and sets the owner. Now, the main part is the attack function. We'll call the transfer function on the victim contract and pass in the attacker address to receive the funds and for the amount we'll pass in the entire balance of the victim's contract. Now this is where most explanations online finish, but this code isn't actually going to work. In our scenario, message sender is going to be the contract making the call. TX origin is going to be the attacker's address.
00:02:31.498 - 00:03:20.886, Speaker A: Neither of these match the owner of the victim contract, and so the call is going to revert, the attacker needs to trick the victim into calling the attack function, which is going to be pretty tough. However, as I witnessed just two weeks ago, even the most suspicious security experts can be tricked and phished. On Twitter, I saw someone panicking because they sent some matic to a random person begging for help on discord. They wanted to be nice and sent one matic to the beggar's address. 24 hours later, the beggar had hacked a protocol and drained thousands of dollars. This security expert is now under suspicion of being part of the hack because their address has records of interacting with the hacker. When someone gives you an address, you can't really tell at a glance if it's a wallet or a contract.
00:03:20.886 - 00:03:55.750, Speaker A: Just by looking at the address, you would need to go online and check the address and see if it's an externally owned account or a contract. But most people just assume the best in others. Now, this got me thinking. If the attacker writes a fallback function into their contract and then tricks the victim to sending them even just one way, the attacking contract can execute the attack. So let's do that. Now, we'll update our attack contract with the fallback function. We'll deploy our safe house contract with 22 ether, and we'll use the first address as the victim address.
00:03:55.750 - 00:04:51.056, Speaker A: And we'll just put this to one side for reference. Once deployed, we'll check the balance to make sure that the funds are actually in the contract, and then we'll save the address of the victim contract for reference as well. We'll then deploy the attack contract as a different person, using the victim contract in the constructor. Now, if the attacking address tries to call transfer, we're going to fail and the transaction is going to revert. However, if we change back to the victim address and send one way to the attacker because they're begging for help, we should expect our fallback function to silently hack the victim. If we head back to the victim contract, we can see the funds have been completely drained. Now, because the victim initiated a transaction, their address is assigned to TX origin.
00:04:51.056 - 00:05:23.020, Speaker A: The attacker just passes the transaction through to the victim's contract and it all matches up. We need to think like attackers in order to protect our contracts, our clients contracts, and everyone's funds. The recommendation is to always use message sender when checking the sender of a transaction. Now, if you think that using this for evil is a good idea, I suggest you check out just how much money bug bounty hunters can make for reporting bugs just like this. That's it for this quick video. Thank you for watching. And keep those private keys safe.
