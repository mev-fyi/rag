00:00:00.250 - 00:00:40.634, Speaker A: Are you a JavaScript developer who wants to get into web3? The first step is to learn the solidity programming language. In this video I will give you an introduction to solidity. I will start from JavaScript code snippets and translate them to solidity. So first of all, what is solidity? Solidity is the language that is used in smart contracts. Smart contracts are the small programs that run on the blockchain. There are several languages for this smart contract, but solidity is the most popular one. Solidity has a syntax that looks like JavaScript, but under the hood it's very different.
00:00:40.634 - 00:01:11.678, Speaker A: Solidity is used for the Ethereum blockchain. Ethereum has the biggest ecosystem of developers, and most blockchain jobs are for Ethereum or other blockchain based on the Ethereum technology. So that's why you should focus on Ethereum and solidity. All right, so let's get started. So I'm going to split my screen in two. On the left you have the JavaScript code, and on the right you have solidity. If you want to be able to run the solidity snippets, you can use an online IDe that is called remix.
00:01:11.678 - 00:01:48.734, Speaker A: So first let's start with the layout of a smart contract. So for JavaScript you have variables and functions, and you can put this directly in your file. In solidity you need to start with the pragma statement that is going to tell the compiler which version of solidity we're using. After you have to define a contract object, all your code is going to be inside. In this contract object you're going to have some variables and some functions. Now let's talk of the variable lifetime and memory. So in JavaScript, if you have a variable that is defined at the file level, its lifetime will be the lifetime of the execution of your program.
00:01:48.734 - 00:02:24.390, Speaker A: And if you define variable inside function, the lifetime will be the execution of the function. When it comes to solidity, the variable that you define at the contract level will be stored permanently in the blockchain. However, for variables that you define inside functions, the lifetime will be the same as the function, so they are temporary. So if you want to dive deeper into memory in smart contract, be aware that there are four memory locations. But for now let's just keep it simple. Just remember that it's possible to store data permanently in the blockchain, and for some other variable it's just going to be temporary. Then let's talk of functions.
00:02:24.390 - 00:03:08.130, Speaker A: So the way we define function in solidity is quite similar to JavaScript. So if there are any argument we need to define a type, and there are a couple of extra keyword that we have to use for solidity functions. The external keyword means that this function can be called from outside the smart contract, and there is a difference between the function that are readonly versus the function that can modify the blockchain data. So if you use the view keyword as well as the returns keyword, it means that this is a readonly function. So in JavaScript we don't have this difference. So next, let's talk of variables in solidity. Contrary to JavaScript, we have to define the types of our variable, and some of the types are similar to what we have in JavaScript.
00:03:08.130 - 00:03:41.166, Speaker A: So we have boolean value for numbers, we have different types, but the most used one is unsigned integer. We also have strings. There is also a type that is unique to solidity, that's the address type. So in web application you will typically identify a user with an ID, but in solidity it will be with an address. So each smart contract has an address. And wallets controlled by humans also have addresses, and each of this address is associated to an ether balance. In solidity, when we use the const keyword, it means that we cannot change this variable.
00:03:41.166 - 00:04:17.306, Speaker A: We can have the same behavior in solidity with the constant keyword. In JavaScript, if we want to be able to change the value of a variable, we need to use the let keyword. And in solidity this is just the basic behavior. So after let's talk of array in solidity. When you define an array, it can only contain elements of the same type, which is different from JavaScript. If you want to access elements of your array, it's the same notation as in JavaScript, and for the length, push and pop operation it's the same. There are many more functions available for JavaScript arrays like concatenate or map, but we don't have the equivalent in solidity.
00:04:17.306 - 00:04:48.242, Speaker A: After that, let's talk of objects. So in solidity the equivalent of object is a struct. So when you use a struct you have to define the field and the type of each field. And once you have defined the type of your struct, you have to create an instance of this struct. So in JavaScript we can use object as key value stores. So you will have an outer object and a list of inner object. In solidity the equivalent will be a combination of mapping with a struct, and this is how you can create new entry in your mapping.
00:04:48.242 - 00:05:27.514, Speaker A: However, there is a big limitation for solidity mapping. Contrary to JavaScript object, it's not possible to loop through all the entries of a mapping. You can get around this limitation by using keys that follow each other, but most of the time the keys will be addresses, and so the other solution will be to emit events and to lessen events from outside the blockchain. Then let's talk of control structures. So in solidity, like for JavaScript, we have if for and while, and their syntax is exactly the same. However, because we have to pay for the execution of a smart contract, it's better to not do too many iteration in your for and while loop. Then let's talk of how we can store data long term.
00:05:27.514 - 00:06:19.222, Speaker A: So in JavaScript, all the variables that you have in your program cannot outlive the execution of the program unless you use a database like MySQL or a NoSQL database. However, for solidity, any variable that you define outside of a function will be stored permanently in a blockchain, and all you have to do to update this value is to reference it in a function. So it's much more easy to store data long term with smart contract after let's talk of API calls. So with JavaScript, if you want to call an API, you can use the fetch function and the await keyword for solidity. The equivalent will be to call another smart contract on the blockchain. So here you have a caller smart contract that is going to call a Kohli smart contract. And in this function we are going to create a pointer to the Kohli smart contract by referencing its interface and its address.
00:06:19.222 - 00:07:03.598, Speaker A: And after we just call the function of this smart contract by using its pointer. So from your smart contract it's easy to call another smart contract. However, it's not possible to call an API that is outside of the blockchain. So if you want to reference some data that is outside of the blockchain, you have to use what we call an oracle like Chainlink. So now let's talk of money transfer. So with JavaScript, if you want to transfer money, first you need to get an API key from a payment processor like Paypal or stripe, which means that you need to get their authorization. And after you will use the fetch function to do an API call to one of these services, and you will have to send your API key when you want to transfer money with a smart contract.
00:07:03.598 - 00:07:46.802, Speaker A: This is a built in feature. So here in our send function we are going to pass the recipient address as well as the amount, and we're going to send money with this snippet, and it's going to return a boolean value to indicate the success or not, plus some optional data. There is no need to get anybody permission, it's much more simple to transfer money with solidity. Next, let's talk of how we can handle errors. So in JavaScript, if you want to trigger an error, you will use this snippet. And in solidity it's a little bit different. First you have to define your error as well as the fields of the error, and then you will throw the error by using the revert keyword plus name of the error and the field that are inside.
00:07:46.802 - 00:08:18.922, Speaker A: Next, let's talk of try catch. So in solidity, if you want to catch an error, you will wrap your code with a try catch block. And in solidity there is also a try catch block, but it works a little bit differently. So here in my contract we're going to call another smart contract data feed, and in this smart contract we are going to execute the get data function. So first we create a pointer to the other smart contract. Then we do the call, and we wrap this call in a try catch block. In this try catch block we also mention the data type that we're going to get in return.
00:08:18.922 - 00:08:48.882, Speaker A: So if everything goes fine, this will be executed. Otherwise we have our first catch block. This will be triggered if there is an error triggered by a require statement, then we have another catch block. This will be triggered if an error was triggered by the EVM itself, like a division by zero. Alternatively, you can have a single catch block that catches any kind of error. The next step is to watch my free masterclass us. That will give you a full roadmap for how to get into Webstree.
00:08:48.882 - 00:08:51.620, Speaker A: Check out the link down below. Alright, that's it for this video.
