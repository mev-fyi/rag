00:00:07.760 - 00:00:46.770, Speaker A: And we are live. Welcome everybody for this coding tutorial. Today we are going to clone to code a clone of one inch, which is a Dex aggregator. This allows you to get the absolute best price when you are using a decentralized exchange. This is a very useful tool in defi. This is also a very interesting project to do for your portfolio and to better understand Defi and how to interface with all these decentralized exchanges. If you are new here, I'm Julian and at Indoblox I teach you blockchain development.
00:00:46.770 - 00:01:44.470, Speaker A: I've been a blockchain developer myself since 2017. And yeah, so this is what we do here on eat the blocks. So let me know where you from in the chat. I see we have justice already here. How about the other, say, where you from in the chat? Alright, so before we get started, very briefly, I like to mention the roadmap, the six figure blockchain developer roadmap. This is a free training available on eitherblocks.com. so if you are completely new to the space and you are wondering how you can get started as a blockchain developer, what do you need to learn and what are the career opportunities, what kind of salary you can expect, how to get your first job.
00:01:44.470 - 00:01:59.894, Speaker A: Basically, check out this free training. It's going to save you a lot of time. I'm going to post this in the chat. Eat the blocks.com roadmap. All right, so we have more people in the chat. Supreme money.
00:01:59.894 - 00:02:42.336, Speaker A: I love your video. Amazing thx. I'm from Nigeria. Okay, what about the other Qatar Zinke? Will it be Rico? It normally yes, but it's always way better when it's live. Okay, so what are we gonna do today? Okay, what is this decentralized exchange I'm talking about? Okay, so here is the most famous decentralized exchange, one inch. So you can click here on launch Dapp. And so basically it really looks like uniswap, which is the main decentralized exchange.
00:02:42.336 - 00:03:25.258, Speaker A: So here you are going to put how much token you want to buy. For example, you pay one ether, then you're going to get this many USDT. Or you can do it the other way around. And so on the surface it looks like it's exactly like Uniswap, which is the main decentralized exchange here, one ether and want some USDC for example. We can also do it the other way around. But the big difference with one inch is that one inch is actually connect to many dex. Not just uniswap, but basically dozens and dozens of dexs.
00:03:25.258 - 00:04:16.536, Speaker A: And it's going to find the best price for you, because those Dexs, they don't always have exactly the same price. So in general, their price is quite close, because when the price is not the same, there is a possibility for arbitrage, meaning that you can buy on a cheap exchange and sell on an expensive exchange. And you have some people called arbitrageur who are doing this all the time. So it means that the discrepancies are never big, but they still exist. And so at any time, let's say if you have a large amount of money to trade, if you go to any specific exchange, it's very likely that this is not the best price that you can get. So if you use something like one inch, basically you are guaranteed to get the best price. And so for.
00:04:16.536 - 00:04:44.472, Speaker A: So I'm going to show you our version of one inch. Okay, so looks like this, you click on connect. So it's going to pop up metamask. Ask you if you want to connect, and then it's going to ask you, okay, how much money you want to sell. The address of the token you want to sell, the address of the token you want to buy, how much token you want to buy. So here prepared already something. So here we have USDC.
00:04:44.472 - 00:05:14.426, Speaker A: Then second one, wrap ether. Okay, and then how much token you want to buy. So wrap ether. This is basically ether, but in an. Yes, 20 token. And here we want to buy one wrap ether. But we cannot just put one here because wrap ether, it has 18 decimal, meaning that when you buy it, you actually buy a very, very small fraction.
00:05:14.426 - 00:05:35.590, Speaker A: If you just say this, it means you actually buy a very, very small fraction. It's like 0.00, etcetera, with 18 decimal total. So you're actually buying a very small fraction. So if you want to buy a whole ether. So it's actually ten power, 18 here, or this is this amount. Okay.
00:05:35.590 - 00:06:15.320, Speaker A: And then you click on submit. And then when you click on submit, it's going to interface with many exchanges, find the best price and then show you where it is. So here, this is on uniswap. And here you can see, you can see the price. So basically, if you want to buy one ether, it's going to cost you this much in USDC. So USDC, it has a decimals number equal to six. So that means this is actually $3157.
00:06:15.320 - 00:06:53.806, Speaker A: And we can verify this price of ether in USD. Yeah, so you can see that this is roughly the same. So the number here is correct. And then if you like what you see, then you click on trade and metamask is going to ask you to first approve your USDC to be spent by uniswap. So this is step one. And then once you confirm that, you're going to have another pop up that asks you to actually do the trade. So you're gonna have two trades success successfully.
00:06:53.806 - 00:07:39.702, Speaker A: It is same process as with any Dex release here. We're not gonna do it because this is on Mainnet, I'm not going to spend some real money. And yeah, so this is basically how this is going to work. And so we are going to build this together today. So how are we going to build this? Which technology are we going to use? So first of all, in terms of Dex, we are going to integrate with Uniswap, the main decentralized exchange on Ethereum. We are going to integrate with sushiswap, which is a clone of Uniswap. So what's great here is that they have the same interface.
00:07:39.702 - 00:08:21.826, Speaker A: So basically they have the same interface. So that's great because you, you, this is easier for our dex aggregator. And then we have also another one, pancakeswap. So pancakeswap, that's a clone of Uniswap on binance chain, so on another blockchain, but they are also deployed on Ethereum. Okay, so we're gonna integrate three decks, but actually I'm going to show you, you can add any other Dex that you want in our app. It's very simple, it's just a configuration. And so in terms of technology.
00:08:21.826 - 00:09:06.250, Speaker A: So we are going to do this on the Ethereum blockchain because this is where most of the defi activity is. We're going to use the, we're going to interface with smart contracts that are written in solidity. So the main programming language for smart contract, our app is going to be mainly a front end application and we're going to use a framework called next J s. This allow you to quickly build dynamic front end application. We're going to use a library called Ethers. So that's a JavaScript library to integrate with smart contracts. We're gonna use bootstrap to make it nice.
00:09:06.250 - 00:09:43.632, Speaker A: We gonna use metamask, which is the most popular wallet for Ethereum applications. And yeah, so these are the main technology we are going to use. Alright, so, so, so let's get started. So here I have my code editor. I'm going to scroll up a little bit. Okay, so this is a next JS project with almost nothing in it. So here is how I created it.
00:09:43.632 - 00:10:05.520, Speaker A: So I use the command NPX create next up. And then you give it the name of project here. Okay. You press enter. It's going to ask you a couple of questions. So you do this and it's going to create a, some border plate code. And here I've made a few modifications.
00:10:05.520 - 00:10:34.692, Speaker A: So by default it's going to show you some, some default HTML here in page js. So this is where you have your homepage basically. So I already replaced this by some, some minimal HTML for our app, you know with a header and just some, some basic styling. And in layout also I've done some modifications. So I import bootstrap which is our CSS framework. I import our style sheet. Okay.
00:10:34.692 - 00:11:16.436, Speaker A: Oh actually I forgot the style sheet. Let me fix this. So I'm gonna go, I'm not gonna spend too much time on HTML and Css because that's not the main point but I. Okay, so new file, so style, new file, style css. Right. So just here some basics, styling. Okay, so in layout here we, we import our style sheet.
00:11:16.436 - 00:11:55.982, Speaker A: Then here's some, we define the title for the type in the browser. Here we import some Google font API, sorry, some font from Google and, yeah, and so that's, that's pretty much it. So now let's run the server to see how it looks like on the front end. So you have to run NPM, run dev, it's going to run the local server. And now let's see localhost 3000, what we have. Alright, so we have an install bootstrap. Okay.
00:11:55.982 - 00:12:19.960, Speaker A: So let's fix this. I'm going to open a new terminal and I'm going to install bootstrap, bootstrap and ethers. So Bootstrap, that's for the CSS ethers, that's to connect to the blockchain. All right, so let's do this. And now if we go back to the front end. Now this is working. Okay.
00:12:19.960 - 00:12:48.110, Speaker A: Dex aggregator. Optimize your trades on dexs. Okay, amazing. So let's go back here and first we want to have a button to connect to, to metamask. So to interact with the blockchain we will need to go through metamask. If you want to read data or send transactions. We are going to use metamask which is basically a chrome extension.
00:12:48.110 - 00:13:31.490, Speaker A: So if you don't have metamask, the step one is to install it as you go to the website of Metamask. And basically there is a link to install it via the Chrome app store. Also type install metamask, chrome app store, chrome web store here and you go here and basically you can, you can install it. And then you're going to see this little fox here that shows you your wallet with your different address and how much money you have. Okay, so once you have this, so let's go back to our code. And so we need to create this connect button. So to connect to metamask.
00:13:31.490 - 00:14:45.000, Speaker A: So let's create a folder here in src slash apps, this is where we have the most of our code. So create a folder called components. And inside we're going to have a component called Connect js. Okay, and so inside we're going to define our button and with the logic as well. So we have the connect, let me see, connect. All right, and we're gonna return some HTML center everything, right? So let's do a button and let's put some bootstrap class in it to make it look nice. And let's make it big and let's put a margin on top.
00:14:45.000 - 00:15:46.060, Speaker A: Alright I, and so when we click on it, we're going to call the function connect that we're going to define before. All right, what else do we need for our button here? So we close this connect, we close the button. Okay. And when we click on it. So first let's make sure this is working here. Okay, let's go back to page js and we're going to import this. First let's make this a client component so, so that we can use a state inside.
00:15:46.060 - 00:16:26.986, Speaker A: Otherwise we cannot have state. So otherwise this is a server component and this you cannot have an internal state in next j's. So import connect from component connect. Right. And below here let's render connect. So let's see how this is working. Okay, so now we can see the connect button and if we click on it, then we can see here.
00:16:26.986 - 00:17:03.664, Speaker A: Okay, amazing. So let's go back to the connect component. And now we need to check if metamask was installed. So for this you check if window ethereum exists. If it doesn't exist, it either mean that metamask is not installed or it wasn't injected yet. So that's a basically a timing problem. Sometimes it doesn't have the time to, to get injected, but that's very rare.
00:17:03.664 - 00:17:42.550, Speaker A: Most of the time if you don't find it, it means that it just doesn't exist. And, and so after that, if we don't have it, we're gonna set an error. Okay, oops, set an error. You need to install metamask before using this app, right. And then we just stop here because there's a problem. And now we're gonna show the error message. Okay, so error.
00:17:42.550 - 00:19:04.110, Speaker A: Alright, so let me take a quick pause here and see the chat. What's the name of the ide? So I use versus code, which is the most popular ide for developer. Will you leave the git repo? No, no, I will make the git repo available to the member of eat the blocks, but I will not make it public. All right, so here let's display the error. So here let's put some margin on top, no margin at the bottom in here. What else do we have? Let's show the error. Okay.
00:19:04.110 - 00:19:50.390, Speaker A: And we need to define a state also. So let's do that. All right, so now we keep going in our connect function and now that means we have window ethereum. So we going to need to do the connection with it. By the way, we forgot here to put the use client directive for next j's. And we need also to import, use state from react. Okay.
00:19:50.390 - 00:20:49.408, Speaker A: And ethers also the library to connect to the blockchain. And so after that let's define, let's connect to metamask. And so to do that, the new ethers dot browser provider and you give it metamask. So window ethereum. And we're going to get a provider object. And with this we have a connection to the blockchain, but that's not finished because we need to this provider, we need to get another object inside it that is called a signer. And so at this moment the user is going to see a pop up that ask, ask the user if they want to connect to this dapp.
00:20:49.408 - 00:21:24.480, Speaker A: And once the user accept the dapp is able to see the address of the users room metamask. Right. So here let's get this signer. And after what we're going to do is we're going to save this signer, but not in this component, but we are going to lift it to the parent component because we're going to need it after to interact with the blockchain. So let's do this. And this is set sign. And this is a function that we are going to pass to our component like this.
00:21:24.480 - 00:22:08.290, Speaker A: All right. And we go to the parent component and we define a state. All right. And here let's pass set signer to this component. Okay. And let's import what we need to import here. Oh yeah, use state from reactival.
00:22:08.290 - 00:22:51.430, Speaker A: Okay. And let's go back to connect because we also need to wrap this in a try catch because it's possible that the user refused to grant us the access to metamask. So in this case we need to. We need to trigger an error. See, set error. You need to accept connection request of metamask to use this app. Right.
00:22:51.430 - 00:23:29.150, Speaker A: So with this, the. This component is finished. Okay, so now we are going to do the next component. Some question here in the chat. Connect set signer equals set signer. Is it something from next? Yeah, so exactly, it's from react. So when you do this, you are saying, hey, render the connect component and you define a property called set signer.
00:23:29.150 - 00:24:13.908, Speaker A: And then you give the value here. So here is the key and here is the value. Okay. And then in the child component, when you call set signer, you are going to save some state here, but in the parent component and after signer, here's it's going to have some value. Okay, so the next thing that we need to do here is. Let me see next once. Okay, so next we need a function, a JSON file with some information about the different dexs.
00:24:13.908 - 00:24:36.170, Speaker A: Okay, so let's create this. Where are we going to put it? This Src slash up. Yes. Okay, so new file. I'm going to call this blockchain dot JSON. Right. And what we need to define there.
00:24:36.170 - 00:25:12.374, Speaker A: So first of all, we're going to have a key called dexs. And this is going to be an array. And in this array we're going to have objects. And in each of this object we're going to have two key values. So gonna have the name of the Dex and here the address. So for example, uniswap. And we're going to use uniswap V two because it's way easier than V three and V four.
00:25:12.374 - 00:25:53.660, Speaker A: And it's also still very used. And for the address, basically you can google this easily. Uniswap V two, periphery address, ethereum. So periphery, this is the name of the contract that we want. There are several contract on Uniswap, but the one you're going to use most of the time is called periphery address Ethereum. Okay, Uniswap V two router is deployed at this address on Mainnet. Okay, great, let's wrap this.
00:25:53.660 - 00:26:34.250, Speaker A: That JSON parser is happy. Okay, so next we're going to have sushiswap V two. Right, and what's the address of Sushiswap V two. So sushi swap, V two, periphery address, ethereum. Okay, so here, deployment addresses. What we want is. Let me, let me see, V two, factory and router.
00:26:34.250 - 00:27:00.532, Speaker A: Okay, V two. So that's the one we want. Factory and router, v two router. Let's click on Ethereum. Okay, so it's this one. And finally we're gonna have a last one that's going to be pancakeswap. But the version that is on Ethereum.
00:27:00.532 - 00:27:33.950, Speaker A: Pancake swap. Oops. What I'm saying. Name pancakeswap VTU with the address. So how are we going to find this pancake swap v two router address on Ethereum. Okay, let me see. Pancakeswap, router, v two.
00:27:33.950 - 00:28:08.476, Speaker A: So router, v two space on Uniswap, V two. Yes. And on Ethereum, this is this address. Okay. All right, so now we have our dexes. Next we also need the Abi of those dexes. So all those smart contract here they are basically, they are the same.
00:28:08.476 - 00:29:01.868, Speaker A: This is not the same instance, but they have the same interface. The interface that they have. This is basically this contract here, Uniswap, v two router. And so you interact with this contract to do, if you want to do any buy or any swap operations or buy or sell or in general, most 99% of the operation you're going to do with a Uniswap clone, this is going to be through this contract and this contract. So the way we interact with a smart contract is that we need something called an ABi. So that's a, that's a JSON document that describe the, that describe the interface of the smart contract. So typically it's going to describe this function here as this name with this many parameter.
00:29:01.868 - 00:29:37.800, Speaker A: And it returned this, but it doesn't define the interface. Okay, just, just the interface. This is all we need to know to interact with this contract. And so, turns out that here we can find this Abi at this address. So unpackaged.com. that's basically, it's a website that store some build artifact of some NPM packages. So NPM, this is the, this is the package manager for Node J S.
00:29:37.800 - 00:30:16.866, Speaker A: And Uniswap has a package there that includes its. Okay, so we're going to copy all of this. So I'm gonna copy paste this in the chat, by the way. All right, let me see what we have in the chat next. Live. Can you build a flash loan arbitrage trader trading bots? Maybe, maybe, maybe there's a good reason to make wallet authentication process easier. Like Morales.
00:30:16.866 - 00:30:44.690, Speaker A: Yeah, Morales is great. But here, I don't want to use too much, too many API because otherwise we learn nothing. Okay, then I made a code using solidity. There was an error on line 37. I have no idea. You have to figure out yourself. Okay, we are doing this tutorial without debugging your code, but nice try.
00:30:44.690 - 00:31:14.684, Speaker A: I think this section is a part of arbitrage app. No, it's not arbitrage, it's we're building a tool for trader basically. But if you want to do some arbitrage tool it's great because by doing this app you are going to learn a lot. Okay, so here, let's select this API. Let's do select all of this. All right. And let's go up to here.
00:31:14.684 - 00:31:35.104, Speaker A: Okay, let's select that. Now back to our code. And now we're going to win to define another key called Dex Abi. Alright, so let's paste this. Alright, so let's crawl up, let's make sure everything was pasted properly. Dex API. Yeah.
00:31:35.104 - 00:32:39.836, Speaker A: Okay, perfect. So now let's go back to page dot j s and we are going to import this JSON document blockchain from blockchain dot JSON. Right. And what we're going to do is as soon as we get a signer we are going to create a, we're going to create a JavaScript object connected to, connected to the different dexes, okay, so we total, we going to have three of them because we have three, three dexes. Okay, so let's do this here dexs. Dexes use state, okay. And here actually we're going to have some, let me show you what's the initial shape of that.
00:32:39.836 - 00:33:49.510, Speaker A: Okay, so basically our initial, initial Dex is going to look like this. So for each dex we're going to have a name, okay, an address and a contract that at the beginning will be undefined, but we are going to populate it, right, so that is initial dexs. So how we're going to do that? So let's do this. Initial Dexs in here. Let's read the Dexs key of our JSON document and we are going to map it because we already have two key that we interested in. We have the name and, and the address. Okay, so we're going to keep this but we want another key here, let's return something.
00:33:49.510 - 00:34:54.022, Speaker A: And inside we gonna, first we're gonna have the two keys that we already have. Okay, so here we use the spread operator and we're gonna add another key. Okay, so with, let me see, contract and that's undefined to begin with, but it's going to be populated after. Okay, so now we have an array of all these initial dexs and now let's populate the contract. So let's use use effect. This is a function from react, and this is going to be triggered as soon as there is a change in signer. So in the connect component, when we click on connect, it's going to activate set signer, it's going to populate signer here.
00:34:54.022 - 00:35:46.810, Speaker A: So it's going to trigger use effect. And here, let's make sure that there is a signer. And if that's the case, then what we do is we define a new Dexis object, right? Actually, this is going to be similar to this. So let's copy paste this, but it's not going to be exactly the same thing. So new dexs, and now we're gonna populate contract. So we are going to use the contract keyword of ethers. So let's import contract from ethers, the library to connect to the blockchain.
00:35:46.810 - 00:36:22.056, Speaker A: And first we need the address of the Dex. Okay. Then we need the Abi. So that's gonna be blockchain, dot Dex Abi, and finally the signer, so that we can, because everything will go through metamask. Okay, so now we have the new dexs, and now we need to save this. Let me see. Yeah, now we need to save this in the states.
00:36:22.056 - 00:37:01.150, Speaker A: So set dexs, new dexes. All right, so when the component load, initially, we have the initial dexs here, but without the contract, and as soon as we have a signer, so as soon as the user have approved, have connected metamask to our app, then we can populate the contract, the contract field here for each Dex. Okay, so now we need to do something. Oh, by the way, use effect, have we. I don't think. Yeah, we need to import it here. Use effect.
00:37:01.150 - 00:37:55.890, Speaker A: Okay, next, we need to conditionally render another component, search trade. So this is where we're going to put the detail of our trade. What is the token we are going to sell? What is the token we're going to buy, and how much of the token that we want to buy. So let's go below here. And if there is a signer, we are going to render a new component that we're going to call search trade, and we're going to pass it. The dexes that we have in the state. Okay, as well as the.
00:37:55.890 - 00:39:04.060, Speaker A: We need the signer as well. Right. And if we don't have signer, then we're going to render connect. Okay, so let's move this here, right? So we only render connect when we don't have the signer. And for search trait, we're going to define this component so this is going to be new component search trade. And let's go in components search trade js. All right, it's going to be a client component and let's export the component here, export default function.
00:39:04.060 - 00:39:36.620, Speaker A: And let's extract what we need. So we need the Dexs, we need the signer. Okay, and let's return some basic styling. Search trade. Alright, so let's see if we have any error here. Apparently not. Let's see in the front end now.
00:39:36.620 - 00:40:04.430, Speaker A: Right. Seems like everything is fine. Let's click on connect. Search trade. Okay, so, so far so good. So let's go back to search trade. And now we're gonna do a form, okay, so let's do a form where we're gonna ask the detail of the trade.
00:40:04.430 - 00:41:02.400, Speaker A: Okay, so here let's wrap everything by a div form floating. So that's some bootstrap styling to, to have a nice form. And here's some margin bottom to give it some breathing room. And so first we're going to have an input for the address of the first token. Type text, right and place. So the id token in this is for the label we're going to put below placeholder. So this is the value when there's nothing, zero x.
00:41:02.400 - 00:41:58.000, Speaker A: And we're going to have on change. So every time it changes we're going to update our state set token in e target value. All right, so we need a state for that. And initially, initially this is going to be an empty string. Okay. And the value it's going to be token in. Okay, now let's close this input.
00:41:58.000 - 00:42:29.012, Speaker A: And now let's put a label also to make it clear what it is. So label HTML four. And that's token in. So it matches the id here. Address of token sold. Okay, let's go back, see what we have. Connect use state is not defined.
00:42:29.012 - 00:42:56.712, Speaker A: No problem, no problem. I know how to fix this. Okay, so now connect address of token sold. Alright. With a nice little effect here. Okay, perfect. Next we're gonna have another field, but this time it's gonna be for the token we buy.
00:42:56.712 - 00:43:47.770, Speaker A: So this one is token we sell to. Can we buy? This is gonna be token out. Okay, address of token bought. And now it's gonna be set. Token out, token out. Okay, we're gonna have another state token out. All right, it's working then what else do we need? We need to have now the final input is going to be the amount of token bought.
00:43:47.770 - 00:44:43.572, Speaker A: Okay, so we have the two addresses but now we need the amount of, so we're gonna call this amount out. And here the placeholder. This is gonna be a number set amount out and the text is going to be amount of token bout. Okay, now the state. So it's a bit repetitive now, but it needs to be done. Okay, so now connect. Okay, amount of token bouthdemental here.
00:44:43.572 - 00:45:23.782, Speaker A: Zero x something. Zero x something. Okay, so the form is working fine. And we also need to have a button to submit all of this because we want to save this in a state and send it to the parent component. So type submit class name to make to style it a little bit. Submit. Okay, and now when we click on submit, we want to capture this event.
00:45:23.782 - 00:46:22.612, Speaker A: So on submit here is going to trigger a function called search. And just above we're going to have this function here, search. And first thing is to prevent the form from being submitted. Then what we want is we are going to get a quote from each of the Dex. Okay, so here we have Dexs, which is an array with the detail of all the Dexs. So uniswap, pancakeswap, sushiswap, basically everything that we put in blockchain, JSON and we're gonna go through all those dexes and one by one we're gonna ask them what's the price for the trade that we want to do. So we have the token in input, we have the token in output, we have the amount.
00:46:22.612 - 00:47:00.176, Speaker A: So that's enough to get a quote. But we need to know which function to call. So let's go in uniswap router two. And there is an interesting function here. It's called getamounts out. Okay, so here gets amount out. Basically you tell it, hey, I, let me see, get demands, get some out or get cement in.
00:47:00.176 - 00:47:35.938, Speaker A: Sorry, sorry, getting confused. Gets int. So you tell it, hey, I want to buy this many token. Okay, so for example, can be wrapped ether, USDC, USDT. I want to have this. Here you specify the amount and here you specify the pass. So the pass, the first element of this array will be the address of the token that you used to buy and the second element will be the token that you will get.
00:47:35.938 - 00:48:18.640, Speaker A: Okay, so basically you are saying, hey, I want to buy this token with this other token and in output, I want to have this many token. How many tokens do you need in input? And is going to answer you with an array. So it's a bit weird that. Why does it, why does it answer you with an array? Because basically we only interested in one thing, the amount in. But actually in this array the first element will be the amount in, in the token that you buy and that the token that you used to pay. Sorry. And the second element of is the amount in for the token that you're going to get.
00:48:18.640 - 00:49:08.236, Speaker A: I know it really, it's not really easy to understand. The TLDR is we only interested in the first element of this array. Okay, this is the amount in, okay, so let's go back here in search trade and we're going to iterate through all the dexes and call this function. So how we're going to do that, we're going to create an array of promises and then we're going to call, we're going to do all these calls together. So otherwise if we, if we wait for each of these call to be finished, if we don't do them concurrently, then if we have many call to do, it's, it's going to, it's going to be very limiting. So Dex is map. And for each Dex, what we're going to do, we're going to build this promise.
00:49:08.236 - 00:49:53.794, Speaker A: So dex.com contract and we know that in the parent component we've built all those objects, okay, with the ethers libraries. Now we know that this points to each Dex and we can call directly all the function on the routers. Get amounts in, for example, that is available, gets amounts in, okay, in. And the first argument is how much money we, how much token we want to buy. So that's this one amount out after which token we use to make purchase. That's token in and which one we want token out.
00:49:53.794 - 00:50:40.810, Speaker A: Okay? And let's get all of the, let's call this the calls array. And now what we're going to do is we're going to execute all of this call. So promise all basic takes, this is a JavaScript, a JavaScript function that allow you to execute an array of promises, okay? So at this point here in cost here, we haven't launched any of the call yet. We are just defining what, what will be those calls, the shape of those calls. It will be with this function, with this argument. But this is not triggered yet. And it's only during this line that we actually trigger all of this.
00:50:40.810 - 00:51:45.882, Speaker A: We use the await keyword. So it's going to call launch all those calls. And when everything finished, when we have all the answers we need, we're going to have an array quotes here. This is actually going to be an array of array, okay? So we're gonna have the like this because you remember that here, get in. It returns an array in return, but we only care for the first element of each inner array. So, okay, so we have, we have all those, all those quotes, but the problem, so now we want to sort them, okay, we want to find the best quotes, the, the cheapest deck, the cheapest decks. But the problem is that if we sold the array like this, we don't know, we don't know which is which, okay, because there is no, there's just a number, but that's it.
00:51:45.882 - 00:52:45.390, Speaker A: So now we know this is in the same order as what we had in this array, but if we modify the order after that, we will not know what is what. So we need to attach some more info to be able to identify each element. So let's do this quotes map, and for each quote of we're gonna add some more info. So let's build an object and we're gonna have a couple of information. So the address and here got the address of the Dex. And with this we know what the quote correspond to and the amount in. So that's basically the quote and that's the first element of the quote.
00:52:45.390 - 00:53:31.820, Speaker A: Amount out. Well, amount out. So here it's basically when you do, when you do this, it's as if you do amount out, amount out. Okay, this is a shortcut notation. When you don't specify the value, when the key and the value are the same, and then we have token token in. So the address of the token we used to pay the address of the token that we purchased. Okay, and let's collect all of that in a new variable called tradesmen.
00:53:31.820 - 00:54:30.312, Speaker A: And so now we can sort those trades and just take the best one, trades dot sort, and so sort. This is JavaScript function to sort array. And we're going to have two arguments. So we're going to compare two elements of the array two by two, trade one, trade two, and we need to define the sorting logic. So, sorting logic, we take trade one dot amount in and it needs to be, let me see, basically we want to minimize the amount in because that's the amount of token that we need to pay. So we want the price to be as low as possible. Of course we want to minimize this trade two dot amount in.
00:54:30.312 - 00:55:11.922, Speaker A: Okay, and if that is the case, return minus one, which means that trade one should be before trade two in the resulting array. Otherwise that's not the case. So we order by lower amount in. All right, let's finish this. And this is in JavaScript. The sort method is in place, meaning that it's going to modify the trade array in place so we don't need to define a new array. Okay.
00:55:11.922 - 00:55:47.310, Speaker A: And now we need to, let me see. Now we need to save the best trade. So for that we're going to store this in the parent component with new state. And what we want is the first element of the array. This is, this will be the one with the lowest amount in, that's the lowest price basically. Okay, so we don't have set trades, so we need to define it. Set trades.
00:55:47.310 - 00:56:57.018, Speaker A: Let's go here in the parent component page j s, and let's define a new, new state called trade. All right, and then we're going to pass this to, let me see, let's scroll down and let's pass this to search trade. So set trade. All right, so let's go back to search trade and let's go back to our function. Okay, so now we have found the best trade to do the best Dex with which we want to interact. But there is another thing that we need to save. We need to have a pointer to the token that we need to buy.
00:56:57.018 - 00:57:36.700, Speaker A: So basically token in. And that's because the, any of the Dex when they want to trade without token, they're going to use a yes. 20 function called transfer from. Okay, you, we can actually see this code. Let me, let me show you here. So you need to have v two router and the function we're going to use is function swap tokenization for, let me see, let me scroll up. Why doesn't find it? Swap.
00:57:36.700 - 00:58:14.958, Speaker A: Oh, swap tokens for exact token. Okay, this is the function we're going to call after. And you can see here that this function here is critical transfer from. So it's going to try to pull the token that you use for paying from your address to its contract. But for this function to work, first you need to have approved Uniswap to spend your token. You know, it's like when you authorize a merchant to spend your, your credit card every month. Let's say you take a subscription, you use a stripe.
00:58:14.958 - 00:59:06.140, Speaker A: So what you're actually saying when you click on submit is you are telling to your credit card company, I authorize this merchant to take money from my credit card. And so we need to do the equivalent, but for smart contract. And this is in order to do that, we need to have a pointer to the token that we use for payment. Okay, so let's define this pointer with the contract object from ethers. We don't have it here, so let's import it. All right, let's do this new contract token in. So yeah, first we need the address of the smart contract.
00:59:06.140 - 00:59:23.880, Speaker A: Then we need the Abi. So blockchain dot. I think we call this ERC. No, we did not define it. No, no, we did not define it. Let's see, blockchain JSON. Yeah, we just have the Dex Abi, but we don't have the ERC Abi.
00:59:23.880 - 00:59:59.150, Speaker A: Okay. So the Ercabi, you can just google Erc Abi. And there is a gift here that's going to give it to you. So let me see row. Right. Let's select all of this. So let's go to blockchain JSON and let's define another key.
00:59:59.150 - 01:00:18.270, Speaker A: We're going to call this ERC 20 API. All right, let's paste this. Okay. And inside we're going to have transfer from this what we are interested. Let me see, transfer here. Where is transfer from decimals. So it can be interesting.
01:00:18.270 - 01:00:38.876, Speaker A: A transfer from. Yeah, yeah. So we have it. Okay. And we need to import blockchain, the JSON file. So import blockchain from. So let's go up one level and that is blockchain dot JSON.
01:00:38.876 - 01:01:08.850, Speaker A: Okay. And here's ERC 20 Abi. Okay. And finally we need to pass the signer. Do we have the signer? Yes, we have it. Okay, perfect. And now we need to put this in the variable and then we're going to save this to the parent component.
01:01:08.850 - 01:01:44.980, Speaker A: Okay, so set token. Okay, let's go to the parent component. Let's define this new state. And let's pass this state, this state setter here. So set token, equal set token. You know what, it start to be a little bit busy here. So let's put everything on their own line.
01:01:44.980 - 01:02:18.960, Speaker A: It's a little bit more tidy. Okay, so search trade. I think search trade is working now. So let me see if we can, if we can test this. Let's go back to the front end. Let's reload, connect. And now let's do some test.
01:02:18.960 - 01:02:40.590, Speaker A: Address of token sold. Address of token bot amount. Okay, submit. Sectrates is not a function. Okay, interesting. Search trade line 30. So we have an error here.
01:02:40.590 - 01:03:11.712, Speaker A: Line. So it shouldn't be, let me see, is it search, set trade or set trade? No, we just need one trade. Right, so it shouldn't be plural. All right, let's go back here to the parent component. Set trade. Okay, so what about now? If we click on it, let's clean this. If you click on it, we have no error.
01:03:11.712 - 01:03:36.566, Speaker A: So here something is not right. Address of token sold. We have like object. Object. We shouldn't see this. We probably have a problem with the way we save the state. So let's go back to search trade e target value.
01:03:36.566 - 01:04:30.108, Speaker A: So here, what's the token out, token in? I don't see the problem. Token in, set, token in, token out, set, token out. What do we have this problem? I don't know, I don't know. Well, we will see later. Moving on. Moving on. Okay, so we have search, trade, and now, so we are able now to find what is the best trade.
01:04:30.108 - 01:05:55.530, Speaker A: Okay, so we put the different parameter here and we are able to put to get the best trade. So actually I want to prove it to you. So let's do some console logging here. So let's console log trade one amount in. And this is going to be in a weird format that is a big int. So that's a JavaScript, it's a type of number in JavaScript to handle really big number, but we need to transform it to a string so that it's readable. Okay, so trade amount in and let's do it for, let's, let's do it for, for the three entry we're gonna have, okay, so trades one, two, three, and logically it's gonna be ascending, it's gonna be sorted, and here we can also see the, let me see, we can see the address also.
01:05:55.530 - 01:06:30.010, Speaker A: Yeah, we can see the address of the Dex. Okay, so let's do that. Okay, let's try again. Let's try again. So let's reload, connect, address of token sold, address of token bought, then the amount of token bought. Let's click on submit. Okay, so now let me see, is it correct? Yes.
01:06:30.010 - 01:06:54.854, Speaker A: So this is the lowest amount. Okay, this one is slightly bigger and this one is bigger. Okay, so our function is working. And this is the address of the exchange. So let me see, in blockchain dot JSON, what is this exchange? So that's uniswap. Okay, Uniswap give us the best price. That actually makes sense because Uniswap is bigger than sushiswap and pancakeswap.
01:06:54.854 - 01:07:32.136, Speaker A: So usually it has, so that means it has more liquidity and usually it has a better price, but that's not always the case. That's why we are building this up. Okay, so so far it makes sense. It seems like this is working. So now that we are able to get the best trade, we need to execute it. And for that we're going to create another component that will be called just trade. Trade js, where we can execute the trade.
01:07:32.136 - 01:08:20.878, Speaker A: Okay, so use client export default function, trade right and let's return for now, just trade. I. Okay, and so now what happened? If we click on, we need to render that. Sorry. So let's go to the parent component. Let's import that trade. Okay.
01:08:20.878 - 01:09:15.760, Speaker A: And let's scroll down and we're going to render it below search trade, but only, only once we have a trade. Okay, so how are we going to do that? If we have a trade, then you're going to render the trade component and we need to wrap this by a, an empty HTML tag. All right, so now, yeah. Okay. We can see the trade component below. Okay, amazing. All right, let's see.
01:09:15.760 - 01:09:52.786, Speaker A: Let's see what we have in the chat veer, do you upload the live session on YouTube? It's recorded. Yes. Looks like you've given us the blueprint for an arbitrage, but that can be an element of it, but that won't be enough. Yeah, it's live. Okay, so let's keep going. Let's keep going. And now we need to code the trade component.
01:09:52.786 - 01:10:37.894, Speaker A: So let's get back to it. So in this trade component, let's see, first we're going to have an h two and say the best price was found. Let's give it some styling, let's make it bold and some margin at the top. Let's wrap this by empty tag here. Okay. And after that, what do we want? So we want to show the detail of the trade to the user. Okay.
01:10:37.894 - 01:11:28.010, Speaker A: So this group class name, this group item. Okay. And so here we're going to have a list with different items. So first, what is the exchange? So Dex dot name. Oops, Dex. Ah, it's the autocomplete of versus code that is interfering. I need to disable.
01:11:28.010 - 01:12:03.478, Speaker A: Yeah, disable it because it's really bad here. We're going to pass the, let me see here. We're going to pass all the dexes, but we need to select the right one. So let's do that. So in this array of Dexs, we're going to find the Dex that. Let me see. The Dex was the correct address.
01:12:03.478 - 01:12:54.296, Speaker A: Okay, so, okay, and so let's pass Dexs and trade in the parent component and trade. Okay. Yes. Let's go back to trade. And so now we have the name of the Dex. Then let's do the address of the token soldier. So now this is going to be on the trade object.
01:12:54.296 - 01:13:35.258, Speaker A: Trade. Right. What else? Address token bot trade token out. All right, now the amount, maybe. Amount. Hey, maybe it's going to be better, more clear to group the amount and the token, yes, like this. So amount, token sold.
01:13:35.258 - 01:14:18.220, Speaker A: And this is going to be amount, amount in. But as I told you before, this is going to be in this weird format called big int. So we need to transform this to a format that we can understand, human readable. So we call the tostring function and we need the amount of token bouthdemental. So let me see. Trade amount out. This one is already in a human readable format.
01:14:18.220 - 01:14:45.732, Speaker A: And we also need to define, okay, so first of all, let's, let's check that this is working. Connect. Okay. Let's just fill the different field here. Submit. Okay. The best price was found.
01:14:45.732 - 01:15:33.460, Speaker A: Amazing. So xn uniswap v two, the token address token sold. Yeah, amount sold. Okay, so 3000 something USDC and to buy one ether. So so far it makes sense. And I also want to show another parameter which is the slippage. So basically the slippage, we need some tolerance because the amount that were calculated before, there is no guarantee that they will be exactly accurate because the price keep changing for after every new transaction, maybe the price will be better, but maybe the price will be worse.
01:15:33.460 - 01:16:19.452, Speaker A: And so we need to have some tolerance. So for that we need to define the slippage parameter. So let's do that. Slippage tolerance. All right. And how we're going to define this? Well, there are some smart way to calculate this and it can be pretty involved really. But you know, I don't want to spend too much time on this.
01:16:19.452 - 01:16:52.130, Speaker A: So we're just going to hard coded slippage tolerance. And let's just make it 10%. Okay, so this is a percentage here. Just define it like this. Okay. And after that let's define a button to trigger the trade. Right.
01:16:52.130 - 01:17:40.630, Speaker A: Trade. And on click, let's execute trade, right. And it's going to be disabled while the trade is processing. So we're going to define a new state processing set processing. Originally this is false. Let's import this from react. Okay.
01:17:40.630 - 01:18:42.940, Speaker A: And if this is processing, then we're going to show something at the bottom processing. Okay. With some margin on the top. Your trade is process is processing. Please wait until the transaction is mined. Okay, that's for processing. Now let's define the function to execute the trade.
01:18:42.940 - 01:19:39.250, Speaker A: So it's going to be an asynchronous function. And first thing is, let's set processing to true. Okay. And here we're going to have a big try catch statement because the transaction can fail. And so when, no matter if it fails or not, so the finally block is going to be called in every case. So we want to set processing back to false here, here. If we have an issue, we're going to set an error.
01:19:39.250 - 01:20:35.090, Speaker A: To set error to true, you're going to show an error and console log the error. So let's define a new state. We're going to have also another one between those, which is confirm. Okay, and here this is going to be error. All right, so now let's, let's display those messages. Okay, so this one will be process. Let me see, confirm.
01:20:35.090 - 01:21:30.510, Speaker A: So after the trade was done and here we're going to say, congrats, your trade was successful. And that's it. And also going to show another error message for in case of error. So now error. Okay, and here's going to be danger to show different color. Let's see what should be the error here. Oops, your trade failed.
01:21:30.510 - 01:22:22.796, Speaker A: Please try again later. Okay, so now we have our different error message, our different state. So let's go back to execute trade in. First thing is we need to approve the token to be spent by the Dex. Okay, but so we have already, where can we find this amount? So trade that amount in. Okay, we already have it, but we need to take into consideration the slippage we define. So for that we are going to modify to multiply this by 100 plus slippage tolerance.
01:22:22.796 - 01:23:17.108, Speaker A: But the problem if we do this, it's not, let me see, slippage. Slippage tolerance. So we need to transform this into a big, actually, I don't know if a bink int big int can multiply a non big int, but as long as this is an integer, I think so. But just off security, let's cast it to a big int like this. Okay. And now we need to define, to divide this by 100 because here we actually want to, the real operation want to do is multiply by 1.1. But we cannot do it directly because this is not possible to multiply a big int by a decimal number.
01:23:17.108 - 01:24:02.364, Speaker A: So we need to scale this by 100 and then define, divide everything by 100. And here we can make the shorthand notation. To cast it to a big int is we add n like this. Right? So this is how we define the amount, the amount we need to approve. Okay, so now let's use the token. Let's use the, the pointer to the token and we're going to approve it. But by the way, where, where does it come from, this token? Well, we actually get it from the parent component.
01:24:02.364 - 01:24:20.536, Speaker A: So let's go to page here. Token, token. Okay. Okay, let's go back to trade. So it's gonna be token. Let's just minimize this a little bit. So token dot approve.
01:24:20.536 - 01:24:55.948, Speaker A: So approve is a function to allow another contract to spend your token. And we're going to approve the dex to spend our money then amount in Max. Okay. Okay. And so now we have sent the first transaction and we need to wait until this is mine. So the user is going to see a first pop up here that you will have to validate. Okay.
01:24:55.948 - 01:26:07.170, Speaker A: And here we're actually waiting that the first transaction is mine. And we need to make sure that the receipt transaction was successful because even though this is mine, it doesn't mean that it was, the transaction was successful. So receipt dot status equal one. And now if this is different, the status is different from one. I think this is between, I think this is as a string, then we're going to throw an error because that means the approval failed. So we shouldn't continue with the process approve transaction failed and so the execution is going to jump to the catch block and everything that is after is not going to be executed. Okay, so once we've done the approval, then we can finally do the swap.
01:26:07.170 - 01:26:32.452, Speaker A: So we need to define a few argument. Actually let's, let's go back to the GitHub definition here. So swap tokens for exact token. So there are different version for swapping. A swap is basically when you buy a token against another one. The one we want is this one. Swap tokens for exact tokens.
01:26:32.452 - 01:27:32.666, Speaker A: So what is exact is the amount that we get in output and what is not. What is not exact is what we provide in input. So we provide a maximum here, but it could be less than this. Okay, and there's another version where you, you specify swap exact token for token, where when what is exact is in input, it's just for our use case. I think to me it made more sense to say, hey, I want to buy this amount of token, how much should I provide you an input for me? Just in our use case this made more sense, but you can have a different choice. So after that we need to pass an array of addresses. Okay, so basically the token and input, the token in output address two is who is going to receive the token.
01:27:32.666 - 01:28:21.102, Speaker A: And deadline is basically how long is this transaction validore. So that's in the case of, let's say you send a transaction and then it gets stuck in the blockchain for a long time and then maybe one week later this is executed. And this is not at all what you wanted, because now the price has moved completely. So your former instructions just don't make sense anymore. So to protect against this, you can specify also a deadline parameter, which is basically an epoch number. So that's the number of seconds since January, 1970. Okay, so now let's define the recipient.
01:28:21.102 - 01:28:56.380, Speaker A: So the recipient for that we will need the signer, the metamask signer, get address. So by the way, let's, let's get it signer. Okay. In the parent company, let's pass it signer. Okay, let's go back to trade and. All right, let's get the signer then. Let's get the deadline.
01:28:56.380 - 01:29:29.006, Speaker A: So the deadline, actually, it could be something that you specified that you let the user choose. So you can make a suggestion, but you let the user adjust it. Well, here we're just going to hot code it. So let's date. Now this is going to give you the epoch, but in millisecond, but we want it in second. So let's divide it by 1000. And now we're going to add an offset.
01:29:29.006 - 01:29:51.356, Speaker A: That is arbitrary. But, for example, can be one day. So one day will be like 86,400. Could be, could be 1 hour. So 1 hour, 60 minutes. So 60. 60 times 60, right.
01:29:51.356 - 01:30:21.098, Speaker A: So let me see, is this correct? So, Julian, Julian, Julian. All right, you guys can see I'm tired. It's after midnight here. So my brain is not, it's not fully functioning. But how many seconds in 1 hour? Okay, so, so we have 60 minutes in 1 hour. Okay, that's correct. In each minute we have 60 seconds.
01:30:21.098 - 01:30:43.958, Speaker A: Right now. I'm not stupid. So, yeah, 60 times 60 then. All right, let me see a little bit in the chat here. If we still have some people. So via protap 17 watching. 17.
01:30:43.958 - 01:30:55.130, Speaker A: Like 100% approved. Now we have 101% approved. Ah, amazing. We are breaking YouTube. No, it's live. Live. Live.
01:30:55.130 - 01:31:33.748, Speaker A: Okay, so now we have the deadline. Now what we need after that, well, after that we can finally do the swap. Okay, so Dex dot contracts, swap tokens for exact tokens. So this is the same name as I show you before, exactly the same autograph. And now we're going to have the different amount. So trade dot amount out. Amount in max.
01:31:33.748 - 01:31:58.420, Speaker A: We just calculate just above by taking into consideration the slippage. Now the address of the different tokens or trade dot token in. Trade dot, token out. Okay. The recipient. And finally the deadline. All right, and let me see what else.
01:31:58.420 - 01:33:12.090, Speaker A: Okay, and after that, let's get the receipt. Receipt two. All right, and so if the receipt, if the receipt is not one, then the error is going to be a swap. Basically trade failed. All right. And otherwise? Otherwise we're going to do set confirm true. And let me see.
01:33:12.090 - 01:33:43.672, Speaker A: And it seems like, seems like we've made it, I think. Seems like we've made it. Yeah. Okay, so let's go back to the front end because I'm sure they're going to be some error as always. All right, so let's reload everything. Connect. Boom.
01:33:43.672 - 01:34:11.794, Speaker A: Let's do it. Let's go. USDC wrap ether amount submit no error so far. So now if I click on trade. Boom, error right away. Trade line 37. Okay, what's wrong? Trade line thirties.
01:34:11.794 - 01:34:39.666, Speaker A: What? Oh no, no, sorry. Trade line 16. Token is, ah, okay, okay. I don't know. Here. That was not correct. Okay, so now what if we click on trade again, cannot read property of undefined.
01:34:39.666 - 01:35:14.100, Speaker A: So reading approve. Okay, so token is not defined. So that's probably problem at this. Okay. Okay, so I probably need to reload the whole thing, connect. So let's try again. Okay, the other token, the amount.
01:35:14.100 - 01:36:07.706, Speaker A: Okay. Trade cannot read property of undefined. So for some reason, for some reason, let me see. Yeah, for some reason here the token is empty. Why is that? Why is that? Do we use it? So we are supposed to use it in search. Trade set token here. Okay.
01:36:07.706 - 01:36:18.346, Speaker A: Ah, okay. Okay. Okay. I'll find the corporate here. There's a typo. It's not set token in is set token. Okay.
01:36:18.346 - 01:36:53.912, Speaker A: Okay. Finally we find the problem. So if I click on, okay, we need to reload everything. So now should be fine. USDC then wrap ether. Yeah, so that's the most fun part when you're almost done, but there are a couple of bugs at the end. Trade.
01:36:53.912 - 01:37:32.546, Speaker A: Ah, now your trade is processing and now we need to ask us to approve USDC for Uniswap. And it's 3400 something, which is consistent with the amount that we see here. So that is basically 3000 something plus 10%. So let's calculate this 3000 something plus 10%. So it's 3400, 448. And how much was it? Yeah, so that's basically the same. Yeah.
01:37:32.546 - 01:38:07.672, Speaker A: So here if we click on approve, so it's going to send a transaction to the blockchain, do the approval and after we're going to have another pop up to do the actual transfer. So we're not going to do it because this is some real money here. But yeah, it's working. Amazing. Wow, we finally made it. Okay, so hope that you guys follow so far. So now how can you make it even better? Okay, so there are a couple of ways.
01:38:07.672 - 01:39:24.658, Speaker A: So some easy way, for example, you can add more dexes. Okay, so if you go to blockchain JSON here, all you have to do is you just add a new dex here with a new name, a new address, and there are ton of clone of Uniswap on Ethereum. Okay? So you can do it easily. Now what if you want to add some dexs that are not clone of Uniswap? Well, now it's going to get slightly more complex because the ABI is going to be different. So what you could do is you could maybe integrate with, I don't know, two or three different kind of decks, but maybe most of them will be clone of uniswap. But for the one that are different, that means your code is going to adapt and to be different, and it's going to significantly complicate your code, unfortunately. So what else can you do to improve our project? So one thing that is not great here is that we specify the token amount in elementary unit, but it's really not user friendly here.
01:39:24.658 - 01:40:17.464, Speaker A: This means one, one ether basically, but it will be better if I just write one and then the code is able to understand the number of decimal. And so for that it will really complexify, because that means you need to check out the address of the token out, create a contract object that points to it called the decimals function. And the decimals function is going to tell you how much decimals they have. And then I internally in the state, transform the amount that was given by the user, multiplied by the decimals to have the real number. So that's basically you show the user, we show one thing to the user, but internally we have another number. And same thing here. It also works in the other direction.
01:40:17.464 - 01:41:11.308, Speaker A: Like instead of showing this amount, that is a user not friendly amount. If we knew the number of decimals here, we would just show 3135, seven maybe, and that's it. But what is complex is that each token, so most of the token use 18 decimals, but not all of them. For example, USDC uses six. So that means in your code every time, you cannot make an assumption that the decimals will be 18 every time. You have to call decimals, what is the decimals? Do the calculation and just makes the code more complex. And we could also allow the user to specify the slippage they want, even we could make a suggestion, but they should be able to change it and same thing for the deadline.
01:41:11.308 - 01:41:46.792, Speaker A: Okay, so yeah, a couple of ways that you can improve this project, but already I think we made something pretty cool, right so let me see if we still have some people following Chanchao. Yes. Qatar zinc. No, no, no. Chen chao, please share that. Okay, so as I mentioned before, those live stream I do on YouTube, so I'm happy to do them for free. The source code will be shared to the private community of eat the blocks of.
01:41:46.792 - 01:42:25.596, Speaker A: So this is something that I will launch very soon. This will be a pet community private where basically to build on these projects. I will share the source code there and there will be discussion for people who want to keep working on those projects. And so this is great if you want to learn or for your portfolio for example. This is also very useful. Yeah. So we are going to stop here, but just before last thing.
01:42:25.596 - 01:42:54.900, Speaker A: If you are new here, if you are new here, check out the free roadmap to become a blockchain developer. So this is basically a free career guide. It's going to explain everything you need to learn the different way to specialize as a blockchain developer and how to find your first job either blocks.com roadmap. This is going to save you a lot of time. Okay. So make sure to check it out if you are new here.
01:42:54.900 - 01:43:21.210, Speaker A: Someone is asking, where can I find this community? I haven't launched this community yet, so I will let you know when it's live. Okay. So thanks everybody for following today and I will see you later. All right, bye. It's.
