00:00:00.330 - 00:00:33.190, Speaker A: In solidity, strings are not super famous to manipulate, but in this video I'm going to give you a couple of tricks like how you can concatenate two strings, how you can find the length of a string, etc. If you don't know me, I'm julian, and on my channel in the blocks I teach blockchain development. So first trick, how to find the length of a string. So let's do this. Let's create a function length. So we define our string as argument. This is going to return an integer.
00:00:33.190 - 00:01:12.082, Speaker A: So we cannot just do str length like we can in other programming language like JavaScript or Python. Before we need to cast our string into a bytes, and after on the bytes type we can access length and we just have to return this. Okay, so let's try it right away if it works. So for example, ABCD length four. Yes, success. Okay, so next let's see how can we concatenate two strings in solidity. So let's do this.
00:01:12.082 - 00:02:03.490, Speaker A: Function concatenate two, argument will be string. So a n. Oh, you know what, this is going to take a lot of space. So string cold data b, what I'm saying? Yeah, like this. Okay, after that let's make this external, let's make this pure, and it's going to return a string in memory this time. Okay, so can we just do return a plus B? That would be too easy. No, we can do this.
00:02:03.490 - 00:02:50.210, Speaker A: However, the trick we're going to use is to use an obscure function in solid called AbI encode pact. And this is going to concatenate our two variable into a bytes type. But this is not okay because we want a string. So from a byte type we can cast it back into a string with the string operator that way. Here, I forgot a comma. Okay, so let's redeploy our smart contract. Let's try to concatenate hello world concatenate.
00:02:50.210 - 00:03:29.120, Speaker A: Yes, it works. Next, how can we reverse a string? Let's do this. So create a function called reverse string called data underscore, str external pure. It's going to return a string in memory. Okay, so the first thing we want to do is to turn our argument into a byte. So let's do this. So we define a new variable of type bytes in memory called STR.
00:03:29.120 - 00:04:21.360, Speaker A: And after we're going to create another variable of type bytes that has exactly the same length as the byte. And this is this temporary byte that we're going to use to copy the reverse string. So you might be tempted to do something like bytes memory, new struct. But if you do this actually you're going to have two pointer to the same kind of data. You're not going to have an empty copy. So that's not what we want. So instead here we're going to create a new string that has the same length as the bytes before.
00:04:21.360 - 00:04:51.370, Speaker A: And this is going to be a string and we just need this temporary. So let's call this TMP. And after we're going to build a bytes variable based on this temporary string. And this is going to be the reverse string. In the end here we build our bytes based on TMP. Okay. And after we going to iterate on the SDR variable.
00:04:51.370 - 00:05:39.994, Speaker A: So let's do this. Okay, so we iterate until we reach the end of the string. Open curly braces here and we're going to fill the reverse byte by starting by the n. So STr length minus I minus one because this is zero indexed and this is equal to str of I. So the beginning of the string and at the end we're going to return this reverse byte, but we need to cast it into a string first. All right, so let's deploy this. Let's make sure it works.
00:05:39.994 - 00:06:09.940, Speaker A: Abcdef. It works. Yeah. Next, how can we compare that? Two strings are equal. Let's do this function compare. It's going to accept two argument. Okay, let's copy paste this external that's pure and that's going to return a boolean value.
00:06:09.940 - 00:06:49.920, Speaker A: Okay, so can we just do a equal equal B? That would be easy, right? Ha. We can do this, but we can use a trick. Basically we're going to compute the hashes of a and b and compare these hashes. Since these hashes will be byte 32, that's easy to compare them in solidity. So let's do this. So the first step is to use Abi encode pact to transform this into a byte. Once you have bytes, you can fit it to the hashing function ketchag 256.
00:06:49.920 - 00:07:15.320, Speaker A: And after you can do the same thing for the other variable. And after you have the right to compare your two bytes, 32. It's going to work. So let's redeploy our smart contract. Let's compare, I don't know, ABC. ABC, yeah, that's true. Okay, let's change just a bit.
00:07:15.320 - 00:07:53.420, Speaker A: ABC and ABCC compare, false. Yeah, it works. One thing to keep in mind is that it's not very efficient to manipulate strings in solidity and it tends to consume a lot of gas. So if you can, it's actually better to avoid to do any string manipulation in solidity. For example, you can try to replace strings by bytes, and if you know in advance what will be the size of your string, you can even give a limit to your byte type, for example, bytes 32. Next, if you want to see some other cool tricks in solidity, check out this playlist. I'll see you there.
