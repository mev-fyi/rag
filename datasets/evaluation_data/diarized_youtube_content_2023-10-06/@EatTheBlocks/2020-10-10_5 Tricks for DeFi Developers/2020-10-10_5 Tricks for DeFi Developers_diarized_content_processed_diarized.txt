00:00:00.330 - 00:00:31.794, Speaker A: DeFi is amazing. If you are a blockchain developer, that's where you should focus your attention. But developing DeFi application is not easy. You have all the problems of blockchain, plus some extra issues coming from DeFi. So in this video I'm going to share with you five tricks you can use in your DeFi project to make your life easier as a blockchain developer. If you don't know me, I'm Julian and on my channel idoblocks, I teach blockchain development and how to find your first blockchain job. And before we continue, quick mention to my new course on DeFi development.
00:00:31.794 - 00:01:13.966, Speaker A: I'm still working on it, but if you want to be notified when it comes out, make sure to register with the link down below. One of the main advantage of DeFi is its composability. We can interact with any DeFi smart contract without asking for any permission. That's why in most DeFi projects we will need to interact with other DeFi protocols compared to other blockchain projects that can be built in isolation. This adds a layer of complexity. When you develop a DeFi project, you want to be able to test it before deploying to Mainnet. And when you test, you want to have a realistic testing environment, but at the same time you want to be isolated from the production environment.
00:01:13.966 - 00:01:55.982, Speaker A: There is a feature of ganache that allow you to fork Mainnet locally. Your fork is totally isolated from Mainnet and exists only on your computer. Another important thing is that you only download the blockchain data related to your transaction, so you don't have the same huge storage requirement as for running a full node on Mainnet. So on this local Mainnet fork you have other DeFi protocols already deployed with the same exact state as on Mainnet. So that is great for testing, at least in theory. However, I've used this feature a couple of times and at the moment it's still very flaky and frustrating. Sometimes it works, sometimes it doesn't.
00:01:55.982 - 00:02:35.918, Speaker A: That's why I've tried another approach, which is to test on public testnet like Covan. But the problem is that not all DeFi protocols are deployed on the same testnet. Some are only on Covan, some are only on Robston, et cetera. Another issue is that these DeFi projects sometimes use separate deployment for some ERC 20 token like DAI, USDC, et cetera, so you lose composability. Often these deployments are not really maintained and you don't always have liquidity in exchanges. So the last solution is to test on a local development blockchain with ganache. But in order to do this, you need to deploy all the DeFi projects that you interact with.
00:02:35.918 - 00:03:19.770, Speaker A: For some of them you only have a few contracts that's doable, but for some other it's much more complex, and you don't necessarily have the time to understand in depth how to deploy these projects. So here is my trick. In this case, you can deploy just one smart contract for this DeFi project. That's basically the smart contract that you interact directly with. For this smart contract, you only create the function that you will need, and you create yourself a simplistic implementation or no implementation at all, leaving the function empty. That's what we call a mock, a sort of skeleton of code, and that's very useful for testing. Of course, it's not as realistic as interacting with the real implementation of a DeFi project, but that's better than nothing.
00:03:19.770 - 00:04:28.798, Speaker A: Next, I'm going to show you how you can get some testnet tokens when you want to test a deFi smart contract, very often you need to have some tokens like die USDC, et cetera. If you test on a testnet like Coven or Robstone, you can have free ether for testing by using a faucet. But in general there aren't any faucet for Yas 20 tokens. So how can we get some yas 20 tokens on testnet? In the first case, if you deploy the YAS 20 token yourself, you can deploy a modified version with an extra faucet function that just mint new tokens for whoever called the function. For the second case, if you have to interact with ES 20 tokens already deployed, not managed by you, you can get some tokens in two steps. First, you get some ether from a faucet, all the testnets have one, and after with this ether, you can use a decentralized exchange deploy on Testnet to buy some es 20 token with your Testnet ether. Even though most decentralized exchanges have some smart contract deployed on Testnet, they don't always have a UI connected to the Testnet smart contract.
00:04:28.798 - 00:05:17.314, Speaker A: In this case, you can still use the exchange and get your es 20 tokens, but you will need to do it programmatically. For example, you can write a script with node JS and truffle and send your transaction to the smart contract of the decentralized exchange. In the specific case of DaI on Covan, you can actually use the UI of the Oasis exchange by happening a query string with network equal Covan at the end of the URL. Next, I will show you how you can work with different solidity versions. When you work on a defi project, often you have to deal with different solidity version. For example, if you want to use the latest version of solidity, currently at 0.7, but you need to use some smart contract with older major version like 0.5
00:05:17.314 - 00:05:48.538, Speaker A: or 0.6. What do you do? If we try to compile a project that uses different major version, the solidity compiler is going to complain. If you just interact with this smart contract that have a different solidity version, that's easier. In that case you can create separate truffle project. One project per version of solidity you compile and deploy per truffle project. You will also need to create a solidity interface for smart contract interactions. To create a solidity interface you just need the function signature and you choose a 3d version you want.
00:05:48.538 - 00:06:42.638, Speaker A: The other case is if you want to use a smart contract with different three DT version, but you don't just interface with this smart contract, instead you inherit from them. In that case you have no other solution but to rewrite this contract with the solidity version you are using for your project. That's not always easy and this can introduce some security vulnerabilities, so be careful with that. And how about for smart contract written with a different language? Well, for most smart contract they will be written in solidity so you won't have this problem. But for some contract they are written in a different language like Uniswap V one and curve finance, which are written in Viper. So in this case, to interact with the Viper contract from a solidity contract, you create a solidity interface with the function signatures of the Viper contract. You will also need to deploy the Viper contract in a separate Java project and that's it.
00:06:42.638 - 00:07:21.082, Speaker A: Next, I'm going to show you a trick to deal with contract addresses and abis. In order to interact with other smart contracts from JavaScript you need the ABI and the address. It's very time consuming to search for these ABI and addresses, and there are no centralized places to find this info. For some projects you need to go to their developer documentation. For some other that's in a GitHub repo. For some other it's a JSON document at specific URL, etc. But fortunately for us there is an NPM package called Moneylego where you can find the ABI and addresses of some defi project.
00:07:21.082 - 00:07:58.590, Speaker A: All you have to do is to install this package and import the ABI and addresses in your Javascript code. You don't find all the defi project in Monilego, but you find the main ones. If you are interested in the Moneylego package, you can check out this tutorial on my channel. Next, I'm going to show you another trick for debugging transactions. When you give up a defi project, at some point you will stumble upon a bug. There are several ways to fix this. One way is to comment uncomment your code until you understand what's wrong, but sometimes the bug is a bit more complex and you need to analyze a failed transaction.
00:07:58.590 - 00:08:34.270, Speaker A: If you use truffle, it has a built in debugger, but it works with a command line and is not super user friendly. If you want to debug a transaction on a public testnet or mainnet, you can use a tool called tenderly. Tenderly is a toolbox for blockchain developer with many different tools. It has a tool to inspect transactions that give you the whole stack trace. You see which smart contract was called which function, and you can walk through the execution path until the end of the transaction or until the transaction revert. That's very useful to debug a fair transaction. So now that you know all these tricks, it's time to use them.
00:08:34.270 - 00:08:50.260, Speaker A: For example, by building some complete DeFi projects. For that you can check out this playlist on my channel where I have a couple of cool tutorials where we build a full defi project and integrate create them with existing Defi protocols like uniswap, unfinance, etc. I'll see you there.
