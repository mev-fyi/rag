00:00:00.410 - 00:00:14.266, Speaker A: You. Hi guys, welcome to the 8th episode of it the blocks. Today we're going to study another aspect of inheritance, which is polymorphism. Polymorphism wasn't invented by solidity. It already exists in many other programming.
00:00:14.298 - 00:00:16.014, Speaker B: Language, and probably that some of you.
00:00:16.052 - 00:00:57.726, Speaker A: Already know it with polyformism. Polymorphism, sorry, this is such a complicated word, I can't get it right. So with polymorphism, what you can do is if you have a child contract that inherit from a parent contract, you can redefine some function of this parent contract and change their behavior. So this is very useful, but it's not very easy to understand. So I will show you some example, and I hope that it will be a little bit more clear for you how it works. We will also study what is the super keyword? So before we start the topic of.
00:00:57.748 - 00:01:47.120, Speaker B: This episode, first we're going to answer the challenge that I talked about during the last episode. So for the last episode we had four contracts. The first one was my contract, and it inherited from kid one and kid two and parent, which are three other contract. So kid two here inherit from parent, kid one also inherit from parent, and we have parent, which doesn't inerrate from any contract. So if you remember, before we put the parent here, we had no problem. So if I save my file, my linter here is going to stop. But if I add parent, my linter is going to tell me that there is a problem and I will not be able to compile this project.
00:01:47.120 - 00:01:56.754, Speaker B: So here, if I hover over this keyword contract here, the linter is going to give me some help.
00:01:56.872 - 00:01:58.498, Speaker A: So what does it say?
00:01:58.584 - 00:02:47.378, Speaker B: Linearization of inheritance graph impossible. Wow, sounds complicated. So I'm going to explain. So actually, when you have multiple inheritance, the order of the inheritance matter. So if you write like this, kid one, kid two parent, basically what you're saying is first my contract inherit from kid one, then it inherits from kid two, but the function of kid two will override the function of kid one, and then the function of parent will override the function of kid two. But there is a problem because kid one and kid two also inherit from parent. So when you say this, it also means kid one inherit from parent, and a function inside kid one will also overwrite the function inside parent, and the same for kid two.
00:02:47.378 - 00:03:25.690, Speaker B: So basically, in other words, here you say, hey, kid one is going to override parent, but here line 15, you're saying parent is going to override kid one. So this is contradictory. So solidity cannot solve this. And that's why it gives us this error. So be careful when you have multiple inheritance, if one of your parent already inherits from a common ancestor, you cannot add this ancestor after your contract here on the right. So here we're going to remove parent and it's going to solve our problem. Okay, so let's switch to our terminal.
00:03:25.770 - 00:03:51.654, Speaker A: So with the truffle command line installed, we're going to run the truffle init command. So I've already run this command. So I already have all the folders and the files so you can check what you have with ls. And you should see something like this. The second thing we're going to do is to use the Truffle command to create a new contract. Truffle create contract. My contract so far.
00:03:51.654 - 00:04:47.970, Speaker A: For those who followed the previous episode, this should sound pretty familiar. And now open your text editor and open the contract that we just created. So we're going to get rid of this constructor function. And like for the previous episode, we're going to add three contract. One will be the parent contract and two other one will be kid one and kid two. So we're going to make kid one inerate from parent and kid two also inerrate from parent and my contract inerrate from both kid one and kit two. So so far it's exactly the same thing as what we've done in the previous episode.
00:04:47.970 - 00:05:34.360, Speaker A: But we're going to do something a little bit different in a parent. So we're going to create a variable of type U int. So it's going to be an integer that we're going to call contract type and we're going to set it to zero. And then we're going to create three function in parent. So the first one will be foo and it's going to return a uint variable and inside it's going to very simply return this contract type variable. And we're going to add two more functions that do exactly the same thing. But you will understand why we're doing this.
00:05:34.360 - 00:06:17.720, Speaker A: Okay, so instead of food it's going to be bar and that one instead of food it's going to be buzz. Okay, so we have our parent contract with one variable and three function. And now we're going to move on to the kid one contract. So for the kid one contract, it's going to have two function, bar and bas. So we're going to copy over those two like this. And it's also going to have one variable of type uint. But this time we're going to set it to uint one.
00:06:17.720 - 00:07:07.430, Speaker A: And finally, the kit to contract is going to have just one function, and it's going to be bas. So we copy this over, and we also copy this variable here. And we were going to set this variable to zero, sorry, to two. Okay. And finally, in my contract, we're going to call all this function. So the first function that I will create will be called call foo. And it's going to return a variable of type uint.
00:07:07.430 - 00:07:57.030, Speaker A: And it's going to very simply return the result of the call to Foo. And because we inherit from kid one and kid two, through the chain of inheritance, we will be able to access foo that is defined in several contracts. So foo is, sorry, foo is only defined here in the parent contract. So what we should see is contract type here. So it should be set to zero. And the second function we're going to create in my contract is called bar. So bar is also going to call a function, and it's going to be bar.
00:07:57.030 - 00:09:04.390, Speaker A: Very simply, and as you guys probably guessing, we're also going to create another function called Callbaz that's going to call bass. So why are we doing all of these functions? So basically, I want to explain how polyphorphism work by demonstrating which function it's calling. So here we already said that we're expecting this call to foo to return zero because zero is the value of this contract type variable here in the parent contract. However, when we're going to call the bar function, it's not so obvious because bar is defined twice. So bar is defined here in the parent contract, but bar is also defined here in the kid one contract. So which one of those two will be called? Well, we will see it thanks to the value that we will have returned. When you run across this situation, basically, the rule is that the function to be resolved will belong to the contract that is the most derived.
00:09:04.390 - 00:09:52.662, Speaker A: So it sounds complicated, but basically it's the higher in the inheritance hierarchy. So here, what happened in my contract is at first I inherit from kid one, and after I inherit from kid two. But kid one itself, it also inherit from parent. So in the chain of inheritance, kid one is after parent. So what we should see when we call the bar function here is that it should actually resolve to the function that belong to kid one here. So the value that will be returned should be one. And by the same reasoning, when we're going to, in my contract, when we're going to call, the function which is bas, is defined in three places.
00:09:52.662 - 00:10:16.400, Speaker A: It's defined. Let me scroll up to the parent contract. So it's defined here in the parent contract bas it's defined in kid one here. And it's also defined in the kid two contract here. So in this case, the most derived contract is kit two. So the call to Bash should resolve to this function here. And the return value should be two.
00:10:16.400 - 00:10:58.110, Speaker A: So our three call should result in, respectively, zero, one and two. Okay, so we're going to check this very simply by going back to the console. Okay, so first, before we launch the truffle develop command, we quickly need to create our migration file. So truffle command migration, and the name of our migration is going to be my contract. Okay. And then I'm going to open this migration file. But first I'm going to copy over the migration that is already, oh, sorry, it's not the right file migration.
00:10:58.110 - 00:11:32.966, Speaker A: That one I'm going to copy over the migration provided by the truffle framework, and I'm going to modify it just a little bit. Migration. So this is exactly that as what we did during the previous episode. Okay. Oh, actually it seems like I already prepared this contract, this migration file before, so I don't need to change anything. So here I have my variable, my contract that equals this line artifact. It's a truffle construct and it's going to require the name of my contract.
00:11:32.966 - 00:12:06.470, Speaker A: And then I'm going to pass this, my contract variable to this deploy function here, line four. And it's going to deploy my smart contract to my local testnet. Okay, so back to our console. So now we're ready to launch the truffle develop command. And it's going to spin up our local testnet and it's going to start the truffle console. Okay, so now we're ready to run the migration. So we're going to type migrate.
00:12:06.470 - 00:12:39.280, Speaker A: Okay. And now we're going to have a variable that points to our contract instance. So we're going to use the my contract variable that was injected by truffle. Then we're going to call the deploy method. That's going to return a promise, and we're going to catch the result of this promise like this. So let's just call the result. And we're going to assign this I variable to inst.
00:12:39.280 - 00:13:11.180, Speaker A: Okay. Is it correct? Oops. It's not correct. Okay, now it works. So now we can use this inst variable and we're going to call our first method, which is call Foo. So call foo. And we're expecting zero and oops, why it's not working.
00:13:11.180 - 00:14:03.290, Speaker A: So here, basically the problem is like I want to call this function, but the result is a transaction receipt. So it means that truffle has done a transaction, but it's not what I want. So let me go back to my contract and I'm going to correct this. So the reason why truffle is trying not to do a transaction is because I forgot the constant keyword here. So let me add this constant, constant and constant. Okay, and now back to our truffle console and we're going to rerun the migration again because our contract has changed. But this time we need to set the reset flag because we changed the contract.
00:14:03.290 - 00:14:43.174, Speaker A: Okay, and now we're going to again have our inst variable point to our updated instance on a local testnet. My contract deployed. And then I inst point to I. Okay, so now if I call foo like this, I should have zero. And here, so we return this big number thing, but the result that we want is actually here. So it's zero. Okay, so, so far so good.
00:14:43.174 - 00:15:10.794, Speaker A: So now how about the bar? So we should have one. And here we can see that we have one. Okay, it's cool, it's working. And finally we're going to call the function baz. And the function baz is going to return two. Yes. Okay, so I have demonstrated how polymorphism work in solidity.
00:15:10.794 - 00:15:58.346, Speaker A: Okay, so now we will go back to our text editor and we're going to study the keyword super. So super allows you to call a function of your parent contract if you inherit from a parent. So for this we're going to create another function in kit two contract and this function will be bar. And it's going to return a variable of type uint. And instead of calling bar, it's going to call super bar. It's going to call function bar that belongs to the contract before in a hierarchy, in a returns hierarchy. Okay, so for this back to our console.
00:15:58.346 - 00:16:40.134, Speaker A: And like every time that we change our contract, we need to run the migrate reset command. Okay. And we also need to update the variable that points to a contract instance. So for this always the same drill. So deployed then, and then that's how you update your variable. Okay, and now what happened when we execute get bar? Get bar. Oh no, it's not correct.
00:16:40.134 - 00:17:51.854, Speaker A: It's not get bar, it's call bar. Okay, and now we have one. Okay, so let's get back to the text editor. So here you could have thought that it would call the function bar of the parent contract, in which case it would have returned zero because the contract type value in the parent contract is zero but actually what we got is one. So it didn't call this function in parent but it called the bar function in kid one. Why is this? Because here we can see clearly that kid two is parent. So when I said that the super keyword will make you call a function in the contract before in the hierarchy chain actually this is evaluated in the context of this contract here my contract so because my contract inherit from kid one and kid two when we call this function bar inside my contract, then he tried to resolve by checking in the chain of inheritance.
00:17:51.854 - 00:18:52.930, Speaker A: So first it checked in kit two and in kit two here it find that there is this function bar and this function bar itself it call another function bar with the keyword super. So it checked before in the in returns Chen but before in the in returns Chen in the context of my contract. So in this case it's kid one, it's not a parent. So I just wanted to show you a tricky example. Once you understand this example, then you're sure that all the other example will be easy in comparison. I know this episode was a little bit more difficult than others so if you had some trouble to understand everything, make sure you rewatch it because it's really important to understand this concept of polymorphism in solidity maybe you will use it yourself or probably that you will see it in other people code. For the next episode we're going to study how inheritance work when you want to use the parent contract constructor.
00:18:52.930 - 00:19:06.980, Speaker A: So for example, if my contract a inherit from B, how I can call the constructor of B and pass some value? If you enjoyed this video, you can give me a like or you can share it or you can subscribe to the channel. Bye bye, see you next time.
