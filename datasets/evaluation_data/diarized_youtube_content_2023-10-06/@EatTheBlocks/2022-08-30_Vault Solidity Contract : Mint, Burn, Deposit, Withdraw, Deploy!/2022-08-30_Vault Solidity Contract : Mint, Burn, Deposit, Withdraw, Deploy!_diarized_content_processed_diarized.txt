00:00:00.410 - 00:00:38.418, Speaker A: Let's write a contract for a vault. I've already defined the interface for IERC 20 and then imported here, so let's start with the state variables. The first thing that we're going to need is the token that's going to be inside this vault. So I'll declare as IERC 20 public. The token will never change, so we'll make this imme mutable and we'll name it token. When a user deposits token, we'll mint shares, and when a user withdraws we'll burn the shares. So we'll need to keep track of the total share and the share for each user.
00:00:38.418 - 00:01:25.474, Speaker A: We'll keep track of the total share in a state variable. We'll name it total supply so I'll type un public total supply share per user. We'll store it in a mapping from address to un. This will be a public state variable and I'll name it balance of next, let's write the constructor. We'll set the token when this contract is deployed. So I'll type construct tor. It's going to take in a single input of address of the token and then we'll set the immutable token here to the token from the input by typing token is equal to IERc 20 token from the input underscore token.
00:01:25.474 - 00:02:12.754, Speaker A: Next we'll write some internal functions to mint and burn shares. The first function we'll write is mint, so I'll type function underscore mint. This function will take two parameters, the address to mint the token to and the amount un amount. This function will be internal, so I'll declare as private and then we'll increment the total supply, so the total shares will increase by the amount. I'll type total supply plus equals amount and then we'll allocate this amount to the user too. So type balance of two incremented by amount. We'll do something similar for the function burn.
00:02:12.754 - 00:02:45.798, Speaker A: So I'll copy this and then paste it here and we'll name this function burn. We'll burn from an address. This function will again be private. Since we're burning, we'll decrement the amount and then deduct the amount from the from address. And that completes the internal function to mint shares and to burn shares. Let's now write the function to deposit and withdraw. First we'll write the function to deposit, so I'll type function deposit.
00:02:45.798 - 00:03:30.634, Speaker A: It's going to take in a single input of un amount. This will be the amount of token that the user is going to deposit. This function will be external. When the user deposits a token, we'll need to mint some shares. We already discussed that the amount of shares to mint is a times t over b where a is the amount of tokens that is being deposited, b is the balance of tokens before the deposit, t is the total supply, the total shares, and s is the shares to mint. The amount of shares to mint is proportional to the increase in the balance of the vault and from this equation we get that s the amount of shares to mint is equal to a times d divided by B. So let's put this into code so we'll say uint shares.
00:03:30.634 - 00:04:30.802, Speaker A: Now notice that when the total supply, the total share is equal to zero, then this equation does not make any sense since total share is equal to zero and we'll be dividing by zero. So when the total share is equal to zero, then we'll have to handle the amount of shares to mint separately from this equation. If total supply is equal to zero, then we want to say that the amount of shares to mint is equal to the amount that was deposited. So we'll type if total supply is equal to zero, then the amount of shares to mint shares is equal to amount that was deposited. Else we'll follow this equation. So we'll say shares is equal to the amount multiplied by total supply and then divided by the balance of the token locked inside this contract. So we'll say token balance of address this.
00:04:30.802 - 00:05:21.118, Speaker A: First we'll mint the shares. So we'll use the internal function that we defined above by typing underscore mint to message sender for the amount shares and lastly we'll actually transfer the token from message sender into this contract. We'll type token transfer from message sender to this contract. Address this for the amount amount that was specified by the input and that completes the function deposit let's now write the function to withdraw. So I'll name it function withdrawal. The input for this function will be the amount of shares to burn. So I'll type un underscore shares.
00:05:21.118 - 00:06:33.206, Speaker A: This function will be external and when we burn the shares we need to calculate the amount of tokens to withdraw for the user and similar to deposit. We already discussed that the amount to withdraw is equal to a is equal to s being the shares multiplied by the balance of token in this contract divided by t total shares let's write this in code. Un amount is equal to shares multiplied by balance of the token in this contract. That will be token balance of address this and then divided by the total supply. Just to be clear that we want to multiply before dividing, I'll put apprentices here and before we transfer the amount to the user, we'll first burn the shares. Underscore burn this is the function that we already defined above for message sender. The amount to burn is shares specified by the input, and once we're done burning the shares, we'll transfer the token by typing token transfer to message sender.
00:06:33.206 - 00:07:18.054, Speaker A: The amount that we're going to transfer is amount and that completes the function. For withdrawal, let's deploy this contract. I've already created an ERC 20 token contract that you can see over here. We'll deploy this contract and mint some tokens to a user and then the user will deposit the token into the vault. After the user deposits, we'll generate some profit for the vault by directly sending some token into the vault so that when the user calls the function withdrawal, they'll be able to withdraw more tokens than what they deposited. So let's deploy the ERC 20 contract. First I'll hit Ctrl s to also compile this contract and then I'll select the ERC 20 contract and then deploy it.
00:07:18.054 - 00:07:50.990, Speaker A: Next I'll deploy the bulk contract. I'll select this, hit Ctrl s and then select the bulk contract. The bulk contract needs the address of the token which we deployed over here, copy it, paste it here and then deploy. Next we will mint some tokens for the user. So I'll open the Erc 20 contract and we'll mint some token to the first user. So I'll scroll down and then we'll mint 1000 token to the first user. Click on mint.
00:07:50.990 - 00:08:44.670, Speaker A: Now, before the user can deposit this token into the vault contract, this user will have to approve the vault to be able to spend to be able to pull this token into the vault. So make sure that we're still user one and we'll approve the vault to spend 1000 token. I'll scroll down to get the address of the vault contract, paste it here, and since we're going to deposit 1000 token, I'll copy this and put it in here. User one is going to approve the vault to spend 1000 token and then hit approve. Okay, we're now ready to deposit this token into the vault contract. So I'll copy this amount, scroll down, open the vault contract, and user one is going to call deposit for 1000 token and then click on deposit. Let's check the total supply.
00:08:44.670 - 00:09:17.406, Speaker A: Total supply is 1000 and let's check the balance of user one. I'll scroll up to copy the address of user one. Scroll down, paste it in here and the balance of user one is 1000. Next, let's increase the balance of the token locked inside the vault. Here we're simulating a vault where it took this 1000 token and somehow it made it more. Now in DFI, this profit is usually made by depositing into other DfI protocols. But for this example we'll keep it simple.
00:09:17.406 - 00:09:49.926, Speaker A: Just mint some tokens and directly send it over to the bulk contract. So I'll scroll up. But before I do that I'll copy the address of the bulk contract and then scroll up. Since I cannot directly mint tokens to the vault contract, what I'll do here instead is mint some token to user and then have the user transfer the token to the vault. So I'll hit mint and this will mint 1000 token to the user. And we'll now transfer this token to the vault contract. Paste the address of the vault here.
00:09:49.926 - 00:10:21.554, Speaker A: We just minted 1000 token. I'll copy this, paste it here. And now the vault contract has 2000 tokens in total. 1000 that was deposited by user one and the extra 1000 that was directly transferred. Next, user one will call the function withdrawal on the bulk contract. But before we do that, let's check the balance of the token. So I'll scroll up, copy the address of user one, scroll down and we'll check the balance of the token for user one.
00:10:21.554 - 00:10:42.778, Speaker A: And it is zero. Right. Now after we withdraw we expect this number to be 2000. So I'll scroll down. User one currently has 1000 shares. There are 2000 tokens inside this bulk contract. So if user one withdraws all of his shares then user one's balance of token should increase by 2000.
00:10:42.778 - 00:11:01.790, Speaker A: Let's call withdrawal. We'll withdraw everything. So 1000 shares, paste it in here and then call withdrawal. If we check the balance of user one after we call withdrawal, we burnt all the shares. So the shares is zero. Total supply is also zero. Let's now check the balance of user one.
00:11:01.790 - 00:11:14.860, Speaker A: Before it was zero we deposited 1000. The vault made an extra 1000. So the balance of user should be 2000 and it is close.
