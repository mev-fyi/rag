00:00:00.410 - 00:00:45.878, Speaker A: When OpenC released the seaport upgrade, it reported that the use of assembly in their solidity code reduced gas fees by 35%, saving its customers an estimated $460,000,000 per year. Today I will go through some simple examples of how and when to use assembly code in your solidity smart contracts. My name is James Bicini, and on this channel I create content about decentralized finance and blockchain development. Please bear in mind that the code you're about to see is experimental, untested, and not fit for. And in some cases, it's downright hideous. Okay, let's jump into this first example. So the assembly that you're seeing here is a form of assembly which in the Ethereum docs, they call it Yule.
00:00:45.878 - 00:01:32.462, Speaker A: It's expanded and simplified, and it's designed to make it more readable. So we've got a simple function here on opcode called s store, and that is storing a value, which is this new value we're passing in, which is an unsigned integer to the zero position. So the first memory allocation slot is storing this number, basically, and we're setting that to storage. So there's three different places that you can store data on the ethereum virtual machine. There's the stack, which operates kind of a fifo first in, first out system, where you're kind of pushing data to the top of the stack and then popping it out. That's the cheapest place to kind of work with data. Then you have memory, which is basically, I think of it as like RAM, it starts to get more expensive when you start storing data in memory.
00:01:32.462 - 00:02:07.410, Speaker A: And certain things like arrays, they actually have to allocate them. If you've been working facility for some time, you know, you have to kind of put in where you're storing that information. And then finally you have account storage or persistent storage, which is kind of, I think of it as like the hard drive of the machine. So once your program or your smart contracts finishes executing, it might hold an account balance for a user or some data like that, which is stored on the decentralized network. That's what we're going to access here. We're going to use the s store opcode to store this value, and that's going to store the data in storage. So it's persistent.
00:02:07.410 - 00:02:52.882, Speaker A: We've also got a function called get data, and this is going to go in, fetch that data, and return it to us. And all we're doing here is we're going to use S load, which is the equivalent of S store. So we're loading data from storage from that slot zero in the smart contract and then we can't return that data directly so we actually have to store it in memory before we can return it. So we're returning a un, two, five, six and all we're going to do is we're going to load that to naught x 80 storage position, which is V is just the variable here that we're loading it from. I probably could name that better. And then we're going to return that as a 32 byte unsigned integer. This is quite a good example because it's using persistent storage and memory storage to do different things.
00:02:52.882 - 00:03:28.622, Speaker A: And these are called opcodes. And if we scroll down here there's a list of useful opcodes and there's an even bigger list on the solidity documentation. This is how we build our functions in assembly. We use these different opcodes to manipulate the data and store it in different places and it gives us a lower level control of how our program executes and stores data. Let's deploy this and run it so I can show you how it works. And we're just going to add a number here, set data, wait for that to go through and retrieve the data. So that's one for one.
00:03:28.622 - 00:04:12.358, Speaker A: Let's move on to the next example. The next one is send ETH. So this is going to be a contract which if there's ETH within a contract or Ethereum native tokens within a contract, then we want to be able to withdraw that. But only two owners can withdraw that and we set that at a start before we get into the assembly. So we've got an array here, we've restricted it to a length of two and we've got two addresses here which are allowed to withdraw the ethereum. Then we've got an external payable function here and we've got an address, two and an amount. So basically what I'm going to do is I'm going to send this one ETH and I'm going to try and withdraw half an ETH.
00:04:12.358 - 00:04:51.686, Speaker A: Not particularly useful, but it's a good way to start demonstrating how we can use loops and statements within our assembly code. So we've set a boolean outside of the assembly a success, and we're later going to check to see if that success is true. So a boolean is just true or false. And there's a require statement here which basically reverts the whole transaction if that's failed to go through. Now let's jump into the assembly and go through this code so we've got a for loop here, and this should look pretty familiar if you dive into it. We've got I equals zero. If I is less than two, continue with a loop, and then I add one each time you do the loop.
00:04:51.686 - 00:05:20.142, Speaker A: So we're then going to set the owner to load the storage value of I. So in this contract we've got the first two values as zero and one are the first two values in this array. It's the first thing we've done within the contract. Not a particularly good way or a secure way of doing this. I wouldn't recommend this code was deployed to Mainnet, for example, for purposes of this demonstration. It's fine. So we're going to set the owner value to each of these addresses, and then we're going to use an if statement.
00:05:20.142 - 00:06:13.122, Speaker A: If the two value, that is a user defined values, this function is equal to one of the owners, then we're going to send them the amount of ETH. We're doing that via a call function or a call opcode which passes the remaining gas, the person you're sending to, and then the amount of ETH that you want to send. Just going to try this out in the console and we're going to get rid of this storing data contract and let's deploy send ETH. I'm going to have to send this some ether with the contract code, and then I'm going to have to copy one of these addresses. So address first and then the amount I'm going to put this is in y. We're sending a lot, so that should work. You can see that's gone through.
00:06:13.122 - 00:06:51.280, Speaker A: If we change the address value by a couple of digits, you get an error. Bad dress, check sum. Let's just check. If we scroll up, we can check the account balances. You see, this is the first address that we sent the ETH to and that's gone through. If we try a random address, which should actually work with the checksum, draw ETH and fail to send ETH because that address is not part of the owners of this contract. So another fairly simple example there, but you can see how we're starting to use for loops and if statements to control the logical flow of the application.
00:06:51.280 - 00:07:32.426, Speaker A: This next example is a little bit more complicated and it looks a bit daunting at first glance. That's something I find with assembly. When you first look at it, it can be quite abstract and it's not as clear as when you're looking at the program flow through solidity. But if you kind of get into it and you kind of look through what's going on and take your time to understand the functions. And if it's well commented as well, which this one isn't, having a basic understanding of assembly and low level data management can help you read and understand what's going on in third party developers contracts. So in this contract we're passing in an input string and a boolean for decrypt. It's going to be if you want to decrypt it or encrypt it.
00:07:32.426 - 00:07:57.934, Speaker A: This is called useless encryption because it is exactly that. It's an external pure function. It's going to output a string to memory. So we're setting a variable type to 32 bytes and we're calling that the output. So we're defining our output variable before we get into the assembly. And then as you can see, we started to put in some functions. So this first function, string to bytes, it simply takes a text string that we're going to pass it and then it's going to convert that to ones and zeros.
00:07:57.934 - 00:08:33.438, Speaker A: And like a byte array, you'll notice again we're using 32 bytes. The reason for that is that everything on the Ethereum virtual machine is built around these 32 byte slots. The next function, add to bytes is our encryption algorithm, if we can call it that. All we're doing here is if we want to decrypt it. So if decrypt is set to false, we're going to add zero one to each bytecode. So if we know that all data gets compiled down to binary so it's ones and zeros, we can represent that for hex string. So a capital A for example, is the character code 41, b is 42, c is 43.
00:08:33.438 - 00:09:06.534, Speaker A: And all we're doing here is adding zero one to each letter. So we have a 32 byte string, so there's 32 characters available and we're going to increase each one by zero one and the same with the decrypt function. All we're doing is subtracting zero one to get back to our original text. We're then calling them functions in turn. So, string to bytes and then passing the output of that byte string into the add to bytes function to get our value back. This will then set our output, which we set to a 32 byte variable. However, we're passing back a string here so it's more readable.
00:09:06.534 - 00:09:44.950, Speaker A: And all we're doing is converting that back to a string using a simple for loop in solidity. This is obviously very oversimplified and I don't think NSA are going to need to build a supercomputer to break this. Let's deploy this and see if it works. So, useless encryption. Let's encrypt the word test and you can see we've got this. And then if we paste this in, you can see it's appended. A lot of these zero one type boat codes actually generally be zero zero because there's nothing after the test, it's just blank.
00:09:44.950 - 00:10:36.276, Speaker A: And if we set decrypt to true, and you can see we can convert it back to the word test. Simple, useless, but a good demonstration of how to use functions to start adding more programmable logic within our assembly code. All the code that we've gone through so far is available in the blog post linked in the description. I think one of the best ways you can actually start to get better at assembly is just simply copy and paste code for even myself or third party developers into remix and start experimenting with it and building out your own functions. Like anything, the more you use it, the more comfortable you become with that low level memory. Data management for me, there is a cost of using assembly in solidity that's both in terms of readability, but also having to think about the stack and how you're kind of moving data in and out of the functions. I like the way that solidity takes care of all that.
00:10:36.276 - 00:11:43.168, Speaker A: It means I can concentrate on my coding, what I'm trying to do, and have some of those technicalities abstracted away. The places where I think that assembly makes a lot of sense is in small pure functions which kind of are used throughout a contract, or in libraries where a simple change to assembly on a simple function which you can probably understand what it does just by the function name, makes a lot of sense because it can save costs throughout the contract where those functions are used for blockchain developers. I think there are two ways you can kind of start to look at this. One is to start using assembly straight from the offset and kind of if you've got a small library or a function that you're going to use repeatedly to kind of code that from the start assembly. The other way is to kind of when you start getting to the testing phase, so you can kind of do the creative process of writing the code in solidity, which is more high level. And then once you start getting to unit testing stage and trying to optimize that code, you can then maybe convert some of the regularly used functions into assembly. And a lot of the frameworks like hard hat and foundry, we actually give you gas optimization reports so you can see how the changes to your code are affecting the gas costs for your transactions.
00:11:43.168 - 00:11:54.970, Speaker A: That's a great way to start using assembly to optimize your gas costs and the performance of your smart contracts. I hope that this introduction to assembly facility has been useful. Please hit the like button for the YouTube algorithm and subscribe to the channel for updates. Thank you for watching.
