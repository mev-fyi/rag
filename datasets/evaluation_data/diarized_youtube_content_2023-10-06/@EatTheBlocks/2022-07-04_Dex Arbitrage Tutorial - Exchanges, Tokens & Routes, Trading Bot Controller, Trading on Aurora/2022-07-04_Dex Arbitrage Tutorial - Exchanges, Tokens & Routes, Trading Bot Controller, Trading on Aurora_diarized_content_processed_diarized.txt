00:00:00.330 - 00:00:37.218, Speaker A: Smart contract developers have the ability to swap digital assets multiple times in a single transaction. If the route isn't profitable, then the whole transaction can be rolled back to the original state and the developer only loses a gas fee. The introduction of layer two s and alternate layer one blockchains with low and even zero gas fees has made this a playground for arbitrage across decentralized exchanges. This solidity tutorial will provide an introduction to Dex arbitrage, along with some open source code to get you started. Good morning. My name is James Petuni and on this channel I explore blockchain development and emerging defi technologies. I'm not a financial advisor.
00:00:37.218 - 00:01:19.522, Speaker A: This is not financial advice. So let's talk a little bit about how DeX arbitrage works. Generally you'd have some form of controller, and this will fire off transactions to a smart contract. The controller will either live on your local computer to start with when you're testing, and then you probably deploy it to a remote server somewhere, a cloud instance, for example. This can be something as simple as a node JS or Python script, which just uses a web free library or iuse js to interact with smart contracts on whichever blockchain network that you want to fire transactions to. Generally between your controller and the decentralized exchanges that you want to trade on, you'd have a smart contract which you write yourself and deploy on the network yourself. This smart contract has a couple of purposes.
00:01:19.522 - 00:02:00.258, Speaker A: The first is to query routes on the decentralized exchanges. You can provide a couple of different decentralized exchanges and ask if I want to buy this asset on one and sell it on another, will that trade be profitable? How many tokens will I get back at the end of the trade? This is a call statement so it doesn't cost any gas fees, and you can run this multiple times every second. Then once we found a profitable route, we'll fire off transaction. This will be signed automatically by the controller, which has a hot wallet, and then that will execute the trade. And then at the end of the trade we'll compare our end balance to our start balance. If the trade has been profitable, then we'll keep them funds. If it's been unprofitable, if we bought them too high and sold them too low, then we'll just revert the whole transaction back.
00:02:00.258 - 00:02:52.910, Speaker A: We can do that with a require statement. If our end balance is lower than the starting balance, then the whole transaction reverts back to the original state. We don't end up buying asset on exchange one, we don't end up selling it on exchange two, we're back to where we started and we just pay a transaction fee if there's a transaction fee on the network. The reason for this is that transactions on Ethereum atomic, if something goes wrong in the middle of a transaction, the whole transaction gets thrown out the window and the node that's running the Ethereum virtual machine carries on to the next transaction that's waiting. This is definitely a feature and not a bug, and it's something that's very useful when we're doing this kind of arbitrage trading across decentralized exchanges, because it limits our losses, or our potential losses to just a single transaction fee. And bear in mind that transactions on alternative layer ones can go as low as like twenty cents on something like phantom, all the way down to absolute zero transaction fees on something like aurora. So trading on Aurora, you actually have no downside.
00:02:52.910 - 00:03:41.854, Speaker A: You can fire up as many trades as you want, the ones that are profitable will go through and the ones that are unprofitable, there's absolutely zero transaction fees. So your account just reverts back to where it was before you've made the transaction. The catch is that a lot of these alternate layer ones have lower trading volumes and lower TVL on their D five protocols. What that means is there's not as much opportunity to make larger amounts and there's not as many arbitrage opportunities throughout the day for you to trade on. The other side of that is there's less competition. And this is something that anyone can kind of go out and find a far outreach of a DeFi protocol and write a little script in a solidity smart contract to take advantage of the opportunity to trade between one DeFi protocol and another, or one digital asset and another, and make a quick little bit of profit. Okay, so this is what a transaction looks like on a blockchain explorer.
00:03:41.854 - 00:04:17.230, Speaker A: You'll notice I'm using the Aurora network here. This has zero transaction fees. The transactions are actually from bottom to top here, which is quite unusual compared to escan. We start with 220 USDC, we swap that for some near protocol, and then we exchange that for USDC. Again, we've started with 220 and we've end up with 222. So there's almost 1% profit on that trade. Bear in mind, this is a very simple form of arbitrage, and some of the more complex strategies use a lot more hops between different assets and different exchanges to try and make back as much as possible for a single transaction.
00:04:17.230 - 00:04:46.310, Speaker A: Let's jump into the solidity code. We've got some interfaces set up a standard ERC 20 interface and then Uniswap v. Two router and uniswap v. Two pair. Uniswap V two has been fought countless times over every EVM blockchain out there. Anything that's based on pancake swap or looks like that will work with this code. So if we scroll down to get to the actual contract itself, our contract is called ARB and we've got a swap function which is just a standard uniswap swap.
00:04:46.310 - 00:05:33.782, Speaker A: Nothing particularly interesting there. This getoutmin is the first query that we're going to give to the Uniswap router to kind of find out how many tokens we get back if we put a certain amount of tokens into a liquidity pool. So we can use this to combine two transactions at once. So estimate a dual decks trade. We're going to provide two different routers, so we could potentially provide two different decentralized exchanges and two different tokens. And it's going to find out how much you'd get back if you swapped token one for token two on router one, or exchange one and then token two back to token one on exchange two, it will return the amount back to our controller. We're going to be using this later to scroll through different routes and try and find opportunities where we can make a profit by trading in this way.
00:05:33.782 - 00:06:01.850, Speaker A: If we scroll down a bit more, we've got a dual deck trade. This has got router one and router two again, and token one and token two. So once we've found a profitable route, we're just going to fire this off. So all we're doing here is taking the balance at the start. We're going to swap them, then put the tradable amount back into the end balance and make sure the end balance is greater than the start balance. We're going to do the trade and make sure it's profitable. Note this isn't very gas efficient way of doing things and the only reason for that is that I wasn't working with any gas fees.
00:06:01.850 - 00:06:42.620, Speaker A: As you start to compete for arbitrage opportunities at higher stakes, it becomes a kind of a competitive scenario where the person with the lowest or most efficient code will win in the end because they can take lower price trades, because their transaction fees are going to be lower because they have more efficient contracts to execute the trades. And then at the end we have this estimate Tridex trade, which I'll talk about at the end of the video. Then we have a get balance and a recovery and a recover tokens. So we're going to actually send the tokens to the contract. So we're going to send like us dollar tether and wrap d to the contract as ERC 20 tokens. And then once we're done, we're going to pull them out again using this recover tokens function. Note this is of course owner only.
00:06:42.620 - 00:07:15.402, Speaker A: The next thing we need to do if we're going to use this code is to build a list of different routers and base assets and tokens on the network that we're going to be trading on. I've got the ArB contract, which is our deployed contract we just looked at here. Once that's been deployed we can update this file. We've got a minimum basis points per trade, so if we want to kind of make sure that any trades we're taking on cover the gas fees, then that will go some way to ensuring that happens. And then we've got some the different routers here. So these are different exchanges on Aurora. We've got trisolaris, which I've done a video about before.
00:07:15.402 - 00:07:44.610, Speaker A: Wanna swap and Aurora swap also tried rose, but I didn't find many profitable routes there, so I took that out when recording this originally. I forgot to explain how you find these router contract addresses. There's a few ways. Sometimes the developer documentation will include a list of contract addresses and you can go through that and there'll be one for the router. The other way is to just carry out a swap on the decentralized exchange itself. And then once that's gone through, open up in a block explorer and have a look at interactive with address. And that interactive with address will be the router for that decentralized exchange.
00:07:44.610 - 00:08:09.900, Speaker A: Next we have the base assets and these are like wrapped Ethereum us dollar stablecoins and things like that. And they are the actual ERC 20 tokens that we're going to transfer to the smart contract. And then we're going to trade off to try and make a profit in these assets. So if we're making a profit in wrapped Ethereum, but the price of Ethereum goes down, we can still lose money that way. And that's something to be aware of. But there's no reason why you need to use all of these. You could just use USD stablecoins if you feel that would be a safer option.
00:08:09.900 - 00:08:52.230, Speaker A: What I'd suggest is you look at what the most widely traded base assets are on the exchange that you're using most kind of decentralized exchanges will have an analytics platform. You go into the pools and see which pools have the most TVL, and there'll always be two tokens there. It'll be a base asset and a traded token. And you want to kind of get a list of which are the most popular base assets. Then we have list of tokens. And the way I found these tokens was to take a look at the managed token lists here, and then they've actually got a list which is on GitHub and we can view that list and it gives you all the different token addresses. So you can copy this straight from the JSON file and that'll give you a list of ERC 20 tokens that being traded on this decentralized exchange.
00:08:52.230 - 00:09:20.766, Speaker A: From there we can try different routes and we can see what routes are available, because not all of these assets might be traded on all the different exchanges. So we can start to put together a big list of different routes which are possible to trade one asset for another asset and then back to our original asset. And this can get as complicated as you like. There's no reason why you only need to use two digital assets or two routers. You can expand this as far as you're willing to take it. And then finally we have the controller code. So let's go through this.
00:09:20.766 - 00:10:04.966, Speaker A: This is written in Node JS, which is a JavaScript runtime environment, and we're importing hard hat, some FS file systems stuff for login and n for controlling the credentials. Our private key is stored in a N file, and that's something to be aware of as well, because having a hot wallet on a network that's connected to the Internet is a potential security risk. We then check which network we're running on, and we're going to import the JSON file that we just looked at. Then we're going to set up and start looking for trades. So let's go to setup. First we're going to establish who the owner of the wallet is, and then we're going to set up an instance of our contract, and we're going to connect our contract to the deployed contract address. This is stored in that configuration file under ARV contract.
00:10:04.966 - 00:11:06.346, Speaker A: So when we deploy the contract, we need to update that JSON configuration file with the deployed contract address. We're then going to check the balance of our base assets and then use all of that balance to trade with. So once that's all set up, we go start looking for trades and we've got two options here if we don't have roots defined already, we can start searching for roots and this will just kind of the search for roots function just kind of picks random roots and then kind of logs them, the ones that work and then just throws an error on the ones that don't. Once we have some good routes, we can do that a little bit more elegantly and we can just use a scrolling function to scroll through the list for the known good routes that we can look at. And we're confident that we might be able to find trades on. We're then going to connect to our smart contract pass through the route itself which contains the router or the two routers and the two tokens and the trade sizing that will send us back a value for how much we're going to get back given our input. And we can check to see if that is greater than our profit target.
00:11:06.346 - 00:11:44.518, Speaker A: The profit target is just a multiple of using this basis points per trade. One basis point is 1% of 1% because we're using 18 decimals a lot of the time. We got to use these big number libraries and that makes everything a little bit more complicated to do kind of simple division and multiplication and we just have to use the big number to even do comparisons. Like if we want to check that the amount back is bigger than our profit target, we have to use GT rather than just kind of the greater than symbol. If everything looks good, we go ahead and execute the trade. And if not, then we just continue the process and look for another route. All the trade is doing is checking that we were not already in a trade.
00:11:44.518 - 00:12:28.298, Speaker A: If we got multiple threads running and then it executes on the contract that dual directs trade function which goes and carries out the swap all in one transaction. At the end of the script we got some simple login which will just tell us how much we've made on each base asset and then we've got some error handling just to make sure the script is continually running, it doesn't throw an error if we have like a network connection issue or something. So let's fire this up and see how it works. I'm not going to go through all the installation instructions in detail. I'm going to assume you've already got node JS installed. You can basically clone the GitHub repository, run NPM, install, edit the n file, add your own private key. Then there's a deploy script at deploy JS which you can use to deploy the smart contract for yourself.
00:12:28.298 - 00:13:02.118, Speaker A: And then you can use to transfer funds to that smart contract. I just transfer a very small amount of funds first and then just make sure use the recover JS script just to make sure you can get those funds out again. Just make sure it all works before you do anything even remotely serious with any real funds. Check out the readme file on the GitHub repository as well, because that will have full installation instructions and there's blog posts linked to it in the description which will go through all the different functions of the smart contract and go through this in all more detail as well. So without further ado, let's go ahead and run this. So we've loaded 171 routes. We've got our owner wallet there.
00:13:02.118 - 00:13:33.750, Speaker A: We've got six different base assets, all with about $20 in each, and we're now looking for transactions on the network. We're looking for opportunities to do this arbitrage trade where it's got a chance of being profitable. Let's come back once it's found profitable trade. Okay, so we got some trades gone through. Now we've got a couple here that went through and then we got one that was reverted because no profit was made, and another one after that. If we go into the block explorer, we can see these here. Let's open these up, see if we made any money.
00:13:33.750 - 00:14:00.632, Speaker A: So if go to the first transaction, we traded 21.56 US a utust, which is a us dollar stablecoin for 21 58. So we made two cent on that one. On this one we made one cent on a very similar path, probably taking in the same opportunity. And then the final one we traded 20.8 near for 20.8, 119.
00:14:00.632 - 00:14:21.428, Speaker A: So 4.2 near. Obviously not massive amounts, but this is over the course of 510 minutes. If we go back into the blog post, we can take a look at the stats from the first couple of nights that I left this running overnight. The first night I had about $20 of capital on each base asset. And these are in basis points again. So this is 0.7%,
00:14:21.428 - 00:14:44.620, Speaker A: this is 9.6%, this was the best performing asset. Obviously it's not very much, it's still only kind of just under $2. But as a percentage terms, earning that in less than 24 hours is quite incredible. Us dollar teval was 1.24. Aurora was next to nothing, at UST was 5.85. I actually had the pad token on here at the time as well and that didn't do anything.
00:14:44.620 - 00:15:12.800, Speaker A: And then USDC was around 2%. Now the obvious next step was to start scaling up. So the next night I added $300. I've done some optimizations as well, and it actually performed a lot worse. You can see here w near was the best performer, again with just under 2%. That's only really $6 then with much more capital. And the problem is that the more capital you add to this strategy, the more slippage you get and the less profit there is on that trade.
00:15:12.800 - 00:15:58.000, Speaker A: It doesn't scale very well. And while this is kind of fun for making small amounts and getting better at solidity and developing skills, it's not going to make a significant amount of money over kind of a short period of time. The other way of looking at it is it's earning over $10 a day, which is $3,600 a year with very little capital outlay. Obviously, the fact I've made this open source now is probably going to mean that more people are going to run this and there's not as much opportunity in this specific blockchain with these specific decentralized exchanges. Hopefully, the kind of the code will help you get started on developing your own systems and you're developing your own arbitrage bots to go out there and take advantage of the opportunities that you find. Please note that the code provided is for educational purposes. It's unaudited, it shouldn't really be used for financial transactions.
00:15:58.000 - 00:16:34.570, Speaker A: Use it as a base to learn from and develop your own strategies where you might be able to compete at some of the higher stakes levels, where there's more significant money to be made at the higher levels, and particularly on the Ethereum mainnet, it becomes very competitive. It becomes a search for mev, or minor extractable value. There's whole communities built up called searchers and you can go on discord and chat to other people that are kind of looking for these opportunities in Defi and where they can extract value before anyone else does. I hope that you found this tutorial and code interesting. If you want to stay up to date with latest developments in Defi and consider subscribing to the channel, please hit the like button for YouTube algorithm and thank you for watching to the end.
