00:00:00.250 - 00:00:55.914, Speaker A: In this video we're gonna code a wrap ether token in solidity. And before we continue, make sure you join the Facebook group of either blocks where you can ask all the question you want about blockchain development and how to find your first blockchain job. So what is a wrap ether token? So on the blockchain there are smart contract that are called decentralized exchanges. They allow to trade ES 20 token in a decentralized way without any centralized party. However, one problem these decentralized exchanges can account here is that they have to manipulate both ES 20 token and ether. And ether and ES 20 token have APIs that are completely different and so that can introduce some complexity in the code of these decentralized exchanges. Could we manipulate ether with the same API as for ESC 20 token? Well, yes we can, with what we call wrapped ether.
00:00:55.914 - 00:01:44.466, Speaker A: So basically, wrap ether token are Yasi 20 token that have some ether collateral inside. So when you want to create a new wrap ether token, you have to provide some ether to the smart contract of the wrap ether token. And if you want to get this ether collateral back, you have to give back your wrap ether token. So let's see how we can code a wrap ether token in solidity. So here I am in remix and we're going to create our smart contract for wrapped ether token. We're going to call this we, okay, so we're going to start with that fragment statement, and after that we're going to import the ES 20 implementation of open zeppelin. So this is the GitHub repo of open Ziplin.
00:01:44.466 - 00:02:38.638, Speaker A: If you don't know what is open Zeppelin, check out this series on open ziplink on my channel. So I'm going to scroll down, I'm going to go inside contract inside token, yes 20 and yes 20 sol. And then I'm going to copy the URL and then back to remix, then import, and then we could paste this URL, terminate by semicolum. All right, so now we can use the YAS 20 token of open ziplink in our smart contract. So we're going to call our contract, we make it inerate from yes 20 because itself this is a Yas 20 token. And after that we're going to define this constructor so it doesn't have any argument. Then we're going to instantiate the constructor of Yas 20.
00:02:38.638 - 00:03:25.498, Speaker A: So first this is the name. So we're going to call this wrapped ether. And after this is the symbol. So w ETH and we make this public, no implementation for the body and after that, we need to define two function, the mint function to create a new wrap ether token, and the burn function when you want to do the reverse operation. So first we're going to create the mint function. Does it take any argument? And it's payable because we need to be able to send some ether to this bath contract to this function. And then we're going to call underscore mint, which is provided by the Yas 20 implementation of open zeppelin.
00:03:25.498 - 00:03:59.740, Speaker A: And then we need to give it the recipient. So the recipient is the sender of this transaction, Msg sender. And then what's the quantity of token that we need to create? Well, we're going to make it simple. And if you send one way of ether, then you're going to get one token. If you want, you can have another rule. Like if you have a different price for your token, you can multiply by two by three whatever you want. But you know what, let's just keep it simple.
00:03:59.740 - 00:05:03.310, Speaker A: So with this, when someone want to create a new wrapped ether, then it call this min function, it provides some ether. This ether is locked inside smart contract of wrapped ETH. And then in exchange, this address gets its wrap ether token. And so after with this wrap ether token, you can do whatever you want, you can transfer it to someone else, or you can keep it forever. And maybe that at some point you have your wrap ether token and you say, okay, well that's cool, but now I want to get my ether back. So you can do this by calling the burn function, and you need to specify what's the amount that you want to get back external. And so we're going to send you this amount of ether, and in exchange we're going to also burn your token for the address.
00:05:03.310 - 00:05:59.978, Speaker A: This is the color of this function. And for the amount, well this is the amount that you specify. And you might say, okay, well this doesn't seem very safe to me because I can call this burn function with whatever amount I want and burn tokens that don't belong to me and get sent a lot of ether so I can steal some ether from this fast contract. Well, actually no, because inside the implementation of the burn function here is going to check that you have enough token, otherwise you're going to burn other people token. So if you try to call this function with an amount that is too big, then underscore burn is going to throw an error and the whole transaction is going to be canceled. So this is a safe implementation. And actually if you want, you can even make your wrap ether even more interesting and create what is called collateral backed token.
00:05:59.978 - 00:06:50.042, Speaker A: And instead of having your token backed by ether, you can also sort of create a meta token that is backed by multiple other tokens. So that would mean that here in the min function, then you will call the transfer from function of other token. So you will transfer from the sender of the transaction and to the address of this smart contract. And here in the burn function then you will do the other operation. So you will transfer to the sender. And yeah, that's how you can do it with ERC 20 token as well. But for example, we just do it with ether.
00:06:50.042 - 00:06:57.980, Speaker A: And if you want to see many other cool tricks with solidity smart contract, I have another series full of them, so I'll see you there.
