00:00:00.170 - 00:00:29.846, Speaker A: Hey, this is julian and you are on idoblox. In this video, I'm going to give you a brief introduction to solidity assembly. By the way, if you want to know my most useful solidity tips, check this free email series link in the description. So first I'll explain you what you can do with assembly. Then we'll talk about the Ethereum virtual machine that runs the code of the smart contract. Then I'll show you the basic syntax for assembly. Then we'll see some basic instruction of assembly, like for reading and storing data.
00:00:29.846 - 00:01:01.562, Speaker A: Finally, I'll give you two code example of assembly. All right, so let's get started and see what you can do with assembly. Solidity assembly is a low level language that allow you to directly manipulate the Ethereum virtual machine. It's a sort of escape hatch that allow you to do things that you just can't do with solidity. It's also more dangerous because you manipulate directly the memory. So if you can, it's better to actually avoid doing assembly. You only use assembly if you have no other choice, and you are stuck with pure solidity.
00:01:01.562 - 00:01:52.106, Speaker A: So next we'll see what is the Ethereum virtual machine. So when you write a smart contract in solidity that is not actually the code that runs inside the Ethereum blockchain. Instead, this solidity code is compiled to a lower level language that is understood by this ethereum virtual machine. So for example, if I write a function foo that adds two numbers uint a uint b u int c, and then c equals a plus b. Then this is going to be compiled to a series of low level instruction called opcode. So these are elementary operation understood by the Ethereum virtual machine. So at this address you can find the list of all the opcode of the ethereum virtual machine.
00:01:52.106 - 00:02:22.102, Speaker A: So for example, you can add numbers, multiply them, subtract them. You can also manipulate the memory and many other things. In total, there are about 100 opcodes. So when you use assembly you can directly manipulate these opcodes. So next, let's see what is the syntax of assembly. So when you write assembly, you need to put it inside a solidity function, and inside a function you need to wrap it in an assembly block. So to declare an assembly block you use the assembly keyword.
00:02:22.102 - 00:02:56.814, Speaker A: You open curly braces, and inside you will write your assembly. So inside your assembly block you can manipulate variables that are declared outside. So that's how you can interface your assembly block with your normal solidity code. You can also define local variables with the let keyword so for example, we could manipulate our c variable by referencing c directly. And if you want to assign to a variable, then you're going to use the colon equal syntax. So this is slightly different than solidity. And after that you specify the name of an opcode.
00:02:56.814 - 00:03:23.290, Speaker A: So for example add. And then this opcode is going to take a couple of arguments. So in the case of add, it takes two arguments. So for example, one and two, and that's it. There is no semicolum in assembly, contrary to solidity. This is really the basic syntax of assembly. Like in solidity, in assembly we have couple of language construct like if for, and we can also define function.
00:03:23.290 - 00:03:57.078, Speaker A: So I'll show you a link to the documentation of solidity so that you can learn all these things. But the next thing I like to show you is how we can read and store data in solidity assembly. And to understand this, we need to first understand the memory layout of the ethereum virtual machine. So in the EVM, everything is stored in slot of 256 bits. So for example a un occupy a single slot. So here if I declare my variable ABC, then that means it's going to occupy three slots. So slot one, slot two and slot three.
00:03:57.078 - 00:04:31.934, Speaker A: So when we manipulate simple data types like Un, it occupy a single slot, but for other types like array or mapping, it will actually occupy several slot. But when we manipulate the memory of the EVM, we actually do operation on a single slot. So let's see how this works. So first, let's load some data from a specific memory slot. So when you do this, you need to use the M load opcode and you need to specify the address that you want to load. So for example, there is a special address at zero x 40. So this is the exit decimal notation.
00:04:31.934 - 00:05:09.310, Speaker A: So this address address will return you the address of the next available slot for memory. So if you want to allocate some space for an array, for example, then you will need to access this special address. And then you're going to assign this to a variable. So for example, you declare a variable like this and you assign the result this way. Next, if you want to store something to memory, then you're going to use the M store opcode. So the first argument is the address of the destination. So for example, we can use the a variable that we created just before.
00:05:09.310 - 00:05:37.458, Speaker A: And second argument is the payload what we want to actually store. So for example can be one, it can be two. Since we are storing in a single memory slot, the payload must fit in 256 bits. And lastly, if you want to store to the storage. So something that will be persisted inside the blockchain. Then you need to use the SS store keyword and the argument are exactly the same. First the address of the destination and second the payload.
00:05:37.458 - 00:06:17.042, Speaker A: So just to be clear, the difference between mstore and SS store is that the first one manipulate the temporary memory of solidity. The lifetime of this is only during the execution of a function, but after it's going to be deleted. SS store manipulate the storage of the smart contract so this will be persisted after the execution of the function. All right, so that's it for reading and storing data. Next, I'm going to give you two example of code with assembly. So first we're going to detect if an address is a smart contract, so you can only do this in assembly. So for that we are going to first define a variable outside our assembly block.
00:06:17.042 - 00:06:55.054, Speaker A: So we're going to call it size, and this is an integer. And inside the assembly block we're going to use the x code size instruction that's going to return the size of the code at a specific ethereum address. So each ethereum address has different fields associated to it. One of this field is the code field, and if this is a regular address, not a smart contract, then this field is going to be empty. So we're going to test for the size of this field. If this is zero then we know this is a regular address. And if this is superior to zero we know this is a smart contract.
00:06:55.054 - 00:07:47.970, Speaker A: So here we're going to pass the address that we want to test. So for example above, then we can define this address to the sender of the transaction and we store the result of xcode size in the size variable. And after the assembly block then if size superior to zero, then we can return true, else return false. So this is how you would detect if an address is a smart contract or not. And the next example is how we can cast bytes into bytes 32. So let's say you have a memory byte. So bytes memory data equal new bytes.
00:07:47.970 - 00:08:38.194, Speaker A: We give it a size of ten, for example. And if we want to cast these bytes into a byte 32 into a fixed size, then solidity will not let us do this. So byte 32 data B 32, if we try to cast the data then solidity is not happy. And the reason is because the size of this bytes 32 is smaller than the size of bytes. But maybe that we are just interested in the first 32 bytes of these bytes here and we don't care about the data after. So in this case, so we can use assembly to save us. So we declare a bytes 32 variable data B 32.
00:08:38.194 - 00:09:28.350, Speaker A: Then we define an assembly block and inside we're going to read the content of the bytes and read it inside data B 32. So for that we go inside our assembly block and we reference our bytes 32. So data B 32 and we're going to assign to it the result of the M load opcode and we need to give it the correct address. So actually data is a pointer. So data is going to be the address of our bytes. But if we do this, it's not going to work, because the way that bytes are let out in memory, the first memory slot actually is the size of the byte, so the data actually start at the second slot. So what we want to do is to do an operation of adding 32 bytes to this pointer.
00:09:28.350 - 00:10:03.326, Speaker A: So we add 32 bytes and then m load is going to read from the correct memory location. If you want to know more about solidity assembly in the future, I will do a special series on advanced solidity that will contain more episodes just on assembly. And you can also check out the documentation of solidity that has a section just on assembly. By the way, if you want to know my most useful solidity tips, check this free email series link in the description. In the next video I'll show you how you can reuse code by using solidity libraries. Thanks for watching. See you.
00:10:03.326 - 00:10:04.060, Speaker A: Funny. Next video.
