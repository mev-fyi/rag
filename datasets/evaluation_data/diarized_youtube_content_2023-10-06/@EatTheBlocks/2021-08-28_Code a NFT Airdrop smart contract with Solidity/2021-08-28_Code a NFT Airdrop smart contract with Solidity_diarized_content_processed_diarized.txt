00:00:00.330 - 00:00:39.050, Speaker A: If you want to launch your NFT collection, how can you get some initial traction? A great solution is to give away some NFTs for free. That's what we call an airdrop. In this video, I will show you how to code a solid smart contract for NFT airdrops. You can use this on any EVM compatible blockchain, ethereum, binance, smart chain, polygon, etc. If you don't know me, I'm julian, and on etherblocks I teach blockchain development. Okay, so we're going to jump in the 3d code of the adrop spot contract. So this is a truffle project where I put the code.
00:00:39.050 - 00:01:28.978, Speaker A: So we're going to go in the contract directory and our code is in NfTrop sol. All right, so let's scroll down. So first we import the ERC 721 interface of open ziplink. That's because NFTs under the hood are ERC 721 tokens and we need this interface to manipulate them. Then we define our NFT airdrop smart contract and we define an airdrop struct. So when you do an NFT airdrop, contrary to an Earth 20 airdrop, for an NFT airdrop, you have to specify not only the address of your NFT but also the ID because in your NFT smart contract you have several NFT, each identified by an ID. Then we're going to define an integer.
00:01:28.978 - 00:02:01.970, Speaker A: Next airdrop Ids. This is an integer that is incremented as a key in this key value mapping here that's a mapping of all our airdrop. And also we have the address of the admin. This is to restrict the access to some function. And finally we have a mapping of addresses to boolean value. So the addresses will be the recipient of the airdrop and the boolean value tell you if the address was approved or not. So first in the constructor, when we deploy the spot contract, we make the deployer the admin of the contract.
00:02:01.970 - 00:02:26.870, Speaker A: Then we have the add airdrops function. So this is called by the admin of the contract. By the way, I just realized I forgot a required statement. So basically I need to copy paste this required statement here, just here for the access control. And here we're going to copy next Airdrop ID in a temporary variable. And that's because we're going to increment this in a for loop. But we don't want to touch the state of the smart contract.
00:02:26.870 - 00:03:31.962, Speaker A: And I forgot to explain here that in argument we pass an address of airdrop struct with the detail of all the airdrop that we're going to do. So for example, if you're going to do ten airdrop to ten different addresses, that means here you're going to have ten elements in your array and after in the for loop. So we are going to loop over this airdrops array and for each element we are going to populate our airdrops mapping by using the next airdrop ID as a key. And we're also going to transfer the NFT from the sender to our smart contract so that later our smart contract can do the airdrop. For this, first we get the address of the NFT and then once we have a pointer to the NFT, we call the transfer from function and we're going to transfer from the sender to the address of the smart contract. And we also grab the correct ID here. And after we increment our temporary variable next airdrop ID so that for the next loop we save the airdrop in the correct position in the airdrops mapping.
00:03:31.962 - 00:04:34.254, Speaker A: All right, so once we have called this, we have defined all our airdrops and then another function that needs to be called by the admin is add recipient where basically we're going to pass the address of recipient. So here we have the address of recipient as an argument. So this is restricted to the admin and we are going to iterate through the address of recipient. And for each of them we are going to populate our recipients mapping and we are going to set it to true for each of this address. And it's also possible to remove the recipients. So you pass an array of recipients that you want to remove and here in the for loop we are just going to set each entry to false in the recipients array. So the reason why I created separated function to add the recipient and airdrops entries is to make the system more flexible because in some cases some recipients are not going to claim the airdrop.
00:04:34.254 - 00:05:22.814, Speaker A: And so in this case you can send an email to your email list saying okay, well you guys just have two weeks left to claim your airdrop, otherwise you're going to be removed from the list. And at the end you just remove the addresses that haven't claimed the NFT and you add a new list of recipients so that your NFT are not wasted. All right, and finally we have the claim function. So that's the function that will be called by the recipient to claim the NFT. And so first we're going to do some access control and make sure that this address is in the recipient's mapping. And just after we remove the address from the mapping so that the address cannot claim twice an NFT. And after we are going to grab the next airdrop that is available and create a pointer to this airdrop.
00:05:22.814 - 00:05:59.434, Speaker A: And after we initiate a pointer to the NFT and again we use the transfer from function to transfer to the recipient. So here you might wonder how comes we don't use the transfer function, why we need delegated transfer. Well, that's because for ES 721 is different from ERC 20. We don't have the transfer method. For es 721 we just have a transfer from. So in this case the from address is ourselves. So specify the address of the smart contract here, address this and the recipient is the sender of the transaction and we'll specify the ID of the NFT.
00:05:59.434 - 00:06:39.334, Speaker A: And that's how we send the NFT to the recipient. And after we increment next airdrop ID so that the next recipient that called the claim function will be sent a different NFT. Okay, so that's it for the NFT airdrop smart contract. Next I'm going to show you how we can test this. So in our project folder, we going in the test folder in NFT airdrop Js first we import the NFT smart contract. So I just created this smart contract for testing. And after we import our NFT airdrop smart contract.
00:06:39.334 - 00:07:21.782, Speaker A: That's the smart contract I just showed you just before. After we define our test. So we define a couple of variables. I point her to the NFT contract, I point her to the airdrop contract. And we also extract a few addresses from our accounts array and we're going to use these addresses for testing. And so before each test we're going to deploy our NFT as well as the airdrop, and we're also going to call the set approval for all function on our NFT so that our airdrop is allowed to spend the NFT. And by the way, in the constructor of the NFT, I created three NFTs that all belong to the admin.
00:07:21.782 - 00:07:48.866, Speaker A: So here when you call set approval for whole, that means the airdrop contract will be able to spend all the NFTs of the admin. All right, so we go down and here we have our test. It should airdrop. So first we are going to call add airdrops. And since we don't specify the address, this is going to be done from the admin. And so we specify an array of airdrop with the NFT key. So that's the address of our NFT and the id.
00:07:48.866 - 00:08:35.714, Speaker A: And here the ID zero, one, two. How do we know these are the correct IDs? Well, that's because I use the same IDs in the NFT contract in the constructor when I minted the NFTs. And since we already call set approval for all before, when the airdrop spot contract is going to try to pull the NFT to its own address, it's going to work. Otherwise you're going to have a failure if you don't call this function. Okay, so then the admin is going to call another function of our airdrop contract, that's add recipients, and we're going to pass the address of recipient for our NFT. And after each recipient is going to individually call the claim function of our airdrop contract. So recipient one, two, three, and after that the airdrop should be complete.
00:08:35.714 - 00:09:21.706, Speaker A: And so we are going to check that the NFTs were all transferred. We don't have a function balance off for ES 721, but instead the equivalent is owner off. And as an argument you pass it the Id of the NFt. So the NFT with ID zero, the owner should be recipient one ID, one should be recipient two, et cetera. And just below we do our assertion. Okay, so in my terminal I'm going to run the test truffle test, and it should work. Let's see this, compile the contract, run the test, and show me this nice check arrow.
00:09:21.706 - 00:09:43.090, Speaker A: Yes, this is a success. That wasn't too difficult. Just a few lines of code and your smart contract is done. Our airdrop contract has a limitation though. The bigger the list of addresses, the more gas you will spend. Remember, we have to register all the addresses of the airdrop in our contract. It can get really expensive and you might even hit the block gat limit of Ethereum.
00:09:43.090 - 00:10:05.500, Speaker A: To avoid this problem, you could use a system of signatures where you approve the addresses of Chen and the smart contract. Only check the signature on Chen when each user individually claims his NFT. And if you want to learn how the signature system works, you can check out this video where I explain how I did the airdrop of the ETB tokens by using signatures. I will see you there.
