00:00:00.330 - 00:00:51.866, Speaker A: In this video I'm going to show you how you can cheaply clone an existing smart contract using the ERC 1167. I'm going to first introduce you the standard, and after we're gonna do some coding and see how we can use this to clone a solidity smart contract. This video is sponsored by Edoblox Pro, my weekly screencast for Ethereum, DAP and solidity smart contract developer. If you want to get access to the source code of all the free videos, go to the website of IdWBlox Pro and create a free account by clicking on sign up. Alright, so let's start by an introduction of the standard. Let's say that you have a DAP project and in this DAP project you have several smart contract and you're going to create a lot of the same smart contract. For example, if you're trying to do a loan system and you're going to represent each loan with loan smart contract, then you're going to redeploy a lot of time.
00:00:51.866 - 00:01:44.014, Speaker A: The same loan smart contract and you're going to waste a lot of gas because the same logic will be redeployed every time. So how can you save some gas and do better than this? Well, with the ERC 1167, actually, you can do some really cheap cloning of solidity smart contract. So how it works. First you have a user who wants to call a function in a smart contract and all the actual functionality, all the code of this smart contract is inside this implementation contract. However, the user does not call directly this implementation contract. The user instead called the proxy contract. So the proxy contract is actually what is defined in this 1167 standard and this contract will have the data and it will forward all the function code to the implementation contract which has the code.
00:01:44.014 - 00:02:51.042, Speaker A: But thanks to the proxy contract, this code will not be executed in the context of the implementation contract, but it will be executed in the context of the proxy contract itself, modifying the data at this level. So it's as if you could turn any deploy smart contract into a library and just use its code and execute its code in another context. In the future, if you want to clone the implementation contract, then you will deploy another proxy contract and another user will call your implementation contract through this other proxy contract and it will be totally independent from the data of other proxy contract that were deployed. So this way you're able to clone a smart contract in really cheap way because you avoid to redeploy the same code every time. The way the proxy contract is able to achieve this magic is by using assembly. So assembly is a sort of escape hatch of solidity that allow you to directly write instruction for the Ethereum virtual machine, or in short, just the EVM. So the EVM is the environment in which all your smart contract run.
00:02:51.042 - 00:03:56.438, Speaker A: And like a cpu, it has some elementary instruction that are very low level and that are a little bit more difficult to understand than writing solidity code. So I will not get into the assembly of the proxy contract, but all that matters is that the proxy contract is able to execute the code of another smart contract in its own context. The last thing I like to tell you before we go to the next section is actually this proxy contract is quite different from other proxy contract that you will hear about. So in general, a proxy contract is a contract that forward function to another contract, but it also allow you to update the address of the implementation contract. So for example, you start, you deploy your implementation contract at a certain date and in the future then you want to update your implementation. So you deploy another implementation contract on the blockchain and you'll change, if you are the admin of the proxy contract, you will change the address that it redirect to. So instead of redirecting to the first implementation contract, it's going to redirect to the new one.
00:03:56.438 - 00:04:33.986, Speaker A: However, in the case of the proxy contract of the 1167 standard, it's a sort of static proxy contract because once you've deployed it, you know that it will always redirect to the same implementation contract. So this is quite different from other proxy contract. Keep this in mind because otherwise you're going to be really confused when you read other tutorials about other proxy patterns. Okay, so we are done with the ERC 1167 standard. And next we're going to go to the next section. So I'm going to show you an actual example of how you can use this standard to clone smart contract. And we're going to create a directory for a truffle project.
00:04:33.986 - 00:05:04.362, Speaker A: So MKDR ERC 1167 and let's step into it and we're going to init the truffle project. So by the way, this requires that you've already installed truffle on your computer. If that's not the case, then you need to install it with NPM. So NPM install globally truffle. I already have it, so I don't need to do this. And once you have truffle, then you can execute the truffle init command. So this is going to start a new truffle project in your folder.
00:05:04.362 - 00:05:46.166, Speaker A: So let's see what we have inside. So this is the usual folder structure of a truffle project. This is not a tutorial on truffle, so I'm not going to explain that, but basically we are going to create our smart contract in the contracts directory. But first thing first, actually we are going to use some solidity code that uses an old version of solidity. So we have to change the setting of solidity in truffle config because by default, truffle five, the version of truffle I'm using is going to use solidity 5.0, but I need solidity 0.4.23. So let's open configuration file.
00:05:46.166 - 00:06:22.760, Speaker A: So let's go to the bottom so you can change some setting of truffle, and here we can see some comments that can help you if you want to change some settings. And so for example, there is a configuration for compilers if you want a custom version of solidity, which is our case. So let's change this. So let's uncomment this and we want 0.4.23, okay, and that's all we want. Okay, so let's save this. And in a contracts directory we're going to create a smart contract called storage Sol.
00:06:22.760 - 00:07:00.754, Speaker A: So this will be the implementation contract. This is where we will put all the logic of the spot contract that we want to clone using the proxy pattern of the 1167 standard. This is going to be a very simple spot contract that can store a string and modify it. First we'll start with the pragma statements. Pragma solidity 0.4.23. Okay, and after let's create our contract contract storage. And then we're going to define a string inside so string public, and we call this data.
00:07:00.754 - 00:07:24.838, Speaker A: And then we're going to define a set of functions. So a function that can change the value of this string. So function set data. And here it is going to be a string memory location call data because we're going to make this function external. So that's the memory location that we need. And we're going to call this underscore data. So here let's call this external.
00:07:24.838 - 00:07:49.054, Speaker A: And here is very simple. We just assign the value of underscore data to our data variable. So this is a setter function. It just changed the value of our string data. So that's it for our storage smart contract. I just want to make something very simple. This is just because we need some smart contract in our example for the implementation smart contract.
00:07:49.054 - 00:08:21.214, Speaker A: Okay, so we are done with our storage smart contract. So next we need to create a factory smart contract that can create new clone of our storage contract. So let's create a new smart contract in the contracts folder and we're going to call this contract storage factory. So let's recreate our pragmas statement. So same version of solidity 0.4.23 and this contract is called storage factory. Okay.
00:08:21.214 - 00:09:06.394, Speaker A: And the whole point of this contract is to have a function that we're going to call create storage. And this function is going to somehow create clone of storage smart contract. So how are we going to create this clone? So we need to use an implementation of the 1167 specification. I told you that there is an implementation in assembly, so this is not very easy. We're not going to create this ourselves. We're going to take the existing implementation of the creator of the 1167 standard. So let's go to GitHub and you'll find the official implementation at this address.
00:09:06.394 - 00:10:03.642, Speaker A: And if you go in the contracts directory then you will find implementation at clonefactory saw. So if we scroll down we will see this create clone function to create a clone of a smart contract. So the way it works is it takes as an argument the address of the implementation smart contract that you want to clone and then it runs some nasty assembly code that I'm not going to explain because this is not the point of this video. I'm just going to show you how you can use all of this and once it's created this clone, then it's going to return the address of the clone smart contract. So the calling function of create clone will have this interesting information that we can reuse for other stuff. So we need the code of this clone factory smart contract. So one way would just be to copy paste this code directly in our contract file.
00:10:03.642 - 00:10:43.878, Speaker A: However, there is an alternative way and with solidity we can import a contract by giving it a URL and solidity is smart enough to hit that URL and take the code from there. So we're going to do that. So let's go back to our contract and now let's import this smart contract. So let's use the import statement and we're going to give it the path to GitHub. So that's how you specify a GitHub pass in solidity. So first the username and then the name of the repo and then the pass contracts clone factory. And now we can use create clone function inside our storage factory contract.
00:10:43.878 - 00:11:25.106, Speaker A: So inside our create storage function, let's execute the create clone function and we need to give it the address of the implementation smart contract. Here. Let's call this implementation. But where do we get this from? Well, actually when we deploy the storage factory, it's the good time to specify what is the implementation contract. So let's create a constructor so function storage factory. So remember that we are using an old version of solidity, so we cannot use the constructor keyword. We need to use the old way of specifying a constructor.
00:11:25.106 - 00:11:53.066, Speaker A: And this is going to take a single argument. So the address of the implementation smart contract implementation. And this is going to be public. And here we're going to define a state variable called implementation. So we just assign it to same value as the argument. And above. Let's define this state variable, so address public implementation.
00:11:53.066 - 00:12:35.114, Speaker A: So this is set when we deploy the smart contract. And so now our create clone function can use this state variable. So this function is going to return the address of the clone contract. So let's define a variable that we call clone. And here with this clone, what you can do after is to execute a function to initialize it. So that's something that is a little bit tricky when you use this 1167 standard is that you cannot put the initialization code inside your constructor, but you need to define a separate function that is called init. So that means that you need to do something like this to initialize your clone smart contract.
00:12:35.114 - 00:13:14.490, Speaker A: So storage, then you pass it the address of the clone. So that's how you get a pointer to the clone smart contract. Then you execute the init method and then you pass it some arguments, for example my arg. And if you do this, then that also mean that probably you will define your argument in a create storage function. So for example, you say something like string my arg. In our case we're not going to do it, but it's just to show you how you would do it if you actually need initialization code. So let's comment this out.
00:13:14.490 - 00:13:59.674, Speaker A: Let's write that's how you would initialize the clone if needed. Okay, so now we have created our clone. However, we somehow need to communicate this address to the color of the create storage function. Unfortunately, since this is a function that is executed in a transaction, we cannot just do something like return cloned because in ethereum transaction it's not possible to return value. We can only return value if we execute this function in a call that does not modify the blockchain. There are two different API when you execute a smart contract. So how are we going to do this.
00:13:59.674 - 00:14:46.360, Speaker A: So we are going to create an array of addresses for the clone contract and we're also going to create another function to access these different values. So let's go on top and let's create a new variable. So that's going to be an array of address that's going to be public and we're going to call this clone contract. And in the create storage function then clone contracts push and we push the clone. Let me remove this, we don't need it. And below let's create a getter function. So we're going to call this get address.
00:14:46.360 - 00:15:24.094, Speaker A: And here we pass the index get address, sorry. And we pass the index that we want to return. And this is going to be a function of type view. So this is not a transaction, we just want to read some data and we make it external and we specify the return type. So this is an address and inside it's very simple. All we do is just we take the clone contract array and we pass it the index of the argument and that's it. So this how an external entity will be able to get the address of the clone contract.
00:15:24.094 - 00:16:10.114, Speaker A: Keep in mind that the way I do it is just one way, but there is an other way, which is maybe actually a little bit more simple. So this other way would be to create an event. So you will create an event that you will call clone contract and then you will give it an address. So clone contract. And if you give it any argument, then you will also give you argument here. So string my arg, et cetera, et cetera. And here inside your create storage function, basically you will emit this clone contract event and then you will read this event.
00:16:10.114 - 00:16:49.242, Speaker A: However, since I just want to use truffle and nothing else, it's not really easy to read the event in this case. So I'm not going to use this and I'm going to use this method with the array of addresses. So we are missing the import to our storage smart contract. So here let's add it import storage. And we missed the last thing before I can show you a demo of this. So we probably need some sort of access control because we don't want anybody to be able to call the create storage function. So let's define an admin in the contract.
00:16:49.242 - 00:17:32.874, Speaker A: So address public admin. And when we deploy the contract, then we're going to set this admin to the sender of the transaction. And after in the create storage function we're going to require that the sender of the transaction is the admin and only admin can clone contract. Okay, so let's save this. And so now we need to actually deploy this contract. So we need to create two migration file, one migration file for the storage smart contract and then another one for storage factory. So let's go back to our terminal and we're going to use the command line of truffle.
00:17:32.874 - 00:18:05.910, Speaker A: So truffle create migration. And first our first migration is storage. And the second one will be storage factory. Okay, so let's go back to our editor and let's open our two migration file. So first storage. And first we need to import the storage smart contract artifact, sorry. So artifact require storage.
00:18:05.910 - 00:18:47.270, Speaker A: Okay. And inside we need to use the deployer object of truffle and we execute the deploy method and we pass in the storage artifact. Okay, and oops, I'm missing a parenthesis here. Okay, you know what, I'm just going to copy this and I'm going to paste and do a search and replace in the other migration file. So here, let me paste this. Okay, let me do a search and replace. So I'm using some Vimfu here, but you can use search and replace in your editors storage by storage factory.
00:18:47.270 - 00:19:21.134, Speaker A: Okay, so now I have everything configured. So let's open a new terminal window and we're going to start a truffle console. So truffle develop is going to start an instance of ganache. So the local blockchain for development. And now let's deploy everything with migrate reset and it should work. Let's see if we have any error. Oh, I got it.
00:19:21.134 - 00:19:57.130, Speaker A: It's because we are using solidity 0.4 and we shouldn't specify the memory location for string when it's an argument. So let's go back to our editor, let's open this storage smart contract, and here in the set data function, let's remove this call data thing. Okay, let's save this, let's go back to the truffle console, migrate reset again and now it cannot find a smart contract. There's probably an import pass. That is wrong. So let's go back to editor and let's open storage factory.
00:19:57.130 - 00:20:28.310, Speaker A: And we forgot the saw for the import pass to storage. So let's save storage factory, go back to truffle console, migrate reset again. And this time it has some problem to fetch the clone factory from GitHub. So you know what, I don't want to waste too much time. So let's go back to the GitHub repo of this clone factory. So that's the official implementation of the 1167 standup. And let's click on contracts and clone factory.
00:20:28.310 - 00:20:57.120, Speaker A: And we're going to copy everything. So copy this and then go back to your editor and let's create a new smart contract that we're going to call clone factory. Sol let's paste this. Okay, and let's go back to storage factory. And let's change the import pass to clone factory. So this time it's on our file system. So it's going to be easy.
00:20:57.120 - 00:21:26.386, Speaker A: Okay, so, okay, so now everything should be fixed. So back to our truffle console. So migrate reset again. And another error. What is the problem? So back to storage factory. Oh, it's because we forgot to import clone factory because we are using the create clone function, but in order to use it, we need to inerit from it. So storage factory is clone factory.
00:21:26.386 - 00:21:56.210, Speaker A: Okay, so now it should be fine. So let's migrate everything. And knight complains that the storage factory contract cannot be deployed. Where's this? So we have our constructor here, and our constructor is expecting an argument for the implementation. So that's basically the template that we're going to copy. And we didn't give this address. So let's open the migration file for storage factory.
00:21:56.210 - 00:22:32.886, Speaker A: Okay, so here we need to grab the address of the storage smart contract. So let's define a variable that we call storage. And we're going to use the storage artifact and we're going to execute the deploy method. Actually, this need to be awaited. And if we use the await syntax, then we also need to make this function async. Okay, so this is going to return a pointer to the storage smart contract. So this is not a Webster instance, but this is a truffle contract instance.
00:22:32.886 - 00:23:20.090, Speaker A: So if you've never heard of truffle contract, this is basically a sort of web three equivalent, but just for truffle, it might be discontinued in the future. They might just use web three everywhere. But the point is, in order to access the address on this truffle contract instance, we just need to use the address field. So here in the deploy method, we give the storage factory artifact, and after that we're going to add a comma and we can pass some arguments for the constructor. And here we're going to pass storage address. Okay, and by the way, we also need to import the storage artifacts. So const storage equal artifacts require and here storage.
00:23:20.090 - 00:23:40.658, Speaker A: Okay, so now we should be fine, my friends. So let's go back to a Trafford console and see how is everything. So migrate reset, enter. And this time it works. Woohoo. Oh, that's amazing. We fixed everything so our setup is working, but I haven't demonstrated anything here.
00:23:40.658 - 00:24:49.722, Speaker A: What I want to do is clone the smart contract several times and call the set data function on our storage smart contract and show you that the data of all this clone is separated. So let's go back to the migration file of storage factory and we're going to create several clone. So currently we are just deploying the template storage smart contract and after we're deploying the storage factory, but after we're going to call the storage factory and we're going to call the create clone function. So how can we do this? So first let's grab a pointer to the storage factory. So we define a variable called storage factory and then equal await storage factory deployed. Okay, and after let's create a couple of clones, so storage, so awaitstoragefactory create storage and let's create three clone. Okay, so next we need to get the address of the cloned smart contract because after we're going to need to have pointers to this smart contract to execute the set data function.
00:24:49.722 - 00:25:26.102, Speaker A: But the first thing we need is the address. So let's define some variable. So let's say storage address one equals storage factory. And you remember that we created this get address function to get the address of the clone smart contract. And this is indexed by the position of creation. So to get the first one you pass the index zero and then two and three it's going to be one and two. So two and three here it's going to be index one and index two.
00:25:26.102 - 00:26:03.662, Speaker A: Okay, and now we need to create pointer to this smart contract. So const storage one. And here we use the storage artifact and we use the ath method. So the ath method will basically instantiate a pointer to an existing smart contract. So we give it the address. So storage address one and same thing for storage two and storage three. Okay, so two, sorry, one, two, three.
00:26:03.662 - 00:26:42.714, Speaker A: Okay, so now we have our pointer to our storage smart contract. And now what I want to do is to execute the set data function on all this contract. And after I'm going to show you that when we're going to read the data variable in this contract, we're going to see that they have different value, which means that they are independent. So let's do this. Oh, by the way, we are missing the await keyword everywhere. Not good, Julian. So here await, same thing here, same thing here and you guessed it, everywhere, await keyword.
00:26:42.714 - 00:27:28.070, Speaker A: Okay, so first we're going to execute the set data function on the sort of master storage smart contract. So that's the template that was first deployed. So storage set data, and we're going to pass it an argument storage. And after for one, two, three, we're going to do storage one, storage three, et cetera, et cetera. So storage one, storage two, storage three. Okay. And by the way, we also need some await keyword because this is an async operation.
00:27:28.070 - 00:28:21.162, Speaker A: Okay, and so finally we are going to console log the value of the data variable in all this smart contract and see if they are different or not. So console log and here await storage data and same thing for storage 123123. Okay, so now let's go back to our truffle console and let's reapply migrate reset. And storage factory has not been deployed to detect the network. Let's go back. Oh, it's because we are missing an await keyword. So let's go up and here when we use the deploy method for the storage factory, we need to await it because otherwise it's not going to be executed right away.
00:28:21.162 - 00:28:58.258, Speaker A: And when we try to grab a pointer to this smart contract, then it points to nothing. All right, so back to our truffle console and migrate reset. And now we can see that the different value that we console log are what we expect. So storage, storage one, storage two, and storage three. So I have demonstrated to you that we have deployed three clone of the same smart contract using the proxy smart contract of the 1167 standard. And although the code of all this smart contract is identical, they each have their separate storage. All the data is independent.
00:28:58.258 - 00:29:25.900, Speaker A: So that's it for this video. Now you know how to cheaply create clones of smart contract using the 1167 standard. That was a pretty advanced level tutorial on solidity. See, probably one of the hardest I've ever done on Etherblock. So if you find it a little bit difficult, it's normal. Just go back, rewatch the video and you can tell yourself that after you master this you really became a better solidity developer. Thanks for watching and see you for my next video.
