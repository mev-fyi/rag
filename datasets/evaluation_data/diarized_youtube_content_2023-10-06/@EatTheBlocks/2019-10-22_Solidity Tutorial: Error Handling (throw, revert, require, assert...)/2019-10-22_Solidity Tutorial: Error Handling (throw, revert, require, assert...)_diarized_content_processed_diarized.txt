00:00:00.170 - 00:00:42.166, Speaker A: Hey, this is Julian, and in this video I'm going to show you how you can handle errors in your solidity smart contract. So first of all, I'll explain you what happened when there is an error in a solidity function. Then I'll show you a couple of keywords that you can use to create an error, like throw, revert, require, and assert. And finally, I'll explain you what happened when there is an error in other smart contract. So first let let's understand what happened when there is an error. So let's create a function. So in our function we'll have a couple of instructions, so everything is going well, and suddenly here, boom, error.
00:00:42.166 - 00:01:21.154, Speaker A: This can happen either because you are triggering an error with one of these keywords, row, revert, require, or assert, or it can happen because you're trying to do something that solidity does not allow, like accessing an out of band element in an array. So when this happened, the execution of the function is stopped. So after, if you have other instruction, then this instruction will never be executed. And second, any state change is reverted. So if previously you had a state change, like modifying a state variable like a equal ten for example. So here a was state variable. So the state change is going to be reverted.
00:01:21.154 - 00:02:16.310, Speaker A: So the value of a will stay the same as it was before you call the full function, and finally the gas will be consumed. So as I mentioned before, I will do a series just on gas, but just know that gas is something that you have to pay when you send transaction to a smart contract. So depending on the nature of the arrow, either all the gas up to the point of execution will be consumed or the whole gas that was provided for the transaction. When you have an error, not only you're not going to have the state change that you want, but you're also going to waste money because you have to pay all this gas. So errors are definitely something that you want to avoid, but sometime you actually want to trigger them. For example, if one of the argument of your function is out of a certain range, and to trigger these errors, you can use any of these keywords. So let's start with the first one.
00:02:16.310 - 00:02:44.478, Speaker A: So the throw keyword was the first keyword to throw an error in solidity, and it was deprecated in solidity 0.5. So you will only see it in old solidity smart contract with solidity 0.4 and before. So don't use this keyword. And in any case, three DT 0.5 will not let you use it. The second way you have to throw an error is with the revert keyword.
00:02:44.478 - 00:03:18.650, Speaker A: So with the revert keyword, you can actually specify an explanation for the arrow. So this is why it reverts. And actually if you want to do a conditional revert, you could do something like this. If such condition, then execute this revert. But there is a shorter way to do this, and that is with the require keyword. So let's see how this works. So with the require keyword to do the same thing, you'll do this.
00:03:18.650 - 00:03:51.986, Speaker A: So it takes two argument. First, you're going to test for a condition. So here I want a to be different from ten. And if this is not the case, so if a equals ten, then I'm going to trigger an error and show this error message. This is why it reverts. So these three line here are exactly the same as this line here. And finally, you can trigger errors with the assert statement.
00:03:51.986 - 00:04:34.082, Speaker A: So for this, you assert a condition. So you're going to assert that a is different from ten, and there is no error message, there's just a condition. And if this condition is not true, then it's going to throw an error. There is a semantic difference between assert and require. So with require, you can handle errors that can happen normally in the lifecycle of your smart contract. But with assert you are testing for errors that should never happen. So if you see an assert statement in a smart contract, that means that this variable, for example, it should never, never equal ten.
00:04:34.082 - 00:05:06.106, Speaker A: And if you finally equals ten, that means there is a bug in a smart contract. So for example, this asset statement that can be used by tools to analyze your smart contract. And these tools can tell you that in some condition this asset statement can fail. So you have to review the logic of your smart contract. But require is more for the runtime of your smart contract. So most of the time you will use this require statement. Okay, so let's quickly see what are the error message given by this statement.
00:05:06.106 - 00:06:03.300, Speaker A: So here let's create a function will throw. First I'm going to revert because reasons, okay, so let's deploy our smart contract, and if we click on will throw, then here in the console it says transact blah blah blah vm error revert. The transaction has been reverted to the initial state because reasons. So here we can see our error string. Okay, so now let's change to require. So let's test for something that will always fail, like true equal false. Okay, so let's deploy this.
00:06:03.300 - 00:07:08.722, Speaker A: And now will throw tell me exactly the same thing. And here again, we can see our error string? And finally, if we assert something, so assert true equal false, then we redeploy the smart contract wolf row, and this time it just tell us invalid opcode and we don't see any error string. So that is because this asset statement was introduced before there was an opcode in the Ethereum virtual machine just for string error. The old way of string error was to create an invalid opcode in the Ethereum virtual machine. All right, and next I'm going to show you how it works when you have error in other smart contracts. So let's quickly create another smart contract B. And in this smart contract B, I'm going to create a function bar and this function is going to error.
00:07:08.722 - 00:08:14.134, Speaker A: So we're going to revert because other reasons, okay, and we're going to call this smart contract from a. So call will throw in other contract. So first we create a pointer, we do this contract, then we create a new contract B, okay? And then we're going to call bar like this. So let me deploy this. So I select my contract, I deploy it and I click in will throw in other contract. And what happened? Then we see exactly the same thing as when we were throwing inside our own contract. So in this case the arrow propagates to the calling contract.
00:08:14.134 - 00:09:03.302, Speaker A: So when this happened, the whole transaction is going to fail. So any state chain that took place inside the calling smart contract will be canceled, but also in the code smart contract. So it's really all or nothing. But it's also possible to recover from the error if you call the smart contract with another way. So let's see how we can do this. So we're going to cast our B pointer to an address and we're going to use the call method and then we're going to use Abi encode pact and then we give the function signature between string so bar like this. All right, so let me comment this and I'm going to redeploy the smart contract.
00:09:03.302 - 00:09:28.862, Speaker A: And this time you will see that something changed. So here I click on will throw in other contract. And this time you see that there is absolutely no error. The transaction was sent successfully. So in this case this line here is going to return a boolean set to false. And so if this boolean is set to false, then you know that there was an error in the code spot contract. And you can handle this however you want.
00:09:28.862 - 00:09:58.180, Speaker A: By the way, I created a free email course to teach you how I got my first remote blockchain job, paid $100,000 a year. So if you want to learn all my secrets, you just have to sign up at this URL. Okay, so that was it for errors in solidity. Smart contract in the next video, I'm going to show you how we can combine the required statement with function modifier so that we can implement access control in our smart contracts. Thanks for watching and see you for the next video.
