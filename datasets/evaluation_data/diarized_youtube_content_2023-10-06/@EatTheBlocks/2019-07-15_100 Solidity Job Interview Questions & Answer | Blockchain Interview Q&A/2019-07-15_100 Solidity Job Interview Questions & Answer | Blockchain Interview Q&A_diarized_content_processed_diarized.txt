00:00:00.170 - 00:00:36.450, Speaker A: In this video, I will give you 100 questions and answers to prepare. Your solidity job interview question will be of different difficulties. Starting from easy going to intermediate and all the way up to difficult. It covers the most important aspect of solidity, smart contract and Ethereum. So after you went through this 100 questions, I guarantee you that you're gonna be really ready for your job interview. And even if you're not preparing a job interview, it's very much worthy to watch the video because you're going to learn a lot of stuff that you didn't know about solidity. By the way, this video is sponsored by Edoblox Pro, my screencast for Ethereum and Solidity smart contract developer.
00:00:36.450 - 00:01:20.070, Speaker A: If you want to access the source code of all my other video tutorials on solidity and Ethereum dapps, you can create a free account on Edoblox Pro. All right, so now let's get started. And we're going to start with the easy questions. What is an Ethereum smart contract? It's a small program that runs on the Ethereum blockchain. What makes an Ethereum smart contract so special compared to other programs? Once an Ethereum smart contract has been deployed to the blockchain, it cannot be stopped. Even if you are the creator of the smart contract, or the government, or even the developer of Ethereum, nobody can stop a smart contract once it has been deployed. It also cannot be hacked as long as the code of the smart contract is correct.
00:01:20.070 - 00:01:52.830, Speaker A: Of course, if there is a bug in the code, then of course your contract can be hacked, like what happened to the DAO. And it's also not possible to modify a smart contract. Just to be specific, the part that cannot be changed is the code. So we said that the code is immutable. However, the data of the smart contract can be modified. Can a smart contract interact with other smart contracts? Yes, and that's actually what makes smart contracts so powerful. Any smart contract can call function on other smart contracts and trigger a sort of chain of execution through the blockchain.
00:01:52.830 - 00:02:59.174, Speaker A: Can a solidity smart contract call an API on the web? No, a smart contract can only execute its own code and interact with other smart contracts on the Ethereum blockchain. If you need your smart contract to interact with an API on the web, the pattern you use is the Oracle pattern, where an external API calls a function on a smart contract and feed it with some data. And after that, the solidity smart contract can make use of this external data that was imported in the Ethereum blockchain, but it's always from the outside world to the blockchain, and never the other way around. Can a solidity smart contract store a lot of data? No. In a smart contract, storing data cost gas, and gas consumption is capped in each Ethereum block, so indirectly storage is limited. And also, since it costs money to store data in a smart contract, you probably don't want to store a lot of data anyway. Can a smart contract be written in another language than solidity? Yes, there are other smart contract languages like Viper or LL, but solidity is.
00:02:59.212 - 00:03:00.870, Speaker B: By far the most popular.
00:03:01.530 - 00:03:44.622, Speaker A: Is solidity a dynamically or statically typed language? It's a statically typed language, which means that variable types need to be defined. That's different from languages such as JavaScript, where you don't have to do this and you can just define your variable and use them right away. And a language figure out the type of the variables on the blockchain. We have to be a little bit more careful about what we do, because after we deploy a smart contract we can't modify its code. So if there is a bug, it's a big problem. And one way to be really careful is by defining the type of every variable, and by being this explicit we reduce the chances of making errors. Is solidity compiled or interpreted? It's compiled.
00:03:44.622 - 00:04:21.386, Speaker A: That means that before we able to run a smart contract, we need to first compile it. That's different from JavaScript, where after you finish writing your code, you can run it directly. The JavaScript virtual machine will compile your code on the fly. That's called just in time compilation, but we don't have this in solidity. What is the file extension of solidity files? Solve pretty simple. Can a single solidity file have several smart contracts? Yes, you just have to use the contract keyword several times. Actually, when you deploy your smart contract, oftentimes it's more convenient to put all your smart contract in a single file.
00:04:21.386 - 00:05:03.134, Speaker A: However, in general, it's better to have a single smart contract in a single solidity file for better code organization. What is the typical layout of a solidity smart contract? First, you need to put the pragma statement to indicate to the solidity compiler which version of solidity you want to use. This is for avoiding mistakes, where you write a smart contract for a version of solidity, but you accidentally used another version when you compile the smart contract. Next you need to declare your smart contract with the contract keyword. Everything which is between the curly brackets is part of this smart contract. Then you can define some variables in your contract and then you define some function to be able to read some.
00:05:03.172 - 00:05:45.802, Speaker B: Data or modify some data. What is the difference between state and local variables? State variables are persisted on the blockchain after a smart contract finished to execute, whereas local variable live only during the execution of a function. What is the problem with the following solidity code? The set function redefined the data variable inside its body. This will create a local variable that will shadow the state variable defined above. To fix the code, remove the address keyword when you reference data inside the set function. Another question about what is the problem was the following code. This is similar to the problem we had just before.
00:05:45.802 - 00:06:47.326, Speaker B: The data argument of the set function shadows the data state variable inside the function. Because of this, we can access the data state variable inside the set function. To solve this problem, we need to rename the argument from data to underscore data. What are the two variable visibilities for state variables in solidity? Private and public? Who can read private and public variables? Private variables can be read only by function inside a smart contract, and public variables can be read by anyone. What is the default visibility of state variables? Private are private variables really private? No. Actually, private variables are only private for the EVM, which is the Ethereum virtual machine, the part of the Ethereum that executes smart contracts. But the data of smart contract is put on the Ethereum blockchain and all data on this blockchain is public.
00:06:47.326 - 00:07:54.574, Speaker B: You can use a special tool to analyze blockchain data and you will be able to read any variables, including the private variables of smart contracts. So private variables aren't really private, it's just that it's a little bit harder to read them. How to deal with private data then you either don't put private data on the blockchain, or you put hashes of data. Mention three data types that you use often and explain why the integer type is used mainly for ether and token transfers. Address is used for identifying humans and smart contract, and finally, strings are used for naming things. What are the two container types in solidity? Mappings and arrays how to declare an array of integer in solidity how to declare a mapping of address to booleans in solidity in this example, address is the key and boolean is the value. How to declare a mapping of address to a mapping of address to Boolean so in other word, a nested mapping.
00:07:54.574 - 00:08:48.280, Speaker B: The way you do this is by using the mapping keyword inside a mapping. So the first key is address. Then you have a second address key, and finally you have the boolean value how to add data to an array declared as a state variable, you basically use the push method. How to add data to a mapping declare as a state variable, you need to use the bracket notation and to specify which key you want to access. How to loop through an array, you have to use a for loop first you define an initial condition, then you define a stopping condition. Then you define what happened at every increment, and inside you write the code that will be executed for every pass. What is the difference between a u in eight and a u in 16? Un eight can store numbers of up to two power eight minus one, so that means it has eight bits, whereas un 16 can store numbers of up to two power 16 minus one.
00:08:48.280 - 00:09:36.020, Speaker B: What are the four function visibilities in solidity? By increasing permissiveness, the most rigged visibility is private. That means that the function can only be called from inside the same contract. Then you have internal, which means it can only be called from inside a contract, or another contract that inerrate from it. Then you have external, which mean the function can only be called from outside a smart contract. And finally you have public, which mean it can be called both from function inside a smart contract and also from outside a smart contract. How to conditionally throw an error with an error message for that you will use a required statement. First you specify what is the testing condition, and if this condition fails, the second argument is the error message.
00:09:36.020 - 00:10:21.470, Speaker B: What are the two artifacts produced by the solidity compiler when compiling a smart contract? The ABI and the bytecode what is the ABI of a smart contract? The ABI defines the interface of the smart contract, which means the set of function that can be called from outside the smart contract. It is used to interact with the smart contract. The API is used outside of the smart contract by Ethereum client libraries like Webstery. The API only defines the function signatures. That means the function name, the argument types, and the written times, but it does not define the implementation of the function. The ABI also defines the events of the contract. In the following contract, which function will be part of the ABI? Foo and Ba will be part of the Abi.
00:10:21.470 - 00:11:18.210, Speaker B: Baas is internal only. It can be only called from inside the smart contract, so there is no point in putting this in the ABI. Does the EVM understand solidity? No, the EVM only understand bytecode, which must first be produced by solidity outside of the blockchain. What is the EVM bytecode? The EVM bytecode is a series of EVM elementary instructions called opcodes these opcodes define very simple operations like adding two numbers, loading data from memory, et cetera, et cetera. There are more than 100 of these opcodes defined in the ethereum yellow paper. Coding directly with opcodes would be very tedious, so we need higher languages like solidity to help us reason at a higher level of abstraction. What are the two API used to interact with a smart contract? Add underscore send transaction and add underscore call transaction costs money and can modify the blockchain.
00:11:18.210 - 00:11:57.406, Speaker B: Calls do not cost money and cannot modify the blockchain but can return a value contrary to transactions. What is gas? It's an abstract unit to measure transaction cost. How is gas? Ped gas is paid in ether using the formula ether. Cost equals gas price times gas, where gas represents the gas cost of the execution of a transaction. Gas price is in way per gas, generally expressed in GuI. It is set freely by the sender of the transaction. A transaction also specifies a gas limit parameter, which specified a maximum number of gas that can be paid by a transaction.
00:11:57.406 - 00:12:44.602, Speaker B: Without this, a transaction could potentially drain an account of all of its ether. What happened? If there is not enough gas in a transaction, the transaction is stopped and all state changes are reverted. Who pays for gas in a transaction? The sender of the transaction what is the most famous ide for solidity? There are quite a few IDe for solidity, but the most famous by far is remix. To use it, you only need to go to the s address in your browser. No need to install anything besides a code editor for Solidity. You can also run an in memory blockchain that you can use to develop your smart contract. These two famous frameworks for solidity smart contract development truffle and open zeppelin truffle is the most popular framework for developing solidity smart contract.
00:12:44.602 - 00:13:36.266, Speaker B: It allow you to easily deploy your smart contract to a development blockchain and interact with it. Open Ziplin provides reference implementation for a lot of token standards like ERC 20 or ERC 721. So before you create your own smart contract, you should always check out if open Zeppelin doesn't already have an implementation that you can reuse. Which JavaScript Ethereum client can we use to develop solidity? Smart contract on a local blockchain? Ganache Ganache is a CLI tool that you can use to automatically start a development blockchain on your computer. This development blockchain is a safe box that you can use to develop your smart contract. It's not connected to any public ethereum network, and every time you start it it start with a fresh blockchain with no data on it. It also comes with ten preloaded Ethereum account that you can use to develop your smart contract.
00:13:36.266 - 00:14:26.578, Speaker B: All the ether that you use on this blockchain is fake ether, so you can spend it all. It's no problem. What do you need to deploy a smart contract to the Ethereum network? You need the bytecode of the smart contract, you need an Ethereum address with enough ether to cover transaction cost. You need a wallet to sign the transaction, and you need a tool to create the transaction and coordinate the signing of the transaction with the wallet and then sending the signed transaction to the Ethereum network. List four famous Ethereum wallets metamask, my Ethereum wallet, Ledger and Treasure Metamask is probably the most famous Ethereum wallet. It's a browser extension available on Chrome and Firefox. Most dapps make sure that it work with Metamask because it's what most users are using.
00:14:26.578 - 00:14:56.810, Speaker B: Metamask store private key in the browser and it requires a password in order to be used. Myether wallet is a website that has a wallet functionality. Ledger and Trezor are two hardware wallets. They can store ether but also bitcoin and many other coins. They are not as easy to use as metamask and myether wallet, but they are way more safe. Usually it's better to put most of your money on a ledger or a Trezor. And in metamask or my ether wallet you will just put some small change in order to use some DAP.
00:14:56.810 - 00:15:41.594, Speaker B: List three networks where you can deploy a solidity smart contract. The most famous one is mannet, so that's the quote unquote real ethereum network where we manipulate real ether. That's the equivalent of a production deployment in the world of web application. Then you have Robston which is a public testnet. So before you deploy to Mainnet, you always deploy first to Robsten to make sure that everything works fine on its test network. The ether you manipulate on Robstone are not really real ether, so it doesn't matter if there is a bug of some of these ether are lost. Robstone can be used with any ethereum client, so it doesn't matter if you run parity gas or any other.
00:15:41.594 - 00:16:07.682, Speaker B: Robstone works with everyone. And another network that we can deploy to is Covan. Covan, like Robston, is a public testnet where you can deploy your DAP before you deploy it to the real network, Mainnet. So Covan is specific for parity client. It doesn't run on other clients. There are quite a few other ethereum network, but the three one I just mentioned are among the most used one. Next we're going to switch to the intermediate question.
00:16:07.682 - 00:16:54.980, Speaker B: It's going to be a little bit more difficult, but most employers will. But keep in mind that for most solidity development position, most employers will expect you to be able to answer these questions. So let's keep going. How to manage dates in solidity so, solidity doesn't have a native date type the way we manage date in solidity is by using timestamps in seconds. We store this large integer in uint variables. How to have the current timestamp in seconds, you just have to use the now building variable. How would you build a timestamp of one day in the future? So you would use the null keyword, which will give you the current timestamp in second, and to this you will add 80,400, which is the number of second in one day.
00:16:54.980 - 00:17:47.310, Speaker B: What are the two ways of defining custom data structure in solidity? You can use struct or nm. When would you use a struct versus an enum? Struct are for representing complex data structure with different fields, a little bit like object in JavaScript, and enum are for creating variant of the same data. So for example, a color can have different variant like red, blue or yellow. You can combine both, because an enum can be a field of a struct. What are the two ways to instantiate a struct? First, you can pass an order list of arguments. In this case the order of arguments matter, and the other way is by using the curly braces notation where you have to specify the name of the arguments. In this case, the order of the argument does not matter how to instantiate a struct that has an inner mapping.
00:17:47.310 - 00:18:27.982, Speaker B: So for this, let's consider a struct that is called user and that has three fields. So first it has an address ID field, then it has a string field called name, and finally it has a mapping field called friends, and this is a mapping of address to Boolean. So let's assume that the user struct is stored inside a mapping. So we're going to call this mapping users and that's a mapping of address to user. So the problem when you have a nested mapping in a struct is that it's not possible to instantiate a mapping in memory. And after assigning to the struct, mapping can only be with a memory location storage. So the way you're going to get around.
00:18:27.982 - 00:19:14.480, Speaker B: This is basically you are going to reference a struct that does not exist yet. So you reference the user's mapping and then you reference an entry that does not exist yet because it's possible to do this in solidity mappings. And you're going to assign the different fields, so ID name and for the mapping. Then you're going to reference the key of the inner mapping that also does not exist. And finally you assign the value of this inner mapping. That's not very intuitive, but that's how you instantiate an inner mapping in solidity. When would you use an array versus a mapping? You would use an array if you want to be able to iterate through a collection of value and you want to use a mapping if you want to be able to do a quick lookup for a specific value.
00:19:14.480 - 00:19:46.626, Speaker B: How to combine array and mapping to allow both iteration and rapid lookup for a struct. So first let's consider this struct. This truck has two fields, an integer field and a string field. So first we are going to define an integer array that will store all the id field of the user struct. This way we can iterate through all the user IDs. Then we are going to define a mapping of integer to user struct. The keys of this mapping will be the user Ids.
00:19:46.626 - 00:20:25.374, Speaker B: If we need to rapidly look up a user and we already know its id, then we can use the mapping and quickly get the user struct. And if we need to iterate through all the user, then we're going to create a for loop with the user id's array. And inside this for loop we're going to use the user's mapping to get its user by its iD. How to define an inmemory array of three integers first you define an integer array with the bracket notation. Then you use the memory keyword to specify that this will be an inmemory array. Then you define the name of the array. Then we need to instantiate this array.
00:20:25.374 - 00:21:04.718, Speaker B: And for that you use the new keyword. You use uint, again with the bracket notation. And after that between parentheses you give the length of the array. So that means that an inmemory array needs to have a fixed length. It cannot have a dynamic length like you have for storage array. How to add value to an inmemory array so with inmemory array you don't have access to the push method of storage array. Instead you need to assign a value to a specific index in an array using the bracket notation how to get the list of older keys in a mapping a little bit like object keys in JavaScript, it's not possible.
00:21:04.718 - 00:21:45.338, Speaker B: Smart contracts don't keep track of the list of entries in a mapping. You need to already know which key you want to access, or you can store a list of all the keys in a separate array. How to create an inmemory mapping in solidity it's not possible. The memory location of mappings can only be storaged. What happened? If you access the key of a mapping that does not exist, solidity will return you the default value of the type. For example, let's say that we have a mapping of integer to Boolean. If we try to access my map of ten, but that this entry does not exist, it will return false because the default value of a boolean is false.
00:21:45.338 - 00:22:18.034, Speaker B: This behavior is different than arrays. If you try to access an element of an array that does not exist, there will be an error. With mapping, there is no error. What are the three mechanism for code reuse in solidity? First, you have a function. So if you notice that there are a couple of places in your code where you use the same code, then you can group this common code in a single function. Then there is code inheritance. So like for other programming language, then you can have ancestor contract and a child contract that inherit from ancestor contract.
00:22:18.034 - 00:23:04.600, Speaker B: So this way you have a basic code in the ancestor contract and each child contract can extend this code. For example, if you see the code of the openzepling framework, you will see that net make a heavy use of inheritance in solidity. How to make a contract a inherit from a contract b in solidity. So first you need to input the ancestor contract with the import keyword. Then you need to make your child contract inherit from the ancestor contract using the ease keyword. And finally, if the ancestor contract has a constructor, then you need to call this constructor in a constructor of your child contract. If a contract a inherit from another contract b, and both contract define the same function foo, which one will be resolved in a contract a.
00:23:04.600 - 00:24:13.158, Speaker B: So in the first case, if both function have exactly the same function signature, then the function foo of the contract a will be resolved. The implementation of a child contract always override the implementation of an ancestor contract. However, in the second case, the function signature of foo in contract a does not match the function signature of the function foo in b. So for example on the contract a, if you try to call foo and you give it an argument, for example the integer one, then the foo function that will be resolved will be the foo function of contract b, not foo of contract a, which doesn't take any argument. So you need to be careful of function signature when you deal with function override. What are the four memory location of solidity, storage, memory stack, and cold data? What is the default visibility of state variables? Private that means that only the smart contract can have access to them. What is the difference between address and address payable? Solidity can only send ether to an address payable.
00:24:13.158 - 00:25:00.614, Speaker B: Keep in mind that this is only a solidity thing, and outside of solidity, ethereum does not make any difference between address or address payable. They are just regular addresses for everybody. Is it necessary to declare an address as an address payable if you want to be able to send it an as 20 token? No, you need to use address payable only if you want to send ether to an address. Tokens are different. What are the main changes in solidity zero five compared to solidity zero four? The constructors are now declared with the constructor keyword. Before, you needed to create a function with the same name of the smart contract, the address type has been split into two subtype address and address payable. Only the second type of address can receive ether.
00:25:00.614 - 00:25:28.418, Speaker B: The VAR keyword has been removed. Events need to be emitted with the emit keyword for dynamic length type like mapping and arrays, the memory location need to be explicit. The function visibility also needs to be explicit. Give three ways to save gas. First, you can put less data on chain. You need to only put what is really really important on the smart contract, and all the rest can be put off chain. Next, you can use events instead of storage.
00:25:28.418 - 00:26:36.634, Speaker B: And finally you need to optimally order your variable declaration. How would you optimally order Un 128, byte 32 and another Un 128 to save gas? So you will declare the two Un 128 next to each other and after the byte 32 to the EVM stores available in 32 bytes a slot. However, three DT is smart enough to pack into a single slot several variables if they can fit together. So for this optimization to work, packed variables have to be defined next to each other. In the above example, the two Un 128 will be placed in the same 256 bit slot because 128 plus 128 fits into a 256 slot. How to concatenate two strings in solidity? First you need to use the ABI encode packed function and pass it the two strings that you want to concatenate. This will produce a variable of type bytes, and then all you need to do is to use the string operator to cast this byte into a string you will find some other tutorials with more complex method, but what I'm showing you here is really the most simple way to do it.
00:26:36.634 - 00:27:44.606, Speaker B: How to get the length of a string in solidity. So there are no straightforward way to do it, but what you can do is to cast your string into a bytes, and once you have your bytes variable then you can access the landfill on it. How to create a smart contract from another smart contract so first you need to import the contract to create. So either use the import keyword or in this example we actually define the two contract in the same file, and after from the smart contract from which you want to create the other smart contract, and you're going to use the new keyword followed by the name of the contract to create, and between parentheses you're going to pass parameter if you need to give argument to the constructor of the new contract. How to call the function of a smart contract from another smart contract so like before, first you need to import a smart contract to call. So either you use the import keyword or you define both contract in the same file, and after you're going to reference the contract to call, and between parentheses you're going to give the address of this contract. So that means that your smart contract needs to know the address of the contract to call.
00:27:44.606 - 00:28:25.822, Speaker B: And finally you're going to add a dot plus the name of the function to call. How to get the address of a smart contract that was created from another smart contract. So after you use the new keyword and you create the new smart contract, then you're going to cast the result with the address operator, and this will give you the address of the new smart contract. What will be the value of MSG sender if a contract calls another one? Alright, so let me describe the situation. So we have two contracts. So first we have the contract a, which is the inner contract, and then we have contract B, which is the outer contract. So inside the contract b we have a foo function that's going to create a new instance of contract A.
00:28:25.822 - 00:29:00.466, Speaker B: And after on this contract it's going to call the bar function. And if you look inside the contract a, the bar function, what we want to know is what will be the value of msg sender inside this bar function. So Msg sender will not be the address that call contract B, but instead Msg sender will be the address of contract b. How to transfer ERC 20 tokens. So in this example there are two contract. First there is the interface for ERC 20 tokens. And then I have another smart contract that I call decentralized exchange.
00:29:00.466 - 00:29:49.646, Speaker B: So this decentralized exchange smart contract has a function transfer token that allow anyone to transfer its ES 20 token to another address. Actually, if you just want to transfer token, you just need to define in the interface the transfer function and a transfer from function. I put all the other function just to show you everything, but if you don't use them, you don't need to put them in the interface. So in your transfer token function in your decentralized exchange, first you need to instantiate a pointer to your ERC 20 contract. So you do this by using the interface that you just defined, and you pass to this interface the address of your ERC 20 token. And after you can call any function on the smart contract. So the most simple function for ERC 20 token is the transfer function, and this function takes two argument.
00:29:49.646 - 00:31:00.270, Speaker B: First argument is the recipient, and second argument is the amount of token to transfer. It's also possible to do delegated transfer using the transfer from function that is used in combination with the approved function that need to be called before transfer from how to declare and emit an event first need to declare the event at the contract level using the event keyword, the name of the event, and the description of its fields. You can use standard solidity types for its fields. Then, inside a function you will emit an event using the emit keyword, the name of the event, and you will give the argument for the field of the event. If you see some solidity code version zero four, you won't see the emit keyword, it was added in three dt zero five what is the index keyword? In event definition, it means that external entities can filter only events whose field match a specific value. For example, in the below example, it means that it's possible to filter events where the two fields have a specific value. How many even fields can be marked indexed? Three maximum.
00:31:00.270 - 00:31:47.694, Speaker B: Is it possible for a smart contract to read the events emitted before? No, only external entities can queries events. Is it possible to delete or modify a past event? No. Events are immutable in solidity. How to do like a JavaScript console log for debugging unfortunately, there is no equivalent of this in solidity, but you can emit an event and inspect the transaction log using an streak. You can log some value even though events are not really designed for debugging like this. How would you implement access control without using a modifier? So for this you're going to use the required statement of solidity so the first argument of the required statement is the condition that you're going to test. So you're going to compare the MSG sender to a predefined address.
00:31:47.694 - 00:32:31.542, Speaker B: And if this is not truthy, you're going to display an error message, which is the second argument of the required statement. How would you implement access control with modifier this time? So we're going to reuse the required statement that we used in a previous question, but we're going to move it to a structure called modifier. So modifier are piece of code that you can run before function. So first you define the body of the modifier, then you define a placeholder underscore. So this represents the function to which the modifier will be attached. And then you attach the modifier to a function. So you do this in the function signature so that guarantee you that this modifier is going to be run before the function you're executing.
00:32:31.542 - 00:33:26.618, Speaker B: And if this modifier throw an error, then the function will not be executed. How to cancel a transaction once a transaction has been sent, nobody can prevent it from being mined by a miner, but you can still send another transaction that will sort of compete with the first one and prevent the first one from being executed under a certain condition. This second transaction needs to have the following properties. First, it will have the same nons as the first transaction. So the nons is an incrementing integer that is sent in each transaction and that is specific to each ethereum address. It will have a higher gas price than the first transaction and when it comes to what the transaction will actually do, it can be sending a tiny amount of ether to another address or triggering a function call with invalid argument. What really matter is that this transaction needs to do something because it's not possible to send empty transaction.
00:33:26.618 - 00:34:00.426, Speaker B: The most important is that the nons is the same and that the gas price is higher than the first transaction. So that miner will pick up on this transaction first because the higher gas price is more interesting for them. All right, so we are done with intermediate question and next we're going to enter the difficult section. So you might not be asked this question for all your solidity job interview, but some companies might ask you for this. So if you really want to be 100% ready then do follow this section. And it's also a good way to push your knowledge in solidity. What is the ABI encoder? V.
00:34:00.426 - 00:34:42.302, Speaker B: Two pragma statement this is a pragma statement that is used to enable experimental features not yet enabled in standard solidity. For example, it enables to return a struct from a function called externally, which is not possible yet in standard solidity. Is it safe to use the API encoder V two pragma statement in production? No, it should only be used in development, not in production. Is it possible to send a transaction without requiring users to pay gas? So that's what we call a gas less transaction. And yes, it's possible. So the way it work is you would ask users to first assign a message on the front end. Then the message and signature would be sent to a centralized back end.
00:34:42.302 - 00:35:26.574, Speaker B: So that will be in your application and that would be off chain. And this backend would create a transaction and embed the payload so the message plus the signature into it. That means that the gas fees will be covered by the wallet of the app instead of the user wallet on chain. A spot contract will verify the validity of the signature and perform an operation on behalf of the user. Which solidity function would you use to verify a signature you need to use EC recover what is a library in solidity? A library is a piece of code that can be reused by other smart contract. There are two types of libraries deploy and embedded. Deployed libraries have their own address and they can be used by several other smart contracts.
00:35:26.574 - 00:36:22.914, Speaker B: Embedded libraries don't have their own address and are deployed as part of the code of the smart contract that use them. Library don't have their own storage, they only provide functions for other smart contract give an example of how to use a library in a smart contract. In this example, we are going to use a library to add two integer first we define the library and after we have a smart contract with an add function that make use of this library. Then in smart contract a, we use the using keyword to attach the library to the integer types. That means that all the function of the library will be callable for each integer inside smart contract a. And we can see this in action in the add function of smart contract a. So instead of just using the plus operator to add a and b, we actually use the add function of our library and for that we use the dot notation.
00:36:22.914 - 00:37:07.646, Speaker B: So a add and we pass the b variable to the add function. So this add function is the add function of our library. And you will notice that even though the add function of the library takes two arguments, we only pass it one argument because the first argument will be a in this case, and the argument that we pass between parentheses will be the second argument. When a library is embedded versus deployed, library will be embedded if it provides internal function. Internal function can only be called by the same smart contract. Deploy libraries, on the other hand, have public functions. What is a reentrancy attack? So, a reentrancy attack happens between two smart contracts.
00:37:07.646 - 00:37:33.686, Speaker B: So let's consider this example. So we have a contract A and a contract b. The contract a holds some ether on behalf of some other addresses, and it has a pay function to restraw this ether. And the contract b is the attacker, and it has some ether in contract A. The attack is going to work this way. So contract B is going to call the pay function in contract A. So this pay function takes two argument.
00:37:33.686 - 00:38:16.966, Speaker B: An address where we want to send the ether, and an integer amount to specify how much we want to send. So first, the pay function check if the balance of the sender is enough. So the attacker will choose an amount which is less or equal to its balance, so that this if condition passes. Then the pay function is going to call the bat function on contract b and send it some ether. And finally, it's going to decrease the balance of the sender. The problem is, in the bat function of contract b, we actually call back the pay function of contract a. And when this happened, the if condition is going to pass again, because at this stage we haven't decreased the balances of the sender.
00:38:16.966 - 00:38:52.882, Speaker B: So A is going to call the bat function of contract B again and send in some ether again. And the loop is going to continue until all the ether of contract A will have been drained and sent to contract B. So that's exactly what happened in the DAO attack in 2016. How to prevent against a reentrancy attack. So there are several solution. The first solution is to decrease the balance or do other state variable update before you call another contract. The second solution is to put in place a reentrancy guard.
00:38:52.882 - 00:39:21.278, Speaker B: You can find an example of heightworks in the open zeppelin framework. And finally, you can limit the gas available to the call contract. This way. If the call contract is trying to do an attack, it doesn't have enough gas to do this. If you send ether using the transfer function, this is done automatically for you. How to produce a hash of multiple values in solidity first, you need to use the ABI encode packed function. You can give it as many argument as you want.
00:39:21.278 - 00:40:00.682, Speaker B: The arguments are the data that you want to hash. So this encode packed function will return a byte, so which is an arbitrarily sized array of bytes, so it can have any length. But the thing is, with a hash, you want to have a fixed size length. So for that you're going to use the ketchup 256 function, and it's going to produce a byte 32 how to generate a random integer in solidity. We can leverage the block timestamp and the block difficulty as a source of randomness and use the ketchack 256 hashing function. First, we need to use the encode packed function and give it the block timestamp and the block difficulty. And we will hash this with a ketchup 256 function.
00:40:00.682 - 00:40:36.594, Speaker B: And finally, we will cast the result into an integer. You need to be aware that miners can manipulate block difficulty and block timestamp, so this method is not 100% secure. And generally speaking, random number generation is a very difficult thing. In smart contract. What are the two kind of assembly in solidity? Functional and instructional? Functional uses function, whereas instructional is just a series of row of codes. Most people use the functional style how to declare assembly code. You need to use the assembly keyword and use curly braces.
00:40:36.594 - 00:40:58.926, Speaker B: Everything inside the curly braces is assembly code. Create a function to determine if another address is a contract or a regular address. All right, so for this you need assembly. So we're going to create a function called ishuman. So this is in regular solidity. This function is going to accept a single address argument. That's the address to check.
00:40:58.926 - 00:41:39.302, Speaker B: Then we define a conlength variable, which is an integer. Then we define an assembly block and we use the EVM opcode x cut size, which can basically give us the cut size of a specific address, and we store the result in the code length variable. And after outside the assembly block in the return statement, we check if this code length is zero. If there is no code associated to an address, then that means that this is not a smart contract. So this is a regular address, so we return true, otherwise we return false. So this is really a typical case of something that you can do only with assembly and not possible just with solidity. All right, that's the end of this video.
00:41:39.302 - 00:41:47.726, Speaker B: Congratulations for following up to here. And if you want to go to the next level and train yourself on how to write sodiat smart contract, you.
00:41:47.748 - 00:41:49.886, Speaker A: Can check out my huge tutorial on.
00:41:49.908 - 00:42:00.538, Speaker B: How to write five sod smart contract on YouTube. So this is for beginners, so that's really good to get started, I'll put the link in the description of this episode.
00:42:00.634 - 00:42:02.860, Speaker A: Thanks for watching and see you for my next videos.
