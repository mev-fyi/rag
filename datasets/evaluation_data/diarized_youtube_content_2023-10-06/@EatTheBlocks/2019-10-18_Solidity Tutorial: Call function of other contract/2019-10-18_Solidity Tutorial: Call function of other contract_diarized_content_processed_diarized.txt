00:00:00.250 - 00:00:42.970, Speaker A: Hey, this is julian and you are on idoblox. And in this video I'm going to show you how you can call function of other smart contracts. In solidity, smart contract interaction are necessary when you want to use a certain project and do some operation. For example, if you want to transfer an ERC 20 token, it's going to involve a smart contract interaction. So make sure to pay attention to this video. So I'm going to show you four thing first, I'm going to show you what is the syntax. If we want to call a function of another smart contract from a smart contract, then I'm going to show you how we can use the import keyword in case that the source code of the two smart contract are not in the same file, which will be the case most of the time.
00:00:42.970 - 00:01:16.760, Speaker A: Then I'm going to talk of contract interfaces, which is the minimum required information for a smart contract to interact with another one. And finally, I'm going to explain you how error propagation work when a smart contract calls another one. So let's start with the first item. Call a function of another smart contract. So we have our smart contract a, and it's going to call a function in a smart contract b. So let's start by creating the smart contract b. And we're going to create a function.
00:01:16.760 - 00:01:54.418, Speaker A: So let's call this function hello world. This is a very simple function, pure function. So it's going to return a static string, and it's going to return a string here and we specify memory. Okay, and here, let's just return hello world. Okay, cool. So we have our target contract B here, and we're going to call this hello world function from a. So in order to do this we need two things.
00:01:54.418 - 00:02:27.980, Speaker A: So first we need the interface of B. So actually since I define both my smart contract in the same file, we already have this interface. So we just need to reference b like this. And second thing, we need the address of B. And for that we need to create a variable inside A and also a function. Let me show you how it works. So first we're going to create an address, I'm going to call this address b, okay.
00:02:27.980 - 00:03:07.846, Speaker A: And then we're going to create a function to set the value of this address. So that means that we're going to first deploy b after we're going to deploy A, and finally we're going to set the address of b inside A. So here let's create the function to set the address of b inside a. We're going to call this function set address b. And as an argument it receive an address which is the address of b. So here I name my variable. My argument underscore address b because I don't want to shadow the state variable address b inside my function here.
00:03:07.846 - 00:03:48.360, Speaker A: Okay, so we make it external, so we can call it from outside smart contract. And inside we just sign the value of address b thanks to the argument. Very simple function. So once we call this function, this address b state variable will be set to the address of the contract b. So we have what we need here for the address of b. And then we're going to create another function that will actually call the hello world function. So I'm going to call this function call hello world.
00:03:48.360 - 00:04:15.166, Speaker A: Okay, this is external. And first we need to create a pointer to the b smart contract. So first we need to declare the type of the variable. So we use the name of the smart contract. Then we give it a variable name. So for example lowercase B. Then we use uppercase B again.
00:04:15.166 - 00:04:54.794, Speaker A: So this is the interface of the smart contract, and between parentheses we specify the address. And we have this address in the address b variable. Okay, so now with our b pointer we are able to call all the function inside our b smart contract. And we're going to do this b hello world. And if we had to pass any parameter, any argument, then we will do it like this. But in this case there is no argument. So we just do this and we're going to return the result of this.
00:04:54.794 - 00:05:27.074, Speaker A: Okay, and here, solidity complaints, because I did not specify correctly the call hello world function. So this is a view function that returns a string. Okay, so now solidity is happy. Okay, we have everything we need. So first step is to deploy B. So I go to the deploy and run transaction here on the left, and I select the b contract with this drop down. And I click on deploy.
00:05:27.074 - 00:05:59.486, Speaker A: Okay, then in the drop down I select A and I click on deploy. So if I scroll down here, I can see my two contracts, B and A. And now I'm going to copy the address of B by clicking here on this button. Copy value to clipboard. Okay, and then I expand the box for the contract a. And I will see my two functions, set address B and call hello world. And next to set address B, I'm going to pass the address of contract B.
00:05:59.486 - 00:06:26.546, Speaker A: And now I click on set address B. Now my contract a have the address of the contract B. So if I click on call hello world, I should see the string hello world. And here, yes, I can see hello world. So this is working great. Okay, so next let's move to the next item by using the import keyword. So in this example I have my two smart contract in the same file.
00:06:26.546 - 00:07:18.938, Speaker A: But in most cases it's not going to be like this. In most cases the other smart contract is going to be in another file. So let's move to this menu for the file explorer so that we can create a new file. So let's click here and we're going to call a new file contract B saw. Okay, so I'm going to copy my pragma statement here and I'm going to cut and past contract B. Okay, so now if we go back to my contract contract A, then we have an error because we reference a smart contract that solidity does not know. So by using the import statement we can fix this.
00:07:18.938 - 00:08:00.834, Speaker A: First we specify the import keyword, then the name of the file where you have the source code of the other smart contract. So contract B sol, and after you can see that the arrow disappear here. So we can reference the b smart contract. So now our source code is a little bit more tidy with the source code of the other smart contract in its own file. Next, let's see what is a contract interface. So actually in our call hello world function, when we reference the whole smart contract b, it's actually not required because we don't need to know the implementation of the function. We only need the function signature.
00:08:00.834 - 00:09:12.174, Speaker A: So if we go to our other file contract b, we can define an interface with just the function signature. So let's define this interface. We're going to call it interface b. Here, an uppercase I, okay? And inside I'm going to copy paste the function signature that I need and I'm going to end it with a semicolum. And in your function b, if you have other function that you want to call from another smart contract, then you also need to add them to your interface. So for example, if you have, I don't know, function foo, this is an external function, and then whatever, then we only need to copy this function signature inside our interface here and we terminate it with a semicolum. And then when we come back to mycontract sol, then instead of referencing b inside the call hello world function, we can reference interface b and the same for the variable type interface b and everything will work fine.
00:09:12.174 - 00:09:59.922, Speaker A: So actually in your interface you don't need to have all the function of the contract b, but only the function that you want to call. So in the contract b, if you have this external foo function, but you don't need it because you're not going to call it, then you can remove it from your interface and it's not going to hurt. You're still going to be able to call the hello world function. So in general, this interface here will be provided by the creator of the function that you want to use. But if this does not exist, then you can create it very easily by just copy pasting the function signature and adding a semicolon at the end. And finally, about contract interfaces. So instead of using the contract keyword, there is another keyword that show better your intention.
00:09:59.922 - 00:10:47.366, Speaker A: That's the interface keyword. However, interfaces do not allow to inerate from other interface. So for this reason, many people prefer to use the contract keyword to define their interface. But this is just a tiny detail. All right, so let's go back to our main smart contract, and the last thing I like to explain you is error propagation. So in our call hello world function here, what happened if when we call hello World on the other smart contract, if this function throw an error? So let's go inside contract B and before returning, let's say that we throw an error by using the revert function. By the way, I will explain what is a revert later in this series.
00:10:47.366 - 00:11:28.326, Speaker A: So if we do this, this is going to throw an error and what's going to happen inside the call hello world function? Well, the error, it's going to be propagated, which means in this case this just returned a value. So it's not very important. But if that was a transaction, then the whole transaction will fail. So that's very important to understand that if you call function in other smart contract, if there is any error in those smart contract, it will have consequences in the parent smart contract. All right, that's it for this video. In the next video I will show you how we can do ERC 20 token transfer in solidity. Thanks for watching.
00:11:28.326 - 00:11:29.810, Speaker A: See you for the next video. Bye.
