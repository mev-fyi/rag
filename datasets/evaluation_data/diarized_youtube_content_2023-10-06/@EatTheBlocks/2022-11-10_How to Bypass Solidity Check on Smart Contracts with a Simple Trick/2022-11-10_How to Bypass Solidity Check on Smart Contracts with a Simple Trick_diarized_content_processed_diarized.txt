00:00:00.250 - 00:00:47.178, Speaker A: Did you know that solidity has a contract size check for safety, but we can actually bypass it? Let's talk about it if you're new here. I'm Stefan and on it the blocks we help web two developers get into web3. Before we jump in, a quick mention regarding the three months web3 mentoring program. You can enroll right now and start your journey into blockchain with a mentor. Amongst other things, you'll learn how to build a portfolio of web3 projects, how to create your online presence as an expert, and how to access a network of like minded developers. Let's take a look at the documentation and more specifically we want to see the members of address types. So it describes what actions you can perform with a type address.
00:00:47.178 - 00:01:39.366, Speaker A: And if we scroll down we get a warning that basically says that when performing external calls to a contract, solidity performs an extra check using the xcode size upcode in order to verify that there is actually some code at the address and that the contract exists. Well, the problem is that there are actually few ways to bypass that size check and make a smart contract appearing like an external owner's address. I'll call it EOA for the rest of the video. Let's see how that works. So I'll be using an example from the solidity by example website. And in this example we've got three contracts. The target contract, which has a function called protected that changes the value of pone to true if the caller is an EOA and it also has a ease contract function that uses the xcode size upcode.
00:01:39.366 - 00:02:18.378, Speaker A: We've also got the failed attack contract that should fail to pass the check in the target contract since it is a contract. And finally we've got the hack contract that takes advantage of the fact that the code is actually stored on the blockchain. After that the constructor has executed. So what we do in the constructor, we'll call the target contract and we'll see that it has no problem passing the check. So let's compile that. I'll deploy target first. If I open the contract and I call it protected, no problem because message sender is my wallet address.
00:02:18.378 - 00:03:20.180, Speaker A: Okay, now let's deploy the other contract, the failed attack contract. And if I call the pone function with the target address, it reverted because message sender is a contract, it contains some code and so it reverted because the xcode size upcode came back with a code size. So we get no contract allowed. But now let's deploy the hack contract with the target address. And now if we check if the target contract thinks we are a contract or not, we get false. We have successfully bypassed the code size check, and you can basically bypass that check in all the following situations. If the hack contract is in construction, if you provide an address where a contract will be created, or if you provide an address where a contract lived but was destroyed.
00:03:20.180 - 00:03:59.056, Speaker A: In conclusion, you simply cannot solely rely on xcode size to check if an address is externally owned or a smart contract before I end this video, a quick mention again about the three months web3 mentoring program. With this program you get a weekly technical call, a weekly nontechnical call as well when you can get advice on your career, social media presence, et cetera. You also get one weekly one on one call with your mentor. You get access to the private disc code chat, as well as the lifetime access to all video courses and future updates. Register now@eattheblocks.com web3 mentoring program and that's pretty much it. Thank you for watching.
00:03:59.056 - 00:04:06.220, Speaker A: Let us know in the comment section what other topics you'd like to see, and I'll catch you in the next one. Bye.
