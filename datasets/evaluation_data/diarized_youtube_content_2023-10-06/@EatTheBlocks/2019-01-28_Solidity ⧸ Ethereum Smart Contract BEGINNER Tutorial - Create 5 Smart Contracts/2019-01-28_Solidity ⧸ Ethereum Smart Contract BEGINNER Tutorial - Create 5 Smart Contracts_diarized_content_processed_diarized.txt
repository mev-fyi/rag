00:00:00.410 - 00:00:00.622, Speaker A: Hello.
00:00:00.676 - 00:00:46.122, Speaker B: Welcome to Smart Contract 30, a huge series that I've done on solidity smart contract to teach you solidity and Ethereum by building 30 smart contract. That's the largest series that you will find on smart contract on YouTube and probably anywhere on the Internet. So I really hope that you're going to appreciate it. In this series we are going to build different smart contracts starting from very simple to progressively more and more difficult. At some point we'll do some smart contracts, like the DaO for example, and other very exciting smart contract. So at the end of the series you will feel very confident and comfortable that you can create your own smart contract. And when I say smart contract, I don't mean super simple smart contract, but.
00:00:46.176 - 00:00:48.710, Speaker A: I mean really advanced smart contract.
00:00:48.870 - 00:01:26.146, Speaker B: So that's really going to bring you a lot. It's going to go through all the different features of the solidity programming language. It's using Solidity 5.0 which is at the time of the recording, at the latest version of solidity. There are many other tutorials that teach you some older version of solidity, so you got to be careful. And on YouTube I will give you for free the first five episodes. So if you want to continue the series, then you can create a paid account on Edoblox Pro, which is ten us a month at the time of this recording.
00:01:26.178 - 00:01:27.526, Speaker A: It's going to increase in the next.
00:01:27.548 - 00:02:07.170, Speaker B: Few months, but if you don't want to pay this yet, then what you can do is you can create a free account on Idoblox Pro and you will have the benefit of having access to the source code of smart contract. So you will be able to follow the video with the video here and the smart contract just below. So it will be really easy to follow. It's free so don't hesitate to create an account. And if at any time you have any question, then you can ask it in the comments of the video. So if I have enough time I will answer you. But don't forget that if you become a pro member of Idoblox Pro, then.
00:02:07.240 - 00:02:09.314, Speaker A: You also have access to a private.
00:02:09.362 - 00:02:30.666, Speaker B: Telegram chat group where me and other students are connected all the time. And so you get really very quick help. We are going to use an online IDE which is called remix. So that's an Ide for solidity. You don't have to install anything on your computer. It's very easy. You just have to go online and you can use it directly.
00:02:30.666 - 00:02:43.754, Speaker B: So basically there is almost no setup. You can just get started like this. Don't worry, if you are not already, you don't know much about Ethereum, then we can start this series.
00:02:43.802 - 00:02:46.638, Speaker A: It's not meant for people who already have a lot of knowledge.
00:02:46.734 - 00:02:47.970, Speaker B: That's it for the intro.
00:02:48.120 - 00:03:27.030, Speaker A: Let's get started. Hey hey and welcome for the first day of smart Contract 30. In this video I will give you a brief introduction to smart contracts, solidity and remix. We will create our first smart contract and deploy it on the Ethereum blockchain. There are several Ethereum blockchain and the one we will use is just a local blockchain, not connected to the real blockchain where we have real ether. So we will not have to spend any real ether, the currency of Ethereum. Instead we will use some sort of fake ether.
00:03:27.030 - 00:04:14.098, Speaker A: We will use remix, an online IDE for solidity smart contract so there won't be any setup necessary. So first let me explain what is a smart contract? So a smart contract is a small program that can run on the Ethereum blockchain. So usually a smart contract is a couple of hundred line of code. So it's not like huge program that you can find in JavaScript or other programming language. A smart contract, once it's deployed to the Ethereum blockchain, cannot be changed, which means you can't change its code. You can change the data of a smart contract, but only the code of the smart contract can do that. Once you deploy a smart contract.
00:04:14.098 - 00:04:59.374, Speaker A: Also you don't need to do any sort of admin. The Ethereum blockchain takes care of running your smart contract. Also, contrary to program that you deploy on a centralized server, with a smart contract it actually costs money to deploy smart contract, and you pay this with ether. Finally, with a smart contract you can do financial transfer as long as the financial assets that you transfer are native to the blockchain. So you can transfer ether, for example, or ERC 20 tokens. There are a couple of languages to write smart contract, but the most popular by far is solidity. Solidity looks like JavaScript, but the similarity is only very superficial.
00:04:59.374 - 00:05:57.558, Speaker A: Actually the language is quite different and much more primitive than JavaScript. One of the main difference between solidity and JavaScript is that with solidity you need to compile the program. So with JavaScript you just write JavaScript code and you can run it right away in a browser or with node JS. With solidity you can't do this. First you need to compile solidity into what we call a bytecode, and this is this bytecode which is a series of elementary instructions that you can send to the Ethereum blockchain and that will effectively be your smart contract on the blockchain. Another big difference between solidity and JavaScript is that solidity is a type language, which means you need to specify the type of all your variables. And when you compile your smart contract into bytecode, the solidity compiler will check the type of your variable and will make sure that everything makes sense.
00:05:57.558 - 00:07:08.480, Speaker A: So for example, if you declare a variable of a certain type at a certain place, and that you try to transform this variable into another type at another place, and maybe that the compiler will complain. In this course I will progressively introduce you the different features of solidity as we make progress through the different project that we will do together. Next, I need to introduce you remix so remix is what you see now on your screen as a developer. Two tasks that you need to do very often while developing smart contract is first, deploying smart contract to the blockchain and second, interacting with your smart contract, which means calling functions of your smart contract. If you had to do this absolutely manually on your own, you would need to piece together many different tools, and as a total newbie, it can be really overwhelming. And even as a more experienced smart contract developer, it's not something that you would typically do. Instead you want to use some sort of more high level tool that help you with the whole development process.
00:07:08.480 - 00:08:13.570, Speaker A: Remix does this for us. So remix is a solidity IDE. IDE stands for integrated development environment. You might have already worked with some IDEs, such as Eclipse for example for Java development, or visual studio for C development on Windows. So IDE sounds like it's a complex piece of software, but actually in the case of Remix, don't be impressed by this because the remix IDE is much more simple than other IDes that I've just mentioned. So one of the main difference between Remix and these other IDs is that with remix it's an online ID, which means you don't have to install anything, it's available in your browser, you just need to visit this URL. So let's see, what are the different parts of this ID? So on the left side here you have the file explorer where you can do some file manipulation like creating new file, renaming your file, or deleting file.
00:08:13.570 - 00:08:54.462, Speaker A: Here in the main part of your ide, it's where you're going to actually write the solidity code of your smart contract. So probably that you're going to spend the most time here. Then on your right here you have different tab. So compile, run, et cetera. So the two most important tab are compile where you can configure some options on how you want to configure how you want to compile your smart contract. And second, you have the run tab where you can deploy and interact with your smart contract. So that's probably where you're going to spend the most time after the code editor here.
00:08:54.462 - 00:09:43.600, Speaker A: And you can also have a look to other tab if you're curious, but we're not going to see most of them at the moment. There is a tab that most people ignore, but actually that is quite interesting, especially for beginner is the support tab here at the far right hand side. So if you click on it, you can click on this button, start chatting and it will connect you with the gitter chat of the remix ide. If you have any question regarding remix, you can ask your question here and the community will answer you. Please note that this is not a chat strictly about solidity. So if you have questions about solidity, you can visit another GitHub channel which is just for solidity. This one is more like for the features of the remix ide.
00:09:43.600 - 00:10:24.406, Speaker A: So now let's start to create our simple smart contract. So we're going to create a new file. So we click here, and here we're going to type the name of our file. So we'll call it simple smart contract with camel case like this. And the extension for solidity file is Sol Sol you click on OK, and we're going to close the other file like this once. It's basically an example smart contract provided by remix, but we're not going to use it. Okay, so now we're going to start to write our first smart contract.
00:10:24.406 - 00:11:26.160, Speaker A: So the first thing that you need to write in your smart contract is an indication to tell the compiler which version of solidity is acceptable to compile this smart contract. So you start this by using the keyword pragma, then space, then solid, and then we're going to use the carrot character and then we're going to type 0510. So this means compile this smart contract only if you, the compiler, you are between the version zero point 50 to the version 0.59 or nine nine nine, et cetera. But not if you are for example 0.6.0 or 0.4 point something.
00:11:26.160 - 00:12:01.482, Speaker A: Because this figure that you see here in the middle, if it changes, it means that there are some breaking changes. So these versions are not entirely compatible. So for example, if you start to write your smart contract when the latest version of the solidity compiler is 0.5.0. Then it's going to be compiled with this version of the compiler. But in two weeks let's say that now your compiler is 0.5.2 and it sees this pragma statement. It will still compile the smart contract, but the compiler version will be slightly different.
00:12:01.482 - 00:12:38.230, Speaker A: So you need to be aware of this when you write your pragma statement. Next we're going to use the contract keyword. So the contract keyword actually defined as smart contract. So you type contract and then you're going to type the name of your smart contract. So in our case we're going to call it simple smart contract. And you notice that I used the camel case, which is a standup practice with solidity smart contract. And then I'm going to open and close curly braces to define my smart contract.
00:12:38.230 - 00:13:15.854, Speaker A: Because it's our first smart contract, we're not going to write anything in the body of the smart contract, but in the next videos where all the action will take place is between these two brackets here. So in a single solidity file you can actually have several smart contracts. So if we wanted, we could write another smart contract like this. Contract, simple smart contract two, et cetera, et cetera. But we are not going to do this. We're just going to define a single smart contract. You don't need to do anything to save the file.
00:13:15.854 - 00:13:53.946, Speaker A: Remixed is on autosave all the time. Now that we have finished to write our smart contract, the next thing to do is to deploy it on the Ethereum blockchain. But before we do this, we need to compile it to a bytecode that the Ethereum blockchain can understand. So let's go to the compile tab and let's see what we have here. So we have a button here, start to compile. So if you click on start to compile here, it will compile the smart contract and you will see here a green box appearing. It's a little bit annoying to have to click on the start to compile button every time you make a change to your smart contract.
00:13:53.946 - 00:14:42.190, Speaker A: So instead we're going to activate the autocompile feature and remix will recompile our smart contract every time we make a change. It's a much better workflow. Now that our contract is compiled, we can actually deploy it to the blockchain. So let's go to the run tab and let's see what we have here. So at the top of this tab we have this section here where we basically configure the parameter of our deployment. So I'm not going to explain in details these parameters in this video because in the next videos of this course we're going to see them in detail. But just quickly make sure that here for the environment you have a JavaScript VM selected, and then for the other parameters you can just leave them to their default value.
00:14:42.190 - 00:15:11.254, Speaker A: It should be fine. In the next panel here you define which smart contract you want to deploy. So as I told you before, in a single file you can have several smart contract. And also we have other file with other smart contracts. So remix needs to know which smart contract you want to deploy. So we just have one here, simple smart contract. So it's already selected and if we want to deploy it, we click here on the deploy red button.
00:15:11.254 - 00:16:06.290, Speaker A: So let's click on it. And just after we do this, we see something appearing here in the deploy contracts panel. So that's our simple smart contract that has been deployed. So we call this thing here a smart contract instance and we can actually deploy several instance of the same smart contract. So here if I click on deploy again, then here I have another instance and let's expand one of these instance and yeah, so we don't see anything here, but when we will have function in next videos, we will see some buttons that will appear here and that will allow us to interact with our smart contract. One thing to note here is that each smart contract instance has its own address on the blockchain. So here we can see like the address of this instance, and here we can see the address of this other instance.
00:16:06.290 - 00:16:46.850, Speaker A: So each of these smart contract can have data. And if we change the data of this smart contract instance, it's not going to have any impact on the data of this smart contract instance and vice versa. So smart contract instances are independent from each other. That's it for this video. For the next video we're going to create a hello world smart contract which will be slightly more advanced than this one. In this smart contract we will have a function and we will be able to call this function from outside the smart contract and we will learn how to do this with remix. Hey, and welcome for this new episode of the Smart Contract 30 series.
00:16:46.850 - 00:17:58.766, Speaker A: And today we are going to create a hello world smart contract. So hello World is a very common kind of tutorial when you're starting something and in general you have to echo a string and that's how a lot of tutorials introduce you to new programming language. And so we're going to do the same thing with a smart contract. The first thing we will do is to create a new file for our smart contract, and we call this hello world. And remember from the last episode that the extension for a smart contract is Sol, okay? And you might also remember that the first thing we need to do is to specify the version of solidity that we want to use, and for this we use the pragma syntax, pragma space solidity. Then we use the carrot character, and then we're going to use the version Zero 50. Then we define our smart contract with the contract keyword, and this time it's going to be called hello world with a camel case.
00:17:58.766 - 00:19:00.002, Speaker A: So uppercase for h and uppercase for w, and inside here we're going to define the actual code of our smart contract. So if you compare with a programming language like JavaScript, actually you might consider that contract is a little bit like an object in JavaScript. And like for object in JavaScript we can also have functions, and the way we define functions is with the function keyword. And in this video we are going to create our first function. So let's do it function here, and then we type the name of the function. So far it's very similar to what we do with JavaScript, and then we open the curly braces and then we type inside the code of our function and file function. We're going to do something extremely simple.
00:19:00.002 - 00:20:26.486, Speaker A: We're going to return a static string hello world just like that, and we end every statement in solidity with a semicolon. So again, very similar to what we have with JavaScript, I have activated autocompilation and it will make remix give me all the error and running messages of the solidity compiler. And as we can see we have two red cross here. So here if we hover on the Red cross then we can see the error, and here we have another error, or you can also see it here. And the first error is a syntax error, no visibility, and after it's cut off, but it's basically no visibility specifier specified. So what's a visibility specifier? So in solidity functions can be internal to the smart contract, which means for example, if I have another function here that I will call foo, then this function can be called by the function hello. And so I could say like foo for example, or I can also call hello or foo from outside the smart contract, and we will see just after how to do that in the case of hello.
00:20:26.486 - 00:21:13.530, Speaker A: Actually we want this function to be callable from outside the smart contract. And for this we need to specify the public visibility keyword. Next we have another error, and basically this error is because we haven't specified what is the written type of this function. So in solidity, unlike in JavaScript, you need to specify exactly what is the written type of a function. And for this you use the returns keyword returns with s here. So be careful, it's something that tricks a lot of beginner. Here you have to use s, but when you actually return something in the function, the return statement is without an S.
00:21:13.530 - 00:22:06.486, Speaker A: So make sure to pay attention if you have to put s or not. And here we need to specify what is the type of the variable, because as I mentioned during the last video, solidity is a type language, which means you need to specify the type of each variable. So I'm not going to give you a list of all the type in solidity because it's a little bit boring, but I'm going to introduce new type as we go through the series of smart contract 30. So the type of this string hello world is very simply string. So we have string in JavaScript and we also have string in solidity, very similar. Next we have another error of the solidity compiler. So it basically complained that I haven't specified any data location.
00:22:06.486 - 00:22:51.482, Speaker A: So data location is not something that I'm going to teach you in this video. We're going to see this in another video, but basically very quickly, in solidity variables can be saved in different data location that are more or less temporary. So in JavaScript you don't have this problem because everything is temporary. When you start your JavaScript process then all the data live in memory, and when the JavaScript process stop, then everything dies. Well in solidity it's a little bit different because you can save some variable to the blockchain. But very briefly here, actually we're not looking to save anything in the blockchain. This is just something temporary that we will return from this function.
00:22:51.482 - 00:23:39.206, Speaker A: And so we will use the keyword memori, which means this is just a temporary variable, we don't want to save it anywhere. And finally we got rid of all the arrows, but we still have a warning. So if you hover on a warning then we see it says function state mutability can be restricted to pure okay, so this is something important. So in solidity function can actually modify something on the blockchain or just written data. So in this case for the hello world smart contract, I want something extremely simple. I don't want to modify the blockchain at all. So we will use the pure keyword.
00:23:39.206 - 00:24:20.274, Speaker A: Basically say this is a readonly function. Don't do any modification on the blockchain and just return this string to me. That's it. We have finished our hello world smart contract and it's time to deploy it and interact with it. So let's go to the run tab, and in the run tab we are going to deploy our smart contract. So here in the deployment panel I already have the hello world compile bytecode that have been selected for me, so I don't need to change this. And here I'm going to click on the deploy button, so deploy.
00:24:20.274 - 00:24:54.498, Speaker A: And then I can see my deploy smart contract appearing here. So remember we call this a contract instance, and if I click deploy here several times then I have other deploy contracts. We just care about one contract instance, so we can just delete the extra contract instance. And let's expand this contract instance and this time we see a button appearing. Hello. What a coincidence. It's the same name as our function here.
00:24:54.498 - 00:25:33.360, Speaker A: Why is this button? So it's very simple. Remix will analyze your contract and will create a button for each function so you can interact with your smart contract after it's been deployed. In our case, the hello function doesn't take any argument, so we just have a button. But when we will have argument in the next videos we will see also an input field here. All right, so let's just click on hello. And what are we expecting? We're expecting very simply to see hello world. So let's see if this works.
00:25:33.360 - 00:26:15.866, Speaker A: Yeah, here we can see the return value of the function and we can see the expected string. So that's great. In this video we have built a smart contract slightly more complex than the last one we created. Well, that wasn't very difficult because the last contract we created was the most simple one you can do with nothing inside. In this smart contract at least we have a function. So we start to see that how a smart contract can be useful. And we were able to create a simple function that returned a static string and we were able to call this function from outside the smart contract and read this value.
00:26:15.866 - 00:27:01.238, Speaker A: You also learn some solidity syntax, such as the pure keyword, the public keyword, how to specify the return type, and I briefly touch on the data location of variable. But we will go over this again in future videos. I know that at this stage you probably still have a lot of questions. For example, haven't talked at all about this panel here, and this is very important, but I don't want to overwhelm you with too much information, so I'm going to distill you all this info in the next video. Don't worry, at the end you will understand everything. Let's continue our journey. Hey hey and welcome to the day three of smart contract certif.
00:27:01.238 - 00:28:05.978, Speaker A: In this video we are going to create a simple storage smart contract that is able to store, modify and read a string value. I'm going to introduce you the concept of transaction which allow to call a function and actually modify the data on the blockchain contrary to the previous videos where we just read data from the blockchain but didn't modify anything. So create a new file that we will call simple storage sol the extension for solidity smart contract. And then let's specify the version of solidity with the pragma statement. So pragma solidity and then we use the character and then zero 50 okay, so now let's actually create our smart contract with the contract keyword contract simple storage. And we open the curly braces and we are ready to actually start to code the smart contract. The first thing we will do inside is to define a variable.
00:28:05.978 - 00:28:52.762, Speaker A: So this variable will have the type string. So we just type string. Then this is a variable that will be accessible from outside. So we'll use the public keyword because variable like functions, you can specify their public visibility and then the name of the variable. So we'll just call this data and we terminate the statement by a semicolon. We haven't specified the memory location of this variable, but we don't need to because this is a variable declare outside of any function. And when you do this, it automatically give it the storage memory location, which means that it will be actually saved on the blockchain.
00:28:52.762 - 00:29:22.854, Speaker A: So this is not a temporary variable. This is something that you will be able to read in other smart contract execution in the future. When you declare a variable, it's possible to give it an initial value. So let's do it and we'll just say my data. Okay, and now let's deploy this smart contract. So we'll go to the run tab and here we're not going to change anything. So let's delete this.
00:29:22.854 - 00:30:14.966, Speaker A: It's like an old contract instance that we don't need anymore. And let's click on the deploy button. Okay, so now it's been deployed and if we expand our simple storage contract, then we see a button called data. That's curious, because if you remember the last episode I mentioned that remix will create a button for all the function of our smart contract, but we don't have any function that is called data. However, when we specify that this data has the public visibility, actually solidity will automatically create a getter function of the same name of the variable. And you can call this function like if it was a function that you created yourself. So let's just click on data to see what happened and we can see my data.
00:30:14.966 - 00:31:05.462, Speaker A: So the static string that we use to instantiate the data variable, it's not very flexible to set an initial value to the data variable and then not be able to change it later in the life of the smart contract. So we want to create a function that we can change the value of the data variable anytime we want. So let's go back to the code editor and actually I'm going to delete this initial instantiation because we don't really care about this. And so we're going to create a setter function. So we use the function keyword and we're going to call this function set. Then this function set is going to take a parameter. So we need to specify the type of this parameter because it's exactly the same logic as when you declare a variable in solidity.
00:31:05.462 - 00:31:39.250, Speaker A: You always need to specify its type. So string, then we need to specify the memory location. So that's memory because that's a temporary variable. And then we need to specify the name of this variable. So you might be tempted to just write it like this data. But if you do this, you're going to shadow the data that is declared here and you will not be able to access it inside the set function. So we can't reuse this name.
00:31:39.250 - 00:32:08.800, Speaker A: Instead we're going to prefix the data by underscore. That's something very common that you will see in solidity. Smart contract. Okay, and then we're going to specify that this function is publicly accessible. So we're going to use the public keyword and then we open the curly braces. And very simply we are going to assign underscore data to data. So let's see.
00:32:08.800 - 00:32:56.518, Speaker A: All right, so as you can see it's possible to access storage variable defined here inside function. So you just have to reuse their name and to assign, it's very simple, exactly like in JavaScript. All right, so let's see if this works. So let's go to the run tab and we're going to redeploy this smart contract. So the general workflow when you're working with a smart contract is you write a smart contract, then every time you make a change, you need to compile it and redeploy it. So if you try to interact with an old instance of the smart contract that was deployed before the last code change, then it will not work. You always have to make sure that you're communicating with the latest version of the smart contract.
00:32:56.518 - 00:33:41.786, Speaker A: So here in the deploy contract panel we can see an old instance of the smart contract and we can just delete it because we don't need it. So let's delete it and then let's redeploy the smart contract. So we click on the deploy button and we have a new instance of the smart contract with the latest code this time. So let's expand it and we can see the data getter function and also the setter function. So there is a big difference between these two function. As you can see the set button is red and here the data button is blue. So why is this, is this just remix that just likes to be fancy and show you different colors? Not really.
00:33:41.786 - 00:34:31.178, Speaker A: There is a specific reason for that. It's because the data function just read data from the blockchain, but the setter function modify data from the blockchain and will actually send what we call a transaction, which is something that I will explain just after. So just first let's do a demonstration of a transaction. So here we have an input field because the setter function accept an argument and you can also see the type of the input that you need to provide. So you need to wrap your string by double quote. So here I'm going to start with a double quote and I'm going to type, for example, some gibberish like smart contract 30 is awesome. Okay.
00:34:31.178 - 00:35:04.822, Speaker A: And then I'm going to close the double quote and I'm going to click on set. Okay, so apparently nothing happened, but actually something did happen. So now if I click on the data button, I should see the updated value for the data variable. So let's click on data, scroll down and I see smart contract 30 is awesome. Yeah, it works. Let's now explain what is a transaction. So the term transaction does not mean that there is necessarily some money transfer that happened.
00:35:04.822 - 00:35:48.798, Speaker A: It can happen, but it doesn't have to. A transaction in Ethereum means that we send a data package that can potentially modify the state of the blockchain. So let's open up the console of remix to get more information. So here I'm going to increase the size of the remix console here so we can see a little bit more clearly. And here we have the output of what happened on the blockchain. So we see for example that here we had a call, so that's when we clicked on the data button. So we just call a function of the smart contract, but we did not modify anything, so that's not a transaction.
00:35:48.798 - 00:36:20.190, Speaker A: And if we scroll up then we can see that we have another output which is transact to simple storage pending. That's a transaction. So we can expand here by clicking on the down arrow and we'll have more information about the transaction. So here first we have a status. Oh yeah. So by the way, this whole thing that you see is what we call a transaction received. So after you send a transaction to the network, that's something that you will get back.
00:36:20.190 - 00:36:58.890, Speaker A: That's a json object that's going to describe what happened to the transaction. So here we have the status and it says that the transaction has been mined. So which means it's been added by the blockchain by an entity that we call a miner. And then we have something which is called the transaction hash. So you can consider that it's like an ID for the transaction. So with this transaction hash you can go to what we call block explorer that we're going to cover in other videos. And with the block explorer, basically you can inspect what happened in a transaction.
00:36:58.890 - 00:37:34.942, Speaker A: Then we have a from field. So a transaction is sent from an address. So I haven't talked much of what is an address, but basically it identifies data on the blockchain. So anybody can create as many address as he or she wants and then each address will have some data associated to it. So where does this address come from? It comes from here. If we go to this panel here in the run tab, then we can see like here we have this label, it's called account. So account and address, they are synonymous.
00:37:34.942 - 00:38:18.162, Speaker A: So don't be confused. If sometime I say account and some other time I say address is the same thing. So our transaction was sent from this address here that was created for us by remix. Then we have the two field. So you send a transaction to an address and in our case the address that we sent it to was the address of our smart contract. So if you see the beginning of this address, zero x five e seven, then you can see that it matches with the address of our deploy smart contract here, et cetera. Then we have a gas filled, a transaction cost, execution cost.
00:38:18.162 - 00:38:49.038, Speaker A: So I'm not going to cover what is gas. We're going to see this in a future video, but it's basically some sort of cost that you need to pay to the blockchain for executing your transaction. What is important to remember is that a transaction costs money. It's not free. Whereas when you just do a call, when you just read data from the blockchain, it's totally free. So I hope that now you understand that a transaction and a call are two different things. That's it for this video.
00:38:49.038 - 00:39:43.114, Speaker A: In the next video, I'm going to explain you how to specify in solidity whether a function has to be called as a transaction or just as a call. In the last video we saw how to create a transaction with solidity and remix. However, in the video before the last one, we created a function that was a call, not a transaction. So in solidity, how can we make the difference between a function that will be executed as a call versus a function that will be executed as a transaction? We're going to see this in this video. By the way, this is the code of the smart contract of the last video. So if you don't have it, you can go to the public GitHub of itoblocks and grab it. So let's create another function that will be a getter for our data variable.
00:39:43.114 - 00:40:16.874, Speaker A: So let's create a new function called get. And this function doesn't take any argument. This function will use the keyword view. So view is a little bit similar to pure that we saw during the first video of this course. So with pure you can read a static value that you hard code in a function. But if you want to actually read the storage of the smart contract, then you need to use the view keyword. So that's what we are going to do.
00:40:16.874 - 00:40:53.800, Speaker A: And then we need to specify that this is a public function. And finally we need to specify the return type of this function. So we use the returns keyword with S. Remember, it's a little bit different than the return statement inside the body of the function. And then we specify the type of the return variable. So that's a string and the memory location, it's memory because that's a temporary variable. Okay, and then we open the curly braces and very simply we just return data.
00:40:53.800 - 00:41:28.334, Speaker A: Okay, so let's check that everything works well. So we go to the run tab and we're going to delete the contract instance that we created before. So let's delete it here and let's redeploy our smart contract. Click on deploy. Let's expand the contract instance and let's set the data variable to some dummy value. Hello. For example, and don't forget to wrap it between double brackets, between double quotes because otherwise it will not work.
00:41:28.334 - 00:41:58.282, Speaker A: And you click on set. And so let's expand the remix console to see the output of the blockchain. Okay, so here we can see a message, I say transact to simple storage. So here we created a transaction because we modified the data of the blockchain. And now if we execute the getter function, let's click on get. So what do we get? We get hello. And in the remix console then we can see that this time it was a call.
00:41:58.282 - 00:42:54.906, Speaker A: So function is executed as a transaction and get is executed as a call. And the reason why is because in a get function we have the view keyword which indicate that it's a riddenly function. But in the set function we don't have any keyword that indicates that it's a riddenly function. So in absence of indication then solidity will consider that this function needs to be executed inside a transaction. And before we finish this video, I also wanted to add an explanation in this video about what is this environment drop down that we have here in the run tab of remix. So if you click on this drop down, you'll get different options, a JavaScript VM injected web three or web three provider. And basically this drop down allow you to choose which blockchain you want to deploy your smart contract to.
00:42:54.906 - 00:43:44.070, Speaker A: So when we talk of the Ethereum blockchain, actually there are different network. There is what we call the main net, which is the real ethereum network, with ether the currency native to Ethereum. So when you deploy a smart contract on this network, basically you are dealing with real money. So it's the equivalent of production as you would have with web application. However, when you are developing a smart contract, of course you don't want to deploy to production, you want to deploy to a development environment. And so the equivalent of a development environment for Ethereum blockchain is a local ethereum blockchain called Ganache. So Ganache is something that is really abstracted by you, by remix.
00:43:44.070 - 00:44:29.594, Speaker A: So you don't have to deal with this. But basically if you want to choose this development environment, you need to tick JavaScript VM and behind the hood remix will run this local Ethereum blockchain and you will not have anything to do. All the ether that is in this local Ethereum blockchain is totally virtual. So it's fine if you lose any ether, you can just reload, remix and new ether will be created. You also have to know that this local Ethereum blockchain is not connected at all with other computers. It's only local to your computer and you are totally isolated from the outside environment. Also, this local Ethereum blockchain automatically create ten different accounts that you can see here.
00:44:29.594 - 00:45:09.080, Speaker A: And basically each of these accounts are prefunded with 100 fake ether. So this allow you to transfer this fake ether to deploy smart contract without having to mine any ether. So that's very convenient if you want to develop smart contract. As for the gas limit and the value field, we'll see this in other videos. In the next video we will continue this smart contract and make it a little bit more sophisticated with arrays. Hey, hey. In this video we will continue the storage smart contract that we've been developing for the past two videos.
00:45:09.080 - 00:45:54.550, Speaker A: So far we've been storing a single string variable in our storage smart contract. But it's not very realistic because in general we want to store list of data and not just a single string. Fortunately solidity has arrays and they are quite similar to what we have in JavaScript. In this video we're going to change our storage smart contract so that it store an array instead of just a string. We will also create different function to manipulate this array. There will be one function to add element to this array, another function to read individual elements from this array, another function to read all the elements of the array, and finally a function to return the length of the array. Let's get started.
00:45:54.550 - 00:46:36.446, Speaker A: So let's create a new file. We'll call this advanced storage sol. And then we need to define our pragma statement, pragma soli dt and then carrot zero 50 as usual. Then we define our smart contract. Contract advance storage. Okay, next we are going to define our array. So so far we've been using string types, but it's not the only variable type that is available to solidity.
00:46:36.446 - 00:47:15.120, Speaker A: We can also represent integers with a uint type. And the way we specify an array of another type is with the square bracket like this. So this means this variable will be an array of integer. Then we specify the visibility of the variable public and then we're going to call these IDs. So it's going to be an array that represent IDs. Next let's define a function to add new element to this array. So we'll use the function keyword and we will call this function add.
00:47:15.120 - 00:48:11.114, Speaker A: And this function is going to take an integer argument. So it's going to be uint and we'll call this argument Id. Then this function will have a public visibility and we don't specify the view of pure keyword because we want this function to be executed in a transaction because we will actually modify the storage of the blockchain. Next, we define the body of the function, and here we will reference our array with IDs. And then in order to append a new element at the end of the array we can use the push method available on the array type, and we terminate the statement by a semicolum. So as you can see, it's exactly the same as in JavaScript. Easy.
00:48:11.114 - 00:49:22.358, Speaker A: Next, let's add another function to get a single element from this array. So we will call this function get, and then it will take an argument which is the index of the ID in the array. So this index will also be an ID, and we will call this position and then we will specify the view keyword because it's a readonly function. Then it's a public function and we specify the return type, so returns a integer and then we open the curly braces and inside the function, very simply we just return IDs. And to access a specific element of an array in solidity you need to use the bracket syntax, and inside the bracket we specify the position and we terminate with a semicolon. Next, let's define a function to return the entire array instead of just a specific element. So we'll call this function get all.
00:49:22.358 - 00:50:17.526, Speaker A: It will not take any argument. We'll reuse the view keyword because it's also a read only function and then it will have a public visibility. And for its return types this time it will not be just a single integer, but it will be an array of integer, and we also have to specify the memory location. So you might be wondering why in this function we had to specify the memory location, but in the function just before we didn't need to. It's because for simple type like integer, it's okay not to specify the memory location, but for complex type like array you have to specify the memory location. Then we open the curly braces and we define the body of our function, and we very simply return the entire arrays just like that. And the last function we will define will tell us what is the size of the array.
00:50:17.526 - 00:51:11.100, Speaker A: So we will call this function length, and it will not take any argument. It will be a view function public and it will return an integer. And in order to get the length of the IDs array exactly like in JavaScript, there is a length property for the array type, and then we terminate with a semicolon. Let's now test that everything is working so I go to the run tab and I clean up the deploy contract panel because it's like all contract instance that I don't need anymore. And then I make sure that we have the advanced storage contract selected here in the drop down. And then let's click on deploy. Okay, and let's expand this.
00:51:11.100 - 00:51:33.940, Speaker A: And first we need to populate our array. So here for the first position let's add ten. And in this case you will notice that I'm not wrapping this with double quotes because this is an integer not a string. So double quotes are not necessary. So I click on add. Okay, and let's add another element. 20.
00:51:33.940 - 00:51:50.646, Speaker A: Okay, so now let's try that. At the first position I see ten. So I click on get and I see ten. Yes, correct. Now let's try that at the second position of the array. I get 20. Yes, I get 20.
00:51:50.646 - 00:52:22.462, Speaker A: Also, I forgot to mention just before, but as you've just noticed now the arrays are indexed starting from zero exactly like in JavaScript. So just a very standard notation here. And then we need to test that the get all function is working properly. So we are expecting an array of ten and 20. Let's see what we have. Yes, we have an array of ten and 20. And finally, how about the length function? It should return two.
00:52:22.462 - 00:52:56.742, Speaker A: Let's click on length and yes, we have two. Everything is working in this contract. Before we finish this video, I would like to give you a short explanation on what is gas. Here in this panel, I've already explained what is the environment field and what is the account field, but I haven't explained the two following field. So I'll start by explaining the gas limit in this video. When you send a transaction to the Ethereum network, you have to pay gas. Gas is an abstract unit that measure the computational difficulty of executing the transaction.
00:52:56.742 - 00:53:55.150, Speaker A: If a transaction does a lot of computation, the gas cost will be higher, and if a transaction does less computation, the gas cost will be less. When you send a transaction, you specify what is the maximum amount of gas that you are willing to spend to execute this transaction. By default, remix puts a very large value here, which is 3 million, but we don't need this high of a value. If you go to the remix console and you analyze the log of the transaction to add a new element to the array, then you can see what is the actual gas cost of this transaction. So let's scroll up until we find the log for the transaction that we executed to create a new element at the end of the array. And let's expand this to see the transaction received. And we'll scroll down and we're going to see a field which says transaction cost.
00:53:55.150 - 00:54:40.138, Speaker A: So it means that we've actually consumed 47,006 gas to execute this transaction. Okay, so let's try to re add an element at the end of the array, but this time with just the exact number of gas that we need and see if we still work. So here we're going to add, this time we'll add 30. So let's click on add and then let's scroll down in the console to see if the transaction executed. And yes, like we have a green check here. So everything worked well. Okay, and now we are going to do the same transaction, but this time with not enough gas.
00:54:40.138 - 00:55:04.530, Speaker A: So here, instead of six, we'll specify five. So that's one unit of gas less than what we need. And this time let's try again to add an element at the end of the array. We click on add and then we get another message in the log here. And this time it's different. We have an error message. Error VM, error out of gas.
00:55:04.530 - 00:55:50.226, Speaker A: So when you see this error message, it means that your transaction didn't have enough gas. And when this happened, the ethereum virtual machine decide to cancel the transaction and any state change are canceled. However, when this happened, all the gas that you send to the transaction is actually consumed. In other words, it's wasted. So you need to be careful about this gas limit parameter, because if you don't adjust it well, then you will just waste money basically. So then the question is, how do you know what is the proper value for the gas limit? Well, when you're developing, you can set a very high value and then by analyzing the transaction receipt, you will know exactly how much gas your transaction consume. And then you just have to set the gas limit to this value.
00:55:50.226 - 00:56:26.250, Speaker A: I'm sure you still have a lot of question about this mysterious gas unit. I will give more details about gas in the rest of this course, but for the moment we'll just stick to this explanation. In this video, we're going to create a crude smart contract. Crude means create, read, update and delete. Crude applications are very common on the web and in smart contract we also often need to do these four operations. Beside this, I will also introduce you struct, which is a solidity syntax to represent custom types. So let's create a new file for smart contract.
00:56:26.250 - 00:57:08.822, Speaker A: We'll call this file crude Sol, and then we'll write our pragma statement, pragma Solid. And then carrot character zero 50 and then we use the contract keyword. Then the name of the smart contract is crude with an uppercase C. Then we open the curly braces and finally we can start to code our smart contract. So the first thing we are going to do is to create our struct. So as I mentioned, struct allow to create custom types. So you already have some native type to solidity like string or integer, but sometime you also have to have a custom representation of your data.
00:57:08.822 - 00:57:50.940, Speaker A: So let's see how it works. So first we use the struct keyword. Then we use the name of the struct and usually we name struct with an uppercase. So we'll do user with an uppercase u and then we open curly braces. And then inside this struct we're going to specify the field of this struct. So first we will have an id and this id will be an integer, so uint id and then I terminate the statement with the semicolon and then there will be another field which will be a string. So we specify a string and we call it name.
00:57:50.940 - 00:58:27.400, Speaker A: All right, we have our user struct as a comparison with JavaScript. It's very similar to an object that has no method but only data. Also keep in mind that this is just a type declaration. It doesn't actually create any instance of the struct. Next we will create an array of this user struct. So for this we can reuse the type definition that we've just created. So here we type user and then to specify that it's an array of user we use a square bracket and then we're going to specify the visibility of this so it's public.
00:58:27.400 - 00:59:06.030, Speaker A: And finally the name of this array and it's going to be users with a lowercase u and a semicolon. As we will create new user we will increment the id field. We need to keep track of what is the next id to create the next user. So for this we create an integer variable that is public and that is called next id. Next let's create a function to create a new user. So we'll define a function called create. And this function is going to take one argument which will be the name of the new user.
00:59:06.030 - 00:59:59.086, Speaker A: So it's going to be a string and then we specify the memory location and then the name of this argument. And then it's going to be a public function because we can call it from outside the smart contract. And then we open the curly braces okay, so in order to create a new instance of a struct, you can use this syntax. So the type of the struct, and then you open parentheses and then you pass the parameter in the same order as they are defined in the struct type. So first we need the id. And how do we do for the id, because this is not an argument of the create function. Well, just above we've defined a next id variable that hold the value for the next user to be created.
00:59:59.086 - 01:00:30.486, Speaker A: So at the beginning it will be initialized to zero. So next id, and then we use a comma to specify the next value. And the next value will be the name that was sent to the create function. And then we terminate this by a semicolon. All right, but if we do this, it's not going to store the instance anywhere. So we want to put the instance in the user's array that we defined just above. So let's do this.
01:00:30.486 - 01:01:10.940, Speaker A: So we reference the user's array and then as you remember from the previous video array, have a function called push to append a new element at the end. And in this push function we're going to pass this user instance that we just created. And is it okay if we just finish the function like this? No, because the next time that we're going to call this function, the next id will be exactly the same, but it will be a different user. So we will override the same user. It's not good. So we want to increment next id for the next time we call the create function. So nextid plus plus like this.
01:01:10.940 - 01:01:58.582, Speaker A: By the way, there is another way to instantiate a new struct, which is by using this notation with curly bracket. And in this notation, basically you define the key and then the value like this, so name. And if you do this, actually you can specify the key and the value in any order. Contrary to if you just use the parentheses and the parameters have to be in the right order. Personally I like this simple syntax for struct that are not too big. But if your structs start to have too many fields, then you might want to use the other notation that I've just showed you. Next, we're going to create a function to read a specific instance of user.
01:01:58.582 - 01:02:58.586, Speaker A: So we call this function read. And as an argument it's going to take the id of the user to read. So this is a uint and we call this id, and then this is a view function because this is read only, this is not a transaction. Then this is a public function. And finally, in the function signature we need to specify the return type. So first it's going to return the id of the user, which is return, and second, it's going to return the name of the user, and the name is a string, and string is a complex type, so we need to specify the memory location like this, and we open the curly braces. In your previous video, when we return something from a readonly function we only return a single value, but in this function we return two value.
01:02:58.586 - 01:04:00.160, Speaker A: It's because in solidity, contrary to JavaScript, a function can return several value. You just have to use a comma to add new value to be returned. So how are we going to find the correct user instance? We're going to loop through the user's array and for each pass we're going to test if the current instance has the correct Id. So first, how can we iterate through the user array? So in solidity, like in JavaScript, we have the four syntax, so it's exactly like in JavaScript. So first you define the value that will be iterated. So in our case we define an integer that will be initialized to zero, and then you define the stopping condition. So in our case when I reaches the length of the array then we need to stop so users length and finally we need to increment I for each pass.
01:04:00.160 - 01:05:22.234, Speaker A: For each pass we need to test if this is the correct user. So in solidity, like in JavaScript, we have if statements, so let's make use of this. So if users, and then we access the user instance with the bracket notation and we pass it the I integer. And then we're going to have a user instance and to access the field of a struct instance we use the dot notation so dot id, and then we're going to compare this to the id that we got as a parameter of this function, and for this we use the double equal and then if that's the case then we will have to return this struct instance. So we use the return keyword and so we access the struct again so user I, and the first value that we have to return is the id, so ID and second, we need to access the name, so dot name, and then we terminate the statement by semicolum. All right, let's take a pause here and we'll continue in the next video. So let's continue the crude smart contract that we started in the last video.
01:05:22.234 - 01:05:49.422, Speaker A: So in this video we're going to add the update and delete function for the smart contract. So let's first start with update. So here let's create this function. So update is going to take two parameter, the first parameter of update will be the ID of the user to update. So it's going to be an integer. And then we need to pass the value that we want to update. Here it's going to be string.
01:05:49.422 - 01:06:30.378, Speaker A: And then as you remember, for string you need to specify the memory type. So here we type memory. Finally you type the name of the argument and then it's a public function, it doesn't return anything. And you open the curly braces. And inside we're going to have a similar logic as in read, where we loop through the user array. And when we find the correct user instance, then we update it. So let's copy paste what we have above and we're going to change what happened when we find the correct struct instance.
01:06:30.378 - 01:07:05.290, Speaker A: So what we're going to do is to access the name field and we're going to assign it to the name parameter that we received in the function. And that's how you update a struct in solidity. Oops, I did a mistake here. It's not ID, it's I. And finally we need to create the delete function. So let's do this function delete, and it's going to receive an ID as a parameter. So that's the id of the user to delete.
01:07:05.290 - 01:07:42.630, Speaker A: And here that's a public function. And in solidity, if you want to delete an entry of an array, you can use the delete keyword. And here users, and we reference the correct struct with the id we receive as a parameter. I can see that solidity is not happy with what I wrote. What's the problem? Oh, I get it. It's because I use the delete special keyword to call my function, but it's not allowed because this is a reserve keyword. So instead let's call it destroy.
01:07:42.630 - 01:08:15.170, Speaker A: Yeah, and now solidity is happy. Okay, so now we have finished to write the smart contract. So let's make sure that it actually works. So let's go to the run tab and let's deploy our smart contract. And then we open the contract instance. And then let's create couple of users. So first we'll have Joe and then we will have Dan, and then we'll have Jenny.
01:08:15.170 - 01:08:46.438, Speaker A: Okay, and now let's try to read these users. So if we go to the read function input here, let's try to read the first user and we see Joe. Yeah. Okay, let's try to read the second user we see Dan. Yeah, and now Jenny. Yeah, very good. Okay, so now let's try to update one of our user.
01:08:46.438 - 01:09:14.840, Speaker A: So to update one of our user we need to input the id and then a comma and then the name that we want to update to. So we want to update Joe. So that's going to be the first user. And then the new name of Joe will be Alice. Okay, so update. And now if I read the slot of Joe, what do I have? I have Alice. Okay, it's working.
01:09:14.840 - 01:09:53.182, Speaker A: And now the last function we need to test is destroy. So let's try to destroy Jenny. So Jenny is Id two. Okay, so destroy. And now if we read Jenny, what happened? Okay, so we see an empty string. So it's been destroyed. So in case you wonder why we still see an empty string and not nothing at all, it's because in a read function we first try to access the element of an array, but this element does not exist.
01:09:53.182 - 01:10:32.014, Speaker A: And then we try to access a field of this nonexistent existing struct. So solidity will initialize the field of any nonexisting struct to the default value of its type. And for string it's the empty string. Let's take a quick pause here and we'll continue. In the next video, let's continue our crude smart contract. In the last video we finished to implement all the functionality, but if we have a closer look at our smart contract we will realize that we have some code duplication. So in this video we will do some refactoring to make our code a little bit better.
01:10:32.014 - 01:11:25.550, Speaker A: Here in the read function we are looping through the user array until we find the correct entry. And in the update function we do the exact same thing. So this can be extracted to its own function. So below the destroy function let's create another function which we will call find, and we will pass an id to this function and this function will return the position of the user struct in the user's array. This is a view function that because it does not modify the blockchain and then we'll need to specify the visibility of the function. So contrary to other function, this is not a public function because we don't want to be able to call it from outside smart contract, but this is a function that will just be called from inside the smart contract. And the way we specify this in solidity is with the internal keyword.
01:11:25.550 - 01:12:03.610, Speaker A: And finally we need to specify the return type. So we are going to return an integer that will be the position of the user struct in the array. Then we open the curly braces and we're going to copy paste the logic to find the correct structure. If we find the correct struct, then we're just going to return the position like this. All right, let's make use of this function. So let's go to read. And here we don't need this anymore.
01:12:03.610 - 01:12:43.000, Speaker A: Instead, let's define the position of the user struct in the array. And then we're going to call our find function. So in solidity a function can call another and you just need to specify the name of the function. Very easy. And then we pass the id that we need to find. And then we can keep the written statement because here and here we reference the corresponds thanks to the I that we got from the find function. And then we access the id and name field.
01:12:43.000 - 01:13:36.158, Speaker A: So all this correct and we can get rid of this. And let's also refactor the update function with the same logic. So let's call find from the update function and let's get rid of the loop. And all we have to do is just to update the correct struct and to reference it we use the I variable again. And before we wrap up this video, we also need to make a change to destroy. So in the past video, in the destroy function, I simplified everything by basically indexing the user struct directly using the id value. But the problem is like the id value is something that belonged to the user struct and it doesn't need to be equal to the position of the user struct in the user's array.
01:13:36.158 - 01:14:30.430, Speaker A: So let's change our destroy function and we'll use the same exact logic as in read and update. So first we find the position of user in the array and then we delete the correct user like this. All right, so in this video we made our code a little bit better by extracting common functionality into same function. However, in solidity there is also another variable to take into consideration. It's gas cost. So sometime when you refactor code like this in solidity, it can end up with a transaction that will require more gas. So as an exercise, try to compare the gas consumption of the read, update and destroy function after the refactor and compare it with before the refactor.
01:14:30.430 - 01:15:17.324, Speaker A: And in production code you always want to take the solution that give you the least conception of gas, not necessarily the one that give you the most streamlike code, which is very counterintuitive. When you come from a traditional programming background, our smart contract is almost finished, but we still have a couple of problems and we're going to fix this in the next video. In this video we are going to finish the crude smart contract. Our crude smart contract has a little problem. If we try to read, update or destroy a user that does not exist, the smart contract will not complain. However, we should have a feedback that tell us that there is a problem and that this user does not exist. For this we're going to use a built in function of solidity which is called revert.
01:15:17.324 - 01:16:02.380, Speaker A: And since in all our read, update and destroy function we make use of the find function, then we're going to go to this function to use this revert keyword. It's going to work like this. First we'll try to find the user with this Id, and if we find it, the function will return here. But if we don't find it, the execution will continue and we'll be able to call our revert function here. So when we call revert. So in solidity, when you call the revert function, it's a little bit like when you throw an error in JavaScript, the execution of the program stop and you'll see a message that tell you that something went wrong. Also, if we were in a transaction, any state change to the blockchain is canceled.
01:16:02.380 - 01:16:41.416, Speaker A: And finally all the gas that would use up to the revert gold will be consumed. When you call the revert function, you can pass a string argument to indicate what is the reason for the error. So let's specify that it's because the user does not exist. And when we trigger this function we should see this error message somewhere. So let's go to the run tab and we're going to deploy the smart contract and make sure that it works as intended. I have a problem with my smart contract here because I'm missing a semicolon. Okay, it's fixed.
01:16:41.416 - 01:17:31.960, Speaker A: So back to the run tab and let's deploy our smart contract and let's expand the contract instance and let's create a couple of users. So Joe Dan okay, so we have two users. So if we try to read the first one then we able to read it. If we try to read the second one then we also able to read it. And how about if we try to read a user that does not exist and here in the remix console then we can see that there was a problem. Vm error revert the transaction has been reverted to the initial state reason provided by the contract user. Does not exist.
01:17:31.960 - 01:18:12.868, Speaker A: Great, it works as expected. We still have a last problem to fix with our smart contract. So to demonstrate what's the problem, I'm going to delete the first user. So here I click on destroy. Okay, so I've destroyed the first user and now if I try to read the first user, what do we see? We don't see any error in the remix console. And here we see an empty string. We were expecting the revert statement here to be triggered, but it wasn't the case.
01:18:12.868 - 01:19:13.580, Speaker A: So what happened here? So in solidity when you try to access a struct that does not exist, you can still read its field and its field will be initialized to the default value of each type. So here in the find function when we try to retrieve the user with the id of zero, and here when we iterate through the user array. So first we try to find the first user and it doesn't exist. And then we try to read its ID and we're still able to read its ID because it's going to be initialized to zero. And so when we compare this with the id that we pass as argument that it matches and this function return the first user that does not exist. And then this nonexisting user here has an empty string. And so that's what we see here.
01:19:13.580 - 01:19:50.490, Speaker A: So obviously that's not correct. So we want to avoid the situation here where basically this comparison is true. C and to avoid this then let's scroll up and we just need to make a tiny change. So here we have our variable nextid which will be used every time we want to create a new user. And so we want to avoid having a user with an ID of zero. So here we can initialize our next ID to one. And so we will never have any user with an ID of zero.
01:19:50.490 - 01:20:22.500, Speaker A: So let's delete the old smart contract and let's redeploy the smart contract. We're going to make sure that everything works fine. So we recreate some users, Joe and Dan. Now let's try to read our first user. So this time the id is one, it's not zero. So yes, we can read Joe and we can also read Dan. Okay, and so now let's delete Dan.
01:20:22.500 - 01:20:55.244, Speaker A: So user id of one. And now what happened if we try to read Dan and this time we have an error here in the remix console which is the reason user does not exist. So it works. We have fixed our problem. So you can be proud of what you've learned so far and you start to reach a level where you know quite a few syntax and types of solidity. You can do all the basic operation around data, create, read, update, and delete. That's very good.
01:20:55.244 - 01:21:28.070, Speaker A: Congratulations for reaching this stage. That's the end of the first part of Smart Contract 30. If you want to continue with the 25 remaining videos of smart contract 30 and really push your knowledge to the next level, then go to the website of it, the blocks pro, and take the monthly subscription. So all Access subscription here and for $10 a month, then you'll get access you all the videos of IDoblox Pro. If you have any question, please ask me in the comments. Thanks for watching and see you in my other videos.
