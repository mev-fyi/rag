00:00:00.330 - 00:00:35.042, Speaker A: Okay, welcome back. Today, you and I are going to look at reentrancy attacks. Now, although reentrancy seems to be well known and kind of old, it seems to be one of the most common attacks over the last few years. If you're new here, I'm Calvin and on eat the blocks we help web two developers transition into Web 3. April of 2020, 25 million was taken from uniswap and lend F using reentrancy. May 2021 7.2 million in tokens was lost by burger swap via a reentrancy exploit.
00:00:35.042 - 00:01:08.702, Speaker A: August 2021 Cream finance lost 18.8 million due to similar exploits. And not forgetting one of the most famous, the Dow hack that caused a loss of $60 million. Now, reentry C can happen when a contract's function makes an external call to an untrusted contract. The untrusted contract repeatedly calls the original function before it's finished executing in order to drain the funds. Let's have a look at a simple example. We'll have one contract under attack called bank, and then we'll have the attacker contract called thief.
00:01:08.702 - 00:01:39.546, Speaker A: The bank tracks how much each address has deposited using a mapping. It has a deposit function which increases the amount that each address has. And then we have the withdraw function, which requires the address in question to have more than a balance of zero. Then it sends the money and sets the balance to zero. If you're a seasoned professional, you may already see the problem here. Looking at the thief contract, we have one function called attack, and then we have a fallback function. This is used when money is sent without a specific function being called.
00:01:39.546 - 00:02:10.358, Speaker A: When the thief calls attack, it deposits one ETH to the bank to increase its balance to one. It then calls withdraw immediately after the bank checks. If the caller has a balance of more than zero, which is true, and then it makes an external call to send the caller back their one ETH. And this is where the reenterancy starts. While the bank is sending the money, the fallback function of the thief checks to see if the bank still has some cash. If it does, it calls the withdrawal function again. The bank then checks the thief's balance, and it's still greater than zero.
00:02:10.358 - 00:02:51.182, Speaker A: So obviously they send out the one ETH. This happens again and again until the funds are drained. The bank's withdrawal function doesn't hit the final line of code to update the balance to zero while it's being called recursively. The thief contract just continually receives one ETH until the bank is completely out of funds. Now, a recommended way of writing functions is to first make all of your checks, then make the changes, update balances, or change the state, and then finally make calls to other contracts. With that in mind, we can simply change the code of the bank to update the balance first, and then send the money. If the thief tries to call again, their balance is already set to zero and the bank doesn't get wrecked.
00:02:51.182 - 00:03:21.894, Speaker A: Another technique is to use booleans to hypothetically lock functions until they're finished. We can set a state variable called locked and then write a modifier that turns it on and off. When a function using this modifier is called, the boolean is switched to true, I. E. Locked, and only after all of the code in the function has been executed does the boolean switch to off or false. This means if the fallback function from the thief calls again recursively, it's going to fail. You can also use things like open Zeppelin's pre made re entrancy guard.
00:03:21.894 - 00:03:38.540, Speaker A: You can download it, add that to your contract for extra safety, and it's always best to have an expert audit your work if you plan to handle lots of people's hard earned cash. That's all for this video. Make sure you keep up to date with new hacks and attacks and don't get wrecked. Thank you for watching and I'll speak to you soon.
