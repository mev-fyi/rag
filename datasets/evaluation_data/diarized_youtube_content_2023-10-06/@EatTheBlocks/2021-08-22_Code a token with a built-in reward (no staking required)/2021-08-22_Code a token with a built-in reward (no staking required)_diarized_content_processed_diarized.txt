00:00:00.330 - 00:00:40.150, Speaker A: In this video we are going to code a very special token. This token automatically gives reward to its holders without requiring to stake the tokens anywhere. And that's great to make your token very attractive for investors. If you don't know me, I'm Julian and on ether blocks I teach blockchain development. To create our token we will use three is smart contract provided by the yield protocol. The yield protocol is a d five protocol to borrow or lend token against a fixed rate. So I'm not going to detail how the yield protocol works, but we are only interested in one of their library.
00:00:40.150 - 00:01:06.786, Speaker A: So the GitHub organization is yield protocol and the repo that we're interested in is yield utils v two. And the contract we want is in contracts token yes, 20 rewards. All right, so let's scroll down. So here we have a couple of import but these are low level stuff so we can skip them. And here this is a definition of our smart contract. And here our smart contract start. Here we scroll down.
00:01:06.786 - 00:01:32.518, Speaker A: And so this truck here are important. So here in this truck we are going to store the period of the reward program. So this is a standard EF 20, but on top of it you can define a reward period. And during this reward anybody who is a holders will receive some reward. And start and end are two timestamps. Then in another struct we store all the details about the reward program. So first how much reward token.
00:01:32.518 - 00:02:08.142, Speaker A: So here accumulated, this is how much reward token you would have accumulated if you had a balance of one token since the beginning of the reward program. Then the last time we updated this struct. And here what's the reward per second per token. And after we have a struct to store some info about the rewards specific to each user. And this will allow to know exactly how much reward we need to send to the user. So here we just define this struct, but below we instantiate them and we also instantiate a mapping here. So for each holder it's going to map to a user reward.
00:02:08.142 - 00:02:51.234, Speaker A: And after we have the constructors, so we have some standard field for as 20 name symbol, number of decimals and we also pass the address of the rewards token. So this is supposed to be another token. Okay, so let's scroll down after we have the set rewards function. So that's going to be access controls. So an admin is going to call this function to set a new reward program with a different parameter, start date, end date. So this is a timestamps in second and rate how many reward you distribute per second for one token. So after we have a few sanity check and we store the details of the reward program after, let's scroll down.
00:02:51.234 - 00:03:06.134, Speaker A: So let's skip this. We're going to come back to it after. So here we have function if you want to mint. If you don't want your token to be mintable, you can just comment start. Then another function for burning. So that's the same thing. You can comment start.
00:03:06.134 - 00:03:35.438, Speaker A: Then you have a transfer function to transfer token from an address to another one. And finally claim function. We'll see this one at the end. That's to claim your reward. So here, what's interesting is that in the mint burn and transfer function, every time we call the same function, update rewards per token, update user reward. Okay, so first let's check out update rewards per token. So this is going to update this truck, rewards per token.
00:03:35.438 - 00:04:11.754, Speaker A: And this truck has an accumulator that tells us how much reward token have accumulated since the beginning of the reward program. So here we copy in memory the two stroke rewards per token and reward period. If the reward program hasn't started yet, we just skip this function. Here we find the earliest time between the current timestamp and the end of the reward program. Because maybe we're after the end of the reward program. Here we calculate the time elapsed since the last time that we updated the accumulator. And of course if this is zero, then we can skip.
00:04:11.754 - 00:04:53.942, Speaker A: And below that's where we are going to update the accumulator. So here we multiply the unaccounted time by the rate and after we update the rewards per token struct. And with this we are ready to calculate the reward for the user. So here we have another function for this update user reward. And so first we copy in memory the reward struck for the specific user. Also rewards per token that we just updated after. Here we are going to calculate how much reward have accumulated since the last time that we've run this calculation.
00:04:53.942 - 00:05:22.434, Speaker A: So here if there's any leftover undistributed, we add it and after we are going to calculate the reward. So we take into consideration the balance of the user and we multiply this by rewards per token accumulated. So here this quantity, this is per token. That's why we can multiply it. But we subtract checkpoint. So checkpoint. This is everything that we have already distributed to the user in the past.
00:05:22.434 - 00:06:02.858, Speaker A: And we divide this by ten power 18 because these two quantity are scaled by this. Okay, and after we save the updated info on the reward for the specific user and we return this. So that's how much reward we need to give to the user. Let's go back to the bottom function. Claim to get reward a user needs to call this function so you can send your reward to another address, but you don't have to. So first we are going to call update rewards per token, then update user rewards and claiming here. So this is the amount of reward that we are entitled.
00:06:02.858 - 00:06:47.310, Speaker A: We reset the accumulated field for the specific user to avoid giving twice the reward. And after we transfer the reward to the user with this line. So here you see that we call the save transfer function. So the reward token doesn't need to have this function because above, let's see above, we use this line using minimal transfer helper. So basically we're going to attach a library to any eras token in this contract and it's going to add some new function like safe transfer. So utoken just need to implement the standard interface of erc. You can just ignore this safe transfer thing.
00:06:47.310 - 00:07:24.486, Speaker A: But here one very important thing to note is that this transfer is going to be done from the address of your token to the address of the user. So that means that before you start your reward program you need to send some reward token to this token. Otherwise the transfer function is going to fail. Okay, so that's it for this smart contract. Yes, 20 rewards. Next I'm going to show you how you can use this smart contract to create your own token. So now I'm going to show you how you can create your own reward token.
00:07:24.486 - 00:07:59.426, Speaker A: So this is the repo of it, the blocks, and this is the folder for these tutorials. This is a truffle project and here we're going to go in the contracts folder. So in yield utils v two, I basically copied over all the contracts folder of the yield utils v two repo. So here we can find in token yes 20 reward as well as all of the other contract, our reward token. Here, this is token Sol. So this is very simple. First we import yes 20 rewards.
00:07:59.426 - 00:08:34.650, Speaker A: Then we define a contract, we inherit from it and in our constructor we receive an argument. So that's the address of the reward token, that's another token. And we call the constructor of ES 20 rewards and we pass the different parameter of our token as well as the address of the reward token and also mint some token to the sender. So this is just for testing. And after in contracts I've just defined another ers 20 token. And so that's just for testing. And that's the token that will be given as a reward.
00:08:34.650 - 00:09:06.180, Speaker A: And just like this, you can create a token with a built in reward feature. So now you know how to create a token with a built in reward mechanism. At the time of recording this video, this is still very new, but I think it will rapidly become more popular because it's a better user experience for investors who don't need to manually stake their tokens. Next, if you want to keep learning advanced topics about token, you can check out this video where I explain how you can set the price of a token on liquidity pools like uniswap or Pancakeswap. I will see you there.
