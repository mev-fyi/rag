00:00:00.250 - 00:00:47.946, Speaker A: Three critical factors that can make the difference between a successful project and failed. One are speed of development, security and cost of usage. With more and more developers and enthusiasts getting into blockchain, many great ideas fail to come to fruition because the growing competition makes it a lot harder to quickly deploy welldeveloped and secure blockchain applications. This is what this course is about. At the end of this course, you will have everything you need to create a secured blockchain application in record time that your customers can use without breaking the bank with third web, the sponsor of this course. Now the beauty of third web is that it is not just for developers. Third web provides you all the necessary features in case you want to go no code, low code or full code.
00:00:47.946 - 00:01:29.514, Speaker A: It allows entrepreneurs, developers, brands and creators to unlock the potential of the third iteration of the Internet in the easiest way possible, without having to learn a brand new coding language, and without needing to hire a completely new team. So if that sounds like you don't, wait. My name is Stefan and I'll be your instructor for this course. Before working as a blockchain developer at the blocks, I worked as an artificial intelligence software engineer for a big five consulting group. And just like AI was the big thing back in the days. With companies hiring hundreds of devs and consultants every year, blockchain development is the new train that you do not want to miss. Now hop in and let's get an overview of this course.
00:01:29.514 - 00:02:20.258, Speaker A: Welcome to the end to end web three developer course. In the next chapters you will see everything you need for writing, deploying and monitoring a secured web three application. You and I, we will go over an overview of third web. Simple examples to get started how to build your own contracts using third web solidity SDK how to publish your smart contracts to an onchain smart contract registry, how to deploy the smart contracts to any supported blockchain, and how to use automatically generated sdks to build a web three application with the deployed contracts. If you're here, it's because you are serious about building something special. Maybe you want to be the next conebase, or the next OpeNC, or even the next Internet. Whatever it is, you are in the right spot.
00:02:20.258 - 00:03:37.550, Speaker A: Now let's take a look at the prerequisites for this course. I will be using hard hat as well as vs code as my code editor. Now we assume that you already have a basic knowledge in web development, JavaScript and Node JS, and even better if you really have some basics in blockchain development, Ethereum, solidity web three hard hat metamask. If you don't have this knowledge, we recommend checking out courses like six figure blockchain developer or web development for blockchain. Now let's continue to chapter two welcome to the end to end web three developer course. In the next chapters you will see everything you need for writing, deploying and monitoring a secured web three application. You and I, we will go over an overview of third web simple examples to get started how to build your own contracts using third web solidity SDK, how to publish your smart contracts to an onchain smart contract registry, how to deploy the smart contracts to any supported blockchain and how to use automatically generated sdks to build a web three application with the deployed contracts.
00:03:37.550 - 00:04:23.890, Speaker A: If you're here, it's because you are serious about building something special. Maybe you want to be the next conebase, or the next openc, or even the next Internet. Whatever it is, you are in the right spot. Now let's take a look at the prerequisites for this course. I will be using hard hat as well as vs code as my code editor. Now we assume that you already have a basic knowledge in web development, Javascript and Node JS, and even better if you already have some basics in blockchain development, Ethereum solidity web three hard hat metamask. If you don't have this knowledge, we recommend checking out courses like six figure blockchain developer or web development for blockchain.
00:04:23.890 - 00:05:15.950, Speaker A: Now let's continue to chapter two welcome. In chapter two of the end to end web three developer course, let's have a quick overview of what we're going to be working with. So, if you remember in the first video, I said that three critical factors that can make the difference between a successful project and a failed one are speed of development, security and cost of usage. Now, can third web help us with that? Well, let's see. Speed of development instead of trying to reinvent the wheel for every project, what you can do is use prebuilt contracts that already cover the most common use cases. So they have quite an extensive set of pre built contracts, anything from signature drop to NFT collection to marketplace to voting. Let's take for example, signature drop.
00:05:15.950 - 00:05:58.714, Speaker A: So let's say, for example that you have an NFT collection and you would like that. Only users who match specific criteria can mint an NFT. Like you need to possess a certain token to be eligible. In that case, you could go with the signature drop prebuild contract. Signature drop is a contract that's based on the ERC 721, a developed by the Azuki team which allows you to release collection of unique one to one nfts with lower gas fees. So already we know we're going to save money with this contract. And on top of that, third web developers have created a signature based minting feature which grants your users the ability to mint nfts based on a custom set of criteria.
00:05:58.714 - 00:06:31.420, Speaker A: So huge time saving here. Another option, if we need to be a little bit more granular, would be to take the route of using a base smart contract like the ERC 721 base and manually adding custom features to it, like permissions, royalties, delayed reveal with the SDK. They also have a massive list of templates. That's pretty cool. And to interact with the blockchain, we can use snippets of code from the SDK in multiple languages. Nice. Next, we need security.
00:06:31.420 - 00:07:12.550, Speaker A: Well, all smart contracts provided by third web are audited through their Burg bounty program. They have an authentication SDK so your users can safely interact with any server side backend services. And also, we don't need to provide our beloved private key to the application anymore. You go onto your dashboard, you connect your wallet and you manage everything from there. Deployment, smart contract settings, roles, analytics, et cetera. And finally, the cost of usage. So compared to the first version of third web, the team has improved the contract architecture by leveraging proxy contracts and removing the project deployment requirement.
00:07:12.550 - 00:07:43.854, Speaker A: Long story short, it is now ten times cheaper to deploy smart contracts. It's free to use the platform, you just pay for the network specific gas fees you're deploying on, and they will release advanced feature in the future which will have a pricing model. We really only scratch the surface of what you can do with this framework. We'll dig deeper as we go along with the course. For now, let's jump in the next video and let's warm up with something simple. Let's go. All right, welcome back.
00:07:43.854 - 00:08:15.786, Speaker A: Here we are going to set up a basic web three project and see all the steps necessary until deployment. Then we'll do the same thing with third web and see how it performs. We're going to stay very simple, no NFts or marketplace for now. We'll see that later on. Just a dummy example so you can tiptoe into that new water before we dive in. So here are the basic steps necessary to develop and manage smart contracts. You're going to need, of course, to create an empty project.
00:08:15.786 - 00:08:50.034, Speaker A: For example, with Hardhat, you're going to need to install the dependencies necessary. You're going to need a blockchain provider API key. For example, you can get it through infura, which means you're going to need to create an infura account and you're going to need to create an API key. Then you need to get your web three wallet private key. You need to add the network configurations to your config file with your API key and private key. Then of course you need to write your smart contracts, test your smart contracts, write a deployment script, deploy your smart contracts. Then you might want to verify your smart contracts.
00:08:50.034 - 00:09:25.550, Speaker A: And then you need some third party tools to monitor your smart contracts. So here we go. All right, so here you are in your code editor and first thing I'm going to do, of course I'm going to CD into the correct folder, CD 2.2, simple example. Here we go. Next step, I'm going to initialize my project NPM init. Next I'm going to install Hardhat NPM install save dev Hardhat.
00:09:25.550 - 00:09:59.050, Speaker A: All right, then I'm going to launch Hardhat NPX Hardhat. I'm going to create a simple project. I'm going to ignore all of that. Next you're going to need the blockchain node provider. So for this example, we're going to use the most commonly used one, which is infura. So you go to infura IO and you create your account. Once you have your account, you can create a project and once you have your project ready, you can create a new key.
00:09:59.050 - 00:10:30.514, Speaker A: When that's done, you can go to manage key and you can get your provider URL for the network of your choice here, ringbeam. And we're going to add this to our hardhat config file. Next we're going to need our private key. So go to your metamask. You're going to see three dots. You go to account details export private key. You type your password right here and then you can copy your private key and past it right here in accounts.
00:10:30.514 - 00:11:16.098, Speaker A: Now the common good practice is to put your URL and your private key into an environment file, a file which you can then add to your git ignore file so it's not pushed into your repository. In that case, you will need to install ORV and you will need to import ORV into your config file at the top. Also in order to verify your smart contract, if you want to verify your smart contract on the Ethereum network, you're going to go on ether scan. Then create an account, create an API key, and then you can pass the API key into the config file. So now let's take care of the contract. We have created a greeter Sol. Then we need to specify the solidity version, so I don't want my compiler to be inferior.
00:11:16.098 - 00:11:58.658, Speaker A: To open eight point ten, I'm going to create a private string called greeting. Then I'm going to have a constructor which is going to take a string as parameter greeting. Now I'm going to change the state of my private variable greeting. Then let's say we have a function greet public. We can only read from it and we're going to return the private variables greeting. Then I need the function to set a different greeting function set greeting with string in memory greeting. It's going to be public and I'm going to change the state of greeting with a new value.
00:11:58.658 - 00:12:51.506, Speaker A: Now, hard hat also has a tool to help you test and debug your smart contract if you want to. It's called console sol. So we import hard hat, console Sol. And then for example, in my constructor, I'm going to console log deploying a greeter with greeting and then the value that I give into my constructor parameter. So you don't have to do this, it's just helpful when you're debugging or testing. Speaking of test, let's quickly go through a small test. So basically what we do, we instantiate our contract greeter and then we deploy it with the parameter hello world, and we verify that it returns hello world.
00:12:51.506 - 00:13:34.834, Speaker A: When we called the greet function, then we called the set greeting function with a new greeting. Hola Mundo. And then we verified that the new greeting has been changed. Now let's write our deployment contract. So I create a constant greeter. I'm going to asynchronously call the get contract factory function to get my greeter contract. Then I'm going to create a new constant greeter small g, and I'm going to asynchronously deploy it.
00:13:34.834 - 00:14:02.422, Speaker A: And my greeting is going to be hello from it blocks. Now I'm going to deploy it deployed. I'm going to console log greeter deploy two. And I want the contract address. And that's it. The end is a common pattern to deal with errors. Now let's test the contract.
00:14:02.422 - 00:14:34.626, Speaker A: Everything's passing. And now let's deploy the contract. All right, it is deployed and here's the contract address. You can check the contracts if you go on itascan. There he is. Now the next step that you might want to do if you want to interact with your smart contract on ether scan would be to verify it. So you would do NPX hard verify the name of the network, your contract address, and then the parameter that your constructor takes.
00:14:34.626 - 00:15:21.170, Speaker A: Now on top of that, if it's an NFT project, you will need to go onto other third parties like Pinata or NFT storage to upload your assets and metadata to a file sharing peer to peer network like ipfs or alternatively zero. Net or ITP. Also, if you sell nfts on different marketplace, you need to deal with the different ways the settings work to configure your nfts. So there are a lot of things here that can be streamlined and more secure. Like I don't want to use many different third parties, the whole setup is inconvenient. And also I don't want my private key to be in there. Like how many people have pushed their private keys by accident into production.
00:15:21.170 - 00:16:14.014, Speaker A: So now let's see how third web is going to streamline the whole process. Okay, so now that we have seen how cumbersome it is to deploy a smart contract the old fashioned way, let's test third web. So let's start from a blank project. I've already created a new directory and inside I'm going to create our contracts folder. I'm going to jump in and create the greeter contract. Now I'm going to jump back and I'm going to initialize my package manager with NPM in it. I'm going to pass all that and there we go.
00:16:14.014 - 00:16:49.320, Speaker A: Let me check that everything is there. Yes. Okay, next I'm going to install the third web command line interface or CLi. It should just take a few seconds. Okay, let's clear all that. Now let's take care of our contract. So I'm going to go into the hard hat project we did before and copy the gritter contract code and I passed it into my new blank contract right here.
00:16:49.320 - 00:17:35.200, Speaker A: Now there is something that I want to show you in dashboard and for that I'm just going to add an event. So event greeting set and it takes a string greeting. Next I'm going to emit the greeting set event in my set greeting function. There you go. And that is it done. You don't need to store your wallet private key anywhere. You don't need a node provider URL, not even a deployment script or config file.
00:17:35.200 - 00:18:34.948, Speaker A: Now of course you can have scripts and a config file if you want to. Now there are two steps that we are not going to do now, but I just want to introduce them to you and we'll dig deeper later on. So right up to that point we are right now you could do NPX third web detect, and this would compile your contract. It would detect the extensions you implemented, and it would also show you other extensions you might want to implement. But because this is a very simple contract for you to begin with, we did not use any extensions yet, so we don't need to use this command right now. The second thing that you could do is NPX third web release, and that would publish your smart contract on third web on chain smart contract registry where people can view and deploy your contract from the dashboard. And on top of that it also gives you a public landing page for both your wallet and smart contract.
00:18:34.948 - 00:19:20.266, Speaker A: But again, we'll see that later. And so now what is left to do is simply deploy our contract with NPX third web deploy, and because we are not providing a config file for this example, we just go with the saucy compiler, which is fine for us. It should take just a few seconds to receive the dashboard URL. There you go. Now we can copy this address and pass it in our browser. It actually opens the link automatically, but my default browser is Safari and Safari doesn't support metamask, so I'll pass the URL in Firefox for now. There you go.
00:19:20.266 - 00:20:00.860, Speaker A: We are now connected to the dashboard and we can enter the parameters to deploy the contract. If you remember, our contract has a constructor with a greeting parameter, so we'll say hello from it the blocks. Then you can choose your network. I'm going to stay with Gorli. Then you connect to your metamask and switch to the correct network if it's not already done. And finally we just deploy. Now remember, we only pay for the network fees using third web dashboard is completely free.
00:20:00.860 - 00:20:43.940, Speaker A: And there we are, the Explorer. You can see that we've got our set greeting functions, which takes one parameter underscore greeting, and we can also call our grid function. So let's run that and we get the greeting we stored when we deploy the contract. Now let's set a new greeting. For example, the classic hola Mundo. We can see in metamask that the set greeting function has been called. Let's confirm that.
00:20:43.940 - 00:21:17.600, Speaker A: And here's the receipt. We can see all the information related to our call. We also have access to the events tab. That's why we added an event earlier, to check out how it looks. In dashboard, we've got the name of the event, the transaction hash, the block number, as well as the event data. We also get a code tab that shows you how to interact with your smart contracts with react, Javascript, Python, and go. It shows you how to connect how to read and write data.
00:21:17.600 - 00:22:04.904, Speaker A: The settings tab is very useful for your NFT or marketplace project because you can configure things like platform fee, primary sale, and royalty. And finally, in the sources tab, you get access to your contracts API as well as the solidity source code, and you can directly verify your contract from here. But for that you need to release it first with NPX third web release, which we skipped for this example, and that's it. It was seamless. We created a contract, a packet manager. We installed the third web Cli and we were already ready to deploy. I think we can agree it was much faster than what we did before.
00:22:04.904 - 00:22:53.768, Speaker A: From here, we're going to kick it up a notch, and we are going to be using a little bit more serious contracts. But nothing to fear, everything will be as seamless as we just did. So next chapter, we'll talk about how to build smart contracts with third web contracts SDK. Let's go hi, welcome to part three of this course. In this chapter, we're going to build our own smart contracts. To do this, we are going to use a software development kit provided by third web called contracts SDK. Now, why not simply write your smart contract from scratch, or use third parties like open Zeppelin contracts wizard first, as we mentioned earlier, in this course, speed is crucial for a software project, and that's especially true in web three, when tons of new projects emerge every day.
00:22:53.768 - 00:23:49.004, Speaker A: Therefore, unless your project's concept is so out of the box that no existing contracts can match any of its specifications, chances are it will more likely have some overlap with current contracts, maybe for NFTs or for tokens, or for marketplaces. Therefore, it is much more efficient to avoid trying to reinvent the wheel and actually kickstart the project with existing audited smart contracts. Second, as a matter of fact, if third web contracts SDK did not exist, I would recommend to get your smart contracts borderplate from Openzeppelin contracts Wizard. It's a well known interactive smart contract generator, but the wizard is limited in that what you see is what you get. So you get an audited smart contract with all the custom features, access control, and upgradability. Then you place it into your project, and that's it. So you don't get anything else out of it.
00:23:49.004 - 00:24:55.020, Speaker A: But by building with third web contracts SDK, not only you can customize base contracts with audited extensions, but you also unlock the features of dashboard and SDK to help you build applications on top of them. For example, if you implement the ERC 721 base, you will unlock the mint button in the dashboard and can use the mint function in the SDK, which automatically uploads and pins your metadata to ipfs. You can think of those contracts as building blocks that help you enrich your smart contracts with features. Therefore, in the SDK you will find some blocks packaged together as base contracts with a full set of features out of the box. And you will also find contract extensions, which are smaller blocks that are fully customizable for you to add into your contracts. So, to recap contracts, SDK gives you access to audited, pre built base smart contracts. It provides you with audited contract extensions that you can import, and it gives you the possibility to unlock the features in dashboard and SDK on your own smart contracts.
00:24:55.020 - 00:25:30.270, Speaker A: Now let's move on and take a look at those base contracts. All right, welcome back. In this video we are going to see what's inside third, web contracts SDK. We're going to look at the base contracts and contract extensions for you to build your own smart contract. So let's start with the base contracts. The contracts SDK has three types of prebuilt base contracts, the ERC 721 bays, the ERC 1155 bays, and the ERC 20 bays. Let's look at the ERC 721.
00:25:30.270 - 00:26:21.592, Speaker A: As the documentation says, the ERC 721 bay smart contracts implements the ERC 721 NFT standard along with the ERC 721 a optimization to the standard. And so if you use the contract as it is, you are immediately able to manage ownership. Mint nfts batch together multiple contracts in a single call burn nfts. You get full royalty support and you get to associate arbitrary metadata with your smart contract. And that's really sufficient for the use case of minting nfts for yourself or to someone else and selling those nfts on the marketplace. Now let's see what this contract looks like. First thing, we've got all the imports, including ERC 721 A, for gas optimization as well as a few extensions.
00:26:21.592 - 00:27:11.576, Speaker A: Then the contract inherits from them. We've got the constructor that initializes the constructor of ERC 721 A, as well as set the owner of this contract and the royalties informations. Then we've got a function that checks which interface this contract implements, ERC 106 572-1721 metadata and ERC 29 81. If you don't know, or as a reminder, an interface is simply a set of function selectors. So a function selectors being the four bytes of the ketchup 256 hash of the signature of the function. Then we've got a function to get the NFT uniform resource identifier or uri, which locates where your assets are stored. Below we can see the function to mint a single NFT.
00:27:11.576 - 00:27:51.192, Speaker A: We can see that it checks the role of the colors first underneath the function to mint several nfts at the same time. We can see it calls the underscore batch mint metadata function from the batch mint metadata extensions that is imported at the top. Then we get a burn function to send an NFT to a null address. Then we get a couple of getter functions, one to get the id of the next NFT to be minted, and one that verifies if a specific address has the right to transfer a particular NFT. And finally we get overridable internal functions. But you don't need to care about that at this point. Now let's see how to use that.
00:27:51.192 - 00:29:03.842, Speaker A: I have initiated my package manager in my root directory and now I'm going to install third web contracts SDK like so NPM install at third web dev contracts. And now all we have to do is NPX adweb create contract. I'll name my project my new NFT. I'm going to choose hardhat and I want the ERc 721 base. Now let's see the in and let's compile it to see if everything is okay. We can see that it has detected the extensions inside the base contract and it also gives us some extensions we could implement like enumerable droppable signature mint and permissions. And that's literally it.
00:29:03.842 - 00:29:47.346, Speaker A: In less than a minute we already have a fully functional NFT contract ready to go. But now let's say you don't want the recipient of your NFT to see it. Now you want to reveal the NFT metadata to your audience at a later date, for example, and use a placeholder instead. So what do we need to do here? You guessed it, we need to extend the contract, which again will unlock features in dashboard. So let's see what extensions we can use. So you go to the third web website in the documentation, and on your left you're going to see extensions. Okay, so we already saw the base contracts here, but what we want to see are the features right here.
00:29:47.346 - 00:30:21.242, Speaker A: So we can see in features that we've got a bunch of them. And the one we want for our example is delayed reveal. Here we go. Let's take a look. The delayed reveal smart contract extension is meant to be used with an ERC 721 or 1155. It lets you create batches or delayed reveal nfts. Okay, we've got the available functionality that we get is the reveal functionality lets an authorized wallet reveal a batch of delayed reveal nfts.
00:30:21.242 - 00:31:14.220, Speaker A: All right, so let's take a look at the functions in this contract. There you go. We've got a function to store a batch of nfts encrypted metadata. It is stored right here in this public mapping encrypted data. We've got a function to get the UrI of a batch of nfts which as we can see right here at line 40, calls the next function below to decrypt the metadata. The encrypt decrypt function we can see it uses assembly with the soar cipher which is a type of encryption decryption algorithm that contains exclusive disjunction operations, hence the name soar operator Xor. But you don't need to know too much about that right now.
00:31:14.220 - 00:31:51.020, Speaker A: And finally we get a function to check if there is a delayed reveal on a particular batch of nfts. Cool. Okay, now let's add that to our base contract. First we need to import the extension like so and make our contract inherit from it. Delayed reveal. For our example, let's say that we only want the owner of this contract to be able to do the reveal. So we're going to store the owner's address here.
00:31:51.020 - 00:32:28.182, Speaker A: So let's add a public address deployer and let's add it to the constructor. I'm going to change the name of the contract as well. Now let's add a function to mint our delayed reveal nfts. We need the address of the recipient, a UrI of a placeholder. And we also need the encrypted metadata. And what we do here, we get the next token id. We store the encrypted metadata with the set encrypted data function that we saw earlier in the delayed reveal contract.
00:32:28.182 - 00:33:23.800, Speaker A: And finally we mint the NFT to the recipient in its unrevealed state. Next we are going to store the true metadata in the mapping postreveal Uri. Next we create a function to reveal the true metadata so we get its Uri with the get reveal Uri function from the delay reveal extension. We're going to delete it from the mapping encrypted data and we'll store our uri into the mapping we created above. And we'll just add a function to get a uri from the mapping given a token id and that's it. Now all we need to do is compile it and we can see that everything has compiled successfully. And with all that later on we will be able to unlock new features in dashboard which will allow us to configure a password and placeholder metadata.
00:33:23.800 - 00:34:26.870, Speaker A: Now what we have done so far is manually create a base contract and add an extension. But we can go even faster. Since third web has already thought about most use cases, we can see that in its SDK are already available some combinations of the base contract with the extensions. Therefore we already get the signature min contract to authorize external parties to mint tokens on your contract. We get the lazy min contract to define the metadata of nfts without minting it to an address, the delayed reveal contract as we saw, and we get the drop contract. If you want to lazy mint tokens and distribute them via signature minting or via the drop mechanism, and you get all the same thing for the ERC 1155 and the ERC 20. The ERC 20 also has a signature mean vote and a drop vote in case you wanted to add a Dow in your application.
00:34:26.870 - 00:35:04.284, Speaker A: As for the extensions themselves, we get a bunch of them. As we saw before, anything from contract metadata to platform fee to primary cell to signature mint. Really anything you will most likely need in your ERC 720 111 55 or ERC 20 contract. As for the no code goes, you can absolutely simply connect to the dashboard and set up your base contract and extensions from there directly. And that's it. In the next video we will move forward and see how to publish your smart contract to an onchain smart contract registry. I'll see you over there.
00:35:04.284 - 00:35:40.900, Speaker A: Welcome to chapter four here. We're going to see what happens when you decide to release your contracts into third web onchain smart contract registry. I'll explain what it is first and we'll put that into practice. First of all, what is an onchain registry? So the registry is just a place when you can keep and maintain your records. Those records can be kept on chain or on chain like it's the case for us. And so what the third web registry does is it maps every contract that you deploy to a version. All contract metadata is stored on ipfs and associated with a version.
00:35:40.900 - 00:36:38.110, Speaker A: Now a little side note, when you'll start to go down the rabbit hole, when you'll want to work on your own project with third web, you are going to encounter the registry as well as the factory. And that's where sometimes people can get confused. So simply put, the factory is the smart contract you interact with to deploy a prebuilt contract, while the registry is the smart contract that tracks the addresses of the contracts you deployed. Just keep that in mind. With the registry you can document a description of the function of the contract, the author, which is also compatible with the Ethereum name service or ens, the contract extensions and the past versions. And once you have published a new version of your smart contract, you can simply deploy it to any of the supported networks in just one click. And you don't need to reveal your private key at any time.
00:36:38.110 - 00:37:25.020, Speaker A: Another thing that you get after publishing your contract is a public landing page for both your wallet and your smart contract. We talked about it a little bit at the beginning of this course. And with this public landing page, the metadata, author release notes and source codes is publicly available and stored on chain. With this landing page, not only people can see the metadata, they can also see all the functions of the contract directly from the dashboard, and they can also deploy a copy of the contract themselves. And finally, as we briefly saw in the simple example of chapter two, once it is released and deployed, you can directly verify your contract on the network. Okay, so now let's see how to actually release our contract. So last chapter we ended up by compiling our contract and at the same time detecting the implemented extensions.
00:37:25.020 - 00:38:06.920, Speaker A: Now we are going to do NPX third web release. It's going to compile our contract and we're going to receive a URL to create a release. Okay, so here's our URL and here we are on the page to create a release. So we can add a description, we can add more information about how our contract works exactly like you would do on a readme for GitHub. We can check out how it looks with preview. We can give it a version and we can add release notes. We can now create the release which by the way will leave on the polygon blockchain.
00:38:06.920 - 00:38:34.040, Speaker A: So I'm going to switch my wallet to Polygon. Now I can create the release. We sound the request. Remember that releasing is gasless. So even if you have zero matic, you are good to go. All right, success. And there's the landing page that we mentioned earlier and we can share it with anybody in the world.
00:38:34.040 - 00:39:13.358, Speaker A: So on top of the description and release note, I can see my profile. I can add my social media accounts like Twitter or GitHub. I can view all the contracts that I release. I can see the contract details, and I can also see all my contracts, functions and events, even those coming from imports and their source codes. This release also creates a deploy button, and that allows anybody to deploy your contract with their own parameters. Okay, we've seen quite a lot already. In the next chapter, we'll rewind a little bit and deploy our delayed reveal ERC 721 contract straight to the blockchain.
00:39:13.358 - 00:39:41.022, Speaker A: We'll also take a look at automatically generated sdks. I'll see you there. Now let's deploy our contract. We have three possibilities. From the public web page with the command third web deploy or directly from third web dashboard. So first, from the web page, as we said previously, anybody can access your contract web page and deploy it with their own parameters. So let's do that.
00:39:41.022 - 00:40:09.670, Speaker A: I'll click on deploy now. And this is where a user can customize the deployment. You can customize the contract name symbols who receive the royalties from each cell of your nfTs. The royalties basis points, for example, 250 means 2.5% royalties of the NFT and the network you want to deploy on and just deploy. But maybe you don't need a public web page. So in that case you could deploy directly from your code editor.
00:40:09.670 - 00:40:47.268, Speaker A: So I would simply do like we briefly did at the beginning of this course. I would do NPX third web deploy. We receive the dashboard URL, let's open it, and there it is. We get to the same point as before to enter our parameters. Now, the third and last way to deploy a contract, which is even faster than the two earlier solutions, is to deploy straight from the dashboard. So let's do that. So if you simply Google third web dashboard, you get to this page.
00:40:47.268 - 00:41:20.272, Speaker A: I briefly introduced it in another video. Now, if you already know the contract you want, you can deploy it straight away. Otherwise at the top you'll see an indication that says, help me choose. Let's click on that. And then if you scroll down a little bit, we can get more details on each prebuilt contract. For example, if we click on signature drop, description says that you can lazy mint configure a single claim phase. And there is also a delayed reveal, just like we want.
00:41:20.272 - 00:41:45.080, Speaker A: So that's a candidate. What else we got? NFT drop. It says that you can claim phases in sequences pretty neat. And we also find lazy mint and our delayed reveal. If we scroll down, we even see an example. But anyway, that's how you would do if you are unsure of what to use. In our case, let's go with NFT drop.
00:41:45.080 - 00:42:19.000, Speaker A: So I come back to the third web contracts page, I choose NFT drop again. I'll add a name, image and description royalties, let's say 2.5% and we deploy. And there it is. Okay, so we just saw the three ways of deploying with third web. Now let's actually add some nfts and use the sdks. So first thing, let's add a claim phase, to which we'll add the nfts.
00:42:19.000 - 00:43:00.470, Speaker A: Okay, so let's say the phase starts in 2 hours and everything else can stay as it is. I'm saving this. Next we'll go to the nfts tab, and here we've got two options. We can do a single upload or batch uploads. Note that the delayed reveal feature will appear for batches of nfts, but not for a single one. So let's choose batch upload. I already have a folder with a couple of images and a CSV file with some properties, which I am going to drag and drop here.
00:43:00.470 - 00:43:50.536, Speaker A: It gives us a nice view of all nfts with details. Then we click next, and there it is, the delayed reveal feature that we unlocked. I enter a password, then I upload a placeholder to hide the actual nfts. Then I'll give it a name, a description, and I'll upload those three nfts. I confirm the approval in my metamask and here they are. Our nfts have been replaced by the placeholder waiting for the first claim phase. Finally to activate phase one and let people claim your nfts.
00:43:50.536 - 00:44:18.710, Speaker A: There is a button right here, reveal nfts. If you have several batches, you can choose which one to reveal. You enter your password and that's it. People can now see and claim your nfts. All right, we have deployed the contract, set up our delayed reveal. We did the actual reveal. Now let's look at the generated sdks.
00:44:18.710 - 00:45:02.094, Speaker A: Okay, so we've got four sdks for react JavaScript, Python and go. I do not code in go, unfortunately, but I do know react JavaScript and Python. So I'll do a demonstration by reading data with JavaScript and Python, and I'll keep the writing with the react SDK for our final project. Okay, so if I go back in my code editor, I created a new folder, and inside that folder I have a blank JavaScript file and I have a blank python file. Okay, we're going to use those two for the demonstration. There's not going to be any HTML, it's all going to be in the terminal. Now let's go back to the dashboard, the first thing to do is going to import third web SDK.
00:45:02.094 - 00:45:33.630, Speaker A: So let's do that. I'm going to copy this cell right here. Now back in my code editor, I can pass this. Now if I save and I try to run the code right now, you can see we should get an error because we cannot use import statement outside the module. So just don't forget in your package json, you're going to copy type module right here. And that's it. You save this.
00:45:33.630 - 00:45:53.460, Speaker A: Now if I run again, we should be good. Yes, we are. Perfect. Next. So for example, let's say I want to check my NfT balance which should be zero because we haven't claimed anything. You can see here, get nft balance in Javascript. So I'm simply going to copy this.
00:45:53.460 - 00:46:25.758, Speaker A: Going to pass it right here. Now, it might be because of current updates, but I know that it's actually contract that balance off. Now if I run this, we get a big number. So let's just add to number. And I'm just going to say my NFT balance is save this and I'm going to run again. And there you go. My NFT balance is zero.
00:46:25.758 - 00:46:57.064, Speaker A: Okay, let's go back now. Let's say I want to see all unclaimed nfts, which should be three. So I'm going to use this cell right here. I'm going to copy this, pass it right here. I'm going to console log first, unclaimed NFT. So this code right here is going to give me the name of the first unclaimed NFT. So elephant.
00:46:57.064 - 00:47:21.044, Speaker A: Okay. But now if, let's say I want everything and I want all unclaimed nfts. Instead, what I could do, I could grab the object return from unclaimed nfts. I'm going to map each item and I'm just going to return the name of each item. I'm just going to add unclaim nfts. Let's see how it goes. And there we go.
00:47:21.044 - 00:47:37.396, Speaker A: We've got elephants, zebras, leopard. Okay, so we have all unclaimed nfts right here. All right. Okay, let's do a last one before we jump to Python. Let's say I want the metadata of an NFT. That would be this one. Get a single NFT metadata.
00:47:37.396 - 00:47:55.090, Speaker A: Okay, copy this again. I know that this has changed. It's now contract that. Get all the metadata of my first NFT. So the token id zero. That's fine. And I'm going to console log metadata of token id zero.
00:47:55.090 - 00:48:26.466, Speaker A: Let's run that. We get the names, description, where the image lives on ipfs, the id which is zero, and the Uri. Cool. Now again, we'll see how to write on the blockchain with the final project, but is the exact same thing. Now for Python you could use online notebook like Google collab for example. Now if you want to work on your machine and you don't have Python, you should install it first, of course. So here's the page.
00:48:26.466 - 00:48:56.350, Speaker A: Once that's done, come back into your code editor and create a py file. Let me clear. And if we go back to my SDK python. So the first thing is to install third web SDK with Pip, which I already done, so it should go fast. Next, let's copy this cell to get started with our contract. Next, same thing. Let's get the balance.
00:48:56.350 - 00:49:22.390, Speaker A: Where's the cell? Get the balance? Let me take this. There you go. All right, let's try this out when it's up. Python and the name of my file and zero. Perfect. Let me actually add my Nft balance. Next, same thing for the unclaimed supply.
00:49:22.390 - 00:49:55.148, Speaker A: Let's print that. Let me add total unclaimed nfts. Let's see how it looks. Total unclaimed NfT three. Very nice, very nice. And now the last one. And now the same as we did for Javascript.
00:49:55.148 - 00:50:22.680, Speaker A: Let's get the metadata of an NFT. I'm going to copy this cell right here. Okay, this time I want the second NFT. I'm going to say metadata of NFT one. And there you go. Just like Javascript, we get the same metadata. It's really all that simple.
00:50:22.680 - 00:51:01.700, Speaker A: And again, I just demonstrated how to read from the dashboard. But later on for the final project, we'll actually do the writing part as well. So in terms of automatically generated reports with onchain analytics, it's not yet available, but stay tuned because it should come out soon. And that's it for this chapter. It was quite a lot of things and we are now ready to jump into the next chapter and build a blockchain application with next js and typescript. I'll see you there. Okay, so now let's combine everything that we've seen so far and build a simple blockchain application.
00:51:01.700 - 00:52:05.606, Speaker A: And what I want to build is a page that allows users to claim their nfts and display their collection. This time we'll use the dashboard to create and deploy an addition drop contract. Then we'll create the next JS application with typescript and we'll use the automated generated SDK and some hooks to interact with the contract. So we'll add a button to check your wallet, we'll check how many nfts we own from the contract in a console, we'll see how to claim some, and we'll play around with hooks and display our own claimed nfts gallery. Now why next JS and typescript? Next JS is an open source framework that allows you to develop fast and user friendly web application and static website using react. So why not just use react? So next JS comes out out of the box with some great features compared to react, such as data fetching, typescript support, and it's also highly configurable. Next JS has also many advantages like it requires less code.
00:52:05.606 - 00:52:50.290, Speaker A: Builds are also very fast because of server side rendering and static generation. It also has fast rendering API support, better image optimization, and more. Now this does not mean that react is dead. The react community is actually still bigger than NextGs, but we see that NextJs is becoming more and more in demand in web three projects and we'll go with typescript because it has become increasingly popular over the last few years and many jobs are now requiring developers to know typescript. Now, if you already know JavaScript, you will be able to pick up typescript quickly. Typescript is a superset of JavaScript, meaning that it does everything that JavaScript does, but with some added features. The main reason for using typescript is to add static typing to javascript.
00:52:50.290 - 00:53:30.078, Speaker A: Static typing means that the type of a variable cannot be changed at any point in a program, and that can prevent a lot of bugs. On the other hand, JavaScript is a dynamically typed language, meaning that variables can change type. Now the downsides of typescript is that it takes a bit longer to write than JavaScript, as you have to specify types. So for very small personal project it might not be worth using it. And also typescript has to be compiled, which can take time, especially in larger projects. With that said, the extra time that you spend to add types will save you hours of debugging down the line. So keep that in mind.
00:53:30.078 - 00:54:26.382, Speaker A: And what's nice with third web is that they already provide us with some types for typescript out of the box. The contract that we'll be using is the edition drop contract, which is ERC 1155 based contract with added features such as permissions, royalties, platform fees and drop. ERC 1155, if you don't know, is a token standard that enables the efficient transfer of fungible and nonfungible tokens in a single transaction. And this addition drop contract is going to allow us to define the conditions for when and how your users can mint an NFT, including allow lists, release dates, claim limits. We can even airdrop them inside the contract. We also already have access to the lazy minting feature, which is going to allow us to upload metadata for our nfts without meeting them. This is useful for when you want other wallets to mint nfts from your drop into their own wallets.
00:54:26.382 - 00:55:05.870, Speaker A: And so with this addition drop contract, for example, you could create NFT memberships like early access cards that you want your users to claim. You could release an item in your game for a limited time, or you could create 100 nfts based on one art piece and allow users to claim one per wallet. Okay, now let's take a look at one of the extension drop. So it has functionalities to let us set restrictions around the meeting of tokens to claim tokens if a wallet is eligible. And we can also define the criteria a wallet must meet to be able to set claim conditions. Interesting. Okay, let's look at the actual contract.
00:55:05.870 - 00:55:39.130, Speaker A: And for that we look into the drop single phase contract. There you go. Okay, so here's the function to claim an NFT. First it checks that the caller is eligible to claim the NFT as well as the max quantity allowed to be minted. Then it does the actual claim and it checks if you get a price. Then we've got the function to set the claim conditions so it checks if the owner resetted the claims. It checks that the max amount of NFT supplied has not been reached.
00:55:39.130 - 00:56:20.242, Speaker A: And if it's all good, we can set the conditions so we can set things like the max supply quantity limit per transaction, the wait time between claims price, et cetera. Next, verify claim. Verify claim was in the first function we saw at the beginning, the claim function. And as it says, that's the function that checks a request to claim nfts against the active claim conditions criteria. A verify claim Merkel proof, another one that was in the claim function at the beginning. And this one verifies if the caller is in the whitelist. Or as it says, it checks whether a claimer meets the claim conditions.
00:56:20.242 - 00:56:56.574, Speaker A: Allow list criteria, get claim type stamp. That's the function that's called in the verify claim function to check when a claimer can claim again by the gate claim type stamp. That's the function that's called in the verify claim function to check when somebody can claim again, basically. And then we've got some optional hooks. But we don't need that. All right. Now that we know what we're working with, let's actually create and deploy the addition drop contract, shall we? Okay, so now let's go to the third web dashboard and actually deploy our addition drop contract.
00:56:56.574 - 00:57:21.094, Speaker A: So there I am, you can google thirdweb.com slash contracts. And now we're going to look for the addition drop contract. So there is one NFT, multiple owners. Very nice. I'm going to name it, I don't know, my new edition drop. Drop.
00:57:21.094 - 00:57:50.280, Speaker A: I'm going to add an image to my contract. So for example, just an image of an astronaut. Why not? And then I'm going to add a description. So like this is my astronauts edition drop. Now let's check the other parameters. So the recipient, me, the royalties are going to be paid to me. So you can do whatever you want, 2.5%.
00:57:50.280 - 00:58:38.020, Speaker A: Let's see the advanced features, the platform fees, I don't know, 2.5%. And now let's just deploy it. I'm going to confirm that. And here we are in the explorer. The next thing that we're going to do, we're going to add an address into the whitelist of minters. So I'm just going to copy the second address that I have, lock back. I'm going to add my second address and I'm going to add the address.
00:58:38.020 - 00:59:18.270, Speaker A: Going to update the permissions. Let's confirm that. Okay, so the main address, the owner of this contract is the only admin and there are two addresses in the whitelist. So the admin and another address who can mint the nfTs. Now what we're going to do, we're actually going to add some nfTs. So for this one I'm going to do a batch upload what you have to do, you need to have either a CSV or a JSON file into a folder with your images. Those images must follow a sequence.
00:59:18.270 - 00:59:55.930, Speaker A: Okay, so I actually already created a CSV based on spreadsheet. It's right here. So I have my metadata CSV and I have three images and we're going to upload all of that. So I'm just going to grab all of this and I'm just going to drop them right here. Here we go. Okay, I have token id, I have one, two, three images. We have the name, we have the description, we have the properties which are the background, the color number one and color number two.
00:59:55.930 - 01:00:13.666, Speaker A: Now we can click next. And what I want to do here, I don't want to do a delete reveal. I want to see the NFT as I minted. I'm not going to show a fault, I'm just going to upload them. So you can see here we are calling the lazy mint. I'm going to confirm that. And there we go.
01:00:13.666 - 01:00:42.310, Speaker A: We have successfully lazy minted three nfts. Really nice. And we are pretty good so far. And the next step is simply we're going to use the SDK that was automatically generated and we're going to use that into our nexTJs typescript application. Okay, so here I am in my code editor. I have my terminal open. I prepared my package manager, I have my SDK installed.
01:00:42.310 - 01:01:22.630, Speaker A: The next thing that we're going to do, we're going to install the nextgs typescript starter by third web. That already gives us the third web provider wrapper, which is necessary for the hooks provided by third web as well. We copy this, go back to the terminal, let's name our project something simple. My edition. Drop nft. Okay, now we can CD into our project and let's test this out with yarn dev. And there it is.
01:01:22.630 - 01:01:56.204, Speaker A: We get a blank page with a connect wallet button if I click it and I want to connect to my metamask. Now let's get into the project and see what we're working with. So the connect wallet button that we just saw, what is actually happening is that we are using a hook provided by third web. You can see that we import connect wallet. The connect wallet hook from third web dev react and we place it into a div. And that's pretty much it. It's really that simple.
01:01:56.204 - 01:02:38.800, Speaker A: But I want to show you another method as well. I'm going to create a new page. I'm going to call it claim TSX. But that's the page that we are going to use to claim our nfts later on. Here. I'm going to import use metamask from third web devreact. I also need to import the type next page.
01:02:38.800 - 01:03:29.522, Speaker A: This comes directly from next. Finally I can create my page. So I'm going to call it claim of type next page at the very bottom. I'm going to export it and I'm going to return an empty d for now. So now let's use the use metamask hook that we imported above. So for example, I can create a constant connect metamask is equal to use metamask. I'm also going to need my address to see if I'm connected or not.
01:03:29.522 - 01:04:12.090, Speaker A: So I'm going to create a constant address. And here we're going to use another hook provided by third web called use address that we need to import here. And I import use address. And now I'm going to create a button that says connected. If I'm already connected or if there's no address that means that we are not connected. So it's going to display connect wallet. So in curly brackets I'm going to say that under the condition that we have an address then I want to display a button that is going to say connected.
01:04:12.090 - 01:05:05.994, Speaker A: Otherwise under the condition that we don't have an address, then I want a button that says connect wallet. And when I click on this button I want to call my connect metamask. And just below that I'm just going to add my address actually. So let's say my wallet address in curly brackets address and we're good to go. We save this. Now I'm going to open my browser and I'm going to add a claim to my local host. And there it is.
01:05:05.994 - 01:05:36.538, Speaker A: We are already connected so it says connected and my wallet address is this one right here. Beautiful. To style the button you can use something for example like end. So if you want to do that, all we need to do is NPM install end. I'm going to import it at the top. So I'm going to import button and has several choices for the button. I'm just going to go with the first one.
01:05:36.538 - 01:06:16.616, Speaker A: So all we need to do is to change the name here button and the type is going to be the primary. And the last step is to import ncss into app TSX so it's available for the whole app. Now let's see how this looks. I'm going to reload the page. And there it is. Now we have a blue button right here. Just to make things a little bit cleaner, I also created a styles folder with a global CSS file as well as a home module CsS.
01:06:16.616 - 01:06:52.792, Speaker A: We're not going to go through that now, but you can have access to it in the repository. And I simply imported global css into my app CSS and my home module css into my claim CSS and I imported the home module css into my claim page right here. And all I'm going to do is that on the first div I'm just going to say class name equal styles container. That's all I'm going to do. And we should get something a little bit more centered. There we go. We have the connected button.
01:06:52.792 - 01:07:17.708, Speaker A: I have my wallet address. All good. In the next video we're going to start interacting with our smart contract with the automatically generated SDK. Take a short break and let's do this. All right, welcome back. The mission for this video is going to be interacting with the contract. So for that we're going to use the third web react SDK as well as the automatically generated SDK.
01:07:17.708 - 01:07:38.436, Speaker A: But we'll see that later on. So as you can see right here, I'm on the third web react SDK. So we got a few things. We got hooks to connect to the wallet. We've got hooks to get the network information, et cetera. What I want to do first I would like the metadata of the contract that we created. And for that I'm going to go down to custom contracts.
01:07:38.436 - 01:08:10.980, Speaker A: I'm going to go to read hooks right here. And at the bottom you see contract metadata. That's the one we want. And as it says, you can use this to get the contract metadata for a built in or custom contract. So they provide you with an example as well as the signature, the parameters, and it returns a response object that includes the contract metadata of the deployed contract. All right, cool. I'm going to import use contract metadata.
01:08:10.980 - 01:08:55.560, Speaker A: Then I can come here and I can copy this example. I'm going to pass it right here and let's say I want the contract name, for example. So contract name and I'm going to say contract metadata and simply name. I'm going to do the same thing for the contract description. So I'm going to copy this on a good lex nine and I'm going to remove this. I'm going to do description. I'm going to replace name by description.
01:08:55.560 - 01:09:52.700, Speaker A: What else? We uploaded an image. So you know what, let's get the image. So I'm going to do image the source. It's contract metadata image and I know it's a pretty big image. So what I'm going to do, I'm going to restyle it quickly and I'm going to say the margin top 20 with a width of 250 and a height of 200. And that's pretty good. I almost forgot, we need the contract address right here.
01:09:52.700 - 01:10:29.860, Speaker A: So I'm going to create that const, contract address now I'm going to third web dashboard and I'm going to copy my contract address. I'm simply going to pass it right here. Right here. I'm going to say contract address. I'm just going to move this line above. Okay. The last thing that we need to do before making any call to the contract, we need to be sure that we are making the call onto the right network.
01:10:29.860 - 01:10:57.100, Speaker A: So we deployed our contract on the Mumbai network on polygon. So you're going to go to app, TSX and inside third rep provider. You see there's something that's called desired chain id and it's calling active chain id. And active chain id right now is on Mainnet. What we want. It's Mumbai. There you go.
01:10:57.100 - 01:11:16.548, Speaker A: Okay, and now everything is ready. Now we can call the contract on Mumbai. Let's see how it looks. I'm reloading the page. And there it is. I have my contract name, my contract description, and I have the image that I use to create my contract. Okay.
01:11:16.548 - 01:11:43.500, Speaker A: Now just to show you different ways of displaying things, I'm also going to show you how you can console log information. Maybe you don't want to display some type of information on the front page. You would prefer to keep it in the console. We can do that too. And for that, let's go check the automatically generated SDK. There it is. So what we can do, we can burn nfts, we can claim nfts, we can get the NFT metadata.
01:11:43.500 - 01:12:49.028, Speaker A: We can airdrop multiple, okay, we can get a single NFT metadata. We can configure the claim condition of the royalties. All right, so first I need to import addition drop, and then I need to use the hook, use edition drop and pass the contract address. So let's import it. First I import, use addition drop, and I'm going to call the hook. So I'm copying this line, I add the contract address. Then I'm going to create a button.
01:12:49.028 - 01:13:53.100, Speaker A: This button is going to execute an asynchronous function. And I go back to the dashboard, I copy this line to get the contract. Our contract is name addition drop. So I'm going to change that. Now, if we go back to our application and I console log, you can see that it returns an empty array because we haven't claimed any nfts yet. Now if we go to the dashboard under the embed tab, if you scroll down, you'll see a preview. This preview allows you to claim an NFT right away.
01:13:53.100 - 01:14:19.910, Speaker A: So now we can claim an NFT because we haven't set the claim phase yet. So let's go do that. Under the tab nfts, go to the NFt you want. I'm going to choose the one with the token id, zero, the first one, and then on the right you can see claim conditions. Okay? So you can set a few things like when it start, the price, the quantities, the network it's fine for me. I want to claim it right now. So I'm going to save this.
01:14:19.910 - 01:14:37.912, Speaker A: Now if I go back into the embed tab, into preview, you can see that. Now we can claim. I'm going to claim one. And there we go. I have one claim. Beautiful. Now if I go back to my application and I reconsol log, now you can see that my array is not empty.
01:14:37.912 - 01:15:43.522, Speaker A: Now we have an object in it. And inside we got metadata owner, quantity owned, supply. Now the one I would like to display is the quantity owned. Let's go back to our code editor. I want to say that I want to map the items in this array and I'm going to say that quantity is equal to the quantity owned of each item I want into a number and I'm going to add that to my quantity. I own a certain amount of nfts. And there we go.
01:15:43.522 - 01:16:12.420, Speaker A: Now if I go back into our application and our console log again, there it is. I own one nfts. Beautiful. Now let's see how to claim an NFT with the SDK. So if we go back on the dashboard, we can see we have a code to claim nfts to a specific wallet. I'm going to import use claim NFT. Then I'm going to take this line.
01:16:12.420 - 01:16:41.314, Speaker A: By the way, I didn't mention those flags is loading and error. So let me explain. Each hook from the third web, react SDK uses react query behind the scene. And that's why you get these flags right here. Like is loading is error. There are a bunch more and you can destructure them from the object that gets returned. But you can have the same flag names.
01:16:41.314 - 01:17:07.674, Speaker A: So if you want to use these flags, you need to rename them. For example, I'll rename. This one is loading metadata. And I'll rename. This one is claiming. Also you'll notice that in the case of metadata we are using something called data, while for claim NFT we are using mutate. It's because as we just saw, the hooks use react query under the hood.
01:17:07.674 - 01:17:35.590, Speaker A: And what a query does, it fetches information to or from the blockchain. And so if you just want to read the data, you are going to look at the data field of the query while for writing the field of the query is called mutate. Simple as that. Now let's look at the parameters that we need for claim NFT. Okay, so we need an address. Two, we need the token id. We need a quantity.
01:17:35.590 - 01:18:01.614, Speaker A: And check erc allowance can be undefined. So we're not going to care about that. But at least we need an address, a token id and a quantity. Okay, next you can do like the code shows here and add the call to the function directly inside the button. But we'll do that later for other stuff. For now, let's put all of that in a function. So I'm going to create a new asynchronous function.
01:18:01.614 - 01:18:42.404, Speaker A: I'm going to call it claim NFT. I'm going to create a variable token id and quantity with the token id. I'm going to take the first one. So token id, zero and quantity, I just want one. I'm just going to add an if statement just in case the metamask disconnects and we need to reconnect. Then I'm going to say const transaction equal await edition drop. And thanks to typescript I can see every method that I can call.
01:18:42.404 - 01:19:49.790, Speaker A: Okay, so you have all of that, but the one I want to call is claim to and for the parameters it takes, my address, the token id and the quantity. Then what I'm going to do, I'm going to take the receipt and I'm just going to console log that receipt. I'm also going to add an alert that says NfT claim successful. Otherwise, if that doesn't work, I'm going to catch the error and I'm going to display an alert that says NfT claim unsuccessful. Then I'm going to create a button. And when I click this button, I'm going to call my claim NFT function. I'm going to call that button claim NFT.
01:19:49.790 - 01:20:34.310, Speaker A: Now if I go back to my application and I click on claim NFT, I'm going to confirm in my metamask. And here's the alert. NfT claim successful. Nice. Now if I look again into my console log button, if I click on it now, it says that I own two nfts. Beautiful. In the next video, the third and final part of this project, we're going to see how to display the amount of nfts claimed and we're going to see how to display a gallery of our nfts.
01:20:34.310 - 01:21:02.018, Speaker A: I'll see you there. All right, welcome back. I would like to display the amount of nfts that have been claimed. I would like to list them. And so this time I'm going to go in the documentation, I'm going to go to Sudweb react SDK and on the left under NFT and edition read hooks. I'm going to go to claim nfts. And this is the one I want.
01:21:02.018 - 01:22:07.760, Speaker A: But be careful because sometimes those hooks are in beta so it is susceptible to change in the future. But anyway, I'm going to copy the line right here that uses the hook use claim nfts, go back to my code and I pass it right here. Then of course I need to import use claimed nfts. Then I'm going to change this value right here for addition drop. Then we have the start, which is the index to start from, and the count which is the maximal amount of items that we want to return. All right, now let's actually return that just below the button. So I'm going to say that if the hook returns me an array and this array actually contains something so his length is superior, zero.
01:22:07.760 - 01:23:10.490, Speaker A: Then in that case I'm going to map what was returned. I'm going to call the item in my mapping NFT. The key of each item is going to be their id. So nft metadata id string. And then I would like to display the supply. So nft supply to number. Then nft metadata name and claim, meaning n amount of x nft claimed.
01:23:10.490 - 01:23:39.286, Speaker A: Okay, we can save this. Now if I run my application, there's the list. Now, I could have named my nfts a little better, I admit. But bear with me on that one. We can see I've got two member Nft 10 member NFT two and zero member NFt three claimed. Okay, now the thing is, a gallery with only one NFt is not a gallery. So let's claim a few more.
01:23:39.286 - 01:24:20.658, Speaker A: So if I go back to my code and inside my claim nft function, I change token id from zero to one. What do you think is going to happen if I try to claim the member NfT two? I get an alert NfT claim unsuccessful. Okay, let's see what's going on. Let's open the console and claim again. Okay, so the transaction has been reverted because there is no active mint. And that means that the NfT we're trying to claim is currently not in a minting phase. So for the first NFT member NFT zero, we added a claim phase from the dashboard.
01:24:20.658 - 01:24:43.786, Speaker A: But maybe this time let's see how we can do with the SDK. So back to the dashboard in my code tab. There it is. Configure claim conditions for each NFT. Let's see what we're working with. We've got the start time for the presale. Okay, it's a private sale.
01:24:43.786 - 01:25:27.514, Speaker A: We've got the public start time, which is 24 hours from now. Then there are the claim conditions with when the private presale starts the maximum, this select group of people can claim the price. And there's the list of those lucky individuals. Then below we've got the public claim conditions with the start time in 24 hours and a higher price. Finally, we specify the token id of the NFT onto which those conditions will apply, and we call the function to set up the conditions. Okay, so let's copy this cell back to my code editor. I think I'll pass it right here.
01:25:27.514 - 01:25:56.880, Speaker A: Let me add a comment. Set claim phase for public cell start time. I'm not going to wait 24 hours, I'll just wait a few seconds. Max quantity. I'll put unlimited price. I'll put zero just because I don't want to spread my testmatic. And for the snapshot I'll add my main address.
01:25:56.880 - 01:26:31.970, Speaker A: I'm just going to remove this comment and I'll set the public price to zero as well. This parenthesis should not be there. And for the token id we want the second NFT. So id one. Now we're going to put all that code in an asynchronous function. I'll call it set claim phase. Let's copy and pass the code inside.
01:26:31.970 - 01:27:07.542, Speaker A: Also, the name of our contract is edition drop. Next, let's add a button. I'm just going to copy the claim Nft button and pass it right below it. I'll rename it set phase and this button will trigger the set claim phase function. Now back to the web page. Let's get rid of the alert. Let's close the console.
01:27:07.542 - 01:27:28.114, Speaker A: And here's our set phase button. Let's see if it works. We get an error because the start timestamp must be in ascending order. Let's see what's going on. Public cell start time. No. Okay, I see what's happening.
01:27:28.114 - 01:27:58.486, Speaker A: I put the public cell start time at ten milliseconds instead of 10 seconds. Okay, it's too short, so let's correct that. There we go. I'm also going to add an alert. New phase set. All right, now let's save this and let's try again. And there we go.
01:27:58.486 - 01:28:20.878, Speaker A: Our metamask opens. Let's confirm that. Okay, we've got the notification. Now let's see. In a dashboard under nfts, if I click on member NFT two and then on claim conditions, there's my phase one with all the parameters are specified. And below we got the public phase. Let's go back to the app.
01:28:20.878 - 01:29:10.160, Speaker A: Now. If I click on claim NFt, there it is. We have successfully claimed one member NFT two. And it's been more than 10 seconds now, which means the public sale has started as well. So let's switch my account on my metamask to my second address so we still see the same amount of claim nfts because those are the total claimed by all people combined. But if I open my console, click on console log on nfts. Now we can see this account owns zero nft.
01:29:10.160 - 01:29:40.220, Speaker A: So now let's claim Nft two since we are now in the public sale phase. Okay, we can see that the total has changed. Let's console log. And there it is. We've got one member NFt two. Cool. Now let me just go in the contract explorer and burn that.
01:29:40.220 - 01:30:10.720, Speaker A: I'll add my account to address the token id and the quantity execute confirm. And there it is. We burnt it. Let's check this out. Yep, this account now own zero nft. Cool. Let me switch back.
01:30:10.720 - 01:30:49.580, Speaker A: Speaking of burning nfts, what we could also do is add a button to burn an NFT. So if we go back into our SDK, we've got this burn a specific amount of an NFT. Okay, so I'm going to copy and past the set claim phase button right below, let's rename it burn NFt. Just to mix it up a little bit. I'm going to create my asynchronous function here. So I'll copy this line. Pass it right here.
01:30:49.580 - 01:31:40.180, Speaker A: Contract is addition drop token id. We want to burn the first one amount one. Let's put all of that in a try catch. Let's console log the error just in case. Let's also add an alert with burn unsuccessful. And one with burn successful. Let's save this.
01:31:40.180 - 01:32:07.530, Speaker A: Here is our new burn nft button. So let's burn a member nft one, confirm. Burn successful. Okay. And boom. We can see now one instead of two member nft one. Cool.
01:32:07.530 - 01:32:50.988, Speaker A: Now let's finally take care of our gallery. To go fast, let's use a UI component of the SDK, the NFT metadata renderer, which is going to help us render our nfts by resolving the metadata in a standard format. But before we do that, just to have a bigger gallery, let's claim our third NFT. So in my set claim phase, I'll change the token id to two. Nothing else in this function needs to change for our purpose. And in the claim NFT function, same thing. Token id equal two.
01:32:50.988 - 01:33:27.550, Speaker A: Let's save that. Let's set our new phase for member NFT three. Confirm. Okay, now let's claim it, confirm again and there it is. Now we own all three nfts. Now back to the UI component. We can copy the third web NFT media and import it.
01:33:27.550 - 01:34:29.872, Speaker A: Then still in the react SDK under NFT and edition and then read hooks. You'll see own nfts. We can use this hook to get the own nfts for a specific NFT contract and wallet address. Okay, so let's copy use own nfts and add it to the imports. Then I copy this line and I'll past it right here. I'm not going to use those flags right now. NFT drop is actually our edition drop and I put my wallet address here and then to display the gallery.
01:34:29.872 - 01:35:06.010, Speaker A: I'm just going to copy this whole block and past it below. Claimed nfts is now own nfts. Let me just change the styling a little bit. This is going to have the style cards. I'll add the style cards in my second div as well. I'm going to change h three for h one. And I'm going to change supply for quantity owned.
01:35:06.010 - 01:35:41.780, Speaker A: Now we can use the UI component third web NFT media. The metadata is NFT metadata. And I also have a style for that image. Let's save that and look at that. Our three nfts. Nicely rendered. Very nice.
01:35:41.780 - 01:36:19.040, Speaker A: Another thing about this UI component is that it removed the complexity of resolving the media type, meaning rendering in a certain way, depending if it's an image or a video or a music file. And so you get a consistent way to render your nfts on your user interface. Okay, the project is done so let's play with it a little bit. What happens if I claim another member? NFT three confirm. And boom, it has been updated. Okay, now let's burn an NFT. Let's go to the burn function.
01:36:19.040 - 01:37:06.072, Speaker A: If I can find it. There it is. Let's burn token one, save it, burn Nft confirm, burn successful. And look at that, it got deleted from our gallery. Nice. Now, I don't know, we could change the background color a little bit. You could go to the styles folder which would be in the repository of course, under home module, for example, for the background I tried to get the third web colors.
01:37:06.072 - 01:38:27.676, Speaker A: Let's see how it looks. Well, it goes from pink to purple, so not too bad. Let's try maybe a bluish color, maybe that one, and maybe a purplish color like that. Let's see. Hey, that's not too bad. Let me claim back the second Nft just to see how it looks with our new background color waste claim Nft here, I'll change two to one claim confirm. Okay, and look at that.
01:38:27.676 - 01:38:46.790, Speaker A: It looks nice with all those colors together. Pretty cool. Anyway, that's it for the project. So try it. Change some things, add more components, use more functions from the SDK, use other contracts as well. We saw they have a list of prebuilt contracts. Have fun with it.
01:38:46.790 - 01:39:24.590, Speaker A: I'll see you in the last video for a recap. Well, if you got that far, congratulations and thank you for watching this course. Hopefully now you feel more confident to read and write smart contracts, especially using third web, which really accelerate the development process. So we hope you now have a better understanding of third web contracts SDK, how to build smart contract with it, how to release and publish your contracts, the different ways of deploying your contracts, and how to use the automatically generated SDK as well. You now have solid bases to work on your dream projects. We'll see you on web three. Take care.
