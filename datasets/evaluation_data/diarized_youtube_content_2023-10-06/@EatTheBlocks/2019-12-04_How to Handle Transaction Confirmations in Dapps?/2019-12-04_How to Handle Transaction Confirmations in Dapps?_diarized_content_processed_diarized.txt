00:00:00.170 - 00:00:22.314, Speaker A: Hey, this is Julian and you're on idoblox. And in this video I'm going to explain how you should handle transaction confirmation in your decentralized application. So this topic is very important for security and very few developers really understand it. So make sure to follow this video. So here is a typical scenario.
00:00:22.442 - 00:00:24.934, Speaker B: So let's say that there is this.
00:00:25.012 - 00:01:18.598, Speaker A: Big trader, so we say a well, in crypto palace, there is this big trader that has a lot of Yas 20 tokens. And he think that this token is going to go down a lot. So this trader is going to want to sell all his token. So he goes to a decentralized exchange and if he send a sell order and he's lucky, so he finds a buyer right away and he offload, for example, his $1 million worth of Yas 20 token. So he's really happy he doesn't have to deal with this anymore. He goes to have coffee, he comes back and then he check his wallet. And then something is wrong because he still sees, he ask 20 tokens what happened? And this is terrible because now the price went down a lot.
00:01:18.598 - 00:01:57.146, Speaker A: So he's 1 million, that became like $500,000. He lost 50%. This is really terrible. So what happened is a chain reorganization. So when you send your transaction to the blockchain, so a miner is going to include it in the block and mine this block. But what happened if you're unlucky? At the same time, another miner somewhere else in the world is maybe mining another block that does not include your transaction. But his block is also going to be broadcasted at the same time as your block.
00:01:57.146 - 00:02:03.122, Speaker A: So two blocks are going to compete in the network. So the Ethereum network will have to.
00:02:03.176 - 00:02:05.906, Speaker B: Decide which block to accept because you.
00:02:05.928 - 00:02:43.282, Speaker A: Cannot have two block at the same height. So it's not like people in the Ethereum network are going to meet and hmm, we have this problem. We need to decide which block we want to keep. It's not like that. It all happened automatically with the Ethereum protocol, one block is going to win over the other one. And so all the transactions that were mined in the block that got discarded, actually it's as if they never happen. So if you're not careful and you send your transaction, you get a confirmation it was included in a block, but you didn't pay attention to what happened.
00:02:43.282 - 00:03:15.974, Speaker A: After a chain reorganization can take place and all the block gets mined on top of the alternative branch. And that's it. Your transaction is not mined. So that's a big problem. So the question is how we can handle this in our decentralized application. So with this problem of chain reorganization, that means that a transaction is never really final. It's not like in a database where you make a change and it's binary.
00:03:15.974 - 00:03:53.318, Speaker A: It's yes or no. In blockchain it's never like this. It's more a matter of probability. So if I send my transaction and there is one block, then there is a certain probability that there will be a chain reorganization. So then if my transaction is in one block but there is another block that is mined on top of it, then I am a bit more sure that there will not be a chain reorganization because now it becomes less likely. And the more block are mined on top of your block, the more sure you are that your transaction is here forever. And it's going to be harder and harder for a chain reorganization to happen.
00:03:53.318 - 00:04:44.134, Speaker A: And at some point it's going to be so unlikely that this chain reorganization will happen that it's almost as good as 100%, but it will never be 100%. By the way, every time you have a block that is mined on top of the other, we call this a confirmation. So one block mine on top of yours is one confirmation, two block, two confirmation, et cetera. So the more confirmation the better. So how can we decide how many confirmation we need for a transaction? Well, we have a problem here because for security purpose it's better if we have as many confirmation as possible. But from a UX UI perspective, it's not really good for a user to have to wait for so long. So we need to make a compromise here.
00:04:44.134 - 00:05:38.166, Speaker A: So for low value transaction it's acceptable to have less confirmation. And for high value transaction we need more confirmation. So visually, how are you going to show this to your user in your decentralized application? So one thing you can do is after a user, click on a button to send a transaction. So you can show a pop up with a confirmation that what just happened. And also you can display in a dynamic way the number of confirmation of this transaction. So you start with one confirmation, then as you receive new block, then it's going to be two confirmations, reconfirmation and for low value transaction you can show it as up to ten confirmation. And when you reach ten confirmation, it means that you have a 99.99%
00:05:38.166 - 00:06:23.078, Speaker A: probability that the transaction is final. So it's good enough for low value transaction. And in terms of time, it's going to last two and a half to 3 minutes. Knowing that a bulk time on Ethereum is roughly between 13 second to 17 second. And for higher value transaction you can actually follow the example of some exchanges that require up to 200, 300 or even 500 confirmation for very large order, very large transaction. Yeah, so that's a rule of thumb. So how can we handle this in Webster? Can we have this transaction confirmation in an easy way?
00:06:23.164 - 00:06:23.510, Speaker B: Yes.
00:06:23.580 - 00:06:25.142, Speaker A: And I'm going to show you this.
00:06:25.276 - 00:06:27.974, Speaker C: So this is documentation of Webstery to.
00:06:28.012 - 00:06:29.526, Speaker A: Show you how you can send a.
00:06:29.548 - 00:06:41.622, Speaker C: Transaction to your smart contract. By the way, if you don't know what is Webster, you can check my other video on Webstery link in the description. So here you have your Webstery contract instance.
00:06:41.686 - 00:06:45.146, Speaker D: So mycontract then methods. My method.
00:06:45.178 - 00:06:47.194, Speaker C: So that's how you configure which method.
00:06:47.242 - 00:06:48.762, Speaker D: You want to call on your smart contract.
00:06:48.826 - 00:06:55.646, Speaker C: You give the argument, then you call send. So this is exactly the same thing as for sending a transaction.
00:06:55.758 - 00:06:59.314, Speaker D: And then you have several APIs. So you have the callback API, which.
00:06:59.352 - 00:07:00.690, Speaker A: Is very old school.
00:07:00.840 - 00:07:03.714, Speaker D: Then you have the promise API where.
00:07:03.752 - 00:07:12.086, Speaker C: You can use a, then you can also use async await and the third API is the event emitter and that's the one you need to use if.
00:07:12.108 - 00:07:19.350, Speaker D: You want to have information about the number of confirmation. So with this API, then you call.
00:07:19.420 - 00:07:26.854, Speaker C: The on method and you give it the name of the event you want to lessen for. So you want to lesson for confirmation.
00:07:26.982 - 00:07:32.246, Speaker D: And then you're going to have a callback with the confirmation number and the receipt of the transaction.
00:07:32.358 - 00:07:38.682, Speaker C: So every time you're going to receive a new confirmation, you're going to receive here a new value for this confirmation.
00:07:38.746 - 00:07:40.874, Speaker D: Number and inside your callback.
00:07:40.922 - 00:07:43.326, Speaker C: Then you can display this information to.
00:07:43.348 - 00:07:47.806, Speaker D: The user by for example, updating a pop up with number of confirmation as.
00:07:47.828 - 00:07:50.046, Speaker C: I mentioned before, and this is going.
00:07:50.068 - 00:07:53.578, Speaker D: To fire until the 24th confirmation.
00:07:53.754 - 00:07:55.366, Speaker B: All right, so that's it about how.
00:07:55.388 - 00:08:18.466, Speaker A: To get transaction confirmation with Webster. If you want to know more about this topic, you can check out this article of Vitalik Butchering. And if you have any question about how you should handle this transaction confirmation in your DAP, ask them in the comments down below. That's pretty much it for this video. Thanks for watching and I'll see you for another video on blockchain and ethereum. Bye.
