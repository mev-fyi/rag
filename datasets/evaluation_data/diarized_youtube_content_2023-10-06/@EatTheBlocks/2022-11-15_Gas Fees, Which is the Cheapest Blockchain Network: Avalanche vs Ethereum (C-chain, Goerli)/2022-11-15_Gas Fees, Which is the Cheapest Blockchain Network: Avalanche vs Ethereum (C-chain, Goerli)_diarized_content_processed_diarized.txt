00:00:00.250 - 00:00:46.118, Speaker A: Which blockchain network do you think is cheaper to use between Avalanche and the Ethereum network? Today we'll compare the cost of deploying and transacting with a decentralized exchange on the seed chain and the goalie network. Big shout out to cosmic and infuria for sponsoring this video. And with that, let's get into it. If you're new here, I'm Stefan and on it the blocks we help web two developers get into web three. You alright? Let's get a quick overview of what are Avalanche chains and Gorilli first, and then we'll jump straight to the action. So avalanche has three chains. We've got the x chain which is used for ultra fast transaction per seconds of the native token Avax thanks to its directed cyclic graph architecture.
00:00:46.118 - 00:01:46.582, Speaker A: We've got the platform chain or Pchain which is used to secure the network validation and Avax staking. And finally we've got the contract chain or c chain. The c chain is the default avalanche blockchain for smart contracts and defi app. Most avalanche DeFi platforms such as Aave, Trader Joe or banky work on the c chain and are compatible with Metamask. The c chain uses what is called the Snowman consensus protocol, which is more like your typical ordered style blockchain rather than a dag, but still optimized for high throughput compared to the Ethereum network. Now what is goalie? You might have heard about the recent shortage of goalie Testnet eth due to many testnets getting deprecated post merge such as Robstand, Ringby and Coven. Keeping only the goalie and sepolia test network goalie is a proof of authority cross client testnet, which is on its way to merge with the pratter proof of stake beacon chain.
00:01:46.582 - 00:02:13.426, Speaker A: Alright, introductions are done. So now what we're going to do, we're going to go over a couple of smart contracts to exchange some ERC 20s. We'll deploy them to the Ethereum Goalie network as well as the Avalanche Fuji network. We'll build some scripts and finally we'll compare how much was spent on each network to follow along. You can clone this repository. I'll put the link of the repository in the description of this video. Today we'll use truffle.
00:02:13.426 - 00:02:46.420, Speaker A: So if you don't have truffle yet, you can follow the installation guide. Here. You can do NPM or PNpM install truffle or brew install truffle. If you're on Mac next, you can clone the repo and open the project with your code editor, and in the config file you can add or replace the Rinkbe network or the Goalie network. And so here's my config file. Okay, so I have updated the infura URL. I have updated the network as well as the network id, which is now five.
00:02:46.420 - 00:03:30.878, Speaker A: And now let's go to infura to get an endpoint. So when you have created your project on infura, you can create a new key. You're going to choose a web three API and you're going to name your project and then in manage key all we're going to need is the API key. And then back to your code editor you're going to create a on file and under something like infura project id you can pass the key that we just copied. Next you're going to add a mnemonic right here. Those values are going to be used in the truffle config file. We have mnemonic right here.
00:03:30.878 - 00:04:23.370, Speaker A: So create that constant and pass either your private key or seed phrase. For the key, open metamask, click the three dots next to your account name, account details, export private key. Then you enter your password and you copy your private key that you can then pass right here. For the seed phrase, go to settings, security and privacy and reveal seed phrase. Now, side note, if you don't want to deal with all of that, you can also use truffle dashboard, which removes the need to specify your private key and network configs. But if you're not using the dashboard, we're going to need something to get the constant from the data file. So we need to install something called of you can do NPM or PNPM install.
00:04:23.370 - 00:04:56.298, Speaker A: Next, what we're going to do, we're going to go over the contract that we're going to deploy. So we're going to have two contracts, one to create some tokens and one that will work as a decentralized exchange where we can deposit, withdraw and exchange tokens. So our two contracts are going to be the Avax test token and the Dex. So now let's see what we're going to put in the token contract. First I specify the solidity version and license. Then I import the base ERC 20 contract from open Zeppelin. Then I create my contract which inherits from the base ERC 20.
00:04:56.298 - 00:05:47.450, Speaker A: And finally, in the constructor, I'll have the name of the token, the symbol, the owner, and the amount of tokens that I want to create. Okay, let's save that. Next, let's go over the Dex contract, we're going to have a few state variables to store the amount of tokens minted, the liquidity for each depositor, and instantiate our custom token. We've also got a few events that will be emitted when we swap our tokens. We've also got a few events that will be emitted when we swap our tokens and provide or remove liquidity. And we'll instantiate the ERC 20 contract at deployment in the constructor. Then we'll add an init function so we can initialize the Dex balance, the treasury, if you will, with a certain amount of our custom token transferred from the ERC 20 contract.
00:05:47.450 - 00:06:44.506, Speaker A: Then we'll have a function to return the current price of our pair of tokens based on the classic a times B equal k formula, and a 3% platform fee applied, hence the 997. Then we've got a function to exchange ethers for our custom token, which uses the price function that we just saw with the eth balance of this contract minus the amount of ETH to swap. Okay, that's for the X reserves and how much of the custom token this contract possess for the Y reserves. Then we do the swap and emit the event that the swap was successful. Then we'll have the function token to eth that does just the opposite. We check the conversion rate, we transfer the ERC 20 to the deck from the user balance, we send the Eth equivalent to the user, and we emit that the operation was successful. Then our two funnel functions, very classic.
00:06:44.506 - 00:07:18.610, Speaker A: One to deposit the pair Fuji Avax and ETH to the pool, and one to withdraw that pair. Okay, now let's get some funds for the deployment so you can go to faucet Avac network and add your metamask address. Okay, now let's deploy our contracts. The deployment script could not be more straightforward. We import both contract artifacts and we deploy them. Last look at the config file before we deploy Gorelin network id five. That's fine.
00:07:18.610 - 00:08:00.180, Speaker A: Fuji network id 43 113. That's fine. Okay, now let's compile and deploy our contracts onto the Fuji network. So now what I want to do now, copy the VAx test token contract address. Then in your data file can add that right here. Same thing for the Dex. Copy the contract address and pass it right here.
00:08:00.180 - 00:08:36.290, Speaker A: And public address is your metamask address. Then we can also pass the DeX contract address to avalanche testnet Explorer, snow trace. Pass the address right here. And there's a contract on the Fuji network. And so far we spend $1. Next, here's what we're going to do. We're going to approve the DeX, meaning we give the DeX contract permission to spend up to a certain amount our Fuji Avax token.
00:08:36.290 - 00:09:07.830, Speaker A: Then we will initialize or bootstrap the DeX contract with some liquidity. And the reason is because I'm going to be the first provider. This action will set up the initial price of the tokens in the pool. Then we'll do an actual deposit of liquidity based on the ratio that we just set up before. And finally, we'll swap some eth for some Fuji evacs. Okay, let's go over the script to do the approval. So, first we get our environment variables and the contracts compiled.
00:09:07.830 - 00:09:40.658, Speaker A: We instantiate each contract with their ABI and address. And then here's when we do the main part. We set up the method that we want to call. We want the approved method from the ERC 20 contract, with the Dex contract address and the amount that we authorize the deck to spend, which we set to 10,000 tokens. We then send the transaction with the setup we just did with the sender being our metamask address account. Zero in this case. Then we get the receipt that contains the data from the approval event coming from the ERC 20 interface.
00:09:40.658 - 00:10:22.062, Speaker A: So we get the event name, the owner address, the Dex address, and how much was authorized. And finally, a couple of function calls to double check our test avax balance and the amount that we authorized the Dex to spend. I'm using PnPX, but you can just use NPX, truffle exec, the path of the script, and then the network. Let's run that. And here's our receipt. Our balance is, we successfully allowed the decks to spend 10,000 ethers. Now, if we go back to snow trace and we passed our metamask wallet address, you can see the last transaction right here when I called the approve method.
00:10:22.062 - 00:10:39.766, Speaker A: And that cost us zero. $3. All right. Okay, cool. Now let's initialize the liquidity pool. So, let's go to the init GS file. So, same as before, we get our environment variables plus the contracts.
00:10:39.766 - 00:11:11.410, Speaker A: Then we set up the init method with contracted methods init, which will create a onetoone alignment, meaning one is can be exchanged for one tavax and vice versa. We then send the transaction. We'll display the network transaction hash and gas used. And finally, we'll call the get liquidity method to verify if the new liquidity has been set correctly. So let's execute that. So NpX truffle exec, the path of the inix Dex file and the network. There you go.
00:11:11.410 - 00:11:37.642, Speaker A: And we can see the transaction hash and the current liquidity of one tavax. Nice. Let's check it out on snow trace if I refresh. And there you go, the init function, $4.7. All right, at the end we'll sum all of that. Okay, so now let's deposit the pair tavax eth to the deck liquidity pool. As usual, I get my environment variables and contract code.
00:11:37.642 - 00:12:05.918, Speaker A: Then I call the deposit function with a value of one to deposit one tavax and one eth. And we console log a few things, like the event, the liquidity provider, how much tavax was deposited and how much eth was deposited. Let's run that same as before. NPX, truffle exec, deposit LP, and the network. All right, everything went smoothly. Finally, let's swap some tokens. Let's look at the swap eth for tavac script.
00:12:05.918 - 00:12:34.442, Speaker A: Okay, so our usual boilerplate. And let's exchange one eth for one tavax. So this time we call the Eth two token function with a value of one. So what happens here? The Dex gets the ether balance, the tavax balance. It calculates how much tavax should be given to the user and call the tevax contract to do the transfer. Okay. And then we'll display the event name, the user address, the transaction details, how much ether we put in, and how much tavax we receive.
00:12:34.442 - 00:12:57.302, Speaker A: We'll also check the Dex liquidity, the balance of our main account, and the balance of the test Avax token that remains. So let's run that. And there you go. You can see that the input was one e and in return we get one Avax deducted of the platform fee. So we get 0.7 roughly. We can also see my ETH balance, 1.88,
00:12:57.302 - 00:13:30.154, Speaker A: and the amount of tavax available. And so now if we look at our wallet address on snow trace, and we take all the gas used from the beginning, and we take all the gas used from the deployment to the swap. And so we end up with zero eight gas used on the Fuji network. And at the end, after we deploy and transact on the goalie network, we'll see how much it really cost on each network. So let's redeploy and re execute all scripts. Let's get some ETH first. Next, we're going to need a faucet.
00:13:30.154 - 00:14:09.600, Speaker A: So for example, you can use this one at paradigm xyz. You're going to need to sign in with your Twitter account, or you can use the chainlink faucet. Once you get your test Eth, you're ready to redeploy the contracts. Okay, so let's redeploy our contracts, but this time on the goalie network. Okay, so it took at least three big minutes to deploy on the goalie network compared to a few seconds on the C chain. Anyway, now let's get our ERC 20 address. And then in my diet all file, I'm just going to replace this address right here.
00:14:09.600 - 00:14:35.962, Speaker A: Same thing for the Dex. Take this one, and I'm going to replace that one. Save. All right. Okay, now let's approve the decks, but this time on the goalie network. Let's go. Okay, good.
00:14:35.962 - 00:15:01.618, Speaker A: Now let's initialize it. Now in the init decks script. Obviously, we're not going to initialize with one ether. It's going to be more something like zero one, change there and there, save this. Then let's execute that. Now let's make a deposit. Same thing in the deposit LP script.
00:15:01.618 - 00:15:24.038, Speaker A: Not going to deposit one ether one. Let's execute that. Okay, we deposited zero one of our custom token and zero one. And finally, let's swap in the swap eth for Tavac script. Same thing. I'm just going to switch for 0.1 and I'll deploy that script on the goalie network.
00:15:24.038 - 00:16:07.802, Speaker A: All right, we deposited zero one ETH and we receive zero, zero six of Tavax. Our ETH balance is now 0.1. So I've already lost two third of my goalie tested balance, which, if I recall, was something like 0.3. So now, same thing as earlier. If I take all the transaction fees, this is what we get. We can see a dramatic difference between the two networks. The total cost for deploying the contracts, approving the decks, initializing the pool, depositing in the pool, and swapping on the avalanche seed chain would cost us $1.92
00:16:07.802 - 00:16:49.046, Speaker A: today. While on the Ethereum network, it would cost you $269. Now, a couple of days before, when I was testing all of that, the total cost on the C chain was almost $30, and the cost on the Goldie network on Ethereum was $68. So a less dramatic difference. But still, the Avalanche C chain is a lot cheaper compared to the Ethereum network. Now, the merge happened very recently, so obviously for the gas cost of Ethereum to go down, we'll have to wait a little bit longer, but, wow, really big difference. So there you have it.
00:16:49.046 - 00:17:28.450, Speaker A: We have successfully created, deployed and transacted with a Dex using a custom token, and we compare transaction cost on the Avalanche C chain and goalie. Now, as I said earlier, it has become harder to get a decent amount of goalie ETH nowadays. So don't let your ETh in the DeX, withdraw your ETH or implement a self destruct or whatever, but get it back. And if you have some extra eth that you won't use, send it back to the faucet at that address. Thank you for watching. Thank you to costancies and infuria for making this video possible. Let us know in the comment section what you think about those costs, and with that, I'll see you in the next one.
00:17:28.450 - 00:17:28.750, Speaker A: Ciao.
