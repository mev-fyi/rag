00:00:00.330 - 00:00:19.790, Speaker A: If you create and sell an NFT, you can make money one time. But it's also possible to build a system of long term passive income for each future sales. In this video, we're going to build an NFT with building royalties by using solidity. If you are new here, I'm julian, and on etherblocks I teach blockchain development.
00:00:23.810 - 00:01:01.482, Speaker B: So let's dive into the code of our royalty NFT. So I'm not going to explain what's a basic NFT, but we were going to focus on the royalties feature. And the basic idea is that every time someone transferred the NFT to someone else, this person will pay some money to the artist that originally created the NFT. So here, this is the code of our project in the GitHub repo of itnoblox. And this time I've used the hot hat framework. It's becoming more and more popular. So first, let's have a quick look at the dependencies of the project in package JSON.
00:01:01.482 - 00:01:34.010, Speaker B: So here we're going to use open zeppelin contracts for the ES 20 of the royalties, and after these are the development dependencies that you're going to find in most hot hat project. So we have hot hat itself. Ethers is to communicate with the blockchain that's basically an alternative to web three. These three dependencies are for testing, and this one is to connect ethers to hard hat. Okay, so let's go back to the root folder. We're going to go first to the contracts folder. So in a hot hat project, that's where you put your smart contract.
00:01:34.010 - 00:02:23.254, Speaker B: And here we're going to go in NFt Sol. So we're going to use the latest version of three T 0.8.6 and we're going to import the ES 721 implementation of open ziplink as well as the interface of ES 20 in order to manipulate ES 20 for the royalties. And so we declare our NFT smart contract here and we make it inerate from ES 721 of open ziplink so that we quickly create our 721 token and we define a few variables. First, the address of the artist who created the NFT, then the address of the token used for the transaction fee for each royalty. Then which amount of token we're going to pay in each royalty. And here a mapping of addresses to boolean values.
00:02:23.254 - 00:03:15.302, Speaker B: That's going to be a list of addresses that don't need to pay the royalty fees like the artist, for example. And so here in the constructor. So that's the function that is called. When we deploy the smart contract, we pass as argument the address of the artist and the detail for the royalties of the address of the token and the amount. And here we call the constructor of ER 721, we pass the name of the NFT, then the symbol of an NFT, and after we're going to instantiate different values, so the address of the artist, transaction fee token, transaction fee amount. Then we put the artist in the excluded list mapping so that the artist doesn't have to pay the royalties to himself, otherwise it doesn't make sense of course. And then we're going to mint an NFT with an ID of zero and send it to the artist.
00:03:15.302 - 00:03:56.038, Speaker B: So this is mainly for the purpose of our test, but of course in your NFT you can have your own logic for minting NFT. And after, so we have a function to update the excluded list mapping. So for example we can add addresses of exchanges. And here, security check, we make sure that only the artist is able to call this function, otherwise anybody can exclude themselves. And so here with the same function we can add or remove someone. So you add someone by passing true here and you remove someone by passing false. And after we're going to override the transfer function of ERC 721.
00:03:56.038 - 00:04:39.670, Speaker B: So this function, transfer from, save transfer from and its variant here with another set of argument. These ref function are already defined in the ER 721 implementation of open ziplink. But we are going to override them to put the royalty logic, and we can do this because they are declared as virtual in open ziplink. So in order to override them, basically we define the same function signature. So the sending address for a transfer, the recipient and the token ID of the NFT. And here we use the override keyword to tell to solidity that we want to override the implementation of the child contract. Otherwise solidity is not going to let us do this.
00:04:39.670 - 00:05:13.998, Speaker B: And so here, basically I copy pasted what we have in open zeppelin and I added the extra stuff that we needed. So first we make sure that the sender is allowed. So either this is the owner or this is someone who has been approved then. So this is the part that is custom for the royalty system. So if the sender is not in the excluded list, we are going to pay the transaction fee and we specify the from address. And finally we proceed to the transfer here. So underscore transfer.
00:05:13.998 - 00:06:06.542, Speaker B: This is provided by Yasi 721 of open zeppelin. So I'm going to explain after pay transaction fee, because this function, we define it in our contract. And after we have variation of transfer from, so we have a safe transfer from which basically check that the recipient address is able to handle Yasi 721 token. This is to avoid lock tokens. And we have a variation of safe transfer from where we also pass some additional data here. And again here you have the royalty system. And so here this is the function that we created to implement the royalty system to recreate a pointer to the ERC 20 of the royalty after we call transfer from, and we're going to transfer from the sender to the artist for the amount that was specified in the constructors.
00:06:06.542 - 00:06:51.482, Speaker B: So here there was a choice to make. First, I tried to implement the royalty system with ether, but the problem is that if you want to do this, you need to add the payable keyword to the different transfer function here, save transfer from these two function and also transfer from. But because the original implementation of openzepling doesn't have the payable keyword, when you override their function, you cannot put payable here in your override otherwise, so it's not going to accept it. So in order to circumvent this limitation, I implemented the royalty system with an ES 20 token. And for this we don't need any payable keyword. Okay, so that's it for the main contract. And we also have a mock token.
00:06:51.482 - 00:07:24.534, Speaker B: So this is only for the test. And here this is a very simple Es 20 token. And in a constructor we send 1000 token to the deployer of the token. Okay, so that's it for the smart contract. And next we're going to do the testing. So for the test we need to go in the test folder and I created the test file here, NFt Js. So first we extract the expect object from the child library.
00:07:24.534 - 00:07:56.206, Speaker B: That will allow us to do some assertion very easily. So we define a describe block that's going to wrap all our test. And here we define a couple of variable that we're going to use in our test. And here we define on the transaction fee is going to be one token. So in our example token we use 18 decimal. So that means one token is actually equal to ten power 18. And so to do this number easily we use the ethers library.
00:07:56.206 - 00:08:35.198, Speaker B: So here, don't be fooled by the fact that here this is ether, this actually means ten power 18. Okay, so let's scroll down and here, so we have the, before each function, it's going to be run before every test. So first we get a couple of addresses that will be generated by hot hat. So if you are used to Webster, this is the equivalent of Webstery ETH getaccounts. And so we are going to transfer the NFT between the artist and the owner and do our test like this. And so here we get the token contract. So in truffle this is equivalent to artifacts require.
00:08:35.198 - 00:09:13.574, Speaker B: And after we deploy the token that will be used for the royalties, we wait for it to be deployed. And so at this point the admin address has 1000 token and then we're going to send 500 token to owner one and another 500 to owner two. And after we get the NFT contract, we deploy it. And for the arguments we pass the address of the RT, the address of the token, and the transaction fee amount. That is one token basically. And after we have our first test. So here we're going to test that he transferred the NFT and he paid the royalty.
00:09:13.574 - 00:09:54.726, Speaker B: So we define a couple of variable the owner of the NFT, the token balance of the sender and the token balance of the artist to test the royalties. So here we connect our NFT pointer to the artist. So that means this is going to be the artist that will sign this transaction. So in Webstery you use the from field when you send a transaction, when you want to change the sender, but with ether you have to do this. Then we're going to transfer the NFT from the artist to owner one and we specify the token ID. So that's zero because a single NFT contract can have several NFT inside. And after we check that the NFT was transferred.
00:09:54.726 - 00:10:37.090, Speaker B: And so for that we call the owner of function on the NFT contract. So this is defined by the ERC 721 implementation of open Zeplin, we specify the token ID and we expect the owner of the NFT to be owner one. And after we're going to do a transfer from token from owner one to owner two. And this time we're going to test the royalties as well. So we didn't test the royalty before because the artist is in the excluded list, he's not supposed to pay royalties. And that makes sense because the artist is not going to pay royalties to himself in this case. So here we connect the token to owner one and we're going to approve the NFT smart contract to spend the royalties.
00:10:37.090 - 00:11:19.494, Speaker B: After we connect the NFT object to owner one, we call transfer from. So from owner one to owner two for the token ID, Zero. And after we read the value for the owner of the NFT and we also get the balance for the sender of the NFT so that's owner one and we also want to get the token balance of the artist. And so first we expect the NFT to have been transferred to owner two and we also expect the royalties to have been paid. So here the sender, initially it had 500 token. It paid one token for the royalties, so now it should have 499. And for the artist it had zero token to begin with.
00:11:19.494 - 00:11:52.878, Speaker B: So now it should have one token. Okay, and next test we going to make sure that we don't pay royalties if we are in the excluded list. So first we transfer the NFT from the artist to owner one. And here we're going to check that the balance of the artist is zero. So nothing was taken from the artist and nothing was sent to the artist. And after we're going to add owner one to the list of excluded addresses. So owner one is not supposed to pay the royalties in this case.
00:11:52.878 - 00:12:33.142, Speaker B: Then we connect the NFT object to owner one. We transfer from owner one to owner two. And then we going to test that the token balance of the sender and of the artists are unchanged. So for the sender it should remain at 500 token and the artist is supposed to not have received anything. All right, so next we're going to test an unhappy path. So you should not transfer an NFT if we don't have enough royalties. So first here we're going to transfer the NFT from the artist to owner one, and after we're going to transfer from owner one to owner two, but without enough token to pay for the royalties.
00:12:33.142 - 00:13:24.030, Speaker B: So here we connect the token object to owner one and owner one is going to transfer all of his token to owner two so that in the end his balance is zero and he doesn't have enough to pay for the royalties. And so here we approve the token to be spent by the NFT contract as if we had enough token after we connect the NFT to owner one. And here we are going to try to call transfer from owner one to owner two, but it's going to revert because it's going to hit the required statement of ERC 20. And so this is the reason of the failure in ERC 20. ERC 20 transfer amount exceeds balance. And so you can see that with hot hat you can test transaction failure very easily with this notation. With revert with here.
00:13:24.030 - 00:14:03.882, Speaker B: And so here we rely on the required statement of ES 20 to do our test. But if we wanted, we could also add our own required statement with a more specific error message. So not enough token to pay royalties. For example, so that's also a possible alternative. And then the final test, we're going to make sure that we can add or remove from the excluded list. So here we connect the NFT object to the artist. We set owner one in the excluded list, and then we read the value of the excluded list mapping for the owner one, and we are expecting a true value.
00:14:03.882 - 00:14:25.570, Speaker B: And then we set it to false. And we read the value again of excluded list, and in this case it should be equal to false. And finally, we try to call set excluded, but from someone who is not the artist, for example, owner two. And so here it's going to hit our required statement, which is artist only.
00:14:25.720 - 00:14:35.794, Speaker A: Now you know how to implement a royalties system for NFTs. What we have built is quite basic, but you can add other features. For example, instead of a seller paying.
00:14:35.832 - 00:14:37.822, Speaker B: The royalties, it could be the buyer.
00:14:37.886 - 00:15:11.614, Speaker A: You could also make the royalties a percentage of the transaction value instead of a fixed value. You could also make the first few sellers receive a part of the royalties to give them an incentive to make the market more liquid. That's what the NFT marketplace super rare did. For all these changes, it's going to be much easier to implement them at the level of the NFT marketplace instead of contract of the NFT. The role of NFT is growing rapidly, and as a blockchain developer, it's a good idea to specialize in this niche. One of the most recent trends in NFT is that it start to take.
00:15:11.652 - 00:15:15.802, Speaker B: Some inspiration from Defi. That's what we see with NFT flash loans.
00:15:15.866 - 00:15:22.270, Speaker A: This opens up completely new possibilities for developers. And if you don't understand how it works, check out this video.
00:15:22.340 - 00:15:22.940, Speaker B: I will see you there.
