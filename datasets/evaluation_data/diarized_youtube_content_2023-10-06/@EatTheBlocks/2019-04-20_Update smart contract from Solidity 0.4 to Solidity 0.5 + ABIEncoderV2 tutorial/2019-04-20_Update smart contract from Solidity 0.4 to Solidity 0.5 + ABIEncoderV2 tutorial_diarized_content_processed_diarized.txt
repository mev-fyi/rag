00:00:00.410 - 00:00:01.726, Speaker A: In this video we are going to.
00:00:01.748 - 00:00:09.662, Speaker B: Learn how we can update a solidity smart contract to Solidity Zero Five. Solidity was updated to version Zero five.
00:00:09.716 - 00:00:11.294, Speaker A: At the end of last year and.
00:00:11.332 - 00:01:11.246, Speaker B: There were a couple of breaking changes compared to Solidity Zero Four. A lot of the tutorials that you will find available on Internet show you how to code smart contract with the old version of solidity, so it's very useful to learn what are the difference is with the new version of solidity you will also learn about experimental features of solidity that are enabled with the ABI encoder V two pragma statement and this allow you to simplify a lot your solidity smart contract. I really wish that someone showed me this when I started learning solidity, so I hope that you'll find it really valuable. The smart contract that we will use as an example is the smart contract in the to do list Dapp tutorial. If you want to have access to the source code of the updated smart contract, you can become a free member of Edoblox Pro by going to this address and then going to the sign up page. And you only need to put your name and email to create an account. Alright, so I've opened the solidity smart contract of the Todo list DAP tutorial and I'll give you a very brief.
00:01:11.278 - 00:01:13.026, Speaker A: Tour of the smart contract in case.
00:01:13.048 - 00:01:42.038, Speaker B: You haven't followed the to do list tutorial. So first you notice that the pragma statement mentioned solidity 0.4. That's an old smart contract. We need to update it to solidity 0.5. So first we define our to do smart contract and what's important to understand is that this smart contract is going to implement a to do list on the blockchain. So here we define a task struct that will allow us to represent tasks in our smart contract. So this task struct has several fields.
00:01:42.038 - 00:02:11.602, Speaker B: So each task has an ID, a date. You can store a content string, you can store a string for the author. Then you have a boolean field to show you if the task is done or not. And also you can see the completion date of a task, the ID of the nest task to create. Then you have an array of task IDs and then you have a mapping of integer to task that act as a container for all our tasks. Okay, so let's scroll down. So here we have an event for every time we create a task.
00:02:11.602 - 00:02:35.162, Speaker B: We also have another event for every time the task status is toggled. So here in the constructor. Then we instantiate the last task ID. Then we have a function to create new task. Then we have a function to have a list of all the task IDs. Then this is a function that we used in development before, but we're going to get rid of it. Then we have a function to get an individual task.
00:02:35.162 - 00:02:57.730, Speaker B: We also have a function to toggle the done status of a task, and we have a modifier that allows to know if a task exists or not. So that was a very brief tour of the smart contract. If you've never followed the todo list tutorial, you can check it out on my YouTube channel and you will become more familiar with this smart contract. So we are going to update this to solidity 0.5.
00:02:57.800 - 00:03:32.362, Speaker A: So the first thing that we're going to do is to update our pragma statement. So it's not 0.4.24 but it's going to be 0.5.0. So I know that at the time of this recording there is a newer version of solidity. I believe at this time it should be 0.5.6. But it actually doesn't really matter that we just use 0.5.0 because solidity adopts the so called semantic versioning, which means that as long as you have the same middle numbers here, basically everything is compatible.
00:03:32.362 - 00:04:05.180, Speaker A: So 0.5.10, .5.2 they're not going to be any breaking change. So let's just use the default version of solidity ship by truffle 5.0. Next, we're also going to add another pragma statement to use some experimental feature of solidity that are very very convenient. That going to help us to simplify our code a lot. So this pragma statement is called pragma experimental ABI encoder V two.
00:04:05.180 - 00:04:46.550, Speaker A: So just one word of caution here. Solidity is going to give you a warning when you compile a smart contract with this pragma statement. It's going to tell you this pragma statement use some experimental feature that should not be used in production. So for production smart contract, do not use this pragma statement, but for your own development, for just pet project or just for learning. This is totally valid. And by the way, this is very likely that in the next version of solidity, the thing that are enabled with this pragma statement will just be enabled by default in the next version of solidity. So you're not wasting your time learning these things.
00:04:46.550 - 00:05:25.762, Speaker A: All right, so first let's see what are the changes that we need to do because of the upgrade to solidity 0.5.0. So let's scroll down and let's see what we have. So first here in the constructor function, well, we already have the constructor keyword, but if you see some older solidity code of like for example solidity 0.4 point something, then you might see a constructor like this. So function plus the name of the smart contract. So in our case it's going to be function to do and then parentheses like this. So if you see this solidity 5.0
00:05:25.762 - 00:05:57.006, Speaker A: is going to refuse to compile this. So you need to replace this by the constructor keyword that basically avoid to have to repeat the name of the smart contract. Here it's just the keyword constructor. Next in the create task function. So here in the arguments, if you just leave things like this, solidity 5.0 is going to complain because now we need to specify the memory location of non scalar data. So what is this weird thing? Non scalar data.
00:05:57.006 - 00:06:37.766, Speaker A: So scalar data, you can basically consider that it's equivalent to simple type like integer boolean value and bytes with the size. So bytes 32 for example, or bytes 16, all the other value are non scalar value because they are some sort of container. So a string for example is a container. It might seem a little bit surprising to consider this, but basically a string is an array of byte. So the same thing apply for array of all sorts. You also have to specify the memory location. So for public function here, the memory location that you want to specify for string is memory.
00:06:37.766 - 00:07:16.882, Speaker A: So that means that the argument that we are giving to this function are just going to be copied in memory, but it's going to be a temporary memory location. Nothing's going to be written to the blockchain. However, since we are refactoring our smart contract, the public keyword of this function is not restrictive enough. So there is another keyword which is more restrictive, which is called external. So external means that this function can only be called from outside the smart contract, but not from the smart contract. So generally speaking you want to be as restrictive as possible. So we're going to use x null, and since we are using x null, we actually cannot use the memory location.
00:07:16.882 - 00:07:49.714, Speaker A: The memory location is only for calls within the smart contract, but not for calls from outside the smart contract. So we can use another memory location, and in this case it's going to be a memory location called call data. We're going to do the same thing for the other string. And since our lines start to be a little bit long, then we're going to put everyone on its own line so there is enough space for everybody and everybody is happy. Yeah. Okay. It's much more tidy like this, by the way.
00:07:49.714 - 00:08:07.190, Speaker A: You know what, let's also do this for this event here. Everybody on his online. It's much more consistent, much more beautiful. Makes Julian happy, makes everybody happy. And here the same. Okay, cool. So back to our create task function.
00:08:07.190 - 00:08:35.242, Speaker A: So another thing that you might have to change on old smart contract is basically on old smart contract you can emit an event just by using the name of the event but without the emit keyword. But in solidity 0.5.0 this is not going to work. You do have to use the emit keyword. So that's it for the moment. Get task Ids. Actually we're going to get rid of this, but I'm going to do this just after get task fixtures.
00:08:35.242 - 00:09:08.838, Speaker A: So this is something all that we used in the first step of this long series, but now we absolutely don't need it anymore. So let's get rid of it. Get task. We're going to get rid of this, but I'm going to do this after also then the toggle done function. So we're going to also change the public keyword to external like we did before for the create task function. And we're also going to put everybody on its own line. And actually I want external before like this just to be consistent.
00:09:08.838 - 00:09:45.794, Speaker A: Okay. And next line, we are creating a pointer to a task using our task array. But as I mentioned just before, solidity 0.5.0 wants to know what is the memory location for all the non scalar type. And a struct is definedly a non scalar type. So what do you think is the memory location here? Is it memory? If we do this, solidity is going to create a copy of what we have in storage and create a copy in memory. But this is going to be only temporary.
00:09:45.794 - 00:10:18.660, Speaker A: And after, when we use this pointer, all the change are not going to be persisted to the blockchain, but it's just going to change this temporary object in memory. And after this function finished executing, nothing has changed in the data of our smart contract. So that's not what we want. So we want a pointer to the actual blockchain. So we don't want memory here but we want storage. Okay, and finally we have a problem here with our event. We're not using the emit keyword so let's use it.
00:10:18.660 - 00:10:47.382, Speaker A: All right. So we are done for the update because of the new version of solidity. But next we're going to do another update. So for this pragma statement here, Abi encoder v two. So why I use this pragma statement? So let me explain to you. So currently, what do we have in a smart contract? So let me scroll down. So in order to get all the tasks, basically we do something quite complex.
00:10:47.382 - 00:11:24.642, Speaker A: So first we have this function, gettaskids, that returns an array of all the task IDs. So that's an array of integer. And then once the front end has this array of integer, it's going to call the get task function that return a single task for a specific ID given as argument. And basically it's going to call this function for all the task IDs. So if we have ten task ID, then the front end is going to call this function ten time. If we have 100, it's going to call it 100 time. It's not very efficient and also it makes everything more complicated.
00:11:24.642 - 00:12:03.490, Speaker A: And the whole reason why we did this is because in solidity without the experimental pragma, we cannot return an array of tract. So we cannot return an array of task, for example. But using this experimental pragma statement, we can do it. So that changes everything. So we can actually get rid of these two function here. And we're going to have only one function that is able to return all the tasks. So function get task, it's not going to take any argument and so it's going to have a couple of fire.
00:12:03.490 - 00:13:01.522, Speaker A: So first this is going to be an external function. Then we use the view keyword just to explicitly mention this does not modify the blockchain and only returns data. And then let's specify the return type so returns and it's going to return an array of tasks. And here we also need to specify the memory location exactly like we do for argument. So this is going to be memory and we open the curly braces. So can we just do something like return task? Will this work? Well, it won't because task is a mapping of integer to task struct a little bit like a key value object in JavaScript, but we cannot return a mapping in solidity even with the experimental statement. Actually, the smart contract itself does not know what keys are in the mapping.
00:13:01.522 - 00:13:34.130, Speaker A: It only store the data of the mapping. But it's you, the developer, to know what are the keys. Or you can store the keys in an array, for example. So what we want to do is create a for loop and fetch all the tasks in the task mapping and put this task in an array and return this array of tasks. So let's try to do this. So for u int and we define a variable called I. So start at zero and then until I is inferior to.
00:13:34.130 - 00:14:21.166, Speaker A: So here let's just create a variable that does not exist yet. So max task id and then we increment I. And so inside what we want to do is create a task truck for task id equal I and put this truck in an array of task. So we want to do two things. Okay, let's delete this. So first of all, how do we know what is max task ID? So let's see what we have in our variable. So we have a variable that is called last task ID and this variable basically going to see how it works in the create tasks function.
00:14:21.166 - 00:14:52.874, Speaker A: So every time we create a new task, this variable is incremented. So we start last task ID is zero. And when we create our first task then we increment it by one. So now last task ID is one and we have one task in our smart contract. Then if we call create task another time, then last task ID will be equal to two and we'll have two tasks. So basically we can rely on the value of last task Id to know how many tasks we have in our smart contract. So let's go back to our get task function and we're going to make use of this.
00:14:52.874 - 00:15:34.322, Speaker A: So instead of mass task id it's going to be last task ID. Okay, so now let's see what we have inside our for loop. So we need to create a task script for the current task ID. So let's reference the task mapping and we're going to pass it I and next we want to put this truck in an array of tasks, but we don't have this array of tasks. So how are we going to do that? Well, we can create an array in memory just for our temporary use in this function. So let's do this. So just above, let's create this array of task.
00:15:34.322 - 00:16:14.142, Speaker A: So first we need to declare its type. So that's going to be a task array like this. Then it's going to be in memory and then we're going to call it underscore task because we do want to shadow the variable task without an underscore. So we use an underscore here and then we're going to instantiate this array. It's a new task and then we need to give it a length and we know that the length of this array is going to be the length of last task ID. So this notation is how you instantiate memory array in solidity. So now that we have this task array, we're going to make use of it inside our for loop.
00:16:14.142 - 00:16:41.290, Speaker A: And so when we grab our task here, we're going to put it this new array that we created. So task. And here we're going to use the same index. This is going to copy a task from storage to a memory location. And after, let me delete this comment. And all we have to do after the for loop is to return the task variable with an underscore. So just to repeat here.
00:16:41.290 - 00:17:15.430, Speaker A: So this underscore task is very different from this non underscore task. So this one here, the normal task is a mapping, so a key value store from integer to task struct. But this underscore task here is an array of tasks and in memory, so you can use exactly the same method to return a collection of data that are stored in a mapping and solidity. All right, so we are almost done. Actually, let me do some reformatting here. Everything should be with the same indentation. It's more clean.
00:17:15.430 - 00:17:47.390, Speaker A: Okay, and let me go at the beginning of our smart contract where we define our variable and actually we don't need this array of task IDs anymore because we simplify the way that we are fetching our collection of tasks. So let's delete this and also let's make sure that we're not making use of it. So let's scroll down. By the way, we also don't need this constructor because the default value of any integer value is zero. So we don't need to be explicit about this. So let's also delete this. Okay.
00:17:47.390 - 00:18:00.502, Speaker A: And in our create task function we're using the task ID array that we don't need anymore. So let's get rid of it and that should be it. All right, that's it for the update to solidity 0.5.
00:18:00.556 - 00:18:17.940, Speaker B: Now you learn a few features of solidity 0.5 and you've also learned how to use the API encoder V two pragma statement gets simplified a lot. Your smart contract if you want to access the source code of this smart contract, don't forget to create your free account on idoblox Pro. And thank you for watching.
