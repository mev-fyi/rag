00:00:00.170 - 00:00:40.470, Speaker A: Hey, this is Julian and you are on idablocks. In this video we're gonna see the ERC one six five standard. So this standard allow a smart contract to tell other smart contract which function it implements. So let's take an example. So here I am in remix and I have two smart contracts, smart contract a and smart contract b. And my smart contract a want to call a funk on smart contract B, but it doesn't know if smart contract B actually has this function. So what ERc one six five offers is a mechanism for B to publish the function it implements.
00:00:40.470 - 00:01:28.762, Speaker A: And a will be able to know in advance which function b implements. So let's start from the beginning, which is how a smart contract can declare that it implements some function. And for that we're going to compute an interface iD. So let's create a function to compute this. So function calculate interface ID doesn't take any argument, public function, everybody can call it and it's going to return bytes four. So each interface id is of type byte four. And if we want to publish that, we implement the foo function, then we're going to return bytes four of k shack 256.
00:01:28.762 - 00:02:11.606, Speaker A: So this function, Kshack 256 calculates a hash and we're going to give it the identifier of the foo function like this. But an interface doesn't have to be restricted to a single function. It can also be an interface for several functions. So if we want to tell to other smart contract that we not only implement foo but also borrow, then we're going to add to our interface another part. So I'm going to copy this thing and paste it here. And the second interface here will be bar for example. So this thing means we implement foo and bar.
00:02:11.606 - 00:02:44.400, Speaker A: So I've used this weird sign here. So that is the operator for the zo operation. So Xo is a logical operator. And you can find the definition here in Wikipedia. But basically the idea is that you'll have some input and output. And if you want your output to be true, then if you have two input, then only one of the input should be true. Here, if you have a and b and b is true, then the output is going to be true.
00:02:44.400 - 00:03:16.346, Speaker A: If a is true but b is false, then the output is going to be true. But all the other cases is going to be false. And you don't need to have just two input, but you can have as many as you want. And so the general rule is that the number of true entry needs to be od. So for example, if we had ABC and all of these entries, all of these inputs are true. Then three is od. So the output is going to be true anyway.
00:03:16.346 - 00:03:59.446, Speaker A: You don't need to understand this in detail. Solidity is going to compute this for you with this operator. And so if you have other function that you want to add to your interface, then you just keep adding with this operator. So actually you don't have to compute this function selector like this with bytes four in ketchak 256. There was a hack to make it easier. So let's declare a variable of type contract b like this. And what we could do is b foo selector and same thing here, b bar selector.
00:03:59.446 - 00:04:57.478, Speaker A: All right, so that's how we compute our interface. So we have our interface, but we need a standard function to publish this interface. So this function is called support interface and it accept as an argument an interface id. So this is external of course this is view, this is just read only and it's going to return a boolean value. And so typically you'll have an internal mapping where you'll have all the interface that you implement. So interfaces and then you'll pass the interface id and then you have your support interface function and then you're done. So that means that in your b smart contract you need a mechanism to first register all the interfaces that you implement.
00:04:57.478 - 00:05:55.440, Speaker A: And in general you can do this in the constructor here without mapping. Then in a constructor we will register our interface like this. And by the way, we need to define our mapping. So this is going to be a mapping of bytes four to boolean value. All right, so here we register our function foo and bar, but we also need to register the support interface so that other smart contract know that b respect the Erc one six five standard. So actually in the documentation of the standard they already give you the interface id for our support interface function. So we can just copy this and oops, here I forgot to set this to true.
00:05:55.440 - 00:06:53.778, Speaker A: And here that means in our interface is mapping that we would add this thing and we'll set it to true. So now let's call support interface from the color contract. So let's assume that contract b is a pointer to a deploy instance of the b smart contract. So then we could call support interface and with the interface that we want to test. So zero x, whatever. And then we could put this in if for example, so if this contract implement this interface, then maybe call function foo or else revert and say contract b does not implement blah blah blah blah blah blah blah. So actually there is a reintrancy vulnerability if you do this because the function foo could call back in your call foo function.
00:06:53.778 - 00:07:35.630, Speaker A: And I will explain this in more detail in another video. So to avoid this we can take advantage of the static call upcode of the EVM. So that's an alternative way of calling other function. And when you call function with a static call, it basically disallow any state changed. And if you want to do this you need to use assembly. And actually in the documentation of Yasu one six five then they talk about this and they actually recommend you a very specific way of calling the support interface function. So if you scroll down then they're going to give you an example.
00:07:35.630 - 00:08:18.602, Speaker A: Okay, so here this is a contract that consume that call another contract. And so here you have a function where we're going to call the interface the support interface function. So first you test if the code smart contract implement the ERC 165 interface and it should return true. Then if this works, you continue to another test. So this time you're going to test that an invalid interface id return false. And finally you're going to test that it implements your interface id. And so here they use this custom function no throat call, so they define it below.
00:08:18.602 - 00:09:23.314, Speaker A: So that's where you do use static call here and here everything is inside an assembly block. So I know that it sounds a little bit scary, but you can just reuse this copy paste it and the only thing you need to know is the address of the contract that you want to call and here the interface id that you want to test and just call this function contract, implement interface and then you're done. By the way, there is really a lot of information to digest about Ethereum tokens. So I've prepared a cheat sheet with all the relevant information about Ethereum tokens and you can get it for free by following the link in the description. So if you write a smart contract that respect the ERC one six five standard, then you can inerate from this smart contract of open Zeppelin and in your constructor. Then you will call the underscore register interface and you will pass it all the interface that you implement. I will do another series just on open Zeppelin and I will show this in more detail.
00:09:23.314 - 00:10:12.046, Speaker A: So Yasi one six five is a good first step in the direction of declaring contract interfaces, but it has some limitation. For example, it's not possible for a regular Ethereum address to declare any interface. So that's one of the reason why the ERC 1820 was created. So ERC 20 builds on top of one six five. So ERC 1820 is really a continuation of the work of ERC one six five and allow for a more sophisticated interface system. And I'm going to show you this in the next video. This is important to understand the standard because in the video after that, I'm going to introduce ERC seven seven and it make use of ERC 1820.
00:10:12.046 - 00:10:14.490, Speaker A: Thanks for watching and see you for the next video. Bye.
