00:00:00.410 - 00:00:33.986, Speaker A: Have you ever heard of sniping boats? They are automating trading script for Defi. Some of them made millions of dollars in a couple of minutes. When a new liquidity pool is deploy, a lot of traders buy your tokens right away which sends the price to the moon. The key is to be among the first buyers and later you can sell the tokens at a higher price and make nice profit. In this video, we are going to code a sniping boat on Uniswap. Our boat will lessen to new liquidity pools and as soon as there is a new one, it will buy some tokens. Hey, if you don't know me, I'm Julian and on it the blocks.
00:00:33.986 - 00:00:35.986, Speaker A: I teach blockchain development.
00:00:36.098 - 00:01:13.614, Speaker B: So this is the code of our Uniswap boat on the GitHub repo of the blocks. So this is in node js and we only have a single dependency to ethers and all the code is in boat JS. So let's see this. So first we import ethers, which is a library to interact with the ethereum blockchain. Then we define a couple of addresses. So first, wrap ether. So Uniswap doesn't work with ether, but it works with a tokenized version of ether called wrap ether.
00:01:13.614 - 00:01:40.682, Speaker B: So it's basically an ES 20 token that is backed by ether. Then these two addresses are two smart contract of Uniswap. So the first one, factory. This is a smart contract that is used when new liquidity pool are created. There is a function that is called create pair on it. And when you call this function, it emit an event. And we are going to listen to this event to detect new liquidity pool.
00:01:40.682 - 00:02:14.822, Speaker B: And after the router smart contract is used to trade on the different liquidity pools, and after the recipient. So this will be the address that received the tokens that we just bought. So this is an address that you need to control, of course. So here you're going to put the mnemonic associated to this address. So this is going to be the first address generated by this mnemonic. Then you're going to need to create a free account on inferra and create an ethereum project. And you copy paste the websocket URL here.
00:02:14.822 - 00:02:45.918, Speaker B: So be careful because we have two different kind of URL, htps and websocket. These are two different things. We need websocket because we're going to listen to events. And so here with this object provider, we connect to the blockchain of Ethereum. Then here we create a wallet object with the ethers library and this will allow us to sign transaction. Then we connect this wallet object to our provider. So now ethers know how to sign transaction.
00:02:45.918 - 00:03:18.502, Speaker B: And after we are going to define a contract object for the factory smart contract. So we need a couple of info. So first we need the address of the factory of Uniswap. Then we need the ABI. So this is a JSON interface that defines the solidity function of the factory contract. So ethers has this nice feature which is called human readable Abi. So you can define the AbI in an array of string here so you don't have to define the whole ABI.
00:03:18.502 - 00:04:11.882, Speaker B: Here, for example, I just put what we are interested in the event, but there are many more stuff in the ABI of the factory contract. Then here we also associate this with the address that we want to use to sign transaction. Then we also define another contract object for the router smart contract. So again we need the address of the router, the ABI. So we're going to need these two function and we also associate this to this account to sign transaction. And after using the factory object, that's where we are going to listen to the pair created event. So that means that a new liquidity pool is created and every time this event is emitted, it's going to call back this function here and it's going to pass it a different field of the pair created event.
00:04:11.882 - 00:05:05.358, Speaker B: So the address of the two token of the pair and also the address of the pair smart contract. So the pair smart contract is basically the smart contract of the new liquidity pool. So after we are going to console log all this info, and after we need to find out if one of the token is wrap ether because we're going to buy the other token using wrap ether. So in most of the market of uniswap, the quote currency is wrap ether, but sometimes it's something else. So for example, if the quote currency is a tether or USDC, then we're not going to be able to do our purchase because our script is only designed to purchase with wrap ether. But you could customize this script to make it a little bit more flexible. So here, if the first token is wrap ether, then the token in is going to be token zero.
00:05:05.358 - 00:05:47.290, Speaker B: So what we're going to buy is the other token. Otherwise, if wrap ether is the other token, then token out is going to be token zero. When you create a new pool on Uniswap, you provide the address of the two tokens and it has its own algorithm to detect what is token zero, what is token one. And after, if none of the token of the liquidity pool is wrap ether, so that means the code currency is not wrap ether. Then we stop here, because with our script we just plan to buy with wrap ether. And after we need to calculate how much of the token we are going to buy. So in the amount in we are going to buy for 0.1
00:05:47.290 - 00:06:14.866, Speaker B: ether. So you can customize this of course, but here we are being pretty conservative. And after for 0.1 ether in input, we want to know what we get as output. So here we used the router and there is a pricing function here, get amounts out, so we pass the amount of token in input, and then we pass the address of the two tokens. So the token we're going to spend token in is going to be wrap ether and token out. This is what we're going to buy.
00:06:14.866 - 00:06:59.170, Speaker B: And then we're going to have an array with the different amounts, and we're interested in the second element of this array, that's the amount of token we're going to get as output. And so between the time when we call this pricing function get amounts out and the time when our trade will be executed, the price on the liquidity pool will have changed. So we need some flexibility. So we are going to specify what is the minimum amount of token that we want as output. And so here it basically means minimum. We want 90% of what we initially saw here with this pricing function, get amounts out. So for that here we calculate 10% of this amount, then we subtract it.
00:06:59.170 - 00:07:46.990, Speaker B: And the reason why we do this complex thing and we cannot directly do amounts one times 0.9 is because this is not a normal JavaScript number. This uses a JavaScript library called big number, because in ethereum we manipulate numbers that are really really big beyond the maximum number that can be represented in JavaScript. So that's why we have to do this indirection here. After we are going to console log the detail of our trade, what's the amount in and what's the amount out? Minimum. And after we are going to send our transaction to uniswap to buy token, and for that we call swap exact tokens for tokens. That means in input we have an exact amount of token, and in output we'll have some flexibility.
00:07:46.990 - 00:08:42.622, Speaker B: So the amount int, that's 0.1 ether and the minimum amount and after we specify the minimum amount of token as outputs. By the way, I realize I've just made a mistake. So here it's not amounts one, but it should be amount at minimum. So I'm going to correct this just after this video and after we specify the address of the token we spend the address of the token we want to buy, then what is the recipient address? And we also need to specify the deadline because it's possible that we send our transaction, but maybe that the network will be clogged and we won't be able to mine our transaction right away. Our transaction can be stuck in the memory pool for several days, and so by the time it's executed we probably won't be happy of the amount at min that we initially specify because the market would have changed a lot. So we also specify a deadline after which the order is not valid.
00:08:42.622 - 00:09:04.550, Speaker B: The deadline is in 10 minutes, so we get the current timestamp with date now, and then we add 10 minutes. So this is specified in millisecond. So this is 1 second times 1 minute times ten minute. And after we wait for the transaction to be mine. And finally we console log the receipt.
00:09:04.710 - 00:09:12.694, Speaker A: Our bot buys token. But what about the reselling part? That's a little bit harder to code. What you can do is send an email to yourself when the bot buys.
00:09:12.742 - 00:09:15.022, Speaker B: Token, for example with the API of.
00:09:15.076 - 00:09:46.230, Speaker A: Sendgrid, and when you receive the email, it's up to you to decide when to sell. Another option is to automatically sell the tokens at a certain time after you bought them. Another thing to note is that I show you how to do it on uniswap, but you can also reuse the same code for all the clone of uniswap like sushiswap and even on other blockchain like pancake swap on binance, smart chain, etc. If you want to be able to code your own trading bot from scratch, you need to understand how uniswap work, and for that you can check out this video on my channel.
00:09:46.300 - 00:09:46.900, Speaker B: I'll see you there.
