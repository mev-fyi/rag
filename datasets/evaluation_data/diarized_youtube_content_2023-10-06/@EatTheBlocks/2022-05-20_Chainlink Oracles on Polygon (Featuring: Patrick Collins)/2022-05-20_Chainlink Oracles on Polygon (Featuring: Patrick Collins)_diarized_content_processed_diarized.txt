00:00:00.970 - 00:00:39.346, Speaker A: Hello all. My name is Patrick Collins and I'm a developer advocate on the Chainlink project. I'm here to talk to you about Oracles on Polygon and how to make incredibly powerful hybrid smart contracts. Keep in mind that we are the pioneers of this new world, of this new technology, and it's going to be us and you, the developers, learning about all these tools. Who will be the one to usher in this new age of these smart contracts and these amazing blockchain. So really excited to be talking to everybody today about Chainlink on the Polygon network. Here's what we're going to be talking about today.
00:00:39.346 - 00:01:59.490, Speaker A: We're going to be talking about the purpose of smart contracts, the Oracle problem, Chainlink features. And then we'll start going into some specific examples here. So in order for us to really understand Chainlink and really understand the offering, we first need to understand the purpose of smart contracts. And I know a lot of you already know what smart contracts are for, but we're going to do a little refresher here, because in order to understand Chainlink, we need to say, what is a smart contract? Why are these so important? Why do we care about what these do? And in order to really understand smart contracts, we first want to take a look at traditional agreements or traditional contracts, right? Because smart contracts are exactly what it says in the name, right? They are smart contracts. They are a new iteration of contracts and of agreements. If we look at traditional agreements, typically in these traditional agreements that are written in pen and paper, there is some party that owns the terms of this agreement, of this contract, right? Some institution, some single centralized entity, and often they actually have conflicting interest. For example, if you're an insurance company and you have a contract with a group of people that says if they get hit by a bus or if something happens to them, you're going to pay them out.
00:01:59.490 - 00:03:06.950, Speaker A: But as the group, as the company, you obviously don't want to do that, right? Because you're not in the business of giving out free money. So they have this conflict of interest where they don't actually want to fulfill their end of the bargain. And this has led many times in the past to groups not fulfilling what they said they're going to do. A group or an entity making some promise, making some agreement and then not delivering. So we have this huge trust, this huge conflict of interest issue. Smart contracts, however, rely on cryptography. They rely on math, right? They allow us to enable, engage in cryptographic agreements where instead of having to rely on the other entity doing the right thing, and being honest, all we need to do is rely that math works right? That our code works, that our code is written in a way that makes sense and that will execute the way that we expect, right? And it will execute the way we expect, because if we write in a contract, one plus one equals two, we don't have to trust that some human being or some entity is going to do the math, right.
00:03:06.950 - 00:04:04.694, Speaker A: We can trust that the cryptography of the system, the decentrality of the system will make it so. So these are incredibly, incredibly powerful agreements and they really kind of cultivate to this one major idea where we get rid of this counterparty risk. We no longer have to worry about these brand based guarantees, these paper guarantees. If you rely or work with some service and they make you all these promises and say, hey, we're going to do this, we're going to do that, and they end up not doing those services. In the traditional agreement world, all we can really do is waltz down the street to the next service or the next entity who's going to make the exact same promises. And we have to trust that, okay, well, hopefully these people will actually fulfill the promises versus with smart contracts, we engage in a world of cryptographic guarantees, of math based agreements. We no longer have to trust someone's going to behave honestly.
00:04:04.694 - 00:04:53.254, Speaker A: We just know that, okay, one plus one equals two. The code is written to say if this, then that we can trust that the cryptography works and that the math works, and that is much, much easier to rely on than centralized human beings and centralized entities. And we've seen a perfect example of this happen very recently with Robinhood, depending on when you're watching this video, of course, Robinhood painted this picture saying, hey, come use our platform. We are democratizing finance. We're allowing anybody to engage in this platform. But they held a centralized key where when push came to shove, if you engaged in finance in a way that they didn't really like, whether or not it was right or wrong, they had the ability to turn off your access to those markets. So they painted this huge picture.
00:04:53.254 - 00:05:53.674, Speaker A: They made all these promises, they made all these agreements, and when push came to shove, they could not deliver. And so this is a major issue, especially with finance, where if you're using an entity that has this power, you're essentially saying, well, you have control over my ability to engage in finance, to engage in markets. So not only that, smart contracts obviously have other improvements over traditional agreements like security, guaranteed execution, transparency, this trust minimization piece that we just talked about, and efficiency so they're amazing. They're an improvement on the current ecosystem of agreements and contracts for a ton of reasons here. But that's kind of the basic gist of it, right? They are this massive, massive improvement over on reliability, accountability in our agreement world now, however. So these smart contracts are fantastic, but they come with a fatal flaw. They come with an issue.
00:05:53.674 - 00:06:49.726, Speaker A: Right. And this issue is known as the oracle problem. So what is the oracle problem? What's up with these smart contracts? What's the issue? We just found out that they're these amazing things. So what could possibly be wrong? Well, these smart contracts and these blockchains, these smart contracts, they run on the blockchain, obviously, and the blockchains have these issues, though. Blockchains themselves are deterministic, meaning they can't reach out to the real world, they can't connect to the real world. They can't use any variable nondeterministic data inside their systems. Now, this is obviously a huge issue because if we want these smart contracts to be these superior agreements, then how are they going to do that if they don't even know what's going on in the real world? How are you supposed to create an agreement that doesn't care about the real world? How are you going to create an agreement that's supposed to affect the real world when it knows nothing about it? Right? So that's obviously a massive issue.
00:06:49.726 - 00:07:44.682, Speaker A: And one of the questions that gets asked a lot is, okay, well, why can't they just make an API call? Why can't they just connect to the real world? What's the deal? And again, the issue here is that they are deterministic, right? Variable data can't work, can't live in these deterministic systems. It'll break consensus. If you ask one node, hey, can you make an API call to some random API? All the nodes will go, yeah, sure, we can do that. One node will make the call and maybe another node gets rate limited, maybe another node gets a different answer because they called it a second or a half or a millisecond later and the answer changed. Or maybe you want some random number and each node is going to have a different idea of what a random number is. They're never going to be able to reach consensus with nondeterministic data. So blockchains by design are deterministic, and it's one of the major security properties of these smart contracts and of these blockchains.
00:07:44.682 - 00:08:18.618, Speaker A: Excuse me. So how do we solve this? How do we get around this? And the answer is with a blockchain oracle. So a blockchain oracle is going to be any device that interacts with the off chain world to provide external data and computation to our smart contracts. Okay, great, we solved it, right? We did it. We have these blockchain oracles, case dismissed, right? Not quite. That's not quite the whole story. So a centralized oracle is going to be a single point of failure for your smart contract, for your application.
00:08:18.618 - 00:09:31.250, Speaker A: You've done all this work. If you've built a decentralized protocol on polygon to make this logic layer truly decentralized, and then you have a single centralized node or a single centralized data source, you've essentially done a ton of work to remove that centralized key away from a party, and then you just reintroduced it by adding this centralized node or a centralized layer. So having a single node or a single data point reintroduces this centralized piece and is no bueno, it's no good, right? We want to make sure both our logic layer, our on chain settlement layer, and our off chain data and external computation layer are both truly decentralized. And that's why a centralized node is going to be no good here. So this all comes down to the solution here, which is going to be chainlink, which is a decentralized oracle network. Chainlink is a modular framework which allows users to build networks and work with external data and external computation in a truly decentralized fashion. So you can get data, you can do event based triggers, you can get random numbers, you can do all these fantastic.
00:09:31.250 - 00:10:56.814, Speaker A: You can kind of have all the feature richness that traditional agreements and traditional web applications have in the context of a decentralized smart contract. And this gives rise to something called a hybrid smart contract, where you have a contract that has some off chain component, whether that's working with external data, enterprise system, traditional payments, or what have you, and then your on chain contracts, which again here is going to be on Polygon to enable us to once again engage in the censorship resistant decentralized finance, NFTs, gaming, death, et cetera. Some examples are going to be, for example, weather insurance or insurance here. In order for you to build an insurance contract, which there are plenty of those in the real world, you're going to need to get the data on whatever you're insuring, right? So if you're insuring crop insurance, for example, you're going to need the rainfall, the temperature, any other product evaluators. That's going to need to go through a decentralized network of Chainlink nodes to go to some on chain contract, which then you can build an insurance protocol out of that DeFi, obviously massive. A vast majority of these protocols you see here are using Chainlink in some capacity to price underlying collateral or do some type of computation or get some type of data nfts gaming. I mean, the use cases go on and on and on.
00:10:56.814 - 00:11:54.478, Speaker A: Maybe you want a random number to create some really verifiable NFT, or you want to do some random attack stat for some character, but the use cases go on and on and on. So with that being said, let's talk about some of these out of the box solutions, right? So Chainlink is a technology that is completely customizable, right? And we can take it and we can do whatever we want with it. But there are some features that are pretty much ready to go out of the box where it takes almost no configuration from our end. We can hit a button that says go and we can get our smart contract set up with some of these incredibly powerful features that we just talked about. One of the main ones, one of the biggest ones, one of the most powerful ones is going to be the Chainlink data feeds, or the Chainlink price feeds. And these are currently powering over $50 billion in the decentralized world. They're currently helping secure more than $50 billion, which is absolutely insane.
00:11:54.478 - 00:13:17.290, Speaker A: What are these? So these price feeds, these data feeds are using off chain data in a decentralized context from many different exchanges, many different data providers, sending them through a network of chainlink nodes, each also, again decentralized, putting them onto some price reference contract or some reference feed that allows these protocols to read this data, to read this pricing information for their protocols. Here's a visualization of what the current, most up to date version of these data feeds look like, which is called off chain reporting, where as you can see here, all the different nodes are going, they're making these API calls, they're reaching out to these data providers, these high quality exchanges and et cetera, getting the price of some asset, like maybe FUSD or matic USD, for example, and they're reaching a consensus off chain. And then they send in a transaction with all the nodes having signed their data to a smart contract for other smart contracts to read and to pull from. And here's a visualization here. We can even go to data chain link here, and we can see if we click on one of these. This is on Ethereum, but let's go to Polygon, actually. So let's do matic USD.
00:13:17.290 - 00:14:06.166, Speaker A: We can see a group of nodes here that are delivering this data. Each one of these nodes is a different entity and they're pulling this data from the real world, delivering it on chain so your applications can use the data for whatever you want. And these data feeds are being used by some of the largest DeFi protocols in this space. Synthetix for example, for pricing underlying collateral sushiswap for doing margin trading, compound, again, underlying collateral aave for depositing and lending. And I think some of these numbers will probably be outdated by the time you watch this and be a lot higher. So these are really battle tested pricey. It's battle tested data that you can use to empower your smart contracts.
00:14:06.166 - 00:14:33.650, Speaker A: And at the end of this session, towards the end, we're going to do some examples, like I said. So don't worry, hold tight. We're getting there. But the documentation in Docstartchain link has a wonderful one click option where you can just click a button and go right into a remix ide. We'll also go into hardhat as well. Stay tuned for that. But documentation is absolutely plentiful if you're looking how to work with these price feeds.
00:14:33.650 - 00:14:52.502, Speaker A: So that's the first one. That by itself is already incredibly powerful. But there's more. Yes, I know, crazy. There's more. Chainlink VRF or chainlink verifiable randomness function is absolutely massive. Chainlink VRF enables provably fair selection processes.
00:14:52.502 - 00:15:41.546, Speaker A: Provably fair random numbers. As you know, as we've talked about, these blockchains are deterministic, and by definition a deterministic system can't have a random number, right? It just doesn't work out. How can you have a random number when you already know what that number is going to be? It's not possible. So in order for us to get a truly random number in our blockchain applications, we do have to look outside the blockchain once again. Chainlink has a process of delivering a cryptographically proven random number into our smart contract. So we can use this randomness to power whatever we want. So for a lot of you who are learning solidity, oftentimes what people will do is they'll use some pseudo random number, pseudo random generator where they hash maybe the block difficulty or the timestamp and all those numbers.
00:15:41.546 - 00:16:42.334, Speaker A: Anything on chain can be influenced by miners, can be hacked, can be adapted, and so it's not going to work if you want any type of secure randomness. So Chainlink VRF gives us that provably secure randomness that proven scarcity those truly, truly random numbers. And if you want, you can check out the GitHub where you can check out the on chain contracts that go through the verification process of proving cryptographically that a number is truly random. And this chainlink VRF is being used by a number of protocols pool together, being one to give out this decentralized random winner for their defi project. Tons and tons of NFTs, Avagochi, Zx, Infinity, ether cards, Pokemon are all using this chainlink VRF to get provably random stats for their nfts, provably random drops, provably random giveaways, raffles, et cetera. And again, one click documentation. Again, we'll head over to those at the end of this.
00:16:42.334 - 00:17:14.418, Speaker A: But really fantastic docs and everything you want to know to use them. You can jump right in the docs there. Next. Oh man, there's more. I know, crazy, right? Chainlink keepers or the Chainlink Keepers network for decentralized event driven executions. As we know, smart contracts actually can't trigger themselves. When we want a smart contract to do something, we or somebody has to initiate some transaction, right? You need to pay some gas to make a state change on the blockchain.
00:17:14.418 - 00:17:53.054, Speaker A: Somebody has to do this. Now we could of course have some cron job or some server off chain doing this. But again, guess what you're introducing when you do that? A single centralized point of failure. If your server goes down, if their server goes down, you've now ruined the decentrality of the application. Or maybe somebody's malicious and doesn't want to trigger your server, you've ruined the decentrality of your system. So smart contracts can't trigger themselves in a decentralized context until now. So chainlink keepers allows us to have smart contract applications that trigger, that do some type of decentralized event based computation.
00:17:53.054 - 00:18:39.870, Speaker A: So on any trigger you can think of, maybe it's a timestamp every ten minutes run this function, maybe it's changing liquidity. Once a price of an asset reaches a certain price, maybe you sell it for a short sell or a stop loss, or to rebalance a portfolio. Whatever you want to do, chain link keepers can trigger that event in a decentralized context, which is absolutely insane. And similarly, there are some fantastic docs on this. This is kind of a really nice GIF walkthrough of working through the user interface to add yourself to what's called the registry contract. This is the contract that all the chainlink nodes are listening to off chain. They're listening for any new upkeeps to happen, right? They're waiting for those events to trigger.
00:18:39.870 - 00:19:32.994, Speaker A: Once the smart contract is registered with this registry, all the keeper nodes will be watching this keeper registry, and this is an easy way for you to connect to that registry. And then last but not least, Chainlink API calls for unlimited customization. So as we know, like I said, those three first ones are kind of the out of the box, ready to go, already decentralized, good to go applications. But like I said, you can really do anything with Chainlink. You can really empower and elevate your smart contracts to have any type of functionality, any type of customization. And to do that, you can do that with the Chainlink API calls. So this will connect your smart contract to all the traditional APIs and services that the web uses today so you can configure your chainlink nodes to work with the real world.
00:19:32.994 - 00:20:38.994, Speaker A: Now, this application does take a little bit more work in order to be truly decentralized because again, a single node configured to make these API calls isn't necessarily sufficiently decentralized. So there is some extra work that goes into this to have to work with other nodes to collaborate. But 100% this feature enables you to customize your smart contract in really any way that you want with a little extra legwork. And that's really the end to end reliability of smart contracts and of what the Chainlink protocol is all about, taking these smart contracts and elevating, heightening them to the next level to enable them to do anything that they want to do. And if you have some really cool ideas on how to elevate it, you can always get a grant. You can always jump into the chainlink discord to the chainlink networks and reach out and contribute or build something really cool. Now we are going to go into these remix and hard hat demonstrations, but before we do that, I do want to talk a little bit about where you can go to learn, where you can go to participate in the chainlink network.
00:20:38.994 - 00:21:17.338, Speaker A: And then we'll jump right into those remix and hard hat examples and show you how to build some of these incredibly powerful billion dollar defi protocols and billion dollar NFT projects, et cetera. So the first place that everyone should know about is docs chain link. This has everything that you're going to ever need to know about Chainlink, about documentation, how to work with literally everything. Next, blog chain link. Tons of fantastic blogs, tons of fantastic tutorials, how to do option trading, how to set up with hard hat, how to do dynamic and MTs. The list goes on and on and on. The Chainlink, YouTube, Chainlink engineering tutorials and developer workshops.
00:21:17.338 - 00:21:52.350, Speaker A: Those are the two main playlists. You can watch us literally step by step, go through a lot of these processes and work with a lot of these tools. Solidity and smart contract starter kits. If you're getting into the framework world with Brownie, hardhat, truffle, et cetera, we already have some boilerplates built for you that you can take and that are good to go and ready to just be forked and worked with. And again, we're going to be working with hardhat today. But if you're familiar with Brownie and Truffle, you can absolutely use those as well. And then absolutely 100%, you can always join the community.
00:21:52.350 - 00:22:20.378, Speaker A: You can jump in, have conversations, reach out and talk to people. So some of the best places to get technical support are going to be on stack overflow or stack exchange. Ethereum asking a question, tagging it, chainlink. That will give more Ike to pretty much the whole community with your question. And anybody who's helpful can jump in and help you out there. The chain link discord. You can jump in for kind of more spitballing, theorizing, and chatting with other members of the community.
00:22:20.378 - 00:23:14.454, Speaker A: Of course, there is the GitHub with starter kits that you can kind of just fork from and get going and learn more. And again, if you have an idea of how to contribute, Chainlink grants is there, and the Chainlink labs will actually pay you to build some really cool advancement or feature that you want to work on. And then, of course, the documentation, which is just absolutely massive. So with that, thank you very much, and let's jump right into those examples. All right, so let's go ahead and get started building some of these hybrid smart contracts on the polygon blockchain. Now, we are going to do some integration tests where we actually simulate running one of these smart contracts on a real polygon mainnet by using what's called a testnet or a fake blockchain. Now, in order to use this fake blockchain, we need a wallet to interface with this blockchain.
00:23:14.454 - 00:23:52.626, Speaker A: And the wallet that we're going to be using is going to be metamask. So if you don't have metamask, you want to head over and download it here, we are going to be working with Testnet, Ethereum, Testnet, Polygon, Testnet, Chainlink. So no real money will be in this wallet. A quick wallet tip. Once you do get this set up, absolutely don't send any real money to this whenever you're developing and whenever you're testing, you want to be testing with a wallet that doesn't have any real funds in it. So you can come to the metamask site to get metamask set up. Once you do, you should see a little fox icon right up in your browser.
00:23:52.626 - 00:24:42.422, Speaker A: And this will be the wallet that we're going to interact with and work with, to work with the polygon chain and work with Chainlink and different testnets. Now to get started, though, we're going to be working with the Coven test network. All the code that we work with here is going to be exactly the same as if we're working on polygon, except for some configuration differences. So we're just going to be working with coven Testnet here. But after we go through a couple of these demos, I'll show you how to go ahead and get metamask set up with Polygon so you can deploy these smart contracts to the polygon mainnet to the polygon main chain. So with that being said, let's jump into some of these out of the box applications here with Chainlink. Again, everything that you need to know about working with these contracts and about getting started is going to be docs chain link.
00:24:42.422 - 00:25:11.070, Speaker A: This is your starting ground. This is ground zero here. And the first thing that we're going to look at is actually working with these data feeds. But if you want to play around and you want to see some of these other tutorials, for example, the basics tutorial, there's a video along with it will help you get set up with Metamask. We'll help you deploy your first smart contracts. We'll help you really just get started with this entire space. If you want to learn more about how Chainlink works, about the different models, the basic request off chain reporting, you can check it out here as well.
00:25:11.070 - 00:26:04.850, Speaker A: But like I said, we're just going to jump into learning about getting the latest price here. So if we come to getting the latest price, we'll learn a little bit of information about what this code looks like, what this code is doing. And if we scroll down, we'll see this exact code here, which is everything that we're going to need to actually work with one of these data feeds and get the price of a real world asset into our smart contracts. We can absolutely copy paste this into whatever editor we want, or we can go ahead and come down, we can click this deploy button, this remix button, which will pop us into remix with this code already populated over here. And if you don't see it on the side, on the left here you should see something like docs chain link, you can click it. Samples price feeds will be here and price consumer v three sol will be what you're looking for. Now let's go through what this code is actually doing.
00:26:04.850 - 00:27:09.106, Speaker A: What's going on here? So at the top of course we have our solidity version. We're importing the chainlink aggregator code here which is going to allow us to have the interface to work with these price feeds where we have our contract name here we have a variable called price feed of type aggregate a V three interface which again is just the data feed. We have our constructor which here is some really important pieces, right? And this is really the only piece that we'll ever have to change. When we switch networks on each network these data feeds live at a different address. So if we're on the coven testnet, if we're looking for the Ethereum USD price feed, this is the address of that data feed. Now we can come here, come to our documentation, go to contract addresses under the data feed section and we can see data feeds across different blockchains. Again, since we're going to be working with Polygon we could scroll down here and we come and grab any of these addresses on the polygon chain and use it in our smart contract.
00:27:09.106 - 00:27:55.438, Speaker A: And if we click one of these addresses it'll even bring us to the explorer and it'll bring us to the exact contract that those feeds are being updated on, which is incredibly exciting. So if we wanted to change addresses we would come here again. We're going to be working with COVID just for this testnet demonstration. So we're going to leave the address as is. Then we have a function get the latest price which all we're really doing here is we're getting this int price value here which is going to be the price of Ethereum in terms of USD. So all we have to do is compile or hit command S, control S or whatever save is. We can come down to deploy, we'll switch to injected web3 and this will inject our metamask as our wallet provider.
00:27:55.438 - 00:28:33.898, Speaker A: Now to work with this again, you do have to be on the coven chain and you do need some testnet ethereum here. If you don't have any coven testnet ethereum, what you can always do is in the chainlink docs you can go to the link token contracts page which is right here and you can scroll down to whatever testnet you're working with. For example COVID and there's usually a link to the most up to date faucet. So if you need some test on Ethereum, you can click the test on Ethereum button, it'll bring you here. This one actually gives us both link and ETH, which is great. We're going to copy our address, we're going to place it in here. I'm not a robot, those are taxis.
00:28:33.898 - 00:28:57.574, Speaker A: Send request and what's going to happen is we're actually going to get funded. Ten testnet link in 0.1 testnet ETH to our account. We will have to wait a little bit as the blockchain goes ahead and validates our request. But once it's done, it'll say it's all done. And if we look into our wallets, this number and this number will be increased. Right.
00:28:57.574 - 00:29:29.220, Speaker A: So if you don't have the link token already in your wallets, you can scroll to the bottom, hit add token and we'll just need this link token address. Again, they're going to be different across different testnets. So for COVID it's going to be this address here. So we'll go into metamask, we'll hit add token, paste that address in. I've already added it, but if you haven't, you hit next and then it'll show up right here in your metamask. So you should have some testnet ETH. You don't need testnet link for this specific demo, but in the next ones you absolutely will.
00:29:29.220 - 00:30:08.318, Speaker A: So now that we have some testnet ETH, we have the gas we need to pay to deploy this contract. What we can do then scroll down, change to the price consumer and go ahead and deploy this contract. So this is going to deploy it to a real Coven testnet, right? We're simulating as if we're deploying to a real main net, right. The difference here is that this is fake ETH, this is fake money. There's no actual value here. But then we can go ahead and hit get latest price and we get a response. Now you might be saying, oh, why is that such a weird number? Why is it so weird? And this is because as you know, solidity doesn't work with decimals so well.
00:30:08.318 - 00:30:43.194, Speaker A: So this number actually gets multiplied by a large number. And we know that this one actually has eight decimal places. And you can see both in the documentation. And there's a function called decimals that you can call to get the number of decimals each one of these feeds has. So for example, if we go to ethereum data feeds. We look for FUSD. We can see that it has eight decimal places, so that we know that this number is actually 3597 here.
00:30:43.194 - 00:31:09.010, Speaker A: And. Perfect. That's exactly how you do this. Now, if you wanted to deploy this to the polygon main net, you absolutely could. This code will work on the polygon mainnet the exact same way. I'm not going to actually do that here because again, I don't want anybody who's watching this to use real funds with a wallet that they're just testing with, just in case you accidentally do something silly with the wallet here. But what you would do is you'd come to your metamask.
00:31:09.010 - 00:31:37.050, Speaker A: Let's go ahead and we'll do expand view so we can see everything a little bit nicer. We'll go ahead and leave remix here. And what we do is we'd come to our networks and we'd hit custom RPC. This is how you add a new network to your metamask. So we'll add polygon in here for a polygon URL. We can actually find that in the polygon documentation. Whoops.
00:31:37.050 - 00:32:00.340, Speaker A: Oopsie daisy. Ad network. There we go. Polygon. We can come to the docs, polygon technology. We can come to the docs and we can get all the information that we need to actually get this set up here. We can do polygonrpc.com.
00:32:00.340 - 00:32:32.330, Speaker A: The chain ID is going to be 137, currency symbol is going to be matic. Block Explorer is going to be polygonscan.com. And then we'd go ahead and hit save. I already have this network up under polygon, parentheses matic. But this is how you would get it set up. Once you have this set up, you should be able to see in your metamask here, you should be able to scroll down and have this polygon account again. You won't have anything in here.
00:32:32.330 - 00:33:35.790, Speaker A: There won't be a faucet for this because this is real money, this is real polygon, but it should be in your wallets. Once you have that, we can actually just roll back over to deploying this with remix. And all we would need to do is switch our address, right? So if we're working with the polygonmatic data feeds and we want to do, let's say, matic USD, we would grab this address here, copy it, and in remix, all we would do is we would change this. We would say polygon in our comment here, polygon, this would be matic USD and we'd paste the address here. And that's it, and then we could compile, we could deploy this injected web3. Again, I'm not actually going to because I don't have any matic to actually deploy with, but this is how you would go ahead and deploy to the polygon chain for working with a data feed. So next, let's go on to chainlink VRF.
00:33:35.790 - 00:34:13.822, Speaker A: So I'm not going to show you how to set up Polygon for each one of these ones moving forward, but the process is going to be the same for all of these. So Chainlink VRF is actually a two transaction process. Again, there's a whole bunch of notes here. We're just going to go ahead and scroll down to the remix button that we can go ahead and click and get started right in here. Docs chain to link samples vrf random number consumer sol that's what we're going to be using. And this is a two transaction process, like I said. And let's actually just flip back to COVID because for this example, we're just going to use coven again.
00:34:13.822 - 00:34:57.334, Speaker A: So for this one you will need testnet ETH and testnet link. So be sure to follow along those instructions I gave before of going to the chainlink docs, going to the link token contracts page and grabbing that coven faucet and getting both link and ETH into your metamask here. So ETH link testnet. Awesome. So let's talk about what's going on here. So we have our version, we're importing some chainlink code from the chainlink GitHub and we're inheriting this VRF consumer base bit. So this VRF consumer base bit allows us to define two really important addresses.
00:34:57.334 - 00:35:51.498, Speaker A: Right? Because when working with the chainlink VRF, there's a contract on chain that's actually going to do the verification of our random number. And right in our constructor, right afterwards, we add those addresses, we say, all right, constructor of the VRF consumer base is going to use the VRF coordinator, and this is the address of the contract that does that verification. Again, it's going to be different on different chains. And then the address of the link token. Now, similarly to transaction gas that we pay whenever we make a transaction, when making a request to a chainlink node, we pay a little bit of Oracle gas or link token. Now, the reason that we pay for the chainlink VRF and we weren't paying for the price feeds is that the Chainlink VRF, we're actually directly requesting the data. The price feeds are actually supported and sponsored by a number of projects who are paying a lot of the request data.
00:35:51.498 - 00:36:32.620, Speaker A: So if we scroll to the bottom of something like data chain to link, all these protocols here are paying to help support these different price feeds. So that's kind of the difference here. So we're doing a direct request to a chainlink oracle to say, hey, can I get a random number please? Then we also define a key hash which uniquely identifies one of these oracles and the fee of the chainlink vRf. It varies by network. You can find all this information if you go to using randomness contract addresses, and you can find all the information here. Polygon is right at the top. You can find the link token address, VRF coordinator key hash, and the fee that goes along with requesting the service.
00:36:32.620 - 00:37:07.262, Speaker A: Now for the moment of truth, get random number. This is the function that we call to request a random number. And all we do is we call this request randomness function. Well, first we just make sure we have link in the contract, but then we just make sure we have enough link to pay the chain link node. But after we do that, we call this request randomness function. Now, you'll not see it defined anywhere, and that's because we're actually inheriting it through the VRF consumer base. But what this will do, and we pass the key hash and fee.
00:37:07.262 - 00:37:40.990, Speaker A: What this will do is it'll ask a chainlink node to give us a random number. So in one transaction we're going to call this function, and then in a second transaction, the chainlink node itself is actually going to call fulfill randomness and give us a random number called random result. So same thing. We can go ahead and compile this, we'll go ahead and deploy this, we'll move to injector web3. We want to be on coven. We'll need both ETH and link in our wallet. We'll scroll down to random consumer, we'll deploy, metamask will be like, hey, you sure you want to deploy? We'll say we absolutely would love to deploy.
00:37:40.990 - 00:38:25.102, Speaker A: And then we'll scroll down and we have our contract here. Now if we hit random result right now, it's going to be zero, right? And this makes sense because we haven't requested a random number yet. However, if we hit get random number now, we'll actually get this gas estimation failed error. And the reason for this is that this contract doesn't have any link token to pay the oracles. So the contract has to have the link token, not the user who's calling the function. So what we need to do is we need to copy this address with that little copy button, come into our metamask, hit send, paste the address of the contract, scroll down to link, and then send this some link. We're going to send it one whole link.
00:38:25.102 - 00:38:58.886, Speaker A: That's definitely overkill, but why not? So we're going to send this contract one link. And again, you're starting to see why doing a lot of this in hard hat is going to be a lot nicer, because it'll automate that whole funding process. And once that goes through, we can then call this get random number function. And metamask does indeed pop up this time. So now we're going to go ahead and confirm. And again, before we actually send it, the price is going to be zero. Now we actually have to wait two transactions.
00:38:58.886 - 00:39:42.262, Speaker A: So even though you might see remix, say, hey, that transaction has gone through, that's just the requesting transaction. This is following what's called the basic request model of working with Chainlink. In a single transaction, we request some data, and then in a second transaction, we get the return of that data or computation. In this case, it's data and or computation, depending on how you look at getting a random number. But what will happen is after a couple minutes or maybe a few seconds, we'll see this random result update after we press it. So we do have to wait a little bit. And as you can see now, we've got a return here of a truly provably random number.
00:39:42.262 - 00:40:36.792, Speaker A: And that's how you work with Chainlink VRF. Now, we're not going to go over chainlink keepers because Chainlink keepers isn't on the polygon chain yet. However, I'm sure if you stay posted, maybe that'll change soon. You can, of course, like I said, configure your chainlink nodes to work with any API and any URL that you'd like to work with. And if you want to do that, this is the code here on how to do that. Now let's go ahead and jump over to working with hard hat in our text editors here. So in order for us to work here first, the text editor that I'm using is called Visual Studio code, and you can download it from code visualstudio.com.
00:40:36.792 - 00:41:20.900, Speaker A: Just please note, this is different than visual studio. This is visual studio code. It looks like this, it's a little bit different. And this is the text editor that I'm going to be working with. You can work with what's called a terminal right here to work with all of our code and everything that we're going to be working with here. Additionally, you'll need Node JS, Node JS installed and also yarn yarn install. You can see if those are installed correctly by doing node version and yarn version.
00:41:20.900 - 00:42:05.952, Speaker A: If you have both of those installed, you should be good to go. So what we're going to do though is we're going to create a new folder for our project here. I've already created a new folder called Polygon ETB, but if you want to create a new folder, you can do Mkdir, Polygon ETB, or whatever you want to call it. And we're going to clone our starter repo. So we can actually just Google Chainlink hard hat starter kit and it actually just popped right up. Or you can just come right to the smart contract kit GitHub and it'll be a pinned repository. There are a couple in here like the Chainlink repo itself, hard hat starter kit, a full python blockchain, course, external adapters, the truffle starter kit, and the brownie starter kit.
00:42:05.952 - 00:42:58.230, Speaker A: So what we can do is we can grab this URL and we're going to go ahead and get clone it. Actually, I forgot to mention that you also need to download git. If you don't have git, you can download git with this right here, and you'll know you have it installed if you do git version. So once you have it installed, we can do git clone paste it in here. And this will go ahead and download everything in the hardhead starter kit for us. And if you're working with visual studio code, you can go ahead and open this up and see it in our little sidebar here. What you'll do is you'll go file open, and wherever this folder is, you can just go ahead and hit open and vs code will go ahead and pop right up and start and open this up for you.
00:42:58.230 - 00:43:35.090, Speaker A: Great. So let's do a quick walkthrough of what is in this repository. What's with this code? So our contract section has all the contracts that we need. It has our API calls, price feeds, random numbers, anything we want to work with there. It has a deploy tab which allows us to deploy our contracts and specify how we want to deploy them. It has some tasks which we can call which we want to get the balance of something we want to withdraw, some link we want to read a price feed, et cetera. And then we have our tests as well.
00:43:35.090 - 00:44:11.230, Speaker A: Additionally, we have a sample env which we'll talk about in a minute. We have some linting folders. You can ignore these git ones for now. It has this cute adorable little logo and then it has some important files called the hardhat config and the hardhat helper config, which we'll talk about in a second package. Json and yarn lock. So the first thing we're going to want to do here is we're going to want to install all the dependencies for this code with a yarn or a yarn install. Or if you prefer NPM, you can also do NPm install.
00:44:11.230 - 00:45:01.036, Speaker A: Awesome. Now that we have everything installed, we can actually go ahead and start testing and working with a fake, a faster blockchain called the hardhat runtime environment. This is a way for us to test our code and test our contracts in a custom setting. So what we're going to do is we're going to do Mpx hardhat node, and what this will do is it'll start up a fake blockchain running on our computer, running in our terminal right here. And it runs through what's called the deploy scripts. So everything in our deploy scripts here it sets up for us and it runs through all these scripts that are in here. So the first thing that it does is it actually deploys what's called mock contracts to our fake blockchain here.
00:45:01.036 - 00:45:57.120, Speaker A: So this is how it deploys the mocks. But when we're working with a testnet, there are price feeds, there are VRF coordinators, there are oracle contracts, but when we spin up a fake blockchain, those don't exist. So this deploy mocks contract deploys a fake price feed, a fake vrf coordinator of mock a fake oracle contract so that we can actually work with them and pretend that we're actually working with a real blockchain. So once we have those mocks deployed, we actually go ahead and deploy a price feed contract, which this is the script that does that. We also deploy an API consumer, we also deploy a random number consumer. And then we do this setup contracts script in JavaScript which will fund our VRF and our API calls with link so that we can actually make those API calls. We can do that basic request model functionality.
00:45:57.120 - 00:46:49.136, Speaker A: And in the output of running this node, running this fake blockchain, there's actually some commands, right? It actually runs through all those scripts and has all the print outputs here. So for example, if we wanted to read from this fake chainlink price feed, we go ahead and run Mpx hardhat, read price feed, the contract address and the network, and I can even copy this open up a new terminal with that little plus button, paste this command in here. And exactly like if we hit that read price button in remix, we get the output here, right? Price is 2000 or whatever this number is. Right. And again, because this is a mock price feed, this is a price that we've actually gone ahead and set. Now, this is incredibly powerful because it means we can test our chainlink smart contracts much quicker. Right? We don't have to wait for transactions to go through.
00:46:49.136 - 00:47:25.020, Speaker A: We don't have to wait for chainlink nodes to respond. Everything is happening locally right in front of our eyes if we have our fake networks spun up here. So that's going to be a huge, huge advantage for running these. And it makes running your tests a lot easier because what we can do if we look at our tests here is we can work with these mocks and run our tests without having to actually, again, wait for transactions to go through and wait for everything to go through. So really incredibly powerful here. And I'm going to go ahead and quit it with control C and we're going to go ahead and close this. So we just have one terminal.
00:47:25.020 - 00:48:07.300, Speaker A: Now, if we do want to deploy these to a real testnet, right. If we want to deploy them to a real testnet or a real main net, we can absolutely do that as well. And that's where our hard hat helper configs come into play. So there's a lot of stuff in here, I know, but right at the top, this is where we have a lot of the main pieces, a lot of the main components that we're going to be working with. So if we want to deploy to coven, we need a coven RPC environment variable. And we have this line of code here says required Env config, which means it's going to pull from a Env file. Now this is an example of a Env file.
00:48:07.300 - 00:48:54.360, Speaker A: So it's env example. But what we'd want to do to actually deploy something is we'd go ahead, we'd make a new file called Env. We'd want to paste it in here and we'd want to change some of this, right? So if we wanted to work with COVID we would get a coven RPC URL from Infuria or from alchemy, whatever we want to do. So if we wanted to get it from alchemy, we go to alchemy, we could log, right, login, sign up, and you'll get an API key that looks just like this. Right? And so for COVID RPCRL, you'll just paste that in right there. We're not going to work with Mainnet for the time being. And then for our private key, this is where you'd come to your metamask.
00:48:54.360 - 00:49:43.176, Speaker A: You'd go to account details, export private key. You'd put your password, and then you'd grab that private key that it gives you and you'd paste it in here. Now, just to note, metamask typically doesn't add the ox at the start, so you'd want to add a zero x at the start and then the rest of your private key. Once you have these in a env, remember, the private key gives whoever has that private key access to your wallet. So this is why I always say, don't use a wallet for testing and for developing that has real funds in it. Make sure that you're very careful and you don't push these up to GitHub, et cetera. In our git ignore file, there's a env.
00:49:43.176 - 00:50:15.170, Speaker A: So this folder should help protect you from accidentally pushing this up to a GitHub here. Now, you can use your private key or your mnemonic. And your mnemonic is actually going to be, if we go in here, we'll go to account settings, security and privacy reveal secret phase. That's going to be your mnemonic. Or you can just do the private key like we just said. But if you want to do your monarch, you could add that in here. We're going to be working with the private key for this demo.
00:50:15.170 - 00:51:12.676, Speaker A: And to work with the private key, we actually have to come to our hardhat config Js scroll down to COVID, and we're going to swap out this accounts section. So we're going to actually comment out all this part and uncomment this part. So we want our accounts to be coming for our private key instead of our mnemonic. And this is the syntax for how to do that. But once we have these two environment variables, your coven RPCRL, and your private key, we can actually go ahead and deploy and work with and deploy to a real testnet or a real main net if we want to deploy all these contracts, right, our API consumer, our price fee consumer, our random number consumer to the coven network. What we'll do is MPX hardhead deploy network, COVID, and this, again, it'll run through all of our deploy scripts and it'll deploy everything. Now it also, and this is where hardhead is.
00:51:12.676 - 00:51:47.788, Speaker A: So fantastic as this is deploying here in our config in our helper config, excuse me, there is a fundamental parameter for each network and COVID's on 42. So for fundamental for the VRF and the API calls, it's going to automatically fund it with this much link. That seems like a lot, but it's in way, so don't worry. This is actually 1234-5678-1234-5678-9 ten. This is actually one link per contract. So it's going to fund with one link. Right from your metamask.
00:51:47.788 - 00:52:24.792, Speaker A: Right. And again, remember you need to have both ETH and link in your metamask so that you can actually deploy here. And it knows to use this fund amount. Because again, in our deploy scripts here, for example, for random number consumer, we have a little bit in here because in our setup contracts, again, we have this auto fund check which checks to see if we should fund this contract with link. And we do want to fund at least the random consumer. For example, with link. Once you've run this script, you can actually scroll up and you can see again a whole bunch of these other scripts to help us interact with these contracts.
00:52:24.792 - 00:53:08.088, Speaker A: For example, if we wanted to read a price feed, we copy this MPX hardhead read price feed contract, blah blah network coven paste it in. Boom. Price is right here. The exact same as if we were pressing that price feed button. If we wanted to request a random number, copy paste MPX request random number contract, blah blah blah network, COVID and this will go ahead and it'll hit that request randomness button similar to what we did in remix. Now again, it gives us a little output here saying, okay, great, you've gone ahead and requested this. Now in order to read that random number back, here's the function that you're going to call.
00:53:08.088 - 00:54:00.164, Speaker A: And if we call it now, it probably won't have responded by now. It hasn't responded by now because again, we do need to wait for those transactions to go through. But this is how we can actually interact with all of our contracts and interact with everything. But now that I've waited for it to go through, we can now see random number is and then this huge, massive random number. And this is all kind of in this deploys and in these tasks that we've created for this hardhead starter kit. So this is a way we can build our test suites, do everything that we need to do in a text editor that we are familiar with. We're going to also run all of our tests, our entire test suite, on one of these stake blockchains on this hard hat runtime environment by just doing NPX hard hat test, and it'll show you the output of running your tests.
00:54:00.164 - 00:54:52.440, Speaker A: So this is how you can test all your smart contracts that are using Chainlink locally. And finally, of course, if we want to deploy all these to the polygon chain, we're going to have to go into our configs to add these different pieces. If we go to our hardhat config Js, you'll see that there's already some polygon pieces in here, right? There's a polygon mainnet RPC URL variable. So if we go to our env the exact same way we made the coven RPC URL, we would copy and paste this, we would add polygon mainnet RPC URL. We'd scroll down, we can see the name of this network is actually polygon. So when we're doing our network flags, we do network polygon. We can see this one's already using the private key and this one has that RPC URL for polygon Mainet RPC URL right here.
00:54:52.440 - 00:55:39.048, Speaker A: So we would add that, we'd add a private key or mnemonic or whatever else we wanted in this env. And then the other main thing that we do is we'd actually come into our hardhat helper config and we'd add a new network. Again, Polygon is already added in here, right, but we have all these environment variables like the link token, FUSD price feed key, hash, et cetera. And this is where we would add those different addresses. So when we deploy a price feed, if we go to our deploy price feed consumer, what it does is on this line right here, it says it's going to deploy the FUSD price feed, which is grabbed from what's called the network config chain ad. FUSD price feed. The network config is this file right here.
00:55:39.048 - 00:56:24.310, Speaker A: China ID for polygon is 137. And then FUSD price feed, this is the address right here. And again, you can find that from the chainlink documentation. So if you'd want to go ahead and deploy all this, once you have this Env set up, you would just run NPX hardhat, deploy network polygon. Again, I'm not going to actually run it here because I don't have any matic in my metamask right now, but this is how you would do it. So with that being said, I hope you all learned a ton about building these insanely powerful smart contracts and these insanely powerful hybrid smart contracts that are going to elevate your solidity and your programming skills on the polygon chain to the next level. Best of luck, and I hope to see you around.
