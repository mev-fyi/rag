00:00:00.410 - 00:00:34.274, Speaker A: In this video I'm going to show you how to generate a random variable in solidity. If you don't know me, I'm julian, and on my channel eat the blocks, I teach blockchain development and how to find your first blockchain job. So here is my solidity smart contract. And I want to create a function that generates a random number. So, let's do this. So we're gonna name our function and modulus. It's going to take a single argument that tell us what is the maximum random number that we want to generate.
00:00:34.274 - 00:01:09.774, Speaker A: We're going to call this mode, that's external, that's a view function, read only and return an integer. Okay, so how are we going to proceed? We need some source of randomness. So first there is the time at which we call this function. So that's now, then there is the current difficulty of the blockchain. So that's block difficulty. And then there is the address of the sender of the transaction. So that's Msg sender.
00:01:09.774 - 00:01:43.358, Speaker A: So we're going to combine all of this with AbI encode packed. So that's an obscure function that we don't use often, but this is very useful when we want to calculate a hash. And we will calculate a hash. So kshack 256. So this allows to compute a hash with the kchak 256 algorithm. And as an argument, it takes a byte and Abi encode produced a byte. So we're good on that.
00:01:43.358 - 00:02:28.714, Speaker A: So we're going to have a hash, but with our hash we don't have an integer. We want an integer. So we can cast this hash into an integer with this. And after that, the problem is that our random number can be very small, very big, but we want it to be within a certain range defined by this variable. So we're going to use the modular operator. So if you don't know what is the modular operator? That's basically the remainder of divisions. For example, ten modulo five equals zero because you can multiply five by two and this is equal to ten.
00:02:28.714 - 00:03:00.894, Speaker A: But if you do, for example, ten modulo seven, then that's going to be three because you can do seven times one. And after the remainder is three to reach ten. So that's how it works. So here I have my random number that is within a certain range. I want to return this. Let me put a semicolon at the end scale up on my screen. Grab a typo.
00:03:00.894 - 00:03:21.674, Speaker A: This is K shack without a C here. All right, so now I'm going to deploy my spot contract in remix. And I'm going to try, I don't know, to generate a random number with a maximum of ten. So that's going to be generated in the range zero to nine. So let's try this. Six. Okay.
00:03:21.674 - 00:03:38.402, Speaker A: Eight. Four. Yeah, keep clicking. Yeah, so you can see that it respect the range and this is random. So that's pretty cool. How about if you try with 100? Yeah, so it seems to be working. Yeah, that's super cool.
00:03:38.402 - 00:04:30.420, Speaker A: Okay, so all of this is good, but the problem is that this way of generating a random number is not entirely safe because this is possible for minor to manipulate these variable here now and block difficulty. So how can we solve this problem? Well, we can use the oracle pattern so we can import data from outside the blockchain in the blockchain. And this source of randomness is something that miners can control. So how could we do this? Well we would define another spot contract. So we call this oracle. Then we need to control to restrict the access of this. So let's, in the constructor we're going to define an admin address.
00:04:30.420 - 00:05:14.670, Speaker A: So admin equals the sender, the address that deployed this smart contract. Let's define this above as a state variable, and after we will create a function to send a number from outside the blockchain. So that will be our source of randomness. So we're going to call this, I don't know, a feed randomness. That's not a great name, but I'm not really inspired. So here that will be my rent. And this will be controlled only by the admin.
00:05:14.670 - 00:06:03.620, Speaker A: So we want the sender here to be the admin. Okay. And just very simply we will save this number here, let's create this as a state variable and we make it public. And so now in my contract what we would do, it would define here a pointer to the oracle. And we're going to define a constructor with the address of the oracle. Oracle. We can call this oracle address, makes this public.
00:06:03.620 - 00:06:54.782, Speaker A: So we're going to instantiate here pointer to oracle like this oracle address. Okay, here let's put everything on its own line because that's more readable. Okay. And so now what we could do is we call the oracle and we want to have the value of the random number. So ran like this. So now we have this unique source of randomness that is not controlled by a minor and that's really way more safe. Another thing you could do is implement a system of nodes.
00:06:54.782 - 00:08:01.142, Speaker A: So here you could define an integer, here you pass your nodes and every time you execute this function, you increment the nodes. So that means you do it slightly differently. You will call this rent and then you will return rent. But the problem if you do this is that this actually modified the blockchain. So you cannot here have a view function anymore. It needs to be called within a transaction, and when you call a transaction then you cannot have the return value. So most likely if you do it that way, then that means that you will use this function internally, and then within another function like I don't know, foo, then you will use your internal functions ran modulus I don't know, ten and then use Ren however you want.
00:08:01.142 - 00:08:09.380, Speaker A: And if you want to see some other really cool trick about solidity, I've actually have a full playlist about that, so I'll see you there.
