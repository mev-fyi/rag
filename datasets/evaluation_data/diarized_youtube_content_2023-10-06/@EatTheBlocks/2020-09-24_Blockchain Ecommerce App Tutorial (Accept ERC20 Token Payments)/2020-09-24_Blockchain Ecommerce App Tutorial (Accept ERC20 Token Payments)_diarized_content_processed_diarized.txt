00:00:00.330 - 00:00:33.974, Speaker A: In this video I'm going to give you a stepbystep tutorial to build a blockchain ecommerce app on Ethereum. The main feature of the app will be to accept crypto payments with ERC 20 tokens. We are going to code the smart contract, the backend, and the front end. For the smart contract we're gonna use solidity, open, zeppelin and truffle. For the back end we're gonna use node js and the COA framework. And for the front end we're going to use react and the bootstrap framework. There are a lot of moving parts, a lot of different technologies, so it's going to be super fun to see how it all fits together.
00:00:33.974 - 00:01:15.774, Speaker A: And if you don't know me, I'm Julian and on my channel, eatoblocks, I teach defi blockchain development and how to find your first blockchain job. And before we continue, a quick mention to my two free training. First, if you want to learn how you can become a professional blockchain developer making $100,000 a year, register for the free training down below. And also, if you want to learn how to make arbitrage flash loan, I have another free training. So we have our front end, that's what the user will see in his web browser. Then we have the back end. That's really what ties everything together.
00:01:15.774 - 00:01:44.202, Speaker A: And we have the database, that's where we track the payments that are done. And we have the Ethereum blockchain where we actually do the payment. So let's see, what's the whole process of placing an order. First the user click on a button to place an order. So this initiate the payment process. The front end calls the API of the backend to generate a payment id. Then the backend save this payment id in a MongoDB database and send back the payment id to the front end.
00:01:44.202 - 00:02:18.814, Speaker A: Then the front end will actually do the payment on the Ethereum blockchain. So this is done in two step. First, it has to approve the spending by the payment processor smart contract. So it does this by sending a transaction to the smart contract of the ES 20 token. And the second step is to actually send the payment to the payment processor smart contract. And along with the payment, the front end also send the payment id to this smart contract. So the payment processor received the ES 20 token and forward them to the address of the merchant.
00:02:18.814 - 00:03:08.850, Speaker A: So this is not shown on the graph because we don't have enough space. And at the same time it also emit an event that indicates that a payment was done for a specific payment id. At the same time, the backend constantly listen to the payment event coming from the payment processor contract, and every time it detects an event, it updates the status of the payment in the MongoDB database. So this process of listening to payment event and updating payment status in a database is independent from the payment process of the front end. So back to the front end once the payment has been sent to the blockchain, the next step is to request access to the purchase item. So that is done with another API call to the backend. The backend received this request and first check the payment status for this specific payment id.
00:03:08.850 - 00:04:01.346, Speaker A: And if the payment was done, the backend sent back to the front end and URL to download the item that was purchased. So of course here I'm talking of a digital product, but even with a physical product it can still work. It's just that instead of sending the URL to download the item, you will initiate the delivery process. Two quick note here. First, the reason why we don't send the YaS 20 token directly to the address of the merchant, and instead we use this payment processor smart contract is because we need to identify this payment with the payment id. And to do this we need to be able to emit an event from the payment processor smart contract containing this payment id. And second, the reason why we need a backend is because we need to be able to keep privately the download URL of the different items of the shop.
00:04:01.346 - 00:04:35.722, Speaker A: And we only reveal these to people who actually send their payments. But on the blockchain everything is public. You can't have any secret on blockchain. So that's it for the architecture of our app. In the next section, we're going to start coding the smart contract. In order to code our smart contract, we're going to use a framework called Truffle. When you install truffle, it already contains solidity, the programming language for Ethereum smart contract, as well as Ganache, which is a local development blockchain.
00:04:35.722 - 00:05:32.286, Speaker A: So that's very very convenient. Truffle is written in node JS. So first you need to install node js on your laptop, and next with NPM, the package manager of Node JS, you can very easily install truffle with NPM, install global truffle that you run in your terminal, and after that in your project folder, you can initiate a truffle project with truffle in it. Next, we need to initialize an NPM project to manage our dependencies. So for that we do NPM init and yes, and after that we're going to install open Zeppelin, which is a very popular library for solidity. Smart contract all right, so next we're going to open Truffle config js. That's the configuration file of truffle.
00:05:32.286 - 00:06:07.806, Speaker A: And at the very bottom we're going to change this configuration for another version of solidity 0.6.2. So that's the version that is used by Open Ziplink. That's why we need to make this change. And next we need to talk about yas 20 tokens. Yas 20 tokens are assets that live on the Ethereum blockchain. For each yas 20 token, we have a smart contract that manages token transfer and a ledger for who owns how many token. A big problem with crypto assets like yas 20 token is that their value fluctuate a lot.
00:06:07.806 - 00:06:43.586, Speaker A: If we accept any yas 20 tokens in our app, we will need to sell the tokens right away to not be exposed to the price fluctuation. That's a bit complicated. So instead we will only accept a specific kind of yas 20 tokens, called a stablecoin. Stablecoin is a token whose value always stay the same. There are different stablecoin available like Dai, USDC, USDT, et cetera. For our application, we will choose die because it's one of the most popular stablecoins and one of the most decentralized. One die always equal $1.
00:06:43.586 - 00:07:13.894, Speaker A: Okay, so now we know which yes 20 token we're going to accept in our app. So next we are going to start coding our first spot contract, which is the payment processor. So let's create a file in the contracts folder. That's where you put all your smart contract in a truffle project. Call this payment processor. Source is the extension for Solidity smart contract. Let's open this in a code editor.
00:07:13.894 - 00:07:44.666, Speaker A: I'm using Vim, but you can use whatever code editor you want. I actually recommend vs code. That's the most popular one. So first in the smart contract you need to specify which version of solidity you are going to use. So we are going to use solidity 0.6.2 to be compatible with open Zeppelin. After we're going to import a smart contract from an interface from open Zeppelin, we need this to manipulate.
00:07:44.666 - 00:08:31.974, Speaker A: Yes, 20 token. So the pass is contract token. Then we're going to define our smart contract with the contract keyword, then the name of the contract, and then we open the curly braces and everything that is inside is our smart contract. So then we're going to define a couple of variable. So first the address of the admin. So that's basically going to be the address of the merchant. And then we're going to define a variable that is a pointer to the dice.
00:08:31.974 - 00:09:12.394, Speaker A: Smart contract. And after that we define a constructor. So this function is triggered when we first deploy the smart contract just one time and it can take a couple of argument. So we're going to pass it the address of the admin as well as the address of die. So the address of die is always the same one on Mainnet. But the reason why we make it configurable here in the constructor is because we also want to deploy our payment processor on public testnet or on the local development blockchain for testing. And in this case, of course the address of die will be different.
00:09:12.394 - 00:09:46.078, Speaker A: Okay, so we make our constructor public because that's the rule of solidity. Constructor need to be public. Then we save the two arguments. So admin, address and for die, this is going to be slightly more complex. So we use the interface we got from open zeppelin and we pass it the address of die. And so with these two things, the address of die and the interface. Now with this variable we can interact with Dai.
00:09:46.078 - 00:10:37.778, Speaker A: So after that we're going to define a pay function. So that's the function that we're going to trigger to make our payment when we purchase an item. So we call this pay and it's going to have two argument. First, the amount of die token that are transferred and after another integer that is the payment id. So we make this external so that we can call this function from outside smart contract. After that we are going to transfer the token to our contract with die transfer from, so I'm not going to go over all the ES 20 token standard, but there are a couple of important function like transfer from that allow you to transfer token from an address to another one. So transfer from is delegated transfer.
00:10:37.778 - 00:11:14.026, Speaker A: That means we can transfer token on behalf of someone else and of course before we need to have been approved. So this is the standard way of transferring tokens to a smart contract. It's also possible to do a direct transfer just with the transfer function. But the problem when we do this is that your smart contract have no way to reacting to incoming transfer. But in our case we want to react to incoming transfer because we also need to emit an event. So that's why we do this pool based transfer. So the from address is the sender of the transaction.
00:11:14.026 - 00:11:50.006, Speaker A: So that's basically the buyer of the item. And then the recipient will be the address of the admin. So that means the token will never be in our smart contract, but they will be directly transferred to the merchant. And we also need to specify the amount. Okay, and after we are going to emit an event so that our back end knows that the payment was done. So for that, first we need to define an event. Here we call this payment done and we're going to define a couple of fields.
00:11:50.006 - 00:12:40.806, Speaker A: First the address of the payer, then the amount of the transfer, then the payment id, then the date. So insolidity dates are represented as integer. These are the timestamps, which is the number of seconds since 1 January 1970, I believe, which is the standard system for timestamp, not just on blockchain but in programming in general. Okay, and after that we're going to emit our event payment done. And so we specify the different parameters. So the payer is MSG sender, the amount, well that's the amount, the payment id and the date. We can use a built in variable of solidity, which is block time stamp.
00:12:40.806 - 00:13:16.978, Speaker A: All right, so we are done for the payment processor. So next we're going to create another smart contract for the DAI token. So just to be clear, the DAI token is already deployed on Mainnet. But the reason why we still need to create a smart contract for DAI is because we also want to be able to use public testnet and local development blockchain in order to develop our system. And for that we do need to deploy our own version of the DAI token. So the DAI contract we're going to create is what we call a mock. This is a fake version of the die token that we use for development.
00:13:16.978 - 00:13:49.810, Speaker A: So we create in the contracts folder die sol. First we start with the pragmat statement. So three DT 0.6.2 like previously. Then we're going to import from open zeppelin again. This time we're going to import ERC 20 sol. So that's not the interface, but that's the actual implementation.
00:13:49.810 - 00:14:41.042, Speaker A: And after we define our smart contract and we make it inerate from ES 20 from open ziplink. So this mechanism of inheritance is a quick way to get some functionality in your smart contract without any coding. So that means now with this statement here in our contract, die, we have all the function that are defined here in this smart contract. So you will see that the code we have to write is very small. So we're going to have a constructor doesn't take any argument. And in this constructor it's possible to trigger the constructor of another smart contract that you inherit from. In this sort of parent constructor you can give it a few argument like this.
00:14:41.042 - 00:15:12.342, Speaker A: So die stablecoin, die. This is for the symbol we make it public. And for the body this is empty. And after we're going to add a function to create some die token by magic. So we call this a faux set. It's going to have two argument, the recipient and the amount to create. So make it external inside we going to create token magically with underscore mint.
00:15:12.342 - 00:15:34.194, Speaker A: So that's defined in the ES 20 implementation of open zeppelin. It has two arguments, the recipient and the amount. Just to be clear, I'm not doing magic here. I'm not creating die token on Mainnet. This is not possible. This is only on public testnet or local development blockchain. This is a convenience so that we can easily develop.
00:15:34.194 - 00:16:12.586, Speaker A: Okay, so we are done with our two solidity smart contracts. Next we need to write the migration file to tell truffle how to deploy our smart contract. So for that we go in the migration folder, we're going to create a migration file called deploycontracts js. All right, here we can copy paste this template from truffle initial migration. This is used internally by truffle. We can copy paste it. Okay, so first we're going to require die, die.
00:16:12.586 - 00:16:53.078, Speaker A: So actually I don't like double quote, I want single quote. Otherwise I feel anxious. And after I'm going to import another smart contract. So payment processor artifacts require payment processor. All right. Okay, so here in this function we tell truffle how to deploy our contract. So we're going to make it async because inside we're going to use the await keyword of Javascript.
00:16:53.078 - 00:17:32.700, Speaker A: So let's get rid of this. Okay, so first we need to define new argument here to this function. So the second argument is the network that is used for the deployment. Third argument is the addresses that we can use. So when you use ganache. So the local development blockchain, it generates ten addresses that each have 100 fake ether. We're going to extract two addresses, one for the admin of the payment processor, another one for the payer, and for the rest we just ignore it.
00:17:32.700 - 00:18:18.310, Speaker A: So we're going to write the deployment if when we do a local development block shan. So the network will be develop. So first we are going to deploy the die token. Then we get a reference to the die token. So yeah, it's always a bit confusing why we have to do this in two steps. So the first statement send the transaction, the second statement wait for the transaction to be mined. And after that, once we have our reference to the deploy die contract, we're going to magically create some token for our payer so that he can buy some goods.
00:18:18.310 - 00:19:08.834, Speaker A: And here we're going to use websteries. Webstery is a Javascript library that is used to interact with the Ethereum blockchain and it's automatically injected in our deployment script by the truffle framework. And we're going to use a utility function to specify how many token we want to send. So here we want 10,000 die token. And the reason why we can't just use 10,000 directly is because, yes, 20 token like ether use a system of way. These are basically cents. So one die token is actually equal to one times ten power 18 of this way unit.
00:19:08.834 - 00:20:02.870, Speaker A: For ether we have exactly the same thing, except here it's like ether way, and here is thy way. So on the blockchain, when you specify a transfer, you always talk in terms of weight, you never talk in terms of whole token or in terms of whole ether since it's super annoying to write very very long number with 18 decimals. Then we use here this convenience function that convert our 10,000 into a very very big number. Next we going to deploy our payment processor and we're going to specify the argument for the constructor. So the address of the admin and the address of the DAI token. Okay. And for the other network we are going to do differently.
00:20:02.870 - 00:20:51.886, Speaker A: So for the admin address it's not going to be generated by ganache. We need to specify it manually for the DAI address. This is the same another address we manage ourself and we're only going to deploy the payment processor because we already have die deployed on Mainnet and also on public testnet payment processor. And we give it to address admin address the die address. So next we're going to deploy this to our local development blockchain to make sure that everything works fine. So let's quit this. So I'm going to create a new terminal to launch this local development blockchain.
00:20:51.886 - 00:21:41.822, Speaker A: So at the root of your project you're going to run truffle develop, it's going to launch Ganache, a local development blockchain that is already installed with truffle. And here we can see some output. So here you can see the ten addresses that were generated by Ganache with their private keys. So for each of these addresses you have 100 fake ether and you also have a console that you can use to interact with this blockchain. So just to be clear, this blockchain runs only on our computer, is totally isolated from Mainnet or public testnet like Coban. And so in order to deploy our smart contract, we're going to run migrate reset. Okay, so here we have a compilation error.
00:21:41.822 - 00:22:00.640, Speaker A: So that's normal. We very often have to fix a few things. So let's open payment processor Sol. So line 23. Let's go. Payment id. Okay, here I have a typo so it should be payment.
00:22:00.640 - 00:22:32.700, Speaker A: All right, let's try again. And great, our deployment is successful. So here if you scroll up you can see the output from our deployment. So here we can see our first deployment for the DaI token. And here this is deployed at this address. And for the payment processor you can also see here its address here. So we are done with the smart contract part and in the next section we're going to code the back end of our app.
00:22:32.700 - 00:23:19.970, Speaker A: There are many possible languages to build our backend, but we're going to go with node JS because that's the most popular on the web and in blockchain. Another benefit of node JS is that since it's basically Javascript server side, we don't need to do any context switch when we will code the front end after. Since we are building a server, we need a web framework. There are many web framework and the most popular one is called exprs, which is quite simple and minimalist. But we are going to use another one which is even more simple. That's called KoA. The reason why I chose KoA over exprs is because with KoA we can use the async await syntax for asynchronous operations.
00:23:19.970 - 00:23:52.734, Speaker A: So the first step is to create a folder for the backend code. And inside we're going to initialize an NPM project. So that's separated from the NPM project of the blockchain part. We're going to install a couple of dependencies. So first the CoA framework, then the router so that we can define different endpoint, then CoA course. I'll explain later. What is this then ether, that's to communicate with the blockchain.
00:23:52.734 - 00:24:26.350, Speaker A: That's an alternative to Webster that is becoming more and more popular. And then finally mongoose so that we can connect to our MongoDB database. So next we're going to create a file to manage the interaction with the database. So we're going to call this DB js. All right, let's open this. And inside we're going to import Mongoose, the MongoDB driver. And first with Mongoose we need to connect to our database so we can do it very easily.
00:24:26.350 - 00:24:54.662, Speaker A: So here, this is going to be your connection string. I'll show you where to get this. And after we're going to use a couple of options. Don't ask me why we need to use this option, we just have to use them. That's it. Okay, so next we need to define what we're going to store in our database. So in MangoDB we store object.
00:24:54.662 - 00:25:34.786, Speaker A: In collection. Collection are containers for object that are similar. So for us we are going to store one kind of object which is a payment. So we define a payment schema and for that we use this notation, new Mongoose schema with an uppercase s. And inside we're going to give it an object with the different field. So it's going to have an id of type string, an item id. So that's the id of what is purchased different from the id of the payment itself.
00:25:34.786 - 00:26:24.238, Speaker A: And then a Boolean value that says if the payment was paid or not. And so after that we need to create a Mongoose model. And with this model we'll be able to interact with this payment collection mongoose model and you give it a name. So payment and we give it a schema, payment schema. And after you export this and we're going to use this in another file. All right, so there are different options for hosting your MongoDB database. You could install MongoDB locally on your laptop, but the easiest is to use a service like mLab that gives you a hosted MongoDB database.
00:26:24.238 - 00:26:54.874, Speaker A: So you go to mLab, you create a free account. I think that at some point it's going to ask you for your credit card, but if you don't use any of the paid feature, you're not going to be charged. By the way, Mlab was acquired by Mongodb. So it's possible that when you watch this video, the URL of MLAb redirects you to MongoDB Atlas. So in this case, don't be surprised, this is normal. All right, so I'm in my dashboard, so I'm going to create a new DB. So here you can choose your cloud provider.
00:26:54.874 - 00:27:19.170, Speaker A: So I'm going to choose the free one which is AWS sandbox. Okay, then click on continue. Yes, us East Virginia, it doesn't really matter. Continue. And here database name. So going to call this blockchain commerce. Okay, continue.
00:27:19.170 - 00:27:43.180, Speaker A: So submit order. So it says submit order, but this is free, you won't be charged. Okay, so let's go in this database. So this is empty. So for the connection string we need to create a user. So here you go to users, you add database user. And we're going to call this test and put whatever password you want.
00:27:43.180 - 00:28:28.220, Speaker A: All right, and so now for the connection string we going to copy this one and back to Db js. I'm going to paste this and replace a DB user. That was test and then the password I chose. Okay, we're good. So next we are going to create our server file server JS. So we're going to import a couple of dependencies. So first the CoA framework and then the router and then course.
00:28:28.220 - 00:29:18.118, Speaker A: So course is a dependency that allow you to query different URL from the front end. So for example, if from the front end you are@abc.com and you try to make API call to another URL, then there is a security mechanism in broader that will prevent you from doing this except if you use this dependency course on your server. So since we're going to have two different URL, we're going to use this CoA course. We also need to import ether in order to communicate with the blockchain. We also need to import the compilation artifact from truffle. So this gives us a couple of info on our smart contract.
00:29:18.118 - 00:29:57.890, Speaker A: Like the abis. That's something that is necessary to interact with it as well as the address. So we have this in build contracts payment processor Json. This was created just after we run the migrate reset command. And we're also going to import the payment model that we just created in DB js. Okay, so next we're going to create a CoA app as well as a router. So after that we're going to define our route.
00:29:57.890 - 00:30:44.838, Speaker A: So first route is for our API get payment id. So this is called at the beginning of the purchase process after the customer click on the purchase button. So we ask the backend to generate a payment id and we have to specify which item we want to purchase here as a parameter to the URL. And then we're going to have an async callback. Just for now we're going to return something simple like hello world. That's how you return a response in COA. So after we are going to configure our app object.
00:30:44.838 - 00:31:32.102, Speaker A: So first we want to use course to be able to receive requests from other URLs. Then we configure our routes to be used by the app. Then we also need to do this router allow methods. Okay, and then we can finally start the server lesson port 4000. And when this is started then we're going to console log that the server has started. Server running on port 4000. Okay, so now we're going to test that everything works fine.
00:31:32.102 - 00:32:14.894, Speaker A: So node server, okay, so first I have a typo here calls, right, okay, another typo. So here I forgot, when you require a file that you create yourself, it's different than when you require an NPM package. The syntax is slightly different. Okay, so it seems to be working. So now if I create another terminal and I try to hit my API, so that's at localhost port 4000. Oh yeah. So I haven't hit any route.
00:32:14.894 - 00:32:50.346, Speaker A: So here we've set the route is API get payment id, and here I have to pass whatever id after for the item id. What do I have? Hello world. Yes, this is working great. Okay, let's stop the server. Let's go back in our file and we're going to implement this endpoint. So the first thing to do in our endpoint is to generate a payment id. So we're going to generate a random number for that math, random.
00:32:50.346 - 00:33:28.730, Speaker A: And we need to scale this for example to 10,000 to generate a random integer between zero and 10,000. And this is going to generate a decimal number, but we don't care about the decimal part. So we remove the decimal part like this. Okay, so now we have our payment id. So next we are going to create a payment entry in our MongoDB database. So for that we use the payment model we created before and it has a create method. So that's thanks to Mongoose.
00:33:28.730 - 00:34:32.410, Speaker A: We're going to pass an object inside with a different field of our object. So id, that's going to be the payment id and item id. So that's going to be passed here as a parameter to our URL item id. And so the parameter of URL in Koa, they are available in context params the name of the parameter and after that a boolean flag. Was it paired? No, because we just initiated the operation and after we return the payment id and for that we create a key payment id. And since the name of the key and the value are the same, then basically when you catch yourself doing this in Javascript, this is redundant, you can remove this part. This is a shortcut notation.
00:34:32.410 - 00:35:16.780, Speaker A: Okay, so next we need to create another rad to get the URL of the item that we purchased. So that's going to be a download URL. So of course here we're supposing that we're doing an ecommerce shop for digital products router get we define another route. This is going to be API getitemurl and we're going to provide the payment id. So here we're going to have an async callback like before. So first we need to fetch the payment from the MongoDB database. So we use the payment model.
00:35:16.780 - 00:36:11.962, Speaker A: There is a function called find one to find single item and the iD will be the payment iD. So we can get this in the context object of CoA context params payment id because that was provided in the URL. And then if we find a corresponding entry and the payment has been done then we can reveal the download URL. So CTX body and here for the URL. So actually we need to define an object here. So we're going to hard code information about our catalog. But of course in the production application this will likely also be stored in the MongoDB database.
00:36:11.962 - 00:37:19.750, Speaker A: So here we have the item id and the URL. So for example HTTP URL two, download item one and here we're going to have another item, for example id two. Item two, okay, so then back to our endpoint. So here item that is indexed by payment item id and we want the URL. And if we don't find a payment in a database or it's not paid yet, then we're going to answer with an empty URL. Okay, so we have our two endpoint and next we need to listen to the payment events from the blockchain to update the payment status in mongodb. So after app lesson we're going to define a new function.
00:37:19.750 - 00:38:12.726, Speaker A: We're going to call this lesson to events. So first we need to connect to the Ethereum blockchain using the ethers library. So for that we create new providers, JSON RPC provider and we pass it the URL to ganache. So that's HTTP localhost port 95 45. And of course when you want to run your script for a public testnet like Covan or for main net, you will need to change this URL here. And then we're going to define a network id. So for ganache this is this number, for mainnet this is one and you can find this value online, you type name of the network plus network id.
00:38:12.726 - 00:38:52.674, Speaker A: And after we need to define a contract object. So for that we use ethers again, uppercase contract and we pass it a couple of info. First we pass it the ABI. So the ABI, this is a JSON description of the interface of our smart contract. And this is available in the payment processor compilation artifact, payment processor JSon. So that was produced when we run the migrate reset command by truffle. So here we have it, Abi, or actually before we need the address.
00:38:52.674 - 00:39:36.000, Speaker A: So this is also in the same object. Payment processor networks, this is indexed by network id and we want the address. Okay, and finally we want the ether provider that we created just before. And after that we can finally lessen two event by using this payment processor object on. And the name of the event is payment done. And we're going to give it an async handler and we're going to have the different field of the event. So the payer, the amount, the payment id and the date.
00:39:36.000 - 00:40:34.274, Speaker A: So we're going to console log this from payer, then the amount, payment id, the date. So the date will be a little bit more tricky. So we need to do create a new JavaScript date. So transform the date into a number. First, this is going to be a timestamp. Then we multiply this by 1000 because the timestamp from solidity from ethereum are in second, but the timestamp in Javascript must be in millisecond. And then, okay, so let me wrap up this date object here, and we're going to use a method that is called two local string to display a human friendly representation of the date.
00:40:34.274 - 00:41:10.240, Speaker A: Okay, so let's close the Javascript template iteral. And so finally if this payment already exists in the database, we're going to update its status. Wait, payment find one. The id is the payment id. And then if we find a payment, the pet value we set it to true. And after we save this. So for that we do await payment save.
00:41:10.240 - 00:41:44.780, Speaker A: Okay, so let's try to run this server and see if there is any typo. Okay, so line 68 node js is not happy. Oh, it's because I should have put this block here inside the event handler. Okay. Otherwise it's not executed in the right place. Okay, now this is inside. Oh, and we also need to trigger the lesson to event function.
00:41:44.780 - 00:42:15.822, Speaker A: Okay, let's try again. And yeah, it works great. So now our back end is complete. Next we need to build the front end. For the front end we are going to use react and bootstrap. React is a very popular framework for building modern responsive user interfaces. This is pretty much standard and you have to know the basics of react in web development.
00:42:15.822 - 00:43:15.800, Speaker A: Nowadays, react can be pretty overwhelming for beginners. But if you use a project called Create React app, it simplify the development a lot by creating a lot of the boilerplate code and doing a lot of configuration for you. As for Bootstrap, this is a CSS framework for the lazy developers who just want a quick and dirty solution to have a decent style even if you have no test. Personally, we are also going to use Metamask, which is an Ethereum wallet distributed as a chrome extension. If you don't already have metamask installed, go to the store for chrome extension, search metamask and install it. And after that we're going to go to our terminals in the root of the project and you're going to need to install create react app. And after we're going to use this tool to create our front end.
00:43:15.800 - 00:43:48.850, Speaker A: Okay, so now we go in the front end folder. So here you can see all the files that were created by create React app. And we're going to install a couple of libraries. NPm install. So first bootstrap the CSS framework, then ethers the library to connect to Ethereum and Axios. That's a library to do HTTP requests. We're going to use it to hit the API of our backend.
00:43:48.850 - 00:44:20.426, Speaker A: Okay, so we are done. Quick note here. So in our project we have three separate NPM projects. So we have NPM project here in the folder of the front end. Then we have one at the root of our project. So that's for the smart contract and we also have a different one for the back end. So every time I show you a command with NPM install, it needs to be run in the proper folder, otherwise it will get mixed up.
00:44:20.426 - 00:44:53.350, Speaker A: Okay, so back to the front end folder. At first we're going to do some cleanup. So you go in the SRC directory. That's where we're going to have all our Javascript code. And so by default create react app put a lot of useless stuff. So I like to have a clean folder. So service worker don't need setup test, don't need logo, don't need app test js donate what else? All the css we don't need this index CSS donate.
00:44:53.350 - 00:45:25.406, Speaker A: Okay, let's see. So we just have index js and app js super clean. Now let's see. In index js we still have to remove some stuff. No service worker, no index CSS, no service worker. All right, how about for app JS? So no logo, no css. Let's remove all of this here.
00:45:25.406 - 00:45:56.582, Speaker A: Hello world. All right, let's open another terminal. Let's go in the front end, let's run NPM start. And then in your browser if you go to localhost column 3000, you should see this. So we are starting from a clean slate. So back to our code editor and we need to create a new file to configure the connection to the blockchain. So we're going to call this file ethereum js.
00:45:56.582 - 00:46:54.438, Speaker A: So that's inside the SRC directory. And so first we're going to import ethers and the contract object of ethers. We're going to use this to connect to the Ethereum blockchain. We're also going to import the compilation artifact of truffle payment processor. We've already used this JSON document in the back end and so currently this is located in build contracts payment processor JSOn. But if we try, actually it's two level up. But if we try to do this, react is going to complain because it's configured in such a way that it cannot import anything outside of the SRC directory.
00:46:54.438 - 00:47:54.560, Speaker A: So in order to solve this problem, we can modify where truffle saved this payment processor JSOn. So let's close our file here and we go back to the root of the project. And so we open truffle config and we can add a new configuration that's contracts build directory. And we specify a place inside the SRC directory of the front end contracts. We also need to go in backend to modify the import pass. So here, now we go in front end SRC contracts payment processor. Okay, so now back in the front end.
00:47:54.560 - 00:48:40.030, Speaker A: And by the way, let's redeploy our contract so that the JSON artifact can be saved in the proper location. So we go in the ganache console and reexecute. Migrate reset. Okay, and so now you can see that we have a contracts folder with our JSON file. Okay, so back to Ethereum js. And so now this is going to be inside the contracts directory, there is another compilation artifact that we need. So that's the one from die.
00:48:40.030 - 00:49:44.222, Speaker A: Okay, so after we're going to define a function, get blockchain, that's going to create our connection to Ethereum. It's going to return a promise. A promise is an object to deal with asynchronous code. So inside this promise, when we call the resolve method, that means that the promise is finished. So we are going to wait for everything to be loaded in the browser with windows window add event less render and this will fire an event that is called load. That means everything has been loaded, including the JavaScript script and including Metamask. And if metamask is present, it's going to inject an object called Ethereum inside window.
00:49:44.222 - 00:50:38.450, Speaker A: So we're going to try to detect this, and if we detect it, the first thing to do is to call window Ethereum enable, and it's going to show a pop up to the user asking him or her to grant the access of metamask for this application. And after, so we're going to assume that the user allow access. So after we're going to execute the next line where we create a provider with ether. So that's basically a connection to the blockchain. So this time our provider will be a type of type web3 provider and we pass it window Ethereum. And after we're also going to get the sign object from the provider. So with this we'll be able to send transactions.
00:50:38.450 - 00:51:35.590, Speaker A: After, we're going to instantiate an object that can interact with our payment processor smart contract. So we use the contract object we got from ethers. So this is similar to what we did for the back end. So first we pass the address payment processor networks and for the network id we can get it in window Ethereum network version. There is also a method of ethers that is called get network that gives you a network id. But when I tried this and I tried this network id here, it was a different one than the one of ganache. And after here you grab the address and now you need the ABI payment processor Abi and you pass the signer.
00:51:35.590 - 00:52:14.270, Speaker A: Okay, and after we're going to do the same thing for die. So this is going to be very similar. Copy paste this die and here replace by die. And after, once we have everything, we are going to resolve everything, we're going to execute the resolve method. So that means that's the end of our promise. We got what we wanted and we return the provider, payment processor and the die object. And with this we'll be able to interact with the blockchain.
00:52:14.270 - 00:53:11.858, Speaker A: And otherwise, if we don't have metamask installed, we're just going to return empty object for everything. And we're going to deal with this in the main file after, okay, and so after that we are going to export this function, and now back in app js and we're going to import this function because we need it. We also need to import, use state and use effect from react. So every time you do some asynchronous operation in your component and you need to wait for something to load. That's when you will use use state and use effect. First we define our state. So our state is our pointer to the smart contract payment processor.
00:53:11.858 - 00:53:53.378, Speaker A: And then we also have a function to modify this state. And this comes from use state function of react. And initially this is undefined and we have the same thing for die. And you can define as many state variable as you need. And after we're going to use the use effect function. So that's what is used in order to trigger any asynchronous operation. And after we need to give it an array of variable that must be watched to trigger use effect.
00:53:53.378 - 00:54:45.054, Speaker A: So for example, if you give an array of ABC, if ABC has three variable, anytime the value of this variable change, then use effect is going to be triggered. In our case, we just want to run this once when the component loads. So we give an empty array and here, so we need to use the await keyword inside. But we cannot give directly an async callback to use effect because that's just the way react is built. So for that we're going to use define another function and it's async and we trigger it just after, and after we're going to call get blockchain. And so we're going to get payment processor, the die variable. We await this because this return a promise.
00:54:45.054 - 00:55:17.118, Speaker A: This is asynchronous. Okay. And when we have these two variable, then we update our state with set payment processor. And the new value of the state is payment processor and for die same. Okay, so after that, that means we can use die and payment processor in our component. So before we return our HTML, we need to deal with the case where metamask is not installed. So if that's the case.
00:55:17.118 - 00:56:33.730, Speaker A: So first we need to detect that window ethereum is undefined here. Make sure to use the single quote, otherwise this equality, this test is not going to work. So if that's the case, we are going to return some HTML to tell the user to download to install metamask. So here we use some class of bootstrap call sm twelve. It means that it's going to take the whole width of the container and then the name of our application and then a message. You need to install the latest version of metamask, all right? Otherwise if metamask is installed, we're going to return the normal HTML. So same thing, we want a container and after that we want also a column sim title.
00:56:33.730 - 00:57:16.580, Speaker A: And after we're going to render another component where we're going to have all our logic for making the payment. So we're going to pass it the payment processor as well as the die object. And at the top of our component we're going to import the store component. Okay. And so now we need to create it. So we call this store js. Okay, so first we need to import react like for every react component and we import ethers, we're going to need it.
00:57:16.580 - 00:58:08.690, Speaker A: We're also going to import axios to make HTTP request to our back end and we define a variable to point to our back end. Currently this is HTTP localhost 4000. But if you deploy it somewhere, for example on Heroku, this URL is going to be different. We're also going to define a catalog here of items. So id one and the price of this item will be 100 die. So in order to specify 100 die, as I told you before, there is this system of way. So 100 die is actually 100 plus many zero after.
00:58:08.690 - 00:59:04.150, Speaker A: So it's a bit annoying to write this. So with ethers you can just specify 100 and it's going to automatically add the missing zero. So I know this is confusing because it said pass ether, but it doesn't care that you are transferring ethers or tokens. All it does is just add the missing zeros, assuming that here this is way. Okay, so after that we're going to have another product id two and the second one will be for example 200. Okay, so now we can define our store and we're going to destructor payment processor and die going to export this, okay, so after back to the component and we're going to return the HTML. So we're going to show a list of item to buy.
00:59:04.150 - 01:00:16.000, Speaker A: So we're going to use a CSS class of bootstrap list group that's going to display nicely. And then for each item we're going to create a list item. So again, this come from bootstrap list group item. And so we're going to put the price in bold, 100 die, then a button to buy this item and some styling from bootstrap. And then we're going to give it an even handler for each click. So every time this is clicked we're going to execute a function we're going to create called buy and we're going to pass the first element of the items array to give some info about the product that are being bought. Okay, so then we need to give a label to this button and we close it.
01:00:16.000 - 01:00:59.530, Speaker A: And next we're going to create another item. So we call this by item two. This one is 200 die and we want the second element of the array. Okay, so after we're going to create this buy function, it's going to receive the item as an argument. So first we need to generate the payment id from the back end. So let's do this. Axios send a get request.
01:00:59.530 - 01:01:48.638, Speaker A: And so here we need the API URL and after that the endpoint is get payment id. And after that we need to pass the item id. So we use the argument and it has an id property. And then the second step is to approve the payment processor to spend our die. For that we call approve and we're going to pass the address of the payment processor and for the amount, that's ITM price. So this send the transaction to the ethereum network. Then we need to wait that it's mine.
01:01:48.638 - 01:02:23.700, Speaker A: So for that we're going to call the wait method on the transaction object. And after that we can send the second transaction to do the actual payment to the payment processor. So first we need to pass the amount, it's item price. Then we need to pass the payment id. So that's going to be contained in the response one object we got from the back end data. So this data here comes from the axios library. And finally we have the payment id.
01:02:23.700 - 01:03:15.106, Speaker A: Okay, so here you're going to get another transaction object. We're also going to wait for this transaction to be mine and after we can finally request the download URL from the back end. But first we want to make sure that the back end had time to listen to the payment event from the blockchain and update the payment status in the database. Otherwise we're going to have a risk condition here. So in order to make sure that we don't have this problem we're going to wait a couple of seconds. So here we can quickly build a function to wait a little bit. So we build a promise and this promise is going to resolve when the set timeout function has waited 5 seconds.
01:03:15.106 - 01:03:59.890, Speaker A: So this is in millisecond here. Okay, and now finally we can get our download URL. It's axios get. Well, actually this is pretty similar to this one, so I'm a bit lazy. So here this is going to be get item URL and here this is going to be response one data payment id. Finally we console log response two and we're going to have the download URL in it. Okay, typo here, response.
01:03:59.890 - 01:04:45.314, Speaker A: Okay, so I think I made a few typos. So let me scroll up and here it's not pass ethers, but it's pass ether without s. Another thing I forgot is in index js we need to import bootstrap. So we go in node modules, bootstrap css, and here we have a minify CSS file, bootstrap min csS. Okay, so now in your front end it should look like this. So now we can actually test the app. So if you click on the fox icon of metamask, you should see this.
01:04:45.314 - 01:05:32.786, Speaker A: So now we need to synchronize metamask with Ganache. So this is cut off on my screen, but on your laptop you should see a link that says import using account seed phrase. So you click on this and then back in your terminal. So if you scroll up in Ganache, at some point you're going to see the seed phrase when you just launch truffle develop here. So you need to copy paste this, then back to metamask. You pass this, then you need to enter a password restore, and then you need to add a new network. So me, I've already done it.
01:05:32.786 - 01:06:01.190, Speaker A: I have Ganache here. But here you can go in custom RPC. So here you can put whatever network name and for the RPC URL that's very important. Here you put localhost 95 45. That's all you need save. So after you're going to switch to this network, so me, I have Ganache already. So after you change network to Ganache, you can see that your account has about 100 ether.
01:06:01.190 - 01:06:37.174, Speaker A: So these are fake ether generated by Ganache. So we're going to change the account to the account two, because in the migration file we sent die token to account two, not account one. So here you should see only one account, but you can click on create account create. And basically it uses the mnemonic phrase to generate other accounts automatically. So after you need to do something very important. If you don't do it, the nons of your account is not going to be the correct one. I spray you the technical detail, but you have to do this.
01:06:37.174 - 01:07:14.706, Speaker A: So you go in the menu in settings in advanced and click on reset account. So before you reset your account, make sure you have the correct account selected, because this reset is only per account. So finally we have synchronized metamask with Ganesh. Now we can return to the tab of our app. Let's reload this with cache clearing. It's going to ask you, okay, do you want to allow this app to access your account? So here we click on next with the second account selected. All right, connect.
01:07:14.706 - 01:07:56.314, Speaker A: Now we're going to try to buy something by the way, before we need to start the back end. So back to our terminal and you know what, I'm going to create another terminal. So in the bottom right terminal I'm going to back in and we're going to start the server with node server. All right, so now back to the front end and let's try to buy. So we have the pop up of Metamask allow localhost to spend your die. Yes, I confirm. So here this is outside of my screen, but I also have a pop up that show me that the transaction was confirmed.
01:07:56.314 - 01:08:24.422, Speaker A: Okay, so here we need to approve the second transaction to actually spend the tokens. So we confirm and then also have the confirmation of metamask outside of my screen. And after, if you open the developer console and you inspect the response from the API, then you should see this. So here in the data field URL, we can see the URL to download item one. So our purchase worked. Yeah. Congrats for following up to here.
01:08:24.422 - 01:09:07.078, Speaker A: You've accomplished quite a lot. This is really a nice project under your belt. So where do you go from there? First you could add some new features. Currently we hard code the catalog of items in the backend and in the front end, but it would be better to save this in our MongoDB database. So once you have moved your catalog to MongoDB you would create a new endpoint on the backend and on the front end you will hit this endpoint to dynamically render the list of items to buy. Also you could add some pictures to the list of items and last feature id instead of showing the URL to download the purchase item in the console which isn't really user friendly. Instead you could show this in a pop up.
01:09:07.078 - 01:10:00.878, Speaker A: Next, there is also something to fix about security. So currently anybody can read the payment id from the smart contract on Ethereum and use this payment id in order to get access to the item. To fix this we could use a system of cryptographic challenge. So how does it work? So first, in the front end, when the user want to access the URL of an item that he or she purchased, first you need to send the address that you use for the purchase to the backend. Then the backend generates a random string and associate this random string to your address by saving both in a single entry in MongodB and finally the backend. Return this random string to the front end. Then the front end is going to prompt the user to sign a message containing this random string using the private key of the address used for the purchase.
01:10:00.878 - 01:10:27.320, Speaker A: So with metamask you can do this. Then the front end sends the signature to the back end which verify that the signature is correct. Also verify that the item was paid for on the blockchain. And finally it respond with the URL to download the item. And next, if you want to keep learning and building cool project on the blockchain, you can check out my playlist where we build many other cool blockchain projects. I'll see you there.
