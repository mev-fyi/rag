00:00:00.330 - 00:00:38.526, Speaker A: Hello, this is julian and you are on idoblocks. And in this video I'm going to teach you what are the builtin variables in solidity. By the way, I created a free email course to teach you how I got my first remote blockchain job. Paid $100,000 a year. So if you want to learn all my secrets, you just have to sign up at this URL. With builtin variables, you can get information about your environment, such as the Ethereum address that called a smart contract or how much ether was transferred to the smart contract. So we can break down these built in variables in three categories.
00:00:38.526 - 00:01:05.198, Speaker A: So the first category is transaction. The second category is MSG, that stands for message. And we're going to see the meaning of this. And the last category is block. So let's start with transaction. So with transaction, the most useful built in variable is TX origin. So that's the Ethereum address that sent the transaction.
00:01:05.198 - 00:01:44.170, Speaker A: So next we have MSG that send for messages. This will give you information about the calling environment of the function. So for example, MSG value will give you the amount of ether that was sent to the smart contract. By the way, the unit of this is way. So we so way is a sort of sent for ethereum. So one way equals ten power -18 ether. So that's a very small fraction of ether.
00:01:44.170 - 00:02:26.134, Speaker A: So when we manipulate ether in smart contract, we use this elementary unit. We don't manipulate directly ether, that's way too big. And the second field that you will use a lot with MSG prefix is msg sender. So that's the ethereum address that called the function. So you're probably wondering what's the difference between MSG sender and transaction origin? Good question, my friend. So you know what, let's take advantage of this question to take a step back and understand the difference between messages and transactions. So let's take a hypothetical scenario where we have a human calling a smart contract.
00:02:26.134 - 00:03:09.706, Speaker A: And because we are doing a blockchain tutorial, I'm going to assume that the human is called Alice. So we have Alice here, a human who is calling a smart contract function. So Alice sent a transaction to our first smart contract. Smart contract A. So in this smart contract, if we check the value of transaction origin, it's going to be the address of Alice. And if we check the value of MSG sender, this is also going to be the address of Alice. So in this case this is exactly the same thing.
00:03:09.706 - 00:04:06.810, Speaker A: Then what can happen is that this smart contract itself might also call another smart contract. So let's call the first smart contract, smart contract A and it's going to call another smart contract called smart contract b. So in smart contract B, if we check transaction origin this time it's still going to be Alice because Alice is the one that signed the original transaction. However, the message is only between smart contract A and smart contract b. So this time MSg sender is smart contract a. And if you continue the logic, so if smart contract B for example called smart contract C, so transaction origin will still be Alice. However MSG sender in this case it's going to be smart contract B.
00:04:06.810 - 00:04:33.870, Speaker A: So I think that now you get the idea. So transaction is a sort of package over all the function call internal to the blockchain. So there is only one transaction origin. This is Alice. However messages, they are inside the blockchain between different smart contract. So in most cases you want to use MSG sender. Next we'll see block building variables.
00:04:33.870 - 00:05:17.602, Speaker A: So the most useful information is block timestamp. So this will give you the timestamp at which the block was mined. So you might think what is this block thing? So on the blockchain, information is organized with transaction. That's how you define when you change data on the blockchain. However, the blockchain is not just a sequence of transaction, but instead these transactions are grouped into what we call block. And these block are the basic unit that are added to the blockchain in the mining process. So this is not a video about how blockchain work.
00:05:17.602 - 00:06:04.734, Speaker A: If you are interested in this, check out the consensus algorithm and especially proof of work and you have more information about this block thing. But as a developer you only need to know that your transaction is going to be put in this data structure, this block thing, and to get the current timestamp at which the block was mined then use this block timestamp variable. It also has a synonym that is called now. So this timestamp is the number of seconds since the 1 January of 1970. But what is important to notice is that this timestamp is in second. But if you deal with timestamp in JavaScript, this is going to be in milliseconds. These built in variables are the most important one, but they are not the only one.
00:06:04.734 - 00:06:23.686, Speaker A: There are others. If you want to check the fullest, check out this link. This is the official documentation of solidity. That's it for this video. In the next video I'm going to show you what the control structures in solidity. So everything which is like if for loop, et cetera, et cetera. See you for the next video.
00:06:23.686 - 00:06:23.780, Speaker A: It.
