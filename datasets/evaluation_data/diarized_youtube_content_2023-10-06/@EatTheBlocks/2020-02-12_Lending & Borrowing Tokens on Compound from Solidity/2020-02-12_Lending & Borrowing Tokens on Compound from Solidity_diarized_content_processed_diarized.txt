00:00:00.170 - 00:00:49.302, Speaker A: When you have a defi project, a lot of time you manage some tokens on behalf of someone else instead of just letting all this money sitting uselessly on your smart contract. What if you could lend these tokens and earn some interest? Well, you can do this with compound. Compound is a deFi project that allow to borrow or lend tokens in a decentralized way on a smart contract. In this video I will introduce you compound and explain how you can interact with it from solidity and Javascript. Hey, I'm Julian and on my channel eat the blocks, I teach blockchain development and how to get your first blockchain job. Before we dive straight into compound, let's understand the different kind of loan that exists. You can have two kind of loan, secure loan or non secure loan.
00:00:49.302 - 00:01:26.914, Speaker A: For a non secure loan, you can borrow money without providing any asset as collateral. However, in general, people want to have some proof that you'll be able to repay the loan. For example, you can show how much money you're making. You can also show you create history to prove that in the past when you borrowed money, you pet it back. Some example of unsecured loan are government bonds or company bonds. The other kind of loan, called a secure loan, requires the borrower to provide an asset in exchange of the money that is lent. We call this asset the collateral at the end of the loan.
00:01:26.914 - 00:02:01.870, Speaker A: If the borrower does not reimburse the money, the collateral will be given to the lender to cover for the losses. An example of that would be when you take a mortgage to buy a house. If you fail to pay back the mortgage, the bank is going to take back possession of your house and sell it to reimburse itself on the blockchain. Compound chose to do secure loans where you have to provide a token collateral in order to borrow. In order to borrow you also have to pay some interest. Like for uniswap, you deal with a pool of liquidity. So borrowers and lenders never have to deal with each other directly.
00:02:01.870 - 00:02:42.874, Speaker A: Loans don't have any predetermined duration and borrowers can choose to pay the loan back whenever they want. As long as the value of their collateral remains above a certain threshold, they can keep the borrowed asset. Otherwise the collateral will be seized, it will be sold, and the proceed will be given to the lenders to cover for their losses. So now let's dive deeper and see what are the smart contract of compounds. So first we have the Ctoken smart contract. So these are self contained borrowing and lending contracts. They really contain the core logic for borrowing and lending tokens, there is one C token smart contract per token.
00:02:42.874 - 00:03:28.970, Speaker A: Contrary to uniswap, you cannot decide on your own to create new market. So you have to deal with all the c token that already exists. And if you want to add new market then it has to be created by using the governance mechanism of compound. You can see all the markets available at this address, so you will interact directly with one of this smart contract. When you want to lend token or borrow token, then we have the controller smart contract. So when a user want to borrow some token then the controller is going to check that this user has enough collateral across all C tokens. So there are a few actions that require you to interact directly with the controller smart contract, but in most cases you won't have to interact with it directly.
00:03:28.970 - 00:04:09.478, Speaker A: Instead that will be the C token that will ask the controller if they can do some actions. So there are still some other smart contract in the compound system, but these are really the main one. So now let's see the full process for borrowing some token from compound. So the first step is to provide some collateral to the compound system. For example, if we want to use Dai as a collateral, then first we will send some dai to the C token for dai. So we call this c token CDi. So we send the dai and in exchange the CDi smart contract is going to give us another token which is called CDI.
00:04:09.478 - 00:05:12.890, Speaker A: So CDI represents the Dai token that we send to the compound system and at any time we can redeem this CDi token against the real die token that we first sent. By the way, all these C tokens are ERC 20 compliance. It's easy to manipulate and we even have some wallet that can show you your c tokens balance such as metamask. The second step is to call the enter market function in the controller smart contract. And by calling this function you specify to the compound system that you are willing to use a certain set of token as collateral for borrowing other tokens. So you might wonder, well, this is a bit strange that we have to do this. Doesn't compound already assume that all the tokens we send to it will be used as collateral? Well, no, because by default when you first send your token to compound and you get some c token in exchange, at this point you are not borrower, but you are a lender.
00:05:12.890 - 00:06:07.918, Speaker A: That means that compound is going to pay you for all the collateral that you provided. In the example before, I just mentioned Dai and CDi, but if you wanted you could provide many other kind of collateral for all the markets that compound support. However, once you start a loan with compound, there is something called the liquidation process. So if the combined value of all your collateral on compound fall below estimates ratio that we call the collateral factor, this is specific for each token. If that happened, your position is judged too risky and anyone can liquidate your position which will basically make you lose possession of your collateral. So you need to specify to compound out of all the assets you provided, which one you want to be at risk so that you can borrow other tokens. The next step is when you're going to actually borrow the token.
00:06:07.918 - 00:06:51.818, Speaker A: So for example, if you want to borrow the bat token, then you're going to call the borrow function on the CBAT smart contract and it's going to give you some bad that you can use in whatever way you want. There is no duration for the loan. You can pay back this bad token whenever you want. When you do decide to repay your loan, you will send your bat token to the CBAT smart contract. So you will need to not only reimburse the token that you've borrowed, but you also need to add the interest. So the longer the loan, the higher the interest. The interest rate is fixed by the compound system on the blockchain and it depends on the supply and demand for the specific market where you borrow your token.
00:06:51.818 - 00:07:43.202, Speaker A: And the last step is to get back the original DAi tokens that you sent to compound. So for that you're going to redeem your CDI token. So the CDI token is going to be sent back to the CDI smart contract and in exchange CDI is going to give back your DAi token and you're going to get back slightly more DAi that you initially sent to compound because you earned some interest during all this time. But if you want to keep earning interest, then you don't need to redeem your CDI and you can just leave it in compound and you will keep earning more and more interest. So next we're going to do some coding and I'm going to show you from a solidity smart contract how you can borrow tokens from compound. So here I am in remix and I have created a smart contract. I'm using sodt 0.5
00:07:43.202 - 00:08:30.878, Speaker A: point twelve because the smart contract of compound require at least this version, but it probably also work for solidity 0.6. So first we need to import a couple of interfaces because we're going to interact with a couple of smart contract. So first we're going to interact with ERC 20 token. So for that we're going to import the ERC 20 interface of open ziplin. If you don't know what is open ziplin, check out this tutorial series. So here, this is the GitHub repo of open zeppelin and I am inside the ERC 20 directory. And so what we need is IRC 20 sol.
00:08:30.878 - 00:09:15.466, Speaker A: So that's the interface for ESC 20 token. You're going to copy the URL, then we're going to go back to solidity and here we're going to import the URL that we've just copied. Okay, so we've imported the YaS 20 interface. So next we're going to import the interfaces of compound that we need. So we need to interact with two kind of spot contract for compound. One is the comptroller and the other one is c tokens. So next we go into the GitHub of compan and we're going to go inside the compan protocol repo and we're going to scroll down and go to the contracts folder.
00:09:15.466 - 00:10:05.386, Speaker A: Scroll down and here you'll see a file called controller interface. So that's what we want. So you're going to copy everything in this file so we won't need to use all the functions, but it's just better to copy the whole interface. Then let's go back to remix and we're going to create a new file we're going to call comptrollerinterface. So let's paste everything all right back to the main file. So we're going to import this controller interface. Okay, next let's go back to the GitHub repo of compound.
00:10:05.386 - 00:10:49.546, Speaker A: Let's scroll down and here you will see another file called C token interfaces. So let's click on that, let's scroll down, let's scroll down again. Okay, so here you're going to see a first set of function transfer from, et cetera. So you're going to copy this from transfer up to c's. Let's go back to remix. We're going to create a new file called C tokeninterface cell. Okay, let's put the pragmat statement here.
00:10:49.546 - 00:11:26.310, Speaker A: Three t 0.5 point twelve. And here we're not going to use the interface keyword but we're going to use the contract keyword because otherwise solit is not happy. I just spare you the detail. Contract seed token interface, okay, and we still need to copy some function from the interface. So let's go back to the GitHub of compound and let's scroll down a bit. And here you will see some other function from mint to liquidate borrow.
00:11:26.310 - 00:12:00.446, Speaker A: So we're going to copy this and for the other thing of the interface you can just ignore it for now. So back to remix. Okay, let's paste this function. All right, so now we have all the function we want. Back to my defi project. We're also going to import the C token interface. So in this smart contract we're going to provide as collateral some dai to compound and we're going to borrow some bat token.
00:12:00.446 - 00:12:48.660, Speaker A: So we need to create a few variable to have pointer to all the different other smart contract that we need to interact with. So we need first to interact with the die token. So let's declare a variable of type interface, ERc 20, that's going to be for die, then another interface, type C token interface. That's going to be for C die, oops. By the way, here it needs to be. Okay then we need also pointer to the bat token and cbat also. So let's copy paste this.
00:12:48.660 - 00:13:50.614, Speaker A: So we need bat and here C bat. And finally we need a pointer to the controller. So controller interface, I'm going to call this controller, okay then we need to have the address of all this math contract. So a good place to have this is inside the constructor. So we're going to pass all this address. So first the address of die, then the address of CDI, then bat, C bat, and finally address of the controller. And of course these addresses will depend on which network you are deploying to.
00:13:50.614 - 00:15:01.854, Speaker A: For mennet, it will be some address covine, it's going to be another address, et cetera. So we make our constructor public and inside we need to create these pointers. So die is Yasi, 20 die, then CDI, C token interface of CDI. Okay, let's copy this because for bat it's almost the same bat, C bat, C bat. And finally for controller, controller, controller interface. Okay, so that means that when you deploy your spot contract, you need to already know all of these addresses and pass it to your constructor. And after in any other function then we'll be able to use these variables here.
00:15:01.854 - 00:15:55.002, Speaker A: So that will be very convenient. So the first step is to provide some collateral to the compound protocol. So we're going to create a function for that, we're going to call it invest. And here we're going to use the pointer to the C token of CDi, of DAi. So that's CDI and it has a function called mint where you tell it how many token you want to send it and in exchange it's going to send you some CDI. For example, let's say we are investing 10,000 die. So if you do just this, do you think it's going to work? No, it's not going to work because CDI is going to internally is going to call the die token.
00:15:55.002 - 00:16:37.818, Speaker A: It's going to call the transfer from function which is the delegated function for ERC 20. But die will say hey buddy, you're trying to transfer from your address but you are not allowed to do this. So we need to allow CDAI to transfer token on our behalf. Otherwise it doesn't work. So for that we do die approve and after we pass the address of CDI, so we cast the pointer of CDI into an address like this. After we pass the amount that we want to approve it for. So 10,000 for example.
00:16:37.818 - 00:17:53.662, Speaker A: So of course you can modify this function and instead of a fixed 10,000 number here you can put it as an argument of invest. That's up to you. So with this we have invested some die in the compound system and we have some CDI. So our smart contract here, my defi product possesses some CDI so we are earning interest actually. So next we need to create another function to redeem our CDI when we want to do the other operation and get our die token back. So for that let's create another function that I'm going to call cash out on the CDI spot contract there is a function called redeem and we need to pass it the number of CDi that we want to redeem. But the problem is that we don't really know because the exchange rate between this CDI and DAi token is increasing all the time with the interest that are accumulating.
00:17:53.662 - 00:18:36.210, Speaker A: So we cannot assume that here we have 10,000 CDI. So we going to use the balance of function of CDI to know what is our balance. So c die balance of and here the balance of us. After here we're going to pass it our balance of CDI and it's going to give us back all our DAi token. So we'll get back not only the initial Dai invested but some interest. So next let's see how we can borrow tokens from coupon. So let's create another function that we're going to create borrow.
00:18:36.210 - 00:19:17.040, Speaker A: So at the beginning we need to do the same thing as we did before. We need to provide some collateral here. Let's just copy paste this then with the controller smart contract. This time we need to call a function called enter markets that signal to the compound protocol that we want to use some token. We invested in compound as collateral for our loan. So this function accepts an array of c token addresses. So if that was Javascript, we could just do something like this.
00:19:17.040 - 00:19:49.846, Speaker A: But this is not JavaScript, this is solidity. So everything is slightly more complicated. So we're going to create this array of addresses ourselves manually. So here we're going to call this market new address array of address. And the size of this array is one. And at the first index we're going to assign CDI. Sorry, here I meant markets.
00:19:49.846 - 00:20:34.114, Speaker A: Okay. And here we're going to pass markets, okay, and the last step is to actually borrow the token. So for that we're going to use a pointer to CBAT and there is a function called borrow where you specify how many token you want to borrow. Very simple. So of course you need to make sure that the number of token that you invested as collateral here the value of this is superior to the value of tokens that you want to borrow. And you also need to consider the collateral factor. So basically the collateral factor tells you what is the extra value of collateral that you need to have in order to borrow some token.
00:20:34.114 - 00:21:15.826, Speaker A: This is specific for each market. So here we're going to be very conservative and say okay, well we just want to borrow 100 bats, that should be largely inferior to what we have here as collateral. And we still need to create a function to repay the loan when we want to reimburse it. So for that let's create a function called payback. And so on the CBAT contract there is a function called repay borrow and we need to pass in the number of underlying token that we want to reimburse. So here we want to reimburse 100 bat token. And here this is the same problem as what we had here what I explained you.
00:21:15.826 - 00:22:12.520, Speaker A: In invest function we need also to approve our bat token, otherwise the delegated transfer of yas 20 will not work. So here in the bat token we're going to approve the address of the CBAT. And actually we're not going to approve it just for 100 token, but we need to make some room for the interest. So here let's say that the interest is 10%, which is pretty high, and we need to have kept the loan for one year to have to pay that. So here instead of 100 then we're going to put 110, or actually you can put a higher number just to be really safe. So this is going to send back the bat token to CBAT so after that you have finished your loan and optionally if you want to get back your collateral. And so for that we can copy what we had here in the cash out function.
00:22:12.520 - 00:22:43.050, Speaker A: But here this is just optional. So after you've created this smart contract, you need to deploy to the Ethereum blockchain. So you have three options. First option is with local development. So you're going to deploy a local development blockchain like ganache. Second option is you deploy to a public testnet like coven. And the last option is you can deploy it to Mainnet.
00:22:43.050 - 00:23:18.460, Speaker A: Yes, I said Mainnet. And this is still in a development environment. But by using a special trick of Ganachelli that allow you to fork Mainnet and have a local copy. First I'm going to show you how you can do local development. So if you go back to the GitHub repo of compound, if you go to the root of the repo and you scroll down, then you can see that it gives you some explanation for a local install. So first you need to clone the repo locally. All right, so I'm going to go to my terminal and do this.
00:23:18.460 - 00:24:20.074, Speaker A: Next you need to step inside the folder of compound protocol and run NPM install. Okay, so let's do this NPM install and after that you can deploy the smart contract of compound with NPM run deploy. It's going to deploy the local Ganache instance. And after that you should see the address of deployment inside the network's directory. So for example, you already have some addresses for all the network like coven JSon. Here you can see like die CDI, et cetera. So after what you need to do is to use these addresses and use them in your migration script when you deploy the smart contract of your defi project and you pass all these addresses to your constructor.
00:24:20.074 - 00:25:06.818, Speaker A: So the next deployment option is on a public testnet like Covan. First you're going to find the faucet for the public testnet that you use. For example, if you use Covan, use the Covan faucet, it's going to give you some Covan ether. Then you're going to get some Dai by going to the Oasis app of Maker Dao that allow you to borrow some dai. So you're going to send some coven east and it's going to send you some Covan Dai. And once your address has some Covan Dai, you can use this dai to provide collateral for the smart contract of compound on Covan and run your test like this. And the last option is to deploy your smart contract on a fork of minnet.
00:25:06.818 - 00:25:43.702, Speaker A: And you can do this by using a secret feature of Ganache Cli which allow you to fork any blockchain. So you're going to operate on a local copy of Mainnet that is only on your computer. So don't be afraid. You don't need to download all the data of Mainnet, which is probably 1 recording this video. That would be absolutely impossible to do that. So instead Ganache is very smart and it only downloads the data it needs in order to run the different transaction that you send it to. So this is absolutely doable on a normal development machine.
00:25:43.702 - 00:26:27.906, Speaker A: So first you need to install Ganache ClI on your computer with NPM, install Ganache CLI and after you're going to run it that way. So you're going to give it an option that is fork. And here you're going to give it the URL to a node that run Mainnet. So we don't want to run Mainnet on our computer. So what we're going to do is use the Inferra service. So Inferra is a public API that can run some Ethereum node connected to Mainnet or any public testnet. So you need to create an account on Inferra.
00:26:27.906 - 00:27:18.778, Speaker A: After you need to create a new project and you'll have different endpoint for the different networks, Mainnet and all the public testnet. So you change the drop down for Mainnet, then you copy the URL. And after you're going to paste your URL here, after you're going to paste your URL here. So just before you need to give it HTTPs and it's going to be something like this. And then you will also need to have some die to one of your address so that you can create some CDI and provide some collateral to the compound protocol. Actually with Ganache you can unlock any address. So without the private key of any address you can still send transaction to your fork of Mainnet from one of this unlock address.
00:27:18.778 - 00:28:04.406, Speaker A: So that's very convenient. So you need to use the unlock the U flag and after you pass the address that you want to unlock. So we want to unlock the admin address of the Dai token so that we can mint any amount of DAi. So we're going to go to Etherscan IO, the blockchain explorer for Ethereum and we're going to search for the Dai token. So here Dai stablecoin, let's click on the contract and here we can see who is the creator. So the creator is the admin of this contract and is the only one who is able to mint any token. So let's click on this.
00:28:04.406 - 00:28:55.282, Speaker A: Okay, so we copy the address here and after we paste it here and after that you press enter and it's going to start your local foc of main net. And so now in your deployment script then you're going to mint some die token. So if you want to see how to use this mint function, then with Etherscan we're going to go back to the Dai token. Here we can read the source code by clicking on contract. And if you scroll down at some point you will see the mint function here. You pass it the address, the recipient address, and then how many die needs to be minted. And after you have your fake mainnet die then you can send them to compound and run all your tests.
00:28:55.282 - 00:29:22.460, Speaker A: If you want to know more about how Ganachali work, and especially this secret forking feature. Actually I've done a video just on that. Lending and borrowing token on the blockchain is very important. And in the next video of this series on DeFi programming, I'll show you gnosis which is a protocol for creating conditional token that allow you to basically bet on any real world event, which is super, super exciting. I'll see you there.
