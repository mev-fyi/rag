00:00:00.330 - 00:00:39.606, Speaker A: Have you heard of NFT or nonfungible tokens? With NFT, you can represent unique assets on the blockchain. Recently an auction of cryptis sold an NFT for more than $130,000. Yes, someone paid that much for a virtual piece of art on the Ethereum blockchain. NFT can be used to represent many other kind of unique assets, like the virtual cats of the cryptokitties game, some piece of virtual real estate like in Decentraland. And recently we also started to see some defi products being represented as NFT. And a lot of people are really excited about this combination of DeFi and NFts. There is just so much potential there.
00:00:39.606 - 00:01:29.334, Speaker A: So a big problem with NFT is that you cannot buy just a fraction of them. You either buy a whole NFT or no NFT at all. What if we could buy just a fraction of NFT? It would be a great way to create some extra liquidity for NFT markets, especially for expensive nfts. Well, in this video I'm going to show you how we can create a refungible token or just RFT that allow you to buy just a fraction of an NFT. This is really a great example of how you can mix defi and NFT, two topics that are super hot in blockchain right now. So make sure to follow. And if you don't know me, I'm Julian and on my channel, idoblocks, I teach defi blockchain development and how to find your first blockchain job.
00:01:29.334 - 00:02:19.394, Speaker A: And before we continue, if you want to learn how to become a professional blockchain developer and how to make $100,000 per year, check out my free training down below. Okay, so let's see how refungible tokens work. So we have an admin which will create a refugible token smart contract. But before creating this smart contract, the first step is to buy an NFT. So this admin will buy an NFT from a seller, probably going through an exchange like rarible or opensea. So the admin will buy this NFT with ether and die and will receive the NFT in exchange. And after that the admin will deploy the smart contract of the refungible token and send the NFT that he just bought before.
00:02:19.394 - 00:03:10.854, Speaker A: And after that he will start the ICO where other investor will buy some shares in the refungible token smart contract. So this investor will say die to the RFT contract and in exchange they will receive some share that represents a share of NFT that is inside the RFT contract. And at the end the admin will get all the die that was sent to the RFT. So that's to compensate him for having purchased the NFT before. And if there is any remaining share that weren't bought, then the share are also sent to the admin. So in the future, anybody with a share of this RFT can go to a decentralized exchange and do some trading. So buying or selling a share of this RFT, and you can be sure of the value of the share of the RFT because this is backed by the NFT token which is inside the RFT contract.
00:03:10.854 - 00:03:22.094, Speaker A: Okay, so now we understand how a refundable token works. The next step is to start the coding. Okay, so in order to start the.
00:03:22.132 - 00:04:03.318, Speaker B: Coding, first need to install node js on your computer. So you install the LTS version. It works on Mac, Linux and Windows. And we need this in order to install truffle, which is a framework for solidity. Smart contract and in order to install truffle, so you go to your command line and with NPM, the package manager of node JS, you install truffle globally with this command. And after that you are able to create some truffle project like this. So here I am in my project folder, truffle in it, and it has created a couple of folders and file.
00:04:03.318 - 00:04:42.758, Speaker B: So we're going to write our smart contract in the contracts folder and we're also going to do a configuration in truffle config. So I'm going to open truffle config JS. And at the very bottom I'm going to change the version of solidity that is used. So we're going to use the latest version of solidity 0.7.3. All right, and after we're also going to install open Zeppelin, which is a library for solidity. So solidity, which is the programming language for spot contract on Ethereum. So we initialize NPM project like this.
00:04:42.758 - 00:05:19.410, Speaker B: And after that we're going to install open Zeppelin and we're going to install a special version of open Zeppelin which is compatible with Sodt 0.7. So for that we go to the page of the NPM package of open Zeppelin and we go in the version tab and we're going to copy this version here. This is for three, two, 0.7 back to the command line at and we specify the version. Okay, this is install. And so next we're going to start to create our smart contract.
00:05:19.990 - 00:05:58.730, Speaker A: So we're going to create a smart contract for our fungible token, we're going to call this fungiblenft source. So that's the extension for sod smart contract. So let's open this. And so inside first we specify our pragma statement. So that tells solidity which version we want to use. So three D, zero point seven point three after we're going to import a couple of stuff. So in three DT you can import some spot contract or some definition from other file.
00:05:58.730 - 00:06:42.042, Speaker A: And so we're going to reference the library, we just install open zeppelin contracts and the path is token. Then ERC 721. So ERC 721, that's a token standard for nonfungible tokens. And we're going to use the interface of this standard so that allow us to manipulate some nft token. And we're also going to import some other stuff for ERC 20. So ER 721, this is for non fungible token NFT. But ES 20, this is for fungible token and we're going to use this to manipulate the die token.
00:06:42.042 - 00:07:22.554, Speaker A: So die, this is a token that will be used to buy share of our NF, of our refungible token. And here we need also the interface of ES 20 to manipulate ES 20 token. And we also need the ES 20 implementation because our fungible token actually itself, it will be an ES 20. Okay, so next we define our smart contract like this. And we inherit from ES 20 like this. So that means we inherit from a lot of functionality that are defined inside open ziplink contract here. So that save us a lot of code.
00:07:22.554 - 00:08:14.090, Speaker A: And after we're going to define the variable of our smart contract. So ICO share price and ICO share supply. So as I explained in the previous section, there is a phase of the fungible token of the fungible NFT where people have to buy share of the NFT and they will pay with a die. So we need to set what is the price for each share and what is the total supply for all of this share. And how can you determine these two value where? It depends on how much you bought the NFTs. For example, if you bought your NFT $100, then you can set your share price at one dollars and your supplies to 101. Hundred times one equal the $100 that you used to buy the NFT.
00:08:14.090 - 00:08:49.666, Speaker A: And they're also going to be a variable for the end of the ICO. This will be limited in time. Okay, so after we're going to define some variable for the NFT and die. So first the NFT iD. So when you manipulate an NFT you need to specify its id in the smart contract of the NFT. Because a single NFT smart contract has several non fungible token, you need to identify it. And after we're going to have a pointer to the NFT token that we manipulate.
00:08:49.666 - 00:09:23.954, Speaker A: So our fungible NFT will be for a specific NFT here. But if you want you can make it complex and make it work with several NFT. And we're also going to have a pointer to die. Oops, typo here, this is ERC 721. Okay. And after we're also going to store the address of the admin. So that's the person that buy the NFT token and send it to the fungible NFT and basically control the whole process.
00:09:23.954 - 00:10:39.510, Speaker A: After we're going to define a constructor function. So the function that is called, when we deploy the smart contract, we're going to pass a couple of arguments. So first the name of refundable token, then a symbol, then the address of the NFT token we going to manipulate. Then we want to know which NFT id we want, then the price of the ICO, then the supply of the ICO, and finally the address of die. And after that we're going to instantiate the constructor of the ES 20 token because we inherited from it and we pass it name and symbol. So now refungible token, oops, actually I meant to call this refungible not fungible mistake here. Okay, let me exit this not fungible but refungible token RFT.
00:10:39.510 - 00:11:37.370, Speaker A: Okay, here. Okay, this is more clear now. And after we're going to instantiate initialize a couple of variable, so NFT ID, then a pointer to our NFT. So for that we use the interface of Yas 721 and we pass the address of the NFT. We also need to initialize ICO share price as well as ICO share supply pointer to die as well. And also we store the address of the admin. So that's the deployer of this contract.
00:11:37.370 - 00:12:05.010, Speaker A: Okay, so let me see if we can compile this. So I like to compile progressively as I write my smart contract to make sure that I don't make too many mistake along the way. It's easier to fix the bug progressively. So no mistake so far. Okay, great. So next we're going to create a function to start the ICO. So this will be called by the admin of the smart contract.
00:12:05.010 - 00:12:43.810, Speaker A: So that's how we define function in solidity. We can pass arguments here. We don't pass any external. That means it can be called from outside the smart contract, from Javascript, for example from a web application. And here we're going to interact with the NFT contract and we're going to transfer the NFT from the admin to our contract. So for that we use the transfer from function and the from address is the center of the transaction. So that's how we know the address of the transaction in solidity.
00:12:43.810 - 00:13:26.400, Speaker A: And after to get the address of our smart contract we use this notation, and after we specify the id of the NFT. Okay, so after that the NFT is in our contract. And second, we're going to calculate the date when the ICO n. So for that we use the current timestamp. So that's an integer and we add the number of second in one week. So we're going to get the timestamp in one week. So seven days is seven times 86,402nd.
00:13:27.570 - 00:13:28.320, Speaker B: Okay.
00:13:29.250 - 00:14:23.410, Speaker A: Should be only the admin that call this function. So we can test for a condition with the required statement and if the condition is not satisfied it's going to throw an error and the transaction is going to be canceled. So here we only want the admin, only admin, okay, and after that we're going to create another function to buy a share of our contract. And as an argument we need to pass an integer, that is the amount of share we want to buy. And this is an external function can be called from outside and we're going to put a couple of require statement. We want this condition to be satisfied. So first we want to make sure that the ICO is not finished yet.
00:14:23.410 - 00:15:13.474, Speaker A: So the ICO n needs to be superior to zero. So by default, when we declare the ICO n, the variable here, by default the value is zero. So we know that if the value is not zero that means it was instantiated, initialized here and the ICO has started. And here the error message is ICO not started yet. Okay, and after we're going to have another require statement where for the timestamp, we want the current timestamp to be before the end of the ICO. Otherwise the ICO is finished and it's too late to invest. And the last required statement is we want to make sure that we still have some share available.
00:15:13.474 - 00:16:07.460, Speaker A: So to get the total amount of share that were issued, we can use the total supply function. So that's a function of ERc 20 that we inherited here. So even though, let me see. Yeah, here we inherited from ERC 20 and even though we didn't define this function, total supply we can still access it thanks to this inheritance. And so we want to make sure that everything that was issued plus the amount of share that is desired, it needs to be inferior or equal to the total amount of share that will be issued in the ICO. And the error message is not enough shares left. Okay, so after we need to calculate the amount of die token that will be paid by the buyer in order to buy all the share.
00:16:07.460 - 00:16:57.902, Speaker A: So for that we define a variable and we multiply the share amount by the ICO share price. So this is a share price in terms of DAi. And after we're going to transfer this die to transfer from, and transfer from the sender of the transaction to this contract, and for the die amount. And finally we're going to issue the share by using the underscore mint function of Es 20. Once again, we didn't need to define this function, this is inherited from Es 20. So we can mint new share to the sender of the transaction. And for the amount, this is share amount that was passed as an argument.
00:16:57.902 - 00:17:39.278, Speaker A: And with this our buy share function is complete. So the last function we need to create is a function that will be called by the admin in order to withdraw the die token that was sent to this smart contract, as well as any remaining share that were not bought. So we're going to call this withdraw profits. Doesn't take any argument. This is an external function and we're going to have a couple of required statements. So first, only the admin can call this function, otherwise everybody can just steal the die. That's not good.
00:17:39.278 - 00:18:20.060, Speaker A: We also need to make sure that the ICO is finished. So for this the current timestamp needs to be superior to icon. And the error message is ICO not finished yet. And after we're going to send the Dai token to the admin. So first we need to calculate the Dai balance. So for that we use the pointer to the Dai smart contract, and with the balance of function we can know the balance of our contract. And if somebody invested in our ICO, so this should be superior to zero.
00:18:20.060 - 00:19:08.774, Speaker A: In this case, we're going to transfer the balance to the admin. So transfer to the admin and we transfer the whole balance. Okay, and next, we also need to send to the admin the balance of shares that were not sold to investors. So maybe we were planning to sell 100 share, but only 50 share were sold, where that means for the remaining 50 share they belong to the admin because he is the one who financed the purchase of the NFT token. Originally. So here we're going to call this unsold share balance. And this is a difference between the ICO share supply minus total supply, total supply.
00:19:08.774 - 00:19:46.280, Speaker A: This is the amount that was actually issued. And here, if this quantity is positive, then we're going to send this quantity to the admin. The way we create new share is with the mint function, exactly like in the buy share function. And we see min this to the admin. And for a balance of unsold share balance. Okay, so now we need to see if it compiles. So let's try to compile again.
00:19:46.280 - 00:20:19.470, Speaker A: And it works great. So now that we have written our smart contract, the next step is to write the test. So, to test our smart contract, we can use our truffle project. So if you check all the folders in our project, you will see that there is a test folder. So truffle has a built in feature to allow you to test your smart contract. And that's very convenient. So when you test your smart contract, oftentimes you want to create some mocks.
00:20:19.470 - 00:20:59.790, Speaker A: Mocks are simple implementation of smart contract that you interact with from your main smart contracts. For example, we interact with DAI, we interact with NFT token from our contract. So we need to simulate this contract. So we're going to create first an implementation for NFT. So in contract, we're going to create this file NFT. So and we open it and specify the pragma statement. And we're going to import the ERC 721 implementation of open zeplink.
00:20:59.790 - 00:21:51.200, Speaker A: So after we define our contract and inherit from ERC 721 from open Zeplink. So that way we create an ERC 721 very easily in the constructor, we going to accept a name argument and also a symbol argument. And after we instantiate Yas 721 like this, we forward name and symbol. Okay. And there is nothing in the body of the constructor yet. After, we also going to create a min function to mint some NFT to any address we want. And we also need to specify the token id.
00:21:51.200 - 00:22:13.830, Speaker A: And we use underscore mint of Yasi 721. 1st argument is the recipient. And second argument, contrary to 20. This time it's not the amount, but this is the token id. Token ID. This is any integer that we decide. Yas 721 doesn't care what you pass here.
00:22:13.830 - 00:22:50.190, Speaker A: You just want to see an integer. Okay, so that's it for the mock of NFT token. And next, we need to create a mock for the die token as well. So the pragmas statement, as usual, then we're going to import the implementation of open ziplink for ERC 20. Then we define our contract. We make it inerate from ES 20. And for the constructor, this time it doesn't take any argument.
00:22:50.190 - 00:23:14.490, Speaker A: And we call the constructor of ES 20. Follow the name. This is diable coin folder symbol. This is just die and then empty body. Okay. And we also need to have a mint function with the address of the recipient. And this time this is going to be the amount for the second argument.
00:23:14.490 - 00:23:30.270, Speaker A: And we use the underscore mint function of, yes, 20 of open zeplink, first argument, recipient, second one the amount and that's it. Okay, so let's make sure that everything compile.
00:23:31.170 - 00:23:32.350, Speaker B: Okay, great.
00:23:32.420 - 00:23:43.730, Speaker A: So next we're going to install another package of open zeppelin in order to easily test our smart contract. This is called test helpers.
00:23:46.170 - 00:24:10.454, Speaker B: Okay, so after we're going to create our test file. So in test directory, we're going to create RFT js. So tests are written in javascript. Well, in node js. Exactly. With a truffle. And after we're going to open this file, we're going to import what we call contract artifacts.
00:24:10.454 - 00:24:58.794, Speaker B: Contract artifacts are representation of our smart contract from the point of view of truffle. And this allow us to easily deploy instance of our smart contract. You will see how it works. So first, for our refungible token, smart contract artifacts require. So this object, artifact, this is injected to this file. Due to this test file by the truffle framework we specify RFT saw, we also want Nft as well as die. The way we define test with truffle is we use this contract function here.
00:24:58.832 - 00:24:59.738, Speaker A: We give it a name.
00:24:59.824 - 00:25:05.162, Speaker B: So here refungible token. And after we're going to give it a callback.
00:25:05.226 - 00:25:06.478, Speaker A: So in our case, this is going.
00:25:06.484 - 00:25:56.880, Speaker B: To be an async callback because we're going to use the await keyword inside and it has a single argument, which is an array of addresses used by the truffle framework to test our contract. So we're going to use it. And after we're going to extract a couple of addresses from this array. So first one is the admin that control the ICO. Then we have four buyer and for the rest we can just ignore it. And after we specify our individual test in it function and we give it a name, here we can say ICO should work and it also has a callback. So it's also going to be an async callback in our case.
00:25:56.880 - 00:26:28.426, Speaker B: And first we're going to deploy the Dai and NFT token. So for that we use the contract artifact that we imported above. And here await keyword, very important. Then same thing for the NFT. Wait, NfT new and we need to give it a name and a symbol. For example, my awesome NFT symbol. I don't know, NFT doesn't really matter.
00:26:28.426 - 00:26:35.862, Speaker B: And then we're going to mint an NFT for the admin and the token.
00:26:35.926 - 00:26:37.370, Speaker A: Id will be one.
00:26:37.440 - 00:26:58.706, Speaker B: So that basically simulates the fact that the admin will buy this NfT from some exchange like opensea or rarible. And we're also going to mint some die for all the buyer. So here we want to execute several promises, several asynchronous call at the same time. So we use a promise in order.
00:26:58.728 - 00:26:59.918, Speaker A: To do it in parallel.
00:27:00.014 - 00:27:06.302, Speaker B: So die mint bio one, and after we specify the quantity.
00:27:06.366 - 00:27:10.146, Speaker A: So for the quantity, actually this is going to be the same for bio.
00:27:10.178 - 00:27:50.622, Speaker B: 1234, this is going to be 25,000 die. So we're going to define this in a variable above and we use web three. So web three is a JavaScript library to easily interact with the Ethereum blockchain and this is already injected by the truffle framework in your test. And so on the web three there are some utility function in order to manipulate units. So on ethereum when you do some financial transfer of ether or of tokens, actually you manipulate a very small quantity.
00:27:50.686 - 00:27:51.922, Speaker A: That we call way.
00:27:51.976 - 00:28:39.486, Speaker B: So this is basically a cent. So for example, one ether equals ten power 18 of this way. So that's basically a lot of 00:180 total. And for token this is the same thing, one die, this is actually equal to ten power 18 of this sort of elementary die if you want. So that's why we have to use this function here and not, and we cannot just do very simply 25,000. So it's going to transform 25,000 to a much bigger number. And this is a number that actually Javascript cannot manipulate.
00:28:39.486 - 00:29:20.906, Speaker B: So it's going to transform this into a string actually. And after that we specify here this amount of die to mint. And this is going to be the same thing for the four buyers. So buyer two, three, four. All right, and after we are going to deploy the RfT contract. So for that RfT new, and we're going to have a lot of argument. So first the name for this token, because the IfT itself, this is an ERC 20 token.
00:29:20.906 - 00:29:53.290, Speaker B: So we're going to say my awesome RFT. And for the symbol can be, I don't know, RfT and then the address of the NFT token. So NFT address, that's how you get the address in a truffle test. And after the token id. So that's one because that's the number we choose here when we created our NFT. And after the share price.
00:29:53.440 - 00:29:57.702, Speaker A: So how many die token we need for one share in our RFT contract.
00:29:57.766 - 00:30:21.294, Speaker B: So just going to make it simple and just say one. And then what is the total supply for the share of the RFT. So we're going to say 100,000. So again we have same problem for the way. So that's why we use this function. 100,000. And finally the address of die.
00:30:21.294 - 00:31:07.150, Speaker B: So die address, okay, and after we need to call the start Ico function. So this function is going to transfer the NFT from the admin to the RFT contract. But if you remember in solidity we use a function that is called transfer from, that's what we call delegated transfer. And in order to do this, first you need to approve another smart contract to spend your token. So in order to do this, we're going to use the NfT pointer that we created and we're going to call the approve function. First argument is the address of the contract you want to approve. So by the way, here it's not Rft uppercase, this is lowercase.
00:31:07.150 - 00:31:32.214, Speaker B: So otherwise we override this, it doesn't work. RfT address. And we need to specify the token id. So that's one. And after we can call the start ICo function. So Rft start ICO, all right. And after we need to invest in the ICO.
00:31:32.214 - 00:32:15.446, Speaker B: So we're going to use the addresses of the four buyers for this. So for that we need to first approve the diet token to be spent to be transferred by RFT because we're going to pay our share with die token. So RfT address. Then we allow this amount, die amount and we need to specify who is the sender of the transaction. So if you don't specify it by default, this is the first address of the addresses array here. So that's basically admin. But if you want a different sender, you need to specify it here with an object.
00:32:15.446 - 00:33:21.262, Speaker B: So we want the buyer to send this transaction. And after you have approved, you can call the buy share function, RfT buy share and which specify which amount we want to buy. So since the price is one, one times 25,000 is 25,000. So we want to buy 25,000 share. And same thing here, we need to specify, this is from buyer one and after we're going to copy paste this for all the buyer. So for buyer two then from buyer three and four and after we need to wait for the ICO to end so that we can finally test that all the token balance are correct. So the ICO time is seven days.
00:33:21.316 - 00:33:22.654, Speaker A: So of course we're not going to.
00:33:22.692 - 00:33:41.438, Speaker B: Wait seven days, but we can cheat by manipulating our local development blockchain because basically truffle, when you run these tests, you run everything on a local development blockchain, totally disconnected from the real blockchain of ethereum. So we can do whatever we want with this blockchain.
00:33:41.534 - 00:33:45.654, Speaker A: And if you remember just before in this tutorial I made you install an.
00:33:45.692 - 00:34:23.070, Speaker B: NPM package called openzepling test helper. And this test helper package has an object to manipulate the time in our local development blockchain. So for that at the top we are going to import a time object from this test helper library. So open Zeppelin test helpers. Okay, so back to the bottom of our test and we're going to manipulate the time with time increase.
00:34:25.350 - 00:34:26.146, Speaker A: We going.
00:34:26.168 - 00:34:59.180, Speaker B: To advance of one week. So we specify this in second one week plus one to finish the ICO. And after we're going to withdraw the profit for the admin RFT withdraw ICO profits. And once we have this we can check the different balances. So balance share of buyer one. So this should be 25,000.
00:35:01.790 - 00:35:02.518, Speaker A: And we.
00:35:02.544 - 00:35:48.602, Speaker B: Check this with the balance of function. Since our IFT is an ES 20 token, it has the balance of function and the balance of who of buyer one. And same thing for buyer 234-23-4234 all right, and we are going to run some assertion here. So assertion allow you to verify that a condition is true. And if the condition is not true your test is going to fail. So balance share buyer one so we transform this into a string because by default this is not written as a string. This is an object of a library called big number.
00:35:48.602 - 00:36:36.950, Speaker B: This is to manipulate numbers that are too big for Javascript. To make it simple you can change it into a string and this should be equal to the share amount, that's the amount of share that we wanted to buy at the beginning of the ICO. And we do this for all the buyers. Buyers 23434 all right, and we're also going to check that the admin has all the die token. So he's supposed to get this as a compensation because the admin is the one who spent money initially to buy the NFT token. So he should receive the DAi token from the buyer of the refundable token. So balance admin dai to get the balance of die, we can use the die contract.
00:36:36.950 - 00:36:39.260, Speaker B: It also has the balance of function.
00:36:39.790 - 00:36:41.642, Speaker A: We want the balance of the admin.
00:36:41.786 - 00:37:27.782, Speaker B: And we can assert that this variable, so also we transform into a string and this should be equal to 100,000. All right, so now we're going to run our test. Okay, so here the typo. So let me reopen this. Okay, so let's try the test again. Okay, so withdraw ICO profit is not a function. So probably that I misspelled this in RFT saw withdraw profit.
00:37:27.782 - 00:37:56.770, Speaker B: Okay, let's change the name of this function to make it match withdraw ICO profit. Let's rerun the test. Okay, so some other typo here, line 51. Okay, balance okay, same typo here's.
00:37:58.970 - 00:37:59.286, Speaker A: And.
00:37:59.308 - 00:38:01.174, Speaker B: Our test works great.
00:38:01.372 - 00:38:49.778, Speaker A: What's next in this project? So far we have smart contract the test, but we are still missing the front end. So you can do this as an exercise. And for this you will need some knowledge in Webstery, the Javascript library for Ethereum, and you can check my playlist on Webstery. So this is just a glimpse of what you can do by combining NFT and DFI. There are many other possibilities, like packaging some advanced DFI products into ES 721 tokens. This makes sense if the DFI product is very specific and nonfungible, for example, an insurance. And if you want to be able to create these mix of DFI and NFT I'm talking about, you will need first to understand well DeFi and you can practice by building a couple of DeFi projects with this playlist.
00:38:49.778 - 00:38:50.500, Speaker A: I'll see you there.
