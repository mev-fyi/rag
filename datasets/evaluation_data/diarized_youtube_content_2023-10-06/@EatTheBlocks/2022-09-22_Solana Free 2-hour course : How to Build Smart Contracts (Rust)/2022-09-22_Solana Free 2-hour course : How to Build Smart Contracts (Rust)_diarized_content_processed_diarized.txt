00:00:00.410 - 00:01:24.840, Speaker A: Alright, guys, I'm back. Another day, another video. So I think the answer for me was pretty clear to go with Solana. And so that's what I've chosen. And in this video, I intend to explain some of the concepts of how smart contracts work in Solana and the rules around coding for Solana of and then I will get into explaining this example, hello world application line by line, so that it's very clear what's going on. And then after doing that, we'll modify the smart contract and some of the Javascript code so that unlike this example, which actually isn't sending any data to the smart contract, it's simply taking the existing data that's there in one of the related accounts and just incrementing it. So we're actually going to modify this sample program to send some information over, save it into a related account, and then read it back from the client code.
00:01:24.840 - 00:02:12.882, Speaker A: So that's what we're going to do today. So let's get started on that. So I talked about how scalable Solana is. The sole tokens have just gone bonkers multiple times increases, which is pretty common in blockchain. So let's get into how we start coding for Solana. So Solana is Solana smart contracts, which are internally called programs. So when you guys start reading the documentation, you're not really going to see smart contract, you're just going to see programs, and that's their name for smart contract.
00:02:12.882 - 00:03:29.226, Speaker A: But Solana smart contracts are written in the rust language. Now, probably most of you guys watching this video aren't familiar with rust, so that may kind of turn you off possibly. But I would like to say that it's far better that they picked a general purpose language to build their smart contracts with than a specific smart contract language like Ethereum did with solidity. Because once you learn solidity, granted, there's other blockchains that use solidity, but you're constrained that the only thing you can do is build smart contracts with solidity. And that's it, right? You can't do anything else with that knowledge that you've gained. But if you learn how to code in Rust, you can basically build almost any kind of application that you want. In fact, Rust in terms of its usage and popularity, has also been skyrocketing similarly to Solana.
00:03:29.226 - 00:04:31.582, Speaker A: So recently, Facebook has decided to join the Rust foundation, which is a foundation dedicated to promoting and improving the rust language. Now, why that's super interesting is because Amazon Web Services, Google, Microsoft, Mozilla, Huawei is a gigantic chinese electronics company. All these companies had already joined the foundation. And even better than that, all these companies are internally using Rust and building on rust for their own internal systems. So what I'm saying is learning Rust is actually, whether you use Solana or not is actually a benefit to your own career. So you should definitely consider it. Okay, so in order to do Solana programming, you need to have rust installed.
00:04:31.582 - 00:05:42.140, Speaker A: You also need to have node installed because the only existing client side framework currently is web three js, Solana, web three js. And obviously that's written in JavaScript. And the projects that you're going to be building are going to be npm packages. So you're going to have to install node, install Rust, and then once you do that, you're going to have to install the CLI, the Solana Cli. So this is their documentation website. Overall it's pretty good. I think that it needs some more fleshing out certain, I guess, edge cases, certain questions about, well, what do I do in this case? Or what does that mean at a code level? At least when I was reading it, it wasn't entirely clear to me, which is why I'm making this video.
00:05:42.140 - 00:06:24.040, Speaker A: But overall, it's going to give you a good overview of Solana and how to code for it. So like I said before, you can, you're going to have to install the CLi. It was pretty easy for me. I'm on macOS and Linux. Seems like it's basically the same process, but on Windows it seems to be a little bit more involved. If you have any problems installing or running the command line tools, just leave a comment and I'll try to help you out. Just be aware of one thing.
00:06:24.040 - 00:07:22.060, Speaker A: Once you do the install, you're going to have to pick a specific network, whether it be the testnet, the main net, or the local testnet. You want to always make sure that your Cli and that network are on the same version. From what the guys on the team told me, it's better to be on the same exact version because they're making a lot of changes and sometimes things will break. So try to make sure if you are having problems that you verify that you're on the same version. And I'll show you a couple of ways to do that. So once you have done that, I'll show you a couple of things. Let's see here.
00:07:22.060 - 00:08:11.740, Speaker A: So once you do that, you'll be able to interact with that Cli. So as an example, if you run this command, you're going to be able to see again your local server. Right. So this is running the full Solana blockchain, but as a test bed on your local machine. So it's giving you all the paths related to that, and then this is going to be a key path to your own wallet. So I believe when you install the ClI, you're going to get this automatically. But if that doesn't happen for you, you can just.
00:08:11.740 - 00:09:25.730, Speaker A: Yeah, this is the guy. So you can create in here, it's showing, creating a secondary address to an existing wallet, but you can create a brand new wallet and put it to a specific path that you want to put it into. But I would suggest sticking with this default path here if you need to generate a brand new wallet. So this will get you your local configurations, this will get you the version number of the cluster that you're presently set to. So my Cli is one six six, my local cluster is one six six. And this shows you which cluster you're pointed at. But if you want to point to, let's say, mainnet or some other cluster, then you would use the set command and then point to that cluster.
00:09:25.730 - 00:10:44.710, Speaker A: So here I wanted to show you this because obviously when we're doing development, we need metrics and we need logging information about what's going on, right? So in order to enable being able to see those, you're going to want to have this environment variable set. I put it into my bash profile, but basically have all these values set, or else you might not be able to see certain log traces. So then once you've done all of that stuff, you want to turn on the local instance of the network. Right now I just turned it on, but there's nothing going to be showing up until you actually start sending instructions to the network. One more thing. The Solana team calls each network a cluster, which was a little bit confusing to me because I think about something completely different when I hear the word cluster. But basically mainnet is its own cluster.
00:10:44.710 - 00:11:32.566, Speaker A: They also have a devnet for when you want to actually deploy out to the network. The testnet is sort of the last step of testing before you deploy out to the main net. And then of course you have the local net. So each of these things are just known as a cluster. So be aware of that. Now, initially when I turned on my local cluster and I built my smart contract and I deployed it and I was running it and stuff, I couldn't see any logs and I didn't know what the heck was going on. So it turns out that additionally you need to run this command in order to see your distinct log statements.
00:11:32.566 - 00:12:46.340, Speaker A: So this thing is really just showing you sort of ongoing messages that are coming from the runtime, the network itself. And this is going to show you the explicit log messages that you put into your smart contract. So when we go into the code, I'm going to show you exactly what I mean, but just definitely be aware of this because obviously it's going to be next to impossible to debug your code without logs. So this is super important to know. Okay, so we've seen all of the major pieces of what is required to get started, and then the sample project that I am running is probably the easiest one that they have, and you just clone it off of git like this. So this is the one that we're going to be working off of. So again, it's in the docs in Solana, and let's get started.
00:12:46.340 - 00:14:44.680, Speaker A: Okay, so the first thing that I want to show is that in the NPM package JSON, there's a bunch of scripts that you can take advantage of to basically shortcut things like where is it, the build process and kicking off the application. So when you run the build for the program itself, it's going to execute this command and dump out the smart contract right here, the compiled smart contract. So then if you need access to that file, you can find it right here in disk programs. So if we look at the smart contract itself, as I stated before, it's using rust as its programming language, which again, I do think is a plus. So before I get into the specifics of what all this code means, let's do a quick sort of high level overview of how executing a smart contract will work. So at a high level, the base element inside of Solana is something called an account, and the account is like an account in any other blockchain. So the data that is being stored in the blockchain is living inside of the account.
00:14:44.680 - 00:16:21.254, Speaker A: So you're not just putting data arbitrarily directly into the blockchain, you're putting it into an account, and that's how it has existence in the blockchain. And then of course, the accounts also hold the lampports, the money that the account possesses. So kind of the unique thing about accounts within Solana is that, like I said, everything is an account, and therefore even this smart contract will actually be living inside of an account. So this smart contract in its binary form is actually going to be the data of some account. So that's definitely something to be aware of. And then also on top of that, sort of in symbiotic fashion, an account that is, every single account that exists in Solana is actually having to be owned, quote unquote, by a program. So just like a program lives, has to live, or has to gain existence in Solana by living inside of an account, every account, if it is to be accessed and modified and used, must be owned by a program.
00:16:21.254 - 00:17:46.420, Speaker A: So this ownership, because I want to make this clear, is not the kind of ownership that you might think of for some other blockchains, which is that a human owner owns an account by being the possessor of the private keys. So you still have that concept and that capability. But in Solana, that is known as a holder. So the account holder is the human that has access to the private keys for ownership, or specifically the owner property that exists in an account object. That has to be some program. So the only way that an account's data can be modified, or the land ports, the money that is in that account, the only way it can be debited, is if the program that owns that account, again, is equal to the owner property of the account is the one doing those actions. So, super important facts to know, and I just wanted to clarify that before we get into the code.
00:17:46.420 - 00:19:12.782, Speaker A: So then, the other thing to note, and to be honest, when I first found out about this, I didn't exactly know what to think about it. I thought that it might be a negative. But nevertheless, in Solana, accounts are charged rent in order to exist on the blockchain. Now, initially, when you hear that, you might kind of think of it negatively, because if you're paying rent, you're constantly having to maintain that rent balance in order for your account and its data and even its funds to exist on the network. Right. But I think that the reason why that is actually very necessary in the case of Solana is because their ultra high throughput, their transactions per second, and then the combination of their extremely low fees makes it quite easy to get spam and really just a bunch of useless data being stored in their blockchain. So over time, with that kind of throughput, which, as I said before, is only going to grow.
00:19:12.782 - 00:20:18.222, Speaker A: So they're very ambitious about how far they want to take their TPS, right, to 710,000 transactions per second and beyond. So you can imagine that over time, this could literally be just multiple petabytes and even way down the road, exabytes of data, right? So in order to keep things sane and reasonable and useful in terms of the data that's on the blockchain. I think charging rent in order for data to be maintained on the blockchain is the right thing to do. So there is rent that is charged to sustain your accounts on the blockchain. There is a way to become rent exempt. And basically you just have to have a certain minimum number of land ports in the account at all times. Then they won't charge you rent, they won't debit out any of your balance.
00:20:18.222 - 00:21:46.314, Speaker A: It'll just stay there for as long as you maintain that minimum balance. And we'll go into the code of how to discover what that exact amount is because it varies based upon how much data is being stored, which of course is fair and it makes sense, but we'll get into that once we look at the specific code. So on top of being charged rent, there is a similar mechanism to Ethereum's compute limits in Solana. So in Solana, just like any other smart contract, any other blockchain, you're going to be performing various tasks in your smart contract. And again, they call it programs inside of Solana. So your programs are going to be executing various instructions, various commands, and in order to prevent performance issues installing of the blockchain, they give you a specific compute limit based upon what you're doing in the smart contract. And that feature is no different than just about any other blockchain.
00:21:46.314 - 00:22:52.910, Speaker A: So just be aware of that. And then I'll show you some methods to know exactly how many compute units you have left. So during development, you won't get caught off guard and then end up having your programs mysteriously fail because they're out of compute units. Let's see here. So then how exactly does the smart contract, how exactly do you run and what is the process of running these contracts? So basically, at a high level, it's very similar to other blockchains. You have a block that is sort of a master container for a set of arbitrary transactions. And then of course, inside of each transaction, you have some metadata, some accounts, and then the specific instructions that you're going to be executing within that transaction.
00:22:52.910 - 00:23:39.118, Speaker A: So specifically, a transaction contains the following members. So it contains an array of signatures that may be needed in order to get the permissions to do various tasks within the transaction. For example, crediting the lamp ports, that is, taking it out of one account and then sending it off to another account. And then of course, writing into the data of an account and modifying that data. So you have that and then you have something called a message. So the message is made up of multiple parts. At the top you have the header.
00:23:39.118 - 00:24:37.640, Speaker A: The header is basically a bunch of metadata, sort of like the headers inside of an HTTP request. So in that header, you're going to have a count of signatures. You're going to have a count of read only addresses that require signatures. And then you have a count of read only addresses that do not require signatures. And this is all metadata that is used internally during runtime to make decisions and to check permissioning and stuff like that. So then after that, you have an array of account addresses. Now, this array of addresses is required because when you launch your individual instructions, those are the calls that are being made to the specific programs that need to do work.
00:24:37.640 - 00:25:50.650, Speaker A: So those programs will make a claim about what accounts they're going to be accessing for various reasons during their run. So as a part of the check, those accounts that they claim to need access to must be listed out in the total array of all account addresses being accessed in the message. So within that transaction. So that's why that is there. And then there is a previous block hash that's also going to be there. Because actually, I don't know if I mentioned this, I think I didn't mention this, but basically, a big element of how Solana works and how Solana creates consensus and maintains its security is by using time as a mechanism, in part to do that work. So they have something called proof of history as their consensus mechanism.
00:25:50.650 - 00:27:36.894, Speaker A: Solana is actually at a general level, it's basically a proof of, what is that called a proof of stake consensus mechanism. So in other words, instead of doing a bunch of very difficult math problems in a competitive way, like proof of work does, they have staking as the main mechanism to allow nodes to participate and perform consensus on the network. But in addition, they have this other structure called, sorry, trains going by. All right, so they have something called proof of history in addition to that. And I'm not going to go into depth, into any real depth in explaining this because a lot of it is just way over my head. But basically, instead of work, this mathematical work, time becomes a key element and a key method of creating consensus, making sure that the data that is in the transaction and in the block is valid and being able to allow other nodes on the network to check the validity of the block. So providing that previous block hash is just going to be a parameter that the runtime uses to make sure that whatever is being requested during this transaction is neither too old or way into the future.
00:27:36.894 - 00:28:28.302, Speaker A: So it's just a quick method of checking that within the transaction itself. And again, as the name implies, it's a transaction. So either every single thing within the transaction completes successfully, and if even one instruction fails, then the whole thing fails and gets unwound, basically. So that's what the previous block hash is about. And then you're going to have an array of instructions. Again, these are the commands that will be launched from specific programs to do various tasks relevant to this transaction. So inside of each instruction, you're going to have a couple of different things.
00:28:28.302 - 00:29:37.394, Speaker A: You're going to have the specific program id. So this program id is actually pointing to the account parent that is holding the program inside of its data, but you need to reference that so the correct set of calls are being made. And then again, you have the list of accounts that you're claiming your program is going to need access to. So these accounts again must be in that master list that I was referring to before in order for this instruction to be considered valid. And then most of the time inside of the program, you're going to do various checks, for example, the owner check and whatever is specific to you to make sure that your program is acting on the correct set of accounts that they need to be acting on. And then you're also going to have a set of parameters called instruction data. So that is a binary array.
00:29:37.394 - 00:30:27.830, Speaker A: It's a U eight array, which is just a set of bytes. They're acting as parameters for your program so that you can execute something unique to the specific time that the program is run. The data is in byte array format in order to be open ended. So there is no rule that you can only send specific types of data. You can send any type of data that you like, including objects, strings, JSON. It's all your choice, specific to what you need to accomplish in your program. So cool.
00:30:27.830 - 00:31:28.474, Speaker A: That is the high level overview of the mechanics of how these programs are called and run. And then let's look at the sample program in the example hello World project. So if you go to program rust, there is a program c. So it is possible to write your programs in c, but I would recommend against that. I think as rust continues to gain popularity, c and c plus plus are going to be lesser used, in my opinion, specifically because of the memory protections that rust provides without sacrificing performance. So that's why I'm focusing on rust in this video. But basically, you go into the folder, you're going to find only one file there.
00:31:28.474 - 00:32:29.660, Speaker A: This is the code for your smart contract from the top. If you're not familiar with Rust, this is just indicating all the libraries that you need access to in order to make your calls into the Solana runtime. I'm going to explain this and all of the borscht stuff in a moment, but let's just kind of focus on the core stuff of the program itself. So this is the entry point for your program. So we'll see later that from the client side, the Javascript code that we're going to basically have a mirror of these three parameters. And as you can see, one of them is the program id. That is the account that your program lives inside of that public address of that account.
00:32:29.660 - 00:34:14.560, Speaker A: So again, I know I sound like a broken record, but the program does not stand alone. And yes, this is representing your program, but the program will always live and exist inside of an account, which is what this is representing. Then in addition, you're going to have the list of accounts, as I mentioned before when I was going through what a transaction is, the list of accounts that your specific program claims to need access to. And then you have that data, that byte array right here of data that acts as parameters for your program to look at and make decisions on before it does its work. So the reason why it's got this underscore in this case is because that's kind of the idiomatic way of indicating that a parameter, although labeled, is not going to be used. And in the case of this example project, this instruction data is actually not being used at all, as I mentioned before. But once we go through line by line and describe and explain everything that's happening in all of this code, I'm going to be modifying this program so that we can actually send in actual parameters and make use of them, update the data, and then retrieve the data towards the end of this video.
00:34:14.560 - 00:35:34.882, Speaker A: So, moving right along, this is the call to do logging. So, like I was mentioning in the beginning, we want to be able to see the things that are happening and in what order they're happening, values for various pieces of whatever parameters, data, whatever it may be, so that all shows up after I run this command. And the code or the line that executes logging is this guy right here. So if you know rust, you might have expected like print line macro instead of this message macro, but they give you this instead. They don't support printline because they say it's a little bit not performant. But if you don't know rust, it's okay, because we're not going to go too deep into rust because the focus of this video is Solana. But I will try and explain sort of these sort of OD syntax statements.
00:35:34.882 - 00:36:44.320, Speaker A: So basically, whenever you see something that looks like a function, but ends in an exclamation, what this is is a macro. So all that means is that this is sort of a shortcut that points to a multiline set of actual code like you see here. So it's just a shortcut way of using just a single command to get something that is much more complicated, sort of handled for you or written for you by the compiler. So that's what this thing is doing right here. And with just about any other printing or logging in rust, we can do string interpolation. So if we did this, this object, which is not real, but this object would end up showing up in here, the value of it would end up showing up in here. So we're able to do things like that with this logging statement if needed.
00:36:44.320 - 00:37:27.082, Speaker A: So at the very top, we're going to just let the world know that we've begun our smart contract. It has begun processing here. What we're doing is this is an array of accounts. That object type is called account info. So Solana, as you've already seen by this array for the list of parameters, is very low level. And although that makes things a little bit harder to code for, they do that deliberately for performance purposes and for flexibility purposes. Right.
00:37:27.082 - 00:39:01.306, Speaker A: So the net effect of that is, for example, when you want to gain access into the accounts, it matters the order in which you place these relevant accounts. And your smart contract has to be aware of that order and grab the appropriate specific account in the right order in order not to make mistakes. So iter is just making this array iterable, which just means that you take the first element or you take the entire array and then you call next on it, which gives you the initial next element. Then when you're done, you call next on it again, which gives you the next element, and so on and so forth. So you're able to iterate through each element in the array. And then this just means that you're getting a reference to a mutable version of that array, which is only required because we're iterating. Okay, so then we have this iterable array that we grab, and then instead of manually calling next next, we just use this helper tool, this helper function, to do that automatically for us.
00:39:01.306 - 00:39:42.102, Speaker A: So this just means every time this guy gets called, it just gives me the immediate next account out of the array. So in this case, this is the first time that I called it. So of course I'm getting the very first account in this array. And then this next call that's being made is it's taking the desired program and confirming that the owner of this account that I want to do something to. Right, and we'll get into that over here. But the owner of this account that I want to do something to is this program. Right.
00:39:42.102 - 00:40:31.556, Speaker A: So we're verifying that that is indeed the case. And then if it's not the case, then we log it so that we can see it on the console. But we also send this error type to be specific about exactly what the failure was. And again, if this fails at any point, then the entire transaction that this was living inside of is going to exit and unroll itself. So let me just turn off the discord. All right? And as I said before, owner does not mean owner like a user with private keys. It means the controller of the account.
00:40:31.556 - 00:41:09.664, Speaker A: The programmatic controller of the account. Okay, let's say we pass this point. So then what is it that we're trying to accomplish in this particular sample? Smart contract. So what we're trying to do is we're trying to take the data that exists in it. And again, we can put in, this is a byte array as well. So we can put in whatever type of data that we want, and we just have to be able to encode and decode it properly. And I'll explain how that works in a moment.
00:41:09.664 - 00:42:12.724, Speaker A: So that's this stuff that you see right here. But specifically, once we get that data in its proper form, this particular sample is just incrementing a number, Right. So it's a pretty useless example, but nevertheless, it gives you some of the knowledge about the basic mechanics of how to do this. So all it does is it increments this value, this member value, which is a part of this type. And then once it does that, in this case, it decoded the data. So it went from a byte array, arbitrary byte array, and then it decoded it into its actual type instance. Then after doing whatever it is that it needed to do, it's now taking it and encoding it back into the data.
00:42:12.724 - 00:43:10.204, Speaker A: And then we close off by logging that, we're done. Again, we have that string interpolation that we're able to send this value and inject it into here. So that's basically what this program is doing. So let me explain some of this serialization stuff. So up here you see that we're importing this library, and Borsch is actually an acronym. It stands for something like binary object serializer deserializer. I forget exactly what the acronym is for, but basically you get the point, it takes a binary format and it either deserializes it or it takes some sort of data type and it serializes it into the binary format.
00:43:10.204 - 00:44:23.324, Speaker A: So that's why these guys are being used. And then in the case of the actual type, the data object itself is represented inside of the accounts data right here as this object type right here. So greeting account, and inside of rust, in the rust language, there's really only the type, struct, enum and tuple. There is no class concept inside of rust because it's not really an object oriented language. But regardless, this kind of type, a struct type is where you can hold data of various kinds. So again, that data being held is just a number in order to increment the number of times that this smart contract was just executed. So it's not actually holding any real worthwhile data, but for testing purposes it's fine.
00:44:23.324 - 00:45:30.740, Speaker A: So that's what they're using. And then this stuff up here is, again, this is a type of macro in the form of an annotation. So it's a lot like annotations that you would see in any other language, typescript, c sharp, java, whatever. So basically it allows you to inherit, or it allows this guy to inherit functionality from these three types without having to manually write the code yourself. So any preexisting function members or methods that exist in here will just be automatically allowed and applied to this type. So inside of rust, this is known as traits. So traits are basically the same thing as interfaces or in swift they're called protocols.
00:45:30.740 - 00:46:38.612, Speaker A: So normally there's some manual coding with the imple keyword to manually write the code to inherit from these different traits. But doing this is a shortcut way of basically getting the same effect. So by doing this, we give greeting account right here, greeting account, the power to encode and decode itself from the binary to whatever the type instance may be. So one last thing before we exit the program. So if you were wondering what this is, this is really an awesome feature in Solana. More than likely other blockchains have it. But basically in Solana you do not have to create monolithic smart contracts.
00:46:38.612 - 00:48:26.876, Speaker A: In other words, you don't have to create a single smart contract that does every single thing that you need your application to do. So it's possible for smart contracts, in other words, to call into other smart contracts, whether they be a smart contract that you created or a smart contract that somebody else created, but they make it accessible to other people. So whether it be for kind of trimming the amount of work that you have to do as a developer or better structuring your smart contract apps, it's possible to divvy up, for example, your smart contract into multiple smart contracts, because depending on the scenario, you're not necessarily going to have to run all of the logic in your app at any given time, right? Sometimes you may run only a certain set of instructions. Sometimes you may have to run all of them. Sometimes you may run some combination of them, including other people's functionality, whether they exist already in the runtime itself or maybe some other third party created it. But nevertheless, this capability is a simple way of allowing this specific smart contract to be entered into and controlled by another program. So just make sure that if that's what you want, that you have this in there.
00:48:26.876 - 00:49:20.056, Speaker A: And then you also need to put into your cargo toml, the configuration file of any rust program. So this is analogous to package JSOn in a node application. So you need this and then you need this in order to make that work. All right, so cool down here is just the tests for this program, but we're not going to get into that stuff in this video. If you do want to see that, just leave a comment and I'll make sure to go over that in the next video. All right, so cool. So this is how a smart contract is set up in Solana.
00:49:20.056 - 00:50:13.708, Speaker A: And then if we go to the Javascript, so TS files are typescript files, but effectively the same thing. So this is what from the client side is going to be accessing the smart contract, sending over instructions. Hey, do this, run this, change this, stuff like that. So this code is running off of mostly this library right here at Solana web three js. I do not know if they're working on a swift version of this API. It wouldn't surprise me if they are. They probably are, but it doesn't exist as of yet.
00:50:13.708 - 00:50:59.640, Speaker A: So if you're wanting to run swift, you would have to use the JSON RPC interface for that. If you want to see a video on that. I think more than likely I will do a video on that, but let me know in the comments if you want to see that. So as you can see, even on the client side, we do have to do the serialization deserialization, and I'm going to show you that in a moment as well. So here's the thing. This is called client, right? And definitely running this from the command line. This is a client.
00:50:59.640 - 00:52:00.770, Speaker A: So to speak. But just be aware that because this specific code right here does access the file system, which of course programmatically isn't allowed in a browser. So the code as is is not going to run in say for example, a react application. So just be aware of that. But in the next video in this series, I'm going to do a lot of modifications to this example code because I intend to create sort of a payments messaging chat application. So we're going to move all of this code from the command line and we're going to move it into a react app to build like a more fleshed out realistic application. So we're going to see that in maybe the second or third video.
00:52:00.770 - 00:53:14.310, Speaker A: All right? So just like everything else, you're going to need to do some imports. There's going to be a lot more imports in the related files. But basically if we start from the top, the first thing that we need to do is make a connection. And the reason for that is, like I said, we can choose which cluster that is, which network that we want to be on for testing purposes, right? So this is going to make that selection for us and then give us this connection object that we can reuse so that we're always on the right network. So then before I get into that, let's cover some of these utilities. So this is just a mechanism to do sleep because some of these calls, since they are going over the network, they can take a few seconds to actually finish. So this guy will allow a pause of some time before continuing.
00:53:14.310 - 00:54:00.420, Speaker A: So then after that, what we're doing here is we're trying to create, I don't want to say account. So let me just pick my words carefully here. We're trying to give ourselves a certain number of land ports money by requesting an airdrop. Obviously this is not going to work on Mainnet. This is only for testing purposes. And then we're verifying that, or we're trying to verify that that was successful. Now the reason why I wanted to pick my words carefully here is that this account that you see here is not an account.
00:54:00.420 - 00:54:57.800, Speaker A: Okay? So I just want to make that super clear. This is not a Solana account, even though that's the name that this thing was given. This type was given. This is actually a key pair, meaning an object that represents the private and public keys for an account, for an account which will be created later. So if you see this, just don't assume that that's like a real account, because it's not. Okay, so I'm going to look at my notes just to make sure I didn't skip anything. All right, so then, moving right along, we have this configuration information.
00:54:57.800 - 00:56:00.310, Speaker A: And this is this stuff right here's this stuff right here. And like I was saying before about the keypath pairing for your own wallet. Normally this thing gets auto created when you install the CLI. I'm not sure because they're making updates all the time. I'm not sure if that's still the case, but I did show you early on how to set up a new wallet if you need to, for whatever reason. And then I think I mentioned this before, but there are specific preexisting programs, smart contracts on the network already for you to make use of. So this is a very important one, the system program.
00:56:00.310 - 00:57:08.970, Speaker A: We'll get into some of the functionality in a bit, but this is the id, the public address for that system program, and then various other configuration informations. So this is where you're going to find the default wallet, private keys. All right, so that's what this code is about. So like I mentioned, file system, programmatic file system access isn't allowed on the browser. So we'll get into handling all of this stuff and building an app in some of the next videos. All right, so the URL, right, we're using the local, which is this guy right here. So that's what that's about.
00:57:08.970 - 00:58:37.860, Speaker A: So this is about configuring and creating a key pair, again, not the account, a key pair that represents the account from which monies land ports will come out in order to pay for all of these transactions that we're about to execute. So of course, since we're on the local testnet, none of this is real money, which is why we were able to. Where is that? Ask for an airdrop, which wouldn't be possible in production. But nevertheless, every transaction that you request requires a certain amount of money to be paid for that transaction. And we're going to see how to calculate that in a moment. But basically we're trying to create, or begin to create that account by first getting the private public key pair and the preference in the case of this example, although this is not something you have to do, is to use your own default wallets key pair in order to generate that account. But again, you don't have to do that if you don't want to.
00:58:37.860 - 01:00:05.280, Speaker A: And then this function right here, read account from file, is just a function that encapsulates that capability of taking that key, putting it to this account type, and generating a key pair object out of it, which again we'll later use to create a real Solana account existing on the network. So this module is just acting as a bunch of utilities helper code for the real meat of the client side code. So if we go in here to establish the payer. So like I just said, we need to calculate or estimate what the fees are going to be for the entirety of all the work that we want to do. So that's what this thing is attempting to do right now. And the system, the runtime, provides this call to give us this little helper object that can help us to make those calculations. So if we go line by line here, we're calling this function, and as the name implies, get minimum balance for rent exemption.
01:00:05.280 - 01:01:15.420, Speaker A: Like I said before, you have the choice where you can either pay rent in order to keep your account alive on the network, or you can stake a higher number of lamp ports in order to not have to pay rent, not have your balance decrease, and just have your account remain on the network indefinitely. So in order to figure out what that amount would be, this function requires the size of your account's data, which is given by this constant. And I'll show you in a moment exactly how that size is known. But let's kind of focus on this local code right here for now. So then we add that to the total fees. And then next, what we're doing here is just an estimate, which is why you have this arbitrary 100 number here. But basically there's per signature that is required.
01:01:15.420 - 01:02:08.330, Speaker A: I guess that changes the calculation fee for some internal reason. So this is going to give you what that lamp port number is, and then this is just there sort of arbitrarily because this is a test environment and we're just going to be running this over and over and over again. And we're not necessarily going to recreate the payer account every single time. So it's just giving us an extra buffer of land ports so that we don't have to keep restocking it and ask for another airdrop and stuff like that. Right? So we saw this function before. It's going to create that again, it's a key pair, it's not the account. So we're going to create that.
01:02:08.330 - 01:02:53.994, Speaker A: So this guy is doing effectively the same thing. Let me see if I can find it. Right. So we're requesting the airdrop, we're confirming that it was good and then we're giving back the key pair. So if this line fails, then this will run instead. So then either way, whichever mechanism ran this is going to check that we have sufficient lamp ports because again, we might be running this over and over again. So we might have run out.
01:02:53.994 - 01:03:45.900, Speaker A: So then if we do have less than whatever is required, right, whatever we deemed required, then we're going to request another airdrop and confirm it just like we did before. So obviously this is just some logging stuff. And then let's go back in here. So the next thing that we're going to run is the check program. Now, I started using this sample project actually a little bit ago, and they've transformed it a lot. Like I said, they're constantly making changes and doing work to upgrade various things in the system. So they very recently updated this example, hello world project.
01:03:45.900 - 01:05:00.986, Speaker A: So before they were using Bpfloader load in order to get your program loaded so that it could execute, but now they're not doing that and they're actually manually forcing you to deploy the program first and then making it accessible. So to explain what the heck I'm talking about, let me just see here. Okay, so we just ran the compile command. I think I showed you that before in the package Json file. So after it runs, it's going to ask you to actually deploy manually the program. Right. So again, we use the CLI program and then we deploy to wherever the path is.
01:05:00.986 - 01:06:46.330, Speaker A: So when you're doing this, just make sure that you're pointing to the right path. So assuming that you did that, then we'll be able to just go ahead and continue and get any relevant parameters. Program id again is the public address, but if it fails, then you would see this error which is indicating that you need to deploy the program. So before I move on, as I just mentioned, there's this thing called the BPF loader, right? So just like there exists the system program that allows you to do certain things like create a new account, debit an existing account, assuming system program is the owner of that account and things of that nature. In order to load a program that has been deployed into the runtime, the BPF loader, as the name says, will load the program that you request into the runtime as a part of doing that which is required to run your program. But as a part of doing that, it will mark the program as read only and it will mark the program as executable. So every program that wants to be run needs to be set up as read only and executable.
01:06:46.330 - 01:08:24.940, Speaker A: And when I say every program, I'm talking about the account that the program lives in in order for it to become usable. And once these two settings have been tripped, once they've been set, then they can never be unset and the program account has to stay in that format essentially forever. The other part of the reason why I mentioned this is that there are these flags in every account representing whether it's read only or writable, on top of things like ownership and on top of things like the holders, the human holders private key signature. You also need the account to be marked as writable before you can actually make modifications to it. So if that is not the case, then an account can still be accessed, but only as a read only and only for adding land ports as opposed to debiting out lamp ports, which the reason that's open ended is everyone is happy to receive money without having to ask for it. I'm sure that's the case for you. So that's why they left it kind of open ended like that.
01:08:24.940 - 01:09:39.982, Speaker A: Let's see here. So moving right along, assuming that was successful, this call is going to get the actual account living inside of the blockchain based upon the program id, the program's account's public address, right? So the real account objects are called account info inside of the runtime, and then it checks if this call actually brought something back, right. And then if it didn't, then it makes sure that there's actually a compiled binary of the program itself. This guy right here, hello world. So and then if there isn't, then it lets you know what went wrong and then it handles other issues. Here's that flag about being executable. Every program's account must be executable.
01:09:39.982 - 01:11:00.380, Speaker A: And then assuming all of those checkings were successful, then you have the program id that resulted in string format displayed in the log. So here, as the name says, we're creating a seed in order to prepare for the actual account info objects creation. So we need the owner of the account, we want some generic seed and then we're just using this as another parameter thrown in there. And I'll show you where this is reused later. So like I was saying before, this set of code is going to get run over and over again. And so that you're not constantly recreating the same set of accounts, you're going to see a lot of these checks to check if the account exists or not, and then to create it if it doesn't. But basically you have this generated public key.
01:11:00.380 - 01:12:04.262, Speaker A: It checks to see if that account already exists. If it does not exist, then it proceeds to try and create it. So this is where we're starting to get into some of the beefier parts of coding into the runtime and accessing the runtime. So again, we check to see really the minimum land ports that we're going to need to not have rent collected on us. So this greeting account is going to be the account that is written to buy the program. So we want to make sure that we don't have to constantly pay rent. So in order to do that, we need to check the size of the data that's going to be in there because that is directly proportional to the amount of rent exemption monies that are required.
01:12:04.262 - 01:12:39.500, Speaker A: And I'll show you how this is calculated in a moment. So that's what we're doing here. And then we go ahead and create our first transaction. And inside of every transaction, as mentioned previously, there is instructions. So the first and only instruction is this guy. Again, the system program can create accounts for us. In this case, we're using a seed value in order to create the account.
01:12:39.500 - 01:13:43.344, Speaker A: This guy right here is going to be our payer for this transaction. Every transaction requires some amount of payment. This is the key pair that we would like to be used. This is the base amount of land ports that we want this account to have in order to be exempt from rent. This is the size of the data that we're requesting on this account. This is the program id that will own and therefore control and access and update this account. Be aware that the space allocated for an account technically can be updated, meaning it can be grown bigger if you need it.
01:13:43.344 - 01:14:55.800, Speaker A: But currently the Solana team recommends that you don't do that because they told me that it's a very arduous, difficult process to do. So for now, you probably want to be careful about the sizing that you give and make sure that it's right for your needs in the future. They did say they're going to make that process easier, but if you need to deploy in the immediate term, you're going to want to pay special attention to this value. All right, so after setting up or checking that our program is set up, we're going to do a quasi say hello. And I say quasi because nothing ever gets sent of any significance to the program right in the program, it's just doing an increment of the data. But we're going to use this later to actually send data. So in this case, we get the account affected, we create a new transaction.
01:14:55.800 - 01:16:12.930, Speaker A: The transaction is going to have the affected account. It's not going to be a signer. It's going to be writable because that's what we're intending to do, the controlling program and then any data that might be sent over, which again in this case doesn't apply. So then we run it on the same network within, embedded within a transaction. And then this is who's going to pay for this, right. So then the last call that's going to be made, as you can see here, the last call that's going to be made is to retrieve data from that account off of the network. So we're going to attempt to get the greeted account, so the account info, and we're going to do some deserializations and then we're going to attempt to show, display that counter value.
01:16:12.930 - 01:18:06.870, Speaker A: Okay. So as I mentioned before, we had to figure out the sizing of the account and we had to do some serialization deserialization, right. So it's very similar to how Borsch works inside of rust, as we saw when we were looking at the program itself. So let's see here. Okay, so the way that the team did it, and I totally agree with this because they weren't doing this before, but now they are, is they made everything statically typed. So this struct type on the rust side is analogous to this class type on the typescript Javascript side. Now, the reason why it looks a little bit weird is because although it has only this one member in it, the borsch, the Borsch library requires this as sort of metadata, right? So if we had two or three members in there, then they would all be listed out here in the count of fields, and then they would all be set inside of this scope.
01:18:06.870 - 01:19:36.610, Speaker A: So that's why it looks a little bit busier than perhaps it needs to be with only one member in it. So then what's happening here is that again, Borsch requires some additional metadata in order to do a mapping. So in this case it needs the type that is coming from the client side, and then it needs some mapping information of how that maps to the actual program side. In other words, the rust code so kind refers to the fact that it's a struct, and then fields refers to the name of the member inside of the rust side and then its type. And because you could have more than one member, this is an array. So these things are being provided to the serializer so that it can properly serialize and deserialize so that each platform will understand according to its own needs. So then here we saw this constant before in order to figure out how much money we needed to be rent exempt.
01:19:36.610 - 01:20:19.310, Speaker A: So we saw that a couple of times. And this also is needed to size the actual data size of our account, our greeting account. So this thing is serializing. It's an array of bytes. Eight bits is equal to one byte. So it's an array of bytes. So it's serializing to that destination data type and it's taking out the length, the size of it, and that's how it knows how much data size is required.
01:20:19.310 - 01:21:32.790, Speaker A: Okay, so then this is like encode decode, right? So this is encode and then down here you're going to have the decode, right. So now I got my account info object back, I'm ready to deserialize. So I'm ready to take it from that binary format, tell the bors system, hey, the account type on this client side is of type greeting account. The schema that you need that you understand and recognize is this over here. So I want you to convert this to an object that I in JavaScript land can understand. So then it goes about doing that. So now we have, let me just make it more clear.
01:21:32.790 - 01:22:55.306, Speaker A: So now we have an actual greeting account object instance so we can have statically typed members and know what this is supposed to be and console logit. So yeah, that was a lot of information. I just wanted to be clear because when I was doing this there was like a ton of stuff that I just wasn't getting and I had to kind of struggle and Google and all the normal stuff that you got to do. So hopefully this information is helpful. And again, before we start modifying this smart contract and the related code, if you have any questions and stuff, just leave a comment and I'll try to answer them. All right guys, so this video ended up taking a lot longer than I thought it would, so I ended up just refactoring the code myself and I'll just go through the changes that I made. So what I did is everything up to here is basically the same.
01:22:55.306 - 01:23:55.870, Speaker A: And what I did is I'm passing in the data as a binary instance of this account type from the client side. So I am using the previously mentioned Borsch serializer deserializer. So in this case I'm taking the data as a array of bytes, so as a slice, and then I'm basically decoding it with this command right here. And that gives me an instance of greeting account. This call right here is just to make sure that if the decoding fails that I'm able to notify with a log message. And then the type of error that occurred. And again, I have multiple log messages.
01:23:55.870 - 01:25:19.370, Speaker A: And then I take that same instance of the data from the actual account that we need to update. And then what I'm doing is I'm taking that data, I'm finding a range in it that is the same size of the instruction data. And then I am copying that data into. So I'm copying the parameter data into the actual accounts data. So copy from slice. The only reason why I instantiated this basically is because I wanted to make sure through the logs that I'm getting the appropriate data, the appropriate values. So technically you don't really have to do this, but in part of doing this, I'm also demonstrating that this parameter data that is of type u eight array, it's possible to pass in really any kind of data that you want, even specific object instances.
01:25:19.370 - 01:27:16.644, Speaker A: So not entirely necessary, but still demonstrates the flexibility of this type. So after doing that you would have to, you would have to build your program, and then after you build the program you would deploy it. So make sure to do that and you're ready to go as far as the program is concerned. And then as far as the code is concerned, the changes that I made are right here. So if you look at this portion with the greeting size, you can see that I actually instantiated an instance of the greeting account and I added sort of this placeholder data and then I passed that instance in. And the reason why I'm doing this is because that sizing is responsible for the space allocation for the greeter account. So the reason why you need to know that is because once you give it a certain, once you give it a certain size, ultimately these are byte arrays, both the instruction and the data.
01:27:16.644 - 01:28:59.300, Speaker A: So they're statically sized at definition time and they can't be changed thereafter. So what you're going to find, at least if your data schema is in the form of some type, what you're going to find is when you're passing that data in through this copy command, the data sizes have to basically match up or else you'll end up getting various serialization deserialization issues as you're using the data. So what I was trying to do was pre allocate a specific size to my account and then make sure that I'm filling in an appropriate value for the input. So in this sample codes case, the input is going to be just a message. So the way that I set it up, this guy, this say hello used to have no parameters. So this time, because we want to send a string message to the account, save it in the account, and then retrieve it later. I'm now passing a parameter, and then after passing that parameter, I create a new instance of the greeting account that we're using as our schema for data being passed back and forth.
01:28:59.300 - 01:30:30.008, Speaker A: So then I set the TXT member field, and then it's that data instance as an object, as an entire object that's being passed in. So because it has to match to this schema on the rust side. So a struct with a member called TXT and a string I can't just pass in this alone. So in other words, I can't just do this and pass it in this way because the schema is actually not the same, not the exact same. So if you remember the real schema for the Borsch serializer, looks like this, where yes, you have a member called TXT, but the constructor is actually receiving a field object that may contain multiple members. And then the schema file which has the mapping between the client side type and then the type on the program, the smart contract. So I'm indicating that it's a struct, I'm indicating that there's a TXT member and I'm indicating the string.
01:30:30.008 - 01:32:02.240, Speaker A: So those things, um, those metadata have to go, have to ship over to the, have to ship over to the, to the program in their correct form. And that's why this serialization is necessary. And then after that you have to wrap it in a node buffer so that it can go over as a blob basically, and be sent over. And then in the program itself it gets deserialized. Um, actually it doesn't even need to get deserialized to be inputted, but it gets grabbed in and then inserted through this copy command inside of the data because this is also ultimately a byte array as well. So then when we retrieve it, everything else is basically the same but this section. And then anytime in here, if you are needing to do a deserialization, that's where things will fail if these lengths aren't exactly the same.
01:32:02.240 - 01:33:22.422, Speaker A: So this issue, I think for the most part exists because I am passing actual object instances back and forth. So if the sizing, the length sizing is not identical, then you can end up getting various issues. So this length right here is actually the same length as this, right. So you're going to have to come up with your own mechanism to, how should I say this? Let's say for example, the text that you're submitting is actually shorter than the sizing of your account data object. So then when this deserialization happens, you're going to end up getting an error. So I'll show you that now. Right? So unexpected three bytes after deserialized, right.
01:33:22.422 - 01:34:58.280, Speaker A: So there's an additional set of kind of empty places, those three positions that I deleted. So you're going to have to come up with some sort of mechanism, let's say for example, underscore, right, you're going to have to come up with some sort of mechanism to indicate that you're not using all of the available space. And then when it comes to parsing and handling that string or whatever type of data that you're sending over, you're going to basically trim out this extra fluff, right? So just to, just to show that this is actually working. Oh, sorry, it's longer than. Right. So yeah, that's basically it. Just like I said, focus on doing whatever is appropriate to your needs in terms of your data structure and the length.
01:34:58.280 - 01:36:31.448, Speaker A: There may be some better ways of handling these sizing differences between the account data on the network side and what you're sending over. This is kind of hokey, but remember, because these types are arrays, they have a static length, right? So there's no way, in other words, to dynamically resize this account's data, right. Let's say if the instruction coming in is three characters shorter, we can't dynamically at runtime make this account data three indexes shorter because it's an array, so it's static in terms of length. So that's the core reason for the issue that we're running into. So there may be more elegant ways to deal with this. And in a lot of situations, you probably won't need to send over an entire object like I ended up doing. If all you need to send over is strings, then you could literally just send over a text without an entire object.
01:36:31.448 - 01:37:39.340, Speaker A: And that might work for your specific case, but under certain circumstances, if you have a more complicated data schema, then that's not going to work. So you're going to have to figure out a way to deal with the differences in the size of the data versus the parameters that you might be sending over. Okay, so that's it. In the next video, I'm going to flesh out this sample and make it a little bit more like an actual app. So we'll bring in react, we will pass messages, instead of just sending it to a single account, we'll pass messages between two accounts, and also we will send money, meaning land ports, between the two accounts. So if you have any questions, definitely leave a comment. I will try to answer any questions that you have.
01:37:39.340 - 01:37:41.070, Speaker A: So thanks for watching.
