00:00:05.320 - 00:00:08.014, Speaker A: Hey, guys, welcome back. So today we're going to cover a.
00:00:08.054 - 00:00:14.630, Speaker B: Super important and awesome feature of Solana. We're going to cover program derived addresses, or PDA's.
00:00:14.782 - 00:00:15.862, Speaker A: So if we take a look at.
00:00:15.878 - 00:00:47.644, Speaker B: Our diagram from a previous video where we're looking at accounts, we know that if we want to change the data of an account, the program that we're asking to make the change has to be the owner of the account, and we also have to sign for this transaction with that account's private key. But this is not always a convenient way to do things right. For example, if we have a DAP and it wants to store data about itself, why should any particular client have to authorize the change? It should be able to make those changes on its own.
00:00:47.804 - 00:00:49.468, Speaker A: Think about like a web two app.
00:00:49.516 - 00:00:52.504, Speaker B: That can read and write from its own database at any time.
00:00:52.834 - 00:01:16.890, Speaker A: When we use PDA's, we can actually mimic this exact behavior with accounts because these PDA's don't have private keys. Instead, they're created by using what are called seeds to create the public key. And then those seeds are used to sign for changes. So let's see what this looks like in code. It'll make more sense. So we're going to actually create a program here that's going to use PDA's to record how many times each user.
00:01:16.922 - 00:01:18.256, Speaker B: Has visited the page.
00:01:18.410 - 00:02:04.376, Speaker A: So, as you can see, this is going to be a struct that represents our PDA's data page visits being the number of visits to the page, of course. And then we've got bump in here. Like, what is that? Well, a bump is actually a concept for PDA's that is actually pretty important. So when you use seeds to derive a public key, there's a chance that the seeds you use and the public key that derives from them could, in theory, have an associated private key. And that's kind of depicted by this curve here, the ED 2559 curve. So if the seeds derive a public key that exists on this curve, then it could have a private key. So what Solana will do is actually tack on an additional integer, a bump to your seeds list, to make sure that it bumps it off of this curve, and it cannot have a private key.
00:02:04.376 - 00:02:23.114, Speaker A: So that's all that means, it bumps it off the curve. The tricky part is we actually have to manage this bump throughout our program. So it's good to kind of stick it in the account data. You could also do other things with it that might work better. This is just an example. And then as you can see we've got some other stuff down here like constants and implementation methods. And then our seeds.
00:02:23.114 - 00:02:57.088, Speaker A: This is going to be our first seed, the page visit string. And then our second seed is going to be just the user's public key. So if we take a look at our processor file, we're going to have two different instructions that our program is capable of doing. We're going to be able to create the page visits PDA and we're going to be able to increment the number of page visits on that account. So this is going to be the function that's going to do the creation of the PDA. So we're reading in our accounts here, and this one here is going to be the PDA. And then down here we're using invoke like we've seen before, but now it's invoke sign.
00:02:57.088 - 00:03:41.112, Speaker A: So like what is this? Well, I said earlier that you don't use a private key to sign transactions that will modify a PDA. And since this is the instruction that's going to create the PDA, thus modify it, we can't use a private key to sign for it because the PDA has no private key. Instead, we have to use the PDA's seeds, including the bump, to actually sign this instruction, this transaction, and okay, the change to this PDA, which in this case is just initializing it. Right. So invoke sign is how you actually do a cross program invocation with a PDA as, as the signer. And then here, pretty straightforward. We're just going to load the data from our page visits account.
00:03:41.112 - 00:03:55.352, Speaker A: We're going to increment it and we're going to serialize it back. All right, now here's our test file. So all this stuff should look pretty familiar. We're just setting up the data up here and the instructions. And then down here we're going to create a test user. So we're just going to create an account. We're not going to allocate any space.
00:03:55.352 - 00:04:05.148, Speaker A: We're not going to do anything crazy. We're just going to set up a basic account to serve as a sample user. Right. And then here is how we actually derive the PDA itself.
00:04:05.236 - 00:04:05.436, Speaker B: Right.
00:04:05.460 - 00:04:40.544, Speaker A: So this is really important. We use public key, dot find, program address, and then there's our string again, and then there's the user's public key. And of course we're mapping it with our programs id and that's going to return to us not just the PDA, but the PDA's bump as well. So then we just set up our first instruction to create the PDA. So we have all four of those accounts in here, system program because we're going to need it to create it. And then we set up that initial data sending confirm and go ahead and create this PDA. And then when we visit the page we're going to do that twice.
00:04:40.544 - 00:05:12.674, Speaker A: We're just going to derive the PDA again. We don't need the bump anymore because we've already got it, we already saved it to our account. And then down here we're going to just tell it to increment page visits each time. And then finally we'll go get that data back and we'll read it out to the console. So we had a successful run and if we check the logs we can see all of our invocation going on here, including the invocation of the system program right through our CPI. So all success looks good. And you can see back in our test number of page visits too.
00:05:12.674 - 00:05:36.218, Speaker A: So this is native. Now let's check out anchor. So in anchor our repository is laid out exactly the same. Even our state looks exactly the same except this is collapsed down to just the data here. In create we're doing set inner new page visits object and we're starting it at zero. And then anchor has an embedded method here to actually get the bump from a particular account based on its seed. So that's come in nice and handy there.
00:05:36.218 - 00:06:08.696, Speaker A: And then we can use init here in this account annotation to actually create this thing and run a CPI from just this context struct right here. So this will go ahead and create it and then increment just looks similar as well. We just go and reference it from the contact struct and increment. The key thing here with anchor two is you can also run checks against these seeds. So when you provide these seeds in a mute, it'll actually go and make sure that the public key was derived from these seeds and the program. So that's it guys, that's PDA's. We will see a lot more of them in different examples.
00:06:08.696 - 00:06:18.044, Speaker A: They're super, super useful for building dapps and now you guys know how to build them, how to use them, how to work with them and all the basics about handling seeds and bumps.
