00:00:00.240 - 00:00:24.374, Speaker A: Welcome to this week's Changelog, where we bring you the updates and changes on Solana each week. My name is Jacob. I'm joined here by Colin today. Let's get started. So right now, if you want to join in the hackathon and participate in building something really cool, there's a community hackathon going around right now through Lamport Dao. It's called the Solana Sandstorm hackathon. Totally recommend entering it.
00:00:24.374 - 00:00:38.574, Speaker A: We, as Solana foundation, are sponsoring it. You can build, like, local tooling. You can build, like, things for nfts, just go build for it. Push the boundaries of Solana and let's see what some cool projects that we can get out of it.
00:00:38.694 - 00:00:55.134, Speaker B: I think it's a really great way to get involved with what's happening in the Solana ecosystem, and it's not a really long one. It actually ends on the 23 January. So just build something, get involved and. Yeah. Ship and then see how it goes. Yeah.
00:00:55.254 - 00:01:03.898, Speaker A: And I think so we have the proposal highlight today is simd three, which is dynamic based fees. Colin, you want to go into that a little bit?
00:01:03.986 - 00:02:05.914, Speaker B: Yep. I think this one is a very interesting one, actually. And I think it's probably something that could potentially be split up into two different proposals, because there's two things in one. So in this dynamic base fees proposal, the first thing is actually changing the way the base fee is being calculated currently, which is just done by the amount of signatures in a transaction to actually be based on the amount of compute units per transactions instead. Then the secondary component of that is to add a mechanism where the total fee is dynamic just based on the current load on the network. And I guess just at a high level, this is some kind of like spam protection or actually just a way to desensitize people spamming the network, or at least make you begin to figure out a different optimal way to get your transactions in, as opposed to just spamming the transactions constantly. So I think it's definitely something that needs to be addressed.
00:02:05.914 - 00:02:10.594, Speaker B: So, yeah, it's a good proposal and some good discussions are on the GitHub as well.
00:02:10.894 - 00:02:43.294, Speaker A: Yeah, some D process is really kicking off at this one. There seems to be a lot of discussion on this one and like, how can we make it better? How do we change fees correct to correctly match what is happening on the network? Looking forward to like, what this turns into in the long run. I don't know if it'll be accepted at this point in time. Doesn't look like consensus is there yet, but whatever happens at the time of consensus, it'll be interesting to see it being tested on the network.
00:02:43.874 - 00:03:06.846, Speaker B: Yeah, definitely. And I think it's also something that is worth reading into irrespective of what you consider your own technical ability to be the discussions that are actually very insightful to kind of see how people think about different ways to make the network more stable and see the different angles of where people are coming from. So definitely worth a read. Yeah.
00:03:06.910 - 00:03:57.218, Speaker A: Awesome. So we have a few commit highlights this week. So one of them was that. So right now Mainnet beta is running 1.13 and it will be at some point in the near future upgraded to 1.14. If you have seen recently with on the fee discussion, like if you've seen recently, a lot of people have been using prioritization fees to get into the blocks, but it's kind of been slow moving for wallets and other Dapps to integrate prioritization fees. So there's an RPC called get recent prioritization fees, which kind of gives you a estimate of what the recent prioritization fees are so that you can better estimate what your future, what prioritization fees are going to be.
00:03:57.218 - 00:04:31.084, Speaker A: So what you can do is this call. You can call it and then you can use it to determine like, okay, what do I think that a good fee amount would be for right now so I can get into the block? So this call is originally going to be in 1.15. It's been moved to 1.14 and some people are already using it today. Like I believe Jupiter uses this today to basically allow the users to get into blocks easier. So it's a cool change. It's a greatly needed RPC call right now.
00:04:31.244 - 00:05:13.834, Speaker B: Yeah, it's actually interesting because that reminds me of a related commit that I saw. That method's also been added to the rust client. So if you're building rust clients, you would also have access to that RPC call. Another commit highlight is the update to compute costs because the way it was initially estimated was slightly incorrect. So now they've fixed that. So as a result, the cost estimates have been adjusted upward, but just very slightly. So it's a level where like, you may not even recognize a change, but it's just to keep in mind that those compute costs have gone up a little bit.
00:05:14.164 - 00:05:45.670, Speaker A: Yeah. Do note that this was on the curve 20 519 syscalls. So it's not across the board, but specifically to curve 25519. Another thing that happened, I think this past. Yeah, this past Saturday or the Saturday before, there was a kind of a mismatch in runtime for 1.14. I think like, 9% of people are validators were deployed with 1.14 on Mainnet beta.
00:05:45.670 - 00:06:18.962, Speaker A: However, basically what's great is it was caught in regression almost. It's like the normal user didn't even notice the network changed a little bit. Actually, nobody really noticed it other than the core engineers. What happened is there was a small runtime change mismatch between 1.14 and 1.13. Thankfully, we were doing, doing proper rollout of 1.14. So it was caught, it didn't affect the network, and it's been fixed.
00:06:18.962 - 00:06:37.854, Speaker A: So really cool. Basically, it was a really great example of good testing and being able to catch problems before they actually cause issues. So, yeah, that was a cool thing that happened. And then, Colin, I think you have our resource of the week.
00:06:38.744 - 00:07:15.880, Speaker B: So resource of the week is go Lana. And kind of like, as the name suggests, it's a way to build smart contracts on Solana in the go programming language. And I think this is something that's very exciting because I think the more languages that we can support and offer, it kind of just like, begins to attract more developers into the ecosystem. So now it's not just rust that supported this rust, Python and go. And I'm like, so curious to kind of see, like, what other languages will be supported next. I think typescript is also in the works, but, yeah. So the resource of the week is go, Lana.
00:07:15.880 - 00:07:31.644, Speaker B: So if you are a go developer in Solana, please go check that out. And as always, everything is open source, so you can kind of give feedback and comments and suggest different improvements to it. But very excited to have that language on board.
00:07:32.294 - 00:07:49.874, Speaker A: Yeah. Do note that Golan is still in alpha stages, so it can't do everything yet, but it's really cool. It's really cool that what you can do with it. I think the maintainer built hello world and an escrow program, so you can test those out in a little bit more.
00:07:50.174 - 00:08:09.224, Speaker B: Sounds good. So that wraps up the changes in the Solana developer ecosystem this week. Join us next week for more. And just before we leave, quick shout out to John C. Who earned the most reputation on the Solana Stack exchange this week. So looking forward to see who else is going to dethrone him for next week.
00:08:10.204 - 00:08:11.484, Speaker A: Awesome. All right, thank you.
