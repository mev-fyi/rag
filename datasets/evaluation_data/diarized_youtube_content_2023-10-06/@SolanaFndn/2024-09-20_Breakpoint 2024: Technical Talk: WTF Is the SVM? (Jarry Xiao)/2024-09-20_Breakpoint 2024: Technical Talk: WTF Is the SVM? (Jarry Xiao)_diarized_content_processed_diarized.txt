00:00:04.000 - 00:00:38.409, Speaker A: Good afternoon, everyone. My name is Jerry and I'm one of the co founders at Ellipsis Labs. And today I'm going to be talking about the svm. There's been a lot of interest these days about what the SVM is and what you can do with the svm, and I'd like to sort of explain my take on it. A few months ago, I made a tweet online describing what I think the SVM is and what the spec is. And throughout this presentation, I will be going over each act of that tweet, and there are like four major points that I made through that. So SVM stands for Solana Virtual Machine.
00:00:38.409 - 00:01:17.795, Speaker A: And what the Solana Virtual Machine is, is an interpreter for EBPF bytecode. And you can see here this is what I mentioned in the tweet. I don't think anyone knows what that means, so I will start from the top, which is a speedrun of computer architecture, which is a course you might take an intro course you might take in college. But a computer or CPU is literally just a machine that can execute simple instructions. These instructions include things like adding, multiply, subtracting, and dividing numbers, keeping track of numbers. And so there are two ways you can do this. There are things called registers, which are essentially numbers that are really close by, and memory, which are numbers that are really far away.
00:01:17.795 - 00:01:55.305, Speaker A: These instructions can jump to a previously executed instruction, and they can also conditionally execute different instructions. These programs in the room are known as loops or if statements. And there are a few key takeaways from this. The first is that all information, including the CPU instructions, can be represented with numbers. And as mentioned in the previous slide, all the instructions are acting on numbers. These instructions are executed sequentially. So the CPU receives a list of different instructions, and given the default behavior, it will just execute one after the other.
00:01:55.305 - 00:02:31.465, Speaker A: But jumps and conditionals will have slightly different behavior. They will move the instruction pointer to a different place in that list. And lastly, a standard collection of CPU instructions is known as an instruction set architecture, or isa. So what is ebbf? EBBF stands for Extended Berkeley Packet Filter. And it's essentially just the ISA for Solana. And that effectively just means that every Solana program is a list of EBBF instructions, also known as bytecode. Here we see a diagram of how each instruction is organized.
00:02:31.465 - 00:03:15.395, Speaker A: It's made of exactly eight bytes. The first byte is the opcode that corresponds to what the instruction actually does. The next byte contains indices for the registers, source and destination. Again, a register is just a number that is closely accessible to the cpu. The last two things are the offset and immediate. And these are just hard coded numbers that the CPU is able to use to perform some computation. And what is an interpreter, which is the last part of that first point in the tweet? An interpreter or a virtual machine is essentially a way that you can execute or simulate this instruction set execution in software.
00:03:15.395 - 00:03:57.735, Speaker A: And this is sufficient for basically any type of application you might want to build on a programmable platform like Solana. So you can use this to program tokens or NFTs or order books or AMMs. What it looks like is really not that complicated. You have a list of instructions. You go through them one at a time, you figure out what registers they use, and based off of the instruction, you decide whether you move your program counter or PC to the next instruction or somewhere else in that list of instructions, which you can kind of see in the pseudocode on the right hand side. So that was the first point. It's an interpreter for EBVF code.
00:03:57.735 - 00:04:40.489, Speaker A: The second thing that you need to have in an svm, or it's really the counterpart to the interpreter, is this transaction processing unit. And it's something I'll refer to as the execution environment. There's an execution environment that follows something that's known as the Solana programming model. And those are essentially just a set of rules. I like to think of this as a type of a referee. So the execution model is something that wraps around the underlying virtual machine, and it essentially tells you or tells this system whether the virtual machine is enacting a state change that is acceptable or one that is unacceptable. It also intakes the user transaction.
00:04:40.489 - 00:05:23.795, Speaker A: So the user transaction will come through the execution environment. It will figure out how to build the vm. The VM is a black box that executes, and after execution, the execution environment will determine whether or not the VM performed an acceptable action or an action that needs to be denied because it violates some rules. And those rules are known as the programming model, which I think Solana developers in the audience will be somewhat familiar with. The programming model is essentially the list of rules that are enforced by the execution environment. And there are a couple examples I list here. For example, a very obvious one is that Lamports or SOL cannot be created in a transaction.
00:05:23.795 - 00:06:23.925, Speaker A: The accounts needed to be can only be modified by the programs that own them. Users must declare all the accounts up front, and then no reentrancy is allowed. And what that means is essentially if you have a program, it Calls other programs, it cannot be re invoked in that same execution call stack. And there are many more. The programming model isn't limited at these points, but I think the high level takeaway is that the execution model is essentially something that wraps something really generic, which is the EBVF interpreter and the way that it's able to control the inputs and outputs of that interpreter are defined by this programming model, which is essentially just a simple rule set. So Act 3 is about the actual byte layout of the programs that are executed executed in the vm. So each program that is executed on Solana is given an input set of parameters that are serialized to the virtual address space that can be accessed by the interpreter.
00:06:23.925 - 00:07:12.719, Speaker A: And this in my opinion is the only true spec found in the svm. This is the only thing that is like enforced by the existing execution model because the execution model is building the VM with a spec in mind. So on chain programs must specify this custom byte layout because the execution environment is passing them those bytes in a particular format. The parameters of all programs are found at a particular address, just a hard coded address somewhere in the virtual address space. And what is found there contains all the inputs that necessary for that program to run. This includes the accounts that are needed to act. So this is like the state that the program requires in order to do execution as well as the inputs.
00:07:12.719 - 00:07:53.103, Speaker A: So inputs can include the number of tokens that something needs to transfer or which instruction inside a program needs to be executed. All of this is represented inside these parameters that are serialized into the virtual memory. And yeah, so it's a pretty complicated spec. There's a lot of stuff on the screen here. I think the high level takeaway is there is a specific format for everything. This is a very difficult or very complex documentation to read through, but essentially what it details is how that address space is laid out. You need to specify the number of accounts, you need to.
00:07:53.103 - 00:08:38.593, Speaker A: For each individual account there is a specific format. The byte layout is extremely well defined. And at the very end, after you've listed all of the accounts, you lay out what the instruction bytes are. Basically these are the specific inputs for the program to tell it what to do during execution. And then lastly you have the program id, but this is by definition a spec because this is what the execution environment does to populate the virtual address space prior to program execution. And if the BPF program does not respect this particular interface, the behavior will not be as expected. And so you might ask, like, I think some of the people in the crowd might be SVM developers and they might not know about the spec.
00:08:38.593 - 00:09:45.085, Speaker A: And the question is, why don't you know about it? Well, the reason is because it's hidden away from the developer behind this entry point macro, or if you use anchor, there's this hashtag programmacro that abstracts away all this complexity, which I think is a good thing. The thing that I think is potentially less positive is that it's a relatively inflexible interface that is really difficult to modify without breaking any backward compatibility. But all that being said, it is a legitimate spec that needs to be followed if you want to build some sort of SVM implementation that is compatible with existing programs on Solana. Act 4 is about the JSON RPC. I think this is an optional piece of the spec, but I think it's a rather important one for practical reasons. This is essentially an API server that you can send post requests to and they will return data in a predefined format. And this is a very standardized spec, which means that if you implement a JSON RPC server with the expected inputs and the expected output serialization format, any client code that can interact with the slide on a JSON RPC can also interact with this custom JSON RPC server.
00:09:45.085 - 00:10:21.939, Speaker A: And here are just some examples. It's a very simple post request with a JSON format of what you want to do. This is a call to getaccountinfo and the format that's returned is standardized. And as long as you follow this schema for GetAccountInfo on any implementation of the JSON RPC server, everything should work fine in a given client implementation. So I finished the tweet. There is one key point that I wanted to go back to. The last line is that the only real spec will always be the wire format.
00:10:21.939 - 00:11:09.055, Speaker A: This is something I truly believe because no matter what the software implementation is doing, that doesn't really matter to the user or it doesn't really matter to the application developer. The thing that really matters to the application developer is you can build some input in some way. You send it to some black box and it comes back in the expected format. And what Alice is doing is it's essentially following this wire format spec, and we believe that it will lead to the proliferation of the spm. So what is atlas? Atlas is the blockchain for verifiable finance. We view verifiable finance as combining the transparency of DEFI with the performance of traditional finance. It is a new implementation of the SVM specifically built for financial applications.
00:11:09.055 - 00:11:44.303, Speaker A: And I think there are some key properties here that make Atlas particularly suitable for those types of applications. There are 50 millisecond slot times. There is low latency, high throughput and low jitter. These are all properties that are extremely desirable for any type of financial system or trading system. And lastly, there are opinionated sequencing rules, which means that Atlas is able to prioritize certain types of behaviors based off of what is catered to At Ellipsis Labs. We believe that infrastructure should be built with a purpose. Infrastructure should never be built for the sake of purely building infrastructure.
00:11:44.303 - 00:12:25.793, Speaker A: There should be some end obligation in mind. And an important thing that we left here at the end is that program execution and the JSON RPC are backwards compatible with some Solana. Mainly that it respects the wire format of Solana. And the reason why we think this is valuable is that there is a whole array of tools and existing source code that knows how to interact with the Solana ecosystem and Atlas should be able to utilize that blossoming ecosystem to build new and better applications. Atlas testnet is live today. You can sign up here. We have QR codes that point you to the Atlas website as well as the Atlas Twitter page.
00:12:25.793 - 00:12:45.595, Speaker A: We truly view Atlas as the next evolution of the svm and I think this is very powerful tech. I think the SVM in particular is a very powerful programming paradigm. I hope for it to be the default for all future blockchain applications that continue to compete with the stronghold of traditional finance. Thank you so much.
