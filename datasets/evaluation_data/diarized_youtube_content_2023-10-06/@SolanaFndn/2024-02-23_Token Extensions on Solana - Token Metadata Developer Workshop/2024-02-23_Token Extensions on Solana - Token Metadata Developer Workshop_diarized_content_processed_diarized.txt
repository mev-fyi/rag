00:00:00.560 - 00:00:46.674, Speaker A: So as some of you may know, you may have seen this on social, you may have seen this on our Luma calendar. We are going to be at ETH Denver talking to ETH devs who are interested in transitioning to Solana. Some of you may be there as well, but the first thing we're going to be there for is biddle week, and Nick Frostbutter is going to be supporting that. We'll have four bounties there as well. If you're going to be there, go ahead and get involved, come see us, talk to Nick, get unblocked, and then we'll also have a booth on the expo floor. So in this booth, we'll be having presentations not only from our staff, but from ecosystem teams as well. You can play some developer games, get a developer Solana T shirt, and then we've also got our only possible on Solana talk.
00:00:46.674 - 00:01:28.522, Speaker A: This will be Jacob Creech, who was just on the call a moment ago. He's our head of Devrel. He'll be talking to what is possible on Solana. Again, we're going to be speaking to a lot of ETH Denver's ETH devs, so we're really going over what Solana is, what the value props are, et cetera. If you are by somehow an ETH developer who has made your way to our call today, we will be having a mixer on March 1 in real life about transitioning to Solana. If you're a Solana developer and you're going to be at ETH Denver, come celebrate with us on March 2. All of these events are in our Luma calendar, so you can sign up there.
00:01:28.522 - 00:01:48.494, Speaker A: We would love to see you there. Love to say hey to our community. Next. You are currently in the transfer hooks token extensions workshop. We have a couple more coming, this one actually confidential transfers. We are changing the date to that to march, so apologies for that. It should be updated on the Luma calendar though.
00:01:48.494 - 00:02:21.694, Speaker A: We'll be having that workshop in early March. And then lastly, stay engaged. If you're not following us on Twitter, definitely do so that's where we're posting about all of these events. Also new educational resources and promoting some of the cool things happening in our ecosystem. I've mentioned our Luma a couple of times now. That's where you're going to find all these IRL and virtual events as well to sign up. And if you want to dig more into the resources that Nick and his team have created for developers, you can do that on YouTube.
00:02:21.694 - 00:02:41.000, Speaker A: You can also see all the past breakpoint talks, et cetera there. But my, my name is Hall. I use they, them pronouns. I lead our dev marketing here at Solana. It's always good to see everybody. I'm going to give it back to Nick now so you guys can go ahead and get started on what you came for. So 1 second, Nick, go for it.
00:02:41.032 - 00:02:54.896, Speaker B: All right. Thanks all. Thanks all a lot. Yeah. And I'll say that I some alpha alert for ETH Denver. Those, those developer t shirts, these are the first of their kind, the very first Solana developer t shirts. We haven't ever had them before and limited edition.
00:02:54.896 - 00:03:20.204, Speaker B: Just saying, just saying. All right, let's go ahead and talk about token extension, specifically token metadata. My personal favorite, token extension. This token extension is, it's just so cool. You can do so many things with this thing and we're going to talk about it. Let me figure out how zoom works again and my screen disappeared. I'm going to go ahead and share screen for, you guessed it, some versus code.
00:03:20.204 - 00:03:59.030, Speaker B: And I will also post a link in the zoom chat if the zoom chat wants to show up again. There it is. I just posted a link to the Solana developers GitHub organization, specifically the token metadata extension repo. Pretty self explanatory what you might find in it. We're going to talk about token metadata extension. In fact, I'll even put the link right here on the screen if anyone's watching on not zoom. You can check out this exact link right here and you'll see this exact repo just published it 20 minutes ago or so.
00:03:59.030 - 00:04:41.076, Speaker B: And we're going to talk about all things token extension. Like I said, the token metadata extension specifically for today, token metadata, token metadata pointer and talk about how these work and some of the nuances that are really important to understand. And there's some foot guns a little bit and if you don't set it up right, you'll get some errors. And we're going to talk about what those look like and how to avoid them. But just real quick on this repo itself, it links out to all of the other Solana, the token extension guides on Solana.com developers as well as the very specific guide for the metadata pointer which we're going to be talking about today. It very briefly talks about how to actually use the script within this repo.
00:04:41.076 - 00:05:33.588, Speaker B: Just one script, super simple. And we're going to use Esrun, one of my personal favorites, to actually just run this typescript script just like it's any other script. It'll be great so let's go ahead and dive in here. The first thing that we're going to talk about is what is the token metadata extension? What are the pointers? Why should we care? How do they work? So the token metadata extension effectively allows you to use the token extension program and have customizable on chain metadata directly on your token mint. So if you're used to the Solana developer experience and creating tokens on Solana, when you create a token, you create what's called a mint. That mint has the ability to mint new tokens just like any nation state currency. You've got your treasury department in the United States, they control the federal mint.
00:05:33.588 - 00:06:51.320, Speaker B: They can mint tokens with that. They are authorized to raise or lower the supply of tokens of currency within their mint. And that's what SPL token mints are, the token metadata extension and a lot of other token extensions you can actually apply directly to the mint itself, which makes it so in years past you've actually had to create a separate program that has some sort of metadata standard that you can follow or the ecosystem can follow in order to consume this metadata information, like the name of your token, a JSON URI that has some assorted additional information like an image, your website URL, whatever. You can put all of that on chain now, or at least most of it on chain. And you can do it with one less account, which is really, really powerful because it makes it so a lot of the things that you're doing with tokens can become more composable because you don't actually need to create an additional account, which means it costs less and you can do more things, which is awesome. I love efficiencies in so many ways. And my favorite part about the token metadata extension is customizable on chain metadata directly within the token extension program.
00:06:51.320 - 00:07:07.744, Speaker B: That is just so cool. Shout out to Solana Labs and the Anza team that are behind token extensions, specifically John Cinque and the rest of his team. Just so good. So good. All right, let's dive in some code. That's what people are here for. Let's do some code.
00:07:07.744 - 00:07:32.270, Speaker B: So we're going to be using JavaScript and typescript today and we're using the standard repos that you might expect. We've got the Solana web, three js. We're loading in. We're importing in some of the standard things like making a connection to the blockchain, those sorts of things. We're also using the Solana SPL token package. Now if you're used to doing anything with tokens on Solana. This is specifically with typescript and JavaScript.
00:07:32.270 - 00:07:57.924, Speaker B: This is the package that you're probably used to using. The beautiful thing about token extensions is you can use the exact same package. All of this functionality is baked in and all you have to do is just specify which token program you want to use. In this case we're going to specify the token 22 program. Then the other package, this is a newer one. This is the SBL token metadata package. Because the metadata extension is actually an interface.
00:07:57.924 - 00:08:29.634, Speaker B: It's an interface that allows anyone in the ecosystem to build on top of it. Just like any interface you can think of a typescript interface. If that's your jam, I'm more of an export type person, not an interface person, but each of their own. This newer package, this is going to have some of the magic sauce that we're going to need to actually do this on chain metadata, this custom on chain metadata and there's some nuances to it. But don't worry, we're going to cover it all here. Let's dive into the actual code. Imports are boring.
00:08:29.634 - 00:09:06.442, Speaker B: The first thing to point out is we're going to make a connection to Devnet. All of the things that we're going to talk about today are live on Devnet. If you're running a local validator with Solana test validator, all of these will be baked into the test validator as well. All of these are live on all networks actually mainnet, Testnet, Devnet and local. The thing that we're doing is specifically we're going to be on Devnet and I'm going to load a key pair from my local file system. This key pair is just the JSOn file for the Solana Cli. This is the standard path, your personal root directory or your personal home directory.
00:09:06.442 - 00:09:40.118, Speaker B: Config Solana ID. If I run the Solana address command, you can see I've got this nic six z address. That's going to be the address that I'm going to be loading in here. My key pair, this key pair has some Devnet soul in it. Do a Solana balance and you can see I've got some Devnet soul in there. So I'm able to pay for all the transactions and the rent storage costs that we're going to need to for this. And then just like creating any other token, you need to generate a new key pair that you can use as your mint itself.
00:09:40.118 - 00:10:10.590, Speaker B: And because this is going to have to be able to write to the blockchain needs to have the signer. So it needs to be a full key pair, not just a public key. So we're going to generate a brand new key pair, just a random one. It doesn't matter what it is. Then we're going to go ahead and define our metadata. Now if you're used to looking at metadata in the salon ecosystem on some of the other metadata protocols and specifications, this looks pretty much the same. That's one of the beautiful things about it is it's so similar and metadata itself is really simple.
00:10:10.590 - 00:10:48.856, Speaker B: It's so similar that it becomes pretty almost composable in itself just because of how similar it is with everyone else. But you might notice there's this additional metadata field that's the interesting one. So there's a couple of fields here and you can see, I have it typed out. You can pull up the type if you're interested in looking at it. There's some comments in here which are always nice. There's a couple of standard required information that you're going to need for just about any metadata, anything that you're putting on chain. You need to specify the mint address itself because this is the address that's actually going to house our metadata.
00:10:48.856 - 00:11:10.018, Speaker B: You can think of it like that. They're going to have pointers that are going to point back to each other. We're going to set a name for our tokens. We're creating a brand new token using the token extension program, also known as Token 22. We call it token extensions. Now we're going to call it only possible on Solana because I love some good opos. Naturally we'll go with a symbol of opos.
00:11:10.018 - 00:11:35.210, Speaker B: We have a JSON Uri here. This just points to a metadata file that has a URL to our image and the same information here, this name and the symbol. Nothing too special about that. Just like any other token metadata metadata specification that you're probably used to. And then there's the additional metadata. This part is the magic sauce that has some nuances. So the first thing to note is the data structure here.
00:11:35.210 - 00:12:02.914, Speaker B: It's an array of arrays. So you have nested arrays and you'll notice that these are effectively a key value pair. How the additional metadata works on chain you can think of it like an NFT attributes. That's how I like to think about it. When you have like an NFT attribute, you have the name of the attribute, the key, and then you have the actual value that it is. So you know if your NFT represents a person, you have like a hair color and hair color of red, brown, you know, whatever. Key value pair.
00:12:02.914 - 00:12:30.296, Speaker B: Pretty straightforward. But this is the specific structure that you have to provide this to the correct instruction in order to add and update this metadata. Simple key value pair. And we'll write in some custom. I'll add in some random numbers in here just to show you that we're going to do this real time. We're going to run this on Devnet. This random number in here, I like, underscores random number so you know that it's real and it's.
00:12:30.296 - 00:13:01.448, Speaker B: It's live. So now that we've defined our metadata, pretty straightforward. Additional metadata, we'll circle back to it. When you're working with token extensions, when you are creating your mint, you have to do some calculations. There's helper functions. In order to do this, you need the actual length of the byte length, the space that you're going to need to actually allocate on chain. You can see we're building our instruction down here and we need to get the total space that we need for our mint account itself.
00:13:01.448 - 00:13:28.776, Speaker B: So we're going to allocate that account on chain. We need space and we need to put land ports in it to pay for the rent. That's what we're going to do. And you'll notice that I'm calculating space, the byte space for our account, as two different variables because it's a very important reason why. So I'm actually going to talk about the second one first. So I'm getting the generic mint space. So when you're doing a lot of things with token extensions, a lot of those extensions are directly on the mint itself.
00:13:28.776 - 00:14:17.126, Speaker B: So when you are allocating the mint, when you're creating the account for the mint, you have to have the exact amount, the exact correct space on the mint itself. And there's a little note here in the comments that it must be the exact amount that you need on the mint itself. So some extensions are applied to the mint, like the metadata pointer, which is what we're doing here. We're saying we're going to have one single extension applied to our token mint, that we're going to create our new token, our opos token. We're only putting the metadata pointer on the mint itself. So we are going to only have that amount of space in the mint account itself when we actually create it. This is one of the nuances with token extensions that I like to point out to people because it's a little bit of a foot gun sometimes.
00:14:17.126 - 00:14:43.190, Speaker B: You'll get like a weird error that you don't quite understand. We're working on improving the errors all the time. So that's the mint space. We're putting one single extension on our mint itself, the metadata pointer. And then we need to know our exact metadata space itself. So our metadata, this on chain metadata, these fields right here, we're storing them on chain. They're going to be an account state which means we have to pay for the rent for that.
00:14:43.190 - 00:15:10.386, Speaker B: We have to pay to store those raw bytes on chain. And there's a helper function that's built into the SPL token metadata package called pack. We can use the Pac function, provide it our metadata, just our structure, our type structure, our JSON object here. And then we can get the length of this. Basically this is going to format it correctly and do some math under the hood. Tell us how many bytes that we actually need for this. But it doesn't end there.
00:15:10.386 - 00:16:02.942, Speaker B: You'll notice that there's also this type size and type and length size with token extensions. All the token extensions work on a TLV structure for deserializing all the data and it stands for type length value. So it's effectively like the discriminator system that you're probably used to or you may have heard about when you're dealing with serializing and deserializing programs and instructions and all that sort of stuff. Exact same thing. We're using the type size to say this is going to have and this is actually just two bytes or. Yeah, it's, yeah, so we're saying the type size because we're effectively going to have a discriminator for the type that we're actually going to use in this metadata. And then we need the additional bytes that are for the length of the metadata.
00:16:02.942 - 00:16:56.864, Speaker B: So think of this like this is the discriminator for this is going to be the space that we need for the discriminator. So the token extension program knows that this is going to be metadata. So it knows to deserialize the metadata correctly. The next value is the total length of the metadata, the total size of the raw bytes that this data is going to take on chain. And then you have the actual data itself. So when the token extension program runs and you're trying to get this on chain metadata, it grabs the type discriminator and it says okay, great, I get the type discriminator for token metadata. So it knows it needs to deserialize token metadata and then it gets the length and then it knows how many bytes it needs to slice out from the total TLV array, the vector and then it can take that data, the final data that was packed, that total length of the actual data.
00:16:56.864 - 00:17:42.578, Speaker B: It can slice that out and it knows to correctly deserialize that into the metadata structure, the struct in rust. So that's what's going on here. And again, this is super important to when you're allocating the mint, that you are only allocating the space for the pointer and not the metadata itself. If you were to allocate this total, this mint space plus metadata space on this create account instruction, it would actually fail because how the token extension program is set up, it will throw an error, your transaction will fail. So that's why we're doing it as two separate steps. There's one of the nuances with token extensions and the token metadata extension, the metadata pointer specifically. And then we're actually building the instruction.
00:17:42.578 - 00:18:13.120, Speaker B: I've mentioned a couple of times, we're building the instruction. We're creating an account. Pretty standard stuff. The one thing to note here is that our program id is the Token 22 program id, the token extension program. So we have to specifically tell the system program that hey, the token 22 program is going to own this account we're going to create because this is going to be our mint water break. All right, I'm going to take a quick look at the chat to see if anyone has any questions. There was a lot of, there's a lot in there.
00:18:13.120 - 00:18:30.788, Speaker B: So if anyone has any questions, feel free to post them in the chat and I'll be getting to them. Someone said attributes meaning NFT traits. Yes, NFT traits. NFT attributes. They're at least in my mind they're the same thing. They're synonymous words. Space limit on mint ace.
00:18:30.788 - 00:18:55.398, Speaker B: I'm not sure what that means. Shiva shivam sani. Sorry if I'm not pronouncing your name right. On the account space limit. On the mint account, yes. So on the mint account itself we're creating the mint with this instruction. This space has to be the exact amount of space from the get mint length helper function that's in the token extension in the SPL token package.
00:18:55.398 - 00:19:20.888, Speaker B: It's a helper function. It basically just knows how to correctly get the total length of all the extensions. If you want to have some other extensions in here, you can throw in all these other extensions and when you're putting these on the mint itself, like most of these extensions, you have to be able to correctly get that value. Excuse me, I hope that answers your question. If it doesn't, feel free to post something else. Awesome. Instead of the answers.
00:19:20.888 - 00:19:50.640, Speaker B: It sounds perfect. All right, moving on. All right, so let's see what's next. The next thing we're going to do is we're going to actually initialize our metadata pointer. So I probably should have started with this. The flow of this script is we're going to define our metadata. We're going to calculate the correct number of space and bytes and lan ports that we need for all of the token actions that we're going to do.
00:19:50.640 - 00:20:21.028, Speaker B: And then we're going to start building all of our instructions. In order to use the token extension program and even the older token program you need to create a couple of instructions. And then when you add in token extensions there's a couple of additional instructions and we're going to build every single one of those. So we need to create the mint itself. We need to initialize the metadata pointer because we're using metadata and then we can initialize the mint. Then after that we will do all of our custom on chain additional metadata. That's what we're doing here.
00:20:21.028 - 00:20:54.772, Speaker B: We've created the instruction to create our mint to allocate our mint account on chain and then we're going to initialize our metadata pointer on the mint itself. One of the really cool things about the token extension program is it doesn't care what metadata program you're using. If you're using the metadata pointer you can point to any token metadata program you want. It could be the SPL Token 22 token extension program. It can be metaplex metadata. It can be libreplex metadata. It can be a custom metadata program you build.
00:20:54.772 - 00:21:20.418, Speaker B: It doesn't care. It's just a pointer that's going to point to another address and it basically makes it so on chain. Everybody knows which correct address that your token needs to go to to get your metadata. Pretty awesome. So super flexible and it's really nice. So in our case we're going to use the token extension program, token 22 as our metadata account. So we're going to use the metadata pointer to point at the mint itself.
00:21:20.418 - 00:21:37.344, Speaker B: So we're going to point back to itself. So you can see here I have hovered over. Hopefully you can see it on the video. Actually can you all see this on the video? Leave me a message in the chat if you can see the helper pop up if anyone can reply in the chat. Yep, cool. Can see it. You never know with zoom.
00:21:37.344 - 00:22:11.128, Speaker B: So you can see right here on the versus code helper pop up. We're going to take in a couple of parameters into this helper function which gets pulled directly from the SPL token package. So like you might expect, we're going to give it the mint address and then we need to say who the authority of this metadata address is. So who is able to update our metadata pointer later. In this case, I'm just going to set it to my payer account because they're going to pay for all the transactions here. It's going to handle the authority for everything. You can set this to any address you want.
00:22:11.128 - 00:22:39.610, Speaker B: This address does not need to sign this transaction to create the Mint. You can set it to a multisig somewhere else and manage your metadata like that in the future. Then the next thing is the metadata address. Again, you can specify any metadata address you want. In this particular case, I'm going to use the SPL token program to, or sorry, the token extension program to be my metadata program. I'm going to point back to itself. So that's why I'm specifying the mint right here.
00:22:39.610 - 00:23:05.582, Speaker B: So my metadata account is going to be my mint. Makes it really nice. Makes it so you don't have to allocate an additional account. So makes it very nice. And then you need to specify whichever token program you're going to use because you're going to use this with either the token extension program or if there's a custom program out there that you want to use, you can do that too. Super flexible. After that, we've now created a very simple initialized metadata pointer instruction.
00:23:05.582 - 00:23:41.932, Speaker B: Pretty straightforward, even though it was very long winded of me to explain it. The next thing we're going to do is we can actually initialize our mint. Now that we have these two instructions, you can think of them like preparing the mint to be created. Now we can actually initialize the mint. So we are officially going to flip that switch and say this account is a mint that can mint tokens on Solana. That's what this is. So we're going to initialize the mint account and we're going to give it some pretty straightforward parameters here or arguments into this function and we're going to give it the mint just like you might assume the decimal places.
00:23:41.932 - 00:23:59.044, Speaker B: In this case, I'm just doing two because why not? And then you have your Mint authority freeze authority. Super straightforward. And your program address, again, we're using token 22. You can see token 22 is, is all throughout here. Super straightforward. We've now initialized our mint. We've built that instruction.
00:23:59.044 - 00:24:50.764, Speaker B: And then I'm gonna skip over this real quick. We're gonna look at our transaction itself and I'll come back to all the other ones. So down, further down in the script, we're actually gonna build the, the transaction. And you can see that the order of operations for all of these instructions is very, very important. So before you initialize the mint, you need to initialize, you often need to initialize most token extensions. So most of the pointer, all of the pointer extensions. So metadata pointer, for example, eventually the group pointer and token group, group member pointer, all of those need to be inside the transaction before the actual initialize mint instruction.
00:24:50.764 - 00:25:19.976, Speaker B: So we're creating the account very first because we need to allocate the account on chain. So the address exists because every transaction is going to execute each of the instructions atomically so they have to be in series and be successful. So we're going to allocate the account first. We're going to initialize the metadata pointer and then we can initialize the mint. And after we've initialized the mint, that's when we can do some of the extra special on chain metadata stuff. So very important to know. All right, let's go back up here.
00:25:19.976 - 00:25:49.758, Speaker B: And so like, if you didn't want to use the metadata extension, you could remove these things here and you'd be totally good to go. And you've created a token. Done. But that's not why we're here. We're here for the extra special sauce of the metadata. I'm going to take a quick stop in the chat, see if anyone has any questions. Someone had a question of, is this different from inscriptions or ordinals? Yes, yes and no.
00:25:49.758 - 00:26:24.392, Speaker B: So this is, it's just, it's just standard Solana account state. You can put anything you want in Solana account state. When you create an account, you can put any data you want into that account up to the size limit because you're just storing the raw bytes in the account itself. So you could put, you know, you could put metadata, you could put a file name. If you have a file that's less, you can put an entire file's content if you want. If as long as it's less than the, I believe, ten kilobyte size limit of a single account, it's going to cost you the rent, the Solana rent for that. But you could do it.
00:26:24.392 - 00:27:03.354, Speaker B: So it's, I guess in that way it's kind of like inscriptions because you're just putting data on chain and you can put whatever data you want on chain. The thing that makes it super interesting with token extensions is it's a standard, it's a specification, it's an interface, whatever word you want to use for it. There's a standard methodology that TLV type length value, that's a standard way to deserialize and serialize the data you're putting in it. So that way you can all be efficiently packed together and stored on chain in the most efficient manner. So I hope that answers your question. It looks like it did. Awesome.
00:27:03.354 - 00:27:34.086, Speaker B: All right. All right. So now that we've initialized the mint, we can initialize our metadata itself. So we've initialized the mint and we need to tell the mint, hey, you're going to store our metadata because we are using our mint as our metadata account. So we need to tell the token extension program to do that. So that's what we're doing here. We're creating the initialize instruction and this specific instruction and this next instruction, the create fields and update fields.
00:27:34.086 - 00:28:12.048, Speaker B: This is actually being pulled in from the SPL token metadata package. So this is the reason, this is the big reason why you're going to need this package installed. If you're doing anything with metadata within token extensions and go back to code. So just like initializing most metadatas, you get a helper function. Most metadata accounts on a program or on a token or anything like that, you get a helper function. You pass in the arguments correctly. We're passing in our mint, which is our mint, and our metadata, which is both the same value because again, we're going to use our mint itself to be our metadata account.
00:28:12.048 - 00:29:16.984, Speaker B: So if you wanted to use a different account for for your metadata account, you wanted to use, say, libre plex or metaplex or any other program that exists out there, you could just specify that here and it would have to match your metadata pointer as well. And then we need to set our, whoever our mint authority is because, and this one's important that this mint authority here needs to actually sign the transaction because the Mint authority is going to control who has the ability to modify the metadata. So this account here, whatever address you put here, needs to actually sign the transaction in order to effectively begin the modification process for the metadata. And then we can actually pass in our on chain metadata. Now you can note here that we're only passing in these three values, the name, the Uri and the symbol. These are the only three values that you're actually passing in initially to initialize the metadata itself. So this instruction is going to initialize our mint account to store our metadata.
00:29:16.984 - 00:29:57.144, Speaker B: And we're going to put the bare minimum metadata in here, the required metadata, these three fields, and then that will actually begin putting some of our metadata on chain. But that doesn't put all of our metadata on chain. That doesn't touch this additional metadata yet. Keyword yet. So that's where this next section comes in. We're going to use the create update field instruction helper function to create an instruction that can actually create or update the additional metadata fields. How this works is you need to use a single instruction for this create update field instruction.
00:29:57.144 - 00:30:50.772, Speaker B: Every single additional metadata field you have has to be an additional instruction. So you can do that as multiple transactions if you want or you can do it as one transaction like I'm doing here. So I think this is a little clever way to do it, to do it when you're creating the mint itself. So what we're doing, if you can't already tell with this, with this pretty straightforward code, is we're going to map over the array of our additional metadatas and we're just going to generate a listing, an array list of all of the additional metadata fields we want. So because our additional metadata is, we're currently putting two, those two key value pairs, we're just going to create two separate instructions because again, you need one instruction for each additional metadata field. Whether that's in the same transaction or a different transaction, it doesn't matter. So we're creating those two instructions and we're going to put those into an array.
00:30:50.772 - 00:31:39.074, Speaker B: And then if you look down, we can finally build our transaction. You saw it earlier and you can notice here I'm doing the triple dot, the ellipsis. So I'm going to use the spread operator and I'm going to spread in the update metadata fields instructions because again, it's an array. So we have to pass in all of these arrays for all of these instructions. So if you look at this instruction or this transaction, this is effectively the same thing as doing this, right? So we're going to have these, was it six instructions in this one transaction to create our token itself? Create the mint. We're going to create our on chain metadata, the basic metadata. And then we're going to put any additional on chain, the additional metadata on chain, any amount that we want.
00:31:39.074 - 00:32:46.704, Speaker B: So if we had a bunch of if we had a bunch of metadata, we want to put, you can put as many instructions in here as you can fit within a single transaction, within the size limit of the transaction so if you can imagine, say this token that we're going to create, say this in NFT, you can have any number of traits on your NFT, right? So if you wanted to have a bunch of, if you wanted to have a bunch of traits or attributes, whatever you want to call them, if you want to have a bunch of those on a single NFT or a single mint, then you're going to define them here. If you do this methodology here, it makes it a nice convenient simple code way to basically generate all of those instructions and put them all in. Go ahead and go back to the initial code. Now we've built an instruction. We can simply sign it, send it to the blockchain and then we can get the results back. At this point, once this transaction gets confirmed, you've officially created your first token using token metadata and token extensions. So super, super awesome.
00:32:46.704 - 00:33:23.162, Speaker B: Yeah, I see some questions in the chat. I'll take a quick stop. Someone asked what's in the metadata uri. If the metadata is stored in the account. So the URI specifically, it can be whatever you're pointing to, you have to give it a value. I believe the program actually requires any, requires a value. And just like any other token metadata type of program is, you're going to need to, typically you're going to want to store some data off chain because it just doesn't make sense to put all of that on chain.
00:33:23.162 - 00:34:02.874, Speaker B: It gets very costly vice. The benefit of putting it off chain is it's way cheaper to do. If you wanted to put that on chain you could do it. You could put all of those fields into, into the additional metadata fields. So things like your image or any other metadata you want to put. I think this specific one that we're putting in this example, I'll even take the look here and I'll go ahead and throw a comment block so everyone can see everything that's actually being put in here. This is the data within this specific off chain Uri.
00:34:02.874 - 00:34:35.904, Speaker B: It just has the same information here, the name and symbol. Nothing special there. But we are, the important thing is we are pointing to an image, an additional image file. Again, you could put that into the additional metadata fields. But the thing about that is you can think of that like a specification that people do not yet support. Everyone is explorers and wallets and all the big players like that, they're used to this type of flow. So the URI points to some JSON file and they're going to query that and get that data, display it out.
00:34:35.904 - 00:35:23.144, Speaker B: So that's what's going in there? I hope that answers your question, Mike. All right, so go ahead and scroll down. So again, at this point we've created our token so we can actually, I have some logs down here to log out the address and we'll run it and I'll share the address inside of the chat. And the last thing we're doing here is we're actually going to, this is the actual way that you can get that on chain metadata. Those additional fields, we can just get it directly from account state. We're going to use the get token metadata helper function and await the promise that it's going to return. This again gets pulled from the SPL token package or SPL token metadata package.
00:35:23.144 - 00:35:44.974, Speaker B: You just need to give it the mint address or wherever the metadata is. In our case it is on the mint account. We're just going to log that out so you'll actually be able to see what that looks like. But it's super straightforward. This is how easy it is to get the on chain metadata, this wonderful helper function. Super simple. Let's go ahead and run this.
00:35:44.974 - 00:36:19.564, Speaker B: I'll go ahead and clear this out again, this script, we're going to run it with Esrun and it's called mint. We'll go ahead and run it. If I could type Esrun. Esrun. There's an r and run and fullscreen this so you can see we're logging out the payer address. We generated a brand new random mint address, new key pair, totally random. And we sent our transaction, we have the transaction signature here and the account that we actually created, the nine s six p.
00:36:19.564 - 00:36:41.938, Speaker B: We also logged out the metadata. We got, this is the metadata that's actually stored on chain. When you use this get token metadata function, this is the data that gets returned. If you look, it's the exact same information that we put inside of our metadata. Makes sense. We've got all this information. We have this additional metadata that we put.
00:36:41.938 - 00:37:05.168, Speaker B: We can put any number of bits of metadata in here. You can see here, this is that random value I typed in right at the beginning. And it's that simple. There was, we can go ahead and look. Go ahead and shift over to. I got to shift over to browser. There we go.
00:37:05.168 - 00:37:35.400, Speaker B: All right, so we'll shift over the browser just to take a look and see. So we have the transaction here pulled up on Salon FM. You can look at this type of information on just about every explorer. The thing I will say is that some explorers and some wallets are still because token extensions are still pretty new, especially the metadata portion. You might not necessarily see the metadata displayed the way that you would expect it to. So just keep that in mind. But you can always query the blockchain and verify the information there.
00:37:35.400 - 00:38:00.068, Speaker B: And that's the beauty of account state. But here's the transaction. You can look at it. We've got those instructions that we ran straightforward and move my zoom window. But the thing that everyone wants to see is the actual mint itself. So we minted, we created our token. Here's the image that was in that off chain Uri, the only possible on Solana name that we gave it.
00:38:00.068 - 00:38:38.500, Speaker B: This is pulling in from the account state. And you can see my Nick six Z address is the, is the authority. And you can see that this is in fact using token extensions. Again, different explorers and different wallets will display this information differently. But you can look at the metadata tab on Solana FM and you can see here is that same off chain or the same on chain metadata we gave you have the additional metadata field and they're just displaying it out directly. The structured object in that key value pair and yeah, that's token extensions. That's token metadata.
00:38:38.500 - 00:39:21.432, Speaker B: It's super straightforward, super simple. Once you understand those foot guns and those nuances that can definitely be in there. I'll pop back over to versus code and if anyone has any questions we'll go through one more thing here before we end this workshop today. But if anyone has any questions, feel free to ask them in the account or in the chat. Someone asked, is there no need for metaplex to handle metadata? Why is it decimals of two? The decimals of two, you can do whatever decimals you want. I just happen to put two. You could do any number of decimals you want, totally up to you.
00:39:21.432 - 00:39:52.632, Speaker B: Just like creating any other token. As far as the question about the need for metaplex to handle metadata, no. With this token extension you don't need an additional metadata program. You can store your metadata within the mint itself using the SPL token extension program. You don't need an additional metadata program. You can still use those if you want. There's potentially some reasons why you would want to use additional metadata programs.
00:39:52.632 - 00:40:41.424, Speaker B: There's potential reasons why you don't. It's definitely a case by case situation. There's another question. Can you combine metadata extension with confidential transfers which hides amounts as far as creating the metadata? Absolutely. If you create a token, if you create a token that you want to use the confidential transfers extension, you can absolutely put the metadata on your mint because it's just metadata on your mint. It's so people can identify your token. If you think of your favorite token like USDC or something, you have a name, you have an image, people are going to want to need to identify it somehow.
00:40:41.424 - 00:41:23.926, Speaker B: Then the confidential transfers are completely separate. But you can put any number of extensions up to the transaction size limit on this, on these tokens. Someone asked what would be the reasons to use or not use metaplex as well as the extension. It's purely, it's kind of like a personal choice if you want to use metaplex, if you want to, not if you want to use libreplex if you want to, not if you want to write your own custom metadata program. The point of this is that it's so flexible. It's an interface you can point to whatever you want for your use case. So maybe there could be some functionality within another metadata program.
00:41:23.926 - 00:41:54.854, Speaker B: Whether it's metaplex, libreplex or a custom one that you write. You could have custom functionality built within that, could have custom parsers, custom data structures, those sorts of things. Those are some of the reasons why you might choose one or the other. I'm getting a lot of thumbs up there. Awesome. Glad to answer your questions. I said I would show one more thing and the thing I wanted to show is I mentioned it a couple of times where it's super important for those couple of nuances with token metadata.
00:41:54.854 - 00:42:31.226, Speaker B: And I want to show you what that looks like. The first one is for the account space. If we allocate more space, if we allocate the entirety of all of this on our mint itself, you'll see that this transaction will actually fail. So before we had just doing the mint itself and not the additional metadata, this is a variable, variable length field. Think of it like that. We're going to try to allocate that on the mint itself and I'll go ahead and show you what that is going to actually look like if we try to run this transaction. You can see right here, the transaction fails.
00:42:31.226 - 00:43:02.984, Speaker B: Right away you get this error message for this particular one is the Token Z program. That's the token 22 token extension. The instruction for initialize mint has invalid account data. So that's the error message that you get for this. So it's, again, it's like I mentioned before is the error message is not super explicit as to what happened and why the error. Why it happens like we had the incorrect space set but that's the account data. So the transaction failed.
00:43:02.984 - 00:44:06.690, Speaker B: There's a couple of these other ones, even if you do any amount of additional, if we do one extra byte on our space, you can see the same thing will happen. The transaction fails because it does not have the correct space that you're allocating when you're actually creating the mint itself. The reason for this is because there's some checks built in with the token extension program that when you're creating this, it will actually require, because of the TLV, the type length value data structure that stores all of this additional token extension data. Whether it's the metadata extension, whether it's any of the other extensions, it's all storing this in the same serializable data buffer in the account. That's the account data. And so it has some checks built in with the program that it requires it to be the same amount. And then you'll also notice that we've put the correct amount of lamports to pay for the total rent.
00:44:06.690 - 00:44:55.892, Speaker B: Because as you execute these instructions after you've initialized your mint, because again, these ones have to be before you initialize it. When you run the instructions that to initialize the metadata and update the additional fields, it's actually going to automatically expand the space that's required because it's filling in the rest of that data buffer and it's going to update this length value of how many bytes the data is actually stored in. That's actually what's happening here. Think of it like it's auto expanding the amount of space that it needs, and the program handles that. In the background. I see there's a couple of questions in the chat. I will try to open the chat.
00:44:55.892 - 00:45:35.554, Speaker B: There it goes. All right. There was a question about Solana wallets displaying the metadata somewhere. Yes. So Solana wallets, to my knowledge, the major wallets do currently support the token metadata and most token extension things, they do support them currently. They display them just like any other token. So if you look at, you can look at certain your favorite tokens on chain and look and see if they're using the token extension program or the original token program, and you can see which program they're using and you'll be able to see where they're getting their data from.
00:45:35.554 - 00:45:59.338, Speaker B: So, like, what's the one? I know bonk earn. Bonk Earn uses the Token 22 program. I can't think of any other ones off the top of my head, but I know bonk earn does. Yeah. So wallet support is there for token extensions. There's another question on is it possible to update or add additional metadata after the mint. Absolutely.
00:45:59.338 - 00:46:26.692, Speaker B: You can absolutely do that. Let me close out of this zoom window. So there's a helper function, like you might have guessed, there's a helper function within the SPL token package. And actually, you know what it is? This, this is the function. You just have to call this function again. And that's it. That's how simple it is to do these things with the token extensions.
00:46:26.692 - 00:47:08.770, Speaker B: If you want to add an additional metadata field you just have to run this instruction again, submit it and you have to have the update authority, the metadata update authority, sign the transaction and then you can update that specific metadata field. And again it's this key value payer. So you have your field, that's the key and then the value is the value. And this is actually idempotent by default. Didn't quite want to load. This is actually idempotent by default. So if, and that's one of the super great things about this helper function is that if this particular field does not exist, the helper function will create it.
00:47:08.770 - 00:47:31.734, Speaker B: If it does exist, it's just going to update it with the new value. So you just have to call this one. You just have to send this one instruction to update or create any additional metadata, those additional metadata fields. And it's that simple. It's great. All right, back to the chat. Someone asked a question.
00:47:31.734 - 00:48:03.726, Speaker B: What was the TLV data record you were talking about? So this is what I mentioned at the beginning. TLV stands for type length value and it scroll up. So when you're doing a lot. So how the token extensions work is just like if, just like any other account structure, it is storing. You're storing data inside the account. You're storing raw bytes inside the account and your program. So if you write a custom program, your program knows that the data stored inside the account, it knows the structure of that.
00:48:03.726 - 00:48:52.810, Speaker B: So you can use whatever your favorite deserializer is. Your program can deserialize that into the correct struct, right. With the token extension program it does the exact same thing. And because there's so much data that can be stored within the, you can have so many extensions stored within it. They're using this TLV type length value serialization method. It's effectively what it is. It makes it so in the entire data field within the account, this buffer of bytes, the program, when it goes to deserialize it, all that data, you can have five different token extensions that are stored within the, stored within the mint itself, within the data.
00:48:52.810 - 00:49:31.424, Speaker B: There's a bunch of individual data that's specific to each extension. And what the token extension program does is it knows how to correctly deserialize and serialize that data because of this type length value structure. Effectively, it uses this type to identify which token extension you are, this extension type, which extension it needs to destilize next. Then it knows, then the next value, excuse me. And then the next value is the length. So the total number of bytes that the actual data that is specific to that extension has. And then the program knows that.
00:49:31.424 - 00:50:09.674, Speaker B: Okay, if so, say you use the discriminator, the type is the discriminator, just like an anchor program. Or you write a program to interpret instructions, you have a discriminator. That's all this is. It's a type the discriminator of that is specific to each extension. So when the deserializer runs to try to grab all the data that's on the token extension account, it knows that, hey, this is the metadata pointer instruction or the metadata pointer extension. And then the next value, the next, I think it's two bytes. The next two bytes is the total number of bytes following that that it needs to actually grab.
00:50:09.674 - 00:50:45.024, Speaker B: That is the actual data itself. And that's this value right here. So our metadata, because it's a variable amount, we need to calculate how many bytes that we need on chain for that to store it. And then when the token extension program runs, it can correctly deserialize. This is effectively the same way that you can get account slices, slices of data. When you are requesting accounts on chain, you can give it the exact offset of trying to get the correct bytes to get the correct data. It's effectively the same thing, just specific within this one account.
00:50:45.024 - 00:51:04.704, Speaker B: So I hope that answers your question, Aaron, about what TLV is. All right, yeah, sure thing. That helped. Let's see. So there was one other error that I wanted to show off real quick before we go. We're getting to the last little bit here. I'll go ahead and clear my console.
00:51:04.704 - 00:51:49.424, Speaker B: The last error that I wanted to show is make sure that's back to normal, is the thing I was mentioning at the beginning of initializing the mint in the correct order. Some instructions. When you're working with the token extension program, some instructions need to be atomically processed before you actually initialize the mint. You need to create the account first, then you need to initialize the pointer and then initialize the mint. So even if you swap this order right here, so if we try to initialize the mint first and then the pointer this transaction will now fail because it's out of order. And you get this same error as before, which is a downside. So it gets a little bit confusing.
00:51:49.424 - 00:52:33.658, Speaker B: But you get this error message that says, hey, when you tried to initialize the mint it errored out. It returned an error because it's invalid because the mint, you cannot do the, you need to initialize, you need to do some of these instructions before. So the same thing is true is if I try to initialize the metadata, so I initialize the pointer, then the metadata, then the mint, this will also error out. And this errors out. You can see the logs are, there's a little bit more logs because you've gotten further into the program of execution. This time you get a different error message but you're still getting an error message on initializing the metadata. In this case because we're trying to initialize the metadata.
00:52:33.658 - 00:53:03.106, Speaker B: And in fact this particular error is because we're trying to initialize the metadata on the mint. But the program doesn't know that the mint is a mint. It's just a regular account because we haven't initialized it as a mint. The same thing is also true if you swap these. If you try to update the fields before you initialize the metadata, you'll also get a different error. This one update field error. Some of these errors are super straightforward, or rather are more straightforward to figure out what's going on.
00:53:03.106 - 00:53:44.618, Speaker B: Some of them are a little bit tricky. And a lot of these things that I'm mentioning here about a lot of these things I'm mentioning here, they're also covered in the guides that we have on token extensions. You can find them in the readme of this file, which I'll also post this back into the zoom chat. And you can see the link right here if you're watching on video, if you're not on the zoom. All of these guides here have callouts for these types of things, of trying to help everyone understand that the order of operations is very, very important with token extensions. Alright? But that, that wraps it up. That's token extensions.
00:53:44.618 - 00:54:13.106, Speaker B: That's, that's the metadata extension. Metadata pointer. I hope everyone was able to learn some good stuff. They, they found this helpful. Like hall said at the very beginning, we have some other assorted workshops that are coming up on the Solana developers Luma calendar, Luma calendar and also ETH Denver. If anyone is going to be at ETH Denver, a bunch of people from Solana foundation and uh, other members of the Solana ecosystem, we're all going to be at ETH Denver. I'm personally going to be at ETH Denver.
00:54:13.106 - 00:54:31.794, Speaker B: If anyone's going to be there, feel free to come over to our booth. Solana foundation is going to have a big booth going on. Uh, we're going to be playing some fun games. We're giving out limited edition Solana developer shirts, the first of their kind. I'm super excited to get one and stop on by. Stop on, say hello, and, uh, yeah, I hope everyone learned something. I hope you have a great rest of your day.
