00:00:01.360 - 00:01:21.426, Speaker A: So John Wong, John Wong from Solana foundation asked me before this talk, he said, is the new web3 js API going to be sweet? And I thought about it for a hot second and I told him, actually, John, no, I don't think so. Because sweet APIs, sugary sweet APIs, they rot your teeth, they give you a sugar high until your application crashes, and they give you a stomach ache after you use them for a really, really, really long time. I like to think of the new web3 JS API as more like vegetables. You eat them, you chew on them, they sharpen your teeth, they're good for you, they give you vitamins and minerals, they improve your eyesight, and they help you see in the dark. Well, APIs, by their very design, they demand to be used in certain ways, and they lead developers down certain paths, and we all end up in the same pits once we use them. And so it's my hope for the new web3 JS API that the design of the API all leads us right down into the pit of success. My name is Stephen Lucher and I work at Solana Labs, and it's my great pleasure this morning to introduce to you the new web3 js.
00:01:21.426 - 00:02:14.230, Speaker A: So, for the uninitiated who don't know what web3 js is, it is a JavaScript library that you would use to read and write data to execute programs on the Solana blockchain. In short, if you've ever minted an NFT, played a game, logged into a service, chances are the application that you were using uses web3 J's underneath the hood. It's downloaded about 400,000 times a week. But just because it's pervasive and just because it's popular doesn't mean it's good or that it's done. You told us, in fact, that you want something better. You told us that the thing, it's hard to customize, it's too opinionated. Folks from Mango told us, Steve, your transaction confirmation strategy just doesn't work for us.
00:02:14.230 - 00:03:25.434, Speaker A: We need something different. Mpiela told us a connection class is cool, but could I maybe get a multi connection class that let me fall back from a primary to a secondary RPC in case the primary fails? An epic face told us, hey, I'd like you to add this feature where if I make a bunch of requests in a short time window, you just automatically batch them together. And so far, requests like these for custom retry behavior in case you get a 429 rate limit or the RPC fails, we've had to say no to all of these requests because what works for one application may not work for all of them, and we have to cater to the plurality of Solana applications with the design of the API. Another thing you told us this thing has got to be tree shakeable. You told me, Steve, I'm happy that you offer all of these 11 billion methods for me to call, but I only use these three. Or I only use these five. But when I include web3 js in my project, I get all of them whether I like it or not.
00:03:25.434 - 00:04:17.714, Speaker A: You told us if I use these five methods, my optimizing compiler should just blow all of the other ones away and only include the five that I need. You also told us it's about time to use modern JavaScript. Things like BN jspolyfils for large integers, gotta get rid of them. We have to find some way to get bigint into this library. You also told us, did you know that modern support natively in environment is coming for exactly the encryption algorithm that Solana uses? Ed 25,519. In fact, it's already here in Safari 17. It's behind a feature flag in Chrome, and it's in all of the major server runtimes like Node JS, Bun, Vercel Edge Runtime, AWS, Cloudflare workers, et cetera.
00:04:17.714 - 00:05:25.460, Speaker A: Despite that, the current web3 j's API key pair generate and transaction sign are fundamentally incompatible with the new modern ED 25519 support, in part because all of these APIs are synchronous and the native ones are asynchronous. So for the past six months or so, me and this crack team of developers, Joe Caulfield, Callum McIntyre and Loras Leyva have been working on a new version of web3 js, and I want to put it into your hands today as a technology preview. Not just to announce it, but to get the code into your hands so that you can start kicking the tires. So here's how I would suggest watching this talk. I would suggest for now, most of you will close your laptops, just put your phones on DND, and then just take both of your hands and just hold onto your butts because we only have 15 minutes to blast through what's new in this humongous API. This talk is going to be split into two parts. First, we're going to compare the old and the new to see what we were able to achieve.
00:05:25.460 - 00:06:19.196, Speaker A: I'm hoping through this section it'll inspire you to come on this journey with us and do this migration with us so that you two can get the kind of wins you're about to see. And then the second thing, I'm going to just deep dive into some of my favorite parts of the new API. So let's begin. First, let's compare the old and the new and see what we were able to achieve. So first, let's talk about the bytes that you ship to your clients when you're building a web app. If you were to take all of the old web3 js, or all of the new web3 js and bundle it together into a single browser, bundle and ship it to your clients every function, minify it and gzip it, how big would that, how many bytes would that be? So, kitchen sink for the old web3 js bundled together in an iife, 90 kb. For the new, 33 kb.
00:06:19.196 - 00:07:17.486, Speaker A: That's a reduction of about 2.7 times. But this isn't the whole story, because if you are running an environment that supports Ed 25519 natively, you can continue to trim this down and throw out more code. Dropping the new web3 js browser bundle to 17 kb, which is about five time reduction. Now, my friend Joe was like, what would a typical application look like? If I were to build a small toy application that just transferred tokens, bundle it up as a browser bundle, what size would I be able to achieve? Well, because of the new way that we can tree shake away functionality that you don't use in the new web3 js, even building a typical application that transfers tokens, Joe was able to bundle the old web3 js into 67, into four and a half kilobytes. That's a 14 times reduction in a simple use case like transferring tokens. Let's take a look at the back end.
00:07:17.486 - 00:07:44.916, Speaker A: Now, Callum was able to create a web service for AWS that accepts a transaction, authenticates you, signs it, sends the transaction, and returns the transaction signature to you. This would be a common use case for a relayer or something like that. He took the AWS tooling, bundled it up. The bundle ended up being 5.4 megabytes on AWS. For the old web3 jS, 1.7 for the new, a reduction in three times.
00:07:44.916 - 00:08:46.304, Speaker A: And actually the new web3 JS version, AWS was actually able to render it in the control panel, which was not true for the old one, which was kind of a fun side effect in terms of performance. Callum also wrote a little thing that takes 500 transactions, signs them over with five signers each. In terms of latency, old web3 JS was able to blow through those 500 transactions in 750 milliseconds and the new in 200, a reduction by 3.7 times if you flip that on its head and ask operations per second. Here's a little toy example that I created to generate a key, sign a message, and then verify that message in that order. And I loaded that up in brave with the experimental flag turned on, which means that you got the native ED 25519 stuff available. Old Web three js was able to crank out 700 of those operations per second, ten times more if you use the native ED 255 one nine stuff in new browsers and new JavaScript environments.
00:08:46.304 - 00:09:49.894, Speaker A: Now the next stat is the one that matters. Does all of this translate into real world applications? So we asked that question, and we decided to take the Solana Explorer Explorer dot Solana.com and replace just on the homepage the old web3 js with the new web3 js not removing or adding any features, just straight up migrating. And after we replaced the old with the new Solana Explorer dropped by 26% from 311 to 228 kb on first load. So here you have a real world application, no feature changes the same features from point a to point b, just migrating to the new web3 js let you throw out a quarter of the code. This is humongous if you're building a web application and shipping it, especially in emerging markets that have terrible connectivity and unreliable networks. So hopefully that's a little bit of a carrot to encourage you to come along on this journey with us and migrate.
00:09:49.894 - 00:10:39.914, Speaker A: What I want to do next is I want a technical deep dive into some of my favorite parts, and I want to talk about these things. First we're going to talk about the transport, the way to get bytes back and forth. Then I want to talk about the RPC API that you use to make requests to the RPC call methods. Then subscriptions subscribing to count data changes, slot changes, that kind of thing. Then I want to say a few words about keys in the new library, transaction builders in the new library, and then I want to talk a little bit about how we are tripling down on typescript to help you fail faster in authoring so that you can ultimately succeed sooner in production. All right, let's go. First, the new RPC transport.
00:10:39.914 - 00:11:37.652, Speaker A: The transport is now defined by an extremely simple interface. It just says if you are a function which takes in a payload and returns a promise for some response, you are a new web3 j's compatible transport. So here's the simplest possible transport that you could write, you could create a transport using some URL like Devnet dot solana.com API, dot devnet dot solana.com. And you could return a function that accepts a payload and uses the native fetch to actually fetch that data from the RPC and return it as JSON. This is a web3 js compatible transport. Now do you remember how Empyella filed this issue saying hey, I want a special kind of transport that tries a primary RPC and falls back to a backup in case that doesn't work well through composition.
00:11:37.652 - 00:12:55.244, Speaker A: Here's how Mpyella could do that today. They could make this transport creator, they could specify a list of URL's for different rpcs. They could create the transports that you saw in the previous slide, one for each URL, and then in a loop we could start, we could say hey, let's pick the first transport, try to make the request, and if that request fails and triggers this try catch, then we can move on to the next transport and then the next transport, and the next transport after that until you either get a response or you run out of transports to try, and you ultimately have to fail the request. So through composition like this, in code that fits literally on a slide, you can implement all of these transport strategies. And I want to see every single transport strategy imaginable created by you and open sourced for all Solana developers to use. All right, next the RPC API. So the current RPC API is about, I don't know, 3000 lines of hand hewn artisanal JavaScript code.
00:12:55.244 - 00:13:50.666, Speaker A: The new RPC API is about 50 lines of highly dynamic code based on JavaScript proxies. Because it turns out that JSON RPC being a specification, is really predictable and repetitive, and you can implement most of it using a very little bit of code. The new RPC is finally cancellable with modern abort controllers in case you navigate away or you otherwise just don't care about the response anymore. And adding a method to the new RPC requires zero bytes after the first one. We can support infinite growth in RPC methods now without adding a single kilobyte to your JavaScript bundles. And the reason that we can do this is because all of the RPC methods are described as typescript types. I want to give you an example of this.
00:13:50.666 - 00:14:54.134, Speaker A: Let's say that your quick node and you offer a superset of the Solana RPC methods like this one to fetch NFT collection details. Well, quick node could now go and they could write something like this type spec that says oh, we offer this method, it takes these arguments and it returns this kind of response. And then we've offered some ways of mixing that in to the existing RPC types so that as a developer you can call special quick node methods alongside all of the regular Solana methods. Same for Helios, same for any RPC that conforms to JSon RPC. So Helios quick node hit us up and let's get this done. All right, the brand new subscriptions API the subscriptions API is now based on modern JavaScript Async iterators. It is also cancellable with modern aborta controllers.
00:14:54.134 - 00:15:52.808, Speaker A: And these two things together enable something that I want to call gap recovery and I'm going to throw up an example. And by example we're going to explore what this looks like. So let's presume that I've made a subscription already and I've gotten a handle on an async iterator, which is account notifications. There async iterators you can iterate over all future values, all future notifications using a JavaScript for await loop. And every time you get a new notification that for loops code will run. Now, if you end up on this line right here, it implies that the subscription was canceled, it was aborted, you unsubscribed from it. On the other hand, if you end up on this line here, it means that the subscription died for some reason, the network went down, some other fatal and it's at this point that gap recovery comes in.
00:15:52.808 - 00:16:50.534, Speaker A: What if you were subscribing to account balances, displaying them in the UI and the subscription went down? You absolutely need to do two things that you cannot do right now in the current web, three js. You need to know that the subscription went down so that you can set it back up again. And then, crucially, you need to recover from having missed messages. If you missed a balance update after you set it up, you have to go and refresh that balance so that your UI is up to date, and then you can continue listening to account changes going forward. This API offers you gap recovery in a way that the old one didn't, and because it's all based on just JavaScript, it operates just the way you would expect a try. Catch. Finally block to work the finally block will run whatever the case, whether the subscription went down or whether you unsubscribed on purpose, so that you can run cleanup code for the rest of your application.
00:16:50.534 - 00:17:32.056, Speaker A: All right, let's talk about keys now. Keys now are based on native J's crypto keys. And in the case that you're running in an environment that does not yet support the ED 25519 curve that Solana needs, we've written a polyfill for you so that you can continue to use subtle crypto in a way that you're used to. And we polyfill the ED 25519 stuff for you. And these keys are super, super fast, as you saw in the benchmarks section. And they also have this interesting property that I'll just call leak resistance. And it looks a little bit like this.
00:17:32.056 - 00:18:29.410, Speaker A: Imagine you have a private key and you, against your best judgment, console, log it, or log it to some kind of error reporting service or JSON, stringify it and store it somewhere. The interesting property of crypto keys is even if you try to do that to a private key like this, all you'll get is metadata about the key itself, something exactly like this. What you won't get from logging or stringifying a JavaScript crypto key is the actual content of the private key bytes. So this is a very nice little extra protection that keeps keys from being leaked from the client. All right, semi lastly, let's talk about transaction builders. So first of all, we've unified legacy and version transactions. There's no more transaction and version transactions classes in the new web.
00:18:29.410 - 00:19:49.294, Speaker A: Three JS transactions are just transactions. And we've done this in part because address lookups are now first class members of instructions. Just in the same way that you would specify the address of an account that participates in an instruction, you can now specify the lookup table address and the index of that account. You build up transactions using functional transforms, and we use typescript to prevent you from making common errors. Let's take a look at how you would build a simple transaction. You might create a pipeline of transforms, and you could start by creating a version zero transaction, and then apply a transform like setting myself as the fee payer, or grabbing the latest block hash and applying it to the transaction, or appending or pre pending transfer or memo instructions, and then taking that transaction, signing it with a regular raw native JavaScript crypto key, and it's ready to send. This takes me to this last part that I talked about, about types, how we help you fail faster so that you can succeed sooner in production.
00:19:49.294 - 00:20:41.344, Speaker A: We want you to find out about errors as you type or as you compile, rather than what you're doing right now, which is finding out about omissions at runtime. Who among us hasn't done this right? Made a transaction but forgot to add a fee payer in the new web3 js that is now a typescript error. Or maybe you've done this. You've set a lookup table address and an index, but you did it on a legacy transaction. That in the new web3 JS is now a type error. Or maybe you've tried to create an advanced nonce instruction by hand, but you forgot an account. You forgot that you need to include the recent block hashes syspar that in the new web3 JS is now a type error.
00:20:41.344 - 00:21:33.834, Speaker A: Find out about these common errors at author time, not at runtime. There is so much more that I want to talk to you about, and so much more detail that I want to go into that I don't have time for. But there is one more thing, and that one more thing is that we haven't talked about the slash programs directory. The thing is, you don't think about building products in terms of the primitives that we've offered to you. Create transaction, generate key pair appending instructions. The way that you think about building products is in terms of these things, transferring tokens, minting nfts, depositing stake, because these are the things that deliver actual value to your customers. So we want to offer you APIs that are closer to your customers desires.
00:21:33.834 - 00:22:21.874, Speaker A: And we want to deliver it not just for the built in programs, but we want to deliver it for every Solana program, even the ones that you will write. And so that's why this team is working on code generation tools for any program, including yours, for only the instructions that you need to use, and all powered by web3 js under the hood. So follow along with development. We're really excited to show you what this looks like. We have a good idea of how it's going to work, but it's coming soon, in the future. But for now, for today, get the technology preview with us. Tell us if you find something broken, tell us if we missed including something.
00:22:21.874 - 00:22:50.934, Speaker A: If you apply it and you migrate and you get some kind of win in terms of speed or size, let us know about it. And here's my offer to you. If you are willing to undertake a migration, you can contact me and I will get you one on one help. We'll be with you side by side all along the way. So tensor get at me, et cetera. Solana Fm get at me and let's get this done. And here's how you get it.
00:22:50.934 - 00:23:05.334, Speaker A: Shoot that code. You can NPM install with the tag, or you can shoot this code, or go to that URL to learn all about it. We've written a one pager with a lot more information for you. Thank you so much for listening, and we'll see you on GitHub.
