00:00:03.800 - 00:00:42.500, Speaker A: So this afternoon I wanted to go over a brief, or not super brief, but a more detailed lecture about serum, like before. If you're interested, please come sit over here. I'll be right on the whiteboard. And there's a lot of space. So what serum is, is in a nutshell, it's an on chain, central limit order book that's built on Solana. This was one of the key innovations that Solana was able to provide as like a decentralized app. And I could sort of explain some intuition behind the reasons first, I guess, maybe just going over the simple mechanics of a central limit order book.
00:00:42.500 - 00:01:33.884, Speaker A: So, central limit order book. There are many different ways to represent order books in terms of how orders are processed, but in general, there's only a few things that are required. There's a price price and there's a size. And this price can be for either buying or selling. We refer to the buyers as bids and the sellers as asks. And order book usually is represented in a ladder format. So let's just say that we have price listed here.
00:01:33.884 - 00:01:57.322, Speaker A: This will be say, also, I'll put this as size of the offer, and then this will be size of the bid. Size of bid. And I'll just write some numbers here. Let's just say the thing trades around ten. 1112, nine, eight, seven.
00:01:57.458 - 00:01:58.134, Speaker B: Right.
00:01:59.754 - 00:02:35.098, Speaker A: Something you might see in an order book is that you can see sizes on each price level. This could be like 20, 2040. And this will define a market. The offers are the prices that people are willing to sell. Whatever asset is represented in this order book at. And the bids represent the prices that people are willing to buy things from the order book at. So in this particular market, the best bid is priced at nine and the best offer is priced at ten.
00:02:35.098 - 00:03:15.748, Speaker A: So that means that these two people, like the people who are putting in bids at price nine, are not willing to buy at price ten. So this defines the market uniquely. If someone wants to purchase something from this order book, the best price that they can get at would be ten. And if someone was trying to sell on this order book, the best price that they could sell at would be at nine. And in most traditional financial markets, the way that price mechanism and price discoveries is sort of represented is through these central limit order books. There are some caveats of building these things on blockchains. One of the main things that would be difficult is prices are very dynamic.
00:03:15.748 - 00:04:08.172, Speaker A: They move really quickly. There are a lot of trades in the market. If you are trying to build an order book on a blockchain, for instance, it has very high gas costs. What could happen is that if you wanted to cancel or move your orders around, every single one of those actions requires you to pay a large fee, and this can be pretty detrimental, especially if you want to have markets that are very tight or liquid. It's a better user experience for people interacting with the markets when the difference between the bid and ask are closer together or tighter, but when they become wider, there's a higher implicit fee for order execution. And that's not necessarily desirable. If you were to run an order book on a blockchain like ethereum, where gas fees are very high, part of the cost that the makers incur when they're placing orders must be represented in that spread.
00:04:08.172 - 00:04:46.604, Speaker A: So it's very unlikely that you'll see efficient markets in that kind of system. So at a very high level, this is the data structure that essential order book will sort of represent. And Solana has the capability to run an order book like this, but it requires a bit of really careful engineering design. So let's talk a bit about how serum is organized. CRM has a couple main accounts that store all the information that you need. One account is the market. This will contain information about the different order books that are involved.
00:04:46.604 - 00:05:13.488, Speaker A: There's a separate account for the asks. This is a public key, the one for the bids. It's also a public key. And there's also an account for what we call the event queue. And this is also going to be a public key. There's also some metadata related to the market itself. You'll obviously need to have the mints for the both sides of the market.
00:05:13.488 - 00:06:00.298, Speaker A: Right? The mint that you buy with and the mint that you sell with. I believe the way that serum represented it is in terms of these terminologies that I personally dislike. But one of them is called base and one of them is called, quote, the convention is base would be something like in a BTC USDC market, where generally the convention is you buy BTC with USDC. So USDC would be on the bids and BTC would be on the offers. The, quote, mint would be USDC and the basement would be BTC. This convention, I think is very confusing, but once you know the nomenclature, that's sort of just how you should think about this. So this is just the metadata account.
00:06:00.298 - 00:06:30.834, Speaker A: It doesn't really encode much information. It just tells you what pieces of data that you actually need to access. The more interesting things are what these different accounts, bids, ask and event queue actually represents. So bid and asks both sort of represent the same underlying data structure. This is essentially just the order book tree. And we'll go over into how this is actually organized in detail in a bit. And the event queue is like a circular buffer.
00:06:30.834 - 00:07:38.744, Speaker A: And really this is just your simple FIFO queue. But the reason why it's implemented as a circular buffer is because when you are allocating accounts on Solana, everything must be densely packed. You have a fixed size buffer that you're storing information in. And so when you are operating on these fixed size buffers, it becomes really useful to make sure that all that information is, is stored in a condensed manner. So the FIFO circular buffer is a good example of how you could do such a implementation. Going through how a trade or order actually happens on CRM is fairly straightforward. So there is an instruction that's called new order that takes in essentially your price, your size and your side.
00:07:38.744 - 00:08:33.674, Speaker A: This will go through the existing order book. It will figure out based on the size, whether you're interacting with the bids or the offers. It will check to see if any of your orders cross with existing, if your order crosses with any existing orders in the book, and if it does, it will match them, right? So in the case where no orders are matched, all it will do is it will take that side. So say, let's make this really concrete. Say this price is like ten, say the size is five and the side is bid, and say the market is like nine at twelve, right? So this is the best offer and this is the best bid. If this were the case, all it would do is it would insert a bid in the bid tree at price ten for size five. This is the case where there are no trades that occurred whatsoever.
00:08:33.674 - 00:08:52.374, Speaker A: Let's change the value a bit. Say that this price was set to say there's ten here at the twelve price, and we set the price here to be twelve. If this were the case, there is actually a match that occurs and this size that is on the offer will be decremented to five.
00:08:52.454 - 00:08:53.006, Speaker B: Right?
00:08:53.150 - 00:09:54.664, Speaker A: That's just the normal behavior of like a central limit order book. And the way that serum represents this is that the data structures represented by the bid and ask will be modified to represent this information. And every trade field that occurs against every individual order gets pushed to this event queue, right? So I guess on trade you want to push a fill event to this event queue. Can anyone reason as to why this is pushed to a queue rather than just handled immediately? Yeah, so it is handled asynchronously, but in a traditional order book, you probably wouldn't yeah. See a hand. Did you say size of transaction concurrency? I'm sorry, I cannot hear you.
00:09:59.924 - 00:10:00.356, Speaker B: Gotcha.
00:10:00.380 - 00:11:02.704, Speaker A: So the suggestion here was like potential concurrency issues, like multiple orders happening at the same time. That's a good guess, but I think everything, because everything happens atomically, every single order will be happening at the same time. So there's no way in which there is a strict ordering to all the events that occur on the blockchain. Does anyone else have a guess as to why this might be the case? I kind of hinted at it when I said transaction size. If you were to actually match every single order on the tree, every single order in the order book, as a trades occurred, you potentially could run out of account space in your transaction. One thing that I probably should have mentioned in the description of the market is that every user on serum is given a special account called an open orders account. And this sort of stores the state of all of the assets they have to use.
00:11:02.704 - 00:12:02.712, Speaker A: And when you place an order on the book, that sort of locks up some tokens. So you have some locked token, locked quantity, and this will get incremented every single time you place an order. Because if I have some amount of USDC and I want to post a bid on the BTC USDC order book, in doing so, I'm saying that this token that I placed as bid is no longer withdrawable from my account. And that piece of accounting becomes somewhat important. When you make a trade on the order book, this lock quantity should in theory, be freed up in some way, so it should probably disappear, and the other token that got filled with should be available for withdrawal. That's just the mechanism, how the value transfer occurs. And because you would need to pass in every single one of these accounts for every single filled side of the trade, it becomes sort of infeasible to allow every single trade to be processed synchronously.
00:12:02.712 - 00:12:15.284, Speaker A: The event queue sort of handles the asynchronous process of managing all the accounting that occurs when trades happen. Does anyone have questions about that? I can elaborate further.
00:12:21.444 - 00:12:22.224, Speaker B: Yeah.
00:12:34.404 - 00:13:15.324, Speaker A: So the question is, when you put in a new order, whether you're transferring token to be locked up? The answer is essentially yes. So whenever you place a new order on the book, you have to transfer some tokens into serum. Serum will note that you have transferred some amount of token. And if you make a trade, what will generally happen is that some token will be transferred from the locked state to a freed state, and you can always retrieve that free token. So there's a locked quantity and there's a locked free quantity and a free quantity. Usually these will also be prefaced with either base or quote. Either base or quote based on these two types.
00:13:15.324 - 00:13:40.756, Speaker A: And when you trade, you can essentially think of these values incrementing and decrementing based on the positions that occur. So if you place an order in the book, your lock quantity is going to increase. When you make a trade, some of that lock quantity generally happen is that once it gets processed in the event queue, this free quantity is going to increase, so you can withdraw.
00:13:40.780 - 00:13:54.464, Speaker C: That's like.
00:13:56.484 - 00:13:57.220, Speaker B: Yes.
00:13:57.372 - 00:13:58.504, Speaker A: Yeah, thank you.
00:13:59.444 - 00:14:00.224, Speaker B: Cool.
00:14:02.744 - 00:14:45.144, Speaker A: So I guess I want to talk a little bit about how these structures are actually organized in memory because that sort of informs you about the complexity of the system. So I'll start with this idea of how do you represent an order book? I'll give a really high level overview of how the memory is set up. You have a section here that's just the header. So this is just the order book, which they call a slab object. You have a header and then you have a large chunk of bytes here that represents the nodes. Each of these nodes are going to be a member of that tree, and the nodes will have different types. One type is an inner node.
00:14:48.284 - 00:14:48.596, Speaker B: And.
00:14:48.620 - 00:15:50.994, Speaker A: One type is a leaf node. Roughly speaking, you can just map all leaf nodes to orders in the tree and the inner nodes sort of form the inner structure of that tree. The whole thing itself at a very high level. This is just your typical binary search tree that you learn in your intro computer science course that's more complicated because of the memory layout. Okay, so at a very sort of, the way that you can think about how node allocation works is that this space is just a, is like a list of nodes. There are inner nodes, there are leaf nodes, and there's something called the free node, which is also just like a node, but we can sort of go into like how that organization works. When you create a new order for the first time, you're simply just allocating a node in here and that is going to be like a leaf node.
00:15:50.994 - 00:16:29.554, Speaker A: When you create a new order on top of this, you need some way of comparing whether this node is less than or greater than the other node and you add another leaf. But potentially you'll also add some inner nodes. So what occurs is you basically start with a leaf node here. This is your first order that comes in. And then when you add in a new order, the tree has to have a preserved structure. So your root becomes like an inner node, and then the two leaves will be sorted based on their prices. Another leaf.
00:16:29.554 - 00:17:08.809, Speaker A: And this process sort of continues iteratively. But there's a rather complex way in which, like, this is all represented at a very high level. This is just a list of nodes, and there's some structure in them that connect between one another. So you can imagine that if you look at the end of node, there are two parameters to represent both left and right. And this allows you to search through this tree. It's rather complex. The mechanism that it uses is this thing called critbit, which I can maybe discuss briefly.
00:17:08.809 - 00:17:51.438, Speaker A: It has to do with sort of like, the searching mechanism that's used. But I think the key innovation that I think is pretty interesting and how serum even organizes the searching is based on what it uses for the keys. One important aspect of how serum works is that it's a price time based order book, which means that suppose I have a bunch of orders at a price level. Say I'll just use ten as a price level, and this price level has a number of orders of different sizes, and this will be sorted by time. So the first index of this array will be the size of the first order that's placed. Say it's like 55, 10, 20. If there was a trade that was size 15 that went through this level.
00:17:51.438 - 00:18:29.074, Speaker A: Ten. The order in which the fills get processed is one, two, and then three. And the final remaining state would be a list that has five and 20. So the data structure of serum has to have some way of representing not only the price ordering, but the time ordering of when the orders were inserted into the tree. So there has to be some mechanism built into the slab data structure that allows you to do so. And that is going to be the key that is used in each of the nodes. And this was a really clever innovation for the way that serum organized this.
00:18:29.074 - 00:19:15.164, Speaker A: Whenever a new order is created, there's an order id that's assigned to it. And this order id is a U 128. U 128. And the way that it works is the algorithm looks really roughly like you take the price, which is like some U 64, and then you shift this over by 64 bits. Then you have a sequence number that you use in some way. We'll discuss that in a second. Then, to create the order id itself, you do something like OId.
00:19:15.164 - 00:19:50.876, Speaker A: It's also U 64. By the way, OId is equal to price ored with the sequence number, and then you do sequence number plus plus. So does anyone see potential problems with this implementation if you use this as a key?
00:19:50.940 - 00:19:51.584, Speaker B: Yeah.
00:19:56.444 - 00:20:44.002, Speaker A: Yeah, that's certainly true. The timestamp can definitely overflow. I guess one thing that you could do is you can sort of reset it. I don't think serum has the current restriction of checking for overflow, but there's another really, I'd say more critical bug with this in terms of like the ordering of the tree. Does this work for both bid and offer, or does it only work for one or the other? Think about the order in which these things should be sorted. The offer should be sorted from smallest to largest, right? Because for the offer, the best offer is the offer with the lowest price that was posted at the earliest time. If you use this order id, this perfectly represents all offers, right? But it doesn't represent all bids.
00:20:44.002 - 00:21:11.494, Speaker A: So does anyone have a very clever idea of how you can represent bids with this ordering with just a small change? Minus? What do you mean by minus? I guess you could do negative price. That would be a somewhat interesting idea. I think prices are represented as U 64.
00:21:11.534 - 00:21:12.154, Speaker B: Yeah.
00:21:17.654 - 00:22:11.466, Speaker A: So you could do the greater than operation like you sort of sort in the opposite way. But I think what ends up happening is that on a particular level of the bid, say this is the bid, right? What's going to happen is that you will pop the most recent entry first on that level, as opposed to the least recent entry first, based on the way that sequence number is organized. So it is certainly true that your order book will be sorted from largest to smallest, which is a desirable feature. But the time ordering gets messed up. If you were to change the order, and that's the main problem, we can maybe go through a small example. Let's say that my price is ten, and my sequence number was two, and then I had another one where my price is ten and my sequence number was three, and these are both bids. The way in which they should actually get filled is this one should get filled first and this one should get filled next.
00:22:11.466 - 00:23:31.344, Speaker A: But if you were to sort it in descending order, this one gets filled first and that one gets filled next. So that's actually inaccurate. You actually have to do something slightly more clever to get this to work for bids. Okay, so the clever thing that you can do for this particular thing is you add one line of code prior to this line, if bid sequence number equals sequence number with the bits reversed. And I think this is pretty big brain, because what this allows you to do is when you do this, it guarantees that the lexicographical ordering of the sequence number is flipped from smallest to largest. And so now your order id is still the same, it's still going to be your price with this adjustment ored with your sequence number. But it's also true that the sequence number is going to be in the right descending order, right? And we can do like a really quick math proof if you're not convinced of this fact.
00:23:31.344 - 00:24:33.194, Speaker A: So just really quickly, right? Suppose we had two numbers. I claim that if normally x is greater than y, that tilde of x like you reverse the bits, this is gonna be less than tilde of y, right? And this is not super hard to imagine, cause like suppose x looked like 0101, something like that. Dot, dot, dot and y looks like 0101, it's like zero and one. There's gonna be some matching common prefix between these two that will always be the same regardless of whether you reverse the bits. But the second in which you reverse the bits, the next and most significant bit will get swapped, which means that the ordering of the two numbers will get swapped. So this clever bit hack allows you to represent both bids and offers in the tree. And this order id is now a unique way to both identify the order and also search the binary to search the order book in its data representation.
00:24:33.194 - 00:25:18.384, Speaker A: So to sort of reiterate about how serum does its structure of the order book, it uses this very clever key mechanism to determine the sort order of all the nodes and then it represents the tree itself in a densely packed list. Every single node in this list is going to be just a single entry with some pointers to other entries in the list. And you can just search this like a normal data structure, like you have APIs around it. But the nice part is that it fits in a densely packed account and it's also sorted. It follows the price time ordering that is sort of required for the matching algorithm that is present. This is quite confusing. So does anyone have any questions related to this?
00:25:19.004 - 00:25:21.084, Speaker B: Yeah, how does it tell the difference.
00:25:21.124 - 00:25:23.184, Speaker C: Between a bid and.
00:25:24.004 - 00:26:02.610, Speaker A: Yeah, that's a great question. So for one thing, they're sort of in two separate accounts. You have one account for a bid, sorry, the question was how do we tell the difference between bid and offer? You have two accounts, one for bid and offer, so you have asks and bids. And the other thing is that when you place a new order, you specify the side. So side is a user parameter. Are there other questions?
00:26:02.762 - 00:26:03.494, Speaker B: Yeah.
00:26:13.394 - 00:26:50.624, Speaker A: So the question is like what happens when you have a large number of orders? That's a great question. So there are a couple ways this is handled. For one thing, the account size is not limited to ten k. If you allocate the account outside of the program, not through a CPI, you can get much larger sizes, but it is true that the size is finite. The way in which serum handles the order book filling up is it will take the least most aggressive order which you can find conveniently due to the sorting key, and then it evicts that. So as long as your order that you're placing has a better price than the least most aggressive order in the book, serum has a way of managing that.
00:26:51.164 - 00:26:51.944, Speaker B: Yeah.
00:27:00.604 - 00:27:13.408, Speaker A: 001011. So eleven should be bigger than one. Okay, so this, to be clear, this is x, right? This is x and this is. Yeah. Right?
00:27:13.536 - 00:27:13.936, Speaker B: Yeah.
00:27:14.000 - 00:27:39.932, Speaker A: All right, cool. So let's do the reversal. This is one 10, and this is 10 zero. So this operation, this tilde operation, just takes the value of the bit and flips it to the different direction. Right. So initially x is larger than y and after the transformation x becomes smaller than y. Oh, I thought we were reversing it.
00:27:39.932 - 00:27:47.264, Speaker A: Yeah, no, no, we're flipping the bits. That's what this refers to. So that's a good clarification. This is a bit flip.
00:27:50.524 - 00:27:51.264, Speaker B: Right?
00:27:52.364 - 00:27:54.744, Speaker A: Are there any other questions related to this?
00:27:56.124 - 00:27:56.904, Speaker B: Yeah.
00:28:01.684 - 00:28:15.314, Speaker A: Yes, the slab, the slab that I'm describing that has all of the nodes inside this, in this binary tree, that slab data structure is stored in a single account. You have one slab for the bids and you have one slab for the offers.
00:28:18.294 - 00:28:22.062, Speaker C: Within the left, right?
00:28:22.158 - 00:28:22.870, Speaker B: Yes.
00:28:23.062 - 00:28:58.394, Speaker A: So these two are like, these are just essentially indices inside the array, because the whole thing lives in a giant array. These are indices in the array and they'll point at other nodes that could either be inner nodes or leaf nodes indices. Correct. It's indices. So essentially the way that you can think about it is that you have an array of nodes, so you have array of node objects. This node would kind of be a union between both of all of these things. It could be internal leaf node and free node.
00:28:58.394 - 00:29:10.254, Speaker A: And when you have an inner node, these two left and right values point to other nodes in this array. And this is how you search that object. Yeah, that's a great question.
00:29:10.714 - 00:29:11.494, Speaker B: Yeah.
00:29:16.194 - 00:30:05.060, Speaker A: Right. So there are a lot of considerations to be made here. And like the important factors are like thinking about what operations you want an order book to support with respect to how it can be modified. I think the two main ones, and really the only two ones are how do you create a new order? And this is divided into two pieces, new order you want to be able to place and you want to be able to trade. And the other is how do I cancel? Cancel. Specifically, how do I cancel if given an order id, because that seems like a fairly reasonable user interface to provide. A user might know what order id they have.
00:30:05.060 - 00:30:47.644, Speaker A: It's probably less intuitive to provide the user the exact node index where their order is inside this giant list of nodes. And so if you want to be able to support both these operations, place a trade in a cancel operation. It becomes kind of useful to do some sort of tree search to find this stuff, especially for cancel, because if you're trying to cancel and you have some order id, it's a log or order of login operation to search a binary tree. Otherwise it would be a linear scan if you didn't have any sort of sorted order. But yeah, that's a good question. Are there any other questions regarding this particular issue?
00:30:50.144 - 00:30:54.696, Speaker C: Yeah, so going back to the Q, there's say like there's two orders from.
00:30:54.720 - 00:31:02.124, Speaker A: The same accounts on two different markets, BTC, USD and EqSUSD.
00:31:03.744 - 00:31:06.176, Speaker C: If there's two orders that could potentially.
00:31:06.200 - 00:31:52.244, Speaker A: Get fulfilled, but they only, is there like any issue with like some kind of double spend because you have block tokens in one account. So in this case you would have like both a BTC and an ETH market. I believe that serum uses like, I don't know if they use the same, I think they use the same underlying collateral vault for everything. So like, I think they have a single vault for all BTC, all USD. But for every single market account there's its own set of open orders which keeps track of free unlocked token. So I think that solves the double spend problem because if you're sort of trading on the ETH market, you know exactly how much ETH is locked and free based on that ETH market parameter. And you know how much token is locked and free in the BTC market.
00:31:52.904 - 00:31:53.684, Speaker B: Yeah.
00:31:56.424 - 00:32:32.934, Speaker A: Other questions? Okay. Oh yeah, technically the tray or like cancel or. Ah, so I think there is a clever, I think there is a clever way to sort of go about this. If I remember correctly, I think they do something where the sequence number always has like the final bit of the sequence number is always correct. So they might actually do something like sequence number plus equals two.
00:32:36.474 - 00:32:37.254, Speaker B: Yeah.
00:32:37.594 - 00:33:15.514, Speaker A: If they do, plus equals two here, I think that actually mitigates that problem because then the final bit of the sequence number is always going to be the same. And so you can just use the order id to identify bit or offer. I think it does something clever like that. I don't remember the details, I'll have to look through the source code, but I'm pretty sure as a fact it does not pass in any side, but there should be enough information encoded inside that order id key to determine whether or not it's a bidder offer. Good question. Ok, if there's no more questions about this, feel free to ask me later. There's some details I glossed over, like how that binary search actually works.
00:33:15.514 - 00:33:46.562, Speaker A: It's rather complicated at a very high level. It uses this whole longest ancestor argument to just allow for the search. Comparing basically two price keys and checking how long the ancestor is is how the tree is indexed. But we can go over that in detail and it makes a lot more sense when looking through source code because it's quite hard to explain without going through the nitty gritty logic. If no more questions on this, I'll talk a bit about how the event queue process works.
00:33:46.738 - 00:33:47.694, Speaker B: Oh yeah.
00:33:51.434 - 00:34:19.744, Speaker A: So it's similar to a priority queue, but you also need to sort of have individual member access, right. In the traditional implementation of priority queue, there is no random access available. You can only access the topmost element. When you use a tree, you can search that more easily. So a tree structure makes a little bit more sense in. In this use case, obviously the data structure you use to define an order book is not necessarily set in stone. There are just certain trade offs that you might want to make.
00:34:19.744 - 00:35:16.036, Speaker A: Other questions? Ok, great. Let's talk about how the event queue works, because this is also quite complicated. Okay, so at a very high level, right, when you process trades in the order book, there are two things that you want to do. The first thing that you want to do is you want to add the fill, right? So there are really two cases. Case one case. One in the trade order is fully filled. This is like the case like if I had order of size ten, size is ten, and trade size ten.
00:35:16.036 - 00:35:55.524, Speaker A: Trade size also equals ten. That order gets fully filled. In that case, there are two events that get pushed the queue. So you have something like EQ push, like fill with some metadata. And also you'd have something that's called an out event, right? So the reason why you would need an out event as well as a fill event for this case is because the user who placed that initial order that got filled, that's the passive fill. Their order id is still stored somewhere, right. Every time you place an order, every time you make a trade, you need to copy that order id key and put it in some static object that you store.
00:35:55.524 - 00:36:38.904, Speaker A: When a trade gets filled, that particular party, their order id is still in their user account. So you need to remove that. So you need to push both a fill event and an out event. In the case that it's partially filled, you only need the fill partial. So these are the basically the only two operations that are really necessary to store in that event queue. There is additional logic to handle self trades. I'm not going to discuss that, that's quite complicated.
00:36:38.904 - 00:38:03.104, Speaker A: But in your standard case, non edge case, where you're trading against counterparties other than yourself, these are the two actions that can occur. You either completely cover their full trade size, or you cover their partial trade size. In the case that their trade size is fully covered, you need to also provide an out event so you can remove the open order from their list of stored state. The logic for how you actually process this event queue is also not super complicated, but requires a bit of thinking. So in general, the idea would be like, while this queue is not empty, if fill, right, or I guess you have some event, it'll be like match event. If it's a fill event, then what you do is you take, you would basically decrement the locked token from the maker's account and increment their free token of the opposite kind. So this would be like decrease locked token, quoted token, or maybe traded token, that's probably better.
00:38:03.104 - 00:39:16.684, Speaker A: And then increment, I guess, like the free, I guess, bad terminology, but opposite token, right? So you can imagine that these are different for both sides of the book, but it shouldn't be that confusing, right? It's just like when a trade occurs, like whatever coconut quoted disappears and whatever token got traded with you appears. That's the main idea of what you need to process. But this requires you need the open orders account. You need the open orders account of the passive fill. And for the odd event is really similar. So if it's an out event, what you essentially do is you remove the order id, the order id from the account, from the open orders account. And this is also for the passive fill, right? These are the main things that you would need to do off the bat with just really naive implementation here.
00:39:16.684 - 00:39:35.924, Speaker A: Can anyone think of a problem that might be a limitation for how this particular mechanism would work? It sounds really simple, right? Like if I were to write like a simple script, this is what I would do on Solana. You have to think about the limitations. Why might a system like this not be as effective as you might think?
00:39:43.984 - 00:39:44.724, Speaker B: Yeah.
00:39:48.724 - 00:40:13.704, Speaker A: Yes, that would be an example of edge case that you should think about, because that's something that can certainly happen. So yeah, let's think about that. Someone flows through a bunch of different levels, a bunch of different market makers get filled. What happens to this while loop? What are some things that can go wrong here? Also, let's think about what accounts you need to pass in to this instruction.
00:40:17.944 - 00:40:23.536, Speaker B: Yeah, yeah.
00:40:23.560 - 00:40:24.128, Speaker A: So you basically.
00:40:24.176 - 00:40:25.088, Speaker B: Yeah, right.
00:40:25.216 - 00:41:18.726, Speaker A: You need to pass in every account that got filled, right? So every single open orders account that you're interacting with will need to be passed into this, into this particular, into the consume events instruction, right. This is the, just to clarify, this is the asynchronous processing of the event queue after the trade has occurred. So trades have already happened. Now we have this event queue that's filled up and we want to process those events. So as we're asynchronously processing this event queue, we need to have access of every single account that this while loop will interact with. So how might you represent that? When I'm in this fill event, I need to have access to the actual piece of state that I'm modifying. What would you do to represent that information? Like, let's just say that I had a list of accounts, right? Say I have a list of like, say I have like a list that's passed in.
00:41:18.726 - 00:41:52.894, Speaker A: I have access to some list of like, these are all my open orders accounts, and this is just some like vector of account info inside this while loop. While I'm popping the queue, I basically need to look up every single open orbit account every single time I enter one of these blocks. That becomes kind of expensive. It's like a linear scan through that list every single time. Is there a way that you can avoid that? I probably don't want to linear scan this list every single time I pop in an event.
00:41:53.994 - 00:41:54.734, Speaker B: Yeah.
00:41:56.834 - 00:42:10.314, Speaker A: Sort of. I mean, you can pass it in as, sure you can pass it in as a tree, but what's another way that you can binary search an object? It's like a sorted list, right?
00:42:11.214 - 00:42:11.902, Speaker B: Yeah.
00:42:12.038 - 00:43:14.350, Speaker A: So the solution serum does to avoid like this unnecessary computation is that it passes in all the open orders accounts to this consume events as a sorted list. So prior to the match here, it will say like, it will search for I'm running out of space on this board, but prior to performing this match operation, it will do a binary search, search over all of the open orders accounts, and it will look for the requisite matching key. So to fetch key or fetch fetch account. Fetch like maker account. And this is one way, sort of. This is one thing it does a safe computation. The other thing it does is do you want this operation to fail or run out of compute in the case that you did not pass in a necessary open orders account, probably not.
00:43:14.350 - 00:43:46.324, Speaker A: Right. You want to be able to pop this queue sort of incrementally. So if this binary search fails to find a match, it will just terminate the instruction. And that's the other way in which it sort of represents this matching process in case of events. So that's really kind of the two main things that are most confusing about serum, but that should essentially cover the main data structure portion, both how orders are represented and how trades go through and then how they're processed. Are there any questions about this event queue portion or the order book portion?
00:43:48.184 - 00:44:05.056, Speaker C: Yeah, binary search versus, I mean, I don't know if you. I don't think you can do a hash maps on. Could you key by the open? Because it's the same. You're essentially binary searching for that public key of the banker account.
00:44:05.120 - 00:44:30.544, Speaker A: Right, right. I don't know if public keys are hashable. I imagine they are because they're just 32 byte strings. I also am not too sure about the limitations of using hash maps in the Solana runtime. It's potentially possible that doing such an operation is not particularly efficient. So I think the binary search makes it relatively easy without too much computational cost. That's a good question, though.
00:44:30.544 - 00:44:36.224, Speaker A: Are there any other questions related to this?
00:44:36.944 - 00:44:37.684, Speaker B: Yeah.
00:44:44.624 - 00:45:03.224, Speaker A: Right. So what happens in. So this case here? Right. That happens inside new order. Like when trades are created, these events are pushed to the queue, and then asynchronously, after that order has been already executed, this process will go on in the background. So there's a separate instruction that implements is popping.
00:45:03.724 - 00:45:06.344, Speaker C: So how does that happen in a smart contract?
00:45:06.924 - 00:45:56.814, Speaker A: Yeah, that's a great question. So there's no way to actually run a thread to do something like this on Solana. So what you'd have to do is sort of have an off chain process call into this instruction kind of on like an interval. This is something we call a crank. So the idea here is that this is like a crank, and a crank just at a very high level is like, this is like a script that you write that calls a particular instruction in a program over and over and over again. So the matching process, or how the matching happens with new order, everything is filled, and atomically the tree gets updated. But when you want to update the actual accounts that encode positions of what people can withdraw from the serum exchange, that all happens in this crank process loops through the event queue.
00:45:57.114 - 00:45:57.894, Speaker B: Yeah.
00:46:00.074 - 00:46:00.578, Speaker A: It'S like a.
00:46:00.586 - 00:46:01.134, Speaker B: What.
00:46:03.034 - 00:46:23.054, Speaker A: Kind of. It's a permissionless crank so anyone can run this crank. It's like this operation of pop in the queue. There's no authority that's required. Like, anyone who has access to the inputs can just call this instruction and it will process the events on the queue. Right. So I think in serum v one, this is not a thing that exists.
00:46:23.054 - 00:46:31.814, Speaker A: But I think in future iterations of serum, the idea is that the cranker will accrue some reward for doing this process. Good question.
00:46:36.394 - 00:46:37.174, Speaker B: Cool.
00:46:37.754 - 00:46:53.304, Speaker A: Are there any other questions related to any of the serum stuff? If you have more advanced questions and you're interested, I'm happy to walk through the source code. It's quite difficult to navigate alone for the first time, so if you have questions, I'm here to answer those.
00:46:55.564 - 00:46:56.060, Speaker B: Cool.
00:46:56.132 - 00:46:56.524, Speaker A: Thanks so much.
