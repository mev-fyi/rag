00:00:05.400 - 00:00:49.934, Speaker A: We're going to take a look at building a hello world program using Anchor. And if you guys haven't heard of anchor yet, you should definitely go check it out, check out this page anchor's docs, because Anchor is an absolutely massive framework to help with building Solana programs. Some people prefer it over a Solana programs crate. It's completely up to you, whatever you're comfortable with. But in this video today we're going to cover the ins and outs of kind of what anchor does for you when you're writing a program with it. So this is the code from another video where we wrote a hello world program using the Solana program crate, which is often called native instead of anchor. Now in this video, what we're going to do is we're going to actually convert that code into what it would look like if we used anchor to create the exact same program.
00:00:49.934 - 00:01:06.314, Speaker A: And we'll talk about what's going on. So this is it right here. This is our anchor version of that exact same code, except we don't have any of those accounts yet. Right. So no payer, no system program. We'll add those in in a sec. First, let's talk about some of the key differences that we see here.
00:01:06.314 - 00:01:44.750, Speaker A: So mainly that entry point that we previously had to define with that macro is now wrapped in this mod and super setup up here. And now arguably most importantly, is what happened to those parameters that we originally had to work with. Right, so program id, we're instead using declare id. That's not a huge deal. But what happened to the list of accounts that we previously required, or the instruction data that we had to parse out so that we know what this thing supposed to do? Well, the list of accounts is still here, and that's actually what this context struct is for right here. So we're going to fill this out in a second. But this is where our accounts are instead going to go.
00:01:44.750 - 00:02:35.281, Speaker A: And then our instruction data, instead of passing in data that we then have to parse and serialize and determine what we're supposed to do, you instead dictate what you want this actual call to the program to do from the client side using what's called an IDL. And it's basically just a representation of all of these functions that you could possibly have in a program. We will see that very soon. In the meantime, let's go ahead and add our accounts to the struct here and let's talk about what's going on here. Alright, so as you can see, we just tossed in our payer and our system program from the previous example. And now what this struct is going to actually do is obviously the first difference is it's no longer a list, right? It's a struct. You can reference the fields by name so you don't have to iterate already, kind of a plus.
00:02:35.281 - 00:03:39.674, Speaker A: And then these decorators here, or annotations that you see are actually responsible for a number of different things that anchor will do for you behind the scenes. So the first one here derive accounts. This is going to turn all of these public keys into their associated accounts with whatever kind of data that they're supposed to have, right? So this one's going to be the system program, it's going to be a program with data type of system. This one's going to be a signer. And then this particular annotation here will actually check to make sure that this account here is allowed to be borrowed as mutable, right? So in this case, if our payer is signing this transaction and we're passing in the payers public key, we're saying that this thing is the signer, right? Like this account is the signer. So in the previous example where we saw it on our client side, when we hit this program with the transaction, we declared that the payer was not only the signer, but also mutable. With anchor, you do that on your program side.
00:03:39.674 - 00:04:34.108, Speaker A: And then this, of course right here is how you actually reference those accounts. You can see we're borrowing payer as mutable, and here we can actually convert those rate to account info, which is the same account info struct that we saw on the native implementation. But anyway, let's go ahead and build this thing with SOLPG and let's see what the client side looks like when you use anchor. So once this thing has built and deployed successfully, we can actually go ahead and go to this IDL tab and we can click export and you can see it'll download this JSON file and we can drop it in our test right here. And when we do that, we see that this is actually a JSON representation of our program, right? So like here's the name and version and then the list of instructions that are possible for this program to do. We only wrote one, it was our hello function. But as you can see, there's both of the accounts that we require for this instruction.
00:04:34.108 - 00:04:57.696, Speaker A: And there it is, is mute is signer, right, just like we saw in native. But anchor has generated this stuff for us. So how do we use this in our test. Well, the first thing we have to do is actually add this anchor ToMl file. And as you can see, there's just a number of different configs for our anchor setup. We want to make sure we're pointing to Devnet. We got our local key pair right here, and then we want to add our programs id.
00:04:57.696 - 00:05:43.686, Speaker A: So flipping back to program credentials, we just copy that, save it, and then we can open up our test where we're also going to add our program id right here. And as you can see now, to set up an anchor test, we actually have this provider object here, which is just going to basically take all of those configs from anchor Toml and set them up in this test suite. This is the Idl that we're using from the JSOn file. And as you can see, we use that to build this program object. And now this object right here will actually allow us to interact with our on chain program as if it was just a regular typescript object. And this is what I mean down here you can see that if we do program dot methods dot hello. This is the name of our function that we wrote.
00:05:43.686 - 00:06:08.130, Speaker A: So here's the required accounts that we pass in. We're going to sign it with our payer, which is just going to be the local config like local wallet. And then we're going to send this transaction by just doing RPC. And that's all it takes. And now we can hit that function on our on chain program pass in these two accounts and get a response. Hello, Solana. And there you go, guys.
00:06:08.130 - 00:06:24.704, Speaker A: That's anchor at a very beginner level overview. We will see a lot more of it in the future, but those are some of the basic reasons why you may want to use it or may not. But either way, it's a powerful tool. They did a great job at Coral, and I encourage you guys to at least take a look at it and see what you think later.
