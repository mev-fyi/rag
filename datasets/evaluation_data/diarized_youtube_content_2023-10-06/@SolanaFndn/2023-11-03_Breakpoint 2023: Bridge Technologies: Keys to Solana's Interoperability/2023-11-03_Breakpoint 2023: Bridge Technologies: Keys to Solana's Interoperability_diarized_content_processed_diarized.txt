00:00:03.640 - 00:00:35.776, Speaker A: Welcome to the last day of Breakpoint. Less windy, less of a hurricane happening today, so I hope you're all staying dry today. We're talking about interoperability protocols. So blockchains, at the start were built for decentralized, permissionless, peer to peer transfer of value from participant to participant. Some people like to think of blockchains as cities where they have their own governance, their own rule sets, their own hospitals. People kind of work in their own constraints of their cities. But historically, you hadn't really thought about going from blockchain to blockchain.
00:00:35.776 - 00:00:59.520, Speaker A: We only really had bitcoin to start, and now we have a lot of different l one s and roll ups being built around. Interoperability protocols are the transportation between these chains, between these cities, helping us move value from place to place, whether you're packing it all up and moving from Ethereum to the land of Solana, or you're just staying for a two day trip. Right, they're helping you do that. So I'd like to introduce the panelists. You want to go first?
00:00:59.712 - 00:01:09.684, Speaker B: Hey, everyone, I'm Praneet. I'm co founder and CEO of Moongate. At Moongate, what we do is we make it very easy for Solana Dapps to onboard Ethereum customers onto their platform.
00:01:10.504 - 00:01:24.764, Speaker C: Hey, everyone, I'm Akash. I'm one of the co founders of Wormhole Labs, and I lead product at the organization. At Wormhole, we're a cross chain interoperability and messaging protocol, supporting over 20 chains for any sort of generic, arbitrary, message passing use cases.
00:01:25.504 - 00:01:52.316, Speaker D: Hey, guys, my name is Alex. I'm CEO and co founder at Deep Breach. My team is building high performance interoperability infrastructure. So we are basically enabling all three pillars of cross chain interoperability, like message transfers, asset custody, and the cross chain trading. And, yeah, we are live on Solana as well, and basically interconnecting EVM and SVM chains with Solana being the first SVM one.
00:01:52.420 - 00:01:52.740, Speaker A: Awesome.
00:01:52.772 - 00:01:52.956, Speaker D: Yeah.
00:01:52.980 - 00:02:00.356, Speaker A: Nice to have you guys. So I'll say first, right? Praneet works at a company that built on top of bridges, and the rest of you guys are building bridges.
00:02:00.500 - 00:02:00.836, Speaker D: I think.
00:02:00.860 - 00:02:14.304, Speaker A: First I'd like to start off, how do you actually interact with bridges? How does your bridge work? How are you building on top of these bridges? And then what the user experience is after? But first, I'd like to hear, how does your product work? And then how is it built on top of bridges?
00:02:14.424 - 00:02:50.670, Speaker B: Right? So how we go about building our product is the core thesis behind the product is like, how do we create that experience where the user never has to leave that app. Right. So having said that, we have to make sure that we are able to embed all the experience, every web, three aspect of the experience inside that. So that's where we leverage some of the existing bridges. So right now we are live with dbridge, and with that, it enables us to bridge very instantly for any customers who's coming from EVM to instantly bridge to Solana. So with that, the experience becomes pretty seamless.
00:02:50.862 - 00:02:52.798, Speaker A: Yeah, makes a lot of sense, Akash.
00:02:52.926 - 00:03:43.914, Speaker C: Yeah. So wormhole is commonly understood and referred to as the bridge between Solana and Ethereum. One, we support multiple chains, and two, we're more generally a broader message passing protocol. So while you can build a bridge on top of it, you can actually do any sort of arbitrary functions or series of functions between different networks. And that's what we're really excited about is even though bridging is the number one use case today for generic message passing, generic message passing enables a lot of different types of applications to be built. So deFi applications that want to have cross chain liquidity, aggregate liquidity on a single chain for efficiency, but be able to support users on multiple chains, consumer applications, anything like this requires and utilizes cross chain messaging in order to be able to share state call functions on different chains, be able to interact between contracts on different chains, and makes different blockchains feel like a single combined OS or VM.
00:03:45.014 - 00:04:42.890, Speaker D: Yeah, and I would like to first highlight that the word bridge itself is super confusing sometimes because like so many different things are called bridge, but mainly in DBridge. We are like highlighting three main verticals of the crosschain interoperability, like first one and probably the foundational one, and the messenger or the transfer of authenticated data when smart contract on chain a needs to communicate or send the packet to smart contract on chain b. And authentication means that the receiving address should be able to validate and know who is the sender. The second vertical, that is also called breach, is like asset custody when we need to issue derivative on the asset from another chain. And USDC from circle is also the asset custody because USDC is derivative from the American dollar and CCTP. The transfer protocol of the circle is the sort of canonical custody for the USDC. And the third vertical, which is super important, the cross chain trading.
00:04:42.890 - 00:05:54.098, Speaker D: So when you assume that assets are already deployed in the chains and you want to let users or protocols to make a simple operation exchange certain amount of asset on chain a for certain amount of assets on chain b, so it's not like bridging, right? It's trading. And in deep breach, we have this zero TVL infrastructure called DLN that enables seamless trading for anyone with zero slippage. And because the classical problems of all the bridges is the use of liquidity pools, when users put assets on one chain and the transfer is settled from the liquidity pool on another, but the pool is always going to be the bottleneck because the amount of transfer is limited by the amount of liquidity bridges. Got to distribute a ton of incentives and the utilization of the liquidity is super low. So we are changing this approach or paradigm from the first principles, trying to implement this intent based model where user creates intent and professional market maker fulfills that intent on the destination. So, yeah, this is in a natural how it works in case of the cross chain trading for the solution that we are building for the ecosystem.
00:05:54.146 - 00:06:12.510, Speaker A: Yeah, awesome. And now I want to dive a bit deeper into the actual implementation and choices. So when you're building products on top of bridges or building products on top of interoperability protocols, what's important to you when it comes to building SDKs or using these other SDKs that these other protocols offer for you to actually do your job?
00:06:12.682 - 00:06:22.830, Speaker B: Yeah. So the cool thing that comes into the place is how do you make sure that there's like good level of security, but you having that good degree of security without compromising the UX.
00:06:22.902 - 00:06:23.566, Speaker A: Right.
00:06:23.750 - 00:07:01.946, Speaker B: Because for the end customers, the cool thing that they care about is how seamless their entire experience can be. Now, if there's any aspect of it where the users are asked to do multiple steps, or where they're like asked to wait to complete from step a to step b? That's too much asking for the user. The core aspect is how do we create those kind of products where the user doesn't even feel like there's much happening? So with that, the core aspect is to create that embedded experience, but also to make sure that the product, every function is pretty fast and pretty seamless for the customer.
00:07:02.010 - 00:07:35.132, Speaker A: Yeah, that makes a lot of sense. And then for you guys, there are lots of different ways to do arbitrary message passing. There are a lot of different ways to integrate with these other chains, from SVM to EVM to Cosmos. And in some cases, people look to do ZksPV or ZK transfers, trustless bridging. There's guardian based networks that actually do that verification. There are just off chain market makers that do this stuff. How do you think about your bridge or your protocol specifically, and how it, how it's differentiated from the others works that people are working on.
00:07:35.308 - 00:08:07.256, Speaker C: Yeah, I think that's a great question. So I think so. There's a number of things that make bridging difficult and therefore differentiated between one another. One of the biggest ones is the trust assumptions and security assumptions that you make in your bridging protocol. So ZK is very popular for many different reasons, but within bridging specifically, we can take advantage of succinctness properties in order to not require a centralized validation mechanism. And so everyone has different words for this. The various protocols have different words to describe the body that decides message a happened on chain one and can be validated and proved on chain two.
00:08:07.256 - 00:09:23.792, Speaker C: Now, the way wormhole works is we have 19 independent, what we call guardians that do this, and they are independent operators. They are all their own standalone for profit companies doing different things largely in the validation and staking space. So they all have their own incentive to be truthful. And we require a super majority of them to validate a message before we pass it to another chain and say yes, this is true, but at the same time requiring 19 guardians, whether it's 919 99, still has some semblance of one, the inefficiency of requiring actors to actually validate a message, and two, the less likely as you grow with size but still plausible chance of collusion. And so what a ZK based verification mechanism or ZK based bridge lets us do is reduce the reliance on individual operators to validate a message. And so we're working very, very expediently to launch ZK lite clients in order to offer a ZK based verified version of the wormhole message passing protocol, not as a standalone product, but as a product in conjunction with the existing Guardian based protocol. And that gives us an opportunity to increase the security measures and reduce the assumptions that we have to make between messages that are passed between two different networks.
00:09:23.792 - 00:10:08.492, Speaker C: We're excited about this because again, it reduces a lot of the trust assumptions that are required for bridging and increases the security of the actual protocol itself. And it makes it easier for applications building on top of us to take advantage of user focused efficiency primitives, things like the actual latency, the cost, the speed to a transaction. All these things get better with ZK forms of message passing. And so we're excited about that. But in terms of differentiation, for developers specifically, we abstract most of this. The goal is to be the best from a security and technological perspective, but also be the best from a developer platform perspective. Because fundamentally, what we're building is a developer platform, we're only as valuable as the applications built on top of us as a cross chain message passing protocol.
00:10:08.492 - 00:10:40.480, Speaker C: And so if we abstract the complexity of the underlying verification mechanism, the actual usage based protocol should be the same, right? Whether or not you want to be able to as cheaply or as quickly be able to share and restate between networks shouldn't change depending on how you verify those messages. And so that's why we focus almost half of our time exclusively on our developer experience around the SDKs that we launch, the protocols that we launch, and the integratable contracts that make things like transfers between chains or trading between chains, as well as generic message passing as simple and as easy as possible.
00:10:40.632 - 00:10:44.024, Speaker A: Yeah, makes sense. We'll come back to abstraction at some point. But Alex, you want to go?
00:10:44.144 - 00:11:28.318, Speaker D: Yeah. Talking about data transfers, I think that it's really important to differentiate two types of data transfers between chains. The first one is the transfer of authenticated message, right? That assumes that again, the receiver should know who is the sender. And in case of authentication, message needs to pass through the validation layer. And that's an inevitable component of any interoperability protocols. But like in 90% of the cases, users do not need to transfer message, they just need to transfer call data or instruction. Where let's say I want to trade 100 USDC into Solana and I want to supply that USDC into Kamino, or I want to acquire NFT from Magic Eden, and I'm not doing the message transfer, I'm just creating an intent.
00:11:28.318 - 00:12:51.334, Speaker D: And the way it works with DLN, with our zero tv infrastructure, that user or anyone just signs the intent, and professional market makers are fulfilling the intent on the destination chain. So let's say I can say I'm giving 100 USDC on Ethereum to anyone who gives me 99 USDC on Solana, and the pro market maker that is first to fulfill that intent will trigger a cross chain message that is sent back and unlock these 100 USDC. So actually, with this design, all the complexities, all the security risks of the cross chain message messaging infrastructure are transferred away from user to professional market maker. And another big advantage, that intent can be fulfilled very quickly. Like in case of DLN, any trade is getting fulfilled in seconds because also professional market makers are taking over the risk of transaction finality on the source chain. And that allows to open up the whole new spectrum of high performance cross chain interactions where users can just forget about any infrastructure layer. Users don't need to think about switching wallets, switching networks, users don't even need to know about Solana or about the bridge, because the app developers will be those who are picking the infrastructure layer for their app in terms of what suits them the best, in terms of security, scalability and stuff like that.
00:12:51.334 - 00:13:40.034, Speaker D: But the user picks the application and the user should just enjoy the user experience. Maybe collect the wallet once from any chain where he has liquidity and click one button that will perform the interaction. And that one button can be open perp on Zita, the user have USDC on Polygon as an example. But under the hood, what will happen, there will be intent created, like to trade from Polygon to Solana and supply that liquidity to Zita in the same transaction. And user will not even know about that. That's sort of same UX as we have now in a web two world where we don't need to think about what server is used there, like how traffic is routed. Because the UX is probably right now the biggest bottleneck for web3 world users are struggling.
00:13:40.034 - 00:13:58.236, Speaker D: Gas price, gas limits and all this stuff. And I feel that we are really coming very close to the stage where users will be very. It will be super easy for them to communicate and to interact with any defi applications. And that's what we are trying to facilitate in debris as well.
00:13:58.300 - 00:14:19.652, Speaker A: Yeah, you said a very interesting word there that some folks in the audience might really understand. Finality. When you integrate with all these different chains, they all have different rule sets, and finality is a huge one, right? At least on the Solana side. A confirmed block is 66% or 67% of stake that's voted on that transaction. A finalized block is 31 blocks. I built on top of that. But for ethereum, it's like twelve minutes or something.
00:14:19.652 - 00:14:34.726, Speaker A: How do you actually go about integrating these different chains with all these different rule sets and abstracting that away from the user experience? And if a user has to wait twelve minutes, 15 minutes for that transaction to unlock, or if you have off chain market making, how does that actually work? Akash, you want to take that first?
00:14:34.870 - 00:15:12.132, Speaker C: Yeah, so that's a great question. And that's actually one of the harder parts about bridging between different networks that have different assumptions around finality. So one, because we are fundamentally a developer platform, it should be up to an application what level of risk or what level of assumptions they want to take. So if you wanted to build on the core generic messaging platform that wormhole constitutes, you can make these choices yourself. If you want to make an optimistic assumption that something will end up becoming finalized. You can do that if you want to wait for finality and you want to use what we consider to be more vertically built applications, on top of the generic message passing protocol, we will make security assumptions on your behalf. We will make finality assumptions based on the network's properties.
00:15:12.132 - 00:16:29.016, Speaker C: So in the case of Ethereum, you wait twelve minutes to go out of Ethereum, but you don't have to wait twelve minutes to go into Ethereum if you're coming from a place like Solana, for example, and in the case of Polygon, some of our more high security applications will wait until the reorg risk is zero, which means you're waiting a much longer period of time. And so again, you have this flexibility and variability as a developer on the platform to decide what assumptions you want to make. And depending on the type of application you're building, if you're building a trading application where latency is very important, or more importantly like a reorg or a rollback, is very, very detrimental to your actual product, you want to make, or take stronger security assumptions, or build an insurance fund or charge for making those optimistic assumptions. Whereas if you're building a game for, for example, making optimistic assumptions is not as high risk or as unlikely as something that will disrupt the user experience to the extent where you want to avoid them. And so our biggest thing is, while abstracting the differences and complexities between networks, one of the biggest ones being finality, we want to make sure the user gets to make that choice. And if the user doesn't want to make that choice, we can make the choice on their behalf, based on the complexity and security risk of their applications. And that's where we think a huge importance in actually building a dev platform comes in, is giving as much control to developers building on the platform as possible.
00:16:29.160 - 00:16:44.032, Speaker A: That makes a lot of sense. So, prunit, you're building on top of these protocols, right? Like how on the user experience side or the user side, are you actually displaying this information? How are you sort of abstracting away these different finality or assumptions that these different chains have and giving an optimal user experience to your users?
00:16:44.168 - 00:17:31.679, Speaker B: Right. Putting this experience inside the user is like we show it as a wallet. So right now, if you have to bridge any assets from, say, one blockchain to another, so you have to leave the dapp in order to do that function and connect your wallet, then copy and paste your address again to that bridge in order to complete that function. How Moongate works is as soon as you click on that connect wallet button on any of the dapper, we give you that option of connecting your EVM wallet. You connect your EVM wallet and then with that we create a Solana native wallet. What that does is like, in this instance, both your wallets are automatically connected with each other. So all you need to do is just type in the amount that you want to bridge and just with one button, and you sign the message and the bridge happens.
00:17:31.679 - 00:17:48.858, Speaker B: So in that way, for the user, it becomes very convenient and very easy to perform that function without having to leave that, having to leave that app open a new tab, or even if you're using on a mobile, the entire experience becomes very straightforward for the customer.
00:17:48.946 - 00:18:09.380, Speaker A: Yeah, that makes a lot of sense. But in some cases, right, there's the user experience and then there's sort of the community or the education for people to actually understand what a bridge is and how you actually interact with it. How do you think about education? How do you actually show this information upfront to them? So they know that if funds are locked for or x amount of minutes, or if you're using a different backend, how do you actually go about that?
00:18:09.532 - 00:19:03.772, Speaker B: So in this case, the UX, the messaging needs to be very clear. So I think there's two aspects of it, like this pre existing web3 users who are coming to use the platform for them, the education, they don't need that much compared to someone who's coming from web two platform. In their instance, yes. You need to make sure that all the pieces of information is they know what steps is happening to like, happening at that stage and what they're expecting next. Versus in web3, we are pretty much used to the kind of ux which is out there, where every time you enter the amount, you click on that bridge button, you have to sign that transaction and immediately that happens. Now it becomes a challenge when a user is expected to wait for a longer period of time, because then it just becomes like an ideal experience for the user to just look at the screen and hope that bridge to happen.
00:19:03.908 - 00:19:29.584, Speaker A: Yeah, it makes a lot of sense. And for you guys, I'd like to move to kind of an adjacent point is when you're building these multi chain, sort of arbitrary message passing protocols, how do you actually decide what new chains you should be adding? Like what sort of assumptions or what technical research you have to do to do the implementation. And then also see how many users they have, how much TVL this chain might have, and how much adoption that we actually think developers might need to actually build on top of these chains. You want to check it first?
00:19:29.704 - 00:19:30.404, Speaker D: Yeah.
00:19:30.984 - 00:20:58.120, Speaker C: So generally this is a great question, because there's a lot of things that motivate expansion to a new chain, and oftentimes you're making a trade off between how difficult is it actually versus how much value do you get? And sometimes it's incredibly difficult. The relevance that it's exponentially more difficult, but it's the most valuable chain that we don't support yet, so we should try and support it anyways. And so oftentimes what we're trying to do is make this decision objectively based on what the community wants to be able to build on, right? So if we're seeing a lot of developers that exist on a single chain wanting to go to from multiple different chains, wanting to go to this one new network, we will be heavily incentivized and motivated to expand to that network, even if it is a different vm. So that's why we support four different major vms within wormhole and a lot of other small, a lot more chains than that, because we know that the value of your interoperability protocol is largely tied to the number of chains you can actually interoperate between. And so we oftentimes will try to make a decision objectively based on where we see user demand, where we're seeing assets being transferred to, or assets being loaded to the networks, where we're seeing good application developers either migrating to or starting on the platform. All these things are different signals that play into whether or not we want to go through the effort, risk and build out of an entirely new network. And every time we add a new network, it's immediately in terms of the networks that you can bridge to it from and n squared in terms of supportability.
00:20:58.120 - 00:21:40.946, Speaker C: So every existing wormhole network will support the new network and vice versa. The new network will be able to support all existing wormhole networks. And so that's one of the values of how we built out wormhole's original architecture. But it doesn't mean that adding a new chain is easy, because like I mentioned, one of the critical pieces, and like we've just been discussing on stage here of an interoperability protocol, is the validation mechanism. And so our validation mechanism, aka our guardians, run nodes for every single network that we support. So supporting a network is not just launching contracts on that network, it's having our guardian spin up nodes, and in our case it's having 20 plus Guardian spin up nodes for every single one of the chains that we support. And so all of this infrastructure is necessary in order to be able to successfully and efficiently securely support every network that we expand to.
00:21:40.946 - 00:21:59.014, Speaker C: And so looking towards user demand, looking to where developers want to expand to where developers are already building on, and we know liquidity is going to be attracted to it, or liquidity from there is going to be want to be utilized across different networks. Those are the kinds of signals that we look for when we decide whether or not it's worth to make technological investment and expanding to a new network.
00:21:59.874 - 00:23:12.488, Speaker D: Yeah, I think in terms of supporting a new network or adding a bridge to the newly created network or roll up, there is a huge gap on the market. If you're launching the chain, you go to the major infrastructure providers and you're saying, look guys, could you integrate our chain? And the infrastructure providers will tell you, give us few million dollars grand, or provide $10 million of liquidity to the liquidity pool of the bridge in order to make that happen. And that will never happen because you're a newly created project, like a startup or small venture, you cannot just afford that. And in deep breach, we actually just solved this huge gap like this week during the breakpoint. On Wednesday, we announced the solution called Eastern Service that allows any new EVM or SVM chain to plug into deep breach infrastructure based on subscription model. So you just initialize subscriptions for the smart contract and anyone can do that, actually even like any of the community members of that chains. And you specify RPC that the validator should use and you make a payment like $10,000 per month on a quarterly basis.
00:23:12.488 - 00:24:18.748, Speaker D: And dbridge validation layer automatically picks up your chain. And the professional market makers of DLN network automatically starts to receive the quotes for any trades coming to and from this blockchain ecosystem. And that's quite unique because on this subscription based model with EAS, you can solve all three pillars of the cross chain interoperability. And that works for all EVM chains and SVM chains and users or chains do not need to provide any liquidity because we are based on zero TVL model. The liquidity is basically halt on the balance sheet market makers. And we just signed up a big partnership with Ford, DeFi, MPC infrastructure and Rockaway fund, who will actually market, make and fulfill even bigger trades, bringing institutional grade liquidity to the cross chain space. So I feel like the entire puzzle for the interoperability is coming together and it will be very easy to create a roll up or deploy new chain, even as vm one, and enable interoperability from the day one, because before it was super challenging.
00:24:18.748 - 00:25:41.134, Speaker D: And you can see that all the newly created chains are really struggling by integrating bridges, securing all those b two b partnerships. But now we are getting to the point when we have a truly scalable infrastructure that is easy to roll out. And even with rollups or new SVM such as Eclipse, I think in the near future users or big companies will be able to just press one button, specify the parameters of decentralization, number of validators or parameters of the ecosystem in general, and in one button also add a breach or interoperability solution to their ecosystem. The cool fact is that this works not only for decentralized or permissionless ecosystem, but also for permission. So if GP Morgan is launching their own chain, they can initialize this EA subscription, provide their own RPC, and enable institutional level trading between GP Morgan chain and the entire Solana and EVM ecosystem. And that's quite exciting, because that will help to bring huge institutional capital on chain and make even traditional markets to be more efficient. And hopefully Solana will be powering all these activities at the chain with the best finality to decentralization rating.
00:25:41.254 - 00:26:07.810, Speaker A: Yeah, that makes a lot of sense. I'm curious, how do you think of differentiation not amongst yourselves, but amongst the interoperability protocols like IPC, where Cosmos app chains all integrate over that and already have some of these baked interest assumptions already there. So it's actually much easier to add new chains rapidly rather than having to accumulate technical implementation for SVM works this way, the EVM works this way, Polkadot works this way. How do you think of the differences between you and Cosmos? Akash, you want to take that?
00:26:07.962 - 00:27:03.414, Speaker C: Yeah, so that's actually a great example. I was going to bring this up as well. So the idea of reverse integration, which I would call kind of a blanket phrase to encapsulate a lot of what we're talking about right now, is really exciting because it means that instead of being bottlenecked on what interoperability protocols like ourselves can expand to, anybody who has the resources and investment and wherewithals who want a bridge to be able to support their network can do the work themselves or pay the fees themselves with a combination of the two. And so existing kind of interoperability protocols that come baked into ecosystems like IBC are useful to the extent that they can replicate the functionalities that a network would actually require. So if a network wants the easiest way to bring in liquidity, there's a couple things that matter. One, moving liquidity should be easy, which is usually the big thing people think about when they say bridging or cross chain messaging. And two, the places that which have liquidity today should be the things that you can bring liquidity in from.
00:27:03.414 - 00:28:00.736, Speaker C: And so while IBC is exciting for intracosmos transactions, it doesn't do a good job of combining cosmos ecosystems with the rest of EVM, SVM, and the move ecosystems, for example, that exist as well. And so what we try and do is where there is a stronghold in kind of a local maximum like IBC, we also built out reverse integration mechanisms for other cosmos chains to be able to reverse integrate against wormhole's IBC solution, which is called gateway. It takes advantage of the existing infrastructure, so we don't try and rebuild the wheel where the wheel exists. But we do acknowledge that in situations like this, they are very much local maximums. And so combining these ecosystem specific interoperability protocols into a broader interoperability protocol that allows you to support networks regardless of the vms that they're built on is where we kind of see the opportunity, not just for us, but it's what the developers themselves actually want. And so we take advantage of what exists, but build on top of it to make sure that it interoperates across vms as well.
00:28:00.840 - 00:28:10.364, Speaker A: Yeah, it makes a lot of sense. We have 55 seconds here. I always like to end my panels with a hot take. So is there a hot take that you might have, that you might think these others not?
00:28:11.184 - 00:28:39.614, Speaker B: Yeah. How we think about is like, the entire web3 would like, you know, the goal is to make the entire web3 as the invisible layer. So whenever the user is using any product. Right. The intent is to use the product not to care that much about, like, which chain or, you know, which token to use. So in the future, as we go about building the products, it would be more about, like, how do you make sure that the user doesn't even feel that they're using, like, a Solana chain or, like, you know, anything as such?
00:28:40.874 - 00:29:19.372, Speaker C: Yeah. I think on this panel, though, I think this might be a common take, but I think generally this is a less common take. Asset bridging has been and likely continues to be the number one use case people think about when they think about bridging, period. But like Alex mentioned, bridging can mean multiple things. I think in the last few months and moving forward, we'll see an acceleration of bridging use cases or specifically generic message passing use cases. Outside of just asset transfers, they're still asset related. There's a lot of DeFi applications looking to share state between liquidity, between value using messaging to be able to in order to peg asset prices between different networks when they're meant to be tracking one another, things like that.
00:29:19.372 - 00:29:33.870, Speaker C: We're going to see a lot more usage of across interoperability protocols, and it's not going to just come down to liquidity based trading between networks. While that still remains a super valuable use case, I think we're going to see tangential use cases driving forward innovation and message passing.
00:29:34.022 - 00:29:35.302, Speaker A: We're out of time, but I want to hear yours.
00:29:35.358 - 00:29:52.510, Speaker D: Yeah, my hot take is quick. Bridges can be secure, bridges can be based on zero TVL design and avoid any honeypots. And users can forget about bridges at all and just enjoy interaction with the app itself and leverage the full potential of defi space.
00:29:52.582 - 00:29:56.254, Speaker A: Awesome. Really insightful, guys. It was great talking to you. Let's have a clap for the finalists.
