00:00:02.040 - 00:00:39.260, Speaker A: All right, thank you very much all for coming out here for the first talk of the morning. My name is Will. I'm software engineer at Orca, and I'm going to be talking about navigating common pitfalls in Solana programs. I'm going to get right started because my presentation is quite packed. So the way that I want to go through this slide is what I like to call the ten Commandments of secure Solana program development. There's a little bit of a side note here, some of the things that I'm going to be talking about. There's some tools out there that do a lot of things for you, one of them being anchor.
00:00:39.260 - 00:01:44.764, Speaker A: But I think it's still very important to know what the types of checks that anchor is doing and also know why we're doing them. So even though anchor handles them for you, it's still very important to know what exactly the things are that anchor is doing for you. So let's get started just with the first one. I think it speaks for itself. Always make sure that you verify the signer of a transaction. There's a couple of scenarios where you might forego a signer check where you might think, not necessarily necessary to do the signer check, but I would always like to rebut that with the question, does it hurt to do a signer check? Why shouldn't you? There's basically not that much downside of doing a signer check other than maybe a little bit of your compute budget. So the first scenario where you could forego a signer check is, for example, in a permissionless instruction where basically anyone would be able to call that instruction.
00:01:44.764 - 00:02:21.474, Speaker A: There's still always a signer of that transaction. So there's no reason not to do the signer check. And another thing that I've seen happen is when you defer the signer check to another program. So, for example, if I have an instruction that does a call to the SPL token program to transfer some tokens, I might forego the signer check, just because I know that the SPL token program will do the signer check on the authority. Same for both of these cases. It doesn't hurt to do the signer check. So I always like to include it.
00:02:21.474 - 00:03:47.504, Speaker A: Moving on to number two, every time you read from a program account, make sure to check your owner. And I think this is one of the most important ones, because basically, if you do not check who the owner is of a program account, that means that the data in that program account, you cannot trust it, because as we know in Solana, when developing smart programs, smart contracts, only the program that owns a program account can write data to that program account. So basically, by doing an ownership check, you're basically checking if this is data that can be trusted or not. This is both valid for your own program, accounts for your own program, but also when you're reading data from other programs. So if I'm reading data from an SPL token mint, I would still very much like to do that ownership check, because if I don't, an attacker potentially could input their own accounts with their own arbitrary data, and some very bad things can happen in that case. All right, number three, it's a little bit in the same line as the previous one, but every time your program interacts with a secondary program, make sure that you actually verify that it is the program that you want to be interacting with. So, let's take the example of an SPL token transfer.
00:03:47.504 - 00:04:46.044, Speaker A: Again, if my instruction is doing an SPL token program transfer, I want to make sure that I'm actually talking to the SPL token program and not some other program that got inserted by an attacker or an adversary. I think this one speaks for itself. So let's move on to number four. This is one that most people, I think, don't know that it's actually happening. People that use anchor a lot, but number four is always use identifiers for your program accounts. So what happens when you start developing a Solana program that's a little bit more complex? You have different types of data accounts, and each of these data accounts hold different data. You want to make sure that you know when you're reading a specific data account, that it's actually the type of data account that you're supposed to be reading.
00:04:46.044 - 00:05:42.844, Speaker A: Because if you have two or three different data accounts that your program uses, they would all pass the ownership check because they're all written by your program. But if you do not have identifiers for, for these program accounts, an adversary or an attacker might still be able to input another one of the accounts or account types that you have. So if we look at SPL token program, it has two program account types. You have the token mint, and you have the token account. And an identifier could be as simple as just the first eight bytes of that account. And for example, for the SPL token program, you could put the first eight bytes to one for the token mint and zero for the token account. And this way you can check that if someone is supplying you a token account, that it is actually a token account and not a token mint.
00:05:42.844 - 00:07:02.254, Speaker A: The next couple points, they are all related to math, and specifically to integer math, because as we know with Solana program, most of the math that we're doing are not actually floating points, but they're integer based. And there's a couple of interesting things that can happen when doing integer math. And I think the first one that is very important to watch out for is overflows and underflows, because basically, if you have, for example, an unsigned eight bit integer, the maximum number that you can get is 255. And if you add one to that, it wraps around to zero, which is pretty much never what we want to happen. So for this, we can use checkmath and check math basically does a quick check is, hey, is this going to overflow or not? Or underflow? And if so, it'll throw an error. When you're first starting out with development in rust, you might think that the basic integer operation that they're already doing these overflow checks for you, because when you're building your program in debug mode, it will actually fail with normal math. But that's a little bit tricky, because once you start building it for release the normal math operations, they will very silently and very happily underflow and overflow.
00:07:02.254 - 00:08:11.494, Speaker A: So checkmath pretty much always is the rule. And there's, of course, exceptions, but every time you're working with a user supplied account or amount, make sure that you use them checked math. In that case, the next one is also related to integer math, and that's related to the order of operations. Because with integer math, especially when we're doing operations like division and square roots and things like that, we have a loss of precision. So, for example, if I have seven and I divide it by two using integer math, I get three instead of two. So you always want to make sure that you do the operations that increase the order of magnitude first and then the operations that decrease the order of magnitude after. So that would be multiply empowers first and division and square roots later, because this way you'll preserve most of the precision that is there, and you'll only do that loss of precision all the way at the end of your operations.
00:08:11.494 - 00:09:08.350, Speaker A: I think number seven. This is by far my favorite, because I think it is something very specific to Solana, and it's related to rounding. So basically, if you do not use a consistent rounding policy, there might be a discrepancy between rounding one way or rounding up and rounding down in one instance or another instance. And there could be a difference of one, pretty much. So if you do not use a consistent rounding policy. So for example, if someone deposits something in your program, you use a specific rounding policy, and then when someone withdraws it again, you have a different rounding policy, and there might be a difference of one so that potentially they could gain one token. If you think about that, at first it might not seem that big of a deal because most of the tokens we have, for example, USDC, has six decimals.
00:09:08.350 - 00:10:10.414, Speaker A: So if we have a difference of one, that's one to the minus six. So there's usually not that much to gain for an attacker on most chains. But this is where it gets interesting, because on Solana, the transaction fees are very low. And also you can bundle quite a lot of instructions in a single transaction. And with these two things together, there are instances where it becomes interesting for an attacker to try to orchestrate an attack like this. Because if you're able to steal one token every time, and you're able to do that maybe 1000 times in a single transaction, and your single transaction costs a fraction of a cent, but you as an attacker gain just a little bit more, then it becomes interesting and pretty much using a single rounding error, an attacker would potentially be able to drain an attire account. So this is a very important one and very interesting, because on Solana we have very cheap transactions.
00:10:10.414 - 00:11:09.796, Speaker A: This is also, I think, one of the more interesting ones, closing program accounts. Because basically, closing a program account in Solana, if you don't know, is basically just taking away the lamp boards that are reserved for rent, and then at the end of the slot, your data account will get purged away. But the issue is here is if you close an account this way, potentially anyone would be able to transfer enough lan ports to that account for rent. Basically reopening it, because as long as a data account has enough land ports for rent, it will remain open. And we all know that transferring Len ports is something anyone can do. So anyone would be able to potentially reopen a closed program account. So in your program, if you rely on a program account being closed or not, this can become an issue.
00:11:09.796 - 00:12:26.444, Speaker A: So for example, if you have a gated mint with a whitelist, and your whitelist spot is represented by there being a data account or not, this could potentially become an issue. Because if someone redeems their whitelist account, you close that account, someone would be able to reopen it, and then they'd have a whitelist spot again and they can mint again, which is not what we want. So one way around this is to make sure, you explicitly store that, for example, in this case that the whitelist spot is redeemed, potentially just a simple Boolean right before you close the account, just so that when someone reopens it, that same data will be there. Because remember, only the program that owns the account can actually write data. So even if the account is closed and reopened, you can still trust the data that is in there because only you would be able to write that. So just writing a Boolean, or the way anchor does it, is they have an identifier for closed accounts. So they write that identifier first and then actually close the account, because then when it's reopened, you can do a simple check and you know, hey, this one was actually reopened by someone and I shouldn't actually use this.
00:12:26.444 - 00:13:09.978, Speaker A: Moving on to number nine, this is another rust specific one, and I think that gets overlooked quite a couple of times. Because in rust, handling an error can be as simple as adding a question mark to the end of a statement. So just that question mark will basically determine whether your errors from that statement are handled or not. So you can think forgetting that question mark is also very easy. And things that can happen from this are quite interesting. So let's take the example of an SPL token transfer. Again, I have an instruction, and it's doing an SPL token transfer.
00:13:09.978 - 00:14:24.234, Speaker A: And if that SPL token transfer completes successfully, I have some other logic in my instruction. If I forget that question mark at the end of my CPI call to the SPL token account, then potentially that CPI might fail. And if that fails, I won't know because I didn't handle the error, and my instruction will happily continue execution. So always make sure to handle all of your errors that can potentially be thrown from anywhere inside your instruction, because if you don't, your execution will continue and you might get some unexpected behavior. Moving on to the last one of the lists, and I think this is another interesting one, is related to PDA seeds. So as we know in Solana, program accounts are derived using seeds, and those seeds can be anything from a string to a byte to a public key, and usually they are dynamic. So that means that one specific user has one specific associated data account for them.
00:14:24.234 - 00:15:29.052, Speaker A: And this is where it becomes a little tricky, because if you have dynamic seeds, you might be able to orchestrate collisions between different types of data accounts. So let's say I have a store, and in that store we have a couple of products, maybe an apple and a pair, and the price and the image and all that information is stored in a data account for the seeds. For that data account. For the apple, I just use plain the apple. And for the pear, I use pear. You can see this apple or pear, you can see that as a dynamic seed, because depending on what I input, I get a different address with a different data account that has different data. So what if I need a global state for my program as well? Maybe some configuration related to the marketplace, maybe which tokens are accepted, something like that.
00:15:29.052 - 00:16:36.904, Speaker A: I can put that in a data account as well, and I'm going to have config as my PDAC for that. And I think you can probably already see what could potentially go wrong here, because if attackers are able to create new products, which could be a thing inside my program, what would happen if they create a product called Config? We would have the config PDA account that would store my information related to the store as a whole, but there would also be a product called config. And because these two conflict with each other, there can be some unexpected behavior. So the way to go around this is to always prefix your PDA seeds. So in the case of the apples and pears, I would put a static seed right before apples and pears. So I call that product apple product pear. And that way I will make sure that I'll never get any collisions with any other data accounts that are, that my program is using.
00:16:36.904 - 00:17:32.790, Speaker A: Finally, I wanted to talk a little bit about some useful tools. I also already mentioned anchor a little bit in the beginning. I think anchor is very nice because it forces you to be very explicit about the accounts and the validation, and it all puts it in a single place where you really have to make sure you handle everything. And if not, anchor just won't build or it'll errors. So anchor would highly recommend using that. Another one of my favorite tools here on the list is Solana bank run, because I think you can handle a lot of the cases or of the things I mentioned here using unit tests and writing unit tests, using Solana test validators. So talking to an actual test validator on your local machine is rather slow.
00:17:32.790 - 00:18:23.108, Speaker A: And the issue with that is that you cannot write arbitrary data to any arbitrary account. And this is where Solana bank run comes in. It's basically just, it exposes the bank's clients that some people might know from rust, and that pretty much allows you to write any data to any account at any time. It allows you to simulate data different clock or different times. So it basically helps you in very easily isolating test cases and setting a specific condition running your tests and then checking if everything goes well. So you can very easily simulate what happens if there's an account that has an owner that is not what you expect it to be, or if there is an account that gets closed and then reopened again. So.
00:18:23.108 - 00:18:53.994, Speaker A: Solana bank run. Very nice tool. Brings me to the end of my talk. I want to give a quick shout out to some of the awesome auditing firms that we have in the Solana space because I think without them, a lot of these things that I've talked about wouldn't have been found. So, quick shout out to them. And then at the end, I just want to thank you all for being here and listening to me talk about security. Thank you very much.
