00:00:08.760 - 00:00:41.685, Speaker A: Hello everybody and welcome to day two of our Solana Pirate boot camp. Today we're gonna put the pirate ships that you minted yesterday to see in the seven seas program. But first let's have a little introduction. So today we're gonna learn Solana, the programming model. And we're gonna write our first program in Solana Anchor. And we're gonna do this through writing some little games. So what we will learn today is we will write our first anchor program together.
00:00:41.685 - 00:01:48.737, Speaker A: Then I gonna show you how you can save Sol in a program and send it out again so that you can reward a player for example, or do whatever applications you need which saves Sol in the program and uses it for something. Then we also gonna interact with SBL tokens in a program and then we going to do a complete local setup with installing everything locally, deploying a program, writing our own JavaScript, next JS client for it, and using the Solana wallet adapter. So what is Solana? Solana will change the future. It's a blockchain with very fast confirmation times, very low fees, but from a programming view, basically what it is, it's just a big database where you have a bunch of different programs which can change this data. And by having that you can of course also build games with it. But let's first of all put our ships to sea. So the pirate ships you minted yesterday, you can now use to play this game and you can deploy your NFT on this map and then drive around and shoot other players.
00:01:48.737 - 00:02:14.621, Speaker A: So please just open this URL here. Solplay.de 7c indexhtml I gonna do the same. And yeah, then we will be able to fight each other. So this is the WebGL version of the game written in Unity. Unity. We will also cover a little bit today at the end, so you just log in with any of your wallets.
00:02:14.621 - 00:03:12.737, Speaker A: I can use Soulflare now because it's already set to defnet and here you can see already that my little pirate ship here is moving around and I can now either move against another ship to do a little bit of damage, or I can use my cannons to do a bit more damage. And I can also collect these chests here. So this gives me gave me ton 10 pirate coins and these pirate coins you can use to upgrade your ship. And tomorrow you will learn how you can use these pirate coins and stake them to get more pirate coins. And on the days after there will be a swap where you can take these pirate coins and trade them into rum and cannons which will influence the damage and the health of your ships on this map. So yeah, get some friends together and play a little bit, have a little battle here. And yeah, we will now learn like after the boot camp you will be able to build something like this yourself.
00:03:12.737 - 00:03:53.125, Speaker A: And as you can see, like maybe that's important to notice that every transaction here, every move on the board is actually a transaction on the Solana blockchain with an auto approved wallet. So you can see here in the bottom the status of the transactions and how fast they are. 400 milliseconds. It's very quite fast for a blockchain. So what is the seven Seas program? So this program is also written in anchor, the same thing that we're going to use today to write our little game. And it's a real time multiplayer PvP. On chain game you pay a little bit of soul to deploy your ship and then it's split up into your ship and into a chest that you spawn.
00:03:53.125 - 00:04:34.975, Speaker A: And whenever someone destroys your ship or collects the chest, you never get the soul that is in the chest. And also some gold pirate gold SPL tokens on top so don't get destroyed. That's important. Yeah, it saves some SPL tokens in a PDA which we learn later what that is. And you can use the gold token to upgrade your ship. And there's a websocket connection from all the clients which listen to the bot account so that they get very quick updates from the state changes of the Solana blockchain. And then on Thursday we're gonna look into randomness for the damage of the ships and the position where new ships spawn and chests.
00:04:34.975 - 00:05:11.089, Speaker A: Then we gonna look also at clockwork threads to move the ships automatically on the map. And then we also going to look at zero copy accounts in case you need an account which is bigger than 10 kilobytes. But yeah, since I'm a game developer, let's talk a little bit about games on Solana before we dive into the programming part. I want to quickly cover why you should build your games on Blockchain and especially on Solana. The transaction fees are super low. As I already mentioned, you only pay 5 lampards which is 0.00005 sol.
00:05:11.089 - 00:05:49.367, Speaker A: So they are very cheap and they confirm within on only 400 milliseconds. Then you can use the blockchain for rewarding your players. Like you can create SBL tokens and give them to players that can be the in game currency. It could be diamonds like in usual traditional games or some coins. And you can Also of course have NFTs like we did just now. Like we created a pirate ship yesterday and now you can use it in the game as a character and all the data of the ship will be saved in a PDA which is derived from this nft. So I'm going to show you later how this is done.
00:05:49.367 - 00:06:28.023, Speaker A: So what you can also do is use NFTs as token gates. So it's only people who own your NFT of your collection can play your game and you can use it to save stats, you can save the game state and all of that is on the blockchain saved there forever basically. Then it's also very composable. Like recently someone built a high score program for example that now everyone can use. And yeah, there's just new things being built every day. Like some people from Jump built a game entity component system that you can use now and anyone else could build a client for your game. Basically.
00:06:28.023 - 00:07:28.579, Speaker A: Like as you saw the seven Seas program, we have a Unity client and there's also a JavaScript client which we're going to look at on Thursday. So it's pretty cool. You put a program in the blockchain and then other people can build their different clients for it, change the graphics or build whatever game with it, or you can just take it and deploy it yourself. And yeah, then of course you can like take and trade the items of the games and trade them on marketplaces. For example, you could NFTs could now be listed on Magic Eden or Tensor or Haraswap or whatever and then you could also use it in our games. Right now I could like build a pirate shooter game or something or like a pirate cannon bowling game and I could use the same NFT for the lock in and I could even like take the same data like if the pirate ships now levels up because it did lots of kills in the game, then in another game I could theoretically use the same data to also have the game like the characters be stronger there. Yeah, and Solana is free for L.
00:07:28.579 - 00:08:10.825, Speaker A: Like everyone can use it and it doesn't cost you anything, especially as a developer because the players will pay for the fees. Like if you saw in the game here, every transaction costs 5,000 Lampheres. But me as a developer, I didn't need to pay this because it's just the players paying it with their own wallets and it will always stay there. And another nice thing is that I don't have to care about authentication. Like I don't need to save an email address and passwords that could eventually get hacked or leaked because people will just log in with their wallets and it's their digital identity and they can also play with multiple wallets. So that's really nice from a game developer perspective. And it also replaces your payment provider.
00:08:10.825 - 00:08:56.291, Speaker A: I don't need to add do a PayPal integration or something. All I need to do is like whenever someone for example buys pirate gold, I transfer a little bit of soul to myself. Or whenever a new game session start, I put a level little fee of thousand lampards or 5000 or whatever depending on how engaged the people are and how much they are willing to pay. I can just build a game and then take a little fee of the, of every game for example. And you also save the app store fees. I mean if you would be able to get the crypto game into the app store then you could save the app store fees. But currently there, as soon as you have an NFT in your game and you give it a functionality then it needs to be bought via in app purchases on iOS as well.
00:08:56.291 - 00:09:24.229, Speaker A: So you can't really, you can't really just put it in there. But Solana build a solution for that. There is the Saga phone which is a crypto native Android telephone and you can, it has a DAPP store. It's like a decentralized app store. And these apps of course don't have any fees or any regulations on it that you're not allowed to have NFTs in the game or pay with crypto. Yeah. And you have a very engaged target audience.
00:09:24.229 - 00:10:08.265, Speaker A: Like there's just a bunch of people who immediately jump onto new stuff that is being built. For example, there's now a wallet called backpack and they released X NFTs. And if you're now like one of the first games which is in there, then probably everyone will try out a game and play it and give your feedback and so on. So currently it's a very good time to start your game with backpack or putting it into the Solana Depth store. Not every game is made for being built on crypto of course. Like don't try to force crypto into your game. Better makes sense to come up with an on chain idea first and then go from there and like try to make it like really fitting for this genre.
00:10:08.265 - 00:10:38.475, Speaker A: And the regulations are not super clear yet in all countries. Like whenever you have now a token and you create it out of thin air, then it might be difficult to sell it. You might need to get KYC like know your customer information from the players. So this might Be a little bit more complicated. So check the regulations in your country and then do it like. And it doesn't really make sense much for real time games. Like for example, a shooter game would be very difficult with a ping of 400 milliseconds.
00:10:38.475 - 00:11:37.155, Speaker A: But yesterday I played League of Legends on my mobile phone, the new Rift version, and I had a ping of 800 milliseconds or something and it was still kind of playable. So theoretically you could build something like this, or at least you could for sure build a tower defense where the build times of the buildings and of the units is like 400 milliseconds. Or maybe we better make it a second or two seconds. And then when the tower is built, then from there on you could just sync everything by time and make it deterministic. And then you could theoretically have an on chain tower defense game or something like a worms game where you set the direction and the power and then you shoot and then you hit the other player within a few seconds where you can calculate and get the response from the blockchain. So I'm very excited what will be built. There will be a game jam later this year, so if you're into games, probably makes sense to join that one.
00:11:37.155 - 00:12:18.585, Speaker A: Now I want to show you some example games. I already showed you the Seven Seas, of course you can already play that one, but there are a bunch more. Like there's for example Star Atlas, you might have heard of it. It's like probably the biggest game on Solana. They have beautiful art and Great NFTs and they have a huge team and they might become the new EVE Online of the gaming industry where you have like these huge battles where you destroy tons of ships and then the leaders collect all the debris and build more ships out of it. So if they pull this off, it's going to be super exciting. And they just recently released their first demo.
00:12:18.585 - 00:12:49.755, Speaker A: It's a movement demo. So you can take a ship and you can move it to another position. You sign it with your wallet and then you can see that the ship actually moves to this position. And here you can also see that there's a bunch of other ships on these tiles already. So the little number on the bottom right shows you how many ships are on this tile. So on this map there's a bunch of ships already. And I think the transactions of Star Atlas already made up 3% of all Solana transactions for a few days.
00:12:49.755 - 00:13:07.907, Speaker A: So this is very exciting. And you can also do some other things. Like I can scan not hundred percent sure what that does. But I think I will then see which ships are around me or something and I can observe. You can look at my dummy. Nft. So, yeah, I'm quite excited about this one.
00:13:07.907 - 00:13:21.625, Speaker A: Like, let's see what the future brings. I can go back and. Oh, there's something here. Oh, maybe I should go to the sun. I can't. Can't go there, can I? Sorry, I just noticed this sun. No, I can't go there.
00:13:21.625 - 00:13:59.721, Speaker A: Anyway, these are probably the different solar systems or something like this. Okay, that was it for Star Atlas. The next game I wanted to show you is called Solana Plays Pokemon. Just was recently released and people played through a whole game of Pokemon here. So how it worked is there's a little screen here which is like a Pokemon Game Boy game. And then people could vote on the different moves on where the character and the game should move to. I don't know if you noticed, but like a few years ago there was a big thing on Twitch where people had a chat where they could write something and then the characters would move on screen.
00:13:59.721 - 00:14:21.403, Speaker A: And yeah, someone built this for Solana. Actually, I know who Solidity did it. So you can follow him on Twitter. It's really cool. He does a lot of good things. And yeah, and they played through the whole game in a few days, so it was very, very nice to see. And there were of course also a few people who tried to cheat it and like sell all the best Pokemon and so on.
00:14:21.403 - 00:14:54.745, Speaker A: So the same things that happened back then in Solana. Twitch PLAYS Pokemon the next game I wanted to show you is Chrono Kingdom. It's also a completely on chain game. And how it works is you build a city at a certain location, then I think I currently can't log in with a different wallet. So. But how it, how this game works, it's like a little bit of like Tribal wars or O game, like the old games in the old browser games. So you build city.
00:14:54.745 - 00:15:33.299, Speaker A: You build buildings, you produce resources in these buildings and then you can use the resources to produce units. And with these units, the map, you can attack other cities and then like eventually conquer them, and then you have more cities and you form tribes and so on. So that is also a very interesting because it's like also completely on chain and I'm a big fan of these completely on chain games. Another one of these is Ladder Caster. It's the very first solar on chain game. I think I met them in very many hacker houses. They were going around and yeah, you have a little mage and you can move around on a grid and they have this interesting system of cranking the turn.
00:15:33.299 - 00:16:03.285, Speaker A: So whenever, always one of the players needs to crank the button to go to the next turn and pays for the new account. And then you could also collect different tokens here, water, earth and fire. And something can use it to perform spells. And you get different items like magic books and so on. Currently they are not online because they are focusing on their referral system called Buddy Link. Maybe I want to check that out and. Yeah, but maybe they go back to the game and show it.
00:16:03.285 - 00:16:36.203, Speaker A: I especially show these games because they're open source. You can just look at the, at the source code and learn from it. Same as Dominari. It's also an on chain grid strategy game where you have some buildings which produce units and you can move them around and fight against other players. And I think every five seconds or so a new round turn starts and then you can move your units and fight. So here's a video to this one and I think it's also open source. And another one which is also open source is Dee's Quest which I also found super nice.
00:16:36.203 - 00:17:17.383, Speaker A: Was part of the last hackathon has also beautiful music. It's an on chain Match three game where you fight against other players. So you pick your AVATAR and every NFT like I didn't like, these are just dummy NFTs that I created. But they, they all have different stats and then you can fight against each other. So it's this multiplayer Match three game. Whenever you collect some items on the map, then they will fill up your energy and then you can use it to perform very strong attacks. I think the music is a bit too loud for the video so I will stop this here.
00:17:17.383 - 00:17:48.208, Speaker A: But yeah, this is definitely something where you can look at the code as well because they have a very interesting on chain matchmaking system. They create an account and then they match you with another account and then you're like basically on chain. Find another player that you want to play against. And I think you can also play for rewards. Okay, but now enough for games. Let's start with the fun game, with the fun stuff, coding a game. So what we're going to build first is this game.
00:17:48.208 - 00:18:17.863, Speaker A: It's called Tiny Adventure. It's a very, very simple Solana program. So I will quickly log in here. You see, I can get data, I can move to the left and I can move to the right. Okay. And that is what we gonna program first. And we're gonna do this in a tool which is called Solana Playground, which is an online tool where you can write and deploy Solana programs.
00:18:17.863 - 00:18:56.115, Speaker A: So I would like to invite you everyone to open now beta solpg IO tutorials. And then here we gonna start the tiny adventure tutorial. So you just started and then you are ready here with the code, the anchor code and the client code. And then what you probably need to do is here on the bottom left, you need to create a new wallet. So you click here on this red dot, then it will ask you, hey, you don't have a wallet yet. Do you want to save your keyphrase? And then you say, yes, I want to save my key phrase. Or you say, no, I don't want to.
00:18:56.115 - 00:19:29.197, Speaker A: Whatever you like best. And then you can do here Solana Airdrop 2. And you do this two times and then you should have enough soil to deploy a program. So here I am switching my endpoint to definite now because I was previously set to localhost, which is something we're gonna do later. We're gonna do local development later, but we will start on DEFNET today. So Solana Airdrop 2. So you write this.
00:19:29.197 - 00:20:02.111, Speaker A: I did already. Too many requests today. But you should be able to get for soil, definite soil, of course. And if you can't, then here is a few tips. So you can go to solfaucet.com or you can get a custom RPC from Helios, quick Node, Triton, hello Moon or whatever, and most of them have their own faucets and then you can get some definite Sol there, hopefully. So now let's look at this game.
00:20:02.111 - 00:20:43.197, Speaker A: So first we're gonna build it. So we just type build on the bottom. What this will do, it takes the code, the Rust code here from the librs file. Like all Solana programs are written in Rust or they are written in some other language like Python and then they are transcompiled to Rust. But in the end what you will get is an SO file. And when you now type deploy, then what it does is it creates a big account and it takes this SO file and it creates many transactions. Like I think you can transfer one kilobyte of data roughly in one transaction.
00:20:43.197 - 00:21:12.465, Speaker A: And it creates a bunch of transactions and pushes these actually to the blockchain. So then after you deployed this, your program will be on the blockchain. So congratulations, you just deployed your first Solana program. And here on the top you have this ID here. This is the program id. So this is the address of your program on the Solana blockchain you can now go to the explorer.solana.com and switch to Definite.
00:21:12.465 - 00:21:39.967, Speaker A: And then you paste this program ID here and then you will see this program is now actually on the Solana blockchain. So here you can see there's a little bit of SOL balance in there for this account. Here's the executable data. This is this SO file which I talked about earlier. Here you can see how big it is. So it's like 469 kilobyte and it costs 3.2 soil to deploy this.
00:21:39.967 - 00:22:19.337, Speaker A: This might sound high, but you can always, if you don't want the program anymore, you can just write Solana program close with this ID here and then you will get your SOL back. I'm not going to do this now because if you do this for a program then you will never be able to use this address again. But let me quickly show you. So this is how it would look like, then you would just get the soil back. So maybe we do this when we go to the next example, we close the first one since you may not have enough defnet soil for deploying the next one. So now we deployed this and now we can run. And what this does is it starts playing the game.
00:22:19.337 - 00:22:52.975, Speaker A: So here we can see a journey begins and then here's the little character. Then we have another transaction and it says, hey, the player position is now one. So we can now this is the transaction hash. So if you copy this address and paste it into the explorer, this will show you the transaction that this game did. So what the game did is set here like a few accounts were passed in. This is one is our wallet, one is the game data account. And then this is the program address that we deployed.
00:22:52.975 - 00:23:31.645, Speaker A: And now you can see that it says, hey, a journey begins. And now the character is at the first position. And now if we take the second signature and paste it in here we will see that hey, now the position is a little bit further to the right. And if we run this a few more times, like I run this once and I run this one more time, then you can see, hey, the guy is now super happy because he's at the last position. So if we copy this one in here we will see that hey, you have reached the end. Super. So you played through your first on Chain Game and this is here the instruction that you can see.
00:23:31.645 - 00:24:12.917, Speaker A: So it's interacting with our program. It has this writable account and this weird string here is the instruction data. So what I want to show you now is that There's a JSON representation of this program which you can deploy. So I can just click here on IDL and on initialize. And now it takes our JSON representation of the program and also writes it to the blockchain. And then from then on, whenever we refresh this transaction, we will see what is actually happening on chain. So currently it still says it's an unknown program, but now if we reload this, it says Tiny Adventure Move right, because we did the move right instruction.
00:24:12.917 - 00:24:42.245, Speaker A: It's interacting with the tiny Adventure program. And here is the gamedata account. And yeah, just shows us now exactly everything that will happen with the program. So that's a very good practice to also publish the IDL whenever you deploy your program. So now let's, let's play a little bit around with this code. So for example, this is the client. First we initialize the account and then here we move left or we move right.
00:24:42.245 - 00:25:23.043, Speaker A: So the first thing you can change is you can now move to the left. And now if I type run here on the bottom, we will see that we are moving back to the left. And I can do this again until I'm back at the start. Yeah, but how does this work in the program? So now we're going to go through the Rust program and I going to explain you step by step what is happening in this game. So the very first thing is happening is we are initializing the account. And in this we take the context, the accounts, the new game data account, and we set the player position to zero. And here you can see already, like in the very top we have the import for the anchor files.
00:25:23.043 - 00:25:55.789, Speaker A: So anchor is a framework on Solana, which makes development way easier. Then we declare an id. This is the idea of our program. Then we have this flag here program, then we have the name, and then we have the first function which is initialize, which will be called with this context here. And every context consists of a bunch of accounts. So if you go down here to the initialize account, we can see that these are the accounts that are passed into this program. So the first one is the game data account.
00:25:55.789 - 00:26:28.301, Speaker A: The second one is the signer. So in this case it's this wallet down here which we connected. But if we play this here in the browser, then it will be always the wallet that is currently connected. In this case would be Solflare Wallet. And then we have the system program, because on Solana you need to always pass in all accounts that a program will interact with. So for example, if we want to create A new account for that we need the system program. And since we want to create a new game data account, we need the system program to be able to do that.
00:26:28.301 - 00:27:02.129, Speaker A: And the gamedata account you can see down here is everything it is actually is just a player position. So the whole game only consists of U8 actually, which goes from 0 to 3. So it's just a number. And the Data type is U8. This is just one byte and it means the number will be able to go from 0 to 255. And yeah, this is an interesting part here because this is pda. It's a program derived address and program derived address.
00:27:02.129 - 00:27:37.659, Speaker A: You can imagine, like if Solana is a big database, then you have somewhere your program and then you have a bunch of PDAs which derive from this program ID, like different entries in the table, for example. And in this case our seat, our table entry is level one. So in level one there'll be a character which is at position one, two, three or something like this. And we could now also change this to be level 2. Then there would be another instance. Or what we could also do is we could add the signer as a reference here. And this would mean that we have a level one for every wallet.
00:27:37.659 - 00:28:09.451, Speaker A: So now every player would have its own level one. Because actually what we built here is a multiplayer game. Like I'm going to show you, I'm going to ask you later to send me your program IDs so that I can then from my client interact with your program. And then we can actually at the same time interact with the same program, which is quite fun. Then here we have the payer which will be the signer. So as the person who calls this transaction also needs to pay for this account. And this is the space.
00:28:09.451 - 00:28:40.805, Speaker A: The space is like basically what it costs to create this account to have it rent exempt. Rent exempt means that you need to pay a certain amount of SALT to save data on the Solana blockchain. And the space is 8 byte, because this is what anchor does to. It's called an account discriminator. It's just a little bit of data that Anchor puts into the beginning of an account so that it always knows which account this is. And then we have one byte for our player position. You eight is one byte.
00:28:40.805 - 00:29:02.545, Speaker A: And yeah, this is already everything that we need to create the accounts. And then we have two functions here, two further instructions. One is moveleft and one is moveright. Let's first look at the moveright function. We get the gamedata account that we pass in. So in the moveright accounts we have the same thing. We put the gamedata account in.
00:29:02.545 - 00:29:45.121, Speaker A: And if the playerposition is 3, then the player has played through the game and is happy. Otherwise we take the player position and we add one to this player position. So we move the character to the right and then this is a print player position which just checks the player position if it's 1, 2, 3. And then it just shows the ASCII representation of the game, basically. So yeah, this is already everything that's happening in Tiny Adventure, basically. So now let's have a look at the client. This is the derivation of the PDA of the program derived address in the client.
00:29:45.121 - 00:30:20.731, Speaker A: It's basically the same as in the program. It's like we take the web3 public key and we find the program address and we take as a seed, we take only level one. And this is like what you would need to put, if you want to put. If you want to have one instance of the game per wallet per player, then you would add this wallet public key here as a buffer as well. And you can put basically almost as many seeds and whatever you want in here. So it could now also have level one and level one, stage eins, stage two, stage three or something. That would also work.
00:30:20.731 - 00:30:52.987, Speaker A: Okay, and then here in line 14, we are fetching the game data account. So we go from the program account, game data, and we fetch it. What this means is we call the RPC node and say, hey, give me the data of this account. And then we have the account data. And if we don't get the account data, then it means the account doesn't exist yet. And then we do the initialize instruction here. So we call program methods initialize and we put in the three accounts, the game namedata account, the signer, and the system program.
00:30:52.987 - 00:31:21.677, Speaker A: System program. As you remember, we need to create the new game data account. And then we need to always, for every transaction we need to also put a signer. Like every wallet on Solana consists of a private and a public key. And if you want to change data, you need the private key to sign for changing this data. In this case, we will subtract some SOL from our wallet because we are paying for the fees. So we need to sign for this change because otherwise everyone could just do that.
00:31:21.677 - 00:32:04.309, Speaker A: And then if we do rpc, then we are sending this transaction to the RPC node and that one will take care of, yeah, propagating it through the network and changing the state. I'm going to tell you a bit about this later. Then here we are waiting for the transaction to be confirmed. Every transaction can have multiple go through multiple stages. The first one is processed which is as soon as some data changes in one of the validators it will be processed. And then as soon as it's confirmed, which takes a little bit longer, then it's usually not revertible anymore. So you can already be sure that this transaction will make it into the state.
00:32:04.309 - 00:32:45.395, Speaker A: And then there is a thing called finalized which makes it like. Then you can really be sure that it's completely finalized which is waiting for 31 confirmations, but this one takes a bit longer. So for games I usually wait for the confirmation state confirmed. And yeah, then here we create the next instruction, a next transaction. We call the method moveleft with the gamedata account, we sign it, we send it to the rpc, we confirm it, then we fetch the gamedata account afterwards. So we get the data that is now in there for the new gamedata position. Then we have a switch case here for the position and then we print the data also in the client.
00:32:45.395 - 00:33:39.173, Speaker A: Yeah, what I would ask you now while I go around and help everyone who has problems with this is just go in here, change the text a little bit, write a little story here. For example, an elephant stands in front of the door. What will happen next? Something like that. And then you change these three texts here, then you build and deploy it and then you send me your data, your program id and then I gonna interact with this program from the, from within the Unity client. And yeah, I would know like if anyone has questions I would now go around, help everyone, just write them in the chat. Now let's continue a bit more with the theory. Solana is a big database.
00:33:39.173 - 00:34:09.761, Speaker A: Everything in Solana is an account. And every account has this weird address here which is a 32 kilobyte string. It's like. Actually it's like an array of 32 bytes, but it's in a representation of base 58. It's not base 64 by the way, because there's a few symbols in there which look similar. So that's why they just use base 58 for that. So there's a little I and the big L or something are similar.
00:34:09.761 - 00:34:31.851, Speaker A: So that's why these are removed. Every wallet is a key pair. Like I already said, you have a private and a public key. Every account can only be changed by its owner or you need at least sign for it. And accounts can be executable like our program that we deployed. So this is a transaction. Transaction consists of instructions.
00:34:31.851 - 00:35:02.475, Speaker A: So for example, I could now in this program also add multiple move write instructions and then I would move two fields at the time. Then there's a recent blockage which is very important for the validators to know that your transaction is not expired. So you always need to provide a blockage. And then the validator will look for the last, not 100% sure how long it is, around 30 or 30 seconds. And if this time has passed, then you can 100% be sure. Okay, this transaction will never make it. I can try it again.
00:35:02.475 - 00:35:26.165, Speaker A: It's not like in other blockchains where you sometimes have stale transactions forever and you never really know where they go through or not. So yeah, that's another advantage here. And it's also used for deduplication. And then there's a fee payer. This is the guy who pays the 5,000 lamp ports for the transaction. And then you have an array of signers. Like we already added only one signer here.
00:35:26.165 - 00:36:21.515, Speaker A: But sometimes, for example, if you create a new token or something, you might add another signer. Or if you want to co sign, like for example, I sign in the client and then I sign another time in the back end and only then the transaction will be valid. For example, that you can also do like this. Here's a nice little graph I did for the tiny adventure. So we have the gamedata account with the seed level one with the player position, which is just a number. And we have the moveleft instruction with subtract 1 and we have the moveright instruction with add 1 and we can get data and then have the ASCII representation of the game. So what happens to your transaction? What I wanted to show you is when you take this account here and now I paste it into the Unity client, then I will be able to interact with the same program.
00:36:21.515 - 00:36:59.615, Speaker A: And we will also be able to see that when I interact with the program from in playground, then we would also see the change directly in the Unity client. So let me quickly start this up here. This is the seven SEAS program. So but now we open the tiny adventure scene. Everything of this is also open source of course, so you can just very easily access it by checking out the repository. So I log in into devnet and now it's interacting with the same program. So I can now say here I want to move to the right.
00:36:59.615 - 00:37:53.563, Speaker A: Here I move to the right and this could now be one of your programs. So I move to the right and then we see that on the right side in Unity, it also moves to the right because the account has a websocket connection to the game data account. And as soon as the state changes here, then the RPC node will inform our client via the websocket that the account changed. Yeah, so whenever we read data, the RPC node just looks into its state, gives us the version of the data with the commitment we want and sends it back. But if we want to write data, then we need to send a transaction which is signed and pays fees. And then the RPC node will propagate it to the current leader of the network. The leader will change the data distributed through a stake weighted tree to all the other validators and they vote on the state.
00:37:53.563 - 00:38:27.615, Speaker A: And lots of magic happening. There's this thing called Turbine and like all the shreds, like shreds are the smallest parts of a transaction, they are distributed through this network. Then the vote and at some point the state will change, will be changed, and then the RPC node notices this and it will directly push the change of the account to our client. So that's why we actually built a multiplayer game here. So every client who changes this data now will immediately get the updates. So this is pretty cool. And it basically comes for free with the Solana blockchain.
00:38:27.615 - 00:39:05.233, Speaker A: Now, I would give you a little homework after. Yeah, after the first session in the afternoon, you might be able to change the game a little bit so that you have position, which is like going in X and Y, because currently we're only going back and forth. And yeah, there's a bunch of different ways how you can implement this. I will show you on Thursday or on day six of the bootcamp how I did this for the seven seas. But yeah, there are different other options that you can use. You can save, for example, X and Y position and create one PDA per ship. Or you just have one player and move it around, or you just save the position.
00:39:05.233 - 00:39:32.145, Speaker A: You can also save the position as a string. Everything will be okay as soon as it works in the end. For the seven Seas, like the one option is to have the X and Y position in there. It's quite easy to implement, but it might be difficult if you have a bigger game and you have lots of ships. You need to somehow figure out where all these ships are and all the seeds of it. That's why for the seven seas, I did it a bit. I just have one big two dimensional array where I have all the ships and then I move them around in there.
00:39:32.145 - 00:39:56.735, Speaker A: It's quite easy to have a websocket connection to this one account then. And whenever it changes, it updates your player position. So. But it's also a bit more complicated. So, yeah, just try whatever works and just submit it later. And yeah, now let's have a little break maybe. And then we're gonna look at Tiny Adventure 2 and how to save Sol in the program.
00:39:56.735 - 00:40:27.511, Speaker A: Welcome back, everybody, to part two of the day two of our bootcamp. Now we're gonna learn how save salt in a PDA and pay it out as a reward to the players. So what we're going to build is this game here. What we can do is we can reset the level and spawn a chest. So the little cube here is a chest. Then I can move right. I can move right.
00:40:27.511 - 00:40:56.731, Speaker A: I can move right again. And then I won't be able to. Oh, I collected the chest because I didn't set a password yet. But what we're going to learn is how you pay sol, save it in the pda and then if you move to the right at some point, you need we will add a password to the chest. So if you want to collect the chest, there will be a password to it. So if I now add something else here, then I would not be able to collect this. Actually, I am able to collect this.
00:40:56.731 - 00:41:41.775, Speaker A: I think I just deployed the program without the password. And we got to add the password to this program now and then deploy it again. And then you will need the password to collect the chest and then you will see here a little wrong password code as soon as you enter the wrong password. Okay, for that we gonna go to Tiny Adventure 2. So please open the Open Solana playground again. And this time we're going to open here the tiny Adventure 2 tutorial. So you just click start and then you will have the code again here, the Rust file and the client.
00:41:41.775 - 00:42:26.935, Speaker A: Then we can quickly close the other account in case you need your SOL back. You can take this program address here and you can write Solana program close and then the id and yeah, then we will get our soul back. So we need to quickly switch this to defknet. And yeah, now we got our SOL back and now we can deploy the next game. Keep in mind that when you close your program, you will never able to use this ID again. So don't accidentally close your mainnet programs, which has a bunch of people using it already. Okay, so now we go to Tiny Adventure 2.
00:42:26.935 - 00:42:59.245, Speaker A: So there's a bunch of more tutorials here that you can try out, of course. So Tiny Adventure two, we built this and then we deploy it and then we run it the same as we did for the first tutorial. Then I gonna show you how the, how the code works. First let me quickly remove a few things here which I didn't want you to see yet. Okay, build. So we're going to build and then we're going to deploy it. This always takes a while.
00:42:59.245 - 00:43:24.319, Speaker A: So now we're deploying it. And now let's already start looking at the code while we are deploying. So it's very similar to the first one. Like the game data account is the same as before, it's just the player position. We have a few more accounts here, as you may notice. And we start again in the initialize, initialize and initialize level 1. This will just create the account.
00:43:24.319 - 00:43:52.341, Speaker A: So there's nothing special here. On the top we have the chest Reward. This is 1 billion Lempards divided by 10 which results into 0.1 Sol. Then when we reset the level and spawn the chest, we set the player to position zero. And then we transfer some SOL into a PDA into another program derived address. And how we do this is we do a cpi, a cross program invocation into another program.
00:43:52.341 - 00:44:31.911, Speaker A: And in this case we call the system program transfer function. So we create a CPI context with the program that we want to invoke, in this case a system program. I could also from here now, for example, invoke the tiny adventure game and say, hey, whenever I move in Tiny Adventure 2 to the right, I want in tiny adventure to move to the left or something like this. Then we define here the accounts for the instruction. So this is a transfer instruction. And we transfer from the payer to the chest vault. And then we call system program transfer with this CPI data context and the amount.
00:44:31.911 - 00:45:03.325, Speaker A: And what this will do is it transfers SOL from our current wallet to the pda. And now we can run this example here you can already see what's happening. So it starts with my balance, which is 62.5 and resets the level and spawns a chest here shows us a little diamond. Then here you can see we only have now a 62.4 sol left because we transferred 0.1 sol into the chest.
00:45:03.325 - 00:45:31.569, Speaker A: Then we move to the right, we move to the right and here in the end we collect the chest. So we are going back to 62.5 SOL. So here you can see the little guy is collecting the diamond which represents the SOL that he collected. So this is how you transfer SOL into a pda. And if we Move to the right and we are at the position directly in front of the chest, which would be two. Then we add one to the player position.
00:45:31.569 - 00:46:26.873, Speaker A: And here we transfer this all back. Here it's a little bit different because we can't use the system program transfer because the PDA is owned by our program and not the system program. So what we do in this case is we just take the Chest Vault account, we take the Lamperts amount of it, which is like the Sol in it, and we subtract the chest reward and we take the player account and add the chest reward for this. It's important to know that every account on Solana you can always add Sol to it, but you can only remove Sol from it when you sign it. And in this case, this Chest Vault is owned by the program, so it will be able to change it whenever it wants. So we can just take some soil the chest revolt from the program and transfer it to the player. Very important here is that the balance of the whole Lamperts in the Solana blockchain needs to be always the same.
00:46:26.873 - 00:47:04.197, Speaker A: Otherwise you can't just create SOL out of thin air by just transferring 1 billion lampards to an account or something like this. So the runtime checks for that, of course. And if you're not at the end, then we just move the player and we print the player position again like so. Now let's look at the accounts because it's a bit different. Now the game data account is the same as before, Level one signer nine bytes. But now we have one more which is a Chest Vault. And the chest vault has exactly 8 bytes, which is the minimum that you can have with an anchor account.
00:47:04.197 - 00:47:51.191, Speaker A: Because it puts the 8 byte account discriminator always in the front of the data of an account that it creates. If you're interested, these eight bytes are actually derived from just taking the string global colon and then the account name and then it takes the 258 hash of it. And then it takes the first 8 byte of this. So in case you ever wonder how this is done, it's not magic, but it's just a standard how anchor does it. And then you have the signer and the system program and the same for the spawn chest account. It takes the payer the Chest Vault, which also has just a seed chest vault. And the move right does the same Chest Vault game data account player system program.
00:47:51.191 - 00:48:34.855, Speaker A: So all that is new in this example is the Chest Vault. And the Chest Vault is just an empty struct just to make sure that this is actually the amount of data that is in there. And what anchor also nicely does is when you add the seats here, it does a bunch of checks in the background so that actually you can only put in the correct account because otherwise if you wouldn't have any checks, you could just put any account in here. So I could say, hey, I want to play a spawn a player, but I just put another account for the transfer of the soul. And this of course we don't want. So that's why you add these checks here and then anchor in the background adds a bunch of checks for you. Now let's look at the client.
00:48:34.855 - 00:48:57.983, Speaker A: Client is the same as before, level one. Then here the chest vault is also just the string. Chest vault. We initialize level 1. In this case we can call this multiple times because we added here. Now it's another nice little thing. We added the init if needed function here, which is an anchor function.
00:48:57.983 - 00:49:31.675, Speaker A: So it will only initialize the new account if it's needed. Otherwise it will just go on. Then we have a little loop here, which from 0 to 3 moves to the right. So it starts at 01, 2, 3 and then in the end it collects the chest. And now what we want to do, or what I would ask you to do as a little task is to add a password to this chest. So only people with the password would be able to collect this. So yeah, pause the video, take your time, try it out and I will be back in a second.
00:49:31.675 - 00:50:15.995, Speaker A: Okay, so how we could do this is we can just add a password here, which is the password string. And here we would just say if password is unequal, whatever we want, I'm gonna say gib. Then we panic and we put an error message. The password password was wrong. So and now if we build this and deploy it and run it. Oh, I got an error here. Now good that this happens now.
00:50:15.995 - 00:50:47.595, Speaker A: So this needs to be uppercase string I think. So you're going to build this, then we deploy it and then you will notice that also in the client, of course. Now we need to add this new parameter. So build now we deploy. This will again take a while, but we can already go here in the client and we should now see a little error here somewhere. The move right now needs another parameter. So here we now put some wrong password just so we will be able to see the error.
00:50:47.595 - 00:51:11.785, Speaker A: Now we wait a little bit until this is deployed. This is a little bit faster if you run your local validator. So I'm going to show you later how to do that when we go to the local setup. Okay, so now this is deployed. And now if we run this, we will get an error in the last instruction here. Hey, failed to sense send. Transaction simulation failed with instruction 1.
00:51:11.785 - 00:51:59.055, Speaker A: Now I want to show you a little bit more how you can make these errors a bit nicer. So we go here in the tutorial to the last page of the penultimate page, or so I think it is. And then we can see we can also create a nice error code. So if you copy this here, this is good practice that instead of just panicking, you create an error code and then this error code you can return here in this function. So let me copy this in here. And if I return this error code, then in the client we can pass this error. So let me build and deploy this again and then I'm going to show you quickly in the Unity client.
00:51:59.055 - 00:52:51.925, Speaker A: So now I'm back in C. In the Unity client I gonna open the tiny Adventure two servers and then I search for error. And here you can see we take the transaction info and then we check if there was a custom error. And then we compare it to the wrong password error, which is in this case 6000, which you can find in the IDL. And then we show a string on the screen which is wrong password so that you can then also do so this IDL you can export here and then you can open it here. Click on the left on this little gears icon and then on IDL and then export, then it will open the IDL for you. And then you can see exactly what is in this JSON representation.
00:52:51.925 - 00:53:31.115, Speaker A: And as soon as you add an error, then the error will also show up here in this JSON. So here, wrong password is the error code 6000. And then in the clients you can use these error codes to handle whatever you want. For example, if the player doesn't have enough tokens to pay for something, you could show him a pop up, hey, do you want to buy more tokens? Or you can just show the error so the players know what the users of your app knows what know what's going on. So back to the presentation. This is Tiny Adventure 2. Here's the little graph of it again, a little flow shot.
00:53:31.115 - 00:54:03.961, Speaker A: We have the get data again. For the player position, we have reset and level, reset level and spawn chest, which sets the game data account position to zero. And it adds a little bit of soul to the chest vault. Then we move right, and when we're at the end, then we check the password and give the player his Soul, this is how to save SOL in a pda I showed you already in the program. So this is how you transfer it out. You just subtract the LAMP parts. And now what is also very important to know is how you interact with SPL tokens.
00:54:03.961 - 00:54:37.665, Speaker A: SPL tokens are most of the tokens in Solana. For example, USDC is an SBL token. The pirate gold that we created is an SBL token. The Canon token is an SBL token. There's also a wrapped SOL token which is also an SPL token. And yeah, if you want to know how to interact with it, I will not go too much into detail how to interact with these in a program because you will do this tomorrow with Jacob for the staking of tokens. But how you would do it is you have a token account and a token account needs to be owned by another account.
00:54:37.665 - 00:55:22.985, Speaker A: So your wallet, for example, can own a token account for usdc. And there's also a special token account which is the associated token account, which is derived from the name of the token, the mint of the token and the associated token program id. And like this, the wallets are very easily be able to find your wallet, your token accounts in your wallet. Because otherwise you can have all kind of token accounts derived from whatever you want. But yeah, is a very good practice to use the associated token account. And you can only have one per token per wallet. And then if you want to create a token account which is owned by the program, you need to add an authority like token account owner.
00:55:22.985 - 00:56:03.430, Speaker A: This can also be a PDA and you add the mint in this case would be pirategory or the USDC mint. And yeah, then you can create this token account in your program and then you can like usually just transfer in and out of this account. So to transfer in you have the transfer instruction the same as the SOL transfer earlier. Do you create a new CPI context with the token program and the transfer instruction. So you have from account to account. And this time you also need to add the authority for the from account because otherwise you can't transfer the tokens out of this account. And then you call the AnchorsBL token program.
00:56:03.430 - 00:56:47.017, Speaker A: It's actually the token program transfer versus CPI context and the amount. So this would be 1,000 tokens, for example. Then you would need to put in thousand to the power times the decimals of the token to the power of 10amount in here. And to transfer out is just a tiny bit more complicated because you need to sign for the PDA with the PDA for the transfer in the program. But here's an example how you can do that. And then you would just call the CPI context new with signer and the sign up in this case be these seats here, the token account owner PDA and the bump. So now becomes more interesting we gonna do a local setup.
00:56:47.017 - 00:57:22.005, Speaker A: So the playground is super nice, but at some point maybe you want to develop locally as well. And if you check out any repository then probably you will want to run it locally. And you also want to be able to build a next JS client. And also on. So how we do this is we follow these instructions on the Ankar installation docs. So this is a very good guide here. So you start with installing Rust for this you use Rust up, just use the newest version that is currently compatible with everything.
00:57:22.005 - 00:58:02.713, Speaker A: Then you go install Solana. So for that you just run this command here in any terminal that you want. So you just create a new terminal, paste this in here and it will install the Solana CLI for you. Then the next thing you need to do is a Solana keygen new. This will create a key pair for you in the standard location. And if you have a key pair there then you can transfer some defnet soil into it for example or some real sol if you want to work on mainnet. And yeah, this is a precondition that you need if you want to run and build Anka programs locally.
00:58:02.713 - 00:58:48.309, Speaker A: Because you need to define a key pair and the easiest way to do this is have a key pair in the standard location and then use that one. Then you need to install Yarn. You can also use NPM but I'm big fan of yarn. Yarn is a bit. It's a bit faster because it does things in parallel and it has hashes for all the versioned packages actually then you use install the anchor version manager AVM for that you just copy paste this command here into your into your terminal and then run it. There's also an example for Linux systems and the rest here we don't need. And then how it should look like in the end.
00:58:48.309 - 00:59:38.917, Speaker A: Let me quickly delete this stuff here. I think there's a shortcut to delete this but okay, so anchor minus minus version should show you 28 Solana minus minus version should show you 1.16. Rust C should show you something like this, maybe a bit newer. And if you have all these installed then you are actually good to go. So then now I would like you to check out the repository game starter kits. So check out this repository please with any git git client you want. If you're using GitHub, GitHub Desktop is the easiest function, the easiest thing to do it.
00:59:38.917 - 01:00:21.863, Speaker A: And then you please open the tiny adventure folder in Visual Studio. So I did this here already and then here on the left you should have app and program. Then you can go into the program folder and you can write Anchor build. This will build your anchor program. Of course you need set up your wallet before like I told you earlier, your wallet is defined here. This is your the default place. And if you don't have any SOL in it, you can type Solana Balance UD will give us the balance of defnet.
01:00:21.863 - 01:00:58.671, Speaker A: So you can, with every command you write in the cla, you can always do UL for local UD for defnet and um for mainnet. So and then you can also do Solana address, this gives you your address and you can just transfer some soil into there. Or you can do Solana airdrop something too. I already have too much requested too much today already or maybe if I add oud. Ah, so I got some more. So Now I'm at 12. I think the current limit is for SOL per day.
01:00:58.671 - 01:01:31.401, Speaker A: So this should be enough to deploy an anchor program. And then you can either close it or you wait a day until you get another for defnet. So yeah, so this is the definition of your program. Here's your program id. You can also add the program ID that you had in Playground earlier, for example, if you want to do that, and then you can deploy the program. And that's basically all we did already in the Playground. But the interesting part now is to look at the client for it.
01:01:31.401 - 01:02:22.415, Speaker A: But maybe let's go first through some extensions that I would recommend or that I use. Not necessarily recommend, but they are very good. So the Rust analyzer is basically a must have if you work with Rust in Visual Studio because it gives you all the types and auto completion and yeah, everything that you need to work with Rust programs, it has all the crates passed and then you can just write dots and then it shows you all the function names. For example, then there's a better toml which formats toml files in a nicer way. So for example the cargo TOML and Sago TOML and the anchor TOML and so on. Then we have error lens. Error lens shows error a bit nicer errors a bit nicer and more prominent and shows you some.
01:02:22.415 - 01:02:53.485, Speaker A: I don't have an error here currently, but yeah, it shows your errors in a nicer way. Then I use also GitHub Copilot as an AI tool which just autocompletes sentences for you. So for example, it's not super good at coding, but it helps you a lot with comments, for example, and tests. If you want to write a for loop, for example, it just does it for you. And sometimes it also comes up with very good ideas. So it's like sometimes very useful. But don't trust it too much.
01:02:53.485 - 01:03:25.259, Speaker A: And then I also have the extension called crates, which shows you which dependencies are out of date by the way. You find all these extensions here. You just type it here. And then you have better tunnel and then you have crates and the crates one, for example, if you go to characters shows you this little checkbox here. Or not if you're not on the newest versions. So just a nice little hint then optional is code. LLDB is like a rust debugger.
01:03:25.259 - 01:03:55.895, Speaker A: It doesn't really work on programs, but it's still good to have prettier. Makes your code prettier by formatting it correctly. And then there's of course a visual code Studio pets, which is very important. Here you have like this little crap and the little mouse and they fight each other. It's a cat, not a mouse. Yeah, it should also be mandatory, I think very important then. Yeah, for the local setup, you can also in your settings you can configure the analyzer and the formatting.
01:03:55.895 - 01:04:27.599, Speaker A: So you can set the default format to Rustling Rust analyzer. You can say format on safe, which is nice. And you can also add your check Rust analyzer to Clippy instead of the default one. So now to the local setup, how you run the program? You go into the program, the tiny adventure. We did this already a few minutes ago, but then you install the NPM packages. I think that we did not do it. So npm npm.
01:04:27.599 - 01:04:55.265, Speaker A: I actually should use yarn installed since you shouldn't mix the different package managers. And what does it say next? Anchor test. So we run anchor test and this now runs the tests. It deploys the program and then runs the test into it. So it initializes run, write, run, write. And now all the tests are passing. Then how to run a local validator? So you can do a Solana test validator.
01:04:55.265 - 01:05:25.567, Speaker A: This starts a local validator on your machine. And then you can also for example in Playground you can here go to localhost and then you can also deploy to localhost and you get some bunch of free SOL here. So 100 SOL on my local net. And you can also airdrop as much as you want. And the deployment is a little Bit faster as well. Solana Airdrop 1000. So now I have 1000 sold.
01:05:25.567 - 01:05:45.085, Speaker A: So that's pretty cool. Yeah. And then we go to the app and run Yarn dev. So that we didn't do yet. So we go out of here, we go into the app folder and then we just run Yarn dev. And now we have our JavaScript client here. It's the same code as in Playground, so I just deployed it somewhere else.
01:05:45.085 - 01:06:23.095, Speaker A: But this is now a Next JS app, so. And it has a few benefits because it's like nice to have build a UI there. So you have like this move left and we assign this and character moves to the left, it moves to the right. I can get data and initialize. And it uses the wallet adapter so the users can pick whatever wallet they want, which is of course very convenient. And when you have any helps you can go to solanastackexchange.com you can ask all kinds of questions here and yeah, we'll hopefully get answered.
01:06:23.095 - 01:06:41.755, Speaker A: There's a bunch of people who are like constantly answering and asking questions. ChatGPT can also often help us. This was Rust problems. Knows Rust very well. Request all these borrow checks and so on. But I would recommend you watch a few videos on Rust. They're very good videos on.
01:06:41.755 - 01:07:14.167, Speaker A: On YouTube. Just some tutorials that you can just follow and like learn about borrow checks and how you do enums and option types and so on. Let's quickly go over the code. Like the backend code is the same as we had earlier in the program, but the front end code is of course a little bit different now. So we have here the multi wallet button. We have the context where we define the different wallets we want to support. We have the IDL as TypeScript for that.
01:07:14.167 - 01:07:48.537, Speaker A: Actually you need. Whenever you build the program it will also create your TypeScript client. So you can go to target types and you can copy these types here. Copy paste them into the client types. So if you now would add in a new function like move up or move sideways or fly, then you would need to build the client, copy the types over and then you can use them in the TypeScript client. The same for C Unity client, which I will show you later. Then here are the different pages.
01:07:48.537 - 01:08:27.533, Speaker A: This is the index page. I will not go too much into detail about the JavaScript part, but you can look at the code here. So you have a use wallet where you get the public key. Then there is a loading state loading right, loading left. So this is like a state for the different buttons so that they have a little spinner in it so you can like can't immediately click it again. Then we have the state which is the ASCII representation of the game with the little O moving over. Then we have here the state game data account which we will fetch and then we will also create a websocket connection for it that I will show you in a bit.
01:08:27.533 - 01:09:00.165, Speaker A: This is how the position is printed. Then we have an effect here which updates the player position whenever the game data account changes. This is a state. Then we have an effect here. The first time we load the game, we will fetch the game data account from this PDA here. PDA is found the same way as in Playground with find program address. Another thing we have here in the anchor typescript is here we create the program.
01:09:00.165 - 01:09:41.027, Speaker A: So this is taking the IDL which I showed you earlier. This type script file here, not exactly this one the program. And yeah, it creates this program. And here's the program ID that you would need to replace if you want to add your own one. Then here we create another wallet. This is only used for the backend API which I will show you later where you can also trigger the move left right instructions without signing. Then here is what happens when we click on get data it does a fetch for the gamedata account and when the data is fetched we set the data in the gamedata account in this state here.
01:09:41.027 - 01:10:24.105, Speaker A: And then when this state changes the position is printed again. Then this is what happens when we click write the same as in Playground methods moverite accounts transaction. And yeah, this is what happens when you are not logged in. Then it will actually call an API which will do this for you in the background. So this is a very nice thing about Next JS apps. If you go to Pages API send transaction API. Then you can see here that there is that there is a burner key pair here and this burner key pair is here in the process ENV environment.
01:10:24.105 - 01:10:47.791, Speaker A: So I have this environment file here which just has a. You should of course never show your private keys to anyone. But this is just a burner key which has a little bit of definite sol in. So I can quickly show you how this looks like I can. Now I can also interact with this game without being locked in. So if I. If I cancel and I'm not locked in, you can see that I still can move.
01:10:47.791 - 01:11:20.937, Speaker A: So and how this works is that it calls an API. So API. I think I brought this earlier. So invalid Transaction API. So now if I point this to the Correct one, we can see that if I call this API here, it should move to the right. See, it works. So, and everyone can now use this API also to interact with our program.
01:11:20.937 - 01:11:46.881, Speaker A: And the trick behind is that the transaction fees are paid in this API by this burner key pair here. So you don't actually need to sign. Yeah, so it gets the instructions either from the query or from the body. And yeah, if it's initialized, it initializes. If it's move right, it's move right. If it's moved, move left, it's move left. So it's the same thing it creates here.
01:11:46.881 - 01:12:34.511, Speaker A: It gets the recent block hash, it sends the transaction with the signer, where the signer is the burner key pair. So yeah, this is this API here. So you just have in your backend you have a key pair that you use to sign for stuff. And you can also use this, for example, to have a partial sign like you sign something in the back end so that you can be sure that the transaction is what you want and then you send it to the client and then the client signs it as well, pays the transaction fees, for example, and sends it off. And here you can also see how you would call that. And now I will do a very quick intro into the Unity game engine. You can get the Unity game engine from unity.com
01:12:34.511 - 01:13:11.625, Speaker A: then you can download the Unity hub and then from there on you can install the newest Unity version. And then you can open the Unity folder in the seven Seas example under Solana game starter kits. So you would go to Solana game starter kits. Then you go to the seven SEAS example and there's a Unity folder in there. And then you open this Unity folder in Unity and then you have all the examples there. So you have the tiny adventure two, you have tiny Adventure and you have of course, seven Seas. So this is a seven Seas game.
01:13:11.625 - 01:13:40.913, Speaker A: So everything is there. And you can do pretty much everything in Unity like you can in JavaScript in the JavaScript web 3js. So you have, you have RPC support. You can create transactions instructions on Unity. You can also Export to Android, iOS, Windows, Switch. So you could theoretically make a game for the Switch which interacts with the blockchain. It's just difficult to send Sol there.
01:13:40.913 - 01:14:27.285, Speaker A: But you could have a QR code which funds your wallet and then you could have a blockchain game on Twitch, for example. On the Switch, for example. And then you have WebGL, Mac Windows, currently supported wallets are the whole wallet adapter for WebGL and on Android I think it's also supporting all wallets. And on iOS currently it's only Phantom using deep links. So if anyone wants to participate, you can add the Soulflare support since I think they have the same deep Link functionality on iOS like Phantom. So if someone feels like participating in the Unity SDK helping the community, this would be maybe a nice first pull request. Then C and JavaScript compared.
01:14:27.285 - 01:15:06.511, Speaker A: So here you can see it's pretty much the same thing. You create, you get the recent blockage, you add the fee payer, you have the instructions. And it's the same in JavaScript just written in C because Unity is C based. And there's also a not Unity implementation which is like Solnette. Actually the Unity SDK is based on the Solnet implementation. And there's also a code Generation tool from BM Research is now maintained by magic block and.net tool install Solana Unity anchor tool.
01:15:06.511 - 01:15:42.435, Speaker A: So you can just install this one in one of your favorite terminals. Let's quickly stop this here. And yeah, so this is how you would install this tool. And then you can run this tool and as an input you put the IDL JSON file and as output you would put the where you want to save the file. So in this case we would. We are in an app. So we want actually we want a new terminal.
01:15:42.435 - 01:16:34.731, Speaker A: We go to program CD program. Why is it wrong? CD program. Okay, I can't write anymore. It's too long already. Okay, so now we paste this in here. And when we are in the program we would go to our folder target target target IDL and then we have here somewhere that JF file. So in target IDL and then we have tiny adventure JSON and for output we put it to target IDL program source code.
01:16:34.731 - 01:17:06.625, Speaker A: So and this now creates us C sharp representation of our game. And this one we can now just copy paste into Unity and use and how this looks like in Unity. Let's look at the tiny adventure service. Here we have the program ID on top. Then we have the game data account. Here we find the Level 1 program address. We do the subscription to the game data account webs via websockets.
01:17:06.625 - 01:17:48.159, Speaker A: This is how you would get the game data. You get account info async from the game data account with the confirmed commitment and the binary encoding as JSON passed. Then you get the game data back and then you can do game data account deserialize from the base 64 decoded data in the account. And this game data account is a part of the tiny adventure Account client that we just generated. So it has everything in there that you need. Like it has the account discriminators, it has deserialize, it has the functions, move left, move right. So here's move right.
01:17:48.159 - 01:18:29.497, Speaker A: This is a move right instruction. So it just creates everything for you. Basically, you don't really need to care about the specific data that is in there. There's an account discriminator, the data that you want to put in. And then when we want to move right, we get the move right instruction, we put in all the accounts, move right accounts, we call on the tiny adventure program, move right with these accounts and the program id, and then we send the instruction in the next block. In this case, there are some transaction servers that I wrote which wraps the transaction so you can nicely show it on the bottom left in the game. But this is how it would look like when you do it manually.
01:18:29.497 - 01:18:51.295, Speaker A: You create a new transaction, add a fee payout, recent block hash signatures. Signatures in this case is empty because it will be filled by the wallet adapter. Then instructions. And then you add your instruction. And you could also add multiple instructions here, like move left, left, move right, or something like this. And move back and forth in one transaction whenever. This would make sense.
01:18:51.295 - 01:19:32.327, Speaker A: Yeah. So this is how it looks like in Unity and Yeah, where you go from here. So if you want to participate, you can, for example, check out the Seven Seas example and add a few more things there. Or like you, I think I said the homework earlier already, right? Yeah. So you take the tiny adventure and you make it so that you move up, down and left and right. So this would be a very good task for the first day and that we will also need on the sixth day when we then look at the implementation of the seven Seas, how we implemented it. So on the sixth day we will go through all the functions and all the features that the game has.
01:19:32.327 - 01:20:08.575, Speaker A: Yeah, thank you very much. Here's a list of all the resources that we went through today. And if you have any questions, drop them below in the comments. And yeah, I hope you're gonna build cool things in the in the next days. And tomorrow you're gonna go and stake your gold. And then this gold you can use in the game to upgrade your pirate ships. And then the day after you will be able to take the gold and have a swap in a swap program and get gold and cannon and rum and the cannon will increase the damage of your ships and rum will make your ships stronger in health.
01:20:08.575 - 01:20:17.935, Speaker A: And then there will also be an arbitrage program and lots more. So I hope you tune in again in the next days and. Yeah, see you next time.
