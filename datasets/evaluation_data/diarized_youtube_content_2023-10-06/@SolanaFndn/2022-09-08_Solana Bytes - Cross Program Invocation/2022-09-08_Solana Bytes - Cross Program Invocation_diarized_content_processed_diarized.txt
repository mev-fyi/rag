00:00:05.600 - 00:00:48.830, Speaker A: Hello everybody. Today we're going to actually cover a pretty simple topic, but it can be really confusing when you first encounter it. So we're going to cover cross program invocations or CPI's. Now all a CPI is, is it's kind of exactly what it sounds like. You're using one program to go invoke another program, right? So hence the cross program invocation term. So what does this really mean? Well, let's say your program is trying to do something that it really can't do, right? Like it needs another program to conduct some operation. What you can do is from your program you can create a new instruction and then go invoke another program on the runtime with that instruction.
00:00:48.830 - 00:02:00.394, Speaker A: And the nice thing is you only have to send one instruction or whatever kind of instructions you have set up for your program and you don't have to actually create the instructions for the other program on your client side. So let's take a look at a CPI in code. So here's a program where we're going to actually use a CPI to create an account which we've seen before from the client side, right? So here's going to be the accounts that we're going to need. And then here, right here with this invoke keyword is actually where we're going to do the CPI, right? So invoke is how you go invoke another program from your program and then this function here from system instruction create account. You can see that this is really just going to return to us an instruction, right? So we use this function pass in the params and we get back an instruction and this instruction is set up exactly the way we would expect, right? So with this instruction we can actually send over that instruction to our other program. And then right here is just a list of accounts that are going to be involved, accounts from our program that we're going to pass to that program and then we just process the result. So check this out guys.
00:02:00.394 - 00:02:39.762, Speaker A: This is our test file here. And as I said, we only need to create the instructions for our program, right? So this is one instruction, it's targeting our program. And nowhere in this test file do we have to create the instructions to send to the system program. Now if we check the logs while we run our test, we can go ahead and see that right here is where we invoke our program, right? This is our program id, the same as up here. And then we have these logs that we created. But then right here, right when we say new public key will be blah blah, blah. You can see we're actually invoking the system program, which makes sense, right? Like that's the invoke keyword, that's exactly what we're doing.
00:02:39.762 - 00:03:37.120, Speaker A: And then it completes its operation and then we return to our program and finish out the rest of the script. So that's how you do it with native, right? So invoke is all you need for native. And then we've got some functions in the rust program library that will help us build instructions that we'll send to different programs. Now with anchor, this looks pretty similar, right? We also have those functions to help us create instructions, but the only difference is anchor uses what's called CPI context, right? And that's really just because anchor has these context structs and they do a lot of like interesting magic behind the scenes with these things. So naturally they set up context for cross programming vacations as well, right? Because this is how anchor programs receive accounts. That's all that really means. And then within CPI context you can set up a new one with the target program and then you can use these embedded structs to actually create the instructions that you need.
00:03:37.120 - 00:04:09.204, Speaker A: And so this is obviously going to be the exact same thing we just did. It's going to be just creating a new account with the system program. But there you have it, guys, cross program invocations, not so scary after all. In fact, these are super powerful because in a lot of use cases, maybe with ownership or some other kind of constraints, your program can't do something. These are exactly what you're going to need to implement in order to get things done later. You, our.
