00:00:23.400 - 00:01:36.422, Speaker A: All right, cool. All right, so today I'm going to be talking about how to build an arbitrage bot on orca. I'm going to keep it pretty light today, and then I'm also going to try and keep some time, maybe five minutes at the end for questions if anyone wants to ask anything. But essentially, how I'm going to structure this today is talk a little bit about orca, the arbitrage strategy that we're going to do, and then also kind of implementation details of the arbitrage. And then at the end, I'm going to dig in a little bit into the kind of implement, essentially the Solana account model and what's actually going on underneath the hood so that you can take all the learnings and generalize it for other arbitrage opportunities. Okay, so how to build an arbitrage bot using Orca's SDK first, what is Orca? It's the most user friendly Dex on Solana. I already said this before, but if you haven't used it before, just go to Orca.
00:01:36.422 - 00:01:55.372, Speaker A: So right now anyone can figure it out. So please use it. But in addition to being the most user friendly Dex on Solana, we have also developed a developer friendly SDK. Right there. We see scuba. He helped develop it. It's great.
00:01:55.372 - 00:02:31.490, Speaker A: It's very user friendly. Go check it out. And we're going to do arbitrage using SDK. So I probably don't have to go over this, but just in case. What is arbitrage? It's essentially just taking profit by finding dislocated markets and then having profit or taking profit in some specific currency. So it could be like Seoul or USDC, whatever. And you can kind of do this right between whatever two markets.
00:02:31.490 - 00:03:14.134, Speaker A: So it could be between a Dex and a sex. It could be between two dexs. Here. I'm going to focus kind of on something that you can do primarily on orca that I think is fairly interesting. So the inspiration for this today is a tweet from my friend Tenxray. Essentially, he found that on saber, you could buy Lidosol for cheaper than actual Sol. So he essentially just borrowed a bunch of soldiers, bought Lidosol on sabre, and then unstaked it, waited till the next epoch, and then made 500 sol in profit.
00:03:14.134 - 00:04:09.008, Speaker A: So, you know, I'll let you figure out how much that is in USC. So there are these real arbitrage opportunities out there. You kind of just have to go find it. And if you can do it programmatically, it can be a lot simpler you don't have to be in front of your screen all day. So kind of based on that, here's the setup. So it's super simple, right? First step, you find the sol msil pair, and then you find any moment when you can buy msoul for cheaper than sol. So there's a bit of a detail here where msoul is, since it's stake Sol is always accruing Sol, and that means that the fair exchange rate between Sol and msoL is always decreasing.
00:04:09.008 - 00:04:56.884, Speaker A: So I think right now one m SOl is worth like 1.0 something sol. So if you find an opportunity where you can buy it for less than the actual cost, then you can make profit by taking that and then unstaking it on marinade. Super simple setup. You can also find more advanced version of this where for example, you can, let's say, go through USDC Msul, but you can do Sol to USDC, USDC to mSoul, and then you unstake msoul. The number of combinations or permutations go on and on. But this is the simplest setup possible.
00:04:56.884 - 00:06:18.594, Speaker A: Okay, so what does the code look like? This is really kind of taken from the readme, and it's really just to showcase how simple the SDK is. So the first few lines were just importing things from typescript decimal. So we're using essentially fixed point math here and Solanaweb3 js actually just to get a temperature check. Who has used the Solana web3 JS library before? Who has written rust Solana code before? Okay, cool. So I think I'll probably breeze through this a little bit because I think it might be pretty straightforward. But essentially line five and six, we're connecting to the production instance of Solana, and then we're getting this Orc object, and then from there we can figure out which pool we want to swap with. And then you decide, ok, what is the input token? It's either a or b.
00:06:18.594 - 00:07:16.976, Speaker A: Here it's Sol. And then how much do you want to trade? And then the first step here is to get a quote. So this is akin to kind of, when you enter a number in the UI, you can get a quote, you can get the amount that you expect to get out, but you can also get the minimum amount that you need to receive before you get a slippage error, which is generally defaulted to 0.1%. So the last line here is you take the quote and then it tells you, okay, what is the expected output amount? So how much do we expect to get? We can use that and then compare that against the, the fair value of MSUl against Sol. And then if it's less, then you can trade. Simple as that. So here, execution.
00:07:16.976 - 00:08:03.260, Speaker A: How does that happen? It's pretty straightforward here as well. So once you get the quote, you have to pass in essentially the, the private key or the wallet instance that is going to sign the signature, essentially like funding the transaction and then funding the input token, the soul. And then you simply call swap, in this case, the payload. So we have two steps here. One is calling swap, and you get the payload, and the second step is execute. The reason why it's set up or split up in two steps is because we want to support both cases. One is when you have the private key in memory and you're signing directly.
00:08:03.260 - 00:08:42.752, Speaker A: The second one is typical for kind of like the web environment where you're connected to Phantom, and then Phantom is doing the signature or the signing process. So we want to be able to pass in the serialized transactions that phantom can do the signing, and then we send it off. And really that's it. So in addition to that, what else is necessary? So we got to figure out what is the fair value? There's a few ways to do this. I think looking at the marinade API, I think you can figure out what is the fair value. And then the second step is the unstaking part. Right.
00:08:42.752 - 00:09:14.354, Speaker A: So step two, we got to unstake, but this is actually pretty. You don't even really need to automate it if you don't want to because you have, I think, a two day window to unstake. So you can kind of just do it manually every two days. But if you want to automate these things, sometimes you don't have the SDK available to you. Right. Sometimes you kind of have to find the instruction interface in rust and then work with that. And sometimes that's non trivial.
00:09:14.354 - 00:10:18.058, Speaker A: So the second part, I'm just going to talk a little bit about what's going on underneath the hood so that you can take these other protocols that don't necessarily have an SDK and then figure out how to interface with it programmatically. I was originally going to use my laptop, but it wasn't working, so I just pasted some code here. So sorry for kind of the resolution being a little messed up, but this is the implementation for the swap function. So if we go back, it's line eight right here. Here is the definition. So I guess before kind of just jumping into this, I think what I'll try and do is like explain the Solana account model in plain English, which tends to be hard to do. But what we're doing here is we are creating an instruction.
00:10:18.058 - 00:11:54.286, Speaker A: So an instruction at the end of day is just a series of bytes that define which program we want to execute, what is the instruction that needs to be executed, and then what are the accounts that have to be passed in, and then what are the instruction arguments? So here I guess we can jump straight to line 155. We have resolve or create associated token address. So what is going on here is when we're doing a swap, what's really happening is we are sending a token from your token account to the pool's token account, and then you're asking the program for the amm to transfer the output token to your token account. But one step that's necessary here is that you need to actually have a token account. And I guess this is where the Solana account comes in. Essentially, anything that you want to do, you need to specify a fixed amount of bytes in the Solana blockchain that you declare that you control. So if you want to own a token, if you want to own a token, you have to essentially say, I want to allocate space in the blockchain to handle these tokens, and then I want the permissions to transfer it to be owned by my private key.
00:11:54.286 - 00:12:54.514, Speaker A: So what's going on here is we're saying if I don't have a token account, create it. If not, just return the existing token account, and then there's another 1169, which is create an approval. So this is akin to ERC 20 approvals, if you are familiar with Ethereum. But this is essentially just granting permission to transfer tokens. And this part is pretty important because it's essentially a security mechanism. This is saying that the most that can be transferred is the specified amount in U 64. And that means that even if you pass pass in this instruction to a malicious program, the most damage you can do is transfer out the amount that you specified.
00:12:54.514 - 00:13:49.702, Speaker A: Otherwise, I think there are essentially alternate ways to pass in these permissions, but they have the potential of essentially taking all of your tokens. And that's what we've been seeing happening in essentially these popular NFT drops where you have these fake accounts. What they're doing is they're asking you to sign your account, and then that essentially gives up a lot of control over your tokens. And then the last step is creating swap instruction. So this is kind of the key part. So I'll dive into that. So there's a ton going on here, but I think kind of understanding this is a nice way of understanding what exactly is going on, right? So kind of something.
00:13:49.702 - 00:14:46.840, Speaker A: One thing that is like unfamiliar or unfamiliar kind of programming paradigm for Solana is that the caller of all these functions have to essentially specify exactly what is being ready from or what it's being written to. So this is pretty different from anything else, like even solidity programming. Solidity programming kind of just, it's really just like specifying what is a contract that you want to execute, and then what are the instruction arguments, and then inside the instruction argument or inside the actual function that is being executed. In the smart contract, it dynamically accesses state from blockchain and then also dynamically reads to state on the blockchain. You can't do that in Solana. And I think that's probably the most important kind of thing to keep in mind when doing Solana programming. You have to say, okay, these are exactly the bytes that I want to read from.
00:14:46.840 - 00:15:31.654, Speaker A: These are exactly the bytes that we want to write to. And that's exactly what's going on here. So if we look at line 533 to line 542, we kind of see essentially everything that we want to do for a swap. So what do we want to do for a swap? Well, first we want to read from the token swap program, which contains all the business logic that is involved in a swap. And then we also want to know about the specific parameters for the pair. Right. And we want to say we want to know.
00:15:31.654 - 00:16:32.012, Speaker A: Okay, so where are the tokens being held for this pair is Sol and msoul. And then what are the permissions that we require? And then one, also pretty important one, although it's kind of minor. Line 540 and 541 is essentially like protocol fees that are being taken out. So the way that RMM works is five bps are being taken out as a fee to go to a separate account. And then that's being essentially used as part of the tokenomics to generate revenue for orca. So, to recap, the first two is essentially just data that is specific for the sole msoul pair, 535. That is essentially the permissions to transfer tokens to the.
00:16:32.012 - 00:17:13.194, Speaker A: Essentially transfer the user's tokens. In this case, it's Sol to the Sol unsol account. Line 537 through 540 is essentially the five tokens accounts that we care about. So that's going to be, um, the user soul, the pool soul, the pools msoul, and the user soul. Uh, and then 541, 540, and 541. We already mentioned, 542 is kind of the business logic for the token program. Um, so I think, uh, kind of like understanding.
00:17:13.194 - 00:18:02.472, Speaker A: Okay. Like, what does each account do? Kind of helps you understand, like, what's actually going on underneath the hood. So if you ever kind of want to see how different programs work in the Solana ecosystem, the best way to do it is to look at the instructions and look at the counts that are being passed in and look at kind of the variables that are being used, and that kind of gives you a sense of how the instructions are working underneath the hood, even if the smart contract is not necessarily open source. So that's something that I would recommend. And, yeah, that's it for today. I'll be around afterwards. So if you have any specific questions, I'm happy to answer them for you, but hopefully you got a better sense for how to do arbitrage on the Solana ecosystem using orca specifically.
00:18:02.472 - 00:18:05.664, Speaker A: Thank you. Thank you.
