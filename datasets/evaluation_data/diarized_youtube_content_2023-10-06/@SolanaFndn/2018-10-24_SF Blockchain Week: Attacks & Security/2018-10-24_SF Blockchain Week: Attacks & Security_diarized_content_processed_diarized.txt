00:00:03.640 - 00:00:04.180, Speaker A: Everyone.
00:00:04.734 - 00:00:59.786, Speaker B: So I am the founder of Solana. It's a high performance blockchain, and this is our kind of latest testnet perf release. We can do about 120,000 transactions per second, steady state, without blowing up and peaks, sometimes around 400 500,000. And these are atomic operations that are cryptographically signed. So the whole thing, either it does or doesn't, it's not batching any of the transactions together. So how do we make this work? This talk is actually about security, but I can give you guys a brief intro about how everything works. So the basic premise, or our basic innovation, isn't in the consensus layer at all.
00:00:59.786 - 00:01:43.786, Speaker B: It's introducing a verifiable delay function into the ledger data structure itself. So a ledger, like every append only ledger, just like proof of work, it's a forking data structure. So this data structure gets split up and is created all over the place by everyone that's trying to compete to append to it. So when you add a VDF into this data structure, it kind of starts acting like a water clock. So imagine water dripping and data rising. In a similar way, this PDF grows a proof of time passing in every branch and every partition of this data structure before consensus. And this sense of time becomes a synchronous clock for the entire network.
00:01:43.786 - 00:02:22.614, Speaker B: So when you have a synchronous clock, you can solve a lot of distributed systems, problems that have been solved, like in the last 40 years. So using the synchronous clock, we can simplify messaging overhead when we need to actually reach consensus. And intuitively, you can think of it this way. Imagine if I send messages to everybody in this room, a bunch of messages, they all arrived out of order. You can actually put them back together in the same order, and you can trust that order of events and more. So you can trust the timestamps in those events and get a sense of time in the network when all those events occurred. You can do that without witnessing them directly by just looking at the timestamps.
00:02:22.614 - 00:02:56.546, Speaker B: And you don't have to talk to each other. You can come to a conclusion about the state of all the active nodes in the network without actually exchanging any information between each other. And then you can optimistically say, hey, this ledger looks okay, I'm going to vote on it. And then you can observe your vote in the future version of the ledger and keep rolling this append only system. So given all that, that's how it works. Basic premise, it's all open source code, Apache 2.0. So please steal our code fixer bugs, and I will be talking about some of those bugs.
00:02:56.546 - 00:03:50.496, Speaker B: So this topic is about security. So I spent most of my career working on mobile operating systems. If you guys ever had a CDMA flip phone, like a Motorola Razr, they ran this os called brew. I was a core brew kernel developer, and this was an os written in c with hand rolled c compatible vtables running in a single address space without memory protection, but with downloadable external applications by untrusted third parties. So how do we make this work? With a lot of blood, sweat and tears and code signing. So in the blockchain, the way I think of this project is I'm building an operating system, the actual state of the chain, like the state machine, that's the kernel, that's what we want to protect. We also want to allow users and applications and everybody to interact with it.
00:03:50.496 - 00:04:28.354, Speaker B: There's a lot of interesting challenges there. So we need to protect users. In just building an operating system, you're not really just building a kernel. You have to build APIs that are secure, like the parity bugs. Some developer accidentally just was experimenting and locked up hundreds of millions of dollars worth of value on Ethereum. Users constantly do the wrong thing. I think if you guys have been paying attention, Antminer had a misconfigured mining node that was censoring transactions on bitcoin.
00:04:28.354 - 00:05:00.668, Speaker B: And people were all up in arms about them trying to attack bitcoin, but this was just a misconfigured node. These are just very simple mistakes that people can make that have huge consequences. And when they're tied to smart contracts, those consequences have huge financial impact. Applications need to be protected from each other and from users. Like the dao hack. This was the first kind of big hack in Ethereum, or the big bug. And this is unintended code.
00:05:00.668 - 00:05:33.838, Speaker B: That was really code is law, right? You build something and then it works in a totally busted way. The other thing is we're building a distributed system, so nodes themselves are a part of the resource we need to protect. Stakes can be slashed, so any kind of system that has slashing, that's an attack vector. Nodes need to actually trust the network. We actually need to boot up and verify that the network we're talking to is the one we expect. So there's attestation. This is a very complicated thing.
00:05:33.838 - 00:06:07.764, Speaker B: No one actually has a really good solution for this. Nodes have to be protected from DDoS. There was again recent bitcoin bug that could have created a denial of service attack. If the miner wanted to spend $80,000 if you're shorting bitcoin, might not be a very large amount of money. The network itself, it's a distributed system. We need to actually protect it from partitions. So the consensus mechanisms actually have to come back together no matter what we do.
00:06:07.764 - 00:06:36.724, Speaker B: We're building a proof of stake system. As far as I'm concerned, these are all still unproven. So there's a lot of challenges to actually decide, like what choices we make, right. And how those will have impact later on, and whether things will actually work. There's a lot of still technical problems to solve also, right. We're building an economy. I'm not an economist and I'm an operating systems engineer.
00:06:36.724 - 00:07:07.934, Speaker B: How do we balance all these things, especially in state based systems, when there's voters, and voters are typically apathetic. I don't know if any of you guys own any stock. I have never voted in any corporate election. So who is going to actually vote in a. In any of these systems is very interesting. I think eos's approach, while on the outside, looks quite broken. 21 validators, right? It's not a decentralized system.
00:07:07.934 - 00:07:58.880, Speaker B: I can only keep track of maybe 20 things. I'm ahead at a time. So simplifying it to a set that a human can actually manage in their brain, I think, is an interesting design choice, because we are still bound in all our design choices by what humans can do. So I don't know if you guys looked at our GitHub or followed any of the instructions for this thing, but we're fast developing projects. We've been open source from day one, so the state of the code base is what it is, so it's fast, and there's a bunch of attack vectors. So I'm going to go over some of the theoretical ones and then show you some actual ones. So this one is like in my compiler course, like back in, I don't know, year 2000.
00:07:58.880 - 00:08:23.214, Speaker B: So date me. This was something my professor talked about. So this is called the Ken Thompson hack. So this was a 1984 ACM Turing award speech. He talks about the worst virus you could build, and this is a virus injected into a compiler. The compiler knows it's compiling the target function of the virus. It knows also when it's compiling itself.
00:08:23.214 - 00:08:49.732, Speaker B: So the source code for the compiler thereafter does not contain any evidence of the virus. So imagine you have a compiler, you're targeting our blockchain we were building in rust. There's only one rust compiler. Somebody can inject this particular vector. Rust is built with itself. The next version of rust does not contain this virus, but the output always does. And it would be extremely hard for us to even detect this.
00:08:49.732 - 00:09:39.624, Speaker B: And this virus could effectively ignore a particular public key when it's doing cryptographic verification. These kind of attack vectors, we're all theoretical in the eighties, but because we live in this distributed economic new world, I think people are going to try them, so it'll be exciting to see what happens. So some other attack vectors. I think the famous phone by XKCD is a $5 wrench simply bashing somebody over the head until they give you the private key. But I think a much simpler one is a bored AWS employee that's like, huh. All these nodes that are running in AWS are all part of this blockchain, and it looks like the whole blockchain is being hosted on AWS. I wonder what will happen if I push this button.
00:09:39.624 - 00:10:44.334, Speaker B: All the code is hosted, or majority of it, for us at least, is hosted on GitHub. So a board employee there could also inject something and we would almost never know. Git does provide some defenses against this, but oftentimes when I do a pull request, I just hard reset because I don't want to deal with whatever messages it gives me. The other interesting thing, blockchains are a virtual machine that are all executing the same instructions, probably in the exact same order of operations. So row Hammer is an attack where you hit the same memory location over and over and over again until you change a memory location that's physically right next to it. So this attack can actually go through a hardware enclave, depending how these enclaves are designed. So if the physical memory is actually next to each other, and I post a contract that hits the same memory location over and over, causes a flush and a write, this could leak over to the state that's right next to this on all the machines that are doing this verification.
00:10:44.334 - 00:11:45.414, Speaker B: Think about it like this one attack can leak and corrupt code in physical memory, and all the computers are supposed to be doing this decentralized verification and validating things. So when all of them sign the state, they all sign the same corrupted state, and the thing goes on and, and nobody notices until they realize there's extra money in somebody's account. So I don't know, did you guys follow readme or any of the instructions? If you actually go to my fork, there's kind of all the answers are there, but you can do that later, kind of go through them. So the state of where we're at is we have a very simple gossip implementation for our network. Are you guys familiar with what gossip is? Gossip is a protocol that's used all over. I think every blockchain probably uses some version of it. For us, we're UDP based written in rust, so we're not using lib P two p.
00:11:45.414 - 00:12:26.168, Speaker B: But our protocol is very simple. You have a table that should map of public keys to node structures. You have an index of when this table was updated, how many times it's been updated, and you have a list of when you updated a particular public key. And you also have a list of when a remote node told you that they updated something. So when you exchange messages, you simply say, hey, remote node, last time I talked to you gave me this update index. Give me all the stuff you've seen since then. So it reduces the overhead of how much data you need to broadcast between nodes to just their latest.
00:12:26.168 - 00:13:06.934, Speaker B: And when you roll up to the latest, you can kind of squash all the other changes. This all works except that these messages should be signed. So if they're not signed, when you ask the remote node, hey, give me information about everybody else that you've seen. They could lie to you, so they can simply munch the data to monkey with you, or they can just give you a totally different view of the network that they want you to see and then you'll start talking to them. So this goes back to the kind of the network attestation problem. So there's a big to do there. These messages should be signed and go through the GPU pipeline for spam filtering and stuff like that.
00:13:06.934 - 00:13:51.784, Speaker B: So that's not implemented. So what you can do with our testnet right now is you can actually mung this data and point it and misconfigure it and kind of take over the network. This is a very simple attack vector, but it's kind of fun because you can actually see it working. So is that at all visible? So really this is all just a way for me to try to get you guys to test our code. So what's hacking? It's really just testing.
00:13:51.864 - 00:13:52.104, Speaker A: Right?
00:13:52.144 - 00:14:39.244, Speaker B: There is a bug. That's the attack vector. You write a test to demonstrate and then you put in the fix. So where is our attack? So in this test we spin up kind of a network of validators, and this is all within your local machine. So you can build up, build your own testnet and your own machine, and then you can start manipulating the data structures that are distributed in this testnet. So after you boot up this network, you can create what? In my test code I call a spy node, just a gossip node that connects to it and discovers the network. And then you can start injecting invalid states.
00:14:39.244 - 00:16:02.874, Speaker B: So when you do this, you get to see that the network doesn't converge, that transactions can effectively start failing because the data that's being replicated is pointing to a dead port. Is this interesting to you guys? So you can configure how many nodes you want to run? Because it's just running on my local MacBook, 20 is plenty to kind of simulate the effects. And this is all written in rust. So we use rust log, which is awesome. And this whole thing is just a simple cargo test. Let's see if the demo gods are on my side today. So right now this is uncommon.
00:16:02.874 - 00:16:43.384, Speaker B: So we should actually see this thing run and converge and do the right thing. And all this test is doing is simply sending some transactions, signed transactions, to a node and verifying that the balances are what you expect. And when you comment the attack vector, you inject some invalid data. This data gets propagated through the network for through gossip, and you will be unable to see the balances actually propagate. And that's a very simple way to host the network. We can come back to this thing while it's compiling.
00:16:45.044 - 00:16:45.904, Speaker A: Jeez.
00:16:54.584 - 00:16:55.764, Speaker B: That'S funny.
00:17:06.344 - 00:17:07.404, Speaker A: That's weird.
00:17:07.784 - 00:17:43.223, Speaker B: That's why it worked right before it got here. Updated the compiler. So yeah, I ran a rust update. So yeah, all these tools are totally automatic. When you run rust update, you download code that you don't really know what it is. It's a compiler that we think we trust. It's kind of interesting and it is an awesome language, but it is the only compiler that there's only one implementation of rust.
00:17:43.223 - 00:18:04.248, Speaker B: So it is very easy for somebody to inject a specific attack vector on projects that are using just that compiler. In building a high performance blockchain, we actually have to make design decisions for performance first, which means complexity. So when things get complicated they are.
00:18:04.256 - 00:18:05.304, Speaker A: Very hard to port.
00:18:05.464 - 00:18:37.484, Speaker B: So I really honestly suspect there will be one implementation of this. And that means that there's only that attack vector. It will always be open because there will probably only be one implementation or rest. So what this thing is doing is just sending balances around and then verifying them against a node that's part of this spun up testnet.
00:18:59.584 - 00:19:00.128, Speaker A: Cool.
00:19:00.216 - 00:19:02.894, Speaker B: So it even failed before that. It.
00:20:19.014 - 00:21:30.746, Speaker A: It, that's really weird.
00:21:30.850 - 00:22:13.904, Speaker B: Okay, so let's see if that thing works. But we can kind of go after the next attack vector. So this is the code that actually does the attack. All it does is put up a node connected the network and start injecting that state. What's cool too, is right now we don't have consensus implemented, so we're implementing it as we speak. So our very, very dumb consensus algorithm is to look at the network and count what everybody else thinks is the leader, without any civil resistance. So you can actually inject a bunch of fake nodes and count and say, I am the leader, right? So you can easily take over the network.
00:22:13.904 - 00:23:08.264, Speaker B: So this is another interesting way to kind of monkey with the network. Again, this would be less likely if we actually verify the messages that are signed. The very simple approach after that is to count by stake late what the network thinks everybody should be pointing to, amongst other approaches. But all those approaches are kind of half measures. The problem we're actually trying to solve with security is this understanding that we can't solve all the problems. We live in a world where all the code we write will have bugs, so we actually need to segment all this code and all these bugs from each other. And how we do this, how we solve an entire class of problems, is for us, we can actually implement a proof of stake enclave.
00:23:08.264 - 00:24:06.402, Speaker B: So going back to our first slide, if you guys remember it, our ledger is a verifiable delay function, so we can actually extract the proof of this time passing as a separate data structure from the actual transactions. It's a very lightweight data structure. The enclave can verify that time is passing in the ledger that's being presented to it very cheaply and very securely. All it's doing is just looking at Shaata 56. This enclave can have a very small amount of code, and this is our hypervisor. This is the smallest thing that actually has security on the line, because when you vote with your stake, you're creating a slashing condition, potentially. So when you can verify this historical record, you can verify the time is passing, you can actually verify that the validator messages you expect are present in this chain at the moment and time that you expect them to.
00:24:06.402 - 00:25:17.374, Speaker B: So when you submit your message, you're doing a very, very small and simple calculation to say that the network I'm observing is actually behaving well and I can submit my message and thus minimize the potential for actually being slashed. So all these bugs like Rohammer and all these other attack vectors become less likely to actually take over this private key that's hosted and controls capital and is actually providing security to the network. So that's, in my mind, very cool. So even if we have bugs in the gossip layer and bugs in these other approaches, you can still do denial of service, you can still bring down the network, but you can't force this enclave to actually vote on something invalid such that it'll get slashed. And that is, I think, a very hard security boundary that we can provide. And what's interesting is that because we have this verifiable delay function as part of the ledger, you're not just implementing a signing oracle where you can throw arbitrary data and trick. This thing can actually verify that the chain that it's signing on is valid and succinct and is derived from the rules of consensus.
00:25:20.554 - 00:25:22.294, Speaker A: Cool. That was it.
00:25:24.434 - 00:25:29.774, Speaker B: You guys have questions? They're very quiet.
00:25:35.114 - 00:25:35.894, Speaker A: Yes.
00:25:36.194 - 00:25:39.530, Speaker C: Explain the spank chain reentrance hack that.
00:25:39.562 - 00:25:47.370, Speaker B: Happened over the weekend. I'm not familiar with it. What happened there was unupdated state within.
00:25:47.442 - 00:25:57.338, Speaker C: A state channel, which caused a recursive function to allow them to remove the ethereum and boost coin from their state channel.
00:25:57.466 - 00:26:14.938, Speaker B: Oh, interesting. Yes. There's a whole other set of problems with doing any kind of cross chain or state channel solutions because there's no way to do at a station or between. Between chains.
00:26:14.986 - 00:26:15.146, Speaker A: Right.
00:26:15.170 - 00:26:25.534, Speaker B: So you have to kind of trust the setup. So, yeah, that's like something I haven't even thought of yet. Anyone else?
00:26:26.714 - 00:26:27.574, Speaker A: Go ahead.
00:26:28.624 - 00:26:43.764, Speaker D: So, one of the promises of Solana is the scalability. What are some security considerations that are likely to come up beyond the scalar?
00:26:45.504 - 00:26:58.164, Speaker B: So, with Dapps, I don't think you need to worry about, like, Ken Thompson attacks. I think those are theoretical still, but I think when there's money in the line, the theory becomes more practical to somebody.
00:26:59.514 - 00:27:00.694, Speaker A: For Dapps.
00:27:02.474 - 00:27:42.642, Speaker B: I think that the attack vectors for dapps are centered. I mean, just beyond the bugs. You have to be careful with the economics, because part of the reason why you want a DaP, right, is you have some token that's representing a resource that's derived that the rules of the Dap kind of derive from and how people can acquire them and kind of spam you, I think, is the real concern with attack vectors there, but also just bugs. So you really want to. Like. The way I think adapts is I think of them as kernel drivers. You want to do the least amount of work in the kernel because that's where all the exploits can occur.
00:27:42.738 - 00:27:43.494, Speaker A: Go ahead.
00:28:12.734 - 00:28:35.114, Speaker B: Yeah. So there's like a rust update in the middle of me working on this. So all you need to do is do as I 64, and that's a cast and it's cool because it's rust, it's a safe cast, so it actually will verify that it'll fit within an I 64. I'll throw an exception, or a virus, because the compiler's been hacked.
00:28:36.894 - 00:28:40.514, Speaker A: Go ahead. Oh yeah, totally.
00:28:57.314 - 00:29:26.034, Speaker B: It doesn't matter. I actually worked on some trust zone stuff back in the day at Qualcomm. You just need some segmentation between. Between the thing that's doing validation and the thing that's actually doing the signing. In theory, you could use like a raspberry PI. I think we're working on SGX as kind of the most likely target because it's available in like a laptop.
00:29:29.974 - 00:29:30.754, Speaker A: Yes.
00:29:37.394 - 00:30:07.582, Speaker B: So I am an operating systems geek, not a cryptography geek. So we pick the simplest VDF that works. There's a lot of very interesting designs if you guys read up on them. So our VDF is just a shout to 56 loop. It's not actually. I think the technical term for VDF has been expanded to imply an asymmetric verification time between generation. For us, the verification time is over how many cores you have.
00:30:07.582 - 00:30:28.794, Speaker B: So modern day GPU, like the ones in your phone, can do somewhere between 50 to thousands of times faster verification. So for us it was really kind of Amdahl's law. When you're two year old's Nvidia card can verify a second and a quarter millisecond. That was good enough.
00:30:30.114 - 00:30:30.930, Speaker A: Go ahead.
00:30:31.082 - 00:30:33.814, Speaker C: Can you talk a little bit about rust? What was the.
00:30:38.274 - 00:31:26.714, Speaker B: Like I mentioned, I spent twelve years working in C, and you just can't do this in C. To have like a structure with a hash map, it'll just take so much work and so many bugs and so many macros. I actually started this project in C for about two weeks. I was making good progress, and then I needed to get some cryptography libraries because I'm not going to implement my own ellipsic curves. So I started thinking about how I'm going to manage libraries in C and the source code, and it just quickly spiraled into me thinking about building a build system and a package manager. And I said, screw this, I'll try this in rost in about a weekend. I was ahead of where I was.
00:31:26.714 - 00:31:47.234, Speaker B: So of Rust has no garbage collector, so you actually can be memory efficient and you understand what memory you're using. So that is important for any time you're doing performance, performance work. Our goal is to actually have Rust as the primary smart contracts language.
00:31:50.654 - 00:31:50.966, Speaker A: And.
00:31:50.990 - 00:32:10.344, Speaker B: We'Re kind of there, you can build stuff and see, and if you can build a program in rust that takes less than 512 bytes of stack. You can actually use it, but there's some toolchain work to actually enable the full suite that still needs to be done.
00:32:20.604 - 00:32:21.124, Speaker A: Cool.
00:32:21.204 - 00:32:24.024, Speaker B: Anyone actually trying to follow the hackathon?
00:32:25.644 - 00:32:26.504, Speaker A: Sweet.
00:32:31.484 - 00:33:27.710, Speaker B: Yeah. So if you look at our GitHub page, there's a readme that covers everything you need to do to actually run a testnet and a demo and actually ping your live testnet and see your transactions there. And I was hoping everybody would do this before they got here, but I suspected that. It's a conference. Right, go ahead. So if you run the demo locally, you don't need to do that, just use localhost. But if you're trying to talk like run a validator node, you need to open UDP ports and kind of poke them through the firewall.
00:33:27.710 - 00:33:31.554, Speaker B: So I'd recommend doing that in like a cloud service or something like that.
00:33:40.294 - 00:33:41.154, Speaker A: Go ahead.
00:33:41.474 - 00:33:44.494, Speaker C: Are you planning to put some docker containers?
00:33:45.834 - 00:33:46.774, Speaker A: So what?
00:33:47.114 - 00:33:49.654, Speaker C: Docker containers, to make it easier.
00:33:50.074 - 00:34:07.630, Speaker B: Oh, to deploy the network. There's a snap, a Linux snap, which kind of wraps everything for you. We haven't had the need to run a full docker thing, but do you.
00:34:07.702 - 00:34:08.314, Speaker A: Sure.
00:34:10.334 - 00:34:45.554, Speaker B: No, it's like an Ubuntu image with Rust. It's fairly easy to deploy. So if you run a validator, we're using GPU's for all the elliptic or verification you actually need access to the GPU's. And Nvidia Docker is very busted, so it's kind of like you can actually run the non GPU version. It'll be pure rust and it'll do like 35,000 transactions per second on the, on my MacBook. But that's not fun. So if you need GPU's, you don't want to use Docker anyways.
00:34:48.374 - 00:34:52.234, Speaker A: Go ahead. Is there any chance you can give us an invite to this board?
00:34:53.974 - 00:37:13.454, Speaker B: Sure, it's a good question. All right, this link will expire one day. Spam or discord. That's where we do all our development. So please be nice. So let's see if this actually worked. Get reset hard.
00:37:13.454 - 00:37:17.544, Speaker B: The period command.
00:37:25.524 - 00:37:26.300, Speaker A: Yeah, go ahead.
00:37:26.332 - 00:37:39.504, Speaker C: While it's running, I'm just wondering, what do you see? What are some security concerns, attacks, issues that you see that are not yet happening and that you would want to protect or start thinking about.
00:37:42.144 - 00:38:14.654, Speaker B: So like, what's been keeping me up is just key management. Like this is like a real problem that. Yeah, just like we're all bad at it. Like even like companies are bad at it, and it's very expensive to actually secure a key in cold storage or any kind of storage. You have to constantly do proof that that key is actually still there. And how do you, what do you do if it's not. Not like, if there is like, you know, a neutron hits that, like, that device and actually, like, creates an error.
00:38:18.994 - 00:38:19.402, Speaker A: Sure.
00:38:19.458 - 00:39:13.730, Speaker B: What if it gets lost? Like, I mean, right? You have to, like, you're effectively guarding gold. So there's like a whole chain of people, and then you have to manage the people. Like, I don't know what this space is gonna do when we actually need to, to deal with this. I think that eventually people just use something like coinbase but have like, wallets that are storing just their kind of $20 worth of crypto because it's what you can afford to lose. But I know, like, do you do your own key management? I do both. Okay, so someone exchanged someone because I worked in hardware. I, like, don't trust the hardware wallets.
00:39:13.730 - 00:39:14.334, Speaker B: Like.
00:39:16.034 - 00:39:17.602, Speaker A: You'D have no idea, right?
00:39:17.658 - 00:39:27.354, Speaker B: You'd have no idea. You have no idea if those, if the self generated keys were actually, like, generated with a secure random source that's not just totally hackable.
00:39:28.894 - 00:39:32.446, Speaker C: There are definitely attacks on random number generators.
00:39:32.510 - 00:39:38.910, Speaker B: Yeah, that would be the easiest vector. And even the company might not even do it maliciously.
00:39:38.942 - 00:39:39.134, Speaker A: Right.
00:39:39.174 - 00:40:41.214, Speaker B: It's just accidental, like misconfigured, like, you know, whatever entropy they're using. There's just so many things can go wrong in that whole chain that I wouldn't trust it. So, yeah, bashing. Bashing your keys and printing out the pieces of paper and storing them in like, safe deposit boxes, probably. I don't know. But yeah, most, I don't have that much crypto, but most of it is in Coinbase. Sadly, in terms of, like, dapps, I think there's a lot of stuff that we haven't really figured out, especially when, when communicating between applications, how that's going to work and whether those channels are secure and how error propagation will go back and actually execute back in the state in a robust way as soon as Ethereum is so slow that we put the smallest amount of stuff on it.
00:40:41.214 - 00:41:04.534, Speaker B: If we have a fast chain, you're going to start putting more and more things on there, and those things are going to get complicated, and those state transitions are going to get more and more complicated, complicated, and it's going to become harder and harder to test. So what do you do in, like, dap? Like, effectively deadlocks, right? Like, there's just so many things get worse as code gets more and more complex.
00:41:08.874 - 00:41:09.234, Speaker A: Cool.
00:41:09.274 - 00:41:10.854, Speaker B: Thank you guys for coming.
