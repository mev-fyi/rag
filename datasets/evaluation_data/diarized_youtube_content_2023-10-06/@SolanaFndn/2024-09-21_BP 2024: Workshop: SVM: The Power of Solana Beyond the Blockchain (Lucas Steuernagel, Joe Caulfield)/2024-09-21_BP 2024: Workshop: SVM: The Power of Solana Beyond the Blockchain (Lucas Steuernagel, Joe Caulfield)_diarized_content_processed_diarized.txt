00:00:03.560 - 00:00:18.325, Speaker A: Hello everyone. We're here today to talk about DSVM and how developers can use it beyond the Solana blockchain. Now I'm Lucas, I'm a software engineer at Anza. I work on compilers and runtime.
00:00:19.025 - 00:00:24.065, Speaker B: And I'm Joe, I work on on chain programs and runtime as well. And we both do spm.
00:00:24.105 - 00:00:24.725, Speaker A: Yeah.
00:00:27.395 - 00:01:01.781, Speaker B: So as you guys know, SVM has been heating up pretty quick. So there's a lot of projects that have been kind of like rising up for all different new use cases and niches to basically use SVM outside of the validator. Right. So here's just like a couple of the teams that you might have heard of. So as you can see, there's a lot of different use cases already that have come up. There's going to be probably more, so some permission environments, a few different kinds of roll ups that maybe roll up to different chains or roll up to Solana, which there's been some debates about already. And then some other stuff too, like ephemeral roll ups.
00:01:01.781 - 00:01:18.745, Speaker B: Right. So like some of these new cool like innovations. But what exactly like is svm? Like what are people like building with and what exactly are they able to do with it? And we're going to talk a little bit about this today, but first we're going to talk about like what is this in the actual validator?
00:01:19.995 - 00:01:59.559, Speaker A: In order for us to understand what the SVM is, we need to understand where it came from. So let's think about how transaction processing pipeline works in Agave. First we have a transaction schedule, decides what transactions can be executed in a batch. And then bank is one of the agave components, loads all the accounts from the database. The transaction processor performs all the checks to make sure the transaction is valid. Then we have a message processor which will serialize all the accounts and pass the data to the virtual machine. And after that happens we have what we call the commit stage.
00:01:59.559 - 00:02:54.065, Speaker A: We backtrack all the results down from the virtual machine to the account cp. So we return to the message processor the program execution result, we deserialize the accounts in the message processor and then the transaction processor verifies that none of the accounts constraints are violated, like balance, lump points, consumed, rent, and even if we return to a read only account, and then if bank decides the transaction are successful, we commit all the results in the database. But we noticed that this is a massive entanglement in our repository and we decided to clean, fix up and build a new product out of that. We call this the Sona virtual machine. The spm, the SVM consists of transaction processor, message processor and the virtual machine. And it connects directly with the account DB and bank.
00:02:59.045 - 00:03:42.945, Speaker B: So this is like a pretty simplistic design of all the things that bank does. I mean there's even more, but you can kind of see that the transaction pipeline that Lucas was just describing is sort of here on the bottom. But then there's like all these other things that if you've ever like had to fork this or use it, you have to kind of just like get rid of. Maybe you need it, but most of the time, you know, you probably don't. So the API that we're going to talk about today actually lets you do like just this. So you can just give it some inputs, you give it a list of transactions, you get that entire pipeline with the cache, like the vm, all these things for free, and then you get some results and you even get some metrics. Right? So this is kind of like the way that we've carved this out of the rest of the runtime.
00:03:42.945 - 00:04:18.895, Speaker B: And like, here's just a low level overview for any of you guys who don't know exactly like what I'm talking about. Like this is what each of these transactions kind of does and looks like. And you can see those components from the SVM right here. So like there's the program ID that's going to be used to load from the cache and it'll eventually come from an account. At some point you got some accounts that are read, some are write and some instruction data. And then the BPF loader is going to load up that executable and the VM is going to be provisioned for you and you'll execute your program right? So you get all of this inside this new API.
00:04:20.675 - 00:05:08.671, Speaker A: And we have the coupled yes we in the Monorepo but now provided as a separate grid. You can just include it in cargo tomo and developers can use from it. It has its own public API and no external dependencies in Agave. And now the question remains, how can we use csvm? So we have a set of items that users need to provide. What if there are overwritten traits you need to implement? Because we made them generic over Agave so anyone can just implement for their needs and to data structures the transaction process environment and the transaction processing configs. But also we have. I'll just go back on the slides.
00:05:08.671 - 00:05:51.633, Speaker A: We also have the items Agave provides, but they are overrideable. So one of the set of built inside can be either built in functions or just built in programs like a system program and state program. And we have sysvars which are variables programs can access during execution. Developers can just import them or develop their own solutions for these. Now the overridden traits, we have two that are the main ones. The first one is a transaction processing callback which is just basically an accounts provider. It has functions for the SCM to retrieve accounts from the database.
00:05:51.633 - 00:06:39.655, Speaker A: I add built in accounts and just check if a set of owners match those of the account. And then the forward graph trait which let us find the relationship between two slots and then the two data structures. The first one is the transaction processing environment. This one contains variables necessary for processing a transaction like the active feature set and how many land ports to charge per signature. We also have the transaction processing config. This is just a set of configurations for how we want to execute the batch of transactions. So some of the settings we have there are if you want to collect logs from the program and if you want to record the return data from the program.
00:06:39.655 - 00:07:13.135, Speaker A: And now what we are calling the SVM is actually the transaction batch processor. This is another data structure. It contains some other things, the CSWire cache and the program cache. And if you want to use the SVM you need to create this data selection in the Rust code. And the SCM entry point is a load and executes sanitized transactions. It has those five arguments. So you need to pass on the callback, transaction processing, callback trade implementation transactions.
00:07:13.135 - 00:07:25.975, Speaker A: You need to process the check results which tells the SPM which transactions are valid for execution. Transaction processing environment transaction processing Configure the two data sources I mentioned in the previous slides.
00:07:27.835 - 00:07:58.675, Speaker B: So what can you build with this? Exactly. You saw some of the examples earlier. These are real live projects that are here probably in this room. And so here's just a couple general examples. The list is honestly bigger, but maybe some off chain services so you can emulate transaction processing outside of the actual protocol. Some light clients, state channels and rollups which we were talking about a little bit earlier subnets so like maybe avalanche and stuff like that. And hopefully in the future some DK proofs.
00:07:58.675 - 00:08:31.505, Speaker B: Some projects are already doing this as well. So this is kind of like what we would like to have as our Anza SVM roadmap. So as we're talking about today, we've decoupled this SVM API which has been super nice to use and soon we want to probably try to do the same thing to the scheduler. And then also we want to have like native support for RIS0 and for ZK proofs, maybe using something else. And then of course we want to have lots of reference implementations for you guys to look at, which one of which we're going to show today. But there's also a few more that you can check out as well.
00:08:32.405 - 00:08:34.305, Speaker A: And now we have a live demo.
00:08:39.845 - 00:09:02.999, Speaker B: So we're going to flip over to a live demo here. But you guys can look at any of our examples already right here. This is just the Agave repo, which most of you should know where it is hopefully. And then you can just go to SVM examples and you can find all the reference examples that we're going to put in there. So there's a couple right now there's an RPC service and then there's this state channel that we're going to go through. But there will be more soon in the future.
00:09:03.167 - 00:09:25.255, Speaker A: Yeah, so if you look at the Agave repository, we can find the svm in the SVM folder we have a Docs folder for documentations. And in the examples folder we're going to talk now about the paintube example, but we also have a PR for another example, which is a JSON RPC server built with the svm.
00:09:27.835 - 00:10:01.545, Speaker B: So basically the way that this example kind of works is this is a pretty straightforward payment channel, which many of you guys might know what this is. But basically this is an off chain environment where two or more parties are going to be allowed to just transact. And this is a simple one. You can actually do this with a lot of different kinds of state changes. But the most simple way you can do it is just token balance changes. So native, solo, token or whatever other token you might be working with. That's the way we lost our demo, but that's what this is going to basically do.
00:10:01.545 - 00:10:48.563, Speaker B: So the people in this channel, like the parties in this channel, will transact with each other. And then at the end right here you can see that that's where like the final resulting balances will settle to the main chain. So as Lucas was talking about earlier, like this trait is one of the like core components you can use to implement and then you can actually like power your like instance of the SVM API. So right here, like I just created this like basic cache that is going to just like pull accounts from rpc. And it's kind of like a really simple dummy implementation. But the point is, this is a custom way to load accounts that I'm just using to implement that trait and give this module a way to Load accounts. You can do this however you want, however it makes sense for whatever it is you're trying to build.
00:10:48.563 - 00:11:28.501, Speaker B: So this is just implementing that trait. And then here is where I'm actually going to bootstrap the processor. So I put it all in this function to make it a little bit easier to call, like, from the internals of the example, but essentially like walking you through what's happening here, like, this is that fork graph trait that we were talking about. It's just a state channel, so there are really no forks. There's no like actually really no blocks or anything like that. So I just mocked this out here. But the actual creation of the processor here, you can see you set this thing up, and then you set it up with the proper fork graph, and then you start configuring, like the runtime environment and you configure the cache.
00:11:28.501 - 00:11:55.495, Speaker B: And so we want to be able to transact with SPL tokens. So here I'm going to actually set up the program cache with the SPL token, like the SPL token program. And so you can get this program binary from like, wherever you want. In this case, I'm just going to get it from the account, like I'm just going to use the callback. And then you set this up with the cache. And then we also want to be able to transfer like actual SOL too. So we're going to add the system program.
00:11:55.495 - 00:12:20.955, Speaker B: And then the token program is owned by the deprecated V2 loader. So we also want to add that. But that's it. That's how you set up the cache, and that's how you set up the processor. And there's even further configurations you can add. We're not even doing sysbars or anything else here, so you can kind of configure this however you want. And then you basically have yourself a working processor that you can use to process transactions.
00:12:24.575 - 00:13:23.115, Speaker A: And now we can take all these components, put them together, and create the entry point for the paid tube. So in this function PayTube process transactions, we create the account loader trade implementation for the transaction processing callback, we create the branch processor, our svm, set up the environment and the configurations. And given the transactions this function receives, we convert them to the SVM format because PageUp needed a slightly different format for the state channel. And then we call the load execute transactions the SVM entry point. We have the results here. And then we call setback, which will set only the account balances in the Solana blockchain. So let's run an example test with SPL tokens.
00:13:23.115 - 00:14:24.343, Speaker A: So in this example, we first create the accounts and the associated token accounts and we start the validator of this accounts. We create our PayTube with again the accounts we just created. And then we define some transactions that we will execute in the state channel. So Bob transfer, Alice transfers to Bob, two tokens. Then Bob transferred five to Will, Alice transfers two to Bob and Will transfers one to Lease. All these transactions are then passed to paychub, process paid to transactions. And what this will do is that we will execute all these transactions in the SCM and then we will only submit to the blockchain the account balances, the minimum set of transactions we need for the accounts to get their final balance.
00:14:24.343 - 00:15:00.635, Speaker A: And at the end of the test, we query the validator to check if the balances are correct. Now if we execute the test, we can show that this is happening. Okay, so here we've got the logs. This is what has happened in DSPM inside paycheck. So there were four transfer instructions and four transactions. And then when we sent in the blockchain, we only have one transaction and three instructions for transfers.
00:15:00.935 - 00:15:49.605, Speaker B: Yeah, and so basically this is like the crux of this innovation here is like you can have a ton of transactions that you might use in a state channel. But as you can see, this is a pretty simple example to go from four to one. But imagine you're going from millions of transactions to a few thousand. You can greatly reduce the costs of settling this information on the L1 until something like a state channel. And as we showed you, this is really all you need to do to set this entire thing up. And with just this bootstrapping method, just using this API, you can literally just bootstrap an entire roll up or anything that you want to do just using these few pretty simple steps and not a very big code base. So you can focus on exactly what it is that you are trying to build and what you are trying to innovate with whatever project it is that you are trying to spin up.
00:15:49.605 - 00:15:51.075, Speaker B: Thanks guys.
