00:00:03.880 - 00:00:46.352, Speaker A: Hello everyone, GMGM. I'm Nick from the Solana foundation devrel team and I'm going to teach you about Solana actions, specifically how to create your own Solana actions. It's actually incredibly easy to create Solana actions because at their core, Solana actions function very, very similar to a typical rest API. And because all you're doing is you're making get and post requests to a server. That server is returning some metadata, that is things like a name, an icon, some descriptions, things like that. And in the end the server is also going to return a signable transaction for the user to ultimately sign with their wallet and send to the blockchain. So I'm going to show you how to actually create these endpoints that use the sauna Actions SDK.
00:00:46.352 - 00:01:03.540, Speaker A: And it's going to be awesome. It's super simple. So let's go ahead and dive in. We're actually going to start from scratch here. We're going to create a brand new next JS app. You can do this in any framework you want. The important thing is the server just needs to be able to respond correctly to cors headers or with core's headers.
00:01:03.540 - 00:01:31.748, Speaker A: And you need to be able to accept get post and option HTTP request. So we're going to go ahead and use the create next app generator here. And I'm going to call this the actions basic project. So we're going to go through and just use all the defaults here. Specifically to note this example I'm going to go through using next JS's app router. You can do the same thing in pages router or fastify express rather any framework you want. It also doesn't have to be JavaScript.
00:01:31.748 - 00:02:12.362, Speaker A: You can do it in rust or any backend language. As long as you can build a rest API in that framework, you can build the Solana actions. I'm going to go ahead and change into this directory here, clear my terminal, and you can see we now have this directory fully set up and ready to go. So first thing I'm going to do here actually is I'm going to create a prettier configuration just to make things look a little bit nicer. And I'm also going to grab a specific icon that I want to use for this and paste this in. So this is just the Solana developers logo here. And within Solana actions you get to specify whatever icon or logo you want displayed with your action.
00:02:12.362 - 00:02:43.136, Speaker A: So I'm just going to display this one. So the first thing we're going to do is we're going to actually install some SDKs and packages within our repo here. Specifically, we're going to use the Solana web3 js, just the standard web3 js that you know and love. And we're going to use the brand new Solana actions SDK so you can go ahead and install them directly from using whatever package manager you want. In this case, we'll just use NPM. So install Solana Web three js and Solana actions. Now that we have those installed, we can go ahead and get started.
00:02:43.136 - 00:03:23.220, Speaker A: So while we're at it here, I'm actually just going to go ahead and run the dev server for this next JS app we're going to run on localhost 3000. So now that we have our dev server running, let's go ahead and create our first HTTP route. So we're going to go ahead and create a new file within the app router directory. So I'm going to call this inside the API directory, call it actions, and we're going to call this memo so memo route ts. And again, if you're not familiar with the next JS app router, this is kind of how you have to structure these. So this particular route will be accessible at our localhost 3000 slash API slash action slash memo. And then we'll be able to make all of our get post and options request to this endpoint.
00:03:23.220 - 00:04:04.262, Speaker A: So we'll go ahead and close this and let's go ahead and build our very first portion of our action. So per the action specification, you have to accept a get any post request. The get request is going to return some basic metadata, and then the post request is going to actually return the transaction. So let's go ahead and build that post request here. And we're going to use some of the helper functions that are built within the Solana actions SDK. So let's go ahead and start that here. So we're going to export a const for the get HTTP method, and this is going to be an arrow function, and we're going to take the request as a parameter.
00:04:04.262 - 00:04:38.390, Speaker A: And again, this is just standard next js app router stuff here. Now we're going to return a response, and our response is always supposed to be a JSON value. So we're going to return JSON. We'll put in an empty string here, and then we're going to actually build this payload. So the specific payload we're going to build is actually, we can actually type it with the Solana actions SDK so we're going to use the action getresponse type here. And this is actually going to be the payload that we're going to return within our JSON. So let's go ahead and take a look at this here.
00:04:38.390 - 00:05:11.738, Speaker A: So we can actually see the type interface for the get response here. We're going to return these values, the icon, title, description label. These are all the minimum required values that you need to return. And I'll show you this really clever way to make it work with your URL correctly, because the icon needs to be an absolute URL. And then this is going to be the basic information that we're going to return. This will be displayed to the user when they actually go to execute your transaction. So let's go ahead and build our payload here.
00:05:11.738 - 00:05:43.080, Speaker A: So the first thing I'm going to do is we're going to create an icon, the HTTPs or HTTP absolute URL for this icon. And I'm going to do this interesting thing here where I'm going to, because I know that this needs to be an absolute URL. I'm actually going to use the URL of the request itself. So that way I always get a valid absolute URL. So I'm actually going to create a double nested URL here using the URL that was provided from the request. And I'm going to do the origin of the URL. And then this finally is going to go to string.
00:05:43.080 - 00:06:14.408, Speaker A: That way this is a correct string. And this image is actually going to be the Solana devs image that I have here. So I'm going to make sure it points to the root of the server Solana devs jpg. And that way I will always get this absolute URL of this image always displayed. So that way whenever someone uses my action, they will always get the correct image. Now a label for this, the label for Solana actions. You can see here, this is actually the button text that's going to be rendered to the user.
00:06:14.408 - 00:06:37.020, Speaker A: So in this example here, we're going to create a very simple memo instruction. So I'm going to make this memo say send memo. And it's just going to send the memo to the chain. And then we can actually view that on chain. The next thing is the description. And this can be whatever you want it to say. We'll just say this is a super simple action.
00:06:37.020 - 00:07:12.942, Speaker A: And then finally we need a title for our payload. You can see we have now satisfied the type because we have a value in here. And we'll just say memo demo now this is the bare minimum you need to actually handle the get request for our action here. Almost actually. The other thing to keep in mind is cors headers. Because the way that actions and blinks work, there's going to be a lot of people that are interacting and making requests from the client side. And the front end you need to make sure that your HTTP endpoints for your get post and your options all support the correct headers.
00:07:12.942 - 00:08:12.330, Speaker A: And within the Solana actions SDK we actually have a constant in here for actions core centers. So these are standard headers that will work out of the box to make it so you can actually accept those values, those requests to your server. So we're going to make sure that we return these headers with every single one of these requests. Now the next thing we need is we need to actually support the option HTTP method because the way that client side requests work with cores within browsers, the pre fetch, the pre simulation in a way for those client side requests, they're going to make an option HTTP method request. So we need to be able to respond to that with the correct headers. If your headers are incorrect or do not accept the origin that they're being called from, then the request will fail and your users will not be able to interact with your action on every single possible endpoint. So for maximum flexibility, what I actually like to do is we will export the options and we're actually just going to make this our get.
00:08:12.330 - 00:08:47.256, Speaker A: So what's actually happening here is we're making it so this exact getvalue, we're just going to return the exact same value. So that way we can always have the correct headers there. Now with our dev server already running, we can go ahead and make HTTP get request to this action endpoint of API actions memo. Actually see some of this data. So within versus code here, I'm actually going to use thunderclient. It's one of the extensions you can install. It's available on the extension store, but it's kind of like postman but just natively within versus code here.
00:08:47.256 - 00:09:13.216, Speaker A: And I could just make those HTTP requests. So you can see I have my localhost 3000 API actions memo. We can go ahead and make a get request. Go ahead and send it. And you can see here we now have these properties just returned in our get request just like any other rest API. So now that we have our get request working, go ahead and close out some of these. The next thing we're going to do is we're going to actually build our transaction within our post request.
00:09:13.216 - 00:10:14.692, Speaker A: So we're going to create a new post request handler. Now within our post request handler. The thing I like to do is I like to wrap the entire thing in a try catch to make sure that I can properly handle all errors. And in the case that any of the code within it triggers an error, it won't fail the actual serverless function. In this case, if you deployed over cell or AWS lambdas or anything, to make sure that we don't have any issues there. So now, every time any possible error occurs within our post handler here, we're always going to return a 400 response and have a JSON value. Now, let's go ahead and actually build that transaction.
00:10:14.692 - 00:10:39.998, Speaker A: So we're going to build a transaction just like any other transaction you would build on Solana. In this case, we're going to build a really, really simple one that just puts a single memo using the SPL memo program, single memo on chain. So let's go ahead and build that. And this is going to be a new transaction from Solana Web through j's. So let's go ahead and build this transaction. So we're going to insert two instructions within this transaction. One of them is going to be a SPL memo instruction.
00:10:39.998 - 00:11:23.666, Speaker A: So we'll go ahead and just paste this in to keep it simple and keep the video faster. And we're going to import our public key from web3, JSDem. And then we're going to create this new instruction, and we need the memo program id, which actually is exported from the Solana actions SDK. And then with that, we now have our very first instruction that we're going to put within our transaction. Now, because of the way that the Solana actions SDK actually works, you're required to have an instruction that is not a memo instruction in it. So we're going to go ahead and add a simple compute unit instruction in here as well. So we're going to import the compute budget program from web3 js, and then we're going to set our compute unit price to micro lamp ports of 1000 just to have a small priority fee.
00:11:23.666 - 00:12:01.532, Speaker A: So we have some instruction that's not just a memo instruction, and I'll touch on why that's important later. So now that we've built our transaction, there's two important things that you need to do. You need to actually set a fee payer for the transaction, because every transaction is required to have a fee payer. Now, per the Solana action specification, the user is always required to sign the transaction. So actually you're going to be provided the user's wallet address within this post request, the body of the post request. So that way you always have the user's wallet address and you can either set them as the fee payer or you can have a gasless relayer. So the user still needs to sign the transaction, but they're not actually going to pay the gas fee.
00:12:01.532 - 00:12:57.712, Speaker A: So if there's some sort of authentication or program on chain that requires their authorization, then they can still sign the transaction to validate the authority keys. So we can go ahead and grab our body text out of the request itself. So we are going to make sure that this is an async function because we need to await it and we can parse the request JSON using standard next js here and we're actually going to get the post request data. This is a type that comes from the actions SDK and it specifies the payload that you're expecting in the body of the post request that comes to your action endpoint. In this case, we only require to have an account. It's going to be the base 58 encoded public key of the account that's expected to sign the transaction. So now that we have the body payload, we still need to validate that the payload is actually valid and specifically the account value that gets sent with this.
00:12:57.712 - 00:13:31.770, Speaker A: So we actually need to validate that the account that is provided is a valid pub key. So this is one way that you could do this. You could grab the body account value, verify that it's a pub key. Because when this new pubkey class goes to run, if this is not a valid pub key, it'll throw an error. And then if an error is thrown we're going to throw a 400 response with our correct cores headers and just simply say that the account was invalid. So now that we have this, we now have our account address that we're going to set as our fee payer. So transaction fee payer equals this value.
00:13:31.770 - 00:14:28.180, Speaker A: Now the last thing that we need for our transaction is to actually get a block hash. So we're going to create a new connection to the blockchain const connection and this is going to be a new connection. And this connection comes from Solana Web three js. And specifically I'm going to use the cluster API URL helper because I'm going to grab a connection to Devnet using the public endpoint. Now, if you're in production, you want to make sure you're using your own production ready production capable RPC endpoints. But since we're only going to be testing here, Devnet public endpoint will be fine. Let's go ahead and set our transaction blockhash, our recent block hash, and we're going to do an await on the connection dot, get latest blockhash and grab the block hash.
00:14:28.180 - 00:15:24.954, Speaker A: So now that we have our recent block hash, we have our fee payer. We can now actually build our post response that's going to be sent back to the user in order to actually perform and execute this transaction, execute our action on chain. So we need to return a new response that is going to be a JSON payload and we're going to go ahead and return another payload value and we're going to also include our headers, our standard cores, action headers. So we're going to go ahead and build this payload now. Now there's a helper function within the Solana actions SDK called create post Response. Now, this post response helper is going to allow you to pass in a transaction any signers that you need and then properly craft the entire payload that you need. That's going to be spec compliant.
00:15:24.954 - 00:16:01.096, Speaker A: So we're going to go ahead and you can take a look at the fields here or the required parameters and arguments for this function. The first one is going to be the fields. So we're going to go ahead and pass in our transaction. And if you have any additional signers that you need, you can pass in signers as an array of all the signers, just like you would when you're signing most transactions. But since we don't have any signers, we'll go ahead and leave that out. Now, if you notice that this payload has an action post response type, we can go ahead and type that to this as well. And for simplicity, we'll also actually take a look at it.
00:16:01.096 - 00:16:39.700, Speaker A: So you can see that per the spec, you're going to return a base 64 encoded serialized transaction. That way on the client side and on the wallet side, they can properly deserialize it and format them and allow the user to sign them. And then if you want to return an optional message to the user after they have actually signed the transaction, this will get displayed to the user in their wallet or on the blink application. So under the hood, this create post response helper function actually does a couple of things. The big thing that it does is it handles all the signers. That allows you to sign the transaction even easier. And it will take this transaction after it's signed, it will serialize it and then it will base 64, encode it and then return it to you.
00:16:39.700 - 00:17:02.488, Speaker A: So that way you're actually getting that proper base 64 encoded transaction that can be sent over the wire and then deserialized by wallets. And that's it. Now we've created our very first action. That's how simple it was. We can go ahead and hop over to our postman style thunder client here. We're going to go ahead and make a post request with an account that is valid. This is my key pair that I have locally here.
00:17:02.488 - 00:17:37.660, Speaker A: And you can see it's this nic six z and the account value, if I hit send on this, you can see we get a transaction return and it's fully base 64 encoded. So now within this response payload here, you can see we have this base 64 encoded transaction that can be serialized and deserialized on the wallet side and the client side, allowing the user to ultimately sign this transaction, send it to the blockchain, and that's it. That's how simple it is to create Solana actions. I hope you found this video helpful and we'll have links to other resources and the actions documentation as well as the actions SDK in the description.
