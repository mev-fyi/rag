00:00:05.280 - 00:01:00.504, Speaker A: The first main agenda items that I want to discuss today is the second project that we're going over, and that's the exchange booth. Yesterday, I dropped the zip file with the spec and the skeleton code into the Discord channel, and I wanted to give a discussion about, like, what this project is and how we can go about designing such a thing. The main motivation behind exchange booth was project one was a very well specced out set of rules, right? We gave you guys an interface. We told you the exact instructions to implement, and we told you exactly what those instructions should do. We even set up an auto grader for you guys. So if you finished your program, you could submit it and we would grade it for you based on the spec that we provided. This spec is a lot more loose, and the goal behind that is we want to give you guys kind of the feel of what it's really like to build a smart contract.
00:01:00.504 - 00:01:39.094, Speaker A: We're taking off the training wheels. This design is going to be entirely on you guys. So whatever pieces of state that you need, that is all stuff that you have to figure out. And the way in which you want to implement the instructions is entirely up to you as well. There won't be a formal autograder, but the staff will be walking around and reviewing your code to get a sense of how you've approached the problem and the progress you made. So with that, I want to give a bit of a discussion of what we're looking for here at a very high level. This exchange booth will work very much like a currency exchange that you might find in an airport.
00:01:39.094 - 00:02:19.734, Speaker A: You have two token types that you want to exchange for one another, and the price of that token is given by some oracle. The hope here was that you could sort of demonstrate the composability aspect of smart contracts by using data that came from your echo program. So, in a sense, that echo program can kind of be used as an oracle where you store information. In this case, that information can be related to the price of two tokens relative to each other. Wanted to go over a really high level overview design. I think in the afternoon today, we can have a more in depth, interactive design discussion. Today we have a lot of chairs situated around the stage.
00:02:19.734 - 00:03:10.514, Speaker A: What I was thinking we can do is in the afternoon, you guys can gather around here and we can whiteboard out some specs for how that struct might actually look and the different design considerations you might make when implementing this contract. But for now, I just want to give a really high level diagram of what we're building here. So we have this exchange booth thing. This is going to allow a number of different features. The main thing is that this is going to store some token accounts that contain two mints. So you have like a mint a and a mint b. There's a user, we'll call him the admin.
00:03:10.514 - 00:04:06.114, Speaker A: This guy's the admin. And the admin can deposit tokens into both of these vaults. This admin also has the ability to withdraw. So red will be withdraw and green will be deposit. The prices of these tokens relative to each other will be determined by some outside account which we often refer to in defi or on blockchain as an oracle. So we'll have some oracle account here which tells me the ratio between a and b. So this is basically just like the price.
00:04:06.114 - 00:05:04.384, Speaker A: You have another user which is just anyone that can interact with this exchange booth and make a trade between mints a and b. And the price is determined by this oracle. So this one say this guy wanted to get some mint a output. Well, how this transaction would look is that the user deposits x tokens of mint b and then the user receives y tokens of mint eight, mint a. And that ratio of like x to y is based on the oracle price. So that oracle price is what determines what the exchange rate is between the two tokens. The way in which you guys can represent this is not super important.
00:05:04.384 - 00:05:37.694, Speaker A: This workshop or this bootcamp is sponsored by pith. So you could use something like pith to represent the oracle price. You could also use something like your echo program. So just a really simple example of how you can use Echo program to represent that oracle price. Is that in your echo buffer? Let's just say that you want to use the authorized buffer, the auth echo. You have some nine bytes that are just metadata. This is just your bump seed and your buffer seed.
00:05:37.694 - 00:06:14.304, Speaker A: Then you have a remaining free amount of data that you can store stuff in. This is just free bytes. What you could do here is you could actually just store the exchange rate. All of this stuff can just be represented as some struct that you write into this free byte section. So one way in which you can implement that oracle component is by populating an authorize echo. So there are going to be a lot of different components of this project. Just going back to this really high level diagram of how things are going to work.
00:06:14.304 - 00:07:17.034, Speaker A: You'll need to create an initialized instruction that creates this exchange with object. This will encode all the state that you need in order to perform any action that the smart object supports. You'll need to allocate accounts for both the mints for the token accounts. These are the vaults that the user will interact with, and you'll also need to find a way to populate an oracle or use a preexisting oracle to fetch the price. Another component that is asked to be supported in the spec is this concept of a fee. So the admin can set a fee for the exchange booth to determine how much above or below the oracle price the trade will actually occur. So if this user were to receive some mint a or try to buy some mint a with mint b, the price that the user would be paying would be slightly higher than the oracle price based on the fee that's set by the admin, which could be just some percentage.
00:07:17.034 - 00:08:08.014, Speaker A: That's the high level diagram. Does anyone have any questions about this program or the spec in general? Yeah, could we pass the mic around? Or if you want to, you can come up here and ask a question. Yeah, thank you. That might be a little bit confusing. The question was, why are these labeled mint a and b? In fact, these are just vaults. So I will change that label to make it more clear. So these are vaults, they'll be represented as just normal token accounts and they contain tokens for a and b? Yes.
00:08:08.014 - 00:08:51.964, Speaker A: Question in the back. Yeah, so I think there are a number of ways to do it. I need to read over the spec to see exactly how we specified it. I think that's part of the design decision, like how you want to implement that fee. One common approach is just to make it a basis points, percentage of the trade volume. That's how a lot of exchanges do it, and I think it makes a lot of sense in this example. That'd be pretty similar to how a lot of the automated market makers on existing blockchains implement the fee structure.
00:08:51.964 - 00:09:50.714, Speaker A: Oh yeah, of course. So the question was like, how should we implement that fee structure? Should that be like a fixed fee that's defined in the contract? Is there like a specific way in which you should implement that protocol? And the answer is that that's really up to the design that the implementer or developer decides to go with. There are many ways to do it and it's really what seems to fit with your design decision in this case. Are there any other questions from the audience regarding just the high level diagram of how this contract will look? Great. So the spec is in the PDF, that's in that zip file that I posted in the channel. We'll have a more in depth discussion on how we can actually design that structure. Later in the afternoon.
00:09:50.714 - 00:10:06.934, Speaker A: That will just probably be a little bit more informal. I can record it, but for the most part, I think I'll just be on a whiteboard and we'll be specking out what structure necessary, what kind of security checks are necessary, and when and why you should use pdas for this particular project.
