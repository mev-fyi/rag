00:00:01.240 - 00:00:09.830, Speaker A: Greg Fitzgerald is the CTO of Solana, and he's going to be our last presentation. And then we'll have a panel.
00:00:09.982 - 00:01:18.214, Speaker B: So scalability is the problem in blockchain to solve this year, and I think Vitalik really said it best. If you tried to build an Uber on unscalable Ethereum, you're screwed. Our blockchain, Solana tries to solve these issues, but then goes another step further. We ask, what is the maximum transaction throughput possible on blockchain? What if the only real constraint was network bandwidth? Could blockchain host the most demanding centralized systems, like the Nasdaq exchange? And that's what we sent out to answer. We found the answer to be yes, but with some changes to the blockchain format. If we added a clock and a few optimizations on how transactions are processed in the transaction pipeline. Excuse me, over here, we could create a blockchain that would allow for over 710,000 transactions per second.
00:01:18.214 - 00:02:06.554, Speaker B: So we'll put that into perspective here. The Nasdaq processes about 500,000 transactions per second. Or we could host something like Google's ad traffic, which comes in at about 350,000 transactions per second, with more than enough room to spare for all of Visa's transactions at peak load. Now, the reason we're able to pull this off is because we've assembled an ideal collection of experts for exactly this task. To build the world's fastest blockchain. We have a veteran team comprised of former Qualcomm systems engineers. Anatoly Akavenko, our CEO, is an expert in distributed systems and operating systems design.
00:02:06.554 - 00:02:43.784, Speaker B: I come from Qualcomm's office of the chief scientist and the LLVM compiler team. And Stephen. Stephen Akridge, our magician with the GPU. Anything in transaction processing that seems expensive, Stephen will split it over 10,000 GPU cores and make it negligible. It's kind of amazing he's right there if anyone's looking for autographs. So 710,000 transactions per second without sharding. How is that possible? It's not just Stephen Hacking on the GPU, though, that has been very significant.
00:02:43.784 - 00:03:44.896, Speaker B: The big innovation, the thing that forced us to define our own blockchain format, is what we call a proof of history. It allows us to implement a whole slew of optimizations, because time is the gold standard of distributed systems. If you have it, optimization is easy. If you don't, you're forced to use more sophisticated algorithms that take longer to execute, like proof of work or the practical version of byzantine fault tolerance. So how do we define time on an adversarial peer to peer network? Well, just like dfinity generates randomness and stores it on chain, we generate a notion of time and store that on chain. We do it by continuously running a SHA 256 hash over itself, forming a chain. Each link in the chain represents a duration of time.
00:03:44.896 - 00:04:26.030, Speaker B: It's like a very small proof of work. By gluing them together, you get a longer duration. And when you put together enough of them that it's more than a typical network latency, you get an upper bound on a voting time right, so you can implement proof of stake. That's not only simpler, it's much faster. The voting rounds are much faster, and that implies a faster finality time. But to get to sub second finality, it's not enough to form consensus quickly. You have to quickly validate these massive blocks of transactions, and you need to quickly replicate them across the network.
00:04:26.030 - 00:05:15.680, Speaker B: So we'll talk about the local processing first. Right out of the gate, we knew that signature verification was going to be a bottleneck, but also that it's this context free operation that we could offload to the GPU. But even after offloading this most expensive operation, there's still a number of additional bottlenecks, such as interacting with the network drivers and managing the data dependencies within smart contracts that limit concurrency. We needed to find a way to keep all hardware busy all the time. That's the network cards, the CPU cores, and all the GPU cores. And to do it, we borrowed a page from cpu design. We created a five stage transaction processor in software.
00:05:15.680 - 00:06:19.900, Speaker B: We call it the TPU, our transaction processing unit. So by the time the TPU starts to send blocks out to the validators, it's already fetched in the next set of packets, verified their signatures, and begun crediting tokens between the GPU parallelization and this five stage pipeline. At any given moment, our TPU can be making progress on over 50,000 transactions simultaneously. And this is all with an off the shelf computer for under $5,000, not some supercomputer. So with the GPU offloading and our pipeline TPU, we have single node performance pretty much covered. The next challenge is to somehow get the blocks from the leader node out to all the validator nodes and to do it in a way that doesn't congest the network and bring throughput to a crawl. For that, we've come up with this replication strategy that we call Avalanche.
00:06:19.900 - 00:07:15.458, Speaker B: With avalanche, we structure the validator nodes into multiple levels where each level is at least twice the size as the one above it. By having this structure, these distinct levels, finality time ends up being proportional to the height of the tree and not the number of nodes in it, which of course, is far greater. So every time the network doubles in size, you'll see a small bump in finality time. But that's it. Log n subsecond finality times at effectively any network size and sense avalanche gives us these amazing scaling process, excuse me, these amazing scaling properties. We've rolled it into our storage solution as well. After validating a block, the network rewards a subset of the nodes that are willing to continue hosting the block.
00:07:15.458 - 00:08:12.144, Speaker B: So, like a torrent network, nobody needs to maintain a full copy of the ledger, but a full copy is always available. Anyone in the network can help store it, and they're rewarded for that service with a portion of the transaction fees. So, what's next for Solana? Our testnet is under active development, and we'll be making our third major release next week. Just to give you an idea of the trajectory that we're on, in our first release, just two months ago, we demonstrated a 7000 transaction per second single node network. And now last month's release, we upped it to 35,000 transactions per second. Next week, we'll be launching our first multinode testnet, and we're expecting it to process well over 100,000 transactions per second. After that, we'll be turning our attention to replication and storage.
00:08:12.144 - 00:08:53.832, Speaker B: And as I mentioned earlier, Avalanche is expected to scale cleanly to 10,000 nodes without degrading finality times. Now we'll prove it. We're aiming to have our full testnet up in June and launch our mainnet by the end of the year. All right, one last thing for application developers. We're going to build you a smart contract platform unlike any other in the blockchain world, one where you choose the language, the one that's best suited for your domain and your expertise. Now, what we currently have is a fairly minimal language tuned for performance. And while we'll continue to support that, what we'll be implementing next is far more general.
00:08:53.832 - 00:09:45.384, Speaker B: It's not a language at all. It's just an interface to a safe execution environment. See, from the network's perspective, it doesn't care about very much of your contract at all. It cares about who you're trying to spend your token, who you're trying to send tokens to, right? From the network's perspective, it's like a black box. Events come in the black box changes state, and when it has acquired enough information, it tells the network where to send the next set of tokens. You should be able to write your contract in any language that targets this safe execution environment. And since we'll be using an LLVM backend to execute these contracts, that means you'll be able to implement your smart contract language in nearly any any mainstream programming language.
00:09:45.384 - 00:10:31.704, Speaker B: You implement the interface, compile it for our environment, you're good to go. Now, in the short term, our existing contract language is fairly expressive, and because it's very small, it's quite straightforward to ensure that it's secure and that it performs well. And because we built it ourselves, it's easy for us to extend for the needs of our early partners. If you'd like to be one of those early partners, to be one of the few that gets custom tailored solutions built into the blockchain, please contact Ellenu to learn more about our blockchain, check out the Solana Whitepaper online. Or if you have any technical questions, please jump in on our Telegram channel. We love what we built and we're more than happy to talk your ear off about it. Thanks everyone.
