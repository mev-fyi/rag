00:00:00.400 - 00:00:09.886, Speaker A: I think we figured. I think we figured it out. Can everyone see us now? They're streaming the video?
00:00:10.030 - 00:00:10.422, Speaker B: Yes.
00:00:10.478 - 00:00:26.034, Speaker A: Okay, cool. I think. Okay, cool, cool. Sorry about that, everyone. We had some technical difficulties. Luckily, I'm not the one building out the blockchain, so. Okay.
00:00:26.034 - 00:00:50.050, Speaker A: Welcome, everyone, to Solana season event. We'll do a super short intro, kind of just jump right into it. This is going to be an intro to the Solana programming model. We have Bartosz, who is one of the core engineers at Solana today. He's just going to walk you all through a to z. Everything you need to know. Starting next week, we're going to be doing open office hours as well.
00:00:50.050 - 00:01:08.194, Speaker A: So we'll be posting those to the Solana season website, and we're going to be doing those over twitch, hopefully with no technical difficulties, where we'll set an hour aside and you'll have a chance to just ask questions directly to one of the core developers. So I think with that, Bartos, you just want to take it over.
00:01:09.654 - 00:01:58.420, Speaker B: Sure. So let's start with screenshare. I guess first I figured I would just, like, talk to people about, like, how you can actually get started just because it's intro and the hackathon is starting only actually in two days. So first you just go here, install Solana Cli. The cool thing about Solana development environment is we try to keep everything fairly straightforward in terms of everything is just plain rust, which is one of the main languages for people to use during the development of the programs. This is how we are calling smart contracts on Solana for people that are coming from other platforms. And you can do everything through CLI, either cargo or Solana.
00:01:58.420 - 00:02:35.314, Speaker B: Just go here, install that, configure your rast environment. This all describes everything pretty well. I will keep posting when I keep talking on the chat. So you can go to this, install CLI, and go from there. The next thing that I wanted to kind of, like, start talking about is in the developing section on, like, how. How programs and how you interact with the blockchain are really structured in Solana. So on the high level, everything on Solana is an account, which is really a, like, important concept to understand.
00:02:35.314 - 00:03:09.918, Speaker B: And I, when I talk with people, it's one of the ones that's kind of, like, tricky at the beginning, because everything is an account. Your program itself is starting an account. Your native soul, as a token, is starting an account, but also your data is stored on an account. The helpful analogy that I like to use here is all the accounts in Solana you can think of them as files. They have certain limitations. So for example, the size of the account, the maximum is like ten megabytes. And if you want to store data in the account, you need to pay for it.
00:03:09.918 - 00:04:00.278, Speaker B: It we have this concept of rent, where you use Solnit token to top the account to effectively pay for rent. If you preload two years worth of rent into an account, the account is then considered rent free and you don't really need to pay for it. Then on the high level, when you want to interact with the blockchain itself, you go through our RPC notes and send transactions is just simple. JSoN RPC that's available through either rust API or JavaScript API that you can call. There is a bunch of community libraries that you can use. I know someone built a cool Java library that you can interact with the RPC nodes as well. There's Python as well, and tons of resources in general how to actually execute transactions on Solana.
00:04:00.278 - 00:05:10.244, Speaker B: Then individual transactions are broken into instructions. And this is, you can think of it as function calls to your program. So the other thing that's important to understand about smart contracts and so on our programs is they don't really hold any state, and that's really an important feature because it allows us to enable, for example, upgradable smart contracts out of the box without any special patterns on them top of it. So what happens is, let's take an example, the token program from Solana program library, which we are calling for short SPL, that represents a token that you can deploy yourself. You can actually do it from command line, you can create new token with a mint, and it doesn't require any rust knowledge. You can just do it straight from the command line, from the JavaScript, your website, which I think is super cool, but it's only possible because you don't need to deploy actually a new program with rust on the chain. But what it implies is you are really reusing the shared code that's deployed in the token program itself.
00:05:10.244 - 00:06:15.202, Speaker B: You can see it on Explorer, so our explorer is@solana.com so you can go here. If you search for token, that will let you find the token program, and that shows you that like how big is the token program that was uploaded by the loader and what's the address of the token program itself? And you can as well see all the instructions that are being executed. So if I click on one of the transactions, you can see what's happening in the transactions itself, how people are minting the tokens and what's happening? So for example, this instruction was not recognized. Someone probably created their custom program and executed a mint instruction with single token. Because Solana programs don't store any state, that implies that you need to pass all the state to it in similar way that you would pass state to the pure function. So at the beginning, when you look at the explorer, it actually lists all the instructions here with the post balances that change as well with the tokens.
00:06:15.202 - 00:07:05.744, Speaker B: So the tokens are kind of separate from the sole balances. So you can think of it, some of those balances here don't change because those are just rent balances on the explorer. So once you move past like understanding the basic, like everything is an account and you want to actually build something. The other useful concept to understand is program derived accounts. And it's a special type of account that doesn't have a private key and it doesn't need to like, it cannot like be, it cannot sign messages from the outside. The only way to sign transactions for the program derived accounts is from the program that really owns that account. And it's really useful to tracking the state of the programs that you are building.
00:07:05.744 - 00:08:45.596, Speaker B: And it's I think one of the hardest concepts to understand at the beginning, like what's the difference really between the program accounts and program derived addresses that programs itself on. But once you understand it, it allows you to create effectively predictable account addresses that can be discovered from outside of the blockchain to look up information that you are looking for and then interact easily with the smart contracts. And I think this is all described here in terms of like when you are executing transactions, you need to think who is signing the specific account, who can change it, and is the account like for example executable. The other thing that once you are building smart contracts, when you are executing it, you cannot actually create new accounts on the fly from the smart contract itself. What's required is you need to allocate a new address before calling the function and then maybe you can allocate the space or you can allocate it before with create account instruction and funding it with Sol. So maybe from there, the good place to look at existing rast programs that we created is Solana program library repository. It contains reference implementations for a bunch of programs that we created, including the token program itself.
00:08:45.596 - 00:09:46.284, Speaker B: So you could potentially take it and modify it, but you could also, you could just use it, like I said before, if you don't want to customize it. There is an AMM implementation. There is borrow lending platform that supports liquidations and multiple markets cross collateral. And there's like other utility programs like Memo program for example, that allows you to add memo to the transaction. So this is usually if you're a rust developer, this is the repository that you want to really start looking at and figuring out how to build a smart contract in Solana. If you are starting from the JavaScript side. On the other side, I created for people that are doing this hackathon, this Dapp scaffold that allows you quickly bootstrap your project with react application and a simple like unopened hello world example in Rust.
00:09:46.284 - 00:10:24.374, Speaker B: The other thing to remember, at least with the smart contracts on Solana, we don't force anyone into specific serialization layer and communication layer between your application and and the application itself. So what happens then is you need to pick what you want to use. You could use Google protocol buffers, you could use Borsch, you could use just serialization provided by Rust. There is a lot of people that started using anchor built by people from serum. It's a great library. I recommend you try it. It's available here Ankara.
00:10:24.374 - 00:11:34.160, Speaker B: It simplifies really the interaction with the smart contracts because it generates the communication layer between your application and the smart contract and simplifies a bunch of boiler plates that you will see sometimes in Solana program library because at the time when we were building it, uncor didn't exist. But also we wanted to keep the list of dependencies fairly small. That was also the guiding principle in this react app. Is it a production ready application that I would deploy? Probably not. Just because it doesn't have a state management library, it doesn't have server side rendering. It's just simplest client side react application created with create react app that you can pull and start running. This also walks you through how you set up your full environment and how you can start interacting with both the hooks that are created here as well as sample client for the program that you can build for Solana program library.
00:11:34.160 - 00:12:24.404, Speaker B: We also have the extensive documentation here. So if you want to read about how do you interact with tokens, how do you create your own token? Again, you don't need to know rust, you can start reading just this documentation and discovers how do you create your own fungible token. You literally just pull this command line from here. Spl token, create token and you have new token. As a developer that's fairly simple. But also for people that are not developers, this makes it super straightforward to actually interact with the tokens and see it's actually easy to use you can then interact with the entities that you created on the blockchain. So the accounts that are created from the token program is actually, you have two types of accounts that are created by the token program.
00:12:24.404 - 00:12:58.244, Speaker B: One is the mint and the other one is the token account. And this is a good example for people to first understand that one program can create multiple types of accounts that that program understands, and they can have different cardinality. If you're coming from like a database world where the mint really is created once for a given token, it tracks the supply of that token and who has the rights to mint it or freeze that mint. And then the token accounts are held by individual token holders to track effectively, who owns different tokens.
00:12:58.404 - 00:13:11.024, Speaker A: Hey Bart, do you want to increase your font size just a little bit? I adjusted the screen. I think that might perfect. If that's better, everyone let us know in the chat, please.
00:13:12.364 - 00:13:14.544, Speaker B: Sorry, guys, I always have the same problem.
00:13:16.204 - 00:13:16.944, Speaker A: One.
00:13:18.044 - 00:13:39.010, Speaker B: Thank you. One more, two more. Okay. Boom. Sorry about that. Yeah, so this allows you to again describes fungible tokens and non fungible tokens as well. So the interesting aspect is the standard for both fungible and non fungible tokens on Solana is actually the same.
00:13:39.010 - 00:15:08.834, Speaker B: The only difference between fungible token and non fungible one is you set decimals to zero, you create supply of one, send it to some account, and freeze that mint. So it shows you really that once you create these programs, they can be highly reusable. And it brings me to the other concept that with token program itself is super interesting. Maybe not so for people that are coming from other blockchains, but if you are coming from outside of the blockchain development world, like tokenization. So when you think about tokenization through the token program, it actually allows you to not only track the list of tokens that people have, but I often think of it as the way to track ownership rights of something and then the API for other programs to interact with between themselves, which is very powerful concept because it allows you to use this very known, well, entity that's supported by the wallets to display to the user that they actually own something, even though it might not have the value, or it's not necessarily tradable immediately on some market and has a very limited supply. And this is where normally non fungible tokens, people associate them with just art that you can read in newspapers. But it's a super powerful concept to indicate to the user that they own something, they can see it in the wallet, and it could be anything.
00:15:08.834 - 00:16:10.332, Speaker B: You could create non fungible token that represents, for example, your car. And then from the smart contract layer, you could think of, for example, options. If you're creating options, you could, you could imagine that specific strike creates a token that can be then traded freely, but it's not necessarily exchangeable for option with a different strike on the same instrument. So it becomes like its own entity and allows them programs like, for example, serum Dex that's available here. Let me just send a link there to, again, rust program. So this is a central limit order book provided by serum and built by serum. And if you build your programs around tokenized assets, you will immediately be able to use these primitives that are available on Solana to interact with other market participants.
00:16:10.332 - 00:17:12.549, Speaker B: You could deploy your own central limit order book from literally just this serum UI where you go at the market at my token, and you could start interacting with it and building on top of it. And this is one of the things that we are super excited at Solana, where composability between those programs and making sure that the interfaces are really straightforward for people to use and to interact both from the JavaScript layer, but also from the rust layer. I also wanted to touch, I guess briefly on the, on the command line before I start answering questions. Sorry, I kind of like, don't keep the track of the questions right now. If you pull that repository, you can really quickly start interacting with it from the JavaScript side. You just start like yarn, yarn start. It will start the application and you will have it available here.
00:17:12.549 - 00:17:56.404, Speaker B: This provides a basic wallet that you can connect. So this integrates with Phantom wallet. Phantom guys did a great job of building a chrome extension on Solana that allows you to interact in a very easy way with the tokens. It's much simpler, in my opinion, than what you have with Metamask, but there's a bunch of other wallets that are available that you can interact with. So this immediately shows you that, hey, I have some Sol available. It interacted with that wallet, and I also exposed like API to give you airdrop of Sol on the Devnet or Testnet that's often useful for development. And then you just start filling the gaps in this specific program.
00:17:56.404 - 00:19:05.488, Speaker B: So I guess from there I can answer a bunch of questions. Okay, let me, yeah, so you could, yeah, I'm trying to pick like questions. There's just like, I didn't keep track, so it's tricky. So the question about custom tokens and customizing the minting operation, like, yeah, sure, technically you could do that. You could take the token program, change it deploy your own and it will work with the ecosystem properly. One thing to consider, most people actually don't do it because what are you trying to achieve when you are customizing the minting process? Usually you want to build maybe some form of vesting schedule, but the reality is you don't need to do that at the minting level. You can do it at the higher level.
00:19:05.488 - 00:19:51.996, Speaker B: Contract that owns the Mint for program derived address. And this is why I was saying the program derived addresses are one of the most important things to understand. And then tokenization, because program direct address can be an authority on demand itself. So that means that the contract or smart contract and program owns then that mint and can like for example, mint more tokens with the, with the schedule. You could really easily build a program on Solana that mimics the like release schedule of like any other, like crypto asset. Sure. So more in terms of like explaining pdas.
00:19:51.996 - 00:20:53.794, Speaker B: So the again, like I said, program derived addresses at the beginning, hard to understand. At the very high level, they are just accounts that program owns. That's the very basic understanding. So if you want to create an account from your program, you could use program derived address for that. The main benefit of using program derived address versus something else is then you can actually create in a predictable way an address, because the address of the program derived accounts is a SHA 256 of multiple components that are provided to it. So you could imagine, let's say I'm creating an auction system and I want to identify each auction by the creator. I could start saying create the auction program with, then hash it with the auction item that I'm trying to sell and maybe which consecutive sell it is.
00:20:53.794 - 00:21:34.704, Speaker B: I'm kind of trying to make it on the fly, so maybe it doesn't make sense. And then you can send it to your program and it can allocate that memory. And that account then is discoverable by other people using that exact same combination of seed phrases that you use to create that address. And they can't then also, like the program itself, can verify that this was created in that way. It's, for example, used in the warm call bridge, which is the bridge between Ethereum and Solana. It supports ERC 20 right now. And there is a team that's working on support for seven to one and 1155 from Ethereum.
00:21:34.704 - 00:22:20.816, Speaker B: And there is also a team that's working on support from other chains. But the way that wormhole bridge uses it is to create a predictable addresses for the mints that the wormhole contract owns. So let's say you have a contract on Ethereum that you want to bridge from Ethereum that has a predictable address. Then the wormhole bridge takes that contract address and creates a program derived account that represents a mint with that contract address. So it's guaranteed that there is only one mint for that one address and you can always discover if it was allocated before. All right, hopefully that answered the question. Yeah, so like SPL token address, sure.
00:22:20.816 - 00:23:15.466, Speaker B: It can be any account that is not allocated yet. So if you create a new account, that's fine. You can use Solana Keygen to generate a key and allocate that account as well to have like a nice name if you want to grind it, or it can be program derived address. The only requirement really is that you are able to actually sign the message that creates that account and that's it. Okay, so in terms of contract execution, yes, Solana charges for executing transactions. The way it's calculated right now is it takes number of signers and just uses a flat fee for all the like for the given transaction. So what that means is we give you a maximum limit of operations that you can execute within instruction.
00:23:15.466 - 00:23:51.322, Speaker B: Right now it's 200,000 operations per instruction and we don't have rebate. So in a sense there is a gas, but it's like it's a flat calculation and we don't rebate if you don't use the limit, like, or you don't hit the limit. So sure. Like SPL token program, like in depth guide. Like really, the documentation for the token program is really extensive. You can really see how it's like working with like creating an accounts wrapping sol. Like wrapping Sol.
00:23:51.322 - 00:24:48.284, Speaker B: At the beginning, when I was interacting with Solana, smart contracts was throwing me off, for example. So maybe it's worth mentioning that in order to create a wrapped cell that behaves like a SPL token, you just create an account and fund the account with rent of the amount that you want to have wrapped and then initialize that account with this predefined mint that's specified here, and that will create a wrapped account. So it's sometimes useful if you're building and interfaces that want to present to the user that they interact with the sole token. But in your contract layer you don't want to have ETH statements between native asset and SPL token. So basically you wrap everything and just interact with the SPL interface. And the way from the JavaScript library, you just execute the create an account, wrap it, and then unwrap it. And because the transactions on Solana are so cheap.
00:24:48.284 - 00:25:20.350, Speaker B: And we don't charge you for operations, we charge you for signers. That will not change really your cost of the transaction. So the max number of accounts that can be passed on the transaction. That's a really good question. And that's one of the things that like, at the beginning was like tripping me. So right now, Solana transactions are limited by UDP frame. So that means you have like 1200 bytes that you can use.
00:25:20.350 - 00:26:02.170, Speaker B: And that means like for the whole transaction. So usually that space is really used by the account addresses. So each account address is 32 bytes. And if you do like graph calculation, that means you can use around like 30 accounts for a given transaction. So not 13, but 330. Like something around that. In terms of the stack limit, those are like arbitrary, I guess, right now, limits that we think are creating a performant environment and protecting the rest of the participants on the blockchain.
00:26:02.170 - 00:26:38.804, Speaker B: Same with operations. Can they be technically increased? Sure. I think this would be up to the validators community to basically vote and like say, hey, we would actually want to use it. There is also technical process that we would need to follow. We had some internal discussions about increasing some of the limits, but nothing concrete right now. Yeah, the randomness question is an interesting one. So right now on Solana, we don't have a VRF that you can use.
00:26:38.804 - 00:27:33.470, Speaker B: And in order to fake randomness, it really depends on the situation. I think some form of commit revolve schemes are ideal. So let's say you have a raffle and you're trying to select a number from zero to 100. You could say that you could randomize it off chain, save it in some account as a hash, and then reveal it after the game that you didn't like, fake the game. And as long as the part like you are not one of the participants that you know how to allocate it like that should be fine. Right now, that's, I think, the most simple one for the. So the only way around the 30 accounts max limit is to split your transactions into multiple transaction.
00:27:33.470 - 00:28:16.730, Speaker B: It's unfortunate. Sometimes it means like you need to go back to the drawing board and rethink how you are interacting with the smart contract. But usually it's doable. It's just like it's kind of a common restriction in distributed systems that you will not have access to the full state. And we just picked this number because it allows us to replicate the state quickly across the network. But if you think in terms of PDA's often will actually help you prevent sending. So many accounts that you need to iterate over because they allow you to pinpoint exactly the account that you need for a given instruction.
00:28:16.730 - 00:29:32.334, Speaker B: So if you are finding yourself hitting transaction size limit, try using PDA's. The other thing that is useful with PDIs that you can find in the scaffold project is you will be able to discover the accounts using the RPC calls when you query get program accounts. So if you go to accounts here, maybe I don't have it here, but one other thing that's different from some other blockchains is it's much easier to discover all the accounts that user owns. So it's kind of similar to get program accounts, but you can get token accounts by owner, pass the id and pass the token program. So this is important. If you create your own token program, for whatever reason, you will need to customize this program id. If you go to this API.
00:29:32.334 - 00:30:15.494, Speaker B: This has similar thing for get program accounts. So basically you pass program id and this returns all program accounts, which is often useful. Yeah, the clock is not good source of randomness. So right now if you don't have an oracle that has a distributed randomness, I think the easiest way really is to go some form of basic commit reveal scheme. I know it doesn't work for all the use cases, but it works for some. So maybe it will help get token accounts by owners index. So it's better to use get token accounts if you need to query accounts by user.
00:30:15.494 - 00:31:20.734, Speaker B: So the last example that's trying like reducing the number of accounts that you need to pass, it's really a specific use case. Once you start hitting like a problem in your specific case, I would say let's cover it during like an office hours where you can actually walk through specific design that you have. And maybe we can come up with a design that will actually work that will not hit instruction limit. You could look also at borrow lending platform where it splits interactions with the contract, where sometimes you can separate what part of your program is permissionless and which one requires permission. And sometimes like that you will be able to reduce set of accounts that are being called. So Python project code in Solana GitHub itself. No, we like Solana officially doesn't maintain the python client, but I know there's a Python community project that community maintains.
00:31:20.734 - 00:32:34.130, Speaker B: So in terms of no, you cannot write a contract that will then somehow limit the amount of accounts that are being passed. Because when you are doing a, a cross program invocation, you can see that in the documentation as well. This is how we are calling if you go to the docs, this describes how to do calling between programs, how to do this, but effectively, once you have the graph of calls, all the accounts need to be known upfront for the whole graph of calls. So it's not like you do the CPI and at that point you discover additional accounts. Now, like at the top level, you need to pass all the accounts that are used throughout the graph. Sure you could, like if you can declare, but even if you declare the addresses in your program itself, they will not be available for you to modify. So sometimes we declare addresses for validation purposes and that's something that's important from the security perspective to check.
00:32:34.130 - 00:33:45.720, Speaker B: For example, hey, is the token account that I'm modifying and actually from the token program, because you could imagine someone deployed their own token program and tries to fake effectively the token account that they own, that is of like totally different type. So you need to ensure that the interactions between your programs are actually owned by the programs that you expect them to own. So usually this is how you would use constants for other accounts, but they still need to be passed explicitly and you just compare them with, with the const that you defined in your rust. All right, let's pick some other questions. Sorry if I missed some. Oh yeah, thanks Dan. I published that link as well.
00:33:45.720 - 00:35:13.204, Speaker B: Okay, so, so I don't want to talk about like quantum computing right now necessarily. I think this is like outside of the like intro to Solana in terms of the like the token list itself and how it's managed. Look, it's like we are not monitoring that repository right now. Frequently, if you are really planning to launch a token that will get big plan for at least a week in advance or more, it will not going to stop or prevent you from actually coding anything. You will be able to interact with the Dex markets and everything. Sure. So the PDA signature, the easiest way to think about it is there is a runtime flag that basically says if the program owns that PDA, that program can set that flag, there is no private key, and then the program will sign that account and you call invoke, sign on the PDA's that the program holds.
00:35:13.204 - 00:36:19.680, Speaker B: Yes, it's. Yeah. So don't answer some of the questions. How would you like. So I'm thinking about this, like how would you issue tokens for people transacting with a program? So you could not. Sure if I understand the question correctly, but let's say if I understand correctly, you want to have a program that basically charges for the usage and then somehow you distribute the tokens, you could have the distribution curve within that program itself that says, hey, every day we release that many tokens and you can call a client method on it and you track slots using a clock. The other way is you could distribute the tokens differently.
00:36:19.680 - 00:37:05.314, Speaker B: Like a cop community I know has the distributor token program that they can basically track the accounts if someone owns and then airdrop on them. So you could use that to distribute that token, and then, so you could reach out to them on discord. And then when you basically subtract or burn those tokens when they hit your program, I think that would be the easiest way. And you could charge a variable amount or a constant amount. All right, let's take maybe five more questions. And then if you have any more specific questions, let's plan for this office hours, just because it's kind of tricky to track all those questions. And.
00:37:05.314 - 00:37:53.106, Speaker B: Sure. So the, in terms of like bugs, that's, that's kind of like security, that the most common security issue that you have with your smart contracts is you didn't validate the inputs. If you look at some of the code in Solana program library, let's go to maybe token swap. So if you go here to the processor. Let's make this bigger. Right. So the structure of the programs is fairly straightforward.
00:37:53.106 - 00:38:28.764, Speaker B: You get this iterator over the accounts. You pull all the accounts that are being passed. This is a list of the accounts ordered. So whenever you are calling, you need to pass all those accounts in order. And then the majority of the code of your program is really like this. Validations, like each instruction will have this long validation section. So often the ones that people are forgetting is like, you need to make sure that the token program that's used is actually the token program that you expect from the, from the constant you want to interact with.
00:38:28.764 - 00:39:14.972, Speaker B: Usually you store it in some top level object. And then when people interact with tokens, you check that. You check if, like, the accounts that are being passed are actually owned by you. And like, all those validations will basically ensure that people cannot spoof the accounts. I think this is the most common source of errors that I've seen. So for cross program invocation, yes, there is a limit right now. The stack depth for cross program invocation is four calls for token transfers.
00:39:14.972 - 00:40:28.914, Speaker B: Yes. Like the best way to think about it, there's like, like four accounts that are really interacting with each other. There's an account, token account, that token program account that stores the code that's executing the code. There is a mint in the transfer case, the mint is read only, and then you have two token accounts and you subtract from one and modify from the other. And as long as the accounts are not overlapping, Solana then can execute multiple transactions in parallel between multiple transfers, for example. And this is important consideration also when you structure the data for your programs, because you don't want to create this guard object that's writable for whatever reason for all the instructions that go to your program, because that will effectively create this bottleneck for speed of execution or throughput. The good example of the design is the Dex market, where each Dex market is kind of independent from each other, and the writable accounts are really like bids and asks and the event queue, and each market has a separate set of those.
00:40:28.914 - 00:41:23.630, Speaker B: So then if you are trading bitcoin to USD and ETH to USD, they are totally independent from each other and can be processed in parallel. Zoom even more. No, the token account balances are not tracked by pdas. Those are just like normal accounts, but they could be. So we have this associated token program that actually creates PDA's that are then given to a user. And the idea there is to have predictable account addresses for a given wallet. The way those pdas are structured is you take the native wallet address and add the mint to it like serum or other tokens like cop, and that will create associated token account for a given user.
00:41:23.630 - 00:43:03.924, Speaker B: So that means that someone can effectively send the COPE or USDC or serum to that wallet, top level wallet address without knowing the specific account address. So you can actually move like change the ownership of the PDA and give it to someone else for like authority that you store. So it's kind of cool. So you should, so the main, the main difference is this really discoverability of the associated token accounts, where you would assume that for a given wallet address, there will be only one serum or cop account, and it's discoverable from outside. If you create a normal token account, which right now we kind of discourage because it, it is not, it's creating basically issues for the wallet users that they need to know the account address you would need to send to that specific account address if you wanted to do a token transfer between the two, but with associated token accounts that can be handled by JavaScript to just discover the account and then send it. All right, so it looks like Dan is replying to some of that. Yeah, I'm kind of getting blind, to be honest.
00:43:03.924 - 00:43:37.378, Speaker B: Okay. Okay, last question, this long one. Here's an example of a use case. So is it easy to monitor transactions on serum and reward users. So, yes, I guess it depends how you want to design it. You could design it in a. So Solana doesn't have events.
00:43:37.378 - 00:44:38.064, Speaker B: So you cannot like, for example, create an event in your program that says on the trade executed in serum Dex, do something with my program. One way is you. I think the one that one way that would work, probably the best would be have some off chain component that tracks the changes or executions on serum and then rewards users for trading. That's one. The other one is you could always modify the interface slightly for serum, but that wouldn't work with the existing deployed markets. Another way is create custom UI that injects, kind of wraps serum and injects special transactions there for the rewards. But I think the way that would work the easiest right now with all the existing serum dexes, if you wanted to create something like that, would be some form of off chain component that tracks the traits and then executes the contract and acts like a crunk.
00:44:38.064 - 00:45:11.556, Speaker B: Okay, so I think we should call it a day, Austin, any other questions, I'm happy to answer them. You can dm me on Twitter or you can go on our discord. We have more people on discord to help with any questions, and we'll be organizing office hours as well to help with specific projects that you have and more detailed questions. But this was fun.
00:45:11.660 - 00:45:12.196, Speaker A: Yeah, we'll be.
00:45:12.220 - 00:45:15.092, Speaker B: And sorry again for the delay. Go ahead, Austin.
00:45:15.188 - 00:45:43.054, Speaker A: I was gonna say we'll be doing a weekly office hours where we'll be able to dig in a little more depth. We're expecting those to be like an hour. But if we have as many folks showed up like we did today, we're happy to extend that out to make sure we can cover all your questions. If you need a meeting, need assistance, go to the Solana discord, Solana.com discord. And we have resource channels set up within the hackathon section where we have folks ready to help you out all day long. So thanks, everyone.
00:45:43.054 - 00:45:46.982, Speaker A: Thanks, everyone for hanging out. And this will be up on the salon YouTube tomorrow.
00:45:47.038 - 00:46:06.914, Speaker B: Maybe one more thing I just remembered. I will try to, like, figure out if we can organize this session maybe next week about, like, oracles. Like, I saw there were some questions about oracles, so there will be something coming out next week. Cool. So just stay patient. Yeah.
00:46:06.954 - 00:46:31.414, Speaker A: Well, if you're looking to get a read on all of the upcoming events, too, we have an events calendar, a public airtable where you can kind of see everything we have scheduled out, and then directly on the Solana season website at Slash hackathon. We have a rolling list of the weekly events, so we'll get that added up and then keep an eye on the Twitter for everything. Okay, I think that's it. Have a good one, everyone.
