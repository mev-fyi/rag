00:00:03.920 - 00:00:55.868, Speaker A: I am Alessandro, I'm with Alex here today, and we work on the runtime team in Solana Labs. In the runtime team we work on compilers, the whole toolchain, LLVM, cargo and all of that. And we also work on the RBPF BPF virtual machine and the code in the validator that invokes the virtual machine, that configures the virtual machine and invokes it as transactions are executed. Today we're going to talk about program runtime v two, which is the next version of this runtime component that we're working on. It's kind of like a very large umbrella project that we've been working on for the past year and that we plan to work on for the coming year at least. So it's a very large project. It involves many implementation detail changes.
00:00:55.868 - 00:01:42.274, Speaker A: So we're going to remove a lot of the technical debt that we have accumulated over the years in the runtime, and at the same time we're going to change some of the public facing APIs exported by the program runtime. Today we're going to cover only this latter part. We don't have time to go into over all the details, but if you want to discuss the details, Alex and I will be around. And also we hang out on the virtual machine channel on Discord. So feel free to reach out and we can discuss details. So the first big change that the new runtime is going to bring is even faster execution. All the heavier features that we implement during the runtime, like a CPI or account reallocation, they're getting rewritten to be a lot more efficient.
00:01:42.274 - 00:02:45.044, Speaker A: Today. They use a lot of actual compute resources, cpu and memory bandwidth and all of that. We are simplifying those a lot, and Alex will go into the details of how we're doing that, but essentially by making them a lot faster, we're also going to be able to remove a lot of the artificial constraints and limits that we have had to put around them. For example, CPI depth right now is very limited. You cannot invoke too many nested programs with CPI, or you cannot relocate too much memory in a transaction just because we do a lot of memory operations. When you reallocate, we're simplifying all of that, which will allow us to make those operations a lot cheaper in terms of ceus, meaning that we will be giving back a lot of compute budget back to developers, and so you will be able to use that budget to implement more complex programs. And also because these operations, they get so much cheaper, we're expecting that composability will be improved, programs will get more complex, and more complex use cases will be able to be implemented on chain.
00:02:45.044 - 00:03:22.422, Speaker A: We're also taking this as an opportunity to fix some of the APIs we expose. Some of our APIs are just not great. We are removing some of the boilerplate that is needed today to write on chain programs. For example, the infamous entry point micro is going away. Entry points are mostly going away entirely. Account info, like all those ugly structures, they're all going away. And yeah, and most importantly, probably we are finally introducing support for generic interfaces.
00:03:22.422 - 00:04:11.068, Speaker A: So today it is possible to have extensible programs. Like for example, the SPL token provides hooks that you can define to sort of influence and modify the behavior of the token program. But it's kind of like another hoc API to extend the program. We're actually building first class support into the language to be able to implement traits and interfaces so that programs can be composed generically. Again, we hope that this will improve compostability. The idea, for example, is that the token program will be rewritten as a set of interfaces and you will be able to plug into whatever behavior you want to modify to apply your own logic. The basic idea is that you will be able to do everything through the regular cargo workflow.
00:04:11.068 - 00:05:05.730, Speaker A: So the idea is that you will be able to build your project. As part of building the project, we will build the bytecode for the program code that you have, as we do today. But also we will build some type info for all the public functions and methods and types that you want to expose to third party programs. And so then those programs will be able to interact with your program using that public API that you have exported, that you have defined. And then you will be able to publish all of this on chain by just running cargo publish. And then on the other end, a program that wants to depend on your APIs and on your program can just go into cargo TOMl can go in the dependencies section and add dependency on your program by just specifying the account address of your program. So you will not need to work to manually create interface APIs, instruction APIs and all of that.
00:05:05.730 - 00:05:57.400, Speaker A: It will all be implicitly done by the tool chain. You will be able to go in cargo tamil, add your dependencies. Then when you build the cargo build system will download the type info that was generated at publish time and it will make that type info available for type checking, linking and everything that is needed in in order for your program to build. So when you build, your program will be dynamically linked. And then when you run it on chain, the program runtime will make sure that the types still match and that linking works, that you're not calling undefined methods and all of that. Now we have a demo, demo of this. The demo does not show the code that we're going to ship or deploy anytime soon.
00:05:57.400 - 00:06:24.714, Speaker A: This is just like a very quick exploratory prototype we did to see if we could actually do this. Most of the credit for the demo goes to Pankaj, who built the registry adapter that you're going to see. I'm going to play a video now. It turns out I cannot stop the video, so I'll try to match the speed at which I recorded the video. Let's see if I can do it. So we're going to define three traits. One that just implements trait provides a trade abstraction.
00:06:24.714 - 00:07:18.346, Speaker A: This is just a very simple toy example of a trade trait that defines only one method that allows moving one value of a type to a destination address at the given price. And then we're going to publish this on chain by just running cargo publish and by specifying to cargo that we want to publish on the software Olana registry. What this does is it deploys on chain. So to verify that that happened, we can dump the public key of the program which is built. And then we're going to put this into the explorer and we're going to verify that it ended up on chain. So we copy the key and we go to the explorer, we put the address in there and we see that just moments ago we deployed this program. This program belongs to loader V four, which is the loader that we use for Prvdo.
00:07:18.346 - 00:07:39.294, Speaker A: It's a new loader we have written for this. Part of this is already implemented. It's already in the monorepo. Next we are going to implement this interface. And so this is the code that implements the interface. It's just like a toy. My NFT example type, which will collect royalties once it's traded.
00:07:39.294 - 00:08:15.520, Speaker A: When the trade method is invoked, it will collect the royalties, pay them to the collector specified in the type, and then it will go on and do the actual trade of the value of the asset. Again, don't focus too much on the code. This is just an example to show you how it works. As you can see, the interface is implemented by just implemented a trade like you would with any other trade. And then finally we see how a caller can invoke this interface. So in the code here, you can see that there is no reference to the Mynft type. This is all generic.
00:08:15.520 - 00:08:58.144, Speaker A: The program works on two addresses, and what it does is it requests the runtime to provide the interface of the source account of an account. That call will fail if the account does not implement the interface, and then it's able to just call the interface on the account. And the way the program can depend on this abstraction is by just going to cargo Toml and adding a dependency on the account. Now what you see there, it's the base 16 version of the account address. That's because it turns out that in cargo toml today you cannot specify an actual account address. But don't mind that in the final version you will have address equals the account address. To specify that you want to depend on something that is on chain.
00:08:58.144 - 00:09:22.754, Speaker A: Yeah, it's cool. And when you build, when you don't make a typo and you build, it downloads everything from the chain, gets the type info, ensures that everything compiles correctly, and then you have your program ready to be deployed. All right, cool. So that's it. Now I'm going to give the stage to Alex. Yeah, it's cool.
00:09:22.794 - 00:09:58.944, Speaker B: Yes, thanks. Thanks. So there are going to be a lot of really big changes, and this is not some small incremental thing, which is really radical. And this is basically the end of the design phase for us. So if you have anything in mind, you have to always want it on the SVM that you think you're missing, and it's not in this presentation. Then come to us later. And how do we even do this? Last year at back point, we announced that move, the programming language, is coming to Solana.
00:09:58.944 - 00:10:52.654, Speaker B: And this year we're announcing that all the features that are move exclusive will be ported to rust as well. So the strong typing system that you have in move is going to apply to everything, to the accounts and to the function signatures. In other words, there's no more need for any decialization of accounts. You can just specify structures and use them as your accounts. You can even export these structures, and other programs can use them as well. Furthermore, the ownership model will become more fine grained. Currently you have one owner per account, which is always the program that created that account.
00:10:52.654 - 00:11:53.788, Speaker B: Now you have one owner per type that's specified. So, so you will be able to where you currently have to reference other accounts, be able to inline them in your structures, and basically the accessing rights will be defined by the type or the program that defined the type. So this increases a lot of the way the composition works, and it all comes down to the way that we change CPI. So CPI currently is really cumbersome. You have to do a lot of setup and teardown, a lot of annoying stux like count metadata and info and assigner and writeable and whatnot. All of that will be hidden in the type system. And you can really use normal function calls to interact with other programs.
00:11:53.788 - 00:12:44.734, Speaker B: So there will be little difference in between internal function calls and external ones. The only real difference is that it's using dynamic linking and how that works. We have already seen how you specify that in the cargo tunnel and the runtime will do the checks for you. So it will verify that if you have an account address and you try to access it and downcast it to a specific height, that is actually the type that's there at this account right now. Otherwise the transaction fails. So the one last thing or the one most important thing that's underlying all of this is how we are doing this. Currently we have one VM instance for every instruction and for every Nassau level in CPI.
00:12:44.734 - 00:13:22.764, Speaker B: And all of that is going away. We're dissolving that into one vm per transaction. So that means we can also share the stack across the entire transaction. We can pass data in between instructions, we can raise all the limits again, the nesting depth will be just a normal function recursion depth. There will be no more length or trace length limit. And one thing I really want you to take home from this presentation is we want to radically rethink how composability works on Solana. So currently CPI is a scary thing.
00:13:22.764 - 00:14:06.014, Speaker B: It's expensive, you have to be really careful with it, and instead we want you to not even think about it anymore. Access. Interact with other programs all the time, call them methods. Don't pass the structures manually anymore, just ask the program to pass it for you. All these things will become possible. So we hope that this is going to knit the community tighter in the ecosystem to increase the composability, and that people will start exposing types and interfaces especially, and others can build on top of that. And this is all now a native feature of the protocol.
00:14:06.014 - 00:14:19.466, Speaker B: This is still upcoming, so it's not finished yet. Like I said, end of the design phase. All you're seeing here are prototypes and we'll be around after I talk. I'm sure you have lots of questions, so come find us, ask us.
00:14:19.570 - 00:14:58.834, Speaker A: One thing we should mention is that all of this is coming and it will run alongside the existing runtime for the foreseeable future. We're not removing support for PRV one. The runtimes will be interoperable, like PRV two will be able to call into PRV one. PRV one will not be able to call into PRV two just because it doesn't have enough info to be able to do that. But yeah, we are breaking APIs in the sense that we're going to provide new APIs, but the existing APIs, they will keep working. So we will give people incentives to upgrade their programs, but we will not just switch the old runtime off. So there will be a very long transition period in which people can upgrade their programs.
00:14:58.834 - 00:15:01.354, Speaker A: Programs. And that is it. Thank you so much.
