00:00:05.520 - 00:00:07.994, Speaker A: Rishi Manche, welcome to validated.
00:00:08.814 - 00:00:12.034, Speaker B: Be here. Thanks for having me, Austin. Been watching these for a while.
00:00:12.574 - 00:01:13.052, Speaker A: Awesome. Well, we're going to talk a bunch today about blockchains, programming languages, move, but sort of to give a little bit of a scene set for years, the smart contract language to program in was solidity. This was the primary language that people programmed in on Ethereum, even though there were sort of a few other options available if you looked hard enough. It seems like many new blockchains that have launched since Ethereum have tried to innovate in part on the language, and that sometimes by creating an entirely new programming language and new framework, that sometimes doing like what Solana does and adopt c and rust as two major programming languages and then build custom abstraction layers on top of that. Like anchor is. Um, but there's also been a lot of attention recently to the language of Move. And move was not specifically developed for blockchains or for smart contracts initially.
00:01:13.052 - 00:01:40.864, Speaker A: Um, but it was pioneered partially at Facebook and partially associated with the Libra project, which became the diem project, which became canceled, unfortunately. Um, but you hear from, from movement labs, um, you guys are a big fan of move, so I want to talk a little bit about what you guys do, what's interesting about move, and sort of where the reality of move and maybe the hype of move either match up or don't match up from the developer standpoint. So let's get into it.
00:01:41.244 - 00:02:17.088, Speaker B: I kick off the origin story. So I've been coding since 14 from Bridgewater, New Jersey, which is like my hometown. So always tinkering around with ROS based programming languages. I think I first started stomach cross ros for gaming purposes, um, back in like, like World War Caf days. Um, and then when I kind of got to crypto, I was really intrigued by all these star guys. Everyone started off coding Ethereum, um, dapps and Ethereum, main exploration. Um, but the main struggle that I faced is that it's very difficult to code solidity and more importantly, difficult to code secure code.
00:02:17.088 - 00:02:56.726, Speaker B: It took me hours, and I'm not even the best programmer. I would say like a mid tier, I would say like c tier. Uh, it took me hours and days to like, debug and to make sure each line there's already, there was no integer overflows. I was spending more time auditing my code than I was spending developing my code, which was at the time as a college kid, was very difficult and a hindrance to me because I couldn't develop this consumer app that I wanted to scale from zero to one. If I was worrying about smart contract functionality. And ultimately, we're all encrypted, not for the stablecoin and defi use cases, but we want to be infrastructure that powers billions of users. We want the gaming, the consumer, really the retail focused apps.
00:02:56.726 - 00:03:20.062, Speaker B: So I think that was the first thing that kind of struck out to me, is I was spending more time on smart contract security than I was on an actual interface from an app and acquiring customers from app, which in web two, doesn't exist. Zuckerberg was able to build Facebook from his dorm room. He wasn't worrying about if Facebook got hacked. He was more worried about getting his app across Harvard. Right. So that was the first kind of major, like, okay, this needs to change.
00:03:20.198 - 00:03:20.566, Speaker C: Sure.
00:03:20.630 - 00:03:42.034, Speaker A: There's also just a lower risk, too. Right. Because if. If you have a web two social app that has, you know, 10,000 users and it gets hacked, the worst that happens is probably a bunch of people's pictures get changed. But in blockchain, everything is financial. And also, there is no off button. Like, once you deploy a contract, it is deployed, and good luck.
00:03:42.414 - 00:03:44.390, Speaker B: Yeah, I think there's also reputation based.
00:03:44.422 - 00:03:44.566, Speaker C: Right.
00:03:44.590 - 00:03:57.354, Speaker B: Like, if Facebook got hacked in, stuck with Dave, they'd be like, okay, like, you just lost, like, three pictures. Like, when stars aren't got hacked, that was like a two day project that went viral over a day. They got hacked in a week and lost all their consumers, and now it's basically dead.
00:03:57.434 - 00:03:57.698, Speaker C: Yeah.
00:03:57.746 - 00:04:06.786, Speaker B: Um, so financial security is very important because if you get hacked, you basically lose all credibility you have and lose all your customer base overnight. Um, which is not a web two concept.
00:04:06.930 - 00:04:07.490, Speaker C: Yeah.
00:04:07.602 - 00:04:20.142, Speaker A: So, uh, yeah, fast. Fast forward a little bit to, like, where did you first learn about move? What sort of caught your eye as this being a language that was more in keeping with what you were looking for?
00:04:20.338 - 00:04:21.926, Speaker C: Yeah, I think I saw a Twitter thread.
00:04:21.990 - 00:05:09.774, Speaker B: Like, I was, like, two years back about the Deon project and then hearing it expanded because I was like, Facebook, the biggest consumer app in the world, like, the biggest social network in the world, looked at blockchains, and it was like, the evm is God awful. And it spent a billion dollars in research to bring the move language. So seeing the article kind of got me looking to the move programming language, hearing about app just to launch, I would say, August of 2022. So pre FTX was really looking at, okay, this is a really interesting framework, interesting language. Spent a lot of time looking at the moop prover and Wolfgang, who's kind of the head of move over there appdoslabs putting a lot of research on Moop prover and formal verification. And to me that was very interesting. Right, like this was the first time where I felt I could deploy smart contracts and not worry about security, instead worry about the actual use case of a smart contract.
00:05:09.774 - 00:05:28.982, Speaker B: So I was actually injured in Aptos early on. I was one of the first 1015 builders in space. I was contributing to the first Dexlink system. My co founder built the first yield aggregator. So we were two of the earliest grassroots builders of the movie system. And yeah, I think from there we were really looking to expand the move reach to other e systems, which ill get more into.
00:05:29.118 - 00:06:29.136, Speaker A: Yeah, so I want to go back a little bit to that move origin because a bunch of the code that was part of the Libra and diem ecosystem, and I worked a little bit on that stuff at Bison trails when I was there, because we were Aaron Henshaw, the co founder and CTO, there was part of the technical steering committee behind Libra and Diem. But we got to a place with this where the project was shutting down, but the code was all open source. And so there were sort of two teams that I believe kind of started working together initially and then split off from them. And so you actually have Aptos, which my understanding is they took a lot of the existing Libra code and they built it into the Apdos network. Today in the SUI network, that didn't necessarily start on the same codebase, but started from a lot of the same ideological underpinnings. And they both have move as the VM language they use. But there's some pretty interesting differences between both of those move implementations.
00:06:29.136 - 00:06:38.280, Speaker A: So do we sort of have two versions of move at this point, or are they still pretty similar from a developer perspective, even if under the hood the VMS work pretty different?
00:06:38.432 - 00:07:07.176, Speaker B: Yeah, I would say the languages are completely different. Aptos move is like diem project, essentially staying in line with the DM principles. For example, the move proverbs built into the VM, which was kind of a core principle of the DM project, while Sumove is more correlated to the consensus mechanisms. So I would say Sumove is tied to Dagweed's consensus and improvements. They were made over there. Aptos was focused more on the direct VM itself, and now they're doing consensus improvements. So I would say they're completely different kind of frameworks.
00:07:07.176 - 00:07:26.136, Speaker B: I would even argue it's similar to JavaScript, where you have react vue angular still frameworks of JavaScript. So if you're a react developer vue, it takes probably a week to learn it. Same thing with Aptos move and suite move. There's still versions of rust. So if you know Aptos move, you probably know suite move. But there are different frameworks.
00:07:26.160 - 00:08:09.800, Speaker A: Fundamentally, the way we originally met and got connected was around this sort of vision for movement labs, which is trying to propagate move to multiple blockchains. And part of the way that Solana is built is that things actually, you're not running a rust native program, you're not running a cnative program. These things all compile down. And without getting too technical at the end, a lot of it's just LLVM. And so that means you can build a front end for pretty much any programming language out there. And so as move was starting to get some attention, there was a project at Solana Labs to work at looking at bringing move support. And then you guys reached out about also getting involved with bringing move to Solana.
00:08:09.800 - 00:08:26.432, Speaker A: So I want to talk a little bit about that work. But as a starter, what sort of inspired you and your co founder to say, look, the impact we want to make in the blockchain space is not necessarily building apps ourselves, but building move across a broader ecosystem.
00:08:26.608 - 00:09:00.646, Speaker B: I think it comes down to the use case building the first DeX and app desk pre FTX and eventually post FTX. There was two assets on the Dex. It was apt and Tesla Tala, which made the Dex not that attractive, especially when the crash happened. So we took a step back and was like, okay, we believe in move as a thesis, like form modification, security, parallelization, great stuff, but want to bring it to adoption and bring it to web3 native today. So the ultimate solution was m two. The first move L2 on Ethereum. So think of all the benefits of Aptos and Sui fully living on ethereum security as L2.
00:09:00.646 - 00:09:29.416, Speaker B: So that same dex that had two assets and a cold start problem on top of Aptos now can deploy. On top of m two, you have native ETH directly. The e system were fully IBC enabled. So you have TIa atom, you actually have USDC off the bat from Noble as well as you have full eVM assets. So we actually have EVM runtime. It lives on top of the move virtual machine. So any evm code can run right now, which provides backwards compatibility and legacy code support, similar to what you guys are doing with neon and slowing.
00:09:29.416 - 00:09:33.152, Speaker B: That's the approach that we're rolling out in house for the move virtual machine.
00:09:33.328 - 00:09:34.044, Speaker C: Nice.
00:09:34.544 - 00:09:53.524, Speaker A: How is that process been of going to a bunch of EVM devs building on Ethereum and saying, hey, there's actually, you can still build on Ethereum, but you actually now are using move like, because I know there's a lot of solidity allegiance in the EVM world.
00:09:53.684 - 00:10:33.288, Speaker B: Yeah, I think this is a cold start problem, right? If you have an app that's like, what, 10 million tbo, it's all in smart contracts. The kind of the friction to get. I'm sure you guys have experienced that too. The friction to convert to rust based code basis is very difficult. A, because rust engineers are really, really expensive, and b, um, it's just like you have to completely scrap all the work you've done and rewrite new code bases, um, which for projects in the bear was very difficult. Now that market's kind of warming up, and especially if the paralyzed EVM trend is to market, and people are saying, like, the benefits of parallelization are really cool. So, like, monads say these groups are propagating, um, the benefits of like local XP markets, um, and parallelization.
00:10:33.288 - 00:10:49.544, Speaker B: For the EVM, we're talking a lot of order books and defi projects and gaming projects that have now converted to writing slowly on top of our mood base. Because you have all benefits of parallelization. You live in Ethereum for security. So for them, the pitch six months ago probably didn't make sense, but now it does.
00:10:50.044 - 00:11:16.894, Speaker A: So walk me through a little bit of how that works, because one of the challenges with parallelizing EVM has always been that ETH transactions are not deterministic in terms of all the state. You can't actually simulate an ethereum transaction and know for certainty this is all the state it's going to touch. So when you're dealing with an interpolation layer to then get that down to move, is there an overhead there for it? Guessing wrong sometimes? Or how does that system actually work?
00:11:17.274 - 00:11:45.340, Speaker B: So we still retain the same DM rich machine. So you have the block STM pattern built into the VM. So it's still optimistic realization from the Aptos project. What we built on top of the movie VM is essentially an interpreter that's eventually converted to a transpiler. I'm not going to get the technical differences, but basically you have opcode compatibility for solidity to move. So if you write smart contracts, it's like 142 opcodes, I believe. You map it to the 54 opcodes and invoke functions of moviem.
00:11:45.340 - 00:11:53.396, Speaker B: So the end state is essentially the same fail processing that you see an app does. It's just that you have the slowly opcodes mapped on top.
00:11:53.500 - 00:12:02.010, Speaker A: Yeah, this is basically what Android did with Oracle and kind of got into a, in that case many years lawsuit and in this case probably no lawsuits since it's all open source because open.
00:12:02.042 - 00:12:05.334, Speaker B: Source, hopefully no lawsuit at the foundation.
00:12:07.474 - 00:12:31.604, Speaker A: But yeah. So that's like an interesting and interesting structure that you guys are kind of going with there. Do you see that as kind of the main way you expect a move to get adopted is through transposing and compiling from solidity as a runtime and then using move on the runtime? Or are you guys more focused on actually getting more developers natively building in move?
00:12:32.664 - 00:13:13.212, Speaker B: I think for us the way this even compatibility is just a short term fix. The long term and three to four year bet is move adoption. We believe that Facebook, the language built by Facebook now guided by both Apples and Sui over the next 34 years, is going to thrive a, for financial reasons and b, just in terms of technological reasons. But to face it, most of the developers, and if not like the 90% developers, are so slowly developers today. And the issue with next gen tech stacks is lack of legacy code adoption. So just because you have PS five, if you don't have any games that work on PS four, it makes it difficult for users to actually use the PS five. So that's why we are looking at like, we believe the developer is going to switch to move, switch next gen languages and frameworks.
00:13:13.212 - 00:13:37.802, Speaker B: But you still need to have EVM compatibility for existing legacy code. Otherwise you're going to have a hard time bootstrapping network. And then once you have network, once you have TVL liquidity and you have the snowball effect where you can attract more users, that's when you can like usher in new developers to move. But we're still quite frankly early from that, still early stages. You guys saw the early stages of Solana. It's very difficult to get people write Solana VM code and we're just getting started.
00:13:37.978 - 00:14:22.098, Speaker A: Yeah, I mean the thing Solana had to do in the early days was be a thousand times faster than the EVM because no one would sort of give the language and the, not the language, but give the VM style and the VM differences any. Look, unless you could say, look, you're going to get 1000 to 10,000 x performance increase by doing this, it fundamentally changes what you can build. So if you're sort of in that situation where you've got a developer that maybe they're building in solidity now, maybe they're building in rust maybe they're something like that even. What is that sort of value proposition to say, hey, move is worth your time learning and switching over to, I.
00:14:22.106 - 00:14:43.228, Speaker B: Would say, addition to the paralyzation speed pitch. I think similar to a slot in thesis, I think the security is a paramount thing. Security comes out of the box with move, you have move approval and form verification built into the VM. So when I was coding solidity and even coding rust back in the day, if I was able to use move, I'd probably reduce my developer time by like, one third to one fourth.
00:14:43.316 - 00:14:43.516, Speaker C: Yeah.
00:14:43.540 - 00:15:03.036, Speaker A: So I want to talk a little bit about what, like, where actually you're seeing move get more security because the EVM is formal verification. Provers exist on other networks too. So, like, I just want to get a little more granular when you're talking about, like, because this is the thing you hear a lot is, oh, move has great security. What does that actually mean when you're coding?
00:15:03.220 - 00:15:03.644, Speaker C: Yep.
00:15:03.684 - 00:15:43.750, Speaker B: So it's in the VM itself. You have a bytecode interpreter and bytecode verifier. So execute smart contract, the move prover essentially looks at each line and says, hey, is there debug? Is there a digital overflow? Did you mess up somewhere? So you actually have the auditing like effect the auditors do, like, after correction in real time. So every time execute smart contract, it checks for these resource type of memory safety. When you actually look at a history of attacks, it's not off the first deployment. So if you look at the Kyber attack, it was actually like the 50th push or the 54th push made by random developer that they forgot to check one line and that costed Kyber the entirety of their portfolio. Right.
00:15:43.750 - 00:16:09.676, Speaker B: I think the curve attack, it's usually the small error that I think for Kyber, it was 0.001% probability that anyone could pick it up that no human or auditor can pick up, usually by hand. I think 92% of EVM protocols are at risk of being hacked. Move fixes that by running each code and running for verification at runtime. So essentially, you have auditor working for you in real time instead of waiting to do it after, which is usually the downfall for these EVM projects.
00:16:09.820 - 00:16:27.124, Speaker A: So, for example, if you're a developer and you're deploying something and there's an error in it, what happens? Does the program deploy fail? Does the program just refuse to execute on mainnet? Now, what does that failure state look like?
00:16:27.544 - 00:16:31.192, Speaker B: It'll toss a compiler flag and be like, you messed up like this line.
00:16:31.288 - 00:16:36.704, Speaker A: Oh, it's in the compiler stage, not. Okay, I thought you. Sorry, I thought you meant like in the VM stage when it was deployed.
00:16:36.864 - 00:16:37.808, Speaker C: Yeah, yeah.
00:16:37.896 - 00:17:00.904, Speaker B: So this is like multiple areas. They have compiler flags that you can add on. I think even like, arbitrage does this with EVM. There's also VM errors that can flag, so you kind of errors in multiple stages. And we're also working on throwing more compiler flags so you can get picked up earlier. Because I think, like, right now it's like 90% more secure than EVM. And now adding more compiler detection actually brings it up to higher percentages.
00:17:01.284 - 00:17:32.901, Speaker A: Yeah. It's interesting to think about this stuff, especially in the context of AI, both auditing and attacking of code bases. Now, I do think there's a little bit of a reckoning for the open source community on how do we actually start responding to this sort of stuff when, you know, as you're saying, like, it might be very hard for a human to catch one of these bugs, but suddenly if you have AI systems going at them, maybe we're 50% more likely to find one of those bugs within a one year timeline or something.
00:17:33.037 - 00:17:33.565, Speaker C: Yep.
00:17:33.669 - 00:18:00.138, Speaker B: But I think, like, with AI, the issue is that you need to have enough trained data. So I think we're very early for that. Like, I've played around with a few AI formal verification systems, and usually they completely miss because you don't have, like, you don't have 8000 different curves, 8000 different kybers. You have like five good ones that are live on Mainnet, so the training data isn't enough yet. In a world where you have a billion user on chain and you have like a billion financial applications, that makes sense. But I don't think AI is there already. I think you need formal verification provers.
00:18:00.266 - 00:18:01.330, Speaker C: Yeah, yeah.
00:18:01.362 - 00:18:24.754, Speaker A: Formal verification has been kind of an interesting component. It is hard to keep an evolving system formally verified. And so, like, with the. With the divergence you're talking about between the Aptos flavor of move and the sui flavor of move, like, do you have a sense of how they're actually doing that sort of concurrent verification work as they sort of start to diverge from like a core product?
00:18:25.734 - 00:18:54.910, Speaker B: I don't want to speak for both teams with thesis, but from my understanding and conversation with teams, Aptos is focused on the VM style, which is the move prover, which Wolfgang kind of spears spearheads over there, I believe Swiss targeting from a consensus mechanism, trying to embed security. I know they're pretty stacked. CK team. So looking like ZK, logging a few ZK cryptography initiatives. But I believe the targeting through consensus and not from the VM level, but could be wrong from sweet style. I'm more familiar with Aptos thesis.
00:18:55.062 - 00:18:55.806, Speaker C: Yeah.
00:18:55.990 - 00:19:07.710, Speaker A: So when you're looking at sort of like we talked about the move mov l two on ethereum or maybe on something like deploy on Celestia in the future, are you guys primarily working with the Apdos flavor then?
00:19:07.902 - 00:19:46.402, Speaker B: Yeah, we're probably working the Aptos flavor just because the VM itself is designed to be modular, while sweet moves VM is designed for more, for its consensus mechanism. We support both styles of move because we have RPC translation layer on top of the move VM because the bytecode for both apps and suite move are still the same. Sometimes, like JavaScript Bytecode is the same for react and Vue, just like how you translate the RPC code with that. The trade off is the benefit of suite move is the way it interacts with consensus. We don't retain that for obvious reasons, because we don't have suis consensus. It's more about providing compatibility sumove projects. But SuI is definitely the best place to write sumove because of its correlation to consensus mechanism.
00:19:46.578 - 00:19:52.810, Speaker A: Yeah, because Sui's got two different consensus mechanisms that a transaction can go through. So there's a lot more to account for there.
00:19:52.922 - 00:19:53.674, Speaker C: Yep, yep.
00:19:53.714 - 00:19:54.562, Speaker B: It's very difficult.
00:19:54.698 - 00:19:55.414, Speaker C: Yes.
00:19:55.874 - 00:20:14.240, Speaker A: So when you guys were looking at something like move support on Solana, what initially attracted your attention there to say, like, yeah, this is actually something worth doing as opposed to looking at bringing move support to avalanche or some other network.
00:20:14.432 - 00:20:43.820, Speaker B: I think for us, first of all, I'm a slanable. Like I use every day. I send salon to my mom via usucc a lot. So I'm a diehard salon maxi, if that works. My second thing is our thesis is move everywhere with movement. That's kind of like, even in our backgrounds, we envision a world where the move framework and move thesis is embedded into every blockchain through one shape or form, whether that's a move prover existing in current existence, like avalanche, Solana, whatever. Or people were saying move smart contracts.
00:20:43.820 - 00:21:11.974, Speaker B: So obviously with the LLVM implementation, you wouldn't get the move prover. What was interesting is we could essentially bring the move programming language to theorem because it is LLVM. You get multiple programming language. And I saw that you guys were already doing it. I checked out the LLVM branch. It talks to a few of the engineers and seemed like, is a product you guys been working on for quite some time. Obviously, it's very difficult, and you guys are propagating the SVM, and your thesis is making SVM as strong as possible and anchor as strong as possible.
00:21:11.974 - 00:21:57.814, Speaker B: But given our experience with move compilers and the leading voice module move or move outside of existing environments, I think that's what attracted us. And something that we're working on right now with the Solana team is bringing the move language to Solana will unlock a lot of different benefits for them developers. A, by having existing move developers who are crushing, and b, you'll actually have some of the move secure, inherited, because a lot of the move security comes from the move contract itself. You have, like, better account models, you have resource security. You can have custom defined modules. So if you're building a gaming app, you can define like, a module design for a specific, let's say, gun or player, and have customizations on the module. And then from there you can experiment with security advantages.
00:21:57.974 - 00:22:34.818, Speaker A: Yeah, it's kind of interesting when you think about the idea that a programming language can sort of be the main characteristic of a blockchain, which is sort of interesting because this was sort of the thing that I think a lot of people were talking about, about Sui and aptos in the beginning is like, oh, their main advantage is that they have move. And it's kind of interesting to sort of be like for you. And you're not quite saying this, but move is not actually a moat, and that a lot of networks can benefit from the same characteristics that Sui and Aptos have. Just sort of had a first mover on.
00:22:34.906 - 00:22:35.194, Speaker C: Yup.
00:22:35.234 - 00:22:36.050, Speaker A: No pun intended.
00:22:36.162 - 00:22:36.714, Speaker C: Yeah.
00:22:36.834 - 00:22:54.914, Speaker B: Ethereum's first mover advantage was in the EVM compared to bitcoin. Right. But after, like, these other vms came up, that advantage wasn't the moat, wasn't that slow at all. In fact, it was became a weakness. The moat was the fact that you had the most TVL, most security on chain. Same thing with apps and suite. Move was the first thing that got people excited.
00:22:54.914 - 00:23:12.954, Speaker B: But now xuite is focused on ZK and cryptography, AppDOS is focused on formal notification, more consensus mechanism research. So move is actually not a mo anymore. In fact, we've proven that it can be brought to other ecosystems, and now it's the framework that's open source that anyone can adopt. And Polkadot, I think, is a move Polkadot palette now.
00:23:13.074 - 00:23:13.522, Speaker A: Cool.
00:23:13.618 - 00:23:20.998, Speaker B: So we're seeing it actually adopted this move module and cosmos as well. Um, so it's interesting to see a move pop up in other existence as well.
00:23:21.166 - 00:23:21.918, Speaker C: Yeah.
00:23:22.086 - 00:23:32.046, Speaker A: So in terms of, um. You know, most languages have some form of trade off in terms of performance optimizations versus usually how easy it is to write in it.
00:23:32.110 - 00:23:32.406, Speaker C: Right.
00:23:32.470 - 00:23:46.434, Speaker A: Like the classic version here, uh, is. Well, rust is not necessarily the easiest language to write in. It's a lot easier than c, but it is faster if you write stuff natively in c. Where does move kind of fall on the spectrum?
00:23:46.854 - 00:24:16.632, Speaker B: So we've been doing a lot of outreach in university and developer groups, and it seems like move has been the easiest language to pick up out of traditional rust and traditional society. Just because it's very object oriented. There's less opcodes you worry about. I think it's like 54 op codes and move and this amount of time it takes to write code. There's some diagram somewhere that says to write account checks for move. It's like this much for any other code base, it's a page, and slowly it's like three pages. Um, so if you're like a university dev, you're like 24, you don't really know how to code.
00:24:16.632 - 00:24:24.968, Speaker B: Move is probably the easiest language to pick up because you don't have to write 30 pages account checks. It's probably done for you. Um, and you can focus more on the product, just reach for the product.
00:24:25.136 - 00:24:56.846, Speaker A: Right. And then in terms of like the actual code performance. Right. I think that's kind of where, um, like, you know, anchor on Solana sort of has a little bit of this problem where it's much easier to write in. It's not a language, it's a framework, but the framework of anchor is quite easy to write in. You do take a performance hit writing in anchor versus rust, and then you take a performance hit writing in Rust versus C, and then you take a performance hit writing in C versus Solana native for your program. So this is also like the swift versus C on the iPhone kind of perpetual debate.
00:24:56.846 - 00:25:04.758, Speaker A: So, like, in that stack, is move performance about, about par with Rust? Is that sort of what you'd say?
00:25:04.926 - 00:25:37.344, Speaker B: So my general thesis, taking a step back, is if we get web two, you had JavaScript and you had like obviously HTML CSS below that, JavaScript above that, and you had react, vue and angular on top of that. So you see the same performance kind of trade offs. Obviously, if you just like hard coded everything, HTML, CSS and C, the compiling times be quicker. But how are you going to do that? And it's very difficult for normal developers to do that. That's why react, Vue and angular got adopted as the three main frameworks to build websites. Technically it's slower, but the developers, users don't see any trade off. And the biggest websites that I've written in that.
00:25:37.344 - 00:26:01.224, Speaker B: Right, same thing with blockchains. I believe the three frameworks that risen is AppDeF, move, suite movements, SVM, they can all coexist, all have their own benefits. Trade offs. Whatever users develop, developers choose what they want. There is performance trade offs in terms of speed. I don't think it's noticeable to the point, like anchor, I mean, it's very minute, um, to the point where it's a trade off. I would say if you're a developer, anchor, sweet move.
00:26:01.224 - 00:26:14.740, Speaker B: And after smooth is still the best way to write rust based contracts, even though like you're sacrificing a little bit. Um, the, the trade offs in terms of go to market user experience security is far worth like the 0.01 millisecond difference or whatever.
00:26:14.852 - 00:26:40.236, Speaker A: Yeah, yeah, I think that's fair on the, on the, the user level. Right. Because I think that is kind of one difference here, is like most people who are building stuff and move, they're, they're not necessarily building groundbreaking, you know, frameworks that are going to become the basis of the next generation of Defi. They're, they're building Defi primitives or they're building DeFi applications, but it's one level sort of higher up in the stack, for lack of a better term.
00:26:40.300 - 00:26:40.644, Speaker C: Yep.
00:26:40.724 - 00:27:33.914, Speaker A: So I think when you sort of look across the blockchain space from an education perspective, there's a ton of work that's been done on sort of developer education over the years. I'm sure you guys are doing your own. When it comes to move, do you have any sort of sense of what works well and what. Because I think there's almost this paradox people get into where Nier had one of the best developer education systems out there, but they almost made it too easy. And then the types of developers that they attracted, maybe a lot of them weren't as strong as some of the developers that had to chew glass on solidity or Solana to get to that place. How do you sort of think about that balance when it comes to onboarding new developers?
00:27:34.934 - 00:28:27.516, Speaker B: I think this is what slotted it. Maybe the best out of anyone is kind of preventing mercenary developers and prioritizing in house organic developers. So that starts off with not throwing a grant at every developer that's interested and being like, build this, and then when they run out of money, then go to the next chain, it starts with like how you're funding developers and how you're giving developers economic incentives. Because ultimately the goal of a developer is to make a career on a platform. If a developer can't have a career on a platform, they're going to keep jumping ship. To have the hottest person on the block is slandered that events of the bear markets to the hackathons and keeping the developer community as tight knit as possible and prioritizing the projects, giving the funding, giving them ecosystem traction. So you're able to retain developers that way because there's a loyalty to the chain and actually a business model built in where these developers actually have money.
00:28:27.516 - 00:29:04.502, Speaker B: They're able to feed their families by building on top of Solana or the next gen chain. Other developers and other e systems have kind of seen the issues where they'll throw grant money. Forget about the project, six months later, the product's on the next chain. So something that we're focused on, and I think the movies in general is focused on is a prioritizing developers that have long term growth contributing open source contributions that are more than just a simple dex for work on top of native chain infrastructure. I think what sweats focused on is a lot of ZK cryptography work. Apples focus on consumer partnerships. Both systems are prioritizing their own use cases.
00:29:04.502 - 00:29:25.754, Speaker B: For us, we have the benefit of inheriting that instead of focus on distribution. I would say just generally having a tightening consumer base, hosting hackathons in person and kind of prioritizing the DJ and developer community is the best way that you retain developers. Making sure they have partnerships, have friends, have a current technic community system. That's how you retain them.
00:29:25.874 - 00:29:36.970, Speaker A: Yeah. So what does the move sort of developer community look like now? Are there sort of pockets in the world or certain types of applications that folks are primarily building on? Move now?
00:29:37.122 - 00:29:47.262, Speaker B: I think according to Capital, Aptos is the fastest growing non EVM. Obviously, given the fact they just launched, that's how the percentage captured. But like, if you just launched the.
00:29:47.278 - 00:29:49.382, Speaker A: First year, percentages are always a little funny.
00:29:49.518 - 00:29:50.126, Speaker C: Yeah, yeah.
00:29:50.190 - 00:30:25.334, Speaker B: But we've seen a great uptick, especially like launching post FTX. You kind of expected nothing to be there. I think the count is like their number move is number eight into the upper count or number nine, something like that, which for a first year ecosystem is pretty vibrant. We're seeing a lot of growth in Southeast Asia, Korea, Taiwan. Korea especially is big, has a big flag there with SK, planet hash and a few other groups. So we're seeing a lot of developer communities come from Asia to start with. And now the kind of focus, or at least our focus is North America Europe adoption, where cory theme and kind of cosmos folks are.
00:30:25.334 - 00:30:30.822, Speaker B: So yeah, this general move adoption I say is Asia based, but our thesis is trying to bring it to us retail.
00:30:30.958 - 00:30:32.954, Speaker C: Nice, that's interesting.
00:30:33.774 - 00:30:47.114, Speaker A: So for movement labs itself, talk to me a little bit about how the is structured. Are you guys primarily grant funded from different blockchains? What's the long term vision of that corporate entity?
00:30:47.734 - 00:31:17.902, Speaker B: We've raised funding from private investors to private rounds. So that's how we grow a team. I think the team's like 17 deep right now. Taraab, actually ahead of Ed, was the head of ecosystem marinade. So we have Solana ties and love Solana and try to embody our hacker developer community and learning from what Solana did, given the fact that it's probably the most exciting ecosystem right now and you guys have crushed it every shape or form. So yeah, I think we're privately funded and now going to raise more future rounds and push product towards testnet mainnet.
00:31:18.038 - 00:31:36.124, Speaker A: Yeah. So walk me through a little bit of what that sort of investible vision is. I think it's very easy to look at what you guys are doing and saying like, yeah, this is a great public good. You're bringing a new programming language to a ton of blockchains. But you know, investors obviously don't usually invest in public goods.
00:31:36.584 - 00:31:55.870, Speaker B: Well, the main value prop is L2 on Ethereum. It works. It works and functions like any other layer too. Something like arbitrary optimism. I think what we've seen is all these different DA layers rise up. See it like Celestia game availability. I think 2024 is proven to be the year of the next gen vms where you have Slana VM, obviously kicking up a lot of people using next gen vms.
00:31:55.870 - 00:32:20.106, Speaker B: Their move has been crushing in the last few weeks. So we've seen a lot of people, especially in Ethereum and Cosmos communities, embrace vms and next gen vms because they learned that they could keep the existing security community of Ethereum, but still use an x gen virtual machine. So that kind of combination has enabled us to a attract interest investors and raise private funding and be kind of labeled ourselves as leaders as like the modular move category.
00:32:20.290 - 00:32:53.214, Speaker A: So in that world where we're now basically talking about the ability to program on multiple languages and support new vms, what is Ethereum doing in that stack at that point when you're now programming a different language, it's executing in a different vm, it's settling to a different DA layer like Eigen or Celestia, which is not actually technically Ethereum, especially with Celestia's case. So like walk me through like the Ethereum quote unquote alignment thesis when we're talking about new vms and new DA layers.
00:32:53.794 - 00:34:04.642, Speaker B: So the value prop is that Ethereum is the best selling layer today, given the fact that it's been battle tested, has TVL, Ethan uses stable money and as many people argue. So Ethereum would be settlement in this case where any transaction or infrastructure application leverages ethereum security, decentralization and network effects to boost trap liquidity. So if you go back to the Dex example or like a yield aggregator example that my co founder built on new L1, there was pretty much no liquidity at the time. I think it was like 30 million when we were at peak when we were launching that same Dex and yield aggregator can now deploy on top of m two, which is our l two product, have native ETH directly which has some assets, has actually liquidity to the products. If you're liquid fund or family office, if you want to use the L2, you can simply deploy the ETH. You don't need to buy apt or sue, which is obviously a volatile asset and prevents retail capital from coming in. So our value prop is if you're a whale, if you're ETH whale, or even if you're a retail user, you can use move apps by using staking ETH, leveraging ETH, not having swap to native asset and have all the benefits that move security for verification into the VM.
00:34:04.778 - 00:34:36.788, Speaker A: Yeah, I guess I'm just curious because the classic version of how you solve this was just you build a bridge from Ethereum to Aptos and people can use their Ethereum then on Aptos or Sui or Solana directly, but that never quite caught on in the same way. And I wonder how much of that's bridge reputation versus. Because the l two bridge is still a bridge, bridging to an l two is still a bridge and the UX is uh. If anyone who tried to get ETH Denver tickets for free this year, the UX still needs some work.
00:34:36.916 - 00:35:12.488, Speaker B: Yeah, I would say that there's too many things here. A security we've heard and seen all the horrible hacks have happened, um, that have led to that. And then b the kind of user experience like if you look on opposite right now, there's like three different usdcs. There's like warm USCC Axel, USCC layers here, USDC Um, and same for USDT and then like and just the user experience when you have five different UCC's probably turns out for most people. Sure. Same with ETH. If you have five different apps, ETH with us with L2, you have native bridging essentially because it's trust minimized bridge over top of Ethereum and the valor set there.
00:35:12.488 - 00:35:15.536, Speaker B: So you don't have to worry about that. You can just bridge from Sepoya.
00:35:15.640 - 00:35:23.660, Speaker A: I will say trust minimized and fraud proofs are not the same thing. But yes, it is a closer system at least. I'll give you that.
00:35:23.792 - 00:35:24.964, Speaker B: Yep, exactly.
00:35:25.124 - 00:35:40.544, Speaker A: So what do you see as the next evolution of move? We have these sort of two flavors of move kicking off. Do you think they're going to keep diverging? And what can people who are excited about move kind of look forward to over the course of 2024?
00:35:41.204 - 00:36:17.916, Speaker B: I think they will keep diverging just because the nature of the two ecosystems, that's unfortunate truth and something we're working on from a culture point of view and technological point of view is uniting the tribes has been difficult to prove, to say the least. But we're doing our best. And then kind of in terms of the next steps to move something that we're doing a lot of research into, the ZK move we saw the EVM to ZK EVM trend. I would argue that ZKVM wasn't that much performance than the EVM that we saw. So we are actively looking at the ZK move thing. The issue is that proving cost today for any zero knowledge provers are way too high. I think our benchmarks four to $0.05
00:36:17.916 - 00:36:56.638, Speaker B: for current resale implementation, which makes the transaction fee pretty difficult. So we're currently in the process of hiring circuit writers and exploring our own ZK movie and trying to get approving costs as low as possible, ideally less than a fraction of a cent, which then it makes sense to use it. And then you have all the benefits of security proofs and even privacy ultimately. But that's still very theoretical, still very downline. I think the main push is just getting adoption from move. Move we believe is a tangible improvement for current implementations. And now it's about getting into retail markets, specifically getting new developers to use it.
00:36:56.638 - 00:37:33.122, Speaker B: Given the fact that Facebook is a web two kind of ecosystem, since we both have web two ties and backgrounds thesis isn't to get Solana developers to migrate to move, or Polkadot developers to migrate to move. The thesis to get JavaScript developers and retail developers from Facebook or consumer mapping systems to use move. So I wouldn't say it's predatory to current web two systems. We're not all trying to exchange the five developers we're grant chasing. We're all trying to tap into the millions of developers that are trying to move looking to web3 but never thought to do so. And our thesis is if you're developing web two, you probably feel comfortable writing the language that Facebook built. And now it's about distributing that.
00:37:33.122 - 00:37:33.854, Speaker B: Nice.
00:37:34.194 - 00:37:45.180, Speaker A: Well, Rishi, if people want to learn more about move to get started programming on it, or keep up to date with what you guys are doing at movement Labs, where do you recommend they go first?
00:37:45.212 - 00:38:12.018, Speaker B: Read the move book that was written by the early DM projects. Kind of ghost into every semantic there's a bunch of YouTube videos and I think after some sweet both have done a good job of interrupt documentation. Hackathons. Sweet hackathons are some of the most fun. Second to maybe Solana. Maybe I love the Solana hackathons and hacker groups. And then for move in labs, in labs Xyz on Twitter, you can follow me rushimanshay on Twitter, endless ship poster and technical memer.
00:38:12.018 - 00:38:21.130, Speaker B: So you can follow my content as well as we have YouTube videos, a bunch of podcasts like this that kind of explain a thesis how to get started. Enjoy the discord.
00:38:21.282 - 00:38:21.970, Speaker C: Love it.
00:38:22.082 - 00:38:24.930, Speaker A: Well, thanks for joining us today on validated.
00:38:25.042 - 00:38:26.874, Speaker B: Thanks for time, Austin. Really appreciate it. It was a blast.
