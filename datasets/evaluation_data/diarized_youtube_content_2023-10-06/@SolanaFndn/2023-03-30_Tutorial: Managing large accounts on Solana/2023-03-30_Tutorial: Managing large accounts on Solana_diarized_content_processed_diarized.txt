00:00:00.160 - 00:00:45.938, Speaker A: Hello everybody. Today we're going to talk about memory on Solana. And memory on Solana is a scarce resource. So you have, if you write a program, especially in Anker, you have a stack size limit of 4, you have a heap size limit of 32, you have a PDA account limit of ten kb. So today I'm going to show you how you can save stack space, how you can create accounts that are bigger than 10. In the end, we're going to look at zero copy civilization so that you can create accounts that are actually big, up to ten megabytes. For that, we're going to go through this repository here, anchor zero copy example.
00:00:45.938 - 00:01:30.474, Speaker A: It contains three tests which we will go through one after the other, and the first one is the stack size limit. So the 4 will quickly show you the structure of this project. So here in the program zero copy, we have the program. This program is written in anchor, and we will run these tests one after the other. The first one is a stack size limit. First thing it creates a new key pair. Then it finds a PDA by using the string hitstack size and sign up public key bytes to find this PDA account.
00:01:30.474 - 00:02:23.930, Speaker A: Then it does an airdrop, and then we initialize the account and that is already it for this one. This test basically succeeds as soon as there's an error in this instruction, because I want to show you that there is a limit on the stack size if you have big structs in your account. The initialize hitstack size instruction has the same seed as the one that you just saw in typescript. So we have the hitstack size string, the payer will be the signer, and we set the size of this account to ten kb. So ten times 1. Then we have this big struct here, hitstack size struct has a good name. So this is an array of nine options of big struct, and the big struct contains four public keys.
00:02:23.930 - 00:03:21.760, Speaker A: The struct has a size of four times 32 bytes, so 128 bytes, and this times nine plus one for the option is thousand 161 bytes. But the way how anchor serializes it, we already hit the stack size at this point, so we can already see as soon as we build this program, Anker does this nice check in beforehand that we surpass the stack size of four kilobyte by 416 bytes already. And if I run this test, then we will also see the error and chain that I'm going to show you now. So we just type anchor, run stack size, and then we see that this failed. So let's just do anchor test first. This will automatically always build and deploy the program so it's easier to run the test. So then we will see here.
00:03:21.760 - 00:04:06.098, Speaker A: Now it runs. And here we can already find the transaction signature. And since I'm running a local validator that you can just do like this, you just type in the terminal if you have the Solana cli installed, Solana test validator minus r, and then you run your local validator, and then you can look into this instruction currently. Now I can't look into this at this anymore, of course, because I just killed my local validator. This is the signature. We copy it into our explorer, which is pointing to our local validator. And then here on the bottom, we see access violation stack frame five.
00:04:06.098 - 00:04:46.408, Speaker A: So some cryptic error. Yeah. Now I want to show you some tricks how you can save some stack space to have bigger structs, bigger accounts. So what you can do is you can box this account here in the derive accounts, struct. And what this will do, it creates a pointer of 16 bytes, which will point to the account, which will now be saved on the heap. And now if we run this again, anchor build, we can see that we saved a bunch of size on the stack. So now we are only surpassing the size of the stack by 72 bytes.
00:04:46.408 - 00:05:53.540, Speaker A: So whenever you have like big structs that are like bigger than 16 bytes or so, it usually makes sense to box the accounts. Now we go to the next test, and I want to show you how you can create an account which is bigger than 10 kb. Because by default PDA that you create in Solana has a size limit of ten kb because anchor creates accounts by doing a cross program invocation to the system program. So basically, you create the account, it gets initialized, and it's called system program, createaccount and initialize. And there in the Solana runtime, there is a limit of ten gb that you can allocate per transaction. And to get around this, what you can do is you can create a new instruction which increases the size of the account. So you can just allocate more money, more memory to it, also more money actually, because the bigger an account, the more it costs.
00:05:53.540 - 00:06:38.354, Speaker A: I can quickly show you how you can find out what an account costs. You can just type in the terminal Solana rent and then, for example, 1024 byte. And then we can see this account costs us 0.008 sol to save on chain. But what we actually wanted to do is I want to show you how you can make your account bigger. So for that, we call this instruction here that I wrote, it's called increase account size. And here you can already see in this line above the struct that we put in now U 16, which is called Len.
00:06:38.354 - 00:07:19.132, Speaker A: It's a nice thing that anchor does. You can put variables in here, and then you can have in your struct declaration, you can have variable data. So when we put this len in here, then we can realloc the account to the len usize that we put in. So it's converting the U 16 to use. So after this instruction went through, we allocate an account, which we allocate the size of the account to be bigger. Now you can also make it smaller and then you get some soil back, actually. So how we call this from JavaScript is we just initialize, no zero copy.
00:07:19.132 - 00:07:53.296, Speaker A: This is the initialization. And then here is the instruction to increase the account data. So we just call program methods, increase account data, and then we set it to 20,480 bytes now, which is double the size. And you can do this with every instruction. So you can now call this 12345 times. And this will always increase your account to see if this really works. And we will now send some strings to this account and save them in the account data field.
00:07:53.296 - 00:08:40.540, Speaker A: So we have this loop here, which goes from zero to 14. And in every iteration in this loop we gonna send 920 ace, so 920 byte into this account and then save it in that account. So in total this should be more than ten kb already. I'm going to quickly show you what we do in the backend in the program. So here we just take the context, we take the accounts, we get the data holder, we get the string that is in there, and then we push the string that we pass in and then anchor automatically serializes it afterwards. And the account will be saved. Yeah.
00:08:40.540 - 00:09:25.252, Speaker A: So let's run this anchor run without zero copy, and then we can see that it failed again. So let's do anchor test. Anchor test just runs all the scripts, but you can also here in the anchor toml what I did, I created these extra scripts here, which run every test separately, but for some reason it doesn't work currently. So here we can see the realloc instruction. So let's copy it. We put it into the explorer. And here we can see that we created this PDA here with a balance of 14 sol.
00:09:25.252 - 00:10:16.744, Speaker A: So we can already see the size of this account is now 20 gb. So we already have a bigger account, but we are not using zero copy yet. So what this means is that as soon as we load more data than 35 kilobyte, then our program will run out of memory. And this happens here after twelve times sending 920 bytes to this account. So let's look at the last instruction here, the last signature. So we paste this in and then we already see here in the end, error memory allocation failed out of memory. So to get around this now we will need to create a zero copy account.
00:10:16.744 - 00:11:07.314, Speaker A: What this means is that not the whole account will be on the heap, but instead it will be in memory on the validator. And we just interact with it by taking certain slices out of this account, work on them, and then directly put them back in. How you create a zero copy account is you add this attribute here, account zero copy, and then you can set a certain rep type. And this default one is c, but there's also a few other ones. The links to the ones that are available are in the repository that I linked down below. Basically what this does is it shows, it explains how the data will be structured in the account. So if you put it to pact, then it tries to make it as small as possible.
00:11:07.314 - 00:11:57.258, Speaker A: But there you can run into problems from time to time. Like for example, options are serialized differently and enums are serialized differently. So I would recommend you only to use this if you really need a big account. So what we do here now is we have this long string and we set it to 40,000 bytes. So u eight is a byte and yeah, the size, we always have to subtract eight bytes because what anchor does when it initializes an account, it always sets a byte discriminator in the beginning of the account. This one is derived from the name of the account and account prefix colon. And then it takes a SHA 258 hash of it and takes the third eight byte and then puts them at the beginning of the data.
00:11:57.258 - 00:12:54.092, Speaker A: Bit of a detail, but maybe it's good to know that you know what is actually in this data field when you look at the account. And then the next thing you need to change as well is that this is not an account anymore, but instead it is now an account loader. If it's an account, then it tries to load the whole account, but if it's just an account loader, then you basically just get the pointer to it. So I gonna show you how this looks here in the program we do basically the same thing as with the other accounts. We just send a string. But now we also set an index and what we do to save the data in this account, the trick is that we don't load the whole account data, but we just take the data, we load it mutable, and then here we take a certain slice of the account. So in this case, we start at an index and go to index times plus 912.
00:12:54.092 - 00:13:38.182, Speaker A: Because we sent 912 bytes of string here. This is not 920 anymore, but instead it's now 912. Because we also need to send this index, which is another eight bytes that we don't have space anymore in the transaction because transaction has 1232 bytes. And we need to be very careful that we are not getting bigger than that. So we only have 912 byte of data actually that we can put in here. And yeah, directly and this index we just copy from, slice the string that we are passing into the function. And like this, we are just directly interacting with the memory.
00:13:38.182 - 00:14:25.642, Speaker A: And so we don't need to load the whole thing and we can interact with up to ten megabytes of data. If I now would, for example, try to load the whole account when if I for example, want to print it, then this would fail because our 40,000 byte are bigger than the 32 byte of heap size. You can try this out. I would recommend that you just check out the repository and then run them yourself. Maybe do a little bit of some tests yourself. But yeah, this should give you basically everything that you need if you want to create a big account. So here you can see we increase it to 20 kb byte, 30 kb byte, 40 kb byte.
00:14:25.642 - 00:14:56.606, Speaker A: And then we take these 912 bytes and we go in the loop like 43 times. And every time we send 912 as. And now we also need to add this index so that we know at which memory position we actually want to change this data. You would need to do the same thing. Now if you want to read the data again, then you would also need to pass in the index from where you want to read the string. So zero copy makes it a bit more complicated. You need to figure out what you actually want to do.
00:14:56.606 - 00:15:28.296, Speaker A: But having ten megabytes accounts also will help you a lot. We can maybe as a last thing, quickly look at how the test looks like when it runs here and it shoves the data into it. Thank you very much for listening. If you have any questions about memory on Solana and zero copy, just put them below in the questions and I will try to answer them all in the next days. Have a nice evening, everybody. Bye.
