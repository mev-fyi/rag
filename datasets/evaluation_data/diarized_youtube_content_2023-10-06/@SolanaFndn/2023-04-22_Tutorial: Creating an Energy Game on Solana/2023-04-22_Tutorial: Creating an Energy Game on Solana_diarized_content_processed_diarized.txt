00:00:00.320 - 00:00:33.462, Speaker A: Hello everybody. Today I'm going to show you how to build an energy system for an on chain game on Solana. The game is going to be called Sol Lumberjack. And what you can do is you can chop trees and you have energy that refills over time. So here you can see I chopped a tree, I got one wood, and now the energy is counting down. Energy systems are very common system in usual traditional casual games. So for example, you can see it like in candy Crush or something.
00:00:33.462 - 00:01:18.026, Speaker A: You have this energy bar that slowly fills up over time and then you use the energy to perform certain actions in the game. You can see it for example in merge games or in candy Crush, also on. And today we're going to build something like a lumberjack where you walk around and whenever you chop a tree you spend one energy and then you get one lurk for it. It's going to look like this. It's based on the Solana app scaffold. So you can easily do this by just typing NPX, create Solana depth and then the app name. And this will conveniently create you a few folders here like an app program, an anchor program, and an app which is a next JS react app.
00:01:18.026 - 00:01:47.586, Speaker A: First thing we're going to do is we're going to go through the program. So here on the bottom you can see the player data. This is the account that every player will create when they start the game. It consists of a name, a level experience would energy, and the last lock in. The last lock in is used to create to calculate how much energy the player would have at a certain point. And here it's the accounts for this. The space will be set to 1000.
00:01:47.586 - 00:02:28.424, Speaker A: It's just because then you can add a little bit more data later. The seats are the player and the signer public key. And the program consists of three instructions. First is init player, then shop tree and update. And the init player will set the energy to max energy, so to ten, and it will set the last login to the current Unix timestamp. Then in the chop tree instruction, what we will do is first we check if the energy is zero, then the player doesn't have enough energy, so we return an error. It's very good to use these error codes because then later in the client you can check for certain errors.
00:02:28.424 - 00:03:11.300, Speaker A: And then in this case, for example, you can show the player a pop up and tell them, hey, do you want to refill your energy for a few, a little bit of sol or some SPL tokens for example. Then what we do next is we add one wood to the player account and we subtract one energy. The interesting part happens here in update energy. So in update energy what we do is the first thing we calculate the time that has passed since the last login. So we're going to take the current Unix timestamp and we subtract the last login. And then while the time passed is still bigger than time to refill energy, 60 seconds. Then we add one energy and we subtract the time to refill energy from the time past and we add it to the time spent.
00:03:11.300 - 00:04:07.020, Speaker A: The time spent we later down here use so that the player, if he already is at eight energy and he spends one more that he doesn't have to wait the whole 60 seconds again, but instead the countdown just continues from where he left off. And then when the energy is Max energy we just break. So how this looks like is like if I chop the tree two times now, for example, then you can see that instead of going back to 60 seconds, it just continues the countdown from there. So this is already everything that happens in the program. Then here instead of the program we go to the app folder now. But before we do that is from the target we can see that there's an IDL created. Then IDL is a JSON representation of your program and it has everything in it like the instructions init player, chop tree.
00:04:07.020 - 00:04:36.000, Speaker A: It has here the data and also very conveniently the error codes that you can check later in the client. And it also creates your typescript client. And this one we're going to copy. And then we put it into our app folder into IDL. This is the same thing as the Idl Json, but it's in typescript. And then everything for the game happens in the choptree TSX file. So we're going to go through here from top to bottom.
00:04:36.000 - 00:05:13.864, Speaker A: First we have the account again, name level, XP vote energy, last login and so on. Then we get the connection, we get the public key. As soon as we have the public key we show the different buttons and we show it on screen. Then we have a state here for the game data account. That one as soon as we set the data updates so you can see the data from this account here, then we have the time passed and the next energy in. And then we get an anchor wallet. We create an anchor provider by putting in the connection and the wallet we set the provider and then we create the program from this idl here, which we just put into the right position.
00:05:13.864 - 00:06:00.916, Speaker A: Idl lumberjack and we put in also the lumberjack program ID and the provider the program iD you get as soon as you here write anchor build and anchor deploy. Then you will get the program id and then you can just copy it into a constants file in the client. Next thing here we not necessarily need, but as soon as the game state changes, we lock the game state. So the game state looks like this. Here you can see the player's level zero, he has 24 w and nine energy and the last login timestamp. Then what we do here is we have another effect that is performed every time the public key changes. This is where we get the new data of the game data account.
00:06:00.916 - 00:06:34.406, Speaker A: So we call the program account playerdata, we call fetch for, for this PDA. This is created, derived same in the program from the public key and the player and the program id. And as soon as we get the data, then we set the game state to the game state we get from the anchor program. And if there is no data yet, then we show a little pop up. Hey, you need to initialize your account first, and then the player needs to initialize their account. And you could also add something like they add a name for example. And now this here is very interesting.
00:06:34.406 - 00:07:10.218, Speaker A: On account change what it does, it creates a websocket connection to the RPC node. And as soon as the account changes, the data will be pushed to us. And then we can just set the game state from the data that we get from this account info. And we can use the programs decoder to decode the player data and then set it into the game state. Now comes the interesting part, the updating of the energy. So it's another effect that will always reset when the game state changes and the time passed. And it will set an interval which is called every second, and it does the same thing as in the program.
00:07:10.218 - 00:07:49.152, Speaker A: So first we convert the timestamp from milliseconds to seconds. We calculate the time passed, and as long as the time passed is bigger than the time to refill energy, in this case 60 seconds, we add one energy and we set the last login to last login. And if someone can tell me why I have to add this little plus here to convert energy to a number. Otherwise it would just say nine one for example, in the energy. That would be really cool. Like I really don't understand this since this is typed to a number, but anyway they should call. It could be any typescript instead of typescript maybe.
00:07:49.152 - 00:08:30.136, Speaker A: So then we set the next energy next time in to nextenergy in and this will automatically update here in the bottom, our little representation of the data of the game would energy next energy in. Then the next thing is what we have here is on init click, we just do some checks, we get the PDA. Again, you could probably do this. Getting the PDA only once, whenever the public key changes in a state would be a bit nicer. Then you can do init player. Here you put the accounts player signer system program. In this case we need the system program as well because Anker creates a new account and for that it does a cross program invocation to the system program to create the account.
00:08:30.136 - 00:09:00.786, Speaker A: And on Solana you always need to put in all the accounts for performance optimization on the chain. Then we get here the transaction builder and we send out the transaction. And I usually like to set skip preflight to true. What this does is even if the simulation fails, it will still send out the transaction. And then you can see the error code here on chain in the Explorer, which often helps to debug certain errors that you might have. And then here's this nice little notify thing. It's a functionality from the app scaffold.
00:09:00.786 - 00:09:32.110, Speaker A: So that is nice. And then on chop click it does the same thing, a few checks, get the PDA and this time we call shop tree. This time we don't need the system program, we just need the player data, PDA and the signer. Then we send out the instruction and it will chop a tree. It subtracts the energy and then every second we update the energy in the game. So that is already it for the program. You can check out this repository, I will put the link to this in the description.
00:09:32.110 - 00:10:14.790, Speaker A: It comes with a bit more explanation of how everything works. And then you can build something, something like this where player could upgrade. Now the access for you could prove it a bit by adding instead of just increasing a counter in the program, you could use the token program and then mint a token every time the player creates a lug. And then he could use the lurk to sell it for gold. And then you could use gold to upgrade your axe and then you could build a building with more gold and so on. So I hope someone builds a nice little mobile game with this. And yeah, the repository is in the comments and if you have any questions put them in the comments as well like the video.
00:10:14.790 - 00:10:19.494, Speaker A: And see you next time. Our.
