00:00:04.120 - 00:00:33.774, Speaker A: Hey, everyone, I'm bri. I'm a developer advocate at Solana foundation, and today we're going to be building out a crud app on the Solana blockchain. It'll be a journal Dapp, where you create, read, update, and delete journal entries. To be able to follow along with this guide, you have to have node JS anchor, the Solana ClI and rust installed on your computer. So let's get started. Use MPX, create Solana Dapper. We'll name it journal.
00:00:33.774 - 00:01:20.174, Speaker A: We'll use next JS tailwind, and then an anchor program. So this is just a CLI command that enables you to create a Solana Dapp very quickly by having an anchor program connected to a front end and then also a wallet connector. You just have to wait for this to load. Okay, so we'll just navigate into this directory and install our node modules. Now, while that's installing, we can open in versus code. Okay, so first thing we want to do is be able to update our anchor program. So we're going to navigate to where the Solana program is.
00:01:20.174 - 00:02:01.434, Speaker A: So, anchor programs, source, lib, RS, this is where your program lives. As you can see, there's some template code here for a counter program. So we're going to delete all of those instructions and the corresponding data structures and start from scratch. Okay, now we have our program macro from anchor. This is where all of your instructions are going to live. Before we write any instructions, we're going to want to define our program state. So the state is just a data structure to define all of the information that you want saved.
00:02:01.434 - 00:03:04.210, Speaker A: Since Solana on chain programs don't have storage, the data is stored on accounts that live on the blockchain. So we're going to use an account macro here, and then we're going to define our state. So, so what do I want to save for my journal entry? Well, I want to know the owner, so I know who owns what journal. And then I want to be able to title, and then I want to be able to title each journal entry and also leave a message in each journal entry. And lastly, I'm going to add an entry id. This can be calculated with a counter. This will just be used to optimize the front end.
00:03:04.210 - 00:03:40.374, Speaker A: You can index and paginate better by having each journal entry associated with a number. Now, every time you initialize a new account on chain, the space must be defined. And that's because we have to know how much rent to pay for that account. So with anchor, you can actually have this calculated for you by using init space. And then whenever you use this for strings, you're going to have to specify the max length. So we'll add that in. Now we'll set the title to 20 because that can be a little small.
00:03:40.374 - 00:04:25.964, Speaker A: And then we'll give 200 to the message okay, now your state's ready. So we can start by initializing our accounts. So for this journal, each journal entry is going to have its own PDA. So anytime you want to create a new entry, you're going to initialize a new account on chain. So we'll make our first instruction create entry. Now, with the anchor framework, every instruction takes a context type as the first argument. The context macro is used to define a struct that encapsulates all of the accounts that will be passed through a given instruction handler.
00:04:25.964 - 00:05:03.296, Speaker A: So we're going to define that. First we'll use our context, and then we're going to have a custom data structure written for this instruction. So that'll be create entry. And before we finish writing this instruction, we're actually going to define this data structure. So when you're writing the data structure for a context, you're going to want to use the derive accounts macro. And what this does, it's used to deserialize and validate the list of accounts specified within the structure. Now we'll just divine our create and true struct.
00:05:03.296 - 00:05:55.654, Speaker A: We're going to use the lifetime specifier. And then the first thing we want to specify is the account that we're creating. So once again we'll use an account macro, and within an account macro you can have constraints. So we're going to set our first constraint as a knit because we're initializing this account. Now we need to generate a PDA. So a PDA is defined by seeds in a bump. So we're going to define our seeds, and here we're going to use the title and the owner, and for the owner we're going to use the key and then we'll add our bumper and that defines our PDA.
00:05:55.654 - 00:06:32.728, Speaker A: So here we're specifying both the title and the owner as our pdA, so we know what journal entries belong to what owner, and then the title is allowing the owner to have multiple journal entries. So there's a new unique PDA generated every time you create a new journal entry. Now we're going to have to define a payer. This payer is who is going to pay the rent needed to create this account on chain. And we'll set that as the owner. And lastly, to be able to know how much rent is going to be paid, you'll need to have the space calculated. So we can calculate the space as well here we're going to have eight as our discriminator.
00:06:32.728 - 00:07:34.394, Speaker A: And then we can just calculate using the init space constant, because we use the derive init space macro when defining our journal entry state. Okay, now we can just define this account. We'll name it journal entry of type account with a lifetime specifier, and it will be saving with the journal entry state. Now we need to specify the account who this owner is going to be. So we'll do owner is going to be the signer, and since the owner will be making a payment, the account state will change. So we're going to have to make this account mutable and we'll just pass through the mute constraint. Okay, and lastly, we just need to define our system program.
00:07:34.394 - 00:08:30.932, Speaker A: Okay, now one last thing. Anytime you're pulling through additional data, you're going to have to use this instruction macro. The instruction macro is used to access the instruction data passed into the instruction handler. So we just have to use instruction, and we're specifying the title here that's being passed through the instruction handler above in the program. And now this is all good to go, so we can go back into our instruction function. Now, we already passed through the context as the first argument. Additional data that we need is the title and the message.
00:08:30.932 - 00:09:38.784, Speaker A: So we're going to pass that through now. Now all we're doing here is just saving the title and the message to the journal entry state of this PDA. So we'll just load in the journal entry and we have to make this mutable because the journal entry is going to be changing. And in rust everything is immutable by default unless you define it as being mutable. So you have immutable, and we're just going to be calling from the context, the journal entry. Now we set the owner, and that can be found by just finding the key. And then we just set the title and the message.
00:09:38.784 - 00:10:26.632, Speaker A: And that's all we need to do. We have our result and now we have initialized an account. Up next, we want to be able to update the message after we initialize it. So we're going to create an update function. And once again we pass through the context as the first argument. And then we're going to have a unique data structure here as well for create entry. So let's go down and define that.
00:10:26.632 - 00:10:57.370, Speaker A: A lot of this stuff is going to be the same. So we're just going to copy this and we have our derive accounts and instruction will be the same. Now we're going to name this as update entry. And here we're passing through the account macro for our journal entry. But we don't need to initialize anymore because it already is initialized. However, the account will be changing, so we're going to have to make it mutable. Now our seeds in our bump to find our PDA, so that stays the same.
00:10:57.370 - 00:11:36.366, Speaker A: Now, because this account is changing, the message length is going to change. It could either increase, it could actually stay the same or it could decrease. So because of that, we're going to have to reallocate the rent that is being paid by the space change that happens when updating this entry. So we're going to have to use the realloc constraint with anchor. So to do this, we're going to have to recalculate the space. So we use our discriminator of eight and then we just once again use the init space constant. And now we're going to have to define a payer.
00:11:36.366 - 00:12:15.504, Speaker A: So this payer is going to either have to pay the additional rent needed or they'll be able to get refunded the excess rent that they previously paid if the message size shrinks. So we'll define the payer. Last thing we're going to have to define is that the space resets to zero before we recalculate space. So we'll set that to true. And now our journal entry is defined the same way, owner is also defined the same way with immutable account as the signer and then our system program. Okay, now we are good to write our next function. So once again we're going to pass through the title and the message.
00:12:15.504 - 00:12:51.422, Speaker A: This is because you'll need the title to find the PDA. And then the message is going to be the new message that we want to update our journal entry. So we're going to change this to new message. And then once again, since we are changing the journal entry state, we're going to load in the journal entry so we can copy this over. And then all we want to change is the message. So we're just going to find message and set it equal to the new message. And that's all we need to do.
00:12:51.422 - 00:13:22.028, Speaker A: So we'll set the result. Now, title needs to be passed through this function because it's being used down here to find the PDA. However, it's not being used in the function itself. So we just have to acknowledge that we know it's not being used in the function for rust. So we'll give the underscore there, then we're good to go. Now we have create and we have update. All that's left is to be able to delete our entries.
00:13:22.028 - 00:14:09.074, Speaker A: So we'll do delete entry. Now once again we'll pass through our context as the first argument, and we'll go down to define that. So we'll copy this over to do a little less typing. We're going to need once again the derive accounts macro and the instructions macro to pass the additional data of the title through. Now we have our struct is going to be a delete entry and it needs to be mutable. We need to use the PDA to be able to find that specific account. Now we're not reallocating anything, so that can go away.
00:14:09.074 - 00:14:57.894, Speaker A: However, we're going to be using the close constraint with anchor. So this close constraint allows you to close the account when calling this context if you are the associated pub key. So we're going to give these rights to the owner. So if the owner runs the function, they'll just be closing the account. And now journal entry stays the same and then owner and system program stays the same as well. So we can go up here and we'll need to pass through the title since it's being used to find the PDA. We don't need to pass through a message because we're not changing any messages here.
00:14:57.894 - 00:15:34.322, Speaker A: Okay. And all we need to do here actually just return a result. So, because in the context we're passing through the delete entry data structure and within the data structure, we're defining a close constraint for the account. If the owner calls this instruction, it'll just close the account and nothing else needs to be done. So since we're not using the context and the title within the function, we can just acknowledge that here. And now we're good to go. So we're going to clean up some imports.
00:15:34.322 - 00:16:14.250, Speaker A: This shouldn't be there. And we have our anchor program with create entry, update entry, and delete entry instructions. We have our journal entry state and then the data structures for each context of the instruction handlers above. And now our program is good to go. Let's attempt to build this and make sure everything works. We'll go into the anchor directory and we are going to first sync our keys. Okay.
00:16:14.250 - 00:17:02.504, Speaker A: And then we're able to build. Okay, so you can see that the program successfully built and now we can deploy it so anchor deploy, I want to deploy on Devnet. So I'm going to specify that here. Okay, so our deploy was successful and you can see this is the program id for this deployment. So we're just going to verify everything here in our lib rs. Our program id should have updated and you can see it matches. Now we're going to check our anchor toml and our program id has been updated.
00:17:02.504 - 00:17:42.656, Speaker A: And one last place to check is in source journal exports and our program id has been updated. Okay, so when you're building the anchor program, it's generating your IDL as well as corresponding typescript types. So those will generate in your target folder. So you can see here the IDL has been updated. And then if you go to types journal, we now have our typescript types as well. Now this is being imported into our web folder. So we're going to now update the front end side of things.
00:17:42.656 - 00:18:24.386, Speaker A: So we'll enter the web folder, go to components journal and we're going to update these two files, the way that data is accessed and then how it's being displayed on the UI with the corresponding buttons. So we'll go into the data access first and as you can see when we click in, we're getting some errors because it's now checking with the newly generated types of our new anchor program. So we're going to update, this is actually our state so we'll update that. Now we want to go into how we initialize new accounts. So when we're initializing a new account, we're creating an entry. And here you can see that this function is using a generated key pair. We don't want to do that.
00:18:24.386 - 00:19:23.164, Speaker A: We want to use the public key of the wallet connected to the front end. So we're going to add in an async await here. And we also have along with the public key we have two user input values, the title and the message. So we want to add that to the title message and the owner, which is the connected public key. Now we want to define our journal entry address so we can do that by getting the public key connected to the front end find program address. Now this program address will be found by your PDA and the program id. So we're going to calculate our PDA.
00:19:23.164 - 00:19:56.078, Speaker A: Our PDA was generated by a title and the owner's public key. So we'll do title and then the owner public key. Okay. And lastly, we just need our program id. Now that we have the journal entry address we can call the program method of create journal entry. So you can just call that with program methods. And then our instruction function create entry.
00:19:56.078 - 00:20:24.334, Speaker A: Now this takes in a title and a message. We'll define the account, which is our journal entry account. And that's of type journal entry address that we just calculated. Okay, now we just call the RPC and we're good to go. So we can delete the initialize instruction that was called previously in the template. Now we just have on success. The transaction is being sent on error.
00:20:24.334 - 00:21:20.098, Speaker A: An error occurs. So one last thing is the types here need to be defined. You can see we're having does not exist on type void. So we can just go up here and create an interface for our entry argument, for our entry arguments. So we have our owner, title and message. And then we'll just pass that through here. And then lastly we just have to return the create entry.
00:21:20.098 - 00:21:45.566, Speaker A: Now we're able to access the data from calling the create entry instruction handler. Okay, now all we have left is update and delete. So we'll go in here to use the program account. We'll update the state here. And here you can see we have the old instructions from the counter program. So we're just going to get rid of that. The close will be very similar to delete.
00:21:45.566 - 00:22:33.554, Speaker A: So we'll just keep that there, see if we can save some typing. So we want to be able to update our entry. And actually our update entry is going to be very similar to our create entry. So we can just copy this over and update where it's needed. Here we're going to have to pull in the program id. So we'll add program id here. Okay, changes the update.
00:22:33.554 - 00:22:56.216, Speaker A: Update still takes in the title, the message and the owner. We need to be able to find our journal entry address from the public key and the program id. So that stays the same. Now we're changing this to update entry. We're still passing through a title and message and calling the account. And then on success we're executing the transaction on error. We're displaying an error.
00:22:56.216 - 00:23:46.564, Speaker A: Now for the delete entry we're going to be passing through the title and we're going to be calling the delete entry function. We pass through the title here. This is going to be our journal entry and the account is journal entry address. Oh, sorry, not here. Here it's just account. And then we just execute our transaction. Great.
00:23:46.564 - 00:24:32.472, Speaker A: So we just have to have the return functions here update and delete. There we go. So our data access is updated. Let's clean up our imports. And now we just have to update the UI. So creating a journal, we're going to use create entry and here in the template you're generating a new key pair. So we want to go in and use the public key attached to the UI.
00:24:32.472 - 00:26:02.262, Speaker A: We're going to have to calculate some things above. We're just going to delete this and then we need to get our public key from the wallet connector. Okay, now we have two values that are user input on the UI, so we need to be able to collect those. It's the title and the message and we'll just import usestate from react. Okay, so this is everything we need as far as our user input of owner, title and message. Now since this is setting the title, title and message to just empty as default, we want to make sure that before a user tries to execute the create entry instruction that they have filled out both the title and the message. So we're just making sure that everything is valid before trying to execute the instruction.
00:26:02.262 - 00:27:36.150, Speaker A: So we'll have a check there and we'll just make sure that title and message aren't empty. Now we need to have a function that's able to call create entry. So we'll handle submit. Now before we actually call create entry, we want to make sure that there's a public key and the form is valid. So we're just going to do a check for that. If the public key exists and if is form valid is true, we're able to create the entry. Now we have everything we need.
00:27:36.150 - 00:29:31.304, Speaker A: We just need to display this on the UI. So we're going to add in two fields for user input. So here we're just going to specify that we want to set the title as whatever value that the user is inputting into the field. So now we have our first input. The second input we'll just copy this over. This will be our message. However, I want a larger text area here because the message will probably be bigger than the title.
00:29:31.304 - 00:30:06.474, Speaker A: Okay, so now we have our user input for text. Sorry. So now we have our user input for title, our user input for message. Now we just have to create our entry. So we have a button. We'll just for consistency here. Actually we have to update the class name here because it's not an input, it is a text area.
00:30:06.474 - 00:30:43.122, Speaker A: And then on click all we're doing is just calling the handle submit function we already created. And then this will be disabled if it's pending and also if the form is not valid. Okay, great. And there we go. Our journal create is done. Now the journalist is just listing all of the journals you have with your account. We don't have to update anything here.
00:30:43.122 - 00:31:26.104, Speaker A: It stays the same as the template provided. Now we'll go down to the journal card. Each card showcases a unique PDA and we'll be able to update that PDA or delete it. So we're going to change this to our update entry and our delete entry. We're not using a memo now here we're going to once again need the public key message and title. Check if the form is valid, calculate the handle, submit and return an error if a public key is not connected. So we can actually just copy all of that over from above.
00:31:26.104 - 00:32:09.394, Speaker A: However, here we're already going to have the title and we're going to be able to derive that from the PDA. So we don't need to set a title. So then we also don't need to check for the title, we just need to check for the message. Okay. And when we're creating an entry we have our title, message and owner. And see we're getting an error that the title doesn't exist. So we actually have to query that and you can query that with account query.
00:32:09.394 - 00:32:56.756, Speaker A: And this is now update entry. And here we're getting an error that it can't be of type, string or undefined. It's undefined because we're not sure if we'll actually get that data. Like we can't guarantee it from the typescript side, which is why we have this question mark to override and say, I promise that it will be there, but we just have to do a double check here. So we're just going to in our if statement, make sure that title exists as well. Okay, so now we can update, we don't need accounts. What we're going to want to display here is the title.
00:32:56.756 - 00:34:19.624, Speaker A: So let's display, let's display our title and then we're also going to want to display the message. Okay, so on our card we're displaying the title, underneath we're displaying the message and now we want to have a button to be able to update the message if we want to. So here we're just going to remove, this was all functionality from the counter. So we'll remove this and we'll want to have the button very similar to the one above. So we're just going to have our user input for a text area for message and then have our update button. So we'll put that here. This is now update entry.
00:34:19.624 - 00:35:06.174, Speaker A: So we have a text area for message. We want to set our new message underneath we have a button to be able to update the entry. So okay, so we have our create and we have our update last. We just need our delete journal entry. So we'll just go into where close was and update it to delete. And delete takes in a title. Now we just have to define that title by querying the account.
00:35:06.174 - 00:36:01.994, Speaker A: And then same as above. Since this could be a string or undefined, we just have to verify that it's there. So if title exists, we're then able to return our function. Okay, and then we'll just change this to delete. All right, and now we're good to go. We'll go up here, clean up some imports, and now we can test it out. So NPM rundev I'm in the wrong folder.
00:36:01.994 - 00:36:25.380, Speaker A: Now we can run NPM Rundev and it is going on our local host server. So we can open that here. You can see on the front end, this is part of the template. You're able to connect your wallet. Currently we're connected to Devnet. You have a clusters tab where you can connect to any network that you want. And then you have where our journal program lives.
00:36:25.380 - 00:36:57.524, Speaker A: Now we'll just put in a title. So I'll do entry one. My message is hello, create journal entry confirm. And you can see your entry shows up on the bottom as a card. You can create as many entries as you want. So we'll make another one. Confirm the transaction.
00:36:57.524 - 00:37:40.224, Speaker A: Just make a third for fun. Confirm the transaction and you can see all of your journal entry cards show up on the UI. Now if I want to delete an entry, I can do that. Just click delete. Okay, confirm the transaction and now that entry no longer shows up. And then I can also go in and update a message. Okay, great.
00:37:40.224 - 00:37:53.144, Speaker A: So that is our journal dapp. We made a quick crud app deployed on the Solana blockchain and we're able to display it on a UI and interact with it. So awesome, thanks everyone.
