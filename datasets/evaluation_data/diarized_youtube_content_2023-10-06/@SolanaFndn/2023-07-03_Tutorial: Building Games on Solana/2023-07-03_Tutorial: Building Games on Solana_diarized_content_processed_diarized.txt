00:00:00.640 - 00:00:35.514, Speaker A: Hello everybody. I'm very happy that so many of you came here to learn about on chain games on Solana. So what we got to do today is first a little intro, then I'm going to tell you why you should build your games on Solana. Then we do a little live demo of a few games that I wrote. And then we gonna write our own on chain game. Actually two of them. And then when we still have time, we're gonna port a game to unity or depending on what you want, I will show you another on chain game, like using energy system or doing some staking or so on.
00:00:35.514 - 00:01:10.090, Speaker A: And then we have a little where to go from here section. Alright, so I'm Jonas Hahn and I worked as a game dev for many years. I worked on Forge of Empires, lost Survivor, did some indie games, worked on World of Kyodai and also contributed to the Solana Unity SDK. And now I work for Solana foundation as a developer relationship person. So why Solana? Games on Solana just makes sense. Like Solana is basically built for games. You have confirmation times of the blocks of 400 to 500 milliseconds.
00:01:10.090 - 00:01:43.524, Speaker A: The transactions fees are extremely low. It's like 0.005 sol per transaction. And yeah, you can reward your players with tokens, for example, or with nfTs. And there's always good to have some rewards for players that they feel like their time is valuable, that they spend in the games. I see that I'm here a bit in the corner, so let me try to move myself a little bit. Yeah, if you build your game on chain, it will also make it composable.
00:01:43.524 - 00:02:16.644, Speaker A: So for example, if you build a ranking program, you could just use the ranking program of another game, for example. Or your NFTs could be used in other games. Or you could build your own client for another program which someone else wrote, for example. So that totally makes sense. I'm going to put a link to a high score program that someone wrote in the comments below or in the slides later that you can download. Yeah. Then another advantage of building on Solana is it's free for all.
00:02:16.644 - 00:02:37.614, Speaker A: It's like running your own backend in the cloud. Decentralized will always be there. Like, you don't need to care about that. The servers go down. I, for example, played for a long time Ragnarok online and at some point just the european servers went down and my characters were gone. So that feels really bad. But if it's on chain, on Solana, then this basically can't happen.
00:02:37.614 - 00:03:17.254, Speaker A: And it also takes away from you, the need to take care of the accounts, you don't need backend and a database and security, but you can just let people log in with their wallets that they have anyway. For example a phantom wallet or Soulflayer or backpack or whatever. And you can just use this as a digital identity and they can use their nfts as their profile pictures and so on. They can show off what they have. So that's really good. It also replaces your payment provider. Like if you have a game and you want people to do micro transactions in it, they should like buy some in game coins so that they can buy potions and so on.
00:03:17.254 - 00:04:05.814, Speaker A: Now you can do this with SPL tokens or Sol, so that takes that away. And also when you release it on mobile, then you save the 30% fee that Apple and Google usually take. This is, yeah, this is I would say very useful, but it's a bit hard still to get into the iOS store. Like I tried with a few games and as soon as you have an NFT in the game and you give it utility, then you need to purchase this via in app purchases on the Apple Store. That's of course because they want a 30% fee, so it's kind of understandable. But to get around this, you would probably need to be implementing your own like minting via in app purchases on iOS. So it would be a nice project if someone wants to tackle that, maybe.
00:04:05.814 - 00:04:44.418, Speaker A: Yeah, and you have a very engaged target audience like the people that are already on Solana and like games, they stick to your games, they are excited about it. And yeah, now is currently a good time to be like the first ones who are on the new saga phone, the Solana phone that they are releasing. And also there is the new wallet called backpack. And the backpack has x nfts. I'm going to show you one of them later. And these xnfts are basically nfts that you can execute. So you can put your xnft in the backpack wallet and then people can click on it and directly play it in the wallet.
00:04:44.418 - 00:05:15.164, Speaker A: So that's really cool system. Then there are also some reasons why you should not build on chain. Like crypto is not for every game. Like you should try to find something why crypto makes sense for your game and not just try to flange it on top. Better of come up with the on chain first idea if you want to build an on chain game and then build on top of that. And the regulations are not really clear yet. Like if you release a token and then you, like, sell it or you let people gamble with it.
00:05:15.164 - 00:05:55.464, Speaker A: Yeah, you need to take care of the regulations in your country. Like, for example, if you have gambling laws or money laundering laws, or it could be seen as a security, for example. So all of that you need to keep in mind. And it's kind of hard to make real time games on chain because the block times are 500 milliseconds. So basically you can only have a state transition every 500 milliseconds confirmed. So, like, if you have a shooter, that's probably not fast enough. But if you have something like warms, for example, where you, like, put the angle, and then you shoot a rocket that flies slowly, that is something you could probably still build on chain.
00:05:55.464 - 00:06:14.614, Speaker A: So I'm gonna show you some example games that are possible, like, just to show you what's possible to build on chain. For example, I have this game here. It's called Soul Hunter. No, that's a tiny adventure. This one is Soul hunter. Tiny adventure we gotta build later. This is also not soul hunter.
00:06:14.614 - 00:06:51.080, Speaker A: Sorry. Let me quickly open this up. So this is the game I wanted to show you first. It's a completely on chain multiplayer action adventure game, basically. So there's one state on the blockchain, which is this grid here. So it's an account which has like four x, four tiles, and every tile has a public key of the player and avatar public key, which is the NFT, and it has some soul saved. So if I now, for example, spawn another character with another wallet, I just minted this little 3d nft here.
00:06:51.080 - 00:07:28.138, Speaker A: I can select it, I can spawn this player, and then if I go to the other instance of the game, I can see that there's this car now, and if I walk up there, then I kill the other player and I steal his soul. So you can see it has an auto approved wallet. So you basically deposit some soul in the in game wallet and then later you can just withdraw it again. So like this, you can have a very fluid gameplay. You can just, like, auto proof the transactions in the client and you don't need to click the proof on Phantom all the time. And there's also this chest spawned here, like whenever you spawn in your character. And you can also collect it for some soul.
00:07:28.138 - 00:07:52.806, Speaker A: So if any one of you want to try it out, you can just go to this URL and collect the chest now and get some free soul. Yeah, this is the life. And it also works on mobile. So from unity, if you build your game in unity, you can easily just export it to Android and iOS. And, yeah, it will work the same way. Then another game I wanted to show you that I found recently is really cool. Like, Solana plays Pokemon.
00:07:52.806 - 00:08:37.914, Speaker A: So basically what you do is you play this Pokemon game Boy game, and on the bottom you vote for certain key presses, and then, like, I don't know if you have seen this, like, a few years ago that was on Twitch. Like, Twitch plays Pokemon, and there was a chat on the side that controlled this game. And here now you have, like, just people playing this game together and voting for the moves on chain on Solana. So I found this really exciting, and there's lots of possibilities here. Like, you can first of all build any Game Boy game, but you could also. They could even try to make Mario. Like, if you decrease the frame rate by a lot, then you could have people vote on jump or something like this.
00:08:37.914 - 00:09:19.044, Speaker A: Would be interesting to have a playthrough of Mario on chain, actually. Then the next thing I wanted to show you is it's a game that was recently released to one of the hackathons. It's Lumia online. It's still very basic, but if you want to have an example of how to build an adventure game, like, you can kill monsters and you have missions and you can spawn something, I really like learning by example. So that's why I'm showing you these. I would like just looking at the source code, and if I have an idea what I want to do, like, hey, I want to do something with tokens in the game on chain. Then I look up a game that did it, and then I read through the code, and then I have a good example of how it works.
00:09:19.044 - 00:10:03.282, Speaker A: Then, like, one of the first games that ever released on chain on Solana was Laddercaster. They joined, like, I think almost all the hacker houses. And, yeah, what you can do is you can walk around, you can collect things, you get tokens, you can get items, and they have this interesting crank system. So whenever you want to proceed to the next round, someone needs to press the button to create the account for the next round. So that's also an interesting game. And, like, one of the most amazing on chain games I've seen so far is Kyo Gen cash clash Kyogen Clash by Dominari. And he's using an entity component system that jump crypto build from.
00:10:03.282 - 00:10:26.624, Speaker A: It's called Ark, and it's basically a system where you can have entities on chain. Like, for example, you have a character, it could be an NFT, and it has certain traits that you can just put on it. There's a little video here and there. It can be played on a big map. There are buildings that spawn units. You can move units. These units fight each other.
00:10:26.624 - 00:10:48.194, Speaker A: And it's also released on the, in the Xnft as a. In the backpack as an XNFT. So I would recommend you try this one out. That's really amazing. But now let's do some live coding. So we gonna build this game here. Now, it's called tiny adventure.
00:10:48.194 - 00:11:34.944, Speaker A: And it's not much, but it's honest work. So you can press here, get data, and you can move left and you can move right. So, and in the end, if you reach the end, the character will be super happy. So I move right here, and now I reach the end and the character is happy. And how we're going to build this is there is this thing called Solana Playground, which is basically a web UI where you can build and deploy and test your Solana programs. And what we're going to do is we go to beta SoLPG IO tutorials. Since I uploaded this tutorial already, the tiny adventure.
00:11:34.944 - 00:12:05.204, Speaker A: There's also some instructions here if you want to read it yourself. You can do that. But we're going to go now step by step, how you would build and deploy such a program. So the first thing you need to do is you click here on the bottom left to create a wallet. It will probably ask you to add some seed phrase and write down your seed phrase. And then you have a wallet in the playground that will be used to deploy the programs. This will be the update authority for your programs.
00:12:05.204 - 00:12:57.162, Speaker A: And yes, let's build this thing. So for that, you just need to type build, and then it's building the project and it will update this id up here. So we can look at this by going to the Solana explorer and we go on definite, and then we type in this, we paste in this address of this program and then we can see here already. Okay, it is deployed, it is still upgradable, it is executable, which means it's a program. And yeah, now this program is already deployed. And now you can also do the same thing by clicking here on build, by the way. And here on the bottom left, you have different endpoints that you can pick.
00:12:57.162 - 00:13:34.106, Speaker A: So I'm now on DeFnet, but if you have some problems, like for example, getting an airdrop or getting errors when you deploy the program, you can pick different ones here. So probably what you need to do before you deploy the program is to get some airdrop. So you can just type Solana airdrop two. And this will does an RPC call to the RPC and we'll just airdrop you some free definite soil. Okay, so that worked. Now we can deploy the program. And for me it says now I don't have the upgrade authority for this one.
00:13:34.106 - 00:14:04.854, Speaker A: So I guess I did something wrong earlier. So I just gonna create a new one and then deploy this. You shouldn't do this. Maybe like this, you lose your upgrade authority if you haven't saved it before. But in my case this is. Okay, so now, yeah, deploying this then this will be on chain so we can look at the signatures. What this does now, it basically builds the program.
00:14:04.854 - 00:14:35.544, Speaker A: This creates an so file. And this so file will then be put into the data of this account. And it does a lot of transactions because the transaction size is limited. On Solana you can only send 1232 bytes. So it needs a lot of transactions to deploy this program, actually. Okay, now it's deployed. Now the first thing we're going to do is we just run this client.
00:14:35.544 - 00:14:59.764, Speaker A: So we just run it. The declared program id doesn't fit. Okay, so we need to let me quickly. Yeah, it's because I created this new key pair. Now I also have a new program id. So let's quickly do this again, deploy it again. So I just copied this program id here and put it into the declare id in the LiBRs.
00:14:59.764 - 00:15:45.286, Speaker A: Okay, so now let's run this finally. So we just type run and we can already see here it says, a journey begins, you are at the start, and then it walks one place to the right. But how does that work? So first of all, congratulations, you deployed your first Solana game on chain on Devnet. So that's really nice. Okay, so the first thing we do here is we create a program account for our level. So what this means is this is called a PDA. And what this means, it's an address on Solana, which is derived from the program id and some seat.
00:15:45.286 - 00:16:26.964, Speaker A: So in this case, we just put a string here, it's level one. So this will basically find us an account which is owned by the program, which the program will be able to sign for. The program can change this account as it wishes, and it has a seat of level one. So you can think of this as a database entry, basically, where the table is the program id and the seats are, are all the different entries. And in this address here, we're going to save the position of the player. So, and then what we do is we see if the account is already there. And if it's not already there, then we initialize the account, and then we call move right on this account.
00:16:26.964 - 00:17:02.394, Speaker A: So now let's look at how this looks like in our program. So this is a Solana program. It is written in rust, and it uses the anchor framework. The anchor framework is just something that is put on top of normal Solana programs to make working with them easier. So it enables you to have nice serialization of accounts. It enables you to do some signup checks. And basically it just makes everything a bit easier to work with on Solana.
00:17:02.394 - 00:17:34.218, Speaker A: So everything in this game that we care about, basically, is this player position here. And we don't actually do much in the game. Like, all we do is we create this data game data account with the player position. And then we have a move right instruction which increases it by one. And we have a move left instruction which decreases it by one. So here we can see how we initialize the account. The struct is called initialize.
00:17:34.218 - 00:18:13.016, Speaker A: And here we can see the same seeds that we put in, into this account in the client. So we have again the string level one. Then we have init if needed, which just means it will create a new account, and the payer of this will be the signer. So if we send this transaction, transaction to the program, then viva pay for the space that this needs on chain. In this case, the space is eight plus one. Eight is just the default account discriminator that anchor creates. So it puts a little discriminator on the beginning of the data so that it knows which account it is.
00:18:13.016 - 00:18:38.814, Speaker A: And then we have just one, which is our u eight. So this is like, we can go from zero to 244. Yeah, 454. Sorry. Yeah. Then we have the signer and we need to put in the system program, because the system program is always needed to create a new account. And on Solana, you always need to pass in all the accounts that the transaction needs.
00:18:38.814 - 00:19:10.504, Speaker A: So this is for Solana to be able to paralyze the execution of many transactions. So basically, all transactions that don't try to write on the same account can be done in parallel, because they don't influence each other. And this makes Solana so much faster than many other blockchains. Okay, this is the initialize struct. And this here is the initialize instruction. And all it does, it sets the player position to zero and it prints. The journey begins.
00:19:10.504 - 00:19:51.454, Speaker A: And this little animation here of the character being at the start of his journey. Then the next thing we gonna do is we gonna move left or maybe let's move right first, because we start on the left. So what we do here is we put in the move right context. As you can see, this is again a list of accounts. In this case, we only need the game data account because it's the only one we need to, we want to change. So we put in this account, and then we can load the account from the context accounts, game data account. And then we can check if the player position is three, then we know, hey, the player already reached the end.
00:19:51.454 - 00:20:21.504, Speaker A: And we say, hey, that was super. And if he's not at the end, then we increase the player position by one. So we just take the player position and say, hey, it's equal to player position plus one. And then we print the player position. This is just a little function here which just says, like, if the player position is zero, we say a journey begins, and if it's less, it goes to three, then you have the end, you reach the end. And this is super. So let's go back to the client now.
00:20:21.504 - 00:20:46.630, Speaker A: So now we learned already how to create a PDA. We learned how to initialize an account. So we just call playground program methods initialize. Then we put in all the accounts that we need. In this case, it's only the new game data account, the signer. In this case we need because we want to pay for the account and the system program for creating the account. Exactly.
00:20:46.630 - 00:21:14.636, Speaker A: And then we put in the key pair so that we can sign this. And then we just confirm the transaction. And also in the client, we print, print a little game animation. And here, now you can like play around a little bit. So let's, let's run this again, for example. So we run, and now we can see we are at position three. And if I run this again, then, hey, we have position three, so we can also move left.
00:21:14.636 - 00:21:45.418, Speaker A: So I can just comment this in and comment the moveleft function out. And then, yeah, we are at position two again. And the nice thing is you can always take this. I think you can copy this whole thing here, actually paste it in here, and then it will show you the transaction. I usually find it nicer to look at the transaction in the explorer. So what I usually do is I just copy paste this id and put it in here. I really got used to the Solana Explorer.
00:21:45.418 - 00:22:10.704, Speaker A: Like, to me, it shows everything in a nice way. So here you can see this is our account. It has like a tiny balance. It's quite interesting, actually. If you have this cli installed, you can just write Solana rent and then we can say, how much does it cost to pay for nine byte, which is the account size. So in this case we can see it's 0.009,535 z.
00:22:10.704 - 00:22:44.734, Speaker A: And that's exactly the balance that this account has for it, like, to be rent exempt so that it forever stays on the chain. Yeah. And this is just our program. And here we can also see, hey, we moved left and we are at position two here. So this is already it for the first game. So what you could do now is, for example, you could like write a longer story about this, send it to your friends, let them play it. But now we're going to go to the next example because we want to have a bit more.
00:22:44.734 - 00:23:30.006, Speaker A: So what we're going to do in this example is we're going to build our first play to earn game. So what this means is what we're going to do for this program is we gonna transfer some soil into PDA, so into a chest vault. And then when the player reaches the end and opens the chest, then he will get the soul that's in this chest. You can already see here it's represented with this little diamond. And let's, in this case go again first to the program. So what you can see here in line 14 is the chest reward. It's just the leopards per soil, which is like 100 million or 10 million or something, and then divide it by ten.
00:23:30.006 - 00:23:56.834, Speaker A: And this is just reward. So it will be 0.1. So here we already have like a little error that I actually, I wanted to show you later how this is done. So let's quickly remove this. So, yeah, so what we're going to do is the same thing as before. We initialize the level, then we have a new instruction. Now it's called reset level and spawn chest.
00:23:56.834 - 00:24:31.830, Speaker A: What this one does, it sets the player to the beginning of the level and then it transfers some soil into a chest vault. And this is done by doing a so called cross program invocation. All it does, basically is from our program, we call the system program to do a transfer. So for that we create a cross program invocation context. Then we put in the program that it should be calling. In this case it's a system program. Then we put here the instruction that we want to call.
00:24:31.830 - 00:25:06.684, Speaker A: In this case it's transfer and we want to call transfer from the payer, which is the account that calls this function. And we gonna transfer it to the chest vault. Going to show you later how we created the chest vault. But yeah, now we transfer the chest reward soil to this chest vault. And then we just type, hey, we reset the level and we spawned a chest at position three. So we need to walk three times to collect this chest. And now we have like a little bit difference also in the move right account.
00:25:06.684 - 00:25:40.214, Speaker A: So what we do here is we get the game data account again. We check if it's already at the end, then we say, hey, you just reached the end. But if he is at position two now and he wants to move to the right, then we know in the next step he will collect the chest. So what we do here is, hey, you made it. You will get this reward. And here you can see that it looks a little bit different than how we transferred this soil into the chest vault. Because our chest vault account is a PDA, so it is owned by our program.
00:25:40.214 - 00:26:24.036, Speaker A: And you can only do cross program invocations to the system program with system accounts. A system account is basically every account on Solana when you create it. So like all your wallets, they are all system accounts. And yeah, to get around this limitation, what we do is just, we subtract the lamp words from the just world account and then we add the lampards to the player account. So, yeah, that's what you can always do. Like, when you are the signer of a program, you can change the lamp words of this account. And in this case, the player will be the signer of this transaction.
00:26:24.036 - 00:27:05.674, Speaker A: So the program is the PDA and the program owns this PDA. So the program can change the leopards of this PDA. And you can always just increase the lamp holds of another account. Only thing that's very important, of course, is that in the end of your transactions, all the balances of all accounts need to be equal. Otherwise the Solana runtime will just say, hey, you can't create soil out of thin air. Okay, this is already how we send soil back out of our chest vault account. And then we here have the print player now with this little diamond.
00:27:05.674 - 00:27:46.954, Speaker A: And the accounts here are almost the same. So the level one is the same as in the first example, but the second account now is the chest vault, and it's created like the other one. So it's like just here init. If needed, you can also just say init because otherwise you could call this function multiple times and maybe you don't want this. So just like give this back and the space will be eight kilobyte, eight byte in this case, because we don't have any data in the chest vault account. As you can see, it's just empty. So all it needs is the eight byte for the account discriminator.
00:27:46.954 - 00:28:22.584, Speaker A: And then we have here the spawn chest. This is also like just putting the account chest vault. And what's kind of important is that you put also the seats in here. What Solana does in the anchor does in the background is it checks that the seats are correct. And if the account is really owned by the program, like if you don't do this, you could, for example, just put in another account. So this is like a security concern. You could spawn a chest, but as a payer or as a chest vault, you put in your own account.
00:28:22.584 - 00:28:57.064, Speaker A: So that would mean you would reset the level, but you would transfer the cell that's supposed to go in the chest to your own account. So that's something you always need to keep in mind that you put the right checks on these accounts and then you are here for the move. Right. It's the same. We also need to put in the chest vault because all accounts that are interacted with in Solana need to be in the instruction. Yeah, that's already the program. Not much like the most important things are the CPI and how you transfer soil from one account to another.
00:28:57.064 - 00:29:20.512, Speaker A: Now we're going to look at the JavaScript client. Let's quickly build and deploy this. I hope I have the correct update authority now, otherwise I quickly need to create a new one. Maybe I can just run this. I think I deployed earlier already. Yeah. So this is looking good here.
00:29:20.512 - 00:29:40.112, Speaker A: We can see that this is our chest balance. B our sole balance before we spawn. Before we spawn suggest. This is the sole balance after we spawn suggest. So it has 0.1 so less in the account now. Then we walk to position one, then we walk to position two.
00:29:40.112 - 00:30:14.524, Speaker A: Then we walk to position three. And here we can see, hey, we collected the chest and we got the soil back from the chest. So how this looks like here we create the PDA, again, here we create the PDA for the chest vault. It's just the same thing as the player data account. Just the string is now chest vault. You can put whatever you want here. And if you want like a game that can be played by only one person, then you could for example, put in here also the public key of the player, and then you would have one instance per player.
00:30:14.524 - 00:30:43.074, Speaker A: Oops. Here we initialize level one. We just need to put in all the accounts that will be created and the signer again pays for these accounts. Then what we do is we reset the level and spawn the chest. So we pay 0.1 sol transfer it into the chest vault. And then from there on, we can collect it later if we walk now three times to the right.
00:30:43.074 - 00:30:56.974, Speaker A: So this like just a for loop. One, two, three. And then we move right. We move right. We move right. And when we are at the last position, then we can collect this account. This all in the, in the account.
00:30:56.974 - 00:31:32.464, Speaker A: So now let's change this thing a little bit. Like, let's say, for example, we don't want everyone to be able to collect the chest, but we want only people to be able to collect the chest who know the password. So now you can like maybe pause a little bit and try to implement this yourself. Maybe you saw it earlier already before I deleted it, but I got to come back in a few minutes and then you can, yeah, try it out yourself. So I guess a bunch of you already figured it out. So all we need to do is we put a password here. It's a string.
00:31:32.464 - 00:32:24.986, Speaker A: And then we just check here. If password unequal, for example, gib, German for GiF. Then we can just say, we just say error or no, I think we need to, like, we can just panic and say, oh no, the password was wrong. So what this does is like, as soon as the password is not correct, it will just program will panic and we will, yeah, the game will stop. I think this actually needs to be here. So I got a build and deploy this, and then we gonna run and look at the error. So now in the client, we also need to provide a password, of course.
00:32:24.986 - 00:32:57.090, Speaker A: So first let's put a wrong one. So we just could put kip hair. Then we run this and we can see, like we can reset the cell chest, we can walk up, but then the last one will fail. And, yeah, because we didn't put the right password. So if we now put the right password, then we can just type run again, and then we will be able to collect the chest because the check in the back end does check. If we collect it. If we can collect it.
00:32:57.090 - 00:33:29.090, Speaker A: So this looking good. We collected the chest. So a little tip here. If you want to see the error on chain, then what you need to do here is you need to put in some parameters for the RPC call. So usually what the RPC calls do is like there's a sync simulation step before you send the transaction. And if this one fails, then the playground doesn't send it out. But you can skip this check by just providing here, skip preflight.
00:33:29.090 - 00:34:04.638, Speaker A: True. And now if I run this, I will get the transaction even though it would fail. The transaction hash. So I will copy this one, put it here in the explorer, and then we can see this one went through because the password is correct. If I put the wrong password, that's what I wanted to show you. Like if the password is wrong and I skipped a preflight checks, then the transaction would go through and it would fail on chain. So this is sometimes helpful if you want to investigate some errors.
00:34:04.638 - 00:35:00.698, Speaker A: The only thing that's not good about it is that you always have to pay the fee for the transaction and then it would fail anyway. But they are cheap so it's not that a big deal. So here we can see, hey, it panicked at auto or the password was wrong, so maybe we fix the typos. So and then what you can do, what's actually like a little bit nicer to do is that you create a real error code. So we try to create this here. So we do, I can cheat a little bit because I'm not so sure always how this, how the syntax is of this. That's a nice thing I like about working locally in visual studio instead of playground actually is that you have auto completion.
00:35:00.698 - 00:35:47.594, Speaker A: It will come soon to playground as well, probably. And you can also use some AI like copilot for example, which helps you a bit. So I just going to copy this over here. So what we create is like we create a custom error, we say, hey, the password was wrong and we say wrong password. And then here on the bottom we just return an error instead of panicking. So like this, now we have a proper error, and then you can also properly handle it in the client. You can for example say like show different error messages when the password is wrong, or show another error when the player doesn't have enough soil, or when he walked against the wall or whatever.
00:35:47.594 - 00:36:45.576, Speaker A: So now that we learned about how to write a program, let's go a little bit back to the document, to the slides and do some theory about it. So this is what we did today. Like we created first the game Tinyadventure, and here you can see like we had the data account, which has the representation in ASCII with the little character walking around. We just have move left which decreases the value, and we have move right which increases the value. Then I want to quickly show you or explain you what actually happens with the transaction. So here we have the client and the client, in our case in the playground it was the JavaScript client, but you can build clients in many languages. I will later show you the Unity SDK, for example, where you can just write your Solana program clients in C sharp, and you can also write it in Python and so on.
00:36:45.576 - 00:37:26.204, Speaker A: So what you do is you create a transaction, and in this transaction you create an instruction, in this case, the move write instruction. This one is then sent to one of the RPC nodes. This is the URL that you put in when you create a transaction. When you create a connection to an RPC node, usually you would just use Defnet, dot solara.com or something, but you can also get RPC nodes from helios, for example, or from quick note. And usually the ones that you pay for are a bit faster. And normal Solana ones shouldn't be used in production since they are very heavily rate limited.
00:37:26.204 - 00:38:26.474, Speaker A: Anyway, this transaction gets serialized and then it gets sent to one of these RPC nodes, and then it's going to be sent directly to the leader of the validators. So in Solana, every block you have, or, or every few blocks you have a different leader, and the leader create the block, and then all the validators validate that the block is correct, actually. And then, so it's sent to the validator, it updates its state, and then the state is in small chunks sent back to all the RPC nodes. These little chunks of the smallest chunk of a block is actually called a shredded. Maybe you saw this somewhere when people discuss on Twitter. And yeah, then the RPC node updates his state. And from the client we can open a Websocket connection to this RPC node, and then as soon as the account changes, it will be pushed to our client.
00:38:26.474 - 00:39:19.606, Speaker A: So that's very good for games. Like if I, for example, show you this game here again, then we can see that almost as soon as I, as I approve the transaction, I already get the update. So this is like less than a second. And what makes it so fast is that I'm not like polling the data, for example, like every second or every few hundred milliseconds, but I have a websocket connection to the state, and as soon as the account changes, in this case our game data account, it gets pushed to the client and we can immediately update. So that is very good. And this is very fast on Solana, then. Yeah, this is tiny adventure two, and it's basically the same as before, just that we now have also the chest vault account with the seeds and the lampards that are in there.
00:39:19.606 - 00:40:07.680, Speaker A: And yeah, we looked at it already in the code, so I don't need to go into too much into detail, but as soon as we reach position three, we transfer this all to the player. And this can be used for all kinds of things. Like imagine what you could do now with this game is you could, instead of moving left and right, you could create a grid like I did in Soul Hunter, and you can let the player move left, right, up, down. You could have some quiz games where people need to put in the correct answers. This could also be a multiplayer game. And yeah, I'm going to show a few more examples, maybe later if we still have time. What I want to show you now is how you can build a client for this game in unity.
00:40:07.680 - 00:40:46.564, Speaker A: So using the Solana Unity SDK. It's currently maintained by Magic block and it's open source. So you can either just include it into your game like this, but it is also now a verified solution in the Unity asset store. So you can just very conveniently include it like this in your project. It also has a decent documentation. So Solana Unity SDK GG, you can like there are some sample scenes where you can connect your wallet configurations, how you do token accounts and so on. So that is very nice.
00:40:46.564 - 00:41:45.338, Speaker A: And, but it's a bit inconvenient to like create these account discriminators and all that stuff by hand. So there's a very cool thing that you can do is you can generate a c sharp client from the code that is in the IDL, and an IDL is a JSON representation of your program. So if you're in the playground, you can go here on this little hammer icon and then click on IDL and export it. And I did this before already. And then you can get this, this JSON file here. And how this looks like is just basically a representation of all the accounts and the data that you need to call these functions in a JSON representation. And what you can do with that is you can convert this into a c sharp client.
00:41:45.338 - 00:42:19.906, Speaker A: So for that you install this tool here, Solana unity anchor tool. And then you just call this command here, it just has an.net Anchorgen, then it has one input is the IDL file, and then it exports you c hash client. So let's quickly do that here.net anchorgen. And then I put in the JSON file I just downloaded from playground, which is the tiny adventure. So tiny Jason and then we say o should be the output.
00:42:19.906 - 00:42:59.774, Speaker A: And then we just say tiny dot cs. And what this does is it creates us this c sharp file here and we can open this and here we can see it has everything that we also had in the JavaScript client. So it has the move right insertion has all the data for the chest vault account. It even has our little error here. So this is tiny adventure two, actually. Yeah, it has, you can get all the data, so you can just say, hey, give me the current data account. Like give me the position of the player and you can just very conveniently call these from c hash.
00:42:59.774 - 00:43:33.444, Speaker A: And then you can build your game in unity and export it as Webgl. For example. This is how the tiny adventure t two would look like. So if I move right here without a password, which I should get an error. Actually, maybe I have the wrong program id in this one. And this is how the JavaScript and the C hash code look side by side. So you can see it's almost the same.
00:43:33.444 - 00:44:16.714, Speaker A: Like you create a transaction, you set a fee payer, you get a recent block hash if you're interested. Like this block hash is only there actually so that the validators know when they should have a transaction expired. So these block hashes are valid for like 30 seconds. So you can just put the block hash and then reuse it for a few seconds and then get a new one. This is a tiny performance improvement. If you're in a game, then you might not want to do an RPC call to get the blockhash and then put it in the transaction. But you can already prefetch them and then you have a few milliseconds that your game is even faster.
00:44:16.714 - 00:44:58.166, Speaker A: And yeah, this is the same how it looks like in c hash. Basically you just create a transaction, you set a fee payer, the block hash, put your instruction, put a signature, and then you send it. And the unity SDK also supports a bunch of things already. So you can connect to your phantom wallet, you can connect on mobile to Phantom via deep links. So you can actually build a mobile casual game with this now if you want. And yeah, if you still have time, I could now show you a little bit about client in unity. So now we are in unity.
00:44:58.166 - 00:45:24.234, Speaker A: So I quickly got to show you how the code looks like this in unity. We just go to the tiny adventure service. You can just check out this repository later and then try it out yourself. You just need to like check out the repository and start the tiny adventure scene. And then you will have the same as here. So here you can see we did the same thing as in the playground. So we define the program id.
00:45:24.234 - 00:46:02.184, Speaker A: In this case it's tiny something. Then in awake we create the program address. Like we find the PDA, it's the same thing again, the string and the program ID and a bump. Then here we do the socket connection so that we always get direct updates from the account. So we just subscribe to pub key data with the game data account PDA. Then we deserialize the data and then we publish the data. And in the tiny adventure screen we are listening to this change and then we update the game data view.
00:46:02.184 - 00:47:03.414, Speaker A: And all we do here is basically the same thing. Again we just show a string and yeah, this is how you can get the data, you just do get account info async and this is how you initialize, move left, move right and here's how you would create the whole transaction. So the same thing we did, before we create a transaction, we set a fee payer, we get a recent blockage and then we put our move left instruction. And this one is just like from our program that we created from the IDL. We can set the account here, then we can just from our tiny adventure program get the move left instruction, put in the account and the program id, and then we can send this transaction to move the player. Yeah, so this is how it looks like in unity. So in c hash.
00:47:03.414 - 00:48:16.860, Speaker A: But I also want to quickly show you how it would look like if you build a react client. So for this one I will also put it into the description or in the slides later you can download. But this is how it looks like if you build it in JavaScript. So you can basically build a client in whatever you want for this. So I connect my wallet, I move right, I approve and then I move and yeah, it's basically always the same here we print the player position, then we click on initialize, we just do program method, initialize, put in the accounts, say transaction, and then in this case, like in react, we use the Solana mobile Solana wallet adapter to send the transaction. So this creates this nice button here where you can use different wallets because currently the unity SDK only supports Phantom Wallet or I think also soulflare. But yeah, this is how you do it in JavaScript.
00:48:16.860 - 00:49:03.596, Speaker A: Like when I click on the button right, then I do the move right instruction, I put in the game data account, I create a transaction. So it's a transaction builder. And then in this case we use the transaction builder and we confirm the transaction with the latest block hash. So now that you know how to build an on Chain game on Solana and also build different clients for it, where can you go from here? So I have a few game ideas that I just wrote down. We can brainstorm later a little bit when the stream is over. What else we could do? But you could, for example, build a proper Solana Royale. Like you could take the Soul Hunter source code, it's open source.
00:49:03.596 - 00:49:31.510, Speaker A: And then you could improve on it. Like you could, for example, have people shoot, you could have a round timer that only every 5 seconds you can move. You could have a castle that spawns units. You could try to build a tower defense game even. It's maybe a bit more complicated because you need to synchronize the times between the clients. But if someone can pull it off, that would be really cool. Then any kind of trading card game would be great.
00:49:31.510 - 00:50:01.910, Speaker A: Of course, like Hearthstone for example, where the cards could be nfts and you play them. And then, yeah, you have this round based game basically. Then something like puzzle pirates would be cool. Like, I don't know if you know this, but it's like what's a very popular game with a lot of minigames? You could have a match three game on game. I think someone did this already. Now, like for the grizzly thun, it's called Dee's quest, so you can look it up. It's also open source, by the way.
00:50:01.910 - 00:50:32.146, Speaker A: It has a very interesting matchmaking, which is on chain, so that's definitely worth checking out. It's also fun to play. Like you pick your nfts and they have different stats, and depending on which things you match, you attack the player. So it's really cool. Any kind of idle game is of course perfect because you could just calculate the times. And whenever you do a request to your program, you could calculate how much time passed and what the player gets for it. So you could just generate some tokens and give them to the player.
00:50:32.146 - 00:51:00.382, Speaker A: And if you want to call transactions in the future, you can use clockwork. That's also very interesting. Project clockwork in XYZ, I think it is. So this is like a framework where you can automate transactions to be performed in the future. So that's also something you could look into then. Yeah, chess, of course, is really cool. There's already an open source chess game, and poker would be cool.
00:51:00.382 - 00:51:33.574, Speaker A: The thing with poker is the same problem that we had earlier with the password. Actually we did in the program. Like as soon as you call the transaction, everyone can see the password because you need to put it in as the data. So it's quite hard to hide data on chain. Actually, there's a few games who do it already. I'm gonna put the links for that. Also in the slides, there's a bonk paper scissors game, for example, where you hide the data on chain on your client and at some point you need to reveal and then the game decides who wins.
00:51:33.574 - 00:52:17.310, Speaker A: Then you could also build something like boulder dish, I don't know if someone still knows. It's like where you walk around and then stones fall down. Something like this could be cool, or like we said earlier, worms game, for example, or some location based games. And also would be really cool if someone builds an Airbnb on Solana. Actually, I mean, it's a bit off topic since it's not a game, but would be really cool if you could just pay for your flats in with crypto and then the entry for the flat could, for example, be an NFT that gets burned after your time is up. Or you could save them and have some kind of travel book or something. So that would be really cool.
00:52:17.310 - 00:52:46.006, Speaker A: Here are a bunch of resources that you can look at later. I'm going to put a few more links in these and yeah, thank you very much for listening and I hope you learned something about building games. And I hope you're going to build some games. Let me know. You can find me on Twitter solplay Jonas. And yeah, I'm always interested and excited about new games. So if you build something, just send them to me or link me on your posts about it.
00:52:46.006 - 00:53:02.286, Speaker A: And yeah, tell everyone about it. Like get it out early, get feedback from the community playtest, iterate on your games. And yeah, I hope I'm gonna see you at one of the hacker houses from Solana and see you next time. Bye.
