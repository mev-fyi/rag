00:00:03.960 - 00:00:39.104, Speaker A: I think third time I'm coming on stage. So, yeah, hope, hope I'm not boring enough. All right, so, going to kick off with Explorekit. So, over the past two sessions we had yesterday, we've been talking about explorers, how explorers can value add applications that you're building in general. But we didn't really showcase any tooling that's available for you to use as a form of an open source SDK. So that's what we're going to do today. We're going to open source our parsers because we know everyone else will value add themselves from here.
00:00:39.104 - 00:01:22.282, Speaker A: So before we begin, so the two of us, I'm Nick, I'm one of the co founders of SFM, or in short, Solana FM. And Zem is one of our engineers. So he's the one who pioneered the kit, and I'm just the one trying to showcase the tremendous beauty that he and his team have been building this for the past couple of months. So what's Ek? So, Ek is a parser. It parses everything in one unified standard. By everything, we mean everything, we mean transactions, accounts, events, and even errors. So you probably would have guessed by now that there is only one standard available today.
00:01:22.282 - 00:01:29.454, Speaker A: So there's idls. So everything is in idls. So why would you need to do or have this standard?
00:01:29.494 - 00:01:29.838, Speaker B: Right?
00:01:29.926 - 00:02:09.264, Speaker A: So when we look at an instruction in the current explorer in Solana FM, you will notice that instructions like the Phoenix order book program not being shown. It's not decoded, it's not deserialized. So we need to find a way to solve this. And when we plug in EK right in, you will get a very beautiful deserialized dataset here. So what's the bus like? What's so special about this? What's special about this is not that it's covering idls, but even native programs are covered in idls. So native programs in the new explorer are all parsed with idls. Nothing is written in rust.
00:02:09.264 - 00:02:45.552, Speaker A: Everything is just in idls. So another example is the SPO stick pool program. You probably know most of these things are all written in rust, but none of the things that we were writing here are written in rust. So everything is in idls. So here's yet another example of what we're capable of doing with just one SDK. So you want to parse everything, you just use EK and you go straight right on. You don't have to spend so much time building an abstraction to parse maybe one program, and then you move on to another program and write another support for that.
00:02:45.552 - 00:03:17.784, Speaker A: So simply put, you just have one simple SDK and you're good to go. So here's another example, right? You don't get to see most of the instructions, and you also get to see events. So the Noop program and several other types of event emissions standards would probably be supported in EK as well. So without further ado, I don't want to cover too many advantages that we have here without showing the actual use case. So I'm going to pass everything on to Zem for now.
00:03:18.404 - 00:04:50.202, Speaker C: Hi, I'm Zamil, a software engineer at SLA FM. And traditionally, how did Explorerkit come about? Was explorers usually for us, there's a lot of programs out there like Phoenix or token metadata that wants their data to be passed on our explorer. But if you've been explorer before or you have tried buildings, a data visualization tool that deals with maybe more than five programs, for example, and then they don't have, like, they usually have a typescript SDK, but this typescript SDK is troublesome to install it on your front end application because let's say if you have a Phoenix typescript SDK, you have a token metadata SDK and maybe some other programs, let's say five, for example, and then these five programs like the SDK, you'll be sending all these SDK to the client JavaScript bundle that Steve Lucher was talking about earlier in the developer stage, if you guys have been there. Yeah, so we want to try to reduce the bundle size by quite a bit. So obviously this is still not something that is very good, because currently Explorerkit is using anchor SDK as well to settle whatever passing has to be done with an anchor idea. But ExplorerKit was mainly built with the mind of trying to solve the problem with Shang generator idls. And because of Shang generator idls, then with Solita.
00:04:50.202 - 00:05:05.556, Speaker C: Solita is a typescript SDK generator based off shank itself. So with a shank generator IDL you're able to get the whole typescript SDK, which is basically what Phoenix and Token metadata was built off, like their typescript SDK.
00:05:05.660 - 00:05:05.940, Speaker B: Yeah.
00:05:05.972 - 00:05:19.596, Speaker C: So looking at the chart here, the web3 js still takes up the huge chunk of the bundle size, which explorekit as a whole in the future will try to reduce it even further, which will reduce the bundle size.
00:05:19.700 - 00:05:20.148, Speaker B: Yeah.
00:05:20.236 - 00:05:56.022, Speaker C: So I will talk about briefly on how the Explorer kit works so we can support two types of idls currently. So it's anchor based idls and shank generated idls through a kinobi tree. So the whole explorer key idea was generally very hugely inspired by how kinobi generates their idls into a set of trees and nodes. So shout out to Lauris for that. Thank you very much. And then anchor as well. So anchor has their whole layout that they can generate through an idl.
00:05:56.022 - 00:06:21.466, Speaker C: So what layout basically means is that because in the RAS structure, so let's say if your first variable of your struct is like U 64, maybe lamports, like maybe a transfer. So for transfer, usually the series of bytes just means that the first few bytes of the transfer data is. The first few is the discriminator to tell you which instruction this is.
00:06:21.570 - 00:06:21.946, Speaker B: Yeah.
00:06:22.010 - 00:06:24.866, Speaker C: And then the next few is probably lampods.
00:06:24.890 - 00:06:25.090, Speaker B: Yeah.
00:06:25.122 - 00:06:31.812, Speaker C: So it's lampods and then. Yeah, basically that's it. So this is like the layout, it's like the blueprint to deserialize the instruction itself.
00:06:31.938 - 00:06:32.456, Speaker B: Yeah.
00:06:32.560 - 00:07:03.732, Speaker C: And then we will do it, we will generate an in memory layout. So this is a bit different from what solida does because Slowita is a static generated SDK. But static generation doesn't make sense for explorers because it's not scalable as well. Let's say if a new, maybe Phoenix V two, they have a new program and then they want their data to be passed on our explorer, it doesn't make sense, like, oh, maybe at 03:00 a.m. In the morning we have to deploy the whole new Explorer again for Phoenix V two to be passed.
00:07:03.828 - 00:07:04.412, Speaker B: Yeah.
00:07:04.548 - 00:07:50.838, Speaker C: So, yeah, so that's about it. And then using Explorerkit is pretty simple. At first you have to get IDL from the package itself. So we have another package that stores mostly native program idls, currently not that much of other programs at the moment. And then once you just need to get the program hash of the program and then the use a specific line and then you can get ideas as well. So the package also supports historical idls as well, but historical idls will be communicating with our repo of idls as well. Afterwards, if you can get the base 58 encoded string of the instruction data.
00:07:50.838 - 00:08:21.494, Speaker C: So we'll be using parsing instruction as an example for this slide. Then with the encoded base 58 string you'll be able to parse it just with like maybe six lines of code. It's pretty simple for developers to use. After passing the data, you'll get something like that, which is all unified mainly because you need to know what is, what sort you can just.
00:08:21.574 - 00:08:23.374, Speaker A: Yeah, of.
00:08:23.374 - 00:08:47.254, Speaker C: Yeah, so this is the demo so far. So with this like maybe 20 lines of code. I'm able to decode an account by itself with generic. Like, the data that comes out from the parser is all the same. So, yeah. So with this then, let's see. Oh wait, actually I should show the RPC first.
00:08:47.254 - 00:09:23.374, Speaker C: Yeah. So with a normal RPC, you usually get a whole gb strings of data, which is basically for encoded. And no matter what you do, like JSon path, it will never work because I can just send it to gp strings. But if we hook up the Explorerkit to an RPC, which is our RPC, we'll get the JSON pass data on our site all run with Explorerkit. Sorry, I think I'm on the wifi. Let me.
00:09:23.874 - 00:09:30.934, Speaker A: It's quite troll sometimes. Oh boy.
00:09:31.994 - 00:09:32.874, Speaker B: Oh yeah, we got it.
00:09:32.914 - 00:10:07.170, Speaker C: Yeah, so you see, look at this. We are able to decode a, this is a jitto stake pool stake account. Yeah, so, sorry. So the initial example that I used just now was a jitto stake pool account. And with stake pool programs can't be passed normally with the RPC rust, like the thing in the RPC itself. So if you ever run a sidecar or something like that, you'll be able to get the whole state account deserialized on the RPC with just Json pass. So this is something that Explorerkit can do, and it's something that guys can try as well.
00:10:07.170 - 00:10:08.386, Speaker C: You guys can try as well.
00:10:08.490 - 00:10:09.174, Speaker B: Yeah.
00:10:10.234 - 00:10:11.214, Speaker C: Thank you.
00:10:12.354 - 00:10:12.754, Speaker B: Yeah.
00:10:12.794 - 00:10:23.900, Speaker C: So back, back to the example. So basically I tried to do the new web3 J's client just now, but I couldn't, so that's a bit tough.
00:10:23.972 - 00:10:24.220, Speaker B: Yeah.
00:10:24.252 - 00:10:36.796, Speaker C: But anyway, so basically you get a connection, basic normal stuff like that. And then you put the stake pool, like a stake pool account. Any account that you want to deserialize.
00:10:36.900 - 00:10:37.324, Speaker B: Yeah.
00:10:37.404 - 00:10:42.014, Speaker C: So afterwards you need to get the owner of the account, like usually it's just a PDA.
00:10:42.054 - 00:10:42.422, Speaker B: Right.
00:10:42.518 - 00:10:49.302, Speaker C: I'm using accounts as an example here because accounts, I think is the easiest for people to understand at the moment. I mean.
00:10:49.358 - 00:10:49.950, Speaker B: Yeah, yeah.
00:10:49.982 - 00:11:07.656, Speaker C: So afterwards you get the owner of the program, like the PDA yourself, and then afterwards you able to create a parcel. The parser, you. Oh, sorry, the parser. And then you can just type pass account, and then you literally get the whole pass account.
00:11:07.760 - 00:11:08.040, Speaker B: Yeah.
00:11:08.072 - 00:11:18.280, Speaker C: So basically that's it. Yeah. How easy is it to use Explorerkit as a developer? And I hope it's simple to use as well.
00:11:18.312 - 00:11:18.760, Speaker B: Yeah.
00:11:18.872 - 00:12:18.530, Speaker C: So I'm going back to the slides. Yeah, so what's next for Explorerkit? So I think currently the Explorerkit now is still in a very babe, not a very good, not saying not a good stage, but it's more of like, it's still only usable for explorers at the moment, I feel, because we don't have serialization support on Explorerkit, only deserialization for now, so, but serialization support should be pretty much easy to add. So other dapps can use this, can try this library as well without installing the whole typescript SDK if they want to. Yeah, and then we also try to improve encoding support. So currently I think we need support Bingcode and Bosch, but we don't support new encodings like bite Mark. That's probably being used in token off rules as well. So maybe in the future you will see what auth rules is being used for this particular pnft.
00:12:18.530 - 00:12:19.538, Speaker C: Yeah, who knows?
00:12:19.666 - 00:12:20.374, Speaker B: Yeah.
00:12:20.714 - 00:13:27.474, Speaker C: And then we also try to reduce the bundle size of the package as well and make it compatible with the new solar web3 js because I tried it just now and it wasn't very compactable, probably because of the anchor SDK for. Yeah, and then last but not least, we also try to increase the coverage of the entire programs that we want to be passed on the Explorer. So in terms of open sourcing, we have open sourced the whole Explorer kit on our GitHub and then afterwards I still haven't given much thought about how people can contribute, but I feel that it would be good if programs out there will want to, they can try to publish their ideals on our site if they thought they don't want to publish it on chain, most probably because they are not anchor based. And they can also create issues for us to take a look and see whether we can get these programs up and running to be passed on the Explorer, I think.
00:13:29.014 - 00:13:29.486, Speaker B: Yep.
00:13:29.550 - 00:13:53.590, Speaker A: All right, so basically Explorerkit is available today, so it's open source since the time Steve Lucher shared about the updates about what's up and coming for the new web3 j's. So knock yourselves out. Scan the QR code. Oh, it's not loading. So yeah, scan your QR code. The link is right there. Head down there and take a look at what we have to offer.
00:13:53.590 - 00:14:04.382, Speaker A: And I want to close this entire thing in general before we head off, which is we've been focused on building parsers since the start of Solana FM and it's really very annoying.
00:14:04.438 - 00:14:05.062, Speaker B: Right?
00:14:05.238 - 00:14:36.414, Speaker A: Everyone has their own struggles in deserializing data and trying to access data from different types of programs, and we want to bring everything back into one place first because there are better things that we need to focus on to build, and it doesn't make sense for just us to focus on to build. And there are so many other types of different parsers that are available in the space and I thought, you know, it makes more sense for us to come together. So let's just work together on this, see how Explorer kit goes. And it's a very nice tool for us to use before RPC 2.0 is out. So thank you, everyone.
