00:00:01.520 - 00:00:46.474, Speaker A: Thank you, cash. Thank you, everyone, for that warm welcome. So what I wanted to do today is sort of give a really quick intro lecture about how to build on Solana for the first time. I know that in the audience today, we have people sort of at varying levels of their experience with Solana. This will be more catered towards beginners, but hopefully even the experienced veterans can gain a thing or two out of this. So as soon as this loads, and as soon as we can get it displayed on the screen. Okay, I'll just go slide by slide here.
00:00:46.474 - 00:01:22.414, Speaker A: I think that should just work just the same. So what I'll be talking about today is how to program on Solana just distributed state machine. And the way to start with that is to understand what Solana is and how you interact with different programs and state. And the way that Solana does this is through this thing called the accounts model, which I'm sure that many of you are familiar with. But again, this is catered mainly towards the beginners. So you guys who have not built on Solana before, hopefully this will be a good way for you to get some exposure. Well, the first thing to note is that Solana operates very much like a typical file system.
00:01:22.414 - 00:02:06.244, Speaker A: In a normal file system, you'll have file names that can point to files which have buffers of bytes that correspond to metadata headers and content, or however you want to store the information. Solana is a little bit different in that instead of calling them files, we call them accounts, and instead of calling it file names, we use public keys. Generally speaking, these are going to be 32 byte strings. Usually when you see them on a web page, they'll be encoded in base 58, which is just a serialization format for those bytes. The differences are these accounts have very specific structures. There's very specific metadata around what each account stores. The first field that's important is the owner.
00:02:06.244 - 00:02:41.270, Speaker A: The owner corresponds to another account address, and that corresponds to a contract that actually has the unique ability to write to that account. We'll be discussing this in a little bit more detail after. Land ports are also really important. Land port is the base unit of Sol. If you're familiar with bitcoin, it's sort of the equivalent of Satoshi, or like Gui and ETH. So the land port, the balance on the account represents the amount of soul that this account contains. All accounts require a certain amount of soul to stay alive.
00:02:41.270 - 00:03:26.104, Speaker A: We refer to this as rent, but you could obviously have more land ports in account, more than the allocated rent that's required. So this is a field that the Solana runtime will keep track of. The most important field here is data, which is just an arbitrary screen of bytes. It could be of any length upwards to ten megabytes. This stores all of the content of that particular account. So if you want to store complex state of any kind, however you define it in your contract, you'll be interacting with this data field of those accounts. Lastly, there's a flag for whether or not this account is executable, that corresponds to whether or not you're working with a program or working with just a typical data buffer.
00:03:26.104 - 00:04:16.954, Speaker A: So Solana contracts are compiled down to EBPF, which is a form of bytecode, and these contracts are uploaded to specific accounts, and the runtime knows how to execute that and also interact with the different accounts that it's the owner of. And we'll talk about that in two slides. But first, I think it's important to sort of talk a bit about cryptography and ownership. Really what makes this whole thing powerful is that when you're building in web, three users have this aspect of actually owning their private key and public key. The way that we represent this is in a key pair. So there's a 64 byte key pair where the first 32 bytes are the secret key, and then, and the second 32 devices are the public key. And there's a unique way in which the public key can be derived from that secret key.
00:04:16.954 - 00:05:08.274, Speaker A: There's also a number of properties that this key pair will have. There is a function called sign that takes in a message and a secret key and returns some signature, which is just going to be some random hash. Nobody can make sense of it. You can't figure out what the secret key is from that signature. But that signature is very important because there's another function called verify, that you can call with a message the signature and the public key, and this will return, true or false, whether or not that secret key signed the message. And this is incredibly powerful, because what this allows you to do is it tells you that if you know a secret key, you know the value of that secret key and no one else knows it. You can prove to someone that you own that public key that's associated with it, that 32 bytes of public key will be revealed to the world.
00:05:08.274 - 00:06:00.924, Speaker A: The secret key is hidden for yourself, but you can verifiably prove that you have the ownership of that public key. And that's really the power of crypto. And Solana uses this in a clever way, because public keys are oftentimes the addresses for certain account buffers so going back to this idea of ownership, this is something that's oftentimes very confusing for people. But I wanted to sort of touch on really the core concept here and explain it a bit. So, as mentioned before, the accounts have a field called owner that corresponds to the public key of the program that has a unique write access. Write access in this case, basically means that this program has the authority to modify the value of the data in that account as well as the lan ports. So in this case, we have three different accounts that we're looking at.
00:06:00.924 - 00:06:44.188, Speaker A: Account C is just some data buffer. Program A and program B are both smart contracts. But importantly, account C is owned by account a, like by program a. So in this example, if program a is attempting to write to this buffer, that will succeed given whatever logic is built into program a. But if program b was trying to write account C, this would fail because program b does not have the ability to directly modify account C. Later down the line, I'll sort of hint on the fact that program a can make a call to account b or to program b to modify account C. And so you can use a layer of indirection, sorry, b makes a call to a to modify c.
00:06:44.188 - 00:07:30.646, Speaker A: So you can do a layer of indirection to modify account state, but you can never modify it directly. And this is sort of implemented inside the runtime. So towards the end of this presentation, what I'll be doing is I'll be showing you a demo of how to build a simple counter program on the Solana blockchain, and sort of using all of the concepts we talked about, like accounts, public keys, private keys with sign in. And also what I'll be talking about a bit, which is just how instructions and transactions work on Solana. So the counter program is going to be really simple. We're going to support two instructions. One is called increment, where we're going to modify the value of a counter by one, increase it, and decrement will decrease the value of the counter by one, and it'll stop at zero to prevent the integer from overflowing.
00:07:30.646 - 00:08:11.068, Speaker A: And the state will also be really simple. This counter will be just represented as a simple eight byte unsigned integer stored in some account. So a brief aside before we talk about how to build that program is to talk about how you actually interact with the blockchain as a user. There's a lot of stuff that happens behind the scenes. Usually what you'll see is some front end application where you interact with an app by clicking some buttons, and eventually you'll use your wallet to sign, and that will trigger off a sequence of events that will eventually execute some state on the blockchain. So we'll talk about this one step at a time. First, you do exactly what I just said.
00:08:11.068 - 00:09:00.574, Speaker A: You click a button on the UI and that will start off a transaction. In this case it will increment an on chain counter for the program that I'm going to be demoing. What will happen in the backend is that there's some client code that will form this object called the transaction, and that will route it to an RPC node which will in turn send it to the current leader of the Solana blockchain. A leader is just one of the nodes that run the consensus algorithm. That validator will take that transaction data and actually execute the instructions that are specified. So if I wanted to increment a counter, the validator would figure out that it needs to run the counter program. With the increment instruction, it will locate the state and then it will take that value of the counter and change it from zero to one.
00:09:00.574 - 00:09:41.904, Speaker A: So this is the step in which you actually send data to the blockchain. But the other important step is the feedback loop of reading that data back from the chain. And that's the query step where you send another request to the RPC which will fetch data that is found at a particular address. So you would have to know the address of the counter. In this case, you would pass that information to the RPC, which will figure out what the value is at the state and send it back to the client. The data from that will be parsed and then displayed back to the user. And this is the full cycle of basically any kind of decentralized application.
00:09:41.904 - 00:10:23.864, Speaker A: Some way in which you can modify state on the blockchain and then some way to read it back. The way in which you send information is through these things called instructions. The way that I like to think about instructions is that they sort of function like a command line argument where you have a number of different components to tell the program what exactly it needs to do. First you need to pass in a program id. So that's kind of like your high level command line command that will just sort of be something like docker or something like grep or git. It just something that tells you this is the program I want to execute. Then what you have is accounts.
00:10:23.864 - 00:11:23.530, Speaker A: Solana is special in that every single account that you're going to be modifying or reading from will need to be passed directly into the instruction. This is because from the client side, you don't necessarily know what the contents of those accounts are, but you might know what the addresses are. In fact, you probably should know the addresses of all the accounts that you're going to be working with. By the time that your transaction hits the blockchain, the runtime will know the contents of those accounts, those public keys. It's like you pass it a bunch of file names and it tells you what the data is of each of those files and the program can act on it based on whether or not the user specifies the signerness or writableness of those accounts. So certain program or accounts that you pass into the instruction will need to be specified as signers or writable. Um, if you try to write to an account that isn't writable, the program will immediately fail, the transaction will not go through.
00:11:23.530 - 00:12:12.580, Speaker A: Likewise, um, the signer field is important because you need to specify every single key that is actually going to be signing the transaction. If you mark a key as a signer, but that key's signature is not found. Remember back in a previous slide, we talked about this idea of having a signature, right? This is just some hash that will be placed into the transaction. So if that signature is not actually found in the transaction and the issigners field is set, then we know that this should also just fail immediately. So this is just metadata on each key that's passed in to know some of the properties of what's going to happen to it when the program executed on chain. Lastly, data is pretty important. So data sort of allows the program to know which, which instruction that it should execute.
00:12:12.580 - 00:13:15.894, Speaker A: In this case, we have a counter program that has two instructions, increment or decrement. So you need to have some way of determining which call to make like are you going to decrement or are you increment? So the easiest way to do that is to define some unique field in this data, which is just a free screen of bytes to differentiate between the different operations you're going to run. Additionally, what you can do with this data field is allow the user to specify certain parameters that those on chain instructions are going to use to eventually execute. Let's talk a bit about this particular sequence of instructions here. The first one is creating a buffer. In order to create a buffer on Solana, you go through what's called the system program and you want to essentially pay the initial rent cost that's required for a buffer of a given size. So the counter buffer, as mentioned in one of the previous slides, is a U 64 so there's eight bytes there.
00:13:15.894 - 00:14:06.574, Speaker A: I'm going to allocate eight bytes of space, and I will calculate the rent cost that's required in lan ports for a size of eight. I will then also assign an owner to the program that has the unique write access to modify the value of that counter. And that program is going to be the counter program. Lastly, I'll pass in the keys that are necessary in order for this operation to go through. You need someone to pay the initial sole rent. That will be the payer, which has to be signer and writable because it needs to verify that it can send Sol and the landport balance is going to decrease. The counter itself will also need to be writable because you're allocating space, but it needs to be signer because in the creation of all new data buffers, the key pair itself must sign for its own creation.
00:14:06.574 - 00:15:01.466, Speaker A: And the other instruction that you might want to implement is just the increment instruction, which will take in the counter object and the counter program and pass in some data to tell that program to increment it. In this case, I'm just going to use the byte zero to represent increment and the byte one to represent decrement. Fundamentally, it doesn't matter all that much. These instructions can get wrapped into an object that's called a transaction that will execute instructions atomically. So if both of these things are wrapped in a single transaction, both instructions need to succeed for the whole thing to go through. But if at any point in the transaction a single instruction fails, the full sequence is going to roll back. And as mentioned before, you will also have a list of signatures that will be contained inside this transaction to indicate which keys have signed.
00:15:01.466 - 00:16:00.756, Speaker A: And this is important because in the metadata you define which keys are supposed to be signers. And if a signature is not found for a key that was supposed to be a signer, then instantaneously you know that the program should or the transaction should fail. So I'm not going to touch on this in too much detail, but this sort of provides a framework for eventual composability. You have these high level transactions that happen at depth zero that will get executed all at once. But inside each of these instructions that are executed at the depth zero instructions, they can make other calls to other programs, which can then make other calls to other programs up until an execution depth of four. So this sort of like creates a compute tree that will get all executed atomically if you package it all into a transaction. And so this is powerful because if someone has written a program that is very useful, for example, like the token program.
00:16:00.756 - 00:16:39.244, Speaker A: What you can do in your programs is make calls to those other useful programs without having to sort of rewrite that source code. The composability aspect allows you to sort of like bundle together these high order instructions in the transaction. So that's like level zero composability. But also inside these instruction make further calls to other programs. This is going into something a little bit more deep, and there's more information here that is probably too complex to cover in this first lecture. So with that I'll just go into the demo of how to build out this counter program. So first I'll show you guys some source code.
00:16:39.244 - 00:17:32.993, Speaker A: Okay, sorry about that. I will just show you it using my terminal. So what I'll do here, I'll open up this counter contract and show you what is contained in here. So this counter contract itself is relatively simple. Everything above here is just imports. Let me also try to make my screen size a little bit larger so you guys can see the text. So, as mentioned before, we have a simple counter that just contains an eight byte integer called count.
00:17:32.993 - 00:18:10.804, Speaker A: This will be the struct that we're initially allocating. And then when we process the instruction, remember that we take in the arguments of the program id accounts and instruction data. I'm going to go back briefly to the slides to show you that. Program ID accounts and data. As mentioned, we use the first byte of the instruction data to determine whether we increment or we decrement. So if it's zero, we're going to call the increment instruction. First, we pull out the counteraccount info, we will load it into a new struct.
00:18:10.804 - 00:18:45.554, Speaker A: We will increment the value inside that struct and then copy that back down into the original buffer. Most of these are just implementation details. If you are not rust native, I wouldn't worry about it too much. Most of it is just figuring out the syntax, but the concept should be pretty straightforward here. All we're doing is we're taking some bytes in a data buffer and we're modifying it in such a way to allow that increment process to occur. And the same thing is true for decrement. The code is almost identical, except for the fact that we're making sure that it doesn't go past zero.
00:18:45.554 - 00:19:53.202, Speaker A: If the instruction data isn't zero one, we just error out and that's the full program. There's really not much to it. What I'm going to do now is I'm going to compile this program with Solana. There's a special extension to the cargo command called build BPF. What this will do is that it will compile the source code down to EBPF, but it will also give you some shortcuts to actually deploy the program. So before I do that, I'm going to start up a local validator on my machine that is done using Solana test validator, by the way, all of these commands, all of these commands can be found from the Solana GitHub page. Cool.
00:19:53.202 - 00:21:03.994, Speaker A: So now I have a test ledger started. What I'll do on the right hand side of the screen is also open up a log stream. Then what I'll do is I'll take the command to deploy the program and deploy that to my local net. And we can see that as the deployment is happening, we notice the logs on the right hand side of my screen sort of print out what's going on, like the current transactions that are occurring. Great. So we see that that finished. Now, finally what I'll do is I'll start up the user interface and then show you guys how this counter is actually might be displayed to a user.
00:21:03.994 - 00:21:49.994, Speaker A: So this is a really simple UI that I built out for this counter. First I connect my wallet using phantom. This will allow me to create a new counter. So when I do this, it's going to ask me to approve the transaction. Once I approve it, a new counter has been generated. If we look back at the logs, we'll see that there has been a new message that occurred. This just created the counter for the first time.
00:21:49.994 - 00:22:40.050, Speaker A: If I increment this counter, we'll see that the value incremented. And then if we look at the logs again, we'll see that there is a new instruction in the logs where an increment was called. And we can do this a few more times and we can decrement as well. And then if we look back at the logs that we see that the most recent thing was a decrement, which was that instruction I just made to talk briefly about how the client was built out. All I have is I have a new public key that's created and a counter that's exposed. And each of these buttons will sort of initialize a sequence of generated transaction and allowing me to sign. And this number here is pulled from a websocket.
00:22:40.050 - 00:23:13.054, Speaker A: So I will grab the value that's found in this account initially and store it here. But additionally, I'll open up a connection to a websocket and listen for changes that occur. So that's why every single time I click this value and I send the approve, it almost updates instantaneously. Because what happens is that the websocket will receive an update for the account the instant that it gets modified on chain. So back to this diagram. That's really how this orange arrow sequence is working. And, yeah, that's really all I have.
00:23:13.054 - 00:23:21.394, Speaker A: Larry and I will be free for office hours after. And we're also going to be sitting over there happy to answer any questions you guys have. And good luck with building. Thanks so much.
