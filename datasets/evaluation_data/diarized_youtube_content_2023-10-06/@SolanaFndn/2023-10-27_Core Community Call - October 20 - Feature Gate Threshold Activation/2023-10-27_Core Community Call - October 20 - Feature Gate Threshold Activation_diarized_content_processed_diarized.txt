00:00:04.320 - 00:00:16.314, Speaker A: All right, welcome, everyone, to this month's core community. Call this. Today we will be having Joe present on. I believe it's the feature gate threshold activation. Go ahead and take it away, Joe.
00:00:18.454 - 00:00:42.270, Speaker B: Cool, sounds good. Thanks, Jacob. Hey, guys, I'm Joe. For those of you guys who haven't met me. Yeah, just wanted to talk a little bit about the simd. If any of you guys haven't seen it, it's number 72. Try to share my screen, you think, Jacob, or go for it? Yeah, I'm not going to go through every crazy, like nippet detail, but we can talk a little bit about the key points and stuff, whatever you guys kind of want to jam on.
00:00:42.270 - 00:01:38.692, Speaker B: But basically this is the proposal here. If someone could provide the link, that'd be great. And the whole idea is to basically create a process that is going to be like automated for kind of doing what we already have laid out with like the manual process for activating a feature. So like right now you would run like Solana feature activate. And you're supposed to have like 95% of stake before you do that, right before, like, you try to activate a certain feature on a certain version, but it's kind of up to you as like a person to go make sure like the CLI will check for you, but you're supposed to make sure that that stake support is there. So this process is going to kind of like automate that through the runtime and through a program. And basically the way it's going to kind of work is if you go through this design part, you can see like, for example, there's two like, nodes running different versions.
00:01:38.692 - 00:02:18.540, Speaker B: They have different feature sets, and we want to make sure that only the feature sets that have majority, like that 95% would be activated and these other ones would have to wait. So again, 95% is the number that we've been going with for now, and we can sort of discuss that later. But that seems to be like, what we want to stay with. And in a nutshell, this topic. These three bullets here kind of summarize, like on an epic boundary, the runtime's going to generate a list of feature gates that are queued. The validators are going to signal which of the queued feature gates they support. Then on the next epic boundary, the runtime will activate the ones that have the necessary support.
00:02:18.540 - 00:03:11.152, Speaker B: And this is going to be an automated process, at least being proposed here. For starters, we've been working a little bit to replace this feature 111 account, which actually doesn't exist right now with a program because this is the owner of all the feature accounts that we deploy when we go to activate. We want to swap that non existent account for BPF program and that process may or may not take a SIMD like we haven't really, I guess landed on. That part of it is in place right now, but there's some questions to answer about the program itself that we can touch on later. But either way, just imagine this program sits there and then basically what it's going to do is it's going to use two PDA's through this proposal. At least one of them is going to sort of take the new requests for activation as they come in. And then at the end of the epoch it will take that list and it will finalize it.
00:03:11.152 - 00:03:54.316, Speaker B: And that finalized list we're going to call the queue is what the nodes will vote on in the following epoch. So you're going to have pretty much like two epochs of like process here. So one to activate or queue to activate and then a second one to actually vote on for support. And then that epic boundary at the end there, Epic two is when the ones that have support will be activated. What this looks like is it's going to be done through what's called a bitmask. We'll have a bit field for all of the features that have been proposed. You'll have this big bit field and then however big, we've talked a little bit about what the size should be.
00:03:54.316 - 00:04:31.482, Speaker B: Then every node will signal a mask of that with a one for features they have and a zero for features they don't. Then everybody will signal that. And at the end of the epoch you'll take a look at all of these signaled supports and just figure out who's got the proper stake support and who doesn't, and just use the bip field to go ahead and activate only the proper ones and then reset everything. So that's what this kind of talks about here. This is what that would look like. There's going to be an instruction that I should probably outline a little more, that you would basically send this bitmask into the program. It will store this information in PDA's.
00:04:31.482 - 00:04:59.958, Speaker B: So there's one PDA for the central authority bitmask, the bit field of the features that have been requested. And then there's each node will have a PDA of the ones that they support. And this will all refresh every epic. And so just the activation will still kind of work the same in a way. There'll just be that check for the stake support. So this is where things are a little bit dicey because it's computationally intensive, but. Or can be.
00:04:59.958 - 00:05:27.734, Speaker B: Basically, it will walk these accounts to tally up all the stake support and then only activate the ones that have the support. But once it knows who, like, once we've tallied up who has the support, the rest is kind of, like, the same. Like, it'll run the activations that have been written into the code. So that's like, the proposal. There's some alternatives I've included in here, too. Like, one alternative is we could sort of, like, not use two pdA's. We could use just one.
00:05:27.734 - 00:06:12.172, Speaker B: Um, but that kind of makes things dicey with, like, the timing of when these signals go out. And another, you know, alternative as well is we could not use transactions. We can instead use the block header, but there doesn't seem to be, like, a ton of support for that idea. But, um, I would love to sort of open up the conversation to just any thoughts on this, especially considering, like, the multi client world we're going to be in. Want to make sure that everybody has, like, a voice on this, and we can kind of figure out what looks best for this. So anybody have any questions to start yet? Yeah, Liam, go ahead.
00:06:12.348 - 00:06:54.044, Speaker C: Yeah. So, hi, I am from the firedancer team. I've been looking at this. We've been thinking about this issue a lot, because as we build fire dancers, there's been. There's a lot of features, and there's been, like, a lot of new features that have been added as we've been developing here. And so we're intimately kind of involved in how features are being added and having to track all of that. So when this proposal came up, and it was not the first discussion that we had about this, in fact, we've been talking about this since probably day one, at least internally.
00:06:54.044 - 00:08:18.394, Speaker C: So I guess, like, one of the big questions, and I think, like, overall, the proposal, like, the bones of the proposal are, or at least, like, the philosophy of this proposal is really good, that, like, okay, maybe, like, we should be enshrining how features get, like, activated based on, like, a stake weighted, you know, based on, we know, which, you know, which validators are actually running the feature based on their stake weight, and then, you know, allowing them to be activated after that. I think that that's actually a really good idea, and it's one that we had internally. Just didn't think about how to do it. I think the big question, like, or I guess, like, there's a few big questions and one of them was one that you just mentioned, which was like, iterating over all of the stake accounts at the end of an epoch to determine whether a feature is ready for activation. It's kind of, well, is an expensive operation, given the number of stake accounts that there are, or even to iterate over the number of vote accounts, that number could also end up exploding at some point. So it's just something to think about whether there should be just one account maybe, where these things are stored, where we do all the accumulation. I think there's a comment about this too, that we've been going back and forth about.
00:08:19.574 - 00:08:28.070, Speaker B: Yeah, I think you're right. I think I saw that. So you think maybe use one account that everybody sort of appends to, maybe.
00:08:28.102 - 00:09:15.938, Speaker C: Not appends to, but like there's a counter in there for each individual feature. So, like, I know this was kind of mentioned in the comment that I made about like an alternative process, and it's certainly, I think, a worthwhile one, is that instead of having this bitmask, having each individual feature have its own account and every time, and have validators have to vote into each feature that is not active yet, that they support and say, like, hey, I'm good on this feature, and they just increment one number in there, and then once you reach, like, you know, some percentage of the number of validators. Right. Or the number, percent of the amount of stake that is necessary, you know, that feature is ready to be activated or is activatable. Right.
00:09:15.986 - 00:09:20.214, Speaker B: So would you suggest then they would write their stake in there, then.
00:09:22.194 - 00:09:27.014, Speaker C: They have access to that, right? I suppose, I think. And then they could also.
00:09:27.874 - 00:09:36.704, Speaker B: I think the problem is the program doesn't. Right. Like we, we have no way to like, prove that that's true. Right. Like from a programs context or is that right?
00:09:37.324 - 00:09:40.944, Speaker C: I can't remember if vote accounts actually contain the current active state.
00:09:43.684 - 00:10:34.134, Speaker D: I think, sorry, tiara here. The way that Richard wrote it out in discord was using the leader schedule. And so that is pulling a ball via Sysvar and then having bits that can reflect each slot in the leader schedule, and a validator could set the bits for their own leader slots. The concern that I have with that approach is that we now have a lot of contention on those single accounts if we're concerned about scalability with the number of validators going up now, suddenly we have thousands of transactions all trying to hit those same accounts at the same time. What are your thoughts about that?
00:10:34.434 - 00:10:52.546, Speaker C: Yeah, so one of the things there. So like the idea there was that it's not a transaction like the leader implicitly is updating syspars all the time. And so this would just be another one of those that happens either before or after transaction processing. And so it really, and then we.
00:10:52.570 - 00:11:02.640, Speaker D: Have, we come back to that same problem with timing in the epoch, right. If your leader slots are all at the very beginning, you can't support later in the epoch.
00:11:02.832 - 00:11:50.564, Speaker C: But I guess the issue is that that person also has a very small stake. Then if they only get one, they only get one set of slots in the leader schedule. They're probably, or even a handful, they're probably not a large amount of the stake that's currently active. And so they probably don't constitute like the whole network as a whole is what matters here in my mind. And they're like, if we're saying a threshold of 95%, well 95% of stake is not going to just be hit all at the beginning of an epoch. That makes sense.
00:11:52.124 - 00:12:17.024, Speaker D: Yeah, I think we might want to think that through and I don't know, mock it out because I mean, I think hypothetically you could have like 20,000 leader slots and they could all, because the leader schedule is randomized, they could all be at the start of the epoch. And again you kind of have this problem where that whole rest of the epoch is wasted in terms of your support signaling.
00:12:19.864 - 00:12:50.934, Speaker C: That is, that is true. That is true. Yeah. It's something to think about. I think there's a trade off between like having contention on an individual account or having, or doing this process of having the leader take care of their control of the bank.
00:12:57.434 - 00:13:20.754, Speaker D: And I think our thinking coming into this is that we are already doing those stake assessments on the epoch boundary. And it's true that that might become a problem in a future where we have 100,000 nodes in the network, but it is a problem that we will already have to deal with.
00:13:22.534 - 00:14:53.412, Speaker C: Right. I think uh, just a few other things that I have noted down here. Um, I think there's a lot of things that are done in this simd that are new and uh, I don't, I don't want to be the person who like throws you know, a wrench in the process. And it is mentioned that the BPF, like kind of this process for like enshrining a BPF program which has like, you know, some of these very specific properties, it's an important change to get right so that we could do it in the future because we'd love eventually to have all of the native programs be BPF too. I think that's an aspirational change that at least the people who are working on the new program runtime v two are really excited about too. And so it would be good to actually get a process down for that and have their input too, so that we can kind of standardize this at the outset because like it's not clear who should actually update these programs, who should be responsible and what kind of, you know, if they're used very frequently, maybe, and they need like maybe some privileged access to things within the bank that aren't normally available. Like we should probably think a little bit about those two as well prior to this.
00:14:53.412 - 00:16:00.004, Speaker C: And then I think, like, I'm happy to write this up, but like kind of a full roadmap of like how the feature roadmap or the like feature gate stuff eventually turns into more of a governance based approach as far as activation, where the, I think the big concern that I think several people that I've spoken to on this have is that the, just updating your software, though, may be an implicit, it's a kind of implicit you are consciously doing that you are not consenting to. All these other new features that may affect. Maybe a validator may not be as profitable after some change just because of the software update, which now triggers a feature activation. So it would be good to give the community that opportunity to come in and say, hey, actually before you, you know, I like the software updates because I get the security fixes, but I don't really want this other thing that kind of hurts me.
00:16:01.104 - 00:16:50.534, Speaker D: Totally, totally. And I posted a comment in discord just kind of at the 11th hour, so you might not have had a chance to read it yet, but we definitely envision that being part of the process. And I think that we probably use some problematic language in the simd that suggests, like, I don't know if I hope the word vote doesn't show up there, but it might. And then the word support is probably also kind of problematic. Maybe we should have said something more like recognize, because this is the aspect that we're addressing in the SIMD is purely the like, hey, this feature exists in my validator software aspect of it and isn't intended to replace an actual governance decision for queuing a feature.
00:16:51.234 - 00:17:19.584, Speaker C: Yeah, I think we should make that really explicit. And then, as I said before, like, I think it's worth, and I'm happy to sit down and do it, but figuring out how that Lego piece plugs into a future governance system and making sure there's going to be compatibility with anything that wants to do. I don't think there's a lot to do there. It's more just that I think we should think about it so that it's not something we have to then re architect this system for.
00:17:22.044 - 00:17:39.144, Speaker D: Yeah, that sounds great. If you're willing to start on a draft of that, I'm sure Joe and I can both chime in and try and get something that seems solid. I don't know if this is an overarching organizational symbol or where the best place for it is, but.
00:17:42.184 - 00:17:42.592, Speaker C: Kind of.
00:17:42.608 - 00:18:01.528, Speaker B: Seems like governance is going to tie into this in multiple ways too, because we've also touched on how we manage the program upgrades too, especially considering it's like elevated status. And that would also tie in, as you said Liam, into the other programs that are going to become BPF eventually. So yeah, there's a lot of us to figure out.
00:18:01.696 - 00:18:19.504, Speaker C: Yeah. The SIMD in a sense kind of highlights some things that want to be done elsewhere too in many ways, like, and it would be really good to knock some of them out. That's all I have.
00:18:21.844 - 00:18:23.064, Speaker D: Thank you very much.
00:18:24.764 - 00:19:04.824, Speaker A: There's also a few comments in the chat both on the. I think Zantetsu was talking about the governance discussions that have been going on and measuring based off of the epoch stakes as well as I think GM Galactus from Mango is making some comments on the rewards distribution as well. This I guess is this requirement, is this current symbiote like requiring that SIMD or something similar so that you can measure the what's on chain, the stake distribution?
00:19:06.964 - 00:19:10.204, Speaker C: I think it's worth going back and looking.
00:19:10.364 - 00:19:37.054, Speaker D: No, I don't think that we have that requirement because the way we've proposed it, the stake sort of tallies would be done in the runtime which has direct access to the data, okay. Rather than inside a BPF program. But it's certainly worth considering and as things develop, if we push more of the functionality into the program, that might change.
00:19:39.194 - 00:19:43.614, Speaker C: Got it. Right.
00:19:43.954 - 00:20:09.354, Speaker A: If there's any questions from the audience, feel free to raise your hand. Otherwise we might be ending this early and during the discussion on this, on Discord. Right, GM Galactus, I will get you on. Yeah.
00:20:09.934 - 00:20:30.494, Speaker E: Hey, thanks Jacob. So actually I just want another topic to discuss. Another topic. And I want to know that if fired answer is implementing geyser interface because we are like looking into RPC architecture, like revised RPC architecture which will stream all the data, our geyser and.
00:20:33.514 - 00:20:34.962, Speaker C: Sorry, what was the original question?
00:20:35.018 - 00:20:41.146, Speaker E: I was like, will fire dancer implement Geyser interface or.
00:20:41.170 - 00:21:05.704, Speaker C: No, I think we're happy to, like, discuss it. There's not a specific plan yet, but it is certainly something that, like, we would want internally. As far as tooling goes, we recognize that there is a need for a geyser like interface. Okay. We will likely provide something that's not identical, but is analogous.
00:21:06.764 - 00:21:07.356, Speaker E: Okay.
00:21:07.420 - 00:21:07.716, Speaker C: Yeah.
00:21:07.780 - 00:21:09.744, Speaker E: Okay. It makes sense. Yeah.
00:21:14.684 - 00:21:15.356, Speaker A: Right.
00:21:15.500 - 00:21:28.964, Speaker E: And I also want to, like, point out that there's not enough testing or geyser, and we are, like, thinking, like, strategies to test or in Solana labs client. So if anyone has some ideas you can share.
00:21:38.544 - 00:21:47.754, Speaker A: Well, also make sure you ask in the geyser channel on Solana Tech GM Galactus so that we can continue the discussion there.
00:21:48.054 - 00:21:49.634, Speaker E: Okay? Okay, thanks.
00:22:01.374 - 00:22:23.430, Speaker A: All right, if there are no other questions, I think Zanfitsu, you have a question about voting. I'm not quite sure if this is the place for that, but we can continue that in discord. But otherwise, thank you, everyone, for coming to this month's core community call. Let's continue the discussion in discord.
00:22:23.502 - 00:22:25.674, Speaker C: Thank you, Jacob.
00:22:26.814 - 00:22:27.486, Speaker D: Thanks, everyone.
00:22:27.550 - 00:22:27.894, Speaker B: Thanks, everyone.
