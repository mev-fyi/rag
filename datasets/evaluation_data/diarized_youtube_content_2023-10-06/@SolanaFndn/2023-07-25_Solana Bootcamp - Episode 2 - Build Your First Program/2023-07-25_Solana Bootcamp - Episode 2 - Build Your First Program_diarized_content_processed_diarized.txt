00:00:08.640 - 00:00:54.986, Speaker A: Hello everybody, and welcome to day two of our Solana pirate boot camp. Today we're gonna put the pirate ships that you minted yesterday to see in the Seven Seas program. But first, let's have a little introduction. So today we're gonna learn Solana the programming model, and we're gonna write our first program in Solana anchor. And we're gonna do this through writing some little games. So what we will learn today is we will write our first anchor program together. Then I'm gonna show you how you can save Sol in a program and send it out again so that you can reward a player, for example, or do whatever applications you need, which saves Sol in the program and uses it for something.
00:00:54.986 - 00:01:39.262, Speaker A: Then we also gonna interact with SPL tokens in a program. And then we gonna do a complete local setup with installing everything locally, having deploying a program, writing our own JavaScript next JS client for it, and using the Solana Wallet adapter. So what is Solana? Solana will change the future. It's a blockchain with a very fast confirmation times, very low fees. But if from a programming view, basically what it is, it's just a big database where you have a bunch of different programs which can change this data. And yeah, by having that, you can of course also build games with it. But let's first of all put our ships to sea.
00:01:39.262 - 00:02:08.934, Speaker A: So the pirate ships you minted yesterday, you can now use to play this game and you can deploy your NFT on this map and then drive around and shoot other players. So please just open this URL here. Soleplay de seven c index HTML I gonna do the same. And yeah, then we will be able to fight each other. So this is the Webgl version of the game written in unity. Unity. We will also cover a little bit today at the end.
00:02:08.934 - 00:02:51.286, Speaker A: So you just log in with any of your wallets. I gonna use Soulflare now because it's already set to Defnet. And here you can see already that my little pirate ship here is moving around and I can now either move against another ship to do a little bit of damage, or I can use my cannons to do a bit more damage. And I can also collect these chests here. So that's gave me ten pirate coins. And these pirate coins you can use to upgrade your ship. And tomorrow you will learn how you can use these pirate coins and stake them to get more pirate coins.
00:02:51.286 - 00:03:34.044, Speaker A: And on the days after there will be a swap where you can take these pirate coins and trade them into rum and cannons, which will influence the damage and the health of your ships on this map. So, yeah, get some friends together and play a little bit, have a little battle here. And yeah, we will now learn, like, after the bootcamp, you will be able to build something like this yourself. And as you can see, like, maybe that's important to notice that every transaction here, every move on the board, is actually a transaction on the Solana blockchain with an auto approved wallet. So you can see here in the bottom the status of the transactions and how fast they are. 400 milliseconds. It's very, quite fast for a blockchain.
00:03:34.044 - 00:04:13.958, Speaker A: So what is the seven Seas program? So this program is also written in Anker, the same thing that we're going to use today to write our little game. And it's a real time multiplayer PvP on chain game. You pay a little bit of soul to deploy your ship, and then it's split up into your ship and into a chest that you spawn. And whenever someone destroys your ship or collects, the chest never gets a soul that is in the chest. And also some gold pirate gold SPl tokens on top so don't get destroyed. That's important. Yeah, it saves some SPL tokens in a PDA, which we learn later what that is.
00:04:13.958 - 00:05:01.414, Speaker A: And you can use the gold token to upgrade your ship. And there's a websocket connection from all the clients which listen to the board account so that they get very quick updates from the state changes of this ladder blockchain. And then on Thursday, we're gonna look into randomness for the damage of the ships and the position where new ships spawn and chests. Then we're gonna look also at clockwork threats to move the ships automatically on the map. And then we also gonna look at zero copy accounts in case you need an account which is bigger than ten kb. But yeah, since I'm a game developer, let's talk a little bit about games on Solana before we dive into the programming part. Now, I want to quickly cover why you should build your games on blockchain and especially on Solana.
00:05:01.414 - 00:05:30.664, Speaker A: The transaction fees are super low. As I already mentioned, you only pay five lampards, which is 0.005 solutions, so they are very cheap and they confirm within only 400 milliseconds. Then you can use the blockchain for rewarding your players. Like you can create SPL tokens and give them to players. That can be the in game currency. It could be diamonds, like unusual traditional games, or some coins.
00:05:30.664 - 00:06:15.744, Speaker A: And you can also, of course, have nfts like we did just now. Like we created a pirate ship yesterday and now you can use it in the game as a character and all the data of the ship will be saved in a PDA which is derived from this NFT. So I'm going to show you later how this is done. So what you can also do is use NFTs as token gates. So it's only people who own your NFT of your collection can play your game and you can use it to save stats, you can save the game state and all of that is on the blockchain, saved there forever, basically. Then it's also very composable. Like recently someone built a high score program, for example, that now everyone can use.
00:06:15.744 - 00:06:53.106, Speaker A: And yeah, there's just new things being built every day. Like some people from Jump build a game entity component system that you can use now and anyone else could build a client for your game. Basically. Like as you saw, the Seven Seas program, we have a unity client and there's also a JavaScript client which we're going to look at on Thursday. So it's pretty cool. You put a program in the blockchain and then other people can build their different clients for it, change the graphics or build whatever game with it. Or you can just take it and deploy it yourself and yeah, then of course you can take and trade the items of the games and trade them on marketplaces.
00:06:53.106 - 00:07:52.624, Speaker A: For example, NFTs could now be listed on magic Eden or tensor or Hardaswap or whatever. And then you could also use it in our games. Right now I could build pirate shooter game or something, or like a pirate cannon bowling game and I could use the same NFT for the login and I could even like take the same data. Like if the pirate ships now levels up because it did lots of kills in the game, then in another game I could theoretically use the same data to also have the game like the characters be stronger there. Yeah, and Solana is a free for l like everyone can use it and it doesn't cost you anything, especially as a developer because the players will pay for the fees. Like if you saw in the game here, every transaction costs 5000 lampholtz but me as a developer, I didn't need to pay this because it's just the players paying it with their own wallets and it will always stay there. And another nice thing is that I don't have to care about authentication.
00:07:52.624 - 00:08:38.924, Speaker A: I don't need to save an email address and passwords that could eventually get hacked or leaked because people will just log in with their wallets and it's their digital identity and they can also play with multiple wallets. So that's really nice from a game developer's perspective. And it also replaces your payment provider. I don't need to add, do a PayPal integration or something. All I need to do is like whenever someone, for example, buys pirate gold, I transfer a little bit of salt to myself. Or whenever a new game session starts, I put a little fee of 1000 lampards or 5000 or whatever, depending on how engaged the people are and how much they are willing to pay. I can just build a game and then take a little fee of the, of every game, for example.
00:08:38.924 - 00:09:09.340, Speaker A: And you also save the App Store fees. I mean, if you would be able to get the crypto game into the App Store, then you could save the App Store fees. But currently there, as soon as you have an NFT in your game and you give it a functionality, then needs to be bought via in app purchases or on iOS as well. So you can't really just put it in there. But Solana built a solution for that. There is the sagafone, which is a crypto native Android telephone. And you can, it has a Dapp store.
00:09:09.340 - 00:09:50.694, Speaker A: It's like a decentralized App Store. And these apps, of course, don't have any fees or any regulations on it that you're not allowed to have nfts in the game or pay with crypto. Yeah, and you have a very engaged target audience. Like there's just a bunch of people who immediately jump onto new stuff that is being built. For example, there's now a wallet called backpack and they released x nfts. And if you're now like one of the first games which is in there, then probably everyone will, will try out a game and play it and give you feedback and so on. So currently it's a very good time to start your game with backpack or putting it into the Solana dev store.
00:09:50.694 - 00:10:25.702, Speaker A: Not every game is made for being built on crypto, of course. Like don't try to force crypto into your game better. Makes sense to come up with an on chain idea first and then go from there and like try to make it like really fitting for this genre. And the regulations are not super clear yet. In all countries, like whenever you have now a token and you create it out of thin air, then it might be difficult to sell it. You might need to get KYC like know your customer information from the players. So this might be a little bit more complicated.
00:10:25.702 - 00:11:11.062, Speaker A: So check the regulations in your country and then do it like. And it doesn't really make sense much for real time games. Like, for example, a shooter game would be very difficult with a ping of 400 milliseconds. But yesterday I played League of Legends on my mobile phone, the new Rift version, and I had a ping of 800 milliseconds or something, and it was still kind of playable. So theoretically, you could build something like this, or at least you could for sure build a tower defense where the build times of the buildings and of the units is like 400 milliseconds. Or maybe we better make it a second or 2 seconds. And then when the tower is built, then from there on, you could just sync everything by time and make it deterministic.
00:11:11.062 - 00:11:49.316, Speaker A: And then you could theoretically have an on chain tower defense game game, or something like a warms game, where you set the direction and the power, and then you shoot, and then you hit the other player within a few seconds, where you can calculate and get the response from the blockchain. So I'm very excited. What will be built? There will be a game jam later this year, so if you're into games, probably makes sense to join that one now. I wanted to show you some example games. I already showed you the seven seas. Of course you can already play that one, but there are a bunch more. Like, there's, for example, Star Atlas.
00:11:49.316 - 00:12:23.644, Speaker A: You might have heard of it. It's, like, probably the biggest game on Solana. They have beautiful art and great nfts, and they have a huge team, and they might become the new eve online of the gaming industry, where you have, like, these huge battles where you destroy tons of ships, and then the leaders collect all the debris and build more ships out of it. So if they pull this off, it's gonna be super exciting. And they just recently released their first demo. It's a movement demo. So you can take a ship and you can move it to another position.
00:12:23.644 - 00:13:00.344, Speaker A: You sign it with your wallet, and then you can see that the ship actually moves to this position. And here you can also see that there's a bunch of other ships on these tiles already. So the little number on the bottom right shows you how many ships are on this tile. So on this map, there's a bunch of ships already. And I think the transactions of Star Atlas already made up 3% of all Solana transactions for a few days. So this is very exciting. And you can also do some other things, like I can scan, not 100% sure what that does, but I think I will then see which ships are around me or something.
00:13:00.344 - 00:13:14.982, Speaker A: And I can observe. You can look at my dummy. Nft. So, yeah, I'm quite excited about this one. Like, let's see what the future brings. I can go back and, oh, there's something here. Oh, maybe I should go to the sun.
00:13:14.982 - 00:13:59.636, Speaker A: I can't, can't go there, can I? Sorry, I just noticed this sun. No, I can't go there. Anyway, these are probably the different solar systems or something like this. Okay, that was it for Star Atlas. The next game I wanted to show you is called Solana plays Pokemon, just was recently released, and people played through a whole game of Pokemon here. So how it worked is there's a little screen here, which is like a Pokemon game Boy game, and then people could vote on the different moves on where the character and the game should move to. I don't know if you noticed, but, like, a few years ago, there was a big thing on Twitch where people had a chat where they could write something and then the characters would move on screen.
00:13:59.636 - 00:14:21.408, Speaker A: And, yeah, someone built this for Solana, actually. I know who solidity did it. So you can follow him on Twitter. It's really cool. He does a lot of good things. And, yeah, and they played through the whole game in a few days, so it was very, very nice to see. And there were, of course, also a few people who tried to shoot it and, like, sell all the best Pokemon and so on.
00:14:21.408 - 00:15:07.074, Speaker A: So the same things that happened back then in Solana, Twitch plays Pokemon. The next game I wanted to show you is Chrono Kingdom. It's also a completely on chain game. And how it works is you build a city at a certain location, then I think I currently can't log in with a different wallet. But how this game works, it's like a little bit of tribal wars or Ogame, like the old games in the old browser games. So you build city, you build buildings, you produce resources in these buildings, and then you can use the resources to produce units. And with these units on the map, you can attack other cities and then, like, eventually conquer them.
00:15:07.074 - 00:15:33.262, Speaker A: And then you have more cities, and you form tribes and so on. So that is also very interesting because it's like, also completely on chain. And I'm a big fan of these completely on chain games. Another one of these is Ladacaster. It's the very first solar onshine game. I think I met them in very many hacker houses that were going around. And, yeah, you have a little mage, and you can move around on a grid, and they have this interesting system of cranking the turn.
00:15:33.262 - 00:16:00.604, Speaker A: So whenever, always, one of the players needs to crank the. Crank the button to go to the next turn and pays for the new account. And then you could also collect different tokens here. Water, earth and fire and something, you can use it to perform spells. And you get different items like magic books and so on. Currently they are not online because they are focusing on their referral system called buddy link. Maybe you want to check that out and.
00:16:00.604 - 00:16:31.164, Speaker A: Yeah, but maybe they go back to the game and show it. I especially show these games because they are open source. You can just look at the source code and learn from it. Same as Dominari. It's also an on chain grid strategy game where you have some buildings which produce units and you can move them around and fight against other players. And I think every, every 5 seconds or so, a new round starts, and then you can move your units and fight. So here's a video to this one, and I think it's also open source.
00:16:31.164 - 00:17:13.302, Speaker A: And another one which is also open source is Dee's quest, which I also found super nice, was part of the last. Hackathon has also beautiful music. It's an on chain match three game where you fight against other players. So you pick your avatar and every NFT like I didn't like. These are just dummy nfts that I created, but they all have different stats, and then you can fight against each other. So it's this multiplayer match three game. Whenever you collect some items on the map, then they will fill up your energy, and then you can use it to perform very strong attacks.
00:17:13.302 - 00:17:43.664, Speaker A: I think the music is a bit too loud for the video, so I will stop this here. But yeah, this is definitely something that you can look at the code as well, because they have a very interesting on chain matchmaking system. They create an account and then they match you with another account. And then you basically on chain, find another player that you want to play against. I think you can also play for rewards. Okay, but now enough for games. Let's start with the fun game, with the fun stuff, coding a game.
00:17:43.664 - 00:18:17.822, Speaker A: So what we're gonna build first is this game. It's called tiny adventure. It's a very, very simple Solana program. So I will quickly log in here. You see, I can get data, I can move to the left, and I can move to the right. Okay? And that is what we gonna program first. And we gonna do this in a tool which is called Solana Playground, which is an online tool where you can write and deploy Solana programs.
00:18:17.822 - 00:18:56.094, Speaker A: So I would like to invite you, everyone to open now beta SoLPG IO tutorials. And then here we gonna start the tiny adventure tutorial. So you just started and then you are ready here with the code, the anchor code and the client code. And then what you probably need to do is here on the bottom left you need to create a new wallet. So you click here on this red dot. Then it will ask you, hey, you don't have a wallet yet. Do you want to save your keyphrase? And then you say, yes, I want to save my keyphrase or you say no, I don't want to.
00:18:56.094 - 00:19:28.070, Speaker A: Whatever you like best. And then you can do here Solana airdrop two. And you do this two times and then you should have enough soil to deploy a program. So here I am switching my endpoint to definite now because it was previously set to localhost, which is something we gonna do later. We're gonna do local development later. But we will start on Defnet today. So Solana airdrop two.
00:19:28.070 - 00:19:59.382, Speaker A: So you write this. I did already too many requests today, but you should be able to get for Sol definite soil of course. And if you can't then here is a few tips. So you can go to solfawset.com or you can get a custom RPC from Helios, quick note, Triton, hello Moon or whatever. And most of them have their own faucets. And then you can get some definite soil there, hopefully.
00:19:59.382 - 00:20:24.196, Speaker A: So now let's look at this game. So first we gonna build it. So we just type build on the bottom. What this will do, it takes the code, the rust code here from the librs file. Like all Solana programs are written in rust or they are written in some other language like Python. And then they are transcompiled to rust. But in the end what you will get is an so file.
00:20:24.196 - 00:21:02.618, Speaker A: And when you now type deploy, then what it does is it creates a big account and it takes this so file and it creates many transactions. Like I think you can have. You can transfer 1 data roughly in one transaction and it creates a bunch of transactions and like pushes these actually to the blockchain. So then after you deployed this, your program will be on the blockchain. So congratulations, you just deployed your first Solana program. And here on the top you have this id here. This is the program id.
00:21:02.618 - 00:21:26.842, Speaker A: So this is the address of your program on the Solana blockchain. And you can now go to the explorer dot solana.com and switch to definitely. And then you paste this program id here. And then you will see this program is now actually on the Solana blockchain. So here you can see there is a little bit of solid balance in there for this account. Here is the executable data.
00:21:26.842 - 00:21:58.808, Speaker A: This is this so file which I talked about earlier. Here you can see how big it is. So it's like 469 kb and it costs 3.2 soil to deploy this. This might sound high, but you can always, if you don't want the program anymore, you can just write Solana program close with this id here, and then you will get your soil back. I'm not going to do this now, because if you do this for a program, then you will never be able to use this address again. But let me quickly show you.
00:21:58.808 - 00:22:29.134, Speaker A: So this is how it would look like, then you would just get the Sol back. So maybe we do this when we go to the next example, we close the first one since you may not have enough definite soil for deploying the next one. So now we deployed this and now we can run. And what this does is it starts playing the game. So here we can see a journey begins. And then here's the little character. Then we have another transaction and it says, hey, the player position is now one.
00:22:29.134 - 00:22:56.576, Speaker A: So we can, now this is the transaction hash. So if you copy this address and paste it into the explorer, this will show you the transaction that this game did. So what the game did, it sets here. Like a few accounts were passed in. This is, one is our wallet, one is the game data account. And then this is the program address that we deployed. And now you can see that it says, hey, a journey begins.
00:22:56.576 - 00:23:31.648, Speaker A: And now the character is at the first position. And now if we take the second signature and paste it in here, we will see that, hey, now the position is a little bit further to the right. And if we run this a few more times, like I run this once and I run this one more time, then you can see, hey, the guy is now super happy because he is at the last position. So if we copy this one in here, we will see that, hey, you have reached the end. Super. So you played through your first on chain game. And this is here the instruction that you can see.
00:23:31.648 - 00:24:06.532, Speaker A: So it's interacting with our program. It has this writable account, and this weird string here is the instruction data. So what I want to show you now is that there's a JSON representation of this program which you can deploy. So you can just click here on IDL and on initialize. And now it takes our JSON representation of the program and also writes it to the blockchain. And then from then on, whenever we refresh this transaction, we will see what is actually happening on chain. So currently it still says it's an unknown program.
00:24:06.532 - 00:24:37.580, Speaker A: But now if we reload this, it says tiny adventure move right, because we did the move right instruction. It's interacting with the tiny adventure program. And here is the game data account. And yeah, just shows us now exactly everything that will happen with the program. So that's a very good practice to also publish the IDL whenever you deploy your program. So now let's play a little bit around with this code. So for example, this is the client.
00:24:37.580 - 00:25:16.914, Speaker A: First we initialize the account, and then here we move left or we move right. So the first thing you can change is you, you can now move to the left. And now if I type run here on the bottom, you will see that we are moving back to the left. And I can do this again until I'm back at the start. Yeah, but how does this work in the program? So now we're going to go through the rust program, and I'm going to explain you step by step what is happening in this game. So the very first thing is happening is we are initializing the account. And in this we take the context, the accounts, the new game data account, and we set the player position to zero.
00:25:16.914 - 00:25:52.738, Speaker A: And here you can see already, like in the very top, we have the import for the anchor files. So anchor is a framework on Solana, which makes development way easier. Then we declare an id. This is the idea of our program. Then we have this flag here program, then we have the name, and then we have the first function, which is initialize, which will be called with this context here. And every context consists of a bunch of accounts. So if you go down here to the initialize account, we can see that these are the accounts that are passed into this program.
00:25:52.738 - 00:26:28.280, Speaker A: So the first one is the game data account, the second one is the signer. So in this case it's this wallet down here, which we connected. But if we play this here in the browser, then it will be always the wallet that is currently connected. In this case would be solflare wallet. And then we have the system program, because on Solana you need to always pass in all accounts that a program will interact with. So for example, if we want to create a new account, for that, we need the system program. And since we want to create a new Gamedata account, we need the system program to be able to do that.
00:26:28.280 - 00:26:51.384, Speaker A: And the game data account, you can see down here is everything. It is actually is just a player position. So the whole game only consists of U eight, actually, which goes from zero to three. So it's just a number. And the data type is U eight. This is just one byte. And it means the number will be able to go from zero to 255.
00:26:51.384 - 00:27:25.348, Speaker A: And yeah, this is an interesting part here because this is PDA. It's a program derived address. And program derived address. You can imagine, like if Solana is a big database, then you have somewhere your program, and then you have a bunch of PDas which derive from this program id, like different entries in the table, for example. And in this case, our seed, our table entry is level one. So in level one will be a character which is at position one, two, three, or something like this. And we could now also change this to be level two.
00:27:25.348 - 00:27:56.830, Speaker A: Then there would be another instance. Or what we could also do is we could add the signer as a reference here. And this would mean that we have a level one for every wallet. So now every player would have its own level one. Because actually what we built here is a multiplayer game. Like I'm going to show you. I'm going to ask you later to send me your program ids so that I can then from my client, interact with your program, and then we can actually, at the same time interact with the same program, which is quite fun.
00:27:56.830 - 00:28:28.044, Speaker A: Then here we have the payer, which will be the signer. So as the person who calls this transaction also needs to pay for this account. And this is the space. The space is like basically what it costs to create this account, to have a rent exempt. Rent exempt means that you need to pay a certain amount of sell to save data on the Solana blockchain. And the space is eight byte because this is what anchor does to. It's called an account discriminator.
00:28:28.044 - 00:28:54.832, Speaker A: It's just a little bit of data that anchor puts into the beginning of an account so that it always knows which account this is. And then we have one byte for our player position. U eight is one byte. And yeah, this is already everything that we need to create the accounts. And then we have two functions here, two further instructions. One is move left and one is move right. Let's first move, look at the move right and function.
00:28:54.832 - 00:29:24.604, Speaker A: Yeah, we get the game data account that we pass in. So in the move right accounts, we have the same thing. We put the game data account in. And if the player position is three, then the player has played through the game and yeah, is happy. And otherwise we take the player position, and we add one to this player position. So we move the character to the right. And then this is a print player position, which just checks the player position if it's one, two, three.
00:29:24.604 - 00:30:06.022, Speaker A: And then it just shows the ASCII representation of the game, basically. So, yeah, this is already everything that's happening in tiny adventure, basically. So now let's have a look at the client. This is the derivation of the PDA of the program derived address in the client. It's basically the same as in the program. It's like we take the web3 public key and we find the program address, and we take as a seed, we take only level one. And this is like what you would need to put, if you want to put, if you want to have one instance of the game per wallet, per player, then you would add this wallet public key here as a buffer as well.
00:30:06.022 - 00:30:36.504, Speaker A: And you can put basically almost as many seeds and whatever you want in here. So it could now also have level one and level one stage eins, stage two, stage three or something would also work. Okay. And then here in line 14, we are fetching the game data account. So we go from the program account, game data, and we fetch it. What this means is we call the RPC node and say, hey, give me the data of this account. And then we have the account data.
00:30:36.504 - 00:31:10.060, Speaker A: And if we don't get the account data, then it means the account doesn't exist yet. And then we do the initialize instruction here. So we call program methods initialize, and we put in the three accounts the game name, game data account, the signer, and the system program. System program. As you remember, we need to create the new game data account. And then we need to always, for every transaction, we need to also put a signer, like every wallet on Solana, consists of a private and a public key. And if you want to change data, you need the private key to sign for changing this data.
00:31:10.060 - 00:31:41.946, Speaker A: In this case, we will subtract some soil from our wallet because we are paying for the fees. So we need to sign for this change, because otherwise everyone could just do that. And then if we do RPC, then we are sending this transaction to the RPC node. And that one will take care of. Yeah, propagating it through the network and changing the state. I'm going to tell you a bit about this later, then. Here we are waiting for the transaction to be confirmed.
00:31:41.946 - 00:32:30.194, Speaker A: Every transaction can have multiple, go through multiple stages. The first one is processed, which is as soon as some data changes in one of the validators, it will be processed, and then as soon as it's confirmed, which takes a little bit longer, then it's usually not revertible anymore. So you can already be sure that this transaction will make it into the state. And then there is a thing called finalized, which makes it like, then you can really be sure that it will, it's completely finalized, which is waiting for 31 confirmations, but this one takes a bit longer. So for games, I usually wait for the confirmation state, confirmed. And yeah, then here we create the next instruction, and next transaction. We call the method move left with the game data account.
00:32:30.194 - 00:33:23.994, Speaker A: We sign it, we send it to the RPC, we confirm it, then we fetch the game data account. Afterwards we get the data that is now in there for the new game data position. Then we have a switch case here for the position, and then we print the data also in the client. Yeah. What I would ask you now, while I go around and help everyone who has problems with this is just go in here, change the text a little bit, write a little story here. For example, an elephant stands in front of the door, what will happen next? Something like that. And then you change these three texts here, then you build and deploy it, and then you send me your data, your program id, and then I gonna interact with this program from within the unity client.
00:33:23.994 - 00:34:06.488, Speaker A: And yeah, I would now like, if anyone has questions, I would now go around, help everyone, just write them in the chat. Now let's continue a bit more with the theory. Solana is a big database. Everything in Solana is an account, and every account has this weird address here, which is a 32 kilobyte string. Actually, it's like an array of 32 bytes, but it's in a representation of base 58. It's not base 64, by the way, because there's a few symbols in there which look similar. So that's why they just use base 58 for that.
00:34:06.488 - 00:34:38.544, Speaker A: So there's a little I and the big l or something are similar, so that's why these are removed. Every wallet is a key pair, like I already said, you have a private and a public key. Every account can only be changed by its owner, or you need to at least sign for it. And accounts can be executable, like our program that we deployed. So this is a transaction. Transaction consists of instructions. So for example, I could now, in this program, also add multiple move write instructions, and then I would move two fields at the time.
00:34:38.544 - 00:35:13.660, Speaker A: Then there's a recent blockage, which is very important for the validators to know that your transaction is not expired. So you always need to provide a blockage and then the validator will look for the last not hundred percent sure how long it is, around 30 or 30 seconds. And if this time has passed, then you can 100% be sure. Okay, this transaction will never make it. I can try it again. It's not like in other blockchains where you sometimes have stale transactions forever and you never really know will they go through or not. So yeah, that's another advantage here.
00:35:13.660 - 00:35:42.216, Speaker A: And it's also used for de duplication. And then there's a fee payer. This is the guy who pays the 5000 lamp words for the transaction. And then you have an array of signers. Like we already added only one signer here, but sometimes, for example, if you create a new token or something, you might add another signer. Or if you want to cosign, like for example, I sign in the client and then I sign another time in the backend and only then the transaction will be valid. For example that you can also do like this.
00:35:42.216 - 00:36:43.080, Speaker A: Here's a nice little graph I did for the tiny adventure. So we have the game data account with the seed level one with the player position, which is just a number. And we have the moveleft instruction with subtract one. And we have the move right instruction with add one and we can get data and then have the ascii representation of the game. So what happens to your transaction? What I wanted to show you is when you take this account here and now, I paste it into the unity client, then I will be able to interact with the same program and we will also be able to see that when I interact with the program from in playground, then we would also see the change directly in the unity client. So let me quickly start this up here. This is the seven Seas program, but now we open the tiny adventure scene.
00:36:43.080 - 00:37:26.512, Speaker A: Everything of this is also open source, of course, so you can just very easily access it by checking out the repository. So I login into Devnet and now it's interacting with the same program. So I can now say here I want to move to the right. Here I move to the right. And this could now be one of your programs. So I move to the right and then we see that on the right side in unity, it also moves to the right because the account has a Websocket connection to the game data account. And as soon as the state changes here, then the RPC node will inform our client via the websocket that the account changed.
00:37:26.512 - 00:37:59.748, Speaker A: Yeah. So whenever we read data, the RPC node just looks into its state, gives us the version of the data with the commitment we want, and sends it back. But if we want to write data, then we need to send a transaction which is signed and pays fees. And then the RPC node will propagate it to the current leader of the network. The leader will change the data distributed through a stake weighted tree to all the other validators, and they vote on the state. And lots of magic happening. There's this thing called turbine and all the shreds.
00:37:59.748 - 00:38:44.456, Speaker A: Shreds are the smallest parts of a transaction. They are distributed through this network, then they vote, and at some point the state will be changed, and then the RPC notices this and it will directly push the change of the account to our client. So that's why we actually built a multiplayer game here. So every client who changes this data now will immediately get the updates. So this is pretty cool. And it basically comes for free with the Solana blockchain. Now, I would give you a little homework after the first session in the afternoon, you might be able to change the game a little bit so that you have position, which is like going in X and Y, because currently we're only going back and forth.
00:38:44.456 - 00:39:09.704, Speaker A: And yeah, there's a bunch of different ways how you can implement this. I will show you on Thursday or on day six of the bootcamp how I did this for the seven seas. But yeah, there are different other options that you can use. You can save, for example, X and Y position and create one PDA per ship. Or you just have one player and move it around, or you just save the position. You can also save the position as a string. Everything will be okay as soon as it works.
00:39:09.704 - 00:39:38.776, Speaker A: In the end for the seven seas, like, the one option is to have the X and Y position in there. It's quite easy to implement, but it might be difficult. If you have a bigger game and you have lots of ships, you need to somehow figure out where all these ships are, all the seats of it. That's why for the seven seas, I did it a bit. I just have one big two dimensional array where I have all the ships and then I move them around in there. It's quite easy to have a websocket connection to this one account then. And whenever it changes, it updates your plan player position.
00:39:38.776 - 00:40:13.516, Speaker A: So. But it's also a bit more complicated. So yeah, just try whatever works and just submit it later. And yeah, now let's have a little break maybe. And then we're gonna look at tiny adventure two and how to save Sol in the program. Welcome back everybody, to part two of the day two of our bootcamp. Now we can learn how to save salt in a PDA and pay it out as a reward to the players.
00:40:13.516 - 00:40:41.028, Speaker A: So what we're going to build is this game here. What we can do is we can reset the level and spawn a chest. So the little cube here is a chest. Then I can move right, I can move right, I can move right again, and then I won't be able to. Oh, I collected the chest because I didn't set a password yet. But what we're going to learn is how you pay. So save it in the PDA.
00:40:41.028 - 00:41:18.024, Speaker A: And then if you move to the right, at some point you need, we will add a password to the chest. So if you want to collect the chest, there will be a password to it. So if I now add something else here, then I would not be able to collect this. Actually, I am able to collect this. I think I just deployed the program without the password and yeah, we can add a password to this program now and then deploy it again. And then you will need the password to collect the chest. And then you will see here a little wrong password code as soon as you enter the wrong password.
00:41:18.024 - 00:42:12.872, Speaker A: Okay, for that we gonna go to tiny adventure two. So please open the open Solana playground again. And this time we're gonna open here the tiny adventure two tutorial. So you just click start and then you will have the code again here, the rust file and the client. Then we can quickly close the other account in case you need your soul back. You can take this program address here and you can write Solana program close and then the id and yeah, then we will get our soul back. So we need to quickly switch this to definite and yeah, now we got our soul back and now we can deploy the next game.
00:42:12.872 - 00:42:44.134, Speaker A: Keep in mind that when you close your program, you will never able to use this id again. So don't accidentally close your mainnet programs which has a bunch a bunch of people using it already. Okay, so now we go to tiny adventure two. So there's a bunch of more tutorials here that you can try out. Of course. So tiny adventure two, we built this and then we deploy it and then we run it the same as we did for the first tutorial. Then I gonna show you how the, how the code works.
00:42:44.134 - 00:43:13.120, Speaker A: First let me quickly remove a few things here, which I didn't want you to see. See it. Okay, build, so we're gonna build and then we're gonna deploy it. This always takes a while. So now we're deploying it. And now let's already start looking at the code while we are deploying. So it's very similar to the first one, like the game data account is the same as before, it's just a player position.
00:43:13.120 - 00:43:40.922, Speaker A: We have a few more accounts here as you may notice, and we start again in the initialize, initialize and initialize level one. This will just create the account. So there's nothing special here. On the top we have the chest reward. This is 1 billion lampards divided by ten which results into 0.1 sol. Then when we reset the level and spawn the chest, we set the player to position zero.
00:43:40.922 - 00:44:19.924, Speaker A: And then we transfer some Sol into a PDA, another program derived address. And how we do this is we do a CPI, a cross program invocation into another program. And in this case we call the system program transfer function. So we create a CPI context with the program that we want to invoke. In this case the system program. I could also from here now for example invoke the tiny adventure game and say hey, whenever I move in tiny adventure two to the right, I want in tiny adventure to move to the left or something like this. Then we define here the accounts for the instruction.
00:44:19.924 - 00:44:59.748, Speaker A: So this is a transfer instruction and we transfer from the payer to the chest vault. And then we call system program transfer with this Cpiter context and the amount. And what this will do is it transfers soil from our account wallet to the PDA. And now we can run this example here, you can already see what's happening. So it starts with my balance which is 62.5, it resets the level and spawn suggest here shows as a little diamond. Then here you can see we only have now 62.4
00:44:59.748 - 00:45:21.084, Speaker A: sol left because we transferred 0.1 sol into the chest. Then we move to the right, we move to the right and here in the end we collect the chest. So we are going back to 62.5 sol. So here you can see the little guy is collecting the diamond which represents the Sol that he collected. So this is how you transfer Sol into a PDA.
00:45:21.084 - 00:46:19.714, Speaker A: And if we move to the right and we are at the position directly in front of the chest, which would be two, then we add one to the player position. And here we transfer this all back. Here it's a little bit different because we can't use the system program transfer because the PDA is owned by our program and not the system program. So what we do in this case is we just take the chest vault account, we take the leopard's amount of it, which is like the Sol in it, and we subtract the chest reward and we take the player account and add the chest reward for this. It's important to know that every account on Solana, you can always add salt to it, but you can only remove salt from it when you sign it. And in this case, this chest vault is owned by the program, so it will be able to change it whenever it wants. So we can just take some soil, the chest reward from the program and transfer it to the player.
00:46:19.714 - 00:46:53.706, Speaker A: Very important here is that the balance of the whole lampards in the Solana Rakta needs to be always the same. Otherwise you can't just create salt out of thin air by just transferring 1 billion leper, it's to an account or something like this. So the runtime checks for that, of course. And if you're not at the end, then we just move the player and we print the player position again, like so. Now let's look at the accounts because it's a bit different. Now. The, the game data account is the same as before.
00:46:53.706 - 00:47:40.860, Speaker A: Level one signer, nine bytes. But now we have one more, which is a chest vault. And the chest vault has exactly eight bytes, which is the minimum that you can have with an anchor account because it puts the eight byte account discriminator always in the front of the data of an account that it creates. If you're interested, these eight bytes are actually derived from just taking the string global colon and then the account name, and then it takes the 258 hash of it, and then it takes the first eight byte of this. So in case you ever wonder how this is done, it's not magic, but it's just a standard how anker does it. And then you have the signer and the system program. And the same for the spawn chest account.
00:47:40.860 - 00:48:32.434, Speaker A: It takes the payer, the chest vault, which also has just a c chest vault, and the move right, does the same chest vault, game, data account player, system program. So all that is new in this example is the chest vault. And the chest vault is just an empty struct just to make sure that this is actually the amount of data that is in there. And what anchor also nicely does is when you add the seeds here, it does a bunch of checks in the background so that actually you can only put in the correct account, because otherwise if you wouldn't have any checks, you could just put any account in here. So I could say, hey, I want to play spawn a player, but I just put another account for the transfer of the soil. And this, of course, we don't want. So that's why you add these checks here and then anchor in the background adds a bunch of checks for you.
00:48:32.434 - 00:49:00.572, Speaker A: Now let's look at the client. Client is the same as before, level one. Then here, the chest vault is also just the string. Chest vault, we initialize level one. In this case we can call this multiple times because we edit here. Now it's another nice little thing. We added the init if needed, function here, which is an anchor function, so it will only initialize the new account if it's needed.
00:49:00.572 - 00:49:49.556, Speaker A: Otherwise it will just go on. Then we have a little loop here, which from zero to three moves to the right. So it starts at 0123, and then in the end it collects the chest. And now what we want to do, or what I would ask you to do as a little task, is to add a password to this chest, so all new people with the password would be able to collect this. So yeah, pause the video, take your time, try it out, and I will be back in a second. Okay, so how we could do this is we can just add a password here, which is the password string. And here we would just say if password is unequal, whatever we want.
00:49:49.556 - 00:50:26.674, Speaker A: I'm going to say gib. Then we panic and we put an error message, the password, password was wrong. So, and now if we build this and deploy it and run it. Oh, I got an error here. Good that this happens now. So this needs to be uppercase string, I think. So you're going to build this, then we deploy it, and then you will notice that also in the client, of course, now we need to add this new parameter.
00:50:26.674 - 00:50:58.306, Speaker A: So build, now we deploy. This will again take a while, but we can already go here in the client and we should now see a little error here somewhere. The move right now needs another parameter. So here we now put some wrong password just so we will be able to see the error. Now we wait a little bit until this is deployed. This is a little bit faster if you run your local validator. So I'm going to show you later how to do that when we go to the local setup.
00:50:58.306 - 00:51:29.610, Speaker A: Okay, so now this is deployed. And now if we run this, we will get an error in the last instruction here. Hey, failed to sense send transaction to an simulation. Failed with instruction one. Now I want to show you a little bit more how you can make these errors a bit nicer. So we go here in the tutorial, to the last page or to the penultimate page or so I think it is. And then we can see, we can also create a nice error code.
00:51:29.610 - 00:52:25.642, Speaker A: So if we copy this here, this is a good practice that you are, instead of just panicking, you create an error code. And then this error code you can return here in this function. So let me copy this in here. And if I return this error code, then in the client we can pass this error. So let me build and deploy this again and then I'm going to show you quickly in the unity client. So now I'm back in C hash in the unity client I gonna open the tiny adventure two service and then I search for error. And here you can see we take the transaction info and then we check if there was a custom error and then we compare it to the wrong password error which is in this case 6000 which you can find in the IDL.
00:52:25.642 - 00:53:07.474, Speaker A: And then we show a string on the screen which is wrong password so that you can then also do. So. This IdL you can export here and then you can open it here, click on the left on this little gears icon and then on IDL and then export, then it will open the IDL for you. And then you can see exactly what is in this JSON representation. And as soon as you add an error, then the error will also show up here in this json. So here wrong password is the error code 6000. And then in the clients you can use these error codes to handle whatever you want.
00:53:07.474 - 00:53:32.764, Speaker A: For example, if the player doesn't have enough tokens to pay for something, you could show him a pop up. Hey, do you want to buy more tokens? Or you can just show the error so the players know what the users of your app knows what know what's going on. So back to the presentation. This is tiny adventure two. Here's the little graph of it again. Little flow shard. We have the get data again.
00:53:32.764 - 00:54:03.940, Speaker A: For the player position we have reset and level, reset, level and spawn chest, which sets the game data account position to zero. And it adds a little bit of salt to the chest vault. Then we move right, and when we're at the end, then we check the password and give the player his soul. This is how to save Sol in a PDA I showed you already in the program. So this is how you transfer it out. You just subtract the lamp words. And now what is also very important to know is how you interact with SBL tokens.
00:54:03.940 - 00:54:43.330, Speaker A: SPL tokens are most of the tokens in Solana. For example, USDC is an SPL token. The pirate gold that we created is an SPL token, the canon token is an SBL token. There's also a wrapped sol token which is also an SPL token. And yeah, if you want to know how to interact with this, I will not go too much into detail how to interact with these in a program because you will do this tomorrow with Jacob for the staking of tokens. But how you would do it is you have a token account and a token account needs to be owned by another account. So your wallet for example can own a token account for USDC.
00:54:43.330 - 00:55:45.334, Speaker A: And there's also a special token account which is the associated token account which is derived from the name of the token, the mint of the token and the associated token program id. And like this, the wallets are very easily be able to find your wallet, your token accounts in your wallet because otherwise you can have all kind of token accounts derived from whatever you want. But yeah, this is a very good practice to use the associated token account and you can only have one per token per wallet. And then if you want to create a token account which is owned by the program, you need to add an authority like token account owner. This can also be a PDA and you add the mint in this case would be pirate gold or the USDC mint. And yeah, then you can create this token account in your program and then you can like usually just transfer in and out of this account. So to transfer in you have the transfer instruction, the same as the Sol transfer earlier.
00:55:45.334 - 00:56:20.984, Speaker A: You create a new CPI context with the token program and the transfer instruction. So you have from account to account. And this time you also need to add the authority for the from account because otherwise you can transfer the tokens out of this account. And then you call the anchor SPL token program. It's actually the token program transfer versus CPI context and the amount. So this would be 1000 tokens for example. Then you would need to put in thousand to the power times, the decimals of the token to the power of ten amount in here.
00:56:20.984 - 00:57:10.154, Speaker A: And to transfer out is just a tiny bit more complicated because you need to sign for the PDA, with the PDA for the transfer in the program. But here's an example how you can do that. And then you would just call the CPI context new with Signer and the signup would in this case be these seats here, the token account owner PDA and the bump. So now it becomes more interesting. We gonna do a local setup. So the playground is super nice, but at some point maybe you want to develop locally as well. And if you check out any repository then probably will want to run it locally and you also want to be able to build an XJs client and also on so how we do this is we follow these instructions on the anchor installation docs.
00:57:10.154 - 00:57:44.220, Speaker A: So this is a very good guide here. So you start with installing rust. For this you use rust app, just use the newest version that is currently compatible with everything. Then you go install Solana. So for that you just run this command here in any terminal that you want. So you just create a new terminal, paste this in here and it will install the Solana Cli for you. Then the next thing you need to do is Solana Keygen new.
00:57:44.220 - 00:58:48.258, Speaker A: This will create a key pair for you in the standard location and if you have a key pair there then you can transfer some defnet soil into it for example or some real sol if you want to work on Mainnet. And yeah this is a precondition that you need if you want to run and build anchor programs locally because you need to define a key pair and the easiest way to do this is have a key pair in the standard location and then use that one. Then you need to install yarn. You can also use NPM, but I'm big fan of yarn. Yarn is a bit, it's a bit faster because it does things in parallel and it has hashes for all the versioned packages actually then you use install the anker version manager AVm. For that you just copy paste this command here into your terminal and then run it. There's also an example for Linux systems and the rest here we don't need and then how it should look like in the end.
00:58:48.258 - 00:59:38.866, Speaker A: Let me quickly delete this stuff here. I think there's a shortcut to delete this but okay, so anchor version should show you 28 Solana minus version should show you 1.16 rust C should show you something like this, maybe a bit newer. And if you have all these installed then you are actually good to go. So then now I would like you to check out the repository game starter kits. So check out this repository please with any git client you want. If you are using GitHub, GitHub desktop is the easiest function, the easiest thing to do it.
00:59:38.866 - 01:00:15.774, Speaker A: And then you please open the tiny adventure folder in visual studio. So I did this here already and then here on the left you should have app and program. Then you can go into the program folder and you can write anchor build. This will build your anchor program. Of course you need set up your wallet before, like I told you earlier, your wallet is defined here. This is your the default place. And if you don't have any solenit, you can type Solana balance.
01:00:15.774 - 01:00:52.410, Speaker A: UD will give us the balance of Defnet. So you can with every command you write in the CLA you can obviously Ul for local, UD for definite, and um for Mainnet. So and then you can also do Solana address. This gives you your address and you can just transfer some so into there. Or you can do Solana airdrop something too. I already have too much requested too much today already. Or maybe if I add ud.
01:00:52.410 - 01:01:13.354, Speaker A: Ah, so I got some more. So now I'm at twelve. I think the current limit is four sol per day. So this should be enough to deploy an anchor program. Then you can either close it or you wait a day until you get another four definite. So yeah, so this is a definition of your program. Here is your program id.
01:01:13.354 - 01:02:03.082, Speaker A: You can also add the program id that you had in playground earlier, for example, if you want to do that, and then you can deploy the program. And that's basically all we did already in the playground. But the interesting part now is to look at the client for it. But maybe let's go first through some extensions that I would recommend or that I use. Not necessarily recommend, but they are very good. So the rust analyzer is basically a must have if you work with rust in visual studio, because it gives you all the types and auto completion and everything that you need to work with rust programs. It has all the crates passed, and then you can just write dots, and then it shows you all the function names, for example.
01:02:03.082 - 01:02:43.884, Speaker A: Then there's better Toml, which formats TomL files in a nicer way. So for example the cargo toml and Xavo Tomml and the anchor tommel and so on. Then we have error lens. Error lens shows error a bit nicer. Error is a bit nicer and more pretty prominent and shows you some I don't have an error here currently, but yeah, it shows your errors in a nicer way. Then I use also GitHub copilot is an AI tool which just autocomplete sentences for you. So for example, it's not super good at coding, but it helps you a lot with comments, for example, and tests.
01:02:43.884 - 01:03:21.726, Speaker A: If you want to write a for loop, for example, just does it for you. And sometimes it also comes up with very good ideas. So it's like sometimes very useful, but don't trust it too much. And then I also have the extension called crates, which shows you which dependencies are out of date, by the way, you find all these extensions here, you just type it here and then you have better tumblr. And then you have crates and the crates. One, for example if you go to calculus, shows you this little checkbox here, or not if you are not on the newest versions. So just a nice little hint then optional is code.
01:03:21.726 - 01:03:44.186, Speaker A: LDB is like a rust debugger. It doesn't really work on programs, but it's still good to have prettier. Makes your code prettier by formatting it correctly. And then there's of course visual code, studio pets, which is very important. Here you have like this little crap and a little mouse and they fight each other. It's a cat, not a mouse. Yeah.
01:03:44.186 - 01:04:23.934, Speaker A: It should also be mandatory, I think very important then. Yeah. For the local setup you can also, in your settings you can configure the analyzer and the formatting, so you can set the default formatter to rustling rust analyzer, you can say format on safe, which is nice. And you can also add your check rust analyzer to clippy instead of the default one. So now to the local setup, how you run the program. You go into the program the tiny adventure. We did this already a few minutes ago, but then you install the NPM packages I think that we did not do yet.
01:04:23.934 - 01:04:55.184, Speaker A: So NPM, NPM, I actually should use yarn install since you shouldn't mix the different package managers. And what does it say next? Anchor test. So we run anchor test and this now runs the tests. It deploys the program and then runs the test into it. So it initializes run write, run write. And now all the tests are passing. Then how to run a local validator, so you can do a Solana test validator.
01:04:55.184 - 01:05:35.214, Speaker A: This starts a local validator on your machine and then you can also, for example in playground you can here go to localhost and then you can also deploy to localhost and you get some bunch of free sol here. So I have 100 sol on my local net and you can also airdrop as much as you want and the deployment is a little bit faster as well. Solana Airdrop 1000 so now you have 1000 solid. So that's pretty cool. Yeah. And then we go to the app and run yarn dev so that we didn't do yet. So we go out of here, we go into the app folder and then we just run yarn dev.
01:05:35.214 - 01:06:15.934, Speaker A: And now we have our JavaScript client here. It's the same code as in playground. So I just deployed it somewhere else. But this is now a next JS app, so and it has a few benefits because it's like nice to have build a UI there. So you have like this move left and we sign this and character moves to the left, it moves to the right. I can get data and initialize and it uses the wallet adapter so the users can pick whatever wallet they want, which is of course very convenient. And when you have any helps you can go to solanastackexchange.com.
01:06:15.934 - 01:06:53.334, Speaker A: You can ask all kinds of questions here. And yeah, we'll hopefully get answered. There's a bunch of people who are like constantly answering and asking questions. Chat CPT can also often help with this with rust problems. Those rust very well request all these borrow checks and so on. But I would recommend you watch a few videos on Rust. They have very good videos on YouTube, just some tutorials that you can just follow and like learn about borrow checks and how you do enums and option types and so on.
01:06:53.334 - 01:07:28.174, Speaker A: Let's quickly go over the code. Like the back end code is the same as we had earlier in the program, but the front end code is of course a little bit different now. So we have here the multi wallet button. We have the context where we define the different wallets we want to support. We have the IDL as typescript for that. Actually you need whenever you build the program it will also create your typescript client. So you can go to target types and you can copy these types here, copy paste them into the client types.
01:07:28.174 - 01:08:04.974, Speaker A: So if you now would add in a new function like move up or move sideways or fly, then you would need to build the client, copy the types over and then you can use them in the typescript client. The same for C hash unity client which I will show you later. Then here are the different pages. This is the index page. I will not go too much into detail about the JavaScript part, but you can look at the code here. So you have use wallet where you get the public key. Then there is a loading state loading right, loading left.
01:08:04.974 - 01:08:50.390, Speaker A: So this is like a state for the different buttons so that they have a little spinner in it, so you can like can't immediately click it again. Then we have the state which is the ascii representation of the game with the little o moving over. Then we have here the state game data account which we will fetch and then we will also create a websocket connection for it that I will show you in a bit. This is how the position is printed. Then we have an effect here which updates the player position whenever the game data account changes. This is a state, then we have an effect here. The first time we load the game, we will fetch the game data account from this PDA here.
01:08:50.390 - 01:09:21.066, Speaker A: PDA is found the same way as in playground with find program address. Another thing we have here in the anchor typescript is here we create the program. So this is taking the IDL which I showed you earlier. This typescript file here, not exactly this one the program. And yeah, it creates this program. And here's the program id that you would need to replace if you want to add your own one. Then here we create another wallet.
01:09:21.066 - 01:10:03.802, Speaker A: This is only used for the backend API, which I will show you later where you can also trigger the move left right instructions without signing. Then here is what happens when we click on get data. It does a fetch for the game data account. And when the data is fetched, we set the data in the game data account in this state here. And then when this state changes, the position is printed again. Then this is what happens when we click right, the same as in playground methods, move right accounts transaction and yeah, this is what happens when you are not logged in. Then it will actually call an API which will do this for you in the backend.
01:10:03.802 - 01:10:47.686, Speaker A: So this is a very nice thing about next JS apps. If you go to pages API send transaction API, then you can see here that there is a burner key pair here and this burner key pair is here in the process env environments. So I have this environment file here which just has a, you should of course never show your private keys to anyone. But this is just a burner key which has a little bit of definite sol in. So I can quickly show you how this looks like I can. Now I can also interact with this game without being locked in. So if I, if I cancel and I'm not locked in, you can see that I still can move.
01:10:47.686 - 01:11:20.850, Speaker A: So. And how this works is that it calls an API. So API. I think I wrote this earlier, so invalidate transaction API. So now if I point this to the correct one, we can see that if I call this API here, it should move to the right. See, it works. So everyone can now use this API also to interact with our program.
01:11:20.850 - 01:11:55.154, Speaker A: And the trick behind is that the transaction fees are paid in this API by this burner key pair here. So you don't actually need to sign. Yeah, so it gets the instructions either from the query or from the body. And yeah, if it's initialized, it initializes. If it's move right, it's move right. If it's move left, it's move left. So it's the same thing it creates here it gets the recent blockage, it sends the transaction with the signer where the signer is the burner key pair.
01:11:55.154 - 01:12:30.704, Speaker A: So yeah, this is this API here. So you just have in your backend, you have a key pair that you use to sign for stuff. And you can also use this, for example to have a partial sign. You sign something in the back end so that you can be sure that the transaction is what you want. Then you send it to the client, and then the client signs it as well, pays the transaction fees for example, and sends it off. And here you can also see how you would call that. And now I will do a very quick intro into the Unity game engine.
01:12:30.704 - 01:13:08.124, Speaker A: You can get the unity game engine from Unity.com, then you can download the Unity hub and then from there on you can install the newest Unity version. And then you can open the Unity folder in the seven CS example under Solana game starter kits. So you would go to Solana game starter kits, then you go to the seven CS example and there's a unity folder in there. And then you open this unity folder in unity, and then you have all the examples. So you have the tiny adventure. Two you have tiny adventure and you have of course seven seas.
01:13:08.124 - 01:13:57.690, Speaker A: So this is a seven seas game. So everything is there and you can do pretty much everything in unity like you can in JavaScript, in the JavaScript rev three j's. So you have RPC support, you can create transactions instructions on Unity. You can also export to Android, iOS, windows switch. You could theoretically make a game for the Switch which interacts with the blockchain. It's just difficult to send SOl there, but you could have a QR code which funds your wallet, and then you could have a blockchain game on Twitch for example, on the Switch for example. And then you have Webgl, Mac Windows currently supported wallets are the whole wallet adapter for WebGL.
01:13:57.690 - 01:14:43.034, Speaker A: And on Android I think it's also supporting all wallets. And on iOS currently it's only phantom using deep links. So if anyone wants to participate you can add the soulflare support. I think they have the same deep link functionality on iOS like Phantom. So if someone feels like participating in the unity SDK helping the community, this would be maybe a nice first pull request, then C hash and JavaScript compared. So here you can see it's pretty much the same thing you create. To get the recent blockers, you add the fee player, you have the instructions and it's the same in JavaScript, just written in c hash because Unity is c hash based.
01:14:43.034 - 01:15:19.384, Speaker A: And there's also a not unity implementation which is like Solnett actually the unity SDK is based on the Solnet implementation. And there's also a code generation tool from BM Research is now maintained by Magicblock and.net tool. Install Solana unity anchor tool. So you can just install this one in one of your favorite terminals. Let's quickly stop this here. And yeah, so this is how you would install this tool.
01:15:19.384 - 01:15:56.958, Speaker A: And then you can run this tool. And as an input you put the IDL JSON file, and as output you would put, yeah. Where you want to save the file. So in this case we would, we are in an app, so we want, actually we want a new terminal. We go to program CD program. Why is it wrong? Where am I? Ls CD program. Okay, I can't write anymore.
01:15:56.958 - 01:16:47.734, Speaker A: It's too long already. Okay, so now we paste this in here and when we are in the program we would go to our folder target, target, target IDL. And then we have here somewhere the j is a file. So in target IDL. And then we have tiny adventure Jason and for output we put it to target IDL program source code. So, and this now creates us c sharp representation of our game. And this one we can now just copy paste into unity and use and how this looks like in unity.
01:16:47.734 - 01:17:26.404, Speaker A: Let's look at the tiny adventure service. Here we have the program id on top, then we have the game data account. Here we find the level one program address. We do the subscription to the game data account via websockets. This is how you would get the game data. You get account info async from the game data account with the confirmed commitment and the binary encoding as JSON passed. Then you get the game data back and then you can do game data account deserialize from the base 64 decoded data in the account.
01:17:26.404 - 01:17:55.202, Speaker A: And this game data account is a part of the tiny adventure account client that we just generated. So it has everything in there that you need. Like it has the account discriminators, it has deserialized, it has the functions move left, move right. So here's move right. This is a move right instruction. So it just creates everything for you. Basically.
01:17:55.202 - 01:18:29.476, Speaker A: You don't really need to care about the specific data that is in there. That's a count discriminator, the data that you want to put in. And then when we want to move right, we get the move right instruction, we put in all the accounts, move right accounts. We call on the tiny adventure program, move right with this account and the program id, and then we send the instruction in the next block. In this case, there are some transaction service that I wrote which wraps the transaction. So you can nicely show it on the bottom left in the game. But this is how it would look like when you do it manually.
01:18:29.476 - 01:19:06.896, Speaker A: You create a new transaction, add a fee payer, recent blockage, signatures. Signatures in this case is empty because it will be filled by the wallet adapter. Then instructions and then you add your instruction. And you could also add multiple instructions here, like move left, left, move right or something like this. And would like move back and forth in one transaction whenever this would make sense. Yeah, so this is how it looks like in unity and yeah, where you go from here. So if you want to participate, you can for example, check out the seven seas example and add a few more things there.
01:19:06.896 - 01:19:38.314, Speaker A: Or like you, I think I set the homework earlier already, right? Yeah. So you take the tiny adventure and you make it so that you move up, down and left and right. So this would be a very good task for the first day and that we will also need on the 6th day when we then look at the implementation of the seven seas, how we implemented it. So on the 6th day we will go through all the functions and all the features that the game has. Yeah. Thank you very much. Here's a list of all the resources that we went through today.
01:19:38.314 - 01:20:13.008, Speaker A: And if you have any questions, drop them below in the comments. And yeah, I hope you're gonna build cool things in the next days. And tomorrow you're gonna go and stake your gold. And then this gold you can use in the game to upgrade your pirate ships. And then the day after you will be able to take the gold and have it swap in a swap program and get gold and cannon and rum. And the cannon will increase the damage of your ships, and rum will make your ships strong, stronger in health. And then there will also be an arbitrage program and lots more.
01:20:13.008 - 01:20:18.404, Speaker A: So I hope you tune in again in the next days and yeah, see you next time.
