00:00:14.440 - 00:01:12.358, Speaker A: Hello, is it possible to have my slide? So this is for the stability devs out there. We've got a whole new tooling set for solidity for Solana. This allows you to take solidity and compile it into native Solana contracts, which should make it very fast and has a number of advantages. So at this moment in time, if you want to write a smart contract for Solana, if you want to do a native one, you'd have to write it to Eden and rust or in C. I think C is also possible. Now if you want to use steadily, then you have to use an EVM layer in order to make that work. So this is a project where we don't use EVM, we take solidity source code.
00:01:12.358 - 00:02:18.190, Speaker A: You can compile it directly to BPF smart contracts. This is a completely new compiler, which is a completely new compiler written from scratch. I started this in 2018 on a rainy Sunday when I thought I can write my own one. I have a background in compilers, so I had been looking at the Ethereum tiny compiler and they don't use LLVM and they have a handwritten parser. So I thought by starting this project from scratch we can do a number of new things. Write it in rust, we can use acidity grammar, and by using LLVM we can do codegen for different chains and make it also very efficient, so we can generate very efficient code. However, if you want to compile to Solana natively, then there are going to be differences.
00:02:18.190 - 00:03:23.774, Speaker A: There's lots of technical details, implementation details of Ethereum, which become evident in the language like gas for example, which doesn't really exist in Solana. On Solana you have a budget and you have to execute within that budget. So you don't really have the concept of gas left. So if your source code uses gas left, then all of that just has to be taken out or has to be replaced with something equivalent. Also, because we're not running on an EVM virtual machine, running on BPF, if there's an assembly statement in acidity source code, then that won't work either, because we don't have EVM instructions, so those sections have to be rewritten. But those two we've paused up Uniswap, for example, those changes are quite small, so the reorder should also be quite small. No, wrong way.
00:03:23.774 - 00:04:09.514, Speaker A: So apart from functionality, which is different because we have a whole new compiler, we can also add functionality, which is a bit more difficult with the Ethereum compiler because that targets just Ethereum chain. So we can do things like Ed 255 1.9 signature verifications. We have a print function, so if you want to debug with your solidity code, you can just use print, which makes life so much easier. You can even do string compares and string concatenations, and you can do string formatting. All of those things are not possible on Ethereum, and we can extend the language whatever way we see fit. So we want to be sensible about what we could possibly add to the language.
00:04:09.514 - 00:05:04.874, Speaker A: Nope, didn't. Again, we also have some more tooling, so because we've written rust, we can use a whole bunch of rust crates. There's a rust crate for language servers, so we've implemented that. And so we have a language server, which means we also have a visual studio code plugin which gives you nice little hovers of types and so on, and gives you warnings and errors and squiggly lines. So it's nice for the development experience. It should also work in other ides. We have a new NPM library called Atslan Acidity, which allows you to deploy call and stability contracts, getevents, get return values, et cetera.
00:05:04.874 - 00:05:53.834, Speaker A: All of this requires slander 181 because we needed to add some functionality to Slana to make this work. So just a simple example, very very very super basic contract just to show what it would look like. So you have a flipper, then you compile it. So you run Solang with a source file. You say I'm compiling for Solana. Then the output is you have a bundled so so that's a native Solana contract file. You have an Ethereum ABI file, and it also outputs a line saying the account data for this contract needs to be 17 bytes.
00:05:53.834 - 00:06:25.212, Speaker A: So that's just useful information. So you can use the minimum amount of data for your contracts. So here's some JavaScript to make it work. So you read the API file, you read the so file. This is just some stuff to do, an airdrop for your local test program. So you load the program once. So the compiled program is load once.
00:06:25.212 - 00:07:18.544, Speaker A: So unlike ethereum, where each contract has an entire copy of the entire code, on Solana we have one contract which contains the code and that can be reused many times. So if you want to deploy the same contract twice, you don't have to pay for it twice. You only pay once for the upload of the contract. So you have uploaded the code. You need an account to store the account state, so you generate the key pair on the program you call deploy contract with some information about the contracts, including construction arguments. Also the amount of space you want the account to have, which is 17 from the earlier slide. We probably need some sort of better metadata so that information is passed along automatically.
00:07:18.544 - 00:08:07.644, Speaker A: And then you get a contract as a result, on which there's a functions interface where you can call the get function. So this get function is the same as the too far away. The get function is the same as the get function here at the bottom. So this function is view. So here we can, because the function is vue, we can do simulate and then the function is simulated so you don't need to pay for it. We have a new version of the library which does this automatically for you, so you don't even need to parse simulate. It's not quite published yet.
00:08:07.644 - 00:09:02.014, Speaker A: We'll do that soon. You can also call the flip function on the flipper, and then when you get it, then the state has been flipped. So the await contract functions flip that will do an actual transaction. That's a very basic example. So a few more technical details in your logs. Types are 256 bits, and in BPF that's not the case in BPF registers of 64 bits, which means that the code gen for some instructions has to be a number of instructions. So if you add to uint 256, that's four instructions for four adds to make each 64 bits work.
00:09:02.014 - 00:10:00.844, Speaker A: If you have a multiply divide or modulo or so, then it gets a bit more complicated. You have sort of begin kind of functions you need in order to make that work. But often the value, the actual values involved aren't that large. So there's a code path in Solang which tries to reduce the strength reduction on on multiply, divide, etcetera. So here we have a loop from I from zero to ten, multiply by 100. The compiler knows that value can never exceed 64 bit, so it will just truncate the values and do a 64 bit multiply, so it could even derive. So this is what it can do currently, maybe in the future what we can do is derived that the variable I could just be 64 bit and even simplify the code even more.
00:10:00.844 - 00:11:00.724, Speaker A: So there's a number of optimizations we can do. So this is not the only solution. There's also neon VM of course offers very precise EVM compatibility. So you can take any contract which is written, any state of the inversion, and it will just work. However, it has to simulate each EVM instruction, so that's just slower. Solar compiles native code, which means you get faster code and you also get access to native features so like the print function, the program log, you can just print directly to that. With neon VM you don't have the functionality because it doesn't exist in Ethereum.
00:11:00.724 - 00:11:56.264, Speaker A: So it's not an Ethereum compiler, you're just not going to have it. So Neon VM, certainly it's very useful and for some use cases it might be a better solution. But here we're trying to do a solidity dialect for Solana. So we're now at a point where all the built ins, everything works, they all got unit tests. So now we're at a point where what we really want is people start using it and we want to help you. So if you're a student dev, you have some contracts, please try it out, tell us what you think, tell you what can be improved. And we already want to make it work, so we're here to help.
00:11:56.264 - 00:12:45.394, Speaker A: We need more functionality, we need more bridges to native things. So at the moment you can't access SPl token and you can't do calls from CDT to rust contracts, vice versa. So that's definitely very important. That's the thing I'll be working on next. So now that we have our own compiler, we can extend the language any way we see fit. So what features missing? Acidity? What can we add? There's lots of data structures which are missing. You don't have trees, you don't have arrays which you can grow, push or pop memory arrays.
00:12:45.394 - 00:13:33.082, Speaker A: There's lots of things that could be added to steady. So as long as it's sensible, I just don't see any reason why it shouldn't be added. We've got more processing power on Solana, so yes, we would like to work on that. Yeah, so I just wanted to talk about it briefly. We have a lot of documentation, mainly about the language, which kind of mostly is the same as the Ethereum synergy compiler. We have a discord channel. And so yeah, please try it out.
00:13:33.082 - 00:13:38.574, Speaker A: Let us know what you think. That's it. Are there any questions?
00:13:39.554 - 00:13:41.414, Speaker B: Any questions? Ake.
00:13:49.834 - 00:14:05.620, Speaker C: So you didn't speak a lot about data storage. For example, in Ethereum you have mappings that can hold an unlimited amount of data. Solana, you have icons that have this ten megabytes limit. So how do you deal with this?
00:14:05.772 - 00:14:40.596, Speaker A: Yeah, okay, so like you say you have this key value store on Ethereum which doesn't exist on Solana. So this is all handled transparently. If you have just fixed width fields that just become fixed, like the flip for example, that's just a fixed amount of count data you need. If you have a mapping, for example, then you can add and remove elements. In that case, there's a mini heap which can do malloc and free on the account data. So that's all handled transparently. There's no key value store anymore.
00:14:40.596 - 00:14:48.024, Speaker A: It's just the account data which usage grows as is needed.
00:14:55.864 - 00:15:09.848, Speaker C: But what happens when the ten megabytes limit is reached? Because unmapping, it's just unlimited. You can have a mapping that holds more than ten megabytes of data, but.
00:15:09.936 - 00:15:16.924, Speaker A: If you try to store ten megabytes of data on Ethereum, that's going to cost you a lot.
00:15:17.504 - 00:15:17.816, Speaker B: Yeah.
00:15:17.840 - 00:15:25.204, Speaker C: But there is multiple users that are storing on the state, so it's not all the same users storing data there.
00:15:25.324 - 00:15:48.584, Speaker A: Yeah. So at the moment, you are limited for one solidity contract is one Solana account. So you are limited by that. Yes, yes. There might be a way of splitting that if necessary. Yeah, this is true. This is limitation.
00:15:48.584 - 00:15:50.974, Speaker A: Sure, we can work it out.
00:15:51.554 - 00:16:05.274, Speaker B: Probably have time for one more question if anyone's got one. Okay, cool. Awesome. Thank you so much, Sean. We are going to bring up the next panelist pretty quickly. Yeah. Round of applause for Sean.
