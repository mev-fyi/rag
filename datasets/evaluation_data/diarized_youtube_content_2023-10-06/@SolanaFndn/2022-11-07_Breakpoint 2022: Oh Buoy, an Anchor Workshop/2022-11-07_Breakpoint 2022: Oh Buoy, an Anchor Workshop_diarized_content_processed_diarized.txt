00:00:02.080 - 00:01:04.084, Speaker A: Okay, hello. In this talk, I'm going to be talking a little bit more intermediate level anchor stuff for people who may have missed certain changes in anchor over the last year. I like pdas a lot, program drive addresses, so I'm going to be talking about that random tidbits, just things that I've picked up in the San ecosystem, and then what's next for anchor and future macros that we're working on? Ready for my talk? So again, you probably already know, but anchor is what you'd use to write smart contracts on Solana. You can write it using the normal Solana default stuff, but anchor makes it a bit easier. It adds a bunch of macros to write a bunch of what you call it border plate code, and it also makes it easier to write a client to interact with those smart contracts. There's the typescript client, but there's also rust clients and python clients with anchor Py. And so who am I? I started working for anchor in the last month or two.
00:01:04.084 - 00:01:33.464, Speaker A: I'm sort of becoming the new maintainer, so I'll be writing a lot of the new source code for anchor and all that kind of thing. Next slide. So new features you may have missed. This is the best one that I liked. No more hex codes. This is a big issue in the discord where you would get a random hex code from your program log and you'd have to decrypt that and figure it out. But there's no more of that.
00:01:33.464 - 00:02:30.294, Speaker A: You should be seeing a line number from your program, like an actual error message. And if you have a values comparison, you're also going to get that as well. So like, let's say you're comparing two public keys, it will show what was the right one, what was the wrong one, and it becomes a whole lot easier to debug all of your stuff. And if you're not seeing this, they're in the program logs. So you either need to try catch on your transaction, or you really need to use no preflight checks, this kind of option when you're sending the transaction, and then look into the program log directory to see this error. But if you're not finding it, come to the discord and we'll try and sort you out. Yeah, this is another big thing just addressed in the previous talk.
00:02:30.294 - 00:03:27.314, Speaker A: Auto derived or auto inferred program derived addresses. One of the most, one of the biggest hassles, I guess, when writing a program is making an SDK that will gather together all of the public keys that you need. And if you write your PDA's, your program drive addresses using a certain set of seeds, like there's a specific format that you need to use and all of the formats are listed out on this PDA derivation lib rs file. If you use those formats, then anchor in the client will be able to auto generate those public keys for you, and that saves a lot of time. And then recently that's also been extended to include the has one relationship. So if you've got a has one relationship like I have a certain account, it will auto infer what that public key is and you no longer have to worry about passing it in manually. So it just saves a lot of time and effort.
00:03:27.314 - 00:03:47.530, Speaker A: And if you don't know how to activate this feature, it's a feature flag in the anchor toml. So you just need to switch seeds equals true and you should be able to get access to that. Cool. Next one. Yeah, this is another big change. If you use program derived addresses, you used to have to pass in the bump. So it's called the bump seed.
00:03:47.530 - 00:04:21.118, Speaker A: It's anchor enforces that we use the canonical bump seed. So you start at the number zero and you iterate up to 255 and you stop at the first one. That gives you a public key that falls off of the curve or whatever kind of crypto shit that involves. So we enforce that you use the canonical seed, but you no longer have to pass in the bump. So again, it was one of these kind of hassles where you'd have to pre calculate, you have to find program address, get the bump, pass it in. No more of that. It's also more efficient as well.
00:04:21.118 - 00:04:48.120, Speaker A: I think in the backend it was calculating the bump like two or three times, so there's no more of that, which is pretty handy. And when you want to access the bumps, they're stored on the context object. So it says context bumps, and then it's a b tree map and you have the name of the account that you're looking for. So definitely use that if you can. Cool. This is also new, maybe you missed it. It's the AVM.
00:04:48.120 - 00:05:21.464, Speaker A: It's the recommended way to install anchor. Now the anchor CLI. Aside from making it easier to install anchor, if you're working with an older program of anchor, which I think a lot of people do, because there's a lot of open source programs that are using older versions, the CLI version has to match up with the program version that you're using. And this makes it super easy to switch between versions. So if you want to go back to version 14 or version 20. I think we're on version 25 at the moment. AVM, which I assume stands for anchor version manager and not virtual machine, then that's what you should do.
00:05:21.464 - 00:05:54.684, Speaker A: Cool. Anchor expand. This is just more like an advertisement. I think everyone should read the generated source code that comes out of anchor. So a lot of the magic from anchor is the macros. And if you want to read what the macros are generating, you would typically run cargo expand. But Polx added a thing called anchor expand, which is just a wrapper around cargo expand, which puts it into the anchor directory so it's easy to access and you can see all the different versions over time.
00:05:54.684 - 00:06:36.042, Speaker A: And also, if you're not aware of it, in your root directory for your anchor program, there is a anchor folder, and that's where you'll also find stuff like the program logs and stuff to do with the test validator that gets spun up. All right, cool. So I'm contractually obligated to mention all of these other things. Recently I think they added idls. So the interface description language for all the SBL programs and other programs that are just not like written in anchor, so that you can make easier clients and still use the anchor syntax. There's the anchor book that I think is sort of half finished by Paul. It's got a lot of descriptions and information about how to use anchor.
00:06:36.042 - 00:07:18.862, Speaker A: There's APR Dev, that's the anchor program repository. It's where we verify programs. Then there's a new feature that's being requested a lot called optional accounts. So I think it's kind of controversial feature in the sense that you can choose whether or not to pass in certain accounts. And personally, my opinionated opinion is that when you're making optional choices, those sort of options should happen in the client, and most of the logic should happen in the client, not in the smart contract. But it's just such a massive demanded feature that I think this is coming in the next version that we release. And then also backpack, which is Armani's new wallet, which is very cool, is going to have native support for anchor clients.
00:07:18.862 - 00:08:08.490, Speaker A: So anchor uses a provider object to interact with wallets and stuff, and in backpack you're just going to get that object automatically, although I don't really know what that means. All right, program derived addresses. I think everyone's been PDA pilled at the moment. Like by now. They're like the way to write secure Solana smart contracts, basically. And there's a lot of weird features about them that you have to figure out by yourself or like here in the rumor mill, try again. Okay, so the first really cool thing that's been added is there used to be a limitation that program drive addresses could only have 10 kb in space, and that's not enough, right? Because I want all my accounts to be PDA's.
00:08:08.490 - 00:08:54.794, Speaker A: So for example, serum, all of the serum order books would be at least 60 kb, if not more. And now with realloc, you can allocate 10 kb, up to 10 kb every instruction. So you can have like twelve instructions, I think, for transactions. So you can just pump that all in there if you want to. And anchor has support for this using realloc, these realloc constraints. And it's really recommended that you use the anker constraints because if you try and go and do it manually, the Solana native runtime won't check that you're allocating, not allocating more than 10 kb. So if you go in and do it manually and you allocate more than 10 kb, you can actually run the risk of overriding data in other accounts.
00:08:54.794 - 00:09:45.592, Speaker A: And there's no checks for this. So try and use the constraints if you can, or be very careful. So another cool kind of PDA thing that maybe not everyone knows about, these are system program owned PDA's. So again, to recap, a program derived address is derived from the program's public key. It can only be signed for by the program used in the derivation, but that address doesn't actually need to be owned by the program that it's used to derive. So the most obvious example of this is the associated token account, where you have an account that's been derived from the associated token account, but the account itself is owned by the token program. But more interestingly is to have a system program owned PDA.
00:09:45.592 - 00:10:37.454, Speaker A: And why would you want something like that? Well, if you want to use Createaccount, Createaccount is sort of a simplification for like using the system program to create a new account. You know, assign the data, transfer the lan ports, assign it to an owner. You need to have a system program to be the payer for that. And this allows you to have a program derived address be the payer for all of your new accounts. So for example, in SBL Gov, the DAO program, you can now use a DAO governance to pay for all of your accounts. So again, if I want to use it to generate a new serum account, 60 don't want to have to make this is what we did previously you'd have to have a separate payer, someone off chain. But now your DAO can pay for everything that's going in there.
00:10:37.454 - 00:11:04.934, Speaker A: So that's that. This one is more kind of galaxy brain. Again, just kind of a weird thing that I came across that I think more people, you know, would like to know about. Maybe this is more like a self authority PDA. If you notice, you're initializing a mint account. So that's an SVL token mint, which you use to mint new tokens. The authority is the mint account itself, which is pretty wacky.
00:11:04.934 - 00:11:50.034, Speaker A: It means that the PDA, the program signs for every time it wants to mint new accounts. Now, why would you want to do this? Maybe you want to save accounts. So instead of having to pass in a mint and a mint authority, which is the signer for creating the tokens, now you only have to pass in one token account. And maybe that sort of efficiency is something that you're really looking for, but good to know about. Again, just more random stuff. When you're trying to return seeds to sign a cross program invocation, you usually want to store them in something easy, right? You want to store them in a function or a macro. And this macro is sort of the easiest way that I've seen to store seeds for doing cross program invocation.
00:11:50.034 - 00:12:31.704, Speaker A: I got it from Christiankam's blockworks or mango voter stake registry, and it's the nicest one because there's a lot of awkwardness if you're trying to make a function that will return the seeds because of how references and slice references and u eight s and all this stuff work in rust. So this is what it actually looks like when you call it. So you've got your CTX accounts transfer, and then with signer, and then you invoke your macro with the market account. Cool. Oh yeah. Seeds collision. You know, I thought maybe everyone knows about this already, but all of the bytes get smashed together.
00:12:31.704 - 00:13:04.274, Speaker A: So if you've got a bunch of seeds, Solana native runtime doesn't care that you separated them when you were inputting them. All the bytes get treated as equivalent. Now, as far as I'm aware, no one has been hacked using this yet, but it's just something to be aware of if you hadn't heard of it before, and I don't think any. No one checks it, basically. So again, more and more just random tidbits, duplicate accounts. So anchor. This is one of the kind of footguns, I guess, left in anchor.
00:13:04.274 - 00:13:36.098, Speaker A: It doesn't check that you're passing in the same public key in multiple locations. So if you're repeating the account, it doesn't check for that. And so the story behind that, that was kind of funny. Recently, somebody made an airdrop program, so they wanted to just give out, I don't know, 0.1 sol to a bunch of people, and they would get the wallet so that someone would sign up for the phantom wallet. They wouldn't have any kind of Solana at the time, and they would call this program. And the program looked relatively well written.
00:13:36.098 - 00:14:19.424, Speaker A: But in the client, the guy was passing in the user's wallet, which signed as the public key for a program account that was to be initialized. So this then turned that account into a program owned account, and it effectively bricked the wallet. So you can't use your wallet anymore because the account is owned by another program. Now, I don't know. There's some details about whether that should be possible because there are checks when you're using create account that there are no lan ports in the account. I don't know how he did this, but that's just one kind of weird example. And then account types, there's lots of account types in anchor, and you should really know them all.
00:14:19.424 - 00:15:18.274, Speaker A: Some of the ones that I don't think that people are necessarily as aware of, they're, well, signer. I think a lot of people know about signer, but system account. So if you've got a system account, an account that you know that will be owned by the system program, for example, if it's going to be a payer or a signer, but not actually signing, then you would use system account. So just reminding of that, and then obviously box, you'll know about box because you'll run into it when you try to Google, why do I have a stack heap error? Why am I running out of stack memory? So there's not many documentation for box, but there's a lot on the discord from people running out of memory that's just highlighting that one. Cool. And so, similar to the accounts is the constraints compared to the accounts, I would say the constraints are relatively well documented. So I would really recommend you just go through the docs, the rust docs, and just read about all the constraints.
00:15:18.274 - 00:16:04.914, Speaker A: I just picked my favorite bits that I don't think everyone knows about. Anchor doesn't check whether you have the mutable constraint. So what this means is that if you forget to write mutable above your account, and you edit the data in that account as mutable at the end of the instruction, it will just reset that data, so it will go back to zero, and you'll be like, I keep updating the data in my account and then I pull it into the client and it's still zeroed out. What the hell is going on? Well, it's probably you forgot to put mute in. Also, some people maybe don't know about the constraint that you can use address. So constraint account key equals sumacount authority is kind of a painful way to write it. So instead you can just write address Sumaccount authority.
00:16:04.914 - 00:16:40.444, Speaker A: And then this is kind of another funny one. You might have seen the token constraints. So there's like token dash, dash, mint, or token authority. And you can use those interchangeably. So you don't just have to use them with initialization, you can actually use them to check does this token have the correct mint, does it have the correct authority? So you can use them individually, you can use them with or without mint, and you can actually use them with public keys or with the accounts themselves. And any combination of those things should work. But if it doesn't come tell us and we'll see what we can do about fixing that.
00:16:40.444 - 00:17:24.572, Speaker A: Let's try next one. Again, this is another thing that's becoming a little bit more widely known as more programs get but built using it. It's just a different layout for your programs that I think is a little bit cleaner. I think Jet was one of the first ones to do it, and then a bunch of other people as well. I made a short video as well, covering this. So essentially what it is is you've still got your lib rs, and that's where you've got all of your instruction handlers, but they call out to the individual instruction, what do you call them? Modules like new order and cancel order. And what's good about that is that you have one file, new order, which contains all the accounts that are going into that instruction.
00:17:24.572 - 00:17:53.282, Speaker A: It contains the function logic and it also contains all the access controls. So any sort of additional constraints beyond the account constraints that you want to apply. And that's really nice for auditors to not have to go looking for all of that stuff. So yeah, definitely recommend checking that out. And I think Armani also released a new XNFT program which uses this layout. And this is something that I personally just use a lot in a lot of recent projects. So it's called anchor clientgen.
00:17:53.282 - 00:18:34.784, Speaker A: What it does is it's a static client generator from an IDL, and what you get from that is just better errors really. I think the errors from the native anchor are a little bit less clean just because of how the typescript works. And when you have a static client gen, it looks nicer. I think there's a metaplex have also released something called Solida, which is also not particularly well known, that does something very similar, so it gives more real errors. And I personally used it in all my recent projects before I joined anchor, so I definitely recommend it, or at least looking into it. And then again some more random tidbits. Things I say on discord a lot.
00:18:34.784 - 00:19:15.184, Speaker A: People ask good questions. People come to the discord and they say, look, I've got this, this problem, and here are the contexts. I'm like, that's such a good question for the stack exchange, because on discord we've been answering questions for like, I don't know, what is it, a year and a half now? And all of the old serum stuff is deleted from the serum discord, and all of the anchor discord stuff is probably lost or changed. So yeah, please go to the Solana Stack Exchange, ask your question there. It seems like it's pretty active and people are answering a lot. I go there, and if I see any unanswered anchor questions, I try to go through it like once every couple of days. Another thing people complain about a little bit is that there's no docs.
00:19:15.184 - 00:20:01.204, Speaker A: So if you want to know how to use some of the syntax, check out anchor tests, particularly the MISC directory, because you wouldn't really look there because it's called Misc, but it actually has almost all of the syntax that you would need to know in terms of how to use certain constraints or account types, stuff like that. And then, similar to like what I was griping about before with like the optional accounts, there's a thing called a Nidif needed. It's a constraint, and it's behind a feature flag so that not too many people will use it. You know, it initializes account if it's not already initialized. So like a token account might not be initialized. That's not too dangerous. But again, I feel like a lot of the logic that is being used by init, if needed, should just be done on the client.
00:20:01.204 - 00:20:29.884, Speaker A: Like in your client, just load up a token account. Is the token account there? If it's not, then just include a create instruction. It's just not that difficult, necessarily. So that's just my personal opinion. Okay, there's so much time left. So now if I've generated any goodwill at all, I'm about to destroy it by going off the rails, because this stuff is kind of new and a bit rough. So I'm going to Adlib a little bit.
00:20:29.884 - 00:21:32.412, Speaker A: So there's a lot of hype about move, and I know that there was like, when this hype was happening, maybe it was a couple of months ago, there were some talks about different ways that move could be put on Solana. I think I saw three different ways that they talked about doing it, like transpilers, compilers, but none of them seemed like it was really like a meaningful way. Like maybe you'd get the move syntax, but you wouldn't really get the features that make move kind of good, like these compile time checks. So instead, you know, the question is, why can't we just learn the lessons from move, like whatever they did or whatever they thought was good and apply them to anchor? Because that's just how code works. You can just change the code and make it better. So I didn't really put in these slides, but there's a really good blog post by Robert Chen from Autosec called Move an auditor's introduction. And in that he talks about one of the main things that people talk about or praise in move, which is the type checker.
00:21:32.412 - 00:22:16.852, Speaker A: And the type checker system in move is good in a way because it tells you a compile time if you've used the wrong type. And the types are very specific. So for example, if you're using say like a sync serum token or a mango token, and you didn't pass, I didn't like specifically, they're their own types. The mango token is its own type, and you can't accidentally pass it in somewhere else, or else the compiler will complain to you. But what Robert Chen argues in that blog post is that that is kind of like an anti pattern you're checking. The types are correct, but that's not really what you want to check. In fact, the type checker, it only works because in a lot of cases, there's only one instance per type.
00:22:16.852 - 00:22:59.124, Speaker A: So you can't have multiple instances of, say, the serum token theoretical move type. Or when they're initializing the type, they check that no one already exists. And this is very similar to what we see in Solana, where, for example, Cashio was hacked for $50 million. And what the hacker did was they created an account of the right type. It was like, I don't know, a storage account or something, but it was malicious. It wasn't the right one that the program was expecting. So that's what you want to avoid, you want to associate the actual instance with other instances or other resources.
00:22:59.124 - 00:23:42.568, Speaker A: So how are we going to do that? Well, we're going to have accounts that live on other accounts. This is kind of the way to say it. And this will sort of automate all of the has one checks and the PDA checks that you might have accidentally missed. Because if you want to access any of the accounts that you expect to exist within position, you have to access them using like, I'll show you the syntax later. It's like position authority or position market to actually look at the details of those accounts. And now I'm just going to check that I haven't omitted anything important. Yeah, it's a source of truth approach.
00:23:42.568 - 00:24:34.078, Speaker A: So when I was like, this is one of the reasons I talked to Robert Chen about this was like when I'm writing my PDA's, I use the approach of having a source of truth. I think he calls it root of trust, where there's like a single account that gets passed in or one of many that acts as the thing that you rely on for all of the other seeds. So you say that this is the one that says what is the base seed for? Like the program type or the token type, and you use that in all of the other accounts to check. And this is just a more efficient way to do that by having the accounts live on other accounts. So what does the, let's look at the account struct now. So you can see the account struct now has some of the syntax that we would have used previously for the derive accounts macro structure, whatever it was. So you've got your signer, your account, and they live on the data account.
00:24:34.078 - 00:25:07.234, Speaker A: Now in reality they only live on there as a public key, but you access them as if they were directly linked, like for example on move. I think they do really live more inside each other, so to speak. But Solana works differently. And then this is the syntax you use to access it. You've got your context accounts, position market, TVL. And now it's really difficult to pass in the wrong market account or pass in the wrong authority. And then, yeah, we're also going to switch to using zero copy.
00:25:07.234 - 00:25:43.508, Speaker A: So some people give out about how anchor's default is Borscht serialization deserialization, because that's a little bit slow. It has a lot of compute units. Also the current zero copy is actually unsafe. We just unsafely say we trust you. Whatever is in your struct and you put zero copy over it, we're just going to trust that it's safe, but we're going to get rid of that. So there are some new restrictions that will come with using actual safe zero copy, but hopefully that will be balanced out by the safety and whatnot. Yeah, that's like.
00:25:43.508 - 00:25:52.044, Speaker A: That's it, basically. So, I don't know. I've still got, like, three minutes left if anyone wants to ask any questions. Although I might not answer them. Cool. Thank you.
