00:00:08.039 - 00:00:31.988, Speaker A: Hey everyone, my name is Armani. Today I am going to do a little more of a technical talk. I'm going to talk about building smart contracts on Solana with Anchor. So yeah, let's get started. So what is anchor? So anchor is a programming framework for building smart contracts on Solana. So in the web two world, we have things like Ruby on Rails and Ethereum. We have solidity web3 js and Hardhat.
00:00:31.988 - 00:01:14.436, Speaker A: And on Solana, well, we've got anchor. And the thing that kind of all these tools have in common is that they allow you to ten x developer productivity by abstracting away the complexity of the underlying platform. And we see this on Solana by taking a look at some of the projects that are using anchor. So if you take a look at the seven of the top ten protocols sorted by TVL on Solana, a lot of them are using anchor. Megyo Ido program like pretty famous events on Solana that at one point had like 500 million TVL in like a single day. It was written in anchor. Metaplex Candy machine, which is responsible for minting most of the NFTs on Solana was written in anchor.
00:01:14.436 - 00:01:52.502, Speaker A: And to me, it's no surprise that the has two hackathon grant prize winners, Zeta and Katana were able to win the hackathon and ship quickly by writing their protocols in anchor. And so, yeah, so today we have over 3000 repositories depending on anchor packages. We've got some stars on GitHub and over 100 contributors from different teams and places all around the world. So, yeah, that's a little bit about anchor, where we are today. Let's talk about the tool chain. So anchor provides a bunch of different things. So we have rust smart contracts.
00:01:52.502 - 00:03:01.428, Speaker A: We have this interface definition language which really defines the protocol that the smart contracts implement so that you can have these client generators that can communicate with smart contracts. This is very analogous to something like protobuf that you might be familiar with. And then we have a CLI which kind of ties all these tools together to have a cohesive developer experience. And so when you bring all these things together, what you get is a very productive workflow where you can write your rust smart contract, compile it, and parse a higher level representation which we call the interface description. And from the interface description, we can generate clients, and with the clients we can invoke our smart contracts. So, yeah, so, you know, not only can you write your smart contracts in rust and write your clients in rust, but in fact you can have clients generated in any programming language and so this is a big productivity boost if you've ever written smart contracts in vanilla rust on Solana. So that's the basic idea.
00:03:01.428 - 00:03:26.964, Speaker A: So, you know, for the rest, rest of the talk, what we're going to do is we're going to go through each of these parts. We're going to go through a smart contract, we'll go through an IDL, and we will create a typescript test. So we're going to show some code. Hopefully it displays on this screen. Well, it's kind of small, but, yeah, we'll see how it goes. So, yeah, let's get started with the smart contract. So before looking at code, we can paint a picture of what this program is going to look like.
00:03:26.964 - 00:03:55.500, Speaker A: It's going to be like the simple, simplest program possible. It's going to be a counter. We're going to have some data. It's going to start at zero, and associated with this data is going to be a wallet or an authority, which is going to have the permission to increment the data. So we'll go from zero to one, and then what we want is, well, if any other wallet comes along and tries to touch the data, we want to reject the transaction and abort. So that's going to be the program, and we can go ahead and write it. So this is what it looks like.
00:03:55.500 - 00:04:22.739, Speaker A: This is the entire smart contract. If you've never seen rust code before or a smart contract in Solana, it might be a little confusing, but we'll go through all the sections, at least at a high level to start. So the first line here we have this prelude, import. This is just rust code for importing types. Not much there. Second line here we have this declare id. This is a quite important part of the framework, and it is a point we'll get to later.
00:04:22.739 - 00:04:45.191, Speaker A: But for now, you can just think of this as just hard coding a static constant into the program where we declare the program address. But this is super important for security purposes, and we'll come back to this later. All right, so we have the id. The next section is going to be this program module. This is really kind of the core of the program. This is where all the business logic lies. So here you'll see we have two functions.
00:04:45.191 - 00:05:16.948, Speaker A: We have initialize and increments. These are the two entry points into the program. So it might be like your rest API or your handlers with a GRPC server or something. So you have two things here. We have the ability to initialize the counter, and we have the ability to increment the counter. And so in the next section we have what we call the accounts context. So what's unique about Solana, and a point we'll get to later as well, is that you actually provide all of the storage that you're going to read and write in your program upfront from the client.
00:05:16.948 - 00:05:49.076, Speaker A: So the accounts context is really saying these are all the key values in the key value store that we're going to touch and manipulate. So you'll notice here we have two structs. Each of them initialize the increment, and each of them corresponds to the handlers. And so you'll have a struct for each function here, giving you all the data that you have access to in your project program. So that's the accounts context. And then the last section here is going to be the account declaration. This would be analogous to like a model and ruby on rails, but this is really going to be the storage layout in your program.
00:05:49.076 - 00:06:18.408, Speaker A: So we just have struct types here. But yeah, those are the sections. We have the id, we have the program module, we have the accounts context, and then we have the storage declaration or the accounts. So yeah, we'll go ahead and go into each of these, these in more detail. All right, so this is our counter, this is our storage for the program. First thing you'll notice is, well, we have this account attribute or this macro. So this is just some rust that allows us to generate a bunch of code.
00:06:18.408 - 00:06:52.964, Speaker A: But basically all it's doing here, at a high level at least, is it's declaring that the struct that is this counter struct that we are decorating is going to be considered an account in our program, just a normal rust struct. And there's going to be two fields. We're going to have the authority, which is just going to be the pub key or the wallet that is allowed to have access to update the data. And then we'll also have the count here. So this is just U 64, this is just going to be the zero, the one, the two, et cetera, the data that we're going to increment. And that's it. That's going to be the storage layout for our program, and that is the storage declaration.
00:06:52.964 - 00:07:44.214, Speaker A: So moving on up, we go into the accounts context. We can drill in, and before talking about these structs, it is worth maybe going into a little more detail, the unique programming model on Solana. So, like I said previously on Solana, what is very unique is that you actually provide all of the data up front you basically are spec. You specify these accounts, but abstractly what it is, it's like you're specifying all the keys in the key value store that you're touching. This is a very cumbersome from the developer experience perspective, because on means on the client, it specify basically all the places in memory or all the keys that you're going to touch in your program. But what's great about this from a performance perspective is that this is actually what allows Solana to schedule parallel transactions dynamically. Because if you have conflicts in the read write sets and, you know, you serialize the data, and if you don't, then you can execute them in parallel.
00:07:44.214 - 00:08:41.176, Speaker A: And so this is like really one of the unique and central challenges in the Solana programming model. But what's also challenging about this is, well, if you think about it, it basically means that clients, untrusted clients, are injecting data into your program. So if you're familiar with things like SQL injection or any type of form input, traditional web development, this is a very scary thing. And so one of the core features of the anchor framework is to provide you tools via this derive macro that we'll go into to be able to declaratively specify constraints and basically create proofs of the data being passed into your program. So that when you see one of these structs created, what you know is like, you can basically guarantee some properties about the types. And so yeah, we can go ahead and go into these in more, more detail. So first thing that you'll notice is we have the derive macro.
00:08:41.176 - 00:09:35.850, Speaker A: This is what allows us to specify one of these structs where a bunch of code will be generated upon construction of these types. So we have these two structs again, one for the initialize handler and one for the increment handler. And if we go into initialize, we can take a look at this first line. So this here is an account macro, which first thing you'll see is we have this account attribute. Inside of these attributes is what allows us to define these directives or these constraints that will generate a bunch of code on construction and then allow you to say certain things about these structs. So here we have the init keyword that stands for initialize. It's kind of analogous to Malloc and C, but basically what's going to happen is when, when you use init, you're going to create a bunch of code to create the account, allocate the data and initialize it.
00:09:35.850 - 00:10:13.744, Speaker A: So you're going to initialize the data, you're going to specify a payer which is going to pay for the rent exemption. Another unique thing on Solana I won't go into, but basically you pay for some rent exemption sold here. It's going to be the authority account. So that's just going to be another account inside of the struct, and then you specify the amount of space you're going to allocate. So here we have 48 bytes which will map to the types that are in the storage declaration. So yeah, that is the account, that is the account attribute that is decorating this counter here. So you're going to create this counter type and we introduce this new type, which is the account.
00:10:13.744 - 00:11:02.258, Speaker A: So the account is an anchor provided type that basically provides a safe deserialized wrapper for the inner type. So here you'll notice inside of this is going to be this counter type. So the counter corresponds to the struct that we previously declared, which is just our normal rust type. But what's great about this is that not only do you get a deserialized rust type, but you also get a guarantee on the inner type. So you can't inject into this any other type other than the counter type that was previously declared in the program. So you can imagine if you have the SVL token program, you have different types like token accounts and mint accounts, and you have to do all these checks to guarantee that you either have one or the other with anchor. You don't have to do any of that because the macros do it all for you.
00:11:02.258 - 00:11:38.882, Speaker A: So yeah, that is the account here we have the authority and we introduce this new type, which is just a signer. This is just a nice type that checks that the account indeed did sign the transaction, and if it didn't, it'll abort. And then lastly we have the system program, which is just kind of a unique, not unique, but it's a requirement of the runtime when you are going to initialize and allocate data. You need the system program to be available because you're doing a cross program invocation. Not super important, but what's nice here is we have a new type. We have the program type generic over the inner type, which is system. So that's basically specified system program.
00:11:38.882 - 00:12:19.114, Speaker A: And again, if we pass in any other type here, then the program will abort. So that's a lot of stuff here. But basically this all comes together to give you basically this guarantee or this proof that if you ever have an initialized struct inside of your rust, program, then, you know, a bunch of things are surely true. You know, you have a brand new allocated account that is a counter. You know, the authority signed for the transaction transaction and paid for the rent exemption sole. And you know that the system program did indeed be, was indeed passed into the program. And if any of those constraints are not true, then the transaction will abort and you'll never actually hit the handler of your program.
00:12:19.114 - 00:13:05.284, Speaker A: And that's really what these constraints or these derived structs are all about. So yeah, that's initialize, you know, second, we can go into the increment struct and we introduce this new type or this new keyword here, mute. Mute sounds permutable. Again, when you're touching data on Solani you need to specify what is going to be writable because that's required for the transaction scheduling. But basically what this means is not only will it take a write lock on this account, but all of the changes that you make to this account will be persisted at the end of the transaction. So if you update any of the fields inside of the counter, ie, increment the count or change the authority, then that will automatically be persisted by the runtime. So that's the mute keyword.
00:13:05.284 - 00:14:11.284, Speaker A: Secondly, we have, this has one constraint, this is kind of just some syntactic sugar that basically says if the authority on the counter type does not equal to the authority passed into the program, then it will abort. So this is just some sugar, it allows you to specify some application specific constraints, which is nice for matching data across different accounts. And so yeah, that's the struct for the increments. And so again, this allows us to basically prove that if we ever have one of these structs, then we indeed have a previously initialized counter and the authority did sign the transaction, and that authority does indeed match the authority on the counter. So yeah, those are the structs for the accounts context and that is it for this section. So the next section that we're going to go up into is going to be the program module and we will dive into here. So first thing that you'll notice is this program attribute that specifies that this can be the program module and that all of the functions inside can be used as method handlers.
00:14:11.284 - 00:14:57.384, Speaker A: Again, we have these two handlers initialize and increments that are the two entry points into your program. We start with initialize and you notice the first parameter here is going to be the accounts context. So just kind of by convention we require these contacts to be passed in and basically this is like the key value store, the cache that's going to be passed into these handlers, but this is how you access all of the data. So this is going to be our initialize struct that we previously discussed. And what's great about this is that you know that if you ever enter into the function body here, then you know all the properties of that struct are indeed true. You have a brand new allocated account, you have the system program, and you have the authority that signed and paid for the rent exemption. So next parameter here is the start.
00:14:57.384 - 00:15:25.360, Speaker A: This is just some data passed in from the client. This is just, you know, be like a normal function call. You just pass in some instances instruction data that's going to represent the start of the counter. It can be zero in our case. Then we can enter the program body or the function body. So the first line here is just going to, we're going to take immutable reference to the counter account and then we're going to mutate it. We're going to set the authority field, we are going to set the counter, then we return success.
00:15:25.360 - 00:15:51.144, Speaker A: And that's it for the initialize function. Next handler. Here is the increment. We have our contact. So again, you have this proof that you indeed, if we enter the function body then we know that we have a previously allocated counter and we know the authority did indeed sign the transaction. So we're safe to execute some code. So we take mutable reference, we update the counts and we return success.
00:15:51.144 - 00:16:26.800, Speaker A: That's it for increments, and that's it for the entire program. Really? Well, you'll notice here is that there's no deserialization in this or serialization here. There was no account validation, there's no constraints. You're just taking some references to some rust structs and you are just updating those structs, which is what you want out of your programming model. It makes the business logic a lot more clear in my opinion, makes it a lot easier to reason about the security of your programs. This is definitely one of the core features of anchor programs. So yeah, that's the business logic.
00:16:26.800 - 00:17:18.494, Speaker A: And then lastly we'll tie up the sluice end with this declare id. So if we take a look at this macro and we actually expand the code, it's pretty simple. All it does is it creates this id variable, this static id variable inside of the program. But why this is so important is when we have this id, what we can do with all these macros is we can bind the program address to all of the accounts. And why that's so important is because it eliminates an entire class of vulnerabilities on Solana, namely ownership checks. Because what it means is that, well, if you ever have one of these structs like initialize or increment, and if you use these account wrappers, then the ownership check will be done for you automatically. So it's impossible to inject in any data from any other programs into these instruction handlers.
00:17:18.494 - 00:18:01.070, Speaker A: And yeah, this is why we use the declare id. And this is why it kind of takes this opinionated perspective that you should hard code the addresses inside of your program. So yeah, that's it for the rest program. And so what we do is we'll compile this and they'll give you a binary. But what we'll also do is, is we'll run a CLI to parse all this rust code into the interface description. So the interface description, you can think of it kind of like a protobuf file, but it's really just some jSon here that maps one to one to your actual rust program. So we'll parse this in text tree and we'll extract the key information into this JSON file.
00:18:01.070 - 00:18:43.794, Speaker A: If you take a look at it, it's not super important, but you know, it's just kind of worth pointing out the sections. So we have the counter program, we have our instructions initialized and increments. We have the arguments, we have the accounts context, and we have the accounts storage declaration. Again, you don't really have to ever look at this file directly, but it's important to point out that it exists, and that this is really the connective tissue that is used to connect the rust programs to your typescript clients, your swift clients, your c hash clients, whatever. And they're all generated from this file. So that's the ideal next section. We go into the typescript test and see how we can integrate this all together with an end to end example.
00:18:43.794 - 00:19:06.822, Speaker A: So here's the full typescript test. Just some mocha test in typescript. First section, just some import types. Second line we just have this describe syntax. This is just mocha, nothing anchor specific here. And then the first interesting line is going to be this program variable. Basically what we have is like this anchor workspace countersyntax.
00:19:06.822 - 00:19:54.798, Speaker A: This is just a nice convenience that allows us to get a pointer or a reference to the counter clients. So this program is going to be the typescript representation of the rest program, and the APIs are going to be kind of exactly what you would expect in that they're just going to map one to one to the rust code. So you know, the next section or the next line here we're just going to generate a key pair for the counter. This is going to be the data that holds the account. And we have these two tests. So here, first we're going to create a counter and we'll have this program RPC initialize function call. And what this is going to do is going to sign and send the transaction to the blockchain and invoke the initialize method.
00:19:54.798 - 00:20:16.744, Speaker A: So let's pass in some parameters into it. So here we have the starting counter. So it's going to start at zero. And then secondly we have the accounts context. So like I said previously, you'll pass in all the accounts. So we'll pass in the counter, pass in the authority, you'll pass in the system program, and we do all this from the client so that the dynamic parallel scheduling can happen. And that's it for the accounts.
00:20:16.744 - 00:20:48.444, Speaker A: And then kind of a loose end. Here is a signers section, not super important, it's kind of a leaky abstraction. But TLDR is that the Solana runtime requires you to sign all transactions for all accounts that you create. So here we're creating the counter account, and so it has to sign the transaction. So that's it for the first test. That will create the counter by invoking the initialize instruction. And then lastly we have the incrementing portion.
00:20:48.444 - 00:21:40.184, Speaker A: So again we'll have this program RPC increment, just a function call, there's no arguments, we'll pass in the accounts, we have the counter, we have the authority, and that's how you increment the counter. And then lastly, normally what you'd want to do is after invoking some transactions, will actually want to fetch the accounts and read the data. So here we have a very similar thing, but instead of having the RPC namespace, we have program account. So we have the account namespace where you can access all of the types or all the rust types in your program, you can fetch them pass in the account that you want to fetch, and that will give you this account type, which is just the typescript representation of the account maps 101 to the restaurant. You'll have the count field. So here we assert it's equal to one and you have the authority field. And here we assert that it's equal to the wallet.
00:21:40.184 - 00:22:05.930, Speaker A: So yeah, that's it for the typescript test. That kind of exercises all of the functionality of the program. And normally what you do is you'd run the test. I'm not going to do it because it's a presentation. And yeah, so you run the test and kind of you see your mocha output, and that's it for the typescript test, and that's it for the entire workflow. So that's kind of a little bit about anchor programs. If this interests you, here are some good resources.
00:22:05.930 - 00:22:25.294, Speaker A: I would definitely check out the GitHub. We've got some tutorials and some documentation, some API docs. And last but not least, the discord. Discord is probably one of the best places to get general developer help on Solana. We got some of the most active people there just hanging out, answering questions all day. So yeah, that's it for my talk, and thank you for listening.
