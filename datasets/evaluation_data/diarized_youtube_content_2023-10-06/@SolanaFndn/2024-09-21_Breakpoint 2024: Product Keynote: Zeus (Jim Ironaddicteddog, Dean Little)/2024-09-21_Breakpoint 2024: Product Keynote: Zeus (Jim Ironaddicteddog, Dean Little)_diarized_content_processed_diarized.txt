00:00:05.280 - 00:00:06.092, Speaker A: Thank you everyone.
00:00:07.945 - 00:00:37.213, Speaker B: So I'm Jim, co founder and CTO of Zeus Network. A lot of people are asking what we're doing at Zeus Network. To simply put WGBBS we gonna bring Bitcoin to Solana. So we're building a Solana 11.5 which is powered by Zeus node and ZPL, aka Zeus program library to bring Bitcoin to Solana. So there are three exciting things I would like to share with you guys. So first thing is we have launched Apollo which allows users to deposit BTC to earn yield on Solana.
00:00:37.213 - 00:01:21.075, Speaker B: Ever since our launch one month ago, we've seen over 40,000 users already trying to use Solana and the number is still going up. So we're so proud to announce our second product which is Zulscan, a bitcoin Solana International explorer which allows you to see what's happening under the hood in our Zeus Node and zpl. And it's completely live now, just Google zeuscan IO. So first we will proudly announce Zeus Layer which is our next killing product. It is a bitcoin and solar infrastructure. So there are actually multiple steps you can see on the diagram. But I would like to point out one most critical step which is we need to pack a lot of BTC from Bitcoin side to Solana side via a program called Simplified Payment Verification Program.
00:01:21.075 - 00:01:43.795, Speaker B: So when this is people asking questions. So we are planning to launch Q4 this year. So obviously there are a lot of things to be achieved, millions billion things to be resolved before. So one of the very first challenges we need to resolve is how do we build a robust SV program on Solana. So I want to have my chief scientist to talk more about that.
00:01:44.545 - 00:02:25.799, Speaker A: In section 8 of the Bitcoin white paper, Satoshi detailed Simplified Payment Verification. This is a means for light clients to be able to have efficient succinct proof of inclusion of any transaction in the bitcoin blockchain by simply following the longest chain of proof of work. All that's actually required to implement this on Solana is a library that's capable of efficiently generating and validating these proofs. And it works even better when you shave 20 cus off of the standard implementation of Shaja 50. Then you come to the problem of data. How do we get transactions and proofs on chain really fast? Because with ordinal inscriptions and other kinds of exotic taproot scripts, some of these transactions are quite large. So we created ChatBuffer.
00:02:25.799 - 00:03:24.485, Speaker A: Now ChatBuffer is actually an SBPF assembly optimized parallel data buffer that enables you to put huge amounts of data on chain really fast and this is also utilized by other teams with big data problems like squads. Finally we have the actual implementation of the Bitcoin protocol itself. Logos is a library that will be Open Sourcing in Q1 of 2025 written by yours truly that implements the entire Bitcoin protocol in Rust with three compiled targets, native Rust, sbpf as well as wasm enabling you to utilize Solana to make truly full stack bitcoin apps. This is powered by our currently Open source Solana SCCP 2x6k1 library. Why? Because we could have just left it at Merkle trees and ECDSA verification. These are natively supported by Solana, but we wanted to tackle the two new cryptographic primitives introduced by Taproot, that is tweaked public keys and Schnorr signatures. These require EC multiplication and EC addition 5 million and 400,000 CUs each.
00:03:24.485 - 00:04:38.575, Speaker A: A naive implementation of this might be that we hack the ecdsday signing algorithm itself. We start by negating the mod inf k by feeding in a nonce of one and then we negate the hash scalar by feeding in a hash of 0 to reduce the algorithm of generating a signature down to rkmodn, a big number operation, enabling us to extract a public key that we can then add to another public key on chain through EC Edition for 400kcus and that unlocks tweaked addresses. However, what if I told you we can do way better? See when you actually look at why this works, if you look at the math under the hood, the right hand side of this is a negative z mol g, negative z being our hash scalar. If we negate the hash scalar, we're able to use this as a mol g and then turn it from a negative into a positive, creating an easy add to the point r on the left hand side, reducing the algorithm down to p k. The reason for this is because the way it was implemented on Solana, it does not hash the output of the public key, giving it superior cryptographic properties. Another thing we can do is we can actually decompress and invert public keys using this function. This enables developers to decide if they would like to trade 25kcus for 32 bytes of precious instruction data.
00:04:38.575 - 00:05:07.997, Speaker A: But the most important thing is actually if we negate the scalar on the right hand side by feeding in a Z of 0, a Z of 0, what we actually end up doing is creating an arbitrary easy multiplication of s mal r on the left hand side. This actually unlocks everything. And I. When I mean everything, I mean everything. Schnorr signatures, ring signatures. Peterson Commitments, bulletproofs. You could theoretically build the entire Monero and zcash privacy stack on Solana without introducing any new cryptography today.
00:05:07.997 - 00:05:10.501, Speaker A: Thank you all for listening. Only possible on Solana.
00:05:10.573 - 00:05:11.445, Speaker B: Only possible Solana.
