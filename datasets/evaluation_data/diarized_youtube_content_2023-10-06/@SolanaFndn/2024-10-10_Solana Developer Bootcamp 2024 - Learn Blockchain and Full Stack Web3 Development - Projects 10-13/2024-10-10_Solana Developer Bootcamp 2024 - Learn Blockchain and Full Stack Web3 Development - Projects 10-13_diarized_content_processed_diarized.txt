00:00:05.400 - 00:01:05.445, Speaker A: Now that you have an understanding of blockchain technology and decentralized applications, let's dive into decentralized finance, also known as DeFi. DeFi refers to financial applications built on decentralized networks. The main goal of DEFI is to transform traditional financial products into trustless and transparent protocols. Instead of relying on intermediaries like banks or brokers, DEFI apps allow you to directly interact with financial services through smart contracts, which are automated agreements encoded on the blockchain that autonomously execute and manage the terms of a contract when specified conditions are met. This automation not only minimizes human error, but also eliminates the need for trust between parties. This also allows users to gain control over their assets with the ability to manage and transact their funds securely and transparently anywhere in the world at any time. The direct interaction enabled by smart contracts and DEFI extends to a variety of services such as borrowing, lending and trading.
00:01:05.445 - 00:01:56.253, Speaker A: Unlike traditional financial systems, there are no office hours for DeFi platforms. They operate 24, 7, providing constant access no matter the user's location or time zone. This around the clock availability ensures that financial operations can proceed without delay, catering to the needs of an increasingly interconnected and globalized world. Another benefit of DEFI is the reduction of operational cost associated with financial transactions. By cutting out intermediaries, transaction fees are typically lower than those in the conventional banking sector. This democratizes access to financial services, particularly benefiting those in underbanked regions or individuals facing financial exclusion. It also creates a more competitive financial environment where innovation thrives, leading to better services and products for users worldwide.
00:01:56.253 - 00:02:31.777, Speaker A: Some key examples of DEFI include decentralized exchanges, stablecoins and lending protocols. Decentralized exchanges allow trustless swapping of cryptocurrency tokens. There are two main types of decentralized an automated market maker and an order book. Order books require matching buyers and sellers, while an AMM uses pooled liquidity that trades algorithmically against your order without needing immediate counterparty matches. Stablecoins bring price stability to crypto. They peg their value to assets like the US Dollar. This avoids volatility, which improves DEFI usability.
00:02:31.777 - 00:03:14.555, Speaker A: And decentralized lending platforms allow users to lend and borrow cryptocurrencies from pools of aggregated liquidity. The interest rates are algorithmically determined based on supply and demand. Beyond these examples, there are several other types of DEFI applications that exist today. And with the code driven open source nature of DeFi, the innovation will continue. Now that we've learned about DeFi, let's dive a bit deeper and build out A lending protocol in the traditional financial system, lending involves banks or financial institutions providing loans to individuals or businesses. In return, the lender receives interest payments over time. This system plays a crucial role in the economy by offering liquidity and enabling capital growth.
00:03:14.555 - 00:03:48.635, Speaker A: However, it's heavily regulated and often requires intermediaries, which can introduce inefficiencies and exclusivity. Now, let's contrast that with decentralized lending protocols. These protocols function on a blockchain network and are designed to be permissionless, meaning they're open to anyone, anywhere, without the need for a centralized authority or intermediary. Here's how it works. Anyone with digital assets can lend them out to earn interest. Conversely, anyone needing a specific asset can borrow it by providing other assets as collateral. This system democratizes access to capital and expands financial inclusion.
00:03:48.635 - 00:04:36.895, Speaker A: The backbone of decentralized lending is smart contracts. These are self executing contracts with the terms of the agreement written directly in the lines of code. They autonomously manage the custody of assets, calculate interest rates based on the supply and demand, and ensure that loans are adequately collateralized. Lenders contribute their assets to liquidity pools from which borrowers can take loans. This pooling mechanism spreads out risk and facilitates better liquidity management compared to traditional individual lending agreements. For lenders, the setup provides an opportunity to earn passive income on their assets without engaging in active trading or investment. For borrowers, it offers quick access to capital without the need for credit checks or the bureaucratic hurdles typically involved in traditional banking.
00:04:36.895 - 00:05:18.137, Speaker A: Lending is not just a feature, but a fundamental pillar of the DEFI ecosystem. It not only frees up the capital locked in cryptocurrencies, but also creates opportunities for leverage in other financial activities within DeFi, enhancing the overall utility of the crypto markets. In our tutorial, we'll build out a lending protocol on Solana from the ground up. You will learn how to create smart contracts that will allow lenders to supply tokens to lending pools and earn interest, while borrowers can secure loans by collateralizing their digital assets. Let's get started. Let's get started building out our lending protocol. This will be a very simplified lending protocol of just two assets.
00:05:18.137 - 00:05:57.555, Speaker A: We'll have SOL and usdc. A user will be able to deposit and withdraw, borrow and repay assets on the lending protocol. In a lending protocol to be able to borrow assets, we're going to make the accounts over collateralized. And to do this, we're going to have to calculate the health factor of the account, which allows an account susceptible to liquidation. If the account falls below the health factor, then it will be able to be liquidated. So overall, the main instructions that we're going to need here is depositing, withdraw, borrow, repay, and liquidate. And we're also going to need to set up the accounts that we'll need.
00:05:57.555 - 00:06:46.209, Speaker A: So the main account that we're going to need is a bank for each asset that we want on the lending protocol and user accounts. So let's get started. We'll first set up our anchor environment and then work from there. We'll navigate into our terminal and we're going to use anchor knit to set up the workspace that we're going to need for our anchor program. Okay. And then we'll just CD to our new workspace and open that in VS code. Okay.
00:06:46.209 - 00:07:45.885, Speaker A: So now our workspace has been created, we're going to navigate into programs, lending source, librs, and this is the basic layout for our anchor program that's been generated from anchor init. Let's first get rid of the instruction that was generated and the derive accounts and just have the basic layout for lending. Now, because this program is going to have a lot of different instructions with a lot of different accounts, we're going to separate things into their own folders and then pull them into the librs just for easy readability. So let's get started by first defining our state. And we're going to want to define what accounts need to hold state for this program in source. Let's create a new file and we'll do state rs. And now right off the bat, we should remember to create our mod files to be able to incorporate all of the separate files that we're making.
00:07:45.885 - 00:08:23.715, Speaker A: So first in lib RS we want to make sure we're going to use our state. So we'll just do mod state. Okay. And we'll go back to our state, and we want to use anchor. And then state is stored in the account. So we're going to use the account attribute to declare that this is a Solana account. And then because an account is going to take up space on chain, we're going to use a knit space to be able to calculate the space throughout our program.
00:08:23.715 - 00:09:22.445, Speaker A: Okay. And then let's see what's the first account that we want? Well, we're going to need accounts for the user, so let's create the user account. So pub struct user and let's figure out what we want to save as far as user information. So we want to know who the owner of this user account is, and we're going to be able to initialize multiple user accounts for any user that comes to this application. So we'll do pub owner and that'll be a public key. Now we're going to want to keep track of how much SOL has been deposited or borrowed, how much USDC has been deposited or borrowed, and then we're also going to want to keep track of the shares. And the shares are what we're going to use for interest calculations, which we'll get into as we need to calculate interest in the logic for the instructions.
00:09:22.445 - 00:11:03.875, Speaker A: So let's first start out with the deposited sol. Now one challenge if you're looking to amplify this program is how would you update this for multi assets more than just two for a lending protocol, since most lending protocols allow for more than just two assets. So what would be the best way to store this in the state and manage all of the assets? Because this is not going to be the most optimal by just explicitly stating each asset in the struct. So now we'll keep track of the sole shares and then we'll need the borrowed SOL and then the borrowed sole shares. We'll need the deposited usdc, the deposited USDC shares, the borrowed USDC and the borrowed USDC shares. Okay, now another thing that we're going to want to keep track of here is just the mint address of the USDC account. And the reason we want to do that is in the future when we're passing through Mint accounts for instructions, we want to be able to check if that Mint account is either USDC or sol.
00:11:03.875 - 00:11:46.855, Speaker A: So if we keep track of one, we can just make a very simple IF statement to check across the two. So we're going to store the USCC address which is also a public key. Okay, we'll just want to keep track of when the account was last updated. So we'll just do last updated and that'll be an i64 because it's a timestamp. Okay, now the other account that we want to keep track of is the banks. So there'll be a bank for each asset on the lending protocol. And we want to initialize the bank and then get keep a state for the bank.
00:11:46.855 - 00:12:41.913, Speaker A: So let's define that account account. We'll use derive init space, we'll define the struct. And this is going to be a bank. Now every bank should have an authority and this authority is who will have special permissions to change the config of the bank. Okay, and then we want a mint address saved because that will be the mint Address of the asset. Now we want to keep track of the total deposits in the bank and then the total deposit shares. Now, since each user account can be liquidated, we want to keep track of the liquidation threshold, the liquidation bonus, the close factor, and the max ltv.
00:12:41.913 - 00:13:55.395, Speaker A: Now these are all constants needed to be able to calculate if an account is healthy or not. And these constants are usually created based on the volatility of an asset. So they're going to be asset specific constants. So we're going to keep those in the bank of the asset. So we can do pub liquidation threshold, we'll do the liquidation bonus, we'll do the close factor and we'll do the max ltv. So just to recap what all of these mean, the MaxLTV is the Max percentage of collateral that can be borrowed for a specific asset. The liquidation close factor is the percentage of collateral that can be liquidated.
00:13:55.395 - 00:14:42.475, Speaker A: You have the liquidation bonus, which is the percentage of the liquidation that's going to be sent to the liquidator as a bonus for processing the liquidation. And you have the liquidation threshold, which is the loan to value at which a loan is defined as under collateralized and can be liquidated. Okay, and then we'll also keep track of when this is last updated. Okay, so those are our accounts. Now we can start out with our instructions. So we're going to make a new folder inside the source folder and name this instructions. Okay, and because we're making a new folder, we'll have to make a modr s file inside of it.
00:14:42.475 - 00:15:37.555, Speaker A: And then we want to update our librs to use instructions. Okay, and now we also need a mod file back one directory. So we'll do modaras. So so far we've created a state file and we've created the instructions folder. Okay, now we can start with our first instruction. So let's first focus on running the instructions for the admin of the entire lending protocol. So we'll make a new file inside instructions and this will be titled admin.
00:15:37.555 - 00:16:26.835, Speaker A: And this is just handling initializing new accounts needed. So we'll update our modrs and make sure we have pub use admin and pub mod admin. Okay, so in our admin RS we're going to use anchor. Now we're going to want to be able to initialize banks for each asset. So let's first define the struct needed for our context to create the instruction for initializing a bank. So let's write that out now. So we'll do derive accounts, define the struct.
00:16:26.835 - 00:17:42.375, Speaker A: Okay, so first we're going to pass through the signer. So that'll be an account that's mutable and we'll do pub signer and that will be the signer type. Okay, now we want to pass through the mint of the asset for the bank. So one thing to note here, we're saying for simplicity, SOL and usdc, however, typically for lending protocols like this to make everything adhere to one type of token, they're going to be using wrapped soul because rapt soul is going to be an SPL token. So instead of having to handle anything with lamp ports and the system account, we're going to make sure all of the mint accounts are going to be an interface account for these banks. So we'll define mint and this will be an interface account and then mints. And now one thing that we haven't done yet is adding the SBL token to our cargo tunnel.
00:17:42.375 - 00:18:25.699, Speaker A: So, so let's go to our terminal and we're going to do cargo add anchorspl. Okay, we'll just check the version here. So we'll go to cargo toml and we have 30.1. Okay, so going back to admin, we're going to want to import mint and the mint is going to come from the token interface. Now we're going to want to initialize our bank. So we'll set the account and we're going to use the init constraint to initialize. And then whenever we're doing that, we need to pass through a pair that will be the signer.
00:18:25.699 - 00:19:08.835, Speaker A: We need to define how much space it's going to take up on chain. So we'll use the 8 discriminator plus bank init space. I'm missing a comma up here. So let's add that and then we're going to make the bank a pda. So let's define the seeds. In the seeds for the bank, we're just going to use the mint key because every bank is going to have a unique mint key for the asset that correlates to the bank. So seeds, we're just going to take the mint key as ref and then we need the bump.
00:19:08.835 - 00:19:49.295, Speaker A: Then we'll define this account. Okay, now we want to import bank, so we're going to use crate for bank. Okay, and now this is having an error because we're initializing a new account and we need to pass the system program through which we'll do that at the end. So we have the bank and the bank is holding the information to the state of the account. But now we also need a token account to hold the tokens for the bank. So we're going to make one more account. And this is going to initialize a token account for the bank.
00:19:49.295 - 00:20:27.153, Speaker A: So we'll use the account constraint. We're going to initialize and we're going to set that. This is for tokens. We're going to take the mint of the mint account that we're passing through and then we want to set the authority to itself. So token authority. And that is going to be the bank token account, which is what we're going to name this account. And then we need a payer, which is the signer, and then we'll need the seeds for this account.
00:20:27.153 - 00:21:20.455, Speaker A: So we don't want to use an associated token account here. We want to just have a token account with a pda so we're able to know that this account is specific to the lending protocol bank. Okay, so we're going to name this treasury and then we're going to take the mint key as well. And then since we have the seeds, we need the bump. And then we'll name this the bank token account. And this is going to be an interface account since we're using the token interface. Okay, now lastly, we need to pass through two more accounts.
00:21:20.455 - 00:22:08.645, Speaker A: One is going to be the token program because we're creating new token accounts. And that will be an interface for token interface. And then lastly is the system program. Okay, so now our error with bink went away because we're passing the system program through. And now we just need to import both the token account and the token interface. And these should both come from anchor SBL token interface. There we go.
00:22:08.645 - 00:22:54.445, Speaker A: And now that's updated. So this is everything we'll need for the struct to initialize new banks. So let's write the instruction for that. We're going to process a net bank and that will be the context. And we'll pass through the context struct that we just created, which is a knit bank. Okay, we'll return our results. Now the initialization happened in the struct.
00:22:54.445 - 00:24:09.445, Speaker A: So all we're going to do here for the function is just saving the information we need to the account state for the bank. So let's load in the bank, we'll take a mutable reference of the account and then we're going to update the mint address. And this is going to be the context counts mint key. Now we're going to take the authority and that's just going to be the signer and then the liquidation threshold we're going to have to pass as an argument here. So we're going to update to add in liquidation threshold. That will be a U64 and let's update bank liquidation threshold. Okay.
00:24:09.445 - 00:25:03.825, Speaker A: And then let's also update the max ltv and we'll add this as a parameter as well. Okay. And then we can just return. Okay, now that we have this function, we can take this to our librs and declare our first instruction in the program. So here we go. We're going to INIT bank. We're going to take the context for a NET bank, pass through the liquidation threshold in xltv and then use the process init bank function that we just created in our previous file.
00:25:03.825 - 00:25:46.475, Speaker A: Now we'll go back to the admin file and there's one more account that needs to be created and that is the user accounts. So let's first create our struct. For that we'll do derive accounts and we'll do pub structs. This is going to be for net user and first we're going to pass through the signer and then next we're going to pass through the user account that we want to create. So accounts. And we're going to initialize here. So we'll use the init constraint.
00:25:46.475 - 00:26:24.741, Speaker A: We'll have the payer as the signer. The space will calculate with init space. The seeds. We're just going to have the signer key and then the bump. Okay. And then we'll just name this account as user account. And then because we're initializing a new account, we need to pass through the system program.
00:26:24.741 - 00:27:27.415, Speaker A: Okay, and now we'll just update our crate to useuser. One more thing to do in our admin file is to create the function for process init user and the context is going to be the init user struct we just created. And then we're also going to want to pass through the USDC address just because we're going to be doing that check throughout this entire program. So we want to just keep track of what that is. So this is another challenge is how to optimize how to keep track and check what min address you're using. And you'll understand why we need this as we start to write out the logic. So we're going to load in the user accounts, we're going to set the owner as the signer key and then the USCC address as the USCC address public key that was just passed through.
00:27:27.415 - 00:27:57.095, Speaker A: Now we can take this function and pull it into our librs and we're going to make an INIT user. There you go. So that's everything we need for the admin side of things. Now let's write our instruction to deposit. So whenever you use a lending protocol, the first thing you want to do is deposit an asset onto the protocol. So you now have collateral that you can borrow against. So let's write the instruction to allow a user to deposit an asset into its respective bank.
00:27:57.095 - 00:28:33.603, Speaker A: So in our instructions we're going to make a new file and that's going to be our deposit rs. Okay. Now we want to immediately go to the modrs file and update that. So we'll use deposit and then mod deposit. Okay, we'll go back to deposit RS and we're going to use anchor. Now let's define our struct for the context for the deposit instruction. So let's think about all the accounts that are needed for a user to be able to make a deposit into the protocol.
00:28:33.603 - 00:29:53.175, Speaker A: So the very first thing is the signer that's going to be the signer of the instruction for the deposit instruction. So we'll do derive accounts, we're going to do pub structs deposit. Okay. And the next thing we're going to need is the mint account for the token that we're trying to deposit. So we'll add in pub mint and this is going to be an interface account. Now we're going to need the bank which is what is going to have all of the information related to the bank that we want to deposit into. So let's load that and this is going to be mutable because we're going to be updating the state and the bank and we'll need the seeds as how we've defined it when we initialize the bank which was just using the mint key.
00:29:53.175 - 00:30:50.505, Speaker A: So we'll use the mint key and then because we're defining the seeds, we need the bump, okay. And we'll set the bank is going to be an account info bank. Okay. And now when you deposit a token into a bank, that token is going to be sent to the bank token account. So we're going to need the bank token account as well. And this is going to be mutable because we're depositing into the account and then the bank token account, we set those seeds as the treasury and the mint key. So treasury, let's just double check to make sure we have our seeds correct.
00:30:50.505 - 00:31:27.319, Speaker A: So treasury and the mint key. Okay. And then we need to update our imports so we need the mint from the SPL token token interface and we need the bank from the crate. Okay. And now because we passed through their seeds, we need our bump. Okay. And this is the bank token account, which is an interface account and token account.
00:31:27.319 - 00:31:52.265, Speaker A: There we go. And now we're also going to have to import this from the token interface. Okay. So the next account we need is the user account. And this is what is storing all the information for this specific user who is using the lending protocol. So we'll pass through account, set it to immutable. We're going to define the seeds and that is just the signer key.
00:31:52.265 - 00:32:19.391, Speaker A: And then the bump. Okay. And then we'll define this account. And we need to make sure we import user from our state. So we have the bank that has the state for the bank. We have the bank token account that is holding the tokens for the bank. We have the user account that is the state for the user.
00:32:19.391 - 00:33:39.045, Speaker A: Now we need a user token account that's going to take the tokens that we're depositing and transfer into the bank token account. So we're going to set the user token account. Now this will be an associated token account of the mint address of the token that they're depositing into the bank account. So we're going to load in the associated token account for this mint address for the user. So we need the associated token and that will be the mint account that we passed through up here. And then we'll do the authority is the signer and then we need the token program. Okay.
00:33:39.045 - 00:34:14.626, Speaker A: And then we'll just label this account for the user token account. And this is an interface account and a token account. There we go. And now we'll need to update our imports, which token account already exists. So we're good. Now we need to pass through the token program, associated token program and the system program. So pub token program, that is an interface token interface.
00:34:14.626 - 00:34:48.100, Speaker A: Now we need the system program and we also need the associated token program. Okay. And then we'll update our imports, all coming from token interface. And this one is going to be coming from the associated token. So that is our struct for deposit. Now we can go ahead and write the logic to make a deposit into the protocol. So let's see, how are we going to actually deposit a token into the bank.
00:34:48.100 - 00:35:35.155, Speaker A: We're going to want to make a CPI transfer from the user's token account into the bank's token account. Then we're going to want to calculate the new shares to be added to the bank and the new shares for the user. We're going to want to update the user's deposited amount and total collateral value and then update the bank state as well. So let's start with making the CPI call. So PUBFN process deposit and this will be the context for deposit. And we want to specify how much the user is going to deposit into the bank. So we'll have amount.
00:35:35.155 - 00:36:38.425, Speaker A: Okay. Okay, so we'll first need the transfer CPI accounts. So let transfer CPI accounts and this is going to be a transfer checked. And then we want to make sure we have this as an import and transfer checked is going to be coming from the token interface which isn't showing up here. So we're just going to write it ourselves. Transfer checked. There we go.
00:36:38.425 - 00:37:17.945, Speaker A: Now we need to pass through the from mint to an authority fields. So first is from and you're transferring the tokens from the user's token account. So we're going to do accounts user token account to account info. And then up next is going to be two and this is to the bank's token account. And then we need the authority and the authority is going to be the signer of the instruction because the signer owns the user's token account. And then lastly we need the mint and that is the mint account that we passed through in our struct. Okay, so there's our transfer.
00:37:17.945 - 00:38:17.039, Speaker A: Now we need to define the CPI program that's going to be used. And since all of the tokens we're going to be transferring will be interface account tokens, we can use the token program. So let CPIProgram CTX accounts.tokenprogram to account info. And now we're going to need the CPI context. So let CPICTX equal and we'll do CPI context new and this will pass through the CPI program and the transfer CPI accounts. Okay, and now we need the decimals.
00:38:17.039 - 00:38:59.015, Speaker A: So the decimals we can just get from the mint account. So CTX counts mint decimals. We don't need to unwrap that, we can just directly grab it. Now we can actually process the transfer. So we can do token interface transfer checked of the CPI context, the amount and the decimals and then we'll unwrap that. Okay, now the transfer took place so we transferred tokens from the user's token account into the bank's token account. Now we're going to have to update the state for both the user account and the bank account to reflect this transfer.
00:38:59.015 - 00:40:02.549, Speaker A: So let's first load in the bank, let bank equal and we'll take a mutable reference to the account for bank. Now, to be able to calculate the shares that we want to update in the bank state, we're going to have to do a little bit of dividing and multiplication. But we're going to have to do it a special way in Rust to take into consideration for overflow and underflow errors. We're going to be using the checked prefix for divide and multiply in Rust to be able to handle any errors that happen if there is an overflow or underflow error. So if there is an error, the checked divide and check to multiply is going to return either a value or a none. And it's not going to panic where if you just divided and it returned an error, it would panic. So we're going to set the deposit ratio which is what we need to calculate the shares for a user.
00:40:02.549 - 00:41:19.575, Speaker A: So the actual formula for calculating the shares, it's going to be deposit shares is the total deposit shares times the deposit ratio. So we need to calculate the deposit ratio which is the amount deposited divided by the total amount of bank deposits. We'll do let deposit ratio equal and it's going to be the amount sorry, it's going to be the amount that we deposited check divide by the bank total deposits and we'll unwrap that. Okay, and now we're going to calculate the user shares. So the user shares is calculated by multiplying the total deposit shares by the deposit ratio. So we'll do bank total deposit shares check to multiply by the deposit ratio and unwrap. Now there's one bit of error handling we're going to want to add and that is we don't want to divide by zero.
00:41:19.575 - 00:42:13.835, Speaker A: So if there are zero deposits we're just going to want to handle that. So we'll do if the bank dot total deposits is equal to zero then we'll return the total deposits is equal to the amount that was just deposited. So total deposits is equal to amount and the total deposit shares is also equal to the amount. Okay, and one more thing, we need to go back up to the token interface and make sure we import. So now that we have the shares calculated, we also want to load in the user account. So we'll do let user equal. It will take a mutable reference to the user account.
00:42:13.835 - 00:42:40.575, Speaker A: And now we're going to want to update the information for the user. So this is where we need to take in the USDC address that we saved the user state. So all we're going to do is have a match statement. So we'll do match and we'll take the mint account that's being passed through in our struct. So accounts.mint. to account info and we need to take the key of that. Okay.
00:42:40.575 - 00:43:35.455, Speaker A: Now, okay, we're going to delete what copilot suggested because that's incorrect. So if the key is equal to the user's USDC address, then I'm going to want to update the user's account for deposited usdc. So user deposited usdc. Now it will be incremented by the amount that was just deposited. So amount and we're also going to want to increment the shares. Okay. And then else, since it's only a two asset protocol, we're going to know that it would be sol.
00:43:35.455 - 00:44:10.265, Speaker A: So we'll update the deposited SOL for the user. Okay, and now let's just make that happy by returning an. Just skip ahead a bit. Now one thing to take into consideration. Lending protocols usually take two options when you deposit. They either mint a collateral token for you to represent the collateral that you have in the bank, or they create a share for you to represent the portion of the bank that you own. So in our case, we're going to be using shares instead of burning and minting tokens throughout the protocol.
00:44:10.265 - 00:44:57.675, Speaker A: Now we just have to update the bank. So the total deposits are now going to increment by the amount and the total deposit shares will increment by the user shares. So that is our deposit function. So now we can take this function and we can state it in our librs. So we'll add in pubfn we're going to deposit, we'll take in the context for the deposit the amount that we want to deposit and we're going to use the process deposit function that we just dated in our previous file. Okay, so that is good to go for deposit. Now if I deposit, you want to be able to also withdraw whatever asset you deposit into the bank.
00:44:57.675 - 00:46:16.035, Speaker A: So let's create the function to be able to withdraw next. So in our instructions we're going to add another file for withdrawal. Okay, now that we created the file, we want to update our mod and mod withdrawal. Okay, now in our withdrawal we want to use anchor. Now let's define the struct needed for withdrawal. So once again we start with derive accounts and then defining our struct, which will just be withdraw, we'll first pass through the account for the signer and we'll also pass through the mint account for the asset. And here we'll need to import the mint from token interface.
00:46:16.035 - 00:46:59.475, Speaker A: Okay, now we need the account for the bank that's holding the state for the bank. So we're going to load the account, make it mutable because we'll be updating the state. We'll need to define the seeds for the account and the seeds just come from the mint key. And then we need the bump. Okay. And then this is just the bank. And now we'll also have to update our import to have bank.
00:46:59.475 - 00:47:33.745, Speaker A: Okay, and now we're withdrawing the asset from the bank token account. So the asset is currently being held in the bank token account and we want to be able to withdraw from it. So we need to pass through the bank token account as well. And the seeds are the bank token account. Let's go back to where we defined this right here. So it's just the treasury and the mint key. We'll copy that over.
00:47:33.745 - 00:48:13.155, Speaker A: Okay, and this is just PUB bank token account, which is an interface account. Token account. And now we want to update our import for the token account. And this should come from the token interface. Now we need the user, we need the user's account state and we also need the user's associated token account. For the Mint we'll do account. It should be mutable.
00:48:13.155 - 00:48:57.615, Speaker A: We'll set the seeds and the seeds for the user's account is just the signer, we need the bump. And then we need to define the account which is the user account. Our state is going to be the user account we defined in our state file. So we want to update the import here to have the user. Okay, and now we need the user's token account that we're going to be withdrawing the asset to. We're going to do an account. And now when we're defining this account, the user should already have the associated token account because they deposited to the lending protocol.
00:48:57.615 - 00:49:38.753, Speaker A: But just in case, because we can't guarantee that the user has this account. Just going to use a knit if needed here. And since we're using INIT if needed, we're going to have to update our cargo toml. So we'll go back here and we're going to do cargo add. And this is coming from Anchorling? Yep. And we'll add the feature for a knit if needed. Okay.
00:49:38.753 - 00:50:07.899, Speaker A: And you can see that feature was added to our cargo toml. Okay, so INIT if needed, if you have to initialize, we need the pair. Okay. And now for the associated token, we have the mint, which is the mint account that we already passed through. We have the authority which is going to be the signer. And now we have the associated token token program, which is just the token program. And then we have just to define this account.
00:50:07.899 - 00:50:51.185, Speaker A: So the user token account. And this is going to be an interface account. Token account. Okay, and now we need the token program, which is an interface token interface. We need the associated token program and the system program. Okay, and now we just need to update our imports and that is our struct for withdrawal. So we'll add the token interface and we'll add the associated token.
00:50:51.185 - 00:51:42.955, Speaker A: Now that we have the struct, we're going to be able to write the logic for our instruction. So let's define the instruction to process the withdrawal. So process withdrawal. And now we also want to allow the user to specify how much to withdraw. So we'll add that as an argument here and we want the results. Okay, now here with the withdrawal it's going to be a little different than deposit because we're withdrawing tokens from the bank token account and we want to make sure that the user has deposited enough tokens to be able to withdraw. They can't withdraw more tokens than they already deposited.
00:51:42.955 - 00:52:33.305, Speaker A: So let's do a check for that first before we process the transfer of the tokens. So we'll first load in the user account because that will tell us how much the user has deposited. So we'll take a mutable reference to the account. And now we're going to check to see if this Mint account is either USDC or sol. So we'll do CTX accounts mint and we're going to do two account info key and we'll do not what Copilot suggested. Let's delete that. So if this is equal to the USDC address, then I'm going to set the deposited value equal to the deposited usdc.
00:52:33.305 - 00:54:07.025, Speaker A: So let's go outside of this if statement and just define the deposited value that is a U64 type. Now I will set the deposited value to the user's deposited USDC and if it's not the USDC address, then I'm going to set the deposited value to the user's deposited solo this error we're going to jump ahead and return our ok, so now we can check if the amount is greater than the deposited value into the bank. So we'll do if amount is greater than deposited value, then I want to return an error. So we haven't written any custom errors yet within this project. So we're going to write our first custom error. So let's first go back and create a file for errors in our source folder and we'll do arrs. Okay, we're going to update our mod file.
00:54:07.025 - 00:55:07.065, Speaker A: Okay, we'll update our librs. We'll go here and we're going to use anchor. And now we're going to use the error code from anchor and then define an error code. Enum. So we'll do pub enum error code. And then we'll write out our first error message. So in the withdrawal we'll do return error error code and we'll just do insufficient funds because the user doesn't have enough funds deposited to withdraw the amount that they're requesting.
00:55:07.065 - 00:55:40.587, Speaker A: Okay, and then we're going to copy this error we just wrote into our errors for our first custom error and we'll define the message that we want. Okay, and now we need to use the error codes. So use create error code. There we go. And I think I spelled sufficient wrong. So let's fix that. Yep, there we go.
00:55:40.587 - 00:56:10.741, Speaker A: And now we'll go back and fix the typo here. There we go. And here we have a tight mismatch because we didn't pull the key. There we go. Okay, so now we have checked the amount of deposited funds from the user into a specified bank. And if it's an incorrect value, we're returning an error. But if not, now we can go ahead and process the transfer for the user to be able to withdraw funds from the bank.
00:56:10.741 - 00:56:38.645, Speaker A: So this is going to be very similar to our transfer from deposit. So we'll do let transfer CPI accounts. Okay, so we'll use transfer checked. We want to make sure we import that and it's not suggesting the right import. So we'll go and manually import it should come from the token interface. So we'll do transfer checked. There we go.
00:56:38.645 - 00:57:10.885, Speaker A: Now let's see. Transfer check does from mint to an authority. So from it's coming from the bank token account because we're withdrawing from the bank, it's going to the user's token account because the user is withdrawing to themselves. The authority is going to be not the signer here. So it's actually going to be the bank token account. Because when we initialize the bank token account, we made the authority itself. So we can just set the authority to the bank token account.
00:57:10.885 - 00:57:35.823, Speaker A: Okay. And then the mint is the accounts mint to account info. Okay, great. So that is our transfer CPI accounts. Now we need to set up our CPI program, which is just going to be the token program because we're transferring Tokens. So let CPI program be the token program. Now let's think about this transfer.
00:57:35.823 - 00:59:13.075, Speaker A: It's a little bit different than the previous transfer because we're transferring from the Bing token account which is its own pda. So whenever you want to make a transfer with a pda, the PDA has to sign for it and we're going to have to derive the signer seeds. So let's first define what the signer seeds are for the bank token account and then we're going to be able to process the transfer. Let's do let sign our seeds. Now this is three references, so 1, 2, 3 and a U8 and this is equal to we have one reference and then we have another reference. And this is where we defined the treasury for the bank token account. And then we also had the mint key as part of the seeds and then we'll need to include the bumper and then we need to define what the mint key is.
00:59:13.075 - 01:00:12.023, Speaker A: So let the min key BCTX accounts mint key. Okay, so there is our signer seats. Now we can create the CPI context. So let CPICTX equal and we'll do CPIContext new and this will be for the CPI program and transfer CPI accounts. And we're going to use with signer this time and add in the signer seeds which update the formatting here. Okay, there you go. Now we need the decimals and that can just be pulled from the mint account and then we can actually process the transfer.
01:00:12.023 - 01:01:04.525, Speaker A: So we'll do token interface transfer, check the CPI context, the amount and the decimals. Now I want to make sure the token interface is imported. Okay, so now that we've processed the transfer for a user to be able to withdraw tokens into their own token account, we want to update the state of both the user and the bank to reflect this token transfer. So we're going to first load in the bank. We'll take immutable reference to the bank. I now need to calculate the shares to remove. So so when we calculate the shares to remove, we're going to take the amount divided by the total deposits in the bank and then multiply that by the total deposit shares.
01:01:04.525 - 01:03:03.075, Speaker A: So we're going to do amount will cast as an F64 divided by bank total deposits also cast as an F64 and then we'll multiply that by the total deposit shares. Okay, now we want to load in the user account and then we're going to do the same thing we did earlier by updating the users deposited either SOL or USDC by checking the mint address that's being passed through. So we'll do If CTX accounts.mint to account info and get the key if this is equal to the user's USDC address. So we're going to decrement the deposited USDC by the amount that is being withdrawn and we're going to decrement by the shares to remove and then else we're going to do the same thing but for sol. Okay, and looks like I had a typo in the users deposited usdc. Okay, we'll have to fix that.
01:03:03.075 - 01:03:55.695, Speaker A: All right, and now all we have left is just to update the bank state. So the bank's total deposits are going to decrement by the amount and the bank's total deposit shares are going to decrement by the shares to remove. So now just recapping the logic here, we're checking to make sure that the user is withdrawing assets that they have already deposited. If they're trying to withdraw too much when returning an error. If they're withdrawing an amount that is accurate, we're going to process the CPI transfer from the bank token account into the user's token account and then after that we just update the state for the both the bank and the user to reflect the transfer that took place. So we deposited and we withdrew. Now we can just go back to our librs and add in the withdrawal function.
01:03:55.695 - 01:04:36.385, Speaker A: So this is just PUBFN withdrawal. It's going to take the context, withdrawal the amount and then we're going to process withdrawal, which is the the function we just wrote in our previous file. Okay, so so far a user is able to deposit assets into a specific bank and then be able to withdraw those assets. But now we want to allow a user to be able to borrow another asset. So when they're borrowing an asset, they're using the deposited assets as collateral. So we're going to calculate the collateral that a user has to find out how much that they're able to borrow against the collateral that they deposited into the bank. So let's write our instruction for borrow.
01:04:36.385 - 01:05:25.145, Speaker A: So we're going to add another instruction file and that will be borrow RS and we'll use anchor here. Okay, we're going to update our mod file. So pub use borrower and mod borrow. Now let's start by defining the struct for our context. So we're going to use derive accounts and the struct is going to be for borrow. We'll use the lifetime specifier. And now let's start with the Account for signing the instruction.
01:05:25.145 - 01:06:23.867, Speaker A: So the first account we're going to pass through is going to be the signer, and we'll also need the mint, which is the mint account of the token that the user wants to borrow. And that will be an interface account. And now we'll have to update our import and that is going to come from the token interface. And there is a weird import that came in. So let's actually delete that and re import mint. Okay, there we go. All right, next we're going to need both the bank of the Mint that the user wants to borrow and the bank token account of that Mint as well.
01:06:23.867 - 01:06:55.225, Speaker A: So let's pass both of those accounts through. So we'll do. Okay, there we go. So Copilot was able to guess it pretty well. We're loading in the account, we're taking the seeds of the mint address and we're using the bank and we need to import that from our state. Okay, next is going to be the bank token account. So account this is also going to be mutable.
01:06:55.225 - 01:07:15.497, Speaker A: The bank token account will go back to admin. This one I always forget. So it's just treasury and then the mint key. So now we can paste that in. And we need our bumper. Okay. And then pub bank token account.
01:07:15.497 - 01:07:33.481, Speaker A: It is an interface account. Token account. We're going to import the token account and that should come from the SPL token interface. There we go. So next we need the user's account from the protocol. So we'll do account. This is going to be mutable because we're going to be changing the account state.
01:07:33.481 - 01:08:16.545, Speaker A: We need the seeds for the user account, which is just the signer key, and then the bumper. Okay. And then we'll just define this account, which is just the user account. And now we're going to have to import user from the state. Now we're going to need the user's token account for the token that they're looking to borrow. We're going to have to use a knit if needed here for the token account because the user is borrowing a new token and you don't know if they have already created their token account for this token. So we'll do account and we'll do a knit if needed.
01:08:16.545 - 01:08:41.037, Speaker A: The payer is the signer. We're doing an associated token account and we'll use the mint of the mint account. We pass through the authority, which is the signer, and then the token program, which we will pass through after this. So now we'll just name this as the user's token account. It's going to be an interface account. Token account. Okay, so now we need the token program because we just referenced it here.
01:08:41.037 - 01:09:16.242, Speaker A: We're also going to need the associated token program. Okay, and lastly we need the system program because we're potentially initializing a new account. And then we just need to update our imports. So token interface should be from the SBL token and the associated token. Okay, now our imports are updated. So that is everything we need for the account struct to process our borrow instruction. Now we can start writing the logic for borrow.
01:09:16.242 - 01:10:12.717, Speaker A: So let's go down here and write PUBFN process borrow. We want to pass through our context as the first argument, and that will be the context of the struct we just wrote above, which is borrow. Okay, now we want the user to specify the amount they want to borrow. So we'll add that as the next argument, which will be a U64 type. Okay, we'll return our result. Okay, so now we have the basic functionality of a withdrawal function. And just to recap, what we have there is the deposited value is calculated.
01:10:12.717 - 01:11:14.525, Speaker A: We're checking to make sure that the amount that the user is requesting to withdraw is less than or equal to the deposited value into the bank. And then we're taking the CPI transfer from the bank token account into the user's token account to withdraw their assets, and then updating the state for both the bank and the user. However, there's one critical part that's missing here and that is being able to calculate interest. So when you're using a lending protocol, the main benefit of a user wanting to deposit their funds into the protocol is because they're earning an interest by depositing the funds. So whenever a user is borrowing the funds, they're paying an APY on the funds to be able to borrow that asset. So we need to take into consideration the interest calculation when we're actually doing the check for how much a user can withdraw, because if they deposited funds, they're going to have a slightly larger value of funds held in the bank than they originally deposited. So we can adjust our check for that.
01:11:14.525 - 01:12:05.035, Speaker A: Now let's go back and figure out how we're going to integrate our interest rate. Typically, in most lending protocols, you're going to have a dynamic interest rate. So one challenge for you if you're working on optimizing this code base, is how are you going to integrate a dynamic interest rate? For simplicity, here, we're just going to have a fixed APY on all of the banks to be able to calculate. But for further optimization you would want to integrate a dynamic interest rate. So let's first start by updating this check between the amount and the deposited value. So we now know that the deposited value is going to be larger than the original calculated deposited value. So let's get rid of this check and let's start to calculate our interest rate.
01:12:05.035 - 01:13:14.035, Speaker A: So first we need to make sure that we are logging when the user deposited their funds. So we're going to go back to our deposit function and at the very end of the deposit function we're going to now use the last updated field that we originally put into the user state. So we'll do user last updated is equal to and we'll do clock dot get the current UNIX timestamp. So now we're keeping track of the time the user deposited into the bank. Now we'll go back to the withdrawal function and we're going to be able to calculate the time difference. So we can just do let the time difference equal. We'll load in the users last updated and subtract by the current time.
01:13:14.035 - 01:14:33.405, Speaker A: Okay, now we have the time difference. So up next is the interest rate. And since we're going to simplify things and have a fixed interest rate for each bank, we can go back to our bank state and just set a fixed interest. So we'll go to the state bank and we'll add in interest rates. And then at the time that we initialize the bank we're going to set the interest rate to 5%. Okay, now going back to withdrawal, we can now calculate the new total deposits into the bank with the accumulated interest rate. So we'll do bank total deposits is equal to and we haven't loaded the bank in yet.
01:14:33.405 - 01:16:13.085, Speaker A: So let's first load that in. We'll do let bank is equal to immutable reference to the bank. Now the formula for a compound interest over a specified period of time it's going to be the value, the original value times the natural log to the power of the interest rate times the time that has elapsed. So we're going to calculate that here we'll do bank total deposits we'll cast as an f64 for the calculation times and we'll need e dot to the power of and we'll take the interest rate. So we'll do bank dot interest rate cas is an F64 times the time diff also cas is an F64 and then we'll want the entire calculation cast back as a U64 to be in the same type for the total deposits. Okay, so that is now our total deposits in the bank. Taking into consideration the APY on the bank, now we can calculate the current value of one share.
01:16:13.085 - 01:17:14.225, Speaker A: So we'll do let's value per share equal and we'll do the total deposits from the bank divided by the total deposit shares. Okay, and now going back to our previous calculation, we do have to import E. So that just comes from the standard constants within rust. And one thing to update here is that to use E to the power calculation we're going to have to use an F32 type. So we'll just recast is an F32. Okay, there we go. Now that we have the value per share, we're going to want to calculate the user's value.
01:17:14.225 - 01:18:07.915, Speaker A: So we'll be able to take the user's amount of shares and calculate their entire deposit value. So let's user value equal and we'll do the deposited value divided by the value per share. Okay, so now we have the entire user value taking into consideration their accumulated interest from the bank. We can now do our check to make sure that the amount that they're requesting to withdraw is accurate. So we'll do if and this time we're going to take the user value. If the user value is less than the amount, then we'll return the error for insufficient funds. So now a user can deposit and withdraw from a bank.
01:18:07.915 - 01:18:50.777, Speaker A: Now we need to allow a user to be able to borrow against their collateral. So the next instruction we're going to write is borrowed. So let's get everything ready to write our borrow instruction. We'll create a new file for borrow RS and then update our mod file. Okay, and now we'll go back to our borrow file. We're going to use anchor. So now we have our borrow and we're going to start by setting up our struct of all the accounts that we need to pass through to run the instruction.
01:18:50.777 - 01:19:29.989, Speaker A: So we'll start with derive accounts. Okay. And we'll name the struct borrower. Okay, so the first account we're going to pass through is our signer, that is who is going to be signing the instruction to call the borrow function. Okay, so Copilot made some suggestions. Let's see what they did. So we need the mint.
01:19:29.989 - 01:20:00.077, Speaker A: Yes. So the mint is the interface account and we're going to import the mint. And that's coming from token interface. Okay. We'll also need to pass through the bank. The seeds for the bank is the mint Key and then we're going to import the bank from the state crate and then next is the bank token account. So we have both the bank that's holding the state for the bank and we have the bank token account that's holding the tokens for the bank.
01:20:00.077 - 01:20:31.495, Speaker A: And now we'll import the token account also coming from token interface. Okay. And then the user accounts, we need to hold all of the user state. This is where we'll be able to query how much collateral the user has deposited into the bank. And here we go. So this is where we're going to change from what Copilot suggested. So up next we need to have a token account for the Mint that the user is requesting to borrow for the user to be able to accept that token.
01:20:31.495 - 01:21:00.445, Speaker A: Now we're not sure if the user has the token account or not because they're borrowing it. So they may not have the asset already. So we're going to have to use INIT if needed to be able to initialize if needed for the user a new token account for the Mint that they specified. So let's do account. The first constraint is going to be INIT if needed. Okay. And because we're initializing, we'll need the payer.
01:21:00.445 - 01:21:32.685, Speaker A: And then we're just going to specify that this is an associated token and the Mint is going to be the mint that we pass through up here. Okay. And then we need the authority which is going to be the signer of the instruction and then we need the token program. So we'll do associated tokens. Token program. Okay, now we'll just define this struct and it will be user token account and that's an interface account. Token account.
01:21:32.685 - 01:22:07.575, Speaker A: Okay, now we're having some errors and that's because we have yet to pass through the token program. We're also initializing a new account on chains. We have to pass through the system program as well. But before we do that, there's one account that we need to pass through and that is going to be the price update account. So to be able to borrow, we're borrowing a different asset than the asset we have as collateral. So we need to understand the value of the asset we have as collateral in USD to be able to compare it to the asset we want to borrow. And we need to get that by using an oracle.
01:22:07.575 - 01:23:21.037, Speaker A: So we're going to use the pith oracle and get the real time price of the asset we have as collateral. So to do that we have to pass through the price update account from pif. So we'll do price update and this is an account and we're going to use price update v2. Now we need to get pith and our cargo toml so we'll go to cargo adjustments and it's going to be the PITH Solana receiver. So cargo pith Solana receiver SDK okay, so now we've updated our cargo with the PIF Solana receiver. Now we'll go back to borrowing and we want to import the price update from pif. Okay, we now want to pass through the token program, associated token program and system program as our accounts.
01:23:21.037 - 01:23:44.665, Speaker A: So token program is going to be an interface. Token interface. We need the associated well, we'll do the system program since that popped up. And now we need the associated token program and that is an associated token. Okay, so now let's update our imports. So we need token interface. We'll import from the token interface and then associated token comes from associated token.
01:23:44.665 - 01:24:22.943, Speaker A: Okay, now our imports are updated and these are all of the accounts. We have a typo there. Let's get rid of that. Okay, and these are all the accounts we'll need for the borrow instruction. So now we can start writing our logic for borrow. So pubfn we're going to process borrow and we'll use our borrow struct for our context that we just defined. And now we want to allow the user to specify the amount they want to borrow.
01:24:22.943 - 01:25:32.925, Speaker A: So we'll pass that through as an argument. That'll be a U64 type. Okay, so now I'm just going to return our okay at the end so we don't have a bunch of errors as we're writing everything. Okay, so let's see, how do we want to start off by processing a borrow on the protocol? Well, first we need to be able to see how much collateral the user has deposited into the bank across the entire protocol to see how much collateral they have to borrow against. So typically in a lending protocol, you'll have several assets that you're going to have to calculate as collateral. For this protocol, we only have SOL and usdc, so we're only going to check one asset as the deposited value for our total collateral. However, when we deposit, we also have the interest accrued on the deposit amount, just like we talked about in our previous instruction.
01:25:32.925 - 01:26:15.063, Speaker A: So we need to take that into consideration too when checking how much collateral a user has. So let's first load in the bank and the user accounts so we have the state to be able to get the information we need for our calculations. So Let bank equal will take a mutable reference to the account for bank and then the same thing for users. And then to get the real time value of your collateral, we're going to have to load in the price update account. So we'll add that. Let price update. Okay, now we want to find out what the total collateral is.
01:26:15.063 - 01:27:04.111, Speaker A: So we're just going to first define total collateral because we're going to use a match statement and we want to be able to use this outside of the match statement. So this is a U64 type. Okay. Now the reason we're using a match statement is to see what asset the user needs for collateral here. So we're going to use CTX accounts and we're going to get the mint address of the mint account that's being passed through. So to account info key, we're going to delete what copilot suggested here. Okay, so delete that as well.
01:27:04.111 - 01:27:50.235, Speaker A: Okay, so we're matching to the key of the mint address being passed through now. So if the key is the user's USDC address, then we're going to calculate the total collateral for usdc. So first we need to load in the price feed. Let's find what the price feed IDs are for both Sol and USDC on Pith. Okay, so to get the purse feed, we're going to have to go to Pith's website where all their feed IDs are listed. So here you can see the price feed IDs. And we're working with Solana stable.
01:27:50.235 - 01:28:03.471, Speaker A: Now first I want sol. So SOL usdc. Sorry. So SOL USD. Here's the price feed for it. We're going to copy that. And now let's create a constants file to keep track of this.
01:28:03.471 - 01:28:45.815, Speaker A: So in our source we're going to have a new file for constants. Let's update our mod file to have constants. Okay, and now we'll use anchor. We're going to use the constant attribute. Okay, and now we'll define our first constant which is the soleusd feed id. So pub const sol USD feed id. This is an anster type.
01:28:45.815 - 01:29:15.105, Speaker A: And then we're just going to paste in the feed ID that we just copied. Now as you can see, this is all grayed out. So we're going to update the rest of our mod files to make sure it's recognizing this. So we'll go back to our librs and we want to mod constants. Okay, and here we go. Sorry, the attribute is actually constant, not with an s There we go. And there's our first feed id.
01:29:15.105 - 01:30:07.647, Speaker A: So the next feed ID we need is the USDC USD feed id. So we're going to type in USDC and here is USDC USD. So we'll copy that feed ID over and bring it into our constants. So pub const USDC USD feed id, define the type and then we'll paste it in. Okay, now one last thing we need for using a pith oracle is we'll need to define the maximum age. So the maximum age is how long you'll allow from the previous update to make sure that the account is not stale. So here we're going to allow 100 seconds for the feed to become alt.
01:30:07.647 - 01:31:09.395, Speaker A: So we'll do PubConst maximum age new 64 type and we'll just set this to 100. So the price feed cannot be older than 100 seconds or it will return an error for being stale. Okay, so going back to our borrow file, this is where we're going to start using PITH to be able to calculate the current USD value of the total collateral of the user on the protocol. So back to our borrow, because the user is passing through the USDC address, it means they're looking to borrow usdc. So we're going to get the sole feed ID because that means that their collateral is in sol. So let's solve feed ID equal and we're going to get feed ID from hex. So this comes from pith.
01:31:09.395 - 01:31:51.153, Speaker A: So we're going to import this. We'll go back to our price update imports and add in the get feed ID from hex function. Okay, now what needs to be passed through as an argument here is going to be the feed id. So we can just use the constant that we just wrote in our previous file and import it. So we'll use the SOL USD feed ID and make sure we update our import to have SOL USD from our crate. Okay, great. So now that we have the feed id, we're going to be able to get the actual sole price from the pith oracle.
01:31:51.153 - 01:33:18.337, Speaker A: So we can do that with let SOL price equal and we'll take the price update account and we're going to call get price no older than. Get price no older than. And we're going to first pass through the clock. So we'll do clock get and unwrap that. And then the maximum age is going to be the max age constant that we just defined. And then lastly we'll pass through the feed ID which will just take a reference to this variable that we just created so SOL feedid and we forgot to unwrap this. So we'll just unwrap and there we go.
01:33:18.337 - 01:34:08.815, Speaker A: Okay, so now we have the sold price. So now we need to calculate interest. So we're going to calculate the accrued interest. And since we're going to have to calculate this for both areas of this match statement, we're going to go below and just make a function for it. So we'll do fn calculate accrued interest and we'll just take in the deposited value. That'll be a U64 type. We'll take in the interest rate and then the last updated time.
01:34:08.815 - 01:35:03.725, Speaker A: Okay, and we'll return a result of type U64. Okay, first we want to get the current time. So we're going to use the same function we used previously, which is taking the deposited value, multiplying it by E to the power of the interest rate times the elapsed time. So we'll get the current time and we'll do a clock dot get unix timestamp. Now we need the time difference and that is going to be the current time minus the last updated time. And now we can get the new value. So const new value.
01:35:03.725 - 01:36:05.875, Speaker A: And this is the formula for compound interest. So we'll do deposited as an F 64 times E to the power of the interest rate as an F32, times the time difference as an F32, cast that as an F64 and then we're going to just be able to return the new value. So we'll go back up to our match statement and pull in this function that we just created to calculate the new value with the accumulated interest. So let's total collateral and we want the sole price. So we're going to take because currently we're keeping this in how many sol you have. So we're going to multiply how many sol we have by the sole price. And the new amount of soul we have is calculated here by the new value.
01:36:05.875 - 01:36:34.905, Speaker A: So we'll do sol price. And now this returns a price struct which we can take a look at it. It is the price the conf exponent published time. All we want here is the actual price. So we'll go back to borrow and we want sole price.price and we're going to multiply that by the new value. So the new value.
01:36:34.905 - 01:37:12.935, Speaker A: Let's calculate that. Let new value equal and we'll do calculate accrued interest and that's going to take in the user.deposed SOL. Okay, and then we also want the interest rate from the bank. So we'll do bank dot interest rate. And lastly we want the last updated. So we'll do user dot last updated and then we'll unwrap this function.
01:37:12.935 - 01:37:45.265, Speaker A: Okay now we have the new value. So we can just do the sold price times the new value and that is your new total collateral. And we'll cast this as a U64 so they're compatible to multiply. There we go. Now we're going to do the same thing but opposite for the USD value. So we will do the other half of the match statement. So first we're going to load in the USDC price feed.
01:37:45.265 - 01:38:39.557, Speaker A: So let USDC feed ID equal and we'll get feed ID from hex for the USDC USD feed id. Okay, now we're able to get the USDC price by using the price update account. We'll do no older than we have the clock, we have the max age and then we have the USDC feed id. Okay now we'll calculate the new value and we're going to use our helper function we created below and we'll do calculate accrued interest the users deposited USDC and I think this is where I had a typo, it's. There we go. And then we have the bank interest rate and the user's last updated time. Okay and now we can calculate the total collateral here.
01:38:39.557 - 01:39:57.225, Speaker A: So total collateral we will use the price from the price struct for USDC cast as a U 64 times the new value. Okay so now we have the total collateral for either asset depending on which asset that the user wants to borrow. And we're going to check to see if the user is able to borrow it. For this lending protocol we're using over collateralized loans which means that the total collateral has to be equal to or less than the total collateral times the liquidation threshold of the asset. So let's check to make sure that the user is able to borrow the amount that they're requesting without making their account unhealthy. So let's do let borrowable amount equal to and we'll do total collateral multiplied by the liquidation threshold and we'll pull that in from the bank. So bank liquidation threshold.
01:39:57.225 - 01:40:51.955, Speaker A: Okay, now we can check to see if the user can borrow the amount they requested or not. So we'll do if the borrowable amount is less than the amount, we're going to return an error code for over borrowable amount. Okay now we're going to copy this and add it to Our custom errors and we're going to add a message for it. And that is not the message we want. Let's do requested amount exceeds borrowed amount. There we go. And now we want to import from our error codes.
01:40:51.955 - 01:41:32.275, Speaker A: So we're going to use create error code. There we go. Let's update our import here. Clean that up a bit and update this. Not sure why that was imported. So so far we have checked to see the value of a user's collateral and took into consideration the interest that they've accrued based on depositing the asset into the bank. And now we're checking to see if the requested amount to borrow is borrowable by keeping the account safe by borrowing this amount.
01:41:32.275 - 01:41:58.409, Speaker A: And now we're just going to update the state for both the bank and the user. Oh actually before we update the state we actually have to process the transfer. So we're going to make our transfer cpi. First step of the CPI is the accounts. So let transfer CPI accounts. We're going to use transfer checked. We need to import that and that should come from token interface which it's not showing.
01:41:58.409 - 01:42:26.005, Speaker A: So we'll manually add that transfer. Okay, transfer checked. There we go. Now we'll scroll back down to our transfer check struct. And we have from it's coming from the bank token account. Because we're borrowing from the bank, it's going into the user's token account. The authority is going to be the bank token account.
01:42:26.005 - 01:42:51.467, Speaker A: So let's update this. And the reason is because when we created the bank token account we specified the authority was itself. And now the mint is going to be the mint account that was passed through. Okay, great. Up next is the CPI program. So this is just going to be the token program. And then now we're going to be signing from the bank token account which is a pda.
01:42:51.467 - 01:43:32.085, Speaker A: So we have to define the signer seeds for this CPI to process. So let's do we actually did this. It's very similar to withdrawal because both of these CPIs are coming from the token account. So we can go back to withdrawal and just copy this over because we're using the same PDA from the same token account. Okay, so back to borrow we'll paste that in. Now that we have our sign receipts we can make our CPI context and that is just the CPI program and the transfer CPI accounts with signer and we're defining our sign receipts. Okay.
01:43:32.085 - 01:44:12.205, Speaker A: Lastly we need our decimals and then we can actually process the transfer. So we'll do token interface and we'll do transfer checked CPI account amount and decimals. Nice. Now that the transfer happen, now we'll update the state for both the bank and the user. So first we want to be able to take into consideration if the total borrowed is zero. So we'll do some error handling here. So if bank dot total borrowed is equal to zero we'll set that to amount.
01:44:12.205 - 01:44:48.031, Speaker A: Now let's check. It's showing that this isn't part of the bank state. So let's go back to our bank and see if we remembered that bank. Okay, so looks like in our bank we only saved the total deposits and deposit shares. So let's add in the total borrowed and total borrowed shares because we want to keep track of that as well for the bank. Okay, let's calculate the borrow ratio to be able to then calculate the user shares. So calculating the shares for borrowed is the same logic and the same formula as the deposit shares just using the borrow ratio instead of deposit ratio.
01:44:48.031 - 01:45:51.249, Speaker A: So first we will calculate borrow ratio and we'll do the amount check divide by the total borrowed in the bank and then the user shares is going to be the bank's total borrowed shared multiplied by the borrow ratio. As you're following along with this code, if you want to look more into all these calculations that I'm talking about, all of the calculations are explained and stated in the readme of this code in the bootcamp. Next we're just going to do our match statement again to see if we're updating the state for borrowed USDC or borrowed solar. So okay, looks like copilot did a good job guessing what we were doing here. So we're doing CTX accounts, the mint to account info. We have the key. If the key is the USDC address, it's going to update the borrowed USDC by the amount and the borrowed USDC shares by the user shares that were calculated.
01:45:51.249 - 01:46:49.215, Speaker A: And if not it's going to update the borrowed sol by the amount specified and the sole shares by the user shares we just calculated. Okay so that's it, we're returning. Ok we need to import our E constant to the file and looks like we have one more error we need to fix. Okay so sorry, when you have the match statement and you're updating the variable, you don't redeclare let so we'll get rid of that. And now that's updated. Okay so now our borrow looks like it's good to go. We can just clean up a few things in the file.
01:46:49.215 - 01:47:22.827, Speaker A: Okay now we'll go back to Our librs and actually use this function. So we'll do pubfn borrow. We're going to use the context with our borrow struct that we defined for all of our accounts, allowing the user to pass through the amount that they want. And then we're using process borrow. And there we go. So far we've done deposits, withdrawal and borrow. The last main function for lending is allowing user to repay the amount that they have borrowed.
01:47:22.827 - 01:48:37.095, Speaker A: So now let's write the instruction for repay. So we're going to add into our instructions folder a new file for repay. We'll use anchor here. Okay, we're going to update our mod file. Okay, now let's start as always with our struct for our context. So we'll do derive accounts and this will be our repay struct. We'll start with the signer as the first account that we're going to pass through and then the mint of the token that the user wants to repay.
01:48:37.095 - 01:49:25.355, Speaker A: Okay. And that'll be an interface for mint. So we need to import our mint coming from token interface. Okay, and then up next we'll need both the bank for the state and then the bank token account. And we'll need to import the bank. Okay, and then this is the bank token account and we'll import token account coming from token interface. Next we need the user account and we'll import user.
01:49:25.355 - 01:50:05.867, Speaker A: And then we need the associated token account. And then we'll need to pass through the token program, the system program and the associated token program. And this is a program. There we go. And the token program is an interface. Just updating our types here. And the system program is a program.
01:50:05.867 - 01:50:35.595, Speaker A: Okay, Copilot was a little off with those suggestions. We'll update our imports. Oh, this is a token interface. There we go. Now we'll update our imports coming from token interface. And this is just associated token. We'll update this import.
01:50:35.595 - 01:51:08.965, Speaker A: Okay, there we go. So there's our struct. Now let's start writing the logic for our repay function. So process repay. We'll do our context from the struct that we just wrote. We'll add in the amount as an argument so the user can specify exactly how much they want to repay. Okay.
01:51:08.965 - 01:51:59.059, Speaker A: All right, so let's think about how we're going to do the logic here. So essentially what this is doing is just making a CPI transfer from the user's token account back into the bank token account to repay the amount that they've borrowed. But we'll need to do just a few checks beforehand. These checks are going to be very similar to our withdrawal checks where we're just checking to make sure that the amount that the user is looking to repay is either equal to or less than the amounts they've borrowed. So they're not making an overpayment to the bank. So we'll first load in the user and then we're going to find out what their borrowed asset is. But we want to also calculate the interest.
01:51:59.059 - 01:53:10.785, Speaker A: We want to take into consideration the interest that the user has had to pay on their borrowed asset. So they'll be able to repay a little bit more than they've originally borrowed to fully repay their loan. So we can do that very similar to how we calculated with withdrawal. So let's just pull this file over and we can reference it. Okay, so we'll do pretty much the same logic here. We're going to define the deposited value, but in this case it's going to be the borrowed value and then we're going to find out which asset is being borrowed. So if the key is the user's USDC address, then the borrowed value is going to equal the user's borrowed usdc.
01:53:10.785 - 01:53:53.315, Speaker A: Otherwise add our comma. Okay, Otherwise it will have the borrowed value be the borrowed. So okay, and then now we have this error here. So just to get rid of that we're going to skip ahead and return our okay at the end. Okay, now that we have that, we want to load in the time difference between when the user initiated their borrow. So we'll do let's time diff equal and we'll keep this last updated amount to be from the deposit. So let's have a last updated for borrow as well.
01:53:53.315 - 01:55:01.035, Speaker A: So we'll go back to the user go to state user we have last updated and now we're going to add a last updated borrow. Okay so the time difference is going to be the users last updated borrowed and we're going to subtract by the current time. So clock get unix timed sample. Now we're going to get the APY on the bank. So let bank equal. Okay, and now we'll do banks total borrowed and we're going to add in the interest. So we'll do bank total borrowed.
01:55:01.035 - 01:56:02.839, Speaker A: Oh, let's delete copilot suggestion here and stick to the same formula we've been using. So total borrowed as an F64. We're going to multiply times e to the power of and we'll do the interest rate times the time difference. Okay, close this. And now we'll update the value per share. So let value per share and we'll do the bank total borrowed divided by the total borrowed shares. And then we're going to update the user value.
01:56:02.839 - 01:56:57.555, Speaker A: So let user value equal. So the user value is going to be the borrow value divided by the value per share. Okay, now we need to import our natural log. There we go. Now we can do our check. So we'll do if the amount is greater than the user value, then we have an over repayment. So we're going to return an error from the error code enum and we'll do over repay dot INTO okay, we want to go back to our error code and update this new custom error.
01:56:57.555 - 01:57:37.773, Speaker A: So errors error code enum. We're going to paste in our over repay and then add a message and we wrote our if statement with the wrong syntax there. Okay, now we just need to import our error code. So we'll go back up here. We're going to use create error code. There we go. Now it looks like there's an issue with our account.
01:57:37.773 - 01:58:02.495, Speaker A: So let's figure out where there's an error. So we have the interface account, token account, user account. Okay, so the user token account should be an interface account. Let's just update that. And there we go. Now our error is gone. So now that we did that check to verify that a user isn't over repaying, we can now process the CPI transfer.
01:58:02.495 - 01:58:47.699, Speaker A: So the transfer is going to come from the user's token account and go into the bank account to allow the user to repay their debt. So let's first start out with the CPI accounts. We'll do a transfer check and we're going to have to import that. And that should come from the token interface. Okay, up next is going to be the CPI program, which is just the token program. Then we have the context. And since this is coming from the user's associated token account, it's not a pda.
01:58:47.699 - 01:59:34.445, Speaker A: We don't need the signing seeds to process this. Now we'll do decimals and then we can actually process the token transfer. Okay, so now that we've processed the token transfer, we're going to update our state for both the user and the bank. So we'll load in the bank which. Have we done that? Yes, we already loaded that in, so we don't need to load that in again. So we'll do, we'll calculate the borrowed ratio, which is going to be the amounts divided by the total borrowed. And then we're going to calculate the user shares which is going to be the total borrowed shares multiplied by the borrow ratio.
01:59:34.445 - 02:00:12.403, Speaker A: And then we're going to write our match statement. And copilot's able to predict this very well because it's very similar logic to what we did in our previous instruction. So we have our match statement and then we're updating the borrowed USDC by the amount in the shares or the sole by the amount in the shares. Now I need to make sure we import our token interface. Okay, now that's imported. And lastly is just updating the bank state. So the bank.total
02:00:12.403 - 02:00:56.475, Speaker A: borrowed is going to decrement by the amount and the total borrowed shares will decrement by the user shares. Okay, so that looks like everything that we'll need for repay. We're going to now take our process repay function and add it to our librs so pub repay. Okay, now let's clean up this file, get rid of this warning from our imports. All right, now one last thing. Since we did add in our APY after the fact, we want to make sure that when a user is borrowing and depositing, we're updating the user's last update value. So let's go to deposit and check.
02:00:56.475 - 02:01:41.749, Speaker A: So we have user last update and it's the current timestamp. And then when we borrow at the end of the borrow, we also want to update, we want to do user dot last updated borrow to also have the current UNIX timestamp. Okay, now everything is good to go with all of our instructions from the user side of things to interact with the lending protocol. Now we have one more instruction that we want to add and that's the ability to liquidate. So if you have an account that becomes unhealthy, you want to allow liquidators to be able to come in and liquidate the account. And to do that we'll need an instruction for the liquidator to be able to run. And that will be the last instruction we'll write for this lending protocol.
02:01:41.749 - 02:02:43.987, Speaker A: So now let's create the file for our liquidation instruction. We'll go to instructions new file liquidate RS and we'll update our mod file. Okay, and then back to, and then back to liquidate. We're going to use anchor and now we're going to define our account struct for liquidate. So how liquidation occurs is a liquidator is able to come to a protocol and repay the debt of an unhealthy account. And in return they receive the collateral plus a liquidation bonus which is a percentage of the liquidation amount that they Receive to incentivize liquidators to come come and liquidate unhealthy accounts on a lending protocol. So let's get started by defining all the accounts needed.
02:02:43.987 - 02:04:08.765, Speaker A: We will use derive accounts. We'll define our struct for liquidate. So the first account that we'll pass through is the signer of the liquidation instruction which is going to be the liquidator. Now we'll need to have the real time value of the assets. So we're going to pass through the price update account from pif. We'll want to update our import, fix our typo. Now we'll update our import.
02:04:08.765 - 02:05:15.185, Speaker A: Now we'll need both mint accounts. We'll need the mint account of the collateral and the mint account of the borrow because we're going to have two transfers that take place through this instruction because one is the liquidator repaying the debt and the other is the liquidator receiving the collateral. So we'll do pub collateral mint and this will be a mint account. And we'll have borrowed mint, which will also be a mint account. And then we'll update our import from it coming from the token interface. Okay, so now we'll need to pass through the bank for both of these assets. We'll need the collateral bank, the collateral bank token account, the borrowed bank and the borrowed bank token account.
02:05:15.185 - 02:06:13.327, Speaker A: So we'll do account and this will have the collateral mint key as the PDA for the collateral bank. And then we'll do the same for borrowed. And now we'll have to update our import for bank from our state file graph. And now we'll need the token accounts for each. So we'll do account mutes. And then the token account has the treasury and the seeds and then the same for the borrowed. Okay, so we have the treasury and then the mint key for the collateral and the mint key for the borrowed.
02:06:13.327 - 02:07:52.295, Speaker A: And now we're going to update our imports for token account. And that is coming from the token interface. Okay, and now we want to pass through the user account for the liquidator. And now we'll need the liquidators collateral token account and borrowed token account. And then lastly we need to pass through the token program, associated token program and system program. And then we need to just update our imports with token interface and associated token. Okay, so those are all the accounts we'll need for the liquidation.
02:07:52.295 - 02:09:40.585, Speaker A: Now we can go ahead and process the logic for the liquidation function. So pubfn we'll do process liquidate, pass through our context with the liquidate structure. Now we'll load in the collateral bank and the user and the price update accounts because we want to be able to see how much collateral that the user has on the protocol to just verify that their account is unhealthy before processing the liquidation. So let collateral bank, we'll load that in. So now we're going to calculate both the total collateral and the total borrowed and we're going to do this very similar to how we did in another instruction when we made a match statement and calculated the USD value with pith. So let's actually just bring that up to reference so you can see it's with our borrow function. Okay, so we have our match and we're going to match the accounts with the mint account.
02:09:40.585 - 02:10:45.883, Speaker A: But let's do the collateral mint. So if the collateral mints dot to account info key, if the key is equal to the USDC address. So if the collateral is the usdc, then we'll update. Well we're going to need the sole price and the USCC price regardless. So we can calculate that outside of the match statement and then pull it in. So let's go back and add that. So we're going to do first get the sole price and the USDC price.
02:10:45.883 - 02:11:49.015, Speaker A: So we need the sole feed ID and we'll do get feed ID from hex, we need to import that from PIF and we need to import the solUSD feed ID from our constants. And now we'll do the USDC feed ID and that'll be the same. And we'll have to update our import with the USDC USD feed id. So this isn't being recognized. So let's go back to our constants and make sure that's how we named it. Oh, we had a typo here. So we'll just copy that over.
02:11:49.015 - 02:13:27.307, Speaker A: There we go USD and now we'll update our borrow with the correct constant name. There you go. Then back to liquidate. Okay, now we'll be able to calculate the price just like we did in our borrow function here. So the sold price is price update get price no older than. We're using our max age which we want to import from our constants and for some reason VS code isn't recognizing these two, but. Oh, there we go.
02:13:27.307 - 02:14:35.161, Speaker A: So we have our sold price and now we need our USDC price. Okay, now we can update our total collateral and total borrowed within our function. So we'll do let new USDC equal and we're going to calculate accrued interest and we want to import this, but we'll have to go Back to our borrow and make this a public function. Okay. And then we'll update our import. Okay. Now just to get rid of this error, we're going to add our okay at the end and there we go.
02:14:35.161 - 02:15:27.335, Speaker A: So now we have the new USDC value. So if the collateral mint is equal to the USDC address, then we'll update our collateral to the USDC price times the new usdc. And we're going to initialize total collateral here and we'll also have to initialize total borrowed. There we go. Okay. And then that means that our new sol will equal and we'll do calculate accrued interest for the borrowed soul. And then we're going to have the interest rate and then the users last updated.
02:15:27.335 - 02:15:57.285, Speaker A: But it's this is going to be last updated for borrow. Okay. And then we haven't imported the borrow bank yet. So we'll load that in up here. Let borrowed bank and then take a mutable reference to the borrowed bank. Okay. And then we're just going to update the total borrowed the same way.
02:15:57.285 - 02:16:41.085, Speaker A: Okay. And now we'll do the reverse for if the collateral mint is sold. Okay we can get rid of that reference. So we have our new sol calculate accrued interest the deposited sol collateral bank the interest rate and then the users last updated that updates the total collateral with the sole price and this updates the total borrowed with the USDC price. So now we're able to calculate our health factor. The health factor is going to be your total collateral times your liquidation threshold divided by the total borrowed. If the health factor falls below 1, then the account is unhealthy and can be liquidated.
02:16:41.085 - 02:17:45.365, Speaker A: So we're going to first do the calculation to check the health factor. So let's health factor equal and we'll do total collateral divided by total borrowed. But we're going to update the total collateral to be the total collateral times your liquidation threshold. Okay. Now that we have the health factor, we can verify if the account is unhealthy to be able to be liquidated. So we're going to add a check here. So if the health factor is greater than or equal to one, then we're going to return an error that you cannot liquidate the account.
02:17:45.365 - 02:18:16.665, Speaker A: So we'll do return error. We'll use our error code enum and we'll do not under collateralized. And now we're going to go back to our error code and update this. And here we have a typo. This should be a health factor. There you go. So error will paste in our not under Collateralized error.
02:18:16.665 - 02:18:58.181, Speaker A: And we'll do users not under collateralized so it can't. There we go. And now we want to import our error. Okay, let's first update our health factor to be a float to have the right type to do the comparison. Okay, now that we did our check against our health factor and we verified that the account is under collateralized, we can process the liquidation. So the first step to the liquidation is going to be the liquidator has to pay back the borrowed amount to the bank. So we're going to transfer to the bank.
02:18:58.181 - 02:19:35.455, Speaker A: So let transfer to bank equal. We'll do transfer checks. So this is what copilot suggested. It's going to come from the borrowed token account. So we're going to update that suggestion. Now it's going to go to the borrowed bank token account. The authority is going to be the liquidator and the mint is going to be the borrowed mint.
02:19:35.455 - 02:20:12.167, Speaker A: Okay, so this is all for the borrowed token because we're repaying a borrowed asset. Now that we set that up, we can do the CPI program, let CPIProgram and that's going to be the token program. And then now we can calculate the CPI context. And this is coming from an associated token account, so we don't need signing seeds. Then we'll specify the decimals, and these are the decimals for the borrowed mint. And then we can process the transfer. So we don't want to liquidate the total borrowed throughout this code base.
02:20:12.167 - 02:21:11.525, Speaker A: We're actually using a close factor for the lending protocol. And the close factor is the percentage of collateral that can be liquidated. So we're going to update this by using the close factor for the liquidation. So we'll first calculate what the liquidation amount can be, and that is equal to the total borrowed multiplied by the liquidation close factor. So total borrowed and then we'll do liquidation close factor unwrap. Okay, now that we have the liquidation amount, we're going to paste that in. Now we'll just have to import our token interface.
02:21:11.525 - 02:21:38.525, Speaker A: And that was our first transfer for the liquidation. Let's just update some of our types here. Okay, so for some reason transfer checked was imported by token. So we always have to check our imports whenever we're doing an automated import through our VS code. So we're going to get rid of that so we can fix our types. And transfer checked should go here. Okay.
02:21:38.525 - 02:22:37.537, Speaker A: And we'll fix this import. So that got rid of our type error. So now we're going to process the second part of the liquidation and that is transferring from the collateral account to the liquidator, it's going to pay back everything the liquidator sent to repay the loan. And it's also going to include an additional amount for the liquidation bonus. So let's calculate what that amount is going to be. Okay, we'll name this liquidator amount and this is going to be the liquidation amount that we calculated earlier times the liquidation bonus. So we'll go to the collateral bank liquidation bonus and then we're going to add the liquidation amount to that.
02:22:37.537 - 02:23:12.175, Speaker A: So the liquidation bonus is a percentage. So we're going to take a percentage of the liquidation amount and add that to the original liquidation amount. Okay, now we can process this liquidation. So let's transfer to liquidator. That will be transfer checked. It's coming from the collateral bank token account. It's going to the liquidators collateral token account.
02:23:12.175 - 02:24:04.555, Speaker A: The authority is the collateral bank token account and the mint is going to be the collateral mint. Now because we're transferring from the bank token account which is a pda, we need to include the sign receipts. So we've written these seeds a few times. Let's just go back to where we have that and just copy it. Okay, paste that in. Now we can execute the transfer. So we'll do let cpicontext to liquidator = and this will be the CPI context of the CPI program.
02:24:04.555 - 02:24:38.307, Speaker A: And then we're going to use the transfer to liquidator account. And then we're going to use with signer seeds. Okay, next we need the decimals. So we'll do let collateral decimals and that'll be the collateral mint decimals. And then we can process this transfer. So token interface transfer checked. Oh, and since we copied this in from our other function, the naming of these accounts are a little different.
02:24:38.307 - 02:25:10.755, Speaker A: So this is going to be the collateral mint and the collateral bank token account. There we go. And that is everything we need for the liquidation. We need to also import this E so liquidation is good to go. We'll go back to our librs and we're going to add our very last instruction for our lending protocol. And that will be liquidate. We'll pull in the context from our liquidate, struct and process liquidate.
02:25:10.755 - 02:26:09.305, Speaker A: And there is our last instruction for our anchor program. So now that we've finished all of our instructions, we just want to update our cargo toml with a few things and then we're going to build our project. So we'll go to our terminal and we're going to cargo ad and we also want the pith SDK from Solana. Okay, and we're just going to Change this to 10.1 for version compatibility. And then we also want to cargo add Solana program, but we're going to want version 18.17, so we'll do 1.18.17.
02:26:09.305 - 02:26:40.905, Speaker A: Now, one last thing. Because we're using anchorspl, we want to update our IDL build to include anchor split. So we'll do anchorling slash. Oh, sorry. We'll do anchorspl/idl build. There we go. If you do not update your IDL build to also include the anchor sbl, your build won't actually build, so you need to include that section.
02:26:40.905 - 02:27:09.845, Speaker A: Now we'll be able to run Anchor build and see if our program compiles. And here we go. You can see everything finished and compiled. Now, up next is writing tests. All right, so for our tests, we're going to be using Bank Run, so we can navigate to our test folder. We can delete the test file that was automatically generated with anchor in it because we're not going to be using it. So move to trash.
02:27:09.845 - 02:27:39.415, Speaker A: Now, with Bank Run, we're going to need to include a fixtures folder inside our test. So we'll do fixtures. And we're going to copy our SO file that was generated when we ran Anchor build. So that was generated in our target folder. So we'll go to target deploylending. So we're going to copy that. Now we'll go into our fixtures and paste it.
02:27:39.415 - 02:28:35.435, Speaker A: Okay, now we can create a file in our test folder for bank run, so we'll do bank run. Spec ts. Now, before we start writing our tests, we want to update our NPM packages. So we'll go to our package JSON, see what we have. So far, our only dependency is coral Anchor, so we're going to have to add a few things to be able to have all of the packages we need to run our tests in TypeScript. First, we're using pith throughout this project for Oracles, so we're going to need to use PITH in our NPM packages as well. So we'll do NPM I@Pith Network Dash and it's the pith Solana receiver.
02:28:35.435 - 02:29:06.955, Speaker A: Okay. Now that's added as a dependency. And this is version 0.8. We're going to do 8.0. Okay, so we're updating all the versions where we know that they're all compatible for dependencies. Up next, we're going to do spl token, so npm spl token. Okay.
02:29:06.955 - 02:29:57.915, Speaker A: And then next is going to be web3js. So we'll do npm I@solana-web3js and then we'll need both Anchor bank run and Solana bank run. So NPMI Anchor bank run And I spelled that wrong. Okay, bank run. There we go. And then Solana bank run. And then because we're using SPL tokens, we'll need SPL token bank run.
02:29:57.915 - 02:30:29.785, Speaker A: So here we're having a dependency conflict. So we're going to update our versions with our dependencies. So for Web3js we should have let's do 1.94. Okay. Anchor bank run is 0.4. Solana bank run, we'll do 0.2. Okay.
02:30:29.785 - 02:31:13.143, Speaker A: Now we should be able to add in SPL token bank run. There we go. So for SPL token bank run we're actually going to do 2.5. And then lastly is our RPC WebSockets. So now all our dependencies have been added to our project, we can go back to our bank run spec and start writing out our text. So the first thing I want to do is get our IDL import done correctly because this gets a little tricky sometimes. So we'll get that out of the way.
02:31:13.143 - 02:31:56.623, Speaker A: So we want to import our IDL from the target file that was generated when we ran anchor build. So we'll do import IDL from and this should come from our target IDL dash and let's see what it's named. So we'll go into our target folder IDL. It's just lending JSON so we'll do lending JSON. Okay, now we want the lending from our types. So we want the typescript compatible type file. So that will be in our lending ts and this is type named lending.
02:31:56.623 - 02:33:10.735, Speaker A: So we'll do import and we want lending from target types lending. Okay. Oh, so now that import is all set for when we're going to need it when we declare our program in our environment setup. So first we're going to set up our environment in bank run. So in bank run it's generating a banks client and a bank server and we want to make sure we have all of the correct programs and accounts that are needed and funded to be able to accurately test a full lending protocol simulation. So we'll do describe and we'll do a lending smart contract test. Okay.
02:33:10.735 - 02:34:18.125, Speaker A: And then async. Now we want to make sure we're using describe and it from node test for this to work properly. So we're going to update our import here to include describe it from not mocha, but we're going to be using node test. Okay. Okay, now that that's set up, we're going to want to start our bank run client and we'll do that by running start anchor. So we'll do context is equal to await start anchor. And then we're going to import this from bank ground.
02:34:18.125 - 02:35:01.525, Speaker A: Okay, and now let's get our argument set up. But first we want to define context. So let context and then the type for context is going to be the program test context. Okay, so with star anchor, it starts a bank run in your anchor workspace with all of the workspace programs deployed. So the first argument here is going to be your path. Since we created our lending so in our fixtures, we can just make our path an empty string. Okay, and then next is going to be all of the programs that you want to deploy.
02:35:01.525 - 02:35:47.175, Speaker A: So we want to deploy our lending program. So we need the name which is lending, and you want to make sure that this name matches whatever your SO file is. If I named this lending project, then this would have to be lending project as well. Next you need the program id. So the program ID is going to come from your idl. So we can do a new public key from IDL address. And you're able to do that because if you go into your idl, you see you have a key value pair of your address.
02:35:47.175 - 02:36:26.873, Speaker A: Now we want to think about additional accounts that need to be passed through. So one account that we're using that we did not initialize within our lending protocol instructions is pith. We're using the price update account from pith, so we need to make sure that that account is also passed through. So this first section is for programs. The next section is for accounts, an array of objects indicating what data to write to the given address. So we're going to set this up for pif. And what you need for an account is the address and the account info.
02:36:26.873 - 02:37:28.129, Speaker A: So we'll set up address and account and info, but we don't have these fields yet, so how do we get them? So you can use the connection to be able to get the account info for a specific account address. So we need to get the PITH account from devnet, and then we can use our devnet connection to get the account info. So we'll first go to Solana FM to get the PITH account address. So if we go to Solana fm, we have the account for the PITH Solana receiver, which is this address. So we're going to copy this address and Write that into our program. So we need a const for pif and that will be a new public key of this program id. Okay, now that we have that, we're going to make a connection to devnet to be able to query this account and get the account info.
02:37:28.129 - 02:38:08.885, Speaker A: So we'll do const devnet connection is equal to we'll do a new connection of the Solana devnet. There we go. And the connection is an Import from Solana Web3js. Now we can use a method on the connection to get the account info. So we'll do cons const account info is equal to await devnet connection. Getaccountinfo of the pith address. So now we have the address so we'll just pull that constant in here and then we also have the info so we'll pull that in as well.
02:38:08.885 - 02:38:59.441, Speaker A: Account info. Okay, and we're missing brackets around here for formatting. Okay, so we have the name lending program ID and we're pulling that from the IDL for the programs that we want to upload on our bank server. And then for the accounts we have the pith address and its corresponding account info. Now that we have that, we're going to set our provider for bank run. So we'll do provider is equal to new bank run provider and that just takes in the context that we defined earlier. And then we're going to make sure we import our bank run provider and then we're going to define our provider.
02:38:59.441 - 02:40:30.593, Speaker A: So we'll do let provider equal a bank run provider. Okay, so now we have our provider. Now let's think everything else we need for our environment setup to be able to test out the lending protocol we're going to need to be able to get the price feed ID and get the real time price of a specific asset. So let's get that set up so we can do const and we need the sole price feed ID and that is equal to we already use this in our constants so we can copy that over. Now we'll need the price feed account so we can do const sol USD price feed account. Now we want to create a pistol on a receiver so we're going to do that with the pith Solana receiver import from pith so we'll do const our pith Solana receiver and we're going to create a new pith Solana receiver. Now we'll import that from pith and then you can see we have to pass through two arguments, the connection and the wallet.
02:40:30.593 - 02:41:35.715, Speaker A: The rest are optional. There's one interesting thing about Bankrupt where it doesn't have a connection natively. So we're going to use a bank run context wrapper that I pulled from GitHub and we're just going to paste that in another file and be able to use some of the methods that are generated there. Let's go back a file and create a new folder for bank run utils and inside that we're going to do bankruptcy TS and what I'm going to do is copy this entire file. The link to the GitHub repo that I pulled this from will be in the bootcamp repo for the Lending Protocol project. So we'll just copy this whole file. And this just allows for a lot of different functions to be used on the bank run connection.
02:41:35.715 - 02:42:42.297, Speaker A: Now we'll go back to our bank run and we'll be able to create a connection with bank run by using this new file that we just imported into our workspace. So we'll go back a few steps to add this in and we'll do the bank run context wrapper is equal to a new bank run context wrapper of the context that we defined. Okay, and then we'll go up here. Bank run context wrapper is a bank run context wrapper type. And you can see the import came from our bank run connection file that we just added. Okay, now that we have that, we can generate a connection. So we'll do const connection is equal to the bank run context wrapper dot connection.
02:42:42.297 - 02:43:16.875, Speaker A: And we're going to do to connection. Okay, now that we have that connection, we can write our first parameter. So this is your connection. Okay, and then we just need the wallet, which is the provider.wallet. and we're going to update that and now we're good to go. So now we have the pistol on a receiver. Now we can use that to get the price feed account.
02:43:16.875 - 02:44:23.999, Speaker A: So we're going to do const sol USD price feed account and that will use the pith solana receiver dot and we'll get price feed account address. And then the first argument is the shard id, which is zero. And then the second is going to be the price feed id, which will use the sole price feed id. Now that we have everything set up here, we have both the account address and the account info. Actually, we don't have the info yet. So let's get that we need const we'll need to generate a public key from this feed account. So we'll do sol USD price feed account just Double check.
02:44:23.999 - 02:45:12.397, Speaker A: Let's see, this is already a public key type, so we don't need to do that. Okay, so we'll just get the account info. So we'll do feed account info and we'll do await. We'll use the DevNet connection to get the account info of the address we just generated from DevNet. So DevNet connection getaccountinfo. And we're getting the account info from this soleUSD pricefeed account. Now we have both the address and the account info for another account that we're going to need deployed onto our bankrun server and client so we can update.
02:45:12.397 - 02:46:00.085, Speaker A: Since we're doing this after SAR anchor, we can actually use set account to add new accounts. So we'll do context and we'll need both the address and the account info, just like we needed earlier. So the address is going to be the sole price feed account and then the info is the feed account info. Okay, now all of our accounts are set up. So next we want to set up our program. So program is equal to new program of type lending. And then we'll do the IDO as lending and then we need the provider.
02:46:00.085 - 02:46:26.019, Speaker A: Okay. And then we're going to define our program here. And then we need to import program. There we go. Up next, we'll need two more things, the banks client and the signer. We're just simplifying things because we're going to be using it a lot throughout the tests. So we're making their own variables.
02:46:26.019 - 02:47:06.265, Speaker A: So banks client is equal to the context banks client. And then the signer is equal to the provider. Wallet payer. Okay, and then we'll define those. And banks client is going to be a bank's client type from bankrupt. And then signer is going to be a key pair because we're signing with it. So we need both the public and private key.
02:47:06.265 - 02:47:25.735, Speaker A: And we'll import that. That should be an import from web3js. Okay. Oh, typo. There we go. Key pair, lowercase P. All right, so let's think about our environment so far.
02:47:25.735 - 02:48:20.061, Speaker A: We have both our lending program deployed. We have the pith accounts deployed. We have the account for our SOL USDC price feed account. Now we need a SPL token for both USCC and sol. So as we mentioned earlier, typically lending protocols will use wrapped SOL here because it is an SPL token type instead of having to use the native system program and LAMP ports to make token transfers. So we're going to generate two arbitrary SPL tokens for testing purposes and be Able to use those as pretend USDC and sol. So we'll do const Mint USDC and we're minting this to make sure that we have the correct authority needed to run our tests.
02:48:20.061 - 02:49:11.353, Speaker A: So we'll create Mint. Okay, and we'll import that wrong import. So where did it go? Great. Mint. Okay, we want to import the createment from the SPL token bank run. So we're going to do import create Mint from and this is going to be SPL token bank run because we want this compatible with our bank run environment. Okay, now let's look at.
02:49:11.353 - 02:49:38.245, Speaker A: Now for createment the first parameter is going to be the banks client and then we'll need the signer. This isn't showing. Hold on. We need to wait for the ID to load. Make sure we have the import in our package. JSON SBL token bank run. Okay, let's just double check everything.
02:49:38.245 - 02:50:10.341, Speaker A: We'll run NPM install make sure we have all of our packages. Okay, I'll go back here. Okay. May just take a little bit longer to load. But for our createment the first argument is going to be the Bings client. The next is going to be the payer which is the signer. Then we need the mint authority.
02:50:10.341 - 02:50:58.915, Speaker A: So the mint authority is going to be the signer's public key. And then we're going to need the freeze authority which we'll set to null and then lastly the decimals which we'll set to two. Now we'll do the same thing but for sol. So we'll do const Mint sol and we'll do await create mint and this will have the same arguments. So we'll just paste that in. Okay, now that that's done, we're going to need a few PDAs so we'll need both the USDC bank account, the sole bank account and the sole token account. So let's start writing those we have.
02:50:58.915 - 02:52:05.195, Speaker A: First up is the USDC bank account. USDC bank account and that is a public key dot find program address sync and we'll do buffer from the treasury. And then for the bank's token account it was the treasury and the mint address key. So we'll do the mint USDC to buffer and then we need the program id. So program dot program. Okay, and we should be using find program address sync because find program address is deprecated. We'll just fix some formatting here.
02:52:05.195 - 02:52:38.435, Speaker A: This should be like that. Okay. And now we'll define the USDC bank account as a public key. There you go. And we're going to do the same thing for the sole bank account. So this is pretty similar formatting but we're going to update the mint to the SOL mint. So mint sol and then we'll define the type up here.
02:52:38.435 - 02:53:09.331, Speaker A: Okay and lastly we need the SOL token account. So we'll do public key find program address sync. We're going to do a buffer from actually that is the sole token account. We did it already, we're just naming it correctly. SOL token account. There we go. So this is our environment set up.
02:53:09.331 - 02:54:11.205, Speaker A: Now we can start with our first test. So we're going to do its will test initializing both the bank and funding the bank. So we'll do test init and fund bank async. So let's define our transaction to init the bank. So we'll do const init and we'll start with the USDC Bank. We'll do await program.methods. a nitbank and then when we initialize the bank it takes in the liquidation threshold and the max ltv.
02:54:11.205 - 02:55:22.527, Speaker A: So we'll do a new bn, we'll set it to one and we'll set the other to one as well. We need to import BN from anchor. Now we need the accounts. So the accounts here are going to be the signer, which is the signer public key and then we'll need the mint and since this is the mint bank we're going to do the mint USDC and then we'll need the token program. So token program is equal to and we'll do the token program ID import from Solana SPL tokens. And lastly we are going to set our RPC with commitment confirmed. Okay now let's console log this transaction.
02:55:22.527 - 02:57:03.905, Speaker A: So we'll do a console log and we'll do create USDC bank account and we'll just log the transaction. Okay, now that we've created it and we have the mint authority on the USDC token that we created, we're going to mint tokens into this account. So let's define the amount that we want to mint Const amount and then we'll define the mint transaction and we'll use Mint 2 which is also going to be coming from the SPL token bank run. So we'll update our import here and then for Mint 2 we're going to pass through the client first and then the signer and then we need the mint address. So we'll do the USDC mint address. So that is oops. And now we'll need the destination which is the USDC bank account and then we'll need the signer and the amount.
02:57:03.905 - 02:57:46.945, Speaker A: Okay, and then we're going to console log that. The next test to write is going to be initializing a user. So let's do it. Test init user. Okay, so now we'll define the transaction there. INIT user TX is equal to await. We'll do program.methods.insiter
02:57:46.945 - 02:58:40.695, Speaker A: and here we're going to pass through the USDC Mint account because that is the argument that it takes in. And then we'll need the accounts and that will just be the signer. Okay, now we need the RPC and now we'll console log that transaction. So we've initialized the user, we've initialized the USDC bank. Now we want to initialize and fund the sole bank as well. So let's do its test init and fun sol bank. Okay, so we'll do the init sol bank transaction.
02:58:40.695 - 02:59:36.355, Speaker A: We want to init the bank. We'll set the liquidation threshold and max ltv we'll set the accounts which will be the signer, the mint is the sole mint and then the token program is the token program id. Then we'll set the rpc. There we go. And now we'll want to console log that and then we want to fund as well. So we'll set the amount and then we'll do the mint transaction and then we'll console log our mint transaction. Okay great.
02:59:36.355 - 03:01:01.395, Speaker A: So now we want to create and fund token accounts for the user. So the user has token accounts to be able to execute, deposit, withdraw, borrow, repay everything they need to do. So it's we're going to create and fund token accounts. Okay so first let's make the USDC account. So USDC token account we'll do await create account and this is also going to be an import from the SPL token from bankruptcy. So we'll update this to have create account. Okay, and now to the create account we're going to need the bank's client, the signer the mint for the USDC and then we need the signer public key.
03:01:01.395 - 03:02:01.665, Speaker A: Okay, now that we have the token account, let's console log that and then we want to fund. So we're going to const amount and then const and we're going to mint USDCTX and we'll do await the same thing we did earlier mint two and we're going to do the bank's client signer, the USDC mint, the USDC token account signer and amount. Okay, there you go clean up some formatting. And now we'll just console log that. Okay, so now everything's set up for us to actually test our four instructions. So let's first test our deposit. So we'll do it test deposit.
03:02:01.665 - 03:03:24.259, Speaker A: So let's define the transaction and we're going to deposit USCC since that was the token account that we funded. So we have those funds to deposit and we'll wait program.methods.deposit. and now we'll define the amount that we want to deposit. So we'll do new BN and we'll just do a large amount. Now we need the accounts, we have the signer, we have the mint and we also have the token program. Okay, now we'll need the RPC commitment confirmed and then we're going to just console log that transaction. Sweet deposit.
03:03:24.259 - 03:03:54.665, Speaker A: Now we have collateral in the protocol. So now we want to borrow against the collateral that we have. So we're going to borrow. We'll do const. Well, we'll define our test first it test borrow. Okay, now we'll define the transaction. So we're going to borrow SOL since we deposited USDC as our collateral.
03:03:54.665 - 03:04:26.215, Speaker A: So borrow SOL program methods borrow. Now we want to take into consideration the liquidation threshold. So we're going to borrow not as much as we deposited. And also SOL is worth more than usdc. So just to be safe, I'm going to just borrow one sol. We'll do new BN of one. Okay, now we need the accounts.
03:04:26.215 - 03:05:17.467, Speaker A: We'll have the signer, we'll have the mint and this will be the SOL mint. We'll have the token program and now we also need the price update account because the borrow function is using the pith oracles and we're going to use the soleusd price feed account. We'll clean up some typos. Okay, there we go. And now we'll just need the RPC and then we'll console log this transaction. Okay, so now we have deposited, we have borrowed. Now we want to be able to repay the loan that we borrowed.
03:05:17.467 - 03:06:20.531, Speaker A: So let's test our repay. We'll define the test and we're going to define the transaction which will be repay SOL because SOL is the asset that we borrowed. So we want to repay the same asset. And we're going to repay and we're going to repay one. Okay, now the accounts that are needed here, we'll do the signer, the mint and the token program and then RPC commitment confirmed. And then we're going to console lock this transaction. Okay, so we've deposited, we've borrowed against that collateral, we've repaid the Lord that we borrowed.
03:06:20.531 - 03:07:32.273, Speaker A: Now all we want to do is withdraw any extra collateral that we have deposited on the protocol. So the next function we're going to test is withdraw. Okay, so we're going to withdraw USDC, let's just withdraw 100 and leave some in the protocol. Okay, so the signer is the public key, the mint is the USDC mint because that is the collateral that we deposited into the protocol. And then we have the RPC and we're console logging that transaction. Okay, so now that we have finished our test, we're just going to run anchor test and make sure everything worked. So we'll do anchor test and then it's going to compile everything, run the test suite and you can see all eight tests have passed.
03:07:32.273 - 03:08:19.811, Speaker A: The suite has passed. And if you want to look at all of your console logs, you can scroll through all of the bank run output in your terminal and now you're good to go. So we have created a lending protocol that allows a user to deposit into a bank and earn interest, withdraw the amounts that they have deposited or borrow against the collateral that they've deposited and also be able to repay their loan. We've also enabled liquidators to be able to come in and liquidate unhealthy accounts. And we tested everything using bankruptcy. All good. In this project, we'll create a decentralized stablecoin that's backed by SOL as collateral.
03:08:19.811 - 03:08:58.613, Speaker A: You can think of this mechanism as allowing depositors to take a loan from themselves against an asset that they own. This program resembles a simplified version of MakerDAO's Dai stablecoin and is adapted from the Foundry DeFi stablecoin projects. Now, what is a stablecoin? A stablecoin is a type of cryptocurrency designed to maintain a stable value often pegged to a real world asset like the US dollar. Our stablecoin will be backed by SOL as collateral. The key components here include minting and burning. Users can mint stablecoins against their collateral and burn them to reclaim collateral. As long as they maintain above a minimum health factor, then you have a price oracle.
03:08:58.613 - 03:09:35.935, Speaker A: We'll use PITH as a decentralized Oracle network to get real time SOL USD price feeds. We'll also have a health factor. Using the price feed, user's collateral value and stablecoins minted, we calculate a health factor for a user's position. If it drops too low, the position may be liquidated. We'll Also have liquidation. If a position becomes under collateralized which is below the minimum health factor, its sole collateral can be liquidated by any user that pays the minted stablecoin. Our decentralized stable coin aims to maintain price stability by requiring an over collateralized position and providing a bonus to liquidators for repaying under collateralized positions.
03:09:35.935 - 03:10:26.525, Speaker A: So let's get started building out our algorithmic stablecoin. For this project, we're going to allow for anyone to be able to create a custom front end. So instead of using the Create Salon ADAP scaffold fold, we're going to be using Anchor knit for our backend and then creating a custom front end that's going to be able to connect to the anchor program. So let's get started with the anchor program. We're going to make a new directory for the stablecoin and then we'll just navigate into that directory and now we can use Anchor net. We'll name this stablecoin. This is going to initialize an anchor workspace for you to be able to create your anchor program.
03:10:26.525 - 03:11:20.065, Speaker A: We'll let this build and then we're going to open the project. Here you can see within our directory we have the stablecoin. We're going to rename this just for convenience, that this is our program side of things or our smart contracts. And then we'll be able to have another folder for the front end. Okay, so in the program you have your librs. So this is just a basic anchor program that initializes and we're going to customize this for our anchor stablecoin. So let's first figure out how we want to design this.
03:11:20.065 - 03:12:03.381, Speaker A: An algorithmic stablecoin maintains its value pegged to another asset. The core mechanism is going to involve adjusting the supply of the stablecoin to respond to market conditions. So we're going to have the goal of one stable coin to be equal to one unit of our reserve token, which we're going to be considering our collateral throughout this project. So we'll need three things. We'll need the stablecoin, we'll need our collateral, and we'll need oracles to be able to understand the current market condition of our collateral. So we'll be able to deposit collateral and mint stable coins, or withdraw collateral and burn stable coins to respond to market conditions. So let's first get organized with our state.
03:12:03.381 - 03:13:01.645, Speaker A: With Solana, all smart contracts are stateless and we're going to store our state within accounts. So for this project we're going to need two states we're going to have a config of the overall stablecoin and we're also going to want to keep track of the collateral. So let's write out the account states for both of those. Since this is going to involve a lot of different instructions, we're going to break up our program outside of just the librs and individually write all the instructions. So inside our source, let's make a new file for state and we'll do state rs and this is where we'll keep track of all the accounts that hold state. So we'll first import anchor into this file. Now let's define our first account state.
03:13:01.645 - 03:14:02.801, Speaker A: For this one we're going to define the collateral. So let's do derive init space and debug and then we'll define the struct. So this will be our collateral structure. So what do we want in our collateral state? Well, first we want to keep track of who the depositor is. So let's save our depositor address and that will be a public key type. And now we need an account that's going to hold the sol, which is our reserve token. So we'll do a SOL account and that will also be a public key type.
03:14:02.801 - 03:14:34.061, Speaker A: So this will be a PDA of the collateral account that allows you to deposit sol. Now we also need a token account for the stablecoin. So let's make this an associated token account. We'll just do token account will also be a PUB key type. So we're going to want to be able to calculate health factor throughout this and allow for accounts to be able to be liquidated based on their current health factor. So to be able to calculate the health factor, we're going to have to keep track of the Lamport balance of each account. So we'll keep track of that.
03:14:34.061 - 03:15:25.731, Speaker A: Here we'll do Lamport balance And that's a U64 type. And we'll also want to keep track of the amount of tokens minted. So amount minted is a U64 as well. And then as always, we need to save the bump. So we'll save the bump for our collateral account and the bump for the sole account, which is a U8 type. And then we're just going to keep track of if the account has been initialized or not. This is just to prevent open overwriting of certain fields.
03:15:25.731 - 03:16:15.265, Speaker A: So we'll do is initialized and that'll just be a boolean. So that should be our collateral account if we need to save anything else as we're working through this, we can go back and add it. So now we'll go to the config account. So the next account we want to keep track of is our config account and that's going to hold all of the global information of the overall stable coin. So let's do once again derive init space and debug for our account and we'll do the config struct. Now first we need to know who the authority is. And this is going to be the overall authority of the entire stablecoin that has certain permissions so pub authority, which will be a public key because that is the wallet address of the authority.
03:16:15.265 - 03:16:59.355, Speaker A: We also want to keep track of the mint address. So this is going to be the mint account of the stablecoin which is also a public key. Now to be able to declare if an account is healthy or not, we're going to have global factors for liquidation and that's going to be applied to each collateral account to understand if it's healthy or needs to be liquidated. So these factors are going to be first the liquidation threshold. So let's keep track of that. And that just determines how much extra collateral is required. Liquidation threshold, which is a U64 type.
03:16:59.355 - 03:17:37.625, Speaker A: And now we'll need the liquidation bonus. So what this is, it's a, it's a percent of bonus lamp ports is going to be sent to the liquidator as a bonus for processing the liquidation of an unhealthy account. And that's a U64 as well. And we spelled liquidation wrong. So let's fix that. Okay, and next is a minimum health factor. So if your health factor is below this minimum value, then it's saying that the collateral account can be liquidated.
03:17:37.625 - 03:18:20.725, Speaker A: So minimum health factor. And then lastly we need to save the bump. So we'll save the bump for both the config account and the stablecoin mint account pda. So next we're going to start writing our instructions for the overall program. And first we want to be able to get these two accounts initialized. So let's initialize our config and we'll go to source. And now we're going to make a new folder that's just going to be for instructions and each instruction is going to live in here.
03:18:20.725 - 03:18:45.495, Speaker A: Now in this we're also going to separate the instructions a little bit more. So let's first just focus on the admin side of the stablecoin. So we'll make another folder for admin. Okay. Now within this folder. Let's initialize our config. So I'll make a file for initialize config.
03:18:45.495 - 03:19:59.835, Speaker A: Okay, so we'll start with use anchor. Okay, and now we're going to write the instruction for processing initializing our config. So we'll do PubFM process initialize config. So as always, the first parameter that needs to be passed through is going to be your context. So let's define that and we'll just set up the whole function, return our OK at the end, and we'll come back for the logic. So let's now define what our initialize config struct is going to look like. So this is always going to be using the derive account attribute, and then we'll define our struct.
03:19:59.835 - 03:20:52.545, Speaker A: Okay, so this is going to state every account that is needed to be able to run the process initialize config instruction. So first we need the signer, because that's who is going to be signing the instruction. And we'll just define that with the account. And it should be mutable because we're going to be initializing, so they're going to be paying rent and the signer here is going to be the authority. So we'll just name the signer the authority. Now let's initialize our config account so we can use the account attribute. Use the init constraint.
03:20:52.545 - 03:21:45.407, Speaker A: Now whenever you're initializing, you need a payer who's going to be paying rent, and that will be the authority, which is the signer of the instruction. Now we always have to calculate space when we're initializing a new account because it's going to be taking up space on chain. So we can calculate space with a knit space, since we use the knit space when defining our account here. So space, we'll start with our eight discriminator and then just add in from the config struct a net space. And now we're going to just define the seeds. So we're going to have a lot of PDAs throughout this workspace and we're going to have to be referencing the PDAs a lot. So you're going to have to memorize all of the seeds for each PDA to be able to derive them.
03:21:45.407 - 03:22:35.349, Speaker A: So to make things easy, we're going to make a constant file to just keep track of everything in one space, and you can pull those constants in whenever you need to derive a specific pda. So let's make a new file in our source folder and name that constants. We'll use anchor once again. And now let's just do pub const and we'll do seed for the config account. Okay, and this is going to be U8. Okay. And we'll just set the seed for the config, just config to make things easy.
03:22:35.349 - 03:23:07.045, Speaker A: So B config account, actually, we'll just make it config. Okay. Now, since it's in another file, we have to be able to import it correctly. So we're going to use crate and do seed config account. And we're also going to need to pull in the config from our state file. And now we can just simply set our seeds to seed config account. Okay.
03:23:07.045 - 03:23:51.035, Speaker A: And lastly, since we defined our seeds, we need a bump, and now we just need to name this account. So we'll do pubconfig account and that will be an account with a lifetime specifier and the config struct. Okay, so now we have this config account, and we also need to think about what else needs to be initialized when you're creating the full algorithmic stablecoin project. And what we need is a Mint account for this tablecoin. So we can actually mint an account through this initialize config. And we can do that by using the Mint constraint within the account macro for anchor. So we're just going to define the account here.
03:23:51.035 - 03:25:01.527, Speaker A: And since we're initializing, we need to use the init constraint we're initializing. So we once again need the payer that will be the authority which is the signer of this instruction. And then we'll also define seeds for this account. So we'll go back to our constants and make a seed for our Mint account and we'll just name this Mint. So we can just set the seeds the same and we'll import that with the use crate. Now we want to initialize the Mint account. So when we're configuring the new Mint account, we want to use the Mint constraints to define how it's graded, who pays for it, how it's addressed.
03:25:01.527 - 03:25:40.473, Speaker A: So let's just set first the Mint decimals. Oh, actually we did the seeds, so we need to define the bump. So let's write that before we forget. Okay, so we initialize, we define the pair, we define the seeds in the bump. Now we can create the mint. So we'll do mint, define the decimals, and let's also make a constant for this because we'll be needing to use the mint decimals throughout the workspace. And we'll set that to nine.
03:25:40.473 - 03:26:12.655, Speaker A: Go back to the initialize, config, and then we're going to import the mint decimals. Okay. And then we'll just set the mint decimals to the constant we just created. Okay, now we need the authority, and we're just going to set that to itself here. So it'll be. The authority is going to be whatever we name this mint account. So we're going to name it just Mint account for simplicity.
03:26:12.655 - 03:26:26.705, Speaker A: Okay. And I need the freeze authority, which is also going to be the mint account. And we need the token program.
03:26:29.605 - 03:26:29.893, Speaker B: Which.
03:26:29.909 - 03:26:51.615, Speaker A: We'Ll have to define as an account within the initialize, config, struct. So token program. Token program. Okay, so since we used Mint account here, we need to make sure we name the mint account to the same. So pub. Mint account. And this is going to be an interface account.
03:26:51.615 - 03:27:50.153, Speaker A: And now because we specified the token program for the mint, we need to pass through the token program account. And lastly, because we are initializing new accounts here, we need to pass through the system program. Now, we're using a few things from additional crates that we have yet to add to our cargo tunnel. So let's update our crates. Before we go any farther in writing the code, let's look at what we have so far in our cargo tunnel. And that's just anchor lang. So we're also going to want anchors po.
03:27:50.153 - 03:28:23.135, Speaker A: We'll just do cargo ab, anchor spl. Oh, we have to CD in the correct directory. So because the entire anchor workspace is in this programs file, we're going to CD into program. And now we can run cargo adjust. Okay, so our anchor spl was added. And now because we added an spl, we have to update the IDL build. So we'll do anchor lang.
03:28:23.135 - 03:29:07.663, Speaker A: Sorry, we'll do anchor spl and then IDL build. And now while we're here, there's one more thing that we're going to have to add, and that's going to be our pith Solana receiver. And this is for our oracles. So we're going to be needing to use an oracle to understand the current market price of our assets. And we're going to be using pith as our oracle for this project. So while we're here, let's just cargo add our pith Solana receiver SDK. Okay.
03:29:07.663 - 03:29:21.159, Speaker A: Okay. So it looks like we have an error in our state. Let's just fix that before we move on. We're Just missing a colon. Little typo. And as you can see, everything here is a little bit grayed out. That's because it's not in our librs file.
03:29:21.159 - 03:30:22.545, Speaker A: When we're using multiple files in our source file, we're going to have to make sure we import everything. We have our mod files correctly written. So let's first start with updating our lib to use the state. We'll do use state. Now, if you go back to the state file, you can see it's no longer grayed out and we correctly had an import for this into our librs and we'll do the same for our constants. Okay, and then let's set up our mod files in our instructions folder just to have everything set up for the future. So we'll do a file and instructions for modr s.
03:30:22.545 - 03:31:20.245, Speaker A: And so far we've created an admin folder, so let's use admin. Okay, and then we need one more inside our admin folder. So we'll do a modrs here and we'll do pub use initialize config, which is the file we just created. Okay, and then one more update. We have our instructions file, so we're going to make sure that that's being used in our libraries. As well. So we'll do use instructions and mod instructions.
03:31:20.245 - 03:32:23.545, Speaker A: Okay, so now that we have all of our mod files set up correctly for this file path, now you can see everything is properly loading into our initialize config file. Okay, now one last thing we have to do is make sure we have all the correct imports for our SBL token. So you can see here the mint is missing an import, so we're just going to import that. So we'll use anchor STL and this is from the token interface and we want them in. Okay, so let's review everything we have so far and then we can start writing the logic for our process initialize config instruction. So for our initialize config, we have our signer, which is going to the authority of the overall stablecoin project. We have our config account, which is going to store all of the state needed for the general config of the stablecoin.
03:32:23.545 - 03:32:59.257, Speaker A: We have our mint account, which is being initialized when processing this instruction. And then the mint account is using the token program, and we actually need to specify what token program we're using. So we're going to use token 2022 for this and let's import that with our mint. Okay, and because we're using token 2022. This is a program, okay, so we have the token program and we have the system program. And the system program is needed because we're initializing new accounts with this instruction. Okay.
03:32:59.257 - 03:33:47.325, Speaker A: All the account initialization takes place with these constraints that we pass with our account macros in our initialize config struct. All we really have to do within the logic for process initialize config is save all the information we want to the state of the config account. Let's do that. We're going to load in our context accounts config account and we're just dereferencing that. So the first field of our config struct is the authority. Let's fill that in. The authority is going to just be.
03:33:47.325 - 03:34:23.293, Speaker A: We can load in the signer from the context accounts. So we'll do CTX accounts authority and that'll bring in the public key of the authority. Now we want the mint account. And since that's an account passed through our initialized config struct, we can just pull that in as well. So CTX accounts mint account key. Now we need the liquidation threshold bonus and minimum health factor. And these are all values that will be constant throughout the entire algorithmic stablecoin.
03:34:23.293 - 03:35:02.153, Speaker A: We could do two things. We could have this as an argument that's being passed through, that's a user input value. Or for simplicity, we can just save this as constants to our workspace. So let's save this as constants to our workspace. If you want this more configurable for future use, you can set this as arguments to be passed through. So let's do the liquidation threshold and we're going to make this a constant. So we'll go back to our constants and we're going to set the liquidation threshold to 50.
03:35:02.153 - 03:35:44.331, Speaker A: So what this means is that it's 200% over collateralized. Now we're going to set the liquidation bonus and we'll set that to 10. So what that means is that you have a 10% bonus. Lamports when liquidating an account. Now we'll set the minimum health factor and we'll set that to 1. So anytime your health factor falls below 1, an account can be liquidated. Now we're going to import all of these and we have a typo with liquidation.
03:35:44.331 - 03:37:06.345, Speaker A: We'll fix that. Okay, now what we have left is the bump for the collateral account and the bump for the mint account. So we'll do bump and we can just grab that from context, bump, dot and then the account that we want. So we'll do config account and it's bumps with an S actually. There we go. And then the bump for the mint account. Okay, so that's everything we need to initialize the config.
03:37:06.345 - 03:38:14.593, Speaker A: Now all we need to do is take this instruction and pull it into our librs. So we'll go to the librs and we're going to delete the initialize instruction that came with our anchor initial and we're going to write our new instruction, which is just initialize config and we're passing through the context. Okay. And all we can do is just pull in the function that we wrote from the other file. So process, initialize, config and we're passing through the context, and we don't need the drive accounts that came with our preset. We can just delete that. And then we're going to clean up our initialize config file.
03:38:14.593 - 03:38:46.045, Speaker A: And it looks like we had a strange import, so we're just going to get rid of that. All right, and now we're good to go. So we're going to finish up all of the admin functions. And one more thing that we're going to want to do is allow an admin to be able to update the config. So let's make a new file for update config. So this is going to be a lot smaller because we're not initializing anything. We're just updating an account that already exists.
03:38:46.045 - 03:39:23.275, Speaker A: So we're going to use anchor to start the file. Now we want to go and update our mod file. So we'll do pub use update config Mod update config. Okay, now we can start with our derive accounts. So what accounts do we need to be able to update the config of the config account? All we need is the config account. So it'll be a really short struct. We'll just do struct update config with your lifetime specifier.
03:39:23.275 - 03:40:03.749, Speaker A: And then we're going to specify the account. So we'll do account. And now we have to make it mutable because we're updating the state of the account. So we have to define this as mutable. And then we need to be able to have the seeds and the bump because it's a pda. So seeds. And since we save the seeds as a constant, we can just load in the constant and we don't have to remember what the seeds are so seed from the config account and then because we're defining the seeds, we need the bump and since we saved the bump to the account state, we can just pull that in.
03:40:03.749 - 03:40:59.605, Speaker A: So config account and then we're going to name this account and that's all we need. So let's make sure we have the right imports. We're going to use Crate and we want both the config and the seed config account. Now let's just write our instruction. So PubFM, we want to process update config and the context. We're going to pass through the data structure that we just wrote. So we'll do update config.
03:40:59.605 - 03:42:12.985, Speaker A: We want to return our results. Okay, so now what are we really updating for our case? The only thing that we're going to need to update in the config account state is the minimum health factor to be able to test liquidation. You can allow for this to be more configurable by updating more parts of the state, but we're just going to update the minimum health factor for our use case. So since we want to update it, we need to pass through as an argument the new minimum health factor that we want to update to and then we're going to load in our config account from the context. So we'll do let config account equal and we'll do a mutable reference to the account and that's our config account. And now all we're doing is updating the minimum health factor to the new minimum health factor that's being passed through. And then we can just return our okay, and we're good to go.
03:42:12.985 - 03:42:53.463, Speaker A: Okay, now we're just going to take this function and pass it through our LIBRs. So we'll update our librs to have another instruction. So we'll do PUBFN update config, pass through the context and this will be the update config context. We're going to pass through the minimum health factor and then we're just going to pull in the process update config function that we just wrote in our other file and then pass through the two arguments that we we need. And that's everything we need for the admin section. So we can just review our files. They all look good to go.
03:42:53.463 - 03:43:37.421, Speaker A: We updated our mod file and our update config. So now because we want to adjust the supply of the stablecoin to respond to changes in market conditions, we're doing two main actions, deposit and mint. And burn and withdraw. So let's focus on the deposit section. First we're going to make a new folder in our instructions for deposit. Now we need the mod file for our deposit folder. Okay, and now we're going to make a file for the instruction that we want to write which is deposit, collateral and mint tokens.
03:43:37.421 - 03:44:41.525, Speaker A: So we'll do new file and name that. Okay, so now we'll write the instruction for deposit, collateral and mint tokens. And let's start with the struct for our context. So we're going to use anchor and then we're going to derive accounts to define our struct. Okay, so we'll just name this deposit, collateral and mint tokens. Add our lifetime specifier. Now let's go back, make sure we have our mod file updated.
03:44:41.525 - 03:45:17.085, Speaker A: We want to use the file we just created and then mod for the file we just created. And then we're going to update. Since we created a new folder for deposit, we're going to go back one for the instructions and we're going to update the mod there. So we'll do pub use deposit and mod deposit. Okay, so now let's define all of the accounts that we need for our deposit, collateral and mint tokens instruction. So first we're going to start with the sign early instruction and that is going to be the depositor in this case. So we'll name that.
03:45:17.085 - 03:45:56.861, Speaker A: We're going to need the config account to be able to access the global config for the stablecoin. So let's pass that through as well. Now we're going to have to define the seeds here. Since it's a PDA and because we saved this as a constant, we can just pull in the constant for the seed config account. We define the seed. So we need a bump and the bump was saved to the config account. So we can just pull that in.
03:45:56.861 - 03:46:26.435, Speaker A: And now we want to do one constraint check and we want to make sure that this config account has the correct mint account. So we're going to just do a check has one equals mint account. And we'll have to pass through the mint account as an account in the struct as well. Now we'll do pub connect config account. There we go. And now we want to update all of our imports. So we want the crate for the seed config account constant.
03:46:26.435 - 03:47:00.805, Speaker A: We want to import the config as well. So we're just going to add that. And now we're getting an error here under the mint account because we haven't stated that account yet. So now let's actually go and write that next. Okay, so now we want to be able to keep track of the collateral. So we want to load in the collateral account so we can update the state as needed. So let's add that as the next account.
03:47:00.805 - 03:47:37.185, Speaker A: Now here the collateral account will be specific for the user. So we're actually going to want to use INIT if needed because we're not sure if the user has a collateral account or not. So we're going to have to update our create. So let's do cargo ad. We already have anchor lang, but we need to make sure we have this feature for an if needed. So. So we'll do anchor lang features init if needed.
03:47:37.185 - 03:48:23.085, Speaker A: And what this does is it just checks if the account is already initialized. If it is, it's going to ignore that constraint and continue with the rest of the logic. If it's not, then it's going to initialize the account. So we'll do INIT if needed. And then because we're potentially initializing, we need a payer and the payer is going to be the depositor. In this case, we need to define the space if we're initializing. So we'll do space is equal to the eight discriminator plus we're going to load in the collateral, struct for the account and then use initial space.
03:48:23.085 - 03:48:59.307, Speaker A: Okay, now we just need to define the seeds and in this case we're going to use the seeds for the collateral account. But we also want to specify that this is for a specific user. So we're going to add in the depositor key. Okay, now where you need the bump since it's a seed. And then we're just going to define the account. So collateral account. Okay, now let's update our imports.
03:48:59.307 - 03:49:32.443, Speaker A: We'll import the mint and that's going to come from token interface. So we'll do anchors pl, token interface, mint. And now we also want the seed collateral account imported, which we haven't defined yet. So let's go back to our constants and define our seedcollateral account. And we'll just make that collateral. Okay, now it can be imported. Now we need to also import collateral from our state file.
03:49:32.443 - 03:50:00.685, Speaker A: And now we have an error under collateral account. And that's because we're potentially initializing a new account on chain. So we need to pass through the system program to do that. So we'll just add in the system program there and let that Error go away. Okay, so now let's think, what are we doing here? We're depositing collateral, we're minting tokens. So we need accounts that are going to be holding those tokens. So for our deposit collateral we need a SOL account that's going to have tokens to be able to send.
03:50:00.685 - 03:50:39.953, Speaker A: We're also going to need a token account to be able to hold stablecoin tokens. So let's add both of those accounts. We'll do account. It's going to have to be mutable because we're going to be transferring tokens, so we need to be able to change the state. And then we'll need to define the seeds for this. So we'll do seeds for a SOL account and let's go back to our constants and define what that is. Okay.
03:50:39.953 - 03:51:20.565, Speaker A: And we'll just name that soul and then we'll update our import here. There we go. And then because this is user specific, we're also going to want to add the depositor's key into the pda. So we'll do depositor key as a ref. And because we have seeds, we need the bump. Okay, now we can just define this for the SOL account. And since this is just holding lamp ports, it's going to be a system account.
03:51:20.565 - 03:52:08.855, Speaker A: There we go. And now we need the associated token account for the mint of the stablecoin. So we'll add that. And here we're going to use a knit if needed as well because we're not sure if this depositor actually has an associated token account for the SPL token mint that we need. So we'll add in accounts and we'll do a knit if needed. And the reason we didn't need to do an if needed for the SOL account is because the depositor is depositing sol so you know that they have the sole account. And then because we're potentially initializing, we need a payer and that payer is going to be the depositor.
03:52:08.855 - 03:52:53.455, Speaker A: And then this is an associated token account. So we're going to use the associated token constraint for this account. So for the associated token we need to specify the mint and the mint is just going to be, we can pull from the mint account that we already defined earlier. And then we'll do the authority and the authority is going to the depositor and then we also need the token program. So associated token, token program. And then we'll just pass through the token program as an account as well. Okay, so now let's define this account and this is just a token account.
03:52:53.455 - 03:53:38.591, Speaker A: And since we're using interface tokens here, this will be an interface account. Token account. Now, because we have the token program here for the associated token, let's pass through the token program as an account. Okay, so we'll do program and then to stay consistent, we're going to be using token 2022 throughout this workspace. So token 2022. Okay. And then because this is an associated token account, we also need to pass through the associated token program.
03:53:38.591 - 03:54:51.085, Speaker A: So pub. Associated token program, this is a program and then associated token. Okay, and then we'll update our imports. So this is coming from the token interface, and then token 2022 is coming from the token interface as well. Okay. Okay, so let's review what we have so far. So we have the signer, which is the depositor, we have the config account which is holding all of the global config information for the algorithmic stablecoin, we have the mint account, which is the mint of the stablecoin.
03:54:51.085 - 03:55:33.705, Speaker A: We have the collateral account, which is holding all of the collateral information for this specific depositor. We have the SOL account, which is the SOL from this depositor. And then the associated token account for the stablecoin, we have the token program, associated program, associated token program, and system program. Okay, so there's one more thing that we're going to need here, and that is our Oracle. Because when we're depositing collateral and we're minting tokens, we want to be able to calculate the new health factor and that's dependent on the current market value of these tokens. We can figure that out by using the Oracle. So we're going to do price update.
03:55:33.705 - 03:56:04.435, Speaker A: And this is an account, we'll use the lifetime specifier. And this we're going to use price update v2 from PIF. Okay. And then we'll want to import that from the pistol on our receiver SDK. Okay, so you can see. Oh, I went back too far. Hold on, let me just re import this.
03:56:04.435 - 03:56:36.847, Speaker A: There you go. Okay, so you can see we have an error here under the derive accounts and it's saying that there is an owner field not satisfied. And that's actually because when we wrote the mint, we're using the wrong account. So we're using interface, we're using token interface for the rest of our tokens throughout this struct. And here we're just using an account. So we want to update this to interface account. Okay, and now the error goes away.
03:56:36.847 - 03:57:00.725, Speaker A: And then there's one more update. We're going to want to make to the struct. We're going to use a box around the config account. And what this does, it's just a smart pointer used for heap allocation. So it'll just help manage this data structure. So now everything's good to go for all of the accounts that we need to sign the instruction to deposit collateral and mint tokens. Now let's start writing the logic help.
03:57:00.725 - 03:58:04.857, Speaker A: We'll go down here and write PUBFN process, deposit collateral and mint tokens. Okay, so we'll first pass through the context which is the struct that we just defined above. And now we're going to need two additional arguments. So it's going to be the amount of collateral that you want to deposit and the amount of tokens that you want to mint. So those are going to be two U64 types. Okay. And then we'll just get our result and then we'll return our okay at the end and then go back and write our logic.
03:58:04.857 - 03:58:32.625, Speaker A: Okay. Okay. So now let's first pull in the collateral account so we can update the account state based on the amount of collateral that we are depositing and the amount of tokens that we're minting. So we'll first do let's collateral account equal. We'll run a. Sorry, not run. We'll have a mutable reference and we'll pull in the collateral account.
03:58:32.625 - 03:59:13.055, Speaker A: Now we're going to update the land port balance and the amount of tokens that are minted. So we'll do collateral account dot landport balance is equal to. And we're going to gather the amount of land ports in the sole account. So you can do that by loading in the account from the context. So we'll do CTX accounts SOL account and then you can just grab the lamports. And then we're also going to add in the amount of collateral to that because. Because that's how many lamp ports we are depositing.
03:59:13.055 - 03:59:44.555, Speaker A: Okay. And now we want to update the amount minted. So we're going to add the amount to mint to the amount minted in the collateral account. So we know for the collateral account we use a knit if needed. So this account could be initialized or not if it hasn't been initialized yet and we're initializing it. When running this instruction, we want to update all of the information in the state to initialize the account. So we're going to first check to see if the account was initialized.
03:59:44.555 - 04:00:36.615, Speaker A: So we'll do if the collateral account was not initialized. So if the Boolean is still false, we're going to update to true and then we're going to set all of the fields in the state. So we'll set the depositor and that is going to be the key from the depositor account. Okay. And then we want to set what the sole account is and that will just be the key of the sole account. Okay. We also want to set the token account and that'll just be the key of the token account.
04:00:36.615 - 04:01:24.657, Speaker A: And then we want to set the bump of the collateral account and the bump of the sole account. So now we have the state initialized if the collateral count hasn't been initialized yet. Now there's three things that we're going to have to do when we're running this instruction. We want to first check the health factor. Then we want to be able to deposit soul, and then we also want to be able to mint tokens. So let's actually take this logic out. We're going to extract it into another file and then pull those functions in.
04:01:24.657 - 04:02:05.505, Speaker A: So we're going to go back to the deposit file and we'll make a utils file. So here we'll use anchor. We want to update our mod file. Okay, now let's first think about the utils that are related only to deposit. Because when we're checking the health factor, we're going to have to do that with withdrawal as well. So we're actually going to extract that one level farther. So let's first focus on deposit and to deposit we need to be able to mint tokens and deposit soul.
04:02:05.505 - 04:03:22.095, Speaker A: So let's first write the function to mint tokens. Okay, so how do we mint. We're going to use Mint 2 from Anchor SPL, so we can import that. So from Anchor SPL we're going to use token 2020 and the Mint to function. So you can see this function takes two arguments. The arguments are the CPI context. So we're going to first write out what our CPI context is.
04:03:22.095 - 04:03:57.875, Speaker A: And now when we mint tokens, it's coming from the mint account. So if you remember when we created our mint account, it has a pda. So we're actually going to have to use our signer seeds here to be able to sign the cpi. So we can do that with new with signer. And we're going to have to define what those signer seats are. So let's go back up here and define what our signer is. So let sign our seeds.
04:03:57.875 - 04:04:37.061, Speaker A: And now we're going to explicitly define the type because it's a little complicated of what the type is for signer seeds. So it is three references. So we have 1, 2, 3 and then a U8. Okay, so we can write that with just reference, reference. And we're going to import the seed for the mint account. So we'll import the crate. Okay.
04:04:37.061 - 04:05:10.913, Speaker A: And then for the signer seeds, we also need the bump. So let's state the bump and we'll just pass the bump through as a parameter since we have the bump in our deposit collateral and mint tokens function. So we can just pass that through this function as an argument. So we'll do bump, which is a U8 type. Okay. Oh, put that in the wrong spot. We'll fix the formatting.
04:05:10.913 - 04:05:56.725, Speaker A: Okay, so bump is a U8 type. Okay, so those are assigner seeds. So now we need for the CPI context, this takes in three arguments. So first we're going to need the program, we can define that. So we'll do the token program to account info. Since we have the token program in our instruction, we can pass that through as an argument. So this will just be token program and it will be of type program.
04:05:56.725 - 04:06:30.495, Speaker A: And we're using token 2022 here. Okay, so we want to import token 2022. So there's our program. Now we need the accounts. So we're actually going to use the Mint 2 struct. Okay, so Mint 2, we need to pass through the mint, the to and the authority. So the mint is going to be the mint account and we have the mint account in our instructions.
04:06:30.495 - 04:06:55.495, Speaker A: So we can just pass that through as an argument as well. So we'll add that here. Mint count. Now this is an interface account. We'll do the lifetime specifier and then the mint type. And we're going to have to update our import to have mints. So we'll import mint and the mint is coming from token interface.
04:06:55.495 - 04:07:20.685, Speaker A: So right here. So now we can just define our mint as the mint account that's being passed through. So we'll do mint account to account info. We'll need our two fields. So we're minting tokens from the mint account to the token account for the user. So this is their associated token account. So we can also pass that through since we have that in the instruction.
04:07:20.685 - 04:07:46.895, Speaker A: So we'll do token account. And this is an interface account. Token account, we need to update our import with token account. And that is coming from token interface. So for two, that will just be our token account to account info. And then lastly we need our authority. So when we created the MINT account, from our initialize config instruction, we specify that the mint account authority is itself.
04:07:46.895 - 04:08:36.025, Speaker A: So here we're just going to put the authority as the mint account. Okay, great. And then lastly, we need to just pass our signer seeds through. Okay, and we'll update the import to include Mint 2. And Mint 2 is coming from token 2022. Okay, and now let's see, we're missing one more parameter from the Mint 2 that we imported, and that is the amount. So we're just going to add in the amount of tokens that we want to mint.
04:08:36.025 - 04:09:29.851, Speaker A: And since we're gathering that from the instruction as well, we can just pass that through as an argument. So amount is going to be a U64 type, and then we'll put amounts here for how many tokens we want to mint. Okay, so there's our function to be able to mint tokens. Now the last thing we need for the deposit section is being able to deposit sol. So let's write a function to deposit soul. We'll do pub FM deposit sol. Okay, so when we deposit sol, we're not minting and burning tokens.
04:09:29.851 - 04:09:55.225, Speaker A: We're just making a transfer from sole account into another account. So this is actually just going to be a CPI for a transfer. So we can import transfer. And that is going to be a. With the CPI context. And here it's not a pda. So we don't need to do new assigner, we can just do new.
04:09:55.225 - 04:10:33.045, Speaker A: We'll define the program. And since we're just transferring lamports, it's going to be the system program. And we have the system program because we're passing it through as an account in our context for our instruction. So we can just add that as an argument here. Your system program, it's going to be a program system. Okay, so the program here is just system program to account info. And now we need the transfer.
04:10:33.045 - 04:11:23.945, Speaker A: So here we just need the transfer and the transfer is from into. So from is going to be the account that we'll pass through. So from will be the signer because we're depositing from the signer into an account. And then we'll have two is going to be a system account because it is the account holding sol. Okay, so from we'll just do from to account info and then to we'll do the same. And then we need to update our import to include transfer. And this transfer is going to be coming from the system program.
04:11:23.945 - 04:11:48.723, Speaker A: So anchor link, system program transfer and we also want to update this import for transfer. And this will also come from the system program. Okay. And we're just going to clean up these imports because VS code did it a little funny. So let's get rid of this. There we go. And then lastly, for the transfer, just like for Mint 2, we need to specify how much.
04:11:48.723 - 04:12:24.135, Speaker A: So in this case it will be LAMP ports. So we'll just do amount and we're going to pass through the amount as an argument for this function. So amount will also be a U64 type. And there's our function to deposit SOL. Okay, so let's pull those two functions back into our deposit collateral mint tokens instruction. So we can just very easily import deposit sol. So we'll update our crate to use deposit soul.
04:12:24.135 - 04:13:01.985, Speaker A: Okay, and then we'll just update the parameters that are needed. So it's from to system program and amount. So the SOL is going to be coming from the depositor. So we'll load in the context accounts.depositor it's going to be going to the sole account. So we'll load that account in as well. So contacts dot account.
04:13:01.985 - 04:13:42.535, Speaker A: And then the system program is the account that we passed through already in our context. So we can just load that in so context accounts dot system program. And then lastly is the amount and the amount is the amount of collateral that's being passed through this instruction. Okay, so that's everything we need for deposit sol. And since this is a function, we're going to unwrap it. So now that we deposited, we're going to be able to mint. So we'll import our mint tokens function and we're going to update our imports here to use the crate for mint tokens.
04:13:42.535 - 04:14:19.179, Speaker A: Okay, so this function takes in. Let's hover over and see. It takes the mint account, the token account, the token program, the amount, and the bump. Okay, so let's pass that all through. So we'll load in the mint account, the token account, the token program. And now the amount is the amount to mint that was passed through as an argument for this instruction. And then lastly is the bump.
04:14:19.179 - 04:15:03.153, Speaker A: But this bump is the bump for the mint account. So we're going to update what copilot suggested and we want to load in the context accounts. And we saved the mint account bump into our config account. So we can just pull in the config account and grab the bump for the mint account. Okay, there we go. And we unwrap that function. Now the only thing we have left to do for this instruction is checking the health factor before we actually deposit and mint tokens.
04:15:03.153 - 04:16:06.553, Speaker A: So we're going to back up a little bit and create a util for all of the instructions that allow checking the health factor. So in our instructions folder we'll make a new file for utils. We're going to update our modrs. Now we'll go back to the util file and we're going to use anchor. So let's first calculate the health factor. So we'll do PUBFN calculate health factor. And for this to be able to calculate the health factor, we need the collateral to understand how much soul is deposited, how many tokens have been minted.
04:16:06.553 - 04:17:04.795, Speaker A: We also need the config account to be able to get the global config information, which includes things like the liquidation threshold and the minimum health factor. And we also need the price feed from our pith oracle to be able to get real time price data for each asset. So first let's pass through collateral and this will be an account for collateral. Now we'll pass through the config account, which is also an account for config. And then we're going to pass through the price feed. This is also an account and this is coming from the pith price feed update. So price Update, we're using V2 in this project.
04:17:04.795 - 04:17:44.049, Speaker A: Okay? And then our result here is going to be a U64 type because we want the value of the health factor to be returned. Now we need to update our imports. So we need collateral, we need the configuration and then we also need the price update V2. And this is coming from the Pith Solana receiver SDK. So now we're going to make the calculations for the health factor. And essentially at a high level, the health factor is just going to be your collateral adjusted for the liquidation threshold divided by the amount minted. But we're going to have to do a little bit of conversions before doing that.
04:17:44.049 - 04:18:19.645, Speaker A: So first we want to get our collateral value in USD. So to do that we're going to want to understand the sole price in USD. And to get that we're going to need the pith oracle. So let's first define this variable. So, collateral value in USD. Okay, just for simplicity, we're going to make this a separate function so it's more readable. So we're going to do get USD value and write this underneath.
04:18:19.645 - 04:19:50.637, Speaker A: So all you need to be able to get your USD value is the land port balance of the collateral account, which is how much sol you have and you need the price feed for sol from the pith oracle. So we'll use that as the two arguments for this function. So it'll be from the collateral account, we need the Lamport balance, and then we also need the price feed. And now we're going to unwrap that. So let's go down here underneath this function and write another one to get the USD value. So as we just explained, we're passing through the amount in Lamports, which is a U64 value, and we're passing through the price feed, which is an account of the price update v2. Okay, we're going to delete what Copilot just suggested.
04:19:50.637 - 04:20:31.885, Speaker A: So we're returning a result of a U64 because this is a collateral value, so It'll be a U64 type. First we need the feed ID. So let's feed ID equal. And you can use this function that comes from pith. So to get the feed id, we're going to have to import a hex value and then we can use a function from pif to get the feed ID from the hex that we import. So let's first import this function from pith. It's just get feed ID from hex.
04:20:31.885 - 04:20:57.005, Speaker A: Okay, now we'll want to update the import here. So this is coming from the Solana pith receiver price update. And we'll just add in this function. So it's get feed ID from hex. There we go. Now we'll need to update the parameters here. So this function takes one argument and that is going to be the feed id.
04:20:57.005 - 04:21:46.331, Speaker A: So let's go to our constants and figure out what this ID is for our pith price oracle. So we'll go back to constants, we're going to add in the feed id. And this is just an feed ID STR is equal to. Okay, now let's get this ID so you can go on the pith website and we can go here. So Price Feed IDs are all listed on the pith website. We're going to click on the dropdown menu and find Solana stable. And now we want the price feed ID for Sol.
04:21:46.331 - 04:22:19.575, Speaker A: So you can see here for soleusd, this is the price feed. So let's copy this over and we're going to save that into our constants. Okay, we'll go back to our editor and paste that in. Okay, and there's your feed id. So we'll go back to utils and we can import the feed ID here and then we'll unwrap that. And now we can take this feed ID and calculate the price. So we can use another function from pif.
04:22:19.575 - 04:22:36.295, Speaker A: So we'll do let price is equal to and we'll do the price feed and we'll do get price.
04:22:38.955 - 04:22:39.323, Speaker B: And we.
04:22:39.339 - 04:23:18.085, Speaker A: Want to do no older than and this is just making sure that you're not getting a stale price. So no older than. Okay. And we can do clock get to get the current time. And now we need a maximum age. So let's set this as a constant as well. We'll go back to our constants.
04:23:18.085 - 04:23:44.675, Speaker A: Pub const maximum age. This will be a U64 type and we'll just set this to 100. So what this is saying is it's allowing the price feed to go up to 100 seconds old. After that it becomes stale. So we'll do 100. And we want to update our import. So we're going to use the crate for the maximum age.
04:23:44.675 - 04:24:13.983, Speaker A: Okay. And then lastly we need the feed id so we just got the feed ID and now we'll just want to reference it. Okay. And then we'll unwrap this and there's our price. So now we'll implement a little bit of error handling. We're going to want to make sure that the price is a positive value before we start running calculations with the price. So we're going to use require and we'll take the price.
04:24:13.983 - 04:24:52.705, Speaker A: And now the price is a price type. So let's actually take a look at what the price type is. So the price is a struct and it has the price, the column for the exponent and the publish time. So we just want the actual price. So we're going to do price.price to get the price value and we want to make sure that this is above zero. Okay.
04:24:52.705 - 04:25:51.865, Speaker A: And if it's not, we're going to return a custom error and that will be invalid price. Now this is the first error we've written so far in our workspace. So we're going to actually create a file for all of the errors that we're going to be writing. So let's go back to our source folder and we're going to make a new file for error rs. Okay, now we're going to use anchor and then we're going to use the error codes and we'll make an enum of custom errors. Pub enum custom error. Okay, and now we're going to take the error that we just wrote, which is invalid price, and set that in our custom error code.
04:25:51.865 - 04:26:23.159, Speaker A: Enum and then we just want to define the message. Okay. And now as you can see, this is grayed out. So we need to update our modrs to be able to recognize this error file. So we'll go to library Pub. We'll just use error mod error. And now we want to use the crate for the customer.
04:26:23.159 - 04:26:52.325, Speaker A: So let's import that. Okay, good to go. Okay, so to be able to get the price in USD we have to take into consideration that we're using lamp ports here. So we want to use a Lamport adjustment. So let's do, let's price in USD. We're going to take the price from the price struct. We're going to cast as a U128 for precision.
04:26:52.325 - 04:27:55.769, Speaker A: And now we want to multiply by the decimal adjustment. So let's go back to our constants and we're going to define what this adjustment is. So we'll do price feed decimal adjustment. So this is a U128 type and this adjustment is just going to be 10 because the price feed returns 10 to the 8th and we want to multiply by 10 to reach Lamports which is 10 to the 9th. Okay, so we'll go back to our utils and we're just going to multiply by this constant. And then we have our import was updated. Okay.
04:27:55.769 - 04:28:41.209, Speaker A: Okay, so now we have the price in USD and we want to be able to calculate the amount in USD. So this is just converting from our land ports to our sole value. So we'll do let amount in USD. We'll dereference amount in Lamports cast as a 128 for precision. We're going to multiply by the price in USD and then we want to divide by how many land ports per sol. So this is another constant. Okay.
04:28:41.209 - 04:29:02.375, Speaker A: And that'll be cast as a U120 as well. And then we updated our import for land ports per sol. So now that's our USD value. So now we can just return that and we're going to cast as a U64. Okay. Okay. So now that we have this function, we can go back to calculating the health factor.
04:29:02.375 - 04:29:57.435, Speaker A: So we now have the collateral value in USD and we're using the getusd value that we just calculated. Now we want to adjust the collateral value for the liquidation threshold. So all we're doing is multiplying by the liquidation threshold. And this just requires over collateralization. So let's collateral adjusted for liquidation threshold equal and we'll just take collateral value in USD multiple by the liquidation threshold that is saved to the config state. So and I can see I have a typo here. So let's fix config, okay? And then you want to divide by 100 because it is a percentage.
04:29:57.435 - 04:30:58.633, Speaker A: So now to get the health factor, it's the collateral adjusted for the liquidation threshold divided by the amount minted. But we want to make sure that we're taking into consideration divide by zero errors. So there is potential that someone has an account with zero amount minted. So let's check that first. So we'll do if collateral dot amount minted is zero, we're going to return and we'll just print the message of health factor max. Okay? And we'll return the max value. Okay.
04:30:58.633 - 04:31:49.683, Speaker A: Now if it's not a zero, we're going to calculate the health factor by dividing. So we'll do let health factor equal and it will be the collateral adjusted for the liquidation threshold divided by the amount minted. And then we can just return the health factor. Okay, so now we calculated the health factor. So now we have the health factor, but what do we do with it? So we're going to make a function to check the health factor to see if an account is healthy or not. So one last function here in our utils, we're going to do pubfn check health factor. And this is going to take in the same thing as calculating the health factor.
04:31:49.683 - 04:32:05.785, Speaker A: We need the collateral rule. Let's actually just copy it to make it easier. Okay. We'll return the result. We're going to delete what copilot suggested. Oops. There you go.
04:32:05.785 - 04:32:47.685, Speaker A: Okay, so all we're doing is loading in the health factor. So the health factor is calculated with the function we just wrote. Okay. And now we want to require that the health factor is above the minimum health factor. So require health factor is greater than or equal to config dot minimum health factor. Okay. And we're able to just load this in from the config state because we saved this earlier when we were initializing the config account.
04:32:47.685 - 04:33:40.037, Speaker A: And if it's not, then we're going to return a custom error that you are below the minimum health factor. Okay. And then we're just going to return okay, and now we have to update our custom error enum to include this new error that we just row and we'll add a message and we spelled calculate wrong here. So let's just fix that. Lots of typos. All right, so these are all the utils we need to be able to calculate the health factor. Now we can just take this and import to our deposit function.
04:33:40.037 - 04:34:15.985, Speaker A: Okay, so we want to be able to calculate the health factor before we actually execute the deposit and minting tokens. So we'll add this function here and we'll do check health factor and then we'll make sure that we import. So we'll use crate check health factor. Okay, and now we're going to check the parameters here. So it takes in the collateral, the config, and the price feed. So we'll update those arguments. Okay, so the config account.
04:34:15.985 - 04:34:47.559, Speaker A: Okay, copilot did this a little backwards, so let's fix that. It's first the collateral account. Okay. Then it's the config account, and then it's the price update. And then we'll just unwrap that. And that is everything we need for depositing collateral and minting tokens. So now we can take this instruction and pull that into our LIBRs.
04:34:47.559 - 04:35:31.235, Speaker A: We'll go back to the librs and we'll make a function for deposit collateral and mint tokens. And this takes in the context, it takes in the amount of collateral, the amount submit, and it's using the function that we just wrote here. Okay, just a recap of what we've done. We've initialized the config, created our config account, our collateral accounts. We've added the instruction to be able to update the configuration. We've created an instruction to deposit collateral and mint tokens. So now what do we have left? We need to be able to withdraw collateral and burn tokens.
04:35:31.235 - 04:36:07.225, Speaker A: So do the reverse of what we just did. So let's make another folder for withdrawal. Since we're making a new folder, we're going to need another moderates. Now we're going to need a file for withdrawal. So we'll do. We're redeeming collateral and we're burning tokens. All right, so we're going to use anchor.
04:36:07.225 - 04:37:02.044, Speaker A: Now let's first define the struct for our context. So here it's going to be very similar to our previous struct because we'll need almost the same accounts. So let's do derive accounts. We'll name our struct, redeem collateral, and burn tokens. Okay, so the first account we're going to pass through is the signer, and this will be the depositor because they are redeeming collateral that they've deposited already. We'll make this mutable, so this will be a signer. Okay.
04:37:02.044 - 04:38:13.564, Speaker A: Now just like for deposit we need to be able to calculate the current price of these assets. So we're going to pass through our price update and that will be the price update v2 from Pith. So let's update our imports to make sure it has that. So we want to use the pith Solana receiver and then price update v2. Now we're going to need both the config account and the collateral account from the depositor so we can load in the account for config. And this since it's a pda, we need to define the seeds and we'll just take the seed config account that we've already saved to our constant and then we also need the bump and the bump was saved to the config account. So we'll just pull that.
04:38:13.564 - 04:38:48.975, Speaker A: And then lastly, we want to make sure that this config account is using the correct mint address. So we're going to add a constraint to verify that. So we're going to do has one mint account. So now we'll define this. This is the config account. This is an account type. So now we'll also need the collateral account.
04:38:48.975 - 04:39:26.715, Speaker A: The collateral account we're going to need to make mutable because we're going to be updating state changes. So we'll do mute. And then we'll also need the seeds because it's a PDA and this is the same as the collateral account that we use for deposit. So it's both the seeds of the collateral account and the depositor's public key. So we'll add seed for collateral account and then we'll do depository key as ref. Okay. And because we did the seeds, we need a bump and the bump is saved to the collateral account.
04:39:26.715 - 04:40:10.175, Speaker A: And then we're going to do two checks on the collateral account. We want to make sure the collateral account has both the same sole account that's being passed through the struct and the same token account that's being passed through the struct. So let's add those two constraints. So has one equal to we'll do the sole account and then has one token account. Now because we're using this constraint, we need to make sure we're passing through both the sol account and the token account in the struct for it to be able to reference it. So we'll finish defining the collateral account and then we want to update our import since we use these constants. So we're going to use crate.
04:40:10.175 - 04:40:44.983, Speaker A: There we go. And now you can see some things aren't fully loading. And that is because we need to update our mod file. So let's go back to our mod and make sure we have everything properly updated. So Pub use. We want to use the redeem collateral and mint tokens file we just created. Sorry, we're burning tokens, not minting and burn tokens.
04:40:44.983 - 04:41:19.515, Speaker A: And then mod. Okay, and then we also want to update. We're going to go back one file and we want to update our mod file in the instructions to use the withdrawal folder that we just created. Okay, so now everything's updating and returning proper errors that we want to see as we're typing this code out. Okay. And you can see these errors because this constraint needs to have all of these accounts passed through to be able to do the check. It's notifying you that we haven't passed these accounts through the struct yet.
04:41:19.515 - 04:41:59.835, Speaker A: So we're going to do that before we finish. Okay, so we have a collateral account. So next let's do the SOL account and the sole account because it's Lamports, it's actually a system account. Okay, and now we need the Mint account. And both of these accounts are mutable because the balance of the accounts are going to be changing. And the Mint account is an interface account with the Mint. And now we need the token account, which is also an interface account.
04:41:59.835 - 04:42:42.577, Speaker A: Okay, and then lastly we need the token program and the system program, so we'll pass those through. And the token program, we're using token 2022 here. Now we just need to update our imports. So we have the mint, and the mint is coming from token interface. We have the token account, which is also coming from Token Interface and Token 2022. Okay, and now let's just update our imports. We accidentally imported the seed for the SOL account, which we don't need here.
04:42:42.577 - 04:43:27.499, Speaker A: Okay, so this is all of the accounts we need for this struct. Now we can go on and write the instruction. So, pubfn, we want to process redeem collateral and burn tokens. Okay. As always, with an anchor instruction, we want to pass through the context first. And this is the redeem collateral and burn token struct that we just defined above. Okay, great.
04:43:27.499 - 04:44:33.085, Speaker A: And now just like the previous instruction, we want to know how much collateral and we also want to know how much to burn. So we'll pass those two values through as well. So amount of collateral, which is a U64 and then amount to burn, which is also a U64. Okay. All right, now let's start writing the Logic out. So first thing we want to do is update the state in our collateral account, reflecting the tokens that we want to burn and the tokens we want to redeem. So we'll load in our collateral account and then we're going to update the collateral account, land port balance.
04:44:33.085 - 04:45:26.151, Speaker A: So we'll grab the lamp ports from the SOL account. So context accounts, SOL account. And then we're going to subtract the amount of collateral that we specified. And now we just want to update the amount minted. So we'll do collateral count, amount minted, and we're just subtracting the amount to burn that was specified. Okay, now just like the last instruction, we want to be able to check the health factor. So we're just going to import the same instruction that we wrote earlier.
04:45:26.151 - 04:46:11.735, Speaker A: So we'll do check health factor. Let's import the health factor so we can see all the arguments that are required. We're going to update from our crate. We want to check health factor. Okay, now that that's updated, we can hover over this. So the first account is collateral, then config, then price feed. So and CTX accounts, collateral account.
04:46:11.735 - 04:46:33.091, Speaker A: Okay, and then we want the config account, and then we want the price update for the price feed. And then we'll just unwrap this. And this should be commas, not semicolons. Let's just fix our typos. All right, there we go. So there's our first check for the health factor. So we have two more functions that we want.
04:46:33.091 - 04:47:02.875, Speaker A: We want to be able to burn tokens and then also withdraw soul. So we're going to write those functions in another utils file, just like we did for deposit. So we'll go back to our withdrawal and we're going to make a new file and this will be utils. We're going to update our mod file to reflect that. So we want PUB use utils and then mod utils. Okay, now I'll go back to our utils. We're going to use anchor.
04:47:02.875 - 04:47:56.317, Speaker A: Okay, now let's write the function for withdrawing soul. So PUBFN withdrawals, we need our lifetime specifier here. So now we're withdrawing SOL from the SOL account to the depositor. And since we're making a transfer from the SOL account, we define the solo account earlier as a pda. So we're going to need the signer seeds for the solo account to be able to process the transfer. So let's first define the signer seeds. We'll explicitly define this type.
04:47:56.317 - 04:48:50.155, Speaker A: Okay. Now we're going to reference, okay, so this will be the seed for the SOL account and then also the depositor key. Okay, and then we need the bump. So since we have the bump in our instruction, we're going to pass that through as an argument here. So we'll go back up to our function definition and add in the bump, which is a U8 type. Okay, instead of passing through the entire depositor account here, we're just going to take the depositor key because we have that in our previous instruction. So let's do a depositor key which is a public key.
04:48:50.155 - 04:49:09.995, Speaker A: And this we can just update to the depositor key as rough. There we go. And now we need to update our imports. So we want. Okay, this was a weird import. We're going to just delete that. And now we want to use the crate for the seed soul account.
04:49:09.995 - 04:49:37.127, Speaker A: Okay, now that we have our signer seeds, we can actually write our transfer function. So we're going to import the transfer. And that is coming from import transfer. And because we're transferring soul, it's coming from the system program. So we'll do system program transfer. There we go. And you can see the arguments that this takes in.
04:49:37.127 - 04:50:19.863, Speaker A: So first we need the CPI context. Let's define that. And since we're signing with this pda, we need new with signer. Okay, so the program is going to be the system program because we are transferring SOL or LAMP boards actually. So the system program we've passed through as an account for the withdrawal instruction. So we're just going to pass that through this function. So it's a system program program.
04:50:19.863 - 04:50:50.001, Speaker A: There you go. And then we'll just convert this to account info. Okay, now we can define our transfer. We'll import this struct from the system program. So we'll add in transfer crap. And now we just need to define from and to. So from we can pass through this account.
04:50:50.001 - 04:51:43.235, Speaker A: So this is going to be from the system account and this is going to account info. Because our transfer is coming from the SOL account and going into the depositor account. So from we'll do from to account info and then to we'll do the same. There you go. Now since we are using the CPI context with signer, we need to specify the signer seeds. So that will come right after defining the transfer. And then lastly, we need the amount of LAMP ports that we're going to transfer.
04:51:43.235 - 04:52:17.405, Speaker A: So we'll pass through the amounts into this function. And that is a U64 type. Okay, and there's our Withdrawal function. So we did withdraw. Now we need to be able to burn. So the next function is going to be burning tokens. So pubfn burn tokens.
04:52:17.405 - 04:53:52.325, Speaker A: Okay, so here we can just use burn and because we're burning the stablecoin token, which is a token 2022 token, we're going to import this from token 2022. So import anchorsbl token 2022 burn. And now since the mint account is its own authority and we're not signing with PDAs here, we don't need to define the signer seats so we can just use the CPI context New and first we need the program and since this is for the mint account, we're going to use the token program. So let's pull the token program from the instruction since we're passing that through our context for the redeem collateral and burn tokens instruction. So we'll add that to be passed through here. Token program. And this is a program of token 2022.
04:53:52.325 - 04:54:48.957, Speaker A: Now we need to update our import to include this. Okay, so now we'll just do token program to account info. Okay and next we just need burn. So let's update our import to include burn and actually let's fix this import because our token 2022 should come from the token interface. There we go. Okay, so for our burn we just have the mint, the from and the authority. So our mint is going to be the mint account that's being passed through.
04:54:48.957 - 04:55:25.995, Speaker A: We already passed this through our struct for our context so we can just pull that in. So we'll do mint account and this is an interface account and we'll do info and then token account. Okay, and we want to make sure we're using the token account. So this didn't import from token and we don't want that. We want the import to come from token interface. So we'll update this to token account. There we go.
04:55:25.995 - 04:56:11.185, Speaker A: Okay, so the first field is mint and we'll do our mint account to account info. The next field is from and this is coming from the token account. So we're going to add in the token account that we passed through here. And this is an interface account for token account. And sorry, the mint account is not a token account, it's a mint. So let's fix that and then update the import for mint. There we go.
04:56:11.185 - 04:57:17.975, Speaker A: Okay, so from and this is the token account to account info and then lastly is the authority and then we're going to pass through the authority here and that is actually the signer of the Instruction and now we just need to specify the amount of tokens to burn. So we can just write amounts and we'll pass through the amount into the function. Okay, so that's everything we need for burn tokens. Now we can take these two functions, pull them into our redeem collateral and burn tokens. Instruction and we're good to go. So we check the health factor. So next we want to burn tokens.
04:57:17.975 - 04:57:53.865, Speaker A: Let's make sure we import this. So we'll update our crate, okay. And we'll check the arguments that we need which is the token program, mint account, token account authority and amount. So let's update that. Let's make sure copilot did this correctly. We have token program first. Then we have the mint account.
04:57:53.865 - 04:58:33.095, Speaker A: Then we have the token account. We have the authority which in this case is the depositor. And then we have the amount to burn. Okay, great. And then we unwrap that and now we're good to withdraw soul. So last function we want to import here is withdraw sol and we'll update our imports withdrawals. And now let's see, we're going to pass through the bump the depositor key the system program from an amazing to an amount.
04:58:33.095 - 04:58:57.521, Speaker A: So first we're going to get the bump and the bump was saved into the collateral count. So we'll do context.accounts.collateralaccount. and we want the bump for the sole account. So bump sole account. There we go. Okay, up next we have bump. We have the depositor key is next.
04:58:57.521 - 04:59:25.845, Speaker A: So we're going to do context accounts depositor key. Okay. And then we have the system program. So we'll do accounts system program. And then we have the from account. So the from account is the sole account. And then we have the to account which is going to the depositor.
04:59:25.845 - 04:59:54.239, Speaker A: So we're going to do accounts depositor and we want to account info. Okay. And then lastly is the amount which is the amount of collateral. And then we'll just unwrap this. Okay. And there's our function. So now we're going to take this function that we just wrote will indoor librs and define the instruction that we want for our program.
04:59:54.239 - 05:00:32.819, Speaker A: So we'll go back to the librs. And now we have pubfn redeem collateral and burn tokens. We're passing through the context for redeem collateral. We're passing through the amount of collateral and the amount to burn and then we're pulling in the process redeem collateral and burn tokens function that we just wrote in this file here. Okay. And then we're just going to clean up a few things and looks like we're good to go for that. So before we do anything else, let's just make sure everything builds.
05:00:32.819 - 05:01:08.253, Speaker A: So we're going to run anchor build here and make sure we have all of our instructions written correctly and everything compiles. Okay. So you can see all of our code compiled and everything built for our program. So now that our code compiled, we're just going to go over everything we have so far as instructions in our program. We have initializing and updating our config and then depositing collateral, minting tokens, redeeming collateral, and burning tokens. So this is pretty much the main logic needed for an algorithmic stablecoin. There's one step that we're missing and that is the ability to liquidate accountability.
05:01:08.253 - 05:02:02.281, Speaker A: So if a collateral account becomes unhealthy, meaning the health factor falls below one, there needs to be an ability for a liquidator to come in and liquidate the accounts. So we're going to write the logic for liquidations. We'll add a file in our withdrawal folder for liquidate and then update the mod file. Okay, we'll go back to our liquidate file. We're going to use anchor. And now let's think about everything needed to liquidate. So first we're going to work through all of the accounts needed because we're going to define the struct for our context and that is going to process all the accounts needed to run the instruction.
05:02:02.281 - 05:03:27.987, Speaker A: So let's do as always, our derive accounts and then we'll name our struct liquidate. Okay, so the first account we're going to pass through this struct is going to be the signer of the instruction, and in this case it's going to be the liquidator. So we'll need an account for the liquidator and that is the signer. Now we're going to need the price update from PITH to be able to calculate the current price of the asset. So we'll do pub price update and that will be the price update v2 from Pith. So let's update our imports. That's coming from the pistol on our receiver SDK.
05:03:27.987 - 05:04:10.175, Speaker A: And now we'll need the config account to be able to pull information like the minimum health factor we'll add in the account. And since this is a pda, we need to define the seeds and we can just pull the seed for the connection config account from our constants. And then since we're stating the seeds, we need the bump and that we saved to the config account, so we can just load that in. And then next we're going to do one more check. And this is the same check that we've been doing. And it's just making sure the config account is using the right Mint account. So we're going to do has one and make sure we have the correct Mint account.
05:04:10.175 - 05:04:37.421, Speaker A: Okay, and then we'll just name this account. So, config account. And now we'll update our imports. So we need our seed config account constant. So we'll use the crate for that. We'll need to also pull in the config. And then the error for the Mint account is that we haven't passed the Mint account through the struct yet, which we'll do later.
05:04:37.421 - 05:05:29.485, Speaker A: All right, so next we'll need the collateral account. And this is to be able to get all the information for the specific account that we want to liquidate. So we'll add in accounts. It's going to be mutable because we're going to be changing the account. And then we want to make sure it has the sole account. And this is our collateral count and we'll have to import collateral. Okay, and then this error is just like the error above, meaning that we need to pass through the solo account for it to have an account to verify against.
05:05:29.485 - 05:06:12.285, Speaker A: Okay, so let's pass through the SOL account. And since the Sol account is holding lamports, it's just a system account. And then we'll need the Mint account as well. So you can see, once we pass through the SOL account, this error went away. And once we pass through the Mint account, the other error should go away as well. And the Mint account is an interface account with Mint. And we just have to import Mint.
05:06:12.285 - 05:06:48.215, Speaker A: And Mint is coming from the token interface. Okay, now we need the token account from the liquidator, so we'll pass that through. This will be mutable and it is an associated token. And the mint is going to be the same as the Mint account. The authority is the liquidator. And then we need the token program, and that will pass through after this. Okay, so token account.
05:06:48.215 - 05:07:16.633, Speaker A: And now we need the token program, which is token 2022. And then we need the system program. Okay, and then we'll update our imports. So for token interface, which is here, we're going to also need token 2022 and token account. Okay, there is an error in our account. So it looks like we did some account Type in correct. So let's fix that.
05:07:16.633 - 05:08:12.429, Speaker A: So right here, the token account, it's an interface account, not just an account. And there you go. So that's our struct that we'll need for our context for this instruction. Now let's write the instruction. So we have PUBFM process, liquidate. We'll pass through our context, make sure we don't have any typos. We'll fix that.
05:08:12.429 - 05:08:54.055, Speaker A: Okay. And now we're going to allow the liquidator to specify the amount that they want to burn. So we'll add that as an argument as well. Okay. Now before we allow the liquidation to process, we're going to want to make sure that the account is unhealthy and able to be liquidated. So the first thing we want to do is check the health factor. So we're going to check the health factor just like we did in the other instructions.
05:08:54.055 - 05:09:33.571, Speaker A: So let health factor equal. And we're going to calculate the health factor. And we want to import the health factor calculation function from our crate, which automatically happened. Okay, so now let's see. We need to pass through the collateral account, config account and price feed. So let's add that. Now we need first the collateral account.
05:09:33.571 - 05:09:52.381, Speaker A: So CTX collateral account. Okay, config account and price update. And then we're just going to unwrap that. Great. So now we know what the health factor is. Now we want to run a check of the health factor. So we're going to require that the health factor is below the minimum health factor.
05:09:52.381 - 05:10:41.127, Speaker A: If not, we want to return an error and let the liquidator know that they cannot liquidate the account. So require oops. And we want health factor to be less than. And we're going to load in the minimum health factor from the config account. Okay. And if it's not, we're going to return a custom error and it will be that it is above the minimum health factor. And then we're going to update our custom error.
05:10:41.127 - 05:11:20.083, Speaker A: So first let's import import the custom error enum. We're going to go to our error file and include the above minimum health factor error. So error RS we're going to paste in the custom error we just created and we're going to define the message. We'll say cannot liquidate a healthy account. There you go. And we'll fix our typo. There you go.
05:11:20.083 - 05:11:49.525, Speaker A: Okay, so back to our liquidate file. So we did our check for the health factor. If the account's healthy, it's going to return an Error. If not, we're going to go ahead and process the liquidation. So we're passing through the amount that we want to burn in its USD value. So now we need to be able able to get lamp ports from USD to be able to use the lamp ports to calculate how much we want to liquidate. So before we actually process our liquidation, let's create a function to be able to get lamp ports from USD.
05:11:49.525 - 05:12:18.807, Speaker A: So we have our lamp ports, which is what we need. And we want to write a function to get Lamports from USD. So let's define that in our utils. We'll go back to our utils file where we were checking the health factor. And here we have getting Sorry. And here we have getting a USD value. So we're going to do something kind of similar.
05:12:18.807 - 05:13:03.357, Speaker A: We'll do get Lamports from USD and this is going to take in the amount in USD. So kind of the opposite of what we were doing above, and that is a U64. And then we need the price feed. And then our result is going to be in a U64 because we want the value of lamports. Okay. First we need the price. So we can actually take the same logic from above.
05:13:03.357 - 05:13:29.811, Speaker A: We're getting the feed ID and then we're calculating the price all from pith so we can pull that in. Okay, and now we'll do the same check. We want to make sure that the price is above zero. And now we're going to get the price in USD. And it looks like copilot may have figured this out. So let's accept their suggestions and take a look. So we have the price in USD.
05:13:29.811 - 05:14:00.117, Speaker A: We're taking the price from the price struct, casting as a U128 and then multiplying by the price fiat decimal adjustment. Okay, now that we have that, we want to get the amount in lamp ports. So we're taking the amount in USD casting as a 128 for precision. We're going to multiply by land ports per sol and then divide by the price in USD. Okay, and then we return the amount in land ports. Great. So that's everything we need there.
05:14:00.117 - 05:14:38.855, Speaker A: And now we'll go back to our liquidate function. We'll make sure that we're importing the get land ports from USD. Okay, and now we're going to check what we need to pass through. So this function takes two arguments and it's the amount in USD and the price feed. So the amount in USD is the amount to burn, and then the price feed we can just pull from the price update account. There we go. And now that we have the lamp ports, we want to calculate what the liquidation bonus is that's going to be sent to the liquidator.
05:14:38.855 - 05:15:20.273, Speaker A: So let liquidation bonus. So this is going to be the Lamports times the liquidation bonus, which we save to the config account state. So we'll pull that in CTX accounts.config account liquidation bonus. And now I want to divide by 100 because the liquidation bonus is a percentage. Okay. Now we want to calculate the amount to liquidate.
05:15:20.273 - 05:16:13.455, Speaker A: So the amount to liquidate is the lamp ports that we're liquidating from the account as well as the liquidation bonus that's going back to the liquidator. So the amount to liquidate is equal to Lamports plus the liquidation bonus. So now that we have that, we're going to be able to process our liquidation. So when we're liquidating, we want to be able to withdraw SOL from the account. We want to be able to burn tokens and then just update the collateral account state. So let's first withdraw the solution and then we'll update the import for withdrawal sol. Okay.
05:16:13.455 - 05:17:06.525, Speaker A: And this takes in the bump depositor key system program from to an amount. Okay, so we'll do the context accounts. We save the bump for the SOL account to the collateral account state so we can load in the collateral accounts and then get the bump for the SOL account. And then next is the depositor key. So we can just do contacts accounts dot and we saved the depositor to the collateral account. So we'll load in the collateral account again and then grab the depositor key that we saved. Okay.
05:17:06.525 - 05:17:44.265, Speaker A: And then up next is the system program. So we can just pull that from the accounts CTX account system program. And then next is from. So from it's coming from the sole account. So we'll load in the sole account and then to it's going to the liquidator. So we can just do CTX accounts.liquidator to account info.
05:17:44.265 - 05:18:43.085, Speaker A: Okay. And then we need the amount which is the amount to liquidate. And then we can just unwrap this. And now I withdrew the soul from the collateral account. So up next is just burning tokens. So we're going to burn tokens and we're going to update the import for burn tokens. So the first thing we're going to pass through is the token program and then the mint account and then the token account.
05:18:43.085 - 05:19:41.451, Speaker A: And the authority is going to be the liquidator in this case and then the amount is just the amount to burn. Okay. So now that the account has been liquidated, we're going to update the collateral account state to reflect these changes so we can load in the collateral account, take a mutable reference, and then we're just going to update both the land port balance and the amount minted in the collateral account state. So collateral account lamport balance is. Let's change this a bit. It's just going to be the accounts.sol account.
05:19:41.451 - 05:20:10.319, Speaker A: Lamp ports. And we're taking the lamp ports directly because we're taking the lamports directly because the liquidation already occurred. So we're taking the current amount of land ports in the SOL account. Okay. And then next is the amount minted and we're just going to subtract by the amount to burn. Okay. You can add an additional check for the health factor after the liquidation occurred, just to log the new health factor to verify that it's healthy.
05:20:10.319 - 05:21:06.455, Speaker A: It's not needed for the liquidation to process, but we're just going to do it to be able to have that log. So we'll do a calculate health factor and it's going to be the collateral account. So CTX accounts collateral count and then the config account and then the price update. Okay. And that is everything we need for the liquidation. So now we can go back to our libraries and then add our final instruction for our program. So librs and we can do pub FN liquidate.
05:21:06.455 - 05:21:32.305, Speaker A: And we're going to take in the liquidate context the amount to burn. And then we're going to use the process liquidate function that we just wrote in our previous file. We'll save that now. Everything looks good to go. So all that's left is to test out everything that we've written so far in our program and make sure that our sample coin works. So let's build our program. We're going to run anchor build.
05:21:32.305 - 05:22:15.857, Speaker A: And what this is doing, it's making sure everything compiles, but it's also updating our target folder. So if you go into target, you can see you have the idl, you have these types, which is an IDL that is in camel case format. So it's compatible with TypeScript. You have a few other things like the so of your program. So this is updating your target with the latest version of your program. Now that we have that, we're going to be able to update our TypeScript tests. So we're going to navigate to test and we're going to go to stablecoin TS and let's start writing our tests.
05:22:15.857 - 05:23:10.451, Speaker A: So the first thing we want to do for our test is to set up our environment properly. Let's see, we have our provider. So we're just going to change the way that everything is configured currently. So we're going to first make a const for our provider, and that is an anchor. We'll use anchor provider env and then we want the connection. So const connection. And we're going to need the connection because we want to be able to use pif and a connection is needed to be able to import pith into your environment here.
05:23:10.451 - 05:23:57.521, Speaker A: So connection, we're going to do provider dot connection and then we need a wallet. So const wallet is your provider wallet, but we want this as an anchor wallet. Okay, now we can do anchorsetprovider and we'll just set the provider with the provider. So we have our program and then it's the anchor workspace for the stablecoin. And this is as the program of type stablecoin. And this is the type file that has been generated for the anchor idl. So to be able to use the pith Solana receiver in our typescript files, we're going to have to update some of our NPM packages.
05:23:57.521 - 05:24:53.069, Speaker A: So first we're going to NPM install and we need the pith network price service client. So let's grab that. So here is the NPM package for the pistol on our receiver SDK. So we're just going to install this and we'll go back to our VS code and we'll run NPM install. Okay? So from this NPM package, we can generate a new pistol on our receiver. And we're going to do that with const pith Solana receiver. And this will be a new pith Solana receiver.
05:24:53.069 - 05:25:27.925, Speaker A: Okay? And we want to import this from the package we just installed. So add import from pith network. Okay? And then this takes in we want the connection, which is why we defined that earlier. And we also want the wallet. The rest of these fields are optional, so we're not going to add those. We just need the connection and the wallet. Okay, now that we have the Solana receiver, we want to be able to use our price feed.
05:25:27.925 - 05:26:39.667, Speaker A: So for our testing purposes, we're using the soleusd price feed. So we're going to go back to our constants and take that price feed value. Okay, we'll go back to our typescript test and we're going to create a constant in typescript. This Time for our price feed. So we'll do SOL price feed ID and we'll paste in the price feed that we just copied from the other file. Okay, now that we have that, we're going to be able to get the soleusd price feed account. So we can just do const SOL USD price feed account and we'll take the pistol on a receiver that we just created and we're going to get the price feed account address.
05:26:39.667 - 05:27:15.587, Speaker A: So get price feed account address and we'll take in first the shard id which is just zero, and then it's going to take in the price feed ID which we just defined above. And somehow I deleted that. So let's fix that. Okay. We're just formatting everything. There we go. Okay, so now we're able to get the SOL USD price feed account address.
05:27:15.587 - 05:28:09.157, Speaker A: And now that we have that, we have pretty much everything set up for environment and then we can start doing tests. There's one last thing that we need, and that's to derive the PDA for a collateral account. So we'll do const collateral account. And this is we're going to use anchor web3 dot public key and then find program address sync. And this is going to find the address from the pda. So we'll do buffer from and our collateral account was defined as collateral. And then we also used the public key of the depositor into the collateral account.
05:28:09.157 - 05:28:52.205, Speaker A: So we're going to do wallet public key to buffer and then all we have left is the program id. Okay, now I think we have everything defined for our environment. We have our program, we have PIF set up correctly for our soleusd price feed and we have the account address for our collateral account. Okay, so let's start writing our first test and that's going to be initializing our config so we can delete what was preset here. And we're just going to write our transaction. So const is equal to await program dot methods. Nope.
05:28:52.205 - 05:29:31.333, Speaker A: And we want to initialize config. Okay, so this takes in no arguments. We'll leave that blank. And then we'll just need to pass through the accounts, which we don't need to explicitly state any here. And then we'll add in the RPC and we're going to do skip preflight true. And we're also going to do commitment confirmed. All right, so that is our first test.
05:29:31.333 - 05:30:32.325, Speaker A: We're just initializing the config. The next test we're going to want to deposit collateral and then mint our stablecoin. So let's write out that test. We're going to deposit collateral and mint USDC and this will also be an async function. Okay, and now here we're going to define both the amount of collateral and the amount to mint. So const amount collateral is equal to and then the amount to mint. Okay, so now let's write out our transaction and that is going to be await program methods.
05:30:32.325 - 05:31:17.975, Speaker A: And then we'll call the instruction for deposit collateral in mint. And then we just have to pass through our two arguments that are needed which is the amount of collateral and amount submit. And since this is a U64 in TypeScript, we're going to have to use big number. So we're going to use new anchor.bn of your amount of collateral and then the same thing we're going to do for the amount to mint. Okay, now we'll pass through the accounts and the additional account that we have to specify here is going to be our SOL USD price feed account which we already generated earlier in our environment setup. We'll pass through accounts.
05:31:17.975 - 05:32:20.079, Speaker A: This will be price update which is our soleusd price feed account. Okay, and then lastly is our rpc. I'm just going to copy over what we had in the previous step. Okay. And I also want to add in some console logs here just so we can see all of our transaction signatures. We'll just do your transaction signature. Okay.
05:32:20.079 - 05:33:17.105, Speaker A: Because then we can just copy this over into all the instructions. Okay, so next test is being able to redeem collateral and burn usdc. So we'll do redeem collateral and burn usdc. Okay, so here we're going to specify the amount to burn and the amount of collateral. So in this test we're just going to do half the amount so we still keep something in the account. Okay. And then we'll do our program method to redeem collateral and burn tokens.
05:33:17.105 - 05:34:23.829, Speaker A: We're passing through the amount of collateral and the amount to burn just like we did above. And then our accounts is going to be the same thing. We're just passing through the price update and then we'll do the RPC with skip preflight and the commitment confirmed and then console log the transaction. Okay, next we want to update the config to then change the minimum health factor so this account becomes unhealthy and we can test the liquidation. So let's do update configuration and we'll just define the transaction to update the config. So await program methods dot update config. So we're going to pass through for update.
05:34:23.829 - 05:34:48.305, Speaker A: Config is going to be the new value for the minimum health factor. So here we're going to make that 100. 100. Okay. And then the accounts, we don't need to define any accounts here. And then we'll need to set the rpc. Okay.
05:34:48.305 - 05:35:31.167, Speaker A: And then lastly we're just going to console log and looks like I have a typo that I've been carrying over, so we're just going to fix that to your. Okay, go. So now that the config is updated, we should be able to liquidate the account. So let's test out liquidations. We'll do liquidate async and then we're going to do our transaction program methods liquidate and we want to define how much to liquidate. So here we'll just do one. Okay, accounts, we don't need the collateral account, we can leave this empty.
05:35:31.167 - 05:36:17.087, Speaker A: And then we have the RPC skip preflight and commitment and then console log and there we go. That's our liquidate transaction. And then the last thing, we'll just update the config back to the normal minimum health factor of one. So we'll just do update configuration and this is going to be exactly the same as we did earlier and we'll just Change this to 1. So this should be everything we need for our test. There's a little bit more environment set up that we need. One second while we do that.
05:36:17.087 - 05:36:58.705, Speaker A: So a few more things we need to update outside of our typescript file. After we wrote these tests, we also need to update our anchor toml and that's because this typescript file is running the test with your test validator. And we need to make sure that we have the pith account cloned to your test validator. So we're going to make a few updates here. So go to anchor toml and then under scripts we're going to define our setup for tests. So tests we're just going to have a wait for the startup and shutdown. So we'll set that startup wait.
05:37:01.165 - 05:37:01.493, Speaker B: We'Ll.
05:37:01.509 - 05:37:56.441, Speaker A: Just set that to 5,000 and then shutdown. Wait, we'll set to 2,000. Okay. And then we just need to define that this isn't upgradable. Okay, now we want to define our test validator. So test dot validator and we're going to be using the bind address is just going to be 0.0.0.0. And then we'll need the URL which is just going to be mainnet.
05:37:56.441 - 05:38:22.265, Speaker A: So we'll Paste the mainnet URL for Solana. Okay. And then the ledger is going to be from your test ledger. So we'll do so in our anchor. We want test ledger. Okay. And then we need the RPC port.
05:38:22.265 - 05:39:11.125, Speaker A: We'll do 8899. Okay. And then one last thing is the account that we want to clone to our test validator. So we'll do test validator clone and we'll state the address of pif. So let's get that, we can get that from Solana fm. So if you go to Solana FM and you type in pith receiver, you have here the program for the Solana pith receiver and we want to take the address of it. So right here we're going to copy that and that is the address that we want to clone into our test validator.
05:39:11.125 - 05:39:57.935, Speaker A: Now we want to update our package JSON and then we should be good to get this to be able to run. We need the RPC websockets. So we'll NPM install RPC websockets. Okay. And just for version compatibility, I know that this version works, so we're going to bump that down. One more thing we want to include is Web3js. So it should be at Solana-Web3js.
05:39:57.935 - 05:40:49.481, Speaker A: Okay. And we're actually going to bump this down a little bit. We'll do 73. Now that we update our anchor toml and installed all of our NPM packages, we're going to test out our typescript test that we wrote so we can just run anchor test and this is going to compile the program, deploy it and test it. Okay, so we're getting an error with the liquidation and looks like we didn't pass through the accounts that we need for liquidation. So we're going to go back to liquidate and in the liquidate instruction we need to pass through two accounts. So we need the collateral account, which is the PDA that we derived up here and we never used it.
05:40:49.481 - 05:41:21.771, Speaker A: So we're going to pass that through first. And we also need the price update to be able to calculate the current price. Okay, now let's test out our test. And now you can see initialize passed. Deposit collateral and mint passed. Redeem collateral and burn past update config passed. But we had an issue with liquidate and the error is unknown, action undefined.
05:41:21.771 - 05:41:59.715, Speaker A: So let's go back to our liquidate and see what is going on. So actually it looks like we were liquidating just one for some reason and that's not a Large enough value. So we're going to liquidate, we're going to change the amount to liquidate here. So we'll do, we'll make a constant and we'll do amount to burn and we'll set that to 500. Okay. And then we'll just pass that through for how much we want to liquidate. Oops.
05:41:59.715 - 05:42:24.955, Speaker A: Amount to burn. There you go. And let's just check everything else. Let's check our values. So, okay, here we have the amount of collateral and the amount to mint should actually be the same value. And we're missing some zeros on amount to mint. So we'll update that and make sure that these are the same.
05:42:24.955 - 05:42:51.417, Speaker A: So now we have the collateral we're minting, we're redeeming collateral and we're burning and these should also be the same values. Okay, there we go. We lost some zeros along the way. So now I think we have everything updated. So let's run anchor test one more time. And there we go. So all our tests pass.
05:42:51.417 - 05:43:33.115, Speaker A: You can see the config was initialized, the deposit collateral and mint us. You have redeem collateral and burn tokens. You have update the config, liquidate and then re updating the config. And there's our test suite. So we now know that all of our instructions work properly as intended in our program. Going back to our librs, we have the ability to initialize the config, update the config, deposit collateral and mint tokens, redeem collateral and burn to tokens and liquidate. So all of these core functions implement the core mechanism to allow you to adjust the supply of the stablecoin and respond to changes in market conditions.
05:43:37.015 - 05:44:11.205, Speaker B: The next project we'll be doing is going to help you think like an attacker. We'll be analyzing a few smart contracts that have common vulnerabilities built into them on purpose. Understanding how the vulnerabilities created and how to avoid them in your own smart contracts. Security is especially important in blockchain. If someone were to exploit your smart contract, they can potentially steal user funds or your own treasury funds. This project may not help you avoid all exploits, but should help you start thinking about ways others can attack your own smart contract. Let's jump in and start understanding security on Solana.
05:44:11.205 - 05:44:56.559, Speaker B: In this project, we're going to go through three vulnerable programs and find the vulnerabilities and test them out and showcase exactly how these common vulnerabilities happen. So if you just pull down the GitHub repository for Attack the Bank you will have three different smart contract folders. Bank 1, Bank 2 and Bank 3. And you'll find that the first Bank 1 under Bank 1 Programs Bank 1 Source Lib RS all right, so this is our first vulnerable smart contract. You can kind of see that we have two different instructions. We have a deposit instruction and we have a withdrawal instruction. The deposit instruction has an amount.
05:44:56.559 - 05:45:35.953, Speaker B: In the context of deposit, it will have a bank. This bank has an authority, a balance. And the bump, the bump is just for like PDA best practices. And then we print out the bank, then we just deposit into the bank amount and we're good to go. The withdrawal one right here, all it does is it takes it out of the balance subs the lamp ports, moves it over to your account, which is the authority and message the bank and it returns basically like a 200. Okay, so these are the two different instructions that we have in the smart contract. Now this smart contract is vulnerable on purpose.
05:45:35.953 - 05:46:00.801, Speaker B: It has some exploit that you can do in it. So we're going to go dig in and try to figure out exactly what that exploit is. So the first part that we want to look at is first the accounts. Are the accounts set up correctly? Do they have correct signer authority? Is there a different program ownership check that is missing? Things like that. So we can see the deposit account struct right here. It has an authority of signer. So that seems pretty good.
05:46:00.801 - 05:46:19.525, Speaker B: We have this bank that is initialized only if needed. The payer or the creator of this bank is the authority. And everything else here seems fine. This is all standard. And then we have system program. So this seems pretty good. It's what you would expect from a place where you're creating an account.
05:46:19.525 - 05:47:02.895, Speaker B: This withdrawal struct, it has an authority, it has a bank that's mutable has one authority, meaning that it's a constraint to make sure that this signer is the authority. And then also we have this bank struct that has the authority set up in the pub key in the actual struct with the balance and the bump. So one thing to note real quick is that we have this authority. So this has one is making sure that the authority within the struct of the bank equals the signer. This is a nice little security check. So that's good. There's one thing that we see right away though in this very simple smart contract is that it says init if needed.
05:47:02.895 - 05:47:47.609, Speaker B: So let's go check if anything happens that, hey, if I initialize the first time and then try to call again to initialize if something might happen. So moving back to the deposit, so let's go through this line by line, make sure that we understand the logic on both cases. So if the bank is not already created, we can see here it'll do init if needed and initialize because it's not created. It'll set all the required fields and then transfer the lamp ports into the bank. That's great. Now what if the account is already created? The account is already created. This does something very interesting if you think about a little bit.
05:47:47.609 - 05:48:31.407, Speaker B: The bank will be set again based off the authority of who set the deposit instruction. So what you can do or what you can potentially see already is that whenever you call this deposit, say you're Alice causing a deposit and trying to deposit some money into the bank. This authority will be set, your account will be initialized, authority is set, and you're good to go. However, if you call with that same account which is already initialized and say you're Bob, you can set the authority to yourself and then take all the money in the bank. So let's illustrate that exact problem. Let's go over the test. We're going to write a test for this just to showcase exactly how it happens.
05:48:31.407 - 05:49:20.293, Speaker B: It's going to be the bank one test. We're going to be using the anchor default test today to showcase exactly how it happens. So first, first we need to set up a writer. Next we have to set up our connection so that we can actually call the smart contract. So this is provider connection. And then we have to call wallet or we have to pull out our wallet. And finally, now that we have all these set up, we can actually just set the provider to the provider.
05:49:20.293 - 05:50:14.015, Speaker B: Now this is all going to be just the basic stuff that you do for every test. We'll get into the actual meat of the vulnerability in just a moment. So we have to create our program so that we can actually do work on it. And then we have to create a new authority because we're going to change this authority over from one wallet to another throughout the this vulnerability exploit showcase. So let's do anchor Web three key pair. So we're pulling in a new key pair and we're going to, we're going to transfer an amount, call it 1 million Lamports. All right, so let's create the before test and start creating all of the different integration tests.
05:50:14.015 - 05:51:09.847, Speaker B: All right, so before our test we need to do a few things. We need to check our pull out our transfer amount. So this is Just going to be the total matter of Lamports for SOL. So anchor web3 lamports SOL. We're going to create the transfer instruction or transfer transaction Web three transaction add and we're going to create a just simple transfer so that we make sure that we're funding the new wallet that we created so it can execute transactions. So this is just using simple web3js stuff. We're transferring from our wallet, not our provider.
05:51:09.847 - 05:51:32.037, Speaker B: So this is provider Wallet Puppy. There we go. We're transferring to the authority. So this is this new authority and we're transferring a certain amount. This is just so that everything's set up. So now we need to actually showcase the deposit and the vulnerability. So let's create a new, a new integration test.
05:51:32.037 - 05:52:16.117, Speaker B: We're going to call it deposit. All right, so we're calling it deposit right here. And we're going to have to do a few things. We're going to have to first call the deposit instruction. So right here we're going to call this deposit instruction with first the wallet. Then we have to call it again with our exploiter, our attacker. So let's call those two instructions.
05:52:16.117 - 05:53:01.495, Speaker B: So create the transaction with just a simple await program. Methods.deposit so we can deposit an amount. We're going to deposit that amount that we set earlier just so that we can keep track of it very easily. We have to set the accounts so the account that it expects is that authority because we're setting the account as we pull it in. So let's just pop that out right there and set our accounts as the authority. So this is the authority key.
05:53:01.495 - 05:54:11.569, Speaker B: So it's expecting authority of the authority public key and then we just do dot transaction to end the transaction creation. Next we're just going to call send and confirm so that actually creates the transaction. So we can call a transaction signature equals await anchor web3 dot send and confirm transaction. This is just all standard that we've done before in this boot camp. So we'll be sending a connection the transaction we're going to the signer is the authority because it must match what was said in the bank according to our SMART contract and our commitment will just be confirmed. I'm going to log this so that we can look at it in Explorer and we should be good to go. Now you can see that this VS code Linter is asking a bunch of questions about what are these things.
05:54:11.569 - 05:54:29.881, Speaker B: We never actually did the NPM install. So let's go ahead and just get that started now. So we have to go into bank one and we just NPM install everything. We'll also have to do the anchor deploy in just a moment. So we'll do right after this anchor build. Anchor deploy. Right.
05:54:29.881 - 05:54:46.765, Speaker B: So we've done the anchor the install. You can see all those red marks disappeared. You can see that this account does not exist. It's because we don't have the anchor project built just yet. So let's go ahead and build that. So we have to CD into the anchor folder or the. Let's see the source.
05:54:46.765 - 05:55:15.447, Speaker B: Is it the source folder? Actually this is an anchor project already, so we can just do array here. So anchor build and it'll take some time to compile. All right, so the program is now built. We can use it to deploy it now. So make sure before you do anything that you have a local test validator running. So you can see here I have one running on my just running Solana test validator. Otherwise you won't be able to deploy your program.
05:55:15.447 - 05:55:48.299, Speaker B: So we're going to just deploy. So anchor deploy and now it's just going to deploy the program and then we can run a test on it and make sure that we did everything correctly. So it's good. Now we just run anchor test. We're going to do skip local validator because I already have it and also skip deploy because we're not going to change this smart contract right now. All right, so you can see right here. Let's see, we got one error.
05:55:48.299 - 05:56:03.747, Speaker B: It's because account is not a function. So let's go update that real quick. So it's saying let's say account not a function on deposit. We are right here. Oh, it didn't save. That's perfect. So we've already fixed this issue.
05:56:03.747 - 05:56:34.767, Speaker B: We just forgot to save. That's fine. All right, so what this is saying right here is that our account that's trying to do the send, it doesn't actually have any LAMP ports. This is because this transaction right up here, we created it, but we never sent it. So let's make sure we send it. That is just going to be the same thing that we did below of where we're going to do an await anchor send and confirm. So let's just do that up here within our before.
05:56:34.767 - 05:57:02.051, Speaker B: So the transaction will be the transfer transaction. This is making sure that we're transferring money to the authority so that we can actually use it and test. And we can see that the missing signature for public key is right here. So this is because the authority was set to our. Let's say this is for the authority. So we added the authority here as the signer. But we never signed it.
05:57:02.051 - 05:57:25.655, Speaker B: We never actually sign this transaction. So we have to sign it with the actual authority before we send it. These are all just normal things that you'll run into whenever you're building smart contracts. So make sure that you sign it if you create a new key pair. Otherwise it won't work correctly. So let's go ahead and do that. All right, so we have the deposit, we have accounts transaction, send for confirm transaction.
05:57:25.655 - 05:57:44.943, Speaker B: Everything looks right so far. And then we have our transaction signature. So our signature verification failed for this one. So what it's doing is it's expecting my anchor. My this is actually my local wallet. So it's expecting that local wallet to be used here. Now that's okay.
05:57:44.943 - 05:58:14.561, Speaker B: We're not actually using it here. So we need to make sure that it's, it's set up correctly. All right, so we have our transaction here. Ah, yes. Okay, so this right here we're transferring from our public key and transferring to our transferring to our other key, our actual key. So we have to use a provider instead of sending confirm. So let's do provider and we have to take out authority because it's not actually using that.
05:58:14.561 - 05:58:40.847, Speaker B: So this will be just using the transfer transaction. This is only to send from our local wallet and so it's actually just sending confirm. So this is all set up by anchor. There we go. Let's run that test and it should pass. Now time to load a program that does not exist. Okay, so this is just saying I didn't set it up on the program side.
05:58:40.847 - 05:59:22.229, Speaker B: So let's do an anchor clean and then we'll do this again, but this time with deployment and that should finally work. Okay, so the error that we got is that we couldn't debit account without a prior credit. So let's check all the balances real quick once we you might run into this locally. This is just so that we make sure that we run into any errors that we do run into, we are able to reconcile. So let's go ahead and grab the balances of all of our accounts. We're going to do this right here and the before Async. That way we can make sure that what accounts do exist, we know what balances they are.
05:59:22.229 - 06:00:03.391, Speaker B: So we're going to grab the wallet balance right here. So this is just an await connection get balance wallet pub key and then we'll also do the new authority balance. All right, so let's run our test and See where this, where the balances are. At this point in time we should expect that this authority balance is going to be zero. And sure enough it is zero. And we can see here custom program error is 1004. This is a specific program ID mismatch.
06:00:03.391 - 06:00:34.645, Speaker B: So we'll get to that in just a moment. So we can see that our authority balance is zero here. Let's go afterwards and make sure that we actually got some balance at. After we. After we confirmed a new transaction for it. And as we can see, the authority balance before and after it went from zero to a bunch. Basically this is actually one soul, so we should be good there.
06:00:34.645 - 06:00:52.985, Speaker B: Now the other thing is that it's just saying that there's something wrong with the specific public key. So let's go make sure they all match. So this is C1 4 here. This is not C1.4, this is HAA. We can go check the cargo. The cargo Tamil as well and the anchor Tamil.
06:00:52.985 - 06:01:29.353, Speaker B: So it's Haa there too. So now let's run it. And we can see here now that we've reconciled both the balance and the program id, everything has succeeded. So this did the deposit. Now let's actually showcase the exploit. So we've done that deposit. We can do a withdrawal, but we don't really care to.
06:01:29.353 - 06:01:49.887, Speaker B: We can showcase that just fine. We know that it's as expected. So now let's create a new authority. So we have that other authority that has money. We already have that. Let's make sure we overwrite the current deposit bank account with this new authority. So we can just call the deposit instruction again.
06:01:49.887 - 06:02:35.761, Speaker B: So we'll just create another exploit transaction. We're going to just use the exact same thing as before, but we're going to exploit it with a different authority now. So instead of having the original authority, we're going to exploit it with my wallet right here. Going to then send and confirm. So this is going to be the exploit, transaction or exploit signature. And let us go look at that real quick. So let's put that right here.
06:02:35.761 - 06:03:07.579, Speaker B: Exploit signature and we have to make sure that it is going to be signed by the wallet instead of the authority. So right here what we can do to sign it by the wallet instead of authority. We just have to do wallet pair. There we go. All right, let's run this. Let's see exploit transaction. We need remember to set there and let us run this so you can see.
06:03:07.579 - 06:03:40.019, Speaker B: I was able to recall that instruction two times. And with the second time I ran it with this exploit signature. So now let's actually showcase that we can access the funds. It didn't fail, which should be concerning. It should have failed given that I am overriding the current bank, the current bank authority with my exploiter's public key. Now let's do the withdrawal. To do the withdrawal, we'll just call the withdrawal instruction.
06:03:40.019 - 06:04:34.355, Speaker B: So we can call it right here. So const Withdrawal instruction equals await program methods withdraw. We're going to withdraw that. Let's withdraw that same amount bn amount. We're going to have the accounts of the authority being not the original authority, but my wallet because I have now exploited it to where I can pull from the bank account with my wallet. And then we're going to set it as an instruction. All right, so now what we can do is we can actually set it to where it will pull the full amount.
06:04:34.355 - 06:05:08.327, Speaker B: One here, one note here is that we originally in the exploit transaction, we did it with the same amount as well. We can actually do this with a deposit of zero just to showcase, hey, there's another constraint that we should have checked. You shouldn't really be able to call this instruction with zero because that could actually potentially cause other issues. All right, so we have the instruction right here for the withdrawal. Now let us create the transaction. There we go. There's our new transaction.
06:05:08.327 - 06:05:41.365, Speaker B: This is the withdrawal exploit transaction. And now we just need to send and confirm it with the wallet paper. It's the same as previously. So let's just go pull this these two lines of code. This is going to be the exploit withdrawal. So this is exploit withdrawal signature and we're going to log it. All right, let's see what happened.
06:05:41.365 - 06:06:40.079, Speaker B: All right, so you can see both my exploit signatures completed successfully if we go actually go pull one of those. So let's bring up the explorer.solana.com and we're going to go set ourselves to our local host, put in the signature right here and we can see that we pulled the withdrawal. The authority was that cwt, which is myself, I pulled all the money and I successfully exploited the bank. So that is something to note about anytime that you're using init if needed. You want to make sure that you don't have this right here where you're setting the initialized values even if the account is already created. An easy way to check all this would be to add something like a boolean right here in the bank of initialized and then just checking if it's initialized.
06:06:40.079 - 06:07:16.987, Speaker B: So if it's initialized here. So like if context accounts bank initialized, throw an error. So this is a very easy way that we could have fixed this problem. Another thing is maybe we should have just had an init and have a separate function or a separate instruction so that you can call it completely separate and you don't have to worry about it. These are just general practices to think about whenever you're doing anything within your smart contract, within it if needed. And it's a good showcase of an exploit. So let's move on to exploit number two.
06:07:16.987 - 06:08:09.645, Speaker B: So if you go over to our bank two example now, you can see this is a very similar smart contract. We have a deposit, we have a withdrawal, we have an update authority. And this is so that hey, if I want to update the authority site to my partner to be able to withdraw from my bank account and deposit to my bank account as well, this is just adding that capability. This is a new feature. And if you go look in the deposit instruction, you can see there is a new chunk of code that checks is initialized to protect from the previous X exploit that we showcased. All right, so let's look through this specific instruction and try to figure out how this smart contract is potentially vulnerable to a new exploit. All right, so we're very familiar with this deposit.
06:08:09.645 - 06:08:48.483, Speaker B: We have a bank account that is given an extra amount. If it's already initialized then don't, don't create these base variables like just get rid of them so that you can't reset the authority key and do a transfer. That seems all well and done. The withdrawal is the exact same as well to where you're adding. You're subbing the land ports from the bank balance, you're adding it to the authority seems fine. And this is the update authority right here is just going to update the authority on the bank to a new key. So that seems interesting.
06:08:48.483 - 06:09:24.245, Speaker B: So first thing when I see this is that I wonder how do they check the constraints on who is signing this transaction? Because I don't see an authority check to make sure that hey, the one who signed this authority is the one who owns this who has the ability to actually do the changing of authority. So let's go look at those account constraints. So this is a deposit one. We can see here that it's still in it if needed and we have the authority. So all this looks good. This is withdrawal has one authority. So it's checking an account constraint across the authority within the bank is the signer for withdrawal.
06:09:24.245 - 06:10:22.885, Speaker B: That seems fine. And now right here we can see that on the update authority the Authority is just a system account. It's not a signer. So if it was a signer, it would use the has one constraint within the bank to check across the different authorities within the bank is equal to the authority on the system account. What this means, however, is that I could pass in the account of whoever the actual authority is and not require them to sign the transaction in order to exploit this instruction and withdraw from the bank. The correct way of doing this would actually have been to have signer here instead of system account so that you can require that this is the signature authority that can update authority on a bank account. But we don't have that.
06:10:22.885 - 06:11:11.975, Speaker B: So let's deploy this and actually showcase this exploit. So we're going to move over to the bank 2 example. The first thing that we're going to need to do is we're going to have to do an anchor build and then we're also going to have to do an anchor deploy so that we have the smart contract built in. One thing that I want to check before we deploy is that the smart contract equals on the program ID across all the anchor toml within the actual code, et cetera, so that we don't run into those mismatch earlier. So let's go check that real quick. So we go to anchor Tamil. We can see that it's a B8 address.
06:11:11.975 - 06:11:37.429, Speaker B: We go over here to the librs, go to the top. Looks like it's B8. So it looks like it's fine right now. So let's do an anchor build. All right, so the anchor smart contract has correctly built. Now let's go check and make sure all those program IDs are the same. We have B8 here.
06:11:37.429 - 06:12:00.745, Speaker B: I'm going to go ahead and close all the bank one examples because we don't need those anymore. So B8 is here. We're going to go to the source. B8 is there as well. Looks like everything is correct. Let us actually go grab that bank one test and I'm going to copy and paste it into to our bank to test so we don't have to worry about doing all the setup in Bank 2. It's just all the same code.
06:12:00.745 - 06:12:20.995, Speaker B: So let's go put it right here. I'm going to call it Bank 2 or remove these extra things that I just imported. So we need all this. The one thing that's different, we definitely don't need bank two. We need or bank one. We need bank two. So let's go bank two.
06:12:20.995 - 06:12:53.035, Speaker B: You can see all these things are Red. So we need to make sure that we do an NPM install again. So NPM install has finished. Pulling all the packages now are things very happy. The one thing I wanted to check real quick is that this is a whole new test on our Bank 2. Now we said earlier, hey, Bank 2 should not be vulnerable to the same exploit that we used in bank one. So let's run that test and just make sure that it isn't.
06:12:53.035 - 06:13:23.605, Speaker B: So we're going to do anchor test. We have to remember to skip the local test validator. And I'm actually going to also skip deploy because we've already deployed the smart contract. All right, so as expected, we ran into a bug. Well, this is not a bug, it's an error. The first one is that it was trying to pull in bank one. That's fine.
06:13:23.605 - 06:14:04.395, Speaker B: That's just because of this guy right here. There we go. So let's run it. All right, perfect. So we ran into an error, and that's exactly what we wanted to do. We wanted to showcase that this is not actually going to correctly compile for or correctly send for this specific vulnerability anymore because it's not exploitable via this vulnerability. So let us remove some of the code for this exploit and move on to the Bank2 exploit with signature so we can pull all this code out right here.
06:14:04.395 - 06:14:29.275, Speaker B: One thing I noticed is that we didn't log this out afterwards. And so this test should pass. Let us send it and make sure. Okay, so this one looks like. Let's see. All right, so we got the same error that we got earlier. Let's just make sure once again that our program ID is the same across.
06:14:29.275 - 06:14:55.405, Speaker B: If I remember correctly, it was because the program that was deployed, the ID was different. So grab that ID real quick. Actually, have we deployed this? I don't think we've deployed this. That's probably what the problem is. Anchor deploy. All right, so we can already see this B8 is not matched to this S7. So let's go update that.
06:14:55.405 - 06:15:24.005, Speaker B: So we immediately know that that's going to be the issue that we're going to run into. So that should be updated now. And now let's run it again with our anchor test. All right, so we can see that the authority balance was not updated. Let's see. The authority balance should have been updated with a new amount of LAMP ports. So we provided the transfer instruction.
06:15:24.005 - 06:15:36.865, Speaker B: This is the authority balance. We didn't. We didn't set it again. That is fine. So we'll just call it after. And that. That'll work just fine.
06:15:36.865 - 06:16:01.755, Speaker B: We can also see that it did had a problem with the program does not exist. So let's go pull that program real quick. I believe we checked the anchor toml which we checked and verified that is the S7 one. We need to check and make sure that is in the bank. Ah, there it is. It's not S7 there. So let's go copy and paste it over.
06:16:01.755 - 06:16:36.265, Speaker B: The reason why we showcase these errors is so that if you do run into them, you know exactly how to fix them. As we saw, I ran into them and since I've done it before, we were able to fix it. So let us pull this out and run the test again. All right, so this passed as expected. We can see our transaction signature. We can see our authority balance increased. So let us exploit this smart contract.
06:16:36.265 - 06:17:29.901, Speaker B: Moving over to the test for deposit, if you remember correctly, we have to do the update authority to update to our new authority, which is going to be our wallet. Our wallet is going to be the exploiter and then we have to try withdrawing. What we're going to see is, as mentioned earlier, if we pass in this authority in the update authority because it's missing its signer check, we will be able to actually pretend that we are the authority. It's kind of faking the authority to exploit the smart contract in a way. All right, so let's go ahead and create this update authority instruction. So we do update authority. Instruction equals await program.
06:17:29.901 - 06:18:12.415, Speaker B: Methods.it's going to be the update authority instruction. We're going to do dot accounts. And instead of the authority being the public key of our current authority, we're going to change into a new authority. You can see that we set it up as the authority here when we did the deposit and we want to update it to a new authority being the wallet, we're going to call this and it's going to be dot instruction. All right, so we have the authority. Let's see, it's saying something about authority does not exist.
06:18:12.415 - 06:18:31.941, Speaker B: Let's see. Name new authority. Okay, so let's go pull the over here. It does have it here. So let's see. So the new the authority right now is the wallet public key. But we don't have the new authority here either.
06:18:31.941 - 06:19:33.117, Speaker B: So we need to make sure that we're also passing the new authority because that one is what it doesn't know what it is. All right, so let's also create the withdrawal instruction. So this is specifically the withdrawal exploit instruction because we did the exploit of updating the authority, we should be able to now withdraw. So we'll do equals await program methods withdrawal with our specific new amount. So we're going to grab the full amount that is currently in there. The authority is going to be our wallet instead of the original authority that was the set during the deposit. And then we just pull this as an instruction and we create our transaction.
06:19:33.117 - 06:20:36.155, Speaker B: So const transaction Equals new anchor web3 dot transaction and add both of our different instructions. We're going to call it an exploit transaction just to make sure that we understand which transaction this is. All right, so now let us send and confirm and confirm that we were able to exploit this new smart contract. So we'll do const transaction signature equals await anchor web3 dot send and confirm transaction, not raw transaction. This is going to have our connection the exploit transaction. We're going to have the wallet pair and confirmed. This is the exploit signature.
06:20:36.155 - 06:21:15.667, Speaker B: All right, so let's log this so we can go see it after this. All right, so we have the log. If everything is correct, this test should pass and that should be concerning to you because it should ideally should not pass. We should not be able to update the authority on the bank to something new without having a signature of the original authority. So let's run that anchor test. All right, so we can see that it passed. Let's go look at that signature on the explorer.
06:21:15.667 - 06:22:05.001, Speaker B: So we'll pull up that signature right here and let's look at the accounts so we can see that it passed in. It passed in the cwt, which is the wallet. And the wallet was able to grab new sol. It pulled some sol from the account, but it did not originally have the signer of that original authority. It just pulled from it. And we can pull from here on the very bottom we can see that the update authority correctly was able to update from CWT from the other the generate keyboard key pair to CWT and it was able to submit subtract 1 million lamports from the bank without ever having needed a signature from the original bank owner. So that is the end of our second exploitable smart contract.
06:22:05.001 - 06:22:52.571, Speaker B: Let's move on to the third. So let's go open up bank three. We'll pull up the program. This is going to be bank3.well lib rs under bank underscore3. We're going to go navigate to it within our terminal and I'm going to anchor deploy right now so that we can check all the different program IDs and make sure they match. We have to anchor, build anchor deployment all right, so we can see that The Solana program ID that we have here for Bank 3 is 3W9.
06:22:52.571 - 06:23:20.085, Speaker B: Let's go make sure we update that everywhere. So let's open the libs rs. You can see it's already going to be a mismatch just so that we don't run into that error again. Let's go update it in bank three over here. There is also another program ID that is kind of show going to showcase our exploit in just a moment we're going to copy and paste those into their respective places as well. Just to get a little bit of ahead of ourselves. There we go.
06:23:20.085 - 06:23:56.417, Speaker B: All right, so we have bank three. We have everything in this smart contract. We can see that like before we have this deposit, it has a bank with the bank account. It's doing the is initialized check. So to avoid being vulnerable to the issue that we had in the first smart contract, the transfer is the same. We have a withdrawal, we can check there's something new in this withdrawal. It's pulling in a bank account that it doesn't exactly know what it is and is trying to serialize against itself.
06:23:56.417 - 06:24:34.523, Speaker B: So that might kind of tell you like, hey, there might be something here. We'll get to that in a moment. We can see that it's checking the authority here to avoid from the earlier problem that we had on the last smart contract does the signer seeds and the transfer and for this one we removed the update just to not have any worry of like, hey, there's additional work. Let's look at the deposit. So the deposit we have an authority of a signer and if needed is there and we have the vault of the system account. That's all fine. We have to withdraw.
06:24:34.523 - 06:25:20.161, Speaker B: And we can see right here is that the bank is of type account info or of account type unchecked account. So this is very important and every time you see this it should raise some flex as someone that is building a smart contract. If your account is an unchecked account, there could be some things that are wrong with it if you don't check all the required variables successfully or the required constraints on it. One of them is like account ownership. Make sure the PDA is generated as expected. If it's a pda, which I believe bank, yeah, bank is a pda. So if it's not generated just like this, that could be a problem.
06:25:20.161 - 06:25:37.997, Speaker B: There can be a program ID ownership. So this should just immediately start raising some flags. We have this vault, we're good to go on there. We have the initialize is initialized on the bank. So this is likely the problem. So let's go check the. This is for the withdrawal struct.
06:25:37.997 - 06:26:02.527, Speaker B: Let's go check the withdrawal function. So we can see here we're just pulling the bank and we don't actually. We check what's inside of it, but we don't check that it was owned by anybody. We check the authority. Great. It's fantastic. But we don't check that it is currently owned by the program of our Bank 3 program.
06:26:02.527 - 06:26:31.041, Speaker B: This is known as something that like you can replace an account and another smart contract and pretend that is the same account. All right, so let's go showcase how you can do that. So we go over to. There's a fake bank smart contract. You can see here we have this bank just. That is the exact same struct, including the name as the bank3. So we can go match them up.
06:26:31.041 - 06:27:18.383, Speaker B: So there we go. Struct, bank authority vault is initialized. Exact same infrastructure. Now, what this means and why it's important is that because I have this outlined, exactly the same anchor won't be able to catch that it is a different account and that it's not owned by the same program if it is not. If it is an unchecked account. So what we can do here is we can initialize this account with a separate program, a fake bank program, and then use it to masquerade and get an exploit into withdrawal from someone that actually owns an account on the original bank program. So let's showcase that with some typescript.
06:27:18.383 - 06:27:43.885, Speaker B: I'm going to go over here. We're going to pull some of the code from the last test just so we don't have to do it all over again. And then we're going to go into the bank three code and we're going to update that. So go into bank three tests. We're going to push it right here. We can see that there's some. The red lines.
06:27:43.885 - 06:28:02.645, Speaker B: It's kind of complaining about us. That's because we didn't do an NPM install. So let's do that real quick. All right. And then we got to make sure we play replacement bank two to be bank three in both cases. All right, so this is the old one. We can see that it's not.
06:28:02.645 - 06:28:30.207, Speaker B: We don't have. It doesn't have any update authority. So let's remove all that code real quick. Just get rid of that. All right, now we need to initialize the other program as well. So we have this const program we need to also initialize the exploitation program. So const exploit program as fake bank.
06:28:30.207 - 06:29:08.725, Speaker B: So we now we have that exploit program and we'll be able to showcase that we will be exploiting by creating an account with a separate program to masquerade as the bank account within our bank program. So let us do the full creation. So right here we're doing the wallet. The wallet funding that everything within that should stay the same. We have the deposit and this is where we're actually going to showcase us exploiting the bank. We're going to do some things that we didn't have before. We have a vault, so we're going to make sure we pull in the vault.
06:29:08.725 - 06:29:46.391, Speaker B: This is just, this is just a pda. So it's just going to be a find programming address sync. And if we go look at what those would were in bank3.Rs. Let's go, let's go look at that real quick. It's just of vault of the string vault. So let's do the buffer from vault and then make sure we have the program id. So now we have the vault account.
06:29:46.391 - 06:30:11.321, Speaker B: We're gonna, we have the very similar thing for the fake bank. So we're gonna get the PDA for the fake bank. It's gonna be anchor find program address sync just as before. And it's actually gonna be the exact same. Oh no, it's not the exact same. It's gonna have the bank because if you go pull let's go pull up a fake bank. There we go.
06:30:11.321 - 06:30:50.233, Speaker B: So fake bank has the vault. Where's the vault? Oh no, it has the bank of the seeds bank. So we'll have to go pull it in with buffer from bank and the exploit program id. All right, so we have the exploit account, we have the exploit vault or we have the original vault. Now let's create a fake bank account real quick. So we'll do create a transaction. This will be using it with the exploit program.
06:30:50.233 - 06:31:16.181, Speaker B: This is going to be exploit program methods dot initialize. We're going to initialize a new vault, a new fake bank account. So we're going to initialize as that vault. Let's see. Just make sure that we have it all set up. Yep. So as that vault and we need to make sure that we have the authority or the fake authority as our wallet because that's who we're going to use to steal all of the money.
06:31:16.181 - 06:31:50.175, Speaker B: This is going to have the accounts of fake authority of our current wallet. So wallet pub key. We're going to pull out the Transaction. So it's dot transaction. And so this is, this is going to be our fake bank creation bank transaction. There we go. We're going to make sure we send that to create the bank.
06:31:50.175 - 06:32:31.731, Speaker B: So it's just going to be an await anchor web3 dot send and confirm transaction with connection fake bank transaction. It's going to be the wallet pair and commitment. And it looks like it created another additional parentheses, but everything is otherwise okay. We've created the fake bank. We've created the vault pretending to be the bank account. Now we just have to actually exploit the withdrawal function with that new account. All right, in order to do that, we're going to create a withdrawal transaction with that new fake bank.
06:32:31.731 - 06:32:58.749, Speaker B: So we'll create that transaction right here equals await program.methods.withdrawal. we're going to withdraw some amount. Then we're going to have our accounts of the authority. This is going to be the opposite authority. And we're going to pass in the bank as the fake bank. There we go. So you can see we're passing in a different bank account.
06:32:58.749 - 06:33:24.695, Speaker B: We're going to do the transaction. This is going to be the exploit transaction. So we make sure that we call it exploit transaction and then we do the same thing that we're used to doing where we do send and confirm. So send and confirm transaction. This will be with the exploit transaction with the wallet as pair. And ideally this exploit should not work. Right.
06:33:24.695 - 06:33:59.241, Speaker B: So let's run it and see what happens. Anchor test, skip local validator because we already have it running and skip deploy. All right, so let's look at what issue it ran into. So there's some safety check failed. This is because I updated the Bank 3 to be an unchecked account, same thing as account info. So you can tell that anchor does not want you to do this. It's saying, hey, there's going to be an error.
06:33:59.241 - 06:34:24.365, Speaker B: Be careful. You're running into some bad territory that you might cause some other issues. So you can see already the safety checks are failing, that the struct is unsafe. It does not want you to create this transaction to exploit the bank. It's trying to keep you from doing this. This is, this is a custom. So it's a.
06:34:24.365 - 06:35:00.843, Speaker B: It's basically keeping you from being able to do this as. As expected. The way we're going to remove that is just adding the check just so that we can showcase this exploit. All right, let's try it again. Okay, so we can see that. Let's see it failed because the program ID did not match let's make sure all our program IDs match. We've run into this seemingly with every single one.
06:35:00.843 - 06:35:26.527, Speaker B: So 3wd actually, let's do the deploy so that we make sure that we match it with what's actually deployed. All right, so 3 should be 3w9 in all the banks. This is bank 3 to 3w9. Bank 3 should be 3w9. The other one is GGH. GGH. This should also be GGH in the fake bank.
06:35:26.527 - 06:35:39.655, Speaker B: Let's go pull that. Yep. And then let's see. So attempted to debit account, no prior credit. That's fine. Let's go pull that, make sure that we have it. All right, this should be.
06:35:39.655 - 06:36:00.433, Speaker B: Looks like it. It failed at the very beginning. So wallet balance, the authority balance. Try to transfer from my wallet to the authority. Let's run it again. All right, so we can see that the wallet balance was updated. So something else happened within deposit.
06:36:00.433 - 06:36:20.717, Speaker B: So we can just check that and make sure that we don't have an additional key pair that we're pulling in that we didn't expect. Looks like we're using it. Find here. It didn't actually send any of the console logs. Do we have any console logs? We have one here. So this one's trying to. Oh, so it's trying to send a.
06:36:20.717 - 06:36:39.493, Speaker B: Confirm a transaction of the deposit from the authority. Depositing amount. Do we have the same enough amount in this authority? Let's see. We have. Yeah, we should have enough amount because we. We checked right up here that it had an amount. So the authority should be the pub key.
06:36:39.493 - 06:37:04.575, Speaker B: The transaction should be authority. It might not be enough enough. So let us should be able to do this one more time. Let's just do two transfer instructions just to make sure. So this one is a system transfer. Let's just pull this and add it again just to make sure we have enough lamp ports. There we go.
06:37:04.575 - 06:37:33.765, Speaker B: Let's run it. All right, so we can see that the transaction signature passed. Oh, we didn't log our exploit signature. So let's go log our exploit as well. So let's do that real quick. So const exploit signature equals await confirm. And let's log that so that we can check what's going on under the hood.
06:37:33.765 - 06:38:01.105, Speaker B: There we go. So it looks like that it doesn't like it because of fake bank. Let's go check fake bank real quick. It's because it has an init. If this was an init, if needed, it should be fine. So let's just change it. It's saying that there's a bank already pulled in and we have to update the cargo to have the init if needed feature.
06:38:01.105 - 06:38:55.951, Speaker B: So let's go pull that real quick, make sure we run it with deploy, otherwise it won't be able to run successfully. All right, so we have the exploit signature right here. And let's go check in the explorer. Okay, so we can see the transfer was able to complete successfully. We were able to withdraw from the bank. This is all using a fake bank account masquerading as the real bank account. So going over the three exploits that we ran through today, the first program was exploitable or vulnerable to an issue with a if needed reinitialization check so that if you were to initialize again, it would re update all the authority variables and then you could use that to exploit and withdraw the function.
06:38:55.951 - 06:39:49.921, Speaker B: We fixed that in the second program and with that program we had an update authority issue where without being the signer, you could update the authority with the update authority instruction. And that was also a problem. So remember to also check the signer that you have signers set instead of just system accounts if you require that signature to withdraw or execute successfully. And this last one is a more convoluted or more hard to see one. It's very nice to see if you look for unchecked accounts, but if there's like account info or something similar, it's basically an unchecked account. You'll be able to masquerade or pull in an account from another program and pretend to be that account and then use that to pass authority attached checks to pull and exploit the funds. So those are the three different exploits we went through.
06:39:49.921 - 06:40:30.133, Speaker B: There's a ton more out there in the ecosystem. Generally. The way that you should think about this is how do I think as an attacker to avoid these issues or other security vulnerabilities on my smart contract? We'll go through more of this in the later project. For making your project going to production, that'll go into like how to create a multisig for your authority, how to properly fuzz your smart contracts, and more. So check out that. But until next time, thank you for going through this project. At this point, we've built 12 different projects throughout this boot camp.
06:40:30.133 - 06:41:23.103, Speaker B: We've primarily been using the local environment for development, but now we're ready to move an application to production. If you have a software engineering background, you're probably familiar with the large amount of work to move from a local development or QA environment to a full scale production environment. Thorough testing, continuous integration, continuous deployment processes, managing edge cases, monitoring your applications, and adding proper security measures to prevent issues are all different action items a software engineering team usually does in getting ready for deployment. Deploying an application to production within the blockchain space is very similar. You have all the same steps, but you have some additional actions that need to be taken care of to be successful. The first of these is getting your smart contract properly audited. Given the large amount of funds stored within smart contracts today, it's critically important to be free of any exploits.
06:41:23.103 - 06:42:07.009, Speaker B: While you cannot ever be 100% certain that you're smart, Smart Contract is free of bugs or exploits. Any additional work you can do to proactively avoid hacks is advisable. The second step is making sure any authority key that you may own, such as a smart contract, upgrade key, token, authority, etc. Is properly behind. A multisig, multisig or multisignature can make an authority require signatures from more than one party. If the parties are sufficiently separated, they have to come into agreement to update a smart contract, mint tokens on the blockchain or access funds in a Treasury. The third step you need to take is obtaining proper infrastructure to make the user experience on your application as good as possible.
06:42:07.009 - 06:43:02.505, Speaker B: Solana is write optimized, meaning that the transactions sent to the network will be fast, but reading the data may be a bit slower. Infrastructure can be run running your own RPC or paying one of the RPC providers, using an indexer to provide the most up to date data for your accounts, or even running your own validator to verify transactions were successful. Just as a note, you may not need any of these depending on your application, but some of these can help you provide a better experience to your users. The last step to take is make your application easily composable and viewable by other developers or users. This includes publishing your IDL, verifying your smart contract on explorers, or potentially creating SDKs that make your smart contract easy to interact with on other platforms. We'll be doing some of these steps and more on the voting application that we built earlier in the bootcamp. Let's get started.
06:43:02.505 - 06:43:41.525, Speaker B: So we're going to take an application to production. We're going to take that voting application that we did early on in the boot camp and do all the work that needs to make it fully productionized and ready to deploy to mainnet on Solana. So the things we're going to do is first we're going to download the voting application, we're going to look at it and see what the UI looks like today. Then we're going to add something called prioritization fees. And we'll get into this a little bit in a moment. Moment. We're going to calculate those priority fees correctly and we're going to grab the specific tools needed to do that.
06:43:41.525 - 06:44:25.143, Speaker B: Following that, we're going to add some fuzz tests to our application and we're going to deploy our application to Devnet. We're going to grab an RPC so that we actually are using a real RPC versus public infra. We're going to talk about some security things and then we're actually going to deploy our application to mainnet to production and we're going to showcase all the work needed to be done to do that and also secure our application on on mainnet. So let's get started. All right, so the first thing we're going to do is we're going to go to the Developer Bootcamp 2024 and we're going to clone the repo. Now, you might have already had this repo clone, so you're welcome to work in that clone. I'm going to just go from scratch so that you don't have to worry about it.
06:44:25.143 - 06:44:58.889, Speaker B: So first off, off, I'm going to go and go ahead and clone it. So I'm going to clone it in a Temp bootcamp repo so I can actually remember where I did it. Get clone repo. I cloned it. And now let's go ahead and open that repo. So I'm going to go over to that folder Temp Boot Camp and we're going to go to Project 14 getting to production and open that repo. So what you'll see right here immediately is you'll have a project that has anchor and has a web.
06:44:58.889 - 06:45:35.275, Speaker B: And what we're going to do is we're going to have to NPM install first off. So NPM install, make sure we have all the dependencies installed. And in a another terminal we're going to do CD into the anchor folder. Let me just make this bigger so everybody can see CD into the anchor folder. Anchor build and so that we're building all our projects. And so once this is build build we will come back and we will do the next step. All right, so everything built and we can go check over here as well.
06:45:35.275 - 06:46:08.935, Speaker B: Looks like the NPM install worked just fine. And so let's go ahead and open another terminal. So open another terminal and we'll do Solana Test validator. As I said that we're running It I'm actually going to run it with Dash R just to make sure that everything is a clean slate. We don't have any issues. So let's get this running. And then over here what we're going to do is we're going to actually do anchor deploy so we can deploy our specific smart contract to our local validator.
06:46:08.935 - 06:46:31.711, Speaker B: So let's go run, run that. All right, so it ran. You can see that it has a program ID right here. So one, one thing that we're going to do real quick is in the voting spec, it's going to have a new public keyword and just update that voting address to whatever was spat out. There we go. And I'm going to do an anchor keys sync. That way it syncs everywhere else.
06:46:31.711 - 06:46:53.209, Speaker B: So look, it found an incorrect program ID declaration in some spots. So we can actually see that it updated everywhere. So if I go to programs, you can see it's now a Z, which is what we put right here. Ayz and also put it in the anchor toml. Perfect. Wonderful. So it added everything.
06:46:53.209 - 06:47:23.947, Speaker B: We're good to go. I'm going to do an anchor test skip local validator. This is so that it will push all the information that I need in order to run my ui. In a moment, it'll create our polls. If you remember creating this test early on, it'll create our polls, it'll create our candidates, and it will create a initialized vote for a candidate. So it's going to run that real quick. Perfect.
06:47:23.947 - 06:47:45.205, Speaker B: So it ran. Going to move over to this one. This one's in the root directory of the project 14. And what we're going to do is we're going to do NPM run dev and this will run our website. And you'll see this is not an actual website that we built in the original project. It's just something we mocked up for this. So let's go look at that website real quick.
06:47:45.205 - 06:48:16.577, Speaker B: So I'm going to go over to localhost 3000 and once it loads, we should be able to see our website, which is a voting application. There we go. And what happens is we have a crunchy and smooth peanut butter to vote for. And if I click on it, it'll pop up my wallet that I have connected using backpack for this one. And I'm going to send my transaction and you can see it immediately updates. We can just keep voting for it. Looks great.
06:48:16.577 - 06:48:39.341, Speaker B: So our application works. Everything's doing well. But there's a few things to keep in mind before we Continue. Let's say there's a lot of people running on this. What ends up happening is you might end up having the. Your users pay a little bit more fees to make sure that their transactions get submitted to the network. So let's look at this in practice.
06:48:39.341 - 06:49:24.935, Speaker B: Let's say we have some hot application we're going to call this application market. We have our voting app. All right, so we have these two applications, right? So let's say there's a thousand users on this one and maybe there's only, only tens of users here. So there's only 10 users. We're still getting started. We just, we have, we just deployed to production. And what will happen is this account will the priority fees for those thousand users might go up a little bit so that people can get their transactions included into this, this account.
06:49:24.935 - 06:50:10.797, Speaker B: While our app, while we only have 10 users, we don't really need priority fees. Now let's say if there's, I don't know, a hundred of these hot application markets with hundreds of thousands of users working on Solana, what you end up having is every one of those accounts might have an isolated market where they're paying a little bit more priority fees to access that market. But ours overall will not go up that much. So what does this look like in practice? Let's go over to look at the current fees or prioritization fees on Solana today. So we're going to go into this website called Solana Compass. They track a bunch of different information like the tps. But what we're going to, what we care about is this live fee data.
06:50:10.797 - 06:50:49.151, Speaker B: So you can see here on the average priority fee. Average priority fee, we'll put it in Seoul so that we can see it in Seoul is 0.0008 ish SOL every minute or so. That's the average. If you remember from my skele, what we were saying is that if this one has a lot, only these users will pay more to access this market versus these may not. They shouldn't have to pay too much more to access our voting app because they're isolated. And what we see this in practice is the median fee is still very low because all those not hot markets or not hot accounts are not very active.
06:50:49.151 - 06:51:43.281, Speaker B: But the average fee might be be higher because of the other markets that or the accounts that have a large amount of users end up getting more people working on them. We can see this here with like the max priority fees and let's put them in Dot soul is like dot one one point Two. So there are people paying a ton of money, but the minimum fee to get included it's 5001 Lamports. And so might see that like hey, why is it 5001? What ends up happening is on Mainnet is you have a bunch of people using Mainnet. So you have the fee or your base fee plus your prioritization additional fee and that'll get you into mainnet. So if you just pay even one Lamport today at the time of recording, you have a good chance of getting in if it's a low market or account. Low, low used account.
06:51:43.281 - 06:52:45.653, Speaker B: So what we end up having is the prioritization fee or the prioritization equals your CU cost. See your lamp parts, micro lamports per CU cost per cu. Alright, so what, there's another word here, cu. So what is that? Let's go look at our transaction. So I'm going to run this transaction real quick and we're going to go look at, on the Explorer, you can see on the Explorer our compute cost for this transaction was 7562. So what that means is it took, this is the units of compute or that it took to execute on the cluster. And if we can get that lower, our overall feature for prioritization to receive higher prioritization will end up being less because it'll take less micro LAN ports per CU to get a higher prioritization on the cluster.
06:52:45.653 - 06:53:13.375, Speaker B: All right, so we've talked about prioritization fees. Let's actually build it into our application. So we're going to go over to Visual Studio and we're going to go into components and we go to voting and we're going to go into the data access. So what this is, is, this is everything that is being run whenever you click those buttons. So you can see here, this is the use voting program candidate count. And we can see here that there's a vote. So this is what happens when that vote button is pressed.
06:53:13.375 - 06:53:55.371, Speaker B: So I'm going to go ahead and make some changes to this. We're going to make this an async method. And let's see, we need that there and we're going to need it down here as well actually. No, right here and then comma and remove this. All right, so this is so that we have this, the execution logic separated and we're going to have to do something that you've probably done in the other boot camp, the other parts of this boot camp. And we're going to have to break up this dark RPC into an instruction Add the instructions in order to do compute. So let's go ahead and do that.
06:53:55.371 - 06:54:10.987, Speaker B: I'm going to first look at Solana. We're going to go to solana.com docs. Go to cookbook. And if you go to the I think believe it's a transaction one. Yes. Add prioritization fees.
06:54:10.987 - 06:54:34.109, Speaker B: So how to add prioritization fees to a transaction. We can see right here there's two different, different instructions that we'll need. So we're going to go ahead and grab those. It's going to ask for compute budget program. So we're going to go add that as well. And so these will return an instruction for us to add to a transaction. All right, so first off, modify compute units.
06:54:34.109 - 06:54:55.119, Speaker B: We know from our transaction it took about 75 62. However, this might not be the maximum. I'm not entirely sure. So we're going to just double check on the another transaction. So 7562. Let's see also 7562. For this specific smart contract, we know that the max may be 7562 cu.
06:54:55.119 - 06:55:27.449, Speaker B: However, this may not always be your max cu. There are some things that cost more compute, such as creating a PDA that has a different bump. The higher bump may take more CU than if your program had a lower bump. So we have these units. I'm going to go ahead and add a little bit of room for it. I would recommend adding a little bit of headroom so that your users do not run into unexpected errors. But you can tighten this headroom by doing a bunch of tests later in order to figure out what are the max compute units that your smart contract might use.
06:55:27.449 - 06:55:58.207, Speaker B: So we're going to add that right now. We're going to set the desired priority fee as one. I'm going to change this into an instruction so that we can get the instruction. So cons vote equals program methods vote candidate B1. And then we're going to have to create our actual transaction. So cons transaction equals new transaction from Web3js. And you can see it already knows what I want to do.
06:55:58.207 - 06:56:14.249, Speaker B: See, it doesn't know how to add vote transaction transaction. Okay, so it wants us to. This is a. Yeah, this is a promise. So we just have to make sure we await it. There we go. I'm just going to do a little bit of cleanup on the formatting here.
06:56:14.249 - 06:56:53.245, Speaker B: And so what this is doing is it's adding all of our instructions to add priority fees to our transaction for our vote. All right, so Final thing is we're going to have to add some information in the transaction for it to be block hash. We're going to need a transaction block has context. It will be fee pair, block hash and last valid block height. So let's just go ahead and list all those out. Fee pair, block hash, last valid block height. All right, so what do we need to do that? We need to actually go grab that information.
06:56:53.245 - 06:57:18.539, Speaker B: So let's go add a new thing here. We're going to add two things. We're going to add const connection equals use connection and const wallet and send transaction. These are the two things that you need in order to actually send a transaction. Using our. Our wallet on use wallet. There we go.
06:57:18.539 - 06:57:41.295, Speaker B: All right, and then we actually need the. Not the wallet but the public key so that we can use as the pair. So our fee pair is going to be that specific public key. So we have that down. Now we need block hash and last block height. So we're going to create a new block hash. Context equals await connection.
06:57:41.295 - 06:58:10.549, Speaker B: Get latest ball cache and context. And let's just grab that and put in the values that are available. So it's value dot block hash. And the same thing is going to be.value. last valid block height. There we go. So we have our transaction.
06:58:10.549 - 06:58:34.261, Speaker B: Now we need to just send it. So we're going to do a return, await, send transaction. This is the thing that we ended up creating earlier. It's going to be transaction comma, connection, and that is it. And we have a signature. So let's go ahead and check that in practice. So let's go to our voting D app.
06:58:34.261 - 06:58:50.965, Speaker B: We're going to refresh it because it's probably aired out at some point whenever we were doing it. Okay, so it looks like we're just missing a comma somewhere. Okay, so we have this. Oh, we have an extra because I added an extra earlier. There we go. Refresh. Boom.
06:58:50.965 - 06:59:17.017, Speaker B: We have our votes. All right, so let's do a vote. I'm gonna have to log back in to my approve and let's look at the error. What was the error that we got? Let's see what error we got from here. I have to vote again just to see what the error is. Oh, transaction sent. So it looks like it was just some issue that we ran into.
06:59:17.017 - 06:59:43.239, Speaker B: That's fine. So let's close that and do it one more time just to make sure. Ah, vote. Failed to vote for candidates. Transaction sent. All right, so let's go look at that transaction and we can See here. Oh, it had 47,412 out of 7,700 compute units.
06:59:43.239 - 07:00:04.213, Speaker B: It added the vote and look at it. Actually it there's more compute as well. This is because the computer compute budget instruction actually takes a little bit more. And we can see here there's one instruction, two instruction, three instructions. So those first two are our instructions that we added. We added. 00001 lamp ports per compute unit.
07:00:04.213 - 07:00:43.525, Speaker B: You can see here the fee is that 5001 SOL. So we've added some additional compute or sorry additional prioritization fees in order to prioritize our transaction on the cluster. Now one thing is to note is that this micro lamp ports equals one is kind of a dumb value to give there. It's just always adding one. What if there's a very high value or very. Say our voting App goes from 10 users to a hundred thousand users. Suddenly those users might end up having to pay a higher priority fee in order to prioritize their transactions for this specific voting app account.
07:00:43.525 - 07:01:43.397, Speaker B: So let's think of how to do that. So if you go over to the RPC methods on the Solana.com stocks RPC and go to get recent prioritization fees RPC method. So this method will actually allow you to get the recent prioritization fees to check what are the fees recently and then make a smart choice on what I should do additionally. So we're going to go and do that. So const recent priority fees equals await connection. Get recent prioritization fees and then what this ends up giving you is it will be a recent prioritization fees list and you'll have to pull the right information out in order to figure out what is the current recent priority fees.
07:01:43.397 - 07:02:16.769, Speaker B: All right, so let's get the minimum the minimum fee in order to get on the cluster. So this will be just a min/ Recent priority fees.map fee not fee calculator but fee prioritization fee. Boom. So this gets our our minimum fee and instead of just putting one, I'm going to put our minimum fee right there. So this minimum fee is just going to be a number. It's going to be a very small number.
07:02:16.769 - 07:02:42.459, Speaker B: I want to make sure that this minimum fee might be. We might be paying a little bit more than minimum fee. So we're just going to add one to that. And let's go ahead and check it out on our voting dapp. So we click vote, it'll pop up our wallet, it'll vote for our transaction. We can see Transaction sent and we can see it was still 5,001. And this is because there's nothing happening on my local cluster.
07:02:42.459 - 07:03:24.685, Speaker B: So it added one more one, just only one more lamp port to my overall fee in order to get it prioritized. That's fine, but however, this will increase if the priorization fee is higher. Another thing to note is that this is more looking at like global fees. If you want to actually use the real priority fees, you're going to have to add a config which gives the locked writable accounts. So this is something you'd have to do a little bit more of. So if we go into here and let's go look at that transaction again, we can see here that there's some writable accounts. This one's going to be the candidate account.
07:03:24.685 - 07:03:54.031, Speaker B: So if you go to the candidate account, you can see here what is it? What was a 9fd? Yep, that's the candidate account right there. That's what gets updated whenever you vote more. So what we ended up having to do is we actually have to give the public key list of the public keys that we plan on doing. And it looks like I probably. Let's see config. And then this is going to be. Let's look at what they can fig.
07:03:54.031 - 07:04:18.297, Speaker B: Get re. Okay, so locked writable accounts. There we go. So this will do the same thing. So if I just pull out and then go over here and run, it'll probably still do 5001. So let's run it. You can tell I really like smooth peanut butter, not crunchy 5001.
07:04:18.297 - 07:04:32.445, Speaker B: And it just. What it ended up doing is it's checking for that specific public key. So we can actually look that. Look at that and say the network tab. So let's. Let's run it one more time. Right here.
07:04:32.445 - 07:04:53.243, Speaker B: The payload was. This is the send transaction. Where is it? Get latest block hash. There it is. So get recent priority fees for that specific thing. And the recent priority fees, we can see that there's going to be a whole bunch and it's zero because there's no additional cost. So you can do either or this is just the start.
07:04:53.243 - 07:05:47.055, Speaker B: This is only to get you started. There's a lot more that you can do to kind of model recent priority fees. There's also some RPC services out there that model them for you and give you an API that allows you to just call that API specifically and get you a better modeled recent priority fee that might guarantee or better guarantee your inclusion on the cluster for all your users. It's very smart to do that. So there's some work that you'll probably, probably be doing in this regard to make sure that this is the best possible fee that you add to your new smart contract or sorry, your transactions for your users. You're gonna have to play around with it, but this is a basic way of doing it. Just take the minimum fee that was required to get on the cluster and add just a little bit potentially on top of it.
07:05:47.055 - 07:06:27.271, Speaker B: All right, so the next thing that we want to do do is if you've noticed throughout this whole thing what we've been doing is we're actually using the RPC that's provided to you instead of using our own RPC for all these, for all these different calls. So even if you look at our call right here, we did an RPC call for get recent prioritization fees. We did a RPC call for get latest block hash. This right here is a send transaction prior RPC call. So there's a bunch of RPC calls. Now this works for local, right? Because we're running our local test validator over here. Right here, this works for local.
07:06:27.271 - 07:07:05.099, Speaker B: But moving up to different environments, say we move to devnet or even later mainnet, which we're going to do in this boot camp. We need to go get an RPC provisioned for us. Now there's a number of different places you can get RPCs. If you go to Solana.com RPC you'll have a page that tells you a bunch of information about what you should do for RPC services. However, it also gives you some different RPC services to go out and get a private service. So this is going to be part of your leveling up system.
07:07:05.099 - 07:07:47.843, Speaker B: You've done a bunch of work on local. If you want to get on DevNet or even main, definitely before mainnet, you must provision some RPC of yourself. You cannot run on the public infra the, the rate limits are too high and will kill your application for users. So you have to get some, some RPC from this, this list. So what we're going to do is just pick a, pick one of these RPCs that you, that you're familiar with on this list and go ahead and grab it. So I'm going to go ahead and grab an RPC off off screen and we'll be back in a moment. All right, so I've grabbed an RPC for devnet and the thing that we're gonna have to do is we're gonna have to actually connect to it.
07:07:47.843 - 07:08:32.849, Speaker B: So I'm gonna go over here and we're going to change the devnet. All right. So one thing you can do quickly is if you do Solana config get you can see that every everything is set to local host now. Now we need to update to Solana config with the RPC. Now if you want to it's okay to use DevNet public RPC so we're going to do that first. So let's go Solana config set dash UD you can see it now is updated to the public infra for Solana Devnet we're going to clear that and now let's go ahead and push this to devnet. Alright so I'm going to go over to here right here and we're going to clear it and I'm going to do an anchor deploy.
07:08:32.849 - 07:09:01.979, Speaker B: So this will now deploy to devnet. All right. So it looks like deploying it try to close try to also deploy to local again. So let's just make sure Solana config get it is set to to Devnet. So let's go update our anchor toml to deploy to Devnet. Here we go. So we're going to change this to I believe it's devnet and make sure that.
07:09:01.979 - 07:09:24.641, Speaker B: Okay so cluster is also devnet. There we go. So everything is now set up. So let us deploy to Devnet. We'll do anchor deploy. You can see now it's doing deploying cluster API.devnet.solana.com and it's deploying and we have now ace smart contract id.
07:09:24.641 - 07:09:43.259, Speaker B: Let's go look at it on devnet. So I'm gonna go to. Let's close up some of these windows. We're gonna go here, we're gonna switch to Devnet. We're gonna type in that specific smart contract and there we go. We have now officially deployed something to Devnet. Now you might run into some issues with like hey, you don't have enough soul.
07:09:43.259 - 07:10:18.095, Speaker B: If you need soul or Devnet soul you need to go to faucet.solana.com you take in your wallet so you can find that by doing Solana address. So take that wallet, you put it right here and we probably only need like five. So we put it at five and confirm the airdrop. It'll ask you to do some captcha and it should give you an airdrop. There you go. So and if you, if you want to get even more solo, you need more solar, go ahead and connect your GitHub and this will give you a higher airdrop limit overall.
07:10:18.095 - 07:11:06.715, Speaker B: So we have deployed to Devnet, we have our smart contract on devnet. Now I'm going to give a few notes on devnet. So we have our deployed to Devnet, but we don't want to make this our main area of development. We want to make sure that we're focusing on building on local and using devnet as more of like a testing environment, making sure everything works. Like, for example, what I would want to do is this spec might. Or this testing spec might have a DevNet specific one and I might have a DevNet. Let's see a test test that runs via CICD whenever I'm pushing to GitHub that runs this and before I move to production.
07:11:06.715 - 07:11:35.665, Speaker B: That's something that you just need to make sure that you have. You don't want to build completely on devnet because devnet is just a quality assurance environment. It's not our environment to run everything on. If you want to run. If you want to build on Solana, you should be building on local, moving, testing and checking on DevNet and then finally pushing to production. So we've made a devnet. What next? The next thing I'm going to do is we're going to go ahead and make another GitHub repository.
07:11:35.665 - 07:12:09.715, Speaker B: We're going to do some things that allows us to check a bunch of information about our smart contract with GitHub Actions. So I'm going to make a repository. We're going to call this the voting app. And I'm just going to create a public repo and let's go ahead and create the repository. I'd recommend y'all do this as well. And we're going to go ahead and click this button right here for copy and we're going to push it to our new repo. So let's go ahead, make sure that we're in the right repo or the right folder.
07:12:09.715 - 07:12:39.315, Speaker B: This will be the Project 14 root directory. And we're go ahead and paste all those commands that we just copied and hit enter and we can go ahead and look at the repo, make sure it actually pushed. And it should have pushed. Yep, Developer Boot Camp voting app. All right, so we have everything. Now let's make sure we add everything. So GitHub status, it has a whole bunch of uncommitted changes.
07:12:39.315 - 07:13:03.087, Speaker B: I'm going to also just make sure Git remote, make sure that's set. Yep. All right, so it's set on origin. Perfect. So there's a few things that I Want to add real quick is we're going to create a gitignore on our project so that we ignore a bunch of the things that we don't need. So if you click new file not there, we'll need it over here. New file.git
07:13:03.087 - 07:13:25.105, Speaker B: ignore. What you can do is you can actually copy and paste the gitignore from the original project. So let's go to that original project, the boot camp. Let's go to our gitignore file. Whoops, right here. And I'm going to just grab that gitignore file, boom, copy and paste it and put it right in there. Alright.
07:13:25.105 - 07:13:46.935, Speaker B: So this will basically ignore a lot of the extraneous things that should only be deployed on local. So let's just go get status. There we go. We have everything it's missing. It looks like it's still adding a few things. I think it's dot nx do we need a dot X? Let's go see. Well, yeah, let's.
07:13:46.935 - 07:14:14.605, Speaker B: That's just a cache. We don't think we need a dot IN X. All right, so get status. There we go. So it's now removed most of those things. So we can just do, get, get add all. It'll add it all to staging and get status Git Commit initial project and get push.
07:14:14.605 - 07:14:57.145, Speaker B: And so this is now pushing our entire voting application project to our GitHub repo. We're going to need it in our GitHub repo to do some work next via GitHub Actions, verifying our smart contract and a little bit more extra work. So let's go ahead and wait for this. Okay, so it added everything it pushed and if we go check out this repo right here, we can see my voting app. I have my initial project, everything's here has that very basic readme. So we are ready to do the next step. So first thing what we're going to do is we're going to add a thing called radar.
07:14:57.145 - 07:15:17.235, Speaker B: This will be for static analysis. It's going to basically check the security of our project. So we're going to add a folder. Let's go ahead. And we're going to go look at the radar thing real quick. So Radar Solana, this is under auditware Radar. This should be all under the readme for the original project.
07:15:17.235 - 07:15:45.645, Speaker B: And you can see here go all the way down. There's some information on it. But we want to just add it to our GitHub action. So we're going to just grab that radar action and we can See here we can just add it to our repository and it will be good to go. So let's go ahead and add it. So we need to add a folder in the root directory of our project. We're going to call this.GitHub
07:15:45.645 - 07:16:17.735, Speaker B: and inside that, that also needs a folder called workflows and we're going to create a f a file called radar YAML. All right, so we can go ahead and copy and paste that radar action. So let's go grab it real quick. So radar action. We're going to just copy this right here. So on push do something. And you can see here it does an output file, there's an upload, it'll do just do path.
07:16:17.735 - 07:16:34.749, Speaker B: Our path is actually slash anchor. So we're going to pull it from anchor and we want to see. Let's just do. No ignore. So ignore should be a. There we go. It's a temporary thing or a optional thing.
07:16:34.749 - 07:17:05.011, Speaker B: And we're just going to add that. So it's got a status git add git commit feet, static analysis. Get push. And so what static analysis does is it'll check our git repo. So if we go, let's close that. If we go here, it'll basically be running a scan on our git repo, our smart contract to see if there's any vulnerabilities in it. And it's always good to have this.
07:17:05.011 - 07:17:36.797, Speaker B: So this is going to be one of the actions that we add to double check. Hey, is our git repo all good? If it is awesome, we we can move to production. If it isn't, let's go fix those different findings that the stack analysis this scanner found. So I'm going to go ahead and open it right here and we're going to wait for it to complete and we're going to go look at its findings. All right, so it's all done. So let's go check out our findings. You can actually go just look up here.
07:17:36.797 - 07:18:05.519, Speaker B: You can see the results. It says, oh, it actually did find a few things. So missing signer check found at this line. So line 45, it's going line 45 of our code and see what it's talking about. Libraries line 45. So line 45 is it has a signer check and what it's saying is like, hey, there's no signer check to create this account. So we have a few accounts here, we have a candidate account, we have a poll account.
07:18:05.519 - 07:18:36.609, Speaker B: So it's like, hey, there needs to be a check to. To Create these accounts. Now for us, we don't actually care because what we're doing is anybody can create these and we're okay with that. If you are making it better or more extensible or hey, there's only one person create that account. That's something to consider. So these are like considered low errors. So it's something that you always can you always look at says okay, so we have duplicate mutable accounts found on line 16.
07:18:36.609 - 07:19:06.005, Speaker B: Let's go, go look at that real quick. Right, so on line 16 we have this poll equals mutable account, immutable accounts poll. So what it's saying is this poll because I made it another. It's already mutable. It's actually set as mutable down here. Let's see where this is in the initialized poll so that it will have the INIT right here. So this in it actually makes this poll mutable already.
07:19:06.005 - 07:19:26.989, Speaker B: So we didn't have to do that. This is just to be careful, like making sure that we don't make something mutable that we don't know about it. It's okay here. And also missing owner check. Making sure that it owns this is probably what, 45? Sort of 45, yeah. For vote. Making sure that the person who's updating this account actually owns it.
07:19:26.989 - 07:19:49.999, Speaker B: We don't have. We, we don't care. Anybody can update this account because anybody can vote. So these are just telling us like, hey, make sure that you are covering all these things because if you're not, you should. You probably have a security vulnerability. All right, so we just spent some time adding a static analysis to our application so that we can check it before we get to production. Now this is just some preventative measures.
07:19:49.999 - 07:20:29.815, Speaker B: There's even more that we can and should do in order to, to make sure our smart contract is properly secure when we deploy it to production. So one of the things is we should get an audit from some security company to audit us. Radar won't cut it. It will give us a lot of like heads up and save us some, potentially some headaches. But should definitely get an audit on our smart contract. If you want to do that, you can just go look up slot of smart Solana auditors and you should get some list of auditing companies. What you can do is also you can check what auditors that Solana Labs has used.
07:20:29.815 - 07:21:04.785, Speaker B: If you go here, you can see all the different reports. We have Halborn, Neodymium, Ski Otter stack, Trail of Bits, Zellick. We have a bunch of different auditors auditing the salon want a core code base. Now these might not be your bet, your the auditor for you, but definitely do your research. Go find an auditor out there. I just gave you a list of names to go check out. There might be more for you out there for your smart contract, but it is an absolute requirement for get to reduction because you don't want.
07:21:04.785 - 07:21:49.133, Speaker B: The last thing that you want is an exploit getting deployed and you get some odd hundred millions of dollars in your smart contract and that exploit is used to drain all the funds. That's the last thing you want. So definitely get an audit. These audits don't guarantee, but they're a good preventative measure to prevent you from running into an exploit in production. All right, so the next thing we're going to do is we're going to actually deploy our smart contract to mainnet or production. While we won't have anything on the front end deployed to actually interact with it, we will go through the steps to deploy it from our local setup to production. So let's get started.
07:21:49.133 - 07:22:34.379, Speaker B: First thing that we're going to have to do is we're going to have to set our URL using the Solana CLI to that specific RPC that we bought on earlier. So let's go ahead and do that. So I'm going to do Solana config, set dash URL, I'm going to go grab it and set mine. I'm not going to showcase mine because anybody can use it. But we'll be back in just a moment. Right, so the way that you can check if you set it correctly, which I just showed you the command, is you can do Solana config get. And this Salonic config git will showcase the specific URPC URL that you set your configuration to.
07:22:34.379 - 07:23:10.049, Speaker B: All right, let's go ahead and deploy now. So what you have to do in order to deploy your smart contract to mainnet, it's a little bit different than what you're. You're used to on deploy. So normally you would do anchor, anchor deploy. Right? That's not what we're going to do here. We're going to use the base Solana clock, which is going to be Solana program, deploy, target, deploy, the specific SOV file, the binary file that you're going to deploy. This is our smart contract binary and we're going to do a couple additional flags in order to make sure it gets to production.
07:23:10.049 - 07:23:42.215, Speaker B: So remember earlier in this specific part of the boot camp, we did something with priority fees. So we're Going to do the same thing with this with the CLI because otherwise we won't be able to actually deploy our smart contract to production. I'm going to add. I'm going to add a little bit. You can add your own. What I would recommend is double check what is normal and what is average. So we can go check right now actually and go to Solana Compass.com
07:23:42.215 - 07:24:13.139, Speaker B: you can check this. You can also check some other websites but you can see what the average priority fee is in Seoul. So the average priority fee is it's about 12 or 10,000 ish with the mean fee being about 80,000. So I'm going to go to make it 80,000. You can do it less, you can do it more. Depends on how much you want to wait. And then I'm going to do something called User PC.
07:24:13.139 - 07:24:46.877, Speaker B: So what this is is if you're using an RPC that is paired correctly to a actual staked validator that's voting on the network that makes it more likely for your transactions to make it to the network. You can find more information via the stake weighted QoS article. So let me go pull that up. What is stake weighted QoS should be on Salona.com there's also. So there's a good guide on Solana.com to what stakeway to QoS is.
07:24:46.877 - 07:25:23.331, Speaker B: It's basically just allows you to hit your validator if the OR hits your RPC and use stake that's on a actual validator on the network to guarantee your transactions make it to the network. So let us do that. So use our PC. That's what we're going to be doing there. And then I'm going to add a max sign attempts. We might not need these but what this means is hey, there's a bunch of transactions that happen with a Solana smart contract deployment. If any of them fail make sure that you retry them a little bit.
07:25:23.331 - 07:25:51.547, Speaker B: So let's go and hit that and let it get started. So, so you might also want to make sure before you start this you check your balance. You can check that with Solana balance. Um, so I have a little bit of SOL on my local and you can send yourself money by just typing in Solana address and that's your address that you send your SOL to. And this is real SOL because we're deploying to a real network. All right, so let's deploy to mainnet. Um, I'm going to go ahead and do Solana program deploy right here.
07:25:51.547 - 07:26:11.435, Speaker B: Here with some compute unit price user RPC with a thousand max attempts. And we're, we'll. We will be back in a moment while it deploys. All right, so we have a program deployed. It took a few try retries. You can see it took six retries. I put a thousand.
07:26:11.435 - 07:26:29.001, Speaker B: I probably could have increased my priority fee to be a little bit higher and would have gone a little bit faster. Just you can check and try different priority fees. I didn't make myself above the median. You can see the median. It's actually, I would. It looks like I was above the. I was above the median and I'm above the mean.
07:26:29.001 - 07:27:00.259, Speaker B: So I was there, but probably not good enough to be very quick. So I paid a little bit, I got through eventually and we've deployed it on into production. So we can actually go onto the Explorer. So let's go over here and I'm going to switch to mainnet and we're going to put in this program ID and boom. We can see that this is the program account for our smart contract. Now it doesn't have much information about. You can see it's missing like security and doesn't have any domains.
07:27:00.259 - 07:27:19.757, Speaker B: But it's here and you can see my upgrade authorities. Right here we have our smart contract on production. So congratulations if you made this far. This is awesome. It didn't cost that much too. So we can actually check. So previously I had, let's see, previously I had a little over seven souls.
07:27:19.757 - 07:27:53.487, Speaker B: So let's do Solana Balance Dash, um, as well. So it costs a little bit around like 2 soul to get deployed. Um, so that's a small program or small smart contract. So good to go. So next up, what we're going to do is we're going to create a verifiable build so that people can view the smart contract code for our smart contract within an explorer. So they can basically verify, hey, this is the code that I'm interacting with and this is what I expect it to be. So let's go and do that.
07:27:53.487 - 07:28:15.449, Speaker B: So in order to do that, we're going to install something called Solana Verify. And you can do that by just typing in cargo, install Solana Verify. Something clear real quick. So we can do Cargo install Solana Verify. If you enter, it'll install it. I already have installed, so I'm not going to do that. And then we're going to use something called the Verifiable Programs API.
07:28:15.449 - 07:28:53.405, Speaker B: What this means is we're verifying that the code equals what's on chain and we're uploading it to in this case ottersexual API. In the future this might be on chain, but today it's via an API. So we're going to add and run that command. So it's Solana. Verify, verify from repo remote dash, um, dash dash Program id. We're going to do the program ID that we have on chain. And so here it is right here.
07:28:53.405 - 07:29:20.895, Speaker B: There we go. And then it's going to be our GitHub repo. So let's go grab that GitHub repo real quick. It's right here. I'm going to go ahead and remove all the extra work because we don't need all that boom. And we're going to put that right here. And then we have to give the library name.
07:29:20.895 - 07:29:49.605, Speaker B: So you can find this library name in anchor cargo. It should be cargo Tamil. And you can see here, not our, sorry, the anchor toml. And you can see here that, let's see. Oh some programs. Cargo toml and its name is voting. So that's under the lib name.
07:29:49.605 - 07:30:10.031, Speaker B: So libvoting. So we're going to call this voting. And then finally we have to give the mount path because our specific repo is not in the root path. Our cargo toml is not in the root path. We have to give it. It's actually in the anchor folder. So we have to do mountain path anchor and enter and starts verifying.
07:30:10.031 - 07:30:49.345, Speaker B: So this will take just a moment. We will come back very quickly. So while that runs, what we're going to do is we're going to check actual smart contract that has been verified on chain to showcase what it looks like in an explorer. So here I am on Sloan FM and we are using the Phoenix program here in. You can see that has little build verified here. You can go check the verification and you'll see, oh here's an actual full end to end amount of the code available so that you can see everything here. This is great.
07:30:49.345 - 07:31:36.581, Speaker B: And it's great for also people wanting to build their own smart contracts to view them and see what's going on on chain. So highly recommend it. Definitely do this before you do anything in production and let's move on from there. All right, so the next thing that we're going to do is we're going to actually upload our ID out on chain. What this does is it allows other people to pull our ID out down and be able to interact with it or understand how to call your program. This allows you to do like things like generate crates to interact with your smart contract and to make sure smart contract overall more composable across other smart contracts because they can actually interact with it. So you can see right here that the IDL Internet thing is right here is how you do is right here.
07:31:36.581 - 07:32:10.395, Speaker B: So we're going to just run it right real quick. So I'm going to go in here, run clear. We're going to CD into my anchor folder and we're going to do IDL init and says to do the target IDL voting JSON and then my specific program id, which we have over here. There we go. Hit enter. And what this will do is actually upload my IDL onto on on chain. So you can actually pull this down as well.
07:32:10.395 - 07:32:29.121, Speaker B: You can pull it. Let's see if we can pull it down with IDL fetch. So you can fetch the IDL for the specific program id. So if you do anchor IDL fetch with the specific specific smart contract id. So let's do that right real quick. It'll fetch it. And there we go.
07:32:29.121 - 07:33:04.265, Speaker B: There's our candidate idl. It's all in the CLI here. We can output into a specific file, but it's now unchained so anybody can pull them down and use it to interact with your smart contract. Okay, so for the last thing we're going to do is we're going to upgrade our smart contract deployment to use an upgrade authority that is a multi sig and not a single authority. So what does that mean? If you look at your actual smart contract, you see the upgrade authority is this key, the cwt. And I own that key right over here. So let's go grab it real quick.
07:33:04.265 - 07:33:46.585, Speaker B: So if we do clear sauna address, you'll see that my key is cwt. So if someone were to exploit my computer or something and get this key, suddenly they have access to upgrading the smart contract and can upgrade it to something that might cause a vulnerability, an exploit or something. It can create an attack. So we're going to create what's called a multi sig and use that to avoid any one key getting attacked. It actually takes multiple signatures to get attacked in order to upgrade my key. So let's go ahead and do that real quick. So we're going to use squads to do that and we're going to create a squad.
07:33:46.585 - 07:34:07.439, Speaker B: All right, so I have. Let's make sure that this is right. Okay, cool. So we're going to call this the voting squad. And this is going to be voting for boot camp. And we're going to use this to create our squad and add our different members. So one of our member addresses will have to be this.
07:34:07.439 - 07:34:28.969, Speaker B: The other one is going to be our. Our wallet that we're connected to right here. And we're going to set another confirmation threshold. This confirmation threshold is just for how many confirmations need to approve a transaction. We're going to have it as one. Because it doesn't actually, we're going to. We're going to have it as one.
07:34:28.969 - 07:34:55.811, Speaker B: What I recommend is you set another one. So let me just set another one real quick. We'll grab my phantom address. There we go. So here we have three addresses, one being my backpack address. So let's just make sure that's my backpack address. Yep.
07:34:55.811 - 07:35:24.065, Speaker B: E8W. One being my C, my CLI address and one being my Phantom address. What I recommend is have it be three different CLI addresses. But because I'm just doing this as an example, we'll do that here. And then we have to set our confirmation threshold. So this confirmation threshold, we're going to set it as two. What this means is that two of these addresses or two of these key pairs need to provide a signature in order to upgrade the smart contract.
07:35:24.065 - 07:35:45.663, Speaker B: So two out of three, we shouldn't just do one because that's even worse security. We should have a two or three or what, five of eight, Something that is takes a majority with a lot of key pairs. So let's go ahead and hit next. We can see here setting. We're going to create the squad. It's got three different members. It takes two, three to upgrade.
07:35:45.663 - 07:36:00.551, Speaker B: And this is our fee. That's all right. We can do that. All right, let's confirm it and we'll ask for confirmation. We're going to approve it. And this should create our multisig on chain. There we go.
07:36:00.551 - 07:36:24.081, Speaker B: We've created. We've created our squad. And so what we're going to do next is we're going to use this to upgrade our authority to this specific squad authority. So let's go and grab that. So what we can do is we want to change our authority to this one. So we're going to go ahead and copy this squad. This is the squad right here.
07:36:24.081 - 07:36:49.455, Speaker B: And we're going to update it to this account because we want to make sure that this account is. Is the one that can update our smart contract. All right, so if you go over here to developers, go to programs, we can see here there's no programs yet. So we're going to add a program and the name of program. We'll call this voting app. And we're going to give the whoops, we're going to give the voting id. So let me go grab that real quick.
07:36:49.455 - 07:37:06.145, Speaker B: Boom. Go back to squads. Put the address in there. All right, let's do next. You need to sign a message in order to use functionality. So we're going to assign it that way. We're adding this program.
07:37:06.145 - 07:37:37.623, Speaker B: All right, so we've added the program and tells us, hey, set the upgrade authority of this new one to our squad. So let's go ahead and run that real quick. So we'll copy it. We're going to go over here into our visual studio and we're going to run that command that it gave us. And so that'll upgrade it from the authority of the CWT to this new authority of the squad. All right, now we can go check that on chain real quick. Refresh this right, right here.
07:37:37.623 - 07:38:14.171, Speaker B: We can see now it's no longer CWT, it's that G1Y, which is our squad or our multi sig. So after the action is done, click verify authority, we can click that and boom. We have our new smart contract. And so this is the smart contract that we want to do in order to. Or this is the multi sig that we use to now upgrade our smart contract. I would recommend doing this for not only smart contracts, but also if you do any tokens and you want to have the mint authority still, I would recommend having the mint authority also governed by a multi sig. So here now I have this voting app.
07:38:14.171 - 07:38:41.053, Speaker B: It is a smart contract and I want, I say I want to actually upgrade it. So what we're going to do is we go into here and we click add upgrade. Let's call this voting v1. We're going to need a buffer address and buffer refund. This buffer refund we can just say is our current wallet. So I'm going to grab that one real quick. We don't have to do the commit link, that's fine.
07:38:41.053 - 07:39:15.061, Speaker B: And this is the authority address. So for the buffer address we actually have to, looking at the logs, do a write buffer. So let's go ahead and do that right in here. So Solana program write buffer and then we have to do target deploy voting. So and what this will do is it will actually create a, a write buffer account for our voting. So our voting binary. And you can see it's actually trying to write and run a bunch of things.
07:39:15.061 - 07:40:02.725, Speaker B: We don't actually do that. So we want to do use rpc and then with what is it with compute priority Fees. Let me go ahead and pull that up real quick with computer unit price and we're going to do. I'm going to do 150000 for this one and max sign attempts 1000 again. Should be with. With compute unit price. There we go.
07:40:02.725 - 07:40:20.185, Speaker B: All right. So I ran into an error. This is fine. It's just I will have to run it again. That's fine. All right, so it's finished. It took about five tries.
07:40:20.185 - 07:40:55.401, Speaker B: We now have buffer ID so we can go back to the squads that we have put in that buffer address and we hit next. And what it says is it's trying to tell us to set the buffer authority to that specific multi sig. So let's go ahead and do that. And this will just send a transaction real quick. Boom. Now the authority is that multisig verify the ethnic authority and boom, we have a new. A new V1 and so we can hit upgrade and we can initialize the upgrade.
07:40:55.401 - 07:41:22.455, Speaker B: And what this will do is it will require us to sign it on two different wallets that are on the multi sig. So let's do that on that one and we can see boom. We have the upgrade. It's starting to be activated. But we need two approvals in order to activate. So I'm going to go ahead and log into my other wallet. So let's go log into that wallet as well.
07:41:22.455 - 07:42:02.905, Speaker B: Phantom I'm going to approve and once I approve on phantom it should be able to initialize and send the upgrade. To send to upgrade my smart contract says confirm. There we go. And so now we have two of two and we can execute. So I'm going to go back to my backpack wallet and I'm going to execute the upgrade. We're going to go ahead and confirm the transaction. Looks like I'm going to receive the buffer SOL as a refund.
07:42:02.905 - 07:42:40.667, Speaker B: And there we go. It's been confirmed, it's executed and it has been upgraded. So that's how we did smart contract upgrades with squads with a multisig to keep it very secure and so that there's not one source of failure with a multisig. So it's great. So we've now gone through a number of different things in order to bring your smart contract to production. There are still some more things like this is not. This is not full encompassing.
07:42:40.667 - 07:43:47.151, Speaker B: Obviously there's still more things that you can potentially do. Things like you could put your RPC between behind like a caching layer so that when you make the RPC calls, if there's a lot of RPC calls it caches the responses so that you can get better better responses for your users on your ui. We haven't deployed the UI yet. I mean you can do there's plenty of tutorials of how to deploy UI out there. I'd highly recommend just using one of the tutorials but we've taught you all enough to get your smart contract to production and teach you some of the ins and outs to get started. So without further ado, that's our everything that we have for today and that is and now congratulations you've made your smart contract into production. If you have any questions, feel free to put them on the GitHub repo and definitely check the GitHub repo if you run into any issues during this and specifically the GitHub repo is developer bootcamp there might be running you might run into something that hey, this command didn't work or something changed.
07:43:47.151 - 07:44:22.881, Speaker B: There's always updates going on in the salon space, so definitely check this repo out as you're building, especially this last project. See if there's any notes on the updates and then we will see you next time. But yeah, good luck. Congratulations on making it this far. This was a ton of content to get through and a huge commitment commitment to make. If you've built every project, you should have a pretty good understanding on how to get started building your very own Solana projects. Don't let this be the end of your journey into blockchain development though.
07:44:22.881 - 07:44:42.475, Speaker B: There's a ton more out there to dive into. Use your newfound knowledge to join a hackathon, find a local Solana community to join or if you have what it takes, try creating your own project and start a career within this industry. Make this the beginning of your development on Solana. Congratulations again and I look forward to seeing you in the Solana developer community.
