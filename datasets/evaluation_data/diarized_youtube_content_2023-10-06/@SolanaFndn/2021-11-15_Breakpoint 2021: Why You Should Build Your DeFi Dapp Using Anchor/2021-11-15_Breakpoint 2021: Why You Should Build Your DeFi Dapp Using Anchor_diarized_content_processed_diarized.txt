00:00:09.200 - 00:01:05.394, Speaker A: Oh, shit. Ah, very good. So this is a talk for aspiring smart contract devs. You get a lot of people coming into the forum and they ask, should I use Solana core or should I use anchor? And my response, unfailingly is, just use anchor. So imagine for a second that you're a new smart contract dev to the Solana ecosystem, and you want to build the next great DeFi dapper. But then you discover the Solana programming model, and it's confusing as fuck, and it's throwing bytes at you left, right, and center, and you don't know what to do with them. But thankfully, there's the anchor framework.
00:01:05.394 - 00:02:12.244, Speaker A: And the anchor framework defends you by converting those bytes into a usable, human readable format. It provides a set of tools and clean APIs for common functions in the slan ecosystem, and it also eliminates a lot of the foot guns, which I guess beginning devs would run into, and even more advanced ones, of course. And eventually that will give you the confidence and the strength to overcome the Solana programming model and build the next great Defi Dapp. So just quick, who am I? I programmed the Ido pool code. It's a token sale mechanism designed to combat the botting of other token sale launches that we'd seen in the Solan ecosystem. And it was designed by Daffy of Mango, and it's been used by mango, Parrot, Orori, and Solend to raise over $275 million at this stage. My own project is foresight, which is an order book based prediction market, which is using anchor framework and built on top of serum.
00:02:12.244 - 00:02:47.434, Speaker A: So back to anchor. What's great about anchor. So the first thing is how it handles serialization for you. There's two main types of serialization in Solana. There's the transactions, and then there's the account data, and then again, moving on, there's program derived addresses, which are pdas. And the great thing about PDA's. So pdas are essentially a way to find the public key for any particular account on chain.
00:02:47.434 - 00:03:22.374, Speaker A: If you know the format of the seed, you can find the public key. And this is great for two reasons. The first being that on the front end, accounts and public keys are really easy to find. The alternatives are to hard code them or to do like a find program addresses, lookup, and then filter, and then filter again super slow. And the second is security, which I guess these guys are talking about. So you can add the seed into your program, and that way your program knows exactly what public key it should be getting. And it gets very hard to slip in incorrect accounts.
00:03:22.374 - 00:04:02.904, Speaker A: And then the other thing that I really like about anchor is just that it helps you write cleaner code. So again, there's some like very clean APIs for common functions. So initializing accounts, particularly when it comes to the SPL token accounts, the Mint accounts, associated token accounts, and then also cross program invocation, there's a consistent API for that. So cross program invocation is trying to call a program from within your program. So calling another program. So for example, you want to call the SPL token program if you're going to transfer some tokens or you want to call serum if you want to place an order. And there's some really good APIs for that in anchor.
00:04:02.904 - 00:04:28.960, Speaker A: Alright, here's the dangerous part. No one thought this was a good idea. Counterconnect. I think we're good. We got Internet, I have it memorized anyway. So if that fails, well, let's wait and see what happens. The things that I was going to show you.
00:04:28.960 - 00:05:01.524, Speaker A: Oh yeah, here we go. So this is if you were to type in on the command line anchor initdao, this is the files that you would get. This is like the default initialization. This is the test file just for the client side. And this is the actual program itself with the real meat of the logic. So in the standard program model you want to store data on an account, activating extensions, of course. So here we go.
00:05:01.524 - 00:05:47.354, Speaker A: So first off, what we're going to do is we're going to store data in an account and that's derived default and we're going to make, I guess we're going to make a dao, since I like daos. But it's going to be a very, very basic one and we're going to call it diodetails. And then in that we're going to store who the DAo authority is. So it, this could be a multisig, it could be a public key linked to something that actually votes. And then we're just going to set like a max supply which is just linked to say how many tokens can be. And that's the data, that's the format of the data that is stored actually on chain. And this little macro here does the serialization deserialization for you.
00:05:47.354 - 00:06:28.724, Speaker A: So again, in Solana, you need to know what accounts you're going to be using. So we need to tell it which accounts we're going to send in so that it can know what data to load up. And the first thing that we're going to need is the authority. And that's going to sign the transaction so that we know for sure that this account is sending that transaction. And then we're going to do a little quick PDA. So we're going to initialize a PDA and we're going to set some seeds. So our seeds are going to be based on the authority itself as ref.
00:06:28.724 - 00:06:51.352, Speaker A: And then we're just going to do like a namespace thing. So we're just going to call it dowdeets. And then we add the bump, which is, again, there's a lot of details to PDA's that you don't really need to know immediately. And bump is one of them. And we're going to payer equals authority. I guess we can just make a new line there. Cool.
00:06:51.352 - 00:07:32.592, Speaker A: And then this is going to actually be diodeets and it's going to be an account. And we just need to tell it what type of data is going to be on there, which is, again, this dowdeets struct that we've just made there. And as part of initialization, there's the system program, which I, I don't know how familiar you'll become with it, but it's sort of how you initialize accounts. You have to initialize the space, how much data is going to be on it, how much, Solana, you want to put into it. But honestly, I never interact with system program all that much, apart from just putting it in as an account. So this is one of these fucking things. Anchor knows what the system program account public key is.
00:07:32.592 - 00:08:04.294, Speaker A: And so it has like this program system to make sure that when you're sending that transaction, it is the correct address. And someone hasn't just tried to cheat you by slipping in a little bit extra. So let's see how much more we can get done in time. So we're going to let the user or whoever is sending over the instruction decide what the max supply is. And then our business audits is going to go in here. So we're going to borrow a mutable reference. So I'm going to say dowdeets equal to unmute.
00:08:04.294 - 00:08:36.194, Speaker A: And then we're going to get one of the accounts and this one is going to be dowdeets. Right. And then we're just going to, again, anchor handles all of this. Right. You assign this mutable reference and then all you have to do to update the data on that is just assign it. Did I get that right? Account dates? No, that's fine. Is equal to CTX accounts authority key.
00:08:36.194 - 00:08:57.014, Speaker A: That looks good. And then we'll update the max supply with the value that was passed in. But maybe you guys would want to be more secure in checking different things. Let's see what file we've got. No field dowdy. It's on. Type mute and initialize.
00:08:57.014 - 00:09:37.226, Speaker A: You know what? Yolo. Moving on. So this is your client. So this is what your front end Dev or your full stack dev is going to be looking at. And then we get to see the value of program derived addresses here. To get the public key for this DAO Deets, this data account where we're going to store the details of our daO, what we have to do is just assign, we just have to use a find program address. So anchor Web three, I think it's in public key findprogram address.
00:09:37.226 - 00:10:30.144, Speaker A: And then we just put in our seed. So our seed is it's our authority, but in this case it's just going to be our provider's wallet public key, and then put that to buffer and then, oh yeah, and then buffer from dao Deets. And then just because again, another one of these quirks about how program drive addresses work, you need to name space it to the program's public key as well. Oh yeah. And we want to initialize what our max supply is. Let that supply, and that's just going to be a new anchor big number, and I guess we'll just give it 20 million. That seems like a reasonable number to pass in.
00:10:30.144 - 00:11:13.984, Speaker A: Okay, so await program RPC, initialize. That's going to call our function on the blockchain. So we're going to pass in our argument max supply, and then we're going to need again pass in, excuse me, the accounts. And for accounts we're going to have, the authority is going to be the program provider. Wallet, public key diodes is already there and system program is stored, I think, on the web3 library system programid. Cool. And that's it really.
00:11:13.984 - 00:11:41.572, Speaker A: I guess I'm also going to show you some fancy stuff. Not fancy stuff. Well, I'm skipping ahead a little bit, but you've got to realize that comparing Solana core with anchor, it's really all the stuff that you're not seeing here. You're not seeing all of the serialization effort. So for example, there's four main, I guess, serialization steps. There is. You've got to take this transaction and you've got to convert all those bytes.
00:11:41.572 - 00:12:16.978, Speaker A: So you've got the bytes for any arguments you've got. So that's the data. You've got the public keys of the accounts. You've got the function that you want to call, and then you've kind of got the format that you're calling. And then in your actual program you need to have all this code that says ok, which function am I going to go to? How am I going to parse that data? How am I going to deserialize all these accounts and all the account infos? So that's the transaction serialization. And then there's the account data serialization where it's like, ok, I've got bytes on an account. I want to read those bytes and put them into this struct.
00:12:16.978 - 00:13:03.626, Speaker A: And then I want to also be able to update those bytes and send it back and have it update correctly. So that's one of the really great things that I think that anchor takes away. And then I'm going to show you the PDA part, which is, so we've assuming there wasn't a compile error, we've initialized our account and we're going to look it up. So we're going to do, let's do data equals to await this one's hard anchor account diodeets. And that's diodeets fetch. And then we pass in the public key of this dowdeets. And then it's really as simple as that.
00:13:03.626 - 00:13:39.794, Speaker A: You fetch it, you've got the data, and we could just do console log max supply, and then I guess data dot max supply. All right, six minutes left. Let me just quickly look at this. There is no field diodes on type and muteinitialize CTX accounts. I've probably done something wrong there. So let's look at this. CTX accounts authority.
00:13:39.794 - 00:13:55.258, Speaker A: Someone shouting out the answer. Let's put pubs in front of all these. Oh no, no, I see it now. I haven't closed this properly. Okay, yeah, yeah, that's where it is. Perfect. And then we just put that inside there.
00:13:55.258 - 00:14:08.314, Speaker A: Nope. This is why people told me not to do live coding, I think. Oh yeah. And then we put dao authority. Cool. All right. Let's hope it'll run out of time.
00:14:08.314 - 00:14:23.814, Speaker A: All right, anchor test and anchor test. That's it. You just hit anchor test. It compiles, it throws up a validator. Local validator. It's pretty amazing. Undefined is not a function.
00:14:23.814 - 00:14:40.774, Speaker A: Oh yeah, that's going to be this one. Did I use await? Let's just do a canvas. Okay. And then I'm going to just abandon it if this doesn't work. No, fuck that. All right. Life coding over.
00:14:40.774 - 00:15:03.348, Speaker A: I'm all about making your life easy. You don't need to see things. Compile to know that it would compile if I had an extra five minutes to debug it. So, yeah, so from having like hundreds of people come into the anchor discord, the Solana discord, and ask like, oh, I'm making my first program. Here's the vow that you need to make right. Don't use vexor strings. Design around using fixed arrays.
00:15:03.348 - 00:15:47.362, Speaker A: Strings are just u eight s in a fixed array, so overalllocate if you need to. But there's not great support for variable length data structures like vexor strings and anchor, or presumably solana, but I don't know, avoid optional counts. So optional counts a variable number of accounts you're going to pass in. Again, not well supported. In anchor, you really want to think about having separate functions where you initialize a data account and then you do the business logic on that data account. That's the best way to think about it. And then another weird thing anyway, please just wrap your Sol in an SPl token if you're going to use it, because it allows you to treat Sol as an equal member with all the other SPL tokens.
00:15:47.362 - 00:16:14.462, Speaker A: Otherwise you need to have a whole other separate set of logic just for Sol. And it's also really not supported well by anchoring what SPl tokens are. So just wrap your Sol and then. Yes, some of the facts of life, there's almost no documentation, but this isn't like a thing against anchor. This is a thing against both anchor and Solana. So I feel like it's a. Is it even? Yeah, I don't know.
00:16:14.462 - 00:16:41.364, Speaker A: Some people don't like discord or some people haven't used discord. Maybe you guys are boomers or something. I mean, I know I'm one, but just, yeah, join the Solana and anchor discord. Learn there's a discord search function. If you didn't know, it's very useful. So use keywords and phrases, type in your error messages, and then only then ask a good question. So ask something that I can give a reasonable answer to, or Alan, CHQD can respond to.
00:16:41.364 - 00:17:33.986, Speaker A: So ask good questions, please. And yeah, I don't know, because like, some of the Solana core devs, not the Solana core devs, but just there seems to be an attitude that there's something wrong with anchor, that it's not being promoted more. So I guess that makes me a toxic anchor maximalist. But really what I'm just trying to do is, I don't know, I want to help people get a better mental model of the account model in Solana and how it all works. From my own experience, I didn't understand the default approach when I used anchor. It helped me really get an understanding of, okay, here are the accounts, here's the data, here's the functions, here's how it all works together. And when I go into the client and I have to manually decode, I don't know, SPL token data and stuff like that, I'm able to do that now where I wasn't able to do it before.
00:17:33.986 - 00:18:00.228, Speaker A: I think that's just because I have a better mental model and I hope that other people can also benefit from that. Is that it? That's it. I also have two minutes left. Okay, I can tell you all the great things about foresight now. So what's the acronym for that? Mofos. So we've got what's amp? Oh yeah, minting. So one of the terrible things about prediction markets in like Auger, you have to decide between minting a token.
00:18:00.228 - 00:18:29.302, Speaker A: So you mint a yes and a no, and then you sell the yes or the no, or you buy on the order book. And even Vitalik was like, I don't know which one to do in his post about the trumpet. So we get rid of that. We have a thing on the back end. You just buy? Yes, you just buy no, it's a single order book, no complication. The o, we've got order books. So none of this amm stuff, which a lot of people use, because bad thing with amms and prediction markets is that information changes very quickly.
00:18:29.302 - 00:19:14.212, Speaker A: You can very easily have a massive price change just based on the fact that something bad happened in the world and the information has changed. I guess with prediction markets or with order book based markets, you can say, here's what my model says. My model says 70% doesn't matter what the price is. I'm just going to set my price at $0.70. Works fees, I guess polymarket and some other places, the way they do fees is it's on trades, but we want to switch to a profit based model. So if you're taking money out of the contract, then we'll charge you some small fee on that and then settling. I guess I've said this too many times, this conference, but serum has this thing where you have to hit a settle button and it's pain in the ass.
00:19:14.212 - 00:19:26.484, Speaker A: So I just wrote some logic using the permissioned serum markets that just kind of gets rid of that. So it's pretty nice ux, not having to do any of that stuff. Cool. And I think that's it. Thank you.
