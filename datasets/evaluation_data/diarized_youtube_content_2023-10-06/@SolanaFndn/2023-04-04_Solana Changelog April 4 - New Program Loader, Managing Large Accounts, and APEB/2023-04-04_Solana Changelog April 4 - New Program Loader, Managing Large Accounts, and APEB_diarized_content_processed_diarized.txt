00:00:00.200 - 00:00:09.238, Speaker A: How's it going, everybody? Welcome back. Another episode of the Changelog here. I'm Joe, this is Jacob, and we are going to bring you some fresh changes on Solana. So what do you got for proposals, Jacob?
00:00:09.366 - 00:00:33.726, Speaker B: Yeah. So just recently there was a new proposal from Anatoly SIMD 45. It's called asynchronous program execution and broadcast. What this does is it separates blocks for user transaction and blocks with votes, allowing for asynchronous execution of user transactional blocks. Really big change, big proposal. Pretty cool, though, the way it's built.
00:00:33.870 - 00:00:44.398, Speaker A: So currently those are executed synchronously and they want to be able to do those asynchronously. What kind of like, changes would that introduce? Like performance wise?
00:00:44.566 - 00:01:42.924, Speaker B: Yeah, so the proposal specifically says it's going to separate into like a builder schedule, kind of which that builds and proposes blocks of user transactions and the regular leader schedule that proposes the blocks of votes. And then way that it works with like, latency and throughput is that the builder scheduled, proposing transactional blocks will be done. Like they can just, the next leader can just continuously build their blocks asynchronously. They don't have to wait for the previous one to be completed, and then whichever one is the client is closer to, like the leader schedule can send their blocks. And so that you have lower latency. That's my understanding. Doing a read of the proposal, it's still like, especially while we're recording this, it's still early days of coming out and being updated, but it's a really cool change.
00:01:43.344 - 00:01:49.244, Speaker A: Nice. And you said that was 45, right? And can you find that on the forum?
00:01:49.944 - 00:01:54.132, Speaker B: Sure. We will put something else on the forum for discussion.
00:01:54.288 - 00:02:00.620, Speaker A: Cool. Yeah, definitely. Take a look, guys. Let us know what you think. Weigh in. How about commits? A couple of commits, right?
00:02:00.772 - 00:02:34.548, Speaker B: Yeah, I saw one commit was the geyser entry interfaces. So today I believe there's no entry being sent over with Geyser, which is one of the things required to cryptographically verify. Blocks contain correct and complete transactional data. So if you're storing things with Geyser and you don't have entry today, you can't verify that you got everything with entry, now you can verify everything. So this is the start of a longer term project to add everything, but it's adding entry in this single commit.
00:02:34.676 - 00:03:04.858, Speaker A: Okay, nice. There was a kind of minor one that changed the deployed slot for an upgraded program. I think that was previously being, that was remaining the same as the originally deployed slot. Right now it's going to be updated. And then the big one is there was a commit for the skeleton program of the BPF loader for the program runtime v two. So you'll be able to see the link in the description of the video. You also probably see a little bit on screen maybe.
00:03:04.858 - 00:03:46.920, Speaker A: And that's a really cool pr because the docs of that PR itself have a lot of information about how this loader works. So you can take a look at that. There's information about deployments, redeployments, freezing, stuff like that. Some notable things like obviously you'd be able to redeploy just like you normally would, but you don't have to use a buffer account. So you guys can take a look at some of the things that are involved with this change. But this is going to be like the base that they're going to kind of build this new BPF loader off of. It's going to lay a lot of the groundwork for the runtime b two, which is far away, but doesn't seem that far away anymore because people are working like crazy on it, which is awesome to see.
00:03:47.112 - 00:04:20.080, Speaker B: Yeah, one of the really cool things I saw in this commit with the new loader, you will be able to realloc like by default your program as you redeploy. So you no longer have to pay two times the initial deployment cost. You're no longer set to a max of two times the initial deployment size. You just, as your program grows, it'll just grow automatically. You don't have a cap. And I know there's tons of different developers out there in the ecosystem that have wanted this feature to be activated on the cluster.
00:04:20.272 - 00:04:31.520, Speaker A: Yeah, that's awesome. Yeah, it sounds like there's like a whole laundry list of things that are going to be addressed with all these new v two stuff. So keep your eyes on that, guys. Definitely take a look. It's a pretty good read.
00:04:31.672 - 00:05:11.298, Speaker B: Super exciting. And then the resource of the week is actually a video by Jonas on the Devrel team managing large accounts. So if you're interested in zero copy, or if you've run into issues with like heap or stack frame sizes and things like that, you can actually go through this resource that was built out by Jonas that teaches how to properly use zero copy to avoid those issues. So that if you're using a very large account, like, I don't know, over 10 kb, you should be able to use zero copy to properly manage your account and your transaction.
00:05:11.426 - 00:05:22.418, Speaker A: Cool. Yeah, that's a super valuable tool. He shot a great video on it. You'll be able to find that link as well in the description. I think that's really it for today, guys. Thanks for joining again. Hope to see you next week.
00:05:22.418 - 00:05:29.498, Speaker A: And don't forget to take a look at that developer forum and weigh in with any thoughts you guys might have or ideas later.
00:05:29.586 - 00:05:30.594, Speaker B: All right, have a good one.
