00:00:04.320 - 00:00:32.432, Speaker A: Hello everybody. Today we're going to talk again about transfer hooks. And this is because the first guide is already slightly out of date and I still got a bunch of questions from many people about details, what you can do with transfer hooks and whatnot. So first I'm going to show you today all the resources that we currently have. Then we're going to build a hello world transfer hook, then counter transfer hook. Then I'm going to show you how you can have dynamic pdas in a transfer hook. And then we're going to build a little whitelist.
00:00:32.432 - 00:01:28.820, Speaker A: And then I'm going to show you two other more advanced examples so that everyone hopefully after this guide knows how to do anything with transfer hooks. So first of all, the resources we currently have, so we have this transfer hook guide here and it has lots of examples and explanations about everything. And all the examples also have a link to a playground example. So you can just click on this link and then you will have an example in playground which you can immediately run and test and work on or use as examples or something. So here we have in hello world, then we have a counter and then we have a transfer fee. So then all the examples are going to show you today you can currently find in my repository, but I hope until this guide is released they will be ending up in the Solana developers program examples under token 2022. Then there's another nice example by Joe.
00:01:28.820 - 00:02:25.204, Speaker A: It's a transfer hook order tracker which uses soul bound tokens to identify the source and the destinations. So this is a nice one to look at if you need a more advanced example as well. And yeah, and here we have the explorer where we're going to look at our instructions. So the first thing is I'm going to quickly go again through the basics in case you're looking watching this the first time. So if you create a transfer hook, it means that every time we transfer a token from one token account to another that the token program, the new token program, token extensions program will do a CPI into your program and call this transfer hook instruction here. So to facilitate this you need to implement the SPL transfer hook interface and the execute instruction and the transfer hook instruction. And you need to create a PDA which saves all the extra accounts that your transfer hook needs.
00:02:25.204 - 00:03:20.656, Speaker A: So how this looks like is whenever the token is transferred it will call this function here. And since we are doing all of this in anchor today, we need this fallback function here. So what we do here, since the token program is a native program, so what we do here is we unpack the transfer hook instruction and then we match it to our instructions in our program. So if it's the transfer hook execute instruction, then what we call, what we do is we take the bytes out of this, out of this data and we call our transfer hook instruction, which is this one, and then this one will be called on every transfer. And here you can see already we do a hello transfer hook. So I'm going to run this in a bit, but first I want to show you these extra accounts that you need. So to perform a transfer hoc, as you know in Solana, you always need to put in all the accounts that you want to have in one instruction.
00:03:20.656 - 00:04:16.346, Speaker A: And since the token transfer doesn't necessarily know all the accounts that you need in your transfer hook, you need to define them beforehand. And for that you create this outer account metas vector here and then you here we calculate the size and the cost it will cost. And then we create this PDA which has a seed of account extra matters, then the mint of the token and also the bump. And then we create this PDA and then we write all our signers, all our extra accounts in this matter. And then in the client we can have a helper function which just looks at the mint, gets all the accounts out. And whenever we do the check transfer we can put all these accounts in. So it's basically the whole magic behind transfer hooks and yeah, then it will call this function here.
00:04:16.346 - 00:04:46.018, Speaker A: So, and to run this, what we're going to do is we call anchor test detach. And the minus minus detach does, is that the local validator will continue running. So I can easily look at the transactions that are happening at the signatures. So here we can see we have these three transactions. The first one is just creating the mint and so on. And the last one is the actual transfer. And if I put this here into my local explorer, so explorer.com
00:04:46.018 - 00:05:21.240, Speaker A: and I switched it here on the top right to localhost. And if I paste this in, if we scroll down here we can see, hey hello transfer hook. So this will be done every time we transfer a token now. And to understand what's happening in the client, let's quickly go through the client code here. So the first thing we do is we create our anchor provider, then we get the program from our IDL. So it's just program transfer hook, and it gets it actually from these types here, target type transfer hook. This is where our program gets all its types from.
00:05:21.240 - 00:05:52.134, Speaker A: Then we just take the normal default wallet. In my case it's just pointing to the default wallet that you usually have when you install Solana. Then we get our connection. And here we create the mint key pair. We define the decimals our token should have, and then we create our source token account. So as you know Anselana, whenever you want to have a token in your wallet, you need to have a token account. And then we create our recipient, it's a random key pair and a recipient token account which we call destination token account.
00:05:52.134 - 00:06:31.054, Speaker A: Then here we in the client also get this account for the account extra metas that we need in the transfer hook. And then here we get the length of our mint. So whenever you add a new extension to your mint, you will also need to allocate some extra space for it. And you get it like this. You have an array of these different types of extensions, then you get the length of them, then you calculate the lampboard set they will cost. Then you create an account which is exactly of that size that you need. Then you initialize the transfer hook instruction, and then you initialize the mint.
00:06:31.054 - 00:06:59.026, Speaker A: And it's important that you always initialize all the extensions first and then the mint, otherwise it will not work. And then we send this off. Then we create the token account and the mint. So here we create associated token account for our wallet and for the destination. Then we create the mint and then we set this off. So it's the second one and the third one is now creating the extra account matters. So it's initialized extra account matters.
00:06:59.026 - 00:07:24.750, Speaker A: And you notice already that we are calling this on our program. So this will be a PDA that is derived from our program. Then we put the mint and we put this PDA of the extra account matters. And now becomes the interesting part here we are transferring actually the first time the token. And the magic of getting the extra accounts actually happens here. So this is a helper function which gets all these extra accounts. Create transfer checked with transfer hook instruction.
00:07:24.750 - 00:07:55.346, Speaker A: And if we go in here, we can see that first we create a normal transfer checked instruction. And then we get these extra accounts here. And for the extra accounts, what it actually does internally, it gets the mint info, so the token account info and it gets the transfer hook out of it. And then it gets all the extra accounts out of there. And then it just adds them to the instructions. So we can here see for every account meta we added to the instruction, and then we push the account matters. And yeah, this is the magic of it.
00:07:55.346 - 00:08:35.434, Speaker A: So basically everyone can now call this transfer hook with our program. And yeah, then we send this off. So, and this is our first transfer already. What you need to keep in mind is that you will not be able to change the token accounts or the mint because they are both demoted in signer and in writable. So you can't for example very easily burn a token here or just change the token amounts. I will maybe in the end show you like some ideas on how you can achieve something like this. So you could for example maybe use a clockwork thread that does something in another thread and uses the permanent delegate extension or something.
00:08:35.434 - 00:09:24.696, Speaker A: But for now I want to show you very quickly a very quick thing how what you can do with this. So let's say we want to fail whenever the amount of this is bigger. So what I just going to do is I just kind of panic in this case would of course be nicer if you create a proper error. But now if I run this again and I say like hey, if I'm transferring an amount that is bigger than 50 then it should panic. And I think we are supporting like we are sending 100. So if I now look at this instruction here, this transaction, we can see it was an error and it says the amount is too big because it was 100 times nine decimals. So like a bunch more than we set here.
00:09:24.696 - 00:09:54.544, Speaker A: So this is the first use case that you can have. You can do something with the amount, you can do something with the token accounts or with the owners or so on. But let's now do a little bit more of advanced example and maybe we run into a few errors which would be nice. So you can show you some of the errors. So let's say we want to have an encounter. So we want to have a PDA which has a number in it. And every time we transfer the token we want to increase it.
00:09:54.544 - 00:10:47.306, Speaker A: So for that the first thing we would need to do is here in our transfer hook, we would need to add a new account, right? So let's say we want an account and we want to initiate and we call it counter and it should be pub counter account, info counter account. So and this will be a pub struct which will be counter account and it has a count. So let's quickly see if we did this correctly here actually. So this is when we do the transfer hook and we also need to initialize this account. When we initialize our account matters. So here we will actually have our init. If needed, the seeds will be just counter, then we have a bump and the payer will be the payer which will be the signer in this case and the space is nine.
00:10:47.306 - 00:11:28.244, Speaker A: But since I think we have a U 64 here, so this will be actually the size needs to be 16. And down here we actually don't need to init, we just need it as mutable and it should be a counter and bump and space we don't need. So let's see if this compiles. So there was some error here already. The counter account trade clone is not implemented. This is here. So this can't be an account.
00:11:28.244 - 00:12:06.642, Speaker A: So I think I'm missing the account flag here. So let's do anchor bill. Okay, this is building now the thing is now if we, if we would run this, we would have some errors of course, because we are not passing in these accounts yet. So we can see we get the first error here. When we create the extra accounts list, we are missing the counter account. So now we go into our test here and first we need to find this PDA. So what are going to do now is I create this, find this PDA.
00:12:06.642 - 00:12:45.764, Speaker A: So for that I just copy the other PDA we have here already. And I remove the mint, I call this counter PDA. And for seed we just put counter. And now here when we create the extra account matters, which is some, somewhere here, we're gonna add this counter PDA as well. So in this is now we get another error here, unknown property. So let's first like build this again, see if there's an error. Command not anchor build.
00:12:45.764 - 00:13:22.082, Speaker A: So here this looks fine, but there's something wrong here. Obviously it may not specify known property of counter does not exist. So maybe we called it counter account. Yeah, we called it counter account. So should be this actually counter count. So now if you run, if you build this and if we now anchor test minus, minus detach again. Now hopefully the first part should be correct, but the last part should still fail.
00:13:22.082 - 00:13:55.820, Speaker A: Yes. So I want to show you now the next error. And this is now because now we are passing in the account when we create the extra account matters. But we are actually not creating the account meta in our account metas array in the program. And this looks then like this caused by account counter error account not enough keys. So here we can see now that we are missing in our program on the top here where we create this account matters. Here we are not putting in anything.
00:13:55.820 - 00:14:28.438, Speaker A: So what we do need to do now here is we need to create this account. And thankfully the copilot helped me a bit here. So we can see that we have these extra account matters and we have new receipt. And there are a bunch of these. There's new from Pubkey, which is just a normal pub key, and new receipt which will be creating a PDA from our program, taking this counter string here. And we need it not to be a signer, but we need it to be writable. So this is correct.
00:14:28.438 - 00:14:57.974, Speaker A: So let's run this again. And we have an error because send literal seed uneclared type. So this is apparently the copilot didn't know it too well. The copilot is actually not very good at importing the correct things. So what we actually need is, we need from the state we need the extra account meta list. From the seeds, we need the seed. And from the account we need the extra meta account.
00:14:57.974 - 00:15:38.548, Speaker A: And now these errors go away. So now we can see, we can now have like extra account metas new receipt. And you can see that extracommerce always has the discriminator, it has the address. And then if it's signer writable or writable or writable and signer. So we don't need it to be a signer, but we need to have it writable because we need to change the number of the counter. And then here in the seats you have a few more, you have literal, you have initialized, you have the account instruction data, and we have account data and accountkey. So we're gonna do some dynamic PDA's with this later as well.
00:15:38.548 - 00:16:04.614, Speaker A: But let's first stick to this one. So now if we run this, hopefully this should work, since there are no errors anymore. So we can see that they are going through. And now here, we should still see our hello world. Yeah, we have hello transfer hook. But now what we want to do is we want to increase this counter, actually. So we, this time the copilot did the right thing, almost.
00:16:04.614 - 00:16:47.754, Speaker A: So this is, I think, count plus one. And now we want to print this and yeah, so the token has been transferred zero times in this case, and it should be now printing has been transferred one time. So let's see if this works. So we gonna copy this one, we paste it in here and we can see here this token has been transferred one times. So this is nice. So with this you can already do all kinds of statistics, collecting for your token or something. But now let's say we want to have a token which has a counter for every token account.
00:16:47.754 - 00:17:34.890, Speaker A: So for that, what we need to do is we need to change our PDA a little bit. So here we additionally put the signer, the owner in this case. So we take the owner to key as ref. I don't know if you need as ref or we probably need the buffer of it, but, and the same thing we do here. So here we take our payer, and now we have a dynamic PDA. So, and in the client, what we would need to do for that is here we also need to add our, you don't want to mint, but we want our payer. So this is a volatile public key dot buffer.
00:17:34.890 - 00:18:41.866, Speaker A: And now we would have a counter, which is dependent on our public key, basically on the owner of the sender token account. And let's see if this works here already, or if we did something wrong. Okay, this seems to, seems to run, we just get an error now here in our account meta again, because we are actually not having, we are not passing in the correct account again in the account metas here. And for that, what we need to do is first of all we have our literal here, and then we want an additional account here. And in this case we want a seed which is coming from the account data. So in the account data, since you don't have the account directly, the owner account, but what you can do is you can take the account data of the token account and take any bytes out of there. And since the owner of the token account is the second field in the token account, you can just take exactly the 32 bytes at the correct position.
00:18:41.866 - 00:19:42.096, Speaker A: So we take our account index zero, which will be our owner token account, and then at account index 32, we take a length of the data of 32. And if you wonder how I figured this out, I went here to the token account, and if you go to definition, you can see that here in this token account, we have the rep type is c. So that's like how it's packed in memory. And then we have, first comes the mint, which will be 32 bytes, so it's position 32, then comes the owner. So we take 32 bytes after 32 bytes offset, and then we just use this one to create our PDA. You can also take the other fields in here. I don't know if it makes sense, but you could use the delegate or the state, or the amount probably doesn't make too much sense, and the close authority, for example.
00:19:42.096 - 00:20:27.434, Speaker A: So yeah, you can do all kinds of things, but now this PDA should be correct in the extra account matters. And if we run this now, hopefully we should have a counter that is counting up for every, for every token account. So this is now working, thankfully. So if I put this in here, we can see that this token has been transferred one time. What you need to keep in mind is that I'm here creating this PDA when I create the account matters. So the first time, so you need this PDA needs actually to exist. You will not be able to create this PDA when you do the transfer hook because you won't have a signer to create the account.
00:20:27.434 - 00:21:20.474, Speaker A: But you can for example on your website have something like where you want to identify your owners or your users and then you have a button where they can create an account and then they will be able to transfer the token. For example, the main thing I wanted to show you is that you also can use the account data and that you can find the owner of the token account in case you want to derive some dynamic pdas. But now let's say we want to have a whitelist so that we only have a certain amount of people which are allowed to transfer this token. And how we would do this is here in our account. We would probably call it differently, but I just don't want to refactor everything now. But I would call this authority and now I have a pub key here. And then we have another, this would be our whitelist.
00:21:20.474 - 00:22:10.386, Speaker A: And our white list, if I can type correctly, will be now a vector of pub keys. And now in our transfer hook what we can do is we can check if our, if the context, if the context dot accounts, dot count as whitelist contains the destination destination pub key. So if it does not contain, so then we would be what? Fail. So now we have our whitelist and we will check if our destination token account is in there. Otherwise we will not be able to transfer there. You could do the same thing with the token account that is the owner. So the sender said the sender is not allowed to send.
00:22:10.386 - 00:23:07.570, Speaker A: So you can like whitelist and blacklist multiple lists of accounts if you want. And how you would do this is here, we would have an add to whitelist function and then instead of transfer we would put something else here. We don't need this, this thing. And then we would do here in our whitelist we would push our new account, so this would be like, look like this, and then we would get the account from our accounts list. So we would need to pass this account in and to be sure that not everyone can just add new stuff to our whitelist. We would do this basically so we could just panic here or throw an error. And then yeah, we would check that only the person that created the extra account matters.
00:23:07.570 - 00:23:36.370, Speaker A: So basically you, when you create your token hook that only you would be able to add stuff to the whitelist. And then here you would be able to in the transfer hook, if something is whitelisted or blacklisted, then that it failed or succeed. So this is another use case what you could do. And now I want to show you one more example and then we are done here. It would be like a transfer cost. If you want to see the whole example, you just look at the repository. But this should give you a good idea already how it works.
00:23:36.370 - 00:24:32.800, Speaker A: So for the transfer cost, what we do, since the token accounts and the mins are not writable whenever you do a token transfer, but you can work around this if you create delegate. So in this case what we would do is we create a delegate, which would be the authority of WSAL account. So this would be Repsol and this would be used to have a transfer fee. So and here in the extra account methods, we can already see that we put first the mint of WSAL, then we need the token program, then we get delegate. So this would be PDA, which would be the authority of our extra token accounts. And then we have here new external PDA with seed. So what this does, it creates PDA from the token program using our, the owner and the W mint index.
00:24:32.800 - 00:25:35.704, Speaker A: So, so this would be the associated token account for, as a token account for the wrapped Sol. And then we have our send up Repsol account and that's when we would derive from the owner the token program and the W Sol index again. And then here we have the counter from the last example and how this looks like in the client is this. So basically the same as the other one, just that we need to also find WSL token account, the delegate token account. And then here when we do the transfer, let's go to the last function here. Here we are creating the extra account metas and here you can see we need to put in all these accounts now and let me find, so here we create the approve instruction. So this is where we approve our delegate to be the owner of the WSAL Mint.
00:25:35.704 - 00:26:20.900, Speaker A: Then we create the sync native instruction for our WSAL token account. Then we get the mint, and here we get the extra account matters again. And we need to put in the mint and the transfer hook in this case. And then yeah, we print all the accounts. And then here we do the same instruction as for this before, where it gets all the extra account metas from the accounts, metas PDA. And with all these extra accounts, what we now can do in the program, in our transfer hook is we can actually do a transfer because in this case all the accounts are writable. So here I did a little messaging which shows you that the Mint account is not writable, the destination and source accounts are all not writable.
00:26:20.900 - 00:27:01.056, Speaker A: So you will get an escalate privileges error or something when you, when you use these. But since we have here the signer is our delegate PDA, we can use, we can now do a check transfer from our sender account to our delegate w sol repsol token account and then we can just send half of the amount there. So you have transfer cost. Now this is of course not super convenient, but at least it's possible to do things like this. And yeah, please check out all the different examples. I hope when this comes out they will be already in the program. Examples.
00:27:01.056 - 00:27:34.670, Speaker A: And yeah, I'm super excited what you're gonna build with these, maybe for the next hackathon or something like this. And yeah, if you have more questions, please keep them coming. And maybe I'll do another video. For example, one where I maybe explain how you could use a clockwork thread to use the permanent delegate extension. And then whenever there's a transfer, you trigger a thread with the now trigger, and then you can do something in there with the permanent delegate. For example, burn tokens or so on. Or if someone of you wants to build this, of course, please open a pr here or make a video about it.
00:27:34.670 - 00:27:40.726, Speaker A: That would of course be highly appreciated as well. Otherwise, see you guys next time. Bye.
