00:00:01.160 - 00:00:25.434, Speaker A: I am Mitch. I am CTO of Switchboard. We co founded this back in April 2021. So it's been almost three years, believe it or not. And this is actually my third breakpoint talking about what we've been building. We've maintained about the fifth or 6th largest DAP on Solana since our inception. And we really appreciate all of the love and support that we've had on Solana since our inception and how we've grown since then.
00:00:25.434 - 00:01:15.864, Speaker A: But since 2021, there's actually been a lot of developments in the Oracle space. The needs have actually changed, and we need more than what the Oracle ecosystem has today. And we really want to build upon that and see how we can help the community the best. But anyways, before we go into what we're going to be introducing today, let's look back a little bit at RV two. And RV two was really centered around this concept, which is our feed builder. This was a no code UI that anyone could go and make their own data feed off of any data they actually wanted. We plugged into every major exchange, every major liquidity source on Solana, and that people build whatever they want, and they could use historical data from our own platform, they could use external data, and they can use data native to the chain to build any type of feed they wanted.
00:01:15.864 - 00:02:14.020, Speaker A: Right now, I think there's about 300 or so custom data feeds being supported by our network and continues to grow. And we want to actually give a whole new feature set on what people can do with these. So to move on a little bit on what we're actually talking about today, which is the problems that we're trying to tackle that we think exist in Oracle space and in rv two. One is we want to maximize security of these Oracle ecosystems. No matter what way you look at it, oracles have a weaker security guarantee than the blockchains they support. No matter how much you can stake towards an oracle, do they ever actually represent the underlying liquidity that's supporting on the apps that are actually ingesting the data? And we believe the answer to that question right now is no, they do not fully align those incentives correctly. Next is the versatility of oracle triggers right now, especially when you're making custom data.
00:02:14.020 - 00:03:01.854, Speaker A: People don't want to have to be paying for these services to be supported while they're not being used. Why pay for a data feed to go all night when you might have a market that's maybe mostly active during working hours in Asia? You don't want to do that 24/7 you want to do it only when you need the information. Next is dynamic Oracle executions. And we've seen this too much in the past that people want more than just a price feed. People want to have liquidity information, they want to have risk information. They want that all built into the data they are ingesting, and that be a complete solution rather than building any type of security on top of that for themselves. So with that, this is what we are aiming to tackle with switchboard v three, tackling the security problem that oracles have currently.
00:03:01.854 - 00:03:41.694, Speaker A: Tackling the versatility of triggers, tackling the execution scope that you can have and putting that all together into one single product. So really we're going off of this motto, smart oracles. Smart contracts need smart oracles. And what we mean by smart oracles is delivering all this information, doing all this risk assessment for you in the data layer itself, so much so that it almost becomes an execution layer. So we have this chart here, just a very vague idea of the limitations of the oracle space today. They're very static. They give you a single data point back for, for each unique feature they're trying to represent or each unique instrument you're trying to look at.
00:03:41.694 - 00:04:46.204, Speaker A: Really, there was no flexibility. And this is what our v two tackled here even before we get to our v three. If you look at the evolution of oracles, since they were really popularized, probably, let's say by Chainlink in 2016, 2017, we've evolved before training existed from a single party trust system to a multiparty trust system where you need a majority to actually attack the price point to a stake weighted multi party trust system. And the stake weighted one actually incentivizes the oracles monetarily to not collude and lie about what information they were trying to represent. So basically, all these oracles work a little bit as a black box. They take a set of data sources, they ingest the responses, maybe do some transformations, and they all have some latency attached to them and the latency of the risk, because any user off chain can look at what might not be reported on chain yet and try to front run the oracle for some advantage that could be a loss or bad debt for the protocol. So we really want to have the protocols be the first one to ever be notified of price changes rather than users.
00:04:46.204 - 00:05:54.068, Speaker A: So just a little bit more about the features we offered to tackle these problems. In our v two, we had a whole set of what we called task types that people could actually integrate, pulling from specific pieces of or places of information, building that into a single index and building your feed, you could say the latency that you wanted so you can actually choose the fidelity of this data. You could say how many oracles you wanted to respond, which affects price, but of course the more the merrier because you would still need attack on the majority to actually influence the results. And really just with this flexible nature of switchboard V two, that really gave the customizability and a whole other bound than all the other oracle solutions that were out there so far. With V three, we want to take this large leap further where we give full customizability outside of these tax types to arbitrary execution. So improved oracle security. How are we trying to tackle this problem beyond just a multiparty trust system? We are actually securing all of our oracles in trusted execution environments.
00:05:54.068 - 00:06:41.194, Speaker A: This is a newer concept for a lot of people, but for those of you who do not know, there is specialized hardware for if you give a certain program and feed it into a certain types of chipset, you can actually produce any output and verify that output came from a specific program. So not only on chain are you trusting that a majority of the oracles are telling the truth. Now you can actually verify the code that is running and being output on chain into your oracle protocol. So there's a whole new layer of trust that we're introducing with switchboard v three here that just has not existed before. Really versatile oracle triggers. So I mentioned that you might not always want a data feed updating 24/7 because that can incur a very large cost, especially when you're trying to do a lot of bespoke data. There might be smaller markets you want to do for these long tail assets.
00:06:41.194 - 00:07:39.330, Speaker A: What can you do? There's different ways you can actually trigger feeds or functions on switchboard v three. One is a cron based schedule, and this can let us take in and help people automate anything they want in the blockchain. Now, with routines, as we call them, for switchboard functions, anyone can run something, let's say every Friday when they want to do settlements for their protocol, or every 8 hours for perpetuals rebalancing. With this, we let anyone do their own automation pattern and format their automation to do dynamic callbacks every single time the routine actually executes. Next is actually a request based system. So what if you only want to trigger an update on a market when somebody is trading well on that trade, you can say now to our oracles, this price needs an update because we have to settle this trade. This will be launched to our Oracle network.
00:07:39.330 - 00:08:18.934, Speaker A: Our oracles will fetch that information and then bring them back to the protocol in the same transaction, that your protocol can execute some action on that, on that information. So really because the information is coming in the same transaction that they reach your protocol. This really eliminates like 99.99% of the front earning risk that exists today in the Oracle landscape. Next is another method for actually running switchboard functions, which is what we call a worker. And these are a long lived switchboard function which can run for an unbounded amount of time. And really this is very nice for the new hybrid model dapps that are coming to existence today.
00:08:18.934 - 00:09:16.294, Speaker A: Look at cube for example. They have their order matching off chain and they have their settlement on chain. What if you could actually make that order matching verifiable as well and still maintain the speed of some centralized exchange and have that compete? This really can bring into scope for decentralized applications to compete with the speed of these trading platforms that have essentially historically been very black box and no one needs Ftx as a reminder. So anyways, dynamic oracle executions. What do I actually mean by that? In switchboard functions you can actually return a set of instructions to do whatever you want. You're not bound to a single quantitative data point anymore, so you can formulate your whole transaction, do whatever you want, pull in any information, and it can be that easy to perform this callback, let's say every 5 seconds. So it's really free form to do anything you could imagine inside a transaction anytime.
00:09:16.294 - 00:10:07.692, Speaker A: One of these functions fires here I have a little example of how you can pass some information to one of our functions. You can parameterize a routine or a request, and it's really easy to write out a parsing method of how you can parse the parameters that you're feeding into this function or request. Beyond that, we have a whole way to report errors if you had a problem in your function, and we give you numeric codes if you ever actually run into something that was unexpected in your function. So you can really easily debug when there's problems occurring on chain when you actually ingest a function. We do have a mechanism to make sure this actually came from our protocol, so you do actually have to validate one of the signers of the transaction when you ingest it on your application. So we wrote a nice helper function in our SDK. You just have to do this validate call on your function.
00:10:07.692 - 00:11:00.262, Speaker A: And once that passes, we can actually verify that this came from one of our oracles and not a random user trying to call some endpoint to settle a price outside of an oracle actually reporting it. Now, another fantastic aspect of trusted execution environments is that they're completely confidential. So we have a whole mechanism of introducing secrets into your functions as well. So if you want to have some private information that you don't want to publish to our oracles, or you don't want to publish on chain mostly, this could be API keys for some private access to some data. You can actually use that inside your function. So an API key for pulling sports data might be really applicable to your application, or an API key to an API that you own that you want to let people request to. And you can actually put a fee on your own function, so you can charge other people for reading this API in a very specific way that you want to control.
00:11:00.262 - 00:11:52.540, Speaker A: It's very versatile and the way you can fetch secrets for your function is built into our SDK. As long as you map the secrets you want to publish to something we call a measurement of your function, they can be exposed into the runtime itself and never actually be exposed to the oracle running your code. So these are all the things that switch for functions can actually offer. All the different applications here are the same thing. We can actually build data feeds into these functions, but with this you can return maybe even 500 data feeds at once, which we do on some chains on Solana. You might have to split that up into a few transactions, but it's very manageable. You can do twaps over any historical data, any type of risk analysis that you want to do before you return a feed, pricing and liquidity and volume data into your data feed before you actually return any data.
00:11:52.540 - 00:13:20.282, Speaker A: And the example I gave before, which is access to private APIs or maybe even reselling APIs for yourself to let other people read from your function. Another nice feature about running inside these trusted enclaves is they have the whole protocol for deriving randomness within the chip, and you're given the guarantee that this randomness actually came from inside the SGX chip, which unless you have some scope inside the SGX chip at the runtime, you cannot predict the randomness there. So we can actually create a function that we show we are pulling randomness from SGX and we can report that back on chain, and there's different models on how you can do this and generate very cheap randomness, single transaction randomness for your application. There's a lot of other uses for switchboard functions. One is multisig solution where you can actually do very controlled signing, maybe of a continuous deployment system that you want for your app you can go through multiple checks, do this very routinely, and have a sign or controlled purely by your function. You have a number of ways to connect with web two hooks maybe of when some event happens on say, GitHub, do something on your dap. You have many other ways to connect web two and web3 with swift reward functions and really want to summarize with smarter oracles need and smart contracts need smarter oracles to go into a little bit of the use cases.
00:13:20.282 - 00:14:27.928, Speaker A: Here we have a whole command line for how you can create a function, and it's as simple as actually publishing a docker container. Here we have a switchforth function docker container where we have written one of these functions. We denote the measurement. You see the Mister enclave, I'm going to make plushies for this one day because it's a really cute name for Mister enclaves, but this is actually in the docs for intel on how you actually derive the measurement of the code that's actually being loaded into this secure runtime. This will basically lock in which code is actually allowed to produce output from your function. So anytime you change your code of your function, that measurement on the last line there will need to be updated as well. Anyways, once you make your function, you can do the more creative stuff like creating a routine like this one specifies running once every 10 seconds, and this runs a lot like rv two does, where you actually have to fund a lease for what was your data feed is now a routine or now a request, and this will run for a certain amount of time and you can see the prams and the last value there.
00:14:27.928 - 00:15:34.190, Speaker A: You can pass a set of params for every routine run as well. So if you want a single function to support a lot of feeds, you could set different routines to update the BTC USD by setting the prams there, or updating ETH USD feed, all using the same function and different parameterizations. Then you can send requests on the fly, either through the command line or on chains. You don't have to make a routine, you can actually use a CPI to trigger a function to run with any parameters that you'd like, which is very useful in the example I gave where you have these maybe low flow markets that you're trying to support that you only want to update when a user interacts with that market. One really nifty feature that I added recently was instead of having to test these containers and emulate this runtime by running on Devnet or spinning up a local net, we emulate that runtime through the command line and you can just test your function locally before even making a docker container so you can catch yourself really easily and quickly before uploading anything on chain. That's everything we have on v three. We're happy to help people build.
00:15:34.190 - 00:15:38.054, Speaker A: And please find me for questions after this. And thank you so much for coming to this.
