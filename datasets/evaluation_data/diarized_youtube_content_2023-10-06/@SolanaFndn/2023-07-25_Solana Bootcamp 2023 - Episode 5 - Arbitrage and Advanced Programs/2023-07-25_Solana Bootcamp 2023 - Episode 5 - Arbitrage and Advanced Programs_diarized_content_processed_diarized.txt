00:00:08.960 - 00:00:34.341, Speaker A: Hey guys, welcome back to the pirate boot camp. This is going to be day five. We're going to be talking about arbitrage, right? So we're going to be hanging down here in this efficient port as a profitable port link. Actually, the quest is called. It's an arbitrage pirate's life for me. Right. So in the last session, if you caught my last session, we talked about a swap program, right? We talked about decentralized exchanges, we talked about the constant product algorithm.
00:00:34.341 - 00:01:23.821, Speaker A: We built a decentralized exchange and we saw in our UI we were able to go flip between different assets of our pirate boot camp, right? And we were able to, you know, swap assets. We were able to propose an amount of one asset and get another asset in exchange using only the liquidity of the pool. All really cool stuff. So now today, what we're going to look at is we're going to expand on those kinds of topics and we're going to talk a little bit more about defi in depth. We're going to talk about market making and about arbitrage and how these things kind of play together. And we're going to talk a little bit about how you can build an arbitrage program. So again, just like the last session, I have some presentation slides in the readme and we're going to run through real quick to talk about what arbitrage actually is.
00:01:23.821 - 00:02:11.045, Speaker A: All right, so, so what is arbitrage trading? Basically, arbitrage is a strategy of trading between two discrepancies in prices, right? These discrepancies can occur over time. They can occur over two different markets. They can occur in a number of ways. But the general idea is that you see one price on one hand and it's different from the price on the other hand. So there's an immediate opportunity to make profit because you can buy at the lower price and sell at the higher price as fast as humanly possible, or computer as fast as can be done with a computer, which is what we're going to do. Right? So that's how arbitrage works. You can see how this kind of works in a financial market.
00:02:11.045 - 00:02:49.215, Speaker A: This is something that people have been doing for a long time now with things like stocks, foreign currency pairs, and now crypto. It's nothing new, but it's actually got a nice little home in crypto where it kind of makes things work a little smoother, which we'll talk about later. So here's a couple of types of arbitrage trading. We're only going to cover one specific type in this workshop. But here are the different types. There's spatial arbitrage, which is going to be the differences in prices that are traded in different geographical regions of the world. There's temporal arbitrage, which exploits different prices of financial instruments between different points in time.
00:02:49.215 - 00:04:05.327, Speaker A: Then we have statistical arbitrage, which seeks to profit from price inefficiencies in the market by analyzing statistical relationships between securities. Now we are going to take a look at a simple scenario. This is the way our arbitrage program is going to work when it comes to liquidity pools. We're going to take a look at a scenario where two liquidity pools have different, I guess, like balances of liquidity, right? So we remember from the last session that a liquidity pool can offer you different prices, so to speak. And why I'm putting that in quotes is because it's not technically a price, it's more like a trade for trade value, right? So when I offer P, I'm going to get some value of R based on your pool's liquidity. And we know from the calculation in the last example that that value is going to determine is going to be determined by the liquidity of each asset in my pool. So what if, though, we have two pools that offer the same kinds of assets, but they have different ratios of liquidity, right? Like maybe I have more USDC in one pool and I have more bonk in another pool, then obviously my return value for R is going to be different in one pool than it is from the other.
00:04:05.327 - 00:04:35.921, Speaker A: And that's how you end up with an arbitrage opportunity. We'll talk a little bit more about what arbitrage can do. But let's take a look at an example of what I mean. We have two liquidity pools and they both have two assets, A and B. So pool number one, if I was to give them 5 of asset A, they're willing to give me back 10 of asset B. And that's based on their liquidity ratio and their constant product K. Right? We're assuming that both these pools do constant product K.
00:04:35.921 - 00:05:09.574, Speaker A: Now, pool number two, if I pay 5 of asset A, I'm going to get just 5 of asset B. So immediately you can see, okay, my five asset A's are worth double in pool A or pool one than they are in pool two. So what do I want to do? Well, let's take a look at what we can possibly do here. So asset a is worth 2x asset B in pool one. It's only worth 1x asset B in pool two. So what we want to do is we want to execute this arbitrage opportunity. We want to start with 5 of asset A.
00:05:09.574 - 00:05:46.133, Speaker A: We want to swap 5 of asset A in pool one to get 10 of asset B, and then we want to swap 10 of asset B with pool two to get 10 of asset A. And boom, we now have 10 of asset A. We just created 5 asset as or doubled our assets just by executing this arbitrage opportunity. Right? And so that's the general sense of how this thing works. Obviously, there's a lot of factors at play. These differences in prices might not stay for very long. There's a tight window where you have to execute this.
00:05:46.133 - 00:06:18.649, Speaker A: There might be fees associated, et cetera, et cetera. The point is, in a general sense, this is an arbitrage opportunity. And when you have two different pools, this can actually happen. Now, what's cool about this in at least with crypto and with defi and decentralized exchanges, is this is actually encouraged behavior. And I'll tell you why. So take a look at this example and follow the arrows again, right? So we know how much money or how much assets we just made from this trade. But let's talk about where these assets went.
00:06:18.649 - 00:07:30.345, Speaker A: Right? So we pulled 10 assets out of pool one for B, and we put 10 of asset B into pool number two. Now, let's just think about that. If we keep doing this because it's continuing to be profitable for us, we are continuously going to be providing more of asset B to pool number two and taking asset B from pool number one. Now, the reason that pool number one is so willing to give us so much of asset B is because it doesn't have a lot of asset B, but it has a lot of asset A. And pool number two might have a lot of asset A, but it doesn't have a lot of asset B. Or more likely, with the numbers we have, they're both the same, right? So if we consider pool number two to have the same number of A and B, but pool number one has much more of asset A than it does, or much more of asset B than it does of asset A. We are actually, by arbitrage, trading these pools, we are taking asset B from pool one and moving it to pool two.
00:07:30.345 - 00:08:12.485, Speaker A: So pool one is actually going to slowly start to offer less and less of asset B for for asset A over time. And pool number two is going to offer more and more of asset B over time as we continue to add asset Bs to it. And so what you end up with is a difference in the constant product value of R that these pools are willing to give us actually reaching equilibrium because we're giving these assets to the pool that doesn't have enough of them. That is how arbitrage is encouraged to work across decentralized exchanges. It's actually an integral part of DeFi in a lot of ways. Right. And you can see exactly why.
00:08:12.485 - 00:08:41.405, Speaker A: So kind of cool. Not only can you make pretty much free money or very easy money, it's also encouraged. So no one's going to shut you down because you're arming their swap pools, right? For the most part. I'm not putting that out there as a blanket statement. Lots of disclaimers go with that. Anywho, the point is this is a cool thing to at least know how to do and we're going to take a look at a program that does it. So, couple of disclaimers, right? Benefits and risks of arbitrage trading.
00:08:41.405 - 00:08:58.565, Speaker A: We can earn risk free profits. We can make efficient use of our capital. We can diversify our portfolio by arbitraging different assets. It involves low market exposure since these trades are very quick. And that's a caveat. I'll explain the next slide. And it can be automated with bots.
00:08:58.565 - 00:09:25.809, Speaker A: Now let's take a look at the risks here. Right. So you can have unexpected price changes, you can have errors in your execution or delays that cause you to actually lose money. You can have an inability to exit a position when you think you otherwise would have been able to. Now with Solana, you can mitigate some of this stuff with the way the transactions work. But still, this is all possible. And lack of clarity on regulations.
00:09:25.809 - 00:09:59.035, Speaker A: Right? And that's something that is hyper relevant in today's crypto world. So just some things to be abreast about now that's really it for arbitrage trading guys. That's a very short deck. But the point is very simple, right? Just taking another quick look at this diagram. This is what our program is going to be designed to do. So we saw in the previous session where we deployed our swap program. So the readme starts to talk about our bot here and then it shows a little bit about the repository setup.
00:09:59.035 - 00:10:47.535, Speaker A: What I want to do is demonstrate how you can set this up so you can start testing this thing. Right? So this is our repository from the last session, this is our swap program. And as you can see, this is the program ID that we just deployed in the last one. So we've got this 98 JF whatever. So what we want to do is, since we know this is already deployed, we're going to copy this program id, we're going to navigate over to our tests for the R program, and we're going to make this swap program one, and we're going to drop that right there. Okay, so here's the key step here, right? We already deployed this program and we already ran our tests against it. So we've already initialized it, et cetera.
00:10:47.535 - 00:11:30.199, Speaker A: And before we did that, we created some new assets on Devnet. So in order to run this test properly for the ARB program, what you want to do is, if you didn't do that already from the previous session, do that and then copy paste the program ID into swap program one. And now here's the key. You want to deploy a new swap program and run some new swaps and initialize that liquidity pool, but don't recreate the assets. We want to use the same assets. And I set the test up from the previous session to give us this JSON because of that exact reason. You can see the addresses in here, you can see the decimals, a couple of the other configs that you know.
00:11:30.199 - 00:12:02.001, Speaker A: The quantity has obviously changed now since we've been swapping, but the idea is the addresses are fixed here. And this is important. We know from the last session we set this up where we were going to be the mint authority. If you're in this session for a boot camp, some of these assets you might not be the mint authority on, at least for like the main swaps that are going on, that's okay. But if you want to just mess around with this, leave this file alone. Do not run any of these other tests. Right? Just run main again.
00:12:02.001 - 00:12:57.551, Speaker A: Right? So here's the steps you want to take in the swap program. Clear out any previous runs and you want to just. We know that our current address is this 98JFA, right? So what we want to do is RMRF our target deploy folder and then we want to do an anchor build again. That should be pretty quick. And what that's going to give us is a new program id and so you can say slana address key pair and you can get our new program ID right here. Right? And so we'll pop that into anchor toml, we'll pop that into librs, we'll save both those files and then we'll anchor build again. This is important, make sure you build it again so that this declare ID has the right value in the binary.
00:12:57.551 - 00:13:31.721, Speaker A: And once that's done. We're going to anchor deploy to Devnet. Make sure you're still on Devnet. And while that's deploying, this is going to obviously set up our second swap program. And so the key here is we want two live swaps that we've simulated with different swaps we run some test against, so their liquidities have kind of changed. And then we can run our swap program against these two swap pools, right? So we know that we had this new id, hopefully it deploys properly. So I'm going to grab the second ID for our swap program.
00:13:31.721 - 00:14:06.203, Speaker A: I'm going to put it into Swap program two. And so now we've got our two swap programs that we're going to be arbing between. So this repository, we've got this set up as a yarn or an NPM repository. We're going to yarn install the dependencies real quick so we can run our tests and let's start going through the program. Right? So hopefully this thing deploys pretty soon. I'll run the swap tests against it when it does deploy, but I think we can now start getting into the arbitrage bottom. So again, just like the last repo, we've got some tests in here.
00:14:06.203 - 00:14:32.017, Speaker A: We'll go through those later. And I have a UI in here. It's not finished. It is kind of cool though. If you guys want to take a look, I'll at least pop in here and do a yarn dev. This is what I wanted to present you guys as a cool little UI for arbitrage trading, but unfortunately did not get all the way there yet. I don't think I disabled my swap program.
00:14:32.017 - 00:15:25.867, Speaker A: Whoopsie. Let's just quickly yarn dev this again. But in case you're interested, this is what it looks like. If you ever do feel like adding some cool features to this ui, you can PR it into the pirate bootcamp. But I was hoping to get something like this set up and as you can see, my CSS or tailwind is already failing us. So either way, guys, pretty cool stuff, but let's get into it, right? Let's talk about this rbot, let's talk about how this is built, let's talk about how it works, what it's going to do, and you'll be able to quickly tell from this readme that I got a little bit fancy with this thing, right? So here's the section rbot and basically, if you read through here, we're designing this thing to evaluate all possible pairings for the liquidity pools offered. Mints, right? So Any mints that this pool has, we want to see if there's arbitrage opportunities between these two pools.
00:15:25.867 - 00:16:17.715, Speaker A: Now, it works out good because our two swap pools are going to have the same set of assets. You might need to modify the program, maybe not based on what assets are in one pool versus the other, if they're different, but the bottom line is we want to take a look at all possible combinations. So if there's five mints, we want to take a look at all the possible combinations of those five mints across the two pools and see if any of them give us an arbitrage opportunity. For what it's worth. If there's a difference in price, then you have an arbitrage opportunity. You don't have to check like bidirectionally each pool, right? So like if we propose P from pool one and get an R value from pool two, like, we don't have to do the other way around. We just want to take a look at the balances and take a look at kind of like.
00:16:17.715 - 00:16:53.173, Speaker A: Well, I think I may be complicating things, but ultimately the point is we want to take a look at the differences in these liquidity amounts and what kinds of values of R we would get. Right? So maybe I'm contradicting myself, but ultimately that's what we want to do. So that's what we're going to build. And so rolling through here, I want to quickly mention the configs I put into this thing. So concurrency. This is how many assets at once we want to check all combinations of. This might not make sense at first, but the code will kind of tell the rest of the story.
00:16:53.173 - 00:17:24.521, Speaker A: But Basically, if there's 10 mints, we can set concurrency to 5. It's going to hit our program twice? Well, not really. It's going to hit our program some number of times, but it's going to only give five assets at a time to the program. So the program is going to check all combinations possible for those five. We're going to move to the next five, and so on and so forth until we've checked every possible combination of the 10 minutes. So that's how the concurrency value works. And that'll make more sense when you see the test temperature is a little bit simpler.
00:17:24.521 - 00:17:51.425, Speaker A: Right. This is how aggressive our bot is going to be when placing trades. So you can see I set this thing up from 0 to 99. If you got this set to 99, that means price differences of 1% will trigger a trade. And so you can scale that back you might be like, okay, maybe we want the price difference to be like 20%. And then we'll place a trade. That's when you'd set the temperature to 80, right? So that's what that thing does.
00:17:51.425 - 00:18:19.551, Speaker A: Cool. All right, let's dive in. So what we can do now is start taking a look at our program and I'll pop open VS code. And it looks like our program did deploy, which is good. And now I'm going to just do quick anchor run test so that our second swap is good to go. There you go. We create the pool, fund the pool with some stuff, and then we are gonna go ahead and place some swaps.
00:18:19.551 - 00:18:40.573, Speaker A: So that'll move the liquidity around. Bingo, we're good to go. So I'll let this thing kind of run out, but I'm probably going to just minimize this bad boy so it's out of our way. And now let's take a look at our ARB program. So just a quick warning, guys. This program is written in native. This is a native Solana Rust crate.
00:18:40.573 - 00:19:07.955, Speaker A: This is not anchor. There's no frameworks involved. This is just using the Solana program crate as is and building an arbitrage program with it. So that's why it's going to look a little bit wacky if you are only used to anchor. Now, I want to start by saying that you don't need to write a program to build an arbitrage bot. This is just something I decided to do to show you guys a number of like, cool things you can do with on chain programs. But you don't have to do it this way.
00:19:07.955 - 00:19:25.535, Speaker A: In fact, it might not even make sense to do it compared to the alternatives. Right. You might be able to make a faster arbitrage bot just building it all off chain. I don't actually know. I'm not an arbitrage trader. This was really fun to make though, and I learned a lot. And I decided to do it with a native program because I thought it would be fun.
00:19:25.535 - 00:19:56.723, Speaker A: So I wanted to put that disclaimer out there. You don't have to use a program, but nonetheless, let's get into it. Right? So walking through the readme, the first thing we're going to see in LIBRS is our entry point. And that's right here. So you can see our entry point Here we use the entry point macro from Solana program to declare process as our entry point processor. And you can see that we're basically going to load our instruction from the data argument. And if it's this try arbitrage instruction.
00:19:56.723 - 00:20:23.675, Speaker A: We're going to go ahead and do this process arbitrage. If it's nothing, if it's not this instruction, we're going to throw an error because that's our only instruction. This is what that instruction looks like right here. We're going to take the two swap program IDs and the concurrency and temperature configs that we just talked about earlier. That's it. That's our only instruction. And it's going to just trigger this program to look for an arbitrage opportunity between these two pools.
00:20:23.675 - 00:21:06.499, Speaker A: Cool. So going through the readme again, let's go ahead and take a look at process arbitrage. Right? So popping this open, you can see here that the main thing we're doing up top is reading in a bunch of accounts, right? So we start by setting up this iterator over this account slice and we start plucking out all the accounts that are going to be passed in. Now, another design choice I made on this is I am expecting these accounts to be in the proper order when they hit our program. If they're not, it's either going to cause mass chaos or it's going to just throw errors. Hopefully most of the time throw errors. But the point is, this is my arbitrage bot.
00:21:06.499 - 00:22:09.255, Speaker A: This is only me using it. I'm not making this available to other people. And if they're passing in their own keys and stuff and signing stuff and they want to use MyBot without asking, I hope it does error. I mean, just a joke, this is devnet, but still, point is, I'm expecting these to be in the proper order because I know I'm going to put them in the proper order, right? So we load each of these in a couple of programs, our swap programs, and then the two pool PDA is one for each pool, right? And then we go ahead and validate those addresses and then we run these three, well, four loops, right? And these are all doing the same thing. So they're going to just read in these accounts and you can see that we're just looping over and running next account info. And all we're trying to do here is when you give me a concurrency value, let's say it's 5, I'm going to loop through 5 of the accounts in the Iterator and I'm going to load five of them as token accounts for the user. Then I'm going to load the next five as token accounts for the swap pool number one.
00:22:09.255 - 00:22:31.725, Speaker A: Then same thing for swap pool number two. And then I'm going to load five mints, right? So five of each. So 20 accounts, four or no, five of each in those four categories. Right. Mint's token account, swap two, swap one and my token accounts. So that's all that this is doing. And once we have all of those accounts allocated, we're going to try for some arbitrage.
00:22:31.725 - 00:22:56.073, Speaker A: Now before I move on to try arbitrage, let's take a look at what's happening here. Try to serialize partial token account state. What is this? Right, well moving through the readme, that is probably the first thing that we will go and take a look at. Right. So yeah, just talking a little bit about the ordering of the accounts. Right. Just making sure that we pass those in in the right order.
00:22:56.073 - 00:23:28.087, Speaker A: And yes, the first thing we're going to talk about is partial token account state. Right. So let's pop this open. This is in the partial state file. And as you can see here, this is our own representation of state for a token account. So you might be thinking like why are we doing this? What is this thing? It says the first three fields of SPL token state account, which you can find right here. If we go to SPL token rest, we can open the Solana create for SPL token.
00:23:28.087 - 00:24:09.365, Speaker A: We can pop state account. And this is associated token account. And as you can see, there's 1, 2, 3, 4, 5, 6, 7, 8 fields in an associated token account. And this is of size, I believe, 165 bytes. So why are we only putting the first three fields? Like what are we doing here? Well, basically we're running an arbitrage bot on chain in a program. And so in order to maximize the number of accounts that we can check at once, we need to minimize the amount of compute that our program uses. So if you haven't heard this yet in the bootcamp or you didn't know this, Solana programs are limited to 200,000 compute units.
00:24:09.365 - 00:24:34.109, Speaker A: And so once you hit that unit, your program is immediately halted and it just does not complete. So everything that your program was doing gets rolled back up and it errors out. Right. So we don't want to do that. We want to make sure we stay under the compute limit. But we maximize the number of accounts that we can check between the pools at once. So that's the purpose for this partial token account state.
00:24:34.109 - 00:25:27.801, Speaker A: We're going to try to save on computer by instead of deserializing this whole data structure for every token account that gets passed in, we're Just going to deserialize these first three fields, since they're the only ones we care about, right? And that is what we're going to be doing in this file here. So first of all, I set up this type as just like a return type. You can see it's just an aggregation of these guys in a tuple, nothing special, just to make it more legible, even though lifetime is still defeat that purpose. But let's pay attention to this try to serialize function that I wrote here for these three fields. And now take a look up here. We're using a crate called bytemucc to do this. Bytemuc allows you to kind of interact with the bytes of a buffer directly, right? So you can do this with zero copy, which means like you're basically using the bytes and having some struct that's pointing to the bytes.
00:25:27.801 - 00:26:23.461, Speaker A: And so when you mess with this struct, it's really just relaying your changes to the bytes directly. The difference between that and what you might typically see with deserialization is a lot of times when something's deserialized, it actually has to copy those bytes and transform them into whatever data structure that you're more familiar with working with, like a struct. So with that being said, what we want to do is we only want to deserialize the first few bytes of what we need. So you can see that I've set that up here in try to serialize, right? So we're going to take a look and make sure the data length, the buffer of our account's inner data is not less than 72. Because if we take a look at the data structure here, we got two 32 byte public keys, 64 plus a U64, which makes 72,8 bytes for U64. So 72 bytes, we need to get those first three fields. So if it's anything less than that, throw an error.
00:26:23.461 - 00:26:53.825, Speaker A: It's not going to work. Counts weren't in the right order or it's not a token account. If it is at least 72 bytes, we're expecting 165. But I don't have to put a check in for that. Maybe I could, but I didn't. And we're going to go ahead and try from bytes with bytemuc and we're going to borrow the first 72 bytes and we're going to pass in this self generic. And that's because we've annotated this struct with POD and zeroable, which means it can be used as a bytemuc type.
00:26:53.825 - 00:27:38.335, Speaker A: And bytemuc is going to be able to build this struct from a buffer. So we're going to pass that in here, borrow the account data first, 72 bytes, try from bytes into self. And if that works, then what we're going to do is take that partial token account data, the first three fields. We're going to validate that the owner is in fact who we expect it to be, and then we're going to return the account info of the token account, the mint, the owner and the amount. And the reason I'm doing this separately is because we have these configs right here. So once we pass the account info, we would have to deserialize this data again. But we're going to need the account info to do CPI calls.
00:27:38.335 - 00:28:15.715, Speaker A: But we also want this data to do checks, right? And to take a look at stuff like mint address, etc. So that's why we're passing all of those things like that. You can see that I actually followed the same exact format. You can see, like obviously we're doing this to save compute. And as you can see from the processor, we're doing it three times. We do it for the user's token accounts, we use it for the swap Token accounts for swap1 and for the token accounts for swap2. So if we have a concurrency of 5, that's 15 accounts that we're saving compute on by only partially deserializing them, which is pretty cool.
00:28:15.715 - 00:29:02.285, Speaker A: And then that leaves just the mints in our fourth loop. And you guessed it, we did the same thing for Mints as well. Right? Here's partial mint state, here's the first two fields of partial mint state or of the mint state itself. And if we look, here's mint, we get these first two fields, optional pub key, right? U64. But we need this decimal field too, don't we? Like we need this U8. So why aren't we pulling this out? Well, basically what happens is with Bytemuc, if you try to include a U8 alongside a U64, it's going to require you to use something called padding, because it can't just flop between two sized integers. It's a little bit more complicated than that.
00:29:02.285 - 00:29:52.083, Speaker A: But ultimately bytemuc wasn't going to let us turn this into a POD or zeroable type. So instead what we wanted to do was we just included the 32 byte pub key and the U64. This being an option, it adds another byte or so, and that gives us the 41 byte size here. And that means that, okay, if we can deserialize partial min state and we can take the first 41 bytes out, right? Then what we can, well, actually technically it's 40, and then we get the 41 as the last one. So we're going to try from bytes the 40, the first 40. Right. And that's going to give us the 32 byte pub key inside of an option and the 8 byte u 64.
00:29:52.083 - 00:30:21.429, Speaker A: And you might be thinking like, okay, well, an option is one additional byte, isn't it? Yes, but technically this is going to be stored in an optional non zero pub key, which means if there's no pub key there, it's 32 zeros. So we can expect this to always be 32. So 32 plus 8, we get 40. We also want to make sure that we account for that U8 one more byte. Right? So we're checking to make sure we have at least 41 bytes in the data. And if we do, we're allowed to continue. If not, we throw an error.
00:30:21.429 - 00:30:58.931, Speaker A: But then take a look at this. We run this bytemuc from bytes, same thing as the last one on our self Type on this pod 0able partial min state type, but we only do it up to 40. We save the last byte. And the reason is obviously because if we can deserialize the first 40 bytes into this, then we can just take our last byte, get 40 and make that, and consider that our decimal place, U8. Right. So that's a little workaround for the ByteMUC limitation on having to pad numbers. I'm sure you could probably think of a different way to do it too.
00:30:58.931 - 00:31:31.861, Speaker A: But this is just one way you could do it. And then you can see that we finally returned the account info for the mint and the U8 of the decimals. So that's it, guys. This file is partial deserialization in order to save on compute. You're going to see a couple things that I do to try to optimize on compute, but ultimately that's going to be one of the biggest ones that's in the program. Cool. All right, so going back to our readme, we talk quite a bit about partial deserialization and then finally we go to try arbitrage.
00:31:31.861 - 00:32:09.895, Speaker A: Right? So let's get into the bread and butter here. Now let's pop open, try arbitrage. This is in our arb RS file. And you can see I set up the struct because we have a lot of arguments going into this Try arbitrage function. So I just put them into a struct for legibility and to make sure we kept them in the right order, et cetera. So taking a look at these, the names of them match exactly what we've got here, right? We've got our token accounts for the user, which is in a vector. We got the swap one token account, swap two token accounts, the mints, right? All four of those should be the same length.
00:32:09.895 - 00:32:34.951, Speaker A: And then we've got the payer, the token program, system program, associated token program, blah, blah, blah, all the way down. Even our configs are in here, right? At least temperature. We don't care about concurrency anymore because we got all the accounts, right? So once we reach this point, concurrency is already over. We used it in the processor to load up all of our different accounts. So it's done. Now temperature is the one that dictates how aggressive to be on a trade. So we included it.
00:32:34.951 - 00:33:12.275, Speaker A: Okay, so cool. So anyway, let's move down to our try arbitrage function. And as you can clearly see, this is a hilarious nested for loop. I didn't think of any smarter way to do this. I'm sure there is, but this was just my way of doing it. For now. We are going to use a nested for loop to check all possible combinations of these mint accounts, right? So we're going to roll in, we're going to grab everything at index I and we're going to check all the index J's against I and just move down with our window across the list of all of these associated token accounts in mints.
00:33:12.275 - 00:33:56.875, Speaker A: That's really the key right there. But as you can see, what are we doing? Like, for each iteration, we are going to calculate R for swap one and R for swap two, right? And then we're going to take a look at the difference between those two. So we do a quick check just to make sure, like, okay, if these, if these values or these, you know, Rs values that come back are not valid, we're going to continue. And then finally, if everything checks out, we're going to check for arbitrage. And I'll show you guys what that looks like in a second. But I wanted to basically summarize what's happening here. You can see that if this is a sum value, if we have a trade, we're going to place it and this is going to return to us a trade, right? You can see this buy enum.
00:33:56.875 - 00:34:44.686, Speaker A: So if buy is buy on swap one, we're going to invoke arbitrage. And you can see from this little like Intellisense here, the buy configs go first, the sell configs go second. And if we want to buy on swap 2, you can see the buy configs are going to be for swap 2 and the sell configs are going to be for swap 1. And all this really means, guys, which I can show you how it looks, is we're just going to CPI between these swaps. So we're going to send the instruction to swap one to do a swap and then we're going to send the instruction to swap two to do a swap. And we just, we know from our indexes and these hilarious nested for loops that we're going to do something similar to the example we saw on the slides. We're going to CPI to swap one, make a trade.
00:34:44.686 - 00:35:14.593, Speaker A: Then we're going to take those assets and CPI to swap two and swap them back for what we originally had and make some arbitrage profit. And that's all that's happening here. So when you see invoke arbitrage, we're literally just setting up instructions and we're running two CPI invokes. Okay, now two things. One, I'm gonna quickly walk back up to check for arbitrage because it's a little bit more simple than I let on. I should have just covered this earlier. Basically, this is straightforward.
00:35:14.593 - 00:35:52.547, Speaker A: It's taking the percent difference of the two R values and considering which one is greater or lesser and returning which type of swap we should do which type of arbitrage, trade or none. Right? And you can see temperatures also being considered here as our trade threshold like we talked about. And so it'll calculate that stuff. And if there is a trade available, right, if it's greater than this stuff and it's over our threshold, it's going to tell us a trade and that's going to be what triggers these CPIs. So pretty cool. Hope you guys are with me so far. We're just going to do a trade between two swaps.
00:35:52.547 - 00:36:27.303, Speaker A: Swap here, swap there, right? Just like we saw. Now here's the last interesting piece about our program. One thing I want to mention before I cover this last interesting piece is you can see that we're doing this determineswap receive function. Look at this, Doc. This is the same as the one we wrote for the swap program. In fact, I literally copied this file in here, or at least copied these functions from the swap program. So again, we're making some big assumptions here that Both of these swaps run the same kind of constant product algorithm.
00:36:27.303 - 00:37:07.875, Speaker A: But for example sake I'm going to run it inside my program here and I'm going to assume it's the same on both of those swaps since I made the swaps. I know it is, but just wanted to call that out. It is a pretty big assumption. But anyways, going back finally to our CPI calls between the two programs, this is a neat little trick you guys might want to know how to do. So we know conceptually what we're doing. We're going to place a swap here, we're going to place a swap there, and we're going to move one asset to the other and eventually end up with the same asset we started with, but more of it. Okay, but in order to do that we are using a native program and we are trying to hit an anchor program.
00:37:07.875 - 00:38:41.609, Speaker A: Now with two anchor programs, if you have the crate of the anchor program that you want to CPI to, you can just import the instructions into your anchor program and just call them that way with anchor CPI context. Now if the crate is not publicly available but you somehow know the instruction name, or if you're using native, you could do this right here. We're going to create a new instruction. Now you can see here, I've got swap instruction data for the buy swap instruction data for the cell and I run this build instruction data and then I use those return values to build a new instance of a Solana program instruction, right? And new with Borscht just means, okay, give me the data as a reference and I will use borscht to serialize it into a buffer. So as long as we give the right data, we can go ahead and pass in. In this case we got a 16 length array or buffer and we're going to pass that in and then we have all these accounts, right? And you can see that I'm just mapping the account infos from my slice here for each one into account metas, right? And so that's going to give you the two instructions that you need and then we can just use CPI with the account infos. So it's a little bit weird, right? Like you have to add the accounts as account metas into an instruction along with the data and the program id.
00:38:41.609 - 00:39:23.849, Speaker A: And then you also have to pass those accounts as account metas in the invoke call. So a little bit strange, but the key important part here is building the instruction for an anchor program you have to run new with Borscht, but we have to use this Data. What does this data look like? Well, it looks like this, right? So I'm doing two at once here. I don't necessarily have to do this, but I just decided to. But what you really want to do is you want to take like. First of all, we know from our swap program that our instruction for swapping looks like this. We have our anchor context which is not included in your instruction parameters.
00:39:23.849 - 00:40:04.215, Speaker A: And we have one argument, a U64, so 8 bytes. Now anchor, we know, puts an 8 byte discriminator on everything. It puts it on your instructions and it puts it on your account state. So we need to know what that instruction discriminator is going to be for our swap instruction. So that we can take the 8 bytes for the instruction discriminator and then the 8 bytes for the U64, build a 16 byte buffer and use that as our instruction data to invoke this program. And that's exactly what we do here. We take, we initialize 2U 16 or 2U 8s of 16 length arrays.
00:40:04.215 - 00:40:49.389, Speaker A: And then right here is our functions discriminator hash input. Right? The name of our instruction is swap. And anchor is going to use the global namespace for your programs instruction by default, right? And that is how you take this. We use the B coefficient here to turn it into bytes. We run Solana program hash to use SHA256 to hash this thing. And then when we get that hash, we have a buffer or a hash and we turn that into this 16 length byte array by taking the first. We take basically the amount, right, the U64 into Leby bytes.
00:40:49.389 - 00:41:33.985, Speaker A: So that's going to convert our by amount into 8 bytes u64 to bytes. And then we're going to add the first 8 bytes of the hash to the first 8 bytes of our buffer. And then we're going to add the 8 bytes from our U64 into the last 8 bytes of our buffer, right? So hash, global colon Swap. Take the first eight bytes, add the U64 to bytes. That gives us a 16 byte length array which we can then use as our instruction data. Boom. And that's how you make an instruction for an anchor program in a native program.
00:41:33.985 - 00:42:05.445, Speaker A: Cool, guys. Okay, so that is everything on the program side, right? So the program side is looking pretty, pretty good. We have all this set up. We're going to try to play some arbitrage trades by invoking this program. Now one more neat little trick that I put into this thing that I thought was kind of cool is if you look at this nested for loop, you can see here that anytime we have a trade, right? If let some trade, we're going to place a trade. But let's take a look, look at like follow this line here. If that resolves to false, we're going to get this error.
00:42:05.445 - 00:43:03.305, Speaker A: So in other words, every time our program runs and checks all possible combinations of mints and has no trades, it's going to error out. Why? Well, on Solana, transactions are checked ahead of time. They're simulated, right? So you know the default send transaction with your RPC providers is going to simulate your transaction with the RPC and if it succeeds then it will send it. So usually when you're testing programs, if you get an error, you'll see transaction simulation failed because the simulation failed. Therefore they never even tried to send it because that costs you a fee. So what we're doing here is we're taking advantage of pretty much the RPC providers by saying, okay, I want you to simulate this transaction over and over and over again. And if and only if it returns an okay value, I want to place an arbitrage trade.
00:43:03.305 - 00:43:45.375, Speaker A: And you can see here that that's what we're going to do, right? An invoke arbitrage is going to return the okay. That's going to close the program out successful. So pretty cool, right? We're going to basically place a trade only if the simulation works, which means in this case we're only going to pay a transaction fee if we have a real trade, which is kind of a little bit of a hack. So anyway, that's the last bit of cool information about the program itself. I thought that was interesting. But nonetheless we're going to move on to our client side stuff and we're going to run some tests. So just to recap here, we saw that we are taking advantage of using native instead of anchor, right? So we've got a little bit lighter of a program.
00:43:45.375 - 00:44:31.935, Speaker A: We're using partial state deserialization. We have set up the constant product algorithm locally to our program. We are using some deterministic order of accounts and we are using concurrency and temperature configs and finally taking advantage of pre flight checks. That's how our program is working right now. So what we want to do now is take a look at one other particular piece of Solana tech that I'm using to actually make this thing work. And that is called an address lookup table, which I cover later in the readme as well down here. So address lookup tables are special accounts on Solana, basically what they Are are hash maps.
00:44:31.935 - 00:45:40.083, Speaker A: So when you build a transaction in Solana, you have to include all of the keys for every account that needs to be involved in the transaction. And this adds 32 bytes of size to your transaction size every time you do that. So the more accounts you need to include, the larger your transaction, the larger your fee, and there is a maximum. Now, the introduction of address lookup tables last year provided a way for you to increase the size of your max transaction size by instead of including 32 bytes for an entire address, you can include the index of that address in a lookup table, which is a single byte number, a U8. So imagine you have a hash map where the key is a U8, which means you can have up to 255 keys and the value is a 32 byte public key, right? You can use this lookup table and you can just give me all the U8 indexes and I can go look them up myself. And that way you don't have to give me 32 bytes for every address, you can just give me one. It's exactly how this works at runtime for Solana.
00:45:40.083 - 00:46:27.141, Speaker A: When you build a transaction with a lookup table, the runtime will actually go look at the lookup table instead of at your transaction. So you can see from my example here, the size is drastically changed, right? So it doesn't help you a lot when you basically have like one account that you're adding, right? Because you have to add the address of the lookup table account itself. This is a table on chain. But once you get past one account incrementally, every account that you add, you save 31 bytes. So pretty cool. So we're going to take advantage of address lookup tables since we need to include, as you can see, we need to include accounts for. We need to include all these accounts.
00:46:27.141 - 00:46:44.196, Speaker A: Then we need to include, let's say, concurrencies, five. We'll need five, five, five. I think I missed one. Which makes 20 plus these first. 1, 2, 3, 4, 5, 6, 7, 8, 9. So I think, wait, 1, 2, 3, 4th. 8.
00:46:44.196 - 00:47:35.495, Speaker A: So 28 accounts for a concurrency of five. And every time we increase concurrency by one, we add four accounts. So you can see that we'll end up with a lot of accounts as we go. So we're going to use an address lookup table and we're going to Send a transaction v0 a version transaction to actually minimize our transaction size. Are you ready? Let's rock and roll. So first things first, I'm going to take down my beautiful UI and I'm going to just run, actually, I'm going to go back to my main directory cargo, build spf, and that's going to build our Solana program, which I already did ahead of time, so you don't have to watch my compiler. And then I'm going to do Solana program deploy, and I'm going to do target deploy, and we're going to go ahead and ship our program to DevNet.
00:47:35.495 - 00:48:20.385, Speaker A: All right, so as you can see, we've now finally deployed our programs on DevNet. And let's take a look at our test here. So first things first, I'm reading our program from just like our local key pair that we just created, so I don't need the address. And let's take a look at this transaction file here. This is how we're going to build the address lookup table. So you can see, we got this function create address lookup table, and those actual functions are coming from Web3js, right? So we get this address lookup table program, we do create lookup table that gives us the instruction and the lookup table's address. And then we can build transaction v0, which is just this helper function that I built down here.
00:48:20.385 - 00:48:56.895, Speaker A: And take a look at this. We build transaction v0 without a lookup table. Right? It's just a version transaction with no lookup tables. So we go ahead and get the block hash, we compile a new message, and we create a transaction with that message and add our signatures. Now, if we want to add an address lookup table, we follow the exact same steps, except here in this compiled to v0 message. We are actually providing, as you can see, the optional config for an address lookup table account. You can have more than one, actually.
00:48:56.895 - 00:49:30.595, Speaker A: And so imagine if you had a ton of address lookup tables and just provided a ton of accounts, and they were all Instead converted to U8 indexes. You could save so much space, you could pack so many accounts in there. I don't know what the total number is with lookup tables, but it's a lot. You can see that all we really have to do differently is provide that lookup table account address, and then this transaction will compile and use our lookup table. Right, which is cool. So anyway, that's exactly what we're going to do. Right? So now let's just.
00:49:30.595 - 00:50:13.235, Speaker A: We want to take a look at that real quick, just so you guys know how it works. But let's take a look at our test. So taking a Look at our test here. What we're going to do is we're going to first go through and beforehand we're going to make sure that we have the tokens in our token account to do the swapping. Right? And again, I'm going to use the same assets as before. So one additional step I forgot to mention earlier is you want to also take the assets JSON and you want to make sure that you remove this one and you put the one from our swap programs in here. Again, because we got the mints in there.
00:50:13.235 - 00:50:35.073, Speaker A: So we're the mint authority. We were the mint authority on both swaps. We're the mint authority again. So the first step in our swap is we're going to mint ourselves some of these tokens. So we have the tokens to be able to place arbitrage trades. Right. And then we're also going to gather all of the token accounts, right? Because sure, we can load this thing, we can get the pool address.
00:50:35.073 - 00:50:49.489, Speaker A: Right. Which I don't know if I'm actually doing or not here. Let's see. I don't think I am. Yeah. So get pool address is just doing the derive git program address. Yeah.
00:50:49.489 - 00:51:16.729, Speaker A: So I'm cheating a little bit here on the client side, I'm using the assets JSON. I could instead just query the pool and ask for all the assets, but I'm going to use just the JSON file. And either way, I'm going to aggregate the lists of all these accounts. So this is going to be all of them. So I think we have 11 assets in the JSON. So each of these lists will have 11 keys in it. And then based on the concurrency value, we'll send some slice of that list over to our program.
00:51:16.729 - 00:52:01.215, Speaker A: But either way, so we airdrop what we need to to our token accounts and we go ahead and aggregate all of these public keys. And now that we've got that ready to go, we're going to create a new lookup table, right? And I've got this like inline extend function that I wrote, which is basically just extending the address lookup table. Right. I'm just trying to be cool here, but basically we're going to extend address lookup table with every public key that we have. So you can see we're going to add all 11 token accounts addresses for us for the SWAP1, for SWAP2 and the Mints. So we're going to add 44 accounts to our address lookup table. And realistically, we could add the other accounts too.
00:52:01.215 - 00:52:30.361, Speaker A: I just think I actually Forgot to do it. Like the first few that we're reading in. Like these ones here, I could add all these as well. So anywho, moving right along, that's going to be where we extend address lookup table and that looks like this. It's another instruction directly from the program. We just pass in a list of addresses, right? So here's extend lookup table address, here's the addresses here, and we can pass them in. And we get the instruction to do that.
00:52:30.361 - 00:53:14.625, Speaker A: And that's how you add new keys to the lookup table. And in the order of how you pass them, you'll get the index, the U8 index. Now the cool thing about this is if you look at the transaction setup, nowhere in this setup here for building a transaction v0 with the lookup table do we have to specify indexes. We just pass the keys like we normally do, right? So if I look at instruction, you can see here, this is my arbitrage instruction. And I'm going to pass in create arbitrage instruction. I'm going to pass in all of these keys. So like keys push, keys push, keys push and eventually keys, which is going to have a huge length, it's going to be a big list.
00:53:14.625 - 00:53:59.539, Speaker A: And nowhere in here am I including the indexes of these keys in the address lookup table. In fact, I don't even think I have the address lookup table in this at all to build the instruction. So you build an instruction, you put your keys in like you normally would, and then all you have to do is include the address for the lookup table in the compiled to V0 message function call and it's automatically resolved for you. It will go look for all of those indexes automatically and figure out which ones live in that address lookup table and which ones don't. So it's super easy to use, guys, super easy. So anyway, moving along, once we've created our address lookup table, we added our accounts to it, then we're going to send arbitrage instruction. This is a function that I wrote here.
00:53:59.539 - 00:54:27.795, Speaker A: You can see we're just creating that instruction for our program, sending it with a lookup table. And I set up these like logging. If we get a trade right here, this is how you can parse out the error type of a send transaction error. And that means we have no arbitrage. And I just put it on a loop here where we're just going to continuously hit it. I got this iterations number as well. Obviously that just means how many iterations do we want to do through the list.
00:54:27.795 - 00:55:26.177, Speaker A: And you can see here, I've set up this complicated list where I've got this step break, blah blah, blah, sub lists, all this crazy stuff. The point is, guys, when I set a concurrency, If I have 10 assets and my concurrency is five, that doesn't mean I have two instructions to send. That means I might have, I don't know the math right now off the top of my head, but you would have to do more than two, right? You're going to need to get every possible combination of five mints in a list of 10 mints, which is not two. So that's the reason for this messy, nasty looking loop. So we set up a loop on the client side to iteratively go through and every time we get to the size of our concurrency, we send the instruction and we start over again. And then on our program side, it will iterate through all of those five and find every possible combination from the program side. Hopefully that makes sense.
00:55:26.177 - 00:55:51.205, Speaker A: It was very confusing to write, but it works. And so that's it, that's literally all we're doing. And then at the end, we take whatever's left, send the final arbitrage instruction. So partial state deserialization, all the other goodies in the program and address lookup tables, pre flight spamming. We've got it all here. We've got a good swap arbitrage bot right now. Let's kick this thing off.
00:55:51.205 - 00:56:06.561, Speaker A: So we're going to create a lookup table on DevNet. Boom, done. Then we're going to add our addresses. There they all are. There's 44 addresses on our lookup table, 0 to 43. And there's an arbitrage trade. We just placed a trade between our two swap pools.
00:56:06.561 - 00:56:28.187, Speaker A: There's another one. And you can see the transaction size I'm printing out right now. If you go ahead and take a look at the transaction size without the lookup table, and we're doing eight accounts right now as well. Pretty sweet. You'll see a significantly larger number. The problem is it sometimes errors out because if you push the max size of a U8, a Uint 8 array, it'll break. Right.
00:56:28.187 - 00:56:42.747, Speaker A: But as you can see, we're trading arbitrage. We are go ahead. And we are sending trades between these two swaps. But anyway, guys, cool. So that's it, that's arbitrage trading. And that's just one way that I set up an arbitrage bot. I encourage you to try building your own.
00:56:42.747 - 00:56:59.557, Speaker A: I think it would be super cool. It's been a lot of fun for me building this one. I even liked adding these, like, configs and like, going kind of crazy with it. I loved all the different optimizations and stuff that we were able to use, like the bytemux stuff. Really, really cool. But yeah, go ahead and try it out. See if you can throw it on mainnet.
00:56:59.557 - 00:57:06.525, Speaker A: See if you can make a little money or something and you know, until next time, we will catch you on the seven C's later.
