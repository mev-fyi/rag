00:00:08.840 - 00:00:09.528, Speaker A: GM.
00:00:09.638 - 00:00:52.024, Speaker B: In this workshop, we're going to learn about Solana Pay and its various use cases, which aren't limited to just payments. We're going to use transaction requests to interact with the seven Seas game. So let's get started. By the end of the workshop, you would also have a QR code which, once scanned with a Solana pay commission compatible wallet, would actually send a request to your local development server, which will then create an instruction which will interact with the seven Seas game. So I'm just going to scan this with my wallet and take a look at what happens in the seven Seas game. Once I press approve, you'll notice that the monster would fire its attack onto the nearest ship. And this is all done with Solana Pay.
00:00:52.024 - 00:01:49.320, Speaker B: So before we dive into the code, let's just do a quick recap or a quick learning on what Solana pay is and why it's even something that exists. Why Solana for payment traditionally, blockchains were built for the payment use case, but we haven't really seen this come to the full fruition just yet. So when we think about Solana, we think about a blockchain that has very low transaction fees, fast settlement and a high throughput. And these are just the kind of attributes that you will need to build an enterprise grade payments infrastructure. So Solanapay is a payments protocol that was built to facilitate commerce on chain. So imagine you have like an e commerce store or a point of sale terminal. How do you connect a particular order to a transaction that's happened on chain? This is like the main or the core problem that Solana pay protocol was created to solve.
00:01:49.320 - 00:03:03.284, Speaker B: There's like so many other things or so many other benefits that you actually get from using it. So when we think about composability, this is something that the Solana blockchain actually heavily optimizes for, and you get to use its full effect on Solana pay. So, like, imagine you want to do a cross promotion between your store and let's say an NFT collection or a DeFi platform, you name it, because it's composable and because it's built on a permissionless infrastructure, you can actually just go ahead and do just that. You'll kind of get to see a bit more of this when we're working on transaction requests where your server would actually get access to the particular account, or should I say the wallet address that has scanned your QR code, and you'll be able to, for example, look at all of the nfts that they have. Look at the tokens they have, you can even see if they've interacted with a particular protocol on chain for you to kind of offer some kind of dynamic checkout experience just based on the fact that you have the user's wallet address. So we get to see, like, see that play out more heavily once we start looking at transaction requests. But going beyond that, Solanapay has been used for lots of things to do with nfts.
00:03:03.284 - 00:03:55.160, Speaker B: We've seen people minting with solanapay, dynamic discounts, loyalty programs. There was even a particular event where there was a photo booth, and you can go into that photo booth, take a picture, and it will actually mint an NFT to your wallet. And that was built with Solana Pay. So there's so many use cases of Solana Pay, specifically when we start looking at transaction requests that go beyond payments. And even in our case in the demo that you saw right at the start, we're going to use this in a pirate use case for our 7th use game. So really cool protocol and really extendable, even though it's just called Solana Pay, can be used outside of payments. So why Solana pay, and I think kind of these attributes pretty much just speak to themselves.
00:03:55.160 - 00:04:43.490, Speaker B: But the fact that settlement is instant, so the moment somebody pays on your store, you actually have the capital instantly at hand, which can now open up some different use cases for merchants, that they can begin to deploy this capital immediately, as soon as it's received. Also, the notion of zero fees and zero fraud, in the fees case, it's pretty much near zero fees because it's like 0.000, $0.01. And when we talk about zero fraud, this is just like an inherent benefit that you get from using blockchain technology. So this is the fact that there's no form of chargebacks that people can just claim. There's no case of somebody, for example, stealing some credit card details and using it on your site. Those kind of things just can't happen.
00:04:43.490 - 00:05:41.726, Speaker B: And then when we're talking about the permissionless innovation that's related to the example that I gave, that, because you have the person's wallet address, you can then offer a dynamic checkout experience just based on what that user has done or what assets that user owns. And you don't need to talk to any team to do something like that because it's all done on chain. Also kind of offers an immersive commerce engagement because you have a direct one to one communication channel between you, the merchant and the end user. There are no third parties, there are no middlemen. As soon as somebody interacts with your store and you have their wallet address, you have a direct line of communication with them. So you can send them like adverts or again, the dynamic or the custom checkout experience. So the first thing that was done in the v one of Solana pay was something called transfer requests.
00:05:41.726 - 00:06:00.896, Speaker B: And this was just to facilitate a simple transfer. And the way this worked is that there was a particular URL that followed a URL scheme that had all of the required parameters encoded into the URL. So you had things like, can actually.
00:06:00.920 - 00:06:02.604, Speaker A: Just check out the spec.
00:06:03.784 - 00:07:06.224, Speaker B: So in the transfer request, some of these are optional. So for example, you had the recipient, which is, this is the address that's going to be receiving the tokens. You had the amount, which is the desired amount that this particular transaction is for an SPL token, which is optional because you could also just deal with native soul. In the case of an SPO token, you just put the token mint, I'll skip reference, but you have the label and the message. And again, an optional memo, which will just create a memo instruction. But the reference is probably the most important thing as part of transfer request, because this is, it will act as like a UUID, and it's just a randomly generated public key that should be used only once, which is to link the transaction that is going to happen on your store or on the point of sale system with a transaction that happens on chain. So that reference or that UUId is what connects the commerce transaction with an on chain transaction.
00:07:06.224 - 00:07:31.304, Speaker B: So yeah, that's transfer request. And again, if this URL is encoded into a QR code, and as long as the wallet you're using supports Solana pay. Once that URL, sorry, once that QR code is scanned, the wallet would know exactly how to decode that URL to get the necessary parameters for the transfer request. And I believe in this page.
00:07:34.184 - 00:07:34.520, Speaker A: There.
00:07:34.552 - 00:08:21.010, Speaker B: Should be a section that tells us, there we go, the wallets that support Solana pay currently. So yeah, getting to the more exciting part, transaction request. This is something that basically is a v two. And now, rather than just a simple transfer, you're actually able to construct any transaction. So any transaction that's a valid Solana transaction, you'll be able to use Solana pay with that. So how it works is that it's still URL based, but this particular URL is pointing to your server, and your server needs to be configured to respond to both a get request and a post request. So now, again, once the wallet that you use.
00:08:21.010 - 00:09:31.612, Speaker B: And once you scan the QR code, the wallet would make to request to that particular URL, which will now hit your server with a get and a post request. The get request, you just need to respond with an icon and a label. And this is just what the wallet would show up in like a pop up UI so that the user at least can get some like familiarity with the transaction so that it knows, or at least it can show that yes, you are about to interact with the store that you think you are interacting with. With the post request in the body would be the account, which is the address of the person that has scanned the QR code, and your server needs to respond with a valid transaction. So this is pretty much what you saw at the beginning of the workshop where I scanned the QR code and it was able to cause the monster to fire off its attack. That's because again, once my server received the post request, I just created the instruction to interact with the Seven Seas program. So yeah, it's quite expandable in terms of what you can do.
00:09:31.612 - 00:10:11.110, Speaker B: We've seen like so many use cases of this in the world, again, that extend beyond payments. So in this workshop, that's exactly what we're going to be doing. We're going to create our own local server that's going to respond to the get and post request. And you'll be able to also scan the QR code that you have on your screen that hits your server and you'll be able to see the monster fire off its attack in the seventies program. So with that said, let's get started then let's start writing some code. Okay, so to follow along with this workshop, you're going to need a free account on Vercel. This is what we will use for the local development.
00:10:11.110 - 00:10:51.864, Speaker B: I guess you could also follow along with Express, but for this workshop we're going to use Vercel because it's just easier setup wise. You're also going to use, sorry, need another free account on Grok. This will just allow for you to be able to hit your API server that you have running locally with an external URL. So go ahead and sign up for free account on Grok and Vercel so that you can follow along with the code. Oh, you would also need to use a mobile wallet that is compatible with Solanapay. You can find a list of those wallets in the Solana pay documentation.
00:10:52.204 - 00:10:55.156, Speaker A: So yeah, let's open up versus code.
00:10:55.340 - 00:10:59.588, Speaker B: So what we're going to do first, we're just going to create our projects directories.
00:10:59.636 - 00:11:08.344, Speaker A: So I'm just going to open up the terminal. I'm going to create one called payments workshop.
00:11:13.724 - 00:11:27.372, Speaker B: Inside this particular director, I'm just going to do NPM inity. This is going to initialize a basic project for us. And why flag is just to say yes to all of the questions that.
00:11:27.388 - 00:11:28.544, Speaker A: It could have asked us.
00:11:29.364 - 00:11:46.268, Speaker B: So yeah, now that we have this directory, we're also going to create a directory called API and within it a file called index js. This is just to follow the convention that Vercel is expecting for a simple API server.
00:11:46.436 - 00:11:49.900, Speaker A: So just going to create that and.
00:11:49.932 - 00:11:52.144, Speaker B: Then create the file index js.
00:11:52.624 - 00:11:57.328, Speaker A: I'm just going to now open this up in versus code so we can.
00:11:57.376 - 00:12:05.644, Speaker B: See we have our package JSon and we have the empty index js file.
00:12:06.904 - 00:12:09.164, Speaker A: Just check that's where we are. Cool.
00:12:09.984 - 00:12:27.040, Speaker B: Then we are going to need to install both Vercel and Grok. I guess optionally you could have this globally installed. But yeah, I just personally like to install dependencies locally because of reasons. So just gonna install those.
00:12:27.072 - 00:12:29.488, Speaker A: So gonna go Vercel and Grok.
00:12:29.656 - 00:12:33.124, Speaker B: This will just install those dependencies for us locally.
00:12:35.504 - 00:12:38.568, Speaker A: I guess whilst that is downloading we.
00:12:38.576 - 00:12:53.304, Speaker B: Can just go ahead and start to scaffold our server. So kind of just to go over again we're gonna be creating our own server that's going to be responding to the get and post request from the wallet.
00:12:53.964 - 00:12:56.740, Speaker A: So going to go ahead and start that.
00:12:56.772 - 00:13:09.012, Speaker B: So again this is just following the convention that Vercel is expecting. So we need to export a default function that is titled handler which takes.
00:13:09.068 - 00:13:12.024, Speaker A: A request and a response.
00:13:13.824 - 00:13:16.560, Speaker B: And just so that we can see that this is working or just console.
00:13:16.632 - 00:13:26.280, Speaker A: Log that is handling a request and we're going to log out request method.
00:13:26.432 - 00:13:29.704, Speaker B: Just so that we can see that we're both getting a get and a post request.
00:13:29.744 - 00:13:42.046, Speaker A: I'm just going to return a response. Thank you. Autocomplete status 200 Jason format we'll just.
00:13:42.070 - 00:14:01.314, Speaker B: Do just a blank response for now. We just want to see that this is working. I guess it goes without mention that for this workshop we're going to be using JavaScript. At some point I might be tempted to use js doc comments just to help with some of the autocomplete features.
00:14:01.734 - 00:14:10.294, Speaker A: So let's just go ahead and now see if this is working. So if we do NPX versailles device, this should now run. Okay, setup this.
00:14:10.874 - 00:14:13.974, Speaker B: I guess all of the default options should just work.
00:14:17.314 - 00:14:23.174, Speaker A: No modifications needed. Cool. So now if we go to localhost.
00:14:24.154 - 00:15:00.292, Speaker B: And I guess we have our code in the API directory. So slash API should return the empty Json. And if we look at our console, we see the handling a request get. So with that we have our basic server running and it can handle technically any request and just respond with an empty JSon. So that's great. I'm now going to open another terminal session side by side. And for that one I'm going to run Grok, which again just exposes our local port via an external URL.
00:15:00.292 - 00:15:03.984, Speaker B: And we're going to need this when we're testing our solana pay endpoint.
00:15:04.804 - 00:15:08.624, Speaker A: So now that I have that running, just make this a bit bigger just to see.
00:15:08.964 - 00:15:13.700, Speaker B: You can see that we have a external URL that we can use.
00:15:13.812 - 00:15:20.384, Speaker A: So it's just, so you have the full URL. So if I take this.
00:15:23.284 - 00:15:24.368, Speaker B: And go.
00:15:24.416 - 00:15:25.856, Speaker A: Back and I'll change this to have.
00:15:25.880 - 00:16:16.960, Speaker B: That external endpoint, this store responds with the empty JSon. You can see another log statement to say hand in a request get. So now we can see that our local server has been forwarded correctly and now we have this external facing URL to hit our local server. So again, this is like extremely necessary for us testing our transaction request endpoint because when we're scanning the QR code from our mobile wallet, it actually needs to hit to our server. So with that we should be at the point where we have our local development server up and running. So the next thing that we are going to need to do is just set up the QR code just so that we can have a QR code that points to the local development server that we have. So for this, we're actually going to use a library called QR code styling.
00:16:16.960 - 00:17:02.724, Speaker B: And I guess you're free to use any QR code provider that you want. This is the one that we actually use in the official Solana pay repo. So we're just going to use it here. What you'll need to copy is the URL that you get with Ngrok. And also not to forget the slash API because our code is written in the API folder and we're just going to need to paste that in where it says data. So now there's other customizing or UI styling options that you have, but I'm just going to leave it empty for now because this works enough for me. This points to our endpoint, but according to the Solana pace spec, which we can take a look at for transaction.
00:17:02.764 - 00:17:03.744, Speaker A: Requests.
00:17:05.684 - 00:17:09.020, Speaker B: The URL that we use in.
00:17:09.052 - 00:17:10.664, Speaker A: The spec.
00:17:12.724 - 00:18:01.004, Speaker B: The URL that we use need to be prefixed with Solana Colon. So we need to make sure that for our QR code we also have the Solana colon. And now we now have a valid URL that matches the Solana pay spec. So if I was to go in whatever mobile wallet that I'm using, I should be able to scan this and it should be able to show me the, show me the configuration I have in my particular store. So now we're just going to go ahead and complete our API to conform to the Solana pace spec because right now we just have it returning an empty JSON response, which isn't entirely useful at the moment. So the first thing that we're going to do is going to create our get handler.
00:18:01.504 - 00:18:06.284, Speaker A: So let's just say function handle get.
00:18:06.704 - 00:18:08.400, Speaker B: This is just going to take the.
00:18:08.432 - 00:18:18.584, Speaker A: Response and we're going to return response status 200, Jason.
00:18:21.324 - 00:19:15.702, Speaker B: And we need to return a label, which in this case could be anything, any valid string. I'm just, because this endpoint is to call the Cthulhu instruction on the seven seas game. I'm just going to call it Cthulhu fire. And then the icon, this will be the image that you want to show. And again, you can choose any image that's like a PNG, JPEG or Webp I believe is supported. I'm just going to use this icon that I have prepared already, which is just going to show like a nice little octopus icon. So now that we have this handle get function that again, this actually conforms to the Solanapase spec that our get must respond with a label and an icon.
00:19:15.702 - 00:19:24.574, Speaker B: So now we're just going to modify this code. We're going to leave the console log just for sanity. And we're going to say if request.
00:19:24.694 - 00:19:42.284, Speaker A: Dot method equals equals get, we want to return handle get and pass in the response.
00:19:44.264 - 00:19:56.494, Speaker B: Else for now we're just going to return an error because we know in future we have to handle the case for if the request method is a, a post.
00:19:56.614 - 00:20:14.794, Speaker A: But just for now, we're just going to return an error and we're just going to say method not allowed and get rid of this.
00:20:18.654 - 00:21:28.144, Speaker B: So now to test this, I guess there's multiple ways. One, you could go back to your, your browser and hit your endpoint with the slash API and you can see that's actually responding with our label and icon. Alternatively, you could actually scan your QR code with whatever wallet you're using. And on Phantom, especially because we haven't created the post response yet, Phantom would actually currently error out. But you actually notice, for example, I'm scanning this on my phone at the moment and you can see it's actually, sorry, our server is getting both a get and a post request. So on Phantom, if you were to scan your QR code, you would be able to see the request coming in on your server, but you wouldn't actually see the, the UI widget pop up on the mobile wallet itself. But I believe if we're to use Soulflare, for example, and scan, you should be able to see the pop up with the, with the, with the correct label and icon.
00:21:28.144 - 00:21:37.036, Speaker B: Um, so yeah, we've handled the get, now we need to create our post response. So we're going to follow a similar thing here.
00:21:37.060 - 00:21:40.194, Speaker A: So we're going to say function handle post.
00:21:40.324 - 00:21:42.046, Speaker B: This one is going to take both.
00:21:42.110 - 00:21:45.274, Speaker A: The request and response.
00:21:50.774 - 00:22:01.194, Speaker B: So according to the Solana pay spec, the wallet is going to send the account and the post body. So actually I just want to log that out.
00:22:03.454 - 00:22:11.814, Speaker A: We can say account should be request body account.
00:22:12.874 - 00:22:28.370, Speaker B: I guess if you're actually building this out properly, you would have like various checks actually make sure that the account is there. But just for this example, we're not going to do any form of validation and I'm just going to start scaffolding the response.
00:22:28.522 - 00:22:36.194, Speaker A: So response status 200, Jason.
00:22:37.654 - 00:22:48.454, Speaker B: And we need to respond with a transaction. For now, we're just going to leave this as a to do, but that actually needs to be a base 64 encoded transaction and we're going to respond.
00:22:48.534 - 00:22:54.854, Speaker A: With a message as well. And it's just going to be Cthulhu fire. Yep.
00:22:54.934 - 00:23:08.754, Speaker B: So this is just like the basic function body. But yeah, there's so much things that we need to do in order to actually get the correct transaction. For now, I'm just going to add this. We can say else. If.
00:23:10.534 - 00:23:28.214, Speaker A: Request method equals equals equals post that needs to be in all caps, then do something else.
00:23:32.434 - 00:23:33.242, Speaker B: So if we want to do that.
00:23:33.258 - 00:23:44.442, Speaker A: We just want to return handle post and it needs the request and response there.
00:23:44.618 - 00:24:24.154, Speaker B: So I guess with this, actually we never need to go back to the handler function again. It correctly routes our get request to the handle get function routes our post request to the handle post function in any other method is currently not allowed. So now we just need to continue to build out this handle post function. To get the correct transaction. We can start doing the necessary steps required to get this the correct property for transaction. So what we're going to need, we're going to need the public key. So I guess in this case it's the player.
00:24:25.134 - 00:24:42.874, Speaker A: The player equals new public key and we're going to pass in this request body account. We're going to need to create this Cthulhu instruction.
00:24:45.994 - 00:24:48.810, Speaker B: Which for now we're just going to scaffold another function called Create.
00:24:48.882 - 00:25:02.282, Speaker A: Cthulhu instruction which is going to need the player and we're going to need, as I said, this transaction and we're.
00:25:02.298 - 00:25:03.474, Speaker B: Just going to scaffold that for now.
00:25:03.554 - 00:25:17.304, Speaker A: As well and just say prepare transaction and it's going to need the Cthulhu instruction and this is going to just return transaction.
00:25:17.964 - 00:26:19.694, Speaker B: So I guess with this we're just like creating the scaffold for the handle post function, which we're going to have this player, which is the account that's actually scanned the QR code. We're going to need to create this Cthulhu instruction and that's going to take in the player. And once we have that instruction, we need to prepare the transaction by just encoding it with base 64. And this will be the final response from our server. So in here I'm actually just going to do a nice little temporary trick that you can do if you're using versus code, you can just have this comment with check and it's actually going to almost type check your JavaScript code for you. So we can see that we're using this public key, this public key class that doesn't exist. And of course our create Cthulhu instruction and prepare transaction functions that also don't exist.
00:26:19.694 - 00:26:38.934, Speaker B: So we're going to, I'm going to create now another terminal session to install the required dependencies. In this case, we actually need to install Solana Web three js because that's where we'll get the public key cut last from.
00:26:40.034 - 00:26:47.018, Speaker A: So I'm going to go ahead and get that installed so we can now.
00:26:47.066 - 00:26:51.466, Speaker B: Add the missing import from web3 j's with a public key.
00:26:51.650 - 00:26:54.614, Speaker A: And now we can also begin to create this function.
00:26:58.764 - 00:27:08.664, Speaker B: So we have this function create Cthulhu instruction that takes in the player. So the first thing that we're going to have to do is.
00:27:10.684 - 00:27:11.940, Speaker A: Actually, let's.
00:27:11.972 - 00:27:41.272, Speaker B: Actually comment out what we need. So first thing we need is we need to get the players gold token account. And if you don't know what this gold token account is, I guess for the purposes of this particular workshop, you don't need to worry too much about it. But if you've been following along with our workshop series, you'll know exactly what this, what this gold token account is and what it's used for. What we're going to need to play is gold token account. We also need to get the all.
00:27:41.288 - 00:27:45.564, Speaker A: Of the accounts needed for the Cthulhu.
00:27:48.184 - 00:27:51.080, Speaker B: Instruction and then we're going to need.
00:27:51.112 - 00:27:53.684, Speaker A: To return the instruction.
00:27:54.664 - 00:28:05.632, Speaker B: So first things first, to get the paisgold token account we're going to use a nice helper function from the Solana SPL token library.
00:28:05.808 - 00:28:22.844, Speaker A: So the count the players token account equals you can use, await, get or create associated token account. And we pass in.
00:28:24.944 - 00:28:26.040, Speaker B: A connection which.
00:28:26.072 - 00:28:33.472, Speaker A: We'Ll need, we'll need a payer, we'll also need the gold token mint and.
00:28:33.488 - 00:29:20.954, Speaker B: Then we need this plays account. So yeah, we're going to need to import this from the SBL Token library. And the payer and gold token bin are variables that we'll need to define at some point. So let's go ahead and install the SPL token library. And we're also going to install the Env and the base 58 library. And you'll kind of like see why we need the Dot NVM and the base 58 library. So we're just going to go ahead and install those.
00:29:20.954 - 00:29:23.894, Speaker B: Then once that is installed we can.
00:29:23.934 - 00:29:38.240, Speaker A: Add this missing dependency. So we're going to go ahead and import from at Solana Spl token and.
00:29:38.272 - 00:29:40.680, Speaker B: We'Re going to need the get or.
00:29:40.712 - 00:29:45.284, Speaker A: Create associated token account. You can see that we have a nice typer here.
00:29:47.184 - 00:30:00.168, Speaker B: So now some of the missing variables that we had, we needed a connection. This is something that's going to come from the SPL, the web3 j's library.
00:30:00.336 - 00:30:09.404, Speaker A: So connection. And that is going to come from Solanaweb3 js.
00:30:09.704 - 00:30:26.304, Speaker B: And for the purpose of this, we're actually just going to use Devnet because that's where the seventies game is deployed. And also that's where our gold is going to be. So now we have the connection, we need the payer. For now, I'm just going to leave this blank.
00:30:26.344 - 00:30:27.524, Speaker A: We'll come back to that.
00:30:28.084 - 00:30:55.304, Speaker B: And we're also going to need the gold token mint. And this is one that comes from one of the earlier workshops. But for this particular gold token mint, we're not going to use the gold token Mint that you yourself created in the previous workshops. We're just going to use the standardized ones, the standardized gold token mint that was created in the deployed seven Seas game.
00:30:55.824 - 00:31:09.944, Speaker A: So it's a new public key and I'll just paste this, that's the go.
00:31:09.984 - 00:31:49.894, Speaker B: Token mint and this payer. And I guess there's like something that's what I kind of find cool with the Solana paid transaction request where one, you can actually choose to be the fee payer so that anybody that is interacting with, let's say your particular store or point of sale system or in this case in our game, you can pay the fee for them if you wanted to. So that's what we're going to do. So for anything related to a fee. So for example, if we need to create the associated token account for this particular player and also just for the transaction costs for the Cthulhu instruction, we are going to be the fee payer.
00:31:50.644 - 00:31:54.772, Speaker A: So I'm just going to do exactly that.
00:31:54.948 - 00:32:03.356, Speaker B: So in this case, we're going to get key pair, which is from Solanaweb.
00:32:03.380 - 00:32:20.974, Speaker A: Three js, just get the updated. We're not going to generate it. I'm going to do from secret Key and I'm just going to use the base 58 decode process env payer.
00:32:21.554 - 00:32:59.202, Speaker B: So there's actually several ways you can go about this. In my case, I'm just going to have the secret key as an environment variable, which of course I'm not going to show here so that it can be loaded in securely. There's multiple ways to actually import from a secret key. Sorry, import from a private key. You can either do it with this method or for example, you can use the unit eight array, which I guess is actually probably a little bit safer since you don't have to rely on an external library.
00:32:59.378 - 00:33:13.246, Speaker A: So let's take a look at the Solana cookbook. Actually, we want to, I think if you look at keepers and wallets. There we go.
00:33:13.390 - 00:33:34.674, Speaker B: How to restore keep keeper from a secret. So example, you can have like the private key in your environment variable and then load it directly with this. There is, as I said, the base 50 option. But I think this is definitely a lot safer because you're not relying on a third party library. So I'm going to go ahead with this method.
00:33:35.554 - 00:33:51.538, Speaker A: Unit A array from. So I'm going to get rid of that and say unit eight array from. The only thing you'll need to do is just JSON parse that.
00:33:51.666 - 00:33:52.906, Speaker B: So it actually reads it in as.
00:33:52.930 - 00:33:55.294, Speaker A: An array and not just a regular string.
00:33:56.714 - 00:33:58.094, Speaker B: So yeah, we have that.
00:33:58.914 - 00:34:00.454, Speaker A: Let's get rid of this.
00:34:03.134 - 00:34:34.792, Speaker B: So we have this place token account. We have a token account. So the next thing that we need to do is now get all of the accounts that are needed for the Cthulhu instruction. And I guess, yeah, when you're following along, this isn't something that you just inherently know. You either need to look at the anchor idl or in my case I just looked at the seven seas program and took a look at all of the accounts that the Cthulhu instruction needs. So I'm just going to copy this.
00:34:34.848 - 00:34:39.804, Speaker A: From something that I prepared earlier.
00:34:40.384 - 00:35:04.480, Speaker B: Okay, so now that we have the required accounts, we need to actually create the instruction. So yeah, because we're not using anchor, we're going to have to like construct this manually, which some people may not be used to. And at the end also not, need not to forget to get the id for the seven seats program. So let's go and start creating this.
00:35:04.512 - 00:35:14.784, Speaker A: So we're going to return new transaction instruction and this is something that comes.
00:35:14.824 - 00:35:22.644, Speaker B: From the Solana web, three js and it's going to need a program id.
00:35:25.244 - 00:35:29.664, Speaker A: Which is the seven how do we write it here? Seventies program.
00:35:31.604 - 00:35:46.236, Speaker B: We're also going to need keys and these are basically the list of accounts that are needed and we also need to send in the data property as.
00:35:46.260 - 00:35:50.502, Speaker A: Well, which we'll do in a second.
00:35:50.678 - 00:36:07.114, Speaker B: So for the keys, this again the order actually matters. So this is following the order that the Cthulhu instruction on the program is expecting. So the first one is we're going to need the chest vault.
00:36:10.294 - 00:36:20.064, Speaker A: This is writable, is true and is signer is false.
00:36:22.284 - 00:36:25.460, Speaker B: The second account we need is the level.
00:36:25.652 - 00:36:41.224, Speaker A: So pub key is level, is writable, is true, and also the is signer is false.
00:36:44.774 - 00:36:47.954, Speaker B: The third account we need is the game actions.
00:36:53.814 - 00:37:01.234, Speaker A: Signer is false. Trading commas are okay, what next?
00:37:01.654 - 00:37:02.914, Speaker B: Next one is player.
00:37:08.074 - 00:37:27.694, Speaker A: This is writable, is true and this one does have to be a signer. Then we have the players token account. Oops.
00:37:32.234 - 00:37:36.914, Speaker B: You can see that intellisense and GitHub Copilot are just fighting for attention at the moment.
00:37:37.254 - 00:39:51.694, Speaker A: And it's a plays tokenaccount address is writable oh no, I've missed one here. So after player is actually the system program id dot program id, it's writable, of course it's false. Assigner also false. After system program we have the player, again is writable, is false, is signer, is false. Now we have the player token account. Players token, players token account address is writable, is true, is signer is false couple more accounts still needed. Pub key we have the token vault is writable, is true, is signer false? We have the token account owner PDA'd took an account on the PDA, so it's writable, is true, is signer, is false.
00:39:51.694 - 00:40:47.774, Speaker A: The gold token mint is writable, is false. Sino it's also false. We have the token program Id writeable, false sign is also false. This we need to import from SPL token. Then we have the associated token program id, which is also from the SPL token library, is writable, is false, is sign or is also false.
00:40:49.154 - 00:41:49.374, Speaker B: So now when it comes to the data, this is one to know what instruction in the program you want to call and then pass any particular data related to that instruction. And yeah, because we're using anchor, we need to like figure out what the anchor discriminator is and then pass in the whatever data that function is needed. So there's multiple ways to do this. There is a like a standardized way on how to get the anchored discriminator, considering that you know the function name that you're trying to call. But just for now I'm just going to use a more rudimentary way and because I actually have what the actual buffer needs to be. But at the end we'll do some refactoring and then you can see how to do this generally with anchor.
00:41:49.674 - 00:41:53.894, Speaker A: So I'm just going to copy from one we prepared earlier.
00:41:54.654 - 00:42:08.510, Speaker B: And there you have it. So with that you would have the actual instruction that you need to call the Cthulhu program. Some missing stuff that we need is just the seven C's program id, which.
00:42:08.542 - 00:42:33.040, Speaker A: Again I'm going to copy from what we prepared earlier. So up here we'll just say const seven cs program. That's not it. So now this should be quiet. So now we're almost there.
00:42:33.112 - 00:42:54.446, Speaker B: I think there's only one step that is missing, which is the actual prepare transaction function. Because now we have our created instruction that takes in the player, gets all of the necessary accounts, and actually constructs the transaction. Sorry, the instruction that we need. So now we can just go ahead.
00:42:54.510 - 00:42:57.794, Speaker A: And do the last part, the prepare transaction.
00:42:59.454 - 00:43:07.830, Speaker B: So this prepared transaction takes in an instruction and all it's going to do is just going to return the desired transaction for us.
00:43:08.022 - 00:43:11.194, Speaker A: So let's see what we need here.
00:43:11.894 - 00:43:13.046, Speaker B: So first thing that we're going to.
00:43:13.070 - 00:43:31.664, Speaker A: Do is we're going to create the transaction equals new transaction. This is from web3. Nope, this is from web3 js. And we're just going to use the add and add that Cthulhu instruction.
00:43:32.484 - 00:43:42.100, Speaker B: So we take the Cthulhu instruction, create a new transaction, add that particular instruction. Now we're just going to set some properties on that. So the first one is going to.
00:43:42.132 - 00:43:46.544, Speaker A: Be the recent block hash that we need.
00:43:49.014 - 00:43:50.102, Speaker B: Yes, this is going to have to.
00:43:50.118 - 00:44:15.094, Speaker A: Be an async function because we're going to need to use await. So we're going to await connection dot get, I think it's get latest blockhash, get latest block hash and we need the blockhash property on that.
00:44:15.714 - 00:44:20.214, Speaker B: And for the fee payer, we're just going to set this as the payer.
00:44:20.874 - 00:44:28.694, Speaker A: Because that's the, we have opted to pay for the transaction fee and because.
00:44:29.114 - 00:45:10.486, Speaker B: We have set ourselves as the, as the fee payer, we're going to need to partially sign this particular transaction because when you're the fee payer, so it's going to get deducted from your account and for any deduction to happen, you would actually need to sign to give authorization to do that. So we're going to do partial sign and we're going to sign as the payer. And what we need to do now, as mentioned is we just need to serialize and yeah, just serialize this transaction and return it as a base 64. So we're going to create a new.
00:45:10.510 - 00:45:16.078, Speaker A: Variable serialize transaction and we're going to.
00:45:16.126 - 00:45:19.990, Speaker B: Serialize it and we're just going to.
00:45:20.022 - 00:45:45.554, Speaker A: Set the verify signatures. We don't need to do that and require all signatures. Also going to be false. So just going to return serialize transaction to string base 64 and that's it.
00:45:45.974 - 00:46:27.212, Speaker B: So we have our transaction prepared. We create a new transaction, add the Cthulhu instruction, set the recent block hash, set the fee payer, partially sign this because we need to sign since we're setting ourselves as a fee payer, serialize the transaction and return it. So this should work. The only thing that you need to do is actually, we can just do that quickly. Just need to create your env file and have your payer set to your, your private key. And of course, I'm just not going.
00:46:27.228 - 00:46:29.024, Speaker A: To show this on screen.
00:46:30.444 - 00:46:50.560, Speaker B: So I'm just going to do that. So I've gone ahead and add my private key in the environment variable. So now we should actually have all of the building blocks required to scan our QR code and get the Cthulhu monster to fire. So I'm just going to set that up.
00:46:50.592 - 00:46:57.844, Speaker A: Let's go to the seven seas program so that we can actually see this working.
00:47:00.864 - 00:47:12.404, Speaker B: So there's a few ships here. So now I'm just going to go to my QR code, which I still have my Solana colon, my ng rocking API. I'm now going to scan this.
00:47:14.144 - 00:47:21.016, Speaker A: I'm going to open this up. So we should see this. So right now. Okay, so I got an error and.
00:47:21.040 - 00:47:23.936, Speaker B: When I got an error from my wallet. When I look, I can see our.
00:47:23.960 - 00:47:55.724, Speaker A: Server is responding with a get and a post. So something must be wrong with the post. So we just take a look again, see if we can spot anything. So a handle post is get. Okay, I can see that. Now, this handle post needs to be an async function because this is using async await. So we need to await this prepare transaction.
00:47:55.724 - 00:48:17.012, Speaker A: That's also an async function, so we need to await you. And that means also in here, we need to await. There we go. Save that. Now, if I go back to the QR code styling, I scan that QR code. We should be able to see that.
00:48:17.068 - 00:48:18.228, Speaker B: Yep, got that get request.
00:48:18.276 - 00:48:25.940, Speaker A: When I press allow, should now also see a post request come in, which we do. And now I have the option on.
00:48:25.972 - 00:48:28.460, Speaker B: My wallet UI to confirm the transaction.
00:48:28.492 - 00:48:32.460, Speaker A: And when I do that, I should see cool it fired.
00:48:32.612 - 00:49:00.604, Speaker B: So we can see that that works. And yeah, that's pretty much it. So we can respond to the get on the post request. And in the handle post we have this Cthulhu instruction. And that just has like the same instruction format as you normally would expect. There isn't anything unique to Solana pay here specifically. Yeah, so just return that instruction.
00:49:00.604 - 00:49:13.452, Speaker B: Then we have our prepare transaction. Just to add the recent block cash, add the fee payer, partially sign it, return it base 64 encoded, and boom, we have it.
00:49:13.468 - 00:49:14.116, Speaker A: All done.
00:49:14.260 - 00:49:50.300, Speaker B: So there you have it. It was quite simple to set up this Cthulhu instruction and have our server respond with it. And just to kind of reiterate that clearly, as we've seen today, Solano Pay can also be used outside of just pure payments. We've used it to create this kutula instruction and use that to interact with the seventies game. Thank you for joining and coding along with this workshop. The final code would be available on GitHub and also a text based walkthrough of this workshop. You can find all of that in the description.
00:49:50.300 - 00:49:51.844, Speaker B: And once again, thank you for joining.
