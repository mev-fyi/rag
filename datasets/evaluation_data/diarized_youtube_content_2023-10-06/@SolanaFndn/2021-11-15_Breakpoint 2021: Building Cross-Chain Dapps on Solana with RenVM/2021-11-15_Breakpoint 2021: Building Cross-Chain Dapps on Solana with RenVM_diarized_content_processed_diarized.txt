00:00:10.400 - 00:01:19.208, Speaker A: Yeah, hi, my name is Rohit and I am a developer at Ren. And yeah, over the last couple of years, we've built some amazing infrastructure, multi chain infrastructure for developers to bridge assets across chains. We initially started with bitcoin, bridging bitcoin to Ethereum as a one, as one representation called Ren BTC. And the most important functionality which RenVM provides you is that it is decentralized. There's no single authority that controls the key which holds your bitcoins or any assets. In the last one year, we tried to focus pretty much on building an abstraction over all these chains. And this abstraction is pretty cool over all these EVM chains which were popping up over the last year, including avalanche, Binance, smart chain, polygon.
00:01:19.208 - 00:02:15.804, Speaker A: And it was towards the end of last year that we started building on Solana. So you could bridge assets from bitcoin, zcash, or these Utxo chains to Solana. So, yeah, this is just an overview of how developers could think of RenVM. They could think of it just as a black box. And you do certain operations on one chain, and you tell RenvM that, oh, I've done this operation. And renvm validates this, whether you've done it right, whether there is some issues in that or not. And if all checks within Renvm are satisfied, then it gives you this kind of a signature which allows you to mint your assets on the host chain.
00:02:15.804 - 00:03:06.008, Speaker A: So after we launched on Solana, it was around five months ago, we've had close to $500 million worth of volume and the total value locked, which have been bridged to Solana. It's mostly BTC, but a lot of Luna and these tokens. The total value locked right now is close to $250 million. And the biggest mint amount was close to 29 bitcoin. So I'm just. Because this is a developer workshop, so I'm just going to take you through step by step. What do you do as a user to interact with RenvM or a developer? So you first interact with RenvM and get a gateway address.
00:03:06.008 - 00:04:14.338, Speaker A: This gateway address is sort of like a unique identifier for your transaction, so that Renvm knows what it's going to verify and who it wants to give the result to. And once you get this gateway address, you do your bitcoin transaction, send the bitcoin to this gateway address, and it's basically a script address which RenvM is able to pull funds from into its own wallet. Once you do your bitcoin transaction, you submit a RenvM transaction to Renvm. And this transaction includes fields like the transaction hash, the outpoint. And this is when you send this information to Renvm. RenvM waits for some confirmations for your transaction to be confirmed from Renvm's point of view. And once it verifies all of this data is true and that you've submitted your transaction, the transaction is complete.
00:04:14.338 - 00:05:06.274, Speaker A: There have been sufficient number of confirmations. Then it gives you a signature. This signature is a signature over the SeC P curve, which is the cryptographic curve used by Ethereum bitcoin for its cryptographic primitives. You use this signature to mint assets on the host chain or the target chain, be it Solana or Ethereum or polygon, whichever chain. So in this case, Solana, we have our Solana programs which are able to verify this signature. And if everything is verified, the SPL tokens are minted to your recipient address on Solana. Once you have these representations on Solana and you want them back on the original chain.
00:05:06.274 - 00:06:09.808, Speaker A: For example, you want to burn these ren BTC tokens back to bitcoin and back from renvmn and receive bitcoin. You burn those tokens and this creates a log on Solana, which is persistent log, saying that, oh, this is my burn nonce and this is the amount I've burned. And you send all of this data to renvm. And Renvm again validates whether this transaction happened. This burn log exists on Solana and it verifies the checks. For example, how many tokens you've burned, deducts some fees for NVM, and it releases those bitcoin back to the address that you really want them to, you want to receive them on bitcoin. There is a different burn functionality which we will soon have when we enable ERC 20 tokens coming from Ethereum to Solana.
00:06:09.808 - 00:06:45.604, Speaker A: So for example, you could have Ren Dai on Solana. And if you want to burn this Rendai, you burn those tokens. Tell Renvm that I have done this operation. Renvm gives you back a signature, giving you authority to release those funds from the Ethereum smart contract. And you can release those Rendai, because in this case, Renvm cannot release those assets directly to you, just in case of bitcoin. Because for bitcoin you need Utxo to release. But over here you need gas, and it's the user's operation.
00:06:45.604 - 00:07:35.824, Speaker A: So the user can take this signature and make a transaction on Ethereum to get back their locked die. So this is a little bit of code. Any developers here? Yeah, that's great. So Renjs is our JavaScript developer tooling. You can use ranjs to basically build, to bridge assets from between any chain to any chain. And we have built some functionality which allows you to specify which chain you want to use as the source chain, the chain you want to use as the destination chain. And a lot of stuff is done for you by the NJS library.
00:07:35.824 - 00:08:30.184, Speaker A: For example, the step which I mentioned before where you deposit your tokens and you deposit your bitcoin to the gateway address and then RenvM is waiting for the sufficient amount of confirmations. So you can see here is just some instantiation. And you see here the asset, let's say in this case is filecoin. You create an associated token account on Solana, which is the account which will hold your SPL tokens. When you mint and you create a lock and mint, you wait for NVM to give you a lock and mint gateway address. So when you say lock and mint, it's lock my bitcoin and allow me to mint it on Solana in the form of RenBTC. So lock and mint accepts these parameters.
00:08:30.184 - 00:09:25.608, Speaker A: What asset you're trying to bridge, from which chain you're trying to bridge this asset and to which chain this asset goes to. So here, in this case it's filecoin. From filecoin then vm network is, you specify which network you are dealing with. Is it testnet or mainnet or something? And going to Solana. And this gateway allows you to watch for events, for example like on deposit, when the deposit is confirmed. So you could see we create a new promise, and as soon as the gateway receives the deposit, it fires this event for you and you can see whether it's confirmed. I've just put some dummy code there, so not to do a lot of stuff there.
00:09:25.608 - 00:10:17.514, Speaker A: But once this deposit is confirmed, you can then await Renvm to give you a signature on that. Once you have it signed, you have a TX hash, which is the transaction hash for RenvM. It's not a bitcoin or Solana transaction hash, but it's the RenvM specific transaction hash, and it gives you a status whether, you know, according to Renvm it's successful or not. And once you have the signature, you can just await deposit mint. And this should give you a transaction hash, which is a Solana transaction hash for the tokens which will be minted to you on Solana. So a basic, the most basic JavaScript integration is as simple as this. You could obviously do a lot of stuff.
00:10:17.514 - 00:11:01.234, Speaker A: A lot of other checks on your front end, depending on what you wish to display or what you wish to do when the deposit is confirmed, or whether it's signed or not, handle failures. You can do all of that. But this is the most basic. And yeah, I think we've been able to abstract over the chains and assets so well that it's less than 20 lines of code just to bridge assets. So on the Solana side, we have two main instructions in our program. One is the mint and one is the burn. This is just the interface for both those instructions.
00:11:01.234 - 00:11:41.520, Speaker A: We make use of program derived addresses. You'll see it everywhere in our Solana implementations, because the token itself, the token mint itself is a program derived address, depending on which gateway you are interacting with. So whether it's the bitcoin gateway or whether it's the filecoin gateway or something like that, and including the mint log. So the mint log is to persist. Signatures, for example. We don't want someone to reuse those signatures and mint assets again. So it's that.
00:11:41.520 - 00:12:32.864, Speaker A: And you have the burn instruction. The burn instruction is to burn your SPL tokens and create a burn log on Solana. I'll just go into a basic rust integration test for people who want to build backend logic with Renvm. So this is an example for burning tokens on Solana using RenvM. So you specify the burn amount, and you specify the recipient of those assets on the original, the source chain, for example, you specify bytes encoded bitcoin address. Or you could specify a filecoin address where you want to receive file coins. In this case, it's bitcoin.
00:12:32.864 - 00:13:10.550, Speaker A: And you can see the burn log is a program derived address, depending on the nonce of your burn. Using this, then we create a burn transaction. And the burn transaction consists of two instructions. The first instruction is the SPL tokens burn instruction, and our gateway verifies whether you've burned those tokens with the correct program, the amount. And we get all of this information from that instruction. Yeah, that's it. It's as simple as this.
00:13:10.550 - 00:14:17.350, Speaker A: You create this burn transaction, you sign it, and you process the transaction. This is the basic rust integration for RenVM. We are also, at the moment we don't support Solana as the source chain, but in a couple of months we'll be ready with that as well. So you could mint Ren Sol on Ethereum, something like that, or on an EVM chain. And l two, yeah, and the reason why we couldn't do it, as of now, is because Solana uses different cryptographic primitives and renvm, being a decentralized custodian, all the nodes participate in an SMPC protocol to produce the signature which you need to mint those assets. And those nodes, at the moment, they participate in an SMPC protocol, which produces a signature on the SECP curve, which Solana doesn't use. Solana uses the Edwards curve.
00:14:17.350 - 00:14:51.766, Speaker A: So the way we are going to implement it is something similar to what we did for ERC 20 tokens. So you lock your assets with the program on Solana, and to release those assets at the time of burning, you need to verify your SEcPI signature on Solana. Something like that. So we'll have it in a couple of months? We are still working on that, yeah, that's the end of the workshop. Any questions from developers here?
00:14:51.940 - 00:14:56.854, Speaker B: If there are questions, I can come around with the microphone. I know everybody loves to talk into a microphone.
00:15:00.394 - 00:15:08.530, Speaker A: Okay. Hi.
00:15:08.562 - 00:15:19.134, Speaker C: You said the tokens are locked for a period of time. So what's, like, the time normally expected? Like, is it a few milliseconds or 100 milliseconds, or is it a longer time, the verification time?
00:15:20.704 - 00:16:02.714, Speaker A: It depends from chain to chain. For example, on bitcoin, we wait for six confirmations because it's a proof of work chain, we wait for six confirmations. So for bitcoin, it's about an hour before RenVM declares it as the truth for us. But for Solana, 30 block confirmations is finality. And as, because it's not proof of work. So you could say something like less than a minute. So in less than a minute, this transaction will be assumed as confirmed from RenVM's perspective.
00:16:02.714 - 00:16:06.314, Speaker A: So it depends from asset to asset and chain to chain.
00:16:08.014 - 00:16:09.622, Speaker C: Yeah, there's many interests in Solana.
00:16:09.718 - 00:16:11.874, Speaker A: Yeah, it's pretty quick. Yeah.
00:16:13.124 - 00:16:15.744, Speaker B: Any other questions while I'm here?
00:16:20.364 - 00:16:38.384, Speaker D: Hi. For the mint and burn interface, you need to provide the program id for all the different chains you want to reference. Do you have a centralized place where you can find a list of all the program ids?
00:16:39.524 - 00:17:24.274, Speaker A: So, the program id depends on which gateway you're interacting with, which asset that gateway is meant to serve. So we have a different gateway for bitcoin, we have a different gateway for filecoin, etcetera. And at the moment, we have not published this crate because we are working on some documentation. Once that documentation is complete, we'll be publishing this crate for different networks. So you'll get to use this. You'll get to import this crate within your source code, and you can access the gateway for a particular asset on whether it's Devnet or Testnet or mainnet. So you can get those addresses from there.
00:17:26.494 - 00:17:35.734, Speaker B: All right, we probably have time for one more. If anybody's got one by the time I get to this stage, that will be done.
00:17:36.194 - 00:17:43.934, Speaker C: Okay, just a simple question. Do you guys have plans to like, incorporate all ERC 20 tokens?
00:17:45.514 - 00:18:32.890, Speaker A: So the protocol itself is permissionless and it's pretty easy for us to add a token or to support a token, but we are doing it based on the volumes of those tokens. So whether a token has sufficient volume so that we could, because RenVM collects fees for each of these burns and mints, etcetera. So, yeah, it depends on the volume. When we launch host to host, which is already on the testnet now, probably in a couple of weeks or something, we'll have it. On Mainnet. We have a lot of stable coins like Dai, USDC. We have magic Internet money.
00:18:32.890 - 00:18:49.554, Speaker A: We have some tokens like FTT, I think around ten to 15, maybe 15 to 20 tokens. But yeah, eventually, if the token has enough volume, the users want it to be bridged between chains. We could add it within a day.
00:18:49.894 - 00:18:53.874, Speaker B: Well, now I have a follow up. What is sufficient volume look like then?
00:18:55.854 - 00:19:27.474, Speaker A: It's relative because volumes keep going up or down. At the moment, we are trying to choose the 15 to 20 top volume tokens which people are looking to integrate with cross chain ecosystems. For example, Solana. People are looking for the magic Internet money on Solana, be it native or be it bridged from Ethereum. So that's something which is important to us, whether it will receive adoption or not.
00:19:28.814 - 00:19:31.726, Speaker B: All right, great. Thank you so much, Rohit. That was awesome.
00:19:31.750 - 00:19:32.574, Speaker A: Thank you. Thanks.
