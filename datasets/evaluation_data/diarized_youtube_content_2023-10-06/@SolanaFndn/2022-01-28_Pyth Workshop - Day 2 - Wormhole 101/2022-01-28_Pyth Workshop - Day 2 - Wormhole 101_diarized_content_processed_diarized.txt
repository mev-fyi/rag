00:00:10.200 - 00:00:34.370, Speaker A: My name is Evan Gray. I'm one of the core contributors to Wormhole project. I'm here to give you a little overview 101 on Wormhole and building the Internet of blockchains. So we're going to go over the five w's and one h of wormhole, as well as a quick little demo.
00:00:34.402 - 00:00:36.778, Speaker B: And then I'll take questions at the end.
00:00:36.826 - 00:00:40.146, Speaker A: So try to breeze through this and.
00:00:40.170 - 00:00:42.890, Speaker B: Just hit the key high levels.
00:00:42.922 - 00:01:36.322, Speaker A: So let's start with what is wormhole? Wormhole is a fully generic cross chain messaging protocol that connects to multiple chains. So right now, as of today, I think missing from this slide, we have Ethereum, Solana, Tera, Binance, smart chain, polygon, avalanche, and Oasis. Hopefully several more chains coming over the next couple months here. Wormhole originally started as a bi directional token bridge between Ethereum and Solana. So what we call wormhole v two. The current iteration was a redesign of that version one protocol to allow for generic message passing. So to be able to pass any kind of information between these connected chains, both one to one.
00:01:36.322 - 00:01:43.104, Speaker A: So like trying to transfer a token between one chain to another chain and one to end messaging.
00:01:43.234 - 00:01:46.084, Speaker C: So say, like broadcasting piss prices from.
00:01:46.124 - 00:01:49.572, Speaker A: Solana to all other connected chains, and.
00:01:49.588 - 00:01:52.384, Speaker B: We'Ll talk a little more about how that might work in the future.
00:01:53.004 - 00:02:40.564, Speaker A: We're also looking at a bunch of different applications building on top, such as governance boats, cross chain staking, atomic swaps, cross chain lending, all kinds of fun things. So like I said originally, the one bi directional token bridge just between Ethan Solana, we took the core concepts that we use there. We already had all the pieces to pass, just tokens, which is a subset of just passing data. So we re architected. Now we have what we refer to as the core layer. So this is just generic message passing, how that works. And then we build applications on top of that, as well as other integrators build on top of that.
00:02:40.564 - 00:02:56.420, Speaker A: So the two that we've built so far that are out in the world is the token bridge and the NFT bridge. So the token bridge right now supports all those changes I mentioned. The NFT supports everything but Terra, which.
00:02:56.452 - 00:02:57.704, Speaker B: Is coming very soon.
00:02:58.604 - 00:03:48.944, Speaker A: We also launched a JavaScript SDK, and like I said, as all those other chains, Oasis being the most recent one to join our supported networks, we're working now to add a rust SDK to help with on chain development on Solana and Terra, as well as, like I mentioned, the NFT bridge and some payload support for token bridge transfers. So one of the most requested features that we've seen is folks want to transmit both value and data. So think about staking cross chain. So I have tokens on chain a, but I want to put them directly into a protocol on chain b. How do I send the tokens and the instructions that I of what I want to do in one wormhole message? So that's what we're working on extending.
00:03:48.984 - 00:03:50.324, Speaker B: The token bridge to do.
00:03:50.744 - 00:03:54.712, Speaker A: As always, you can stay appraised of all the stuff we got going on. You can join the discord.
00:03:54.768 - 00:03:55.560, Speaker B: Follow us on Twitter.
00:03:55.592 - 00:04:06.204, Speaker A: Those are our two probably primary ones. Just a few metrics about wormhole. So these stats are from a couple weeks ago, but we've had.
00:04:09.744 - 00:04:10.680, Speaker B: I guess.
00:04:10.872 - 00:04:57.264, Speaker A: A lot of money transferred. So almost 4 billion now bridged through wormhole. We have a TVL, which is total value locked of over a billion dollars notional, and we've processed hundreds of thousands of messages. Soon we'll see that skyrocket even more as some protocols add message passing and data attestation. So when we talk about the who of wormhole, so I mentioned I'm a core contributor as well as some other folks from jump crypto. We have folks in the community and from other chains that contribute as well. So one example is those folks from Algorand that are working on adding support.
00:04:57.264 - 00:05:23.440, Speaker A: There's help from Terra, all these connected chains, as well as protocol as other chains when they want to add features, say to the SDK, we see contributions there. Then we have these 19 guardians. So the 19 guardians help secure the network by watching nodes of each of the connected chains and confirming the validation.
00:05:23.472 - 00:05:25.284, Speaker B: Of transactions that occur there.
00:05:26.024 - 00:06:35.420, Speaker A: Everyone always asks me, who are the 19 guardians? So to just cut that out, I listed them here on the slide. We have two community managers that help out on Discord, Telegram, Twitter, and reply to the community. So wormhole does have a public facing Tokenbridge as well as NFT bridge. So we have a lot of folks that reach out for support there as they're bridging to new chains, need help with their wallets or understanding addresses and things like that. So not only that support, but also handling incoming requests of folks that want to integrate and help them find partners or people to assist with what might be new chain developments. I'm sure if y'all work with PIF on Solana, you know, that it can be, you know, challenging and a lot of work, especially as we have folks that are coming from, you know, either other ecosystems entirely. There's essentially three networks that we work with.
00:06:35.420 - 00:07:10.664, Speaker A: The wormhole. When we say mainnet we're referring to, there's 19 guardians, Solana, Ethereum, Terra BSc, Polygon, Avalanche, Oasis. We also have a testnet deployment that's secured by just one guardian and it connects to Solana Devnet as well as a couple of different of the Ethereum testnets and all those other chains. The goal is that as we add support for new networks, we get them added in Testnet first, get to try them out, get to allow integrators to try them out. And then we have a pretty bulky devnet that lets us develop wormhole and.
00:07:10.704 - 00:07:12.204, Speaker B: Try all these things out.
00:07:15.704 - 00:07:40.844, Speaker A: So biggest question, how does wormhole actually work? So I briefly went over the fact that we have this core layer of how we pass messages across chains. Then we have guardians, Va's application layer and go over each of these as well as an example token bridge interaction. And then I'll actually do a quick.
00:07:40.884 - 00:07:42.344, Speaker B: Demo of token bridge.
00:07:44.204 - 00:08:29.004, Speaker A: So first off, the core layer. So contracts are coded for each chain and deployed across all the supported chains. So when we say we've connected all these chains, it means that we've deployed a core layer contract on all seven of those. And this provides three pieces of functionality. So the core contract can publish messages which logs information on that chain that the Guardians can watch for. They can verify messages that checks that two thirds plus majority of the guardians have signed and then they can execute governance. So we might have guardian sets change.
00:08:29.004 - 00:09:13.252, Speaker A: As you know, if a guardian decides to leave or we onboard a new guardian or re expand the Guardian set, we need to have a way for the core contracts on each chain to know what the current guardian set is and update that. And they do that via governance. So all the guardians agree to perform an action and they'll by signing all these messages and two thirds majority, we can submit that and upgrade the contracts. So what do the Guardians do? Well they're running each of these nodes. So every guardian is running a node for each of the supported chains and that allows them to firsthand witness transactions.
00:09:13.308 - 00:09:14.804, Speaker B: That occur on those nodes.
00:09:14.964 - 00:10:17.574, Speaker A: So they're watching each of those four contracts for transactions that involve them to watch the logs that they emit. So when someone's developing, say on top of Ethereum, they can write in their contract to cross call to wormhole and say I want to emit this data, whatever it is. So in a PIF example it might be hey, I want to emit this PIF price based on the one of the price contracts. So they would call the core bridge say I want to publish this message. The guardians are all watching for that log from the transaction that involves the core contract. They wait for a specified consistency level. So in the case of the token bridge on Ethereum, we wait 15 blocks to confirm that we're pretty certain the block won't get rolled back.
00:10:17.574 - 00:10:53.810, Speaker A: On Solana, that would be like 32 slots are where finalization is reached on Solana. So we don't want to perform any action on another chain based on that data. Before we see that specified number of blocks, we want to make sure that you can't hand the token bridge money and then it gets rolled back. So this is where the Guardians are waiting for that specified number of blocks to pass. Only then do they sign the message. Now, all 19 do this process independently, and then they gossip over a peer to peer network to share the fact.
00:10:53.842 - 00:10:56.570, Speaker B: That they've signed, and then they expose.
00:10:56.642 - 00:11:17.530, Speaker A: An endpoint so that anyone can go to one of the Guardians and request a signed VAA. So when you do a transaction, you get a sequence number back. You can think of that like your ticket, and you hand that back in to receive this signed message that has, you know, the 19 signatures on it. You can retrieve that signed message once.
00:11:17.562 - 00:11:19.254, Speaker B: You reach two thirds majority.
00:11:22.114 - 00:11:52.640, Speaker A: So, vaas, I never remember what it stands for. It's a verifiable action approval, but we just call them Vaas everywhere, pretty much. It includes this information about where the transaction took place, where that message was logged from. So it's got a timestamp, the emitter chain, the emitter address sequence number, which is a unique, incrementing number, and that consistency level we talked about, and then a payload. And that's what gets signed by each.
00:11:52.672 - 00:11:54.324, Speaker B: Guardian with their private key.
00:11:58.044 - 00:12:01.580, Speaker A: So what actually happens when a message.
00:12:01.612 - 00:12:02.972, Speaker B: Is sent over wormhole?
00:12:02.988 - 00:12:18.012, Speaker A: We can take a quick look at the lifetime here. A message is admitted by a contract on a given chain. So any contract can call to the core bridge and have their message omitted. And the guardians are all set up.
00:12:18.028 - 00:12:20.820, Speaker B: To walk to these core contracts.
00:12:21.012 - 00:12:35.234, Speaker A: So once they witness and wait for those confirmations, signatures are aggregated and guardians independently observe and sign like we talked about. And once we reach to those majority.
00:12:35.274 - 00:12:37.374, Speaker B: Becomes available for folks to query.
00:12:39.914 - 00:13:17.244, Speaker A: Then the key point here is that guardians just make that message available. They make that vaa available to folks. They don't actually post it onto another chain. So in the case of a token bridge transfer, someone transfers money, locks it in the bridge. The guardians witness that getting locked and the corresponding message. They will then provide a VAA that's like, think of them like a decentralized notary, right? They're just notarizing that. Yes, I saw this message happen.
00:13:17.244 - 00:14:19.304, Speaker A: Then it's up to the user or process that we call a relayer to actually submit that to the destination chain. That essentially covers how the core layer works. Like I said, just kind of roll through these take questions at the end. So the application layer is any contract that we build on top of this core layer, that we build on top to communicate via wormhole messages. So they'll leverage the core layer to publish and verify messages. They don't have to worry about validating that 19 guardian sign, that they don't have to worry about how to observe these messages cross chain. All they need to know is that they can published data, that everything else will happen for them, and then they can accept and do their own validation on whatever payload they describe.
00:14:19.304 - 00:15:22.364, Speaker A: So if we take a look at what a token bridge transfer looks like, this is another series of contracts that we wrote and deployed on all those chains. And it pretty much allows for a handful of functions that, the key of which are transferring tokens and completing a transfer. So we could think of transferring tokens as blocking native tokens and then publishing a message that essentially says user a lock these tokens, they're trying to send it to this other chain, to this other wallet. Then once we receive that message, we call verify to complete, or we call complete transfer to complete it on the other chain. So this would verify the signatures, make sure that it, you know, received two thirds majority of guardian signatures. That's done via the core layer. And then they can validate that it came from a legitimate token bridge on the other chain and that it wasn't already submitted to avoid double expense.
00:15:22.864 - 00:15:26.448, Speaker B: And the payload looks like I've detailed down here at the bottom.
00:15:26.616 - 00:16:21.114, Speaker A: So it has the amount you're trying to transfer, token address, token chain, the where you're, who you're trying to send to on the destination chain, what chain that is, and then a fee that can be paid. So if we had a user named Josh who's going to Tokenbridge trying to send 100, we Josh is very rich, but it's testnetweast. They go to warmholebridge.com and say, make a transaction to Ethereum. So this whole process that we've been going over pretty much looks like this for almost any use case. So a user submits to Ethereum, if they're trying to go from Ethereum to Polygon, in this example, they submit to Ethereum, I want to transfer via the token bridge. It would lock 100 wheat for them and produce a wormhole message.
00:16:21.114 - 00:16:58.574, Speaker A: That message is observed by the Guardians. The Guardians wait those confirmations. In this case, it'd be 15 confirmations. And then sign a VAA and gossip to all the other 19 guardians once it's accumulated enough signatures. In this case, Josh, using wormholebridge.com, will get that signed VaA back from the Guardians and that's their ticket from the decentralized notary rights. Their ticket that will let them go to the destination chain and exchange it for wormhole wrap tokens on the other side.
00:16:58.574 - 00:17:17.160, Speaker A: So they then submit that to polygon, which takes to the token bridge contract which will cross call to the core layer to verify the signatures, validate that this hasn't already been redeemed, and then.
00:17:17.272 - 00:17:20.004, Speaker B: Mint the wormhole rap tokens on the other side.
00:17:22.464 - 00:17:52.926, Speaker A: One keynote is that in this example, Josh here needed to have funds on Ethereum to submit the transaction in the first place. But they also need to have funds on polygon. So if they're trying to go from Ethereum to Polygon, the guardians don't submit the transaction on a user's behalf. Right? The user would need to have funds on the target chain to be able.
00:17:52.950 - 00:17:54.914, Speaker B: To submit their transaction.
00:17:56.534 - 00:17:58.118, Speaker A: So I'm going to pause here for.
00:17:58.166 - 00:18:01.194, Speaker B: 1 second and share.
00:18:03.374 - 00:18:04.062, Speaker A: A screen so.
00:18:04.078 - 00:18:06.114, Speaker B: I can show a quick example of this.
00:18:15.114 - 00:19:11.214, Speaker A: All right, so here I've got the wormhole bridge app connected to Testnet and I have a couple wallets connected. In this case I'm going to send USD from terra over to Solana. So I'll connect my terra wallet and I'm testnetrich over here, so, but I'm frugal. I'm just going to send $0.25 over from Terra to Solana. Here I specify my target wallet, so I connect my phantom wallet. In this case, I already had it connected and this tells me that I'll receive the wormhole wrapped UST token on the other side and it'll be sent to my associated token account where I already have 3.25
00:19:11.214 - 00:19:26.474, Speaker A: USD. I get a little warning that I'm going to need to pay transaction fees on Solana. Here I can pick my fee, denomination, I'll pay in Luna, that's fine.
00:19:28.174 - 00:19:29.474, Speaker B: And I'll transfer.
00:19:32.514 - 00:19:55.546, Speaker A: So this is about to be that first part of the diagram I showed where we're going to submit to the source chain that hey, I want to lock up 0.25 tera and I want to Luna, sorry, 0.25 UST on Terra and result in 0.25 wormhole wrapped UST.
00:19:55.610 - 00:20:02.486, Speaker B: On Solana get a pop up from.
00:20:02.510 - 00:20:44.786, Speaker A: My wallet to approve. I can check out that this is going to deposit the tokens and initiate a transfer. This will happen pretty fast, but in this time I'm waiting for the transaction to occur and right immediately afterwards it gets confirmation from the single guardian on testnet that it's seen this transaction and I get my signed VAA. So that all happened in one step pretty fast in the middle there, because Terra offers instant finality. If we go back the other way, we'll see it take 32 slots to.
00:20:44.810 - 00:20:46.094, Speaker B: Confirm on so on.
00:20:46.954 - 00:20:56.756, Speaker A: So now I'm waiting at this fourth step, which is the end of that diagram I showed where you in order to redeem the tokens, I have to submit that signed VAA to the corresponding.
00:20:56.780 - 00:20:58.020, Speaker B: Side of the token bridge.
00:20:58.172 - 00:21:03.344, Speaker A: So I'll go on Solana, redeem my tokens, and.
00:21:07.204 - 00:21:16.104, Speaker B: Shawana takes a few transactions to submit due to the instruction size limitation here.
00:21:17.144 - 00:21:58.140, Speaker A: But on this third one, it's going to take my soul and give me ust. So I have to pay that transaction fee myself. But if we go view on Explorer, I submitted that signed VAA and got my 0.25 wormhole wrapped ust up. That's a very quick demo of pretty much how the workflow works. Regardless of how you're trying to send and exchange messages, more or less, that.
00:21:58.172 - 00:22:00.064, Speaker B: Process will always be followed.
00:22:11.264 - 00:22:48.550, Speaker A: So we talked about one challenge there is that the user needs to have destination fees. You could also think that you might have some automated processes that want to publish information and relay them to other chains, publish prices on other chains for PIF, for example, and you don't necessarily have the fees to pay on those other chains, right? So you want some mechanism that could.
00:22:48.622 - 00:22:50.910, Speaker C: Be watching for these transactions to occur.
00:22:51.022 - 00:22:58.054, Speaker A: And publish them on the target chain, and that's what we call a relayer. So far, we've been working on two different approaches for relaying.
00:22:58.214 - 00:22:59.054, Speaker C: One is rest.
00:22:59.134 - 00:23:43.704, Speaker A: So a designated service that's stood up that you can ping and say, hey, I have a VAA to redeem. Like, can you go do it for me? I'll give you this fee and then spy, which is a relayer that sits on the gossip network so that when the guardians are all gossiping to each other, that hey, we've all signed this transaction, this message that they can receive those as well and submit them to target chains. So something we've been working on is helping out the PIF team for attesting.
00:23:43.744 - 00:23:45.424, Speaker B: Pith prices to other chains.
00:23:45.584 - 00:24:37.884, Speaker A: So say, taking these pith prices that are aggregated on Solana, batching them and sending them to a contract on Terra. And the goal is that it looks something a little like this. You'd have an attester that runs and hits Solana to say, okay, there's a PIF to wormhole contract on Solana. It knows how to package up prices and send a wormhole message. So it goes to the core layer, sends a message that includes all the data that Terra folks would want to know about. A fifth price message would be observed, confirmed, signed and gossiped by the guardians. And anyone could run a process, this spiralayer, that will see when the PIF price reaches consensus in the Guardian network.
00:24:37.884 - 00:25:43.546, Speaker A: That relayer can then publish that price to Terra. The advantages here are that you have a trustless intermediary who confirms that, yep, the right contract published this message. The guardians all confirmed that it came from that contract on Solana, right? That it was a legitimate transaction. Then on the terror contract can say, okay, yes, this came from the right source, you know, it's valid, it was signed by all the guardians. And that in this example for PIF, that the price has to increment so that we only accept newer prices on the other chain, and then can update that price on chain, so that folks that are writing smart contracts on Terra only receive newer PIF prices, and they can refer to that contract to get a price that's attested and in a trustworthy fashion directly derived from the on.
00:25:43.570 - 00:25:44.974, Speaker B: Chain data on Solana.
00:25:50.994 - 00:26:31.308, Speaker A: We have some demos if you are interested in learning more about wormhole. You can check out our docs or look at our GitHub. This is pretty much the most of the presentation I had on to spare the overly technical and code deep dive here. Give you all some time to ask questions. We're partnering with a bunch of folks to add support and to add especially support for wormhole wrapped assets around various ecosystems. So, been working with Solana and Terra to stand this up. We'll be replacing the shuttle bridge, hiring a lot of cross chain development there.
00:26:31.308 - 00:27:30.868, Speaker A: So working with the anchor team there at Terra FTX will be replacing solid bridge with the wormhole token bridge. That's super exciting. Working with Acala and Karura to get Wormhole live there as they launch their EVM compatible layer. We have a bunch of projects building on top of wormhole. So we have some folks working on governance actions on cross chain liquidity, cross chain nfts, stablecoin, lending, borrowing, spending, obviously working with PIF to make prices available on other chains. And just a little blurb for when you're developing with wormhole. One of these benefits that we see is that you get to work on a protocol first design, develop in a chain agnostic way, and leverage the strengths of each chain.
00:27:30.868 - 00:27:48.744, Speaker A: So, for example, here we see that with PIF, right, it gets to run on Solana with the fastest chain of all these connected chains, and then still relay that data in a trustworthy fashion to every other connected chain. So you get the same security and assurances and speed.
00:27:49.244 - 00:27:51.060, Speaker C: But yet, if you're a protocol trying.
00:27:51.092 - 00:28:12.404, Speaker A: To develop on terra or on Polygon, because that's what you feel is going to be more popular for what you do, you can still rely on the data of another protocol on a totally different connected chain. Here's my quick wormhole stats page, and I'll leave this up while I take questions.
00:28:12.444 - 00:28:15.412, Speaker B: That's my super fast overview.
00:28:15.508 - 00:28:17.544, Speaker A: Switched into as much time as I can.
00:28:24.664 - 00:28:25.064, Speaker B: Cool.
00:28:25.104 - 00:28:27.416, Speaker A: I'll take it as either, you know.
00:28:27.600 - 00:28:28.416, Speaker D: Can you hear me?
00:28:28.440 - 00:28:31.232, Speaker A: Super straightforward. Oh, yeah, go ahead.
00:28:31.328 - 00:28:31.672, Speaker E: Nice.
00:28:31.728 - 00:28:58.162, Speaker C: So we actually talked a little bit over telegram, but could you go over the transaction three types a little bit with the payload? Yes. Thanks. Yeah, so we have a feature that we're dubbing going to payload three for now, or contract controlled transfers. The idea there is like we walk through a token bridge transaction from the perspective of an end user, right? So there, they're just trying to send.
00:28:58.178 - 00:29:02.826, Speaker A: Their token to crosschain. But if you step back and you think of it as a protocol, as.
00:29:02.850 - 00:29:15.394, Speaker C: An integrator, you might want to do a token transfer. So say, send your wheat from Ethereum to Solana, but you actually want to.
00:29:16.294 - 00:29:19.182, Speaker A: Yield farm it on Solana, and you.
00:29:19.198 - 00:29:30.114, Speaker C: Don'T want to have to go to Solana and receive the other side of the token bridge transfer, and then go to a totally different app and then.
00:29:31.014 - 00:29:33.634, Speaker A: Perform whatever yield farming or staking there.
00:29:34.374 - 00:30:04.088, Speaker C: You'd prefer as a protocol to just write something that can perform a token transfer on Ethereum, take the weif, send it directly to a contract on Solana, and then have that contract receive the funds and perform a predetermined asset, a predetermined action. So payload three is essentially a token bridge transfer that has an extra payload.
00:30:04.236 - 00:30:34.414, Speaker A: An arbitrary payload at the end of it. And the way that it's different is with a regular token transfer, anyone can redeem that token transfer because it's already designated in the transfer that if I make it and I say I wanted to go to my wallet on Ethereum, my wallet address is encoded in that transfer. So anyone can redeem it. The money's going to go to me. But in this case I had an action I wanted to perform on a contract on the other chain.
00:30:34.754 - 00:30:36.634, Speaker C: So the difference here is that instead.
00:30:36.674 - 00:30:42.202, Speaker A: The two field goes to a contract and only that contract is allowed to.
00:30:42.338 - 00:30:44.530, Speaker B: Redeem the tokens from the token bridge.
00:30:44.642 - 00:30:51.170, Speaker A: So anyone can call that contract, but we ensure in the token bridge that the caller to the token bridge is.
00:30:51.242 - 00:30:54.574, Speaker B: Only the contract specified in the to field.
00:30:55.554 - 00:30:59.714, Speaker A: Does that make sense? Kind of get behind the motivation there.
00:31:09.614 - 00:31:27.786, Speaker D: Question about the guardians. So are the guardians essentially clients for each chain that are either polling or I guess somehow observing the state? Yeah, but they, they're basically clients for each chain, right? Is that, is that accurate or.
00:31:27.930 - 00:31:34.762, Speaker C: Yeah, they're not, they're non validating nodes. So yeah, they run nodes for each of the chains. So it would be like Solana node.
00:31:34.778 - 00:31:36.574, Speaker A: And Ethereum node, a polygon node.
00:31:36.874 - 00:32:06.142, Speaker C: They don't need to be validating, but what they do is observe all transactions involving the core layer contracts. And the Guardian software currently is an additional piece of code written in go that observes the logs of each of these connected chains. So they have to provide to that contract to that code how pretty much the websocket endpoints for each of the.
00:32:06.158 - 00:32:09.022, Speaker A: Chains that they're running and that's how.
00:32:09.038 - 00:32:12.794, Speaker C: They observe every transaction that's happening involving that.
00:32:16.434 - 00:32:34.974, Speaker E: Just wondering about if an adversarial attack can happen when some guardians decide to broadcast bad messages. I don't know. Can you go through how you prevent this or.
00:32:35.274 - 00:32:37.774, Speaker A: Sure, yeah, yeah.
00:32:38.634 - 00:32:56.874, Speaker C: So what the core layer contracts assure on every chain. So when you receive a VAA as an integrator, when the token bridge receives the VAA, the first step that it takes is handing that message to the core layer contracts where they have registered.
00:32:57.694 - 00:33:00.486, Speaker A: The 19 public keys for the guardians.
00:33:00.670 - 00:33:12.296, Speaker C: And so what they assure, or what the core layer contracts assure is that the signatures on the message you passed in have to match the signatures that.
00:33:12.320 - 00:33:14.084, Speaker A: They have in the current guardian set.
00:33:15.584 - 00:33:33.342, Speaker C: So part of the VAA says what Guardian set it was signed with. So in this case we're on set one. It's got to be the signatures from those 19 guardians that I listed. So even if like five guardians wanted to collude and sign some bad message.
00:33:33.448 - 00:33:35.226, Speaker A: There'D only be five signatures on it.
00:33:35.330 - 00:33:40.642, Speaker C: And that second part is it validates that there are two thirds plus majority.
00:33:40.778 - 00:33:44.906, Speaker A: So you would need 13 of the 19 companies right now to collude in.
00:33:44.930 - 00:33:48.134, Speaker B: Order to broadcast a bad message.
00:33:48.954 - 00:34:00.366, Speaker A: In the future, we'll add, you know, there will be, let's say, more protections. We'll look at expanding the guardian set and some mechanisms for, say, punishing bad.
00:34:00.390 - 00:34:02.274, Speaker B: Behavior, downtime, things like that.
00:34:07.254 - 00:34:07.814, Speaker A: All right, thank you.
