00:00:09.120 - 00:00:52.186, Speaker A: Hello and welcome to our day six of our pirate bootcamp tutorial. Today we're going to talk about clockwork threads, randomness and zero copy. And then in the end we will have a little sea battle on the seven Seas program. So we will start with turning on the wind on the seven seas. I will show you in a bit what that means. Then we will learn about clockwork threads and how you can trigger transactions automatically from in the distance on certain triggers. Then we gonna dive a bit into randomness on chain, how you can achieve randomness with different values, different functions, and how you can use switchboard oracle to get a more secure randomness as well.
00:00:52.186 - 00:01:27.764, Speaker A: Then we're gonna look at big accounts, especially zero copy with anchor. Yeah. And then we have a little sea battle. Okay, but the first thing we gotta do is we gonna turn on the wind on the seven seas. So in the last days you were able to get some to stake your gold and swap your gold for some cannons. So your ship should already be very well equipped now. And now if we deploy our ship here, let's pick an avatar, let's use this one and we deploy our ship.
00:01:27.764 - 00:02:16.624, Speaker A: This is not on definite, so let me quickly switch to definite. Okay, and now let's try again. So now we have our ship deployed here and you can also see the little NFT in here. And now what I want to show you is that when we here resume the wind, then magically, suddenly all the ships on the map are moving automatically. And this is done by using a clockwork thread which in the background every 2 seconds goes through all the chips on the map and moves them by one field forward in the current look direction. And yeah, now I gonna show you how this is done. And I can also pause the wind again.
00:02:16.624 - 00:03:05.384, Speaker A: So now all the ships are stopped again and yeah, how does this work? Clockwork threads. So how clockwork works is you create a thread and this thread will call a certain instruction on your program over and over again depending on certain triggers. And clockwork does it like this. They have a worker network which listens for these triggers. And whenever the trigger time is due, then it calls the, like one of the workers calls your transaction and the fees are taken from the thread. So every instruction actually costs you 1000 lampards. And these are the different ways how you can trigger the threads.
00:03:05.384 - 00:03:49.270, Speaker A: For example, there is a cron trigger which has this cron notation which for example fires it every 12:00 a.m. Noon every day. So, but I want to quickly show you all the other triggers for that we go to the clockwork development documentation and we can hopefully open this here and here we can now look at the different triggers. We go on threads and then we go on triggers. And here we can see the different triggers. So you can trigger an instruction when a certain account changes. You can use a cron notation.
00:03:49.270 - 00:04:30.764, Speaker A: That's the thing we saw earlier with the cron notation. So here you can see for example, if you do zero 00:12 then it does it at 02:00 p.m. Every day. 00:15 ten does it at 1015 every day. And there's all kinds of these things. And then there's also now if you want to immediately have a worker which triggers your transaction, then you can have it on a certain slot or on a certain epoch or on a certain timestamp. And you can also now which is new, use the pith oracle and then listen for example for certain price changes.
00:04:30.764 - 00:05:14.850, Speaker A: So you can say as soon as whatever token reaches a certain price then you want to buy it or something like this. Or you can also use it for example for staking. Like you can say, hey, I put my NFT in the contract and then I want automatically to give the staker some token after a certain time automatically, so he doesn't need to do anything and he directly gets them into his wallet, which is quite nice functionality. Yeah, then cs I said epoch timestamp pith. Here are a few of the use cases. Clockwork did a bunch of examples already. So there's the hello clockwork example, then there's the counter example, just counts up a value.
00:05:14.850 - 00:05:56.232, Speaker A: Then you can use it for reoccurring payments. For example for token distribution you can do dollar cost averaging. Like I already said, you can listen to certain prices and then just buy or sell. Then you can have a serum crank and you can also use it for subscriptions. Like say you have a game and you want to transfer some of his tokens every month to, to your treasury, then you could also do that. And yeah, they would pay on a recurring schedule. But I think the easiest way to learn about how this works is that we just built a little example and I prepared a little game.
00:05:56.232 - 00:06:35.680, Speaker A: It's called it's an idle game and you can find it here under Solana developers Solana game starter kits. And then I would ask you to open the idle game folder in visual studio. And then you go into the program, you install the NBM packages, you build anchor and you test. So that would be the first test if the anchor program is working. And then we would go into CD app, install the packages there as well. I think I use yarn actually usually, but this should also work. So I will now also do this.
00:06:35.680 - 00:07:12.380, Speaker A: Like I opened example the idle game and yeah, I started it already, but what I do is I just do yarn dev. Then you can click this link and this will open the game. This is some weird wallet adapter error that's currently popping up. You don't need to care about that one. Okay, so now we are in the game. Now what we can do, we can do some airdrops since we are on Defnet and we can initialize the game. So here we pay for the game account, we approve this.
00:07:12.380 - 00:07:57.864, Speaker A: And now we can see here that there's already a thread running which gives us one wood every 10 seconds. See, now I have one wood and then there's a few more functions here, which is like upgrade teeth, buy a new lumberjack and trade wood for gold. So if we buy another lumberjack, then we would get two wood per every 10 seconds. And if we upgrade the teeth, since it's a beaver, of course he makes better teeth. So then the wood that you are selling would give you some more gold. And we can also stop the threat here. Okay, now we'll go through the code with you and explain you a little bit how this works.
00:07:57.864 - 00:08:34.452, Speaker A: So this is the game data account. This is where the whole game lives. Basically for every player we have an authority, we have wood, we have lumberjacks, we have gold, we have the teeth upgrades, and we have the last time it was updated. This is important because we want to show in the client the time until the next tick of the thread will be. So we need to save the time when it was last updated. And then in the client we can just calculate the current time minus the updated time. And then we know exactly how much time we need to show until the next update.
00:08:34.452 - 00:09:09.634, Speaker A: Because of course the program doesn't update every second or something, but only every 10 seconds when we, when the trick tick is called from the thread. Then here we have some error codes, here we have some constants. The wood that we need to sell and we need at least ten votes to sell. The gold that we get per vote is like five. And then the gold we need to upgrade the teeth multiplier and how much it costs to binary lumber deck. And then here we have the thread tick time in seconds. So that's the first part of our thread that we need.
00:09:09.634 - 00:09:29.098, Speaker A: So it's just a string. 10 seconds will be part of the cront notation. Then here we have a PDA which is the thread authority. And we have the seed for the game data. So. And now here when we initialize we are creating this thread. So what we do first is we create the game data.
00:09:29.098 - 00:10:12.924, Speaker A: This is a normal PDA like you learned on day two, for example, here would be the player position of the little player moving back and forth. So here we just initialize it. We set the authority, the lumberjacks to one, and the teeth upgrades to one. And we set the updated at time to the current Unix timestamp so that one you can get from clock and then the Unix timestamp. And yeah, you need to make sure that in the client you're also always using the Solana blockchain time if you want to calculate times because you can't just use UDC because the time might be off. Yeah, this is how you import the clockwork SDK and how you import it. And this is how you add the clockwork SDK to your dependency.
00:10:12.924 - 00:11:04.834, Speaker A: So here we are now creating the instruction that the thread should trigger. So what we do is we take the thread tick accounts. These ones is just the game data account with the seed, same as in the tiny adventure tutorial. Then we have the thread which has a constraint that the threat authority is equal to the threat authority key to this one here. And the threat authority is just the static seed and the game data authority. So what this means is that every player who plays the game has its own thread and he is also the authority of this thread, so he can stop it started, pause it, whatever he wants. Now back to our initialize function.
00:11:04.834 - 00:11:36.236, Speaker A: So here we have the accounts and here we have now the instruction that will be called. So the worker network will do a CPI into our program and we'll call this function here. And in this function on thread tick, which will be called every 10 seconds we get the game data and then we just add to the wood the amount of lumberjacks. So if you have one then you get one extra wood. If you have two, you get two extra wood. Then we set the updated add time in the game data account. And that's already it.
00:11:36.236 - 00:12:08.914, Speaker A: So that's the only thing that happens every 10 seconds. And now we have the instruction ready that we want to call. So next thing we're going to do is the trigger. I told you already, it's a bunch of different triggers and this one will be a cron trigger. So all we do here is like this little asterixis and then we pass in the thread tick time in seconds. At the position where the seconds are which is here, and then we say it's also skippable. So in case the player wants to stop its thread because they are also kind of expensive.
00:12:08.914 - 00:12:54.984, Speaker A: Like if you run it every 10 seconds it will cost thousand lampards and as you know like 1 million instruction cost around five soil. So you need to take care that, yeah, that costs a bit of money, that's just something you have to keep in mind. So for an idle game, if it calls every second or every 10th of a second, that's also quite expensive. So then the next thing is here we call, we do a CPI to the clockwork SDK to the clockwork program to create the thread. And for that we create a new context. We put in the clockwork program the same as we did for the tokens and for the soil transfer in the tiny adventure. Then here we have the accounts for the thread create.
00:12:54.984 - 00:13:48.654, Speaker A: It's the payer, the system program because it needs to create a new account, the thread and the authority. And then here we have the seats which are the signer, so thread authority seats and the payer key bytes. And then here we have the amount of leopards that we want to put into the thread. So in this case we want to put 0.1 solution, we put the thread id and then we put the instructions which this one, so you can also call multiple instructions, but I think you pay 1000 lampards per instruction. So you can cheat the system by just putting as many instructions in there as possible and trigger. So yeah that is already, it is actually quite straightforward, it's way easier than for example doing the randomness which we're going to do later.
00:13:48.654 - 00:14:37.244, Speaker A: So yeah and this offers you a bunch of possibilities. And now we already have 40 wood here so what we can do now is we can trade some wood for gold. So if we have 21 25 gold then we can buy another lumberjack. And now we have two lumberjacks and now we get two wood every 5 seconds. So. And now I want to quickly show you how the same thing is done in the seven CS program. So for that I gonna open the seven CS program and here you can see that I should update visual studio and that we have a start thread, a pause thread and a resume thread instruction here.
00:14:37.244 - 00:15:13.150, Speaker A: And the start thread instruction does basically the same as we saw in the idle game. So it creates an instruction thread, tick accounts, it has a cron trigger. This one is a bit different, it's called every 2 seconds, not every 10 seconds. And then we have the thread authority again just in this case it's not the player who owns the thread, but it's the program. So it's actually only a string in this case. And I put two sol in here because I don't want the thread to run out that quick. And then in this instruction, let's go in there.
00:15:13.150 - 00:16:03.092, Speaker A: On thread tick we call on the move on the game we call move in direction by thread. And in this function we find the players on the board. So we find all alive players, push them in a vector, then we go over all alive players, so where the state is player, and then we find the direction they are currently looking at. And then we are checking if the new board state is empty. And then we move the player there and set the other state of the tile before he was before to empty. Yeah. So there is also the possibility to have dynamic threads, which Nick explained in the talk at the bootcamp.
00:16:03.092 - 00:16:53.530, Speaker A: I haven't tried that out yet, but there is definitely the possibility to have dynamic threats, because what I did here is I did it like this, that as soon as the player reaches another ship or another chest, then he would stop, because I don't have the accounts for the token account. If the player would want to collect gold from a chest, then we would need to have a token account. So we would have to pass dynamic data into the thread. But there is the possibility. So you can research that in the clockwork documentation and also the clockwork discord or ask on stack exchange or so on if you need this functionality. And yeah, so currently it would be nice if the ships like drive around on the map and automatically collect gold whenever a new chest spawns and so on. So if someone wants to take this over, it would be a nice challenge for the afternoon, actually.
00:16:53.530 - 00:17:25.374, Speaker A: Like a little homework. Okay, but let's go further to the next topic, I would say. So this was the, this was everything about clockwork. And if there are any questions, you can just post them below the video and we will try to answer them later. So now let's talk about randomness. Randomness on chain is very important, especially for games, of course, especially for gambling games. Like for example, if you have a coin flip, or you want to build a roulette or poker, or any card game where you want to shuffle cards or whatever.
00:17:25.374 - 00:18:30.726, Speaker A: But it's also a little bit of a complicated system because everything on chain is public. And yeah, you don't want people to see the data and create their transactions so that they circumvent the randomness and trigger it exactly at the slot where the coin flip would win, for example, or the roulette would go to 30. So there are a bunch of ways how you can do this. The first one is Xor shift. So this is just a mathematical function where you put in a value basically as a seed, like as you know, in normal random functions, and then there's some magic bit shift stuff happening with it and then you get a new random value out of it and then you can call it again and then you get the next random value. So this is very good, especially for games and on chain programs because it's very cheap. Like you see, there's very little instructions here.
00:18:30.726 - 00:19:09.726, Speaker A: It's very easy to implement. So I'm going to show you later how it's done in seven seas. In seven seas it's used for the spawning of a new ship. So it's finding the new ship position and for the damage that the big Cthulhu does when he attacks someone. Yeah, so the problem with this is that it's not fitting to all statistically randomness tests. So you can read about more about this on the Wikipedia article or there's also some papers about it. This is, for example, also used in JavaScript eight.
00:19:09.726 - 00:19:41.804, Speaker A: In Chrome it's using the Xorshift 1024. And yeah, there are a bunch of different implementations of these. So you can make it a little bit statistically, more statistically a little bit better. I will show you later. But first let's look at the usage, how it's done used in seven seas for the Cthulhu damage. So here we are using the, we are creating a new Xor shift. Then we have the base Cthulhu damage, which is ten.
00:19:41.804 - 00:20:18.844, Speaker A: Then we get 30% of the Cthulhu damage, which would be three in this case. Then we take the Cthulhu damage and we add randomness, modulo the damage variant plus one. So this would mean like whenever Cthulhu shoots, he does ten damage plus one, two, three damage. Yeah. And the nice thing about this is that this is also predictable. So whenever I run my tests and I put in the same seat, then it will always also give exactly the same result. So for games and tests, this is like very convenient.
00:20:18.844 - 00:21:03.334, Speaker A: You might also have noticed in the game, like whenever you spawn a ship and there are like two ships on the board, then the next ship will always spawn on the same position. This is because for the spawning of the ships, we are using the amount of items on the board as a seat. So like this is very predictable. So you can very easily write tests, for example, as partnership. Then I move three files down, spawn the next ship, and I can shoot directly at it. So this is a little bit more statistically safe implementation of the XOR shift. What it does is it has a bit of different values, and then it multiplies the U 64 by U 128, and then it cuts off the unnecessary bits again.
00:21:03.334 - 00:22:01.788, Speaker A: So this speeds a few more of the statistics tests, but also has a little bit more compute and needs a little bit more memory. Then another nice thing that you can do is you can combine the randomness with the current block hash or with the current slot of the blockchain. And like this, you will have a pretty nice random value which is not related to a fixed value. So then you basically get the, you just pass in the slot, current slot as the seat for the randomness, and then you do the same thing, modulo max, the max value that you want. And yeah, you can also do this by, instead of the slot, you can use the current blockers and just take the first few bytes, for example, and use them as a seed. That's also already pretty random. Then what you can also do is you can use the hashing function.
00:22:01.788 - 00:22:49.332, Speaker A: Hashing functions are very, very random. So use the slot, then you create a hash from the slot, and then you take the first few bytes of it. I think here we taking the first eight bytes, and then you convert them into U 64. And this is also pretty random. But yeah, we will talk a little bit about security now, because they are random, but they are not 100% secure. So what this means is a malicious validator could come in and change the block by putting in more like, he could like fill up the block in a certain way so that the block hash would have a certain structure. And then like this, he could theoretically attack your randomness value.
00:22:49.332 - 00:23:30.640, Speaker A: And while this is very unlikely that this is being exploited, it happened before. So for example, the trashpandamint was botted because people exactly sniped all the legendary ones. And there's also the code roulette, which was exploited. I added a few links here that you can look at. So yeah, they predicted which will be the next random value, and then they got it. So as soon as there's much of money involved, you should not rely strictly on the block hash or the current slot. But there's also a solution to this, a partial solution, which is using an oracle.
00:23:30.640 - 00:24:28.808, Speaker A: And there is, for example, the oracle from switchboard, which would be the one that we'll be looking at today. And how it works is that you ask an oracle for a random value and then the oracle will give you this random value and then use it in your program. But as you can already see, this is like a two step process so it makes it more complicated. Yeah, and as you can see here, there exists a collusion vector. So this is still not 100% safe sadly, because if the malicious validator would work together with all the switchblog oracle providers, then they could still theoretically break this. But it's way more secure already than only relying on the block hash. And how it works is you request randomness from in this case switchboard or any other oracle, then they do a CPI into your program.
00:24:28.808 - 00:24:59.546, Speaker A: So you need to save the state that you want to interact with in your program. Then you get the CPI from outside, then you consume the randomness. And using a search box oracle also costs 0.002 sol per random value. So there are a few other hacks and workarounds that you can do by just using another oracle. You could just use the get the current sol price from pith, for example, and use that one somehow for your randomness. But you definitely need to research enough.
00:24:59.546 - 00:25:35.256, Speaker A: If you have lots of money that is dependent on this random value, then you should be very careful. So, but we gonna today look at the implementation of switchboard and I added a few resources here. Here is implementation of rust program which implements a bunch of different randomness functions that you can just copy, paste or test out. Then we have the coin flip example here. That's the thing we're gonna build in a bit. Then we have xor shift explained on Wikipedia. We have an article about switchboard randomness, which is quite interesting.
00:25:35.256 - 00:26:06.624, Speaker A: Then we have another playground tutorial that you could just run through. It's called boss battles. It's you're attacking a boss and whenever you do damage, it's a random damage. But today, let's look at the switchboard implementation for this, please. You already checked out the game starter kits, so this time we're gonna open the coin flip example. I again started with Yarn dev in the app folder. So CD app and then yarn dev.
00:26:06.624 - 00:26:38.952, Speaker A: Then we have this nice little game here. So there's again this weird ethereum error from the wallet adapter. Right now let's log in. It should be connecting, but it's not. Now it is. Okay, now we initialize our player. Now we can see that there's a vault balance of twelve and a player balance of zero seven.
00:26:38.952 - 00:27:04.428, Speaker A: So now we do tails. Then we have a nice little animation. This is like waiting for the randomness now and here we can see, yeah, we lost. So we got, wait, I won. But the player balance is still less. So I guess the text is the wrong way around because the balance in the world went up and the player balance went down. But yeah, we are anyway here not for gambling.
00:27:04.428 - 00:27:28.664, Speaker A: We are here to look at, to learn about randomness. So let's look at this code a bit. We're gonna look at the Librs file here. We can see how you implement it like you get it from the switchboard SDK in the kaggle tumblr. You can also see switchboard v two. We are currently using the 0.123 version.
00:27:28.664 - 00:28:15.578, Speaker A: And now let's look at it. So when we initialize the game, first thing is we start a bump and we start a VF switchboard key and we save the max result. In our case it's two. So if you want to have another game which is like goes from one to ten, a ten sided dice roll gambling, then you could set this to ten, for example, or if you have a card game one to 52, pick a card and then you win, then you would set it to 52. So now we request randomness. The first thing we do here is we transfer 0.1 sol into a PDA, which is this way, the solvolt, and then we set the state to what the player guessed.
00:28:15.578 - 00:28:54.244, Speaker A: So one or zero or one, depending of coins or like heads or coins, heads or tails. The result we set to zero. And now we do this very big randomness request here. Let's go through the most important accounts. But they are all, they're all described here, what they do actually. So we have the oracle queue, we have the VF account where the new randomness result will be stored. So they put it into this account, then they do a CPI into the program, and then in this account you will find the data.
00:28:54.244 - 00:29:47.428, Speaker A: Then there is the authority of the VRF account of this one. So only this account will be able to get the, get the randomness out of this account. Then we have the oracle queue, this is the queue which provides the random values. And then we have the queue authority, we have the data buffer account, we have the permissions, we have an escrow account which is funded by reptile from the player to pay for the fees, the 0.002 sol, and we have the player wallet, the player authority, and then the standard stuff, recent blockage. This is the program state from our game, and we need the token program because it's interacting with wrapped Sol. And as you can already see, this is quite complicated.
00:29:47.428 - 00:30:39.476, Speaker A: So if you have like a very simple use case for your program then better use an XOR thing and use the block hash. But if there's money involved then you should probably use something like this. And I also yesterday I talked with clockwork and they are also thinking about implementing a little bit easier random function using their worker network. Or if you want to work on something like this, this is something that's would be very good to have a very easy way to get randomness on chain. Then here's the player key, these are the seeds. And then we invoke signed this randomness function. And then after a bit there will be the CPI from switchboard which comes back into our program from outside here.
00:30:39.476 - 00:31:05.644, Speaker A: Then we have the VF account. Here we find the random value and here we check. If it's empty then there is no randomness result. I don't know, for example, if switchboard didn't manage to get a random value, for example, I guess then we have the game state. Here we have the max result. And then at some point we will cut off. Now here we will do modulo maxresult.
00:31:05.644 - 00:31:52.494, Speaker A: This means like we have a very huge number, U 128, but we only need actually a little bit of the last bit. So we cut everything else off and then we check if we won. Then we transfer solve to the player. And if we did not win, then we don't do that. Yeah, so this is the coin flip example and yeah, everything in the program, all the accounts have comments and I explained and you can read more into detail and how it works and just use it in your program if you need that. So these are all the randomness functions. Let's build a coin flip game that we just did.
00:31:52.494 - 00:32:25.920, Speaker A: And now it becomes interesting. Now we're going to talk about zero copy and big accounts. So for that we're going to start this playground tutorial. Like I uploaded it in playground for ease of use. You can go here on the left to the tutorials, then back to tutorials, and then you can open the zero copy example. And for that we need a local validator. So we write Solana test validator to start a local validator.
00:32:25.920 - 00:33:04.104, Speaker A: And then in playground we can also connect directly to this local validator by using the endpoint localhost here. Yeah, so first we're gonna run this thing and look at the tests and then I can explain you what this is and what you need it for. So we just do build, then we do deploy and then we do test. Yeah. How this works. This web platform actually like it, it sends your code off to a server, it builds it there and it comes back. So it's a very nice system actually.
00:33:04.104 - 00:33:34.328, Speaker A: So now we deploy it. If I can manage to write it correctly, you can see it costs a little bit of soil. I have still 100 soil left deploying it. You can already see a little warning here that we gonna need later. It's already giving us a little warning that we might run out of stack size. So we have four kb of stack size only. And here in the first test, error is now nicely already showing us this might fail, but you can still run and build it, and it would then fail at runtime.
00:33:34.328 - 00:33:59.552, Speaker A: Okay, so this is deployed. Now we run the tests, and here you can see what's happening. So the first test is hitting the stack size limit. So let this run in the background. For some reason it takes a while. So we have certain limits in the Solana runtime. So we have an account limit, which is 10 kb or ten kb bytes.
00:33:59.552 - 00:35:02.110, Speaker A: Again, actually of the size your accounts can be. Then we have a four kilobyte stack size, and we have a 32 kilobyte heap size. So in this account, this kilo, ten kilobyte account limits is actually only there because there is a limit of how much memory you can allocate when you do a cross program invocation. And the cross program invocation in this case is a CPI to the system program to create an account or increase the size of an account. And since the anchor framework creates an account, and it does a CPI in the background, like whenever you put init over your account in anchor, what it actually does, if you look at the code behind it, is it takes the data from your account and it creates a new account with a system program, then adds the little discriminator at the front, and then puts all the data that you want into this account, the next thing we're gonna go beyond the limits. Let's quickly look at this here. Yeah, so it's running.
00:35:02.110 - 00:35:33.214, Speaker A: So here you can see already that we ran out of, there's some error here, exceeding timeouts. So that shouldn't happen, of course, since I'm on the local validator. So let's run this test again. Okay. For some reason it doesn't run currently, but what you would see is that the first test fails because it's running out of stack size. That I gonna show you here. We can just open the tests.
00:35:33.214 - 00:36:06.274, Speaker A: And all we do in the first test is we initialize an account which is too big. So what happens here is this is the initialize hitstack size structure. It's a very fitting name because it's hitting the stack size as soon as you create it. It has ten kilobyte of data in it, or ten kb. KB are the 24 bytes on top. So it's like a power of two. And here you can see this is the hit the stack size struct.
00:36:06.274 - 00:37:05.954, Speaker A: So it's an option of big struct. And the big struct has four public keys, and every public key has 30 32 kilobyte. And if you have twelve of these, then we will hit the stack size, because every struct in rust and in the Solana runtime lives on the stack by default. So to solve this problem, if you ever run into it, if you have too big of an account and you hit the stack size, then you can box your account. So you can box an account by just writing box on it. And what this means is there will only be a pointer left on the stack and it will point to the heap, and then the majority of the data will be on the heap where you have much more space. And this you can do like, like here, can I search here box? Oh yeah, here.
00:37:05.954 - 00:38:07.854, Speaker A: So here you can just comment this out, comment this in, and then you will see that the test will pass afterwards. So then the next test, let's see if it ran out this time. No, it's still not running, but hopefully it will run for you or otherwise. I will also put a link into the slides where you have a GitHub repository where you can run the whole thing locally, so you can play around a little bit with it. But now I want to show you how you can get bigger accounts, so how you can go beyond the limit. So you can, you can create a ten GB account, and then directly afterwards you can call another instruction which increases the account size by another ten kb. So how you can do this is anchor has this very nice function here where you can directly use data that you pass into the instruction, and you can use it in the struct initialization here.
00:38:07.854 - 00:38:48.054, Speaker A: So what this means is we here we have a realloc and we use the length value that we pass into the instruction data, and then we initialize them with zero. That's a bit of a security thing. You should usually use this because otherwise you have some old data in your accounts, then you realloc and the payer will be the signer. Of course if you realloc an account, it's the same cost as usually. So for a ten kilobyte account, you would always say pay around 0.07 sol or zero seven sol. Let's quickly check so that I don't say something wrong.
00:38:48.054 - 00:39:17.124, Speaker A: Can just say Solana rent and then 10 kb. So it would be ten 0.07 sol. So yeah, this is how you can make a bigger account. And you can see the code for this here and in the client and the test. Let's go to the second test. This is how you would then do a realloc.
00:39:17.124 - 00:39:50.906, Speaker A: So you call the methods of the program, increase account data and you just put in the new size that you want. So if you make it bigger you need to pay for it, but you can also make it smaller and then you get the soil back. So I haven't tried. If you put it to zero, maybe it just closes the account. So that also someone could try in the afternoon, maybe as a little homework, just put a zero here and see what happens to the account. Not sure if you can do this because it wouldn't be rent exempt anymore. Or if you can't do it because, or if you can do it and we'll just close the account.
00:39:50.906 - 00:40:33.882, Speaker A: So it would be interesting. So someone please try that out and write a comment in the, under the video maybe. So this is how you can get accounts up to ten megabytes. And this should be enough for everyone. And they are also way more expensive than already. So, but if this still isn't enough, like, because if you load this account now and it has more than ten kilobyte of data, then you would hit the heap size, this is only 32 kb. So if you increase this account three times, like we do here in the second test, and we shove more data into it, as soon as we go above 32 kb, then we will get a runtime error.
00:40:33.882 - 00:41:41.488, Speaker A: I would love to show you this error here, but what you would do now is you run the tests and then you copy the signature from the second test where it, where you see the error and paste it into the explorer, and then you would see that, that the runtime is running out of memory and that you, yeah, you can't completely load an account that is bigger than 32 kilobyte into memory, so the runtime will crash. But what you can do, you can circumvent this by using a zero copy account. And how this works is that instead of loading the whole account into memory, you only have a pointer to a certain amount of memory and you directly interact with this memory by using memcpy operations. So here you can see you just add this flag here, zero copy, unsafe and rep type. In this case it's c, but there are also a bunch of different rep types that you can google. There's also pact, which makes it a little bit smaller, but then you will have a bunch of problems with options and enums and so on, because they are serialized differently. So this is how it's used.
00:41:41.488 - 00:42:36.074, Speaker A: In the seven seas program we have a zero copy account, which is the game data account, and it has a two dimensional array board of ten by ten tiles and an action id which is used for the animations. And every of these tiles is also zero copy struct. And it has the current player, it has the state of the tile, the health, the damage, the range, the collect reward, the avatar pub key which is the NFT. So that in the game we can load the little image of the player of the pirate ship and also show it to the players. Then we have the look direction that we use for the clockwork threads, so they know in which direction they need to move the ship. We have the ship level and we have the start health of the player. This one is important because now that you have rum token, which you got yesterday, your ship might start with a different amount of health.
00:42:36.074 - 00:43:30.822, Speaker A: And of course the client doesn't know beforehand which start health you have. So that's why we save the start health in this account as well. So in the client we can then directly calculate the health and the start health and we can show a nice little health bar and yes, so this was zero copy, and now we gonna build the seven CS program. So for that it's in the same repository, you just this time in visual studio you open the seven CS program. And for this program we have multiple clients. So there's a JavaScript client which doesn't have a lot of functionality yet, and then there is the unity client which looks much more beautiful. So let's first start with the JavaScript client.
00:43:30.822 - 00:44:34.648, Speaker A: So we go in cdapp and we do yarn dev again, and now we have this nice little JavaScript client here, let's close all the other stuff that we don't need anymore, there's loads of it. And there's this error again. And now we are connecting. And here you can already see the first chip. And I also gonna run the game, maybe just open the Webgl version and then I'm going to show you that actually the same client works for both, like they interact with the same program. So here I gonna log in now with my phantom wallet or backpack or whatever you like, just make sure you set it to definitely. Okay, so here we can see now that we have two different representations of the game.
00:44:34.648 - 00:45:22.840, Speaker A: One is in JavaScript and one is in unity Webgl client. And you can see if I move my ship around here, you can actually see the actual representation of the grid on the left. So you can also see that the ship is a little bit lagging behind to have a nice little animation. And when I shoot, I also can't see this in the JavaScript client yet. So there's also something someone could build in the afternoon if you want to do some homework, try to make a nice little animation for the shooting of the ships. So now we're gonna go through all the features and I will quickly show you how they are implemented in the game. So then in the end you would theoretically be able to build this game completely yourself, or you just copy it, deploy it yourself, change the graphics, whatever you want to do with it.
00:45:22.840 - 00:45:54.994, Speaker A: It's all free for all. So we have the zero copy bought account which I showed already. We have this here, the two dimensional array with all these tiles. So this is one of the features. Then we have the on chain movement, which I quickly going to show you the move player. What move player does? It moves, it calls on the game, which is the game data account, the move player and direction. What it does, it finds the player on the board, saves the player position.
00:45:54.994 - 00:46:44.044, Speaker A: Then when it finds the player on the board, it calculates the new player position, which would be, if you go up it would be y one. If you go right it would be x plus one and so on for the four directions. Then it checks if the new tile is empty, and if the new tile is empty, it just moves the player there. If the player is not empty, if the tile is not empty and it's a chest, then we collect the chest and set the current tile to empty. Then we transfer from the chest vault some salt to the player who collected the chest. And we also transfer some gold token from the gold token, pda token account to the player. And then we also save the game action which we will be looking at at a bit.
00:46:44.044 - 00:47:27.034, Speaker A: Yeah, you can gain soul tokens, gold tokens by killing chips, that's what you just saw. The same thing happens when you shoot. Then it finds the tiles on the side and does attack on tile. And when you kill another ship, then you will also get the soul in that ship and you will also get the gold token in that ship. The rum and cannons, apparently you don't get because they quickly throw them into the harbor or into the sea or something. Your ship account is derived from the mint of the pirate NFT. So whenever you spawn your ship, what's actually happening is there's a PDA created which takes the mint of the NFT as a seed for any of these NFTs.
00:47:27.034 - 00:48:06.154, Speaker A: Here, the ship starts at level zero, so there's a PDA which saves the current ship level. And when you use your gold token, you can upgrade this ship. So you actually upgrading this NFT PDA. So yeah, this is how you can save data on any NFT. Actually just derive PDA from the mint of the NFT, and then you interact with that, and you upgrade the ship with SPL tokens. You use SBL tokens for damage and health. So this is done like when we spawn a ship, it's in spawn players.
00:48:06.154 - 00:48:45.436, Speaker A: We are checking the token accounts of the player, and we use these amounts here for cannons and extra health. So the extra health comes from the rum token, and the cannons come from the cannon tokens. And the cannons in the ship are used to calculate extra damage. So if you have thousand cannons, I think you currently would get thousand two damage. Then the next feature there is, there's an auto proof wallet. I'm gonna go on this on the next slide more in detail. Then there's the clockwork weather effects that we talked about earlier already.
00:48:45.436 - 00:49:13.898, Speaker A: They have the NFT avatars. So like, you select an NFT and then use this Nft as your character. So you can also see this little NFt here. If I. If I open this and I deploy this ship, then you can see that the NFT avatar is actually here on the ship. So it's loaded after a while. Then we have the animations via game action account.
00:49:13.898 - 00:50:00.672, Speaker A: So if someone has a better idea for this, I would be very interested in this. But how I did this, since, like, all the client sees is that the state changes, right? The board changes from one state to another. Like, once the player is here, then it's there. So how I managed to get the clients to actually show animations is that I create, I have a new account which is a vector of game actions. And whenever an action happens in the game, I create a new game action. So for example, here, if we shoot, I create a game action, which is the game action ship shot type, and it has the player and the target. And so the game shot just shoots in both directions.
00:50:00.672 - 00:50:36.070, Speaker A: But then there's another one, which is, for example, take damage, then ship taking damage. So whenever a cannonball hits a ship, then it's triggering with the ship taken damage type and then it would be the target and the player in there then. Yeah, it also has the damage and there could be any other data in there as well. Oh yeah. And then we have the surprise Cthulhu attack which you will learn about tomorrow where you will be able to scan a QR code and then the big monster on the side of the map will shoot. We are Solana pay transaction request. So that will be very fun.
00:50:36.070 - 00:51:09.032, Speaker A: More tomorrow. Yeah. And then a little excuse on how you can do auto proof wallets. How I did this in the seven seas is I have a key pair in the game and whenever you deploy a ship, there's a tiny bit of soil transferred into this in game wallet and then that one is used to pay for the transaction fees. You can also click here and you can withdraw this amount and you can put some in manually if you want as well. So this is one way. It's not 100% secure since the browser isn't really a safe place.
00:51:09.032 - 00:51:50.584, Speaker A: So there could be some cross site scripting or malicious extensions. But I think for the game, for this game it's fine. It's just like tiny amounts in there and I mean it's still a funded key in the browser, so it's a little bit dangerous actually. Then there are some other options, which is the gum session keys. I did a video on the gum session keys earlier, so it's basically also saving an ephemeral key pair in the browser and transfers a little bit of salt into it. And then in your program you need to adjust your program so that you have an authority which is allowed then to do certain actions in the game. So I will link the video to that in the resources.
00:51:50.584 - 00:52:18.524, Speaker A: Then what you can also do is use a burner key pair. This is pretty much what I did in the seven Seas program. Then solflare wallet has some auto approve functionality, so you can per app, you can create a new key pair and then you can set auto proof. I mean this forces you to use solve layer and it's kind of hard to explain the players. Hey, create an auto proof wallet. An auto proof wallet are very dangerous. They can use all kinds of things.
00:52:18.524 - 00:52:59.834, Speaker A: Yeah. And clockwork is also working on some solution maybe where you can facilitate the workers, but this is not a really a solved problem that. So if some of you guys want to like work a little bit on this, this would be a very valuable addition to the whole ecosystem, I think. Yeah, I think that is it for day six. Very excited for you tomorrow to tune in again for the big cthulhu attack. And, yeah, now we could do a little sea battle. So if you all log in now, we could fight each other and then we could also like, turn on the wind and see how it is with the wind.
00:52:59.834 - 00:53:13.886, Speaker A: And then we. Yeah, here are the resources. I will add the link to the session keys video here as well. And yeah, thank you very much for joining me today and see you everyone tomorrow. Bye.
