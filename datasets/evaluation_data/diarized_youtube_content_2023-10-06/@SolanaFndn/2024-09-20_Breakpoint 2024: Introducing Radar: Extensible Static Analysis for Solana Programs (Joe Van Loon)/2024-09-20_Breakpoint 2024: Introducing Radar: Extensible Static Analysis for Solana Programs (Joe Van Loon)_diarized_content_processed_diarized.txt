00:00:03.360 - 00:00:39.857, Speaker A: Hello, my name is Joe. I'm the CEO and founder of Audit Wizard. Today I'm going to be talking a little bit about Radar, my new open source static analysis tool for Solana programs. So in this talk, we're going to cover everything you need to know about using Radar to improve your project security. You can easily write your own detectors if you're a developer, auditor, anyone who cares about security. This is the tool for you. So a bit about me.
00:00:39.857 - 00:01:16.175, Speaker A: As I said, I'm Joe. I worked in Web2 as a security engineer for about eight years at companies like Amazon and Apple. Most recently I was on the cryptography team at Apple. Done a lot of security reviews in that time. Also spent a good deal of time researching how we can empower devs to take security into their own hands. I believe tools are the feature of that. We also have here Tomar Barr.
00:01:16.175 - 00:01:52.295, Speaker A: He wrote all the code for Radar. He feels the same as I do. He's our lead, responsible for the greatness of his Radar today. And together with the rest of the team, we've built Audit wizard, which is an all in one security platform. All right, so what is Radar? It's yet another static analysis tool. You may be familiar with things like Slither and Ethereum Land. Currently it's one of Solana's only open source free tools.
00:01:52.295 - 00:02:41.955, Speaker A: It can be used out of the box as a traditional scanner as various methods, CLI and others we'll get into. It also has unique benefits of using an intuitive template engine. It allows you to define your own detectors via templates really easily. And we include many helper functions to allow you to sort of abstract away some of the difficulties of doing that so you can easily write your own rules. The nice thing about that is if you have some specialized projects, you have a large code base, you want to detect certain things that are not so generic. This is how you can do that really easily. All right, so how do you use Radar? There are multiple options for using it.
00:02:41.955 - 00:03:24.963, Speaker A: There's a CLI and a server component. The tool is Docker based to make it compatible across platforms. The CLI is really just a convenience wrapper in front of that. So it should just work at any, any platform, any system. There's also a nice side effect of how we've engineered that. We basically built in an API microservice into it and sort of architected a CLI around that. And the nice thing about that is it allows you to build on top of it in server applications.
00:03:24.963 - 00:04:09.365, Speaker A: Your own clis, whatever your use case, would Be definitely setting it apart from other static analysis tools which are not designed to do that at all. They're purely CLIs. Through building our platform Autowizard, we incorporated many static analysis tools and we always sort of struggled with extending them, incorporating them into our automated workflows. So that's the decision we made to make things much easier for the community. Here we have a video of it in action. You can see just the basics that we've installed it, we're running it against our project. There is Docker, you can see it running.
00:04:09.365 - 00:04:31.073, Speaker A: Don't need to worry too much about that. But you can see all the output from the CLI there. You can format it. Yep. And view it in a really nice sort of machine readable, human readable format. In addition to that, you can incorporate Radar into your workflow. Right.
00:04:31.073 - 00:05:39.865, Speaker A: So GitHub Actions, GitHub Commit, hooks, we all have them, have them all pre configured in the Radar repos. There's a marketplace GitHub action you can just go ahead and plug in right away. So anytime you have a print, it actually will plug into GitHub itself in the security tab and you can go ahead and triage the results there, just like you do any of your other security tools. All right, so my favorite slide here. We took a different approach with Radar. Typically when you have a static analysis tool, the detectors are defined in code. If you want to extend those detectors, you need to fork the code base, you need to look at all of the sort of examples that are there, you need to understand how their engine works, and then you can attempt to write your own detectors.
00:05:39.865 - 00:06:29.545, Speaker A: And if you want to contribute that back, you open a pr, you go through all that process. Not super accessible when you want to just quickly test something on the fly. So what we decided for Radar is that we would allow you to write essentially templates that you can just load in on the fly, and you can also create a nice database of them. So to do that, it's really easy. We use simple Python syntax to define the detector rule. There's a few examples in the repo. And we also have detailed API docs that cover all of the sort of helper functions, which I'll go into in a little bit.
00:06:29.545 - 00:07:32.373, Speaker A: So you can go and you can jump in and start constructing some of these rules in a pretty simple, intuitive way. So traditionally with static analysis tools, you need to manually traverse what's called an abstract syntax tree. That can be pretty painful because it's just like a lexical structured representation of the syntax. Doesn't really follow any rhyme or reason as far as control flow goes. So you have to kind of determine that yourself. The way you might do that is say, like, I want to find all the functions that call into this certain function. So, okay, you write a detector that will find that certain function and then you have to go through everything else in the abstract syntax tree, completely crawl it and manually check to see what calls into that, apply whatever conditions.
00:07:32.373 - 00:08:24.505, Speaker A: We abstract a lot of that away. There's also much more complex things you can do. We have helper functions to define sub patterns that you can use as building blocks. You can simply chain them together using basic logic. You know, you have a Turing complete language of Python and can make some pretty powerful stuff that way. All right, so under the hood we first explored using something like an LLVMIR or bytecode representation for the detectors and for defining these patterns of code. That's one approach.
00:08:24.505 - 00:09:00.444, Speaker A: The other is using abstract syntax trees. As I said, it was just the one, the one we chose. Each has its pros and cons. I think there's actually another tool you hear about pretty soon here that's taking the opposite approach. The nice thing about intermediate representation about bytecode is the control flow is very well defined. The downside of it is it's not exactly representative of the original syntax that you've seen. Right.
00:09:00.444 - 00:09:40.945, Speaker A: So if you're used to just reading the code and understanding a pattern from that, you then have to sort of translate how that would look in bytecode, how that would look in llbmir. The nice thing about abstract syntax trees is that it's just exactly what the code looks like. It's just a structured representation that you then have to crawl over, write some logic on top of. So we opted to go with the abstract syntax tree. It seemed like the simplest way to go about it. And really the idea behind RADAR is that we make it as simple as possible. So you don't have to be a security expert to write some of these detectors.
00:09:40.945 - 00:11:22.735, Speaker A: So to get into how it works, the first thing radar does is it parses the ast, uses the Rust sync rate to take the Rust code output formatted astronomy and it's pretty simple. From there iterates over the set of detectors and then use that data structure and derive patterns from it. So as I said, it's pretty complicated actually to write a behavior based or data flow based detector on a syntactic representation of the code. So our approach to solve that was to write a pretty extensive library of what we call these helper functions and those functions are. You can consider them your basic building blocks of the detector. There's some simple things like get the list of functions that call into this function and there's more complex things like find things we would consider to be modifiers, different conditions that you can chain together to have sort of a complex detector. All right, so oftentimes when building a system like this, devs will gravitate towards defining a domain specific language in dsl.
00:11:22.735 - 00:12:18.551, Speaker A: If you've seen platforms like Satoru for example, or other scribble formal verification tools, they often use a DSL because then you can be very specific about the expressions. We entertained that as well. Ultimately opted to use Python because it's, you know, as I said, a Turing complete language. There's plenty you can do with it logically and it just seemed again to be the simplest way to do things. So yeah, that allows you to have a really low barrier to entry. Jumping in, writing around templates, experimenting with things. Alright, that's my talk for today.
00:12:18.551 - 00:12:38.265, Speaker A: Thank you for listening. We have some links here to help you get started. You can check out what radar is@Autowizard IO Radar. Check out the GitHub, our actions and also we have some example contracts. You can run the OC level. Yep. Thanks everyone.
