00:00:06.760 - 00:01:18.954, Speaker A: All right, everyone see the presentation? Someone? I don't have a second monitor today, which is a little bit of a hindrance here. So, yeah, feel free to just speak up if there's something people want to bring up or a question because it's going to be a little, little difficult with just the single monitor unless there's like a speaker mode. Hold on one sec, let me see if I can. No, it's not. Okay, well, we'll just do it this way and I'll check messages periodically. All right, so my goals today are to talk about security, specifically Ubuntu security for setting up your validator and then key security for your validator, identity vote, account and withdrawal keys. The reason I wanted to talk about this was there's been a couple people reaching out to me from the delegation program who have their identity keys compromised.
00:01:18.954 - 00:02:19.917, Speaker A: And there was a recent hack in December at a data center where I'm not sure the total number, but around eight or nine validators had their identity key compromised. And I think all of those could have been avoided if people took these steps. So want to talk a little bit about some ideas for what you might want to do for your validator. Uh, to make sure that you at least cover some surfaces, to make sure people don't have easy access to your machine. And then, um, kind of open it up for discussion to see where, what other people are doing and figure out if people have methods that they're using that I don't mention here or methods they do or don't like, uh, just so they can see what the community is doing. My goals today, first of all, talk about what to do before you start running your validator. These are not necessarily validator specific things.
00:02:19.917 - 00:03:08.474, Speaker A: These are just Ubuntu server hardening practices, things that you can do for setting up either a validator or if you're setting up an Apache server or anything else, ways to limit access to the box. Then after that, talk a little bit about key security and an option that was brought up during that hack about starting your validator without actually having the identity key, even physically on your machine. So that's maybe something people want to do, but there are some trade offs there. I'm just going to check messages real quick. Yeah. And again, if there's questions, please just speak up. Don't need to raise your hand or anything.
00:03:08.474 - 00:03:58.174, Speaker A: We'll just make you interactive. Okay. So first and foremost, you should be using ssh keys for login and try to avoid password login. Recommendation here is to use an ssh key, generate an ssh key or use one that you've already got, copy it to your machine. So SSh copy id the path to the key and then the server that you want to connect to. Then once you've done that, make sure that the password authentication to the server is disabled. If you have a box that has password authentication to start, you want to go in and edit the SSHD config, turn password authentication to no and challenge response authentication to no as well.
00:03:58.174 - 00:04:41.634, Speaker A: That way, even if someone tries to log in with a password instead of an ssh key, they'll be denied. The nice thing about this, of course, is that people can't try to brute force your password. It makes it a lot harder to gain access because only SSH keys are allowed and they're obviously very difficult to guess. Um, another thing that you could consider, and I'm kind of curious if anyone is currently doing this, is setting up two factor auth. So using Google Authenticator you can actually set up two factor auth to your machine. Is there anyone that's currently doing this or has this set up?
00:04:44.774 - 00:05:25.194, Speaker B: I do not, but I will inject. I have a very minor addition for my own login and that is that I subscribe to this service. I think it's called textbelt, where you can SMS message yourself. And I have a little line in my bash login for the only user that can log in that sends me a text message anytime there's a login, I just want it to be so an attacker would have to sort of know that if they were somehow able to log in through my account, they would have to know ahead of time. I don't even know how they could prevent that line from running since it's in my bash login. But anyway, it just sends me an SMS message. Not true security, but it's just one more step to let me know if something was to go wrong and someone were to somehow get in.
00:05:25.194 - 00:05:32.218, Speaker B: I'll get a test message at a time that I wasn't expecting it saying that I haven't logged into. So I have that one minor edition. It was pretty easy to add.
00:05:32.386 - 00:05:54.764, Speaker A: Yeah, yeah, that's a great addition. Yeah. I sort of glazed over some details here, but monitoring is always super useful as well as sort of limiting access. Right. So it's always a good idea to have either email or text message alerts that tell you like when something suspicious is happening, like, like a login that you don't expect. So yeah, completely agree. That's awesome.
00:05:54.764 - 00:06:30.292, Speaker A: If you want to share any of that set up or just message it out to the group, that would be helpful too. So anyway, two factor off. I haven't actually set this up myself. I don't know the limitations of it. If it becomes cumbersome for running a validator, my hunches it's not, but something to investigate and try out. Okay, next recommendation here is to update regularly. As you all know, there's always security vulnerabilities in every software.
00:06:30.292 - 00:07:23.736, Speaker A: They're impossible to avoid completely. The best mitigation of course, is whenever there is a security vulnerability and it is patched and fixed, you should update right away. A good practice would be to follow security notices like Ubuntu security notices here, and then once you see that that security notice has been published, you should update and upgrade to the latest. Of course this line here just does a general upgrade of all packages that is probably not what you want for all cases. You probably just want to focus on the package that has security vulnerabilities. But this is good to do periodically as well, just to make sure you don't have some stale packages there that are years old and maybe exploitable. Another thing to do is just to regularly audit your list of installed packages.
00:07:23.736 - 00:08:35.670, Speaker A: If you do sudo app list installed, you can see all the packages that you've got installed and maybe there's some stuff like, I don't know, maybe you were experimenting with something, you installed something six months ago and you're not using it anymore. It might be a good time to remove that. So yeah, update regularly and then another tool that I think is useful, I'm not sure if people are using this or not, is to actually install what's called unattended upgrades. This essentially does these steps for you automatically, so it looks for any changes in the list of. I can actually show you the list here. I think I've got it on this one. Well let me, I'll skip this for now.
00:08:35.670 - 00:09:32.008, Speaker A: I don't want to grab the password at the moment. It essentially allows you to decide which packet repositories you're going to monitor and if there's any changes to those repositories, then it upgrades those packages automatically. By default it is just set to security upgrades and not to general updates, but you can configure all these things. I would suggest just setting this explicitly to false so that you don't automatically reboot your machine when there's an upgrade. I don't think it's very common for that to be necessary, but every once in a while there's some package that requires an upgrade or, sorry, requires a reboot of your system. You don't want that to happen at like 02:00 p.m. When you know you're maybe not around or not available, not the keyboard you want to know and sort of schedule it ahead of time.
00:09:32.008 - 00:10:22.194, Speaker A: So setting this to false would be a good idea. And just like Zantetsu mentioned, you can also set up email and notifications with this so you can get notified whenever package is upgraded. Is there anyone that is using this currently unattended upgrades? No? Okay, well, something to check out. Curious to see what people think of it. Fail to ban. This is another one I know a couple people in the community definitely use and I'd recommend it. It does intrusion detection and it can be set to, I think by default it actually is configured to use or to monitor a lot of different intrusion detection scenarios.
00:10:22.194 - 00:10:58.474, Speaker A: But SSH is probably the one we're most interested in. So the default setup is pretty good. You can install fail to ban, just pseudo app install fail to ban and then check to see if it's running. You can also configure it to do email notifications, probably SMS as well. So whenever there's some ip that's banned you could see automatically. Hey, this person was trying to access my machine. Anyone currently using this tool? Give me 1 second.
00:10:58.474 - 00:11:32.534, Speaker A: Yes. Okay. Okay. Looking through the messages here, Zantetsu added text belt in the chat. I'll make sure to save that text and put it in the notes for the video. And Brian gave it a thumbs up for fail the band. So that's awesome, right? Sharing my screen again.
00:11:32.534 - 00:11:58.850, Speaker A: All right, another thing that's useful is the firewall. Actually, let me double check.
00:11:58.882 - 00:11:59.854, Speaker B: Okay, here we go.
00:12:00.354 - 00:12:38.006, Speaker A: Firewall setup. Firewall. Of course it would be great if you have like a network appliance is actually a firewall that's before it ever hits your machine. But in the absence of that, or maybe in combination with that, it's a good idea to set up a firewall on your machine as well. UFW is a firewall tool that I've seen a lot of people use, but there are others as well. Excuse me, this is just a really basic setup of UFW. But of course there's other options.
00:12:38.006 - 00:12:56.034, Speaker A: You can allow access, excuse me, dying over here. You can allow access for specific ips, you can block ips. Lots of different options here, but another tool that I think useful to have and useful to set up.
00:12:57.254 - 00:12:59.394, Speaker B: Just curious, where did you get 12,000 from?
00:12:59.934 - 00:13:02.154, Speaker A: Just the number I picked, okay.
00:13:02.534 - 00:13:27.412, Speaker B: I mean, there were documents said 10,000, 8000 to 10,000, and that's what I used. And I have no idea if those documents still exist or if they've been updated. I've read a lot of conflicting posts on discord. Some people say, oh, you need to go to 9000. Oh, you only need to go to the range that you set in your valid, you know, validator, command line options or whatever. And I don't know what the right number is. 12,000 seems fine to me.
00:13:27.412 - 00:13:50.234, Speaker B: I think people have had conflicts when they've tried to run other software on other ports. Now, why you're running any software in your validator that would open a port other than the validator and Ssh, I do not know. That seems like a very bad idea. But anyway, that range can be arbitrarily large, but I think needs to be at least to 9000 or 8100. I don't know what the correct ranges, to be honest.
00:13:50.394 - 00:14:12.134, Speaker A: There's a minimum number of ports. I think it was 20. So I think at the minimum you need 8000 to 820 or whatever range 9000 to 920. But I think a lot of people open up more ports than that. But yeah, I don't know. I think this is just a preference. Maybe, Brian, if you have more.
00:14:12.134 - 00:14:15.934, Speaker A: More context there, what you got you set up there?
00:14:17.104 - 00:14:22.724, Speaker C: To be honest, I would have to go. Look, I don't recall off the top of my head.
00:14:23.424 - 00:14:32.032, Speaker B: I think with quic, you have to have at least like a thousand or maybe even two. The old days, maybe 20 ports was enough, but these days it has to be quite a bit more than that.
00:14:32.128 - 00:14:32.720, Speaker A: Okay.
00:14:32.832 - 00:14:44.224, Speaker C: Yeah. We tend to follow the suggested documentation without too many customizations on ports or things like that. Yeah, yeah.
00:14:45.564 - 00:14:53.052, Speaker A: Cool. Yeah, yeah. So this is what I set up. But again, some, can I ask, Sergio.
00:14:53.228 - 00:15:05.544, Speaker B: Said 20 in the chat. I just. If that person is able to describe, do they really mean they only have 20 ports open on UDB and TCP? And it really works even with quic. That surprises me. It might be true.
00:15:07.524 - 00:15:40.290, Speaker A: Let me stop the share real quick. Yeah. So, Sir Sergi, how do you actually say your name? Serge? I just say Sergo because that's your handle. Yeah, in general, Sergei, but normal sergo is fine because it's like combination of my name to name. Great. Yeah. So I think 20 is what's documented.
00:15:40.290 - 00:15:45.454, Speaker A: I don't know for sure if that's actually the minimum anymore with quic, like you mentioned.
00:15:49.954 - 00:16:21.122, Speaker B: Yeah, I think the validator has that thing but I think it's wrong. Like, you can set that, but in fact, it uses more than that. So I think there's some disconnect between the command line options and then value. Like, I think that the actual runtime now, Qwik doesn't even obey that range. So, yeah, it's a little bit confusing. And I think if you said it, I think the best thing is don't run anything on your, on your validator that would ever open a port and then you can open all the ports you want to. You know what I mean? Because open 8000, 10,000, 8000, 20,000, doesn't matter because at that point, there's nothing that's going to open a port anyway.
00:16:21.122 - 00:16:26.170, Speaker B: So, you know, you're really just opening a huge block for the validator. And I think, personally, that's what I do.
00:16:26.282 - 00:16:27.574, Speaker C: That's solid advice.
00:16:29.034 - 00:17:25.286, Speaker A: Yeah, I agree. All right, let me share again. Okay, so we've gone over this before in other validator workshops, but just to reiterate again, every validator that's a voting validator has three keys, the identity key, the vote account key, and the withdrawal key. The identity key is required to run the validator, and it pays fees, typically, although you can have a different fee payer than the identity key if you prefer. I don't see a need for that. For most cases, the vote account key, which is mainly a create at one time, and then it doesn't really have a lot of value after that. It's just to identify what validator to stakeholder, if you're a staker.
00:17:25.286 - 00:18:13.044, Speaker A: And then, of course, the withdrawal key can withdraw funds. It can change the identity, it can change the withdrawer. This key is the one that you should keep very secure. It should never be on the server, obviously. Ideally, you want to make it a cold storage key, hardware, wallet, something where you're very, very sure that no one has access to that but you. So I brought this up because the identity key is actually the thing that's been getting compromised in the recent hack and then in other messages that I received on Discord. And what came out of that, and I think Brian was the one that mentioned it, is that you don't actually have to even put your identity key on the machine if you don't want to.
00:18:13.044 - 00:19:17.216, Speaker A: You could instead do in this next slide, which is to run the validator in a non voting mode and then only put the key on the validator once the binary is running in memory. So it's only in memory, it's not on disk, which makes it more difficult for an attacker to get that key. Of course, the downside to this approach is that automatic restarts are broken. So if whatever happens, let's say the server shuts down for whatever reason, restarts, the restart won't work successfully, and you'll have to intervene manually to fix that issue. So if you have system d set up and the restart happens, the restart won't go as planned, so it increases some operational overhead. But again, the win here is that you don't have to worry about the key getting compromised, or I shouldn't say don't have to worry about it, but it's less of an attack surface. Right.
00:19:17.216 - 00:19:23.804, Speaker A: The key doesn't stay on the file system. So if an attacker were to gain access to the file system, they wouldn't be able to get the key.
00:19:24.384 - 00:20:03.990, Speaker C: Yeah, and that's the biggest risk there. Also, keeping in mind that most of us are running on bare, rented, bare metal, we occasionally give these servers back to the vendors. And if there's not proper security protocols in place for recycling a machine, you could end up with a situation where your key is still sitting there, visible for the next user of that machine. So there's stuff you just don't think about, but the risks are out there. The. This. Yeah, we're doing this now.
00:20:03.990 - 00:20:10.594, Speaker C: It's a good trick. It is a little bit harder to manage, but it just feels a hell of a lot safer than leaving JSON files on a disk.
00:20:10.934 - 00:20:43.896, Speaker A: Yeah. Yeah. So just to kind of back up a sec there, I think there. I wanted to make one point here. Oh, yeah. Another good practice that I sort of glossed over, didn't mention here is that it's always a good idea whether or not you store the key on the file system to keep your funds small. So even if you're not storing on the file system, even if you run it in memory, you still don't want to have 10,000 sol in the identity key, because there's no reason to have it sitting there.
00:20:43.896 - 00:21:12.584, Speaker A: Right. Keep it as small as you're comfortable with to pay voting fees and nothing else. So let's say you're getting enough rewards and sort of at an equilibrium where you can keep maybe two or three soul in the identity key. That that's a good practice instead of keeping a lot there. Yeah. So a little review of the process for setting this up. You want to start your validator using the no voting flag.
00:21:12.584 - 00:21:55.160, Speaker A: So your validator is essentially functioning like an RPC in this case, and you want to as well start with a temporary identity key. It could be any identity key you want. Doesn't really matter. That identity key is going to get swapped out when the validator is up and running because the identity key should have no funds in it. It doesn't matter if you keep it on the server. So you keep that key on the file system, run the validator, and then when the validator is running caught up, you can use the command Solana validator, authorize voter, add and copy and paste in the identity key. Array of bytes, or not bytes, but array of numbers.
00:21:55.160 - 00:21:59.484, Speaker A: Essentially the JSOn contents into the standard input.
00:22:00.624 - 00:22:16.952, Speaker B: You don't have to wait till it's caught up or even close to catching up. It's probably right. The idea you can just do it as soon as you start the validator. The point is that it's not on the file system, but it has to happen after the validator starts. And you probably want it to happen well before you catch up because you don't want to miss missed votes because you didn't get it it in time.
00:22:17.088 - 00:22:18.016, Speaker A: Yeah, that's fair.
00:22:18.160 - 00:23:08.564, Speaker C: Yeah. As soon as it's ready to receive commands through the admin interface. Tim, the thing that we do is we start up in voting mode, but both the validator id and the vote account id are dummies. And so what it means is that there's no soul in the id wallet, so it can't actually vote. Like basically it's ready, but it's broken and there's a bunch of error, you know, errors that get written to the log. We just kind of ignore those. And, and then when you go through, and then when you do the authorized voter and the set identity commands, then, then it just, you know, magically works at that point.
00:23:08.564 - 00:23:19.874, Speaker C: And I'll actually, I'll try to just confirm what I just told you just to make sure I'm not misleading you.
00:23:20.174 - 00:23:23.454, Speaker A: Okay, fair. Is there a reason why you set it up?
00:23:23.494 - 00:23:36.314, Speaker C: Voting is that I think we just found it to be easier and it might just be an operational thing too, that our configs were already set up that way and we didn't want to bus configs for a bunch of machines.
00:23:36.894 - 00:24:14.908, Speaker A: Yeah, it makes sense. Yeah. So, you know, figure out what's right for you. But again, the key takeaway here is that you use a dummy key, start running with that dummy key, and then once the validated process has started, you can switch out the voter sort of in memory without having it on disk. Yeah, that's all I got. Kind of wanted to keep it short today and, and the presentation here. Open it up to questions and thoughts.
00:24:14.908 - 00:24:27.764, Speaker A: I'm curious what the rest of you are doing and sort of where operationally and security wise you've made trade offs. Anybody want to go wrote a program.
00:24:27.844 - 00:24:38.914, Speaker B: To address some of my issues? Yeah, that was my, you know, my solution to some of the problem. But I do keep my, you know, the solution I have does not.
00:24:40.774 - 00:24:41.334, Speaker A: Remove.
00:24:41.414 - 00:25:15.792, Speaker B: The issues that Brian has found to address via the steps of, you know, setting the identity as the validator starts, because I do keep my validator key, info key, you know, identity key on the node. And I just accept that if that thing gets hacked, that's my, that's the only downside is that I have to, you know, reset my identity to a different identity and my authorized voter or whatever. That's, you know, that's the risk I'm taking. But it makes operationally a lot simpler because I don't have to be there, I just have.
00:25:15.848 - 00:25:17.160, Speaker A: Although to be honest with you, it's.
00:25:17.272 - 00:25:38.552, Speaker B: In about the last year, it's never, the validator's really never restarted unattended before the last. Last, you know, last year it used to sometimes crash, especially when I was using GPU enabled, it would crash occasionally. That hasn't happened in a long time. So I probably could accept having to be manually present for every restart, but I just haven't done that yet.
00:25:38.728 - 00:26:03.814, Speaker A: Yeah. Yeah, that's fair. Yeah. I think the bare minimum of having the identity on the machine and nothing else is super important. Right. Like, as long as you're doing that, you're 90% of the battles won. If you keep the amount of funds and the identity small and you do or do not have the identity on the file system but no other keys, then you're most of the way there, or even 100% of the way there, depending on what your setup is.
00:26:03.814 - 00:26:21.054, Speaker A: Yeah. What is the recommended way of restarting a validator with no to minimum downtime? Yeah, I'm curious, is anyone else, do they have a second backup there?
00:26:23.984 - 00:27:15.304, Speaker C: We have a hot backup, but I mean, I'll confess that we really only use that in the case of an emergency if there's an actual problem on the primary machine. I mean, right now if we're doing a software upgrade, to be honest, we'll just restart the node. And it seems like there's so much hassle with switching to the backup machine and then restarting and then switching back, especially for a relatively short period of time. But yeah, if there is a problem on the primary machine, then absolutely. We're going to move and then we'll just leave production on. What used to be the backup server is now the primary server, and then this one is going to be the backup. So a blue green scenario where you're flopping back and forth.
00:27:15.744 - 00:27:54.516, Speaker B: So I have exactly the same situation as Brian Long, and I think that maybe this comes from when you started to be a validator and the tools that were available at that time and the techniques that were common and we're kind of embedded in that. But I think that some new people coming along are doing the good work of finding a better way since they haven't, you know, they're still getting into understanding how to run things, so they're finding the better ways to do things. And I think that having a hot failover is absolutely the best way to do it. My hot failover is in the same data center cabinet, so it's not as good as if it was in another data center. And so I really need to have one in another data center, but that becomes more costly and more complex by far. So I. It's a subject.
00:27:54.516 - 00:28:00.452, Speaker B: It's like I see it in the distance. I just keep avoiding it and looking at stuff. But, yeah, it's the thing we should have.
00:28:00.588 - 00:28:11.080, Speaker A: Yeah. So none of you use the hot backup for upgrades then, if you're upgrading to a new version of the software. Yeah. Interesting.
00:28:11.232 - 00:28:17.960, Speaker C: Yeah, yeah. I totally understand the reason why we should do it, but then there is the, the operational hassle is significant there.
00:28:18.032 - 00:28:28.124, Speaker A: So, yeah, so pumpkin says he upgrades all the time with hot swaps. Anything you want to add? There? Is there sort of best practices that you figured out?
00:28:33.164 - 00:28:46.532, Speaker B: I love it if pumpkin can, I don't know if the docs that are out there are sufficient, but I'd love it if he's having success with it. It would be great to have a really comprehensive and clear write up with all of the rough edges described. That would be awesome.
00:28:46.628 - 00:28:47.264, Speaker A: Yeah.
00:28:48.004 - 00:28:50.024, Speaker C: And a round of applause for pumpkin.
00:28:50.364 - 00:28:51.588, Speaker A: Yeah, good job.
00:28:51.636 - 00:29:23.494, Speaker D: Yeah, I just kind of expanded upon the Michael Vines identity transition demo. I'm basically doing exactly what he said, only I kind of simplified the process because the way he wrote it was kind of theoretical and it was kind of difficult to read and because it was all in the same, it was on the same machine. But yeah, I mean, I could make a write up of what I'm doing. It's actually, it's not that complex to do at all. And, yeah, I can share that.
00:29:24.334 - 00:29:54.554, Speaker B: Yeah, it's great if you would do that. I personally haven't broke the subject because I also want to come up with some strategy to have it happen automatically, like if my validator fails. But that gets really complicated because you don't want them both to be think they're leading at the same time. You have a third system out there that's watching them both and making decisions and trying to coordinate. I was thinking of doing something like having each one just watch for votes landing and having a timeout where the leader says, off, my votes haven't land in five minutes. I'm just done. I'm never going to vote again until I see the backup, you know, start voting and then it goes down.
00:29:54.554 - 00:30:08.898, Speaker B: Then I will start again. And maybe that would cover some cases and it wouldn't require a third piece of management, but it's, it's so complicated that, again, I keep not broaching it because it seems like a very big mountain to climb, and I keep trying to find the smaller hills I can get up in the meantime and not have to.
00:30:09.026 - 00:30:10.210, Speaker A: Yeah, it's easy.
00:30:10.242 - 00:30:24.564, Speaker D: It's easy to get burned, too, because if you hot swap, if you screw up your hot swap, you can trigger the duplicate instance check and then both of your nodes are down. So I think I'm figuring out ways around that, though.
00:30:26.824 - 00:30:38.680, Speaker A: Yeah. Happy to coordinate with you if you've got, you know, even if you just kind of want to meet and describe what you're doing and have me write some stuff up or find a community member that wants to write it up, it would be really valuable, I think, to share.
00:30:38.792 - 00:30:51.530, Speaker D: Yeah, definitely. Especially recently, I've had a lot of concerns and kind of the issues that I did have. I had a chance to talk with Michael Vines about the different issues I encountered, and he kind of ironed those out.
00:30:51.562 - 00:30:52.374, Speaker A: So I think.
00:30:52.754 - 00:30:59.334, Speaker D: I think I have a pretty good idea going forward. Of the Gotchas that you could encounter.
00:30:59.674 - 00:31:19.798, Speaker B: This does intersect with security, because if you had a really good hot swap setup, then you could, theoretically, if you got hacked on your main system yourself, independently of that system, set the identity to a new host and hot swap over to it or something like that, you could like, you know, basically pinch that old one off completely and. And you know, that. And that's a security feature to be.
00:31:19.806 - 00:31:36.054, Speaker A: Able to do that. Yeah. Yeah. Any other thoughts or questions? I've got to leave a little early today, so cutting it kind of short, but good discussion. I think. I definitely want to follow up pumpkin on that.
00:31:36.174 - 00:32:13.664, Speaker B: Doc, you want to put a link to my program. I know it hasn't been audited yet, and no one really uses it. Except I don't know if pumpkin is still using it or not, but it works. I mean, I've been under it for, I don't know, a month or two now, and it works fine. So if you find what I'm doing valuable in terms of the ways that it lets you manage keys a little differently, feel free to use it and give me any feedback and any help I can provide, I'd be happy to do it. Pumpkin pointed out that the command I wrote to do it, the client side of it, is not super well hardened. It'll submit transactions, but if a transaction fails, it doesn't even tell you anything.
00:32:13.664 - 00:32:42.744, Speaker B: So you have to run the thing. If you're going to actually run the program to make a change to your keys or something, you have to go and look at the explorer and see what the result of that transaction was. It's a little bit rough around the edges, but it is secure. That's not a security flaw. It's just that the tool is not as, as foolproof as it could be, the client side of it. But anyway, I'll make a link to it in case anybody wants to talk about it or read about it.
00:32:43.164 - 00:33:34.624, Speaker A: Yeah, I dropped a link in the chat. Like you said, it hasn't been audited yet, but I think this is something that the foundation in general is supportive of. I think Zentetsu, you talked to labs team members, and they sort of said that they want to make this a composable feature rather than change the actual core software. And so this is what you came up with, and I think it's a good approach. So pending an audit, I think it's a good idea. It kind of eliminates that problem that I mentioned briefly earlier, that the withdrawal key does a lot of things right. You don't want it to both be a withdrawal and authorized changer of identities and of withdrawal keys.
00:33:34.624 - 00:34:10.924, Speaker A: Cool. Any other thoughts? Questions? All right, well, thanks, everyone, for coming. I'll have another one of these maybe in a couple weeks or a month, depending on interest and sort of what comes up. But like always, I want to plug that. If you have a topic you want to cover or if you want to lead one of these, that would be really, really awesome. I'm trying to make it so that I'm not the only one actually leading these. So please, please, please get in touch with me and we can schedule something.
00:34:10.924 - 00:34:14.128, Speaker A: But otherwise, thanks, everybody, and I'll see you next time.
00:34:14.256 - 00:34:15.352, Speaker C: Thanks, Tim. See ya.
00:34:15.408 - 00:34:17.904, Speaker A: Thanks. Thanks, everyone.
