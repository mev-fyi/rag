00:00:10.960 - 00:00:44.030, Speaker A: Hello. Okay. Hey, guys. So I'm Elliot, and this is Lucas, and we're two of the on trained developers at Bonfida. And today we're here to talk to you about something we're very much excited about, and it's Bonfida's vision for Serum's future. Essentially, Bonfida and Serum have been linked closely together, basically since Bonfida's inception and release. This partnership has been basically in our DNA from the very start.
00:00:44.030 - 00:01:22.758, Speaker A: And we've built services and we've built applications on Serum's infrastructure. And so we feel that Serum is really a foundational component in the Solana ecosystem, and we really want to establish this fact, and we really want to invest into Serum. And so this is what we came up with. So let's talk about the asset agnostic order book. So let's first go through what Serum is. I think most of you here know what Serum is, but let's remind ourselves for a minute. Serum is a decentralized exchange.
00:01:22.758 - 00:02:37.924, Speaker A: It relies on the central limit order book, and it's really the reason why it's so powerful, so flexible, so revolutionary. It's the first central limit order book decentralized exchange that runs on a blockchain. And this is in part in, well, in large part due to Solana's impressive performance and also due to the quality of serum's engineering. So serum as a market is just a product that we're very much excited about. But the only problem that we see with Serum is that it's a beautiful piece of engineering technology and technology, but it's really wrapped up, and it's really enclosed into a way too specific implementation, because the CRM Dex can only be used to swap Solana program library tokens, so SPL tokens. So in terms of the kind of variety of assets and the kind of variety of applications that you can think of that the serum decks can actually deal with, it's kind of limited. And what we really want is to unleash this technology and to really make it usable by everyone for many different use cases.
00:02:37.924 - 00:03:45.604, Speaker A: And this isn't simply something that we want to do. It's something that we've observed in the world, because other projects have constantly been forking Serum's code base and to create new central limit order book based markets. But this is the kind of approach that we want to move away from. We want to have a common component that can be used by every team to build custom order book based markets, which for basically any asset. And this is where this idea of the asset agnostic order book comes in this vision. This key part of our vision, which is the asset agnostic order book, is really a part of a free, pronged approach to basically split up what makes Serum great into different products. The first product that will be really the cornerstone of this whole thing will be, of course, the asset agnostic order book, which the serum implementation will be called serum core.
00:03:45.604 - 00:05:06.354, Speaker A: On top of that, you'll have what's nowadays, the serum decentralized exchange, Serum Dex, which will be built, which is already actually built on the agnostic order book pending release, and the final component, which is something that is still kind of in the design process, but we're gradually having more and more of an idea of what it will look like. The final component is the serum network, because as builders ourselves of smart contracts on chain, one of the things that comes up every time, almost every time, when building complex smart contracts is the fact that there's always some kind of cranking mechanism, there's always some kind of operation that needs to be run on a schedule in order for the smart contract to perform normally. And since Serum has really been in the game of running production production level, well, basically running complex smart contracts in production since basically the beginning, what we want is to leverage Serum's network of cranking servers and enable developers to just leverage this computing power, this availability reliability, to abstract away this need for basically running your own crankers.
00:05:09.574 - 00:05:51.874, Speaker B: Yes. So I'll be giving you a quick overview of how the agnostic asset agnostic order book works. And what we saw at Bonfida was the main structure, the main framework that was useful in the old serum version, and that we wanted to extract into a new module, into this new serum core. So mainly I'll be going over what we saw is an order book. For us, an order book is like a framework that matches, that allows for storing and matching of orders. And orders have to be represented only by a quantity and a price, essentially. It does not need to be a specific asset, it does not need to be a specific token or anything.
00:05:51.874 - 00:06:59.216, Speaker B: It can be any kind of contract derivative, any kind of thing that you would want to exchange that is quantizable and that you can set a price on. So this is how you then can represent this abstract order book, where you have, when you want to sell or buy the bids, or asks with a different price every time, and the different orders. Of course, there will always be a spread, because if an order crosses the spread, it will be matched with another order from the other side and be then filled so, to further explain how the asset agnostic order book actually works, we'll be going through the different inputs that are given to the program in our program. So there are the quantities, as I said, the limit price. The thing is that you cannot have only one quantity because you could be filled on each kind of assets actually on the base or on the quote. So, so you need to set a certain limit on the quantity. You want to be matched on both of these assets.
00:06:59.216 - 00:07:55.804, Speaker B: Then there's the price, of course, the side, which is natural. And then we added there's also the parameter of match limit, which is important for developers that will be developing the caller programs, what we call the caller programs. It's like when you want to use the asset agnostic orderbook, you are developing a caller program that will be using it with cross programming invocations. And the match limit lets you calibrate actually performance of the asset agnostic order book because it lets you set how deep you want to go into the search of the order book when you want to match different orders. If you would, for example, set a gigantic order, you'd be matching all of the order book. And this is why you have to limit it in a way. Then there's the callback info, which is an important piece of the data structure that lets you the asset agnostic order book communicates some information with the caller program that Ilyat will be getting into later.
00:07:55.804 - 00:09:16.268, Speaker B: And then there are post only and post allowed inputs which let you kind of shape the trade behavior of your order. With this you can implement, fill or kill, immediate or cancel or limit kind of orders. And then the self trait behavior, which is a bit self explanatory also, which is how the order will trade if you match with your own order actually as a user in the order book. Going further, there's a first way of how the asset agnostic order book can actually communicate with the caller program, that is with the order summary structure. This order summary is information that the asset agnostic order book will write into the event queue, which is a structure I'll be getting into later, and that the caller program can then use read during the new order instruction, actually just after the CPI call to do some early business logic, to do some early locking of assets or transfer of assets and stuff like that. That is there to be more efficient and have a better to be more efficient. Essentially, in this order summary, you have a unique order identification number.
00:09:16.268 - 00:10:12.884, Speaker B: And also what happened during this early matching during the new order instruction, that is the total base quantity. The total base quantity posted, and hence the total quantity that was matched, which is a subtraction of both. And this whole thing is then stored in the event queue to be read by the caller program. And the event queue is something I want to get into also, because it's quite important to understand why it exists and what role it plays in the asset diagnostic order book. The event queue also exists in the older serum version, and it exists because of one fundamental limitation of the Solana runtime. The Solana runtime has limitation that you cannot dynamically call, read, or modificate any accounts within an instruction. You need to know beforehand what kind of accounts you will be passing through and using.
00:10:12.884 - 00:11:27.054, Speaker B: That means that if you have an order book like before, and you want to match certain orders, you don't know exactly which order you are going to match, so you don't know which users you are going to match, and you can't put them into the instruction beforehand. This is where you need some kind of buffer, which is the event queue, which will take some of the results of the new order instruction, store them in a circular buffer where you can then process them later and have the caller program act on these events, but with the appropriate accounts, with the maker account. For example, if an order was matched, and yes, this is why this structure exists. In this structure, there are two kinds of events that can be inserted. There's either fill, which is an event that corresponds to a match between two orders, an exchange of two assets with some relevant information about the orders, but also the callback info, which Elliott will be explaining later. And then there's also the event out type, which corresponds to a deletion of the order book from the order book. That could be like when an order is completely matched, or when an order is canceled, for example.
00:11:27.054 - 00:11:32.574, Speaker B: Yes, in this kind of scenario, and I think yes, that's for you.
00:11:32.954 - 00:12:18.140, Speaker A: The final kind of implementation detail that you want to talk about. Well, not implementation detail, but usage detail. That's very important for developers is this idea of callback information. If you look at the whole system, essentially the entry to your interaction with the asset agnostic order book is the new order instruction. But the end of this flow only happens at the consume events end. So you have in some way to transmit some information through that cycle, even though the beginning and the end of the cycle can happen at very different times and in very different transactions and in basically different contexts all the way. So this is why you have callback information in practice.
00:12:18.140 - 00:13:29.304, Speaker A: It's more often than not something very simple. It's probably a public key of a user account or a public key that, that tells you what user you're talking about. And it's basically the kind of information that you want to transmit to yourself at the consume events side of the processing cycle basically. So it's a very simple idea, but it's also very key in implementation because you define this once and then you have to roll with it because it's a fixed size vector and it's going to, and it's determined when you create the first instance of the asset agnostic order book. But of course there will be more documentation for this once the code is released and we'll have great documentation for this. But this is really what makes the asset agnostic order book really asset agnostic, this really abstract way of transmitting information. So the final thing that we're going to walk through really quickly is how you would actually implement CRM Dex using those very simple primitives.
00:13:29.304 - 00:14:27.890, Speaker A: So the first thing we have is the callback info. And so in the case of serum decks, the only thing you want is the user account, right? Because you want to identify the matching parties when you're performing a fill, for instance. But you also want to know the feed tier of each user because depending on their feed tier, your business logic will deduct a different amount of fees. So this is something that you actually have to transmit through the order book. If we look at new order, it's also very simple. And one thing that you can do with the Dex and that you can't necessarily do with all different kinds of markets is you can add a bit of preemptive logic. The idea is that even though the processing cycle isn't completely finished, even though you're not at the consumer event side of the, of processing, you can still know at new Order the quantity of assets you've actually been matched with.
00:14:27.890 - 00:14:29.774, Speaker A: So you can kind of predict.
00:14:31.794 - 00:14:32.082, Speaker B: You.
00:14:32.098 - 00:15:34.198, Speaker A: Can predict the taker volume basically for any order and perform all transfers immediately. So you have this shortcut mechanism which allows the asset diagnostic order book to be compatible with instantaneous operations on the taker side. And the final thing I'm going to really talk about is the fact that you can really build other stuff on the asset agnostic order book. And the first thing we did once we had the asset agnostic order book ready was to build a perpetual futures market based on the asset agnostic order book. Even though right now it's not released, it should be released pretty soon would be my guess. We built a perpetual futures market in a matter of weeks. Whereas when confronted with the same problem a few months ago, it took us a lot more time and we actually had to implement a virtual automated market maker instead of having an order book.
00:15:34.198 - 00:16:45.238, Speaker A: And as we soon found out, and as was very clear, the order book is a superior solution because it allows for basically very flexible market making strategies. And it's impossible to front run an order book in the same way that you could front run an automated market maker. So we're all very, very excited about this perspective of enabling people to really take the best technology around, to really take the best of what CRM has to offer, which is really, it's very powerful. Matching engine is a very powerful order book, enabling teams to build their visions with basically the best tech. Right. Because we've stocked, this is a real need we've identified in the community because we've talked to financial people, basically to people, financially minded people who have all these amazing concepts for very exotic derivative products. But the barrier of entry is just so high right now, because if you want to build an order book right now, you need to really get into it and really have some experienced, well, Solana contract developers, right, but the promise of the asset agnostic order book is to really open up the gates.
00:16:45.238 - 00:17:36.422, Speaker A: Right? Anyone can build pretty much any derivative products on the same technology, and then we'll all share the kind of analysis tools and all, well, all kinds of, you can imagine all kinds of sharing of technology. So I think, yeah. So I'm going to provide you with a few useful links here. Of course, feel free to reach out to us on the bond feed at Discord, on Telegram as well, or even on GitHub. Or you could also try and reach us on the Bonfida messaging app, which is an end to end encrypted app, which basically works entirely on chain using Solana, of course. And we actually have an App Store app ready right now. If you want to download it.
00:17:36.422 - 00:18:07.548, Speaker A: You can reach us at, well, you can reach me at Elliot Sol and you can reach him at lcchy Sol there. We'll be glad to answer any of your questions anywhere, not just on the Bonfil messaging service, but if you reach out to us on the bonfide messaging service, we'll also be glad to kind of nerd out with you on the fact that we're communicating entirely trustlessly and just really on the blockchain with each other. Well, we've been very glad to be here. Thanks for your time and I hope you get to build amazing things with these things.
00:18:07.596 - 00:18:08.124, Speaker B: Thank you very much.
