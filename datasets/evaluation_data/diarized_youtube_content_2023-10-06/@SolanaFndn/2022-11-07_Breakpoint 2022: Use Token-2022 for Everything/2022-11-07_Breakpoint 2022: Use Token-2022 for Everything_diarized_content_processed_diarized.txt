00:00:03.120 - 00:00:54.280, Speaker A: So I'm John, as I was saying, one of the engineers at Solana Labs, for the most part working on the Solana program library. So if you've looked at that repo, if you've looked at some of the reference implementations like token swap or stake pools or. I helped a little bit with governance sort of going around that side of the world. So I'm going to go through this essentially saying, like why we're doing this. I'm going to talk about what the extensions are in the new token program, and then I'm going to try and do this through a frequently asked questions thing, because I've had this conversation with a lot of different people. So I'm going to assume that you, the audience, is sort of someone who has a vague idea of what this is and is going to ask me questions about it. And sometimes this audience person is a little passive aggressive with their questions, and that happens.
00:00:54.280 - 00:01:38.044, Speaker A: I've gotten a lot of passive aggressive questions about this. All right, so why? You all know SPL token, it works, it's battle tested. It has been through so many audits, a lot of security has been, a lot of time has been spent making it secure. But we really need some more stuff on it. We need more protocol level functionality in order to actually do cool stuff with these tokens, all without causing any problems with the existing millions of tokens that exist on the system. So we're going to write and deploy a new and separate token program in 2022. So that's why it's called Token 2022.
00:01:38.044 - 00:02:37.762, Speaker A: And then usually the first question I get is like, John, are you really sure you want to do this? I literally got this question yesterday and two days ago, like, are you really sure you want to make a new token program? Because adopting a new token program is going to be tricky, but I think it's going to be really good. A lot of people want to add new functionality to token programs, and the way they've had to do it now is through composability. You add another program on top of the token program that does certain things, it's limiting in the end. And so what we think is that right now everyone assumes just one token program everywhere. Great. If we now have two token programs, then you sort of have to re architect everything into imagining, okay, there might be one, there might be two, and then at that point, if anyone wants to add another token program, I think it's going to end up being a lot easier. I get this a lot.
00:02:37.762 - 00:03:02.206, Speaker A: I don't like the name, and it's almost 2023. It's not a question. Maybe we'll rename it, but I do get that a lot. We started this in token at the start of 2022. So yeah, projects are long, maybe we'll rename it and then others like oh, what about Token 2023? People are just going to get confused. Yeah, they probably will. So we'll come up with better names later then.
00:03:02.206 - 00:03:35.682, Speaker A: A lot of times people still don't agree with me. So the one know how this works. So token 22 is a superset of SPL token. So that means that the structures and the instructions have for the most part the same exact ABI. Eventually you opt into new functionality through what we call extensions. And if you want to know about like how we encode them, like I think it's super cool. We, the person who designed it used to work a little bit more in telephony, came up with this really cool way in order for us to store variable data at the end.
00:03:35.682 - 00:04:22.042, Speaker A: We can nerd out on that later, but just to talk about it, generally all new data is written after the 165th byte. This is very important. 165 bytes is the size of a token account. So the idea is everything is written after that. So if you've got a mint, which is normally 82 bytes, we write out different bits into it, and then we'll have to add some padding and then all of the new stuff is written. So it's a way to make it easier for us to figure out like is this a mint or is it not? Because otherwise you could probably create some rugs. Then the next part is people say, well, can I even use this? And I always say yes, it has been deployed to mainnet since Anatoly forced me to do it in the summer.
00:04:22.042 - 00:04:47.100, Speaker A: It was like in the early summer. So really all you can do is get token accounts by owner and you literally just pass in another program id. And it works. I swear, I swear that it works. And then if you're using JavaScript, the SPL token package, if you're using anything greater than version 0.3, will have token 22 support, and then the CLI starting with version 2.1 will have it.
00:04:47.100 - 00:05:21.660, Speaker A: It's not released yet because circular dependencies suck. We spend so many hours trying to sort it all out. We're almost there, but we'll be able to get the CLI out soonish. And the next thing people ask me is like awesome, is this even safe to use? Mostly yes. So there's four audits done, we want to get one more done for some new functionality that we're adding in the next couple of weeks. So this means that the program is currently upgradable. We're hoping to freeze it before the end of the year.
00:05:21.660 - 00:05:51.094, Speaker A: So that way it can really be token 22. Absolutely. Like time boxed in a year. So if you were to look at it, it's under this really fun program id, which is token z. We got this pub key, we were really happy about it. It's like tokens, it's like the next generation, it's the Gen Z token and it's right now the program upgrade authority is this three URRP, which to me just sounds like Burp. I thought that was a pretty funny thing, so I wanted to share it with you all.
00:05:51.094 - 00:06:19.106, Speaker A: So maybe you're thinking to yourself like okay, another token program. What does this mean? What are the knock on effects? You might be thinking oh God, please not another associated token account program. Don't worry, you're safe. We did this all for you. We deployed it during the summer. You're all good. So the one associated token account program works with token 22 and even adds immutable ownership.
00:06:19.106 - 00:06:48.206, Speaker A: So you can simply, this already works. You can do this on all networks, create your token 22 account mint, it's all there. So at this point you might be thinking immutable ownership now that's cool. I know. So there's a lot of extensions that we've added, one of them being immutable ownership. And then you might say like all right, tell me about some of these other extensions. And typically when people ask me this question, I can't remember them all off the top of my head.
00:06:48.206 - 00:07:08.394, Speaker A: So I'm really happy. There's a screen that gives it to all to me. So you can use it for confidential transfers. This is a really big feature that's been worked on, pooh boy for a long time. We'll get more into that later. You can also add a CPI guard. This is a new one that we recently added.
00:07:08.394 - 00:07:33.554, Speaker A: We'll be able to talk about it a bit more later. You can add memo requirements on transfers. So this way people have to add a memo if they're going to transfer into your account. And then there's immutable ownership. And then when we're talking about mints, there's quite a few extensions for those. So again, it's confidential transfers. It has to get enabled on the mint first before you can use it in your account.
00:07:33.554 - 00:08:05.274, Speaker A: You can also add transfer fees, you can close your mints, you can add interest to your token, you can make it non transferable, you can give a default account state and a permanent delegation. I'm just going through the list now so that you all have it. We'll do something more interesting to learn a bit more about this, because you might be thinking, that's a lot. You all have been working really hard. Of course we have. You might not understand what they're for, so we're going to do this with a game. Game.
00:08:05.274 - 00:08:36.058, Speaker A: What I'll do is I was trying to think about this in terms of jeopardy context, but then it didn't super work out. But the idea is I'll describe a token design, give you like a moment to think about it. But you probably don't know all these extensions yet. I know all the top of my head. Give you a moment to think about how to do it and then I'll explain how you would make this work with a live demo. Well, live ish, it's on my computer. All right, so you might be thinking to yourself, I just saw this awesome presentation about compressed nfts.
00:08:36.058 - 00:09:26.494, Speaker A: How can I make a token that can be compressed, decompressed and recompressed with an off chain merkle tree? And the answer there is, you use the close mint authority extension. So this way, as soon as the supply of the token is zero, you can close it just like a normal token account. So I will give a quick demo of how that would look with one hand. So yeah, I just, I made shell scripts because I do not trust my typing when there are people looking. So we're going to run through this. So pretty much very simply, what happened, if I can do this with one hand. So what happened over here? We created a mint with this enable close flag.
00:09:26.494 - 00:10:08.024, Speaker A: Important thing, you have to create it with token 22 because the normal token keg program will not be able to support this. And then I closed the mint right over here, and then I recreated it over here, so the whole thing got closed and recreated. So this one's pretty simple. Big fan of it. All right, so next you might be thinking, I want to send a token without anyone knowing how much I have or how much I transferred. This one's pretty easy. The answer is you have the confidential transfer extension.
00:10:08.024 - 00:10:51.058, Speaker A: So a lot of people have asked about this. I think it's probably one of the coolest features that we have worked on. There's even like a patent for it, I believe, and a really, really good white paper. So the basic concept is, I'm not a cryptographer, I also didn't work on this, so don't worry the basic concept is you deposit tokens from your public account as a ciphertext into the sort of confidential part of your account, into the extension, and then from there you can transfer tokens around and all the amounts are masked. So it's just amounts that are masked. This is a bit of a misconception. A lot of times people think like, oh, we're doing anonymous transfers.
00:10:51.058 - 00:11:35.674, Speaker A: This is not anonymous transfers, it is confidential. So this way I send money to you, people will see that I transacted with you, but they won't see the amounts. So this means that when you first do that deposit, people will know, like, oh, they deposited 100 tokens into their account confidentially, so they'll know that you have at least 100. The idea being is that over time, as people use this, it gets mixed around and you won't be able to know how much people have. There isn't a demo for this one because I wasn't sure how to get my validator set up for it because we need larger transaction sizes, which the next project, I'm really excited to do it. It's something that requires Qwik. So we were really happy that quic was going to be added to the network so that we can have larger transaction sizes.
00:11:35.674 - 00:12:20.664, Speaker A: All right, another one. So if you're someone who runs a stake pool or a lending protocol, you may have some lp tokens and you want them to go up in value over time, like some sort of a rebasing token. So this is another pretty easy one. You create the mint with the interest bearing extension, and then a pretty fun one, you could have your protocol update the sort of perceived interest rate every epoch. So you just create your token with the interest rate and then it works. So I'll do a quick demo on this one. Okay, so here.
00:12:20.664 - 00:13:12.804, Speaker A: Okay, so if we go up, we'll see that we're creating the mint with this interest rate. I gave a really big number creating an account for it, mincing some tokens into it, and then. So unfortunately, not everything is using the new amount to UI amount instruction. Essentially this all works through a UI trick, so we pretty much assume an interest rate. The actual amount of tokens isn't changing, but the sort of UI amount is. This is how a lot of these sort of rebasing tokens work on other networks. So we're hoping that a lending protocol or perhaps a stake pool will like to be able to use this, but then you can reset the interest rate to anything else that you want.
00:13:12.804 - 00:13:58.268, Speaker A: Okay, another use case. So if you're creating a bank like payment system, you want to create monthly statements for your clients and you also don't want them to get rugged by sketchy protocols. So what do you do? You can enforce that. All client token accounts require memos when funds are coming in. The idea being is that you could then sort of look through. If you're talking about any popular payment provider, typically you add in a little bit of a memo, or even if you're using your bank, you add a memo before you do a transfer. And then the other one is if you want to add the CPI guard extension.
00:13:58.268 - 00:14:31.534, Speaker A: This way Dap transfers must go through a delegate. This is a really, really cool feature. The concept being that if you add the CPI guard extension and then you sign a transaction to some sort of a sketchy dapp, they literally cannot move funds. If you signed it yourself. You must approve a delegate and sign with that delegate in order for the transfer to go through this dap. And then it also adds a bunch of other niceties. It's a pretty fun one.
00:14:31.534 - 00:15:12.702, Speaker A: So I'll do a quick one quick demo on this one. Okay, this one takes a little longer. Okay, so if we go up, we're just creating tokens at first, so that's not such a big one. And then where did it go? So on the recipients we're going to use this, enable required transfer memos on it. And then when I try and transfer without a memo, it'll fail. Please provide a memo. And then I provide a memo of find memo and then it goes through.
00:15:12.702 - 00:16:08.744, Speaker A: So this way if you're trying to create some sort of a robust client facing payment system, you can do that. And then the CPI guard is an extra little thing so that this person could interact with all sorts of sketchy dapps and there's a much lower chance that they'll get rugged, or at least the amount that they can get stolen is limited by how much you delegate or how much you approve. Okay, this one's cool. So if you're developing a game and you only want players to hold your token, maybe transfer it between each other without being able to dump it on an exchange. So this you could do with the default account state extension with the frozen, making it frozen. So the idea being is that anytime someone creates a token account with this mint, it'll just be frozen. This way you can create a small network of people that are allowed to use this token.
00:16:08.744 - 00:16:49.612, Speaker A: And then if you wanted, when unfreezing people's accounts, you make sure that has immutable ownership. And that way any sort of player can't just give the token account to an exchange, thereby completely obviating what you're trying to do. So this one's pretty simple to work with. So here, if you see we're creating our mint up here with the default accounts data frozen, then we're creating an account. And then if I check the account, you'll see that the state is frozen. Nothing was done to it. We didn't have to do anything else.
00:16:49.612 - 00:17:21.154, Speaker A: It just starts off frozen. So think about creating closed networks of tokens or permission tokens could be created with this. This way, not just anybody can have a token account for your mint. Okay, this one's also really cool. If you're running a DAO or something, you want to create some sort of a privilege token for your council members. Since they are council members, your DAO has given them special authority. You don't want them to be able to move or sell their tokens.
00:17:21.154 - 00:17:54.654, Speaker A: And then eventually you might want the DAO to be able to take that token back. So if you find out one of your council members is doing something sketchy, you want to revoke their ownership. The way you would do this now is going to be really difficult. You have to go through some sort of a delegate or something. It kind of stinks. So the way you would do this is you create a mint with two different extensions. So one is you have a permanent delegation to the DAO, which means that it could burn anything on the network, anything on that mint, and then you make the token non transferable.
00:17:54.654 - 00:18:19.046, Speaker A: So this way a member can't just give it over to their friend or something like that. And what's cool is if you have the non transferable part, immutable ownership is required in order to make that work. And you could do this in other ways, right? This is just one model. Perhaps you use the default account state extension instead. So this way all the accounts are frozen. You only unfreeze accounts for your council members. That's another option.
00:18:19.046 - 00:19:05.214, Speaker A: One of the big things about this is we really want to give full flexibility for people to design the token that is going to be best for their use case. And I don't have a demo for that because I didn't finish the CLI, but it's there, I swear. So you might already be thinking to yourself like, okay, this is all really cool, but I already have a token. Is there any way to migrate over to token 22? Of course there is. So you can create a new mint and then use this new SPL token upgrade program. This is a stateless protocol that we designed to be like, as simple as possible. The idea being that you mint a bunch of new tokens to some sort of a bag, an escrow, whatever you want, and then this protocol will burn the old tokens and receive new ones.
00:19:05.214 - 00:19:45.672, Speaker A: So I'll give a quick demo for this one. This one also takes a little longer. Okay, cool. So, all right, so, yeah, there's a little bit of setup because you have to, like, create the new mint. Up here is at the top, the old mints created a little bit higher than that. Create an account, mint some tokens into it, create the new account to receive the tokens, and then over here, we create a special escrow. It doesn't need to be a special escrow.
00:19:45.672 - 00:20:21.724, Speaker A: Literally any token account that is owned or even delegated to the, the escrow authority can work for this. Again, stateless protocol. We wanted to make this as flexible as possible if you wanted to migrate. So I mint a bunch into the escrow, and then I exchange my old tokens for my new tokens over here in the SPL token upgrade ClI. Then you'll see I got my new tokens at the end, so that's a pretty cool one, too. And what's pretty cool is you can do this between any two mints that you want. You can do this migration path.
00:20:21.724 - 00:20:54.170, Speaker A: So after I talked about this, you're like, yeah, okay, cool, awesome. I don't want to burn tokens, though. And you know what, that's fine. We're creating a new token wrap program that allows you to wrap tokens between any two mints. This is still work in progress. We're really at the proposal stage with it, but, you know, we're building out the functionality bit by bit. So what you do is you create a wrapper mint on the old token, and then what you do is you send the old token into a bag controlled by the program, and on the other side, it will mint you the wrapped token.
00:20:54.170 - 00:21:22.380, Speaker A: So it's sort of just like a bridge, the way that, like, wormhole works, things like that. But it would be all on Solana. We're going to add some other bits in order to make it more usable for NFTs, in order to give a back pointer to what is like the mint that you're wrapping. But that's sort of the idea. We think that probably wrapping tokens is going to be the big way forward for most people, you know, we'll see. Okay. There's a lot of different use cases, so we have to keep going through this.
00:21:22.380 - 00:21:59.156, Speaker A: If you're someone who has an on chain program and you want to add support for token 22, how would you do that? First of all, I think that's awesome. If you want to add support, talk to me. I'm happy to help you figure out how to do it. In general, if you're only using one token at a time, the upgrade process is extremely easy. So, for example, if you're a stake pool, in which case you're working with Sol and you're working with one SPL token, you're fine. If you're an NFT project, you're probably also fine if you're using multiple token programs at once for like trading. That's when it gets trickier.
00:21:59.156 - 00:22:48.732, Speaker A: So I went through the whole painful process of upgrading the AMm, the token swap, to work with both Token and token 22 at the same time, which means you could trade one for the other. It wasn't really easy, but I did it and I documented the whole thing. So this way, if this is something you're thinking about doing, you can read through all of the docs. It goes through step by step in a test driven development way, which is, I guess, better in order to add that support. And then you might be thinking, well, I have a wallet, how am I going to work with Token 22? Nice, awesome. We want more wallets to support it. We're still working on the docs, but pretty much it should big word just boil down to getting another set of accounts.
00:22:48.732 - 00:23:17.434, Speaker A: Right now you just get the token accounts by the wallet address and implicitly you're passing in the token program id. So now you would also get them for token 22. And then eventually, if you're doing a transfer, you literally just need to change that last parameter to token 22. That's really it. At this point you might be overwhelmed. That's fine, we're done. So thank you.
00:23:17.434 - 00:23:47.662, Speaker A: We got a bunch of links over here. I'll probably be adding these to the token 22 documentation, so that this way you have all the different possibilities and how you want to use them. And the CLI examples that I'm using will also be added to the docs. So thank you very much for listening. I think we've got five minutes. I don't know if that's enough time to do questions. No one's stopping me.
00:23:47.662 - 00:23:52.834, Speaker A: So we've got five minutes. If you want to ask any questions, please use a microphone. I'm happy to answer anything.
00:24:00.494 - 00:24:25.514, Speaker B: Hello. So in the first token program, there were a lot of vulnerabilities that came about because of the delegate functionality. Do you remember that? The delegate functionality, right, yeah. So a lot of user error kind of came about that. So in the new token program, this sounds like that times a million, right? You've got all these different features, so much capacity for user error. What are you doing to reduce that?
00:24:26.214 - 00:24:29.606, Speaker A: So how do we reduce user error with Token 22?
00:24:29.710 - 00:24:54.538, Speaker B: Yeah, given the context that the delegate authority functionality led to a lot of vulnerabilities when people were using the original SPL token program because they didn't realize it was there. And so people would like, you wouldn't check that the delegate hadn't been assigned and so someone would maliciously assign their own delegate authority, you know, assign a token account and then steal all their money, which is quite common thing.
00:24:54.666 - 00:25:17.298, Speaker A: Yeah, so the way that, so the CPI guard actually covers for that also, the idea being that you cannot do an approval inside a CPI. So the only way that you would get rugged is if you don't look at the transaction and you don't see that at the top level it's doing an approval. So this way you have to approve at the top level. You cannot approve in a CPI. That's what the CPI guard is trying to do, among other things.
00:25:17.386 - 00:25:26.290, Speaker B: But that's just one feature. So I mean for all of the different features, is there like an easy way to check that all the features are turned off or these kind of things?
00:25:26.442 - 00:25:51.514, Speaker A: Yeah, it depends on the extensions that, oh yes. So if you want to target different extensions that, for example, if you don't want the mint to be closed, you can just check that pretty easily in your on chain program. The idea is we've got like, we did some fun little metaprogramming stuff in order to make it work. So you just like say get extension for that type and if it works, that means it's there. If it doesn't work, then it's not. So you might, you will have to add different checks if you want to prevent certain extensions from being enabled.
00:25:52.014 - 00:25:53.302, Speaker B: Yeah, yeah, definitely.
00:25:53.438 - 00:25:54.634, Speaker A: Okay, cool.
00:25:56.994 - 00:26:20.146, Speaker C: Hey, how's it going? You mentioned there's like a new get token accounts by owner for the new token program. They'll be indexed by all RPCs. Does that mean you expect like all wallets and Dapps to do two network calls to get all token accounts if they need to support both? Or do you think that RPCs will support a unified index on those two programs?
00:26:20.330 - 00:26:39.222, Speaker A: Yeah, that's a good question. We're not planning on doing that for now. The idea being is you do one call and you do the other. So this way it's thing an extra call if you want to get all their token accounts. Unifying them is going to be kind of gross and tricky, but we can be flexible. We'll see. I mean, I think the idea would be if you want to do that, use a geyser plugin, put it in a different database and query that.
00:26:39.222 - 00:26:42.078, Speaker A: That would be my, my case.
00:26:42.206 - 00:26:43.230, Speaker C: Got it. Makes sense.
00:26:43.342 - 00:26:48.166, Speaker A: Yeah. Got another two minutes? Yeah.
00:26:48.190 - 00:26:49.254, Speaker C: Another question.
00:26:49.374 - 00:26:50.566, Speaker A: It sure hit me.
00:26:50.750 - 00:27:03.120, Speaker C: For getting extensions, are those all built into the mint and token accounts, like at the end of the account data, or are they separate accounts? In other words, like can you get all the extensions and look at them without another network call?
00:27:03.272 - 00:27:05.864, Speaker A: Sorry, I missed that last part. You get all the extensions in one.
00:27:05.944 - 00:27:13.056, Speaker C: In other words, can you get all the extensions and check which ones are active without an additional network call to an existing RPC?
00:27:13.240 - 00:27:21.736, Speaker A: Oh no. So the way when you get your token account, all the extensions, if you do like get account, that's the full data, and then if you parse it, the extensions are there. So yeah, that's just one call.
00:27:21.800 - 00:27:22.844, Speaker C: Got it? Yeah, double the.
00:27:22.944 - 00:27:57.124, Speaker A: Thanks. Yeah, sure. Hey, congrats on the talk. It's really, really cool. Small question with regards to zero downtime migrations is the right approach to use the wrapping system for what type of migration? Say that again. Zero downtime. So if you're like a wallet or an exchange or so, well, especially if you're a wallet, like, how would you do that with zero downtime? Zero downtime to who? To, I guess the token in a certain sense, yeah.
00:27:57.124 - 00:28:15.080, Speaker A: So that's, I think it's an open question. Probably what you'd want to do is wrap them. So this way the tokens always exist somewhere. You can always. So if a program only supports token, that's fine. You wrap token 22 into token, use it there, and then get out whenever you need to. That would probably be the best way.
00:28:15.080 - 00:28:35.440, Speaker A: Have them both wrapped. Thank you. All right, I don't know if we have time for one more. I don't know if I'm going to get booted. Okay, I'm going to be over there or I'll be in the back. If you have any questions about this other use cases, please feel free to get in touch. I'd be happy to talk through anything otherwise.
00:28:35.440 - 00:28:38.264, Speaker A: Thank you very much for listening. I really appreciate your time. Thank you.
