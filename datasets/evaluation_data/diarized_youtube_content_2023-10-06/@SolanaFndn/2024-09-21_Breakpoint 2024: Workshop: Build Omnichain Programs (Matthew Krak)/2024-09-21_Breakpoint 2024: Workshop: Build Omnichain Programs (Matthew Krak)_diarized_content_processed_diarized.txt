00:00:05.040 - 00:00:28.771, Speaker A: What's up, Solana Breakpoint. How are you guys doing? That was pretty weak. How are we doing? There we go. I'm going to try and keep this a little bit high energy. I know you guys have sat through and listened to a lot of really interesting presentations, so without further ado, we can hopefully jump into a couple more. Today I'll be talking to you a little bit more about what LayerZeroLabs is. If you guys aren't familiar, Layer Zero Labs is an omnichain interoperability protocol.
00:00:28.771 - 00:01:26.791, Speaker A: What does that actually mean, though, for you app developers? Layer 0 is basically a way for you to permissionlessly interact with any chain that we support. Currently at the moment, we're live on 80 plus different EVM networks and we launched recently live on Solana as of two months ago. And with Layer zero, one of the things that we're really interested in seeing you guys build out and work on is new novel use cases for interoperability. One of the big selling points that Layer 0 has over other interoperability solutions is that you're able to configure not only the type of validator set that you use for verifying messages between chains, but also configure the size and scope of those validators. Currently, layer 0 has what's called a decentralized verifier network system, where as an app developer, you essentially have control over your own channel between point A and point B of your network. The way that this fundamentally works is pretty interesting. You're able to basically configure any type of these verifier networks that are currently live today.
00:01:26.791 - 00:02:38.131, Speaker A: At the moment, there are 30 plus different verifier networks to choose from. Currently some of the popular ones are Polyhedra, a ZK Light client, Layer zero Labs, Google Cloud, nethermind, and a bunch more that are currently being activated and unlocked on Solana today. And really the main benefit that you guys are going to be able to activate from this as an application developer is the ability to say, I'm not forced to accept a one size fits all model for my application security. I'm actually able to control and parameterize what type of security I need on a per pathway basis. What that means is there are no more examples where I subscribe and put my trust into one monolithic verifier network, and that verifier network fails and outright destroys not only your application due to invalid message delivery. That's malicious, but it no longer means that every application has to subscribe to a single verifier network. Ultimately, for us, what that means is that you're able to not only unlock more and more use cases for not only bridging, because it's able to be customized based on your own use case, but then it also leads to you being able to activate much, much more execution and overall environment changes for you.
00:02:38.131 - 00:04:14.377, Speaker A: As the app developer, one of the big things I was going to talk about here, regardless of the slides or not, was basically going through kind of understanding where we've gone from bridge infrastructure from 0 to 1. As some of you may be familiar with, the way that bridge infrastructure historically worked as an app developer was that whenever I wanted to move to a new chain, I had to figure out a very complex problem. And that problem was how am I able to not only send messages from chain A to chain B, but also be able to not only ensure that the validity of that message was maintained in a cross chain environment. When I say validity of a message, what I mean is that you need to be able to send not only whatever your input state changes are on a source blockchain, say Solana, but then ensure that that state change that has occurred is then transmitted correctly to the destination. Historically, the way that this worked was that you would have some type of bridge security, whether that was a centralized provider or that was a single network collection of signers, or even a middle chain bridge that would basically validate that this message delivery occurred on the source blockchain network and then deliver that message through to the destination chain. One major problem with this type of approach though, was that what happens when that validation fails, whether there's a back door into the signer clients that you have, where the centralized entity turns on you, or whether the relaying between a middle chain bridge just simply doesn't have enough node diversity. The major issues that could occur from your centralized or validator set failing was that suddenly that attacker could take advantage of everything on the destination chain.
00:04:14.377 - 00:05:04.863, Speaker A: If you're able to pass any type of message through as valid, with no security checks on who can pass that message, it means that you're now fundamentally hurting not only the application that subscribes to that validation network, you're hurting every single type of transfer that's happening between point A and point B. Historically, this has accounted for around four out of the five largest bridge hacks and losses of monetary value in blockchain history. Overall, around $2.3 billion have been lost to bridge security related hacks. Which means that as a user, you really need to make some stark trade offs around how you determine your application security when it comes to moving data between chains. For us, this is where we feel that layer zero comes in and provides a really valuable utility for layer zero. We're built on three principles in particular.
00:05:04.863 - 00:05:47.751, Speaker A: One, that the protocol is permissionless. Any application built on any of the networks that we support can uniquely go and access not only the layer 0 endpoint smart contract and send a message to any of the pathways that we support. But two, once a message has been emitted out from the source chain, layer 0, the protocol has no ability to strike down or censor messages once they're in flight. This unique censorship resistance is really, really valuable in a cross chain environment. If someone was able to censor packets while they were off chain being moved to the destination, it would mean that fundamentally your protocol wasn't secure. Ah, there we go. Are we able to see that? Okay, I'm going to try and catch up really quick, but we're at a pretty good spot.
00:05:47.751 - 00:06:37.749, Speaker A: So again, permissionless, censorship resistant and next up here, immutable. One of the big pieces for layer zero as a protocol is that our smart contracts and the protocol contract standards that we put out are immutable. We ask you, the developer, to not only deploy your own Solana programs, but we make sure that the core protocol infrastructure can't be changed or upgraded by us as centralized entity. We want to make sure that once you interact with this interface, it is immutable and unchanging, because that's very, very important for you, the app developer. So let's get into a little bit more of what makes Layer zero bridge infrastructure. One of the things I talk about a lot is this analogy to the real world. Bridges are really, really important because not only do they connect one isolated groups of people, but they also connect the information that flows between them.
00:06:37.749 - 00:07:45.801, Speaker A: And that information can be really, really valuable because they're not only able to coordinate the transfer of goods and services, but using that information, eventually financialize those assets and enable these isolated parties to exchange information. Catching up a little bit here, we understand that cross chain is reality. Different chains have different value propositions, both in terms of speed, cost, potentially communities, funding, etc. And we see developers moving to more and more chains. From the Electric Capital Developer report back in 2023 and overall understanding kind of this infrastructure that I mentioned before, this idea that token transfers and movement of information on a single blockchain is relatively straightforward, but movement on more than one chain becomes infinitely more complicated. This idea of needing to invoke a call on a source chain that eventually changes the state on the source and then correctly relay it to the destination to trigger some other function call. Again, as I mentioned before, taking advantage of these cross chain transfers, if you don't have proper security in place, can lead to really, really not so nice outcomes for the average user.
00:07:45.801 - 00:08:24.051, Speaker A: And that's where this kind of idea of monolithic bridge security comes into play. Monolithic bridge security, in my opinion, as I mentioned before, isn't really all that secure. Because if your security fails, not only you, the single application, but every application on that network is fundamentally now at risk. And as I mentioned previously, this is why we have such large exploits in this space. Because every application falls prey to a single validator set failing. Ultimately, it's because of this channel basis where every app is forced to use the same security channel for their bridge infrastructure. And for us, what that means is that app developers like yourself are forced to make a really nasty trade off.
00:08:24.051 - 00:09:21.619, Speaker A: Network A might be providing a very low security threshold, but much cheaper for bridge infrastructure or Network B might be providing you with a really, really high cost of security, but at the same time a really, really high level of security to go with it. Obviously this is a bit of a simplification, but the main takeaway is that the switching cost between these different bridge providers is really high. Typically it requires core contract changes, different function methods to be invoked, and ultimately redeployments potentially on your application. That's why I like to say if Ethereum is a dark forest, you can think of cross chain as being a dark ocean. You have all these isolated islands of connectivity, and if some malicious actor gains control of the pathway between them, the islands face an existential threat. Ultimately, if the actor also destroys the port of entry, it also faces an existential threat to the island itself. So for layer zero, what we kind of see as a solution to this issue of monolithic bridge security is what we call our Omnichain protocol stack.
00:09:21.619 - 00:10:14.161, Speaker A: The idea that applications built on Layer 0 are able to access these immutable Layer 0 endpoint contracts and actually configure the type of security that they use. And more importantly, there's the type, also the scope of security, the number of validators that you have in your set. Beyond that, we also provide a broad function call layer, the ability for message execution to be done automatically on behalf of the application that is calling it. Also delivering native dash tokens and other composable function calls that might be necessary for a destination transaction. And finally, broad smart contract application standards such as the oap, which is a way for you to move any type of bytes, input or data between chains. And the OFT the Omnichain Fungible Token Standard, which basically extends just the native SPL token model on Solana and combines it with ERC20 on the destination. At the moment, ONFT is grayed out.
00:10:14.161 - 00:11:05.555, Speaker A: Right now we are working with the Metaplex guys on getting that set up for Solana, but ERC721 is currently live on all 80 chains that we support. Getting a little bit diving in and really looking into the message workflow. When you send messages with layer zero, the way that it works is that the application defines a message in bytes. They want to send a destination chain as an endpoint identifier and a send library configuration. This configuration determines the type of security that you use. In this case, there are four DVNs configured here and the executor that you want to use. From there, those decentralized verifier networks will validate on the destination chain and compare against the receive library config that you, the app developer, have set, which specifies the finality that you expect them to wait, the number of DVNs to provide the signature, and the threshold for verification for a message to be considered verified.
00:11:05.555 - 00:12:17.473, Speaker A: From there, an executor, whether it's one that we run or a permissionless one, one that you interact with yourself, can deliver the message automatically through. For Solana, this is a little bit different. The way that it works is that we commit a message and basically say that it's been verified from the DBN set, and then two, this message gets executed through via the destination app and then does a quick little relay through cross program invocation down to the destination app. So super interesting. Without getting too much into it, the way that the layer 0 endpoint works is that it basically defines this interface and this channel setup for your app itself, which allows us to configure not only the type of security that we want to use via these appendable message libraries, but it provides you with a really interesting app use case where if as layer 0 becomes more developed and there are better validation techniques that come online, you're able to suddenly extend existing applications by opting into new configuration parameters and setups. So really, really unique here. And what that means for an app developer like yourself is that when we look back at security cost curve, not only does layer 0 support point A and point B on this curve, but it supports every single point in between.
00:12:17.473 - 00:13:11.591, Speaker A: And more importantly than that, as new validation techniques come online, you're suddenly able to unlock better security over time by opting into it yourself as the app developer. And if you prefer the existing setup that you already might have, you're able to continue running the same configuration as is with no changes to your application. So it gives you the best of both worlds in terms of what can be a decentralized verifier network. There are currently 30 plus that are live today. At the moment, some of the ones that you can configure between are Polyhedra, a ZK Lite client, Lagrange, Cryptographically Secure State Proofs, or an existing provider like Axelr, CCIP or Google Cloud. And what's really interesting there is that it means that you can not only control the scale of your verifier setup, but you're also able to now have different permutations of these different providers. And on top of that, add yourself as a verifier to provide redundancy.
00:13:11.591 - 00:14:10.639, Speaker A: And what that means is that layer zero is broadly scalable for verification, diving in a little bit deeper into kind of the execution side of the workflow. Traditionally, the way that execution works on an EVM compatible blockchain is that messaging is atomic. So either everything succeeds on the execution level or it reverts. And that might be useful in a lot of cases, but for cross chain messaging, it can be a little difficult for the app developer because let's say on the destination chain you want to send a token, swap that token and then stake it all within one workflow. From the user perspective, if one of those calls fails, the entire transaction reverts. And realistically, what that means for you, the app developer, is that you need to think of more creative ways to build your application that might be unintuitive for a user who's interacting with it. Layer zero built this concept of horizontal composability, a way for you to basically get around this issue of atomicity by for a single receive call defining all of the inputs that you want to change.
00:14:10.639 - 00:15:33.125, Speaker A: So in the token transfer example, let's say the first call in that stack is receiving tokens and then execute a second message back up to the endpoint that pings the executor on the destination chain and executes an entirely separate workflow transaction called LZ Compose. And what that means is that when you're delivering data or any type of transaction in a cross chain environment, you can separate now your workflows. So in the example I mentioned previously, swapping tokens, let's say in that second call the swap fails you can know that the token transfer succeeded on destination without needing to worry about the entire transaction stack reverting, giving you a lot more broad configurability and kind of how cross chain workflows behave beyond just kind of the execution types that you have available. Layer 0 also supports gas drops down to the destination chain. So for example, with Solana, if I wanted to have a user interact on Solana itself, they could make a call to the smart contract that I have deployed and say that I want to purchase a certain amount of GAS and deliver it to a destination app. Or, or as a developer I can specify that I want this gas to be transferred to an end user's address along with the cross chain message. And so it means that not only can you help ease the onboarding process for your users as they move from chain A to chain B, but also ensure that there's automatic execution that you don't run into any weird gas issues around with that.
00:15:33.125 - 00:16:49.911, Speaker A: So everything that I've talked about in the last few minutes, hopefully you've caught up. Basically builds this idea that Omnichain applications allow any smart contract on any blockchain network that Layer zero supports to not only control the validation that they need for every pathway that they want to move to, but also control the ability to move between not only chain A and chain B, but have relays of transactions between every network that they want to be on. Ultimately diving back into that Omnichain transfer that I mentioned before, this allows you to not only control again the security setup itself, but feel confident that you're able to work through. And if a validation network fails, know that you're not going to be at risk of having everything within your application lost and potentially having to worry about what happens to your user base as well. All of this kind of builds to the idea of what we think of as an Omnichain tech stack. The idea that any application with any broad use case, whether that's DeFi, SocialFi, Gaming, NFTs, Oracle feeds, etc. Can interact with a layer 0 endpoint smart contract and be comfortable knowing that not only are they able to kind of meet the broad needs that they have for their application, but be sure that they're able to not only solve the problem areas that they need and really, really work well within the configurable set.
00:16:49.911 - 00:17:07.255, Speaker A: So I think if you go to that QR code right now, I believe right now it goes to a couple example design patterns that we have. If you're interested on GitHub, I, I went a little bit fast to kind of catch up on the slides. So happy to kind of go through and answer any questions that there might be from the audience, too. But, yeah, thank you, guys.
