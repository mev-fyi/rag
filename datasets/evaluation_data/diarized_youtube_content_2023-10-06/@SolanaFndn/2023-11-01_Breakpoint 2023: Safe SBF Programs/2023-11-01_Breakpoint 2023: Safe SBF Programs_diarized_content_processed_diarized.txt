00:00:03.800 - 00:01:07.354, Speaker A: So, yes, I'm going to talk today about how we can make Solana contracts safer, and in particular SBF programs. Okay, so at this point, it shouldn't be a surprise for everyone here that security is a serious challenge, right, for the broader adoption of crypto, and in particular defi. So here I just show some data about what is the trend over the last six, seven years, about the amount of crypto has been stolen and the number of hacks. And you can see that the trend is actually scary. So it's increasing and the amount is getting bigger and bigger. So the solution that we propose at Sertora is to do formal verification. So the high level idea is that given a program P and a specification s, we want to build a mathematical proof that psatisfies us, or otherwise we want to find a witness of the specification that is violated.
00:01:07.354 - 00:01:51.484, Speaker A: And both outcomes are important, because either we get what we want, which is the proof, or otherwise we can use the witness to do debugging and trying to fix our code. Obviously, there are challenges to this. The first thing is that to write a specification is hard and it's unconsuming. And the other problem is that to extract the semantics of the program in a way that we can reason about it is also very challenging. So our approach is to provide developers with novel specification languages and tools that can make easier to write specifications and develop automatic formal verification tools. So just briefly, allow me to introduce Sertora. So we are founded in 2000.
00:01:51.484 - 00:02:59.258, Speaker A: So we are a global company, we have a significant number of verification and Defi experts. We already have quite a big experience in the EBM world, where we already verify 2 million lines of code, of solidity and VYPR. And we already preventing an important number of bugs. Before Pronza were deployed in 2022, we started doing focusing on Solana. So the approach that we take to the problem is that while given the code and given the specification that we call it invariants, it goes to this magic box, which is the certoraprover. And either we are able to find to build the proof that the code is safe, otherwise we actually report the windows that something is wrong, or actually, unfortunately, sometimes, because the problem is undecidable, we may time out. And obviously a lot of effort that we put is in order to avoid this timeout.
00:02:59.258 - 00:04:00.280, Speaker A: So now let's go now to Solana. So when you try to do verification of Solana, you have different level of abstraction, and you need to decide at which level of abstraction you want to do verification. So a very common obvious, actually solution is to try to do it at the level of rust IR because you have a lot of information available to you to make your life easier in terms of verification, like types, pointers, pointer ownership, aliasing, et cetera. But the problem with that is that you are ignoring the Solana virtual machine. So this is something important to keep in mind. You could actually go to a bit lower where you could do it at the LBM bitcode level, but still you would have problems because you still ignore the details of the Solana virtual machine. Or you can go all the way down and you can actually do verification at the SBF level, the Solana binary format.
00:04:00.280 - 00:04:57.512, Speaker A: And the good thing about it is that while you are going to include all the Solana virtual machine details, you can actually do verification also when the source code is not available or when the input language is not actually unlike language. And actually you could also, you don't need to trust the compiler, right? So you could also catch bugs in the compiler or the code generation. However, the problem with that is that this is going to be harder to do because there's a lot of information that you lost over the compilation process. Okay, this is just to show you, give you a glimpse about how the bico, the Solana bytecode looks like. This is at the top. At the bottom you have is a picture about how the simplified picture about how the virtual machine works. So you have registers and you have four different memory regions, the stack, the heap, the information about the accounts.
00:04:57.512 - 00:05:41.878, Speaker A: So, but this is pretty much at the level that we're going to do verification. Very low level, we don't trust anyone. So now this is the pipeline of the prover that we have built. So we take the original rust code with the specification that is going to be written also in rust. We can also take, and we do, we can take events, other crazy inputs like C code, although we focus obviously on Rust. Then it goes to the LLBM compiler, you get the LLBM bitcode, then ultimately you get the SBF file. And then is when, basically this is the input for our tool.
00:05:41.878 - 00:06:30.054, Speaker A: And then is when we are going to try to do a decompilation process. We're going to try to reconstruct a lot of information that we lost over the process, like again, pointer information types, etcetera. Then it's going to go to some internal representation where essentially it's going to allow us to build a formula which basically represents the semantics of the program. Then we're going to use off of the shell SNT solvers. They are constraint solvers, that they're going to actually decide whether or not the formula is satisfiable. And based on that, we can actually claim whether or not the original Rus contract was safe, was correct with respect to the specification or not. Okay, so that's pretty much the whole pipeline.
00:06:30.054 - 00:07:04.068, Speaker A: Well, here I just trying to emphasize a bit of our secret sauce. Again, we put a lot of effort on the decompilation and we put a lot of effort in how we build this formula to deal with DeFi properties. Now, I'm going to talk about a case study. So two months ago, we started working with the squats. Squats is actually a very version four. It's a very sophisticated multi set wallet, has already more than 600 million in asset secure. It's extremely well written and well designed.
00:07:04.068 - 00:07:44.926, Speaker A: It has been already manually audited several times. So what we did on this project is to verify formally several core parts of the protocol, which is the multisig part. And the proposal mechanism included new features like tamlocks. So I'm going to talk about the proposal mechanism a little bit. So the idea is that because it's a multisig, so you need to be signed by several members before a transaction is executed. Because of that, you have a threshold, which is the magic number that allows you to decide whether or not it's going to be executed. So the typical cycle is going to be okay.
00:07:44.926 - 00:08:48.852, Speaker A: A proposal is going to be created by a proposer, then the voters, they're going to vote, either accept or reject the proposal. And ultimately if the proposal is accepted, it's going to be executed. This is a more formal way of expressing what I just say. This is kind of automata view of how the proposal mechanism works. So the black boxes and the green boxes are the states, and then everything else are the transition between states, right? So you can actually create an active proposal by calling proposalactivate, then you can actually vote by either calling proposal reject or proposal approved. Ultimately, if the threshold is reached, you can approve the proposal, and then after that you can cancel it or you can execute the proposal. So things that we would like to prove about this proposal mechanism are things like, for instance, we want to make sure that there are no missing transitions in the automat I showed you.
00:08:48.852 - 00:09:38.076, Speaker A: We want to make sure that all the states are rich, so there are no data states, and then seeing more interesting things like no double boating or the property, the key property that I mentioned before, you should be approved only if you reach the threshold. So this is the key properties that you want to prove. So now I'm going to give you a live demo. So I'm going to show you how we can prove a property. Let me quickly. Okay. Okay, so we're ready.
00:09:38.076 - 00:10:04.816, Speaker A: Now I'm ready to show you the demo. So here what I would do is going to be similar, like when you do testing. So you need to write a harness for the property that you want to prove. And we call it a verification harness. So at the high level, and this is written in rust. So it's in. And basically the idea is that you need to do something similar.
00:10:04.816 - 00:10:53.464, Speaker A: Like in testing, you need to create an environment. And this environment, it could be less or more complicated depending on the number of interactions that you want to actually, or you need to model for the property you care. I'll show you later the details. Then after we create the environment, we actually simulate the action of either the member is going to accept the proposal or is going to reject it, and we are going to do it several times. And then finally we are going to check for the property that we care about. In this particular case, we want to say if the proposal gets approved, it must be the case that the number of approvals is greater or equal than the threshold of the multi seq. Okay, so that's what we want to prove.
00:10:53.464 - 00:11:18.338, Speaker A: So let me show you how we are going to do it. So I just run it. So I wrote a script that is going to call the prover. The parameters are going to be the SBF file. So this shows you that we actually verify the SVF code. This is the name of the rule that we want to prove. And then there is an option that says that we are going to roll loops up to three.
00:11:18.338 - 00:11:47.434, Speaker A: And this is because of the limitations of the. Well, the theoretical limitations that the problem is undecidable. So we need to somehow fix the number of iterations. So, ok, it's going to running for a bit. Let me come back. And meanwhile I can actually explain more about the code. So the next thing I want to show you is how we can actually create this environment, how it's different from a normal environment that you would create for testing.
00:11:47.434 - 00:12:19.756, Speaker A: So again, the high level is the same thing. So we need to create a multisig and that's something that we want to do by calling the public API of squats. So there's nothing different here. We just unwrap the result because we only care about, we want to check only for the property if everything success, or if the creation of the multi seq success. So that's why we call it unwrap. Then we're going to create a transaction, in this particular case, a bolt transaction. This is just a wrapper just to hide some code.
00:12:19.756 - 00:12:45.748, Speaker A: But it's actually calling again the public API. Nothing interesting here. And then we are going to create the proposal. We're going to create a proposal, again, we are going to call proposal create, which is part of the public API. So again, at the high level, hopefully you can see that it's something that you would do if you would do testing. So, okay, let me come back, by the way. So, okay, now I got the results from the verifier.
00:12:45.748 - 00:13:20.112, Speaker A: So essentially the interesting part here is that the property was proof says verify, right? It's non violated. It took in total 16 seconds. You know, it could be more, it could be less. So that's the result of the prover. Okay, coming back to the program now because again, it's going to take a while. Let me, before I continue explaining the code, let's assume I want to show you what happened if you have a bug. So I'm going to inject a bug and I'll show you what is the bug about.
00:13:20.112 - 00:13:57.304, Speaker A: But basically for now I'm going to just run it. So, okay, so I'm going to generate just the SVF code and then I'm going to just run it. Okay, so it's ready now. Okay, I'm going to run it again. I'll come back. Okay, now. So again, so now I'm going to try to describe briefly which are the main difference between a verification harness and a testing harness.
00:13:57.304 - 00:14:42.722, Speaker A: So everything you see here in the code there is calls to non debt. And this is kind of the key here. So the idea is that this non det is going to generate an object or the corresponding type, whatever it is, but basically the values of that object is going to be an arbitrary value. So it's gonna, and that is gonna allow to the verifier to reason about it symbolically. So in that way that's the main difference. How unlike in testing where you need to provide a concrete value, here we just, we are able to provide a symbolic value that basically cover all the possible cases. So for instance, in this particular case, a couple of key parameters are gonna be the number of members.
00:14:42.722 - 00:15:31.316, Speaker A: So we need to fix the number of members, but each member is filled with random values, which means that in that way we can cover all the possible permissions that the member may have or any other information about it. So we're not going to make any assumptions. By the way, I should say, also an important part is the fact that we don't in the way that we deal with the runtime part is again, we just create accounts that they are filled with non deterministic values. So in that way, again, you cover the case where you don't know what you're going to get from the runtime, so you make the worst possible assumptions about it and then you do verification with that. Okay, so that's pretty much. And again, another example is the threshold. We're not going to make any assumption about the threshold.
00:15:31.316 - 00:16:16.704, Speaker A: It's going to be, again, any non deterministic value. So hopefully you can see basically this is how we can actually get more coverage doing verification or formal verification simply because we can reason symbolically about the inputs. Okay, let me come back to this again. Okay, we are lucky here. You can see here, in this particular case, because I injected a bug, the rule says okay, the proverb says violate it, it takes a bit longer. In this particular case, we are working on how to present the Witness in Rust to the User. So obviously this is an important part that we are doing right now to make the Tool usable, but this is something that we don't have right now.
00:16:16.704 - 00:16:59.072, Speaker A: So I think that's okay. Yeah. And the last thing I want to say about the code, because before we were saying that, I was saying that after you create the non deterministic environment, you need to basically simulate the fact that the members, they could vote, accept or reject. And again, here, this is how we do it. We can create this function where based on some non deterministic value, we are going to either approve or reject or do nothing. And again, this is how you actually model all the possibilities. So with this thing, I'm done with the demo because I don't have more time to show you how we injected the bug.
00:16:59.072 - 00:17:44.584, Speaker A: But I think hopefully at this point is good enough for you to get an idea about how the tool looks right now. So now I'm going to come back to the slides and conclude. So basically, the point of this presentation is just to show you that we have a tool that is based on formal verification for SBF code. And the idea is to try to provide stronger security guarantees. Users. We definitely want more clients like squats because the experience has been very, very positive working with them. We also would like to have more code that use more DeFi properties because that's something that is our strength.
00:17:44.584 - 00:17:56.484, Speaker A: So it would be nice to have cases like that. And definitely there are many things that we need to improve on the tool we are working on it, but hopefully we will get everything we want. So with that, I conclude. So, thank you very much.
