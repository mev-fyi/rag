00:00:05.480 - 00:00:05.960, Speaker A: What's up, guys?
00:00:05.974 - 00:00:11.470, Speaker B: So today we're going to take a look at processing instructions with native Solana programs.
00:00:11.502 - 00:00:11.670, Speaker A: Right.
00:00:11.702 - 00:00:13.718, Speaker B: So we're not using anchor or seahorse.
00:00:13.846 - 00:00:14.902, Speaker A: And here, as you can see, this.
00:00:14.918 - 00:00:21.834, Speaker B: Is what we did previously with account data, where we were kind of like serializing the data that was going to go into our account.
00:00:22.134 - 00:00:23.182, Speaker A: Well, it turns out you got to.
00:00:23.198 - 00:00:33.394, Speaker B: Do the same kind of thing for instructions, but it actually operates a little bit differently because this is going to determine what operation that your program is going to take when it receives this instruction.
00:00:33.514 - 00:00:34.362, Speaker A: So we'll take a look at how.
00:00:34.378 - 00:01:10.352, Speaker B: To build instructions, how to decipher between different ones, and how to kick off certain operations based on certain instruction data. So here I've got this little like journal program here, right? And this operates similar to some stuff we've seen before with like a PDA. So we're going to initialize a journal PDA and then we're just going to write new entries to it. And all this really is, is just each entry is its own PDA that's derived from the journal. And we're just going to add like a little message in there and stuff like that. So this will make a little more sense as we go into the code, but that's generally what this thing is going to do. And so we obviously are going to have two different instructions.
00:01:10.408 - 00:01:10.624, Speaker A: Right.
00:01:10.664 - 00:01:14.888, Speaker B: So if we look at our instructions folder here in our typescript folder.
00:01:15.056 - 00:01:28.652, Speaker A: So here you can see in this init journal file, we're going to actually initialize a journal here. And we're doing the same kind of thing that we saw with the account data, except we've omitted the whole, like extending the assignable parent class so you.
00:01:28.668 - 00:01:30.596, Speaker B: Guys can see exactly what these fields are.
00:01:30.700 - 00:02:00.708, Speaker A: And notice we've got a nickname, a bump. And then this instruction field, which is going to be this journal instruction enum right here. Right. And we'll come back to this. So what is this really doing? Right, well, basically we're propagating the props out to be the fields like we saw before with assignable. We've got the same like to and from buffer functions that we saw before, which is going to help us with serializing and deserializing the schema that we're going to use to do that. And then down here is going to be the function that's going to create the actual instruction.
00:02:00.708 - 00:02:55.798, Speaker A: So you can see that we're going to create the PDA for a journal. In this case, we're creating the journal account. And then here's where we build the instruction data. And as you can see, just like the fields we saw above, we set this instruction field to the journal instruction enum variant, this case the init journal one, and then we add our two other fields as well. And then we set up a transaction where we boil that instruction data down into the buffer representation, pass it back so we can ship it. Now, if we take a look at new entry, it's going to look pretty similar, right? Like we're going to get the journal address, we're going to go fetch the journal's info so we can calculate the entry address, and then we're going to do the same thing here, but with the new entry variant this time, right? And then obviously the rest follow suit. So what is this instruction field actually doing? And like, why do we have an enum here? And like, how does this work? Well, if you take a look at this enum, it's pretty simple, right? We've got two different kinds of instructions.
00:02:55.846 - 00:02:57.446, Speaker B: And this is where you put the.
00:02:57.470 - 00:03:39.610, Speaker A: Different types of instructions that your program can support. Now, on the rust side, we can take a look at our processor file, and you can see that this is what the enum actually looks like on the rust side. So like, whoa, okay, why does this look so different? Well, technically speaking, an enum boils down to, in borscht, zero, one, two, right? Like it's an integer representation of what the variant is. So the word doesn't necessarily have to match exactly. And in rust, you can have enum variants that actually have passed through ARG's by way of structs, and that's exactly what these are. So when it comes down to the process instruction function, you can see that we just pass in our instruction data. I flipped it to input, so it might make a little bit more sense of what's going on here.
00:03:39.610 - 00:04:26.394, Speaker A: And then we just do this journal instruction, which is the enum try from slice, and we take a reference to that input set that equal to the instruction that we've received, right? So this is the type of instruction, it's one of these two values of the enum. So we do a match on it. And as you can see, either value that we get, right, like either variant of the enum has these arg's passing through, and we just send them over to whatever instruction function that we're running. So if we just take a look at like init journal, for example, you can see that the arg's come in as this init journal args. And what does this actually look like, well, it's the two fields left over besides the enum variant that we passed in. So like in typescript we had the enum variant plus these two. Now we just have these two.
00:04:26.394 - 00:05:30.374, Speaker A: And since we're getting these as our arg's, we can see like there, if we go highlight arg's, you can see that we're actually using those values to go ahead and create some data types and like do the rest of our operation here. And just for reference, this looks similar to what we did with account data. We're just creating that thing, setting some new data, et cetera. Same kind of deal with new entry, right? The ARG's are the two leftover fields. We get those passed in in the struct in this object, and we just go about our business like we did in the init journal one. So like, why is this so important? Like what is this doing? Well, basically, if you set things up like this, it's a very simple match statement to go ahead and like trigger different operations based on the instruction type you pass in. And like we said, if you're just setting this instruction field and you're making it equal to a variant of a particular enum that represents all the different kinds of instructions your program can support, then all you have to do is serialize on that first one simply just by doing this, and just grab that input, determine which one it is.
00:05:30.374 - 00:05:52.902, Speaker A: Is it zero? Right? Is the first enum variant, is it one, is it the second? So on, so forth, and then kick off your actual operation with the rest of the ARG's. And it's really that simple, guys. And as you can see, here's our test right here. Looks pretty similar to what we've done before. We're going to initialize the journal and we're going to go ahead and write a few entries, and let's just kick it off for posterity. And there you go, guys. Successful test.
00:05:52.902 - 00:06:03.694, Speaker A: You can see that that is exactly what we needed. And this is really how you just process instructions using borscht and using serialization and deserialization and match statements. Good luck.
