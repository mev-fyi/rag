00:00:09.120 - 00:00:50.985, Speaker A: Hello, my name is Jacob Creech. I work as developer relations at Solana Foundation. Today we're going to expand on the gold tokens that you earned in the previous day of the boot camp. We're going to do a deep dive working with tokens in general in Solana, learn PDAs in much more detail, and how to create a staking program for those tokens. Now, what do I mean when I talk about a staking program? The staking program that we will build today will allow you to deposit tokens, earn rewards for the stake that you have in the program. And the longer that you have those tokens staked, the more rewards that you will receive. Now, why would you want to do this? A stake program can have many applications.
00:00:50.985 - 00:01:42.589, Speaker A: Take for example, if you're building a mobile game where you send woodcutters to chop wood in a forest. The longer the woodcutters are in the forest, the more wood they will cut. On the program level, both the woodcutters and the wood can be represented as tokens. If you can send your woodcutter token to chop wood by depositing it within the program, the program would then generate wood tokens for you over time. Let's get to building this staking program. Now, it's good practice before you build any program on Solana to first kind of draw out what accounts that you will be using within the program. We do this early so that you can know what to expect when you're working with the accounts and the account model on Solana.
00:01:42.589 - 00:02:52.635, Speaker A: And it kind of also helps that when you are working later, you don't realize, oh, I needed this account earlier and have to rewrite all the code previously. So first off, we know that we have these users, so we have a user and they have wallets, right? And for our case, they have specifically a PDA called the gold token account. So that gold token account is directly related to the user and is a pda. So we know that we have this account and the user, which is also an account, because remember, everything is an account on Solana. Next, that we know that there is going to be a stake program. Now, for the users to deposit gold tokens into the stake program, they're going to need a specific stake program account on the stake program itself. So we know that that's going to be.
00:02:52.635 - 00:03:47.221, Speaker A: We're going to call it right over here, we're going to call the user stake account. Now, this is going to be a PDA off the stake program. And let's derive it with the key were the seeds of token and this would actually be token plus user pubkey. Now the reason why we do both the string literal token plus user pub p is so that we can directly relate this account to the user by user pub key. We don't want someone that is a different signer, say another user accessing the user funds of someone else. That would be a security risk. So make sure that you always put in your seeds correctly.
00:03:47.221 - 00:04:52.115, Speaker A: And adding a user pub key to your seeds creates a user space in your PDAs on your program. Secondly, whenever you stake those tokens within the stake program, we're going to have to know exactly what time you stake those tokens. So in that we'll have to know some stake info. So let's create a stake info account. This will be another PDA and this PDA, let's just derive it off of, let's call it stake info plus user PubKey. And so we'll have the string literal of stake info and user pubkey in order to get the information about their specific stake on the program. This information would be like the slot time so that we know how to generate the rewards.
00:04:52.115 - 00:05:35.125, Speaker A: And speaking of rewards, we're going to need some have to need a place for the rewards to come from on the stake program itself. So let's create a stake another token account called gold token vault. So this is where all the rewards will be generated from and we will create the seed of vault for those rewards. So there we have it. We have all the accounts that we are required to run the stake program. We have the token account that is owned by the user. We have the token account that is the stake by the staking program.
00:05:35.125 - 00:06:20.325, Speaker A: We have the information about this different token accounts that are staked. And then finally we have the token account that all the rewards come from. Now you might see somewhere in the wild that whenever you have a token account off of a program, you have something that looks like this. People usually sometimes or sometimes create a PDA that is just for signing. So this would be like a signing PDA that would be derived off of the stake program. And then the authority of the gold token vault would would be the signing pda. That way the stake program can sign for transfers within the gold token vault.
00:06:20.325 - 00:07:04.231, Speaker A: However, this is not required and it's actually not best practice. So instead what you can do, and this is usually not what you expect at first, is you can take that gold token vault. So we're going to add the seeds back just for completeness sake. Instead you can take that gold token vault and make the authority itself. And given that it's authority itself, you can then use that PDA off of the stake program to sign for the transfers for itself. It kind of removes the need for extra accounts. And usually when you're working on Solana programs, the less accounts, the better.
00:07:04.231 - 00:07:45.005, Speaker A: The reason being is if you have less accounts, your transactions are smaller, your compute compute usage is smaller, and the transactions will cost cheaper in the long run if compute ever ends up costing any amount of soul. So here we go. We have all the accounts that we needed for the state program to run. So let's get to coding. Okay, so first what we're going to do is we're going to initialize a new anchor project. So what you could do is anchor init and we're going to call this staking program. And so what this will do is it will create the program or the anchor project for us to work in to create this stake program.
00:07:45.005 - 00:08:12.105, Speaker A: So we can see, you got initialize and we'll CD into the staking program. And you can see here that if I open this up, it has an app. That app is for usually where you store the front end. We're not going to have a front end. We're going to write just test for this program. You have your program, which is a lib RS file. You can see here, it's just a base initialize function as well as base initialize account.
00:08:12.105 - 00:09:03.961, Speaker A: And then the test will just run initialize and that is it. So we're going to check right here and just make sure we're at anchor 28 for the uses of this tutorial or this bootcamp day. What we're going to do is we're going to be working with the Solana CLI version 1.16.0. So if you're not on Anchor 28 or Solana CLI 1.16.0, make sure you change these versions because it's no guarantee that this program will work or be backwards compatible if you have a major version change. Finally, we're going to be using the anchor version to also compile of anchor 28 as well. All right, so first off, I'm going to make sure that this builds just to make sure that we're not running into any issues.
00:09:03.961 - 00:09:35.795, Speaker A: So we're going to do anchor build and we're going to wait for the build. Perfect. So if you ran anchor build and you just got a few warnings, that's perfect. So if you look at these warnings and you're wondering, what do these warnings mean? This is Meaning because we're using, we have a context in the parameter here and we're not using it. If we're not using it, it's telling us to put an underscore as a prefix but we will use in the future. So let's just leave it there. But otherwise it compiled and everything worked.
00:09:35.795 - 00:10:31.351, Speaker A: So let's get started. So looking back at this diagram, we can see that we're going to use these seeds of vault, stake, info and token. So I want to make sure that we do this early and include those three seeds in constants. So first off, up here we're going to create a pubmon constants and we're going to create some constants for us to reference while we are running through this program. So first will be the vault seed which will be reference U8 and that will equal the string literal of looking back at it, just vault this. Then we'll do pubconst. Let's see, we have stake info the next.
00:10:31.351 - 00:11:28.319, Speaker A: So stake infoseed, same type equals string literal and we had it as stake underscore info. Finally, we're going to have the last one and this one's going to be the token seed as looking back here, we have it as token. That's going to be the same type of string literal token. Perfect. So we have all the constants that we need and we have the vault, the stake info and the token for seeds. All right, so getting into initialize, the way that you usually write programs is you or at least the way that I like to write them. So I like to scaffold first, what are the different instructions or functions that I need within my program and then create all the accounts.
00:11:28.319 - 00:12:10.983, Speaker A: So we know that we need initialize because if the gold token vault doesn't exist, we need to be able to create it before there's anything else or any other actions happening within the stake program. So going back here we have the initialize function. It's going to have an initialize struct. We'll get to these accounts in just a moment. Secondly, we're going to need a function that allows the user to take the action of staking to the stake account. So here we have yet another one. We're just going to copy and paste this for now we're going to call this stake and if we look at this, we're going to want to be able to stake an amount.
00:12:10.983 - 00:12:55.337, Speaker A: So we're going to add the amount as a parameter for the stake function. And finally, whenever we are want to get rid of the stake or De stake, we're going to have a destake function that then gives us rewards, resets our stake info, and gives us back our balance from the stake account. So that is the final function. So we're just going to paste that back. And this one's going to call destake. Right? All right, so we have our three functions or these are each instructions. And now we need to create the accounts with an initialize.
00:12:55.337 - 00:13:45.505, Speaker A: So if we look at these, this initialize, we have to think, what do I need whenever I initialize this? So first off, we know that we're going to have to need this gold token vault, right? So we're going to have to create an account. And this will be account. We're going to use something called init if needed. So what in if needed is it allows us to initialize the account if it doesn't already exist. So what that means is if I call this instruction of initialize up here, it won't create the account if it already exists. But if it doesn't exist, have it be created. So if needed, we're going to have the seeds.
00:13:45.505 - 00:14:13.981, Speaker A: If you look up over here, it was vault. So constants was a vault seed because it's going to be a pda. We always need a bump. So this is where we need a pair. So the pair will equal this, the person who is the signer of the transaction. So in a moment we'll go add that. But we know that it has to be the signer.
00:14:13.981 - 00:14:41.095, Speaker A: So let's go at it right now, just so that we know about it. So right here we're going to have another account. It's going to be mutable because we're going to use it as the signer to pay for things. And that's just going to be the signer. Signer. All right. And just so that it carries throughout, we're going to do the lifetime.
00:14:41.095 - 00:15:21.325, Speaker A: Perfect. So we can see here this pair is referencing the account up here of signer. There's two other things. So we have the token mint and then the token authority. I'll set those up in just a moment once I finish writing everything. So this account will be the public. This will be a token vault account, and this will be a type of account info token account.
00:15:21.325 - 00:16:13.855, Speaker A: All right, so let's go back for just a moment. So if you remember when I was talking about earlier is that in order to sign for the transfer of this, you would have to have the authority of itself. So here, up here we have the authority. We're going to have the authority of itself. Secondly, we have a mint right here and you might be asking, what is the mint? So when you're using tokens within programs, so any type of token account, you're going to need a number of accounts that are always required in order to manage those accounts. So you're going to need the public mint, which is the type account mint. You're going to always need the token program, which is of type program token.
00:16:13.855 - 00:16:48.851, Speaker A: And then because we're creating account, we will be needing the system program. Otherwise we wouldn't be able to create the token account system. All right, so right now we have all of this information. Oh, and we have this token mint equals. We need to make sure that it equals the mint down here. All right, so right here we have all the information to initialize the accounts. We have the token vault account being initialized on startup and that is all we need.
00:16:48.851 - 00:17:15.485, Speaker A: So let us anchor build this and we should run into a few errors. The reason being we will run into a few errors because we include all this stuff from token and this is not used. And then init if needed, is not available as well by default. So let's just run through those as a practice. So we're going to do anchor build and immediately it's going to run to a few errors. So if we go down, we're going to. Yes.
00:17:15.485 - 00:17:32.745, Speaker A: So there we go. We're going to go to the first error that was just me accidentally not putting a semicolon. Let's run it again. All right, perfect. We got some more errors. Let's scroll up to the first error so we can see. All right, it's exactly what I said in and if needed, it doesn't exist.
00:17:32.745 - 00:18:06.323, Speaker A: So we need to make sure that we include that feature whenever we start. So right here we'll go to cargo and we'll see here that it says anchor laying equal 0.28.0. So in order to include new features, you'll have to do the following. So you're going to equal to the bracket. This will be version equals same version 0.28.0. However, I'm going to make sure that I include the features of INIT if needed. Right.
00:18:06.323 - 00:18:50.405, Speaker A: So here what I have is I have anchor lang including the feature in and if needed on version 28. So that should cover this. So finally we should run into one more error and that is something about us not including SBL token or anchor SBL into the cargo toml. So let's just wait just for practice when we want to see the error and then Use it. All right, so if you look here, we have a bunch of things about Missing Token, Missing Mint, missing token account. So let's make sure that we add those and we can actually see right here, the Rust compiler is very smart in saying, hey, I couldn't find Anchor sbl, you should import this crate. So let's go import them.
00:18:50.405 - 00:19:37.265, Speaker A: So here in the dependencies for Cargo tunnel, we're going to just type in Anchor sbl, we're going to make sure that it's of the latest version of 28 and that is it. And then finally, right here at the top, we only have Use Anchor Lang Prelude, right? We have to make sure that we use the other stuff within the crates as well. So we're going to do use Anchor SPL and there's a few things that we need. So token, we're going to need token of self, Mint Token, Token account. Perfect. So this should be everything that we've used. And let's do an anchor build and see if we ran into any issues or forgot anything.
00:19:37.265 - 00:20:00.447, Speaker A: All right, so it looks like I ran into an error still. So let's see what we forgot. You can see that I just said I forgot a semicolon. That's a pretty simple error. Let's go fix that real quick. And we can see here it finished successfully released the target. Some a few warnings about missing context and not using account mounts, just as earlier.
00:20:00.447 - 00:20:28.887, Speaker A: That's okay. Let's just continue. All right, so next up, what we're going to do is we're going to go to the test, right? And we're going to take this test and we want to make sure that we test the initialize functionality. If we don't do this first, we might run into issues later and not know what we're doing. Right. Okay, so if we do anchor test, Anchor test will run a local validator on the test. But in order to speed it up, we're going to run it ourselves.
00:20:28.887 - 00:21:00.505, Speaker A: You can see I'm already running it over here. Let's restart it just for. So you all can understand how it looks. So I'm going to run Solana test validator that's going to test or run a Solana test validator. In my background, it's currently at slot 200,000, 218,000. All right, so let's do anchor test and this one's going to be skip local validator. What this does is it skips the local validator setup.
00:21:00.505 - 00:21:41.241, Speaker A: It makes this quite a bit faster. And you saw here that at the beginning it was doing a bunch of transactions and this deployed my program to program ID this. Now it failed and let's explain why. So we can see here the invalid valid argument of the token Vault account was not provided. So let's explain that a little bit. Whenever you make a transaction on Solana, you need to make sure that you're including all the accounts required to make that transaction. So if you look over here, whenever we were doing the initialize instruction, we have it using this set of accounts.
00:21:41.241 - 00:22:07.997, Speaker A: Namely Token Vault account is the one that was not included. So let's make sure we include it. Right. So first thing we're going to have to do is we're going to have to create the accounts that are required and those accounts are the vault. We're going to have to create a mint because the token accounts have to be created off of vault or off a mint. And let's get started. So first off, we're going to have to create that mint account and we want to make sure that we save it.
00:22:07.997 - 00:22:29.129, Speaker A: So in order to create mints, this is using mocha. We're going to have to include it as yarn add at solana. Believe it's SPL/SPL token. Right. All right. We already have coral anchor. We're also.
00:22:29.129 - 00:22:50.535, Speaker A: Let's see, do we already have. Let's check. We also don't have web3js so let's make sure we have web3js so that we can do all the information. Perfect. Let's go back to the test. We have isinitialized. It's doing the initializer PC call, but it's not providing any of the accounts that we need.
00:22:50.535 - 00:23:28.305, Speaker A: So I am going to now set this information over here. So just for completeness sake so I can get my pair. I'm going to do const provider equals anchor provider. So I have all the information. We're going to set this as the provider. I want to make sure that I get the pair out of it. So const pair equals provider wallet as anchor wallet.
00:23:28.305 - 00:23:51.973, Speaker A: Perfect. I'm going to need this later. We're going to have to set up our connection so that we can make RPC calls. So cons connection equals new connection. We're going to be working on our local validator. So this will be HTTP 127.00 or 0127.0.0.1
00:23:51.973 - 00:24:47.425, Speaker A: at port 8899 which is the default port. We're going to use the state commitment of confirmed so that we make sure that we're Always looking for confirmed things. If we look right here it's saying hey, I don't know what connection is, we would just want to add it from web3js and finally, let's see, we already have the program so we're good to go. I'm going to create a separate function so async function create mint token and we're going to create this mint token and log it. So this will be cons Mint equals await create mint. This is a function from spl, the SPL token library. So let's go add that in real quick.
00:24:47.425 - 00:25:22.243, Speaker A: Add import from SPL token. This is going to require quite a few things. We already have the connection. We're going to have the pair pair which means it's the actual public key. We're going to have to do the oh, sorry, pair pairs assigner pair public key is the actual public key of the pair. Another pair public key. Make this token of 9 decibels and that is it.
00:25:22.243 - 00:25:57.117, Speaker A: So we're going to have the mint. The mint is, let's see what kind of, what type is the mint. That's a public key. We want to make sure that we create this off of a key pair though. So let's go up here and we're going to do mint key pair. And this is the reason why we want to do this is we want to have that key pair for use throughout all the tests. We don't have to restart test have the same key pair being or previous key pair that we no longer have being used in stake program and then not be able to create tokens off of it.
00:25:57.117 - 00:26:22.401, Speaker A: So let's create that real quick submit key pair. This will be key pair dot generate I believe and it's going to say that I don't have it. So let's add it back in. Perfect. And just for funsies we're going to console log it. Now you don't want to normally log this, but because of the test it should be okay. This is so that we can get the secret and we run it.
00:26:22.401 - 00:26:57.065, Speaker A: So here what we'll do is we'll add the mint key pair to say hey, use this mint key compare in order to create my mint. Right. So first thing we're going to do is we're going to create that mint. So await create min token. All right, so this should log my mint. So we'll do console log mint and we also have the mint key pair. So let's do anchor test again and see what happens.
00:26:57.065 - 00:27:25.445, Speaker A: All right, perfect. So we have the public key which is right here of the mint. And then here's the secret key. So in order to make sure that we're using the mint, the same mint always, I'm going to grab the secret key real quick. Instead of generating a new one every single time, I'm going to use that secret key that we used previously. So this would be from secret key. This would be new uint8 array.
00:27:25.445 - 00:27:49.705, Speaker A: And then you just include the secret from earlier. Perfect. So this would create the same mint every single time. We don't need to use this anymore. So we're just going to not use it here because we've already created on our local. But if we do need to create it, we can recreate it there. So we're going to remove these console logs because we don't need those anymore.
00:27:49.705 - 00:28:19.053, Speaker A: All right, so next up, we need to create that vault account for whenever we did the. The. The token vault account. Because whenever we run this test, it's going to require that account in order to run that instruction. So let's create it. So because it's a pda, we're going to have to create it off of this. So this is going to be vault account, and we're going to set it equal to basically how you derive a pda.
00:28:19.053 - 00:28:46.791, Speaker A: So that's using a function off of public key dot. They were going to do find, program, address sync, and then it's going to be from the buffer from. And if we look over here, it was from vault. So we're going to use vault. And finally, we need to always include the program id. Is it program or program id Just for. Yeah.
00:28:46.791 - 00:29:12.449, Speaker A: Okay. So program dot, program id. There we go. So now we have the vault account and we can use it within our instruction. So over here, we're going to have to make sure that we have the accounts, and we're going to have to include the accounts that are required in order to run this. So this would have to need the signer. So if you remember, we have to have a signer in order to pay for this.
00:29:12.449 - 00:29:39.495, Speaker A: So it'll be payer, public key. We're going to need the account or the vault account. So this is token vault account. Vault account. And then finally, we're going to need the mint. And the reason why we need the mint is so that it knows what mint is expected for this token vault account. So this mint is going to be the mint key pair dot, public key.
00:29:39.495 - 00:30:00.951, Speaker A: Perfect. So we have the initialize. So initialize will work once. Let's see how it works. All right, our test Passed. We initialized the token vault. It has no tokens to begin with, but we initialize it and now we can have users staking to the stake program and de staking later.
00:30:00.951 - 00:30:42.589, Speaker A: So let's go right at those functions. All right, so first off we're going to have to create a new set of accounts for this stake. So first we're going to do the same thing as we did earlier, going to do set up a struct for all the accounts. So derive accounts. This is going to be a pub struct, let's call it stake so that we know exactly what it's interacting with. And first off, what you do know is that you're always going to need a signer because we're going to have, we're going to have accounts that will need to be created within the stake instruction. It won't always need to be created, but sometimes it will.
00:30:42.589 - 00:31:32.011, Speaker A: So count mutable and this will be public signer signer info. All right. The other one that we'll have to need to create is we're going to have to create the stake info. So outside of here, I'm going to create a different account called stake Info just so that we have it and you can easily reference it. So this will be account and pub struct stake info Pub. We're going to do staked at slot. So what this will do is it'll tell us that whenever that user staked into their stake account, we know exactly at what slot they staked.
00:31:32.011 - 00:32:15.765, Speaker A: Slot is really the source of truth for time on the cluster. There is the ability to use a basically a timestamp but it's not to be relied on because it's kind of like an oracle. Timestamp versus slots is we know that it's always going to be the correct slot according to the cluster. Finally, we're going to create a public key just for error Sake of is staked this or sorry, it's going to be a boolean. This will tell us whether or not the user is already staked. And if they are, we don't want them to stake more or if they are are not and we're trying to de stake later, we don't want to run into issues. All right, so let us create that stake info for this stake instruction.
00:32:15.765 - 00:32:38.655, Speaker A: All right, so here we have, we have an account. We know that if does the account already. If the account does not already exist, we want to create it. So init if needed. Again, the seeds. If we looked over here, the stake info is stake infoseed in the user public key. So let's make sure we include that so constants.
00:32:38.655 - 00:33:19.675, Speaker A: This will be stake infoseed and then signer key.as underscore ref because it's a PDA, we always need a bump. We're going to have just as the pair as a signer as earlier. One thing to note is this is going to be a token account. So just as earlier, we're going to need these three accounts always because this is a token account. So let's just add that real quick. And because it's a token account, just like previously, we're going to have to include the mint and then we're going to have to include the authority.
00:33:19.675 - 00:33:54.923, Speaker A: So this authority will be itself. So let's name it real quick before we finish that. So, so public account public. This will be the stake info account and then this will be an account of type token account. All right, so the authority is itself. All right, so we have our stake info account. Now we need to make sure that we have the user stake account and actually yeah, so the user stake account.
00:33:54.923 - 00:34:18.345, Speaker A: And we're also going to need the gold token account that the user owns. So that's three different accounts that we'll need at this specific time. So let's create that. So first we'll create the one that is their stake account. So just like before, it's another token account. It'll be in it if needed because we want to create it if it doesn't already exist. The seeds will be.
00:34:18.345 - 00:35:03.585, Speaker A: If we look here, it's token plus user pub key. So constants token seed signer key as ref. Because the PDA will have a bump, we're going to have to have a signer in case it needs to have be paid for by someone. Just like previously, it's going to be the token mint equal mint and then token authority equals itself. So let's call itself so public. This will be the stake account. So we'll call it stake account.
00:35:03.585 - 00:35:33.417, Speaker A: It'll be an account of type info and token account. So just like before, our stake account. There we go. So now we have the stake info account and we have the user stake account. Finally, we're going to need that token account that the user already has. So this will be just like before, an account. However, there's a few things that it's not going to be created or not going to be here.
00:35:33.417 - 00:36:34.369, Speaker A: So because it's outside the program, this specific account is outside the program. We're not going to do an in if needed because you can do that on the client side. So let's just make sure that we have it's mutable because we're going to move funds or tokens from this account and then it's associated. Since it's an associated token account, we're going to make sure the mint is the same and then the associated token authority is the signer. So this is because this is being signed by the user, not itself. So this is going to be public, this is going to be user token account, account, info token account. All right, so if you notice that we use this associated token account and we didn't, we haven't already included that.
00:36:34.369 - 00:37:09.655, Speaker A: So we make sure you include it now. And also because we have an associated token account, we're going to have to need the program here for it as well. So we're going to have to do pub associated token token program. Everything's underscore program info, associated token. All right, I have not already imported that. So we need to make sure that we import. Otherwise we're going to run two errors.
00:37:09.655 - 00:37:47.441, Speaker A: So it's going to be associated token, associated token. All right, so now we have everything within this struct. One thing that we need to do is we need to change this into use stake instead of initialize. Now let's see if it compiles and run it and fix any of the errors that may show up. All right, so compiled everything worked as expected and we're good to go. So we just ran into some warnings just as before. These are things that we have not used just for clarity sake.
00:37:47.441 - 00:38:29.523, Speaker A: Since we are not using the context in the initialize, let's just do that to get rid of that warning. All right, so we have the accounts. Now we need to actually implement the staking logic. All right, so let's get started with that. So first off, whenever I write stake or execute stake, I'm going to have to make sure that I have the stake info and this is going to be immutable because I'm going to change what the info is provided in there because now we're staking and I want to make sure that I'm grabbing it early. All right, so I have the stake info. Now there's some cases that I want to account for.
00:38:29.523 - 00:39:23.361, Speaker A: Like for example, if a user stakes but has no tokens or if the user is trying to stake and already staked. And finally, if you're thinking in the future for like someone that is trying to de stake over here but they've they're not actually staked, we want to throw an error as well. So let's make sure that we create all these errors or these error codes to be used within the program. So down here I'm going to create an error code of enum error code and we're going to create a few errors. So first off, we're going to do message. This message is going to be tokens are already staked. So we don't want to stake if we already have staked tokens.
00:39:23.361 - 00:39:56.795, Speaker A: We want to make sure the user de stakes at that point. So we'll call this isstaked. Secondly, we'll create the message of tokens are not staked so they're trying to de stake later. We don't want them to do that if they don't already have tokens. So call not staked. And then finally we're going to have to create the error message of let's say there's no tokens of stake. So what are you tokens what are you trying to stake for? So no tokens to stake.
00:39:56.795 - 00:40:47.755, Speaker A: And this will be no tokens. Perfect. So up here what we're going to do is we're going to create those different error responses and then we're going to make sure that we return them if they hit those specific conditions. So first off, if stake info is staked so we're already staked, let's make sure that we return an error error code isstaked.into and finally if the amount so if they have no tokens or they're trying to stake no tokens, let's not waste compute time. Let's return the error error code. No tokens.
00:40:47.755 - 00:41:15.581, Speaker A: All right, now let's get to actual staking logic. I'm going to build this just to make sure. Ah, perfect. So I ran into an issue. This is because it's can't find the stake infos off of stake. Let's go down here and realize that. Did I oh, it's because it's called stake info account is staked.
00:41:15.581 - 00:41:40.195, Speaker A: So it's saying that my stake info does not have is staked. Let's go down here and see what I called it should be is staked. Let's figure out what went wrong. So what I had here is is on my stake. I called this a token account. Instead of stake info it should be stake info. And then if I do stake info it shouldn't need all this other information as well.
00:41:40.195 - 00:41:59.577, Speaker A: So let's make sure I remove that are not needed. Right. So we have the stake infoseed. It's not a token account. So we make sure I remove everything that's not here. So this is a problem on my part because it is a custom account, we're going to have to include the space. So space equals eight.
00:41:59.577 - 00:42:24.819, Speaker A: Eight, because that's the discriminator that is always required at the beginning of an anchor account. Standard MEM size of stake info. Perfect. And so now this should work. All right, great. Look at that. No errors.
00:42:24.819 - 00:42:49.495, Speaker A: And we're ready to go. The first thing I want to do is I want to make sure I get the time. And how you get time is you're using a account or a sys var that's called the clock. So let's grab that. So use Solana program. Clock clock. Now, because I'm using Solana program, I need to make sure that I include it over here.
00:42:49.495 - 00:43:16.865, Speaker A: So program, let's just make sure that is actually Solana program. I believe it's on a dash program. So underscore. And then this would be because I'm using 1.16.0, same exact version. All right, so now that I have the clock, let us actually grab the time or the slot that at which I am at. So here we go.
00:43:16.865 - 00:44:05.283, Speaker A: So over here I'm going to grab the clock. So let clock equals clock get. I want to make sure that I'm creating the stake info staked at slot and we want to set that to clock slot, which is a U64. And then stake info dot is staked equals to true. All right, so I've now set it to the current slot and I've said that I've already staked. Now let's actually do the stake. So I'm going to do let stake amount equals amount.
00:44:05.283 - 00:44:53.839, Speaker A: So this is the amount that I required and we're going to do something special. So because the instruction requires an amount that's U64, this is something to consider. Staked at slot is unknown field. Let's go figure what I called it stake at slot. All right, so that should work. So the amount that say you send from the front end, if it has nine decimal places, which we know from our program, our test that we created a mint key of nine decimal places represented on the program side is actually a one. So one token would equal one with nine zeros afterwards.
00:44:53.839 - 00:45:28.340, Speaker A: So we need to actually make sure that we're getting the right amount of tokens instead of the opposite. So say if we just made stake amount equals to amount, we would only have this amount instead. So we need to make sure that we're getting the correct token amount that the front end expects. So we're going to do a little bit of math here. So we're going to do checked multiplication. This is going to be 10u64.power context accounts mint decimals.
00:45:28.340 - 00:46:15.445, Speaker A: So raise it to 10 to the power of the amount of decimals so they can get that one with nine zeros instead of 0.0000 something something nine or one. So this would be as dot unwrap and then we got a transfer. So transfer is a new thing off of the token on spl. We're going to make sure that we're including it so that we can actually call it so transfer, transfer. All right, so let's go back down here and we're going to now call the transfer. So we call transfer.
00:46:15.445 - 00:47:04.325, Speaker A: This will call cpicontext new. So what this is is whenever you're trying to call another instruction off of a different program, you need to make sure you use cpicontext new. There's also new with signer if I need to sign for it. For this one, we don't need to sign for it because the token account is owned by the signer versus the program itself. So what we'll do is CPIC new and we will include the accounts. So we're going to do it off of the accounts of the token program to account info. We're going to do the transfer function off of the token program and we're going to do from.
00:47:04.325 - 00:47:46.235, Speaker A: So it's from to and then the authority. All right, so we know that this from is going to be from the token account to the user stake account and the authority is the signer. So what we called it is this is from user token account. So this is actually context accounts.user token account.to account info. The stake account counts, stake account to account info.
00:47:46.235 - 00:48:34.111, Speaker A: And finally authority is the signer. And one thing that we are missing from all this is we have the transfer function. But what's the amount that I'm actually transferring? So up here we'll do the stake amount and then we should be good. So let's build it and see if it works. All right, so we can see here it built just fine and we're ready to test it. So let's get to testing it. All right, so here we are, we are in the test now and we need to make sure that we create a new integration test for staking.
00:48:34.111 - 00:49:01.121, Speaker A: So we're going to go down here. I'm going to do it, our integration test. I'm going to do stake. It's going to Be a new async function. Boom. So we're now going to be ready to create a new integration test for staking. If we look back here on the actual implementation, what we're going to have to do is we're going to have to include all these accounts into the instruction used for staking.
00:49:01.121 - 00:49:48.765, Speaker A: So we have to make sure that we include all of them just for checking what accounts and seeing what's going on. Let's quickly create the transaction and get all the errors that are we're expecting. So we'll do await program methods and this will be just as before. We'll do stake this will be new anchor bn. We'll just stake one token for now. We'll have to have our signers or I guess for now we don't need that. We're going to just call the RPC just to get it to fail and then we want to make sure that we log the transaction just so that we can see what's going on.
00:49:48.765 - 00:50:14.285, Speaker A: We can do this really quick just taking the previous console log. Boom. All right, so this should fail because we don't have any of the accounts that we had previously. Let's just make sure that it fails as expected. So we go here anchor test. It'll try to create or initialize it again because it's already initialized. That should be just fine because we do init if needed.
00:50:14.285 - 00:50:32.893, Speaker A: All right, so it failed. The initialized succeeded but the stake failed. And the reason being is we don't have the accounts. That's perfect. That means it's failing for exactly the reasons that we expected. So let's create all these accounts. So first of all we're going to create the.
00:50:32.893 - 00:51:11.795, Speaker A: Let's create the user token account. So user token account equals await. This is how you do it from the SPL token library get or create associated token account. What this does is if the token account doesn't already exist, create it if it if it does exist, just get the address. So get the pda. So that requires a connection requires pair pair. It requires our mint key pair public key so that it knows what meant to grab from and then the pair dot pair in case or what who was the owner.
00:51:11.795 - 00:51:46.185, Speaker A: So it's myself public key. Perfect. So now we have the user token account. One thing to note is there's currently no token stored here. So we need to make sure that we mint some tokens so that we have some to actually send over. So let's do await min to connection pair pair which is the signer mint key pair Public key because I need to know which one to mint user token account. So mint to this address.
00:51:46.185 - 00:52:19.781, Speaker A: This is the paired up pair for the owner and then we're going to do, we're going to do quite a lot of tokens. So this is just 1 to the power of 10 to the power of 11. So quick fix upgrade. There we go. So here we are, we're minting some tokens to our token account and now we're ready to create the other accounts. So next up we want to get the stake info count. So let's get the same pda.
00:52:19.781 - 00:53:44.895, Speaker A: So just as before do public key dot find program address sync it's going to be buffer from and it's going to be our specific our key. So if we go over here, remember previously it was stake underscore info. So stake info stake underscore info and then it will be also the public key that we had previously or the payer's public key, the signer's public key. So payer public key to buffer and then since it's a PDA we always have the program program ID and there we go, we have the stake info account. Next up we're going to get the get the stake token account or the stake account. So let we're going to do stake account equals same as before public key dot find program address sync the for the stake account it's token and user public key. So we'll just grab this real quick and replace stake info with token always have the program id.
00:53:44.895 - 00:54:06.619, Speaker A: There we go. So we have right now we have the user token account. We have the stake info with the stake account. Finally we need the gold gold token vault. So we're going to go up here, we're just going to copy and paste this vault account. Actually let's look at the accounts real quick. We have the user account stake account stake info signer.
00:54:06.619 - 00:54:45.867, Speaker A: We actually don't need anything else. So we have all the accounts that we need. Let us let's see what else oh for one thing that we don't have is for this specific address. So this is just getting the address of the stake account that's a token account. But there's no guarantee that doesn't already exist. So let's, let's create it so this be, await, get or create associated token account connection pair pair mintkeypare pair public key. Let's see.
00:54:45.867 - 00:55:34.585, Speaker A: Oh mintkeypair public key Perfect. So that should be created for there we have the user token count we have the one off the stake and then finally now we need to just add them all to the RPC call. So here we know that the stake of one, we know that it's going to require someone to pay for this transaction. So signers is going to be pair pair and then we need the accounts. All right, so if you look at here, we can see all the accounts that are required. So we need a stake info account, which is stake info. We need the.
00:55:34.585 - 00:55:57.295, Speaker A: Let's see, we need the stake account, which is stake account. We need user token account, which is user token account. And then we need. Let's see, we already have the mint. Oh, we don't have the mint. So mint, that is going to be the mint key. Pair dot public key.
00:55:57.295 - 00:56:19.683, Speaker A: And that is we also need the signer because we don't currently have the signer. Let's see what's wrong with this? Oh, it's not type address. So we just do dot address. So make sure that we also include the signer. So this will be the signer and this is payer dot public key. Okay, so we have all the accounts. Now let's test it.
00:56:19.683 - 00:56:47.345, Speaker A: So let's run it and if we did everything correctly it should work. If we didn't, let's just debug it and fix all any of the issues. So it's replay playing, it's running check and check. We got two passes. So that means we staked one token to the stake program and everything worked as expected. So that's fantastic. That's actually really exciting that it worked first try.
00:56:47.345 - 00:57:25.225, Speaker A: It's a rare occasion. So finally we need to go do the de stake instruction. So we go up here, we can see here right now that I'm using initialize as before. We need to create a new set of accounts for the DSTAKE instruction. Otherwise I don't have the right accounts or the context in order to run it. So let's do it. So derive accounts, public struct, destake info.
00:57:25.225 - 00:58:14.857, Speaker A: There we go. All right, so we know that we need to have a signer in order to run all this. So we're going to do account mutable just as before, pub signer, signer info and then we need a few other accounts. So we need all the accounts that we have previously. So we need basically we need all of these accounts because we know that we're going to be running with all the accounts. So if you look at it back here, we're going to be using all these accounts all in this specific instruction. So we're basically just going to copy and paste all the Accounts from pre previous account structs and just make sure we have all of it in the right context.
00:58:14.857 - 00:58:37.515, Speaker A: So here we need the user account, we need stake account stake info. We're just going to copy those over. Perfect. And then finally, let's see, we have a stake info stake account, user token account. We need the vault account. So let's go grab that vault token account up here in stake actually would be an initialize. Here we go.
00:58:37.515 - 00:59:21.613, Speaker A: There we go. So we should have everything now. So four accounts, token vault stake info account, stake account and user token account. Because we're not creating these at this time, we actually don't need all the information every single time. So we can remove all these payers and signers and just have the seeds and the bump and these will all be mutable because they don't, they already exist at this point. So we don't need init if needed. All right, so we have all the accounts in our dstake.
00:59:21.613 - 01:00:08.375, Speaker A: Now let's create the actual implementation of D stake here. So if we go up, we're going to go up here, we're going to set the context as dstake and we're going to start writing the logic. So here what we have is we are going to first just like in stake construction, we're going to do let stake info equals mutable context accounts stake info. All right, so now we have the stake info. Actually just for tests, we're going to do anchor build just to make sure we did all those accounts correctly. All right, so perfect. That told us something real quick.
01:00:08.375 - 01:00:55.185, Speaker A: Is it stake info count? I think everything else worked though. Yep, everything else worked. All right, so stake info, what we want to do is just like in the stake instruction, we want to check if the stake info is staked, but we want to make sure that it's not already it's not unstaked or de staked. So stake info.is state return error error code not staked. So we don't want to try have someone try to de stake if they're not already staked. That would cause issues.
01:00:55.185 - 01:01:36.459, Speaker A: It's kind of like a security vulnerability. So let's go here. We're going to grab the clock. So let clock equals clock get and we want to figure out the amount of slots passed since the original time that we staked. So we'll do let slots underscore past equals clock dot slot minus stake info dot stake at slot. All right, so now we know how many times how many slots has passed. Now we need to also get the current stake Amount that we have.
01:01:36.459 - 01:02:09.921, Speaker A: So let stake amount equals contact accounts. This is going to be the stake account dot amount. All right, so we have the amount, we have the slots passed. Now we need to basically calculate the reward. So let's calculate the reward real quick. So let reward equals. So this is kind of like where we need to think about it.
01:02:09.921 - 01:02:47.965, Speaker A: I'm going to make something very simple as the reward. I'm going to make the reward just let's say one token per slot. Most other stake programs, they don't necessarily do this. They do kind of like a token amount based off of the percentage over the circuiting supply per slot. That way they kind of give a specific curve of amount and they know what the end date. Here I'm just giving an amount. So anybody that stakes it doesn't matter how much you stake, you could stake one token, you get one per slot or you can stake 100 tokens, you still get one per slot.
01:02:47.965 - 01:03:53.375, Speaker A: So as homework, what I would recommend is mess around with changing this reward parameter. Try to make it based off of the total amount they stake versus just a set constant amount per slot. All right, just for ease of use, as stated slots passed as U64, we're going to just do checked multiplication. So for each slot we're going to do let's say one use 64 pound. Actually this would be 10, right? Yeah, 10. So for each slot passed, we're just going to do one token. So get the correct amount by doc accounts, mint decimals as U32 and unwrap.
01:03:53.375 - 01:04:21.679, Speaker A: All right, now we need to do a few things. We need to do two different transfers. We need to transfer the rewards that you got to your gold token account. And then finally we need to transfer the current stake back to the token account. So let us do the first one. So let's do the vault one. So if you remember that the vault it was the authority of itself.
01:04:21.679 - 01:04:45.915, Speaker A: So it's a pda. You need to be able to get the signer in order to sign for the transfer from the account back into the user owned token account. So that means you need to get the bump. And this is how you get the bump. You do context bumps. Get this, I'm going to leave that just for a moment. Unwrap.
01:04:45.915 - 01:05:11.745, Speaker A: And so this gets the bump based off of the specific account. So we'll go down here and this will be the stake account or the, sorry, the vault account. So this is token vault account and I'll be able to get the bump from there. So here we go. Token Vault account. Next we're going to get the signer from the bump signer. So this is how what the signer looks like within a program.
01:05:11.745 - 01:05:35.929, Speaker A: So three of those and then U8 equals Amsterdam. Amsterdam. We have our seeds. So constants. This is going to be the vault seed and then the bump. Perfect. So the vault seed in the bump.
01:05:35.929 - 01:06:29.005, Speaker A: Now we can actually do the transfer. So this is going to be like a elevated transfer or an elevated CPI call because we're using the program to sign for a specific pda. So we'll do just as before, transfer CPI context new with signer. This is where things are getting different because we're signing for PDA within the program context accounts dot token program. Because we're going to be signing with the token or we're going to be transferring using an instruction within the token program to account info transfer. Same as before. It's going to be from to authority.
01:06:29.005 - 01:06:54.151, Speaker A: All right, so we're going to be transferring from the vault to the token account. So let's do that transfer real quick. So contacts.accounts. vault token vault account. 2 account info 2. We're going to do the user account. So user or contacts accounts dot token.
01:06:54.151 - 01:07:25.295, Speaker A: I think it's what to user token account to account info. And then finally the authority will be my myself. So we'll just copy and paste it. So token account. All right. Since we need to be able to use the signer to sign for this that we just created, we're going to do signer and. And then finally we need to transfer the specific reward amount.
01:07:25.295 - 01:08:04.615, Speaker A: There we go. So this d stake will calculate the reward. It'll get the signer of the token vault account and then transfer from the token vault account the amount of reward to the user token account. All right, so we have another transfer. In order to do, we need to also transfer from the user stake account to the user's gold token account in their wallet. All right, so let's do let staker so we know what's the staker is context accounts.signer. key let bump.
01:08:04.615 - 01:08:27.485, Speaker A: We're getting the bump because we're going to be signing for a different account. Again, context bumps. Get this one's going to be. Let's see what I called it. Going to de stake down here. It's going to be the stake account to the token account. So we're going to be signing for the stake account.
01:08:27.485 - 01:09:13.834, Speaker A: Perfect. So dot unwrap and then we're going to get the signer. So let signer type equals just as before the seeds, this is going to be staker as well as ref. And then finally, I believe is the bump. So slice with the bump. All right. And then semicolon.
01:09:13.834 - 01:09:57.429, Speaker A: Perfect. Now just as before, we're going to need to do the same transfer CPI call. So transfer. All right, so CPI context new with signer. This is going to be the context accounts token program. We're using the same token program to do the transfer transfer from to authority. All right, so our from will be context accounts dot.
01:09:57.429 - 01:10:24.875, Speaker A: This will be from the. What is it? The user stake account. So stake account 2 account info. The two will be the same two as before. So it'll be to the user token connect token account. And then the authority is itself. All right, so we have it as the signer so that we can sign for it.
01:10:24.875 - 01:11:17.055, Speaker A: And then finally we have the stake amount so that we know the amount that we'll be transferring is equal to the current stake amount. All right. One thing that I want to do real quick is that the stake info, we want to be able to reset it so that we don't have something that might cause some issues later. So we want to make sure that we're not considered staked anymore because we de staked. And then just for. This is not something that you have to do, but I want to make sure that I do it is that I'm going to set it as the current slot so that if there is any issues, the blast radius is smaller because I'll update the slot. All right, let's anchor build it and see if I ran into any errors.
01:11:17.055 - 01:11:32.269, Speaker A: All right. Looks like I ran to a few errors. That's all right. Let's go up to the first error. You always go up to the first error to see what's going on. So in type, ascription cannot be followed by a method call. Let's go see what that is.
01:11:32.269 - 01:11:52.995, Speaker A: That's 101. So right here we're at 101 transfer. Let's see what I did wrong. Oh, so I think what I did wrong is these are parentheses instead of brackets. Easy fix. Let's just grab that, make it a bracket instead and run it again, see what other errors pop up. Looks like I ran to a few more errors.
01:11:52.995 - 01:12:12.965, Speaker A: It says that I don't know what stake account is. Let's see where this is. This is 107. So stake amount. Did I get the amount anywhere? Yeah, I did get the amount up here. So now I need to figure out why it doesn't know what to do there. Oh, it's Because I just don't have a comma.
01:12:12.965 - 01:12:26.857, Speaker A: See, these are just very simple errors. Let's see. Final error. Let's see. No field token program. Okay, and this is in line 82. So accounts token program.
01:12:26.857 - 01:12:47.681, Speaker A: Ah, so I just did it twice. That's easy. And boom, we're all good. So this result may be an error should be handled. Let's see what that means. Unused must be used. That is in line 97.
01:12:47.681 - 01:13:10.565, Speaker A: So this right here, let's just see. I believe that's what you're supposed to do to get rid of it. Yeah, so that was one of them. And then I gotta do the other one as well. Perfect. The last warning is self is unused. Let's remove that and run it.
01:13:10.565 - 01:13:29.313, Speaker A: Boom. Look at that. No warnings because we use all the variables and it compiled successfully. So let's go test it out. So what we're going to do is we're going to create yet another integration test and this integration test will be for destaking. So. So integration test.
01:13:29.313 - 01:14:11.217, Speaker A: D stake equals async function call. All right, we need to get all the accounts in order to do the D state call. So first off, I'm just going to grab this transaction real quick, paste it and then we're also going to paste the transaction signature line. There we go. And let's just remove these accounts and the signers and we're going to just have the call of dstake. All right, so we're de staking. We're calling the RPC call now.
01:14:11.217 - 01:14:42.111, Speaker A: We know that from previously. We need to have all the accounts that are required for this instruction and the pair in order to pay for this instruction. So we're going to do signers. This is going to be payer pair and accounts. All right, so let's go fill these accounts. We need all these different accounts. What's great is previously we got all these accounts already.
01:14:42.111 - 01:15:05.579, Speaker A: So it actually makes it really nice for us. So we can just do this. Get all these accounts, put them all here, we don't need them into anymore because it already has some amount in it. So we have the user token account, we have a stake info. We have a stake account. We still need the we sell it so vault. We don't have the vault.
01:15:05.579 - 01:15:42.695, Speaker A: So let's go grab the vault from up here. All right, so we have all the accounts now. So we have the user token account, stake info account, stake account and the vault account. So let's fill this out. So stake account will be stake account stake info account will be stake info. This will be User token account will be the user token account address because it's not an address. It's called a, let's see, it's called an account.
01:15:42.695 - 01:16:14.085, Speaker A: So we have to make sure we get the address. We have the vault account which is the vault. We have our signer which is pair.public key. And we have and finally our mint which is mint key, pair public key. All right, so we have the all the accounts. We got all the accounts and we're trying to do the following.
01:16:14.085 - 01:17:00.492, Speaker A: Our instructions should pull tokens from the gold token vault, move them to the gold token account and then also pull tokens from the user stake account and pull them and de stake them into the gold token account. And finally the stake info should be updated. Now if we run this, this should run to an error and I believe it should be, if I'm not incorrect, it should be 0x1. So let's get it, let's see if we hit that error and then we'll explain what it is. All right, perfect. So we ran into an error dstake 0x1 custom program error 0x1. So let me explain what that is.
01:17:00.492 - 01:17:43.115, Speaker A: Okay, so 0x1, let's think about it. We ran into an error for DE staking. What could that mean? So as mentioned before, we're grabbing the rewards from the token vault, putting them into our token account, grabbing the rewards from their user stake account and putting it into our token account. If we look up the error. So 0x1 is coming from token so we can see 0 would be error, not rent exempt. Oh, but 0x1 would be insufficient funds for this operation. So transferring from one of these token accounts is telling us that it does not have the funds to transfer from that token account back to our user owned token account.
01:17:43.115 - 01:18:09.131, Speaker A: We know that we deposited the funds to the user staking account so we know that there's already funds there. However, that gold token vault never received funds. So it's just sitting there with zero funds and we're trying to grab rewards from it. And essentially because we're doing that, it has zero funds. We're running into this insufficient funds error. So let's go fix that. So going back to the test here, we know that this vault account does not have enough rewards.
01:18:09.131 - 01:18:31.515, Speaker A: So let's mint a bunch of the tokens to that vault account. So what we do is we do await Mint 2 and it's connection. We need the pair. So it's once again pair dot pair. We'll need the mint. So mint key, pair dot public key. We will need to make sure that we're minting to the vault account.
01:18:31.515 - 01:19:03.261, Speaker A: The owner is pair, pair or this is the. This is the authority. And finally, we want to just mint a whole bunch. So let's just do 20, 21. So what this does is this is making sure that we're minting a bunch of tokens to the vault account to guarantee that we have enough to distribute as rewards afterwards. All right, so let's run the test and see if it works. So if everything worked just fine, then we should have it initialized.
01:19:03.261 - 01:19:48.835, Speaker A: It should stake and then destake. So look at that. We have all three passing and we have completed running the test and checking that our staking program work worked, both initializing staking and de staking. To reiterate what we did, we created a stake program that allowed people to deposit their tokens on in it and get rewards of the same token. There are a number of things that you can do with this. Like for example, the original example given the woodcutters generating wood by depositing those woodcutter tokens and generating the wood token. In our case, we took our gold tokens from seven seas and generated even more gold tokens.
01:19:48.835 - 01:19:55.255, Speaker A: So look out for the rest of the boot camp and thank you for joining us. Bye.
