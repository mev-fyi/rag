00:00:04.560 - 00:00:06.474, Speaker A: All right, Andre, welcome to validated.
00:00:06.934 - 00:00:09.862, Speaker B: Hello, Austin, it's very nice to see you.
00:00:10.038 - 00:00:44.044, Speaker A: Well, I think we'll have a good conversation today. I wanted you on to talk about Neon. And Neon is this Ethereum virtual machine emulation layer that's been deployed on top of Solana. It's not an l two, it's not a roll up. It is sort of a full emulation of the Ethereum stack on top of Solana, which is a pretty unique approach. I don't think we've seen different VM layers deployed on top of existing VM layers that aren't making use of something like a roll up or an l two. So it's a pretty unique design.
00:00:44.044 - 00:01:39.224, Speaker A: You guys have done a ton of engineering work to make this possible. And one of the things I think is interesting that I want to talk a bunch about is the ability to build transactions that reference programs built in EVM deployed on neon, that also reference programs and transaction data built in SVM and deployed on the Solana base layer as well. So I'm really excited to get into the details of this with you today. So I want to start a little bit today with why build an EVM layer on top of Solana? There are a lot of EVM execution environments out there today. Solana has sort of famously not had Ethereum support and EVM support. So talk to me a little bit about why this project was interesting to you and sort of what some of the use cases you see are for bringing the EVM onto Solana.
00:01:39.564 - 00:02:14.400, Speaker B: Solana has a unique feature. It's allowed to execute transactions in parallel. It is impossible. And at the same time I said before, it has unique architecture which allow to build any type of project on the Solana. It is very useful. And right now neon EVM is the first virtual machine for Ethereum which can run transactions in parallel. You don't have such evms on the market.
00:02:14.400 - 00:03:15.960, Speaker B: All of them work in the classical way how they process transactions. Yes, right now there are different projects which try implementing other way how they execute these transactions. But they need the time they will face with different problems, they will find different bugs and so on. When neon evm right now on Solana Mynet and you can run ethereum like transactions. You can deploy any Ethereum application from the Ethereum ecosystem on the Solana and execute Ethereum transaction. And you will use Ethereum tool chain, Ethereum wallets, Ethereum frameworks, testing tools, everything, travel, open zeppelin and other tools and you will have already existed infrastructure of the Ethereum. But on Solana and Neon EVM.
00:03:15.960 - 00:03:58.814, Speaker B: It's not only Ethereum virtual machine, it's an ecosystem of ethereum on the Solana. And we integrate different components from the Ethereum to Solana. And you can use exist projects, you can use exist tools, all of them works. And it's nice. It's a great opportunity for developers who want to create a new application. And he think, oh, this application has good features, but it can be combined with features from another project. We can build it, or we can run this application on the Solana with great performance.
00:03:58.814 - 00:04:13.484, Speaker B: It was our goals, our ideas, what we can bring to the Ethereum community. To the Solana community.
00:04:14.304 - 00:04:30.128, Speaker A: Yeah, it's a really great vision. I do think Neon does not get enough credit for being the first parallel EVM implementation to actually ship to production. Talk to me a little bit about how Neon is built for parallel EVM.
00:04:30.176 - 00:05:14.598, Speaker B: Transactions we made right now. Neon EVM is an additional implementation of Ethereum virtual machine. At the start, we tried to compile an existing variant of ethereum virtual machine and execute on the Solana, but we faced that. It used a lot of compute units, it's gas and Solana, and it was a very long way how we optimized internal structures and internal processing inside of EVM. And for example, when we started the swap of tokens in uniswap version two, took more than 20 million of compute units in one transaction. It was incredible, right?
00:05:14.646 - 00:05:18.794, Speaker A: And that's about half of all of the compute units in the Solana block.
00:05:19.294 - 00:06:07.150, Speaker B: Yes, yes. You made the modification inside the Solana core and compiled custom version of the Solana to execute such big transaction. But then we implement an additional method for execute such long transaction. But right now, swap of two tokens in Uniswap takes 400, no, not 600,000 of computing, so it can be executed in one Solana transaction. It was one step. The next step for us was how we optimize the internals structures which Ethereum virtual machines stores in state. In state.
00:06:07.150 - 00:07:12.744, Speaker B: In Ethereum, you have a big hash table with key and value, but value has a very small size, it is only 32 bytes. When on Solana you have one account which can grow up to ten megabytes. And it's a very big advantage for Solana. So we have a contract and we have internal variables. Internal variables of the contract has the values and compiler creates a unique key for each variable and store its value inside of this big hash table. Contract has its own tree of the values and what we did for Solana, we split this big tree into chunks and stores them in separated Solana accounts. For Solana, it means that these chunks has independent data and they can be used in different transactions independently and can be run in parallel.
00:07:12.744 - 00:08:38.674, Speaker B: It's why we split into chunks for two reasons. For example, how Ethereum store long string inside of this bigtable, split it into chunks and store chunks in separated cells in the Ethereum hash table Mercury Patricia Tracy if you know and when you need check your values, your string inside of the contract, it gets all these chunks from the, from the state. Join all these chunks in one thing and then you can do what you want. And for example, if in our contract on neon EVM, your contract use a long string and it is split in the chunks, this string will be stored in one salon account, it will be not split in different accounts. The same happens with string structures inside of ethereum virtual machine. If you have a structure with different fields and it's a big packet of the memory which is stored in different chunks, but in EVM, it's stored in one solana account. Maybe it can be split in two, but in most cases it will be stored inside of one.
00:08:38.674 - 00:09:38.904, Speaker B: So if you have two users, and these two users send transactions to the contract on the EVM, they will use different data in the transaction. So it means that such transaction can be executed in parallel because they use one contract, but they use different data inside of this contract. For another variance. How you can implement parallel execution in other chains? It will be more difficult to find differences and split with data and find how you can run them in parallel. So we use parallel execution of Solana. I think we have ways how we can improve the performance and then we will do it. Right now it looks optimal for the current moment.
00:09:38.904 - 00:09:47.140, Speaker B: And yes, we widely use all features of the Solana inside of neon EV.
00:09:47.332 - 00:10:00.104, Speaker A: Yeah. So speaking of performance, when you're looking at neon today, how does it stack up compared to some of the l two solutions that have been deployed on ethereum in terms of performance?
00:10:00.904 - 00:10:56.976, Speaker B: In terms of performance, we made several experiments. If you run our neon EVM on the local stands, we can create custom version of the Solana and we can create more than four pipelines inside of our version of the Solana. Four pipelines, it's configuration of the mainnet of Solana and Testnet and the net. And we can run a really huge amount of transactions. We only limit it on the hardware on which we run it. So you can build a really high performance roll up on the Solana and EVM. If you're talking about Solana Minnet and Devnet in August, maybe not August.
00:10:56.976 - 00:11:56.544, Speaker B: In September we run tests on Solana Minet on the rail cluster and we reached 7778 transactions per second on the live cluster. It means that at this moment it was not only one neon EVM in the network, there were other Solana programs and all of them tried to execute transactions. And we reach this number on the real cluster. It's great. You have a big cluster with a lot of nodes in the network. It's a live system which reach consensus very fast. And at the same time a simple test show us that we can execute so many transactions which impossible in other ethereum like networks.
00:11:57.164 - 00:12:15.184, Speaker A: Yeah, I was going to say that number is pretty close to the theoretical limit of all l two s and all roll ups combined, which is about 880 transactions per second across every single l two and roll up on Ethereum. So getting into the 700s while operating on the Solana mainnet is quite impressive.
00:12:15.564 - 00:12:55.408, Speaker B: Yes, we are surprised it really we thought, okay, we will reach 500 DP's and it will be enough. Yes, our goal was to reach 1000, but we understand that in Solana we have NAS applications and it's not so easy. I want to say that right now in the Solana there are a lot of activity and it will be not so simple. But in November we try it again and again reach more than 700 of transactions per second.
00:12:55.536 - 00:13:14.974, Speaker A: So what are some of the use cases that folks are actually using neon for now? I imagine there's a lot of conversations that have to happen when you're trying to get Ethereum teams to look at deploying something on Solana, even if they still are doing it in EvM through neon.
00:13:15.674 - 00:14:27.916, Speaker B: Yes, we have a lot of conversation with different teams and it's normal that for major applications on Ethereum, they want a stable system and they want some period of stable work. It's okay for them, they have a reputation and so on. And for us it's a challenge to agree that they are ready to deploy new vm. But at the same time, Ethereum community big and there are a lot of independent teams who are ready to fork existing protocols and execute these protocols on any Ethereum like chains. You have Uniswap, but you have a lot of forks of Uniswap, and most of them are very popular. Not only one uniswap in the Ethereum, and the same happens with other projects too. And for mature projects, it's a step for testing of the neon EVM and they can check that.
00:14:27.916 - 00:14:42.074, Speaker B: Okay, it works. Okay, we are ready to go to the neon and Solana, and it's our way how we want to invite big projects to the Solana.
00:14:42.494 - 00:15:32.594, Speaker A: Yeah, I really love that kind of vision for how this all comes together, where you actually see projects deploying on neon the same way you'd see them deploying on any other EVM execution environment that's open to them. I want to talk a little bit about decentralization and security of this. I mean, as most folks listening to this podcast know, the Ethereum l two landscape is, there's a lot of options, but decentralization is not a key component of any of those options today. Most run on either fully permissioned networks or they run on single sequencers. How is neon structured in terms of decentralization, if that is part of the network today? And sort of how are you guys thinking about that into the future?
00:15:33.884 - 00:17:22.546, Speaker B: Okay, it's a very interesting question, because when we started our project and we have one unique feature which allow us to execute a really huge transaction on the Solana, we can use much more than 30 million of gas, which is available on the Ethereum, because we split our transaction in small chunks and we execute the them on the Solana, and we finalize our step on the, on the final iteration. We call our small chunks iterations. But this way of execution has one denial service attack, which was described by the neodym. And then how you can. What is the challenge for us? What is the final step of how to say it? We need this final step, but during execution can happen different years. For example, we can communicate with Solana program and it can, some error can happen, and we should interrupt our transaction in the middle of execution and say to user, you have a bad result of the execution. It's okay for Ethereum, but for us it means that we should find way how we check with failing on the neon EVM, we should allow to interrupt any transaction, but this interruption should be valid for, for the transaction.
00:17:22.546 - 00:18:00.534, Speaker B: And this is a challenge for us. That is why in the current implementation, we have a white list of operators, and only operators from the trusted list can execute transaction. On the Solana, we don't have limits on amount of these operators who execute transaction. And so from the, from the start point, we already have more than one point for transaction execution. So we already decentralized it, but we still have a trust at least, right?
00:18:00.694 - 00:18:05.354, Speaker A: Which is similar, to be fair, that's similar to all the l two s that are in production today.
00:18:05.694 - 00:18:55.312, Speaker B: Yes, yes. But we found the decision, and right now NVM. Oh, neodymium is audit our way how we will execute such long transaction. And they said okay, it looks nice, it looks ambitious, but it should work. Okay, so not in this release, which we planned in April, but in the next which should happen in May, maybe in June, we will remove our whitelist and our platform will become really decentralized. Anyone will have ability to execute any transaction on neon EVM without any limitations. So from this perspective we look decentralized.
00:18:55.312 - 00:19:56.464, Speaker B: In additional moment. Users should understand that all transaction on neon EVM is validated by Solana validated leaders, validators. And it's a very big network and it's very difficult to make something wrong with the execution. Everything is recording in the Solana block log in Solana transaction and everything can be checked. It's a very big difference with l two decision for Ethereum where you have a separated node node which execute transaction and you need some additional tools to verify that all these transactions was processed with write rules with all checks of security and so on. You already have all these checks from the box by Solana validators, by its engine of Solana of transaction processing.
00:19:57.124 - 00:20:42.494, Speaker A: Yeah, I mean that's really impressive to hear that you guys are this close to actually opening it up from a permissionless standpoint. That's really awesome to hear. I didn't realize that was so close. I do want to talk a little bit about how programs on neon EVM can interact with programs on the Solana base layer as well, because that is one of the pieces here. That is, I think pretty special to what you guys have done from an implementation standpoint. Right now, you cannot have atomic transactions between base and the Ethereum l one today. But there is a model where you can do an atomic transaction between the neon EVM and say a defi market hosted on Solana.
00:20:43.754 - 00:22:06.692, Speaker B: Yes, we have a lot of differences between Ethereum structure and Solana. We have a lot of difference how Solana checks signatures and permissions on the object on the Solana state and how it is done, how Ethereum do it. In Ethereum, each contract has permissions only on the state which it owns. On Solana, when you sign the transaction, if you sign this transaction and if you owner of the object, the program will have access to this object on the state. And for us was challenged how we can combine these two different permission system and we resolve this issue. It is on the audit in neodym and we protect all assets of users on the EVM site and we can call any Selana programs, but it is not the final implementation we will continue working with integration. And Ethereum application has a more complex logic inside of the contracts.
00:22:06.692 - 00:23:23.704, Speaker B: They can have a very big stack of the calls. And on each stack level you have a different contract which has its own logic. So you have a lot of logic which should be done during execution to do it. As I said before, we have implemented the iterative mode of execution, but it is not compatible with calling of Solana programs, because if we call Salana program, it makes changes directly to Solana state. When EVM contracts, collect this data in the EVM temporary objects and the EVM apply these changes on the final step. So what we will do right now, we have a layer which allow us to call any cylinder program, any, it may be metaplex, it may be ork, it may be radium, any other. And we need to integrate this layer, this functionality with Ethereum like application, which don't think about performance, it does a lot of things, it uses a lot of computing units and so on.
00:23:23.704 - 00:24:01.624, Speaker B: So what we will do, we will split our transaction into part. In the first part, we will run Ethereum application, it will do its logic, it's long, it's use a lot of resources, and so on and on the final step, we apply all changes from the Ethereum application and then call Solana program, and it will happen only in one Solana transaction. So this is our way how we will implement otomic for these combined transactions, which contains two different types of applications.
00:24:02.524 - 00:24:03.020, Speaker A: Very cool.
00:24:03.052 - 00:24:03.804, Speaker B: This is our plan.
00:24:03.884 - 00:24:50.814, Speaker A: Yeah, no, I kind of love that vision of how these things can coexist and interoperate with one another, because that is one of the, one of the interesting visions about Solana is it is a network with one state, one global state. But it doesn't necessarily mean that it can't have multiple VM layers executing, executing on it. It just means that that all exists in the same state. So I want to talk a little bit about a program that's executing on neon. Where does its state live? How does it actually track data associated with the current state of the program? Walk me through a little bit of that data structure.
00:24:52.314 - 00:25:25.356, Speaker B: Okay. NeonVM stores all its data inside of Solana state. We have different types of accounts. It can be contract and can be end user without contract. It can be storage of the contract with, I don't know the balances of your c 20. Contract is a mapping object which is storing inside of the contract, storage in variables. And we split all these types of accounts.
00:25:25.356 - 00:26:08.794, Speaker B: In the Solana accounts they have, each type of accounts has its own structure. It's okay. What we did outside of Solana. In Ethereum, all data is storing inside of mercury. Patricia three and it has feature which allow to collect historical data. You can historical Ethereum nodes collect all information in the state and they have API to get historical data from it. And also it is allowed to debug transaction on these old data.
00:26:08.794 - 00:26:44.264, Speaker B: We don't build this historical data inside of Solana state. It will be very expensive. It will increase the cost of our transaction. But it's not critical information for the transaction execution. So, okay, so we can build these information outside of Solana, we can collect this information in additional service. And Solana already has infrastructure for it. It has geyser plugin inside of Solana and we use it to collect these account changes.
00:26:45.004 - 00:26:50.864, Speaker A: That's interesting. You're actually using geyser to pull this data in, not like an Ethereum specific tool.
00:26:51.264 - 00:27:16.124, Speaker B: Yes, yes. We collect this information and build API which provide you access to this historical data. And we built Ethereum like APIs. So you can use Ethereum tools tool to use it to debug transaction to get information about all balances and so on and so on and so on.
00:27:16.304 - 00:27:19.784, Speaker A: That's very cool. I didn't realize that's how you guys were doing it. That's a great solution.
00:27:20.844 - 00:27:54.556, Speaker B: Yes. Someone teaches us to build a modular architecture. You shouldn't do everything in one place. Your application should do main functionality, it should provide you function to execute transaction. You can get the balance, you can get the state and so on. All other stuff can be done outside of Solana node. And it's great with the decision of Solana team.
00:27:54.556 - 00:28:10.674, Speaker B: It's allow your team to create great architectures. You can separate transaction processing and separate the RPC layer which return you to the data. We like it.
00:28:10.804 - 00:28:54.274, Speaker A: That's great. When you're looking at neon hitting these very high TPS numbers in these benchmarks you guys have run on Mainnet, what are the types of applications and developers that are looking to build on neon? Are you finding it's a lot of developers on EVM environments that maybe have struggled with scale and performance? Or is this, you know, institutional applications where they say we have our EVM code, we've audited it 10,000 times, we don't want to rebuild stuff for running on Solana native. What's the sort of the profiles of different developers and teams that are excited about neon?
00:28:56.134 - 00:29:45.128, Speaker B: Yes, it's an interesting question. From one hand, we have platforms, so we should provide the ability to execute any type of. But it's true. And when we built our platform, we should check that everything will be okay with such type of application. Because as I said before, it is possible to run separated Solana node, deploy new vm and run such application on it. It will be roll up, it will be used everything from the Ethereum. But if you're talking about Solana Mainnet, it looks like that it's more interesting for fast applications where you need more interaction with the user.
00:29:45.128 - 00:30:10.170, Speaker B: It can be games, for example, it can be fast Dexs, where you exchange tokens and so on. But we can have institutional application which provide, I don't know, insurers, for example. Why not?
00:30:10.282 - 00:30:46.624, Speaker A: Interesting. Yeah. And so as you sort of look forward to the future of Dion, you mentioned sort of this idea that this code can be used in some different ways, that it may end up being built on some roll ups. Where do you see this technology that neon has developed deploying? Do you see this as sort of. Some people might run actually private instances of neon on top of a private instance of Solana as sort of like an alternative, like an enterprise blockchain type solution? Or do you see most of the future of neon as being on Solana Mainnet?
00:30:46.744 - 00:31:36.214, Speaker B: Solana will have the same way as Ethereum. Ethereum is a central core of of roll ups where they collect all information. I think the same will happen with Solana. Solana has a great performance, but it can provide more fast layer for such decisions. You can take the Solana, the future of the Solana in Mainnet. You will have proofs of the executions from different labs, but these roll ups will be built on the Solana too. And all these information, all these transactions will be executed on the roll ups near the Solana Minot.
00:31:36.214 - 00:32:37.144, Speaker B: And it is the future because, yes, it's cool that you can run a lot of transactions on one layer, it's nice. But for example, if you need a fast game for users, you can create zero app based on the Solana. You can decrease time of one block for faster confirmations and so on. And for users, it will be more responsible UI and at the same time it will be safe for user because everything will be proof of this execution will be on the Solana Mainnet, which already has a lot of validators, and it is security decision, but it has much greater performance than Ethereum.
00:32:38.324 - 00:33:11.324, Speaker A: Very interesting. Are you guys thinking of extending the EVM and making modifications to that core layer to make it more performant with some of the other things you've talked about? I know, for example, there's a number of roll ups and LSU solutions that are actually starting to say very much like Apple has done with AirPods. They're Bluetooth headphones, but there's some special features when you're using Apple stuff. Are you guys thinking of sort of expanding what's possible on the EVM core?
00:33:12.424 - 00:33:53.848, Speaker B: Yes, yes, we are thinking about it. And if, and via program, via program, which can be modified very fast, you don't need any. You shouldn't upgrade Solana nodes in the Solana magnet. We can bring our features independent from the Solana, and our features can be delivered much faster than it is possible in other blockchain decisions. Because we are programmed, we can be upgraded at any moment with any functionality and so on. And it's a very great feature and we should use it. Yes.
00:33:53.848 - 00:34:52.386, Speaker B: We are thinking, for example, for example, Ethereum for a long time discuss how they can extract payments on the Ethereum and how can they use different tokens. The first proposal was in 2016, as I remember, it was about nonsense, how they can be implemented in contract layout and how transaction can be executed on the salon. Right now we have 43 37. Yep. About account abstraction layer and it is a very long evolution of it. They don't want to implement it inside of blockchain node, inside of EVM, because it will require a lot of audit. They should check that they didn't make some mistake and so on.
00:34:52.386 - 00:35:30.664, Speaker B: That is why they try to implement it outside of the core. Right. But for us, we already working inside of sandbox of Solana virtual machine, and if something wrong with the logic and we try to access to not existing memory point, it will be failed by the. And we have this advantage. So we can, we can develop our virtual machine much faster than it is possible in Ethereum community.
00:35:31.284 - 00:35:39.864, Speaker A: That's so interesting. I never would have thought of it that way. That because you're running on the constraints of the SVM, there's actually a safety layer in there.
00:35:40.204 - 00:35:56.954, Speaker B: Yes, it's more safety than it is in the ethereum ecosystem. Our EVM works inside of sandbox and we use this safe mode deeply. Yes, it's true.
00:35:57.254 - 00:36:03.714, Speaker A: Is there anything else on neon that you think is important for us to talk about that we haven't touched on today?
00:36:05.494 - 00:36:09.114, Speaker B: We didn't cover multi token payments.
00:36:09.854 - 00:36:12.074, Speaker A: Oh yeah, we should talk about that.
00:36:12.524 - 00:36:13.020, Speaker B: Yes.
00:36:13.092 - 00:36:26.304, Speaker A: Yeah. So you're basically talking about the systems where you can have multiple tokens on neon, but also at some point there's a gas token that you need to pay to actually pay for these transactions. How does that structure work.
00:36:27.204 - 00:37:18.652, Speaker B: Okay. It's a very interesting decision. It was, we discussed abstraction account layer from the Solana from the field. I'm sorry, I still like Solana. Okay. We discussed the account abstraction layer from the Ethereum and for us it was, it was interesting. Why so long? Why it's so complex, why they use so many abstraction layers inside of transaction processing? And we think, okay, can we use something inside of ethereum protocol which can be used for payment in other tokens than neon? And at the same time it will be very easy to integrate with existing ethereum tools.
00:37:18.652 - 00:38:48.564, Speaker B: And we found it, we found that we can change the chain id inside of transaction and there are no any limitations on the protocol level when we have different transactions from different chain with different chain ids and all of them can be run on one layer. Okay, interesting. So, and what we can, what we can do with it, we can implement payment in different tokens. And it's very safe because in ethereum abstraction layer they have an additional proposal. I don't remember the number, but it is about how protect the bundler layer who execute transaction on the ethereum from the malicious sector. Because you can send transaction and they still have cases when is possible, don't pay for this transaction, it will be a denial service attack. And ok, and what is the difference with the pain by the native token? Because this token is based on the blockchain level and.
00:38:48.564 - 00:39:55.548, Speaker B: Okay, nice. So we can create tokens on the EVM level and use different chain ids and provide ability to use different tokens which is linked to this chain id. Nice. So we can give guarantees for users and for operators that their transaction can be executed on EVM and the operator will receive payments without any problems because it is protected by the EVM user can use different tokens and this token can be native from one side. But we want to go forward and create an additional layer which provide your c 20 interface to these tokens, so you can use the same tokens for the transaction payment and for using different applications in Dexs and in games and so on. It is universal way how we can do it. It looks amazing because we don't change anything inside of the protocol.
00:39:55.548 - 00:40:14.926, Speaker B: We use existing protocol and anyone can use existing tools and no differences. You can use old wallets, you can use old clients, old applications, and all of them will work without any modifications. Sorry, that's really interesting.
00:40:15.100 - 00:40:36.254, Speaker A: I hadn't heard that approach before. I love that approach to a multi wallet, multi token world in the way you're talking about it. I guess one thing we haven't covered today before we wrap up is there is a neon token. What is the functionality of the neon token in this ethereum on Solana ecosystem?
00:40:37.114 - 00:41:25.450, Speaker B: Okay, about neon token neon token has more than one function. One of the functions pay for transaction. But we will increase the amount of tokens, the number of tokens which can be used by users. Also this token is used by the governance. It's your void for upgrading of EVM, your void for your void, how we can develop our EVM and so on. And also we won't implement an additional functionality for staking of neon it's ability. How operators can I need describe more details.
00:41:25.482 - 00:41:26.054, Speaker A: Sure.
00:41:26.514 - 00:42:18.840, Speaker B: Okay. Ethereum transaction has big size and the Solana transaction is small. And we need additional accounts on the Solana layer in which we should store the transactions. At the same time we use these accounts for iterative mode. We store inside these accounts the state of EVM, the temporary data between iterations which we apply at the final step. Okay, so our operators should create this account and they should pay in sales. But we find interesting decisions that operators can stake new on tokens instead of sold tokens and they can stake user tokens.
00:42:18.840 - 00:43:26.184, Speaker B: And for creating more holder accounts on the state they can process more transactions in parallel and they will pay to users by earning tokens. For example, one user executes transaction and paying USDC operator receive these tokens to his balance and pay percent to the users who delegate then the neon tokens. So it's a way how neon tokens can be staked in the platform and it is way how users can earn money on the neon tokens and so on the same security level as in blockchain. It's a way how neon execute transaction. You stake tokens, neon tokens and you receive money. But neon doesn't have emission inside. We don't produce new neons.
00:43:26.184 - 00:43:32.904, Speaker B: We play in other tokens than neon. Okay.
00:43:33.064 - 00:43:37.624, Speaker A: Well. Yes Audrey, thank you so much for joining us on validated today.
