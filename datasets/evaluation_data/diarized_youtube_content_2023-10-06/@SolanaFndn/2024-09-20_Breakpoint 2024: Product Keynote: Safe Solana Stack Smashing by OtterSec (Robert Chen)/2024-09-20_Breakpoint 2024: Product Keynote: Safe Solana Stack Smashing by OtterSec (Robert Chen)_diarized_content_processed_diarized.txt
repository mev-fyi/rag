00:00:03.840 - 00:00:34.075, Speaker A: This isn't a product keynote. I wanted to talk about some cool Solana bugs. This is a pretty common bug class that we've seen. Some of you, if you're Solana developers, might have seen it as well. Your stack gets randomly corrupted. This is probably a bit more of a technical talk, so hopefully it will be understandable for developers. But yeah, so not that many people know this, but this is a pretty pervasive problem since around a year ago.
00:00:34.075 - 00:01:14.323, Speaker A: The root cause is a bug in the Solana compiler. I think Jerry did a tweet about this a few months ago. We work with a lot of Solana teams as well who have ran into this problem. If you are a Solana developer, you might have seen this if you your slaughter program randomly and mysteriously changes its state. So for example, here's a message. You run the program and all of a sudden your variables change on the stack. Unfortunately, the reason why this happens is pretty hard to understand unless you actually dig into what's happening low level.
00:01:14.323 - 00:01:58.539, Speaker A: And the purpose of this talk is to hopefully make this issue legible to more developers. So I have a couple of examples here. All the examples are an entirely safe rust, so you should be able to read the code and if the compiler was working as intended, the result should be relatively straightforward. So the first one is we have an outer function that get inlined in these examples. I use stdint blackbox, which doesn't do anything. This is just a compiler hint. It's not really relevant for purposes of these examples.
00:01:58.539 - 00:02:57.153, Speaker A: And you could replace this with any other syscall like a solog, for example. So in our example we have an outer function that allocates a variable called isadmin, then we call an inner function and the inner function does a variety of different stack shenanigans. And the question is what happens here when you try to run it and critically does is admin change. So here we're allocating 1000 bytes and it's fine, you can run this. And hopefully as expected, the variable on the stack does not change at all. What happens if you do it with an array of length 4096 or 1000 in hex? For those of you who don't know, stack frames in Solana are this size. So each time you do a function call, you have up to 0 to 1000 bytes of stack space available for you.
00:02:57.153 - 00:03:40.441, Speaker A: And you'll notice that when you compile this there is a compiler warning. Importantly, this is a warning, an error. So you can, you know, if you don't look too carefully at your compilation logs, you can end up, you know, ignoring this. If you're a developer, maybe you should check if you have any warnings when you're compiling your programs. So in this case, we allocate exactly the number of bytes in a stack frame in the array in the inner function call, and we don't crash. The is admin variable is still unchanged. What if we do 0x1001, so 4096.1
00:03:40.441 - 00:04:18.475, Speaker A: bytes, and, you know, the choice of this number probably already gives you the answer here. You'll note that the stack offset increases by 1 in the compiler warning. And yeah, the warning Messages increased by 1. And you know, for those who are astute, it does crash, which is, you know, I think, pretty astonishing if you're writing a Solana program. The implication here is that, you know, your code can, you know, this is completely safe for U.S. code. You're not doing anything magical here.
00:04:18.475 - 00:05:03.851, Speaker A: But because you allocated a lot of bytes on the stack, you overwrote a variable in the previous function frame. And, you know, I want to see what actually happens here. So this is going to be a bit lower level. This is all assembly, I guess, as a brief primer, you have a bunch of variables, a bunch of registers. R10 is the stack variable, so that corresponds over the stack. So when you start the function call of outer, you have R10 set to some value. Then you allocate and this is a bit out of scope with this example, but you allocate a pointer on the stack and you can see hopefully here the line which I highlighted, where you do R10 minus 8.
00:05:03.851 - 00:05:39.485, Speaker A: So you take the pointer R10, you subtract 8 and you allocate a variable there. Then you allocate the is administrative. This is 4 bytes Rust integers by default are I32. So this is 32 bit int. You can see here's R 1012, which is 8 plus 4. Then we do a function call. And what the interpreter does, which I have here, is it adds 0x1000 stack frame size to R10 and then it jumps to the assembly code of the other function.
00:05:39.485 - 00:06:21.185, Speaker A: Again, we allocate a pointer. Again, this is the outer scope of this talk, but then we allocate a bunch of stack space. And Importantly, we allocate 0x1001. So if you do a bit of math here, this exceeds the stack frame, it exceeds the amount that we incremented R10, and it sets all the memory here to 1. And what this means is when we do 01001 of allocation on the stack we overwrite ISadmin variable. So this is actually what is happening under the hood. This is why we're able to in completely say for us, change the value of a previous stack variable.
00:06:21.185 - 00:07:13.305, Speaker A: This also explains why it doesn't happen when you do a value of 0 to 1000. If the size of the buffer was only 0 to 1000, you'll notice that we overwrite uptoptr, but importantly we don't overwrite the ISadmin variable. One question you might ask yourself is are the compiler warnings sufficient? And good question. Unfortunately not. So this is an example where you use 0 to 1000 minus 8 bytes of stack space and it still causes an overwrite of the is admin variable. This talk was only supposed to be five minutes, so this is left as an exercise to the reader. But if you're able to figure this out, I'd be curious to get your thoughts on why you think this also fails.
00:07:13.305 - 00:07:48.919, Speaker A: One hint is around the RBPF calling convention. So specifically, how do you pass in a large number of stack variables? Yeah, hopefully this this is a pretty motivating example. The solution As a note, all of these are in I think v1.18, but they're patched in Anza's v2.0 back v2.0, so hopefully none of this will be an issue in a few weeks. If you're a slot developer writing a program, and this is what we tell our clients, one thing you can do is you can disable direct mapping to test.
00:07:48.919 - 00:08:37.801, Speaker A: And the reason for this is enable stack frame gaps. When you enable stack frame gaps. That's funny. When you enable stack frame gaps, this causes the overflow to be caught. Specifically, it makes it so that the area or the memory in between stack frames are not writable. So this is actually a pretty good way to catch essentially every stack overflow issue, or almost every. You can also check for compiler warnings.
00:08:37.801 - 00:09:05.795, Speaker A: I think this is honestly the compiler should probably error here, but if you see one of these errors, maybe you should try to optimize your stack a bit more. The last thing, and hopefully you never have to do this, is to actually read the assembly. And hopefully this presentation gave you some insight into what the assembly actually looks like and what it's doing under the hood. Okay, sweet. Thanks for having me.
