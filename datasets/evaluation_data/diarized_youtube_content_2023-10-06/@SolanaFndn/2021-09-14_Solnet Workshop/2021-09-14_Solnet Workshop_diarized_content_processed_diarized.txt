00:00:07.920 - 00:00:46.184, Speaker A: Hello, everyone. Sorry for the delay. We're having some slight technical issues with Internet. So I'm Thiago and he's my brother, Google. We're both the developers of Solnet, the original developers. I mean, we already have a few contributions. So I guess I'm going to start by showing the page of the project and talk a bit to what led us here.
00:00:46.184 - 00:01:12.168, Speaker A: Where is the screen sharing? Oh, my God. I haven't used zoom in a while. Okay, is it working?
00:01:12.256 - 00:01:12.924, Speaker B: Yeah.
00:01:17.264 - 00:01:59.504, Speaker A: Okay, so in this Gita page, the block mounting page, you can find all the projects that we're working on, both related and some not directly related to Sonnet. Currently we have Sonnet as the main repo. We have the barely minted Sonnet anchor repo, and still not finished, the Metaplex one, Raytheon. And what am I missing? Google.
00:02:01.204 - 00:02:02.252, Speaker B: There's also.
00:02:02.428 - 00:02:05.344, Speaker A: Okay, yeah, the zero one.
00:02:05.684 - 00:02:16.284, Speaker B: Yeah. And there's also the Devon figure library, which is already quite old. It doesn't touch in like three months or almost.
00:02:21.704 - 00:03:07.688, Speaker A: There's something still not yet public because it's still very early. But you'll soon find more about it. And it's the reason that led us to create Sonnet in the first place. So, going a bit for history reasons, in context, um, we started developing Solnet. In the previous hackathon. We had another idea, but when we started delving into code and trying to develop that idea, we found out that there was no c sharp SDK. So basically we changed our mind.
00:03:07.688 - 00:04:22.384, Speaker A: Back then we started with Solnit, and now we have the tools that allow us to actually develop that tool. This was only four months ago. So for anyone out there who thinks it's too late or is not sure if this is the right move to make to develop for Solana, I encourage you to actually start reading. Either try to find something that you feel like it's missing, or maybe contribute to the several other, or even Sonnet or the other SDKs. Because when we started Solnet four months ago, there were only four SDKs. Back then. It was the Java one from Skynet, and then there was a Python one, right?
00:04:23.374 - 00:04:38.714, Speaker B: Yeah, I think you had the original one in Java, which kind of ended up working. You had the python one, and then there was web, three DJs, and obviously the rest testifier.
00:04:41.014 - 00:05:32.344, Speaker A: Yeah. So. And this was four months ago. Now you have an endless stream of SDKs from Golang. There's swift, there's a lot of other stuff that I don't recall right now, but, yeah, we even made a community of SDK devs from everyone trying to expand the ecosystem. And yeah, that led us to to start working on Solnit. The main goal was to cover the entire RPC API, which it is 100% covered as of now.
00:05:32.344 - 00:05:45.404, Speaker A: Also we have most of the DSPL covered. I think there's like a couple missing.
00:05:46.024 - 00:06:05.724, Speaker B: Yeah, we don't yet have the state problem and the governance, which is going to be very important in the near future with Tao showing up and stuff like that. Obviously it's one thing that we want to work on in the near future.
00:06:10.164 - 00:07:37.504, Speaker A: Okay. Beyond directly the DRPC and the programs, we also have some nice, very nice contribution from what's his name, I'm sorry, liquizard with the token wallets. That allows a lot of flexibility and is obvious to handle the account and associated token accounts. And we have the transaction and message API, which is very similar to the web3 j's with also some quality of life stuff on top of it. Beyond this we have the zero, which is now finalized, and Mango, it's a whip along with Metaplex and a few others. Oh, and another one very important that I've also been working in the past week, which is the Solnet anchor. He's on a very good set right now.
00:07:37.504 - 00:07:39.884, Speaker A: It's still not production ready, but.
00:07:43.424 - 00:07:43.736, Speaker B: I'll.
00:07:43.760 - 00:08:32.870, Speaker A: Give a sneak peek before we end this session. As of requirements, you only need net five. It has just a couple of dependencies. We even trimmed a few others to twelve degrees to load size in the Blazor webassembly. So this is another plus. You can use Solnit to develop Webassembly apps which Google can, can show what he's been working on. Feel free to contribute if.net
00:08:32.870 - 00:09:10.454, Speaker A: is your thing. If it's not your thing, feel free to come to this site. We have cool stuff. We have this. It's, I would say it's silhouette because it's only focused on the solnet core. It doesn't feature anything related to serum or any other library that you're currently working on. We have a couple of articles here and the entire API documentation that you can find inside the code itself.
00:09:10.454 - 00:10:02.538, Speaker A: Okay, we have a couple three articles here. One, it's a very simple article. It's just, how can you use this, what steps you need to take? And it's important to mention that it's all on Nuget. And this feature is somewhat outdated, as you can see. We have a couple more library is there, if the page loads. Okay. Oh, there is something that I need to mention, which is if you're using the Blazor webassembly, you can only use the sync functions.
00:10:02.538 - 00:10:28.126, Speaker A: The donut sync will throw a platform not supported exception. And the websockets isn't yet 100% functional. It's something that we need to look for in the future. Okay. Searching for Solnit in Nougat. We'll get a few more hits than what we saw before. Yeah.
00:10:28.126 - 00:11:15.064, Speaker A: So there's the seal. It's finalized 1.0. Great work by Hugo and the solid extensions, which was mainly contributions from Leak wizard. Very, very great shout out for you. Thank you for the great work, dude. Yeah, and I think right now I'm going to to pass to Google so it can show you how easy it is to build using Solnet. And it's going to do a walkthrough with the DL world.
00:11:17.644 - 00:12:23.496, Speaker B: Yeah. Before I actually dive on to that, I just want to say something that we actually have discussed earlier that we should mention in this presentation, and I already saw someone asking the question in the chat, which is regarding the use of Solnit on unity. As of this moment, because Solnit is targeting the.net five, you can't use Solnit with Unity. So you can define direct integration of Solana into any game just like that. But there was one part of the first release of Solnit, I'm not mistaken, done by the guys from all art protocol, and they created a Solana Unity Wallet SDK something. I think that was an end which you could integrate to to games using Unity for the future.
00:12:23.496 - 00:12:45.000, Speaker B: This integration is going to be a lot easier because we know that there are already been done some great strides where dotnet six on unity in the future, and.net six is going to be released later this year, if I'm not mistaken. That's right.
00:12:45.112 - 00:12:46.444, Speaker A: It should be November.
00:12:46.784 - 00:13:29.084, Speaker B: Yeah. And once that's, that's released, I think it will be a matter of maybe one, two months before unity actually starts to support.net six as well, since previews have already been out for a few. For a while already, and they have already started discussing that it should happen sooner than we expect, to be honest. Okay, so now for me, I'm going to dive into the. Let me select the directory. I'm going to dive into the hello world.
00:13:29.084 - 00:13:47.944, Speaker B: I'm not sure, is it showing up properly? Yeah, that's fine. Okay, so basically what we have here is a very simple example of what you can do using sonnet.
00:13:49.844 - 00:14:02.264, Speaker A: Maybe. Let me just interrupt something quickly, just to slightly zoom in on your id so it shows better if people are using like oh, these screens.
00:14:03.904 - 00:14:05.848, Speaker B: Yeah. How am I going to zoom in?
00:14:05.896 - 00:14:13.584, Speaker A: Like that, right. Control scrolling or control plus or something like that. Okay.
00:14:13.624 - 00:14:17.964, Speaker B: Oh, you mean only. Yeah, okay. Yeah, yeah.
00:14:19.064 - 00:14:25.384, Speaker A: Should probably do that into id too. Id? No, I mean the browser.
00:14:25.544 - 00:15:09.882, Speaker B: Yeah. Okay. So yeah, basically I have a 1440p screen, so I didn't want to mess up the aspect ratio or downsizing it. I was going to say you can't write sonar programs directly with c hash, but you can interact with them. We have written Solnet serum to interact with the serum problem. We've written a couple of program implementations which you can find in solnep programs for the Associated Token Account program, the system program token program. All of these are basically fully featured.
00:15:09.882 - 00:15:57.454, Speaker B: You can do operations using multi signature accounts using the token program. You can do pretty much all of these things from.net, but you can't directly write Solana programs using.net dot in the future, once we have Solnat anchor released and production ready, obviously it's going to be even easier. And with some of the things that we're going to show after, you'll see why. Having this whole stack is actually going to be very good, not just for obviously.net, but also for, for Solana as well, because this is still quite big community of developers that we should type into by having these kind of tools.
00:15:57.454 - 00:16:37.514, Speaker B: Okay, so I'm just going to dive into this. I have already added this allnet dependencies here. I'm assuming you know how to create a.net project. In this case, I'm using write up because of the, just to showcase the fact that this is actually cross platform, I'm going to create a new project here and just give it some name. I already went ahead though, and I already created the project and the dependencies. I ordered the RPC, the wallet MD programs, which is the ones we're going to use in this example specifically.
00:16:37.514 - 00:18:03.654, Speaker B: Okay, so in this case, obviously this is an ll remove this, and we're going to start off by creating a wallet. This wallet that I'm going to create, it's going to be the, it's a wallet basically, obviously, but it's going to feature the same keys as you would see on solids or phantom, for example. But we also have the functionality to create wallets and generate the same keys as in the Solana Keygen command line tool. We have an open issue in the project so that we can feature more wallets, but it's something that needs to be worked on in the future so that we can actually support more stuff like Ledger and others. Okay, so I'm just gonna go. This is probably gonna lag a bit because I'm see and the stream here you can see, obviously you can choose from the different types of wallets and mnemonics. In this case, I'm gonna go follow word by word, the yellow world example.
00:18:03.654 - 00:18:11.386, Speaker B: I'm going to create a wallet with a 24 wall mnemonic in english words.
00:18:11.570 - 00:18:36.794, Speaker A: I'm just gonna try to zoom in a bit more. People are still complaining that it's not readable. Yeah, yeah, a bit, a bit more. Okay. I think that should be better.
00:18:40.774 - 00:19:30.514, Speaker B: Okay, so I'm gonna print the mnemonic here. Just a mnemonic. I'll do the public key. This is the account. Just look at that. We have implemented some quality of life things in the wallet package specifically because of conversion between strings and public keys and private keys and stuff like that. So that you don't actually need to be accessing the properties to get the actual public key and then the actual key.
00:19:30.514 - 00:20:18.294, Speaker B: So in doing things like this, it should obviously make your life easier. No. As you can see here, we have our monic, we have our public key. And with this we can actually start to do some things. I'm going to do something different for the sake of this. Okay. I'm gonna output the mnemonic here just to show you that you can actually do it like this as well.
00:20:18.294 - 00:21:25.590, Speaker B: I'm gonna write again and it should. We have the same monitor, we have the same quality. So moving forward, we're gonna start using the, the RPC. We have our wallet. So we are going to want our RPC plans, and we have implemented factory patterns on this. So what we're going to do is we're going to access our manufacturer, we're going to get the defiance in this case, we're going with testnet. So I can actually replicate the requesting of the airdrop so we can get lamppost and so we can do something else with those lampards afterwards, if I'm not mistaken.
00:21:25.590 - 00:22:54.420, Speaker B: Yeah, this is the. Okay, so we have, we have that. Now what happens is we don't have any balance in these account or in this actually. So when we do a get balance on these specifics on this specific account, we are going to see that, you are going to see that it shouldn't return anything, if I'm not mistaken, or it's going to return that it didn't find the account. What? Okay, I just saw someone asking, what if you have different accounts, which one will be selected. Okay, so this obviously depends if the mnemonic you input and the way you generate the wallet is by following the Soleno key gen command line keys. Basically you are only going to have one account the default way.
00:22:54.420 - 00:23:07.224, Speaker B: This account is the first account by the derivation path. So if you wanted to get your second account, you would probably do something like this.
00:23:12.144 - 00:23:30.360, Speaker A: Doing this, maybe they could be asking about if you add another key pair, and in that case you can initialize the wallet with any other valid mnemonic or the bytes for the keys as well.
00:23:30.432 - 00:24:28.094, Speaker B: Oh yeah. Obviously you can initialize accounts themselves using either the bytes that represent the private key and the public key, or the strings for the private key and the public key. This is for accounts, because basically an account is something that is able to sign something so you cannot interact with the network and the cluster. Basically, if you're just looking for the keys themselves, you can obviously initialize a public key using the same thing. Basically you have a overloads for a string, for a byte array and read only span. Okay, so moving forward here, I'm asking for the balance of this account.
00:24:31.584 - 00:24:32.136, Speaker A: Because.
00:24:32.240 - 00:25:28.854, Speaker B: We actually implemented a completely, how do you say it? I'm not sure I missed one word. We actually implemented a full fidelity implementation of the RPC. What you're going to have is in certain methods you're going to have this response value, and what this response value contains is basically the context for that specific response that you're getting from the RPC. In this case, this means that the object contains the slots which you can see here, it contains these spots. That's just the spot, right? Yeah, just basically that.
00:25:28.934 - 00:26:06.854, Speaker A: But the idea behind this was. Sorry, sorry, go ahead. Okay. The idea here was to keep full fidelity from the original RPC so that you get all the information, but at the same time you get the information already serialized. So you can use it freely and very easily, but you don't lose on any information. That's the main takeaway for me.
00:26:08.674 - 00:26:48.544, Speaker B: Yeah. Okay. So I've already gone ahead and done the request. Obviously it's showing account balance as being zero. That's because this is a newly created wallet and obviously we haven't transferred anything to it. We can, however request a. Hopefully the defaulce actually has coins.
00:26:48.544 - 00:27:50.184, Speaker B: I haven't actually checked in a while, but a while ago it was pretty much dried out. Yeah. Okay, so I'm asking for 1 billion lampworks. This is pretty much one solution. So we have here the signature for the transaction where we asked for the error. Let me go and test it and see. So it's confirming.
00:27:50.184 - 00:28:15.034, Speaker B: We could write some codes to actually keep polling until the transaction is confirmed and stuff like that. But that's not the whole point of this. It's just more an overview of what you can do. Now. You should do this thing, actually.
00:28:16.534 - 00:28:24.176, Speaker A: That part teaches you how to subscribe to the transaction and check whenever it's finished.
00:28:24.200 - 00:28:42.884, Speaker B: Yeah, I'm actually looking at it. I didn't remember that we are this part. Okay. So we are going to do this properly.
00:29:04.634 - 00:29:06.930, Speaker A: You're missing the using probably.
00:29:07.082 - 00:30:30.106, Speaker B: Okay, that's, no, no, no, it was the wrong method. Yeah. Okay. So basically, once again, factory pattern, you want to get the RPC client, you get your pc client, you want to get the websockets are the streaming RPC client. You use these to get streaming client from the factory. And now what we're going to do here is I'm going to basically do the same thing and I'm going to be subscribing to the signature. And basically what this subscribe signature method does is it's going to subscribe to the confirmation or the finalization of that specific signature.
00:30:30.106 - 00:31:09.094, Speaker B: Basically you can specify this by providing the commitment parameter. This is the faulting to finalized. I'm gonna go ahead and actually do this using confirm because it's faster, not that you should do it. It's really context dependent. Oh, yeah. I was getting confused now.
00:31:19.274 - 00:31:46.654, Speaker A: When type. Well, I'll just say something quickly. So someone was asking if you could download the project after we finish. Actually, you can check it out right now. So on the repo, we have a solnet examples project that it's full of examples, and one of those examples is the diesel world that we're doing right now.
00:31:49.794 - 00:33:13.144, Speaker B: Yeah. Okay. So I was going to say, once this transaction is either finalized or actually confirmed, in this case, we're specifying the confirmed commitment. You're going to get a notification of this. And in this notification you're going to have access to possible errors that might have occurred into transaction or instruction errors which might have to deal with interaction with programs and things like that. Obviously, there are a couple of these here, and I would need the whole other hour to actually go deeper into these because I have to actually parse these program specific errors in sonnet zero into a c sharp structure as well. So, okay.
00:33:13.144 - 00:34:34.619, Speaker B: So in doing these, we're going to be subscribed to the transaction signature, and the notification is only going to be fired once it actually confirms something to do something here so that we can execute the whole code in a row and actually also have the transaction that we're going to graph afterwards be done in one single execution. Okay, so what we're going to do now is basically a small overview of what you can do with the transaction builder and the transaction and message classes. Okay, there's a small note.
00:34:34.651 - 00:34:37.463, Speaker A: You're not changing the confirm variable.
00:34:39.563 - 00:36:06.504, Speaker B: Yeah, I know the account already as well. I'm going to be talking mostly about these transaction builder, these as these methods. I'm going to be going over them a little bit more in depth. But I would also like to point out that you have this one, which exactly is supposed to be like this, the method one and the transaction one. These are, these were implemented specifically to allow interoperability with other SDKs, primarily the web3 js one. It basically follows the same format, although when we're not interacting with any other SDK, we usually follow the route of using the transaction delivery, which makes it way easier and much cleaner to offer them, for instance. Okay, so in order to crash a transaction and actually submit it to the cluster, we're going to need to request a recent blockage first.
00:36:06.504 - 00:37:52.634, Speaker B: This block hash has about 3 seconds of time until it actually isn't valid anymore. So when you request a blockage, you have to be careful how long you take, how long you're going to take until actually use that blockage. I'm going to put our wallet as the fee payer, and then I'm going to add an instruction to the other instruction to the transaction, but I am going to call the number problem. And since this example was written, a lot of things have actually changed. We have also implemented the memo v two program. We didn't break backwards compatibility, and I implemented it differently because the way we implemented the original memo program, it basically required the designer of the transaction to also find the the memo, basically. Now that's not the case anymore and you can just do any kind of memo that you want.
00:37:52.634 - 00:39:01.694, Speaker B: Yeah, so obviously the same way I was talking about the transaction in the message classes, which allow interoperability with the other SDKs, the transaction builder also has quality of life methods that allow for this. In this case, the compile message. I could compile this message right here and I would only get the message, this isn't silent, and I could deserialize it using the message. Deserialize. I could do it like this and I would get the message and this could be used to then do a transaction basically just like the web3 js one, like the transaction calling, using the message and the signers, the signature thing.
00:39:04.394 - 00:39:49.104, Speaker A: In this case, I think it's important to note that it's not just a question of interoperability with the other SDKs, because that's also the mechanism that allows you to use hardware wallets to sign a given transaction, because the transaction builder is a nice quality of life, but it's very strict the way you use it if you want to sign directly. So with that mechanism, you can actually sign the transaction anywhere else you want and send it in somewhere else or back using solid.
00:39:50.624 - 00:40:05.964, Speaker B: Yeah, exactly. In this case though, we are going to want to sign our transaction right away. As you can see, these build methods actually has two overloads.
00:40:10.184 - 00:40:10.864, Speaker A: One of which.
00:40:10.904 - 00:41:49.374, Speaker B: Takes a list of signs. This is used primarily for cases where you're dealing with the more complex programs or crafting way more complex transactions. And these transactions require to be signed by multiple accounts. What you do is you just pass a list of accounts where they are ordered in the, they are ordered in the way that they appear within the message and that they actually need to send the message. And I'm going to talk a bit more about that in a second, but that's actually a bit confusing sometimes. Yes. So now I'm just going to this one, I'm just going to submit this transaction to the cluster and I'm going to run this.
00:41:51.354 - 00:41:55.098, Speaker A: One. Should take a bit longer because you'll be waiting for the.
00:41:55.266 - 00:42:13.234, Speaker B: Okay, so you can see obviously account balance is already one building lamps because I had done the previous request and you're using the same account. We got the first transaction edge, this one here. And we are probably subscribed right now.
00:42:24.534 - 00:42:31.094, Speaker A: Yeah. Need to wait like 3 seconds I think, for it to confirm that one.
00:42:34.234 - 00:43:03.674, Speaker B: No, it's already finalized. So what actually happened and would be you. I'm gonna run, I'm gonna run it again. No, it didn't change what it's here.
00:43:09.974 - 00:43:19.474, Speaker A: Not sure confirmed.
00:43:49.774 - 00:45:00.174, Speaker B: Okay, whatever, keep it simple. So please, it's already, I'm wondering if this has been one of those cases where the RPC is actually not sending notifications as it should. Because there's, there has been a known issue where the RPC misses notifications. Okay.
00:45:00.254 - 00:45:05.734, Speaker A: It's. You can send input on the console.
00:45:08.114 - 00:45:43.634, Speaker B: Yeah, I could have sent input any because I already advanced, but um. Yeah, okay. There's something wrong here, but I'm pretty sure it's probably Dr. PC and not once this confirm will confirms, you'll actually be able to see the contents of the transaction and see the memo.
00:45:52.214 - 00:45:52.790, Speaker A: Okay.
00:45:52.862 - 00:45:53.118, Speaker B: Yeah.
00:45:53.166 - 00:45:55.474, Speaker A: Salt scan doesn't support the memo v two yet.
00:45:57.194 - 00:47:01.726, Speaker B: It does, but it doesn't convert from the encoding to the actual string. Okay, you can see here, transaction was signed by the account which has a balance of 3.99 lampos because of the amount of time that run this. And then we have the memo program call here which sends the memo that we wanted it to send fad. Then this, using the first implementation of the memo program, I would have had to pass the account for the message to be signed because of the way we implemented it. And then you would have an extra parameter which was the designer for bad message. Okay, so basically this is the hello world.
00:47:01.726 - 00:48:32.024, Speaker B: It's very simple, it doesn't go very much in depth, but other than these, we have quite extensive collection of examples in the solnet, for example project inside Solnet. And obviously we don't have that much more time to move forward with this. But I would like to give emphasis on the multisig examples that we have. This file here contains 1000 lines of code, basically on how you, not how you should do multisig operations, but a way to do them programmatically within C sharp. Obviously this is, this is very crude example and I'm not using nonce accounts in most of these examples though you definitely should because of the way multiseqs happen and delays between signatures and stuff like that. And I'm not using the mechanisms which allow you to compile a message populating them with. Well technically I am, but you would need to do this differently and not actually populating the message with the accounts that are actually going to sign the instructions and the transactions.
00:48:32.024 - 00:48:40.514, Speaker B: But yeah, that's kind of it from my side. Should we, should I still give a sneak peek into what I've been doing on laser side?
00:48:41.534 - 00:48:44.314, Speaker A: Yeah, just like two minutes it should be.
00:48:46.094 - 00:49:47.354, Speaker B: So it is here. Too many id is open. So I'm just going to run the server right here. What you can see here is a blazor webassembly application. I've been playing around with the NPM packages which have the wallet adapters for the browser and obviously the react packages for UI as well. Obviously I can't use, I mean I could use those, but it would be even more painful for, for me that I'm doing this and for web used and ended up using this because of the way it works and the way you would have a react in the Blazor webassembly application all in one. You don't want it.
00:49:47.354 - 00:51:27.514, Speaker B: But yeah, I've been playing with this and I can already, I have done this, but only Phantom is currently working. I can already connect to the wallet and obviously I can already require certain signatures from the web application. Obviously there are some things that may still happen because of the way the JavaScript interoperability happens and the fact that you're using C sharp to do these calls to the j's, object references and stuff like that. This is still a lot of work to go until it's actually production ready for whoever wants to attempt doing solenoid applications using Blazor. This is just a small example of the things that you actually can do using C sharp.net and Solana. And we had some people telling us that we should give out some ideas of things that you could do using these tools, and I'm gonna put one of them out there, which is if likes trading.
00:51:27.514 - 00:52:23.204, Speaker B: Solnet Zero is already in a state where it basically has all of the groundwork unit actually login a lot. Solnet zero is in a state where it basically has all of the groundwork that you would need for you to build a algorithmic trading framework or just a framework for bots, for market makers or wherever it is. And it is something that I would personally be doing it. But unfortunately there are just way too many things to do and we can obviously do all of them. So yeah, that's one of my ideas. If anyone is out there and you're interested in trading and on zero and looking more in depth into things, this is something that I would encourage you to do. Obviously.
00:52:23.204 - 00:53:22.754, Speaker B: Solnet zero also has an examples library which has quite a few of them. I remember there are two of them that go in depth into actually order placement. And then there's these two here which are more niche and don't actually use the two primary classes in the rest of the project. But yeah, basically that's, basically that's it. This has been, don't let the gold coverage in this one fool you. This has been tested a lot over the course of the past two months or something, and it's very, very robust already. Jack, you still want to show?
00:53:23.054 - 00:54:07.496, Speaker A: Yeah, I guess I can do a 1 minute sneak peek about what I've been been working on if you stop sharing your screen. Okay, let's go again. Share screen. There it is. Okay, so for the past few weeks I've been working on the encore code generation for solid. I've had a few pains and some clarity moments, and last night there was another pain moment, but I'm over it already. What I have right now is the code generation.
00:54:07.496 - 00:55:10.284, Speaker A: In the Solnit tinker project, I have a program which uses this library to actually receive input, and this input being the JSON. I didn't check the resolution. You guys can see things here a bit. And yeah, so there is this program I made quickly to just grab the JSON, parse it, and generate the code. And I already have some working examples. There's still a few, a few minor issues with some edge cases that I still need to fix. But for now I can show, for example, it was the swap program, which is one of the anchor examples.
00:55:10.284 - 00:55:53.450, Speaker A: So I have the, the project here, Sonet anchor examples with two IDL files. There's the chat and the rest. The rest one is the one from the swap. I didn't name it properly, so I just run the source gen program and generated the swap cs and. Okay, so this code might not be the prettiest because it was generated. And in some cases the indentation doesn't work as a human would do it. However, all the objects are already created.
00:55:53.450 - 00:57:09.164, Speaker A: There's even some quality of life niceties, for example, the accounts groups for each instruction. And beyond these, there's what you would expect. So there's all of the instructions. Their construction is implemented here with the serialization of the data. This means that you only have to write your contract code in rust using anchor, and then you run this generator and you get the client code generation for free. Here we have the static class program, just like we have in the remaining sonnet, where we have the transaction building on the transaction instruction, so you can build the transaction itself. You also have a client which abstracts most of these things if you just want to have a simple transaction building.
00:57:09.164 - 00:57:50.664, Speaker A: So imagine you only want to create this transaction. Okay, so for more context, this is the press, this is the swap program. So it has the instructions. Okay, so we have the swap instruction and the swap instruction. You just want to set this instruction. So basically all you need to do is grab this client that is also generated and called the send swap without the inputs, as expected. And then there's maybe this bit that may be a bit scary.
00:57:50.664 - 00:58:43.814, Speaker A: In order to have things a bit more flexible, there's this callback that you'll need to create to sign the transactions. This will be called with the payload and the public key of the account that needs to sign, and it needs to return the signature. If there's a transaction that needs multiple signatures, it will be called multiple times with the public key or different at each call. Okay, so this example is very simple. It doesn't really create any types, and I don't even think it creates accounts. Okay, I guess doesn't even create accounts. So yeah, this is a very simple one.
00:58:43.814 - 00:59:48.004, Speaker A: I have a more complex one here, which is the chat one. However, it's not yet 100% working. There's still a few things I still need to work out. For example, there's a pr that still needs to happen in the core of solnet to read some stuff. And there's this thing here that I need to fix about properties. But yeah, what's important here, what's important here is that all the types and accounts that are described in the ideal, they'll be generated for you without the properties, and then you get for free the serialize and serializing methods. You will only have serializing methods on types, not on accounts, because you don't send an entire account on any instruction.
00:59:48.004 - 01:00:38.894, Speaker A: So you don't need to serialize those, but you need to deserialize those if you are a retrieving one. Okay, so yeah, your types, you get the serialized as well. And okay, one small thing about the client, which is the base client that it's implemented in solnet anchor. This base client has a couple of functions that allow you to retrieve or subscribe to any account that is described in a given idea. So we have a getaccount and a subscriber count. Those are generic methods. They'll use.
01:00:38.894 - 01:01:48.472, Speaker A: They'll use, ah, those reflections to retrieve the serialized methods. This serialized method is automatically implemented, generated from the IDL and the type definition. So yeah, maybe this was too quick, but I think we're running out of time and I just wanted to show you a sneak peek. But basically in the future, in the very near future, you just need to write the contracts and you get the free client with everything you need to write your application, be it like a blazer webassembly, or in the future when unity gets to move into net six, then, or any other type of application using.net.
01:01:48.488 - 01:01:48.616, Speaker B: Comma.
01:01:48.640 - 01:02:21.448, Speaker A: Basically you get the client and all the nice piece for free, which means that you get to focus on the application and not on data serialization and to serialization. So yeah, I think that's the gist of it. I'm not sure if we have any questions right now, but we did have.
01:02:21.496 - 01:02:58.610, Speaker B: One question regarding the citadel. I've already answered it in the chat. Other than that, I think we are going to wrap up. We've covered pretty much what we wanted to cover. Okay, so someone asked a question about where can we learn more about concepts like freezing authority, you should. That's a difficult one actually. You should definitely take a look at the token program implementations and if you know.net,
01:02:58.610 - 01:04:08.284, Speaker B: you can actually look at our own implementation of the program, you'll see that the priz authority is actually optional when you do an initialize mint. Same thing with the priz authority is optional when you initialize a mint, which basically makes it a optional thing internally. It does logic when you don't pass the key, and when you don't pass the key, obviously there is no way to freeze any accounts that is associated with that actual token mint. Obviously this is different for NFTs, but I'm assuming that most of these latest launches actually don't have a freeze authority, only some or maybe an SMB actually added on their initial release. I'm not sure if that answers your question. Yeah, there's many many many documents, documentation, guides, whatever, so you can actually easily find out about them.
01:04:11.304 - 01:04:48.894, Speaker A: Yeah, let me just reinforce to everyone watching that it's not late to start building and integrate scheme of things. We're still very early, so you guys dive in. Don't be afraid. Ask questions. Going to the solemn discord. There's also several learning discords out there, so feel free to join us and ask us questions. Also, go to our GitHub, I've shared it a couple of times in the chat.
01:04:48.894 - 01:04:57.874, Speaker A: Go there, feel free to participate, help us ask questions. You're welcome guys.
01:04:58.294 - 01:05:08.114, Speaker B: Thank you so much. Tiago and Hugo, really appreciate your presentation today and looking forward to having you on next time. Thank you.
01:05:08.734 - 01:05:09.134, Speaker A: Bye now.
