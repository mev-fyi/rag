00:00:02.640 - 00:00:22.634, Speaker A: Hey, guys, I'm Anush CDO in core dev clinancer, and it's my co founder, harsh. So today we're gonna talk about, like, clients mainly, and like, dive deeper into them. So before we start, I want to make sure we have a baseline level of understanding. So how many people here know what a like, client is? Sure. Fans.
00:00:23.694 - 00:00:24.434, Speaker B: Great.
00:00:25.294 - 00:01:13.942, Speaker A: And how many people know here what a full node is? And what about sick node? Okay, so for the people who don't know, like science, they just verify individual state and transactions. Full nodes have access to the entire state and replay entire blocks. And state nodes on top of that also take part in consensus. So I want to start with just going over the agenda today. We're going to talk about how we got here, why clients are important to Solana, how they add value, and also how it works. So you first want to talk about, kind of go back to the past and from the beginning. So this is the bitcoin white paper.
00:01:13.942 - 00:02:04.164, Speaker A: So if you look at the bitcoin white paper, it actually mentions simple payment verification on a high level. This basically just means that a user can verify a specific piece of state or just their transaction against the block headers without having access to the entire state. This is how it works. So you have your transaction which is part of the Merkle branch, which is part of the root, and that's part of the block header. So anyone can just verify their bitcoin transaction against the Merkle root in the block header. Now, Ethereum, on the other hand, also has like, clients, and they actually started working on this back in 2015. This is a pull request for like the Ethereum, like client.
00:02:04.164 - 00:02:55.994, Speaker A: And they actually mentioned the bitcoin like client in the paper. So I was talking about bitcoin and Ethereum because I kind of wanted to touch upon like, what bitcoin, Ethereum got right? And what they're actually like the kind of narrative that they're pushing today. Right? So today, you know, Vitalik talks about like, the blockchain trilemma. And I kind of believe, I think we, you know, a lot of people in Solana system believe that, like, chain trilemma doesn't really apply to Solana. And it's not really a real, like, theorem, unlike the cap theorem, because it really just applies to Ethereum. So it's more like the e trilemma. And, you know, similar to trilemma, the Ethereum community has sort of, you know, created a lot of other myths about how blockchains in general work.
00:02:55.994 - 00:03:45.564, Speaker A: And those have, you know, people have applied those to Solana as well. So if you look at the kind of false narrative that is created today, people believe things like, you know, full node should be designed to run on, like, cheap hardware. And another one is end users should be able to run entire full nodes, and that you can only choose between two of these three in the trilemma. But the reality is that running full nodes is really not an efficient way to verify individual transactions. We also know that only 0.02% of metamask users actually run full nodes. And we know that Solana is capable of all these three.
00:03:45.564 - 00:03:46.184, Speaker A: Right?
00:03:47.124 - 00:03:47.956, Speaker B: Yeah.
00:03:48.140 - 00:04:57.790, Speaker A: So why did I talk about this is because we need to learn from what bitcoin, Ethereum did, right? So what they did was they basically built their entire technology stack on certain fundamental blockchain principles, like verifiability, permissionlessness. And because they made those decisions and built that kind of a stack, they started creating a culture around this, right? So when people use bitcoin, Ethereum, they have this culture that, okay, I can, you know, I don't need to trust any centralized party. I have verifiability. And because that kind of culture was built, they built a social standard where bitcoin, Ethereum kind of become accepted as one of the best blockchains, roll ups. Keep talking about borrowing Ethereum security. This is one of the reasons. So how do we become, how do we learn those things from Ethereum? And how do you actually become better than Ethereum? So on the left and right side, you can see there's a comparison between Solana and EVM.
00:04:57.790 - 00:05:24.054, Speaker A: And as you can see, there's a lot of things that Solana does right over Ethereum. Right. But there's certain things that are still a work in progress. Obviously, as we saw fire downs today reach testnet, that's a great thing. So we have more client diversity, we're building light clients. And obviously things like runtime v two are improving the devx. So if you actually want to be better than ethereum, we have to actually beat them on all levels and learn from them.
00:05:24.054 - 00:06:03.194, Speaker A: So I really want to like, you know, drive the point home with this quote from Akshay BD. He says that for Solana to compete, you need to become the default social standard. This means winning hearts and minds, even if that doesn't directly accrue value to Sol or Solana's mainnet. Once we achieve that, everything gets easier. In other words, winning real world assets is downstream of winning real world influence. So all of this is really just to answer the point of like why do we need, like, clients? Right? It's because like, this is like a non negotiable point that blockchains should be. Blockchain infrastructure should be built on these foundational principles of verifiability, permissionlessness.
00:06:03.194 - 00:06:59.094, Speaker A: And this should not be something that we decide, okay, users may not really want or like, 99% of the time it won't happen. It should be, it can't happen. And we already see the benefits of focusing on or having some efforts around these things. Visa not only looked at speed and cost, but they also look at decentralization. There's a lot of other networks that have fast finality or cheaper transactions, but they don't really have the kind of ecosystem decentralization that Solana has. So it kind of ticks all the boxes. We also have very reputed crypto media like bankless, which recognizes Solana's efforts towards deceleration, and a client diversity like fire dancer, and also tiny dolcer.
00:06:59.094 - 00:07:13.114, Speaker A: And obviously, people who are not using Solana's mainnet, but using Solana's tech stack, like, you know, make it out. They would actually just directly benefit from the right client infrastructure that we build.
00:07:15.494 - 00:08:31.904, Speaker B: Yeah. So, moving on to our next topic, which is the future. We are currently having SIMD one. That's the phase one. We categorize lite clients into three main stages, which is the phase one starts with the SPV, and it is all about verifying transaction inclusion and verifying that the transaction is included in the block and the supermajority of the network votes on that transaction. So we formalize the SIMD spec, we implement the consensus verification, and then after that we can directly apply it to wallets and saga and whatever. Moving on to phase two, we have data availability sampling, which relies on sampling random data from the, checking for data availability and verifying that the block is actually available by all the nodes, formalizing the spec, doing data availability sampling implementation, and then helping with repair.
00:08:31.904 - 00:08:56.154, Speaker B: Moving on to phase three, we have SVM fraud proofs, which is basically around the idea that any invalid state transition can be easily detected by a light client. And for that we have to implement some fraud proving mechanism, which is in the works right now. And. Yeah.
00:08:59.454 - 00:09:41.924, Speaker A: So I want to start by talking about the phase one. So in phase one, we have three SimD's, and we are actually really proud to announce that we actually have SImD 64 already merged and approved. We'll be working on SIMD 52 and 54, which will complete the implementation of SPV. But I want to talk about why SPV is important. With an example, imagine a scenario like you're a merchant, you're trying to sell this really exclusive shoe. So in this scenario, the user is malicious, you're the merchant. So the user decides to trick you and steal the shoe.
00:09:41.924 - 00:10:32.702, Speaker A: He contacts the RPC, and the RPC also agrees, saying that, okay, I can take a cut of the profits. So let's actually do this as a merchant. You tell the user that, hey, it's going to cost 1000 Sol, you're going to transfer me that the user sends the transaction to the RPC, and the RPC sends a fake confirmation and balance change to the merchant. Now, in this whole interaction, the validator is not even part of this interaction, and that's where the problem really starts. So the merchant thinks that, okay, I've received the, received the amount and the transaction is confirmed. So I can actually transfer the shoe. The shoe gets transferred, but okay, the merchant realizes later on that hey, I actually didn't even get the money.
00:10:32.702 - 00:11:06.554, Speaker A: And the problem here is now no one's going to trust the merchant, that he actually got tricked. And that actually creates a problem that people trust crypto, because it's better financial system where you don't have to trust anyone. But this merchant just got tricked into the exact same thing. But what happens when you have SPB, same situation. User sends a transaction to the RPC server. RPC server gives a fake infringement balance. But here's where the difference actually starts.
00:11:06.554 - 00:11:38.314, Speaker A: The merchant has the tiny dancer client side on its POS terminal. So the client verifies if super majority of the stake has actually signed off on the transaction, and it's actually included in the block and executed correctly. And now the merchant knows that the transfer never really happened. So now the RPC server and user realized that the merchant has client certification. They can't actually trick them and the merchant is safe. The transfer of the shoe never happens.
00:11:41.974 - 00:12:24.962, Speaker B: So let's go to the brief protocol interaction here. We have a user, we have an RPC server, we have blocks. Let's say a user wants to send a transaction. A transaction lands on slot n and the user is running a light land. So what it does is user requests proof from the RPC and generates, the RPC generates a merkle proof of receipts. So we, according to SIMD 64, we have the Merkle receipts done. So what we, what we'll do is like adding the receipt tree and the receipt route to the bank hash.
00:12:24.962 - 00:13:11.514, Speaker B: So it will generate a Merkle proof. The RPC will generate the merkle proof. The proof will be sent to the user. And the lite line, which is running in parallel, will verify the proof. So this stage will verify transaction inclusion. And then the user will request slots from slot n to 232, because that's the transaction finality depth. And then it will pass vote transactions to get the stake amount, which is the current active stake, and it will compare it with the current active stake.
00:13:11.514 - 00:13:42.084, Speaker B: And it will see if the transaction is actually verified and signed off by the supermajority of the networks. So that's how it works. If the stake sum is like the stake sum that we do parse, which is great, if it's greater than the two thirds of the majority, then the transaction is confirmed under super majority. So yeah.
00:13:44.824 - 00:14:34.168, Speaker A: Now I want to dive deeper into how the SP works at the consensus protocol level. So essentially it's just a mercury of the receipt. So like, what is a receipt? A receipt basically just has three pieces of information. The version of the receipt, the actual message hash, which is 32 byte hash, and the execution status, which is just a one byte status of whether it executed or not. And the message hash is like a hash of all the data in the transaction. So each receipt contains these three pieces of information, and every leaf is a hash of that receipt. So what we do is we create a mercury tree of all these receipts, and then we get something called an intermediate route, which is, as you can see here in gamma.
00:14:34.168 - 00:14:57.664, Speaker A: And then we hash the intermediate route with the quality of the transaction receipts. This is done so that we can prevent length extension attacks, which could be a potential security flop. And then we get the actual receipt rule, which is Endelta here, and that's added into the bank hash alongside other existing hashes like the account delta hash.
00:15:00.004 - 00:16:04.304, Speaker B: So you might wonder that whether this SPV mechanism is extensible to just salon, just the bridges or. Yeah, so I'll show you a brief interaction of how SPV can be extended to bridges. So let's say a user wants to transact from chain a to chain b. So user deposits a token. And what we have here is the SPV client is like a program which generates a proof of receipts and the state proof. And whenever the user requests a payment back from the token b, the withdrawal contract on chain b requests proof from the chain a. And then chain B verifies the proof that is on chain a verifies consensus, verifies the receipt proof.
00:16:04.304 - 00:16:11.924, Speaker B: And then if the transaction, if the verification is successful, then the transaction succeeds. So, yeah.
00:16:13.904 - 00:16:49.696, Speaker A: So in phase two, we actually go a step further and actually talk about like das. And what das really does is it helps us verify, like, the integrity of the chain. So earlier, I actually referenced the bitcoin white paper. If you read further in the SPV part, it mentions that in case someone gains super, like, 51% of the hash power, they can still pass an invalid state transition. And that's a problem because users cannot actually detect that. But only full nodes can detect that. So in a POS network that it wouldn't be 51%, it would be like 67%.
00:16:49.696 - 00:17:32.196, Speaker A: And to actually prevent that, we have das. So just to explain it, this is how turbine works. We have the leader, which actually has the turbine neighborhood tree, and it propagates the block using. It propagates the block in shreds to all the other validators. And the shreds are actually erasure coded. So they use Reed Solomon encoding to make sure that in case some packets are lost, you can actually still recover the block. So this is how a block that is encoded using resolomon actually looks like.
00:17:32.196 - 00:18:52.114, Speaker A: So you have 32 data sheds and 32 parity sheds. So what we are doing is we are saying that, hey, a full node requires downloading the entire block to make sure that the bank hash is actually computed properly and there is no invalid state transition. But what a user can actually do is a user can actually just request some part of the block that is easy enough to download on lower end devices, and then we can probabilistically estimate that, okay, if this part of the block is available, then with some probability, the other part of the block is also available. So if there's 100 shreds, and I just request, sorry, if there's 256 shreds, and if I just request, like ten, the probability of the remaining shreds being unavailable is like one by two to the power r, and that's an exponentially low. Like, that number is, you know, it scales exponentially as you increase the number of samples. And the reason this is important is because, like, the user can actually request the samples and make sure that the block is available, and then if the block is available, the full node can actually download the entire block, replay the transactions, calculate the bank hash, and then evaluate whether there's an inverse state transition or not.
00:18:55.494 - 00:19:45.364, Speaker B: So not only does random sampling help in data availability guarantees, but it can also help in block repair. Here's a brief idea that we had. So we have a current validator who's trying to repair a block. We have a full lite lan node. Assuming that we have a robust lite LAN node that is fully functional, the current validator sends broadcast requests to the liteline network, and any light, any light node that's active and reads the request. The request contains any missing shreds that the validator wants to repair the block. And what it does is if the Liteland has it, then the Liteland can directly broadcast it to the validator.
00:19:45.364 - 00:20:08.104, Speaker B: Otherwise it can query other nodes. And that's how it works. That's how it works. We also store shreds so that whenever any other lagging light client wants to catch up, they can directly query it from the neighboring lightlands.
00:20:09.244 - 00:21:02.250, Speaker A: Yeah, so in the previous diagram, the last part of it was the fraud proving part of it. So I'll touch upon a bit in this part. So in phase three, we just have like lines using fraud proofs. So I mentioned earlier that the lite clients will actually use das to verify that the block is available. Now let's say that the block is available and the full node is able to download the entire block. But in case the full node detects that there's some sort of an invalid say transition and there's a mismatched bank hash, how will the full node actually tell the user that hey, this block is actually different from the block that the majority is propagating. If the full node just notifies the user, the user has to trust the full node.
00:21:02.250 - 00:21:42.434, Speaker A: So we require some sort of a proof here, and that's where fraud proofs come in. So it's basically just a succinct proof that some invalid computation has happened, and it can be easily verified on a like line. So whenever there's a 67% attack, the full node can notify the user about it. And the goal would be that we need to figure out exactly where the invalid state transition happens. So we go from the transaction to the down to the CPI, down to the exact VPF bytecode, and that will actually allow the like line to verify where this happens.
00:21:44.094 - 00:22:55.274, Speaker B: So before wrapping our talk, we have one more thing. We have one more idea that we want wanted to discuss. So the ultimate goal of any lite land, it needs to be participating in the consensus. So we were thinking of having voting light lands, which is just distributing the stake to the light nodes. Once we have SVM fraud proofs active and data availability sampling, here's how it will look like and what will. The main benefit of it is we are just decentralizing the stake and any user can vote on blocking transaction inclusion or report fraud proofs, and if they are malicious, they can get slashed. This also enables an additional social layer because currently the status quo is the validators are having the majority stake and any normal user cannot vote on the transaction or state of the ledger.
00:22:55.274 - 00:23:02.594, Speaker B: So yeah, that's about it. And thanks for listening to us.
00:23:02.934 - 00:23:37.544, Speaker A: If you have any questions, we'd be happy to answer. We have like five minutes, we can answer any quick questions. Sorry. Yeah, so the goal is that like science should be able to verify the transaction in something as low end as like your smartphone. So this would be just part, it would be part of like the phantom wallet or any other wallet. And when you send a transaction it will just proceed with the confirmation steps within like, you know, the bounds of like your phone's hardware.
00:23:41.194 - 00:23:42.574, Speaker B: Any other questions?
00:23:51.914 - 00:24:13.284, Speaker A: So the proof generation happens on the full node. So the, let's say fire dancer or the labs client will generate the fraud proof, but the proof is actually verified on your phone or your like web browser. So verification is actually, you know, very lightweight, but generation will require the entire state. So that will happen on the full load.
00:24:18.664 - 00:24:22.680, Speaker B: Sorry, can you repeat that over and.
00:24:22.712 - 00:24:24.484, Speaker A: Beyond just transaction property?
00:24:25.064 - 00:25:03.754, Speaker B: No. So yeah, we, we do like the, currently what we are implementing is simple payment verification. So what it does is any transaction that you send, you can locally verify that it has been voted on by the super majority of the network. And the block that has been voted on the transaction is actually included in this. So yeah, it would be a backend service. So any user doesn't have to manually run it. It can, it can, they just have, will get a notification that the transaction is verified.
00:25:03.754 - 00:25:25.314, Speaker B: Yeah. Did, did that answer your question? Can you repeat the question?
00:25:25.494 - 00:25:26.254, Speaker A: Yeah.
00:25:38.194 - 00:26:05.314, Speaker B: No. So the question is like how many slots do we have to wait until the finalization? So we have the simD active stakewait sIMd. So that will add the stake rates for the epoch into a single account. So that's been, the formal details need to be finalized yet. We are working on it, but basically.
00:26:05.474 - 00:26:43.934, Speaker A: Has like 32 block finality. Right. So you'd have to like, if you want to like make sure that a block is finalized, you have to wait like up to 32 blocks. So it's possible that like the vote for block n is like in, in a block up to the next 32 blocks. No, you only need up to 32 blocks. Yeah.
00:26:47.544 - 00:26:55.184, Speaker B: Right. We are wrapping up. Thanks for listening again and get in touch. We can reach the.
